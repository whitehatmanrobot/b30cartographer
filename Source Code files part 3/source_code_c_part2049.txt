Created = dTCreated;
            rule.DTModified = dTModified;
            return rule;
        }
        /// <summary>
        /// There are no comments for Property RuleID in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(EntityKeyProperty=true, IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public int RuleID
        {
            get
            {
                return this._RuleID;
            }
            set
            {
                this.OnRuleIDChanging(value);
                this.ReportPropertyChanging("RuleID");
                this._RuleID = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("RuleID");
                this.OnRuleIDChanged();
            }
        }
        private int _RuleID;
        partial void OnRuleIDChanging(int value);
        partial void OnRuleIDChanged();
        /// <summary>
        /// There are no comments for Property DTStart in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.DateTime DTStart
        {
            get
            {
                return this._DTStart;
            }
            set
            {
                this.OnDTStartChanging(value);
                this.ReportPropertyChanging("DTStart");
                this._DTStart = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("DTStart");
                this.OnDTStartChanged();
            }
        }
        private global::System.DateTime _DTStart;
        partial void OnDTStartChanging(global::System.DateTime value);
        partial void OnDTStartChanged();
        /// <summary>
        /// There are no comments for Property DTEnd in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.DateTime DTEnd
        {
            get
            {
                return this._DTEnd;
            }
            set
            {
                this.OnDTEndChanging(value);
                this.ReportPropertyChanging("DTEnd");
                this._DTEnd = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("DTEnd");
                this.OnDTEndChanged();
            }
        }
        private global::System.DateTime _DTEnd;
        partial void OnDTEndChanging(global::System.DateTime value);
        partial void OnDTEndChanged();
        /// <summary>
        /// There are no comments for Property Comment in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public string Comment
        {
            get
            {
                return this._Comment;
            }
            set
            {
                this.OnCommentChanging(value);
                this.ReportPropertyChanging("Comment");
                this._Comment = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value, true);
                this.ReportPropertyChanged("Comment");
                this.OnCommentChanged();
            }
        }
        private string _Comment;
        partial void OnCommentChanging(string value);
        partial void OnCommentChanged();
        /// <summary>
        /// There are no comments for Property DTCreated in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.DateTime DTCreated
        {
            get
            {
                return this._DTCreated;
            }
            set
            {
                this.OnDTCreatedChanging(value);
                this.ReportPropertyChanging("DTCreated");
                this._DTCreated = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("DTCreated");
                this.OnDTCreatedChanged();
            }
        }
        private global::System.DateTime _DTCreated;
        partial void OnDTCreatedChanging(global::System.DateTime value);
        partial void OnDTCreatedChanged();
        /// <summary>
        /// There are no comments for Property DTModified in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.DateTime DTModified
        {
            get
            {
                return this._DTModified;
            }
            set
            {
                this.OnDTModifiedChanging(value);
                this.ReportPropertyChanging("DTModified");
                this._DTModified = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("DTModified");
                this.OnDTModifiedChanged();
            }
        }
        private global::System.DateTime _DTModified;
        partial void OnDTModifiedChanging(global::System.DateTime value);
        partial void OnDTModifiedChanged();
        /// <summary>
        /// There are no comments for Action in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RewardsDBModel", "FKAction_Rule_RuleID", "Action")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityCollection<Action> Action
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedCollection<Action>("RewardsDBModel.FKAction_Rule_RuleID", "Action");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedCollection<Action>("RewardsDBModel.FKAction_Rule_RuleID", "Action", value);
                }
            }
        }
        /// <summary>
        /// There are no comments for ActionSetExecutionType in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RewardsDBModel", "FKRule_ActionSetExecutionType_ActionSetExecutionTypeID", "ActionSetExecutionType")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public ActionSetExecutionType ActionSetExecutionType
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<ActionSetExecutionType>("RewardsDBModel.FKRule_ActionSetExecutionType_ActionSetExecutionTypeID", "ActionSetExecutionType").Value;
            }
            set
            {
                ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<ActionSetExecutionType>("RewardsDBModel.FKRule_ActionSetExecutionType_ActionSetExecutionTypeID", "ActionSetExecutionType").Value = value;
            }
        }
        /// <summary>
        /// There are no comments for ActionSetExecutionType in the schema.
        /// </summary>
        [global::System.ComponentModel.BrowsableAttribute(false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityReference<ActionSetExecutionType> ActionSetExecutionTypeReference
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<ActionSetExecutionType>("RewardsDBModel.FKRule_ActionSetExecutionType_ActionSetExecutionTypeID", "ActionSetExecutionType");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedReference<ActionSetExecutionType>("RewardsDBModel.FKRule_ActionSetExecutionType_ActionSetExecutionTypeID", "ActionSetExecutionType", value);
                }
            }
        }
        /// <summary>
        /// There are no comments for GameKeys in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RewardsDBModel", "FKRule_GameKeys_GameKeyID", "GameKeys")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public GameKeys GameKeys
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<GameKeys>("RewardsDBModel.FKRule_GameKeys_GameKeyID", "GameKeys").Value;
            }
            set
            {
                ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<GameKeys>("RewardsDBModel.FKRule_GameKeys_GameKeyID", "GameKeys").Value = value;
            }
        }
        /// <summary>
        /// There are no comments for GameKeys in the schema.
        /// </summary>
        [global::System.ComponentModel.BrowsableAttribute(false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityReference<GameKeys> GameKeysReference
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<GameKeys>("RewardsDBModel.FKRule_GameKeys_GameKeyID", "GameKeys");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedReference<GameKeys>("RewardsDBModel.FKRule_GameKeys_GameKeyID", "GameKeys", value);
                }
            }
        }
        /// <summary>
        /// There are no comments for Reward in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RewardsDBModel", "FK_Rule_Reward_RewardID", "Reward")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public Reward Reward
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<Reward>("RewardsDBModel.FK_Rule_Reward_RewardID", "Reward").Value;
            }
            set
            {
                ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<Reward>("RewardsDBModel.FK_Rule_Reward_RewardID", "Reward").Value = value;
            }
        }
        /// <summary>
        /// There are no comments for Reward in the schema.
        /// </summary>
        [global::System.ComponentModel.BrowsableAttribute(false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityReference<Reward> RewardReference
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<Reward>("RewardsDBModel.FK_Rule_Reward_RewardID", "Reward");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedReference<Reward>("RewardsDBModel.FK_Rule_Reward_RewardID", "Reward", value);
                }
            }
        }
        /// <summary>
        /// There are no comments for RuleExpression in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RewardsDBModel", "FKRuleExpression_Rule_RuleID", "RuleExpression")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityCollection<RuleExpression> RuleExpression
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedCollection<RuleExpression>("RewardsDBModel.FKRuleExpression_Rule_RuleID", "RuleExpression");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedCollection<RuleExpression>("RewardsDBModel.FKRuleExpression_Rule_RuleID", "RuleExpression", value);
                }
            }
        }
    }
    /// <summary>
    /// There are no comments for RewardsDBModel.RuleExpression in the schema.
    /// </summary>
    /// <KeyProperties>
    /// RuleExpressionID
    /// </KeyProperties>
    [global::System.Data.Objects.DataClasses.EdmEntityTypeAttribute(NamespaceName="RewardsDBModel", Name="RuleExpression")]
    [global::System.Runtime.Serialization.DataContractAttribute(IsReference=true)]
    [global::System.Serializable()]
    public partial class RuleExpression : global::System.Data.Objects.DataClasses.EntityObject
    {
        /// <summary>
        /// Create a new RuleExpression object.
        /// </summary>
        /// <param name="ruleExpressionID">Initial value of RuleExpressionID.</param>
        /// <param name="leftOperand">Initial value of LeftOperand.</param>
        /// <param name="rightOperand">Initial value of RightOperand.</param>
        /// <param name="dTCreated">Initial value of DTCreated.</param>
        /// <param name="dTModified">Initial value of DTModified.</param>
        public static RuleExpression CreateRuleExpression(int ruleExpressionID, string leftOperand, string rightOperand, global::System.DateTime dTCreated, global::System.DateTime dTModified)
        {
            RuleExpression ruleExpression = new RuleExpression();
            ruleExpression.RuleExpressionID = ruleExpressionID;
            ruleExpression.LeftOperand = leftOperand;
            ruleExpression.RightOperand = rightOperand;
            ruleExpression.DTCreated = dTCreated;
            ruleExpression.DTModified = dTModified;
            return ruleExpression;
        }
        /// <summary>
        /// There are no comments for Property RuleExpressionID in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(EntityKeyProperty=true, IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public int RuleExpressionID
        {
            get
            {
                return this._RuleExpressionID;
            }
            set
            {
                this.OnRuleExpressionIDChanging(value);
                this.ReportPropertyChanging("RuleExpressionID");
                this._RuleExpressionID = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("RuleExpressionID");
                this.OnRuleExpressionIDChanged();
            }
        }
        private int _RuleExpressionID;
        partial void OnRuleExpressionIDChanging(int value);
        partial void OnRuleExpressionIDChanged();
        /// <summary>
        /// There are no comments for Property LeftOperand in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public string LeftOperand
        {
            get
            {
                return this._LeftOperand;
            }
            set
            {
                this.OnLeftOperandChanging(value);
                this.ReportPropertyChanging("LeftOperand");
                this._LeftOperand = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value, false);
                this.ReportPropertyChanged("LeftOperand");
                this.OnLeftOperandChanged();
            }
        }
        private string _LeftOperand;
        partial void OnLeftOperandChanging(string value);
        partial void OnLeftOperandChanged();
        /// <summary>
        /// There are no comments for Property RightOperand in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public string RightOperand
        {
            get
            {
                return this._RightOperand;
            }
            set
            {
                this.OnRightOperandChanging(value);
                this.ReportPropertyChanging("RightOperand");
                this._RightOperand = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value, false);
                this.ReportPropertyChanged("RightOperand");
                this.OnRightOperandChanged();
            }
        }
        private string _RightOperand;
        partial void OnRightOperandChanging(string value);
        partial void OnRightOperandChanged();
        /// <summary>
        /// There are no comments for Property DTCreated in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.DateTime DTCreated
        {
            get
            {
                return this._DTCreated;
            }
            set
            {
                this.OnDTCreatedChanging(value);
                this.ReportPropertyChanging("DTCreated");
                this._DTCreated = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("DTCreated");
                this.OnDTCreatedChanged();
            }
        }
        private global::System.DateTime _DTCreated;
        partial void OnDTCreatedChanging(global::System.DateTime value);
        partial void OnDTCreatedChanged();
        /// <summary>
        /// There are no comments for Property DTModified in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.DateTime DTModified
        {
            get
            {
                return this._DTModified;
            }
            set
            {
                this.OnDTModifiedChanging(value);
                this.ReportPropertyChanging("DTModified");
                this._DTModified = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("DTModified");
                this.OnDTModifiedChanged();
            }
        }
        private global::System.DateTime _DTModified;
        partial void OnDTModifiedChanging(global::System.DateTime value);
        partial void OnDTModifiedChanged();
        /// <summary>
        /// There are no comments for DataType in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RewardsDBModel", "FKRuleExpression_DataType_DataTypeID", "DataType")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public DataType DataType
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<DataType>("RewardsDBModel.FKRuleExpression_DataType_DataTypeID", "DataType").Value;
            }
            set
            {
                ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<DataType>("RewardsDBModel.FKRuleExpression_DataType_DataTypeID", "DataType").Value = value;
            }
        }
        /// <summary>
        /// There are no comments for DataType in the schema.
        /// </summary>
        [global::System.ComponentModel.BrowsableAttribute(false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityReference<DataType> DataTypeReference
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<DataType>("RewardsDBModel.FKRuleExpression_DataType_DataTypeID", "DataType");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedReference<DataType>("RewardsDBModel.FKRuleExpression_DataType_DataTypeID", "DataType", value);
                }
            }
        }
        /// <summary>
        /// There are no comments for Rule in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RewardsDBModel", "FKRuleExpression_Rule_RuleID", "Rule")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public Rule Rule
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<Rule>("RewardsDBModel.FKRuleExpression_Rule_RuleID", "Rule").Value;
            }
            set
            {
                ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<Rule>("RewardsDBModel.FKRuleExpression_Rule_RuleID", "Rule").Value = value;
            }
        }
        /// <summary>
        /// There are no comments for Rule in the schema.
        /// </summary>
        [global::System.ComponentModel.BrowsableAttribute(false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityReference<Rule> RuleReference
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<Rule>("RewardsDBModel.FKRuleExpression_Rule_RuleID", "Rule");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedReference<Rule>("RewardsDBModel.FKRuleExpression_Rule_RuleID", "Rule", value);
                }
            }
        }
        /// <summary>
        /// There are no comments for RuleOperandType in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RewardsDBModel", "FKRuleExpression_RuleOperandType_LeftRuleOperandTypeID", "RuleOperandType")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public RuleOperandType RuleOperandType
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<RuleOperandType>("RewardsDBModel.FKRuleExpression_RuleOperandType_LeftRuleOperandTypeID", "RuleOperandType").Value;
            }
            set
            {
                ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<RuleOperandType>("RewardsDBModel.FKRuleExpression_RuleOperandType_LeftRuleOperandTypeID", "RuleOperandType").Value = value;
            }
        }
        /// <summary>
        /// There are no comments for RuleOperandType in the schema.
        /// </summary>
        [global::System.ComponentModel.BrowsableAttribute(false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityReference<RuleOperandType> RuleOperandTypeReference
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<RuleOperandType>("RewardsDBModel.FKRuleExpression_RuleOperandType_LeftRuleOperandTypeID", "RuleOperandType");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedReference<RuleOperandType>("RewardsDBModel.FKRuleExpression_RuleOperandType_LeftRuleOperandTypeID", "RuleOperandType", value);
                }
            }
        }
        /// <summary>
        /// There are no comments for RuleOperandType1 in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RewardsDBModel", "FKRuleExpression_RuleOperandType_RightRuleOperandTypeID", "RuleOperandType")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public RuleOperandType RuleOperandType1
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<RuleOperandType>("RewardsDBModel.FKRuleExpression_RuleOperandType_RightRuleOperandTypeID", "RuleOperandType").Value;
            }
            set
            {
                ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<RuleOperandType>("RewardsDBModel.FKRuleExpression_RuleOperandType_RightRuleOperandTypeID", "RuleOperandType").Value = value;
            }
        }
        /// <summary>
        /// There are no comments for RuleOperandType1 in the schema.
        /// </summary>
        [global::System.ComponentModel.BrowsableAttribute(false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityReference<RuleOperandType> RuleOperandType1Reference
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<RuleOperandType>("RewardsDBModel.FKRuleExpression_RuleOperandType_RightRuleOperandTypeID", "RuleOperandType");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedReference<RuleOperandType>("RewardsDBModel.FKRuleExpression_RuleOperandType_RightRuleOperandTypeID", "RuleOperandType", value);
                }
            }
        }
        /// <summary>
        /// There are no comments for RuleOperator in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RewardsDBModel", "FKRuleExpression_RuleOperator_RuleOperatorID", "RuleOperator")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public RuleOperator RuleOperator
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<RuleOperator>("RewardsDBModel.FKRuleExpression_RuleOperator_RuleOperatorID", "RuleOperator").Value;
            }
            set
            {
                ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<RuleOperator>("RewardsDBModel.FKRuleExpression_RuleOperator_RuleOperatorID", "RuleOperator").Value = value;
            }
        }
        /// <summary>
        /// There are no comments for RuleOperator in the schema.
        /// </summary>
        [global::System.ComponentModel.BrowsableAttribute(false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityReference<RuleOperator> RuleOperatorReference
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<RuleOperator>("RewardsDBModel.FKRuleExpression_RuleOperator_RuleOperatorID", "RuleOperator");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedReference<RuleOperator>("RewardsDBModel.FKRuleExpression_RuleOperator_RuleOperatorID", "RuleOperator", value);
                }
            }
        }
    }
    /// <summary>
    /// There are no comments for RewardsDBModel.RuleOperandType in the schema.
    /// </summary>
    /// <KeyProperties>
    /// RuleOperandTypeID
    /// </KeyProperties>
    [global::System.Data.Objects.DataClasses.EdmEntityTypeAttribute(NamespaceName="RewardsDBModel", Name="RuleOperandType")]
    [global::System.Runtime.Serialization.DataContractAttribute(IsReference=true)]
    [global::System.Serializable()]
    public partial class RuleOperandType : global::System.Data.Objects.DataClasses.EntityObject
    {
        /// <summary>
        /// Create a new RuleOperandType object.
        /// </summary>
        /// <param name="ruleOperandTypeID">Initial value of RuleOperandTypeID.</param>
        /// <param name="ruleOperandTypeName">Initial value of RuleOperandTypeName.</param>
        /// <param name="dTCreated">Initial value of DTCreated.</param>
        /// <param name="dTModified">Initial value of DTModified.</param>
        public static RuleOperandType CreateRuleOperandType(int ruleOperandTypeID, string ruleOperandTypeName, global::System.DateTime dTCreated, global::System.DateTime dTModified)
        {
            RuleOperandType ruleOperandType = new RuleOperandType();
            ruleOperandType.RuleOperandTypeID = ruleOperandTypeID;
            ruleOperandType.RuleOperandTypeName = ruleOperandTypeName;
            ruleOperandType.DTCreated = dTCreated;
            ruleOperandType.DTModified = dTModified;
            return ruleOperandType;
        }
        /// <summary>
        /// There are no comments for Property RuleOperandTypeID in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(EntityKeyProperty=true, IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public int RuleOperandTypeID
        {
            get
            {
                return this._RuleOperandTypeID;
            }
            set
            {
                this.OnRuleOperandTypeIDChanging(value);
                this.ReportPropertyChanging("RuleOperandTypeID");
                this._RuleOperandTypeID = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("RuleOperandTypeID");
                this.OnRuleOperandTypeIDChanged();
            }
        }
        private int _RuleOperandTypeID;
        partial void OnRuleOperandTypeIDChanging(int value);
        partial void OnRuleOperandTypeIDChanged();
        /// <summary>
        /// There are no comments for Property RuleOperandTypeName in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public string RuleOperandTypeName
        {
            get
            {
                return this._RuleOperandTypeName;
            }
            set
            {
                this.OnRuleOperandTypeNameChanging(value);
                this.ReportPropertyChanging("RuleOperandTypeName");
                this._RuleOperandTypeName = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value, false);
                this.ReportPropertyChanged("RuleOperandTypeName");
                this.OnRuleOperandTypeNameChanged();
            }
        }
        private string _RuleOperandTypeName;
        partial void OnRuleOperandTypeNameChanging(string value);
        partial void OnRuleOperandTypeNameChanged();
        /// <summary>
        /// There are no comments for Property DTCreated in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.DateTime DTCreated
        {
            get
            {
                return this._DTCreated;
            }
            set
            {
                this.OnDTCreatedChanging(value);
                this.ReportPropertyChanging("DTCreated");
                this._DTCreated = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("DTCreated");
                this.OnDTCreatedChanged();
            }
        }
        private global::System.DateTime _DTCreated;
        partial void OnDTCreatedChanging(global::System.DateTime value);
        partial void OnDTCreatedChanged();
        /// <summary>
        /// There are no comments for Property DTModified in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.DateTime DTModified
        {
            get
            {
                return this._DTModified;
            }
            set
            {
                this.OnDTModifiedChanging(value);
                this.ReportPropertyChanging("DTModified");
                this._DTModified = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("DTModified");
                this.OnDTModifiedChanged();
            }
        }
        private global::System.DateTime _DTModified;
        partial void OnDTModifiedChanging(global::System.DateTime value);
        partial void OnDTModifiedChanged();
        /// <summary>
        /// There are no comments for RuleExpression in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RewardsDBModel", "FKRuleExpression_RuleOperandType_LeftRuleOperandTypeID", "RuleExpression")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityCollection<RuleExpression> RuleExpression
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedCollection<RuleExpression>("RewardsDBModel.FKRuleExpression_RuleOperandType_LeftRuleOperandTypeID", "RuleExpression");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedCollection<RuleExpression>("RewardsDBModel.FKRuleExpression_RuleOperandType_LeftRuleOperandTypeID", "RuleExpression", value);
                }
            }
        }
        /// <summary>
        /// There are no comments for RuleExpression1 in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RewardsDBModel", "FKRuleExpression_RuleOperandType_RightRuleOperandTypeID", "RuleExpression")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityCollection<RuleExpression> RuleExpression1
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedCollection<RuleExpression>("RewardsDBModel.FKRuleExpression_RuleOperandType_RightRuleOperandTypeID", "RuleExpression");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedCollection<RuleExpression>("RewardsDBModel.FKRuleExpression_RuleOperandType_RightRuleOperandTypeID", "RuleExpression", value);
                }
            }
        }
    }
    /// <summary>
    /// There are no comments for RewardsDBModel.RuleOperator in the schema.
    /// </summary>
    /// <KeyProperties>
    /// RuleOperatorID
    /// </KeyProperties>
    [global::System.Data.Objects.DataClasses.EdmEntityTypeAttribute(NamespaceName="RewardsDBModel", Name="RuleOperator")]
    [global::System.Runtime.Serialization.DataContractAttribute(IsReference=true)]
    [global::System.Serializable()]
    public partial class RuleOperator : global::System.Data.Objects.DataClasses.EntityObject
    {
        /// <summary>
        /// Create a new RuleOperator object.
        /// </summary>
        /// <param name="ruleOperatorID">Initial value of RuleOperatorID.</param>
        /// <param name="operator">Initial value of Operator.</param>
        /// <param name="symbol">Initial value of Symbol.</param>
        /// <param name="dTCreated">Initial value of DTCreated.</param>
        /// <param name="dTModified">Initial value of DTModified.</param>
        public static RuleOperator CreateRuleOperator(int ruleOperatorID, string @operator, string symbol, global::System.DateTime dTCreated, global::System.DateTime dTModified)
        {
            RuleOperator ruleOperator = new RuleOperator();
            ruleOperator.RuleOperatorID = ruleOperatorID;
            ruleOperator.Operator = @operator;
            ruleOperator.Symbol = symbol;
            ruleOperator.DTCreated = dTCreated;
            ruleOperator.DTModified = dTModified;
            return ruleOperator;
        }
        /// <summary>
        /// There are no comments for Property RuleOperatorID in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(EntityKeyProperty=true, IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public int RuleOperatorID
        {
            get
            {
                return this._RuleOperatorID;
            }
            set
            {
                this.OnRuleOperatorIDChanging(value);
                this.ReportPropertyChanging("RuleOperatorID");
                this._RuleOperatorID = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("RuleOperatorID");
                this.OnRuleOperatorIDChanged();
            }
        }
        private int _RuleOperatorID;
        partial void OnRuleOperatorIDChanging(int value);
        partial void OnRuleOperatorIDChanged();
        /// <summary>
        /// There are no comments for Property Operator in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public string Operator
        {
            get
            {
                return this._Operator;
            }
            set
            {
                this.OnOperatorChanging(value);
                this.ReportPropertyChanging("Operator");
                this._Operator = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value, false);
                this.ReportPropertyChanged("Operator");
                this.OnOperatorChanged();
            }
        }
        private string _Operator;
        partial void OnOperatorChanging(string value);
        partial void OnOperatorChanged();
        /// <summary>
        /// There are no comments for Property Symbol in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public string Symbol
        {
            get
            {
                return this._Symbol;
            }
            set
            {
                this.OnSymbolChanging(value);
                this.ReportPropertyChanging("Symbol");
                this._Symbol = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value, false);
                this.ReportPropertyChanged("Symbol");
                this.OnSymbolChanged();
            }
        }
        private string _Symbol;
        partial void OnSymbolChanging(string value);
        partial void OnSymbolChanged();
        /// <summary>
        /// There are no comments for Property DTCreated in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.DateTime DTCreated
        {
            get
            {
                return this._DTCreated;
            }
            set
            {
                this.OnDTCreatedChanging(value);
                this.ReportPropertyChanging("DTCreated");
                this._DTCreated = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("DTCreated");
                this.OnDTCreatedChanged();
            }
        }
        private global::System.DateTime _DTCreated;
        partial void OnDTCreatedChanging(global::System.DateTime value);
        partial void OnDTCreatedChanged();
        /// <summary>
        /// There are no comments for Property DTModified in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.DateTime DTModified
        {
            get
            {
                return this._DTModified;
            }
            set
            {
                this.OnDTModifiedChanging(value);
                this.ReportPropertyChanging("DTModified");
                this._DTModified = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("DTModified");
                this.OnDTModifiedChanged();
            }
        }
        private global::System.DateTime _DTModified;
        partial void OnDTModifiedChanging(global::System.DateTime value);
        partial void OnDTModifiedChanged();
        /// <summary>
        /// There are no comments for RuleExpression in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RewardsDBModel", "FKRuleExpression_RuleOperator_RuleOperatorID", "RuleExpression")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityCollection<RuleExpression> RuleExpression
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedCollection<RuleExpression>("RewardsDBModel.FKRuleExpression_RuleOperator_RuleOperatorID", "RuleExpression");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedCollection<RuleExpression>("RewardsDBModel.FKRuleExpression_RuleOperator_RuleOperatorID", "RuleExpression", value);
                }
            }
        }
    }
    /// <summary>
    /// There are no comments for RewardsDBModel.StatDescription in the schema.
    /// </summary>
    /// <KeyProperties>
    /// StatDescriptionID
    /// </KeyProperties>
    [global::System.Data.Objects.DataClasses.EdmEntityTypeAttribute(NamespaceName="RewardsDBModel", Name="StatDescription")]
    [global::System.Runtime.Serialization.DataContractAttribute(IsReference=true)]
    [global::System.Serializable()]
    public partial class StatDescription : global::System.Data.Objects.DataClasses.EntityObject
    {
        /// <summary>
        /// Create a new StatDescription object.
        /// </summary>
        /// <param name="statDescriptionID">Initial value of StatDescriptionID.</param>
        /// <param name="name">Initial value of Name.</param>
        /// <param name="dTModified">Initial value of DTModified.</param>
        public static StatDescription CreateStatDescription(int statDescriptionID, string name, global::System.DateTime dTModified)
        {
            StatDescription statDescription = new StatDescription();
            statDescription.StatDescriptionID = statDescriptionID;
            statDescription.Name = name;
            statDescription.DTModified = dTModified;
            return statDescription;
        }
        /// <summary>
        /// There are no comments for Property StatDescriptionID in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(EntityKeyProperty=true, IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public int StatDescriptionID
        {
            get
            {
                return this._StatDescriptionID;
            }
            set
            {
                this.OnStatDescriptionIDChanging(value);
                this.ReportPropertyChanging("StatDescriptionID");
                this._StatDescriptionID = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("StatDescriptionID");
                this.OnStatDescriptionIDChanged();
            }
        }
        private int _StatDescriptionID;
        partial void OnStatDescriptionIDChanging(int value);
        partial void OnStatDescriptionIDChanged();
        /// <summary>
        /// There are no comments for Property Name in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public string Name
        {
            get
            {
                return this._Name;
            }
            set
            {
                this.OnNameChanging(value);
                this.ReportPropertyChanging("Name");
                this._Name = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value, false);
                this.ReportPropertyChanged("Name");
                this.OnNameChanged();
            }
        }
        private string _Name;
        partial void OnNameChanging(string value);
        partial void OnNameChanged();
        /// <summary>
        /// There are no comments for Property Comment in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public string Comment
        {
            get
            {
                return this._Comment;
            }
            set
            {
                this.OnCommentChanging(value);
                this.ReportPropertyChanging("Comment");
                this._Comment = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value, true);
                this.ReportPropertyChanged("Comment");
                this.OnCommentChanged();
            }
        }
        private string _Comment;
        partial void OnCommentChanging(string value);
        partial void OnCommentChanged();
        /// <summary>
        /// There are no comments for Property DTModified in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.DateTime DTModified
        {
            get
            {
                return this._DTModified;
            }
            set
            {
                this.OnDTModifiedChanging(value);
                this.ReportPropertyChanging("DTModified");
                this._DTModified = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("DTModified");
                this.OnDTModifiedChanged();
            }
        }
        private global::System.DateTime _DTModified;
        partial void OnDTModifiedChanging(global::System.DateTime value);
        partial void OnDTModifiedChanged();
        /// <summary>
        /// There are no comments for DataType in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RewardsDBModel", "FKStatDescription_DataType_DataTypeID", "DataType")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public DataType DataType
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<DataType>("RewardsDBModel.FKStatDescription_DataType_DataTypeID", "DataType").Value;
            }
            set
            {
                ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<DataType>("RewardsDBModel.FKStatDescription_DataType_DataTypeID", "DataType").Value = value;
            }
        }
        /// <summary>
        /// There are no comments for DataType in the schema.
        /// </summary>
        [global::System.ComponentModel.BrowsableAttribute(false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityReference<DataType> DataTypeReference
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<DataType>("RewardsDBModel.FKStatDescription_DataType_DataTypeID", "DataType");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedReference<DataType>("RewardsDBModel.FKStatDescription_DataType_DataTypeID", "DataType", value);
                }
            }
        }
        /// <summary>
        /// There are no comments for GameKeys in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RewardsDBModel", "FKStatDescription_GameKeys_GameKeyID", "GameKeys")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public GameKeys GameKeys
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<GameKeys>("RewardsDBModel.FKStatDescription_GameKeys_GameKeyID", "GameKeys").Value;
            }
            set
            {
                ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<GameKeys>("RewardsDBModel.FKStatDescription_GameKeys_GameKeyID", "GameKeys").Value = value;
            }
        }
        /// <summary>
        /// There are no comments for GameKeys in the schema.
        /// </summary>
        [global::System.ComponentModel.BrowsableAttribute(false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityReference<GameKeys> GameKeysReference
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<GameKeys>("RewardsDBModel.FKStatDescription_GameKeys_GameKeyID", "GameKeys");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedReference<GameKeys>("RewardsDBModel.FKStatDescription_GameKeys_GameKeyID", "GameKeys", value);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\RulesBadgeAuthoring\CreateBadgeEditPage.xaml.cs ===
namespace RulesBadgeAuthoring
{
    using System;
    using System.Linq;
    using System.Windows;
    using System.Windows.Controls;
    using RulesBadgeAuthoring.Model;
    using RulesBadgeAuthoring.RewardsDataService;
    using RulesBadgeAuthoring.View;
    using Action = RulesBadgeAuthoring.RewardsDataService.Action;

    public partial class CreateBadgeEditPage : UserControl, IActionEditPage
    {
        private const string StorePathFormatString = "/Store/User[ID='/Event/LivePuid']/Game[ID='/Event/GameKey']/{0}";
        private const string PropertyPathFormatString = "/Event/Property[{0}]";

        public ActionEditPopup ActionEditPopup { get; set; }
        public event EventHandler<EventArgs> OnCreateOrUpdateable;

        private Action Action { get; set; }
        private bool IsCreated { get; set; }
        private bool DontUpdateTextBoxes { get; set; }

        public CreateBadgeEditPage()
        {
            InitializeComponent();

            this.InitializeEvents();
            this.Loaded += new RoutedEventHandler(CreateBadgeEditPage_Loaded);
        }

        private void InitializeEvents()
        {
            this.BadgeSelector.SelectionChanged += new SelectionChangedEventHandler(BadgeIDSelector_SelectionChanged);
        }

        void CreateBadgeEditPage_Loaded(object sender, RoutedEventArgs e)
        {
        }

        void BadgeIDSelector_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            if (this.Visibility == Visibility.Visible)
            {
                if (!this.DontUpdateTextBoxes)
                {
                    this.BadgeIDParamEditBox.Text = (this.BadgeSelector.SelectedItem as Reward).RewardID.ToString();
                    this.OnCreateOrUpdateable(this.IsCreateable, null);
                }
            }
        }

        public Action ConstructActionFromPage()
        {
            Action action = this.Action;

            if (action.IsCreated && action.ActionParameterList.Count == 0)
            {
                ActionParameter userParam = this.ConstructUserParam();
                action.CreateParameter(userParam);

                ActionParameter BadgeIDParam = this.ConstructBadgeIDParam();
                action.CreateParameter(BadgeIDParam);
            }
            else
            {
                ActionParameter param;

                // USer Is has path
                param = this.GetUserParamFromAction();
                param.Path = this.UserParamEditBox.Text;
                param.IsModified = true;

                // badgeID has only Values
                param = this.GetBadgeIDParamFromAction();
                param.Value = this.BadgeIDParamEditBox.Text;
                param.IsModified = true;

                action.IsModified = true;
            }

            return action;
        }

        private ActionParameter ConstructUserParam()
        {
            ActionParameter userParam = new ActionParameter()
            {
                ActionParameterDefinition = this.FetchActionParameterDefinition(this.ActionEditPopup.ActionTypeSelectionCmbBx.SelectedItem as ActionDefinition, "User"),
                Path = this.UserParamEditBox.Text,
                Value = string.Empty,
                IsCreated = true,
                IsModified = true
            };

            return userParam;
        }

        private ActionParameter ConstructBadgeIDParam()
        {
            ActionParameter BadgeIDParam = new ActionParameter()
            {
                ActionParameterDefinition = this.FetchActionParameterDefinition(this.ActionEditPopup.ActionTypeSelectionCmbBx.SelectedItem as ActionDefinition, "BadgeID"),
                Value = this.BadgeIDParamEditBox.Text,
                Path = string.Empty,
                IsCreated = true,
                IsModified = true
            };

            return BadgeIDParam;
        }

        private ActionParameterDefinition FetchActionParameterDefinition(ActionDefinition definition, string paramName)
        {
            var paramDefinition = from parDef in definition.ActionParameterDefinition
                                  where parDef.Name.Equals(paramName)
                                  select parDef;

            return paramDefinition.First<ActionParameterDefinition>();
        }

        public bool IsCreateable
        {
            get
            {
                if (this.DataContext != null)
                {
                    return this.CheckIfModified();
                }

                return true;
            }
        }

        private bool CheckIfModified()
        {
            if (!this.UserParamEditBox.Text.Equals(this.GetUserParamFromAction().Path))
            {
                return true;
            }

            if (!this.BadgeIDParamEditBox.Text.Equals(this.GetBadgeIDParamFromAction().Value))
            {
                return true;
            }

            return false;
        }

        private void PopulateBadgeList()
        {
            try
            {
                // BUGBUG: investigate why there is an event subscription dangling.
                this.BadgeSelector.SelectionChanged -= BadgeIDSelector_SelectionChanged;
                this.BadgeSelector.SelectionChanged -= BadgeIDSelector_SelectionChanged; 
                this.BadgeSelector.UpdateLayout();

                // drain combobox
                while (this.BadgeSelector.Items.Count > 0)
                {
                    this.BadgeSelector.Items.RemoveAt(0);
                }

                this.BadgeSelector.UpdateLayout();

                //
                // select the list of rewards for this game.
                var rewardList = from reward in RewardManager.RewardList
                                 select reward;

                // set Reward List
                foreach (Reward reward in rewardList)
                {
                    this.BadgeSelector.Items.Add(reward);
                }

                this.BadgeSelector.UpdateLayout();
            }
            finally
            {
                this.BadgeSelector.SelectionChanged += new SelectionChangedEventHandler(BadgeIDSelector_SelectionChanged);
            }

            if (this.Action.IsCreated)
            {
                if (this.BadgeSelector.SelectedIndex != 0)
                {
                    this.BadgeSelector.SelectedIndex = 0;
                }
            }
            else
            {
                if (this.BadgeSelector.SelectedItem != this.GetBadgeFromAction())
                {
                    this.BadgeSelector.SelectedItem = this.GetBadgeFromAction();
                }
            }
        }

        private ActionParameter GetUserParamFromAction()
        {
            ActionParameter paramUser = (from par in this.Action.ActionParameterList
                                         where par.ActionParameterDefinition.Name.Equals("User")
                                         select par).First<ActionParameter>();
            return paramUser;
        }

        private ActionParameter GetBadgeIDParamFromAction()
        {
            ActionParameter paramBadgeID = (from par in this.Action.ActionParameterList
                                            where par.ActionParameterDefinition.Name.Equals("BadgeID")
                                            select par).First<ActionParameter>();
            return paramBadgeID;
        }

        public Reward GetBadgeFromAction()
        {
            ActionParameter badgeParam = this.GetBadgeIDParamFromAction();

            int badgeID = int.Parse(badgeParam.Value);

            var badge = (from reward in RewardManager.RewardList
                         where reward.RewardID == badgeID
                         select reward).First<Reward>();
            return badge;
        }

        void Action_OnInitializeComplete(object sender, EventArgs e)
        {
            this.Action.OnInitializeComplete -= Action_OnInitializeComplete;

            if (RewardManager.RewardList == null)
            {
                RewardManager.RewardList = new RewardCollection(RewardManager.ServiceContext);
            }

            if (RewardManager.RewardList.Count == 0)
            {
                this.InitializationProgress.Show();
                RewardManager.RewardList.LoadComplete += new EventHandler(RewardList_LoadComplete);
                RewardManager.RewardList.LoadAsync();
            }
            else
            {
                RewardList_LoadComplete(null, null);
            }
        }

        void RewardList_LoadComplete(object sender, EventArgs e)
        {
            bool shouldUpdateTextBoxes = true;

            this.InitializationProgress.Close();
            RewardManager.RewardList.LoadComplete -= RewardList_LoadComplete;

            if (!this.IsCreated && this.Action.HasInitialized)
            {
                shouldUpdateTextBoxes = false;

                this.UserParamEditBox.Text = this.GetUserParamFromAction().Path;
                this.BadgeIDParamEditBox.Text = this.GetBadgeIDParamFromAction().Value;
            }

            try
            {
                if (!shouldUpdateTextBoxes)
                {
                    this.DontUpdateTextBoxes = true;
                }

                this.PopulateBadgeList();
            }
            finally
            {
                if (!shouldUpdateTextBoxes)
                {
                    this.DontUpdateTextBoxes = false;
                }
            }
        }

        public void Show(Object dataContext)
        {
            this.DataContext = dataContext;
            this.Visibility = Visibility.Visible;

            this.Action = this.DataContext as Action;
            if (this.Action == null)
            {
                this.IsCreated = true;
                this.Action = new Action();
                this.Action.DTModified = DateTime.UtcNow;
                this.Action.IsCreated = true;
                this.Action.ActionDefinition = (this.ActionEditPopup.ActionTypeSelectionCmbBx.SelectedItem as ActionDefinition);
                this.Action.ExecuteOrder = this.ActionEditPopup.RuleEditPage.Rule.ActionList.Count;
            }
            else
            {
                // this must be a CreateBadgeAction
                if (!this.Action.ActionDefinition.Name.Equals("CreateBadge"))
                {
                    throw new InvalidOperationException();
                }

                if (this.Action.ActionParameterList.Count != 2)
                {
                    throw new InvalidOperationException();
                }
            }

            this.Action.OnInitializeComplete += new EventHandler<EventArgs>(Action_OnInitializeComplete);
            this.Action.BeginInitialize();
        }

        public void Close(Object dataContext)
        {
            this.Visibility = Visibility.Collapsed;
            this.DataContext = dataContext;
            this.IsCreated = false;
            this.Action = dataContext as Action;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\RulesBadgeAuthoring\LoadingProgressPopup.xaml.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Animation;
using System.Windows.Shapes;

namespace RulesBadgeAuthoring
{
    public partial class LoadingProgressPopup : UserControl
    {
        public LoadingProgressPopup()
        {
            InitializeComponent();
            this.Loaded += new RoutedEventHandler(LoadingProgressPopup_Loaded);
        }

        void LoadingProgressPopup_Loaded(object sender, RoutedEventArgs e)
        {
            theBack.Width = App.Current.Host.Content.ActualWidth;
            theBack.Height = App.Current.Host.Content.ActualHeight;

            App.Current.Host.Content.Resized += (s, f) =>
            {
                theBack.Width = App.Current.Host.Content.ActualWidth;
                theBack.Height = App.Current.Host.Content.ActualHeight;
            };
        }

        public void Show()
        {
            popMessage.IsOpen = true;
            this.Visibility = Visibility.Visible;
        }

        public void Close()
        {
            popMessage.IsOpen = false;
            this.Visibility = Visibility.Collapsed;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\RulesBadgeAuthoring\RuleListPage.xaml.cs ===
namespace RulesBadgeAuthoring
{
    using System;
    using System.Linq;
    using System.Windows;
    using System.Windows.Controls;
    using RulesBadgeAuthoring.Model;
    using RulesBadgeAuthoring.RewardsDataService;

    internal enum PopulationEnum
    {
        RuleListLoading = 1,
        ActionListLoading,
        Complete
    }

    public partial class RuleListPage : UserControl
    {
        private DoubleClickManager DoubleClickManager { get; set; }

        public RuleListPage()
        {
            InitializeComponent();
            this.Loaded += new RoutedEventHandler(RuleListPage_Loaded);
            this.CreateRuleButton.Click += new RoutedEventHandler(CreateRuleButton_Click);
            this.dgRule.SelectionChanged += new SelectionChangedEventHandler(dgRule_SelectionChanged);
            this.dgRule.LoadingRow += new EventHandler<DataGridRowEventArgs>(dgRule_LoadingRow);


            this.DoubleClickManager = new DoubleClickManager(500);
            this.DoubleClickManager.DoubleClick += new EventHandler<System.Windows.Input.MouseButtonEventArgs>(DoubleClickManager_DoubleClick);
        }

        public event EventHandler<EventArgs> OnPopulationComplete;

        void RuleListPage_Loaded(object sender, RoutedEventArgs e)
        {
        }

        void dgRule_LoadingRow(object sender, DataGridRowEventArgs e)
        {
            e.Row.MouseLeftButtonUp += this.DoubleClickManager.HandleClick;
        }

        void dgRule_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            DebugTextLogger.Log("Selection Changed");
        }

        void CreateRuleButton_Click(object sender, RoutedEventArgs e)
        {
            myPopup.DataContext = null;
            myPopup.Show();
        }
        
        void DoubleClickManager_DoubleClick(object sender, System.Windows.Input.MouseButtonEventArgs e)
        {
            DebugTextLogger.Log("Dbl Clicked");
            myPopup.DataContext = this.dgRule.SelectedItem as Rule;
            myPopup.Show();

        }
        void RuleList_SaveComplete(object sender, SaveDataEventArgs e)
        {
            throw new NotImplementedException();
        }

        void RuleList_LoadComplete(object sender, EventArgs e)
        {
            if (RewardManager.RuleList.Count > 0)
            {
                this.dgRule.ScrollIntoView(RewardManager.RuleList[0], this.dgRule.Columns[0]);
            }

            this.OnPopulationComplete(null, null);
        }

        internal void Populate()
        {
            // Make sure the DataGrid is using the RuleList as its DataContext:

            this.dgRule.DataContext = RewardManager.RuleList;

            RewardManager.RuleList.LoadComplete += new EventHandler(RuleList_LoadComplete);
            RewardManager.RuleList.SaveComplete += new EventHandler<SaveDataEventArgs>(RuleList_SaveComplete);

            RewardManager.RuleList.LoadAsync();
        }

        private void DeleteRuleButton(object sender, RoutedEventArgs e)
        {
            Button btn = sender as Button;
            int selectedItemID = Convert.ToInt32(btn.Tag.ToString());

            var ruleToDelete = (from rule in RewardManager.RuleList
                                where rule.RuleID == selectedItemID
                                select rule).First<Rule>();
            if (ruleToDelete != null)
            {
                this.DisableButtons();
                RewardManager.RuleList.Remove(ruleToDelete);

                if (!ruleToDelete.HasInitialized)
                {
                    ruleToDelete.OnInitializationComplete += new EventHandler<EventArgs>(DeleteRuleToDelete_OnInitializationComplete);
                    ruleToDelete.BeginFullInitialize();
                }
                else
                {
                    DeleteRuleToDelete_OnInitializationComplete(ruleToDelete, null);
                }


                DebugTextLogger.Log("Item ID={0} and dgIndex={1}", selectedItemID, ruleToDelete.RuleID);
            }
        }

        void DeleteRuleToDelete_OnInitializationComplete(object sender, EventArgs e)
        {
            Rule ruleToDelete = sender as Rule;

            ruleToDelete.IsDeleted = true;
            ruleToDelete.Commit();

            RewardManager.SaveComplete += new EventHandler<SaveDataEventArgs>(RewardManager_SaveComplete);
            RewardManager.SaveAsync();
        }

        void RewardManager_SaveComplete(object sender, SaveDataEventArgs e)
        {
            try
            {
                RewardManager.SaveComplete -= RewardManager_SaveComplete;
                DebugTextLogger.Log("operation completed w/ {0}", e.Succeeded);
            }
            finally
            {
                this.EnableButtons();
            }
        }

        private void DisableButtons()
        {
            this.CreateRuleButton.IsEnabled = false;
        }

        private void EnableButtons()
        {
            this.CreateRuleButton.IsEnabled = true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\RulesBadgeAuthoring\RewardListPage.xaml.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Animation;
using System.Windows.Shapes;

namespace RulesBadgeAuthoring
{
    using System;
    using System.Windows.Browser;
    using System.Windows.Controls;
    using System.Linq;
    using RewardsDataService;
    using System.Data.Services.Client;
    using System.Windows;
    using RulesBadgeAuthoring.Model;

    public partial class RewardListPage : UserControl
    {
        public RewardsDBEntities ServiceContext { get; private set; }

        private DoubleClickManager DoubleClickManager { get; set; }

        public RewardListPage()
        {
            InitializeComponent();

            Loaded += new System.Windows.RoutedEventHandler(Page_Loaded);
            CreateRewardButton.Click += new RoutedEventHandler(CreateRewardButton_Click);
            dg.SelectionChanged += new SelectionChangedEventHandler(dg_SelectionChanged);
            dg.LoadingRow += new EventHandler<DataGridRowEventArgs>(dg_LoadingRow);

            this.DoubleClickManager = new DoubleClickManager(500);
            this.DoubleClickManager.DoubleClick += new EventHandler<System.Windows.Input.MouseButtonEventArgs>(DoubleClickManager_DoubleClick);

            this.myPopup.PopupClose += new EventHandler<EventArgs>(myPopup_PopupClose);
        }

        void myPopup_PopupClose(object sender, EventArgs e)
        {
            if (this.Visibility == Visibility.Visible)
            {
                RewardManager.RewardList.Clear();
                RewardManager.RewardList.LoadAsync();
            }
        }


        void Page_Loaded(object sender, System.Windows.RoutedEventArgs e)
        {
            using (DebugTextLogger.EnterFunction("RewardListPage::Page"))
            {
                try
                {
                    if (RewardManager.RewardList == null)
                    {
                        RewardManager.RewardList = new RewardCollection(RewardManager.ServiceContext);
                        this.dg.DataContext = RewardManager.RewardList;
                        this.dg.Columns.Insert(0, this.Resources["dtc"] as DataGridTemplateColumn);

                        RewardManager.RewardList.LoadComplete += new EventHandler(RewardList_LoadComplete);
                        RewardManager.RewardList.LoadAsync();
                    }
                }
                catch (Exception ex)
                {
                    DebugTextLogger.Log(ex.ToString());
                }
            }
        }

        void RewardList_LoadComplete(object sender, EventArgs e)
        {
            // TODO: scroll into view.
            if (RewardManager.RewardList.Count > 0)
            {
                dg.ScrollIntoView(RewardManager.RewardList[0], dg.Columns[0]);
            }
        }

        void dg_LoadingRow(object sender, DataGridRowEventArgs e)
        {
            e.Row.MouseLeftButtonUp += this.DoubleClickManager.HandleClick;
        }

        void DoubleClickManager_DoubleClick(object sender, System.Windows.Input.MouseButtonEventArgs e)
        {
            DebugTextLogger.Log("Dbl Clicked");
            myPopup.DataContext = dg.SelectedItem as Reward;
            myPopup.Show();
        }

        void dg_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            DebugTextLogger.Log("Selection Changed");
        }

        void CreateRewardButton_Click(object sender, System.Windows.RoutedEventArgs e)
        {
            myPopup.DataContext = null;
            myPopup.Show();
        }

        private void Button_Click(object sender, RoutedEventArgs e)
        {
            Button btn = sender as Button;
            int selectedItemID = Convert.ToInt32(btn.Tag.ToString());
            
            foreach(Object obj in this.dg.ItemsSource)
            {
                Reward rwd = obj as Reward;
                if (rwd.RewardID == selectedItemID)
                {
                    this.dg.SelectedItem = obj;
                    break;
                }
            }

            DebugTextLogger.Log("Item ID={0} and dgIndex={1}", selectedItemID, this.dg.SelectedIndex);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\RulesBadgeAuthoring\Page.xaml.cs ===
namespace RulesBadgeAuthoring
{
    using System;
    using System.Windows.Browser;
    using System.Windows.Controls;
    using System.Linq;
    using RewardsDataService;
    using System.Data.Services.Client;
    using System.Windows;
    using RulesBadgeAuthoring.Model;

    public partial class Page : UserControl
    {

        public Page()
        {
            InitializeComponent();


            SilverlightAsyncHelper.Initialize();
            DebugTextLogger.Initialize(this.DebugTextBox, this.DebugTextScroller);

            App.Current.Host.Content.Resized += (s, f) =>
            {
                this.Width = App.Current.Host.Content.ActualWidth;
                this.Height = App.Current.Host.Content.ActualHeight;
            };

            Loaded += new System.Windows.RoutedEventHandler(Page_Loaded);

            using (DebugTextLogger.EnterFunction("Page::Page"))
            {
                try
                {
                    //RewardManager.InitializeConstants();
                }
                catch (Exception ex)
                {
                    DebugTextLogger.Log(ex.ToString());
                }
            }
        }

        void Page_Loaded(object sender, System.Windows.RoutedEventArgs e)
        {
            using (DebugTextLogger.EnterFunction("Page::Page"))
            {
                try
                {
                    this.MyTabCotrol.IsEnabled = false;
                    this.InitializationProgress.Show();

                    RewardManager.OnInitializeComplete += new EventHandler<EventArgs>(RewardManager_InitializeComplete);
                    RewardManager.BeginInitializeConstants();

                    this.Width = App.Current.Host.Content.ActualWidth;
                    this.Height = App.Current.Host.Content.ActualHeight;

                }
                catch (Exception ex)
                {
                    DebugTextLogger.Log(ex.ToString());
                }
            }
        }

        void RewardManager_InitializeComplete(object sender, EventArgs e)
        {
            RewardManager.OnInitializeComplete -= RewardManager_InitializeComplete;
            this.RuleListPage.OnPopulationComplete += new EventHandler<EventArgs>(RuleListPage_OnPopulationComplete);
            this.RuleListPage.Populate();
        }

        void RuleListPage_OnPopulationComplete(object sender, EventArgs e)
        {
            this.RuleListPage.OnPopulationComplete -= RuleListPage_OnPopulationComplete;
            this.MyTabCotrol.IsEnabled = true;
            this.InitializationProgress.Close();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\RulesBadgeAuthoring\GlobalSuppressions.cs ===
// This file is used by Code Analysis to maintain SuppressMessage 
// attributes that are applied to this project. 
// Project-level suppressions either have no target or are given 
// a specific target and scoped to a namespace, type, member, etc. 
//
// To add a suppression to this file, right-click the message in the 
// Error List, point to "Suppress Message(s)", and click 
// "In Project Suppression File". 
// You do not need to add suppressions to this file manually. 

[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "ID", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.RuleExpression.#RuleExpressionID")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "ID", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.RuleOperandType.#CreateRuleOperandType(System.Int32,System.String,System.DateTime,System.DateTime)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "d", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.RuleOperandType.#CreateRuleOperandType(System.Int32,System.String,System.DateTime,System.DateTime)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.RuleOperandType.#RuleExpression")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.RuleOperandType.#RuleExpression1")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "ID", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.RuleOperandType.#RuleOperandTypeID")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "ID", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.RuleOperator.#CreateRuleOperator(System.Int32,System.String,System.String,System.DateTime,System.DateTime)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "d", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.RuleOperator.#CreateRuleOperator(System.Int32,System.String,System.String,System.DateTime,System.DateTime)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.RuleOperator.#RuleExpression")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "ID", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.RuleOperator.#RuleOperatorID")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "ID", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.StatDescription.#CreateStatDescription(System.Int32,System.String,System.DateTime)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "d", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.StatDescription.#CreateStatDescription(System.Int32,System.String,System.DateTime)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "ID", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.StatDescription.#StatDescriptionID")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "d", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.Reward.#CreateReward(System.Int32,System.DateTime,System.DateTime,System.DateTime,System.DateTime)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "ID", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.Reward.#CreateReward(System.Int32,System.DateTime,System.DateTime,System.DateTime,System.DateTime)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly", MessageId = "TEnd", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.Reward.#CreateReward(System.Int32,System.DateTime,System.DateTime,System.DateTime,System.DateTime)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "ID", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.Platforms.#PlatformID")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.Platforms.#GameKeys")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "d", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.Platforms.#CreatePlatforms(System.Int32,System.String,System.DateTime)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "ID", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.Platforms.#CreatePlatforms(System.Int32,System.String,System.DateTime)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.Locale.#RewardLocale")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "LCID", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.Locale.#LCID")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "l", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.Locale.#CreateLocale(System.Int32,System.String,System.String,System.DateTime)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "d", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.Locale.#CreateLocale(System.Int32,System.String,System.String,System.DateTime)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "CID", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.Locale.#CreateLocale(System.Int32,System.String,System.String,System.DateTime)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "ID", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.GameSchemaProperties.#GameSchemaPropertyID")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "d", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.GameSchemaProperties.#CreateGameSchemaProperties(System.Int32,System.String,System.Int32,System.Boolean,System.DateTime)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "ID", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.GameSchemaProperties.#CreateGameSchemaProperties(System.Int32,System.String,System.Int32,System.Boolean,System.DateTime)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.GameSchemaNames.#GameSchemaProperties")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "ID", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.GameSchemaNames.#GameSchemaNameID")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "d", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.GameSchemaNames.#CreateGameSchemaNames(System.Int32,System.String,System.Boolean,System.DateTime)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "ID", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.GameSchemaNames.#CreateGameSchemaNames(System.Int32,System.String,System.Boolean,System.DateTime)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.GameKeys.#StatDescription")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.GameKeys.#Rule")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.GameKeys.#Reward")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.GameKeys.#GameSchemaNames")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "ID", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.GameKeys.#GameKeyID")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "d", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.GameKeys.#CreateGameKeys(System.Int32,System.String,System.DateTime)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "ID", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.GameKeys.#CreateGameKeys(System.Int32,System.String,System.DateTime)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "ID", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.RewardCategory.#CreateRewardCategory(System.Int32,System.String)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.RewardCategory.#Reward")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "ID", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.RewardCategory.#RewardCategoryID")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "ID", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.RewardLocale.#CreateRewardLocale(System.Int32,System.DateTime)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "d", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.RewardLocale.#CreateRewardLocale(System.Int32,System.DateTime)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "ID", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.RewardLocale.#RewardLocaleID")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "ID", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.RewardType.#CreateRewardType(System.Int32,System.String)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.RewardType.#Reward")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "ID", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.RewardType.#RewardTypeID")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly", MessageId = "TEnd", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.Rule.#CreateRule(System.Int32,System.DateTime,System.DateTime,System.DateTime,System.DateTime)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "ID", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.Rule.#CreateRule(System.Int32,System.DateTime,System.DateTime,System.DateTime,System.DateTime)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "d", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.Rule.#CreateRule(System.Int32,System.DateTime,System.DateTime,System.DateTime,System.DateTime)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.Rule.#RuleExpression")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "ID", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.Rule.#RuleID")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "ID", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.RuleExpression.#CreateRuleExpression(System.Int32,System.String,System.String,System.DateTime,System.DateTime)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "d", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.RuleExpression.#CreateRuleExpression(System.Int32,System.String,System.String,System.DateTime,System.DateTime)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "ID", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.Reward.#RewardID")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.Reward.#RewardLocale")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.Reward.#Rule")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "ID", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.GameCategories.#GameCategoryID")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "d", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.GameCategories.#CreateGameCategories(System.Int32,System.String,System.DateTime)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "ID", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.GameCategories.#CreateGameCategories(System.Int32,System.String,System.DateTime)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.DataType.#StatDescription")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.DataType.#RuleExpression")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.DataType.#GameSchemaProperties")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "ID", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.DataType.#DataTypeID")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames", MessageId = "string", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.DataType.#CreateDataType(System.Int32,System.String)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "ID", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.DataType.#CreateDataType(System.Int32,System.String)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.DataType.#ActionParameterDefinition")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "d", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.ActionSettingsDefinition.#CreateActionSettingsDefinition(System.Int32,System.String,System.String,System.DateTime)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "ID", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.ActionSettingsDefinition.#CreateActionSettingsDefinition(System.Int32,System.String,System.String,System.DateTime)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "ID", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.ActionSettingsDefinition.#ActionSettingsDefinitionID")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.ActionSettingsDefinition.#ActionSettings")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "d", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.ActionSettings.#CreateActionSettings(System.Int32,System.String,System.DateTime)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "ID", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.ActionSettings.#CreateActionSettings(System.Int32,System.String,System.DateTime)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "ID", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.ActionSettings.#ActionSettingsID")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.ActionSetExecutionType.#Rule")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "ID", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.ActionSetExecutionType.#CreateActionSetExecutionType(System.Int32,System.String)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "ID", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.ActionSetExecutionType.#ActionSetExecutionTypeID")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1721:PropertyNamesShouldNotMatchGetMethods", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.ActionParameterDefinition.#Type")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "ID", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.ActionParameterDefinition.#CreateActionParameterDefinition(System.Int32,System.String,System.String,System.Int32)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "ID", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.ActionParameterDefinition.#ActionParameterDefinitionID")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.ActionParameterDefinition.#ActionParameter")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "ID", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.ActionParameter.#CreateActionParameter(System.Int32)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "ID", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.ActionParameter.#ActionParameterID")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "d", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.ActionDefinition.#CreateActionDefinition(System.Int32,System.String,System.DateTime,System.String)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "ID", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.ActionDefinition.#CreateActionDefinition(System.Int32,System.String,System.DateTime,System.String)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.ActionDefinition.#ActionSettingsDefinition")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.ActionDefinition.#ActionParameterDefinition")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "ID", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.ActionDefinition.#ActionDefinitionID")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.ActionDefinition.#Action")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "d", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.Action.#CreateAction(System.Int32,System.DateTime)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "ID", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.Action.#CreateAction(System.Int32,System.DateTime)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.Action.#ActionSettings")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.Action.#ActionParameter")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "ID", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.Action.#ActionID")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "RulesBadgeAuthoring.Page.#RulesTabItem")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "RulesBadgeAuthoring.Page.#LayoutRoot")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "RulesBadgeAuthoring.Page.#RewardListPage")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "RulesBadgeAuthoring.LoadingProgressPopup.#MyProgressBar")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "RulesBadgeAuthoring.LoadingProgressPopup.#LayoutRoot")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "RulesBadgeAuthoring.CreateBadgeEditPage.#Sum1ParamEditBoxToolTip")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "RulesBadgeAuthoring.CreateBadgeEditPage.#LayoutRoot")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "RulesBadgeAuthoring.BadgeCreatePage.#LayoutRoot")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "RulesBadgeAuthoring.ActionEditPopup.#LayoutRoot")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "RulesBadgeAuthoring.SumPropertyEditPage.#LayoutRoot")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "RulesBadgeAuthoring.StatementEditPopup.#LayoutRoot")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "RulesBadgeAuthoring.RuleListPage.#LayoutRoot")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "RulesBadgeAuthoring.RuleListPage.#PlaceHolder")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "RulesBadgeAuthoring.RuleEditPopup.#LayoutRoot")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "RulesBadgeAuthoring.RewardListPage.#PlaceHolder")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "RulesBadgeAuthoring.RewardListPage.#LayoutRoot")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "RulesBadgeAuthoring.RewardListPage.#dtc")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Scope = "member", Target = "RulesBadgeAuthoring.RewardsDataService.Rule.#Action")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\RulesBadgeAuthoring\RuleEditPopup.xaml.cs ===
namespace RulesBadgeAuthoring
{
    using System;
    using System.Windows;
    using System.Windows.Controls;
    using RulesBadgeAuthoring.RewardsDataService;
    using RulesBadgeAuthoring.View;
    using Action = RulesBadgeAuthoring.RewardsDataService.Action;

    public partial class RuleEditPopup : UserControl
    {
        
        internal Rule Rule { get; set; }
        private bool IsUpdate { get; set; }
        private bool IsUpdating { get; set; }
        private DoubleClickManager DoubleClickManagerActions { get; set; }
        private DoubleClickManager DoubleClickManagerStatements { get; set; }

        public RuleEditPopup()
        {
            InitializeComponent();

            this.InitializeEvents();

            this.Loaded += new RoutedEventHandler(RuleEditPopup_Loaded);
        }

        void RuleEditPopup_Loaded(object sender, RoutedEventArgs e)
        {
            using (DebugTextLogger.EnterFunction("Page::Page"))
            {
                try
                {
                    // initialize cover area of the pop-up window.
                    theBack.Width = App.Current.Host.Content.ActualWidth;
                    theBack.Height = App.Current.Host.Content.ActualHeight;

                    //this.dgStatements.Columns.Insert(0, this.Resources["dtcStatements"] as DataGridTemplateColumn);

                }
                catch (Exception ex)
                {
                    DebugTextLogger.Log(ex.ToString());
                }
            }
        }

        private void InitializeEvents()
        {
            App.Current.Host.Content.Resized += (s, f) =>
            {
                theBack.Width = App.Current.Host.Content.ActualWidth;
                theBack.Height = App.Current.Host.Content.ActualHeight;
            };

            this.AddActionButton.Click += new RoutedEventHandler(AddActionButton_Click);
            this.AddStatementButton.Click += new RoutedEventHandler(AddStatementButton_Click);
            this.CreateOrUpdateButton.Click += new RoutedEventHandler(CreateOrUpdateButton_Click);
            this.CancelButton.Click += new RoutedEventHandler(CancelButton_Click);

            this.dgStatements.LoadingRow += new EventHandler<DataGridRowEventArgs>(dgStatements_LoadingRow);
            this.dgActions.LoadingRow += new EventHandler<DataGridRowEventArgs>(dgActions_LoadingRow);
            
            this.DoubleClickManagerActions = new DoubleClickManager(500);
            this.DoubleClickManagerStatements = new DoubleClickManager(500);
            
            this.DoubleClickManagerActions.DoubleClick += new EventHandler<System.Windows.Input.MouseButtonEventArgs>(DoubleClickManagerActions_DoubleClick);
            this.DoubleClickManagerStatements.DoubleClick += new EventHandler<System.Windows.Input.MouseButtonEventArgs>(DoubleClickManagerStatements_DoubleClick);
            this.CommentTextBox.TextChanged += new TextChangedEventHandler(CommentTextBox_TextChanged);

            this.BeginDatePicker.SelectedDateChanged += new EventHandler<SelectionChangedEventArgs>(BeginDatePicker_SelectedDateChanged);
            this.EndDatePicker.SelectedDateChanged += new EventHandler<SelectionChangedEventArgs>(EndDatePicker_SelectedDateChanged);
        }

        void EndDatePicker_SelectedDateChanged(object sender, SelectionChangedEventArgs e)
        {
            if (this.Visibility == Visibility.Visible)
            {
                if (!this.IsUpdating && this.CanEnableCreateOrUpdateButton())
                {
                    this.CreateOrUpdateButton.IsEnabled = true;
                }
            }
        }

        void BeginDatePicker_SelectedDateChanged(object sender, SelectionChangedEventArgs e)
        {
            if (this.Visibility == Visibility.Visible)
            {
                if (!this.IsUpdating && this.CanEnableCreateOrUpdateButton())
                {
                    this.CreateOrUpdateButton.IsEnabled = true;
                }
            }
        }

        void CommentTextBox_TextChanged(object sender, TextChangedEventArgs e)
        {
            if (this.Visibility == Visibility.Visible)
            {
                if (!this.IsUpdating && this.CanEnableCreateOrUpdateButton())
                {
                    this.Rule.IsModified = true;
                    this.CreateOrUpdateButton.IsEnabled = true;
                }
            }
        }

        void DoubleClickManagerStatements_DoubleClick(object sender, System.Windows.Input.MouseButtonEventArgs e)
        {
            if (this.Visibility == Visibility.Visible)
            {
                DebugTextLogger.Log("DoubleClickManagerStatements_DoubleClick");
                this.popStatement.RuleEditPage = this;
                this.popStatement.DataContext = this.dgStatements.SelectedItem as RuleExpression;
                this.popStatement.Show();
            }
        }

        void DoubleClickManagerActions_DoubleClick(object sender, System.Windows.Input.MouseButtonEventArgs e)
        {
            if (this.Visibility == Visibility.Visible)
            {
                DebugTextLogger.Log("DoubleClickManagerActions_DoubleClick");
                this.popAction.RuleEditPage = this;
                this.popAction.DataContext = this.dgActions.SelectedItem as Action;
                this.popAction.Show();
            }
        }

        void dgActions_LoadingRow(object sender, DataGridRowEventArgs e)
        {
            e.Row.MouseLeftButtonUp += this.DoubleClickManagerActions.HandleClick;
        }

        void dgStatements_LoadingRow(object sender, DataGridRowEventArgs e)
        {
            e.Row.MouseLeftButtonUp += this.DoubleClickManagerStatements.HandleClick;
        }

        void CancelButton_Click(object sender, RoutedEventArgs e)
        {
            if (this.Visibility == Visibility.Visible)
            {
                this.Close();
            }
        }

        void CreateOrUpdateButton_Click(object sender, RoutedEventArgs e)
        {
            if (this.Visibility == Visibility.Visible)
            {
                this.CreateOrUpdateButton.IsEnabled = false;

                this.Rule.DTStart = this.BeginDatePicker.SelectedDate.Value;
                this.Rule.DTEnd = this.EndDatePicker.SelectedDate.Value;
                this.Rule.Comment = this.CommentTextBox.Text;

                if (RewardManager.ActionSetExecutionTypeList.Count > 0)
                {
                    this.Rule.ActionSetExecutionType = RewardManager.ActionSetExecutionTypeList[0];
                }

                this.Rule.Commit();
                RewardManager.SaveComplete += new EventHandler<RulesBadgeAuthoring.Model.SaveDataEventArgs>(RewardManager_SaveComplete);
                RewardManager.SaveAsync();
            }
        }

        void RewardManager_SaveComplete(object sender, RulesBadgeAuthoring.Model.SaveDataEventArgs e)
        {
            if (this.Visibility == Visibility.Visible)
            {
                DebugTextLogger.Log("operation completed w/ {0}", e.Succeeded);
                RewardManager.SaveComplete -= RewardManager_SaveComplete;

                if (!this.IsUpdate)
                {
                    RewardManager.RuleList.Add(this.Rule);
                }

                this.Close();
            }
        }

        void AddStatementButton_Click(object sender, RoutedEventArgs e)
        {
            if (this.Visibility == Visibility.Visible)
            {
                this.popStatement.RuleEditPage = this;
                this.popStatement.DataContext = null;
                this.popStatement.Show();
            }
        }

        void AddActionButton_Click(object sender, RoutedEventArgs e)
        {
            if (this.Visibility == Visibility.Visible)
            {
                this.popAction.RuleEditPage = this;
                this.popAction.DataContext = null;
                this.popAction.Show();
            }
        }

        public void Close()
        {
            popMessage.IsOpen = false;
            this.Visibility = Visibility.Collapsed;

            // Must always be the last line in Close();
            this.DataContext = null;
            this.IsUpdate = false;
            this.Rule = null;

            this.CommentTextBox.Text = string.Empty;
        }

        public void Show()
        {
            using (DebugTextLogger.EnterFunction("Query:RuleEditPopup:Delegate"))
            {
                try
                {
                    // must the very first line in the Show.
                    this.InitializeStatus();

                    popMessage.IsOpen = true;
                    this.Visibility = Visibility.Visible;

                    // determine the text in the SubmitUpdateButton
                    this.SetCreateOrUpdateButtonText();

                    //CancelButton.Focus();
                    this.UpdateLayout();
                    this.UpdateLayout();
                }
                catch (Exception ex)
                {
                    DebugTextLogger.LogException(ex);
                }
            }
        }

        private void InitializeStatus()
        {
            this.AddActionButton.IsEnabled = false;
            this.AddStatementButton.IsEnabled = false;

            if (this.DataContext == null)
            {
                this.IsUpdate = false;
                this.Rule = new Rule();
                this.Rule.IsCreated = true;
                this.DataContext = this.Rule;

                this.Rule.DTStart = this.BeginDatePicker.SelectedDate.Value;
                this.Rule.DTEnd = this.EndDatePicker.SelectedDate.Value;
            }
            else
            {
                this.IsUpdate = true;
                this.Rule = this.DataContext as Rule;

                this.UpdatePageFromRule(this.Rule);
            }

            this.Rule.OnInitializationComplete += new EventHandler<EventArgs>(Rule_OnInitializationComplete);
            this.Rule.BeginInitialize();
        }

        void Rule_OnInitializationComplete(object sender, EventArgs e)
        {
            // Set Data Contexts
            this.dgStatements.DataContext = this.Rule.ExpressionList;
            this.dgActions.DataContext = this.Rule.ActionList;

            this.Rule.OnInitializationComplete -= Rule_OnInitializationComplete;

            if (!this.CanEnableCreateOrUpdateButton())
            {
                this.CreateOrUpdateButton.IsEnabled = false;
            }

            if (this.Rule.GetGameKey() != null)
            {
                this.AddActionButton.IsEnabled = true;
            }

            this.AddStatementButton.IsEnabled = true;

            this.Rule.OnActionModified += new EventHandler<EventArgs>(Rule_OnActionModified);
            this.Rule.OnExpressionModified += new EventHandler<EventArgs>(Rule_OnExpressionModified);
        }

        void Rule_OnExpressionModified(object sender, EventArgs e)
        {
            if (!this.Rule.HasInitialized)
            {
                RuleExpression expression = sender as RuleExpression;
                if (expression != null)
                {
                    if (expression.GetStatementType().StatementTypeEnum == StatementTypeEnum.GameKey)
                    {
                        this.AddActionButton.IsEnabled = false;
                        this.AddStatementButton.IsEnabled = false;

                        this.Rule.OnInitializationComplete += new EventHandler<EventArgs>(Rule_OnInitializationComplete);
                        this.Rule.BeginInitialize();
                    }
                }
            }

            if (!this.IsUpdating)
            {
                this.CreateOrUpdateButton.IsEnabled = this.CanEnableCreateOrUpdateButton();
            }

            if (this.Rule.GetGameKey() != null)
            {
                this.AddActionButton.IsEnabled = true;
            }
        }

        void Rule_OnActionModified(object sender, EventArgs e)
        {
            this.CreateOrUpdateButton.IsEnabled = this.CanEnableCreateOrUpdateButton();
        }

        private void UpdatePageFromRule(Rule rule)
        {
            try
            {
                this.IsUpdating = true;

                this.BeginDatePicker.SelectedDate = rule.DTStart;
                this.EndDatePicker.SelectedDate = rule.DTEnd;
                this.CommentTextBox.Text = rule.Comment ?? string.Empty;
            }
            finally
            {
                this.IsUpdating = false;
            }
        }

        private bool CanEnableCreateOrUpdateButton()
        {
            // Does rule have a Game Key ?
            if (!this.Rule.HasValidGameKey())
            {
                return false;
            }

            if (!this.CommentTextBox.Text.Equals(this.Rule.Comment))
            {
                return true;
            }

            if (this.Rule.DTStart != this.BeginDatePicker.SelectedDate)
            {
                return true;
            }

            if (this.Rule.DTEnd != this.EndDatePicker.SelectedDate)
            {
                return true;
            }

            if (this.Rule.IsModified)
            {
                return true;
            }

            // TODO: Check enabled/disabled button.

            return false;
        }

        private void SetCreateOrUpdateButtonText()
        {
            if (this.IsUpdate)
            {
                this.CreateOrUpdateButton.Content = "Update";
            }
            else
            {
                this.CreateOrUpdateButton.Content = "Create";
            }
        }

        private void DeleteButtonClickStatements(object sender, RoutedEventArgs e)
        {
            Button btn = sender as Button;
            int selectedItemID = Convert.ToInt32(btn.Tag.ToString());

            RuleExpression expressionToDelete = null;
            bool isFound = false;

            foreach (Object obj in this.dgStatements.ItemsSource)
            {
                expressionToDelete = obj as RuleExpression;
                if (expressionToDelete.RuleExpressionID == selectedItemID)
                {
                    isFound = true;
                    this.dgStatements.SelectedItem = obj;
                    break;
                }
            }

            DebugTextLogger.Log("Item ID={0} and dgIndex={1}", selectedItemID, this.dgStatements.SelectedIndex);

            if (isFound)
            {
                this.Rule.DeleteExpression(expressionToDelete);
            }

        }

        private void DeleteButtonClickActions(object sender, RoutedEventArgs e)
        {
            Button btn = sender as Button;
            int selectedItemID = Convert.ToInt32(btn.Tag.ToString());

            Action actionToDelete = null;
            bool found = false;

            foreach (Object obj in this.dgActions.ItemsSource)
            {
                actionToDelete = obj as Action;
                if (actionToDelete.ExecuteOrder == selectedItemID)
                {
                    found = true;
                    this.dgActions.SelectedItem = obj;
                    break;
                }
            }

            DebugTextLogger.Log("Item ID={0} and dgIndex={1}", selectedItemID, this.dgActions.SelectedIndex);

            if (found)
            {
                // delete entry here.
                this.Rule.DeleteAction(actionToDelete);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\RulesBadgeAuthoring\SumPropertyEditPage.xaml.cs ===
namespace RulesBadgeAuthoring
{
    using System;
    using System.Linq;
    using System.Windows;
    using System.Windows.Controls;
    using RulesBadgeAuthoring.Model;
    using RulesBadgeAuthoring.RewardsDataService;
    using RulesBadgeAuthoring.View;
    using Action = RulesBadgeAuthoring.RewardsDataService.Action;

    public partial class SumPropertyEditPage : UserControl, IActionEditPage
    {
        private const string StorePathFormatString = "/Store/User[ID=/Event/LivePuid]/Game[ID=/Event/GameKey]/{0}";
        private const string PropertyPathFormatString = "/Event/Property[{0}]";

        public ActionEditPopup ActionEditPopup { get; set; }
        public event EventHandler<EventArgs> OnCreateOrUpdateable;

        private Action Action { get; set; }
        private bool IsCreated { get; set; }
        private bool DontUpdateTextBoxes { get; set; }

        public SumPropertyEditPage()
        {
            InitializeComponent();

            this.InitializeEvents();
            this.Loaded += new RoutedEventHandler(SumPropertyEditPage_Loaded);
        }

        private void InitializeEvents()
        {
            this.StatSelector.SelectionChanged += new SelectionChangedEventHandler(StatSelector_SelectionChanged);
            this.PropertySelector.SelectionChanged += new SelectionChangedEventHandler(PropertySelector_SelectionChanged);
        }

        void SumPropertyEditPage_Loaded(object sender, RoutedEventArgs e)
        {
        }

        void PropertySelector_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            if (!this.DontUpdateTextBoxes)
            {
                GameSchemaProperties gsp = this.PropertySelector.SelectedItem as GameSchemaProperties;
                if (gsp != null)
                {
                    this.Sum2ParamEditBox.Text = string.Format(SumPropertyEditPage.PropertyPathFormatString,
                                                               (this.PropertySelector.SelectedItem as GameSchemaProperties).Name);
                    this.Sum2ParamEditBoxToolTip.Text = this.Sum2ParamEditBox.Text;
                    this.OnCreateOrUpdateable(this.IsCreatable, null);
                }
            }
        }

        void StatSelector_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            if (!this.DontUpdateTextBoxes)
            {
                StatDescription statDesc = this.StatSelector.SelectedItem as StatDescription;
                if (statDesc != null)
                {
                    string resultString = string.Format(SumPropertyEditPage.StorePathFormatString,
                                                        (this.StatSelector.SelectedItem as StatDescription).Name);
                    this.Sum1ParamEditBox.Text = resultString;
                    this.Sum1ParamEditBoxToolTip.Text = resultString;
                    this.StoreParamEditBox.Text = resultString;
                    this.StoreParamEditBoxToolTip.Text = resultString;

                    this.OnCreateOrUpdateable(this.IsCreatable, null);
                }
            }
        }

        public Action ConstructActionFromPage()
        {
            Action action = this.Action;

            if (action.IsCreated && action.ActionParameterList.Count == 0)
            {
                ActionParameter userParam = this.ConstructUserParam();
                action.CreateParameter(userParam);

                ActionParameter sum1Param = this.ConstructSum1Param();
                action.CreateParameter(sum1Param);

                ActionParameter sum2Param = this.ConstructSum2Param();
                action.CreateParameter(sum2Param);

                ActionParameter storeParam = this.ConstructStoreParam();
                action.CreateParameter(storeParam);
            }
            else
            {
                ActionParameter param;

                param = this.GetUserParamFromAction();
                param.Path = this.UserParamEditBox.Text;
                param.IsModified = true;

                param = this.GetSum1ParamFromAction();
                param.Path = this.Sum1ParamEditBox.Text;
                param.IsModified = true;

                param = this.GetSum2ParamFromAction();
                param.Path = this.Sum2ParamEditBox.Text;
                param.IsModified = true;

                param = this.GetStoreParamFromAction();
                param.Path = this.StoreParamEditBox.Text;
                param.IsModified = true;

                action.IsModified = true;
            }

            return action;
        }

        private ActionParameter ConstructUserParam()
        {
            ActionParameter userParam = new ActionParameter()
            {
                ActionParameterDefinition = this.FetchActionParameterDefinition(this.ActionEditPopup.ActionTypeSelectionCmbBx.SelectedItem as ActionDefinition, "User"),
                Path = this.UserParamEditBox.Text,
                Value = string.Empty,
                IsCreated = true,
                IsModified = true
            };

            return userParam;
        }

        private ActionParameter ConstructSum1Param()
        {
            ActionParameter sum1Param = new ActionParameter()
            {
                ActionParameterDefinition = this.FetchActionParameterDefinition(this.ActionEditPopup.ActionTypeSelectionCmbBx.SelectedItem as ActionDefinition, "Sum1"),
                Path = this.Sum1ParamEditBox.Text,
                Value = string.Empty,
                IsCreated = true,
                IsModified = true
            };

            return sum1Param;
        }

        private ActionParameter ConstructSum2Param()
        {
            ActionParameter sum2Param = new ActionParameter()
            {
                ActionParameterDefinition = this.FetchActionParameterDefinition(this.ActionEditPopup.ActionTypeSelectionCmbBx.SelectedItem as ActionDefinition, "Sum2"),
                Path = this.Sum2ParamEditBox.Text,
                Value = string.Empty,
                IsCreated = true,
                IsModified = true
            };

            return sum2Param;
        }

        private ActionParameter ConstructStoreParam()
        {
            ActionParameter sum2Param = new ActionParameter()
            {
                ActionParameterDefinition = this.FetchActionParameterDefinition(this.ActionEditPopup.ActionTypeSelectionCmbBx.SelectedItem as ActionDefinition, "Store"),
                Path = this.StoreParamEditBox.Text,
                Value = string.Empty,
                IsCreated = true,
                IsModified = true
            };

            return sum2Param;
        }

        private ActionParameterDefinition FetchActionParameterDefinition(ActionDefinition definition, string paramName)
        {
            var paramDefinition = from parDef in definition.ActionParameterDefinition
                                  where parDef.Name.Equals(paramName)
                                  select parDef;

            return paramDefinition.First<ActionParameterDefinition>();
        }

        public bool IsCreatable
        {
            get
            {
                if (this.DataContext != null)
                {
                    return this.CheckIfModified();
                }

                return true;
            }
        }

        private bool CheckIfModified()
        {
            if (!this.UserParamEditBox.Text.Equals(this.GetUserParamFromAction().Path))
            {
                return true;
            }

            if (!this.Sum1ParamEditBox.Text.Equals(this.GetSum1ParamFromAction().Path))
            {
                return true;
            }

            if (!this.Sum2ParamEditBox.Text.Equals(this.GetSum2ParamFromAction().Path))
            {
                return true;
            }
            
            if(!this.StoreParamEditBox.Text.Equals(this.GetStoreParamFromAction().Path))
            {
                return true;
            }

            return false;
        }

        void Action_OnInitializeComplete(object sender, EventArgs e)
        {
            this.Action.OnInitializeComplete -= Action_OnInitializeComplete;

            bool shouldUpdateTextBoxes = true;

            if (!this.IsCreated && this.Action.HasInitialized)
            {
                shouldUpdateTextBoxes = false;

                this.UserParamEditBox.Text = this.GetUserParamFromAction().Path;
                this.Sum1ParamEditBox.Text = this.GetSum1ParamFromAction().Path;
                this.Sum2ParamEditBox.Text = this.GetSum2ParamFromAction().Path;
                this.StoreParamEditBox.Text = this.GetStoreParamFromAction().Path;
            }


            try
            {
                if (!shouldUpdateTextBoxes)
                {
                    this.DontUpdateTextBoxes = true;
                }

                this.PopulatePropList();
                this.PopulateStatList();
            }
            finally
            {
                if (!shouldUpdateTextBoxes)
                {
                    this.DontUpdateTextBoxes = false;
                }
            }

        }

        private void PopulatePropList()
        {
            try
            {
                this.PropertySelector.SelectionChanged -= PropertySelector_SelectionChanged;

                // drain combobox
                while (this.PropertySelector.Items.Count > 0)
                {
                    this.PropertySelector.Items.RemoveAt(0);
                }

                this.PropertySelector.UpdateLayout();

                // set Game Schema Properties List
                GameSchemaPropertiesCollection gspList = this.ActionEditPopup.RuleEditPage.Rule.GetGameKey().PropertiesList;

                foreach (GameSchemaProperties prop in gspList)
                {
                    this.PropertySelector.Items.Add(prop);
                }

                this.PropertySelector.UpdateLayout();
            }
            finally
            {
                this.PropertySelector.SelectionChanged += new SelectionChangedEventHandler(PropertySelector_SelectionChanged);
            }

            if (this.Action.IsCreated)
            {
                if (this.PropertySelector.SelectedIndex != 0)
                {
                    this.PropertySelector.SelectedIndex = 0;
                }
            }
            else
            {
                if (this.PropertySelector.SelectedItem != this.GetPropFromAction())
                {
                    this.PropertySelector.SelectedItem = this.GetPropFromAction();
                }
            }
        }

        /// <summary>
        /// A bug in Combobox is preventing the change of ItemsSource
        /// </summary>
        private void PopulateStatList()
        {
            try
            {
                this.StatSelector.SelectionChanged -= StatSelector_SelectionChanged;

                // drain list
                while (this.StatSelector.Items.Count > 0)
                {
                    this.StatSelector.Items.RemoveAt(0);
                }
                this.StatSelector.UpdateLayout();

                StatDescriptionCollection gameStatList = this.ActionEditPopup.RuleEditPage.Rule.GetGameKey().StatList;
                foreach (StatDescription sd in gameStatList)
                {
                    this.StatSelector.Items.Add(sd);
                }

                this.StatSelector.UpdateLayout();
            }
            finally
            {
                this.StatSelector.SelectionChanged += new SelectionChangedEventHandler(StatSelector_SelectionChanged);
            }


            if (this.Action.IsCreated)
            {
                if (this.StatSelector.SelectedIndex != 0)
                {
                    this.StatSelector.SelectedIndex = 0;
                }
            }
            else
            {
                StatDescription sd = this.GetStatFromAction();
                var statDesc = from statdesc in this.StatSelector.Items
                               where (statdesc as StatDescription).StatDescriptionID == sd.StatDescriptionID
                               select statdesc;
                this.StatSelector.SelectedItem = (statDesc.First<object>() as StatDescription);
            }
        }

        private ActionParameter GetUserParamFromAction()
        {
            ActionParameter paramUser = (from par in this.Action.ActionParameterList
                                         where par.ActionParameterDefinition.Name.Equals("User")
                                         select par).First<ActionParameter>();
            return paramUser;
        }


        private ActionParameter GetSum1ParamFromAction()
        {
            ActionParameter paramSum1 = (from par in this.Action.ActionParameterList
                                         where par.ActionParameterDefinition.Name.Equals("Sum1")
                                         select par).First<ActionParameter>();
            return paramSum1;
        }

        private ActionParameter GetSum2ParamFromAction()
        {
            ActionParameter paramSum2 = (from par in this.Action.ActionParameterList
                                         where par.ActionParameterDefinition.Name.Equals("Sum2")
                                         select par).First<ActionParameter>();
            return paramSum2;
        }

        private ActionParameter GetStoreParamFromAction()
        {
            ActionParameter param = (from par in this.Action.ActionParameterList
                                     where par.ActionParameterDefinition.Name.Equals("Store")
                                     select par).First<ActionParameter>();
            return param;
        }

        public StatDescription GetStatFromAction()
        {
            ActionParameter paramSum1 = this.GetSum1ParamFromAction();
            
            string statName = paramSum1.Path.Split(new char[] { '/' }, StringSplitOptions.RemoveEmptyEntries).Last<string>();

            var stat = (from statDesc in this.Action.Rule.GetGameKey().StatList
                        where statDesc.Name.Equals(statName)
                        select statDesc).First<StatDescription>();
            return stat;
        }


        public GameSchemaProperties GetPropFromAction()
        {
            ActionParameter sum2Param = this.GetSum2ParamFromAction();

            int beginIndex = sum2Param.Path.LastIndexOf('[');
            int endIndex = sum2Param.Path.LastIndexOf(']');

            string propName = sum2Param.Path.Substring(beginIndex + 1, endIndex - beginIndex - 1);

            var prop = (from propDesc in this.Action.Rule.GetGameKey().PropertiesList
                        where propDesc.Name.Equals(propName)
                        select propDesc).First<GameSchemaProperties>();
            return prop;
        }

        public void Show(Object dataContext)
        {
            this.DataContext = dataContext;
            this.Visibility = Visibility.Visible;

            this.Action = this.DataContext as Action;
            if (this.Action == null)
            {
                this.IsCreated = true;
                this.Action = new Action();
                this.Action.DTModified = DateTime.UtcNow;
                this.Action.IsCreated = true;
                this.Action.ActionDefinition = (this.ActionEditPopup.ActionTypeSelectionCmbBx.SelectedItem as ActionDefinition);
                this.Action.ExecuteOrder = this.ActionEditPopup.RuleEditPage.Rule.ActionList.Count;
            }
            else
            {
                // this must be a SumPropertyAction
                if (!this.Action.ActionDefinition.Name.Equals("SumProperty"))
                {
                    throw new InvalidOperationException();
                }

                if (this.Action.ActionParameterList.Count != 4)
                {
                    throw new InvalidOperationException();
                }
            }

            this.Action.OnInitializeComplete += new EventHandler<EventArgs>(Action_OnInitializeComplete);
            this.Action.BeginInitialize();
        }

        public void Close(Object dataContext)
        {
            this.Visibility = Visibility.Collapsed;
            this.DataContext = dataContext;
            this.IsCreated = false;
            this.Action = dataContext as Action;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\RulesBadgeAuthoring\StatementEditPopup.xaml.cs ===
namespace RulesBadgeAuthoring
{
    using System.Windows;
    using System.Windows.Controls;
    using RulesBadgeAuthoring.View;
    using System;
    using RulesBadgeAuthoring.RewardsDataService;
    using System.Linq;
    using RulesBadgeAuthoring.Model;

    public partial class StatementEditPopup : UserControl
    {
        private UIElement CurrentRightOperandControl { get; set; }
        private UIElement CurrentLeftOperandControl { get; set; }

        private RuleExpression Expression { get; set; }

        internal RuleEditPopup RuleEditPage { get; set; }


        private bool IsUpdate { get; set; }

        private bool IsUpdating { get; set; }

        public StatementEditPopup()
        {
            InitializeComponent();

            InitializeEvents();

            this.Loaded += new RoutedEventHandler(StatementEditPopup_Loaded);
        }

        private void SetItemSources()
        {
            try
            {
                this.IsUpdating = true;
                
                // set statement type combobox
                this.StatementTypeCbBox.ItemsSource = StatementEditConfig.StatementDropDownList;

                // load ops combobox
                this.OperationCbBox.ItemsSource = RewardManager.RuleOperatorList;

                // set Game Key Right Operand combobox
                this.RightOperandGameKeyCbBox.ItemsSource = RewardManager.GameKeyList;

                // set Locale Right Operand combobox
                this.RightOperandLocaleCbBox.ItemsSource = RewardManager.LocaleList;
            }
            finally
            {
                this.IsUpdating = false;
            }
        }

        void StatementEditPopup_Loaded(object sender, RoutedEventArgs e)
        {
            theBack.Width = App.Current.Host.Content.ActualWidth;
            theBack.Height = App.Current.Host.Content.ActualHeight;

        }

        void RuleOperatorList_LoadComplete(object sender, EventArgs e)
        {
            if (RewardManager.RuleOperatorList.Count > 0)
            {
                this.OperationCbBox.SelectedIndex = 0;
            }
        }

        private void InitializeEvents()
        {
            App.Current.Host.Content.Resized += (s, f) =>
            {
                theBack.Width = App.Current.Host.Content.ActualWidth;
                theBack.Height = App.Current.Host.Content.ActualHeight;
            };

            this.StatementTypeCbBox.SelectionChanged += new SelectionChangedEventHandler(StatementTypeCbBox_SelectionChanged);

            this.OperationCbBox.SelectionChanged += new SelectionChangedEventHandler(ContentChanged);
            this.LeftOperandCbBox.SelectionChanged += new SelectionChangedEventHandler(ContentChanged);
            this.RightOperandGameCategoryCbBox.SelectionChanged += new SelectionChangedEventHandler(ContentChanged);
            this.RightOperandGameKeyCbBox.SelectionChanged += new SelectionChangedEventHandler(ContentChanged);
            this.RightOperandLocaleCbBox.SelectionChanged += new SelectionChangedEventHandler(ContentChanged);
            this.RightOperandPlatformsCbBox.SelectionChanged += new SelectionChangedEventHandler(ContentChanged);
            this.RightOperandPropertyCbBox.SelectionChanged += new SelectionChangedEventHandler(ContentChanged);
            this.RightOperandStatCbBox.SelectionChanged += new SelectionChangedEventHandler(ContentChanged);
            this.RightOperandLiteralTextBox.TextChanged += new TextChangedEventHandler(RightOperandLiteralTextBox_TextChanged);
            
            this.CancelButton.Click += new RoutedEventHandler(CancelButton_Click);
            this.CreateOrUpdateButton.Click += new RoutedEventHandler(CreateOrUpdateButton_Click);
        }

        void RightOperandLiteralTextBox_TextChanged(object sender, TextChangedEventArgs e)
        {
            if (this.Visibility == Visibility.Visible)
            {
                bool fClear = false;

                if (!string.IsNullOrEmpty(this.RightOperandLiteralTextBox.Text))
                {
                    int b;
                    if (!int.TryParse(this.RightOperandLiteralTextBox.Text, out b))
                    {
                        fClear = true;
                        MessageBoxResult result = MessageBox.Show("Only Int32 values are allowed", "UH OH!", MessageBoxButton.OK);
                    }
                }
                else
                {
                    //fClear = true;
                }

                if (fClear)
                {
                    // TODO: put back the old value.
                    this.RightOperandLiteralTextBox.Text = "0";
                }

                this.ContentChanged(null, null);
            }
        }


        void ContentChanged(object sender, SelectionChangedEventArgs e)
        {
            if (!this.IsUpdating)
            {
                this.CheckAndEnableCoub();
            }
        }

        void CreateOrUpdateButton_Click(object sender, RoutedEventArgs e)
        {
            if (this.Visibility == Visibility.Visible)
            {
                this.CreateOrUpdateButton.IsEnabled = false;

                this.UpdateExpressionFromUI(this.Expression);

                if (!this.IsUpdate)
                {
                    this.RuleEditPage.Rule.InsertCreatedExpression(this.Expression);
                }
                else
                {
                    ////
                    //// check if updated expression is already in the created expressions
                    //// if it is, we don't need to indicate to the Rule object of any changes.
                    ////
                    //if (!this.RuleEditPage.Rule.ExpressionList.Contains(this.Expression))
                    //{
                    this.RuleEditPage.Rule.UpdateCreatedExpression(this.Expression);
                    //}
                }
                this.Close();
            }
        }

        void CancelButton_Click(object sender, RoutedEventArgs e)
        {
            if (this.Visibility == Visibility.Visible)
            {
                this.Close();
            }
        }

        void StatementTypeCbBox_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            if (this.Visibility == Visibility.Visible)
            {
                if (!this.IsUpdating)
                {
                    DebugTextLogger.Log("StatementEditPopup::StatementChanged");

                    StatementType stype = this.StatementTypeCbBox.SelectedItem as StatementType;

                    //
                    // if there is no GAME KEY, don't let any non game key type selection.
                    //
                    if (!this.RuleEditPage.Rule.HasValidGameKey() &&
                        stype.StatementTypeEnum != StatementTypeEnum.GameKey)
                    {
                        MessageBoxResult result = MessageBox.Show("You MUST create a GameKey statement first", "UH OH!", MessageBoxButton.OK);
                        this.StatementTypeCbBox.SelectedIndex = 0;
                        return;
                    }


                    this.SetVisibilityState(stype);
                    //this.SetStatementType(stype);
                    this.SetLeftOperand(stype, true);
                    this.SetOperation(stype);
                    this.SetRightOperand(stype, true);

                    this.ContentChanged(null, null);

                    this.UpdateLayout();
                }
            }
        }

        private GameSchemaPropertiesCollection GetGameKeyPropertyList()
        {
            GameKeys game = this.Expression.Rule.GetGameKey();
            if (game != null)
            {
                if (game.PropertiesList == null)
                {
                    game.PropertiesList = new GameSchemaPropertiesCollection(RewardManager.ServiceContext);
                }

                return game.PropertiesList;
            }

            return null;
        }

        private StatDescriptionCollection GetGameKeyStatList()
        {
            GameKeys game = this.Expression.Rule.GetGameKey();
            if (game != null)
            {
                if (game.StatList == null)
                {
                    game.StatList = new StatDescriptionCollection(RewardManager.ServiceContext);
                }

                return game.StatList;
            }

            return null;
        }

        public void Close()
        {
            popMessage.IsOpen = false;
            this.CreateOrUpdateButton.IsEnabled = false;
            this.Visibility = Visibility.Collapsed;
            this.Expression = null;
            this.DataContext = null;

            try
            {
                this.IsUpdating = true;
                this.StatementTypeCbBox.ItemsSource = null;
                this.OperationCbBox.ItemsSource = null;
                this.RightOperandGameKeyCbBox.ItemsSource = null;
                this.RightOperandLocaleCbBox.ItemsSource = null;
            }
            finally
            {
                this.IsUpdating = false;
            }
        }

        public void Show()
        {
            using (DebugTextLogger.EnterFunction("StatementEditPopup:Show"))
            {
                try
                {
                    popMessage.IsOpen = true;
                    this.Visibility = Visibility.Visible;

                    this.SetItemSources();

                    this.InitializeStatus();

                    this.UpdateLayout();
                    this.UpdateLayout();
                }
                catch (Exception ex)
                {
                    DebugTextLogger.LogException(ex);
                    throw;
                }
            }
        }

        private void InitializeStatus()
        {
            if (this.DataContext == null)
            {
                this.IsUpdate = false;
                
                this.Expression = this.ConstructAndInitializeExpression();
                this.Expression.Rule = this.RuleEditPage.Rule;
                this.DataContext = this.Expression;
            }
            else
            {
                this.IsUpdate = true;
                this.Expression = this.DataContext as RuleExpression;
                this.Expression.Rule = this.RuleEditPage.Rule;
            }

            this.UpdateUIFromExpression(this.Expression);
            
            //this.CheckAndEnableCoub();
        }

        private RuleExpression ConstructAndInitializeExpression()
        {
            RuleExpression expression = new RuleExpression();
            expression.IsCreated = true;
            expression.IsModified = true;

            //this.UpdateExpressionFromUI(expression);

            return expression;
        }

        private void CheckAndEnableCoub()
        {
            if (!this.IsUpdate)
            {
                this.CreateOrUpdateButton.Content = "Create";
                this.CreateOrUpdateButton.IsEnabled = true;
                return;
            }
            else
            {
                this.CreateOrUpdateButton.Content = "Update";
                if (this.CheckIfChanged())
                {
                    this.Expression.IsModified = true;
                    this.CreateOrUpdateButton.IsEnabled = true;
                    return;
                }
                else
                {
                    this.Expression.IsModified = false;
                }
            }

            this.CreateOrUpdateButton.IsEnabled = false;
            return;
        }

        private bool CheckIfChanged()
        {

            if (!this.GetLeftOperandString().Equals(this.Expression.LeftOperand))
            {
                return true;
            }

            if (this.OperationCbBox.SelectedItem != this.GetOperationCbBoxItemFromOperation(this.Expression.RuleOperator))
            {
                return true;
            }

            if (!GetRightOperandString().Equals(this.Expression.RightOperand))
            {
                return true;
            }

            return false;
        }

        private void UpdateExpressionFromUI(RuleExpression expression)
        {
            StatementType stype = this.StatementTypeCbBox.SelectedItem as StatementType;

            if (!this.IsUpdate)
            {
                expression.RuleExpressionID = 0; //TODO: investigate a better ID setting ops
                expression.DTCreated = DateTime.UtcNow;
                expression.RuleOperator = this.OperationCbBox.SelectedItem as RuleOperator;
                expression.DataType = this.GetDataTypeFromStatementType(stype);
            }
            
            expression.DTModified = DateTime.UtcNow;
            expression.LeftOperand = this.GetLeftOperandString();
            expression.RightOperand = this.GetRightOperandString();
            expression.RuleOperator = this.OperationCbBox.SelectedItem as RuleOperator;
            expression.RuleOperandType = RewardManager.RuleOperandTypeList[stype.LeftOperandTypeIndex];
            expression.RuleOperandType1= RewardManager.RuleOperandTypeList[stype.RightOperandTypeIndex];
        }

        private string GetRightOperandString()
        {
            switch ((this.StatementTypeCbBox.SelectedItem as StatementType).StatementTypeEnum)
            {
                case StatementTypeEnum.Property:
                    if (string.IsNullOrEmpty(this.RightOperandLiteralTextBox.Text))
                    {
                        return (this.LeftOperandCbBox.SelectedItem as GameSchemaProperties).Name;
                    }

                    return this.RightOperandLiteralTextBox.Text;
                    
                case StatementTypeEnum.Statistics:
                    if (string.IsNullOrEmpty(this.RightOperandLiteralTextBox.Text))
                    {
                        return (this.LeftOperandCbBox.SelectedItem as StatDescription).Name;
                    }

                    return this.RightOperandLiteralTextBox.Text;

                case StatementTypeEnum.GameKey:
                    return (this.RightOperandGameKeyCbBox.SelectedItem as GameKeys).GameKeyID.ToString();

                case StatementTypeEnum.GameCategory:
                    return (this.RightOperandGameCategoryCbBox.SelectedItem as GameCategories).Name;

                case StatementTypeEnum.Locale:
                    return (this.RightOperandLocaleCbBox.SelectedItem as Locale).Locale1.ToString();

                case StatementTypeEnum.Platforms:
                    return (this.RightOperandPlatformsCbBox.SelectedItem as Platforms).Name;

                default:
                    throw new InvalidOperationException();
            }
        }

        private string GetLeftOperandString()
        {
            StatementType stype = this.StatementTypeCbBox.SelectedItem as StatementType;
            switch (stype.StatementTypeEnum)
            {
                case StatementTypeEnum.Property:
                    if (string.IsNullOrEmpty(this.RightOperandLiteralTextBox.Text))
                    {
                        // creates and returns /Game/Properties/Name
                        return stype.LeftOperand + "/Name";
                    }

                    return stype.LeftOperand + string.Format("[{0}]", (this.LeftOperandCbBox.SelectedItem as GameSchemaProperties).Name);


                case StatementTypeEnum.Statistics:
                    if (string.IsNullOrEmpty(this.RightOperandLiteralTextBox.Text))
                    {
                        // creates and returns /Game/Properties/Name
                        return stype.LeftOperand + "/Name";
                    }

                    return stype.LeftOperand + string.Format("[{0}]", (this.LeftOperandCbBox.SelectedItem as StatDescription).Name);

                case StatementTypeEnum.GameKey:
                case StatementTypeEnum.GameCategory:
                case StatementTypeEnum.Locale:
                case StatementTypeEnum.Platforms:
                default:
                    return this.LeftOperandTextBlock.Text;
            }
        }

        private DataType GetDataTypeFromStatementType(StatementType statementType)
        {
            if (statementType.StatementTypeEnum == StatementTypeEnum.Statistics)
            {
                return RewardManager.DataTypeList[1]; // TODO: index 1 is DataTypeID=2, which is int32
            }
            else if (statementType.StatementTypeEnum == StatementTypeEnum.Property)
            {
                return RewardManager.DataTypeList[1]; // TODO: index 1 is DataTypeID=2, which is int32
            }

            return RewardManager.DataTypeList[0]; // TODO: index 0 is DataTypeID=1, which is string.
        }

        private void UpdateUIFromExpression(RuleExpression expression)
        {
            try
            {
                if (this.IsUpdate)
                {
                    this.IsUpdating = true;

                    StatementType stype = this.Expression.GetStatementType();

                    this.SetVisibilityState(stype);
                    this.SetStatementType(stype);
                    this.SetLeftOperand(stype, false);
                    this.SetOperation(stype);
                    this.SetRightOperand(stype, false);
                }
                else
                {
                    this.StatementTypeCbBox.SelectedIndex = 0;
                    // trigger the UI population
                    //StatementTypeCbBox_SelectionChanged(null, null);
                }
            }
            finally
            {
                this.IsUpdating = false;
            }
        }

        private void SetVisibilityState(StatementType st)
        {
            switch (st.StatementTypeEnum)
            {
                case StatementTypeEnum.GameKey:
                    this.SwapOperandControls(true, this.LeftOperandTextBlock);
                    this.SwapOperandControls(false, this.RightOperandGameKeyCbBox);
                    break;

                case StatementTypeEnum.Locale:
                    this.SwapOperandControls(true, this.LeftOperandTextBlock);
                    this.SwapOperandControls(false, this.RightOperandLocaleCbBox);
                    break;

                case StatementTypeEnum.GameCategory:
                    this.SwapOperandControls(true, this.LeftOperandTextBlock);
                    this.LeftOperandTextBlock.Text = st.LeftOperand;
                    this.SwapOperandControls(false, this.RightOperandGameCategoryCbBox);
                    break;

                case StatementTypeEnum.Platforms:
                    this.SwapOperandControls(true, this.LeftOperandTextBlock);
                    this.SwapOperandControls(false, this.RightOperandPlatformsCbBox);
                    break;

                // TODO: we should ideally set a GameKey first before hitting this section.
                // selecting the property and/or statistics is a very GameKey/Platform specific operation.
                //
                // we should ideally not even allow the creation of Property/statistics statement until a GameKey is selected
                //
                // NOTE: Assume a GameKey exists, if not select everything.
                case StatementTypeEnum.Property:
                    this.SwapOperandControls(true, this.LeftOperandCbBox);
                    this.SwapOperandControls(false, this.RightOperandLiteralTextBox);
                    GameSchemaPropertiesCollection gspList = this.GetGameKeyPropertyList();
                    this.LeftOperandCbBox.ItemsSource = gspList;
                    if (gspList.Count == 0)
                    {
                        gspList.LoadComplete += new EventHandler(PropertiesList_LoadComplete);
                        gspList.LoadAsync(this.Expression.Rule.GetGameKey().GameKeyID);
                    }
                    break;

                case StatementTypeEnum.Statistics:
                    this.SwapOperandControls(true, this.LeftOperandCbBox);
                    this.SwapOperandControls(false, this.RightOperandLiteralTextBox);
                    StatDescriptionCollection sdList = this.GetGameKeyStatList();
                    this.LeftOperandCbBox.ItemsSource = sdList;
                    if (sdList.Count == 0)
                    {
                        sdList.LoadComplete += new EventHandler(sdList_LoadComplete);
                        sdList.LoadAsync(this.Expression.Rule.GetGameKey().GameKeyID);
                    }
                    break;

                default:
                    break;
            }        
        }

        void sdList_LoadComplete(object sender, EventArgs e)
        {
            throw new NotImplementedException();
        }

        private void SetLeftOperand(StatementType st, bool useDefault)
        {
            switch (st.StatementTypeEnum)
            {
                case StatementTypeEnum.GameKey:
                    this.LeftOperandTextBlock.Text = st.LeftOperand;
                    break;

                case StatementTypeEnum.Locale:
                    this.LeftOperandTextBlock.Text = st.LeftOperand;
                    this.SwapOperandControls(false, this.RightOperandLocaleCbBox);
                    break;

                case StatementTypeEnum.GameCategory:
                    this.LeftOperandTextBlock.Text = st.LeftOperand;
                    break;

                case StatementTypeEnum.Platforms:
                    this.LeftOperandTextBlock.Text = st.LeftOperand;
                    break;

                case StatementTypeEnum.Property:
                    if (!useDefault)
                    {
                        if (this.RuleEditPage.Rule.GetGameKey().PropertiesList.Count > 0)
                        {
                            GameSchemaProperties gsp = this.Expression.GetGameSchemaProperty();
                            if (gsp != null)
                            {
                                this.LeftOperandCbBox.SelectedItem = gsp;
                            }
                            else
                            {
                                this.LeftOperandCbBox.SelectedIndex = 0;
                            }
                        }
                    }
                    else
                    {
                        this.LeftOperandCbBox.SelectedIndex = 0;
                    }

                    break;

                case StatementTypeEnum.Statistics:
                    if (!useDefault)
                    {
                        if (this.RuleEditPage.Rule.GetGameKey().StatList.Count > 0)
                        {
                            StatDescription sd = this.Expression.GetStatDescription();
                            if (sd != null)
                            {
                                this.LeftOperandCbBox.SelectedItem = sd;
                            }
                            else
                            {
                                this.LeftOperandCbBox.SelectedIndex = 0;
                            }
                        }
                    }
                    else
                    {
                        this.LeftOperandCbBox.SelectedIndex = 0;
                    }
                    break;

                default:
                    break;
            }
        }

        private void SetRightOperand(StatementType stype, bool useDefault)
        {
            if (!this.IsUpdate || useDefault)
            {
                ComboBox rightComboBox = this.CurrentRightOperandControl as ComboBox;
                if ((rightComboBox != null) && rightComboBox.ItemsSource != null)
                {
                    if ((rightComboBox.Items != null) &&
                        (rightComboBox.Items.Count > 0))
                    {
                        rightComboBox.SelectedIndex = 0;
                    }
                }

                return;
            }

            switch (stype.StatementTypeEnum)
            {
                    // set value to the edit box.
                case StatementTypeEnum.Property:
                case StatementTypeEnum.Statistics:
                    int b;
                    // if it is a LITERAL put it there, otherwise make it emtpy.
                    if (int.TryParse(this.Expression.RightOperand, out b))
                    {
                        this.RightOperandLiteralTextBox.Text = this.Expression.RightOperand;
                        break;
                    }

                    this.RightOperandLiteralTextBox.Text = string.Empty;
                    break;

                    // Select item from the right Operand combobox.
                case StatementTypeEnum.GameKey:
                    // use default in create mode.
                    // get gamekey from RuleExpression.RightOperand
                    this.RightOperandGameKeyCbBox.SelectedItem = this.GetGameKeyForGameKeyIdString(this.Expression.RightOperand) as GameKeys;
                    break;

                case StatementTypeEnum.GameCategory:
                    this.RightOperandGameCategoryCbBox.SelectedItem = this.GetGameCategoryForGameCategoryString(this.Expression.RightOperand) as GameCategories;
                    break;

                case StatementTypeEnum.Locale:
                    this.RightOperandLocaleCbBox.SelectedItem = this.GetLocaleForLocaleString(this.Expression.RightOperand) as Locale;
                    break;

                case StatementTypeEnum.Platforms:
                    this.LeftOperandTextBlock.Text = this.Expression.LeftOperand;
                    break;

                default:
                    throw new InvalidOperationException();
            }
        }

        void PropertiesList_LoadComplete(object sender, EventArgs e)
        {
            GameSchemaPropertiesCollection gspList = this.LeftOperandCbBox.ItemsSource as GameSchemaPropertiesCollection;
            if (gspList.Count > 0)
            {
                GameSchemaProperties gsp = this.Expression.GetGameSchemaProperty();
                if (gsp != null)
                {
                    this.LeftOperandCbBox.SelectedItem = gsp;
                }
                else
                {
                    this.LeftOperandCbBox.SelectedIndex = 0;
                }
            }

            gspList.LoadComplete -= PropertiesList_LoadComplete;
        }

        private Locale GetLocaleForLocaleString(string p)
        {
            var localeCollection = from local in RewardManager.LocaleList
                                   where local.Locale1.Equals(p)
                                   select local;
            
            return localeCollection.ToArray<Locale>()[0];
        }

        private GameCategories GetGameCategoryForGameCategoryString(string p)
        {
            //var categoryCollection = 
            throw new NotImplementedException();
        }

        private GameKeys GetGameKeyForGameKeyIdString(string p)
        {
            var gameKeyCollection = from game in RewardManager.GameKeyList
                                    where game.GameKeyID == int.Parse(p)
                                    select game;

            return gameKeyCollection.ToArray<GameKeys>()[0];
        }

        private void SetOperation(StatementType stype)
        {
            if (!this.IsUpdate)
            {
                if (RewardManager.RuleOperatorList.Count > 0)
                {
                    this.OperationCbBox.SelectedIndex = 2;
                }
            }
            else
            {
                if (RewardManager.RuleOperatorList.Count > 0)
                {
                    this.OperationCbBox.SelectedItem = this.GetOperationCbBoxItemFromOperation(this.Expression.RuleOperator);
                }
            }
        }

        private RuleOperator GetOperationCbBoxItemFromOperation(RuleOperator ruleOperator)
        {
            RuleOperator op = (from ro in RewardManager.RuleOperatorList
                               where ro.RuleOperatorID == ruleOperator.RuleOperatorID
                               select ro).First();
            return op;
        }

        private void SetStatementType(StatementType stype)
        {
            this.StatementTypeCbBox.SelectedIndex = stype.DropDownIndex;
        }

        private void SwapOperandControls(bool isLeftOperand, UIElement newControl)
        {
            if (isLeftOperand)
            {
                this.SwapLeftOperatorControl(newControl);
            }
            else
            {
                this.SwapRightOperatorControl(newControl);
            }
        }

        private void SwapRightOperatorControl(UIElement newRightOperatorControl)
        {
            if (this.CurrentRightOperandControl != null)
            {
                this.CurrentRightOperandControl.Visibility = Visibility.Collapsed;
            }
            this.CurrentRightOperandControl = newRightOperatorControl;

            if (newRightOperatorControl != null)
            {
                newRightOperatorControl.Visibility = Visibility.Visible;
            }
        }

        private void SwapLeftOperatorControl(UIElement leftControl)
        {
            if (this.CurrentLeftOperandControl != null)
            {
                this.CurrentLeftOperandControl.Visibility = Visibility.Collapsed;
            }
            this.CurrentLeftOperandControl = leftControl;

            if (leftControl != null)
            {
                leftControl.Visibility = Visibility.Visible;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\RulesBadgeAuthoring\Model\ActionDefinition.cs ===
namespace RulesBadgeAuthoring.RewardsDataService
{
    using System.ComponentModel;
    using RulesBadgeAuthoring.Model;

    public partial class ActionDefinition : BaseEntity
    {
        partial void OnActionDefinitionIDChanged() { FirePropertyChanged("ActionDefinitionIDChanged"); }
        partial void OnAssemblyNameChanged() { FirePropertyChanged("AssemblyName"); }
        partial void OnCommentChanged() { FirePropertyChanged("Comment"); }
        partial void OnDTModifiedChanged() { FirePropertyChanged("DTModified"); }
        partial void OnNameChanged() { FirePropertyChanged("Name"); }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\RulesBadgeAuthoring\Converters\RewardIdToCategoryConverter.cs ===
namespace RulesBadgeAuthoring.Converters
{
    using System;
    using System.Globalization;
    using System.Windows.Data;

    public class RewardIdToCategoryConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            //decimal amount = System.Convert.ToDecimal(value);
            //string c = amount.ToString(parameter as string, culture);
            //return c;
            return "category x";
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            //string amountString = value.ToString();
            //decimal amount = 0;
            //if (!decimal.TryParse(amountString, out amount))
            //    amount = 0;
            //return amount;
            return "WhatBack";
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\RulesBadgeAuthoring\Converters\RewardIdToNameConverter.cs ===
namespace RulesBadgeAuthoring.Converters
{
    using System;
    using System.Globalization;
    using System.Windows.Data;
    using RulesBadgeAuthoring.RewardsDataService;

    public class RewardIdToNameConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            Reward reward = value as Reward;
            //decimal amount = System.Convert.ToDecimal(value);
            //string c = amount.ToString(parameter as string, culture);
            //return c;
            if (parameter != null)
            {
                return reward.Name;
            }

            return reward.Description;
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            //string amountString = value.ToString();
            //decimal amount = 0;
            //if (!decimal.TryParse(amountString, out amount))
            //    amount = 0;
            //return amount;
            return "WhatBack";
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\RulesBadgeAuthoring\Converters\RewardIdToTypeConverter.cs ===
namespace RulesBadgeAuthoring.Converters
{
    using System;
    using System.Globalization;
    using System.Windows.Data;

    public class RewardIdToTypeConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            //decimal amount = System.Convert.ToDecimal(value);
            //string c = amount.ToString(parameter as string, culture);
            //return c;
            return "type 1";
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            //string amountString = value.ToString();
            //decimal amount = 0;
            //if (!decimal.TryParse(amountString, out amount))
            //    amount = 0;
            //return amount;
            return "converterBack";
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\RulesBadgeAuthoring\Model\Action.cs ===
namespace RulesBadgeAuthoring.RewardsDataService
{
    using System;
    using System.Linq;
    using RulesBadgeAuthoring.Model;


    public partial class Action : BaseEntity
    {
        partial void OnActionIDChanged() { FirePropertyChanged("ActionID"); }
        partial void OnDTModifiedChanged() { FirePropertyChanged("DTModified"); }
        partial void OnExecuteOrderChanged() { FirePropertyChanged("ExecuteOrder"); }

        internal bool HasInitialized { get; set; }
        internal bool IsModified { get; set; }
        internal bool IsCreated { get; set; }
        internal bool IsDeleted { get; set; }

        internal ActionParameterCollection ActionParameterList { get; set; }

        public event EventHandler<EventArgs> OnInitializeComplete;

        public void BeginInitialize()
        {
            if (this.ActionParameterList == null)
            {
                this.ActionParameterList = new ActionParameterCollection(RewardManager.ServiceContext);
            }

            // if our Action ID is 0, we cannot really initialize.
            if (this.HasInitialized || this.ActionID == 0)
            {
                this.OnInitializeComplete(this, null);
                return;
            }

            this.ActionParameterList.LoadComplete += new EventHandler(ActionParameterList_LoadComplete);
            this.ActionParameterList.LoadAsync(this.ActionID);
        }

        public ActionDefinition GetDefinition()
        {
            if (this.ActionDefinition != null && this.ActionDefinition.ActionDefinitionID != 0)
            {
                ActionDefinition actDefintion = (from actionDef in RewardManager.ActionDefinitionList
                                                 where actionDef.ActionDefinitionID == this.ActionDefinition.ActionDefinitionID
                                                 select actionDef).First<ActionDefinition>();
                return actDefintion;
            }

            return null;
        }

        public void CreateParameter(ActionParameter parameter)
        {
            parameter.Action = this;
            this.ActionParameterList.Add(parameter);
            this.IsModified = true;
        }

        public void UpdateParameter(ActionParameter param)
        {
            this.IsModified = true;
        }

        public void Commit()
        {
            // one of these 3 should exist
            if (!(this.IsModified || this.IsCreated || this.IsDeleted))
            {
                return;
            }

            if (this.IsDeleted)
            {
                this.CommitConstituents(true);
                this.ActionParameterList.Clear();

                if (!this.IsCreated)
                {
                    this.RemoveLinksAndDestroy();
                }

                return;
            }
            else if (this.IsCreated)
            {
                // construct
                RewardManager.ServiceContext.AddToAction(this);
            }
            else if (this.IsModified)
            {
                // modify
                RewardManager.ServiceContext.UpdateObject(this);
            }

            this.SetLinks();
            this.CommitConstituents(false);

            this.IsCreated = false;
            this.IsModified = false;
        }

        public void SetLinks()
        {
            // Set links
            this.SetLink("Rule", this.Rule);
            this.SetLink("ActionDefinition", ActionDefinition);
        }

        public void RemoveLinksAndDestroy()
        {
            //this.RemoveLink("Rule", this.Rule);
            //this.RemoveLink("ActionDefinition", this.ActionDefinition);
            
            this.DeleteSelf();
        }

        public void CommitConstituents(bool isDelete)
        {
            foreach (ActionParameter param in this.ActionParameterList)
            {
                param.IsDeleted = isDelete;
                param.Commit();
            }
        }

        void ActionParameterList_LoadComplete(object sender, EventArgs e)
        {
            this.HasInitialized = true;
            this.ActionParameterList.LoadComplete -= ActionParameterList_LoadComplete;
            this.OnInitializeComplete(this, null);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\RulesBadgeAuthoring\Model\ActionList.cs ===
namespace RulesBadgeAuthoring.Model
{
    using System.Linq;
    using RulesBadgeAuthoring.RewardsDataService;
    using System;

    public class ActionCollection : BaseList<RulesBadgeAuthoring.RewardsDataService.Action>
    {
        public ActionCollection(RewardsDBEntities context)
            : base(context)
        { }

        public void LoadAsync(int ruleId)
        {
            // Eager Loading
            using (DebugTextLogger.EnterFunction("ActionList::LoadAsync"))
            {
                try
                {
                    var query = from action in this.Context.Action.Expand("ActionDefinition").Expand("Rule")
                                where action.Rule.RuleID == ruleId
                                select action;

                    base.LoadAsync(query);
                }
                catch (Exception ex)
                {
                    DebugTextLogger.LogException(ex);
                    throw;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\RulesBadgeAuthoring\Model\ActionDefinitionList.cs ===
namespace RulesBadgeAuthoring.Model
{
    using System.Linq;
    using RulesBadgeAuthoring.RewardsDataService;
    using System;

    public class ActionDefinitionCollection : BaseList<ActionDefinition>
    {
        public ActionDefinitionCollection(RewardsDBEntities context)
            : base(context)
        { }

        public void LoadAsync()
        {
            // Eager Loading
            using (DebugTextLogger.EnterFunction("ActionDefinitionList::LoadAsync"))
            {
                try
                {
                    var query = from actionDef in this.Context.ActionDefinition.Expand("ActionParameterDefinition")
                                where actionDef.ActionDefinitionID > 0
                                select actionDef;
                    base.LoadAsync(query);
                }
                catch (Exception ex)
                {
                    DebugTextLogger.LogException(ex);
                    throw;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\RulesBadgeAuthoring\Model\ActionParameterDefinition.cs ===
namespace RulesBadgeAuthoring.RewardsDataService
{
    using System.ComponentModel;
    using RulesBadgeAuthoring.Model;

    public partial class ActionParameterDefinition : BaseEntity
    {
        partial void OnActionParameterDefinitionIDChanged() { FirePropertyChanged("ActionParameterDefinitionID"); }
        partial void OnCommentChanged() { FirePropertyChanged("Comment"); }
        partial void OnNameChanged() { FirePropertyChanged("Name"); }
        partial void OnParameterOrderChanged() { FirePropertyChanged("ParameterOrder"); }
        partial void OnPathRequiredChanged() { FirePropertyChanged("PathRequired"); }
        partial void OnValueRequiredChanged() { FirePropertyChanged("ValueRequired"); }
        partial void OnTypeChanged() { FirePropertyChanged("Type"); }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\RulesBadgeAuthoring\Model\ActionParameter.cs ===
namespace RulesBadgeAuthoring.RewardsDataService
{
    using System.ComponentModel;
    using RulesBadgeAuthoring.Model;
    using System;

    public partial class ActionParameter : BaseEntity
    {
        partial void OnActionParameterIDChanged() { FirePropertyChanged("ActionParameterID"); }
        partial void OnPathChanged() { FirePropertyChanged("PathChanged"); }
        partial void OnValueChanged() { FirePropertyChanged("ValueChanged"); }

        internal bool IsModified { get; set; }
        internal bool IsCreated { get; set; }
        internal bool IsDeleted { get; set; }

        public void Commit()
        {
            // one of these 3 should exist
            if (!(this.IsModified || this.IsCreated || this.IsDeleted))
            {
                return;
            }

            if (this.IsCreated && this.IsDeleted)
            {
                // do nothing
            }
            else if (this.IsDeleted)
            {
                //this.RemoveLink("Action", this.Action);
                //this.RemoveLink("ActionParameterDefinition", this.ActionParameterDefinition);
                this.DeleteSelf();
                return;
            }
            else if (this.IsCreated)
            {
                RewardManager.ServiceContext.AddToActionParameter(this);
            }
            else if (this.IsModified)
            {
                RewardManager.ServiceContext.UpdateObject(this);
            }

            // set links
            this.SetLink("Action", this.Action);
            this.SetLink("ActionParameterDefinition", this.ActionParameterDefinition);

            this.IsCreated = false;
            this.IsModified = false;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\RulesBadgeAuthoring\Model\ActionSetExecutionType.cs ===
namespace RulesBadgeAuthoring.RewardsDataService
{
    using System.ComponentModel;
    using System.Collections.Generic;
    using RulesBadgeAuthoring.Model;
    using System.Linq;

    public partial class ActionSetExecutionType : BaseEntity
    {
        partial void OnActionSetExecutionTypeIDChanged() { FirePropertyChanged("ActionSetExecutionTypeID"); }
        partial void OnExecutionTypeChanged() { FirePropertyChanged("ExecutionType"); }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\RulesBadgeAuthoring\Model\ActionParameterList.cs ===
namespace RulesBadgeAuthoring.Model
{
    using System.Linq;
    using RulesBadgeAuthoring.RewardsDataService;
    using System;

    public class ActionParameterCollection : BaseList<ActionParameter>
    {
        public ActionParameterCollection(RewardsDBEntities context)
            : base(context)
        { }

        public void LoadAsync(int actionId)
        {
            // Eager Loading
            using (DebugTextLogger.EnterFunction("ActionParameterList::LoadAsync"))
            {
                try
                {
                    var query = from actionParameter in this.Context.ActionParameter.Expand("ActionParameterDefinition").Expand("Action").Expand("ActionParameterDefinition/DataType")
                                where actionParameter.Action.ActionID == actionId
                                select actionParameter;
                    base.LoadAsync(query);
                }
                catch (Exception ex)
                {
                    DebugTextLogger.LogException(ex);
                    throw;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\RulesBadgeAuthoring\Model\ActionParameterDefinitionList.cs ===
namespace RulesBadgeAuthoring.Model
{
    using System.Linq;
    using RulesBadgeAuthoring.RewardsDataService;
    using System;

    public class ActionParameterDefinitionCollection : BaseList<ActionParameterDefinition>
    {
        public ActionParameterDefinitionCollection(RewardsDBEntities context)
            : base(context)
        { }

        public void LoadAsync()
        {
            // Eager Loading
            using (DebugTextLogger.EnterFunction("ActionParameterDefinitionList::LoadAsync"))
            {
                try
                {
                    var query = from actionPD in this.Context.ActionParameterDefinition.Expand("DataType")
                                where actionPD.ActionParameterDefinitionID > 0
                                select actionPD;
                    base.LoadAsync(query);
                }
                catch (Exception ex)
                {
                    DebugTextLogger.LogException(ex);
                    throw;
                }
            }
        }

        public void LoadAsync(int actionDefinitionId)
        {
            // Eager Loading
            using (DebugTextLogger.EnterFunction("ActionParameterDefinitionList::LoadAsync"))
            {
                try
                {
                    var query = from actionPD in this.Context.ActionParameterDefinition.Expand("DataType")
                                where actionPD.ActionDefinition.ActionDefinitionID == actionDefinitionId
                                select actionPD;
                    base.LoadAsync(query);
                }
                catch (Exception ex)
                {
                    DebugTextLogger.LogException(ex);
                    throw;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\RulesBadgeAuthoring\Model\BaseEntity.cs ===
namespace RulesBadgeAuthoring.Model
{
    using System.ComponentModel;

    public class BaseEntity : INotifyPropertyChanged
    {
        public event PropertyChangedEventHandler PropertyChanged;

        protected void FirePropertyChanged(string propertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            {
                handler(this, new PropertyChangedEventArgs(propertyName));
            }
        }

        public void SetLink(string sourceProperty, object linkTarget)
        {
            RewardManager.ServiceContext.SetLink(this, sourceProperty, linkTarget);
        }

        public void RemoveLink(string sourceProperty, object linkSource)
        {
            RewardManager.ServiceContext.DeleteLink(this, sourceProperty, linkSource);
        }

        public void DeleteSelf()
        {
            RewardManager.ServiceContext.DeleteObject(this);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\RulesBadgeAuthoring\Model\DataType.cs ===
namespace RulesBadgeAuthoring.RewardsDataService
{
    using System.ComponentModel;
    using RulesBadgeAuthoring.Model;

    public partial class DataType : BaseEntity
    {
        partial void OnDataTypeIDChanged() { FirePropertyChanged("DataTypeID"); }
        partial void OnDataTypeStringChanged() { FirePropertyChanged("DataTypeString"); }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\RulesBadgeAuthoring\Model\DataTypeList.cs ===
namespace RulesBadgeAuthoring.Model
{
    using System.Linq;
    using RulesBadgeAuthoring.RewardsDataService;
    using System;

    public class DataTypeCollection : BaseList<DataType>
    {
        public DataTypeCollection(RewardsDBEntities context)
            : base(context)
        { }

        public void LoadAsync()
        {
            // Eager Loading
            using (DebugTextLogger.EnterFunction("DataTypeList::LoadAsync"))
            {
                try
                {
                    var query = from dataType in this.Context.DataType
                                orderby dataType.DataTypeID
                                where dataType.DataTypeID > 0
                                select dataType;
                    base.LoadAsync(query);
                }
                catch (Exception ex)
                {
                    DebugTextLogger.LogException(ex);
                    throw;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\RulesBadgeAuthoring\Model\GameSchemaProperties.cs ===
namespace RulesBadgeAuthoring.RewardsDataService
{
    using System.ComponentModel;
    using RulesBadgeAuthoring.Model;

    public partial class GameSchemaProperties : BaseEntity
    {
        partial void OnCommentChanged() { FirePropertyChanged("Comment"); }
        partial void OnDTModifiedChanged() { FirePropertyChanged("DTModified"); }
        partial void OnGameSchemaPropertyIDChanged() { FirePropertyChanged("GameSchemaPropertyID"); }
        partial void OnNameChanged() { FirePropertyChanged("Name"); }
        partial void OnOrderChanged() { FirePropertyChanged("Order"); }
        partial void OnRequiredChanged() { FirePropertyChanged("Required"); }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\RulesBadgeAuthoring\Model\BaseList.cs ===
namespace RulesBadgeAuthoring
{
    using System;
    using System.Collections.Generic;
    using System.Collections.ObjectModel;
    using System.ComponentModel;
    using System.Data.Services.Client;
    using System.Diagnostics;
    using System.Linq;
    using RulesBadgeAuthoring.RewardsDataService;
    using RulesBadgeAuthoring.Model;

    public abstract class BaseList<T> : ObservableCollection<T> 
        where T : BaseEntity
    {
        public event EventHandler LoadComplete;
        public event EventHandler<SaveDataEventArgs> SaveComplete;

        protected RewardsDBEntities Context { get; set; }

        protected BaseList()
        {
        }

        public BaseList(RewardsDBEntities context)
        {
            this.Context = context;
        }

        protected void entity_PropertyChanged(object sender, PropertyChangedEventArgs e)
        {
            T entity = (T)sender;
            Context.UpdateObject(entity);
        }

        protected void LoadAsync(IQueryable<T> query)
        {
            this.Clear(); // Clear the list, since we are reloading. Even if we fail, we want it cleared.
            DataServiceQuery<T> dataServiceQuery = (DataServiceQuery<T>)query;
            dataServiceQuery.BeginExecute(new AsyncCallback(OnLoadComplete), dataServiceQuery);
        }

        protected void OnLoadComplete(IAsyncResult result)
        {
            DataServiceQuery<T> query = (DataServiceQuery<T>)result.AsyncState;
            try
            {
                List<T> entities = query.EndExecute(result).ToList();
                foreach (T item in entities)
                {
                    item.PropertyChanged += entity_PropertyChanged;
                    this.Add(item);
                }
            }
            catch (Exception ex)
            {
                DebugTextLogger.LogException(ex);
                throw;
            }

            if (LoadComplete != null)
            {
                LoadComplete(this, new EventArgs());
            }
        }

        protected void OnSaveComplete(IAsyncResult result)
        {
            bool succeeded = true;
            try
            {
                DataServiceResponse response = (DataServiceResponse)Context.EndSaveChanges(result);

                foreach (OperationResponse opResponse in response)
                {
                    if (opResponse.Error != null)
                    {
                        DebugTextLogger.Log("Failed to save data: {0}", opResponse.StatusCode);
                        succeeded = false;
                    }
                }
            }
            catch (Exception ex)
            {
                DebugTextLogger.LogException(ex);
                succeeded = false;
            }

            if (SaveComplete != null)
            {
                SaveComplete(this, new SaveDataEventArgs { Succeeded = succeeded });
            }
        }

        public virtual void SaveAsync()
        {
            Context.BeginSaveChanges(SaveChangesOptions.Batch, new AsyncCallback(OnSaveComplete), null);
        }

        protected void LoadAsync(IQueryable<Collection<T>> query)
        {
            this.Clear(); // Clear the list, since we are reloading. Even if we fail, we want it cleared.
            DataServiceQuery<Collection<T>> dataServiceQuery = (DataServiceQuery<Collection<T>>)query;
            dataServiceQuery.BeginExecute(new AsyncCallback(OnLoadComplete), dataServiceQuery);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\RulesBadgeAuthoring\Model\ActionSetExecutionTypeList.cs ===
namespace RulesBadgeAuthoring.Model
{
    using System.Linq;
    using RulesBadgeAuthoring.RewardsDataService;
    using System;

    public class ActionSetExecutionTypeCollection : BaseList<ActionSetExecutionType>
    {
        public ActionSetExecutionTypeCollection(RewardsDBEntities context)
            : base(context)
        { }

        public void LoadAsync()
        {
            // Eager Loading
            using (DebugTextLogger.EnterFunction("ActionSetExecutionTypeList::LoadAsync"))
            {
                try
                {
                    var query = from actionSetExecutionType in this.Context.ActionSetExecutionType
                                where actionSetExecutionType.ActionSetExecutionTypeID > 0
                                select actionSetExecutionType;
                    base.LoadAsync(query);
                }
                catch (Exception ex)
                {
                    DebugTextLogger.LogException(ex);
                    throw;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\RulesBadgeAuthoring\Model\GameKeyList.cs ===
namespace RulesBadgeAuthoring.Model
{
    using System.Linq;
    using RulesBadgeAuthoring.RewardsDataService;
    using System;

    public class GameKeyCollection : BaseList<GameKeys>
    {
        public GameKeyCollection(RewardsDBEntities context)
            : base(context)
        { }

        public void LoadAsync()
        {
            // Eager Loading
            using (DebugTextLogger.EnterFunction("GameKeyList::LoadAsync"))
            {
                try
                {
                    var query = from gameKey in this.Context.GameKeys
                                orderby gameKey.GameKeyID
                                where gameKey.GameKeyID > 0
                                select gameKey;
                    base.LoadAsync(query);
                }
                catch (Exception ex)
                {
                    DebugTextLogger.LogException(ex);
                    throw;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\RulesBadgeAuthoring\Model\GameKeys.cs ===
namespace RulesBadgeAuthoring.RewardsDataService
{
    using System.ComponentModel;
    using RulesBadgeAuthoring.Model;
using System;

    public partial class GameKeys : BaseEntity
    {
        partial void OnCommentChanged() { FirePropertyChanged("Comment"); }
        partial void OnGameKeyIDChanged() { FirePropertyChanged("GameKeyID"); }
        partial void OnNameChanged() { FirePropertyChanged("Name"); }
        partial void OnDTModifiedChanged() { FirePropertyChanged("DTModified"); }

        internal event EventHandler<EventArgs> OnInitializeComplete;

        internal GameSchemaPropertiesCollection PropertiesList { get; set; }
        internal StatDescriptionCollection StatList { get; set; }

        internal bool HasInitialized { get; private set; }


        internal void BeginInitialize()
        {
            if (!this.HasInitialized)
            {
                if (this.PropertiesList == null)
                {
                    this.PropertiesList = new GameSchemaPropertiesCollection(RewardManager.ServiceContext);
                    this.PropertiesList.LoadComplete += new EventHandler(LoadSequencer);
                    this.PropertiesList.LoadAsync(this.GameKeyID);
                    return;
                }
                else if (this.StatList == null)
                {
                    loadSequence++;

                    this.StatList = new StatDescriptionCollection(RewardManager.ServiceContext);
                    this.StatList.LoadComplete += new EventHandler(LoadSequencer);
                    this.StatList.LoadAsync(this.GameKeyID);
                    return;
                }
                else
                {
                    this.HasInitialized = true;
                }
            }
            
            if (this.HasInitialized)
            {
                this.FireInitializeComplete();
            }
        }

        private void FireInitializeComplete()
        {
            EventHandler<EventArgs> temp = this.OnInitializeComplete;
            if (temp != null)
            {
                temp(null, null);
            }
        }

        private int loadSequence = 0;
        void LoadSequencer(object sender, EventArgs e)
        {
            loadSequence++;

            switch (loadSequence)
            {
                case 1:
                    this.PropertiesList.LoadComplete -= LoadSequencer;

                    if (this.StatList == null)
                    {
                        this.StatList = new StatDescriptionCollection(RewardManager.ServiceContext);
                        this.StatList.LoadComplete += new EventHandler(LoadSequencer);
                        this.StatList.LoadAsync(this.GameKeyID);
                    }
                    else
                    {
                        this.HasInitialized = true;
                    }

                    break;

                case 2:
                    this.StatList.LoadComplete -= LoadSequencer;
                    this.HasInitialized = true;
                    break;

                default:
                    throw new InvalidOperationException();
            }

            if (this.HasInitialized)
            {
                this.FireInitializeComplete();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\RulesBadgeAuthoring\Model\Locale.cs ===
namespace RulesBadgeAuthoring.RewardsDataService
{
    using System.ComponentModel;
    using RulesBadgeAuthoring.Model;

    public partial class Locale : BaseEntity
    {
        partial void OnCollationChanged() { FirePropertyChanged("Collation"); }
        partial void OnDTModifiedChanged() { FirePropertyChanged("DTModified"); }
        partial void OnLCIDChanged() { FirePropertyChanged("LCID"); }
        partial void OnLocale1Changed() { FirePropertyChanged("Locale1"); }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\RulesBadgeAuthoring\Model\PlatformsList.cs ===
namespace RulesBadgeAuthoring.Model
{
    using System.Linq;
    using RulesBadgeAuthoring.RewardsDataService;
    using System;

    public class PlatformsCollection : BaseList<Platforms>
    {
        public PlatformsCollection(RewardsDBEntities context)
            : base(context)
        { }

        public void LoadAsync()
        {
            // Eager Loading
            using (DebugTextLogger.EnterFunction("PlatformsList::LoadAsync"))
            {
                try
                {
                    var query = from platforms in this.Context.Platforms
                                where platforms.PlatformID > 0
                                select platforms;
                    base.LoadAsync(query);
                }
                catch (Exception ex)
                {
                    DebugTextLogger.LogException(ex);
                    throw;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\RulesBadgeAuthoring\Model\RewardCategory.cs ===
namespace RulesBadgeAuthoring.RewardsDataService
{
    using System.ComponentModel;
    using RulesBadgeAuthoring.Model;

    public partial class RewardCategory : BaseEntity
    {
        partial void OnRewardCategoryIDChanged() { FirePropertyChanged("RewardCategoryID"); }
        partial void OnRewardCategoryNameChanged() { FirePropertyChanged("RewardCategoryName"); }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\RulesBadgeAuthoring\Model\Platforms.cs ===
namespace RulesBadgeAuthoring.RewardsDataService
{
    using System.ComponentModel;
    using RulesBadgeAuthoring.Model;

    public partial class Platforms : BaseEntity
    {
        partial void OnCommentChanged() { FirePropertyChanged("Comment"); }
        partial void OnNameChanged() { FirePropertyChanged("Name"); }
        partial void OnPlatformIDChanged() { FirePropertyChanged("PlatformID"); }
        partial void OnDTModifiedChanged() { FirePropertyChanged("DTModified"); }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\RulesBadgeAuthoring\Model\GameSchemaPropertiesList.cs ===
namespace RulesBadgeAuthoring.Model
{
    using System.Linq;
    using RulesBadgeAuthoring.RewardsDataService;
    using System;

    public class GameSchemaPropertiesCollection : BaseList<GameSchemaProperties>
    {
        public GameSchemaPropertiesCollection(RewardsDBEntities context)
            : base(context)
        { }

        public void LoadAsync(int gameKeyId)
        {
            // Eager Loading
            using (DebugTextLogger.EnterFunction("GameSchemaPropertiesList::LoadAsync"))
            {
                try
                {
                    var query = from gameSchemaProperties in this.Context.GameSchemaProperties
                                where gameSchemaProperties.GameSchemaNames.GameKeys.GameKeyID == gameKeyId
                                select gameSchemaProperties;
                    base.LoadAsync(query);
                }
                catch (Exception ex)
                {
                    DebugTextLogger.LogException(ex);
                    throw;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\RulesBadgeAuthoring\Model\LocaleList.cs ===
namespace RulesBadgeAuthoring.Model
{
    using System.Linq;
    using RulesBadgeAuthoring.RewardsDataService;
    using System;

    public class LocaleCollection : BaseList<Locale>
    {
        public LocaleCollection(RewardsDBEntities context)
            : base(context)
        { }

        public void LoadAsync()
        {
            // Eager Loading
            using (DebugTextLogger.EnterFunction("LocaleList::LoadAsync"))
            {
                try
                {
                    var query = from locale in this.Context.Locale
                                orderby locale.LCID
                                where locale.LCID > 0
                                select locale;
                    base.LoadAsync(query);
                }
                catch (Exception ex)
                {
                    DebugTextLogger.LogException(ex);
                    throw;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\RulesBadgeAuthoring\Model\Reward.cs ===
namespace RulesBadgeAuthoring.RewardsDataService
{
    using System.ComponentModel;
    using RulesBadgeAuthoring.Model;

    public partial class Reward : BaseEntity
    {
        partial void OnRewardIDChanged() { FirePropertyChanged("RewardID"); }
        partial void OnRewardValueChanged() { FirePropertyChanged("RewardValue"); }
        partial void OnCommentChanged() { FirePropertyChanged("Comment"); }
        partial void OnDTStartChanged() { FirePropertyChanged("DTStart"); }
        partial void OnDTEndChanged() { FirePropertyChanged("DTEnd"); }
        partial void OnDTCreatedChanged() { FirePropertyChanged("DTCreated"); }
        partial void OnDTModifiedChanged() { FirePropertyChanged("DTModified"); }
        //partial void OnGameKeyChanged() { FirePropertyChanged("GameKey"); }
        private void OnNameChanged() { FirePropertyChanged("Name"); }
        private void OnDescriptionChanged() { FirePropertyChanged("Description"); }

        // TODO: Update schema to have a locale independent Name and Description 
        public RewardLocaleCollection RewardLocaleList { get; private set; }

        [DoNotSerialize]
        internal bool InvalidateLocale { get; set; }


        [DoNotSerialize]
        public string Name 
        {
            get
            {
                if (this.RewardLocale.Count > 0)
                {
                    return this.RewardLocale[0].LocRewardName;
                }

                return string.Empty;
            }
        }

        [DoNotSerialize]
        public string Description 
        {
            get
            {
                if (this.RewardLocale.Count > 0)
                {
                    return this.RewardLocale[0].LocRewardDescription;
                }

                return string.Empty;
            }
        }

        private void FetchRewardLocale()
        {
            if (this.RewardLocaleList == null || this.RewardID == 0 || this.InvalidateLocale)
            {
                this.InvalidateLocale = false;
                //this.RewardLocaleList = new RewardLocaleList(RewardManager.ServiceContext);
                //this.RewardLocaleList.LoadComplete += new System.EventHandler(RewardLocaleList_LoadComplete);
                //this.RewardLocaleList.LoadAsync(this.RewardID);
            }
        }

        void RewardLocaleList_LoadComplete(object sender, System.EventArgs e)
        {
            if (this.RewardLocaleList.Count > 0)
            {
                //this.name = this.RewardLocaleList[0].LocRewardName;
                //this.description = this.RewardLocaleList[0].LocRewardDescription;
                this.OnNameChanged();
                this.OnDescriptionChanged();
            }
        }


        public void UpdateAllFields()
        {
            this.OnRewardValueChanged();
            this.OnCommentChanged();
            this.OnDTStartChanged();
            this.OnDTEndChanged();
            this.OnDTCreatedChanged();
            this.OnDTModifiedChanged();
            //this.OnGameKeyChanged();
            this.OnNameChanged();
            this.OnDescriptionChanged();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\RulesBadgeAuthoring\Model\RewardList.cs ===
namespace RulesBadgeAuthoring.Model
{
    using System.Linq;
    using RulesBadgeAuthoring.RewardsDataService;
    using System;

    public class RewardCollection : BaseList<Reward>
    {
        public RewardCollection(RewardsDBEntities context)
            : base(context)
        {}

        public void LoadAsync()
        {
            // Eager Loading
            using (DebugTextLogger.EnterFunction("RewardList::LoadAsync"))
            {
                try
                {
                    // TODO: we are doing eager loading here, maybe we should consider lazy loading.
                    var query = from reward in this.Context.Reward.Expand("RewardLocale").Expand("RewardType").Expand("RewardCategory")
                                where reward.RewardID > 0
                                select reward;
                    base.LoadAsync(query);
                }
                catch (Exception ex)
                {
                    DebugTextLogger.LogException(ex);
                    throw;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\RulesBadgeAuthoring\Model\RewardType.cs ===
namespace RulesBadgeAuthoring.RewardsDataService
{
    using System.ComponentModel;
    using RulesBadgeAuthoring.Model;

    public partial class RewardType : BaseEntity
    {
        partial void OnRewardTypeIDChanged() { FirePropertyChanged("RewardTypeID"); }
        partial void OnRewardTypeNameChanged() { FirePropertyChanged("RewardTypeName"); }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\RulesBadgeAuthoring\Model\RewardLocale.cs ===
namespace RulesBadgeAuthoring.RewardsDataService
{
    using System.ComponentModel;
    using RulesBadgeAuthoring.Model;

    public partial class RewardLocale : BaseEntity
    {
        partial void OnDTModifiedChanged() { FirePropertyChanged("DTModified"); }
        partial void OnLocRewardDescriptionChanged() { FirePropertyChanged("LocRewardDescription"); }
        partial void OnLocRewardNameChanged() { FirePropertyChanged("LocRewardName"); }
        partial void OnRewardLocaleIDChanged() { FirePropertyChanged("RewardLocaleID"); }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\RulesBadgeAuthoring\Model\RewardLocaleList.cs ===
namespace RulesBadgeAuthoring.Model
{
    using System.Linq;
    using RulesBadgeAuthoring.RewardsDataService;
    using System;

    public class RewardLocaleCollection : BaseList<RewardLocale>
    {
        public RewardLocaleCollection(RewardsDBEntities context)
            : base(context)
        { }

        public void LoadAsync(int rewardId)
        {
            // Eager Loading
            using (DebugTextLogger.EnterFunction("RewardList::LoadAsync"))
            {
                try
                {
                    var query = from rewardLocale in this.Context.RewardLocale.Expand("Reward")
                                where rewardLocale.Reward.RewardID == rewardId
                                select rewardLocale;
                    base.LoadAsync(query);
                }
                catch (Exception ex)
                {
                    DebugTextLogger.LogException(ex);
                    throw;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\RulesBadgeAuthoring\Model\RewardCategoryList.cs ===
namespace RulesBadgeAuthoring.Model
{
    using System.Linq;
    using RulesBadgeAuthoring.RewardsDataService;
    using System;

    public class RewardCategoryCollection : BaseList<RewardCategory>
    {
        public RewardCategoryCollection(RewardsDBEntities context)
            : base(context)
        { }

        public void LoadAsync()
        {
            // Eager Loading
            using (DebugTextLogger.EnterFunction("LocaleList::LoadAsync"))
            {
                try
                {
                    var query = from rewardCategory in this.Context.RewardCategory
                                orderby rewardCategory.RewardCategoryID
                                where rewardCategory.RewardCategoryID > 0
                                select rewardCategory;
                    base.LoadAsync(query);
                }
                catch (Exception ex)
                {
                    DebugTextLogger.LogException(ex);
                    throw;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\RulesBadgeAuthoring\Model\RewardTypeList.cs ===
namespace RulesBadgeAuthoring.Model
{
    using System.Linq;
    using RulesBadgeAuthoring.RewardsDataService;
    using System;

    public class RewardTypeCollection : BaseList<RewardType>
    {
        public RewardTypeCollection(RewardsDBEntities context)
            : base(context)
        { }

        public void LoadAsync()
        {
            // Eager Loading
            using (DebugTextLogger.EnterFunction("LocaleList::LoadAsync"))
            {
                try
                {
                    var query = from rewardType in this.Context.RewardType
                                orderby rewardType.RewardTypeID
                                where rewardType.RewardTypeID > 0
                                select rewardType;
                    base.LoadAsync(query);
                }
                catch (Exception ex)
                {
                    DebugTextLogger.LogException(ex);
                    throw;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\RulesBadgeAuthoring\Model\Rule.cs ===
namespace RulesBadgeAuthoring.RewardsDataService
{
    using System.ComponentModel;
    using System.Collections.Generic;
    using RulesBadgeAuthoring.Model;
    using System.Linq;
    using System;
    using System.Windows;

    public enum RuleInitializationSequence
    {
        LoadStart = 0,
        ExpressionListLoad = 1,
        ActionListLoad = 2,
        GameKeyLoad = 3,
        LoadComplete,
        ActionListItemsLoad,
        GameKeyItemLoad,
        Invalid
    }

    public partial class Rule : BaseEntity
    {
        partial void OnCommentChanged() { FirePropertyChanged("Comment"); }
        partial void OnDTCreatedChanged() { FirePropertyChanged("DTCreated"); }
        partial void OnDTStartChanged() { FirePropertyChanged("DTStart"); }
        partial void OnDTEndChanged() { FirePropertyChanged("DTEnd"); }
        partial void OnDTModifiedChanged() { FirePropertyChanged("DTModified"); }
        partial void OnRuleIDChanged() { FirePropertyChanged("RuleID"); }

        /// <summary>
        /// ExpressionList is an amalgamation of all existing and (pending) created expressions
        /// </summary>
        public RuleExpressionCollection ExpressionList { get; private set; }
        public ActionCollection ActionList { get; private set; }

        private ActionCollection DeletedActionList { get; set; }
        private RuleExpressionCollection DeletedExpressionList { get; set; }


        public event EventHandler<EventArgs> OnInitializationComplete;
        public event EventHandler<EventArgs> OnExpressionModified;
        public event EventHandler<EventArgs> OnActionModified;

        private event EventHandler<EventArgs> OnAllActionsInitialized;


        //internal ICollection<RuleExpression> UpdatedExpressions
        //{
        //    get
        //    {
        //        return this.UpdateExpressionList;
        //    }
        //}

        internal bool IsModified { get; set; }
        internal bool IsCreated { get; set; }
        internal bool IsDeleted { get; set; }
        internal bool HasInitialized { get; private set; }

        private RuleInitializationSequence currentFullInitSequence = RuleInitializationSequence.LoadStart;
        public void BeginFullInitialize()
        {
            this.InitializeLists();

            if (this.HasInitialized)
            {
                this.FireOnInitialize();
                return;
            }

            this.currentFullInitSequence = RuleInitializationSequence.ExpressionListLoad;
            this.FullSequenceLoading(null, null);
        }

        private void FullSequenceLoading(object sender, EventArgs e)
        {
            switch (this.currentFullInitSequence)
            {
                case RuleInitializationSequence.ExpressionListLoad:
                    this.currentFullInitSequence = RuleInitializationSequence.GameKeyLoad;
                    this.ExpressionList.LoadComplete += new EventHandler(FullSequenceLoading);
                    this.ExpressionList.LoadAsync(this.RuleID);
                    break;

                case RuleInitializationSequence.GameKeyLoad:
                    this.currentFullInitSequence = RuleInitializationSequence.GameKeyItemLoad;
                    this.ExpressionList.LoadComplete -= FullSequenceLoading;
                    GameKeys game = this.GetGameKey();
                    game.OnInitializeComplete += new EventHandler<EventArgs>(FullSequenceLoading);
                    game.BeginInitialize();
                    break;

                case RuleInitializationSequence.GameKeyItemLoad:
                    this.currentFullInitSequence = RuleInitializationSequence.ActionListLoad;
                    this.GetGameKey().OnInitializeComplete -= FullSequenceLoading;
                    this.ActionList.LoadComplete += new EventHandler(FullSequenceLoading);
                    this.ActionList.LoadAsync(this.RuleID);
                    break;

                case RuleInitializationSequence.ActionListLoad:
                    this.currentFullInitSequence = RuleInitializationSequence.ActionListItemsLoad;
                    this.ActionList.LoadComplete -= FullSequenceLoading;
                    this.FullSequenceLoading(null, null);
                    break;

                case RuleInitializationSequence.ActionListItemsLoad:
                    this.currentFullInitSequence = RuleInitializationSequence.LoadComplete;
                    this.OnAllActionsInitialized += new EventHandler<EventArgs>(FullSequenceLoading);
                    this.BeginAllActionInitialize();
                    break;

                case RuleInitializationSequence.LoadComplete:
                    this.currentFullInitSequence = RuleInitializationSequence.Invalid;
                    this.OnAllActionsInitialized -= FullSequenceLoading;
                    this.HasInitialized = true;
                    this.FireOnInitialize();
                    break;

                default:
                    throw new InvalidOperationException();
            }
        }

        int actionLoadCurrentIndex;
        private void BeginAllActionInitialize()
        {
            this.RuleAction_OnInitializeComplete(null, null);
        }

        // initialize ALL the expressions.
        void RuleAction_OnInitializeComplete(object sender, EventArgs e)
        {
            ActionCollection actList = this.ActionList;

            Action previousAction = sender as Action;
            if (previousAction != null)
            {
                previousAction.OnInitializeComplete -= RuleAction_OnInitializeComplete;
            }

            int currentIndex = this.actionLoadCurrentIndex++;
            if (currentIndex < actList.Count)
            {
                actList[currentIndex].OnInitializeComplete += new EventHandler<EventArgs>(RuleAction_OnInitializeComplete);
                actList[currentIndex].BeginInitialize();
            }
            else // end of sequence, go back to sequenced Loading
            {
                this.FireOnAllActionInitialized(null);
            }
        }


        private void InitializeLists()
        {
            if (this.ExpressionList == null)
            {
                this.ExpressionList = new RuleExpressionCollection(RewardManager.ServiceContext);
            }

            if (this.ActionList == null)
            {
                this.ActionList = new ActionCollection(RewardManager.ServiceContext);
            }

            if (this.DeletedActionList == null)
            {
                this.DeletedActionList = new ActionCollection(null);
            }

            if (this.DeletedExpressionList == null)
            {
                this.DeletedExpressionList = new RuleExpressionCollection(null);
            }
        }

        /// <summary>
        /// Ensure that that the RuleExpression Collection is converted into the 
        /// Observable ExpressionList
        /// BUG BUG: On created and commit Rules, we may not have the most accurate expression list. :(
        /// The method here, would probably be to invalidate the Rule List completely upon creating a rule.
        /// And re-enumerating.
        /// </summary>
        public void BeginInitialize()
        {
            if (!this.HasInitialized)
            {
                this.InitializeLists();

                currentLoadSequence = 0;

                // BUG BUG:
                if (this.IsCreated && this.GetGameKey() == null)
                {
                    this.DTCreated = DateTime.UtcNow;
                    this.DTModified = DateTime.UtcNow;

                    //
                    // on creation we are in this weird state w/ no game key associated yet.
                    // without a gameKey and/or RuleID we cannot completely initialize.
                    //
                    this.FireOnInitialize();
                }
                else
                {
                    // we can only initialize gameKey and nothing else. :-(
                    if (this.RuleID == 0)
                    {
                        this.currentLoadSequence = (int)RuleInitializationSequence.ActionListLoad;
                    }

                    SequencedLoader(null, null);
                }
            }
            else
            {
                this.FireOnInitialize();
            }
        }

        private int currentLoadSequence = (int)RuleInitializationSequence.LoadStart;

        void SequencedLoader(object sender, EventArgs e)
        {
            currentLoadSequence++;

            switch ((RuleInitializationSequence)currentLoadSequence)
            {
                case RuleInitializationSequence.ExpressionListLoad:
                    this.ExpressionList.LoadComplete += new EventHandler(SequencedLoader);
                    this.ExpressionList.LoadAsync(this.RuleID);
                    break;

                case RuleInitializationSequence.ActionListLoad:
                    this.ExpressionList.LoadComplete -= SequencedLoader;
                    // we do a round-trip to ActionListLoader and come back here,
                    // continuing at GameKeyLoad.
                    this.ActionList.LoadComplete += new EventHandler(SequencedLoader);
                    this.ActionList.LoadAsync(this.RuleID);
                    break;

                case RuleInitializationSequence.GameKeyLoad:
                    this.ActionList.LoadComplete -= SequencedLoader;

                    // Initialize GameKey's sub-fields.
                    GameKeys game = this.GetGameKey();
                    if (game != null)
                    {
                        game.OnInitializeComplete += new EventHandler<EventArgs>(SequencedLoader);
                        game.BeginInitialize();
                    }
                    else
                    {
                        this.HasInitialized = true;
                    }

                    break;

                case RuleInitializationSequence.LoadComplete:
                    if (this.GetGameKey() != null)
                    {
                        this.GetGameKey().OnInitializeComplete -= SequencedLoader;
                    }

                    this.HasInitialized = true;
                    break;

                default:
                    throw new InvalidOperationException();
            }

            if (this.HasInitialized)
            {
                this.currentLoadSequence = 0;
                this.FireOnInitialize();
            }
        }

        // Until commited store the created expressions in the 
        public void InsertCreatedExpression(RuleExpression expression)
        {
            //if (this.ExpressionList == null)
            //{
            //    this.ExpressionList = new RuleExpressionList(RewardManager.ServiceContext);
            //}

            this.ExpressionList.Add(expression);
            this.IsModified = true;

            this.OnExpressionModified(expression, null);
        }

        public void UpdateCreatedExpression(RuleExpression update)
        {
            this.IsModified = true;
            this.OnExpressionModified(update, null);
        }

        public void InsertCreatedAction(Action action)
        {
            if (!this.ActionList.Contains(action))
            {
                this.ActionList.Add(action);
            }
            
            this.IsModified = true;
            this.OnActionModified(action, null);
        }

        //TODO:
        // we need to make sure delete operations are also handled
        // and IsModified is also updated accordingly.

        /// <summary>
        /// Commit any changes and updates.
        /// BUG BUG: There is no exception/unwinding, any exception will foobar the state.
        /// </summary>
        public void Commit()
        {
            // one of these 3 should exist
            if (!(this.IsModified || this.IsCreated || this.IsDeleted))
            {
                throw new InvalidOperationException();
            }

            //
            // first delete any marked for deletion entries.
            //
            while (this.DeletedActionList.Count > 0)
            {
                Action action = this.DeletedActionList[0];
                this.DeletedActionList.RemoveAt(0);
                action.Commit();
            }

            while (this.DeletedExpressionList.Count > 0)
            {
                RuleExpression expression = this.DeletedExpressionList[0];
                this.DeletedExpressionList.RemoveAt(0);
                expression.Commit();
            }

            if (this.IsDeleted)
            {
                this.CommitConstituents(true);
                this.ExpressionList.Clear();
                this.ActionList.Clear();

                if (!this.IsCreated)
                {
                    this.RemoveLinksAndDestroy();
                }

                return;
            }
            if (this.IsCreated)
            {
                RewardManager.ServiceContext.AddToRule(this);
                
            }
            else if (this.IsModified)
            {
                RewardManager.ServiceContext.UpdateObject(this); // TODO: this might be happening behind our back, verify.
            }

            this.SetLinks();
            this.CommitConstituents(false);

            this.IsCreated = false;
            this.IsModified = false;
        }

        internal void CommitConstituents(bool isDelete)
        {
            foreach (RuleExpression expression in this.ExpressionList)
            {
                expression.IsDeleted = isDelete;
                expression.Commit(); // object itself will determine if there is need for it.
            }

            foreach (Action action in this.ActionList)
            {
                action.IsDeleted = isDelete;
                action.Commit();
            }
        }

        internal void SetLinks()
        {
            //this.SetLink("GameKeys", this.GetGameKey());
            this.SetLink("ActionSetExecutionType", this.ActionSetExecutionType);
            if (this.Reward != null)
            {
                this.SetLink("Reward", this.Reward);
            }

            var activeStatus = (from statuses  in RewardManager.StatusList
                                where statuses.StatusName == "Active"
                                select statuses).First<Status>();
            this.SetLink("Status", activeStatus);
        }

        internal void RemoveLinksAndDestroy()
        {
            //this.RemoveLink("GameKeys", this.GetGameKey());
            //this.RemoveLink("ActionSetExecutionType", this.ActionSetExecutionType);
            if (this.Reward != null)
            {
                //this.RemoveLink("Reward", this.Reward);
            }

            this.DeleteSelf();
        }



        // traverse the entire list of RuleExpressions to find the GameKey.
        internal GameKeys GetGameKey()
        {
            if (this.ExpressionList != null && this.ExpressionList.Count > 0)
            {

                foreach (RuleExpression rre in this.ExpressionList)
                {
                    if (rre.LeftOperand.Contains("GameKey"))
                    {
                        string gameKey = rre.RightOperand;

                        var games = (from game in RewardManager.GameKeyList
                                     where game.GameKeyID == int.Parse(gameKey)
                                     select game).First<GameKeys>();

                        return games;
                    }
                }
            }

            return null;
        }

        // if we have a valid GameKey or a statement with a valid /Event/GameKey then TRUE
        internal bool HasValidGameKey()
        {
            if (this.GetGameKey() != null)
            {
                return true;
            }

            return false;
        }
        
        internal void DeleteExpression(RuleExpression expressionToDelete)
        {
            // make sure expression is not a GameKey expression
            if (expressionToDelete.LeftOperand.Contains("GameKey"))
            {
                MessageBox.Show("GameKey statement cannot be deleted, try deleting the entire Rule", "OPS!", MessageBoxButton.OK);
                return;
            }

            this.IsModified = true;

            expressionToDelete.IsDeleted = true;
            expressionToDelete.IsModified = true;

            // for only previously existing actions (e.g. commited = !IsCreated) 
            // add it to the deleted actions list, which will get cleaned up in commit.
            if (!expressionToDelete.IsCreated)
            {
                this.DeletedExpressionList.Add(expressionToDelete);
            }

            // Remove from list and forget about it. As it is uncommitted 
            this.ExpressionList.Remove(expressionToDelete);

            this.OnExpressionModified(expressionToDelete, null);
        }

        internal void DeleteAction(Action actionToDelete)
        {
            this.IsModified = true;

            actionToDelete.OnInitializeComplete += new EventHandler<EventArgs>(actionToDelete_OnInitializeComplete);
            actionToDelete.BeginInitialize();
        }

        void actionToDelete_OnInitializeComplete(object sender, EventArgs e)
        {
            Action actionToDelete = sender as Action;

            actionToDelete.OnInitializeComplete -= actionToDelete_OnInitializeComplete;

            actionToDelete.IsDeleted = true;
            actionToDelete.IsModified = true;

            // for only previously existing actions (e.g. commited = !IsCreated) 
            // add it to the deleted actions list, which will get cleaned up in commit.
            if (!actionToDelete.IsCreated)
            {
                this.DeletedActionList.Add(actionToDelete);
            }

            // Remove from list and forget about it. :-)
            this.ActionList.Remove(actionToDelete);
            this.OnActionModified(actionToDelete, null);
        }

        private void FireOnInitialize()
        {
            EventHandler<EventArgs> temp = this.OnInitializationComplete;
            if (temp != null)
            {
                temp(this, null);
            }
        }

        private void FireOnAllActionInitialized(Action action)
        {
            EventHandler<EventArgs> temp = this.OnAllActionsInitialized;
            if (temp != null)
            {
                temp(action, null);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\RulesBadgeAuthoring\Model\RewardManager.cs ===
namespace RulesBadgeAuthoring
{
    using System;
    using System.Data.Services.Client;
    using System.Data.Services.Common;
    using System.Reflection;
    using System.Linq;
    using System.Xml.Linq;
    using RulesBadgeAuthoring.Model;
    using RulesBadgeAuthoring.RewardsDataService;

    public enum LoadSequenceEnum
    {
        LoadOperator                = 1,
        LoadOperandType,            //2
        LoadGameKey,                //3
        LoadDataType,               //4
        LoadRewardType,             //5
        LoadRewardCategory,         //6
        LoadLocale,                 //7
        LoadActionSetExecutionType, //8
        LoadPlatforms,              //9
        LoadActionParamDef,         //10
        LoadActionDef,              //11
        LoadStatus,                 // 12
        LoadComplete                //13
    }

    public class RewardManager
    {
        // TODO: Make this configurable from the app.config file.
        private static Uri ServiceLocation = new Uri("http://savasgdev/RuleAuthoring/RewardsDataService.svc", UriKind.Absolute);

        public static RewardsDBEntities ServiceContext { get; private set; }

        public static event EventHandler<SaveDataEventArgs> SaveComplete;
        public static event EventHandler<EventArgs> OnInitializeComplete;

        // constants
        public static RewardTypeCollection RewardTypeList { get; private set; }
        public static RewardCategoryCollection RewardCategoryList { get; private set; }
        public static LocaleCollection LocaleList { get; private set; }
        public static GameKeyCollection GameKeyList { get; private set; }
        public static RuleOperatorCollection RuleOperatorList { get; private set; }
        public static DataTypeCollection DataTypeList { get; private set; }
        public static ActionSetExecutionTypeCollection ActionSetExecutionTypeList { get; private set; }
        public static RuleOperandTypeCollection RuleOperandTypeList { get; private set; }
        public static PlatformsCollection PlatformsList { get; private set; }
        public static ActionParameterDefinitionCollection ActionParameterDefinitionList { get; private set; }
        public static ActionDefinitionCollection ActionDefinitionList { get; private set; }
        public static StatusCollection StatusList { get; private set; }


        // non-consts
        public static RuleCollection RuleList { get; set; }
        public static RewardCollection RewardList { get; set; }

        private static int InitializationLoadCounter { get; set; }
        private static bool IsInitialized { get; set; }

        public static void BeginInitializeConstants()
        {
            using(DebugTextLogger.EnterFunction("RewardManager:InitializeConstants"))
            {
                try
                {
                    if (RewardManager.IsInitialized)
                    {
                        RewardManager.OnInitializeComplete(null, null);
                        return;
                    }

                    RewardManager.ServiceContext = new RewardsDBEntities(RewardManager.ServiceLocation);

                    // RewardManager.ServiceContext.MergeOption = MergeOption.NoTracking;
                    
                    RewardManager.ServiceContext.WritingEntity += new EventHandler<ReadingWritingEntityEventArgs>(ServiceContext_WritingEntity);

                    //
                    // create objects, but do not load the following yet:
                    //
                    RewardManager.RuleList = new RuleCollection(RewardManager.ServiceContext);

                    //
                    // TODO: investigate if there is a way to reduce the number of round-trips here:
                    //
                    RewardManager.RuleOperatorList = new RuleOperatorCollection(RewardManager.ServiceContext);
                    RewardManager.RuleOperatorList.LoadComplete += new EventHandler(Initialize_LoadTracker);
                    
                    RewardManager.RuleOperandTypeList = new RuleOperandTypeCollection(RewardManager.ServiceContext);
                    RewardManager.RuleOperandTypeList.LoadComplete += new EventHandler(Initialize_LoadTracker);

                    RewardManager.RewardTypeList = new RewardTypeCollection(RewardManager.ServiceContext);
                    RewardManager.RewardTypeList.LoadComplete += new EventHandler(Initialize_LoadTracker);

                    RewardManager.RewardCategoryList = new RewardCategoryCollection(RewardManager.ServiceContext);
                    RewardManager.RewardCategoryList.LoadComplete += new EventHandler(Initialize_LoadTracker);

                    RewardManager.LocaleList = new LocaleCollection(RewardManager.ServiceContext);
                    RewardManager.LocaleList.LoadComplete += new EventHandler(Initialize_LoadTracker);

                    RewardManager.GameKeyList = new GameKeyCollection(RewardManager.ServiceContext);
                    RewardManager.GameKeyList.LoadComplete += new EventHandler(Initialize_LoadTracker);

                    RewardManager.DataTypeList = new DataTypeCollection(RewardManager.ServiceContext);
                    RewardManager.DataTypeList.LoadComplete += new EventHandler(Initialize_LoadTracker);

                    RewardManager.ActionSetExecutionTypeList = new ActionSetExecutionTypeCollection(RewardManager.ServiceContext);
                    RewardManager.ActionSetExecutionTypeList.LoadComplete += new EventHandler(Initialize_LoadTracker);

                    RewardManager.PlatformsList = new PlatformsCollection(RewardManager.ServiceContext);
                    RewardManager.PlatformsList.LoadComplete +=new EventHandler(Initialize_LoadTracker);

                    RewardManager.ActionDefinitionList = new ActionDefinitionCollection(RewardManager.ServiceContext);
                    RewardManager.ActionDefinitionList.LoadComplete +=new EventHandler(Initialize_LoadTracker);

                    RewardManager.ActionParameterDefinitionList = new ActionParameterDefinitionCollection(RewardManager.ServiceContext);
                    RewardManager.ActionParameterDefinitionList.LoadComplete += new EventHandler(Initialize_LoadTracker);

                    RewardManager.StatusList = new StatusCollection(RewardManager.ServiceContext);
                    RewardManager.StatusList.LoadComplete +=new EventHandler(Initialize_LoadTracker);

                    Initialize_LoadTracker(null, null);
                }
                catch (Exception ex)
                {
                    DebugTextLogger.LogException(ex);
                    throw;
                }
            }
        }

        static void Initialize_LoadTracker(object sender, EventArgs e)
        {
            InitializationLoadCounter++;
            switch ((LoadSequenceEnum)InitializationLoadCounter)
            {
                case LoadSequenceEnum.LoadOperator:
                    RewardManager.RuleOperatorList.LoadAsync();
                    break;

                case LoadSequenceEnum.LoadOperandType:
                    RewardManager.RuleOperatorList.LoadComplete -= Initialize_LoadTracker;
                    RewardManager.RuleOperandTypeList.LoadAsync();
                    break;

                case LoadSequenceEnum.LoadGameKey:
                    RewardManager.RuleOperandTypeList.LoadComplete -= Initialize_LoadTracker;
                    RewardManager.GameKeyList.LoadAsync();
                    break;

                case LoadSequenceEnum.LoadDataType:
                    RewardManager.GameKeyList.LoadComplete -= Initialize_LoadTracker;
                    RewardManager.DataTypeList.LoadAsync();
                    break;

                case LoadSequenceEnum.LoadRewardType:
                    RewardManager.DataTypeList.LoadComplete -= Initialize_LoadTracker;
                    RewardManager.RewardTypeList.LoadAsync();
                    break;

                case LoadSequenceEnum.LoadRewardCategory:
                    RewardManager.RewardTypeList.LoadComplete -= Initialize_LoadTracker;
                    RewardManager.RewardCategoryList.LoadAsync();
                    break;

                case LoadSequenceEnum.LoadLocale:
                    RewardManager.RewardCategoryList.LoadComplete -= Initialize_LoadTracker;
                    RewardManager.LocaleList.LoadAsync();
                    break;

                case LoadSequenceEnum.LoadActionSetExecutionType:
                    RewardManager.LocaleList.LoadComplete -= Initialize_LoadTracker;
                    RewardManager.ActionSetExecutionTypeList.LoadAsync();
                    break;

                case LoadSequenceEnum.LoadPlatforms:
                    RewardManager.ActionSetExecutionTypeList.LoadComplete -= Initialize_LoadTracker;
                    RewardManager.PlatformsList.LoadAsync();
                    break;

                case LoadSequenceEnum.LoadActionParamDef:
                    RewardManager.PlatformsList.LoadComplete -= Initialize_LoadTracker;
                    RewardManager.ActionParameterDefinitionList.LoadAsync();
                    break;

                case LoadSequenceEnum.LoadActionDef:
                    RewardManager.ActionParameterDefinitionList.LoadComplete -= Initialize_LoadTracker;
                    RewardManager.ActionDefinitionList.LoadAsync();
                    break;

                case LoadSequenceEnum.LoadStatus:
                    RewardManager.ActionDefinitionList.LoadComplete -= Initialize_LoadTracker;
                    RewardManager.StatusList.LoadAsync();
                    break;

                case LoadSequenceEnum.LoadComplete:
                    RewardManager.ActionDefinitionList.LoadComplete -= Initialize_LoadTracker;
                    RewardManager.IsInitialized = true;
                    break;

                default:
                    throw new InvalidOperationException();
            }

            if (RewardManager.IsInitialized)
            {
                RewardManager.OnInitializeComplete(null, null);
            }
        }

        static void ServiceContext_WritingEntity(object sender, ReadingWritingEntityEventArgs e)
        {
            // e.Data gives you the XElement for the Serialization of the Entity    
            //Using XLinq  , you can  add/Remove properties to the element Payload     
            XName xnEntityProperties = XName.Get("properties", e.Data.GetNamespaceOfPrefix("m").NamespaceName);
            XElement xePayload = null;

            foreach (PropertyInfo property in e.Entity.GetType().GetProperties())
            {
                object[] doNotSerializeAttributes = property.GetCustomAttributes(typeof(DoNotSerializeAttribute), false);
                if (doNotSerializeAttributes.Length > 0)
                {
                    if (xePayload == null)
                    {
                        xePayload = e.Data.Descendants().Where<XElement>(xe => xe.Name == xnEntityProperties)
                            .First<XElement>();
                    }

                    //The XName of the property we are going to remove from the payload     
                    XName xnProperty = XName.Get(property.Name, e.Data.GetNamespaceOfPrefix("d").NamespaceName);

                    //Get the Property of the entity  you don't want sent to the server     
                    XElement xeRemoveThisProperty = xePayload.Descendants()
                                    .Where<XElement>(xe => xe.Name == xnProperty)
                                    .First<XElement>();

                    //Remove this property from the Payload sent to the server      
                    xeRemoveThisProperty.Remove();
                }
            }
        }

        protected static void OnSaveComplete(IAsyncResult result)
        {
            bool succeeded = true;
            try
            {
                DataServiceResponse response = (DataServiceResponse)RewardManager.ServiceContext.EndSaveChanges(result);

                foreach (OperationResponse opResponse in response)
                {
                    if (opResponse.Error != null)
                    {
                        DebugTextLogger.Log("Failed to save data: {0}", opResponse.StatusCode);
                        succeeded = false;
                    }
                }
            }
            catch (Exception ex)
            {
                DebugTextLogger.LogException(ex);
                succeeded = false;
            }

            if (SaveComplete != null)
            {
                SaveComplete(null, new SaveDataEventArgs { Succeeded = succeeded });
            }
        }

        public static void SaveAsync()
        {
            //RewardManager.ServiceContext.MergeOption = MergeOption.PreserveChanges;
            RewardManager.ServiceContext.BeginSaveChanges(SaveChangesOptions.Batch, new AsyncCallback(OnSaveComplete), null);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\RulesBadgeAuthoring\Model\RuleExpression.cs ===
namespace RulesBadgeAuthoring.RewardsDataService
{
    using System.ComponentModel;
    using System.Collections.Generic;
    using RulesBadgeAuthoring.Model;
    using System.Linq;
    using RulesBadgeAuthoring.View;
    using System;

    public partial class RuleExpression : BaseEntity
    {
        partial void OnRightOperandChanged() { FirePropertyChanged("RightOperand"); FirePropertyChanged("RuleOperator"); }
        partial void OnLeftOperandChanged() { FirePropertyChanged("LeftOperand"); FirePropertyChanged("RuleOperator"); }
        partial void OnDTCreatedChanged() { FirePropertyChanged("DTCreated"); }
        partial void OnDTModifiedChanged() { FirePropertyChanged("DTModified"); }
        partial void OnRuleExpressionIDChanged() { FirePropertyChanged("RuleExpressionID"); }

        internal bool IsModified { get; set; }
        internal bool IsCreated { get; set; }
        internal bool IsDeleted { get; set; }

        // TODO: how to make these flags a bit more smarter.
        internal bool IsProperty 
        {
            get
            {
                if (this.GetGameSchemaProperty() != null)
                {
                    return true;
                }

                return false;
            }
        }
        internal bool IsStatistics 
        {
            get
            {
                if (this.GetStatDescription() != null)
                {
                    return true;
                }

                return false;
            }
        }

        internal bool HasLiteral { get; set; }

        /// <summary>
        /// Commit any changes and updates.
        /// </summary>
        public void Commit()
        {
            // one of these 3 should exist
            if (!(this.IsModified || this.IsCreated || this.IsDeleted))
            {
                return;
            }

            if (this.IsDeleted)
            {
                if (!this.IsCreated)
                {
                    this.RemoveLinksAndDestroy();
                } 
                
                // else ignore, nothing to commit.
                return;
            }
            if (this.IsCreated)
            {
                RewardManager.ServiceContext.AddToRuleExpression(this);
                
            }
            else if (this.IsModified)
            {
                RewardManager.ServiceContext.UpdateObject(this);
            }

            this.SetLinks();

            this.IsCreated = false;
            this.IsModified = false;
        }

        internal void RemoveLinksAndDestroy()
        {
            //this.RemoveLink("Rule", this.Rule);
            //this.RemoveLink("DataType", this.DataType);
            //this.RemoveLink("RuleOperator", this.RuleOperator);
            //this.RemoveLink("RuleOperandType", this.RuleOperandType);
            //this.RemoveLink("RuleOperandType1", this.RuleOperandType1);
            this.DeleteSelf();
        }

        internal void SetLinks()
        {
            this.SetLink("Rule", this.Rule);
            this.SetLink("DataType", this.DataType);
            this.SetLink("RuleOperator", this.RuleOperator);
            this.SetLink("RuleOperandType", this.RuleOperandType);
            this.SetLink("RuleOperandType1", this.RuleOperandType1);
        }

        internal GameSchemaProperties GetGameSchemaProperty()
        {
            string propertyName = string.Empty;

            if (string.IsNullOrEmpty(this.LeftOperand))
            {
                return null;
            }

            // Left Operand: /Event/Property/[HighScore]
            // Right Operand: <a literal>
            // TODO: come up w/ a better heuristic than this:
            if (this.LeftOperand.Contains("["))
            {
                int indexBegin = this.LeftOperand.IndexOf("[", StringComparison.OrdinalIgnoreCase);
                int indexEnd = this.LeftOperand.IndexOf("]", StringComparison.OrdinalIgnoreCase);
                propertyName = this.LeftOperand.Substring(indexBegin+1, indexEnd - indexBegin -1);
            }
            else
            {
                // Left Operand: /Event/Property/Name
                // Right Operand: Property or Statistics Name.
                propertyName = this.RightOperand;
            }

            var ret = from prop in this.Rule.GetGameKey().PropertiesList
                      where prop.Name.Equals(propertyName)
                      select prop;
            if (ret.Count<GameSchemaProperties>() > 0)
            {
                return ret.First<GameSchemaProperties>();
            }

            return null;
        }

        internal StatDescription GetStatDescription()
        {
            string statName = string.Empty;

            if (string.IsNullOrEmpty(this.LeftOperand))
            {
                return null;
            }

            // Left Operand: /Event/Property/[HighScore]
            // Right Operand: <a literal>
            // TODO: come up w/ a better heuristic than this:
            if (this.LeftOperand.Contains("["))
            {
                int indexBegin = this.LeftOperand.IndexOf("[", StringComparison.OrdinalIgnoreCase);
                int indexEnd = this.LeftOperand.IndexOf("]", StringComparison.OrdinalIgnoreCase);
                statName = this.LeftOperand.Substring(indexBegin + 1, indexEnd - indexBegin - 1);
            }
            else
            {
                // Left Operand: /Event/Property/Name
                // Right Operand: Property or Statistics Name.
                statName = this.RightOperand;
            }

            GameKeys game = this.Rule.GetGameKey();
            if (game.StatList != null && game.StatList.Count > 0)
            {
                var ret = (from prop in this.Rule.GetGameKey().StatList
                           where prop.Name.Equals(statName)
                           select prop).First<StatDescription>();
                return ret;
            }

            return null;
        }

        internal StatementType GetStatementType()
        {
            if (string.IsNullOrEmpty(this.LeftOperand) ||
                string.IsNullOrEmpty(this.RightOperand) ||
                this.RuleOperator == null)
            {
                throw new InvalidOperationException();
            }

            var st =  from statementType in StatementEditConfig.StatementDropDownList
                      where this.LeftOperand.Contains(statementType.LeftOperand)
                      select statementType;
            
            if (st.Count<StatementType>() == 1)
            {
                DebugTextLogger.Log("{0}", st.First<StatementType>().StatementTypeEnum);
                return st.First<StatementType>();
            }

            // then it is either prop or stat determine which
            if (this.IsProperty)
            {
                return (from statementType in st
                        where statementType.StatementTypeEnum == StatementTypeEnum.Property
                        select statementType).First<StatementType>();
            }
            else if (this.IsStatistics)
            {
                return (from statementType in st
                        where statementType.StatementTypeEnum == StatementTypeEnum.Statistics
                        select statementType).First<StatementType>();
            }

            // if we are here, we couldn't determine the type of this expression, how sad.
            // we must have a bug then.
            throw new InvalidOperationException();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\RulesBadgeAuthoring\Model\RuleOperandTypeList.cs ===
namespace RulesBadgeAuthoring.Model
{
    using System.Linq;
    using RulesBadgeAuthoring.RewardsDataService;
    using System;

    public class RuleOperandTypeCollection : BaseList<RuleOperandType>
    {
        public RuleOperandTypeCollection(RewardsDBEntities context)
            : base(context)
        { }

        public void LoadAsync()
        {
            // Eager Loading
            using (DebugTextLogger.EnterFunction("RuleOperandTypeList::LoadAsync"))
            {
                try
                {
                    var query = from ruleOperandType in this.Context.RuleOperandType
                                where ruleOperandType.RuleOperandTypeID > 0
                                select ruleOperandType;
                    base.LoadAsync(query);
                }
                catch (Exception ex)
                {
                    DebugTextLogger.LogException(ex);
                    throw;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\RulesBadgeAuthoring\Model\RuleExpressionList.cs ===
namespace RulesBadgeAuthoring.Model
{
    using System.Linq;
    using RulesBadgeAuthoring.RewardsDataService;
    using System;

    public class RuleExpressionCollection : BaseList<RuleExpression>
    {
        public RuleExpressionCollection(RewardsDBEntities context)
            : base(context)
        { }

        public void LoadAsync(int ruleId)
        {
            // Eager Loading
            using (DebugTextLogger.EnterFunction("RuleExpressionList::LoadAsync"))
            {
                try
                {
                    var query = from ruleExpression in this.Context.RuleExpression.Expand("RuleOperator").Expand("DataType")
                                where ruleExpression.Rule.RuleID == ruleId
                                select ruleExpression;

                    //var query = from rule in this.Context.Rule
                    //            where rule.RuleID == ruleId
                    //            select rule.RuleExpression;

                    base.LoadAsync(query);
                }
                catch (Exception ex)
                {
                    DebugTextLogger.LogException(ex);
                    throw;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\RulesBadgeAuthoring\Model\RuleOperator.cs ===
namespace RulesBadgeAuthoring.RewardsDataService
{
    using System.ComponentModel;
    using RulesBadgeAuthoring.Model;

    public partial class RuleOperator : BaseEntity
    {
        // TODO: Nothing to extend, consider removing file.
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\RulesBadgeAuthoring\Model\RuleOperandType.cs ===
namespace RulesBadgeAuthoring.RewardsDataService
{
    using System.ComponentModel;
    using RulesBadgeAuthoring.Model;

    public partial class RuleOperandType : BaseEntity
    {
        partial void OnDTCreatedChanged() { FirePropertyChanged("DTCreated"); }
        partial void OnDTModifiedChanged() { FirePropertyChanged("DTModified"); }
        partial void OnRuleOperandTypeIDChanged() { FirePropertyChanged("RuleOperandTypeIDChanged"); }
        partial void OnRuleOperandTypeNameChanged() { FirePropertyChanged("RuleOperandTypeNameChanged"); }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\RulesBadgeAuthoring\Model\SaveDataEventArgs.cs ===
namespace RulesBadgeAuthoring.Model
{
    using System;

    public class SaveDataEventArgs : EventArgs
    {
        public bool Succeeded { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\RulesBadgeAuthoring\Model\RuleOperatorList.cs ===
namespace RulesBadgeAuthoring.Model
{
    using System.Linq;
    using RulesBadgeAuthoring.RewardsDataService;
    using System;

    public class RuleOperatorCollection : BaseList<RuleOperator>
    {
        public RuleOperatorCollection(RewardsDBEntities context)
            : base(context)
        { }

        public void LoadAsync()
        {
            // Eager Loading
            using (DebugTextLogger.EnterFunction("RuleOperatorList::LoadAsync"))
            {
                try
                {
                    var query = from ruleOps in this.Context.RuleOperator
                                select ruleOps;

                    base.LoadAsync(query);
                }
                catch (Exception ex)
                {
                    DebugTextLogger.LogException(ex);
                    throw;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\RulesBadgeAuthoring\Model\RuleList.cs ===
namespace RulesBadgeAuthoring.Model
{
    using System.Linq;
    using RulesBadgeAuthoring.RewardsDataService;
    using System;

    public class RuleCollection : BaseList<Rule>
    {
        public RuleCollection(RewardsDBEntities context)
            : base(context)
        { }

        public void LoadAsync()
        {
            // Eager Loading
            using (DebugTextLogger.EnterFunction("RuleList::LoadAsync"))
            {
                try
                {
                    var query = from rule in this.Context.Rule
                                where rule.RuleID > 0 
                                select rule;
                    
                    base.LoadAsync(query);
                }
                catch (Exception ex)
                {
                    DebugTextLogger.LogException(ex);
                    throw;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\RulesBadgeAuthoring\Model\StatDescription.cs ===
namespace RulesBadgeAuthoring.RewardsDataService
{
    using System.ComponentModel;
    using RulesBadgeAuthoring.Model;

    public partial class StatDescription : BaseEntity
    {
        partial void OnCommentChanged() { FirePropertyChanged("Comment"); }
        partial void OnDTModifiedChanged() { FirePropertyChanged("DTModified"); }
        partial void OnNameChanged() { FirePropertyChanged("Name"); }
        partial void OnStatDescriptionIDChanged() { FirePropertyChanged("StatDescriptionID"); }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\RulesBadgeAuthoring\Properties\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("RulesBadgeAuthoring")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("49dcc3af-a4de-485c-913e-0673370494b1")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\RulesBadgeAuthoring\Utilities\DoubleClickManager.cs ===
using System;
using System.Net;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Documents;
using System.Windows.Ink;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Animation;
using System.Windows.Shapes;

namespace RulesBadgeAuthoring
{
    public class DoubleClickEventArgs : EventArgs
    {

    }

    public class DoubleClickManager
    {
        /// <summary>
        /// Read http://msdn.microsoft.com/en-us/library/system.datetime.ticks.aspx
        /// </summary>
        private const long TicksPerMilliSecond = 10000;

        public event EventHandler<MouseButtonEventArgs> DoubleClick;
        //public event EventHandler<MouseButtonEventArgs> SingleClick;

        /// <summary>
        /// maximum number of milliseconds before a double which click is registered.
        /// </summary>
        public long DoubleClickTimeout { get; set; }

        private long LastClickTick { get; set; }

        private bool IsClicked { get; set; }

        public DoubleClickManager(int doubleClickTimeout)
        {
            this.DoubleClickTimeout = doubleClickTimeout;
        }

        public void HandleClick(object sender, MouseButtonEventArgs e)
        {
            if (!IsClicked)
            {
                this.LastClickTick = DateTime.Now.Ticks;
                IsClicked = true;
                return;
            }

            long currentTick = DateTime.Now.Ticks;

            // measure absolute distance from last click.
            long span = this.LastClickTick - currentTick;
            if (span < 0)
            {
                span = currentTick - this.LastClickTick;
            }

            DebugTextLogger.Log("Span between two consecutive clicks {0}ms", span / DoubleClickManager.TicksPerMilliSecond);

            // if it is within the double click timeout interval register a click.
            if (span < (this.DoubleClickTimeout * DoubleClickManager.TicksPerMilliSecond))
            {
                // NOTE: A nice to have here would be to verify that the selection hasn't changed.
                // One OO way to achieve this would be to Derive the object being tracked to have a DoubleClick event handler, 
                // and contain this Manager, hiding the details.
                OnDoubleClick(sender, e);
            }

            // update last click before returning.
            this.LastClickTick = currentTick;
        }

        private void OnDoubleClick(object sender, MouseButtonEventArgs e)
        {
            if (this.DoubleClick != null)
            {
                this.DoubleClick(sender, e);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\RulesBadgeAuthoring\Model\StatDescriptionList.cs ===
namespace RulesBadgeAuthoring.Model
{
    using System.Linq;
    using RulesBadgeAuthoring.RewardsDataService;
    using System;

    public class StatDescriptionCollection : BaseList<StatDescription>
    {
        public StatDescriptionCollection(RewardsDBEntities context)
            : base(context)
        { }

        public void LoadAsync(int gameKeyId)
        {
            // Eager Loading
            using (DebugTextLogger.EnterFunction("StatDescriptionList::LoadAsync"))
            {
                try
                {
                    var query = from statDescription in this.Context.StatDescription.Expand("DataType")
                                where statDescription.GameKeys.GameKeyID == gameKeyId
                                select statDescription;

                    base.LoadAsync(query);
                }
                catch (Exception ex)
                {
                    DebugTextLogger.LogException(ex);
                    throw;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\makefile.inc ===
# this is a slight modification of the makefile.def target that skips ComVisible since it's specified per project.

$(OBJ_PATH)\$O\_generated.cs: $(SOURCES_USED)
    -$(_DEL)
    set createfile=<<$@.temp
!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES) && "$(MUI)" == "1" && "$(URT_VER)" == "2.0"
[assembly:System.Resources.NeutralResourcesLanguage("en")]
!endif
[assembly:System.Reflection.AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")]
!ifdef VER_PRODUCTNAME_STR
[assembly:System.Reflection.AssemblyProduct("$(VER_PRODUCTNAME_STR)")]
!endif
!ifdef VER_LEGALCOPYRIGHT_STR
[assembly:System.Reflection.AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")]
!endif
!ifdef VER_COMPANYNAME_STR
[assembly:System.Reflection.AssemblyCompany("$(VER_COMPANYNAME_STR)")]
!endif
!ifdef VER_PRODUCTVERSION_STR
[assembly:System.Reflection.AssemblyFileVersion("$(VER_PRODUCTVERSION_STR)")]
!endif
<<KEEP
!if defined(_ASSEMBLY_IDENTITY) \
        && "$(_ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME_LOWERCASE)" != "none" \
        && "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)" \
        && !defined(_MANAGED_CXX_LIBRARY) \
        && "$(MANAGED_TARGET_TYPE)" != "module"
    asmIdToAttribs.cmd "$(_ASSEMBLY_IDENTITY)" $@.temp csharp
!endif
    $(_MOVE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\RulesBadgeAuthoring\View\IActionEditPage.cs ===
namespace RulesBadgeAuthoring.View
{
    using System;
    using Action = RulesBadgeAuthoring.RewardsDataService.Action;


    public interface IActionEditPage
    {
        ActionEditPopup ActionEditPopup { get; set; }
        event EventHandler<EventArgs> OnCreateOrUpdateable;
        Action ConstructActionFromPage();
        void Show(Object dataContext);
        void Close(object dataContext);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\RulesBadgeAuthoring\Utilities\DoNotSerializeAttribute.cs ===
namespace RulesBadgeAuthoring
{
    using System;

    /// <summary> 
    /// Properties marked with this Attribute are not serialized in the payload when sent to the server 
    /// </summary> 
    [AttributeUsage(AttributeTargets.Property)]
    public class DoNotSerializeAttribute : Attribute
    { }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\RulesBadgeAuthoring\Utilities\SilverlightAsyncHelper.cs ===
namespace RulesBadgeAuthoring
{
    using System;
    using System.Threading;

    public static class SilverlightAsyncHelper
    {
        private static int UiThreadId { get; set; }
        private static SynchronizationContext UiSyncContext { get; set; }

        public static void Initialize()
        {
            SilverlightAsyncHelper.UiThreadId = Thread.CurrentThread.ManagedThreadId;
            SilverlightAsyncHelper.UiSyncContext = SynchronizationContext.Current;
        }

        public static bool IsUiThread()
        {
            return SilverlightAsyncHelper.UiThreadId == Thread.CurrentThread.ManagedThreadId;
        }

        /// <summary>
        /// The System.Exception (which is the base class for ALL other exceptions) has a constructor which accepts a 
        /// string and inner exception.
        /// Create a new Exception class, with the same type, using the Activator.
        /// And ensure that the proper Constructor is created.
        /// 
        /// This way we can keep the original stack trace, as well as the current stack trace.
        /// the Inner exception will keep the originating threads stack trace.
        /// the outer exception will hold the current stack trace.
        /// </summary>
        /// <param name="error"></param>
        /// <returns></returns>
        private static Exception CloneAndKeepStackTrace(Exception error)
        {
            Type exType = error.GetType();
            Object[] arguments = new Object[2] { string.Empty, error };
            return (Exception)Activator.CreateInstance(exType, arguments);
        }

        public static void PostOnUI(SendOrPostCallback beginMethod, Object state)
        {
            SilverlightAsyncHelper.UiSyncContext.Send(
                (SendOrPostCallback)delegate(object sendState)
                {
                    try
                    {
                        beginMethod(state);
                    }
                    catch (Exception ex)
                    {
                        DebugTextLogger.LogException(ex);
                        throw;
                    }
                }, (object)null);
        }

        /// <summary>
        /// This method runs the provided delegate on the UI-thread, and feeds the given state to it.
        /// ALL exceptions will be caught and re-thrown at the initiating threads context.
        /// 
        /// Callers are still encouraged to do proper exception handling within the delegate.
        /// </summary>
        /// <param name="beginMethod"></param>
        /// <param name="state"></param>
        public static void BeginOnUI(SendOrPostCallback beginMethod, Object state)
        {
            if (SilverlightAsyncHelper.IsUiThread())
            {
                beginMethod(state);
                return;
            }

            Exception error = null;

            SilverlightAsyncHelper.UiSyncContext.Send(
                (SendOrPostCallback)delegate(object sendState)
                {
                    try
                    {
                        beginMethod(state);
                    }
                    catch (Exception ex)
                    {
                        error = ex;
                    }
                }, (object)null);

            if (error != null)
                throw CloneAndKeepStackTrace(error);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\RulesBadgeAuthoring\Utilities\DebugTextLogger.cs ===
namespace RulesBadgeAuthoring
{
    using System.Windows;
    using System.Windows.Controls;
    using System.Windows.Browser;
    using System;
    using System.Text;

    internal class LogScope : IDisposable
    {
        public string PrintUponExit { get; private set; }

        public LogScope(string printUponExit)
        {
            this.PrintUponExit = printUponExit;
        }

        public void Dispose()
        {
            DebugTextLogger.Log(this.PrintUponExit);
        }
    }

    internal static class DebugTextLogger
    {
        private const string Newline = "\n";
        private const string FunctionEntryPrefix = "> ";
        private const string FunctionExitPrefix = "< ";

        private static TextBox DebugTextBox { get; set; }
        private static ScrollViewer DebugScrollViewer { get; set; }
        private static bool IsDebugMode { get; set; }

        public static void Initialize(TextBox debugTb, ScrollViewer debugSv)
        {
            DebugTextLogger.DebugTextBox = debugTb;
            DebugTextLogger.DebugScrollViewer = debugSv;

            // Initialize debug logging
            string val = null;
            HtmlPage.Document.QueryString.TryGetValue("Debug", out val);

            if (!String.IsNullOrEmpty(val) && String.Compare(val, "On", StringComparison.OrdinalIgnoreCase) == 0)
            {
                DebugTextLogger.IsDebugMode = true;
                debugTb.Visibility = Visibility.Visible;
                debugSv.Visibility = Visibility.Visible;
            }
        }

        public static void Log(string str, params object[] args)
        {
            if (DebugTextLogger.IsDebugMode)
            {
                StringBuilder sb = new StringBuilder(512);

                sb.AppendFormat(str, args);
                sb.Append(DebugTextLogger.Newline);

                DebugTextLogger.Print(sb.ToString());
            }
        }

        public static void LogException(Exception ex)
        {
            if (DebugTextLogger.IsDebugMode)
            {
                DebugTextLogger.Print(ex.ToString());
            }
        }

        private static void Print(string str)
        {
            if (DebugTextLogger.IsDebugMode)
            {
                SilverlightAsyncHelper.BeginOnUI(delegate(object obj)
                {
                    DebugTextLogger.DebugTextBox.Text += str;
                    if (DebugTextLogger.DebugScrollViewer.ScrollableHeight > 0)
                    {
                        DebugTextLogger.DebugScrollViewer.UpdateLayout();
                        DebugTextLogger.DebugScrollViewer.ScrollToVerticalOffset(double.MaxValue);
                    }
                }, null);
            }
        }

        public static LogScope EnterFunction(string format, params object[] args)
        {
            if (DebugTextLogger.IsDebugMode)
            {
                StringBuilder sb = new StringBuilder(512);
                sb.Append(DebugTextLogger.FunctionEntryPrefix);
                sb.AppendFormat(format, args);
                sb.Append(DebugTextLogger.Newline);

                DebugTextLogger.Print(sb.ToString());
                sb.Replace(DebugTextLogger.FunctionEntryPrefix, DebugTextLogger.FunctionExitPrefix, 0, 2);

                return new LogScope(sb.ToString());
            }

            return null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\RulesBadgeAuthoring\Service References\RewardsDataService\Reference.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Original file name:
// Generation date: 8/10/2009 11:01:41 AM
namespace RulesBadgeAuthoring.RewardsDataService
{
    
    /// <summary>
    /// There are no comments for RewardsDBEntities in the schema.
    /// </summary>
    public partial class RewardsDBEntities : global::System.Data.Services.Client.DataServiceContext
    {
        /// <summary>
        /// Initialize a new RewardsDBEntities object.
        /// </summary>
        public RewardsDBEntities(global::System.Uri serviceRoot) : 
                base(serviceRoot)
        {
            this.ResolveName = new global::System.Func<global::System.Type, string>(this.ResolveNameFromType);
            this.ResolveType = new global::System.Func<string, global::System.Type>(this.ResolveTypeFromName);
            this.OnContextCreated();
        }
        partial void OnContextCreated();
        /// <summary>
        /// Since the namespace configured for this service reference
        /// in Visual Studio is different from the one indicated in the
        /// server schema, use type-mappers to map between the two.
        /// </summary>
        protected global::System.Type ResolveTypeFromName(string typeName)
        {
            if (typeName.StartsWith("RewardsDBModel", global::System.StringComparison.Ordinal))
            {
                return this.GetType().Assembly.GetType(string.Concat("RulesBadgeAuthoring.RewardsDataService", typeName.Substring(14)), true);
            }
            return null;
        }
        /// <summary>
        /// Since the namespace configured for this service reference
        /// in Visual Studio is different from the one indicated in the
        /// server schema, use type-mappers to map between the two.
        /// </summary>
        protected string ResolveNameFromType(global::System.Type clientType)
        {
            if (clientType.Namespace.Equals("RulesBadgeAuthoring.RewardsDataService", global::System.StringComparison.Ordinal))
            {
                return string.Concat("RewardsDBModel.", clientType.Name);
            }
            return null;
        }
        /// <summary>
        /// There are no comments for Action in the schema.
        /// </summary>
        public global::System.Data.Services.Client.DataServiceQuery<Action> Action
        {
            get
            {
                if ((this._Action == null))
                {
                    this._Action = base.CreateQuery<Action>("Action");
                }
                return this._Action;
            }
        }
        private global::System.Data.Services.Client.DataServiceQuery<Action> _Action;
        /// <summary>
        /// There are no comments for ActionDefinition in the schema.
        /// </summary>
        public global::System.Data.Services.Client.DataServiceQuery<ActionDefinition> ActionDefinition
        {
            get
            {
                if ((this._ActionDefinition == null))
                {
                    this._ActionDefinition = base.CreateQuery<ActionDefinition>("ActionDefinition");
                }
                return this._ActionDefinition;
            }
        }
        private global::System.Data.Services.Client.DataServiceQuery<ActionDefinition> _ActionDefinition;
        /// <summary>
        /// There are no comments for ActionParameter in the schema.
        /// </summary>
        public global::System.Data.Services.Client.DataServiceQuery<ActionParameter> ActionParameter
        {
            get
            {
                if ((this._ActionParameter == null))
                {
                    this._ActionParameter = base.CreateQuery<ActionParameter>("ActionParameter");
                }
                return this._ActionParameter;
            }
        }
        private global::System.Data.Services.Client.DataServiceQuery<ActionParameter> _ActionParameter;
        /// <summary>
        /// There are no comments for ActionParameterDefinition in the schema.
        /// </summary>
        public global::System.Data.Services.Client.DataServiceQuery<ActionParameterDefinition> ActionParameterDefinition
        {
            get
            {
                if ((this._ActionParameterDefinition == null))
                {
                    this._ActionParameterDefinition = base.CreateQuery<ActionParameterDefinition>("ActionParameterDefinition");
                }
                return this._ActionParameterDefinition;
            }
        }
        private global::System.Data.Services.Client.DataServiceQuery<ActionParameterDefinition> _ActionParameterDefinition;
        /// <summary>
        /// There are no comments for ActionSetExecutionType in the schema.
        /// </summary>
        public global::System.Data.Services.Client.DataServiceQuery<ActionSetExecutionType> ActionSetExecutionType
        {
            get
            {
                if ((this._ActionSetExecutionType == null))
                {
                    this._ActionSetExecutionType = base.CreateQuery<ActionSetExecutionType>("ActionSetExecutionType");
                }
                return this._ActionSetExecutionType;
            }
        }
        private global::System.Data.Services.Client.DataServiceQuery<ActionSetExecutionType> _ActionSetExecutionType;
        /// <summary>
        /// There are no comments for ActionSettings in the schema.
        /// </summary>
        public global::System.Data.Services.Client.DataServiceQuery<ActionSettings> ActionSettings
        {
            get
            {
                if ((this._ActionSettings == null))
                {
                    this._ActionSettings = base.CreateQuery<ActionSettings>("ActionSettings");
                }
                return this._ActionSettings;
            }
        }
        private global::System.Data.Services.Client.DataServiceQuery<ActionSettings> _ActionSettings;
        /// <summary>
        /// There are no comments for ActionSettingsDefinition in the schema.
        /// </summary>
        public global::System.Data.Services.Client.DataServiceQuery<ActionSettingsDefinition> ActionSettingsDefinition
        {
            get
            {
                if ((this._ActionSettingsDefinition == null))
                {
                    this._ActionSettingsDefinition = base.CreateQuery<ActionSettingsDefinition>("ActionSettingsDefinition");
                }
                return this._ActionSettingsDefinition;
            }
        }
        private global::System.Data.Services.Client.DataServiceQuery<ActionSettingsDefinition> _ActionSettingsDefinition;
        /// <summary>
        /// There are no comments for Config in the schema.
        /// </summary>
        public global::System.Data.Services.Client.DataServiceQuery<Config> Config
        {
            get
            {
                if ((this._Config == null))
                {
                    this._Config = base.CreateQuery<Config>("Config");
                }
                return this._Config;
            }
        }
        private global::System.Data.Services.Client.DataServiceQuery<Config> _Config;
        /// <summary>
        /// There are no comments for DataType in the schema.
        /// </summary>
        public global::System.Data.Services.Client.DataServiceQuery<DataType> DataType
        {
            get
            {
                if ((this._DataType == null))
                {
                    this._DataType = base.CreateQuery<DataType>("DataType");
                }
                return this._DataType;
            }
        }
        private global::System.Data.Services.Client.DataServiceQuery<DataType> _DataType;
        /// <summary>
        /// There are no comments for GameCategories in the schema.
        /// </summary>
        public global::System.Data.Services.Client.DataServiceQuery<GameCategories> GameCategories
        {
            get
            {
                if ((this._GameCategories == null))
                {
                    this._GameCategories = base.CreateQuery<GameCategories>("GameCategories");
                }
                return this._GameCategories;
            }
        }
        private global::System.Data.Services.Client.DataServiceQuery<GameCategories> _GameCategories;
        /// <summary>
        /// There are no comments for GameKeys in the schema.
        /// </summary>
        public global::System.Data.Services.Client.DataServiceQuery<GameKeys> GameKeys
        {
            get
            {
                if ((this._GameKeys == null))
                {
                    this._GameKeys = base.CreateQuery<GameKeys>("GameKeys");
                }
                return this._GameKeys;
            }
        }
        private global::System.Data.Services.Client.DataServiceQuery<GameKeys> _GameKeys;
        /// <summary>
        /// There are no comments for GameSchemaNames in the schema.
        /// </summary>
        public global::System.Data.Services.Client.DataServiceQuery<GameSchemaNames> GameSchemaNames
        {
            get
            {
                if ((this._GameSchemaNames == null))
                {
                    this._GameSchemaNames = base.CreateQuery<GameSchemaNames>("GameSchemaNames");
                }
                return this._GameSchemaNames;
            }
        }
        private global::System.Data.Services.Client.DataServiceQuery<GameSchemaNames> _GameSchemaNames;
        /// <summary>
        /// There are no comments for GameSchemaProperties in the schema.
        /// </summary>
        public global::System.Data.Services.Client.DataServiceQuery<GameSchemaProperties> GameSchemaProperties
        {
            get
            {
                if ((this._GameSchemaProperties == null))
                {
                    this._GameSchemaProperties = base.CreateQuery<GameSchemaProperties>("GameSchemaProperties");
                }
                return this._GameSchemaProperties;
            }
        }
        private global::System.Data.Services.Client.DataServiceQuery<GameSchemaProperties> _GameSchemaProperties;
        /// <summary>
        /// There are no comments for Locale in the schema.
        /// </summary>
        public global::System.Data.Services.Client.DataServiceQuery<Locale> Locale
        {
            get
            {
                if ((this._Locale == null))
                {
                    this._Locale = base.CreateQuery<Locale>("Locale");
                }
                return this._Locale;
            }
        }
        private global::System.Data.Services.Client.DataServiceQuery<Locale> _Locale;
        /// <summary>
        /// There are no comments for Platforms in the schema.
        /// </summary>
        public global::System.Data.Services.Client.DataServiceQuery<Platforms> Platforms
        {
            get
            {
                if ((this._Platforms == null))
                {
                    this._Platforms = base.CreateQuery<Platforms>("Platforms");
                }
                return this._Platforms;
            }
        }
        private global::System.Data.Services.Client.DataServiceQuery<Platforms> _Platforms;
        /// <summary>
        /// There are no comments for Reward in the schema.
        /// </summary>
        public global::System.Data.Services.Client.DataServiceQuery<Reward> Reward
        {
            get
            {
                if ((this._Reward == null))
                {
                    this._Reward = base.CreateQuery<Reward>("Reward");
                }
                return this._Reward;
            }
        }
        private global::System.Data.Services.Client.DataServiceQuery<Reward> _Reward;
        /// <summary>
        /// There are no comments for RewardCategory in the schema.
        /// </summary>
        public global::System.Data.Services.Client.DataServiceQuery<RewardCategory> RewardCategory
        {
            get
            {
                if ((this._RewardCategory == null))
                {
                    this._RewardCategory = base.CreateQuery<RewardCategory>("RewardCategory");
                }
                return this._RewardCategory;
            }
        }
        private global::System.Data.Services.Client.DataServiceQuery<RewardCategory> _RewardCategory;
        /// <summary>
        /// There are no comments for RewardGameKeys in the schema.
        /// </summary>
        public global::System.Data.Services.Client.DataServiceQuery<RewardGameKeys> RewardGameKeys
        {
            get
            {
                if ((this._RewardGameKeys == null))
                {
                    this._RewardGameKeys = base.CreateQuery<RewardGameKeys>("RewardGameKeys");
                }
                return this._RewardGameKeys;
            }
        }
        private global::System.Data.Services.Client.DataServiceQuery<RewardGameKeys> _RewardGameKeys;
        /// <summary>
        /// There are no comments for RewardLocale in the schema.
        /// </summary>
        public global::System.Data.Services.Client.DataServiceQuery<RewardLocale> RewardLocale
        {
            get
            {
                if ((this._RewardLocale == null))
                {
                    this._RewardLocale = base.CreateQuery<RewardLocale>("RewardLocale");
                }
                return this._RewardLocale;
            }
        }
        private global::System.Data.Services.Client.DataServiceQuery<RewardLocale> _RewardLocale;
        /// <summary>
        /// There are no comments for RewardType in the schema.
        /// </summary>
        public global::System.Data.Services.Client.DataServiceQuery<RewardType> RewardType
        {
            get
            {
                if ((this._RewardType == null))
                {
                    this._RewardType = base.CreateQuery<RewardType>("RewardType");
                }
                return this._RewardType;
            }
        }
        private global::System.Data.Services.Client.DataServiceQuery<RewardType> _RewardType;
        /// <summary>
        /// There are no comments for Rule in the schema.
        /// </summary>
        public global::System.Data.Services.Client.DataServiceQuery<Rule> Rule
        {
            get
            {
                if ((this._Rule == null))
                {
                    this._Rule = base.CreateQuery<Rule>("Rule");
                }
                return this._Rule;
            }
        }
        private global::System.Data.Services.Client.DataServiceQuery<Rule> _Rule;
        /// <summary>
        /// There are no comments for RuleExpression in the schema.
        /// </summary>
        public global::System.Data.Services.Client.DataServiceQuery<RuleExpression> RuleExpression
        {
            get
            {
                if ((this._RuleExpression == null))
                {
                    this._RuleExpression = base.CreateQuery<RuleExpression>("RuleExpression");
                }
                return this._RuleExpression;
            }
        }
        private global::System.Data.Services.Client.DataServiceQuery<RuleExpression> _RuleExpression;
        /// <summary>
        /// There are no comments for RuleGameKeys in the schema.
        /// </summary>
        public global::System.Data.Services.Client.DataServiceQuery<RuleGameKeys> RuleGameKeys
        {
            get
            {
                if ((this._RuleGameKeys == null))
                {
                    this._RuleGameKeys = base.CreateQuery<RuleGameKeys>("RuleGameKeys");
                }
                return this._RuleGameKeys;
            }
        }
        private global::System.Data.Services.Client.DataServiceQuery<RuleGameKeys> _RuleGameKeys;
        /// <summary>
        /// There are no comments for RuleOperandType in the schema.
        /// </summary>
        public global::System.Data.Services.Client.DataServiceQuery<RuleOperandType> RuleOperandType
        {
            get
            {
                if ((this._RuleOperandType == null))
                {
                    this._RuleOperandType = base.CreateQuery<RuleOperandType>("RuleOperandType");
                }
                return this._RuleOperandType;
            }
        }
        private global::System.Data.Services.Client.DataServiceQuery<RuleOperandType> _RuleOperandType;
        /// <summary>
        /// There are no comments for RuleOperator in the schema.
        /// </summary>
        public global::System.Data.Services.Client.DataServiceQuery<RuleOperator> RuleOperator
        {
            get
            {
                if ((this._RuleOperator == null))
                {
                    this._RuleOperator = base.CreateQuery<RuleOperator>("RuleOperator");
                }
                return this._RuleOperator;
            }
        }
        private global::System.Data.Services.Client.DataServiceQuery<RuleOperator> _RuleOperator;
        /// <summary>
        /// There are no comments for StatDescription in the schema.
        /// </summary>
        public global::System.Data.Services.Client.DataServiceQuery<StatDescription> StatDescription
        {
            get
            {
                if ((this._StatDescription == null))
                {
                    this._StatDescription = base.CreateQuery<StatDescription>("StatDescription");
                }
                return this._StatDescription;
            }
        }
        private global::System.Data.Services.Client.DataServiceQuery<StatDescription> _StatDescription;
        /// <summary>
        /// There are no comments for Status in the schema.
        /// </summary>
        public global::System.Data.Services.Client.DataServiceQuery<Status> Status
        {
            get
            {
                if ((this._Status == null))
                {
                    this._Status = base.CreateQuery<Status>("Status");
                }
                return this._Status;
            }
        }
        private global::System.Data.Services.Client.DataServiceQuery<Status> _Status;
        /// <summary>
        /// There are no comments for Action in the schema.
        /// </summary>
        public void AddToAction(Action action)
        {
            base.AddObject("Action", action);
        }
        /// <summary>
        /// There are no comments for ActionDefinition in the schema.
        /// </summary>
        public void AddToActionDefinition(ActionDefinition actionDefinition)
        {
            base.AddObject("ActionDefinition", actionDefinition);
        }
        /// <summary>
        /// There are no comments for ActionParameter in the schema.
        /// </summary>
        public void AddToActionParameter(ActionParameter actionParameter)
        {
            base.AddObject("ActionParameter", actionParameter);
        }
        /// <summary>
        /// There are no comments for ActionParameterDefinition in the schema.
        /// </summary>
        public void AddToActionParameterDefinition(ActionParameterDefinition actionParameterDefinition)
        {
            base.AddObject("ActionParameterDefinition", actionParameterDefinition);
        }
        /// <summary>
        /// There are no comments for ActionSetExecutionType in the schema.
        /// </summary>
        public void AddToActionSetExecutionType(ActionSetExecutionType actionSetExecutionType)
        {
            base.AddObject("ActionSetExecutionType", actionSetExecutionType);
        }
        /// <summary>
        /// There are no comments for ActionSettings in the schema.
        /// </summary>
        public void AddToActionSettings(ActionSettings actionSettings)
        {
            base.AddObject("ActionSettings", actionSettings);
        }
        /// <summary>
        /// There are no comments for ActionSettingsDefinition in the schema.
        /// </summary>
        public void AddToActionSettingsDefinition(ActionSettingsDefinition actionSettingsDefinition)
        {
            base.AddObject("ActionSettingsDefinition", actionSettingsDefinition);
        }
        /// <summary>
        /// There are no comments for Config in the schema.
        /// </summary>
        public void AddToConfig(Config config)
        {
            base.AddObject("Config", config);
        }
        /// <summary>
        /// There are no comments for DataType in the schema.
        /// </summary>
        public void AddToDataType(DataType dataType)
        {
            base.AddObject("DataType", dataType);
        }
        /// <summary>
        /// There are no comments for GameCategories in the schema.
        /// </summary>
        public void AddToGameCategories(GameCategories gameCategories)
        {
            base.AddObject("GameCategories", gameCategories);
        }
        /// <summary>
        /// There are no comments for GameKeys in the schema.
        /// </summary>
        public void AddToGameKeys(GameKeys gameKeys)
        {
            base.AddObject("GameKeys", gameKeys);
        }
        /// <summary>
        /// There are no comments for GameSchemaNames in the schema.
        /// </summary>
        public void AddToGameSchemaNames(GameSchemaNames gameSchemaNames)
        {
            base.AddObject("GameSchemaNames", gameSchemaNames);
        }
        /// <summary>
        /// There are no comments for GameSchemaProperties in the schema.
        /// </summary>
        public void AddToGameSchemaProperties(GameSchemaProperties gameSchemaProperties)
        {
            base.AddObject("GameSchemaProperties", gameSchemaProperties);
        }
        /// <summary>
        /// There are no comments for Locale in the schema.
        /// </summary>
        public void AddToLocale(Locale locale)
        {
            base.AddObject("Locale", locale);
        }
        /// <summary>
        /// There are no comments for Platforms in the schema.
        /// </summary>
        public void AddToPlatforms(Platforms platforms)
        {
            base.AddObject("Platforms", platforms);
        }
        /// <summary>
        /// There are no comments for Reward in the schema.
        /// </summary>
        public void AddToReward(Reward reward)
        {
            base.AddObject("Reward", reward);
        }
        /// <summary>
        /// There are no comments for RewardCategory in the schema.
        /// </summary>
        public void AddToRewardCategory(RewardCategory rewardCategory)
        {
            base.AddObject("RewardCategory", rewardCategory);
        }
        /// <summary>
        /// There are no comments for RewardGameKeys in the schema.
        /// </summary>
        public void AddToRewardGameKeys(RewardGameKeys rewardGameKeys)
        {
            base.AddObject("RewardGameKeys", rewardGameKeys);
        }
        /// <summary>
        /// There are no comments for RewardLocale in the schema.
        /// </summary>
        public void AddToRewardLocale(RewardLocale rewardLocale)
        {
            base.AddObject("RewardLocale", rewardLocale);
        }
        /// <summary>
        /// There are no comments for RewardType in the schema.
        /// </summary>
        public void AddToRewardType(RewardType rewardType)
        {
            base.AddObject("RewardType", rewardType);
        }
        /// <summary>
        /// There are no comments for Rule in the schema.
        /// </summary>
        public void AddToRule(Rule rule)
        {
            base.AddObject("Rule", rule);
        }
        /// <summary>
        /// There are no comments for RuleExpression in the schema.
        /// </summary>
        public void AddToRuleExpression(RuleExpression ruleExpression)
        {
            base.AddObject("RuleExpression", ruleExpression);
        }
        /// <summary>
        /// There are no comments for RuleGameKeys in the schema.
        /// </summary>
        public void AddToRuleGameKeys(RuleGameKeys ruleGameKeys)
        {
            base.AddObject("RuleGameKeys", ruleGameKeys);
        }
        /// <summary>
        /// There are no comments for RuleOperandType in the schema.
        /// </summary>
        public void AddToRuleOperandType(RuleOperandType ruleOperandType)
        {
            base.AddObject("RuleOperandType", ruleOperandType);
        }
        /// <summary>
        /// There are no comments for RuleOperator in the schema.
        /// </summary>
        public void AddToRuleOperator(RuleOperator ruleOperator)
        {
            base.AddObject("RuleOperator", ruleOperator);
        }
        /// <summary>
        /// There are no comments for StatDescription in the schema.
        /// </summary>
        public void AddToStatDescription(StatDescription statDescription)
        {
            base.AddObject("StatDescription", statDescription);
        }
        /// <summary>
        /// There are no comments for Status in the schema.
        /// </summary>
        public void AddToStatus(Status status)
        {
            base.AddObject("Status", status);
        }
    }
    /// <summary>
    /// There are no comments for RewardsDBModel.Action in the schema.
    /// </summary>
    /// <KeyProperties>
    /// ActionID
    /// </KeyProperties>
    [global::System.Data.Services.Common.DataServiceKeyAttribute("ActionID")]
    public partial class Action
    {
        /// <summary>
        /// Create a new Action object.
        /// </summary>
        /// <param name="actionID">Initial value of ActionID.</param>
        /// <param name="dTModified">Initial value of DTModified.</param>
        public static Action CreateAction(int actionID, global::System.DateTime dTModified)
        {
            Action action = new Action();
            action.ActionID = actionID;
            action.DTModified = dTModified;
            return action;
        }
        /// <summary>
        /// There are no comments for Property ActionID in the schema.
        /// </summary>
        public int ActionID
        {
            get
            {
                return this._ActionID;
            }
            set
            {
                this.OnActionIDChanging(value);
                this._ActionID = value;
                this.OnActionIDChanged();
            }
        }
        private int _ActionID;
        partial void OnActionIDChanging(int value);
        partial void OnActionIDChanged();
        /// <summary>
        /// There are no comments for Property ExecuteOrder in the schema.
        /// </summary>
        public global::System.Nullable<int> ExecuteOrder
        {
            get
            {
                return this._ExecuteOrder;
            }
            set
            {
                this.OnExecuteOrderChanging(value);
                this._ExecuteOrder = value;
                this.OnExecuteOrderChanged();
            }
        }
        private global::System.Nullable<int> _ExecuteOrder;
        partial void OnExecuteOrderChanging(global::System.Nullable<int> value);
        partial void OnExecuteOrderChanged();
        /// <summary>
        /// There are no comments for Property DTModified in the schema.
        /// </summary>
        public global::System.DateTime DTModified
        {
            get
            {
                return this._DTModified;
            }
            set
            {
                this.OnDTModifiedChanging(value);
                this._DTModified = value;
                this.OnDTModifiedChanged();
            }
        }
        private global::System.DateTime _DTModified;
        partial void OnDTModifiedChanging(global::System.DateTime value);
        partial void OnDTModifiedChanged();
        /// <summary>
        /// There are no comments for ActionDefinition in the schema.
        /// </summary>
        public ActionDefinition ActionDefinition
        {
            get
            {
                return this._ActionDefinition;
            }
            set
            {
                this._ActionDefinition = value;
            }
        }
        private ActionDefinition _ActionDefinition;
        /// <summary>
        /// There are no comments for Rule in the schema.
        /// </summary>
        public Rule Rule
        {
            get
            {
                return this._Rule;
            }
            set
            {
                this._Rule = value;
            }
        }
        private Rule _Rule;
        /// <summary>
        /// There are no comments for ActionParameter in the schema.
        /// </summary>
        public global::System.Collections.ObjectModel.Collection<ActionParameter> ActionParameter
        {
            get
            {
                return this._ActionParameter;
            }
            set
            {
                if ((value != null))
                {
                    this._ActionParameter = value;
                }
            }
        }
        private global::System.Collections.ObjectModel.Collection<ActionParameter> _ActionParameter = new global::System.Collections.ObjectModel.Collection<ActionParameter>();
        /// <summary>
        /// There are no comments for ActionSettings in the schema.
        /// </summary>
        public global::System.Collections.ObjectModel.Collection<ActionSettings> ActionSettings
        {
            get
            {
                return this._ActionSettings;
            }
            set
            {
                if ((value != null))
                {
                    this._ActionSettings = value;
                }
            }
        }
        private global::System.Collections.ObjectModel.Collection<ActionSettings> _ActionSettings = new global::System.Collections.ObjectModel.Collection<ActionSettings>();
    }
    /// <summary>
    /// There are no comments for RewardsDBModel.ActionDefinition in the schema.
    /// </summary>
    /// <KeyProperties>
    /// ActionDefinitionID
    /// </KeyProperties>
    [global::System.Data.Services.Common.DataServiceKeyAttribute("ActionDefinitionID")]
    public partial class ActionDefinition
    {
        /// <summary>
        /// Create a new ActionDefinition object.
        /// </summary>
        /// <param name="actionDefinitionID">Initial value of ActionDefinitionID.</param>
        /// <param name="name">Initial value of Name.</param>
        /// <param name="dTModified">Initial value of DTModified.</param>
        /// <param name="assemblyName">Initial value of AssemblyName.</param>
        public static ActionDefinition CreateActionDefinition(int actionDefinitionID, string name, global::System.DateTime dTModified, string assemblyName)
        {
            ActionDefinition actionDefinition = new ActionDefinition();
            actionDefinition.ActionDefinitionID = actionDefinitionID;
            actionDefinition.Name = name;
            actionDefinition.DTModified = dTModified;
            actionDefinition.AssemblyName = assemblyName;
            return actionDefinition;
        }
        /// <summary>
        /// There are no comments for Property ActionDefinitionID in the schema.
        /// </summary>
        public int ActionDefinitionID
        {
            get
            {
                return this._ActionDefinitionID;
            }
            set
            {
                this.OnActionDefinitionIDChanging(value);
                this._ActionDefinitionID = value;
                this.OnActionDefinitionIDChanged();
            }
        }
        private int _ActionDefinitionID;
        partial void OnActionDefinitionIDChanging(int value);
        partial void OnActionDefinitionIDChanged();
        /// <summary>
        /// There are no comments for Property Name in the schema.
        /// </summary>
        public string Name
        {
            get
            {
                return this._Name;
            }
            set
            {
                this.OnNameChanging(value);
                this._Name = value;
                this.OnNameChanged();
            }
        }
        private string _Name;
        partial void OnNameChanging(string value);
        partial void OnNameChanged();
        /// <summary>
        /// There are no comments for Property DTModified in the schema.
        /// </summary>
        public global::System.DateTime DTModified
        {
            get
            {
                return this._DTModified;
            }
            set
            {
                this.OnDTModifiedChanging(value);
                this._DTModified = value;
                this.OnDTModifiedChanged();
            }
        }
        private global::System.DateTime _DTModified;
        partial void OnDTModifiedChanging(global::System.DateTime value);
        partial void OnDTModifiedChanged();
        /// <summary>
        /// There are no comments for Property AssemblyName in the schema.
        /// </summary>
        public string AssemblyName
        {
            get
            {
                return this._AssemblyName;
            }
            set
            {
                this.OnAssemblyNameChanging(value);
                this._AssemblyName = value;
                this.OnAssemblyNameChanged();
            }
        }
        private string _AssemblyName;
        partial void OnAssemblyNameChanging(string value);
        partial void OnAssemblyNameChanged();
        /// <summary>
        /// There are no comments for Property Comment in the schema.
        /// </summary>
        public string Comment
        {
            get
            {
                return this._Comment;
            }
            set
            {
                this.OnCommentChanging(value);
                this._Comment = value;
                this.OnCommentChanged();
            }
        }
        private string _Comment;
        partial void OnCommentChanging(string value);
        partial void OnCommentChanged();
        /// <summary>
        /// There are no comments for Action in the schema.
        /// </summary>
        public global::System.Collections.ObjectModel.Collection<Action> Action
        {
            get
            {
                return this._Action;
            }
            set
            {
                if ((value != null))
                {
                    this._Action = value;
                }
            }
        }
        private global::System.Collections.ObjectModel.Collection<Action> _Action = new global::System.Collections.ObjectModel.Collection<Action>();
        /// <summary>
        /// There are no comments for ActionParameterDefinition in the schema.
        /// </summary>
        public global::System.Collections.ObjectModel.Collection<ActionParameterDefinition> ActionParameterDefinition
        {
            get
            {
                return this._ActionParameterDefinition;
            }
            set
            {
                if ((value != null))
                {
                    this._ActionParameterDefinition = value;
                }
            }
        }
        private global::System.Collections.ObjectModel.Collection<ActionParameterDefinition> _ActionParameterDefinition = new global::System.Collections.ObjectModel.Collection<ActionParameterDefinition>();
        /// <summary>
        /// There are no comments for ActionSettingsDefinition in the schema.
        /// </summary>
        public global::System.Collections.ObjectModel.Collection<ActionSettingsDefinition> ActionSettingsDefinition
        {
            get
            {
                return this._ActionSettingsDefinition;
            }
            set
            {
                if ((value != null))
                {
                    this._ActionSettingsDefinition = value;
                }
            }
        }
        private global::System.Collections.ObjectModel.Collection<ActionSettingsDefinition> _ActionSettingsDefinition = new global::System.Collections.ObjectModel.Collection<ActionSettingsDefinition>();
    }
    /// <summary>
    /// There are no comments for RewardsDBModel.ActionParameter in the schema.
    /// </summary>
    /// <KeyProperties>
    /// ActionParameterID
    /// </KeyProperties>
    [global::System.Data.Services.Common.DataServiceKeyAttribute("ActionParameterID")]
    public partial class ActionParameter
    {
        /// <summary>
        /// Create a new ActionParameter object.
        /// </summary>
        /// <param name="actionParameterID">Initial value of ActionParameterID.</param>
        public static ActionParameter CreateActionParameter(int actionParameterID)
        {
            ActionParameter actionParameter = new ActionParameter();
            actionParameter.ActionParameterID = actionParameterID;
            return actionParameter;
        }
        /// <summary>
        /// There are no comments for Property ActionParameterID in the schema.
        /// </summary>
        public int ActionParameterID
        {
            get
            {
                return this._ActionParameterID;
            }
            set
            {
                this.OnActionParameterIDChanging(value);
                this._ActionParameterID = value;
                this.OnActionParameterIDChanged();
            }
        }
        private int _ActionParameterID;
        partial void OnActionParameterIDChanging(int value);
        partial void OnActionParameterIDChanged();
        /// <summary>
        /// There are no comments for Property Path in the schema.
        /// </summary>
        public string Path
        {
            get
            {
                return this._Path;
            }
            set
            {
                this.OnPathChanging(value);
                this._Path = value;
                this.OnPathChanged();
            }
        }
        private string _Path;
        partial void OnPathChanging(string value);
        partial void OnPathChanged();
        /// <summary>
        /// There are no comments for Property Value in the schema.
        /// </summary>
        public string Value
        {
            get
            {
                return this._Value;
            }
            set
            {
                this.OnValueChanging(value);
                this._Value = value;
                this.OnValueChanged();
            }
        }
        private string _Value;
        partial void OnValueChanging(string value);
        partial void OnValueChanged();
        /// <summary>
        /// There are no comments for Action in the schema.
        /// </summary>
        public Action Action
        {
            get
            {
                return this._Action;
            }
            set
            {
                this._Action = value;
            }
        }
        private Action _Action;
        /// <summary>
        /// There are no comments for ActionParameterDefinition in the schema.
        /// </summary>
        public ActionParameterDefinition ActionParameterDefinition
        {
            get
            {
                return this._ActionParameterDefinition;
            }
            set
            {
                this._ActionParameterDefinition = value;
            }
        }
        private ActionParameterDefinition _ActionParameterDefinition;
    }
    /// <summary>
    /// There are no comments for RewardsDBModel.ActionParameterDefinition in the schema.
    /// </summary>
    /// <KeyProperties>
    /// ActionParameterDefinitionID
    /// </KeyProperties>
    [global::System.Data.Services.Common.DataServiceKeyAttribute("ActionParameterDefinitionID")]
    public partial class ActionParameterDefinition
    {
        /// <summary>
        /// Create a new ActionParameterDefinition object.
        /// </summary>
        /// <param name="actionParameterDefinitionID">Initial value of ActionParameterDefinitionID.</param>
        /// <param name="name">Initial value of Name.</param>
        /// <param name="type">Initial value of Type.</param>
        /// <param name="parameterOrder">Initial value of ParameterOrder.</param>
        public static ActionParameterDefinition CreateActionParameterDefinition(int actionParameterDefinitionID, string name, string type, int parameterOrder)
        {
            ActionParameterDefinition actionParameterDefinition = new ActionParameterDefinition();
            actionParameterDefinition.ActionParameterDefinitionID = actionParameterDefinitionID;
            actionParameterDefinition.Name = name;
            actionParameterDefinition.Type = type;
            actionParameterDefinition.ParameterOrder = parameterOrder;
            return actionParameterDefinition;
        }
        /// <summary>
        /// There are no comments for Property ActionParameterDefinitionID in the schema.
        /// </summary>
        public int ActionParameterDefinitionID
        {
            get
            {
                return this._ActionParameterDefinitionID;
            }
            set
            {
                this.OnActionParameterDefinitionIDChanging(value);
                this._ActionParameterDefinitionID = value;
                this.OnActionParameterDefinitionIDChanged();
            }
        }
        private int _ActionParameterDefinitionID;
        partial void OnActionParameterDefinitionIDChanging(int value);
        partial void OnActionParameterDefinitionIDChanged();
        /// <summary>
        /// There are no comments for Property Name in the schema.
        /// </summary>
        public string Name
        {
            get
            {
                return this._Name;
            }
            set
            {
                this.OnNameChanging(value);
                this._Name = value;
                this.OnNameChanged();
            }
        }
        private string _Name;
        partial void OnNameChanging(string value);
        partial void OnNameChanged();
        /// <summary>
        /// There are no comments for Property Type in the schema.
        /// </summary>
        public string Type
        {
            get
            {
                return this._Type;
            }
            set
            {
                this.OnTypeChanging(value);
                this._Type = value;
                this.OnTypeChanged();
            }
        }
        private string _Type;
        partial void OnTypeChanging(string value);
        partial void OnTypeChanged();
        /// <summary>
        /// There are no comments for Property ParameterOrder in the schema.
        /// </summary>
        public int ParameterOrder
        {
            get
            {
                return this._ParameterOrder;
            }
            set
            {
                this.OnParameterOrderChanging(value);
                this._ParameterOrder = value;
                this.OnParameterOrderChanged();
            }
        }
        private int _ParameterOrder;
        partial void OnParameterOrderChanging(int value);
        partial void OnParameterOrderChanged();
        /// <summary>
        /// There are no comments for Property PathRequired in the schema.
        /// </summary>
        public global::System.Nullable<bool> PathRequired
        {
            get
            {
                return this._PathRequired;
            }
            set
            {
                this.OnPathRequiredChanging(value);
                this._PathRequired = value;
                this.OnPathRequiredChanged();
            }
        }
        private global::System.Nullable<bool> _PathRequired;
        partial void OnPathRequiredChanging(global::System.Nullable<bool> value);
        partial void OnPathRequiredChanged();
        /// <summary>
        /// There are no comments for Property ValueRequired in the schema.
        /// </summary>
        public global::System.Nullable<bool> ValueRequired
        {
            get
            {
                return this._ValueRequired;
            }
            set
            {
                this.OnValueRequiredChanging(value);
                this._ValueRequired = value;
                this.OnValueRequiredChanged();
            }
        }
        private global::System.Nullable<bool> _ValueRequired;
        partial void OnValueRequiredChanging(global::System.Nullable<bool> value);
        partial void OnValueRequiredChanged();
        /// <summary>
        /// There are no comments for Property Comment in the schema.
        /// </summary>
        public string Comment
        {
            get
            {
                return this._Comment;
            }
            set
            {
                this.OnCommentChanging(value);
                this._Comment = value;
                this.OnCommentChanged();
            }
        }
        private string _Comment;
        partial void OnCommentChanging(string value);
        partial void OnCommentChanged();
        /// <summary>
        /// There are no comments for ActionDefinition in the schema.
        /// </summary>
        public ActionDefinition ActionDefinition
        {
            get
            {
                return this._ActionDefinition;
            }
            set
            {
                this._ActionDefinition = value;
            }
        }
        private ActionDefinition _ActionDefinition;
        /// <summary>
        /// There are no comments for ActionParameter in the schema.
        /// </summary>
        public global::System.Collections.ObjectModel.Collection<ActionParameter> ActionParameter
        {
            get
            {
                return this._ActionParameter;
            }
            set
            {
                if ((value != null))
                {
                    this._ActionParameter = value;
                }
            }
        }
        private global::System.Collections.ObjectModel.Collection<ActionParameter> _ActionParameter = new global::System.Collections.ObjectModel.Collection<ActionParameter>();
        /// <summary>
        /// There are no comments for DataType in the schema.
        /// </summary>
        public DataType DataType
        {
            get
            {
                return this._DataType;
            }
            set
            {
                this._DataType = value;
            }
        }
        private DataType _DataType;
    }
    /// <summary>
    /// There are no comments for RewardsDBModel.ActionSetExecutionType in the schema.
    /// </summary>
    /// <KeyProperties>
    /// ActionSetExecutionTypeID
    /// </KeyProperties>
    [global::System.Data.Services.Common.DataServiceKeyAttribute("ActionSetExecutionTypeID")]
    public partial class ActionSetExecutionType
    {
        /// <summary>
        /// Create a new ActionSetExecutionType object.
        /// </summary>
        /// <param name="actionSetExecutionTypeID">Initial value of ActionSetExecutionTypeID.</param>
        /// <param name="executionType">Initial value of ExecutionType.</param>
        public static ActionSetExecutionType CreateActionSetExecutionType(int actionSetExecutionTypeID, string executionType)
        {
            ActionSetExecutionType actionSetExecutionType = new ActionSetExecutionType();
            actionSetExecutionType.ActionSetExecutionTypeID = actionSetExecutionTypeID;
            actionSetExecutionType.ExecutionType = executionType;
            return actionSetExecutionType;
        }
        /// <summary>
        /// There are no comments for Property ActionSetExecutionTypeID in the schema.
        /// </summary>
        public int ActionSetExecutionTypeID
        {
            get
            {
                return this._ActionSetExecutionTypeID;
            }
            set
            {
                this.OnActionSetExecutionTypeIDChanging(value);
                this._ActionSetExecutionTypeID = value;
                this.OnActionSetExecutionTypeIDChanged();
            }
        }
        private int _ActionSetExecutionTypeID;
        partial void OnActionSetExecutionTypeIDChanging(int value);
        partial void OnActionSetExecutionTypeIDChanged();
        /// <summary>
        /// There are no comments for Property ExecutionType in the schema.
        /// </summary>
        public string ExecutionType
        {
            get
            {
                return this._ExecutionType;
            }
            set
            {
                this.OnExecutionTypeChanging(value);
                this._ExecutionType = value;
                this.OnExecutionTypeChanged();
            }
        }
        private string _ExecutionType;
        partial void OnExecutionTypeChanging(string value);
        partial void OnExecutionTypeChanged();
        /// <summary>
        /// There are no comments for Rule in the schema.
        /// </summary>
        public global::System.Collections.ObjectModel.Collection<Rule> Rule
        {
            get
            {
                return this._Rule;
            }
            set
            {
                if ((value != null))
                {
                    this._Rule = value;
                }
            }
        }
        private global::System.Collections.ObjectModel.Collection<Rule> _Rule = new global::System.Collections.ObjectModel.Collection<Rule>();
    }
    /// <summary>
    /// There are no comments for RewardsDBModel.ActionSettings in the schema.
    /// </summary>
    /// <KeyProperties>
    /// ActionSettingsID
    /// </KeyProperties>
    [global::System.Data.Services.Common.DataServiceKeyAttribute("ActionSettingsID")]
    public partial class ActionSettings
    {
        /// <summary>
        /// Create a new ActionSettings object.
        /// </summary>
        /// <param name="actionSettingsID">Initial value of ActionSettingsID.</param>
        /// <param name="settingXml">Initial value of SettingXml.</param>
        /// <param name="dTModified">Initial value of DTModified.</param>
        public static ActionSettings CreateActionSettings(int actionSettingsID, string settingXml, global::System.DateTime dTModified)
        {
            ActionSettings actionSettings = new ActionSettings();
            actionSettings.ActionSettingsID = actionSettingsID;
            actionSettings.SettingXml = settingXml;
            actionSettings.DTModified = dTModified;
            return actionSettings;
        }
        /// <summary>
        /// There are no comments for Property ActionSettingsID in the schema.
        /// </summary>
        public int ActionSettingsID
        {
            get
            {
                return this._ActionSettingsID;
            }
            set
            {
                this.OnActionSettingsIDChanging(value);
                this._ActionSettingsID = value;
                this.OnActionSettingsIDChanged();
            }
        }
        private int _ActionSettingsID;
        partial void OnActionSettingsIDChanging(int value);
        partial void OnActionSettingsIDChanged();
        /// <summary>
        /// There are no comments for Property SettingXml in the schema.
        /// </summary>
        public string SettingXml
        {
            get
            {
                return this._SettingXml;
            }
            set
            {
                this.OnSettingXmlChanging(value);
                this._SettingXml = value;
                this.OnSettingXmlChanged();
            }
        }
        private string _SettingXml;
        partial void OnSettingXmlChanging(string value);
        partial void OnSettingXmlChanged();
        /// <summary>
        /// There are no comments for Property DTModified in the schema.
        /// </summary>
        public global::System.DateTime DTModified
        {
            get
            {
                return this._DTModified;
            }
            set
            {
                this.OnDTModifiedChanging(value);
                this._DTModified = value;
                this.OnDTModifiedChanged();
            }
        }
        private global::System.DateTime _DTModified;
        partial void OnDTModifiedChanging(global::System.DateTime value);
        partial void OnDTModifiedChanged();
        /// <summary>
        /// There are no comments for Property Comment in the schema.
        /// </summary>
        public string Comment
        {
            get
            {
                return this._Comment;
            }
            set
            {
                this.OnCommentChanging(value);
                this._Comment = value;
                this.OnCommentChanged();
            }
        }
        private string _Comment;
        partial void OnCommentChanging(string value);
        partial void OnCommentChanged();
        /// <summary>
        /// There are no comments for Action in the schema.
        /// </summary>
        public Action Action
        {
            get
            {
                return this._Action;
            }
            set
            {
                this._Action = value;
            }
        }
        private Action _Action;
        /// <summary>
        /// There are no comments for ActionSettingsDefinition in the schema.
        /// </summary>
        public ActionSettingsDefinition ActionSettingsDefinition
        {
            get
            {
                return this._ActionSettingsDefinition;
            }
            set
            {
                this._ActionSettingsDefinition = value;
            }
        }
        private ActionSettingsDefinition _ActionSettingsDefinition;
    }
    /// <summary>
    /// There are no comments for RewardsDBModel.ActionSettingsDefinition in the schema.
    /// </summary>
    /// <KeyProperties>
    /// ActionSettingsDefinitionID
    /// </KeyProperties>
    [global::System.Data.Services.Common.DataServiceKeyAttribute("ActionSettingsDefinitionID")]
    public partial class ActionSettingsDefinition
    {
        /// <summary>
        /// Create a new ActionSettingsDefinition object.
        /// </summary>
        /// <param name="actionSettingsDefinitionID">Initial value of ActionSettingsDefinitionID.</param>
        /// <param name="name">Initial value of Name.</param>
        /// <param name="settingSchema">Initial value of SettingSchema.</param>
        /// <param name="dTModified">Initial value of DTModified.</param>
        public static ActionSettingsDefinition CreateActionSettingsDefinition(int actionSettingsDefinitionID, string name, string settingSchema, global::System.DateTime dTModified)
        {
            ActionSettingsDefinition actionSettingsDefinition = new ActionSettingsDefinition();
            actionSettingsDefinition.ActionSettingsDefinitionID = actionSettingsDefinitionID;
            actionSettingsDefinition.Name = name;
            actionSettingsDefinition.SettingSchema = settingSchema;
            actionSettingsDefinition.DTModified = dTModified;
            return actionSettingsDefinition;
        }
        /// <summary>
        /// There are no comments for Property ActionSettingsDefinitionID in the schema.
        /// </summary>
        public int ActionSettingsDefinitionID
        {
            get
            {
                return this._ActionSettingsDefinitionID;
            }
            set
            {
                this.OnActionSettingsDefinitionIDChanging(value);
                this._ActionSettingsDefinitionID = value;
                this.OnActionSettingsDefinitionIDChanged();
            }
        }
        private int _ActionSettingsDefinitionID;
        partial void OnActionSettingsDefinitionIDChanging(int value);
        partial void OnActionSettingsDefinitionIDChanged();
        /// <summary>
        /// There are no comments for Property Name in the schema.
        /// </summary>
        public string Name
        {
            get
            {
                return this._Name;
            }
            set
            {
                this.OnNameChanging(value);
                this._Name = value;
                this.OnNameChanged();
            }
        }
        private string _Name;
        partial void OnNameChanging(string value);
        partial void OnNameChanged();
        /// <summary>
        /// There are no comments for Property SettingSchema in the schema.
        /// </summary>
        public string SettingSchema
        {
            get
            {
                return this._SettingSchema;
            }
            set
            {
                this.OnSettingSchemaChanging(value);
                this._SettingSchema = value;
                this.OnSettingSchemaChanged();
            }
        }
        private string _SettingSchema;
        partial void OnSettingSchemaChanging(string value);
        partial void OnSettingSchemaChanged();
        /// <summary>
        /// There are no comments for Property DTModified in the schema.
        /// </summary>
        public global::System.DateTime DTModified
        {
            get
            {
                return this._DTModified;
            }
            set
            {
                this.OnDTModifiedChanging(value);
                this._DTModified = value;
                this.OnDTModifiedChanged();
            }
        }
        private global::System.DateTime _DTModified;
        partial void OnDTModifiedChanging(global::System.DateTime value);
        partial void OnDTModifiedChanged();
        /// <summary>
        /// There are no comments for Property Comment in the schema.
        /// </summary>
        public string Comment
        {
            get
            {
                return this._Comment;
            }
            set
            {
                this.OnCommentChanging(value);
                this._Comment = value;
                this.OnCommentChanged();
            }
        }
        private string _Comment;
        partial void OnCommentChanging(string value);
        partial void OnCommentChanged();
        /// <summary>
        /// There are no comments for ActionDefinition in the schema.
        /// </summary>
        public ActionDefinition ActionDefinition
        {
            get
            {
                return this._ActionDefinition;
            }
            set
            {
                this._ActionDefinition = value;
            }
        }
        private ActionDefinition _ActionDefinition;
        /// <summary>
        /// There are no comments for ActionSettings in the schema.
        /// </summary>
        public global::System.Collections.ObjectModel.Collection<ActionSettings> ActionSettings
        {
            get
            {
                return this._ActionSettings;
            }
            set
            {
                if ((value != null))
                {
                    this._ActionSettings = value;
                }
            }
        }
        private global::System.Collections.ObjectModel.Collection<ActionSettings> _ActionSettings = new global::System.Collections.ObjectModel.Collection<ActionSettings>();
    }
    /// <summary>
    /// There are no comments for RewardsDBModel.Config in the schema.
    /// </summary>
    /// <KeyProperties>
    /// ConfigID
    /// Name
    /// Value
    /// DTModified
    /// </KeyProperties>
    [global::System.Data.Services.Common.DataServiceKeyAttribute("ConfigID", "Name", "Value", "DTModified")]
    public partial class Config
    {
        /// <summary>
        /// Create a new Config object.
        /// </summary>
        /// <param name="configID">Initial value of ConfigID.</param>
        /// <param name="name">Initial value of Name.</param>
        /// <param name="value">Initial value of Value.</param>
        /// <param name="dTModified">Initial value of DTModified.</param>
        public static Config CreateConfig(int configID, string name, string value, global::System.DateTime dTModified)
        {
            Config config = new Config();
            config.ConfigID = configID;
            config.Name = name;
            config.Value = value;
            config.DTModified = dTModified;
            return config;
        }
        /// <summary>
        /// There are no comments for Property ConfigID in the schema.
        /// </summary>
        public int ConfigID
        {
            get
            {
                return this._ConfigID;
            }
            set
            {
                this.OnConfigIDChanging(value);
                this._ConfigID = value;
                this.OnConfigIDChanged();
            }
        }
        private int _ConfigID;
        partial void OnConfigIDChanging(int value);
        partial void OnConfigIDChanged();
        /// <summary>
        /// There are no comments for Property Name in the schema.
        /// </summary>
        public string Name
        {
            get
            {
                return this._Name;
            }
            set
            {
                this.OnNameChanging(value);
                this._Name = value;
                this.OnNameChanged();
            }
        }
        private string _Name;
        partial void OnNameChanging(string value);
        partial void OnNameChanged();
        /// <summary>
        /// There are no comments for Property Value in the schema.
        /// </summary>
        public string Value
        {
            get
            {
                return this._Value;
            }
            set
            {
                this.OnValueChanging(value);
                this._Value = value;
                this.OnValueChanged();
            }
        }
        private string _Value;
        partial void OnValueChanging(string value);
        partial void OnValueChanged();
        /// <summary>
        /// There are no comments for Property DTModified in the schema.
        /// </summary>
        public global::System.DateTime DTModified
        {
            get
            {
                return this._DTModified;
            }
            set
            {
                this.OnDTModifiedChanging(value);
                this._DTModified = value;
                this.OnDTModifiedChanged();
            }
        }
        private global::System.DateTime _DTModified;
        partial void OnDTModifiedChanging(global::System.DateTime value);
        partial void OnDTModifiedChanged();
    }
    /// <summary>
    /// There are no comments for RewardsDBModel.DataType in the schema.
    /// </summary>
    /// <KeyProperties>
    /// DataTypeID
    /// </KeyProperties>
    [global::System.Data.Services.Common.DataServiceKeyAttribute("DataTypeID")]
    public partial class DataType
    {
        /// <summary>
        /// Create a new DataType object.
        /// </summary>
        /// <param name="dataTypeID">Initial value of DataTypeID.</param>
        /// <param name="dataTypeString">Initial value of DataTypeString.</param>
        public static DataType CreateDataType(int dataTypeID, string dataTypeString)
        {
            DataType dataType = new DataType();
            dataType.DataTypeID = dataTypeID;
            dataType.DataTypeString = dataTypeString;
            return dataType;
        }
        /// <summary>
        /// There are no comments for Property DataTypeID in the schema.
        /// </summary>
        public int DataTypeID
        {
            get
            {
                return this._DataTypeID;
            }
            set
            {
                this.OnDataTypeIDChanging(value);
                this._DataTypeID = value;
                this.OnDataTypeIDChanged();
            }
        }
        private int _DataTypeID;
        partial void OnDataTypeIDChanging(int value);
        partial void OnDataTypeIDChanged();
        /// <summary>
        /// There are no comments for Property DataTypeString in the schema.
        /// </summary>
        public string DataTypeString
        {
            get
            {
                return this._DataTypeString;
            }
            set
            {
                this.OnDataTypeStringChanging(value);
                this._DataTypeString = value;
                this.OnDataTypeStringChanged();
            }
        }
        private string _DataTypeString;
        partial void OnDataTypeStringChanging(string value);
        partial void OnDataTypeStringChanged();
        /// <summary>
        /// There are no comments for ActionParameterDefinition in the schema.
        /// </summary>
        public global::System.Collections.ObjectModel.Collection<ActionParameterDefinition> ActionParameterDefinition
        {
            get
            {
                return this._ActionParameterDefinition;
            }
            set
            {
                if ((value != null))
                {
                    this._ActionParameterDefinition = value;
                }
            }
        }
        private global::System.Collections.ObjectModel.Collection<ActionParameterDefinition> _ActionParameterDefinition = new global::System.Collections.ObjectModel.Collection<ActionParameterDefinition>();
        /// <summary>
        /// There are no comments for GameSchemaProperties in the schema.
        /// </summary>
        public global::System.Collections.ObjectModel.Collection<GameSchemaProperties> GameSchemaProperties
        {
            get
            {
                return this._GameSchemaProperties;
            }
            set
            {
                if ((value != null))
                {
                    this._GameSchemaProperties = value;
                }
            }
        }
        private global::System.Collections.ObjectModel.Collection<GameSchemaProperties> _GameSchemaProperties = new global::System.Collections.ObjectModel.Collection<GameSchemaProperties>();
        /// <summary>
        /// There are no comments for RuleExpression in the schema.
        /// </summary>
        public global::System.Collections.ObjectModel.Collection<RuleExpression> RuleExpression
        {
            get
            {
                return this._RuleExpression;
            }
            set
            {
                if ((value != null))
                {
                    this._RuleExpression = value;
                }
            }
        }
        private global::System.Collections.ObjectModel.Collection<RuleExpression> _RuleExpression = new global::System.Collections.ObjectModel.Collection<RuleExpression>();
        /// <summary>
        /// There are no comments for StatDescription in the schema.
        /// </summary>
        public global::System.Collections.ObjectModel.Collection<StatDescription> StatDescription
        {
            get
            {
                return this._StatDescription;
            }
            set
            {
                if ((value != null))
                {
                    this._StatDescription = value;
                }
            }
        }
        private global::System.Collections.ObjectModel.Collection<StatDescription> _StatDescription = new global::System.Collections.ObjectModel.Collection<StatDescription>();
    }
    /// <summary>
    /// There are no comments for RewardsDBModel.GameCategories in the schema.
    /// </summary>
    /// <KeyProperties>
    /// GameCategoryID
    /// </KeyProperties>
    [global::System.Data.Services.Common.DataServiceKeyAttribute("GameCategoryID")]
    public partial class GameCategories
    {
        /// <summary>
        /// Create a new GameCategories object.
        /// </summary>
        /// <param name="gameCategoryID">Initial value of GameCategoryID.</param>
        /// <param name="name">Initial value of Name.</param>
        /// <param name="dTModified">Initial value of DTModified.</param>
        public static GameCategories CreateGameCategories(int gameCategoryID, string name, global::System.DateTime dTModified)
        {
            GameCategories gameCategories = new GameCategories();
            gameCategories.GameCategoryID = gameCategoryID;
            gameCategories.Name = name;
            gameCategories.DTModified = dTModified;
            return gameCategories;
        }
        /// <summary>
        /// There are no comments for Property GameCategoryID in the schema.
        /// </summary>
        public int GameCategoryID
        {
            get
            {
                return this._GameCategoryID;
            }
            set
            {
                this.OnGameCategoryIDChanging(value);
                this._GameCategoryID = value;
                this.OnGameCategoryIDChanged();
            }
        }
        private int _GameCategoryID;
        partial void OnGameCategoryIDChanging(int value);
        partial void OnGameCategoryIDChanged();
        /// <summary>
        /// There are no comments for Property Name in the schema.
        /// </summary>
        public string Name
        {
            get
            {
                return this._Name;
            }
            set
            {
                this.OnNameChanging(value);
                this._Name = value;
                this.OnNameChanged();
            }
        }
        private string _Name;
        partial void OnNameChanging(string value);
        partial void OnNameChanged();
        /// <summary>
        /// There are no comments for Property Comment in the schema.
        /// </summary>
        public string Comment
        {
            get
            {
                return this._Comment;
            }
            set
            {
                this.OnCommentChanging(value);
                this._Comment = value;
                this.OnCommentChanged();
            }
        }
        private string _Comment;
        partial void OnCommentChanging(string value);
        partial void OnCommentChanged();
        /// <summary>
        /// There are no comments for Property DTModified in the schema.
        /// </summary>
        public global::System.DateTime DTModified
        {
            get
            {
                return this._DTModified;
            }
            set
            {
                this.OnDTModifiedChanging(value);
                this._DTModified = value;
                this.OnDTModifiedChanged();
            }
        }
        private global::System.DateTime _DTModified;
        partial void OnDTModifiedChanging(global::System.DateTime value);
        partial void OnDTModifiedChanged();
    }
    /// <summary>
    /// There are no comments for RewardsDBModel.GameKeys in the schema.
    /// </summary>
    /// <KeyProperties>
    /// GameKeyID
    /// </KeyProperties>
    [global::System.Data.Services.Common.DataServiceKeyAttribute("GameKeyID")]
    public partial class GameKeys
    {
        /// <summary>
        /// Create a new GameKeys object.
        /// </summary>
        /// <param name="gameKeyID">Initial value of GameKeyID.</param>
        /// <param name="name">Initial value of Name.</param>
        /// <param name="dTModified">Initial value of DTModified.</param>
        public static GameKeys CreateGameKeys(int gameKeyID, string name, global::System.DateTime dTModified)
        {
            GameKeys gameKeys = new GameKeys();
            gameKeys.GameKeyID = gameKeyID;
            gameKeys.Name = name;
            gameKeys.DTModified = dTModified;
            return gameKeys;
        }
        /// <summary>
        /// There are no comments for Property GameKeyID in the schema.
        /// </summary>
        public int GameKeyID
        {
            get
            {
                return this._GameKeyID;
            }
            set
            {
                this.OnGameKeyIDChanging(value);
                this._GameKeyID = value;
                this.OnGameKeyIDChanged();
            }
        }
        private int _GameKeyID;
        partial void OnGameKeyIDChanging(int value);
        partial void OnGameKeyIDChanged();
        /// <summary>
        /// There are no comments for Property Name in the schema.
        /// </summary>
        public string Name
        {
            get
            {
                return this._Name;
            }
            set
            {
                this.OnNameChanging(value);
                this._Name = value;
                this.OnNameChanged();
            }
        }
        private string _Name;
        partial void OnNameChanging(string value);
        partial void OnNameChanged();
        /// <summary>
        /// There are no comments for Property Comment in the schema.
        /// </summary>
        public string Comment
        {
            get
            {
                return this._Comment;
            }
            set
            {
                this.OnCommentChanging(value);
                this._Comment = value;
                this.OnCommentChanged();
            }
        }
        private string _Comment;
        partial void OnCommentChanging(string value);
        partial void OnCommentChanged();
        /// <summary>
        /// There are no comments for Property DTModified in the schema.
        /// </summary>
        public global::System.DateTime DTModified
        {
            get
            {
                return this._DTModified;
            }
            set
            {
                this.OnDTModifiedChanging(value);
                this._DTModified = value;
                this.OnDTModifiedChanged();
            }
        }
        private global::System.DateTime _DTModified;
        partial void OnDTModifiedChanging(global::System.DateTime value);
        partial void OnDTModifiedChanged();
        /// <summary>
        /// There are no comments for Platforms in the schema.
        /// </summary>
        public Platforms Platforms
        {
            get
            {
                return this._Platforms;
            }
            set
            {
                this._Platforms = value;
            }
        }
        private Platforms _Platforms;
        /// <summary>
        /// There are no comments for GameSchemaNames in the schema.
        /// </summary>
        public global::System.Collections.ObjectModel.Collection<GameSchemaNames> GameSchemaNames
        {
            get
            {
                return this._GameSchemaNames;
            }
            set
            {
                if ((value != null))
                {
                    this._GameSchemaNames = value;
                }
            }
        }
        private global::System.Collections.ObjectModel.Collection<GameSchemaNames> _GameSchemaNames = new global::System.Collections.ObjectModel.Collection<GameSchemaNames>();
        /// <summary>
        /// There are no comments for RuleGameKeys in the schema.
        /// </summary>
        public global::System.Collections.ObjectModel.Collection<RuleGameKeys> RuleGameKeys
        {
            get
            {
                return this._RuleGameKeys;
            }
            set
            {
                if ((value != null))
                {
                    this._RuleGameKeys = value;
                }
            }
        }
        private global::System.Collections.ObjectModel.Collection<RuleGameKeys> _RuleGameKeys = new global::System.Collections.ObjectModel.Collection<RuleGameKeys>();
        /// <summary>
        /// There are no comments for StatDescription in the schema.
        /// </summary>
        public global::System.Collections.ObjectModel.Collection<StatDescription> StatDescription
        {
            get
            {
                return this._StatDescription;
            }
            set
            {
                if ((value != null))
                {
                    this._StatDescription = value;
                }
            }
        }
        private global::System.Collections.ObjectModel.Collection<StatDescription> _StatDescription = new global::System.Collections.ObjectModel.Collection<StatDescription>();
    }
    /// <summary>
    /// There are no comments for RewardsDBModel.GameSchemaNames in the schema.
    /// </summary>
    /// <KeyProperties>
    /// GameSchemaNameID
    /// </KeyProperties>
    [global::System.Data.Services.Common.DataServiceKeyAttribute("GameSchemaNameID")]
    public partial class GameSchemaNames
    {
        /// <summary>
        /// Create a new GameSchemaNames object.
        /// </summary>
        /// <param name="gameSchemaNameID">Initial value of GameSchemaNameID.</param>
        /// <param name="name">Initial value of Name.</param>
        /// <param name="ordered">Initial value of Ordered.</param>
        /// <param name="dTModified">Initial value of DTModified.</param>
        public static GameSchemaNames CreateGameSchemaNames(int gameSchemaNameID, string name, bool ordered, global::System.DateTime dTModified)
        {
            GameSchemaNames gameSchemaNames = new GameSchemaNames();
            gameSchemaNames.GameSchemaNameID = gameSchemaNameID;
            gameSchemaNames.Name = name;
            gameSchemaNames.Ordered = ordered;
            gameSchemaNames.DTModified = dTModified;
            return gameSchemaNames;
        }
        /// <summary>
        /// There are no comments for Property GameSchemaNameID in the schema.
        /// </summary>
        public int GameSchemaNameID
        {
            get
            {
                return this._GameSchemaNameID;
            }
            set
            {
                this.OnGameSchemaNameIDChanging(value);
                this._GameSchemaNameID = value;
                this.OnGameSchemaNameIDChanged();
            }
        }
        private int _GameSchemaNameID;
        partial void OnGameSchemaNameIDChanging(int value);
        partial void OnGameSchemaNameIDChanged();
        /// <summary>
        /// There are no comments for Property Name in the schema.
        /// </summary>
        public string Name
        {
            get
            {
                return this._Name;
            }
            set
            {
                this.OnNameChanging(value);
                this._Name = value;
                this.OnNameChanged();
            }
        }
        private string _Name;
        partial void OnNameChanging(string value);
        partial void OnNameChanged();
        /// <summary>
        /// There are no comments for Property Ordered in the schema.
        /// </summary>
        public bool Ordered
        {
            get
            {
                return this._Ordered;
            }
            set
            {
                this.OnOrderedChanging(value);
                this._Ordered = value;
                this.OnOrderedChanged();
            }
        }
        private bool _Ordered;
        partial void OnOrderedChanging(bool value);
        partial void OnOrderedChanged();
        /// <summary>
        /// There are no comments for Property Comment in the schema.
        /// </summary>
        public string Comment
        {
            get
            {
                return this._Comment;
            }
            set
            {
                this.OnCommentChanging(value);
                this._Comment = value;
                this.OnCommentChanged();
            }
        }
        private string _Comment;
        partial void OnCommentChanging(string value);
        partial void OnCommentChanged();
        /// <summary>
        /// There are no comments for Property DTModified in the schema.
        /// </summary>
        public global::System.DateTime DTModified
        {
            get
            {
                return this._DTModified;
            }
            set
            {
                this.OnDTModifiedChanging(value);
                this._DTModified = value;
                this.OnDTModifiedChanged();
            }
        }
        private global::System.DateTime _DTModified;
        partial void OnDTModifiedChanging(global::System.DateTime value);
        partial void OnDTModifiedChanged();
        /// <summary>
        /// There are no comments for GameKeys in the schema.
        /// </summary>
        public GameKeys GameKeys
        {
            get
            {
                return this._GameKeys;
            }
            set
            {
                this._GameKeys = value;
            }
        }
        private GameKeys _GameKeys;
        /// <summary>
        /// There are no comments for GameSchemaProperties in the schema.
        /// </summary>
        public global::System.Collections.ObjectModel.Collection<GameSchemaProperties> GameSchemaProperties
        {
            get
            {
                return this._GameSchemaProperties;
            }
            set
            {
                if ((value != null))
                {
                    this._GameSchemaProperties = value;
                }
            }
        }
        private global::System.Collections.ObjectModel.Collection<GameSchemaProperties> _GameSchemaProperties = new global::System.Collections.ObjectModel.Collection<GameSchemaProperties>();
    }
    /// <summary>
    /// There are no comments for RewardsDBModel.GameSchemaProperties in the schema.
    /// </summary>
    /// <KeyProperties>
    /// GameSchemaPropertyID
    /// </KeyProperties>
    [global::System.Data.Services.Common.DataServiceKeyAttribute("GameSchemaPropertyID")]
    public partial class GameSchemaProperties
    {
        /// <summary>
        /// Create a new GameSchemaProperties object.
        /// </summary>
        /// <param name="gameSchemaPropertyID">Initial value of GameSchemaPropertyID.</param>
        /// <param name="name">Initial value of Name.</param>
        /// <param name="order">Initial value of Order.</param>
        /// <param name="required">Initial value of Required.</param>
        /// <param name="dTModified">Initial value of DTModified.</param>
        public static GameSchemaProperties CreateGameSchemaProperties(int gameSchemaPropertyID, string name, int order, bool required, global::System.DateTime dTModified)
        {
            GameSchemaProperties gameSchemaProperties = new GameSchemaProperties();
            gameSchemaProperties.GameSchemaPropertyID = gameSchemaPropertyID;
            gameSchemaProperties.Name = name;
            gameSchemaProperties.Order = order;
            gameSchemaProperties.Required = required;
            gameSchemaProperties.DTModified = dTModified;
            return gameSchemaProperties;
        }
        /// <summary>
        /// There are no comments for Property GameSchemaPropertyID in the schema.
        /// </summary>
        public int GameSchemaPropertyID
        {
            get
            {
                return this._GameSchemaPropertyID;
            }
            set
            {
                this.OnGameSchemaPropertyIDChanging(value);
                this._GameSchemaPropertyID = value;
                this.OnGameSchemaPropertyIDChanged();
            }
        }
        private int _GameSchemaPropertyID;
        partial void OnGameSchemaPropertyIDChanging(int value);
        partial void OnGameSchemaPropertyIDChanged();
        /// <summary>
        /// There are no comments for Property Name in the schema.
        /// </summary>
        public string Name
        {
            get
            {
                return this._Name;
            }
            set
            {
                this.OnNameChanging(value);
                this._Name = value;
                this.OnNameChanged();
            }
        }
        private string _Name;
        partial void OnNameChanging(string value);
        partial void OnNameChanged();
        /// <summary>
        /// There are no comments for Property Order in the schema.
        /// </summary>
        public int Order
        {
            get
            {
                return this._Order;
            }
            set
            {
                this.OnOrderChanging(value);
                this._Order = value;
                this.OnOrderChanged();
            }
        }
        private int _Order;
        partial void OnOrderChanging(int value);
        partial void OnOrderChanged();
        /// <summary>
        /// There are no comments for Property Required in the schema.
        /// </summary>
        public bool Required
        {
            get
            {
                return this._Required;
            }
            set
            {
                this.OnRequiredChanging(value);
                this._Required = value;
                this.OnRequiredChanged();
            }
        }
        private bool _Required;
        partial void OnRequiredChanging(bool value);
        partial void OnRequiredChanged();
        /// <summary>
        /// There are no comments for Property Comment in the schema.
        /// </summary>
        public string Comment
        {
            get
            {
                return this._Comment;
            }
            set
            {
                this.OnCommentChanging(value);
                this._Comment = value;
                this.OnCommentChanged();
            }
        }
        private string _Comment;
        partial void OnCommentChanging(string value);
        partial void OnCommentChanged();
        /// <summary>
        /// There are no comments for Property DTModified in the schema.
        /// </summary>
        public global::System.DateTime DTModified
        {
            get
            {
                return this._DTModified;
            }
            set
            {
                this.OnDTModifiedChanging(value);
                this._DTModified = value;
                this.OnDTModifiedChanged();
            }
        }
        private global::System.DateTime _DTModified;
        partial void OnDTModifiedChanging(global::System.DateTime value);
        partial void OnDTModifiedChanged();
        /// <summary>
        /// There are no comments for DataType in the schema.
        /// </summary>
        public DataType DataType
        {
            get
            {
                return this._DataType;
            }
            set
            {
                this._DataType = value;
            }
        }
        private DataType _DataType;
        /// <summary>
        /// There are no comments for GameSchemaNames in the schema.
        /// </summary>
        public GameSchemaNames GameSchemaNames
        {
            get
            {
                return this._GameSchemaNames;
            }
            set
            {
                this._GameSchemaNames = value;
            }
        }
        private GameSchemaNames _GameSchemaNames;
    }
    /// <summary>
    /// There are no comments for RewardsDBModel.Locale in the schema.
    /// </summary>
    /// <KeyProperties>
    /// LCID
    /// </KeyProperties>
    [global::System.Data.Services.Common.DataServiceKeyAttribute("LCID")]
    public partial class Locale
    {
        /// <summary>
        /// Create a new Locale object.
        /// </summary>
        /// <param name="lCID">Initial value of LCID.</param>
        /// <param name="locale1">Initial value of Locale1.</param>
        /// <param name="collation">Initial value of Collation.</param>
        /// <param name="dTModified">Initial value of DTModified.</param>
        public static Locale CreateLocale(int lCID, string locale1, string collation, global::System.DateTime dTModified)
        {
            Locale locale = new Locale();
            locale.LCID = lCID;
            locale.Locale1 = locale1;
            locale.Collation = collation;
            locale.DTModified = dTModified;
            return locale;
        }
        /// <summary>
        /// There are no comments for Property LCID in the schema.
        /// </summary>
        public int LCID
        {
            get
            {
                return this._LCID;
            }
            set
            {
                this.OnLCIDChanging(value);
                this._LCID = value;
                this.OnLCIDChanged();
            }
        }
        private int _LCID;
        partial void OnLCIDChanging(int value);
        partial void OnLCIDChanged();
        /// <summary>
        /// There are no comments for Property Locale1 in the schema.
        /// </summary>
        public string Locale1
        {
            get
            {
                return this._Locale1;
            }
            set
            {
                this.OnLocale1Changing(value);
                this._Locale1 = value;
                this.OnLocale1Changed();
            }
        }
        private string _Locale1;
        partial void OnLocale1Changing(string value);
        partial void OnLocale1Changed();
        /// <summary>
        /// There are no comments for Property Collation in the schema.
        /// </summary>
        public string Collation
        {
            get
            {
                return this._Collation;
            }
            set
            {
                this.OnCollationChanging(value);
                this._Collation = value;
                this.OnCollationChanged();
            }
        }
        private string _Collation;
        partial void OnCollationChanging(string value);
        partial void OnCollationChanged();
        /// <summary>
        /// There are no comments for Property DTModified in the schema.
        /// </summary>
        public global::System.DateTime DTModified
        {
            get
            {
                return this._DTModified;
            }
            set
            {
                this.OnDTModifiedChanging(value);
                this._DTModified = value;
                this.OnDTModifiedChanged();
            }
        }
        private global::System.DateTime _DTModified;
        partial void OnDTModifiedChanging(global::System.DateTime value);
        partial void OnDTModifiedChanged();
        /// <summary>
        /// There are no comments for RewardLocale in the schema.
        /// </summary>
        public global::System.Collections.ObjectModel.Collection<RewardLocale> RewardLocale
        {
            get
            {
                return this._RewardLocale;
            }
            set
            {
                if ((value != null))
                {
                    this._RewardLocale = value;
                }
            }
        }
        private global::System.Collections.ObjectModel.Collection<RewardLocale> _RewardLocale = new global::System.Collections.ObjectModel.Collection<RewardLocale>();
    }
    /// <summary>
    /// There are no comments for RewardsDBModel.Platforms in the schema.
    /// </summary>
    /// <KeyProperties>
    /// PlatformID
    /// </KeyProperties>
    [global::System.Data.Services.Common.DataServiceKeyAttribute("PlatformID")]
    public partial class Platforms
    {
        /// <summary>
        /// Create a new Platforms object.
        /// </summary>
        /// <param name="platformID">Initial value of PlatformID.</param>
        /// <param name="name">Initial value of Name.</param>
        /// <param name="dTModified">Initial value of DTModified.</param>
        public static Platforms CreatePlatforms(int platformID, string name, global::System.DateTime dTModified)
        {
            Platforms platforms = new Platforms();
            platforms.PlatformID = platformID;
            platforms.Name = name;
            platforms.DTModified = dTModified;
            return platforms;
        }
        /// <summary>
        /// There are no comments for Property PlatformID in the schema.
        /// </summary>
        public int PlatformID
        {
            get
            {
                return this._PlatformID;
            }
            set
            {
                this.OnPlatformIDChanging(value);
                this._PlatformID = value;
                this.OnPlatformIDChanged();
            }
        }
        private int _PlatformID;
        partial void OnPlatformIDChanging(int value);
        partial void OnPlatformIDChanged();
        /// <summary>
        /// There are no comments for Property Name in the schema.
        /// </summary>
        public string Name
        {
            get
            {
                return this._Name;
            }
            set
            {
                this.OnNameChanging(value);
                this._Name = value;
                this.OnNameChanged();
            }
        }
        private string _Name;
        partial void OnNameChanging(string value);
        partial void OnNameChanged();
        /// <summary>
        /// There are no comments for Property Comment in the schema.
        /// </summary>
        public string Comment
        {
            get
            {
                return this._Comment;
            }
            set
            {
                this.OnCommentChanging(value);
                this._Comment = value;
                this.OnCommentChanged();
            }
        }
        private string _Comment;
        partial void OnCommentChanging(string value);
        partial void OnCommentChanged();
        /// <summary>
        /// There are no comments for Property DTModified in the schema.
        /// </summary>
        public global::System.DateTime DTModified
        {
            get
            {
                return this._DTModified;
            }
            set
            {
                this.OnDTModifiedChanging(value);
                this._DTModified = value;
                this.OnDTModifiedChanged();
            }
        }
        private global::System.DateTime _DTModified;
        partial void OnDTModifiedChanging(global::System.DateTime value);
        partial void OnDTModifiedChanged();
        /// <summary>
        /// There are no comments for GameKeys in the schema.
        /// </summary>
        public global::System.Collections.ObjectModel.Collection<GameKeys> GameKeys
        {
            get
            {
                return this._GameKeys;
            }
            set
            {
                if ((value != null))
                {
                    this._GameKeys = value;
                }
            }
        }
        private global::System.Collections.ObjectModel.Collection<GameKeys> _GameKeys = new global::System.Collections.ObjectModel.Collection<GameKeys>();
    }
    /// <summary>
    /// There are no comments for RewardsDBModel.Reward in the schema.
    /// </summary>
    /// <KeyProperties>
    /// RewardID
    /// </KeyProperties>
    [global::System.Data.Services.Common.DataServiceKeyAttribute("RewardID")]
    public partial class Reward
    {
        /// <summary>
        /// Create a new Reward object.
        /// </summary>
        /// <param name="rewardID">Initial value of RewardID.</param>
        /// <param name="dTStart">Initial value of DTStart.</param>
        /// <param name="dTEnd">Initial value of DTEnd.</param>
        /// <param name="dTCreated">Initial value of DTCreated.</param>
        /// <param name="dTModified">Initial value of DTModified.</param>
        public static Reward CreateReward(int rewardID, global::System.DateTime dTStart, global::System.DateTime dTEnd, global::System.DateTime dTCreated, global::System.DateTime dTModified)
        {
            Reward reward = new Reward();
            reward.RewardID = rewardID;
            reward.DTStart = dTStart;
            reward.DTEnd = dTEnd;
            reward.DTCreated = dTCreated;
            reward.DTModified = dTModified;
            return reward;
        }
        /// <summary>
        /// There are no comments for Property RewardID in the schema.
        /// </summary>
        public int RewardID
        {
            get
            {
                return this._RewardID;
            }
            set
            {
                this.OnRewardIDChanging(value);
                this._RewardID = value;
                this.OnRewardIDChanged();
            }
        }
        private int _RewardID;
        partial void OnRewardIDChanging(int value);
        partial void OnRewardIDChanged();
        /// <summary>
        /// There are no comments for Property RewardValue in the schema.
        /// </summary>
        public string RewardValue
        {
            get
            {
                return this._RewardValue;
            }
            set
            {
                this.OnRewardValueChanging(value);
                this._RewardValue = value;
                this.OnRewardValueChanged();
            }
        }
        private string _RewardValue;
        partial void OnRewardValueChanging(string value);
        partial void OnRewardValueChanged();
        /// <summary>
        /// There are no comments for Property DTStart in the schema.
        /// </summary>
        public global::System.DateTime DTStart
        {
            get
            {
                return this._DTStart;
            }
            set
            {
                this.OnDTStartChanging(value);
                this._DTStart = value;
                this.OnDTStartChanged();
            }
        }
        private global::System.DateTime _DTStart;
        partial void OnDTStartChanging(global::System.DateTime value);
        partial void OnDTStartChanged();
        /// <summary>
        /// There are no comments for Property DTEnd in the schema.
        /// </summary>
        public global::System.DateTime DTEnd
        {
            get
            {
                return this._DTEnd;
            }
            set
            {
                this.OnDTEndChanging(value);
                this._DTEnd = value;
                this.OnDTEndChanged();
            }
        }
        private global::System.DateTime _DTEnd;
        partial void OnDTEndChanging(global::System.DateTime value);
        partial void OnDTEndChanged();
        /// <summary>
        /// There are no comments for Property DTCreated in the schema.
        /// </summary>
        public global::System.DateTime DTCreated
        {
            get
            {
                return this._DTCreated;
            }
            set
            {
                this.OnDTCreatedChanging(value);
                this._DTCreated = value;
                this.OnDTCreatedChanged();
            }
        }
        private global::System.DateTime _DTCreated;
        partial void OnDTCreatedChanging(global::System.DateTime value);
        partial void OnDTCreatedChanged();
        /// <summary>
        /// There are no comments for Property DTModified in the schema.
        /// </summary>
        public global::System.DateTime DTModified
        {
            get
            {
                return this._DTModified;
            }
            set
            {
                this.OnDTModifiedChanging(value);
                this._DTModified = value;
                this.OnDTModifiedChanged();
            }
        }
        private global::System.DateTime _DTModified;
        partial void OnDTModifiedChanging(global::System.DateTime value);
        partial void OnDTModifiedChanged();
        /// <summary>
        /// There are no comments for Property Comment in the schema.
        /// </summary>
        public string Comment
        {
            get
            {
                return this._Comment;
            }
            set
            {
                this.OnCommentChanging(value);
                this._Comment = value;
                this.OnCommentChanged();
            }
        }
        private string _Comment;
        partial void OnCommentChanging(string value);
        partial void OnCommentChanged();
        /// <summary>
        /// There are no comments for Rule in the schema.
        /// </summary>
        public global::System.Collections.ObjectModel.Collection<Rule> Rule
        {
            get
            {
                return this._Rule;
            }
            set
            {
                if ((value != null))
                {
                    this._Rule = value;
                }
            }
        }
        private global::System.Collections.ObjectModel.Collection<Rule> _Rule = new global::System.Collections.ObjectModel.Collection<Rule>();
        /// <summary>
        /// There are no comments for RewardCategory in the schema.
        /// </summary>
        public RewardCategory RewardCategory
        {
            get
            {
                return this._RewardCategory;
            }
            set
            {
                this._RewardCategory = value;
            }
        }
        private RewardCategory _RewardCategory;
        /// <summary>
        /// There are no comments for RewardType in the schema.
        /// </summary>
        public RewardType RewardType
        {
            get
            {
                return this._RewardType;
            }
            set
            {
                this._RewardType = value;
            }
        }
        private RewardType _RewardType;
        /// <summary>
        /// There are no comments for RewardGameKeys in the schema.
        /// </summary>
        public global::System.Collections.ObjectModel.Collection<RewardGameKeys> RewardGameKeys
        {
            get
            {
                return this._RewardGameKeys;
            }
            set
            {
                if ((value != null))
                {
                    this._RewardGameKeys = value;
                }
            }
        }
        private global::System.Collections.ObjectModel.Collection<RewardGameKeys> _RewardGameKeys = new global::System.Collections.ObjectModel.Collection<RewardGameKeys>();
        /// <summary>
        /// There are no comments for RewardLocale in the schema.
        /// </summary>
        public global::System.Collections.ObjectModel.Collection<RewardLocale> RewardLocale
        {
            get
            {
                return this._RewardLocale;
            }
            set
            {
                if ((value != null))
                {
                    this._RewardLocale = value;
                }
            }
        }
        private global::System.Collections.ObjectModel.Collection<RewardLocale> _RewardLocale = new global::System.Collections.ObjectModel.Collection<RewardLocale>();
    }
    /// <summary>
    /// There are no comments for RewardsDBModel.RewardCategory in the schema.
    /// </summary>
    /// <KeyProperties>
    /// RewardCategoryID
    /// </KeyProperties>
    [global::System.Data.Services.Common.DataServiceKeyAttribute("RewardCategoryID")]
    public partial class RewardCategory
    {
        /// <summary>
        /// Create a new RewardCategory object.
        /// </summary>
        /// <param name="rewardCategoryID">Initial value of RewardCategoryID.</param>
        /// <param name="rewardCategoryName">Initial value of RewardCategoryName.</param>
        public static RewardCategory CreateRewardCategory(int rewardCategoryID, string rewardCategoryName)
        {
            RewardCategory rewardCategory = new RewardCategory();
            rewardCategory.RewardCategoryID = rewardCategoryID;
            rewardCategory.RewardCategoryName = rewardCategoryName;
            return rewardCategory;
        }
        /// <summary>
        /// There are no comments for Property RewardCategoryID in the schema.
        /// </summary>
        public int RewardCategoryID
        {
            get
            {
                return this._RewardCategoryID;
            }
            set
            {
                this.OnRewardCategoryIDChanging(value);
                this._RewardCategoryID = value;
                this.OnRewardCategoryIDChanged();
            }
        }
        private int _RewardCategoryID;
        partial void OnRewardCategoryIDChanging(int value);
        partial void OnRewardCategoryIDChanged();
        /// <summary>
        /// There are no comments for Property RewardCategoryName in the schema.
        /// </summary>
        public string RewardCategoryName
        {
            get
            {
                return this._RewardCategoryName;
            }
            set
            {
                this.OnRewardCategoryNameChanging(value);
                this._RewardCategoryName = value;
                this.OnRewardCategoryNameChanged();
            }
        }
        private string _RewardCategoryName;
        partial void OnRewardCategoryNameChanging(string value);
        partial void OnRewardCategoryNameChanged();
        /// <summary>
        /// There are no comments for Reward in the schema.
        /// </summary>
        public global::System.Collections.ObjectModel.Collection<Reward> Reward
        {
            get
            {
                return this._Reward;
            }
            set
            {
                if ((value != null))
                {
                    this._Reward = value;
                }
            }
        }
        private global::System.Collections.ObjectModel.Collection<Reward> _Reward = new global::System.Collections.ObjectModel.Collection<Reward>();
    }
    /// <summary>
    /// There are no comments for RewardsDBModel.RewardGameKeys in the schema.
    /// </summary>
    /// <KeyProperties>
    /// RewardGameKeysID
    /// </KeyProperties>
    [global::System.Data.Services.Common.DataServiceKeyAttribute("RewardGameKeysID")]
    public partial class RewardGameKeys
    {
        /// <summary>
        /// Create a new RewardGameKeys object.
        /// </summary>
        /// <param name="rewardGameKeysID">Initial value of RewardGameKeysID.</param>
        /// <param name="dTCreated">Initial value of DTCreated.</param>
        public static RewardGameKeys CreateRewardGameKeys(int rewardGameKeysID, global::System.DateTime dTCreated)
        {
            RewardGameKeys rewardGameKeys = new RewardGameKeys();
            rewardGameKeys.RewardGameKeysID = rewardGameKeysID;
            rewardGameKeys.DTCreated = dTCreated;
            return rewardGameKeys;
        }
        /// <summary>
        /// There are no comments for Property RewardGameKeysID in the schema.
        /// </summary>
        public int RewardGameKeysID
        {
            get
            {
                return this._RewardGameKeysID;
            }
            set
            {
                this.OnRewardGameKeysIDChanging(value);
                this._RewardGameKeysID = value;
                this.OnRewardGameKeysIDChanged();
            }
        }
        private int _RewardGameKeysID;
        partial void OnRewardGameKeysIDChanging(int value);
        partial void OnRewardGameKeysIDChanged();
        /// <summary>
        /// There are no comments for Property GameKeyID in the schema.
        /// </summary>
        public global::System.Nullable<int> GameKeyID
        {
            get
            {
                return this._GameKeyID;
            }
            set
            {
                this.OnGameKeyIDChanging(value);
                this._GameKeyID = value;
                this.OnGameKeyIDChanged();
            }
        }
        private global::System.Nullable<int> _GameKeyID;
        partial void OnGameKeyIDChanging(global::System.Nullable<int> value);
        partial void OnGameKeyIDChanged();
        /// <summary>
        /// There are no comments for Property DTCreated in the schema.
        /// </summary>
        public global::System.DateTime DTCreated
        {
            get
            {
                return this._DTCreated;
            }
            set
            {
                this.OnDTCreatedChanging(value);
                this._DTCreated = value;
                this.OnDTCreatedChanged();
            }
        }
        private global::System.DateTime _DTCreated;
        partial void OnDTCreatedChanging(global::System.DateTime value);
        partial void OnDTCreatedChanged();
        /// <summary>
        /// There are no comments for Reward in the schema.
        /// </summary>
        public Reward Reward
        {
            get
            {
                return this._Reward;
            }
            set
            {
                this._Reward = value;
            }
        }
        private Reward _Reward;
    }
    /// <summary>
    /// There are no comments for RewardsDBModel.RewardLocale in the schema.
    /// </summary>
    /// <KeyProperties>
    /// RewardLocaleID
    /// </KeyProperties>
    [global::System.Data.Services.Common.DataServiceKeyAttribute("RewardLocaleID")]
    public partial class RewardLocale
    {
        /// <summary>
        /// Create a new RewardLocale object.
        /// </summary>
        /// <param name="rewardLocaleID">Initial value of RewardLocaleID.</param>
        /// <param name="dTModified">Initial value of DTModified.</param>
        public static RewardLocale CreateRewardLocale(int rewardLocaleID, global::System.DateTime dTModified)
        {
            RewardLocale rewardLocale = new RewardLocale();
            rewardLocale.RewardLocaleID = rewardLocaleID;
            rewardLocale.DTModified = dTModified;
            return rewardLocale;
        }
        /// <summary>
        /// There are no comments for Property RewardLocaleID in the schema.
        /// </summary>
        public int RewardLocaleID
        {
            get
            {
                return this._RewardLocaleID;
            }
            set
            {
                this.OnRewardLocaleIDChanging(value);
                this._RewardLocaleID = value;
                this.OnRewardLocaleIDChanged();
            }
        }
        private int _RewardLocaleID;
        partial void OnRewardLocaleIDChanging(int value);
        partial void OnRewardLocaleIDChanged();
        /// <summary>
        /// There are no comments for Property LocRewardName in the schema.
        /// </summary>
        public string LocRewardName
        {
            get
            {
                return this._LocRewardName;
            }
            set
            {
                this.OnLocRewardNameChanging(value);
                this._LocRewardName = value;
                this.OnLocRewardNameChanged();
            }
        }
        private string _LocRewardName;
        partial void OnLocRewardNameChanging(string value);
        partial void OnLocRewardNameChanged();
        /// <summary>
        /// There are no comments for Property LocRewardDescription in the schema.
        /// </summary>
        public string LocRewardDescription
        {
            get
            {
                return this._LocRewardDescription;
            }
            set
            {
                this.OnLocRewardDescriptionChanging(value);
                this._LocRewardDescription = value;
                this.OnLocRewardDescriptionChanged();
            }
        }
        private string _LocRewardDescription;
        partial void OnLocRewardDescriptionChanging(string value);
        partial void OnLocRewardDescriptionChanged();
        /// <summary>
        /// There are no comments for Property DTModified in the schema.
        /// </summary>
        public global::System.DateTime DTModified
        {
            get
            {
                return this._DTModified;
            }
            set
            {
                this.OnDTModifiedChanging(value);
                this._DTModified = value;
                this.OnDTModifiedChanged();
            }
        }
        private global::System.DateTime _DTModified;
        partial void OnDTModifiedChanging(global::System.DateTime value);
        partial void OnDTModifiedChanged();
        /// <summary>
        /// There are no comments for Locale in the schema.
        /// </summary>
        public Locale Locale
        {
            get
            {
                return this._Locale;
            }
            set
            {
                this._Locale = value;
            }
        }
        private Locale _Locale;
        /// <summary>
        /// There are no comments for Reward in the schema.
        /// </summary>
        public Reward Reward
        {
            get
            {
                return this._Reward;
            }
            set
            {
                this._Reward = value;
            }
        }
        private Reward _Reward;
    }
    /// <summary>
    /// There are no comments for RewardsDBModel.RewardType in the schema.
    /// </summary>
    /// <KeyProperties>
    /// RewardTypeID
    /// </KeyProperties>
    [global::System.Data.Services.Common.DataServiceKeyAttribute("RewardTypeID")]
    public partial class RewardType
    {
        /// <summary>
        /// Create a new RewardType object.
        /// </summary>
        /// <param name="rewardTypeID">Initial value of RewardTypeID.</param>
        /// <param name="rewardTypeName">Initial value of RewardTypeName.</param>
        public static RewardType CreateRewardType(int rewardTypeID, string rewardTypeName)
        {
            RewardType rewardType = new RewardType();
            rewardType.RewardTypeID = rewardTypeID;
            rewardType.RewardTypeName = rewardTypeName;
            return rewardType;
        }
        /// <summary>
        /// There are no comments for Property RewardTypeID in the schema.
        /// </summary>
        public int RewardTypeID
        {
            get
            {
                return this._RewardTypeID;
            }
            set
            {
                this.OnRewardTypeIDChanging(value);
                this._RewardTypeID = value;
                this.OnRewardTypeIDChanged();
            }
        }
        private int _RewardTypeID;
        partial void OnRewardTypeIDChanging(int value);
        partial void OnRewardTypeIDChanged();
        /// <summary>
        /// There are no comments for Property RewardTypeName in the schema.
        /// </summary>
        public string RewardTypeName
        {
            get
            {
                return this._RewardTypeName;
            }
            set
            {
                this.OnRewardTypeNameChanging(value);
                this._RewardTypeName = value;
                this.OnRewardTypeNameChanged();
            }
        }
        private string _RewardTypeName;
        partial void OnRewardTypeNameChanging(string value);
        partial void OnRewardTypeNameChanged();
        /// <summary>
        /// There are no comments for Reward in the schema.
        /// </summary>
        public global::System.Collections.ObjectModel.Collection<Reward> Reward
        {
            get
            {
                return this._Reward;
            }
            set
            {
                if ((value != null))
                {
                    this._Reward = value;
                }
            }
        }
        private global::System.Collections.ObjectModel.Collection<Reward> _Reward = new global::System.Collections.ObjectModel.Collection<Reward>();
    }
    /// <summary>
    /// There are no comments for RewardsDBModel.Rule in the schema.
    /// </summary>
    /// <KeyProperties>
    /// RuleID
    /// </KeyProperties>
    [global::System.Data.Services.Common.DataServiceKeyAttribute("RuleID")]
    public partial class Rule
    {
        /// <summary>
        /// Create a new Rule object.
        /// </summary>
        /// <param name="ruleID">Initial value of RuleID.</param>
        /// <param name="dTStart">Initial value of DTStart.</param>
        /// <param name="dTEnd">Initial value of DTEnd.</param>
        /// <param name="dTCreated">Initial value of DTCreated.</param>
        /// <param name="dTModified">Initial value of DTModified.</param>
        public static Rule CreateRule(int ruleID, global::System.DateTime dTStart, global::System.DateTime dTEnd, global::System.DateTime dTCreated, global::System.DateTime dTModified)
        {
            Rule rule = new Rule();
            rule.RuleID = ruleID;
            rule.DTStart = dTStart;
            rule.DTEnd = dTEnd;
            rule.DTCreated = dTCreated;
            rule.DTModified = dTModified;
            return rule;
        }
        /// <summary>
        /// There are no comments for Property RuleID in the schema.
        /// </summary>
        public int RuleID
        {
            get
            {
                return this._RuleID;
            }
            set
            {
                this.OnRuleIDChanging(value);
                this._RuleID = value;
                this.OnRuleIDChanged();
            }
        }
        private int _RuleID;
        partial void OnRuleIDChanging(int value);
        partial void OnRuleIDChanged();
        /// <summary>
        /// There are no comments for Property DTStart in the schema.
        /// </summary>
        public global::System.DateTime DTStart
        {
            get
            {
                return this._DTStart;
            }
            set
            {
                this.OnDTStartChanging(value);
                this._DTStart = value;
                this.OnDTStartChanged();
            }
        }
        private global::System.DateTime _DTStart;
        partial void OnDTStartChanging(global::System.DateTime value);
        partial void OnDTStartChanged();
        /// <summary>
        /// There are no comments for Property DTEnd in the schema.
        /// </summary>
        public global::System.DateTime DTEnd
        {
            get
            {
                return this._DTEnd;
            }
            set
            {
                this.OnDTEndChanging(value);
                this._DTEnd = value;
                this.OnDTEndChanged();
            }
        }
        private global::System.DateTime _DTEnd;
        partial void OnDTEndChanging(global::System.DateTime value);
        partial void OnDTEndChanged();
        /// <summary>
        /// There are no comments for Property Comment in the schema.
        /// </summary>
        public string Comment
        {
            get
            {
                return this._Comment;
            }
            set
            {
                this.OnCommentChanging(value);
                this._Comment = value;
                this.OnCommentChanged();
            }
        }
        private string _Comment;
        partial void OnCommentChanging(string value);
        partial void OnCommentChanged();
        /// <summary>
        /// There are no comments for Property DTCreated in the schema.
        /// </summary>
        public global::System.DateTime DTCreated
        {
            get
            {
                return this._DTCreated;
            }
            set
            {
                this.OnDTCreatedChanging(value);
                this._DTCreated = value;
                this.OnDTCreatedChanged();
            }
        }
        private global::System.DateTime _DTCreated;
        partial void OnDTCreatedChanging(global::System.DateTime value);
        partial void OnDTCreatedChanged();
        /// <summary>
        /// There are no comments for Property DTModified in the schema.
        /// </summary>
        public global::System.DateTime DTModified
        {
            get
            {
                return this._DTModified;
            }
            set
            {
                this.OnDTModifiedChanging(value);
                this._DTModified = value;
                this.OnDTModifiedChanged();
            }
        }
        private global::System.DateTime _DTModified;
        partial void OnDTModifiedChanging(global::System.DateTime value);
        partial void OnDTModifiedChanged();
        /// <summary>
        /// There are no comments for Action in the schema.
        /// </summary>
        public global::System.Collections.ObjectModel.Collection<Action> Action
        {
            get
            {
                return this._Action;
            }
            set
            {
                if ((value != null))
                {
                    this._Action = value;
                }
            }
        }
        private global::System.Collections.ObjectModel.Collection<Action> _Action = new global::System.Collections.ObjectModel.Collection<Action>();
        /// <summary>
        /// There are no comments for ActionSetExecutionType in the schema.
        /// </summary>
        public ActionSetExecutionType ActionSetExecutionType
        {
            get
            {
                return this._ActionSetExecutionType;
            }
            set
            {
                this._ActionSetExecutionType = value;
            }
        }
        private ActionSetExecutionType _ActionSetExecutionType;
        /// <summary>
        /// There are no comments for Reward in the schema.
        /// </summary>
        public Reward Reward
        {
            get
            {
                return this._Reward;
            }
            set
            {
                this._Reward = value;
            }
        }
        private Reward _Reward;
        /// <summary>
        /// There are no comments for Status in the schema.
        /// </summary>
        public Status Status
        {
            get
            {
                return this._Status;
            }
            set
            {
                this._Status = value;
            }
        }
        private Status _Status;
        /// <summary>
        /// There are no comments for RuleExpression in the schema.
        /// </summary>
        public global::System.Collections.ObjectModel.Collection<RuleExpression> RuleExpression
        {
            get
            {
                return this._RuleExpression;
            }
            set
            {
                if ((value != null))
                {
                    this._RuleExpression = value;
                }
            }
        }
        private global::System.Collections.ObjectModel.Collection<RuleExpression> _RuleExpression = new global::System.Collections.ObjectModel.Collection<RuleExpression>();
        /// <summary>
        /// There are no comments for RuleGameKeys in the schema.
        /// </summary>
        public global::System.Collections.ObjectModel.Collection<RuleGameKeys> RuleGameKeys
        {
            get
            {
                return this._RuleGameKeys;
            }
            set
            {
                if ((value != null))
                {
                    this._RuleGameKeys = value;
                }
            }
        }
        private global::System.Collections.ObjectModel.Collection<RuleGameKeys> _RuleGameKeys = new global::System.Collections.ObjectModel.Collection<RuleGameKeys>();
    }
    /// <summary>
    /// There are no comments for RewardsDBModel.RuleExpression in the schema.
    /// </summary>
    /// <KeyProperties>
    /// RuleExpressionID
    /// </KeyProperties>
    [global::System.Data.Services.Common.DataServiceKeyAttribute("RuleExpressionID")]
    public partial class RuleExpression
    {
        /// <summary>
        /// Create a new RuleExpression object.
        /// </summary>
        /// <param name="ruleExpressionID">Initial value of RuleExpressionID.</param>
        /// <param name="leftOperand">Initial value of LeftOperand.</param>
        /// <param name="rightOperand">Initial value of RightOperand.</param>
        /// <param name="dTCreated">Initial value of DTCreated.</param>
        /// <param name="dTModified">Initial value of DTModified.</param>
        public static RuleExpression CreateRuleExpression(int ruleExpressionID, string leftOperand, string rightOperand, global::System.DateTime dTCreated, global::System.DateTime dTModified)
        {
            RuleExpression ruleExpression = new RuleExpression();
            ruleExpression.RuleExpressionID = ruleExpressionID;
            ruleExpression.LeftOperand = leftOperand;
            ruleExpression.RightOperand = rightOperand;
            ruleExpression.DTCreated = dTCreated;
            ruleExpression.DTModified = dTModified;
            return ruleExpression;
        }
        /// <summary>
        /// There are no comments for Property RuleExpressionID in the schema.
        /// </summary>
        public int RuleExpressionID
        {
            get
            {
                return this._RuleExpressionID;
            }
            set
            {
                this.OnRuleExpressionIDChanging(value);
                this._RuleExpressionID = value;
                this.OnRuleExpressionIDChanged();
            }
        }
        private int _RuleExpressionID;
        partial void OnRuleExpressionIDChanging(int value);
        partial void OnRuleExpressionIDChanged();
        /// <summary>
        /// There are no comments for Property LeftOperand in the schema.
        /// </summary>
        public string LeftOperand
        {
            get
            {
                return this._LeftOperand;
            }
            set
            {
                this.OnLeftOperandChanging(value);
                this._LeftOperand = value;
                this.OnLeftOperandChanged();
            }
        }
        private string _LeftOperand;
        partial void OnLeftOperandChanging(string value);
        partial void OnLeftOperandChanged();
        /// <summary>
        /// There are no comments for Property RightOperand in the schema.
        /// </summary>
        public string RightOperand
        {
            get
            {
                return this._RightOperand;
            }
            set
            {
                this.OnRightOperandChanging(value);
                this._RightOperand = value;
                this.OnRightOperandChanged();
            }
        }
        private string _RightOperand;
        partial void OnRightOperandChanging(string value);
        partial void OnRightOperandChanged();
        /// <summary>
        /// There are no comments for Property DTCreated in the schema.
        /// </summary>
        public global::System.DateTime DTCreated
        {
            get
            {
                return this._DTCreated;
            }
            set
            {
                this.OnDTCreatedChanging(value);
                this._DTCreated = value;
                this.OnDTCreatedChanged();
            }
        }
        private global::System.DateTime _DTCreated;
        partial void OnDTCreatedChanging(global::System.DateTime value);
        partial void OnDTCreatedChanged();
        /// <summary>
        /// There are no comments for Property DTModified in the schema.
        /// </summary>
        public global::System.DateTime DTModified
        {
            get
            {
                return this._DTModified;
            }
            set
            {
                this.OnDTModifiedChanging(value);
                this._DTModified = value;
                this.OnDTModifiedChanged();
            }
        }
        private global::System.DateTime _DTModified;
        partial void OnDTModifiedChanging(global::System.DateTime value);
        partial void OnDTModifiedChanged();
        /// <summary>
        /// There are no comments for DataType in the schema.
        /// </summary>
        public DataType DataType
        {
            get
            {
                return this._DataType;
            }
            set
            {
                this._DataType = value;
            }
        }
        private DataType _DataType;
        /// <summary>
        /// There are no comments for Rule in the schema.
        /// </summary>
        public Rule Rule
        {
            get
            {
                return this._Rule;
            }
            set
            {
                this._Rule = value;
            }
        }
        private Rule _Rule;
        /// <summary>
        /// There are no comments for RuleOperandType in the schema.
        /// </summary>
        public RuleOperandType RuleOperandType
        {
            get
            {
                return this._RuleOperandType;
            }
            set
            {
                this._RuleOperandType = value;
            }
        }
        private RuleOperandType _RuleOperandType;
        /// <summary>
        /// There are no comments for RuleOperandType1 in the schema.
        /// </summary>
        public RuleOperandType RuleOperandType1
        {
            get
            {
                return this._RuleOperandType1;
            }
            set
            {
                this._RuleOperandType1 = value;
            }
        }
        private RuleOperandType _RuleOperandType1;
        /// <summary>
        /// There are no comments for RuleOperator in the schema.
        /// </summary>
        public RuleOperator RuleOperator
        {
            get
            {
                return this._RuleOperator;
            }
            set
            {
                this._RuleOperator = value;
            }
        }
        private RuleOperator _RuleOperator;
    }
    /// <summary>
    /// There are no comments for RewardsDBModel.RuleGameKeys in the schema.
    /// </summary>
    /// <KeyProperties>
    /// RuleGameKeysID
    /// </KeyProperties>
    [global::System.Data.Services.Common.DataServiceKeyAttribute("RuleGameKeysID")]
    public partial class RuleGameKeys
    {
        /// <summary>
        /// Create a new RuleGameKeys object.
        /// </summary>
        /// <param name="ruleGameKeysID">Initial value of RuleGameKeysID.</param>
        /// <param name="dTCreated">Initial value of DTCreated.</param>
        public static RuleGameKeys CreateRuleGameKeys(int ruleGameKeysID, global::System.DateTime dTCreated)
        {
            RuleGameKeys ruleGameKeys = new RuleGameKeys();
            ruleGameKeys.RuleGameKeysID = ruleGameKeysID;
            ruleGameKeys.DTCreated = dTCreated;
            return ruleGameKeys;
        }
        /// <summary>
        /// There are no comments for Property RuleGameKeysID in the schema.
        /// </summary>
        public int RuleGameKeysID
        {
            get
            {
                return this._RuleGameKeysID;
            }
            set
            {
                this.OnRuleGameKeysIDChanging(value);
                this._RuleGameKeysID = value;
                this.OnRuleGameKeysIDChanged();
            }
        }
        private int _RuleGameKeysID;
        partial void OnRuleGameKeysIDChanging(int value);
        partial void OnRuleGameKeysIDChanged();
        /// <summary>
        /// There are no comments for Property DTCreated in the schema.
        /// </summary>
        public global::System.DateTime DTCreated
        {
            get
            {
                return this._DTCreated;
            }
            set
            {
                this.OnDTCreatedChanging(value);
                this._DTCreated = value;
                this.OnDTCreatedChanged();
            }
        }
        private global::System.DateTime _DTCreated;
        partial void OnDTCreatedChanging(global::System.DateTime value);
        partial void OnDTCreatedChanged();
        /// <summary>
        /// There are no comments for GameKeys in the schema.
        /// </summary>
        public GameKeys GameKeys
        {
            get
            {
                return this._GameKeys;
            }
            set
            {
                this._GameKeys = value;
            }
        }
        private GameKeys _GameKeys;
        /// <summary>
        /// There are no comments for Rule in the schema.
        /// </summary>
        public Rule Rule
        {
            get
            {
                return this._Rule;
            }
            set
            {
                this._Rule = value;
            }
        }
        private Rule _Rule;
    }
    /// <summary>
    /// There are no comments for RewardsDBModel.RuleOperandType in the schema.
    /// </summary>
    /// <KeyProperties>
    /// RuleOperandTypeID
    /// </KeyProperties>
    [global::System.Data.Services.Common.DataServiceKeyAttribute("RuleOperandTypeID")]
    public partial class RuleOperandType
    {
        /// <summary>
        /// Create a new RuleOperandType object.
        /// </summary>
        /// <param name="ruleOperandTypeID">Initial value of RuleOperandTypeID.</param>
        /// <param name="ruleOperandTypeName">Initial value of RuleOperandTypeName.</param>
        /// <param name="dTCreated">Initial value of DTCreated.</param>
        /// <param name="dTModified">Initial value of DTModified.</param>
        public static RuleOperandType CreateRuleOperandType(int ruleOperandTypeID, string ruleOperandTypeName, global::System.DateTime dTCreated, global::System.DateTime dTModified)
        {
            RuleOperandType ruleOperandType = new RuleOperandType();
            ruleOperandType.RuleOperandTypeID = ruleOperandTypeID;
            ruleOperandType.RuleOperandTypeName = ruleOperandTypeName;
            ruleOperandType.DTCreated = dTCreated;
            ruleOperandType.DTModified = dTModified;
            return ruleOperandType;
        }
        /// <summary>
        /// There are no comments for Property RuleOperandTypeID in the schema.
        /// </summary>
        public int RuleOperandTypeID
        {
            get
            {
                return this._RuleOperandTypeID;
            }
            set
            {
                this.OnRuleOperandTypeIDChanging(value);
                this._RuleOperandTypeID = value;
                this.OnRuleOperandTypeIDChanged();
            }
        }
        private int _RuleOperandTypeID;
        partial void OnRuleOperandTypeIDChanging(int value);
        partial void OnRuleOperandTypeIDChanged();
        /// <summary>
        /// There are no comments for Property RuleOperandTypeName in the schema.
        /// </summary>
        public string RuleOperandTypeName
        {
            get
            {
                return this._RuleOperandTypeName;
            }
            set
            {
                this.OnRuleOperandTypeNameChanging(value);
                this._RuleOperandTypeName = value;
                this.OnRuleOperandTypeNameChanged();
            }
        }
        private string _RuleOperandTypeName;
        partial void OnRuleOperandTypeNameChanging(string value);
        partial void OnRuleOperandTypeNameChanged();
        /// <summary>
        /// There are no comments for Property DTCreated in the schema.
        /// </summary>
        public global::System.DateTime DTCreated
        {
            get
            {
                return this._DTCreated;
            }
            set
            {
                this.OnDTCreatedChanging(value);
                this._DTCreated = value;
                this.OnDTCreatedChanged();
            }
        }
        private global::System.DateTime _DTCreated;
        partial void OnDTCreatedChanging(global::System.DateTime value);
        partial void OnDTCreatedChanged();
        /// <summary>
        /// There are no comments for Property DTModified in the schema.
        /// </summary>
        public global::System.DateTime DTModified
        {
            get
            {
                return this._DTModified;
            }
            set
            {
                this.OnDTModifiedChanging(value);
                this._DTModified = value;
                this.OnDTModifiedChanged();
            }
        }
        private global::System.DateTime _DTModified;
        partial void OnDTModifiedChanging(global::System.DateTime value);
        partial void OnDTModifiedChanged();
        /// <summary>
        /// There are no comments for RuleExpression in the schema.
        /// </summary>
        public global::System.Collections.ObjectModel.Collection<RuleExpression> RuleExpression
        {
            get
            {
                return this._RuleExpression;
            }
            set
            {
                if ((value != null))
                {
                    this._RuleExpression = value;
                }
            }
        }
        private global::System.Collections.ObjectModel.Collection<RuleExpression> _RuleExpression = new global::System.Collections.ObjectModel.Collection<RuleExpression>();
        /// <summary>
        /// There are no comments for RuleExpression1 in the schema.
        /// </summary>
        public global::System.Collections.ObjectModel.Collection<RuleExpression> RuleExpression1
        {
            get
            {
                return this._RuleExpression1;
            }
            set
            {
                if ((value != null))
                {
                    this._RuleExpression1 = value;
                }
            }
        }
        private global::System.Collections.ObjectModel.Collection<RuleExpression> _RuleExpression1 = new global::System.Collections.ObjectModel.Collection<RuleExpression>();
    }
    /// <summary>
    /// There are no comments for RewardsDBModel.RuleOperator in the schema.
    /// </summary>
    /// <KeyProperties>
    /// RuleOperatorID
    /// </KeyProperties>
    [global::System.Data.Services.Common.DataServiceKeyAttribute("RuleOperatorID")]
    public partial class RuleOperator
    {
        /// <summary>
        /// Create a new RuleOperator object.
        /// </summary>
        /// <param name="ruleOperatorID">Initial value of RuleOperatorID.</param>
        /// <param name="operator">Initial value of Operator.</param>
        /// <param name="symbol">Initial value of Symbol.</param>
        /// <param name="dTCreated">Initial value of DTCreated.</param>
        /// <param name="dTModified">Initial value of DTModified.</param>
        public static RuleOperator CreateRuleOperator(int ruleOperatorID, string @operator, string symbol, global::System.DateTime dTCreated, global::System.DateTime dTModified)
        {
            RuleOperator ruleOperator = new RuleOperator();
            ruleOperator.RuleOperatorID = ruleOperatorID;
            ruleOperator.Operator = @operator;
            ruleOperator.Symbol = symbol;
            ruleOperator.DTCreated = dTCreated;
            ruleOperator.DTModified = dTModified;
            return ruleOperator;
        }
        /// <summary>
        /// There are no comments for Property RuleOperatorID in the schema.
        /// </summary>
        public int RuleOperatorID
        {
            get
            {
                return this._RuleOperatorID;
            }
            set
            {
                this.OnRuleOperatorIDChanging(value);
                this._RuleOperatorID = value;
                this.OnRuleOperatorIDChanged();
            }
        }
        private int _RuleOperatorID;
        partial void OnRuleOperatorIDChanging(int value);
        partial void OnRuleOperatorIDChanged();
        /// <summary>
        /// There are no comments for Property Operator in the schema.
        /// </summary>
        public string Operator
        {
            get
            {
                return this._Operator;
            }
            set
            {
                this.OnOperatorChanging(value);
                this._Operator = value;
                this.OnOperatorChanged();
            }
        }
        private string _Operator;
        partial void OnOperatorChanging(string value);
        partial void OnOperatorChanged();
        /// <summary>
        /// There are no comments for Property Symbol in the schema.
        /// </summary>
        public string Symbol
        {
            get
            {
                return this._Symbol;
            }
            set
            {
                this.OnSymbolChanging(value);
                this._Symbol = value;
                this.OnSymbolChanged();
            }
        }
        private string _Symbol;
        partial void OnSymbolChanging(string value);
        partial void OnSymbolChanged();
        /// <summary>
        /// There are no comments for Property DTCreated in the schema.
        /// </summary>
        public global::System.DateTime DTCreated
        {
            get
            {
                return this._DTCreated;
            }
            set
            {
                this.OnDTCreatedChanging(value);
                this._DTCreated = value;
                this.OnDTCreatedChanged();
            }
        }
        private global::System.DateTime _DTCreated;
        partial void OnDTCreatedChanging(global::System.DateTime value);
        partial void OnDTCreatedChanged();
        /// <summary>
        /// There are no comments for Property DTModified in the schema.
        /// </summary>
        public global::System.DateTime DTModified
        {
            get
            {
                return this._DTModified;
            }
            set
            {
                this.OnDTModifiedChanging(value);
                this._DTModified = value;
                this.OnDTModifiedChanged();
            }
        }
        private global::System.DateTime _DTModified;
        partial void OnDTModifiedChanging(global::System.DateTime value);
        partial void OnDTModifiedChanged();
        /// <summary>
        /// There are no comments for RuleExpression in the schema.
        /// </summary>
        public global::System.Collections.ObjectModel.Collection<RuleExpression> RuleExpression
        {
            get
            {
                return this._RuleExpression;
            }
            set
            {
                if ((value != null))
                {
                    this._RuleExpression = value;
                }
            }
        }
        private global::System.Collections.ObjectModel.Collection<RuleExpression> _RuleExpression = new global::System.Collections.ObjectModel.Collection<RuleExpression>();
    }
    /// <summary>
    /// There are no comments for RewardsDBModel.StatDescription in the schema.
    /// </summary>
    /// <KeyProperties>
    /// StatDescriptionID
    /// </KeyProperties>
    [global::System.Data.Services.Common.DataServiceKeyAttribute("StatDescriptionID")]
    public partial class StatDescription
    {
        /// <summary>
        /// Create a new StatDescription object.
        /// </summary>
        /// <param name="statDescriptionID">Initial value of StatDescriptionID.</param>
        /// <param name="name">Initial value of Name.</param>
        /// <param name="dTModified">Initial value of DTModified.</param>
        public static StatDescription CreateStatDescription(int statDescriptionID, string name, global::System.DateTime dTModified)
        {
            StatDescription statDescription = new StatDescription();
            statDescription.StatDescriptionID = statDescriptionID;
            statDescription.Name = name;
            statDescription.DTModified = dTModified;
            return statDescription;
        }
        /// <summary>
        /// There are no comments for Property StatDescriptionID in the schema.
        /// </summary>
        public int StatDescriptionID
        {
            get
            {
                return this._StatDescriptionID;
            }
            set
            {
                this.OnStatDescriptionIDChanging(value);
                this._StatDescriptionID = value;
                this.OnStatDescriptionIDChanged();
            }
        }
        private int _StatDescriptionID;
        partial void OnStatDescriptionIDChanging(int value);
        partial void OnStatDescriptionIDChanged();
        /// <summary>
        /// There are no comments for Property Name in the schema.
        /// </summary>
        public string Name
        {
            get
            {
                return this._Name;
            }
            set
            {
                this.OnNameChanging(value);
                this._Name = value;
                this.OnNameChanged();
            }
        }
        private string _Name;
        partial void OnNameChanging(string value);
        partial void OnNameChanged();
        /// <summary>
        /// There are no comments for Property Comment in the schema.
        /// </summary>
        public string Comment
        {
            get
            {
                return this._Comment;
            }
            set
            {
                this.OnCommentChanging(value);
                this._Comment = value;
                this.OnCommentChanged();
            }
        }
        private string _Comment;
        partial void OnCommentChanging(string value);
        partial void OnCommentChanged();
        /// <summary>
        /// There are no comments for Property DTModified in the schema.
        /// </summary>
        public global::System.DateTime DTModified
        {
            get
            {
                return this._DTModified;
            }
            set
            {
                this.OnDTModifiedChanging(value);
                this._DTModified = value;
                this.OnDTModifiedChanged();
            }
        }
        private global::System.DateTime _DTModified;
        partial void OnDTModifiedChanging(global::System.DateTime value);
        partial void OnDTModifiedChanged();
        /// <summary>
        /// There are no comments for DataType in the schema.
        /// </summary>
        public DataType DataType
        {
            get
            {
                return this._DataType;
            }
            set
            {
                this._DataType = value;
            }
        }
        private DataType _DataType;
        /// <summary>
        /// There are no comments for GameKeys in the schema.
        /// </summary>
        public GameKeys GameKeys
        {
            get
            {
                return this._GameKeys;
            }
            set
            {
                this._GameKeys = value;
            }
        }
        private GameKeys _GameKeys;
    }
    /// <summary>
    /// There are no comments for RewardsDBModel.Status in the schema.
    /// </summary>
    /// <KeyProperties>
    /// StatusID
    /// </KeyProperties>
    [global::System.Data.Services.Common.DataServiceKeyAttribute("StatusID")]
    public partial class Status
    {
        /// <summary>
        /// Create a new Status object.
        /// </summary>
        /// <param name="statusID">Initial value of StatusID.</param>
        /// <param name="dTCreated">Initial value of DTCreated.</param>
        /// <param name="dTModified">Initial value of DTModified.</param>
        public static Status CreateStatus(int statusID, global::System.DateTime dTCreated, global::System.DateTime dTModified)
        {
            Status status = new Status();
            status.StatusID = statusID;
            status.DTCreated = dTCreated;
            status.DTModified = dTModified;
            return status;
        }
        /// <summary>
        /// There are no comments for Property StatusID in the schema.
        /// </summary>
        public int StatusID
        {
            get
            {
                return this._StatusID;
            }
            set
            {
                this.OnStatusIDChanging(value);
                this._StatusID = value;
                this.OnStatusIDChanged();
            }
        }
        private int _StatusID;
        partial void OnStatusIDChanging(int value);
        partial void OnStatusIDChanged();
        /// <summary>
        /// There are no comments for Property StatusName in the schema.
        /// </summary>
        public string StatusName
        {
            get
            {
                return this._StatusName;
            }
            set
            {
                this.OnStatusNameChanging(value);
                this._StatusName = value;
                this.OnStatusNameChanged();
            }
        }
        private string _StatusName;
        partial void OnStatusNameChanging(string value);
        partial void OnStatusNameChanged();
        /// <summary>
        /// There are no comments for Property DTCreated in the schema.
        /// </summary>
        public global::System.DateTime DTCreated
        {
            get
            {
                return this._DTCreated;
            }
            set
            {
                this.OnDTCreatedChanging(value);
                this._DTCreated = value;
                this.OnDTCreatedChanged();
            }
        }
        private global::System.DateTime _DTCreated;
        partial void OnDTCreatedChanging(global::System.DateTime value);
        partial void OnDTCreatedChanged();
        /// <summary>
        /// There are no comments for Property DTModified in the schema.
        /// </summary>
        public global::System.DateTime DTModified
        {
            get
            {
                return this._DTModified;
            }
            set
            {
                this.OnDTModifiedChanging(value);
                this._DTModified = value;
                this.OnDTModifiedChanged();
            }
        }
        private global::System.DateTime _DTModified;
        partial void OnDTModifiedChanging(global::System.DateTime value);
        partial void OnDTModifiedChanged();
        /// <summary>
        /// There are no comments for Rule in the schema.
        /// </summary>
        public global::System.Collections.ObjectModel.Collection<Rule> Rule
        {
            get
            {
                return this._Rule;
            }
            set
            {
                if ((value != null))
                {
                    this._Rule = value;
                }
            }
        }
        private global::System.Collections.ObjectModel.Collection<Rule> _Rule = new global::System.Collections.ObjectModel.Collection<Rule>();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup\LCWebService\ILiveConnect.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.Serialization;
using System.ServiceModel;
using System.Text;
using System.ServiceModel.Security;

namespace LiveConnectWeb
{
    [ServiceContract(Namespace="http://liveconnect.xboxlive.com")]
    public interface ILiveDirectory
    {
        [OperationContract]
        [FaultContract(typeof(SecurityAccessDeniedException))]
        [FaultContract(typeof(ArgumentException))]
        [FaultContract(typeof(ArgumentOutOfRangeException))]
        [FaultContract(typeof(ArgumentNullException))]
        void SetSNUserInfo(ushort sNetworkId, SNUserInfo userInfo);

        [OperationContract]
        [FaultContract(typeof(SecurityAccessDeniedException))]
        [FaultContract(typeof(ArgumentException))]
        [FaultContract(typeof(ArgumentOutOfRangeException))]
        void RemoveSNUserInfo(ushort sNetworkId, ulong XUID);

        [OperationContract]
        [FaultContract(typeof(SecurityAccessDeniedException))]
        [FaultContract(typeof(ArgumentException))]
        [FaultContract(typeof(ArgumentOutOfRangeException))]
        SNUserInfo GetSNUserInfoByXUID(ushort sNetworkId, ulong XUID);

        [OperationContract]
        [FaultContract(typeof(SecurityAccessDeniedException))]
        [FaultContract(typeof(ArgumentException))]
        [FaultContract(typeof(ArgumentOutOfRangeException))]
        [FaultContract(typeof(ArgumentNullException))]
        SNUserInfo GetSNUserInfoBySNUId(ushort sNetworkId, string snUserId);

        [OperationContract]
        [FaultContract(typeof(SecurityAccessDeniedException))]
        [FaultContract(typeof(ArgumentException))]
        [FaultContract(typeof(ArgumentOutOfRangeException))]
        [FaultContract(typeof(ArgumentNullException))]
        SNUserInfo[] GetSNUserInfos(ushort sNetworkId, string[] sNUserIDs);

        [OperationContract]
        [FaultContract(typeof(ArgumentOutOfRangeException))]
        SNetworkInfo GetSNetworkInfo(ushort sNetworkId);

        [OperationContract]
        SNetworkInfo[] GetSNetworkInfos();
    }

    [ServiceContract(Namespace="http://liveconnect.xboxlive.com")]
    public interface ILiveAuthentication
    {
        //Each of these interfaces is tied to a device which is sent in the XAML token
        [OperationContract]
        [FaultContract(typeof(SecurityAccessDeniedException))]
        [FaultContract(typeof(ArgumentException))]
        [FaultContract(typeof(ArgumentOutOfRangeException))]
        [FaultContract(typeof(ArgumentNullException))]
        void SetAuthInfo(ushort sNetworkId, ulong XUID, string gamerTag, string deviceId, SNAuthInfo userInfo, bool addToDirectory, Visibility visibility);

        [OperationContract]
        [FaultContract(typeof(SecurityAccessDeniedException))]
        [FaultContract(typeof(ArgumentException))]
        [FaultContract(typeof(ArgumentOutOfRangeException))]
        [FaultContract(typeof(ArgumentNullException))]
        SNAuthInfo GetAuthInfo(ushort sNetworkId, ulong XUID, string deviceId);

        [OperationContract]
        [FaultContract(typeof(SecurityAccessDeniedException))]
        [FaultContract(typeof(ArgumentException))]
        [FaultContract(typeof(ArgumentOutOfRangeException))]
        [FaultContract(typeof(ArgumentNullException))]
        void RemoveAuthInfo(ushort sNetworkId, ulong XUID, string deviceId);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup\LCWebService\CertNetworkMapper.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Configuration;
using System.Text.RegularExpressions;

namespace LiveConnectWeb
{
    internal sealed class CertNetworkMapper : NetworkMapper
    {
        private static readonly CertNetworkMapper instance = new CertNetworkMapper("CertId");

        private CertNetworkMapper(string key)
            : base(key)
        {
        }

        internal static CertNetworkMapper Instance
        {
            get
            {
                return instance;
            }
        }

        internal bool IsPeerAllowed(ushort networkId, string peerId)
        {
            return base.IsEntryAllowed(networkId, peerId);
        }

        internal string NormalizeSubject(string subject)
        {
            string normSubject= "";

            if (subject == null)
            {
                return null;
            }

            Match match = subjectReg.Match(subject);

            if (match.Success)
            {
                normSubject = match.Groups["subject"].Value;
            }
            else
            {
                normSubject = subject;
            }

            return normSubject;
        }

        Regex subjectReg = new Regex(@"CN\s*=\s*(?<subject>[^,]+)", RegexOptions.Compiled);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\GDS\UI\RulesBadgeAuthoring\View\StatementEditConfig.cs ===
namespace RulesBadgeAuthoring.View
{
    using System;
    using System.Collections.ObjectModel;
    using System.Collections.Generic;

    public enum StatementTypeEnum
    {
        GameKey,
        Locale,
        GameCategory,
        Statistics,
        Platforms,
        Property
    }

    public class StatementType
    {
        public string Name { get; set; }
        public bool AllowsEditing { get; set; }
        public string LeftOperand { get; set; }
        public int LeftOperandTypeIndex { get; set; }
        public int RightOperandTypeIndex { get; set; }
        public int DropDownIndex { get; set; }
        public StatementTypeEnum StatementTypeEnum { get; set; }
    }

    public static class StatementEditConfig
    {
        static private List<StatementType> intList;
        
        static public ICollection<StatementType> StatementDropDownList
        {
            get
            {
                if (intList == null)
                {
                    var arrayOfConfig = new StatementType[] 
                    {
                         //TODO: No good differentiation between Property and Statistics exist.
                         new  StatementType() 
                         {Name="GameKey", AllowsEditing=false, LeftOperand="/Event/GameKey", 
                         LeftOperandTypeIndex=0, RightOperandTypeIndex=1, DropDownIndex = 0, StatementTypeEnum=StatementTypeEnum.GameKey},
                        
                         new  StatementType() 
                         {Name="Locale", AllowsEditing=false, LeftOperand="/Event/Culture", 
                          LeftOperandTypeIndex=0, RightOperandTypeIndex=1, DropDownIndex = 1, StatementTypeEnum=StatementTypeEnum.Locale},
                        
                         new  StatementType() 
                         {Name="Game Category", AllowsEditing=false, LeftOperand="/Event/EventCategory", 
                             LeftOperandTypeIndex=0, RightOperandTypeIndex=1, DropDownIndex = 2, StatementTypeEnum=StatementTypeEnum.GameCategory},

                        new  StatementType() 
                        {Name="Platforms", AllowsEditing=false, LeftOperand="/Event/Platform", 
                            LeftOperandTypeIndex=0, RightOperandTypeIndex=1, DropDownIndex = 3, StatementTypeEnum=StatementTypeEnum.Platforms},

                        new  StatementType() 
                        {Name="Property", AllowsEditing=false, LeftOperand="/Event/Property", 
                         LeftOperandTypeIndex=0, RightOperandTypeIndex=1, DropDownIndex = 4, StatementTypeEnum=StatementTypeEnum.Property},

                        new  StatementType() 
                        {Name="Statistics", AllowsEditing=false, LeftOperand="/Event/Property", 
                            LeftOperandTypeIndex=0, RightOperandTypeIndex=1, DropDownIndex = 5, StatementTypeEnum=StatementTypeEnum.Statistics},

                    };

                    intList = new List<StatementType>(arrayOfConfig);
                }

                return intList;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup\LCWebService\LiveConnectEventLogger.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Diagnostics;

namespace LiveConnectWeb
{
    enum EventErrorIds
    {
        InternalServerError = 1000,
        GeneralSQLError = 2000,
        GeneralSecurityViolation = 3000,
        STSSecurityTitleViolation = 4001,
        STSSecurityXUIDViolation = 4002,
        STSSecurityPrivacyViolation = 4003,
        X509NoValidCertFound = 5001,
        X509SubjectViolation = 5002
    }

    class LiveConnectEventLogger
    {
        private static readonly LiveConnectEventLogger instance = new LiveConnectEventLogger();

        private LiveConnectEventLogger()
        {
            eventLog = new EventLog();
            eventLog.Source = "LiveConnect";
        }

        internal static LiveConnectEventLogger Instance
        {
            get
            {
                return instance;
            }
        }

        public EventLog EventLog
        {
            get
            {
                return eventLog;
            }
        }
        
        EventLog eventLog;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup\LCWebService\LiveConnect.designer.cs ===
#pragma warning disable 1591
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3074
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace LiveConnectWeb
{
	using System.Data.Linq;
	using System.Data.Linq.Mapping;
	using System.Data;
	using System.Collections.Generic;
	using System.Reflection;
	using System.Linq;
	using System.Linq.Expressions;
	using System.ComponentModel;
	using System;
	
	
	[System.Data.Linq.Mapping.DatabaseAttribute(Name="LiveConnect")]
	public partial class LiveConnectDataContext : System.Data.Linq.DataContext
	{
		
		private static System.Data.Linq.Mapping.MappingSource mappingSource = new AttributeMappingSource();
		
    #region Extensibility Method Definitions
    partial void OnCreated();
    partial void InsertNetworkInfo(NetworkInfo instance);
    partial void UpdateNetworkInfo(NetworkInfo instance);
    partial void DeleteNetworkInfo(NetworkInfo instance);
    partial void InsertDirectory(Directory instance);
    partial void UpdateDirectory(Directory instance);
    partial void DeleteDirectory(Directory instance);
    partial void InsertAuthentication(Authentication instance);
    partial void UpdateAuthentication(Authentication instance);
    partial void DeleteAuthentication(Authentication instance);
    #endregion
		
		public LiveConnectDataContext() :
            base(System.Configuration.ConfigurationManager.ConnectionStrings["LiveConnect"].ConnectionString, mappingSource)
    {
			OnCreated();
		}
		
		public LiveConnectDataContext(string connection) : 
				base(connection, mappingSource)
		{
			OnCreated();
		}
		
		public LiveConnectDataContext(System.Data.IDbConnection connection) : 
				base(connection, mappingSource)
		{
			OnCreated();
		}
		
		public LiveConnectDataContext(string connection, System.Data.Linq.Mapping.MappingSource mappingSource) : 
				base(connection, mappingSource)
		{
			OnCreated();
		}
		
		public LiveConnectDataContext(System.Data.IDbConnection connection, System.Data.Linq.Mapping.MappingSource mappingSource) : 
				base(connection, mappingSource)
		{
			OnCreated();
		}
		
		public System.Data.Linq.Table<NetworkInfo> NetworkInfos
		{
			get
			{
				return this.GetTable<NetworkInfo>();
			}
		}
		
		public System.Data.Linq.Table<Directory> Directories
		{
			get
			{
				return this.GetTable<Directory>();
			}
		}
		
		public System.Data.Linq.Table<Authentication> Authentications
		{
			get
			{
				return this.GetTable<Authentication>();
			}
		}
		
		[Function(Name="dbo.spGetXUIDS")]
		public ISingleResult<spGetXUIDSResult> spGetXUIDS([Parameter(DbType="Int")] System.Nullable<int> sNetworkId, [Parameter(DbType="NVarChar(4000)")] string userList)
		{
			IExecuteResult result = this.ExecuteMethodCall(this, ((MethodInfo)(MethodInfo.GetCurrentMethod())), sNetworkId, userList);
			return ((ISingleResult<spGetXUIDSResult>)(result.ReturnValue));
		}

        [Function(Name = "dbo.spGetXUIDSEx")]
        public ISingleResult<spGetXUIDSResult> spGetXUIDSEx([Parameter(DbType = "Int")] System.Nullable<int> sNetworkId, 
                                                            [Parameter(DbType = "Xml")] System.Xml.Linq.XElement userList)
        {
            IExecuteResult result = this.ExecuteMethodCall(this, ((MethodInfo)(MethodInfo.GetCurrentMethod())), sNetworkId, userList);
            return ((ISingleResult<spGetXUIDSResult>)(result.ReturnValue));
        }

		
		[Function(Name="dbo.spSetSNUserInfo")]
		public int spSetSNUserInfo([Parameter(DbType="SmallInt")] System.Nullable<short> sNetworkId, [Parameter(DbType="BigInt")] System.Nullable<long> xuid, [Parameter(DbType="NVarChar(64)")] string snUserId, [Parameter(DbType="VarChar(16)")] string gamerTag, [Parameter(DbType="Int")] System.Nullable<int> flags)
		{
			IExecuteResult result = this.ExecuteMethodCall(this, ((MethodInfo)(MethodInfo.GetCurrentMethod())), sNetworkId, xuid, snUserId, gamerTag, flags);
			return ((int)(result.ReturnValue));
		}
		
		[Function(Name="dbo.spRemoveUserInfo")]
		public int spRemoveUserInfo([Parameter(DbType="SmallInt")] System.Nullable<short> sNetworkId, [Parameter(DbType="BigInt")] System.Nullable<long> xuid)
		{
			IExecuteResult result = this.ExecuteMethodCall(this, ((MethodInfo)(MethodInfo.GetCurrentMethod())), sNetworkId, xuid);
			return ((int)(result.ReturnValue));
		}
		
		[Function(Name="dbo.spRemoveSNAuthInfo")]
		public int spRemoveSNAuthInfo([Parameter(DbType="SmallInt")] System.Nullable<short> sNetworkId, [Parameter(DbType="BigInt")] System.Nullable<long> xuid)
		{
			IExecuteResult result = this.ExecuteMethodCall(this, ((MethodInfo)(MethodInfo.GetCurrentMethod())), sNetworkId, xuid);
			return ((int)(result.ReturnValue));
		}
		
		[Function(Name="dbo.spSetAuthAndUserInfo")]
		public int spSetAuthAndUserInfo([Parameter(DbType="SmallInt")] System.Nullable<short> sNetworkId, [Parameter(DbType="BigInt")] System.Nullable<long> xuid, [Parameter(DbType="NVarChar(64)")] string snUserId, [Parameter(DbType="VarChar(16)")] string gamerTag, [Parameter(DbType="VarChar(4096)")] string token, [Parameter(DbType="VarChar(32)")] string deviceId, [Parameter(DbType="Int")] System.Nullable<int> flags, [Parameter(DbType="SmallInt")] System.Nullable<short> preserveToken)
		{
			IExecuteResult result = this.ExecuteMethodCall(this, ((MethodInfo)(MethodInfo.GetCurrentMethod())), sNetworkId, xuid, snUserId, gamerTag, token, deviceId, flags, preserveToken);
			return ((int)(result.ReturnValue));
		}
		
		[Function(Name="dbo.spSetSNAuthInfo")]
		public int spSetSNAuthInfo([Parameter(DbType="SmallInt")] System.Nullable<short> sNetworkId, [Parameter(DbType="BigInt")] System.Nullable<long> xuid, [Parameter(DbType="NVarChar(64)")] string snUserId, [Parameter(DbType="VarChar(4096)")] string token, [Parameter(DbType="VarChar(32)")] string deviceId, [Parameter(DbType="SmallInt")] System.Nullable<short> preserveToken)
		{
			IExecuteResult result = this.ExecuteMethodCall(this, ((MethodInfo)(MethodInfo.GetCurrentMethod())), sNetworkId, xuid, snUserId, token, deviceId, preserveToken);
			return ((int)(result.ReturnValue));
		}
	}
	
	[Table(Name="dbo.NetworkInfo")]
	public partial class NetworkInfo : INotifyPropertyChanging, INotifyPropertyChanged
	{
		
		private static PropertyChangingEventArgs emptyChangingEventArgs = new PropertyChangingEventArgs(String.Empty);
		
		private short _SNetworkId;
		
		private string _Description;
		
		private string _Logo;
		
    #region Extensibility Method Definitions
    partial void OnLoaded();
    partial void OnValidate(System.Data.Linq.ChangeAction action);
    partial void OnCreated();
    partial void OnSNetworkIdChanging(short value);
    partial void OnSNetworkIdChanged();
    partial void OnDescriptionChanging(string value);
    partial void OnDescriptionChanged();
    partial void OnLogoChanging(string value);
    partial void OnLogoChanged();
    #endregion
		
		public NetworkInfo()
		{
			OnCreated();
		}
		
		[Column(Storage="_SNetworkId", DbType="SmallInt NOT NULL", IsPrimaryKey=true)]
		public short SNetworkId
		{
			get
			{
				return this._SNetworkId;
			}
			set
			{
				if ((this._SNetworkId != value))
				{
					this.OnSNetworkIdChanging(value);
					this.SendPropertyChanging();
					this._SNetworkId = value;
					this.SendPropertyChanged("SNetworkId");
					this.OnSNetworkIdChanged();
				}
			}
		}
		
		[Column(Storage="_Description", DbType="NVarChar(255) NOT NULL", CanBeNull=false)]
		public string Description
		{
			get
			{
				return this._Description;
			}
			set
			{
				if ((this._Description != value))
				{
					this.OnDescriptionChanging(value);
					this.SendPropertyChanging();
					this._Description = value;
					this.SendPropertyChanged("Description");
					this.OnDescriptionChanged();
				}
			}
		}
		
		[Column(Storage="_Logo", DbType="VarChar(255) NOT NULL", CanBeNull=false)]
		public string Logo
		{
			get
			{
				return this._Logo;
			}
			set
			{
				if ((this._Logo != value))
				{
					this.OnLogoChanging(value);
					this.SendPropertyChanging();
					this._Logo = value;
					this.SendPropertyChanged("Logo");
					this.OnLogoChanged();
				}
			}
		}
		
		public event PropertyChangingEventHandler PropertyChanging;
		
		public event PropertyChangedEventHandler PropertyChanged;
		
		protected virtual void SendPropertyChanging()
		{
			if ((this.PropertyChanging != null))
			{
				this.PropertyChanging(this, emptyChangingEventArgs);
			}
		}
		
		protected virtual void SendPropertyChanged(String propertyName)
		{
			if ((this.PropertyChanged != null))
			{
				this.PropertyChanged(this, new PropertyChangedEventArgs(propertyName));
			}
		}
	}
	
	[Table(Name="dbo.Directory")]
	public partial class Directory : INotifyPropertyChanging, INotifyPropertyChanged
	{
		
		private static PropertyChangingEventArgs emptyChangingEventArgs = new PropertyChangingEventArgs(String.Empty);
		
		private short _SNetworkId;
		
		private long _XUID;
		
		private string _SNUserId;
		
		private string _GamerTag;
		
		private int _Flags;
		
		private System.DateTime _LastAccessedTime;
		
    #region Extensibility Method Definitions
    partial void OnLoaded();
    partial void OnValidate(System.Data.Linq.ChangeAction action);
    partial void OnCreated();
    partial void OnSNetworkIdChanging(short value);
    partial void OnSNetworkIdChanged();
    partial void OnXUIDChanging(long value);
    partial void OnXUIDChanged();
    partial void OnSNUserIdChanging(string value);
    partial void OnSNUserIdChanged();
    partial void OnGamerTagChanging(string value);
    partial void OnGamerTagChanged();
    partial void OnFlagsChanging(int value);
    partial void OnFlagsChanged();
    partial void OnLastAccessedTimeChanging(System.DateTime value);
    partial void OnLastAccessedTimeChanged();
    #endregion
		
		public Directory()
		{
			OnCreated();
		}
		
		[Column(Storage="_SNetworkId", DbType="SmallInt NOT NULL", IsPrimaryKey=true)]
		public short SNetworkId
		{
			get
			{
				return this._SNetworkId;
			}
			set
			{
				if ((this._SNetworkId != value))
				{
					this.OnSNetworkIdChanging(value);
					this.SendPropertyChanging();
					this._SNetworkId = value;
					this.SendPropertyChanged("SNetworkId");
					this.OnSNetworkIdChanged();
				}
			}
		}
		
		[Column(Storage="_XUID", DbType="BigInt NOT NULL", IsPrimaryKey=true)]
		public long XUID
		{
			get
			{
				return this._XUID;
			}
			set
			{
				if ((this._XUID != value))
				{
					this.OnXUIDChanging(value);
					this.SendPropertyChanging();
					this._XUID = value;
					this.SendPropertyChanged("XUID");
					this.OnXUIDChanged();
				}
			}
		}
		
		[Column(Storage="_SNUserId", DbType="NVarChar(64) NOT NULL", CanBeNull=false)]
		public string SNUserId
		{
			get
			{
				return this._SNUserId;
			}
			set
			{
				if ((this._SNUserId != value))
				{
					this.OnSNUserIdChanging(value);
					this.SendPropertyChanging();
					this._SNUserId = value;
					this.SendPropertyChanged("SNUserId");
					this.OnSNUserIdChanged();
				}
			}
		}
		
		[Column(Storage="_GamerTag", DbType="VarChar(16) NOT NULL", CanBeNull=false)]
		public string GamerTag
		{
			get
			{
				return this._GamerTag;
			}
			set
			{
				if ((this._GamerTag != value))
				{
					this.OnGamerTagChanging(value);
					this.SendPropertyChanging();
					this._GamerTag = value;
					this.SendPropertyChanged("GamerTag");
					this.OnGamerTagChanged();
				}
			}
		}
		
		[Column(Storage="_Flags", DbType="Int NOT NULL")]
		public int Flags
		{
			get
			{
				return this._Flags;
			}
			set
			{
				if ((this._Flags != value))
				{
					this.OnFlagsChanging(value);
					this.SendPropertyChanging();
					this._Flags = value;
					this.SendPropertyChanged("Flags");
					this.OnFlagsChanged();
				}
			}
		}
		
		[Column(Storage="_LastAccessedTime", DbType="DateTime2 NOT NULL")]
		public System.DateTime LastAccessedTime
		{
			get
			{
				return this._LastAccessedTime;
			}
			set
			{
				if ((this._LastAccessedTime != value))
				{
					this.OnLastAccessedTimeChanging(value);
					this.SendPropertyChanging();
					this._LastAccessedTime = value;
					this.SendPropertyChanged("LastAccessedTime");
					this.OnLastAccessedTimeChanged();
				}
			}
		}
		
		public event PropertyChangingEventHandler PropertyChanging;
		
		public event PropertyChangedEventHandler PropertyChanged;
		
		protected virtual void SendPropertyChanging()
		{
			if ((this.PropertyChanging != null))
			{
				this.PropertyChanging(this, emptyChangingEventArgs);
			}
		}
		
		protected virtual void SendPropertyChanged(String propertyName)
		{
			if ((this.PropertyChanged != null))
			{
				this.PropertyChanged(this, new PropertyChangedEventArgs(propertyName));
			}
		}
	}
	
	[Table(Name="dbo.Authentication")]
	public partial class Authentication : INotifyPropertyChanging, INotifyPropertyChanged
	{
		
		private static PropertyChangingEventArgs emptyChangingEventArgs = new PropertyChangingEventArgs(String.Empty);
		
		private short _SNetworkId;
		
		private long _XUID;
		
		private string _SNUserId;
		
		private string _Token;
		
		private string _DeviceId;
		
		private System.DateTime _LastAccessedTime;
		
    #region Extensibility Method Definitions
    partial void OnLoaded();
    partial void OnValidate(System.Data.Linq.ChangeAction action);
    partial void OnCreated();
    partial void OnSNetworkIdChanging(short value);
    partial void OnSNetworkIdChanged();
    partial void OnXUIDChanging(long value);
    partial void OnXUIDChanged();
    partial void OnSNUserIdChanging(string value);
    partial void OnSNUserIdChanged();
    partial void OnTokenChanging(string value);
    partial void OnTokenChanged();
    partial void OnDeviceIdChanging(string value);
    partial void OnDeviceIdChanged();
    partial void OnLastAccessedTimeChanging(System.DateTime value);
    partial void OnLastAccessedTimeChanged();
    #endregion
		
		public Authentication()
		{
			OnCreated();
		}
		
		[Column(Storage="_SNetworkId", DbType="SmallInt NOT NULL", IsPrimaryKey=true)]
		public short SNetworkId
		{
			get
			{
				return this._SNetworkId;
			}
			set
			{
				if ((this._SNetworkId != value))
				{
					this.OnSNetworkIdChanging(value);
					this.SendPropertyChanging();
					this._SNetworkId = value;
					this.SendPropertyChanged("SNetworkId");
					this.OnSNetworkIdChanged();
				}
			}
		}
		
		[Column(Storage="_XUID", DbType="BigInt NOT NULL", IsPrimaryKey=true)]
		public long XUID
		{
			get
			{
				return this._XUID;
			}
			set
			{
				if ((this._XUID != value))
				{
					this.OnXUIDChanging(value);
					this.SendPropertyChanging();
					this._XUID = value;
					this.SendPropertyChanged("XUID");
					this.OnXUIDChanged();
				}
			}
		}
		
		[Column(Storage="_SNUserId", DbType="NVarChar(64) NOT NULL", CanBeNull=false)]
		public string SNUserId
		{
			get
			{
				return this._SNUserId;
			}
			set
			{
				if ((this._SNUserId != value))
				{
					this.OnSNUserIdChanging(value);
					this.SendPropertyChanging();
					this._SNUserId = value;
					this.SendPropertyChanged("SNUserId");
					this.OnSNUserIdChanged();
				}
			}
		}
		
		[Column(Storage="_Token", DbType="VarChar(4096) NOT NULL", CanBeNull=false)]
		public string Token
		{
			get
			{
				return this._Token;
			}
			set
			{
				if ((this._Token != value))
				{
					this.OnTokenChanging(value);
					this.SendPropertyChanging();
					this._Token = value;
					this.SendPropertyChanged("Token");
					this.OnTokenChanged();
				}
			}
		}
		
		[Column(Storage="_DeviceId", DbType="Char(32) NOT NULL", CanBeNull=false, IsPrimaryKey=true)]
		public string DeviceId
		{
			get
			{
				return this._DeviceId;
			}
			set
			{
				if ((this._DeviceId != value))
				{
					this.OnDeviceIdChanging(value);
					this.SendPropertyChanging();
					this._DeviceId = value;
					this.SendPropertyChanged("DeviceId");
					this.OnDeviceIdChanged();
				}
			}
		}
		
		[Column(Storage="_LastAccessedTime", DbType="DateTime2 NOT NULL")]
		public System.DateTime LastAccessedTime
		{
			get
			{
				return this._LastAccessedTime;
			}
			set
			{
				if ((this._LastAccessedTime != value))
				{
					this.OnLastAccessedTimeChanging(value);
					this.SendPropertyChanging();
					this._LastAccessedTime = value;
					this.SendPropertyChanged("LastAccessedTime");
					this.OnLastAccessedTimeChanged();
				}
			}
		}
		
		public event PropertyChangingEventHandler PropertyChanging;
		
		public event PropertyChangedEventHandler PropertyChanged;
		
		protected virtual void SendPropertyChanging()
		{
			if ((this.PropertyChanging != null))
			{
				this.PropertyChanging(this, emptyChangingEventArgs);
			}
		}
		
		protected virtual void SendPropertyChanged(String propertyName)
		{
			if ((this.PropertyChanged != null))
			{
				this.PropertyChanged(this, new PropertyChangedEventArgs(propertyName));
			}
		}
	}
	
	public partial class spGetXUIDSResult
	{
		
		private long _XUID;
		
		private string _SNUserId;
		
		private string _GamerTag;
		
		private int _Flags;
		
		public spGetXUIDSResult()
		{
		}
		
		[Column(Storage="_XUID", DbType="BigInt NOT NULL")]
		public long XUID
		{
			get
			{
				return this._XUID;
			}
			set
			{
				if ((this._XUID != value))
				{
					this._XUID = value;
				}
			}
		}
		
		[Column(Storage="_SNUserId", DbType="NVarChar(64) NOT NULL", CanBeNull=false)]
		public string SNUserId
		{
			get
			{
				return this._SNUserId;
			}
			set
			{
				if ((this._SNUserId != value))
				{
					this._SNUserId = value;
				}
			}
		}
		
		[Column(Storage="_GamerTag", DbType="VarChar(16) NOT NULL", CanBeNull=false)]
		public string GamerTag
		{
			get
			{
				return this._GamerTag;
			}
			set
			{
				if ((this._GamerTag != value))
				{
					this._GamerTag = value;
				}
			}
		}
		
		[Column(Storage="_Flags", DbType="Int NOT NULL")]
		public int Flags
		{
			get
			{
				return this._Flags;
			}
			set
			{
				if ((this._Flags != value))
				{
					this._Flags = value;
				}
			}
		}
	}
}
#pragma warning restore 1591
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup\LCWebService\NetworkMapper.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Configuration;

namespace LiveConnectWeb
{
    internal abstract class NetworkMapper
    {
        protected NetworkMapper(string Key)
        {
            this.key = Key;
            key += ";";
        }

        internal void LoadFromConfig()
        {
            for (int i = 0; i < ConfigurationManager.AppSettings.Count; i++)
            {
                if (ConfigurationManager.AppSettings.GetKey(i).StartsWith(key))
                {
                    bool[] networks = new bool[MaxNetworks];

                    SetAllowedNetworks(ConfigurationManager.AppSettings[i], ref networks);

                    entries.Add(
                        ConfigurationManager.AppSettings.GetKey(i).Substring(key.Length, ConfigurationManager.AppSettings.GetKey(i).Length - key.Length).ToLower(),
                        networks);
                }
                else if (ConfigurationManager.AppSettings.GetKey(i).Equals("NumberOfNetworks"))
                {
                    ushort numNetworks = 0;

                    if (ushort.TryParse(ConfigurationManager.AppSettings[i], out numNetworks))
                    {
                        MaxNetworks = numNetworks;
                    }
                }
            }
        }

        internal bool IsEntryAllowed(ushort networkId, string entryId)
        {
            bool[] networks;

            if (networkId > MaxNetworks || entryId.Length == 0)
            {
                return false;
            }

            if (entries.TryGetValue(entryId.ToLower(), out networks))
            {
                return networks[networkId];
            }

            return false;
        }

        private void SetAllowedNetworks(string networkList, ref bool[] networks)
        {
            int first = 0, second = 0, network;
            bool done = false;

            if (networkList == null || networks == null || networkList.Length < 1 || networks.Length < 1)
            {
                return;
            }

            second = networkList.IndexOf(',', first);

            do
            {
                if (second == -1)
                {
                    second = networkList.Length;
                    done = true;
                }

                network = 0;
                if (int.TryParse(networkList.Substring(first, second - first), out network) && network <= networks.Length && network > 0)
                {
                    networks[network] = true;
                }

                if (!done)
                {
                    first = ++second;
                    second = networkList.IndexOf(',', first);
                }
            } while (!done);
        }

        internal ushort MaxNumNetworks { get { return MaxNetworks; } }

        protected ushort MaxNetworks = 5;
        private Dictionary<string, bool[]> entries = new Dictionary<string, bool[]>();
        private string key;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup\LCWebService\LiveConnectWeb.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.Serialization;
using System.ServiceModel;
using System.Text;
using System.ServiceModel.Security;
using System.Threading;
using System.Security.Principal;
using System.IdentityModel.Claims;
using System.Diagnostics;
using System.Text.RegularExpressions;
using System.Configuration;

namespace LiveConnectWeb
{
    [ServiceBehavior(Namespace="http://liveconnect.xboxlive.com")]
    public class LiveConnect : ILiveDirectory, ILiveAuthentication
    {
        private static int maxNumberOfLookups;

        #region Input Validation Routines
        private static ulong DefaultXuid(ulong Xuid, XblSamlSecurityToken xblToken)
        {
            if (xblToken != null)
            {
                return xblToken.Xuid;
            }

            return Xuid;
        }

        private string DefaultDeviceId(string deviceId, XblSamlSecurityToken xblToken)
        {
            if (xblToken != null)
            {
                return xblToken.MachineId;;
            }

            return deviceId;
        }

        private bool GamerTagIsValid(string gamerTag)
        {
            if (string.IsNullOrEmpty(gamerTag) || gamerTag.Length > 15)
            {
                return false;
            }

            string tmp = gamerTag;
            if (gamerTag.Trim().Length != tmp.Length)
            {
                return false;
            }

            if (Encoding.UTF8.GetByteCount(gamerTag) != gamerTag.Length)
            {
                return false;
            }

            return true;
        }

        private bool DeviceIdIsValid(string deviceId)
        {
            if (string.IsNullOrEmpty(deviceId))
            {
                return false;
            }

            string tmp = deviceId;
            if (deviceId.Trim().Length != tmp.Length)
            {
                return false;
            }

            return true;
        }

        private bool SNUserIDIsValid(string snUserId)
        {
            if (string.IsNullOrEmpty(snUserId) || snUserId.Length > 128 || badSnuidExp.Match(snUserId).Success)
            {
                return false;
            }
            string tmp = snUserId;

            if (snUserId.Trim().Length != tmp.Length)
            {
                return false;
            }

            return true;
        }

        private void ValidateUserInfo(SNUserInfo userInfo, XblSamlSecurityToken xblToken)
        {
            if (userInfo == null)
            {
                throw new FaultException<ArgumentNullException>(new ArgumentNullException("userInfo"));
            }

            if (DefaultXuid(userInfo.XUID, xblToken) == 0)
            {
                throw new FaultException<ArgumentOutOfRangeException>(new ArgumentOutOfRangeException("userInfo.XUID"));
            }

            // if we have a xblToken, and it's a phone token, use the gamertag from it.
            if (xblToken != null && xblToken.TokenType == XblSamlTokenType.User)
            {
                if (!string.IsNullOrEmpty(xblToken.GamerTag))
                {
                    userInfo.GamerTag = xblToken.GamerTag;
                }
            }

            if (!GamerTagIsValid(userInfo.GamerTag))
            {
                throw new FaultException<ArgumentException>(new ArgumentException("userInfo.GamerTag"));
            }

            if (!SNUserIDIsValid(userInfo.SNUserID))
            {
                throw new FaultException<ArgumentException>(new ArgumentException("userInfo.SNUserID"));
            }
        }

        private void ValidateAuthInfo(SNAuthInfo userInfo)
        {

            if (userInfo == null)
            {
                throw new FaultException<ArgumentNullException>(new ArgumentNullException("userInfo"));
            }

            if (!SNUserIDIsValid(userInfo.SNUserID))
            {
                throw new FaultException<ArgumentException>(new ArgumentException("userInfo.SNUserID"));
            }

            if (string.IsNullOrEmpty(userInfo.Token))
            {
                throw new FaultException<ArgumentException>(new ArgumentException("userInfo.Token"));
            }
        }

        private void AuthorizeTitleXuidPeer(ushort sNetworkId, XblSamlSecurityToken xblToken, ulong realXuid)
        {
            if (xblToken != null)
            {
                //Verify that the titleId is entitled to the network
                AuthorizeTitle(sNetworkId, xblToken);

                //Verify that that sts xuid matches the calling XUID
                AuthorizeXUID(sNetworkId, realXuid, xblToken);
            }
            else
            {
                AuthorizeServicePeer(sNetworkId);
            }
        }

        #endregion

        #region Authorization Check Routines
        // it is not valid to send in XUID in the parameter, that does NOT match the information in the securityToken.
        // Under the phone case, we expect to retrieve and use the Xuid information from the token explicitly.
        // this test is only valid for Console token and for nothing else.
        private void AuthorizeXUID(ushort sNetworkId, ulong XUID, XblSamlSecurityToken clientInfo)
        {
            if (clientInfo != null && clientInfo.TokenType == XblSamlTokenType.Console)
            {
                if (XUID != clientInfo.Xuid)
                {
                    LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                        string.Format("STS: XUID access denied: NetworkId: {0} Input XUID: {1} Token XUID: {2} {3}",
                        sNetworkId.ToString(),
                        XUID.ToString(),
                        clientInfo.Xuid.ToString(),
                        Environment.StackTrace),
                        EventLogEntryType.Warning,
                        (int)EventErrorIds.STSSecurityXUIDViolation);

                    throw new FaultException<SecurityAccessDeniedException>(new SecurityAccessDeniedException());
                }
            }
        }

        private void AuthorizeTitle(ushort sNetworkId, XblSamlSecurityToken clientInfo)
        {
            if (!TitleNetworkMapper.Instance.IsTitleAllowed(sNetworkId, clientInfo.TitleId.ToString("X8")))
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    string.Format("STS: Title access denied for network Id = {0} title ID = {1} {2}",
                    sNetworkId.ToString(),
                    clientInfo.TitleId,
                    Environment.StackTrace),
                    EventLogEntryType.Warning,
                    (int)EventErrorIds.STSSecurityTitleViolation);

                throw new FaultException<SecurityAccessDeniedException>(new SecurityAccessDeniedException());
            }
        }

        private void AuthorizeServicePeer(ushort sNetworkId)
        {
            X509ClientInfo xClientInfo = X509ClientInfo.GetFromOperationContext();

            if (xClientInfo != null)
            {
                //Verify that the subject that identifies the peer is entitled to the network
                if (!CertNetworkMapper.Instance.IsPeerAllowed(sNetworkId, xClientInfo.Subject))
                {
                    LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                        string.Format("X509: Certificate denied for social network ID = {0} with subject {1} {2}",
                        sNetworkId.ToString(),
                        xClientInfo.Subject,
                        Environment.StackTrace),
                        EventLogEntryType.Warning,
                        (int)EventErrorIds.X509SubjectViolation);

                    throw new FaultException<SecurityAccessDeniedException>(new SecurityAccessDeniedException());
                }

            }
            else
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    "X509: No Cert Found " + Environment.StackTrace,
                    EventLogEntryType.Warning,
                    (int)EventErrorIds.X509NoValidCertFound);

                throw new FaultException<SecurityAccessDeniedException>(new SecurityAccessDeniedException());
            }
        }
        #endregion

        internal static void Opening(Object sender, EventArgs e)
        {
            //Initalize title to network mapper from configuration
            TitleNetworkMapper.Instance.LoadFromConfig();

            //Initialize the certificate network mapper from configuration
            CertNetworkMapper.Instance.LoadFromConfig();

            string value = ConfigurationManager.AppSettings["MaxNumberOfLookups"];
            maxNumberOfLookups = int.Parse(value);

            return;
        }

        #region Interface Operations
        public void SetSNUserInfo(ushort sNetworkId, SNUserInfo userInfo)
        {
            if (sNetworkId > TitleNetworkMapper.Instance.MaxNumNetworks - 1)
            {
                throw new FaultException<ArgumentOutOfRangeException>(new ArgumentOutOfRangeException("sNetworkId"));
            }

            XblSamlSecurityToken xblToken = XblSamlSecurityToken.CreateFromSoapRequest();

            ValidateUserInfo(userInfo, xblToken);
            
            ulong realXuid = DefaultXuid(userInfo.XUID, xblToken);

            AuthorizeTitleXuidPeer(sNetworkId, xblToken, realXuid);

            try
            {
                cache.SetSNUserInfo(sNetworkId, userInfo, realXuid);
            }
            catch (System.Data.SqlClient.SqlException ex)
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    string.Format("ConnectionString: {0} Exception: {1}",
                    cache.ConnectionString,
                    ex.ToString()),
                    EventLogEntryType.Error,
                    (int)EventErrorIds.GeneralSQLError);

                throw new FaultException(genericErrorString);
            }
            catch (Exception ex)
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    string.Format("Exception: {1}",
                    ex.ToString()),
                    EventLogEntryType.Error,
                    (int)EventErrorIds.InternalServerError);

                throw new FaultException(genericErrorString);
            }
        }

        public void RemoveSNUserInfo(ushort sNetworkId, ulong XUID)
        {
            if (sNetworkId > TitleNetworkMapper.Instance.MaxNumNetworks - 1)
            {
                throw new FaultException<ArgumentOutOfRangeException>(new ArgumentOutOfRangeException("sNetworkId"));
            }

            XblSamlSecurityToken xblToken = XblSamlSecurityToken.CreateFromSoapRequest();

            ulong realXuid = DefaultXuid(XUID, xblToken);
            
            if (realXuid == 0)
            {
                throw new FaultException<ArgumentOutOfRangeException>(new ArgumentOutOfRangeException("XUID"));
            }

            AuthorizeTitleXuidPeer(sNetworkId, xblToken, realXuid);

            try
            {
                cache.RemoveSNUserInfoByXUID(sNetworkId, realXuid);
            }
            catch (System.Data.SqlClient.SqlException ex)
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    string.Format("ConnectionString: {0} Exception: {1}",
                    cache.ConnectionString,
                    ex.ToString()),
                    EventLogEntryType.Error,
                    (int)EventErrorIds.GeneralSQLError);

                throw new FaultException(genericErrorString);
            }
            catch (Exception ex)
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    string.Format("Exception: {1}",
                    ex.ToString()),
                    EventLogEntryType.Error,
                    (int)EventErrorIds.InternalServerError);

                throw new FaultException(genericErrorString);
            }

            return;
        }

        public SNUserInfo GetSNUserInfoByXUID(ushort sNetworkId, ulong XUID)
        {
            SNUserInfo userInfo;

            if (sNetworkId > TitleNetworkMapper.Instance.MaxNumNetworks - 1)
            {
                throw new FaultException<ArgumentOutOfRangeException>(new ArgumentOutOfRangeException("sNetworkId"));
            }

            XblSamlSecurityToken xblToken = XblSamlSecurityToken.CreateFromSoapRequest();

            ulong realXuid = DefaultXuid(XUID, xblToken);
            if (realXuid == 0)
            {
                throw new FaultException<ArgumentOutOfRangeException>(new ArgumentOutOfRangeException("XUID"));
            }

            AuthorizeTitleXuidPeer(sNetworkId, xblToken, realXuid);

            try
            {
                userInfo = cache.GetSNUserInfoByXUID(sNetworkId, realXuid);
            }
            catch (System.Data.SqlClient.SqlException ex)
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    string.Format("ConnectionString: {0} Exception: {1}",
                    cache.ConnectionString,
                    ex.ToString()),
                    EventLogEntryType.Error,
                    (int)EventErrorIds.GeneralSQLError);

                throw new FaultException(genericErrorString);
            }
            catch (Exception ex)
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    string.Format("Exception: {1}",
                    ex.ToString()),
                    EventLogEntryType.Error,
                    (int)EventErrorIds.InternalServerError);

                throw new FaultException(genericErrorString);
            }

            //Verify that that sts xuid matches the calling XUID
            //If the entry is not visible then the XUIDs must match
            if (xblToken != null)
            {
                if (userInfo != null && realXuid != XUID && userInfo.Visibility != Visibility.Everyone)
                {
                    //peterl:   suppressing this as per the xoc, bug# 11564.  These events are flooding the event log,
                    //          due to a bug in twitter/facebook console applications.
                    //LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    //    string.Format("STS: XUID Denied: NetworkId: {0} Input XUID: {1} Token XUID: {2} Visibility {3}",
                    //    sNetworkId.ToString(),
                    //    XUID.ToString(),
                    //    realXuid.ToString(),
                    //    userInfo.Visibility.ToString()),
                    //    EventLogEntryType.Warning,
                    //    (int)EventErrorIds.STSSecurityPrivacyViolation);

                    throw new FaultException<SecurityAccessDeniedException>(new SecurityAccessDeniedException());
                }
            }

            return userInfo;
        }

        public SNUserInfo GetSNUserInfoBySNUId(ushort sNetworkId, string snUserId)
        {
            SNUserInfo userInfo;

            if (sNetworkId > TitleNetworkMapper.Instance.MaxNumNetworks - 1)
            {
                throw new FaultException<ArgumentOutOfRangeException>(new ArgumentOutOfRangeException("sNetworkId"));
            }

            if (!SNUserIDIsValid(snUserId))
            {
                throw new FaultException<ArgumentException>(new ArgumentException("snUserId"));
            }

            try
            {
                userInfo = cache.GetSNUserInfoBySNUId(sNetworkId, snUserId);
            }
            catch (System.Data.SqlClient.SqlException ex)
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    string.Format("ConnectionString: {0} Exception: {1}",
                    cache.ConnectionString,
                    ex.ToString()),
                    EventLogEntryType.Error,
                    (int)EventErrorIds.GeneralSQLError);

                throw new FaultException(genericErrorString);
            }
            catch (Exception ex)
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    string.Format("Exception: {1}",
                    ex.ToString()),
                    EventLogEntryType.Error,
                    (int)EventErrorIds.InternalServerError);

                throw new FaultException(genericErrorString);
            }

            XblSamlSecurityToken xblToken = XblSamlSecurityToken.CreateFromSoapRequest();
            if (xblToken != null)
            {
                //Verify that the titleId is entitled to the network
                AuthorizeTitle(sNetworkId, xblToken);

                //Verify that that sts xuid matches the returned XUID
                //If the entry is not visible then the XUIDs must match
                if (userInfo != null && userInfo.XUID != xblToken.Xuid && userInfo.Visibility != Visibility.Everyone)
                {
                    //peterl:   suppressing this as per the xoc, bug# 11564.  These events are flooding the event log,
                    //          due to a bug in twitter/facebook console applications.
                    //LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    //    string.Format("STS: XUID Denied: Input XUID: {0} Token XUID: {1} Visibility {2}",
                    //    userInfo.XUID.ToString(),
                    //    xblToken.Xuid.ToString(),
                    //    userInfo.Visibility.ToString()),
                    //    EventLogEntryType.Warning,
                    //    (int)EventErrorIds.STSSecurityPrivacyViolation);

                    throw new FaultException<SecurityAccessDeniedException>(new SecurityAccessDeniedException());
                }
            }
            else
            {
                AuthorizeServicePeer(sNetworkId);
            }

            return userInfo;
        }

        public SNUserInfo[] GetSNUserInfos(ushort sNetworkId, string[] sNUserIDs)
        {
            if (sNetworkId > TitleNetworkMapper.Instance.MaxNumNetworks - 1)
            {
                throw new FaultException<ArgumentOutOfRangeException>(new ArgumentOutOfRangeException("sNetworkId"));
            }

            if (sNUserIDs == null || sNUserIDs.Length == 0)
            {
                throw new FaultException<ArgumentNullException>(new ArgumentNullException("sNUserIDs"));
            }

            if (sNUserIDs.Length > maxNumberOfLookups)
            {
                throw new FaultException<ArgumentOutOfRangeException>(new ArgumentOutOfRangeException("sNUserIDs"));
            }

            foreach (string userId in sNUserIDs)
            {
                if(!SNUserIDIsValid(userId))
                {
                    throw new FaultException<ArgumentException>(new ArgumentException("sNUserIDs"));
                }
            }

            XblSamlSecurityToken xblToken = XblSamlSecurityToken.CreateFromSoapRequest();

            if (xblToken != null)
            {
                //Verify that the titleId is entitled to the network
                AuthorizeTitle(sNetworkId, xblToken);
            }
            else
            {
                AuthorizeServicePeer(sNetworkId);
            }

            try
            {
                SNUserInfo[] userInfos = cache.GetSNUserInfos(sNetworkId, sNUserIDs);

                // scrub XUIDs from SNUI structure if the request is coming from WP7
                if (xblToken != null && xblToken.TokenType == XblSamlTokenType.User)
                {
                    foreach (SNUserInfo userInfo in userInfos)
                    {
                        userInfo.XUID = 0;
                    }
                }
                
                return userInfos;
            }
            catch (System.Data.SqlClient.SqlException ex)
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    string.Format("ConnectionString: {0} Exception: {1}",
                    cache.ConnectionString,
                    ex.ToString()),
                    EventLogEntryType.Error,
                    (int)EventErrorIds.GeneralSQLError);

                throw new FaultException(genericErrorString);
            }
            catch (Exception ex)
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    string.Format("Exception: {1}",
                    ex.ToString()),
                    EventLogEntryType.Error,
                    (int)EventErrorIds.InternalServerError);

                throw new FaultException(genericErrorString);
            }
            finally
            {
                ScheduleGamertagChangeCheck(sNetworkId, xblToken);
            }
        }

        private static void ScheduleGamertagChangeCheck(ushort sNetworkId, XblSamlSecurityToken xblToken)
        {
            // if we have a user token, schedule a gamerTag check and update worker Item.
            if (xblToken != null &&
                xblToken.TokenType == XblSamlTokenType.User &&
                !string.IsNullOrEmpty(xblToken.GamerTag) &&
                xblToken.Xuid != 0)
            {
                // update the gamerTag if it has changed.
                ThreadPool.QueueUserWorkItem(delegate(object state)
                {
                    try
                    {
                        string newGamerTag = xblToken.GamerTag;
                        ulong xuid = xblToken.Xuid;
                        ushort snid = sNetworkId;
                        SNUserInfo snUserInfo = cache.GetSNUserInfoByXUID(snid, xuid);

                        if (snUserInfo != null && snUserInfo.GamerTag != newGamerTag)
                        {
                            snUserInfo.GamerTag = newGamerTag;
                            cache.SetSNUserInfo(snid, snUserInfo, xuid);
                        }
                    }
                    catch (Exception ex)
                    {
                        LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                            string.Format("ConnectionString: {0} Exception: {1}",
                            cache.ConnectionString,
                            ex.ToString()),
                            EventLogEntryType.Error,
                            (int)EventErrorIds.GeneralSQLError);
                    }
                });
            }
        }

        public SNetworkInfo GetSNetworkInfo(ushort sNetworkId)
        {
            SNetworkInfo sNetworkInfo = null;

            if (sNetworkId > TitleNetworkMapper.Instance.MaxNumNetworks - 1)
            {
                throw new FaultException<ArgumentOutOfRangeException>(new ArgumentOutOfRangeException("sNetworkId"));
            }

            XblSamlSecurityToken xblToken = XblSamlSecurityToken.CreateFromSoapRequest();

            if (xblToken == null && X509ClientInfo.GetFromOperationContext() == null)
            {
                throw new FaultException<SecurityAccessDeniedException>(new SecurityAccessDeniedException());
            }

            try
            {
                sNetworkInfo = cache.GetSNetworkInfo(sNetworkId);
            }
            catch (System.Data.SqlClient.SqlException ex)
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    string.Format("ConnectionString: {0} Exception: {1}",
                    cache.ConnectionString,
                    ex.ToString()),
                    EventLogEntryType.Error,
                    (int)EventErrorIds.GeneralSQLError);

                throw new FaultException(genericErrorString);
            }
            catch (Exception ex)
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    string.Format("Exception: {1}",
                    ex.ToString()),
                    EventLogEntryType.Error,
                    (int)EventErrorIds.InternalServerError);

                throw new FaultException(genericErrorString);
            }

            return sNetworkInfo;
        }

        public SNetworkInfo[] GetSNetworkInfos()
        {
            SNetworkInfo[] networkInfos = null;
            XblSamlSecurityToken xblToken = XblSamlSecurityToken.CreateFromSoapRequest();

            if (xblToken == null && X509ClientInfo.GetFromOperationContext() == null)
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    "No STS token and no certificate found",
                    EventLogEntryType.Warning,
                    (int)EventErrorIds.GeneralSecurityViolation);

                throw new FaultException<SecurityAccessDeniedException>(new SecurityAccessDeniedException());
            }

            try
            {
                networkInfos = cache.GetSNetworkInfos();
            }
            catch (System.Data.SqlClient.SqlException ex)
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    string.Format("ConnectionString: {0} Exception: {1}",
                    cache.ConnectionString,
                    ex.ToString()),
                    EventLogEntryType.Error,
                    (int)EventErrorIds.GeneralSQLError);

                throw new FaultException(genericErrorString);
            }
            catch (Exception ex)
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    string.Format("Exception: {1}",
                    ex.ToString()),
                    EventLogEntryType.Error,
                    (int)EventErrorIds.InternalServerError);

                throw new FaultException(genericErrorString);
            }

            return networkInfos;
        }

        public void SetAuthInfo(ushort sNetworkId, ulong XUID, string gamerTag, string deviceId, SNAuthInfo userInfo, bool addToDirectory, Visibility visibility)
        {
            XblSamlSecurityToken xblToken = XblSamlSecurityToken.CreateFromSoapRequest();

            string machineId = DefaultDeviceId(deviceId, xblToken);

            if (sNetworkId > TitleNetworkMapper.Instance.MaxNumNetworks - 1)
            {
                throw new FaultException<ArgumentOutOfRangeException>(new ArgumentOutOfRangeException("sNetworkId"));
            }

            if (!GamerTagIsValid(gamerTag))
            {
                throw new FaultException<ArgumentNullException>(new ArgumentNullException("gamerTag"));
            }

            if (!DeviceIdIsValid(machineId))
            {
                throw new FaultException<ArgumentNullException>(new ArgumentNullException("deviceId"));
            }

            ValidateAuthInfo(userInfo);

            ulong realXuid = DefaultXuid(XUID, xblToken);

            AuthorizeTitleXuidPeer(sNetworkId, xblToken, realXuid);

            try
            {
                cache.SetAuthInfo(sNetworkId, realXuid, gamerTag, machineId, userInfo, addToDirectory, visibility);
            }
            catch (System.Data.SqlClient.SqlException ex)
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    string.Format("ConnectionString: {0} Exception: {1}",
                    cache.ConnectionString,
                    ex.ToString()),
                    EventLogEntryType.Error,
                    (int)EventErrorIds.GeneralSQLError);

                throw new FaultException(genericErrorString);
            }
            catch (Exception ex)
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    string.Format("Exception: {1}",
                    ex.ToString()),
                    EventLogEntryType.Error,
                    (int)EventErrorIds.InternalServerError);

                throw new FaultException(genericErrorString);
            }

            return;
        }

        public SNAuthInfo GetAuthInfo(ushort sNetworkId, ulong XUID, string deviceId)
        {
            XblSamlSecurityToken xblToken = XblSamlSecurityToken.CreateFromSoapRequest();
            SNAuthInfo authInfo = null;

            string machineId = DefaultDeviceId(deviceId, xblToken);

            if (sNetworkId > TitleNetworkMapper.Instance.MaxNumNetworks - 1)
            {
                throw new FaultException<ArgumentOutOfRangeException>(new ArgumentOutOfRangeException("sNetworkId"));
            }

            if (!DeviceIdIsValid(machineId))
            {
                throw new FaultException<ArgumentException>(new ArgumentException("deviceId"));
            }

            ulong realXuid = DefaultXuid(XUID, xblToken);

            AuthorizeTitleXuidPeer(sNetworkId, xblToken, realXuid);

            try
            {
                authInfo = cache.GetAuthInfo(sNetworkId, realXuid, machineId);
            }
            catch (System.Data.SqlClient.SqlException ex)
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    string.Format("ConnectionString: {0} Exception: {1}",
                    cache.ConnectionString,
                    ex.ToString()),
                    EventLogEntryType.Error,
                    (int)EventErrorIds.GeneralSQLError);

                throw new FaultException(genericErrorString);
            }
            catch (Exception ex)
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    string.Format("Exception: {1}",
                    ex.ToString()),
                    EventLogEntryType.Error,
                    (int)EventErrorIds.InternalServerError);

                throw new FaultException(genericErrorString);
            }

            return authInfo;
        }

        public void RemoveAuthInfo(ushort sNetworkId, ulong XUID, string deviceId)
        {
            XblSamlSecurityToken xblToken = XblSamlSecurityToken.CreateFromSoapRequest();

            string machineId = DefaultDeviceId(deviceId, xblToken);

            if (sNetworkId > TitleNetworkMapper.Instance.MaxNumNetworks - 1)
            {
                throw new FaultException<ArgumentOutOfRangeException>(new ArgumentOutOfRangeException("sNetworkId"));
            }

            if (!DeviceIdIsValid(machineId))
            {
                throw new FaultException<ArgumentException>(new ArgumentException("deviceId"));
            }

            ulong realXuid = DefaultXuid(XUID, xblToken);

            AuthorizeTitleXuidPeer(sNetworkId, xblToken, realXuid);

            try
            {
                cache.RemoveAuthInfo(sNetworkId, realXuid, machineId);
            }
            catch (System.Data.SqlClient.SqlException ex)
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    string.Format("ConnectionString: {0} Exception: {1}",
                    cache.ConnectionString,
                    ex.ToString()),
                    EventLogEntryType.Error,
                    (int)EventErrorIds.GeneralSQLError);

                throw new FaultException(genericErrorString);
            }
            catch (Exception ex)
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    string.Format("Exception: {1}",
                    ex.ToString()),
                    EventLogEntryType.Error,
                    (int)EventErrorIds.InternalServerError);

                throw new FaultException(genericErrorString);
            }

            return;
        }
        #endregion

        const string genericErrorString = "Internal Server Error";
        static LiveConnectCache cache = new LiveConnectCache();
        static Regex badSnuidExp = new Regex(@"[<>:"",\\]", RegexOptions.Compiled);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup\LCWebService\LiveConnectCache.cs ===
using System;
using System.Text;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Data.Linq;
using System.Xml.Linq;

namespace LiveConnectWeb
{
    public class LiveConnectCache
    {
        private const string Snuids = "Snuids";
        private const string Snuid = "id";

        internal string ConnectionString
        {
            get
            {
                LiveConnectDataContext db = new LiveConnectDataContext();

                return db.Connection.ConnectionString;
            }
        }

        //This function removes the pairing from both the authentication table and the user table
        public void RemoveSNUserInfoByXUID(ushort sNetworkId, ulong XUID)
        {
            using (LiveConnectDataContext db = new LiveConnectDataContext())
            {
                int retVal = db.spRemoveUserInfo((short)sNetworkId, (long)XUID);

                //TODO: Add correct exception when error handling story is in place
                if (retVal != 0)
                {
                    throw new Exception();
                }
            }
        }

        public SNUserInfo GetSNUserInfoByXUID(ushort sNetworkId, ulong XUID)
        {
            using (LiveConnectDataContext db = new LiveConnectDataContext())
            {
                Directory directoryEntry = db.Directories.SingleOrDefault(record => record.XUID == (long)XUID && record.SNetworkId == sNetworkId);

                if (directoryEntry == null)
                {
                    return null;
                }

                return GetSNUserInfoFromRecord(directoryEntry);
            }
        }

        public SNUserInfo GetSNUserInfoBySNUId(ushort sNetworkId, string snUserId)
        {
            using (LiveConnectDataContext db = new LiveConnectDataContext())
            {
                Directory directoryEntry = db.Directories.SingleOrDefault(record => record.SNetworkId == sNetworkId && record.SNUserId == snUserId);

                if (directoryEntry == null)
                {
                    return null;
                }

                return GetSNUserInfoFromRecord(directoryEntry);
            }
        }

        private static SNUserInfo GetSNUserInfoFromRecord(Directory directoryEntry)
        {
            //TODO: Change this to a stored proc and add a call to update the LastAccessedTime
            return new SNUserInfo()
            {
                SNUserID = directoryEntry.SNUserId,
                XUID = (ulong)directoryEntry.XUID,
                GamerTag = directoryEntry.GamerTag,
                Visibility = (Visibility)directoryEntry.Flags
            };
        }

        public void SetSNUserInfo(ushort sNetworkId, SNUserInfo userInfo, ulong realXuid)
        {
            using (LiveConnectDataContext db = new LiveConnectDataContext())
            {
                int flags = 0;

                if (userInfo.Visibility == Visibility.Everyone)
                {
                    flags = 1;
                }

                int retVal = db.spSetAuthAndUserInfo((short)sNetworkId, (long)realXuid, userInfo.SNUserID, userInfo.GamerTag, null, null, flags, 1);

                //TODO: Add correct exception when error handling story is in place
                if (retVal != 0)
                {
                    throw new Exception();
                }
            }
        }

        public SNetworkInfo GetSNetworkInfo(ushort sNetworkId)
        {
            using (LiveConnectDataContext db = new LiveConnectDataContext())
            {

                NetworkInfo networkInfo = db.NetworkInfos.SingleOrDefault(record => record.SNetworkId == sNetworkId);

                if (networkInfo == null)
                {
                    return null;
                }

                return GetNetworkInfoFromRecord(networkInfo);
            }
        }

        public SNetworkInfo[] GetSNetworkInfos()
        {
            LiveConnectDataContext db = new LiveConnectDataContext();
            List<SNetworkInfo> networkList = new List<SNetworkInfo>();

            foreach (NetworkInfo networkInfo in db.NetworkInfos)
            {
                SNetworkInfo sni = new SNetworkInfo();

                sni.Description = networkInfo.Description;
                sni.Id = (uint)networkInfo.SNetworkId;
                sni.Logo = networkInfo.Logo;

                networkList.Add(sni);
            }

            return networkList.ToArray();
        }

        SNetworkInfo GetNetworkInfoFromRecord(NetworkInfo networkInfo)
        {
            return new SNetworkInfo()
            {
                Description = networkInfo.Description,
                Logo = networkInfo.Logo,
                Id = (uint)networkInfo.SNetworkId
            };
        }

        public void SetAuthInfo(ushort sNetworkId, ulong XUID, string gamerTag, string deviceId, SNAuthInfo userInfo, bool addToDirectory, Visibility visibility)
        {
            using (LiveConnectDataContext db = new LiveConnectDataContext())
            {
                int flags = 0;

                if (
                    gamerTag.Length <= 0 ||
                    deviceId.Length <= 0 ||
                    userInfo == null ||
                    XUID == 0 ||
                    userInfo.Token.Length <= 0 ||
                    userInfo.SNUserID.Length <= 0)
                {
                    throw new ArgumentException();
                }

                //We always add to the directory but default to private
                //Ignore visibility if adding to the directory was not specified
                if (visibility == Visibility.Everyone && addToDirectory)
                {
                    flags = 1;
                }

                int retVal = db.spSetAuthAndUserInfo((short)sNetworkId, (long)XUID, userInfo.SNUserID, gamerTag, userInfo.Token, deviceId, flags, 0);

                //TODO: Add correct exception when error handling story is in place
                if (retVal != 0)
                {
                    throw new Exception();
                }
            }
       }

        public SNAuthInfo GetAuthInfo(ushort sNetworkId, ulong XUID, string deviceId)
        {
            using (LiveConnectDataContext db = new LiveConnectDataContext())
            {

                Authentication authEntry = db.Authentications.SingleOrDefault(record => record.XUID == (long)XUID && record.SNetworkId == sNetworkId && record.DeviceId == deviceId);

                if (authEntry == null)
                {
                    return null;
                }

                return GetAuthInfoFromRecord(authEntry);
            }
        }

        private static SNAuthInfo GetAuthInfoFromRecord(Authentication authEntry)
        {
            return new SNAuthInfo()
            {
                SNUserID = authEntry.SNUserId,
                Token = authEntry.Token
            };
        }

        public SNUserInfo[] GetSNUserInfos(ushort sNetworkId, string[] sNUserIDs)
        {
            List<SNUserInfo> snUserInfos = new List<SNUserInfo>();

            using (LiveConnectDataContext db = new LiveConnectDataContext())
            {
                XElement xmlSnuidList = ConvertSnuidsToXml(sNUserIDs);

                using (ISingleResult<spGetXUIDSResult> xuidResults = db.spGetXUIDSEx((int)sNetworkId, xmlSnuidList))
                {
                    foreach (spGetXUIDSResult xuidResult in xuidResults)
                    {
                        SNUserInfo tmp;

                        tmp = new SNUserInfo();

                        tmp.XUID = (ulong)xuidResult.XUID;
                        tmp.SNUserID = xuidResult.SNUserId.ToString();
                        tmp.Visibility = (Visibility)xuidResult.Flags;
                        tmp.GamerTag = xuidResult.GamerTag;

                        snUserInfos.Add(tmp);
                    }
                }

                return snUserInfos.ToArray();
            }
        }

        //This nulls out the token and device but does not remove the user pairing
        public void RemoveAuthInfo(ushort sNetworkId, ulong XUID, string deviceId)
        {
            using (LiveConnectDataContext db = new LiveConnectDataContext())
            {
                int retVal = db.spRemoveSNAuthInfo((short)sNetworkId, (long)XUID);

                //TODO: Add correct exception when error handling story is in place
                if (retVal != 0)
                {
                    throw new Exception();
                }
            }
        }

        private static XElement ConvertSnuidsToXml(string[] sNUserIDs)
        {
            XElement root = new XElement(LiveConnectCache.Snuids);
            
            foreach (string snuid in sNUserIDs)
            {
                XElement newNode = new XElement(LiveConnectCache.Snuid, snuid);
                root.Add(newNode);
            }

            return root;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup\LCWebService\Smoke.aspx.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Globalization;
using System.Net;
using System.IO;
using System.Diagnostics;

/// <summary>
/// Summary description for Smoke.
/// </summary>
public partial class Smoke : System.Web.UI.Page
{
    private static string buildNumber;
    private static object buildLock = new object();

    /// <summary>
    /// 
    /// </summary>
    private string BuildNumber
    {
        get
        {
            if (buildNumber == null)
            {
                lock (buildLock)
                {
                    if (buildNumber == null)
                    {
                        buildNumber = typeof(LiveConnectWeb.LiveConnect).Assembly.GetName().Version.ToString();
                    }
                }
            }

            return buildNumber;
        }
    }

    /// <summary>
    /// 
    /// </summary>
    protected void DoSmokeTests()
    {
        bool result = true;
        result &= WriteHeaderInfo();
        result &= DoSqlStatementTest();
        //result &= DoStoredProcTest();
        
        if (!result)
            this.Response.StatusCode = 500; //one or more tests failed
    }


    /// <summary>
    /// 
    /// </summary>
    private bool WriteHeaderInfo()
    {
        try
        {
            Response.Write("<h2>Site Info</h2><br/>");
            string machineName = Environment.MachineName;
            if (machineName.Length < 5)
                machineName = "###";
            else
                machineName = machineName.Substring(0, 1) + "####" + machineName.Substring(machineName.Length - 4);
            Response.Write("Host: " + machineName + "<br/>");
            Response.Write(String.Format("{0}<br/>", BuildNumber));
            return true;
        }
        catch (Exception ex)
        {
            Response.Write(ex.ToString() + "<br/><br/>");
            return false;
        }
    }

    /// <summary>
    /// 
    /// </summary>
    /// <returns></returns>
    private bool DoSqlStatementTest()
    {
        try
        {
            Response.Write("<h2>Accessing DB</h2><br/>");
            Response.Write("<strong>SQL Statements:</strong><br/>");
            
            using(SqlConnection connection = new SqlConnection(System.Configuration.ConfigurationManager.ConnectionStrings["LiveConnect"].ConnectionString))
            using(SqlCommand command = new SqlCommand("SELECT * FROM NetworkInfo (nolock)", connection))
            {
            	connection.Open();
		using(SqlDataReader reader = command.ExecuteReader())
		{
			while(reader.Read())
			{
				Response.Write(String.Format("{0}, {1}, {2}<br/>", reader["SNetworkId"], reader["Description"], reader["Logo"]));
			}
		}
	    }
	    	    
            Response.Write("OK<br/><br/>");           
            return true;
        }
        catch (Exception ex)
        {
            Response.Write(ex.ToString() + "<br/><br/>");
            return false;
        }
    }

    /// <summary>
    /// 
    /// </summary>
    /// <returns></returns>
    /*private bool DoStoredProcTest()
    {
        try
        {
            Response.Write("<strong>Stored Procedures:</strong><br/>");
            using(SqlConnection connection = new SqlConnection("Persist Security Info=False;Integrated Security=SSPI;database=LiveConnect;server=LEOSQL"))
	    using(SqlCommand command = new SqlCommand("SELECT * FROM NetworkInfo (nolock)", connection))
	    {
	    	using(SqlDataReader reader = command.ExecuteReader())
	    	{
			while(reader.Read())
			{
				Response.Write(String.Format("{0}, {1}, {2}", reader["SNetworkId"], reader["Description"], reader["Logo"]));
			}
		}
	    }
            Response.Write("OK<br/><br/>");
            return true;
        }
        catch (Exception ex)
        {
            Response.Write(ex.ToString() + "<br/><br/>");
            return false;
        }
    }    */
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup\LCWebService\MessageInterceptor.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.ServiceModel.Dispatcher;
using System.ServiceModel.Description;
using System.ServiceModel;
using System.Collections.ObjectModel;
using System.ServiceModel.Channels;
using System.IO;

namespace LiveConnectWeb
{
    class MessageInterceptor : IDispatchMessageInspector, IServiceBehavior
    {
        DateTime timeToCheckSiteClosed;
        bool isUpdating = false;
        string siteClosedFileName;

        public MessageInterceptor()
        {
            timeToCheckSiteClosed = DateTime.Now;
            siteClosedFileName = System.Web.Hosting.HostingEnvironment.ApplicationPhysicalPath + "site.closed";
        }

        public object AfterReceiveRequest(ref System.ServiceModel.Channels.Message request, IClientChannel channel, InstanceContext instanceContext)
        {
            if (timeToCheckSiteClosed < DateTime.Now)
            {
                isUpdating = File.Exists(siteClosedFileName);
                timeToCheckSiteClosed = DateTime.Now + TimeSpan.FromSeconds(30);
            }

            // DeploymentStatus is just a static class, used throughout the project  web or otherwise  indicate the state of the site
            if (isUpdating)
            {
                throw new FaultException("Service is temporarily unavailable");
            }

            return null;
        }

        public void BeforeSendReply(ref System.ServiceModel.Channels.Message reply, object correlationState)
        {
        }

        public void ApplyDispatchBehavior(
            ServiceDescription desc, ServiceHostBase host)
        {
            foreach (
                ChannelDispatcher cDispatcher in host.ChannelDispatchers)
                foreach (EndpointDispatcher eDispatcher in
                    cDispatcher.Endpoints)
                    eDispatcher.DispatchRuntime.MessageInspectors.Add(
                        new MessageInterceptor());
        }

        public void AddBindingParameters(
            ServiceDescription serviceDescription,
            ServiceHostBase serviceHostBase,
            Collection<ServiceEndpoint> endpoints,
            BindingParameterCollection bindingParameters
        )
        {
            return;
        }

        public void Validate(
            ServiceDescription serviceDescription,
            ServiceHostBase serviceHostBase
        )
        {
            return;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup\LCWebService\ServiceFactory.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.ServiceModel.Activation;
using System.ServiceModel;

namespace LiveConnectWeb
{
    public class ServiceFactory : ServiceHostFactory
    {
        public override ServiceHostBase CreateServiceHost(string service, Uri[] baseAddresses)
        {
            ServiceHost serviceHost;

            serviceHost = new ServiceHost(typeof(LiveConnectWeb.LiveConnect), baseAddresses);
            serviceHost.Opening += new EventHandler(LiveConnect.Opening);

            serviceHost.Description.Behaviors.Add(new MessageInterceptor());

            return serviceHost;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup\LCWebService\TitleNetworkMapper.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Configuration;

namespace LiveConnectWeb
{
    internal sealed class TitleNetworkMapper : NetworkMapper
    {
        private static readonly TitleNetworkMapper instance = new TitleNetworkMapper("TitleId");

        private TitleNetworkMapper(string key)
            : base(key)
        {
        }

        internal static TitleNetworkMapper Instance
        {
            get
            {
                return instance;
            }
        }

        internal bool IsTitleAllowed(ushort networkId, string titleId)
        {
            return base.IsEntryAllowed(networkId, titleId);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup\LCWebService\SNInfo.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Runtime.Serialization;

namespace LiveConnectWeb
{
    [DataContract]
    public class SNetworkInfo
    {
        string description;
        string logo;
        uint networkId;

        [DataMember]
        public string Description
        {
            get
            {
                return description;
            }

            set
            {
                description = value;
            }
        }

        [DataMember]
        public string Logo
        {
            get
            {
                return logo;
            }

            set
            {
                logo = value;
            }
        }

        [DataMember]
        public uint Id
        {
            get
            {
                return networkId;
            }

            set
            {
                networkId = value;
            }
        }

        public override string ToString()
        {
            return String.Format("{0} (ID={1}) - {2}", this.Description, this.Id, this.Logo);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup\LCWebService\SNAuthInfo.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Runtime.Serialization;

namespace LiveConnectWeb
{
    [DataContract]
    public class SNAuthInfo
    {
        string snUserId;
        string token;

        [DataMember]
        public string SNUserID
        {
            get
            {
                return snUserId;
            }

            set
            {
                snUserId = value;
            }
        }

        [DataMember]
        public string Token
        {
            get
            {
                return token;
            }

            set
            {
                token = value;
            }
        }

        public override string ToString()
        {
            return String.Format("SNUserID={0}, Token={1}", this.snUserId, this.token);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup\LCWebService\SNUserInfo.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Runtime.Serialization;

namespace LiveConnectWeb
{
    [DataContract]
    public enum Visibility
    {
        [EnumMember] Me,
        [EnumMember] Everyone
    };

    [DataContract]
    public partial class SNUserInfo
    {
        string snUserId;
        string gamerTag;
        ulong xuid;
        Visibility visibility;

        [DataMember]
        public ulong XUID
        {
            get
            {
                return xuid;
            }
            set
            {
                xuid = value;
            }
        }

        [DataMember]
        public string GamerTag
        {
            get
            {
                return gamerTag;
            }

            set
            {
                gamerTag = value;
            }
        }

        [DataMember]
        public string SNUserID 
        { 
            get
            {
                return snUserId;
            }

            set
            {
                snUserId = value;
            }
        }

        [DataMember]
        public Visibility Visibility 
        {
            get
            {
                return visibility;
            }

            set
            {
                visibility = value;
            }
        }

        public override string ToString()
        {
            return ToString("\r\n");
        }

        public string ToString(string delimiter)
        {
            return String.Format("XUID={0}{4}GamerTag={1}{4}SNUserID={2}{4}Visibility={3}",
                                    this.xuid.ToString("X16"),
                                    this.gamerTag,
                                    this.snUserId,
                                    this.visibility,
                                    delimiter);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup\LCWebService\X509ClientInfo.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.ServiceModel;
using System.Security.Principal;

namespace LiveConnectWeb
{
    internal class X509ClientInfo
    {
        internal static X509ClientInfo GetFromOperationContext()
        {
            X509ClientInfo clientInfo = null;
            char[] deliminator = {';'};

                if (OperationContext.Current.ServiceSecurityContext.PrimaryIdentity.AuthenticationType.CompareTo("X509") == 0)
                {
                    string[] values = OperationContext.Current.ServiceSecurityContext.PrimaryIdentity.Name.Split(deliminator);

                    if (values.Length == 2)
                    {
                        clientInfo = new X509ClientInfo();

                        clientInfo.Subject = CertNetworkMapper.Instance.NormalizeSubject(values[0]);

                        clientInfo.Thumbprint = values[1];
                    }
                }

                return clientInfo;
        }

        internal string Subject { get; private set; }
        internal string Thumbprint { get; private set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup\LCWebService\test\CustomSignedXml.cs ===
using System;
using System.Collections.Generic;
using System.Web;
using System.Xml;
using System.Xml.Serialization;
using System.Security.Cryptography;
using System.Security.Cryptography.Xml;


namespace LiveConnectWeb.Test
{

    // http://blogs.msdn.com/shawnfa/archive/2004/04/05/108098.aspx
    // Searching for Custom ID Tags With Signed XML
    // Excerpt... The biggest limitation with doing this is that you must refer to the nodes that are being signed by ID, 
    // which for v1.1 and 1.0 of the framework was given by an attribute named "Id". The problem there is that 
    // the Id attribute may already have another use in your schema, and you cannot reuse them for creating node names. 
    // Another problem that may come up is that the XML being signed may be generated by a tool or program, 
    // and it's not possible for you to add Id tags. Whidbey reduces this limitation somewhat by also allowing 
    // "id" and "ID", but the fundamental problem still exists.

    // Nodes that are being referred to by ID are resolved in the GetIdElement method of the SignedXml class. 
    // By subclassing SignedXml and overriding this method, its possible to create your own id node resolver. 


    public class CustomSignedXml : SignedXml
    {
        public CustomSignedXml(XmlDocument doc) :
            base(doc)
        {
        }

        public override XmlElement GetIdElement(XmlDocument doc, string id)
        {
            // check to see if it's a standard ID reference
            XmlElement idElem = base.GetIdElement(doc, id);
            if (idElem != null)
                return idElem;

            idElem = doc.SelectSingleNode("//*[@AssertionID=\"" + id + "\"]") as XmlElement;
            return idElem;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup\LCWebService\XblSamlToken.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.ServiceModel;
using System.IdentityModel.Tokens;
using System.ServiceModel.Security;

namespace LiveConnectWeb
{
    /// <summary>
    /// 
    /// </summary>
    public enum XblSamlTokenType: byte
    {
        Console,
        User,
        Partner,
        Machine,
    }

    /// <summary>
    /// platform types, as defined in xonline
    /// </summary>
    public enum Platform: ushort
    {
        Xbox1 = 0,
        Xbox360 = 1,
        PC = 2,
        Web = 3,
        WindowsPhone = 15,
        WebGames = 16,
    }

    public abstract class XblSamlSecurityToken : SamlSecurityToken
    {
        protected const string XblAttributeNamespace = "http://xboxlive.com/claims";
        protected const string UserTokenSubject = "XboxLive User security ticket";

        internal const string PlatformTypeAttribute = "PlatformType";
        internal const string MachineIdAttribute = "MachineID";
        internal const string DeviceIdAttribute = "DeviceID";
        internal const string ClientVersionAttribute = "ClientVersion";
        internal const string TitleIdAttribute = "TitleID";
        internal const string TitleVersionAttribute = "TitleVersion";

        // future place holder
        public static XblSamlSecurityToken Create(String samlToken)
        {
            throw new NotImplementedException();
        }

        public static XblSamlSecurityToken CreateFromSamlToken(SamlSecurityToken samlToken)
        {
            XblSamlSecurityToken returnXblToken = null;
            // ensure assertions and statements w/ at least one element do exist in the token.
            if (samlToken == null ||
                samlToken.Assertion == null ||
                samlToken.Assertion.Statements == null  || 
                samlToken.Assertion.Statements.Count == 0)
            {
                throw new FaultException<SecurityAccessDeniedException>(new SecurityAccessDeniedException("Invalid token."));
            }

            //grabs the first <saml:AttributeStatement> in the token; our (if not all) tokens should only have one
            SamlAttributeStatement statement = samlToken.Assertion.Statements[0] as SamlAttributeStatement;

            if (string.Compare(statement.SamlSubject.Name, XblSamlSecurityToken.UserTokenSubject, true) == 0)
            {
                returnXblToken = new PhoneXmlSamlSecurityToken(samlToken);

                // ensure phone tokens have platform type as windows phone.
                if (returnXblToken.PlatformType != (ushort)Platform.WindowsPhone)
                {
                    throw new FaultException<SecurityAccessDeniedException>(new SecurityAccessDeniedException("Invalid platform type."));
                }

                if(String.IsNullOrEmpty(returnXblToken.DeviceId))
                {
                    throw new FaultException<SecurityAccessDeniedException>(new SecurityAccessDeniedException("Empty or null device id."));
                }
            }
            else
            {
                returnXblToken = new ConsoleXmlSamlSecurityToken(samlToken);

                // ensure phone tokens have platform type as Console.
                if (returnXblToken.PlatformType != (ushort)Platform.Xbox360)
                {
                    throw new FaultException<SecurityAccessDeniedException>(new SecurityAccessDeniedException("Invalid platform type."));
                }
            }

            return returnXblToken;
        }

        public static XblSamlSecurityToken CreateFromSoapRequest()
        {
            // If there is no token, simply return null
            if (OperationContext.Current.IncomingMessageProperties.Security.IncomingSupportingTokens.Count != 1)
            {
                return null;
            }

            // from this point on, any security token validation failure, now that we know it exists, is lethal.
            SamlSecurityToken token = null;

            try
            {
                token = OperationContext.Current.IncomingMessageProperties.Security.IncomingSupportingTokens[0].SecurityToken as SamlSecurityToken;
                
            }
            catch (Exception ex)
            {
                //at this point, if we can't get or parse the token, it's most likely an attack
                throw new FaultException<SecurityAccessDeniedException>(new SecurityAccessDeniedException("No SamlSecurityToken found, despite supporting Tokens being valid", ex));
            }

            if(token != null)
                return CreateFromSamlToken(token);
            return null;
        }

        public virtual XblSamlTokenType TokenType { get; protected set; }

        public virtual ulong Xuid { get; protected set; }

        public virtual string GamerTag { get; protected set; }

        public virtual ushort Tier { get; protected set; }

        public virtual ushort Country { get; protected set; }

        public virtual uint TitleId { get; set; }

        public virtual uint TitleVersion { get; protected set; }

        public virtual ushort ClientVersion { get; protected set; }

        public virtual string MachineId { get; protected set; }

        public virtual ushort PlatformType { get; protected set; }

        public virtual string DeviceId { get; protected set; }

        public virtual ulong Puid { get; protected set; }

        public virtual ulong Cid { get; protected set; }

        public virtual string Privileges { get; protected set; }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="attributes"></param>
        /// <param name="claimName"></param>
        /// <param name="isHex"></param>
        /// <returns></returns>
        protected static ulong ParseUInt64Attribute(IList<SamlAttribute> attributes, string claimName, bool isHex)
        {
            string value = attributes.First(attr => attr.Name.Equals(claimName) && attr.Namespace.Equals(XblAttributeNamespace)).AttributeValues[0];
            return Convert.ToUInt64(value, isHex ? 16 : 10);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="attributes"></param>
        /// <param name="claimName"></param>
        /// <param name="isHex"></param>
        /// <returns></returns>
        protected static uint ParseUInt32Attribute(IList<SamlAttribute> attributes, string claimName, bool isHex)
        {
            string value = attributes.First(attr => attr.Name.Equals(claimName) && attr.Namespace.Equals(XblAttributeNamespace)).AttributeValues[0];
            return Convert.ToUInt32(value, isHex ? 16 : 10);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="attributes"></param>
        /// <param name="claimName"></param>
        /// <param name="isHex"></param>
        /// <returns></returns>
        protected static ushort ParseUInt16Attribute(IList<SamlAttribute> attributes, string claimName, bool isHex)
        {
            string value = attributes.First(attr => attr.Name.Equals(claimName) && attr.Namespace.Equals(XblAttributeNamespace)).AttributeValues[0];
            return Convert.ToUInt16(value, isHex ? 16 : 10);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="attributes"></param>
        /// <param name="claimName"></param>
        /// <returns></returns>
        protected static string ParseStringAttribute(IList<SamlAttribute> attributes, string claimName)
        {
            return attributes.First(attr => attr.Name.Equals(claimName) && attr.Namespace.Equals(XblAttributeNamespace)).AttributeValues[0];
        }

        /// <summary>
        /// 
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="attributes"></param>
        /// <param name="claimName"></param>
        /// <returns></returns>
        protected static T ParseAttributeValue<T>(IList<SamlAttribute> attributes, string claimName)
        {
            string value = attributes.First(attr => attr.Name.Equals(claimName) && attr.Namespace.Equals(XblAttributeNamespace)).AttributeValues[0];
            return (T)Convert.ChangeType(value, typeof(T));
        }
    }

    public class PhoneXmlSamlSecurityToken : XblSamlSecurityToken
    {
        internal const string PuidPhoneAttribute = "Puid0";
        internal const string CidPhoneAttribute = "CID0";
        internal const string XuidPhoneAttribute = "Xuid0";
        internal const string GamertagPhoneAttribute = "Gamertag0";
        internal const string TierPhoneAttribute = "Tier0";
        internal const string CountryPhoneAttribute = "Country0";
        internal const string PrivilegesPhoneAttribute = "Privileges0";
        internal const string PartneridPhoneAttribute = "PartnerID0";

        public PhoneXmlSamlSecurityToken(SamlSecurityToken samlToken)
        {
            this.TokenType = XblSamlTokenType.User;

            IList<SamlAttribute> samlAttributes = (samlToken.Assertion.Statements[0] as SamlAttributeStatement).Attributes;
            try
            {
                // bug: 11643 and 11687
                // the linq queryes (specifically .First call) may result in InvalidOperationException if the item does NOT exist.
                // or the subsequent string to whatever-type does fail w/ a similar exception.
                this.Xuid = ParseUInt64Attribute(samlAttributes, PhoneXmlSamlSecurityToken.XuidPhoneAttribute, false);
                this.GamerTag = ParseStringAttribute(samlAttributes, PhoneXmlSamlSecurityToken.GamertagPhoneAttribute);
                this.PlatformType = ParseUInt16Attribute(samlAttributes, PhoneXmlSamlSecurityToken.PlatformTypeAttribute, false);
                this.MachineId = ParseUInt64Attribute(samlAttributes, PhoneXmlSamlSecurityToken.MachineIdAttribute, false).ToString();
                this.TitleId = ParseUInt32Attribute(samlAttributes, PhoneXmlSamlSecurityToken.TitleIdAttribute, true);
                this.TitleVersion = ParseUInt32Attribute(samlAttributes, PhoneXmlSamlSecurityToken.TitleVersionAttribute, false);
                this.DeviceId = ParseStringAttribute(samlAttributes, PhoneXmlSamlSecurityToken.DeviceIdAttribute);
            }
            catch (InvalidOperationException)
            {
                throw new FaultException<SecurityAccessDeniedException>(new SecurityAccessDeniedException("Missing or Invalid Field."));
            }
        }

        public override ushort Tier { get { throw new NotSupportedException(); } }
        public override ushort Country { get { throw new NotSupportedException(); } }
        public override ushort ClientVersion { get { throw new NotSupportedException(); } }
        public override ulong Puid { get { throw new NotSupportedException(); } }
        public override ulong Cid { get { throw new NotSupportedException(); } }
        public override string Privileges { get { throw new NotSupportedException(); } }
    }

    public class ConsoleXmlSamlSecurityToken : XblSamlSecurityToken
    {
        internal const string PuidConsoleAttribute = "Puid1";
        internal const string CidConsoleAttribute = "CID1";
        internal const string XuidConsoleAttribute = "Xuid1";
        internal const string GamertagConsoleAttribute = "Gamertag1";
        internal const string TierConsoleAttribute = "Tier1";
        internal const string CountryConsoleAttribute = "Country1";
        internal const string PrivilegesConsoleAttribute = "Privileges1";
        internal const string PartneridConsoleAttribute = "PartnerID1";

        public ConsoleXmlSamlSecurityToken(SamlSecurityToken samlToken)
        {
            this.TokenType = XblSamlTokenType.Console;

            IList<SamlAttribute> samlAttributes = (samlToken.Assertion.Statements[0] as SamlAttributeStatement).Attributes;

            try
            {
                // bug: 11643 and 11687
                // the linq queryes (specifically .First call) may result in InvalidOperationException if the item does NOT exist.
                // or the subsequent string to whatever-type does fail w/ a similar exception.
                this.Xuid = ParseUInt64Attribute(samlAttributes, ConsoleXmlSamlSecurityToken.XuidConsoleAttribute, true);
                this.PlatformType = ParseUInt16Attribute(samlAttributes, ConsoleXmlSamlSecurityToken.PlatformTypeAttribute, true);
                this.MachineId = ParseUInt64Attribute(samlAttributes, ConsoleXmlSamlSecurityToken.MachineIdAttribute, true).ToString();
                this.TitleId = ParseUInt32Attribute(samlAttributes, ConsoleXmlSamlSecurityToken.TitleIdAttribute, true);
                this.TitleVersion = ParseUInt32Attribute(samlAttributes, ConsoleXmlSamlSecurityToken.TitleVersionAttribute, true);
            }
            catch (InvalidOperationException)
            {
                throw new FaultException<SecurityAccessDeniedException>(new SecurityAccessDeniedException("Missing or Invalid Field."));
            }
        }

        public override string GamerTag { get { throw new NotSupportedException(); } }
        public override ushort Tier { get { throw new NotSupportedException(); } }
        public override ushort Country { get { throw new NotSupportedException(); } }
        public override ushort ClientVersion { get { throw new NotSupportedException(); } }
        public override ulong Puid { get { throw new NotSupportedException(); } }
        public override ulong Cid { get { throw new NotSupportedException(); } }
        public override string Privileges { get { throw new NotSupportedException(); } }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup\LCWebService\test\Player.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace LiveConnectWeb.Test
{
    public class Player
    {
        public ulong Xuid
        {
            get;
            set;
        }

        public byte Tier
        {
            get;
            set;
        }

        public byte Country
        {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup\LCWebService\test\ILiveConnectTest.cs ===
using System;
using System.ServiceModel;

namespace LiveConnectWeb.Test
{
    /// <summary>
    /// 
    /// </summary>
    [ServiceContract]
    [XmlSerializerFormat]
    public interface ILiveConnectTest
    {
        [OperationContract]
        void AddDirectoryInfo(ushort socialNetworkID, ulong xuid, string snUserID, string gamerTag, Visibility visibility);

        [OperationContract]
        void AddAuthInfo(ushort socialNetworkID, ulong xuid, string snUserID, string authToken, string deviceID);

        [OperationContract]
        int ExecuteSql(string sql);

        [OperationContract]
        string ExecuteSqlDataSet(string sql);

        //Methods to generate STS tokens
        [OperationContract]
        string GetStsToken(Player[] players, string audience, ulong machinePuid, uint clientVersion, uint title, uint titleVersion, int minutesToExpire);

        [OperationContract]
        string GetSimpleStsToken(ulong xuid, uint titleId, ulong machinePuid, int minutesToExpire);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup\Monitoring\LiveConnectPing\Authentication.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace LiveConnectPing
{
    /// <summary>
    /// 
    /// </summary>
    public enum Authentication
    {
        None,
        ClientCertificate,
        ConsoleStsToken,
        UserStsToken,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup\LCWebService\XBoxClientInfo.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.ServiceModel;
using System.IdentityModel.Tokens;
using System.Globalization;

namespace LiveConnectWeb
{
    public class XBoxClientInfo
    {
        internal ushort Platform {get; private set;}
        internal string MachineId { get; private set; }
        internal uint ClientVersion { get; private set; }
        internal string TitleId { get; private set; }
        internal uint TitleVersion { get; private set; }
        internal ulong Xuid { get; private set; }
        internal ushort Tier { get; private set; }
        internal ushort Country { get; private set; }

        public static XBoxClientInfo GetFromSamlToken()
        {
            XBoxClientInfo clientInfo = null;

            if (OperationContext.Current.IncomingMessageProperties.Security.IncomingSupportingTokens.Count != 1)
            {
                return null;
            }
            
            SamlSecurityToken token = OperationContext.Current.IncomingMessageProperties.Security.IncomingSupportingTokens[0].SecurityToken as SamlSecurityToken;

            if (token != null)
            {
                SamlAttributeStatement statement = token.Assertion.Statements[0] as SamlAttributeStatement;

                if (statement != null)
                {
                    clientInfo = new XBoxClientInfo();

                    string machineId = statement.Attributes.First(attibute =>
                                attibute.Namespace == "http://xboxlive.com/claims"
                                && attibute.Name == "MachineID").AttributeValues[0].Replace("0x", "");

                    clientInfo.MachineId = ulong.Parse(machineId, NumberStyles.HexNumber).ToString();

                    string clientVersion = statement.Attributes.First(attibute =>
                                attibute.Namespace == "http://xboxlive.com/claims"
                                && attibute.Name == "ClientVersion").AttributeValues[0].Replace("0x", "");

                    clientInfo.ClientVersion = uint.Parse(clientVersion, NumberStyles.HexNumber);

                    clientInfo.TitleId = statement.Attributes.First(attibute =>
                                            attibute.Namespace == "http://xboxlive.com/claims"
                                            && attibute.Name == "TitleID").AttributeValues[0].Replace("0x", "");

                    string titleVersion = statement.Attributes.First(attibute =>
                                attibute.Namespace == "http://xboxlive.com/claims"
                                && attibute.Name == "TitleVersion").AttributeValues[0].Replace("0x", "");

                    clientInfo.TitleVersion = uint.Parse(titleVersion, NumberStyles.HexNumber);

                    string xuid = statement.Attributes.First(attibute =>
                                attibute.Namespace == "http://xboxlive.com/claims"
                                && attibute.Name == "Xuid1").AttributeValues[0].Replace("0x", "");

                    clientInfo.Xuid = ulong.Parse(xuid, NumberStyles.HexNumber);

                    string tier = statement.Attributes.First(attibute =>
                                attibute.Namespace == "http://xboxlive.com/claims"
                                && attibute.Name == "Tier1").AttributeValues[0].Replace("0x", "");

                    clientInfo.Tier = ushort.Parse(tier, NumberStyles.HexNumber);

                    string country = statement.Attributes.First(attibute =>
                                attibute.Namespace == "http://xboxlive.com/claims"
                                && attibute.Name == "Country1").AttributeValues[0].Replace("0x", "");

                    clientInfo.Country = ushort.Parse(country, NumberStyles.HexNumber);
                }
            }

            return clientInfo;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup\Monitoring\LiveConnectPing\ColorConsoleTraceListener.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Diagnostics;
using System.Globalization;

namespace LiveConnectPing
{
    /// <summary>
    /// 
    /// </summary>
    public class ColorConsoleTraceListener : TextWriterTraceListener
    {
        private bool showSource;

        /// <summary>
        /// 
        /// </summary>
        public ColorConsoleTraceListener()
            : this(true)
        {

        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="showSource"></param>
        public ColorConsoleTraceListener(bool showSource)
            : base(Console.Out)
        {
            this.showSource = showSource;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="eventCache"></param>
        /// <param name="source"></param>
        /// <param name="eventType"></param>
        /// <param name="id"></param>
        /// <param name="message"></param>
        public override void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string message)
        {
            if ((this.Filter != null) && !this.Filter.ShouldTrace(eventCache, source, eventType, id, message, null, null, null))
                return;

            try
            {
                Console.ForegroundColor = ConsoleColor.White;
                this.WriteHeader(source, eventType, id);

                switch (eventType)
                {
                    case TraceEventType.Start:
                    case TraceEventType.Stop:
                        {
                            Console.ForegroundColor = ConsoleColor.Green;
                            break;
                        }
                    case TraceEventType.Verbose:
                        {
                            Console.ForegroundColor = ConsoleColor.Gray;
                            break;
                        }
                    case TraceEventType.Information:
                        {
                            Console.ForegroundColor = ConsoleColor.Blue;
                            break;
                        }
                    case TraceEventType.Warning:
                        {
                            Console.ForegroundColor = ConsoleColor.Yellow;
                            break;
                        }
                    case TraceEventType.Error:
                    case TraceEventType.Critical:
                        {
                            Console.ForegroundColor = ConsoleColor.Red;
                            break;
                        }
                }

                base.WriteLine(message);

                Console.ForegroundColor = ConsoleColor.White;
                this.WriteFooter(eventCache);
            }
            finally
            {
                Console.ResetColor();
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="eventCache"></param>
        /// <param name="source"></param>
        /// <param name="eventType"></param>
        /// <param name="id"></param>
        /// <param name="format"></param>
        /// <param name="args"></param>
        public override void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string format, params object[] args)
        {
            TraceEvent(eventCache, source, eventType, id, String.Format(format, args));
        }

        /// <summary>
        /// 
        /// </summary>
        protected override void WriteIndent()
        {
            this.NeedIndent = false;
            for (int i = 0; i < this.IndentLevel; i++)
            {
                for (int j = 0; j < this.IndentSize; j++)
                    this.Write("\t");
            }
            //base.WriteIndent();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="source"></param>
        /// <param name="type"></param>
        /// <param name="id"></param>
        protected virtual void WriteHeader(string source, TraceEventType type, int id)
        {
            StringBuilder header = new StringBuilder();
            if (this.showSource)
                header.AppendFormat("{0} ", source);
            header.AppendFormat("{0}: ", type);
            if (id != 0)
                header.AppendFormat("{0}: ", id);
            this.Write(header.ToString());
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="cache"></param>
        protected virtual void WriteFooter(TraceEventCache eventCache)
        {
            if (eventCache != null)
            {
                base.IndentLevel++;
                if (this.IsEnabled(TraceOptions.ProcessId))
                {
                    this.WriteLine("ProcessId=" + eventCache.ProcessId);
                }
                if (this.IsEnabled(TraceOptions.LogicalOperationStack))
                {
                    this.Write("LogicalOperationStack=");
                    Stack logicalOperationStack = eventCache.LogicalOperationStack;
                    bool flag = true;
                    foreach (object obj2 in logicalOperationStack)
                    {
                        if (!flag)
                        {
                            this.Write(", ");
                        }
                        else
                        {
                            flag = false;
                        }
                        this.Write(obj2.ToString());
                    }
                    this.WriteLine(string.Empty);
                }
                if (this.IsEnabled(TraceOptions.ThreadId))
                {
                    this.WriteLine("ThreadId=" + eventCache.ThreadId);
                }
                if (this.IsEnabled(TraceOptions.DateTime))
                {
                    //this POS is in UTC; convert to local
                    DateTime local = TimeZoneInfo.ConvertTimeFromUtc(eventCache.DateTime, TimeZoneInfo.Local);
                    this.WriteLine("DateTime=" + local.ToString("MM/dd/yyyy hh:mm:ss.ffff tt"));
                }
                if (this.IsEnabled(TraceOptions.Timestamp))
                {
                    this.WriteLine("Timestamp=" + eventCache.Timestamp);
                }
                if (this.IsEnabled(TraceOptions.Callstack))
                {
                    this.WriteLine("Callstack=" + eventCache.Callstack);
                }
                base.IndentLevel--;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="opts"></param>
        /// <returns></returns>
        protected bool IsEnabled(TraceOptions opts)
        {
            return ((opts & this.TraceOutputOptions) != TraceOptions.None);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup\Monitoring\LiveConnectPing\LiveConnectPingArguments.cs ===
using System;
using CommandLine;

namespace LiveConnectPing
{
    /// <summary>
    /// 
    /// </summary>
    internal class LiveConnectPingArguments
    {
        /// <summary>
        /// 
        /// </summary>
        [Argument(ArgumentType.Required, LongName="hostname", ShortName="h", HelpText="Specifies the DNS hostname used in the WCF endpoint, to call Live Connect.")]
        public string Hostname = String.Empty;

        /// <summary>
        /// 
        /// </summary>
        [Argument(ArgumentType.AtMostOnce, DefaultValue=false, LongName="ignoresslerrrors", ShortName="ssl", HelpText="Specifies whether or not server-side SSL errors should be ignored, or result in errors.")]
        public bool IgnoreServerSslErrors = false;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup\LCWebService\test\LiveConnectTest.cs ===
using System;
using System.Xml;
using System.IO;
using System.Data;
using System.Data.SqlClient;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using System.Security.Cryptography.Xml;

namespace LiveConnectWeb.Test
{
    /// <summary>
    /// 
    /// </summary>
    public class LiveConnectTest : ILiveConnectTest
    {
        // Token Signing Certificate
        //  this is the cert and associated private key that signs the SAML token
        static private X509Certificate2 _certificate = null;

        private const string samlNamespace = "urn:oasis:names:tc:SAML:1.0:assertion";
        private const string stsIssuer = "http://sts.xboxlive.com";
        private const string signingCertSubject = "lnconnect.redmond.corp.microsoft.com";

        /// <summary>
        /// 
        /// </summary>
        /// <param name="socialNetworkID"></param>
        /// <param name="xuid"></param>
        /// <param name="snUserID"></param>
        /// <param name="gamerTag"></param>
        /// <param name="visibility"></param>
        public void AddDirectoryInfo(ushort socialNetworkID, ulong xuid, string snUserID, string gamerTag, Visibility visibility)
        {
            LiveConnectDataContext db = new LiveConnectDataContext();

            //for now, ignore any issues related to primary key violations
            //an exception will be thrown back to the client
            Directory directoryEntry = new Directory();
            db.Directories.InsertOnSubmit(directoryEntry);

            directoryEntry.SNetworkId = (short)socialNetworkID;
            directoryEntry.XUID = (long)xuid;
            directoryEntry.GamerTag = gamerTag;
            directoryEntry.SNUserId = snUserID;
            directoryEntry.Flags = (int)visibility;
            directoryEntry.LastAccessedTime = DateTime.Now;

            db.SubmitChanges();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="socialNetworkID"></param>
        /// <param name="xuid"></param>
        /// <param name="snUserID"></param>
        /// <param name="authToken"></param>
        /// <param name="deviceID"></param>
        public void AddAuthInfo(ushort socialNetworkID, ulong xuid, string snUserID, string authToken, string deviceID)
        {
            LiveConnectDataContext db = new LiveConnectDataContext();

            //for now, ignore any issues related to primary key violations
            //an exception will be thrown back to the client
            Authentication authEntry = new Authentication();

            db.Authentications.InsertOnSubmit(authEntry);

            authEntry.SNetworkId = (short)socialNetworkID;
            authEntry.XUID = (long)xuid;
            authEntry.SNUserId = snUserID;
            authEntry.Token = authToken;
            authEntry.DeviceId = deviceID;
            authEntry.LastAccessedTime = DateTime.Now;

            db.SubmitChanges();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="sql"></param>
        public int ExecuteSql(string sql)
        {
            using (SqlConnection connection = new SqlConnection(System.Configuration.ConfigurationManager.ConnectionStrings["LiveConnect"].ConnectionString))
            using (SqlCommand command = new SqlCommand(sql, connection))
            {                               
                command.CommandType = CommandType.Text;
                connection.Open();
                return command.ExecuteNonQuery();
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="sql"></param>
        /// <returns></returns>
        public string ExecuteSqlDataSet(string sql)
        {
            using (SqlConnection connection = new SqlConnection(System.Configuration.ConfigurationManager.ConnectionStrings["LiveConnect"].ConnectionString))
            using (SqlDataAdapter dataAdapter = new SqlDataAdapter(sql, connection))
            {
                DataSet set = new DataSet();
                dataAdapter.Fill(set);
                return set.GetXml();                
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="players"></param>
        /// <param name="machinePuid"></param>
        /// <param name="clientVersion"></param>
        /// <param name="title"></param>
        /// <param name="titleVersion"></param>
        /// <returns></returns>
        public string GetStsToken(Player[] players, string audience, ulong machinePuid, uint clientVersion, uint title, uint titleVersion, int minutesToExpire)
        {
            string assertionID = string.Format("SamlSecurityToken-{0}", Guid.NewGuid().ToString());
            
            DateTime now = DateTime.UtcNow;
            DateTime expires = now.Add(TimeSpan.FromMinutes(minutesToExpire));

            TextWriter textWriter = new StringWriter();
            XmlTextWriter writer = new XmlTextWriter(textWriter);
            
            writer.WriteStartElement("saml", "Assertion", samlNamespace);
            writer.WriteAttributeString("MajorVersion", "1");
            writer.WriteAttributeString("MinorVersion", "1");
            writer.WriteAttributeString("AssertionID", assertionID);
            writer.WriteAttributeString("Issuer", stsIssuer);
            writer.WriteAttributeString("IssueInstant", now.ToString("o"));
            
            writer.WriteStartElement("Conditions", samlNamespace);
            writer.WriteAttributeString("NotBefore", now.ToString("o")); 
            writer.WriteAttributeString("NotOnOrAfter", expires.ToString("o"));
            writer.WriteStartElement("AudienceRestrictionCondition", samlNamespace);
            writer.WriteElementString("Audience", samlNamespace, audience);
            writer.WriteEndElement(); //AudienceRestrictionCondition
            writer.WriteEndElement(); // Conditions

            writer.WriteStartElement("AttributeStatement", samlNamespace);
            
            writer.WriteStartElement("Subject", samlNamespace);
            writer.WriteElementString("NameIdentifier", samlNamespace, string.Format("0x{0:X16}", players[0].Xuid)); // primary Subject is player1, in uppercase hex
            writer.WriteEndElement();

            // Write out machineID claim
            WriteClaim(writer, "PlatformType", string.Format("0x{0:X2}", 0x2));
            WriteClaim(writer, "MachineID", string.Format("0x{0:X16}", machinePuid));
            WriteClaim(writer, "ClientVersion", string.Format("0x{0:X8}", clientVersion));
            WriteClaim(writer, "TitleID", string.Format("0x{0:X8}", title));
            WriteClaim(writer, "TitleVersion", string.Format("0x{0:X8}", titleVersion));
                        
            // Write out player claims
            for (int i = 0; i < players.Length; i++)
            {
                if (players[i] != null)
                {
                    WriteClaim(writer, String.Format("Xuid{0}", i + 1), string.Format("0x{0:X16}", players[i].Xuid)); //always return uppercase hex
                    WriteClaim(writer, String.Format("Tier{0}", i + 1), string.Format("0x{0:X2}", players[i].Tier));
                    WriteClaim(writer, String.Format("Country{0}", i + 1), string.Format("0x{0:X2}", players[i].Country));
                }
            }
                        
            writer.WriteEndElement(); // AttributeStatement
            writer.WriteEndElement(); // Assertion
            
            textWriter.Flush();

            XmlDocument document = new XmlDocument();
            document.LoadXml(textWriter.ToString());
            
            SignXmlViaLocalCert(document, assertionID);
            
            return document.OuterXml;
        }

        public string GetSimpleStsToken(ulong xuid, uint titleId, ulong machinePuid, int minutesToExpire)
        {
            //103=US, 6=Gold
            Player player1 = new Player(){ Xuid=xuid, Country=103, Tier=6 };

            //random machine puid, hard-coded client version, random title version
            return GetStsToken(new Player[] { player1 }, "http://xboxlive.com", machinePuid, 0x25223C00, titleId, GenerateRandomUInt32(), minutesToExpire);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="claim"></param>
        /// <param name="value"></param>
        private static void WriteClaim(XmlTextWriter writer, string claim, string value)
        {
            writer.WriteStartElement("Attribute", samlNamespace);
            writer.WriteAttributeString("AttributeName", claim);
            writer.WriteAttributeString("AttributeNamespace", "http://xboxlive.com/claims");
            writer.WriteElementString("AttributeValue", samlNamespace, value);
            writer.WriteEndElement();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="document"></param>
        /// <param name="assertionID"></param>
        private void SignXmlViaLocalCert(XmlDocument document, string assertionID)
        {
            // grab the cert so we don't have a race condition with it changing during a reload
            // we need this because we access the cert twice in this function and don't want to take a lock... but need to stay consistant
            X509Certificate2 signingCertificate = GetCertificate();

            // Create a CustomSignedXml object.  
            // The CustomSigendXml object lets us change what attribute is used to find the node to sign.
            // The standard SignedXml signs the node identified by the attribute named 'id'.
            // We need to sign the node identified by the attribute named 'AssertionID'. 
            CustomSignedXml signedXml = new CustomSignedXml(document);
            signedXml.SignedInfo.CanonicalizationMethod = SignedXml.XmlDsigExcC14NTransformUrl;
            signedXml.SigningKey = (RSACryptoServiceProvider)signingCertificate.PrivateKey;

            // Create a reference which tells SignedXml what node to sign
            Reference reference = new Reference();
            reference.Uri = "#" + assertionID;

            // Add an enveloped transformation to the reference.
            XmlDsigEnvelopedSignatureTransform transform1 = new XmlDsigEnvelopedSignatureTransform();
            reference.AddTransform(transform1);

            XmlDsigExcC14NTransform transform2 = new XmlDsigExcC14NTransform();
            reference.AddTransform(transform2);

            // Add the reference to the SignedXml object.
            signedXml.AddReference(reference);

            // add key info
            KeyInfo keyInfo = new KeyInfo();
            keyInfo.AddClause(new KeyInfoX509Data(signingCertificate));
            signedXml.KeyInfo = keyInfo;

            // Compute the signature.
            signedXml.ComputeSignature();

            // Get the XML representation of the signature and save
            // it to an XmlElement object.
            XmlElement xmlDigitalSignature = signedXml.GetXml();

            // Append the element to the XML document.
            document.DocumentElement.AppendChild(document.ImportNode(xmlDigitalSignature, true));
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        private static X509Certificate2 GetCertificate()
        {
            X509Certificate2 certificate = _certificate;

            // do I have a cert
            if (certificate != null)
                return certificate;

            string certSubject = signingCertSubject;
            X509Store store = new X509Store(StoreName.My, StoreLocation.LocalMachine);
            store.Open(OpenFlags.ReadOnly);
            try
            {
                // Find the certificate that matches the subject
                X509Certificate2Collection matches = store.Certificates.Find(X509FindType.FindBySubjectName, certSubject, false);
                if (matches == null || matches.Count == 0)
                    throw new ApplicationException(String.Format("No certificates with subject {0} were found in the specified store", certSubject));
                if (matches.Count > 1)
                    throw new ApplicationException(String.Format("Multiple certificates with subject {0} were found in the specified store", certSubject));
                if (!matches[0].HasPrivateKey)
                    throw new ApplicationException(String.Format("Certificate with subject {0} doesn't have a private key", certSubject));
                _certificate = certificate = matches[0];
            }
            finally
            {
                store.Close();
            }
            return certificate;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public static ulong GenerateRandomUInt64()
        {
            byte[] buffer = new byte[sizeof(ulong)];
            RNGCryptoServiceProvider rng = new RNGCryptoServiceProvider();
            rng.GetNonZeroBytes(buffer);
            return BitConverter.ToUInt64(buffer, 0);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public static uint GenerateRandomUInt32()
        {
            byte[] buffer = new byte[sizeof(uint)];
            RNGCryptoServiceProvider rng = new RNGCryptoServiceProvider();
            rng.GetNonZeroBytes(buffer);
            return BitConverter.ToUInt32(buffer, 0);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup\Monitoring\LiveConnectPing\LiveConnectService.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4016
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace LiveConnectWeb
{
    using System.Runtime.Serialization;


    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "SNUserInfo", Namespace = "http://schemas.datacontract.org/2004/07/LiveConnectWeb")]
    public partial class SNUserInfo : object, System.Runtime.Serialization.IExtensibleDataObject
    {

        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;

        private string GamerTagField;

        private string SNUserIDField;

        private LiveConnectWeb.Visibility VisibilityField;

        private ulong XUIDField;

        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string GamerTag
        {
            get
            {
                return this.GamerTagField;
            }
            set
            {
                this.GamerTagField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string SNUserID
        {
            get
            {
                return this.SNUserIDField;
            }
            set
            {
                this.SNUserIDField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public LiveConnectWeb.Visibility Visibility
        {
            get
            {
                return this.VisibilityField;
            }
            set
            {
                this.VisibilityField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public ulong XUID
        {
            get
            {
                return this.XUIDField;
            }
            set
            {
                this.XUIDField = value;
            }
        }
    }

    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "Visibility", Namespace = "http://schemas.datacontract.org/2004/07/LiveConnectWeb")]
    public enum Visibility : int
    {

        [System.Runtime.Serialization.EnumMemberAttribute()]
        Me = 0,

        [System.Runtime.Serialization.EnumMemberAttribute()]
        Everyone = 1,
    }

    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "SNetworkInfo", Namespace = "http://schemas.datacontract.org/2004/07/LiveConnectWeb")]
    public partial class SNetworkInfo : object, System.Runtime.Serialization.IExtensibleDataObject
    {

        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;

        private string DescriptionField;

        private uint IdField;

        private string LogoField;

        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Description
        {
            get
            {
                return this.DescriptionField;
            }
            set
            {
                this.DescriptionField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public uint Id
        {
            get
            {
                return this.IdField;
            }
            set
            {
                this.IdField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Logo
        {
            get
            {
                return this.LogoField;
            }
            set
            {
                this.LogoField = value;
            }
        }
    }

    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "SNAuthInfo", Namespace = "http://schemas.datacontract.org/2004/07/LiveConnectWeb")]
    public partial class SNAuthInfo : object, System.Runtime.Serialization.IExtensibleDataObject
    {

        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;

        private string SNUserIDField;

        private string TokenField;

        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string SNUserID
        {
            get
            {
                return this.SNUserIDField;
            }
            set
            {
                this.SNUserIDField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Token
        {
            get
            {
                return this.TokenField;
            }
            set
            {
                this.TokenField = value;
            }
        }
    }
}


[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
[System.ServiceModel.ServiceContractAttribute(Namespace = "http://liveconnect.xboxlive.com", ConfigurationName = "ILiveDirectory")]
public interface ILiveDirectory
{

    [System.ServiceModel.OperationContractAttribute(Action = "http://liveconnect.xboxlive.com/ILiveDirectory/SetSNUserInfo", ReplyAction = "http://liveconnect.xboxlive.com/ILiveDirectory/SetSNUserInfoResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/SetSNUserInfoArgumentExceptionFaul" +
        "t", Name = "ArgumentException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentNullException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/SetSNUserInfoArgumentNullException" +
        "Fault", Name = "ArgumentNullException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ServiceModel.Security.SecurityAccessDeniedException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/SetSNUserInfoSecurityAccessDeniedE" +
        "xceptionFault", Name = "SecurityAccessDeniedException", Namespace = "http://schemas.datacontract.org/2004/07/System.ServiceModel.Security")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentOutOfRangeException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/SetSNUserInfoArgumentOutOfRangeExc" +
        "eptionFault", Name = "ArgumentOutOfRangeException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    void SetSNUserInfo(ushort sNetworkId, LiveConnectWeb.SNUserInfo userInfo);

    [System.ServiceModel.OperationContractAttribute(Action = "http://liveconnect.xboxlive.com/ILiveDirectory/RemoveSNUserInfo", ReplyAction = "http://liveconnect.xboxlive.com/ILiveDirectory/RemoveSNUserInfoResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentOutOfRangeException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/RemoveSNUserInfoArgumentOutOfRange" +
        "ExceptionFault", Name = "ArgumentOutOfRangeException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/RemoveSNUserInfoArgumentExceptionF" +
        "ault", Name = "ArgumentException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ServiceModel.Security.SecurityAccessDeniedException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/RemoveSNUserInfoSecurityAccessDeni" +
        "edExceptionFault", Name = "SecurityAccessDeniedException", Namespace = "http://schemas.datacontract.org/2004/07/System.ServiceModel.Security")]
    void RemoveSNUserInfo(ushort sNetworkId, ulong XUID);

    [System.ServiceModel.OperationContractAttribute(Action = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNUserInfoByXUID", ReplyAction = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNUserInfoByXUIDResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNUserInfoByXUIDArgumentExcepti" +
        "onFault", Name = "ArgumentException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentOutOfRangeException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNUserInfoByXUIDArgumentOutOfRa" +
        "ngeExceptionFault", Name = "ArgumentOutOfRangeException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ServiceModel.Security.SecurityAccessDeniedException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNUserInfoByXUIDSecurityAccessD" +
        "eniedExceptionFault", Name = "SecurityAccessDeniedException", Namespace = "http://schemas.datacontract.org/2004/07/System.ServiceModel.Security")]
    LiveConnectWeb.SNUserInfo GetSNUserInfoByXUID(ushort sNetworkId, ulong XUID);

    [System.ServiceModel.OperationContractAttribute(Action = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNUserInfoBySNUId", ReplyAction = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNUserInfoBySNUIdResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNUserInfoBySNUIdArgumentExcept" +
        "ionFault", Name = "ArgumentException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentNullException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNUserInfoBySNUIdArgumentNullEx" +
        "ceptionFault", Name = "ArgumentNullException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ServiceModel.Security.SecurityAccessDeniedException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNUserInfoBySNUIdSecurityAccess" +
        "DeniedExceptionFault", Name = "SecurityAccessDeniedException", Namespace = "http://schemas.datacontract.org/2004/07/System.ServiceModel.Security")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentOutOfRangeException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNUserInfoBySNUIdArgumentOutOfR" +
        "angeExceptionFault", Name = "ArgumentOutOfRangeException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    LiveConnectWeb.SNUserInfo GetSNUserInfoBySNUId(ushort sNetworkId, string snUserId);

    [System.ServiceModel.OperationContractAttribute(Action = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNUserInfos", ReplyAction = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNUserInfosResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNUserInfosArgumentExceptionFau" +
        "lt", Name = "ArgumentException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentNullException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNUserInfosArgumentNullExceptio" +
        "nFault", Name = "ArgumentNullException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentOutOfRangeException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNUserInfosArgumentOutOfRangeEx" +
        "ceptionFault", Name = "ArgumentOutOfRangeException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ServiceModel.Security.SecurityAccessDeniedException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNUserInfosSecurityAccessDenied" +
        "ExceptionFault", Name = "SecurityAccessDeniedException", Namespace = "http://schemas.datacontract.org/2004/07/System.ServiceModel.Security")]
    LiveConnectWeb.SNUserInfo[] GetSNUserInfos(ushort sNetworkId, string[] sNUserIDs);

    [System.ServiceModel.OperationContractAttribute(Action = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNetworkInfo", ReplyAction = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNetworkInfoResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentOutOfRangeException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNetworkInfoArgumentOutOfRangeE" +
        "xceptionFault", Name = "ArgumentOutOfRangeException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    LiveConnectWeb.SNetworkInfo GetSNetworkInfo(ushort sNetworkId);

    [System.ServiceModel.OperationContractAttribute(Action = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNetworkInfos", ReplyAction = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNetworkInfosResponse")]
    LiveConnectWeb.SNetworkInfo[] GetSNetworkInfos();
}

[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
public interface ILiveDirectoryChannel : ILiveDirectory, System.ServiceModel.IClientChannel
{
}

[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
public partial class LiveDirectoryClient : System.ServiceModel.ClientBase<ILiveDirectory>, ILiveDirectory
{

    public LiveDirectoryClient()
    {
    }

    public LiveDirectoryClient(string endpointConfigurationName) :
        base(endpointConfigurationName)
    {
    }

    public LiveDirectoryClient(string endpointConfigurationName, string remoteAddress) :
        base(endpointConfigurationName, remoteAddress)
    {
    }

    public LiveDirectoryClient(string endpointConfigurationName, System.ServiceModel.EndpointAddress remoteAddress) :
        base(endpointConfigurationName, remoteAddress)
    {
    }

    public LiveDirectoryClient(System.ServiceModel.Channels.Binding binding, System.ServiceModel.EndpointAddress remoteAddress) :
        base(binding, remoteAddress)
    {
    }

    public void SetSNUserInfo(ushort sNetworkId, LiveConnectWeb.SNUserInfo userInfo)
    {
        base.Channel.SetSNUserInfo(sNetworkId, userInfo);
    }

    public void RemoveSNUserInfo(ushort sNetworkId, ulong XUID)
    {
        base.Channel.RemoveSNUserInfo(sNetworkId, XUID);
    }

    public LiveConnectWeb.SNUserInfo GetSNUserInfoByXUID(ushort sNetworkId, ulong XUID)
    {
        return base.Channel.GetSNUserInfoByXUID(sNetworkId, XUID);
    }

    public LiveConnectWeb.SNUserInfo GetSNUserInfoBySNUId(ushort sNetworkId, string snUserId)
    {
        return base.Channel.GetSNUserInfoBySNUId(sNetworkId, snUserId);
    }

    public LiveConnectWeb.SNUserInfo[] GetSNUserInfos(ushort sNetworkId, string[] sNUserIDs)
    {
        return base.Channel.GetSNUserInfos(sNetworkId, sNUserIDs);
    }

    public LiveConnectWeb.SNetworkInfo GetSNetworkInfo(ushort sNetworkId)
    {
        return base.Channel.GetSNetworkInfo(sNetworkId);
    }

    public LiveConnectWeb.SNetworkInfo[] GetSNetworkInfos()
    {
        return base.Channel.GetSNetworkInfos();
    }
}

[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
[System.ServiceModel.ServiceContractAttribute(Namespace = "http://liveconnect.xboxlive.com", ConfigurationName = "ILiveAuthentication")]
public interface ILiveAuthentication
{

    [System.ServiceModel.OperationContractAttribute(Action = "http://liveconnect.xboxlive.com/ILiveAuthentication/SetAuthInfo", ReplyAction = "http://liveconnect.xboxlive.com/ILiveAuthentication/SetAuthInfoResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ServiceModel.Security.SecurityAccessDeniedException), Action = "http://liveconnect.xboxlive.com/ILiveAuthentication/SetAuthInfoSecurityAccessDeni" +
        "edExceptionFault", Name = "SecurityAccessDeniedException", Namespace = "http://schemas.datacontract.org/2004/07/System.ServiceModel.Security")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentException), Action = "http://liveconnect.xboxlive.com/ILiveAuthentication/SetAuthInfoArgumentExceptionF" +
        "ault", Name = "ArgumentException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentOutOfRangeException), Action = "http://liveconnect.xboxlive.com/ILiveAuthentication/SetAuthInfoArgumentOutOfRange" +
        "ExceptionFault", Name = "ArgumentOutOfRangeException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentNullException), Action = "http://liveconnect.xboxlive.com/ILiveAuthentication/SetAuthInfoArgumentNullExcept" +
        "ionFault", Name = "ArgumentNullException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    void SetAuthInfo(ushort sNetworkId, ulong XUID, string gamerTag, string deviceId, LiveConnectWeb.SNAuthInfo userInfo, bool addToDirectory, LiveConnectWeb.Visibility visibility);

    [System.ServiceModel.OperationContractAttribute(Action = "http://liveconnect.xboxlive.com/ILiveAuthentication/GetAuthInfo", ReplyAction = "http://liveconnect.xboxlive.com/ILiveAuthentication/GetAuthInfoResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ServiceModel.Security.SecurityAccessDeniedException), Action = "http://liveconnect.xboxlive.com/ILiveAuthentication/GetAuthInfoSecurityAccessDeni" +
        "edExceptionFault", Name = "SecurityAccessDeniedException", Namespace = "http://schemas.datacontract.org/2004/07/System.ServiceModel.Security")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentNullException), Action = "http://liveconnect.xboxlive.com/ILiveAuthentication/GetAuthInfoArgumentNullExcept" +
        "ionFault", Name = "ArgumentNullException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentException), Action = "http://liveconnect.xboxlive.com/ILiveAuthentication/GetAuthInfoArgumentExceptionF" +
        "ault", Name = "ArgumentException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentOutOfRangeException), Action = "http://liveconnect.xboxlive.com/ILiveAuthentication/GetAuthInfoArgumentOutOfRange" +
        "ExceptionFault", Name = "ArgumentOutOfRangeException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    LiveConnectWeb.SNAuthInfo GetAuthInfo(ushort sNetworkId, ulong XUID, string deviceId);

    [System.ServiceModel.OperationContractAttribute(Action = "http://liveconnect.xboxlive.com/ILiveAuthentication/RemoveAuthInfo", ReplyAction = "http://liveconnect.xboxlive.com/ILiveAuthentication/RemoveAuthInfoResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentNullException), Action = "http://liveconnect.xboxlive.com/ILiveAuthentication/RemoveAuthInfoArgumentNullExc" +
        "eptionFault", Name = "ArgumentNullException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentException), Action = "http://liveconnect.xboxlive.com/ILiveAuthentication/RemoveAuthInfoArgumentExcepti" +
        "onFault", Name = "ArgumentException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ServiceModel.Security.SecurityAccessDeniedException), Action = "http://liveconnect.xboxlive.com/ILiveAuthentication/RemoveAuthInfoSecurityAccessD" +
        "eniedExceptionFault", Name = "SecurityAccessDeniedException", Namespace = "http://schemas.datacontract.org/2004/07/System.ServiceModel.Security")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentOutOfRangeException), Action = "http://liveconnect.xboxlive.com/ILiveAuthentication/RemoveAuthInfoArgumentOutOfRa" +
        "ngeExceptionFault", Name = "ArgumentOutOfRangeException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    void RemoveAuthInfo(ushort sNetworkId, ulong XUID, string deviceId);
}

[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
public interface ILiveAuthenticationChannel : ILiveAuthentication, System.ServiceModel.IClientChannel
{
}

[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
public partial class LiveAuthenticationClient : System.ServiceModel.ClientBase<ILiveAuthentication>, ILiveAuthentication
{

    public LiveAuthenticationClient()
    {
    }

    public LiveAuthenticationClient(string endpointConfigurationName) :
        base(endpointConfigurationName)
    {
    }

    public LiveAuthenticationClient(string endpointConfigurationName, string remoteAddress) :
        base(endpointConfigurationName, remoteAddress)
    {
    }

    public LiveAuthenticationClient(string endpointConfigurationName, System.ServiceModel.EndpointAddress remoteAddress) :
        base(endpointConfigurationName, remoteAddress)
    {
    }

    public LiveAuthenticationClient(System.ServiceModel.Channels.Binding binding, System.ServiceModel.EndpointAddress remoteAddress) :
        base(binding, remoteAddress)
    {
    }

    public void SetAuthInfo(ushort sNetworkId, ulong XUID, string gamerTag, string deviceId, LiveConnectWeb.SNAuthInfo userInfo, bool addToDirectory, LiveConnectWeb.Visibility visibility)
    {
        base.Channel.SetAuthInfo(sNetworkId, XUID, gamerTag, deviceId, userInfo, addToDirectory, visibility);
    }

    public LiveConnectWeb.SNAuthInfo GetAuthInfo(ushort sNetworkId, ulong XUID, string deviceId)
    {
        return base.Channel.GetAuthInfo(sNetworkId, XUID, deviceId);
    }

    public void RemoveAuthInfo(ushort sNetworkId, ulong XUID, string deviceId)
    {
        base.Channel.RemoveAuthInfo(sNetworkId, XUID, deviceId);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup\Monitoring\LiveConnectPing\CommandLineArguments.cs ===
//////////////////////////////////////////////////////////////////////////////
//    Command Line Argument Parser
//    ----------------------------
//
//    Author: hotweird@hotmail.com
//
//    Microsoft Public License (Ms-PL)
//
//    This license governs use of the accompanying software. If you use the software, you
//    accept this license. If you do not accept the license, do not use the software.
//
//    1. Definitions
//
//    The terms "reproduce," "reproduction," "derivative works," and "distribution" have the
//    same meaning here as under U.S. copyright law.
//
//    A "contribution" is the original software, or any additions or changes to the software.
//
//    A "contributor" is any person that distributes its contribution under this license.
//
//    "Licensed patents" are a contributor's patent claims that read directly on its contribution.
//
//    2. Grant of Rights
//
//    (A) Copyright Grant- Subject to the terms of this license, including the license conditions
//        and limitations in section 3, each contributor grants you a non-exclusive, worldwide,
//        royalty-free copyright license to reproduce its contribution, prepare derivative works
//        of its contribution, and distribute its contribution or any derivative works that you create.
//
//    (B) Patent Grant- Subject to the terms of this license, including the license conditions and
//        limitations in section 3, each contributor grants you a non-exclusive, worldwide,
//        royalty-free license under its licensed patents to make, have made, use, sell, offer for
//        sale, import, and/or otherwise dispose of its contribution in the software or derivative
//        works of the contribution in the software.
//
//    3. Conditions and Limitations
//
//    (A) No Trademark License- This license does not grant you rights to use any contributors'
//        name, logo, or trademarks.
//
//    (B) If you bring a patent claim against any contributor over patents that you claim are
//        infringed by the software, your patent license from such contributor to the software ends
//        automatically.
//
//    (C) If you distribute any portion of the software, you must retain all copyright, patent,
//        trademark, and attribution notices that are present in the software.
//
//    (D) If you distribute any portion of the software in source code form, you may do so only under
//        this license by including a complete copy of this license with your distribution. If you
//        distribute any portion of the software in compiled or object code form, you may only do so
//        under a license that complies with this license.
//
//    (E) The software is licensed "as-is." You bear the risk of using it. The contributors give no
//        express warranties, guarantees or conditions. You may have additional consumer rights under
//        your local laws which this license cannot change. To the extent permitted under your local
//        laws, the contributors exclude the implied warranties of merchantability, fitness for a
//        particular purpose and non-infringement.
//
//    Usage
//    -----
//
//    Parsing command line arguments to a console application is a common problem. 
//    This library handles the common task of reading arguments from a command line 
//    and filling in the values in a type.
//
//    To use this library, define a class whose fields represent the data that your 
//    application wants to receive from arguments on the command line. Then call 
//    CommandLine.ParseArguments() to fill the object with the data 
//    from the command line. Each field in the class defines a command line argument. 
//    The type of the field is used to validate the data read from the command line. 
//    The name of the field defines the name of the command line option.
//
//    The parser can handle fields of the following types:
//
//    - string
//    - int
//    - uint
//    - bool
//    - enum
//    - array of the above type
//
//    For example, suppose you want to read in the argument list for wc (word count). 
//    wc takes three optional boolean arguments: -l, -w, and -c and a list of files.
//
//    You could parse these arguments using the following code:
//
//    class WCArguments
//    {
//        public bool lines;
//        public bool words;
//        public bool chars;
//        public string[] files;
//    }
//
//    class WC
//    {
//        static void Main(string[] args)
//        {
//            if (CommandLine.ParseArgumentsWithUsage(args, parsedArgs))
//            {
//            //     insert application code here
//            }
//        }
//    }
//
//    So you could call this aplication with the following command line to count 
//    lines in the foo and bar files:
//
//        wc.exe /lines /files:foo /files:bar
//
//    The program will display the following usage message when bad command line 
//    arguments are used:
//
//        wc.exe -x
//
//    Unrecognized command line argument '-x'
//        /lines[+|-]                         short form /l
//        /words[+|-]                         short form /w
//        /chars[+|-]                         short form /c
//        /files:<string>                     short form /f
//        @<file>                             Read response file for more options
//
//    That was pretty easy. However, you realy want to omit the "/files:" for the 
//    list of files. The details of field parsing can be controled using custom 
//    attributes. The attributes which control parsing behaviour are:
//
//    ArgumentAttribute 
//        - controls short name, long name, required, allow duplicates, default value
//        and help text
//    DefaultArgumentAttribute 
//        - allows omition of the "/name".
//        - This attribute is allowed on only one field in the argument class.
//
//    So for the wc.exe program we want this:
//
//    using System;
//    using Utilities;
//
//    class WCArguments
//    {
//        [Argument(ArgumentType.AtMostOnce, HelpText="Count number of lines in the input text.")]
//        public bool lines;
//        [Argument(ArgumentType.AtMostOnce, HelpText="Count number of words in the input text.")]
//        public bool words;
//        [Argument(ArgumentType.AtMostOnce, HelpText="Count number of chars in the input text.")]
//        public bool chars;
//        [DefaultArgument(ArgumentType.MultipleUnique, HelpText="Input files to count.")]
//        public string[] files;
//    }
//
//    class WC
//    {
//        static void Main(string[] args)
//        {
//            WCArguments parsedArgs = new WCArguments();
//            if (CommandLine.ParseArgumentsWithUsage(args, parsedArgs))
//            {
//            //     insert application code here
//            }
//        }
//    }
//
//
//
//    So now we have the command line we want:
//
//        wc.exe /lines foo bar
//
//    This will set lines to true and will set files to an array containing the 
//    strings "foo" and "bar".
//
//    The new usage message becomes:
//
//        wc.exe -x
//
//    Unrecognized command line argument '-x'
//    /lines[+|-]  Count number of lines in the input text. (short form /l)
//    /words[+|-]  Count number of words in the input text. (short form /w)
//    /chars[+|-]  Count number of chars in the input text. (short form /c)
//    @<file>      Read response file for more options
//    <files>      Input files to count. (short form /f)
//
//    If you want more control over how error messages are reported, how /help is 
//    dealt with, etc you can instantiate the CommandLine.Parser class.
//
//
//
//    Cheers,
//    Peter Hallam
//    C# Compiler Developer
//    Microsoft Corp.
//
//
//
//
//    Release Notes
//    -------------
//
//    10/02/2002 Initial Release
//    10/14/2002 Bug Fix
//    01/08/2003 Bug Fix in @ include files
//    10/23/2004 Added user specified help text, formatting of help text to 
//            screen width. Added ParseHelp for /?.
//    11/23/2004 Added support for default values.
//    02/23/2005 Fix bug with short name and default arguments.
//////////////////////////////////////////////////////////////////////////////
namespace CommandLine
{
    using System;
    using System.Diagnostics;
    using System.Reflection;
    using System.Collections;
    using System.IO;
    using System.Text;
    using System.Runtime.InteropServices;

    /// <summary>
    /// Used to control parsing of command line arguments.
    /// </summary>
    [Flags]
    public enum ArgumentType
    {
        /// <summary>
        /// Indicates that this field is required. An error will be displayed
        /// if it is not present when parsing arguments.
        /// </summary>
        Required = 0x01,
        /// <summary>
        /// Only valid in conjunction with Multiple.
        /// Duplicate values will result in an error.
        /// </summary>
        Unique = 0x02,
        /// <summary>
        /// Inidicates that the argument may be specified more than once.
        /// Only valid if the argument is a collection
        /// </summary>
        Multiple = 0x04,

        /// <summary>
        /// The default type for non-collection arguments.
        /// The argument is not required, but an error will be reported if it is specified more than once.
        /// </summary>
        AtMostOnce = 0x00,

        /// <summary>
        /// For non-collection arguments, when the argument is specified more than
        /// once no error is reported and the value of the argument is the last
        /// value which occurs in the argument list.
        /// </summary>
        LastOccurenceWins = Multiple,

        /// <summary>
        /// The default type for collection arguments.
        /// The argument is permitted to occur multiple times, but duplicate 
        /// values will cause an error to be reported.
        /// </summary>
        MultipleUnique = Multiple | Unique,
    }

    /// <summary>
    /// Allows control of command line parsing.
    /// Attach this attribute to instance fields of types used
    /// as the destination of command line argument parsing.
    /// </summary>
    [AttributeUsage(AttributeTargets.Field)]
    public class ArgumentAttribute : Attribute
    {
        /// <summary>
        /// Allows control of command line parsing.
        /// </summary>
        /// <param name="type"> Specifies the error checking to be done on the argument. </param>
        public ArgumentAttribute(ArgumentType type)
        {
            this.type = type;
        }

        /// <summary>
        /// The error checking to be done on the argument.
        /// </summary>
        public ArgumentType Type
        {
            get { return this.type; }
        }
        /// <summary>
        /// Returns true if the argument did not have an explicit short name specified.
        /// </summary>
        public bool DefaultShortName { get { return null == this.shortName; } }

        /// <summary>
        /// The short name of the argument.
        /// Set to null means use the default short name if it does not
        /// conflict with any other parameter name.
        /// Set to String.Empty for no short name.
        /// This property should not be set for DefaultArgumentAttributes.
        /// </summary>
        public string ShortName
        {
            get { return this.shortName; }
            set { Debug.Assert(value == null || !(this is DefaultArgumentAttribute)); this.shortName = value; }
        }

        /// <summary>
        /// Returns true if the argument did not have an explicit long name specified.
        /// </summary>
        public bool DefaultLongName { get { return null == this.longName; } }

        /// <summary>
        /// The long name of the argument.
        /// Set to null means use the default long name.
        /// The long name for every argument must be unique.
        /// It is an error to specify a long name of String.Empty.
        /// </summary>
        public string LongName
        {
            get { Debug.Assert(!this.DefaultLongName); return this.longName; }
            set { Debug.Assert(value != ""); this.longName = value; }
        }

        /// <summary>
        /// The default value of the argument.
        /// </summary>
        public object DefaultValue
        {
            get { return this.defaultValue; }
            set { this.defaultValue = value; }
        }

        /// <summary>
        /// Returns true if the argument has a default value.
        /// </summary>
        public bool HasDefaultValue { get { return null != this.defaultValue; } }

        /// <summary>
        /// Returns true if the argument has help text specified.
        /// </summary>
        public bool HasHelpText { get { return null != this.helpText; } }

        /// <summary>
        /// The help text for the argument.
        /// </summary>
        public string HelpText
        {
            get { return this.helpText; }
            set { this.helpText = value; }
        }

        private string shortName;
        private string longName;
        private string helpText;
        private object defaultValue;
        private ArgumentType type;
    }

    /// <summary>
    /// Indicates that this argument is the default argument.
    /// '/' or '-' prefix only the argument value is specified.
    /// The ShortName property should not be set for DefaultArgumentAttribute
    /// instances. The LongName property is used for usage text only and
    /// does not affect the usage of the argument.
    /// </summary>
    [AttributeUsage(AttributeTargets.Field)]
    public class DefaultArgumentAttribute : ArgumentAttribute
    {
        /// <summary>
        /// Indicates that this argument is the default argument.
        /// </summary>
        /// <param name="type"> Specifies the error checking to be done on the argument. </param>
        public DefaultArgumentAttribute(ArgumentType type)
            : base(type)
        {
        }
    }

    /// <summary>
    /// A delegate used in error reporting.
    /// </summary>
    public delegate void ErrorReporter(string message);

    /// <summary>
    /// Parser for command line arguments.
    ///
    /// The parser specification is infered from the instance fields of the object
    /// specified as the destination of the parse.
    /// Valid argument types are: int, uint, string, bool, enums
    /// Also argument types of Array of the above types are also valid.
    /// 
    /// Error checking options can be controlled by adding a ArgumentAttribute
    /// to the instance fields of the destination object.
    ///
    /// At most one field may be marked with the DefaultArgumentAttribute
    /// indicating that arguments without a '-' or '/' prefix will be parsed as that argument.
    ///
    /// If not specified then the parser will infer default options for parsing each
    /// instance field. The default long name of the argument is the field name. The
    /// default short name is the first character of the long name. Long names and explicitly
    /// specified short names must be unique. Default short names will be used provided that
    /// the default short name does not conflict with a long name or an explicitly
    /// specified short name.
    ///
    /// Arguments which are array types are collection arguments. Collection
    /// arguments can be specified multiple times.
    /// </summary>
    public sealed class Parser
    {
        /// <summary>
        /// The System Defined new line string.
        /// </summary>
        public const string NewLine = "\r\n";

        /// <summary>
        /// Don't ever call this.
        /// </summary>
        private Parser() { }

        /// <summary>
        /// Parses Command Line Arguments. Displays usage message to Console.Out
        /// if /?, /help or invalid arguments are encounterd.
        /// Errors are output on Console.Error.
        /// Use ArgumentAttributes to control parsing behaviour.
        /// </summary>
        /// <param name="arguments"> The actual arguments. </param>
        /// <param name="destination"> The resulting parsed arguments. </param>
        /// <returns> true if no errors were detected. </returns>
        public static bool ParseArgumentsWithUsage(string[] arguments, object destination)
        {
            if (Parser.ParseHelp(arguments) || !Parser.ParseArguments(arguments, destination))
            {
                // error encountered in arguments. Display usage message
                System.Console.Write(Parser.ArgumentsUsage(destination.GetType()));
                return false;
            }

            return true;
        }

        /// <summary>
        /// Parses Command Line Arguments. 
        /// Errors are output on Console.Error.
        /// Use ArgumentAttributes to control parsing behaviour.
        /// </summary>
        /// <param name="arguments"> The actual arguments. </param>
        /// <param name="destination"> The resulting parsed arguments. </param>
        /// <returns> true if no errors were detected. </returns>
        public static bool ParseArguments(string[] arguments, object destination)
        {
            return Parser.ParseArguments(arguments, destination, new ErrorReporter(Console.Error.WriteLine));
        }

        /// <summary>
        /// Parses Command Line Arguments. 
        /// Use ArgumentAttributes to control parsing behaviour.
        /// </summary>
        /// <param name="arguments"> The actual arguments. </param>
        /// <param name="destination"> The resulting parsed arguments. </param>
        /// <param name="reporter"> The destination for parse errors. </param>
        /// <returns> true if no errors were detected. </returns>
        public static bool ParseArguments(string[] arguments, object destination, ErrorReporter reporter)
        {
            Parser parser = new Parser(destination.GetType(), reporter);
            return parser.Parse(arguments, destination);
        }

        private static void NullErrorReporter(string message)
        {
        }

        private class HelpArgument
        {
            [ArgumentAttribute(ArgumentType.AtMostOnce, ShortName = "?")]
            public bool help = false;
        }

        /// <summary>
        /// Checks if a set of arguments asks for help.
        /// </summary>
        /// <param name="args"> Args to check for help. </param>
        /// <returns> Returns true if args contains /? or /help. </returns>
        public static bool ParseHelp(string[] args)
        {
            Parser helpParser = new Parser(typeof(HelpArgument), new ErrorReporter(NullErrorReporter));
            HelpArgument helpArgument = new HelpArgument();
            helpParser.Parse(args, helpArgument);
            return helpArgument.help;
        }


        /// <summary>
        /// Returns a Usage string for command line argument parsing.
        /// Use ArgumentAttributes to control parsing behaviour.
        /// Formats the output to the width of the current console window.
        /// </summary>
        /// <param name="argumentType"> The type of the arguments to display usage for. </param>
        /// <returns> Printable string containing a user friendly description of command line arguments. </returns>
        public static string ArgumentsUsage(Type argumentType)
        {
            int screenWidth = Parser.GetConsoleWindowWidth();
            if (screenWidth == 0)
                screenWidth = 80;
            return ArgumentsUsage(argumentType, screenWidth);
        }

        /// <summary>
        /// Returns a Usage string for command line argument parsing.
        /// Use ArgumentAttributes to control parsing behaviour.
        /// </summary>
        /// <param name="argumentType"> The type of the arguments to display usage for. </param>
        /// <param name="columns"> The number of columns to format the output to. </param>
        /// <returns> Printable string containing a user friendly description of command line arguments. </returns>
        public static string ArgumentsUsage(Type argumentType, int columns)
        {
            return (new Parser(argumentType, null)).GetUsageString(columns);
        }

        private const int STD_OUTPUT_HANDLE = -11;

        private struct COORD
        {
            internal Int16 x;
            internal Int16 y;
        }

        private struct SMALL_RECT
        {
            internal Int16 Left;
            internal Int16 Top;
            internal Int16 Right;
            internal Int16 Bottom;
        }

        private struct CONSOLE_SCREEN_BUFFER_INFO
        {
            internal COORD dwSize;
            internal COORD dwCursorPosition;
            internal Int16 wAttributes;
            internal SMALL_RECT srWindow;
            internal COORD dwMaximumWindowSize;
        }

        [DllImport("kernel32.dll", EntryPoint = "GetStdHandle", SetLastError = true, CharSet = CharSet.Auto, CallingConvention = CallingConvention.StdCall)]
        private static extern int GetStdHandle(int nStdHandle);

        [DllImport("kernel32.dll", EntryPoint = "GetConsoleScreenBufferInfo", SetLastError = true, CharSet = CharSet.Auto, CallingConvention = CallingConvention.StdCall)]
        private static extern int GetConsoleScreenBufferInfo(int hConsoleOutput, ref CONSOLE_SCREEN_BUFFER_INFO lpConsoleScreenBufferInfo);

        /// <summary>
        /// Returns the number of columns in the current console window
        /// </summary>
        /// <returns>Returns the number of columns in the current console window</returns>
        public static int GetConsoleWindowWidth()
        {
            int screenWidth;
            CONSOLE_SCREEN_BUFFER_INFO csbi = new CONSOLE_SCREEN_BUFFER_INFO();

            int rc;
            rc = GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), ref csbi);
            screenWidth = csbi.dwSize.x;
            return screenWidth;
        }

        /// <summary>
        /// Searches a StringBuilder for a character
        /// </summary>
        /// <param name="text"> The text to search. </param>
        /// <param name="value"> The character value to search for. </param>
        /// <param name="startIndex"> The index to stat searching at. </param>
        /// <returns> The index of the first occurence of value or -1 if it is not found. </returns>
        public static int IndexOf(StringBuilder text, char value, int startIndex)
        {
            for (int index = startIndex; index < text.Length; index++)
            {
                if (text[index] == value)
                    return index;
            }

            return -1;
        }

        /// <summary>
        /// Searches a StringBuilder for a character in reverse
        /// </summary>
        /// <param name="text"> The text to search. </param>
        /// <param name="value"> The character to search for. </param>
        /// <param name="startIndex"> The index to start the search at. </param>
        /// <returns>The index of the last occurence of value in text or -1 if it is not found. </returns>
        public static int LastIndexOf(StringBuilder text, char value, int startIndex)
        {
            for (int index = Math.Min(startIndex, text.Length - 1); index >= 0; index--)
            {
                if (text[index] == value)
                    return index;
            }

            return -1;
        }

        private const int spaceBeforeParam = 2;

        /// <summary>
        /// Creates a new command line argument parser.
        /// </summary>
        /// <param name="argumentSpecification"> The type of object to  parse. </param>
        /// <param name="reporter"> The destination for parse errors. </param>
        public Parser(Type argumentSpecification, ErrorReporter reporter)
        {
            this.reporter = reporter;
            this.arguments = new ArrayList();
            this.argumentMap = new Hashtable();

            foreach (FieldInfo field in argumentSpecification.GetFields())
            {
                if (!field.IsStatic && !field.IsInitOnly && !field.IsLiteral)
                {
                    ArgumentAttribute attribute = GetAttribute(field);
                    if (attribute is DefaultArgumentAttribute)
                    {
                        Debug.Assert(this.defaultArgument == null);
                        this.defaultArgument = new Argument(attribute, field, reporter);
                    }
                    else
                    {
                        this.arguments.Add(new Argument(attribute, field, reporter));
                    }
                }
            }

            // add explicit names to map
            foreach (Argument argument in this.arguments)
            {
                Debug.Assert(!argumentMap.ContainsKey(argument.LongName));
                this.argumentMap[argument.LongName] = argument;
                if (argument.ExplicitShortName)
                {
                    if (argument.ShortName != null && argument.ShortName.Length > 0)
                    {
                        Debug.Assert(!argumentMap.ContainsKey(argument.ShortName));
                        this.argumentMap[argument.ShortName] = argument;
                    }
                    else
                    {
                        argument.ClearShortName();
                    }
                }
            }

            // add implicit names which don't collide to map
            foreach (Argument argument in this.arguments)
            {
                if (!argument.ExplicitShortName)
                {
                    if (argument.ShortName != null && argument.ShortName.Length > 0 && !argumentMap.ContainsKey(argument.ShortName))
                        this.argumentMap[argument.ShortName] = argument;
                    else
                        argument.ClearShortName();
                }
            }
        }

        private static ArgumentAttribute GetAttribute(FieldInfo field)
        {
            object[] attributes = field.GetCustomAttributes(typeof(ArgumentAttribute), false);
            if (attributes.Length == 1)
                return (ArgumentAttribute)attributes[0];

            Debug.Assert(attributes.Length == 0);
            return null;
        }

        private void ReportUnrecognizedArgument(string argument)
        {
            this.reporter(string.Format("Unrecognized command line argument '{0}'", argument));
        }

        /// <summary>
        /// Parses an argument list into an object
        /// </summary>
        /// <param name="args"></param>
        /// <param name="destination"></param>
        /// <returns> true if an error occurred </returns>
        private bool ParseArgumentList(string[] args, object destination)
        {
            bool hadError = false;
            if (args != null)
            {
                foreach (string argument in args)
                {
                    if (argument.Length > 0)
                    {
                        switch (argument[0])
                        {
                            case '-':
                            case '/':
                                int endIndex = argument.IndexOfAny(new char[] { ':', '+', '-' }, 1);
                                string option = argument.Substring(1, endIndex == -1 ? argument.Length - 1 : endIndex - 1);
                                string optionArgument;
                                if (option.Length + 1 == argument.Length)
                                {
                                    optionArgument = null;
                                }
                                else if (argument.Length > 1 + option.Length && argument[1 + option.Length] == ':')
                                {
                                    optionArgument = argument.Substring(option.Length + 2);
                                }
                                else
                                {
                                    optionArgument = argument.Substring(option.Length + 1);
                                }

                                Argument arg = (Argument)this.argumentMap[option];
                                if (arg == null)
                                {
                                    ReportUnrecognizedArgument(argument);
                                    hadError = true;
                                }
                                else
                                {
                                    hadError |= !arg.SetValue(optionArgument, destination);
                                }
                                break;
                            case '@':
                                string[] nestedArguments;
                                hadError |= LexFileArguments(argument.Substring(1), out nestedArguments);
                                hadError |= ParseArgumentList(nestedArguments, destination);
                                break;
                            default:
                                if (this.defaultArgument != null)
                                {
                                    hadError |= !this.defaultArgument.SetValue(argument, destination);
                                }
                                else
                                {
                                    ReportUnrecognizedArgument(argument);
                                    hadError = true;
                                }
                                break;
                        }
                    }
                }
            }

            return hadError;
        }

        /// <summary>
        /// Parses an argument list.
        /// </summary>
        /// <param name="args"> The arguments to parse. </param>
        /// <param name="destination"> The destination of the parsed arguments. </param>
        /// <returns> true if no parse errors were encountered. </returns>
        public bool Parse(string[] args, object destination)
        {
            bool hadError = ParseArgumentList(args, destination);

            // check for missing required arguments
            foreach (Argument arg in this.arguments)
            {
                hadError |= arg.Finish(destination);
            }
            if (this.defaultArgument != null)
            {
                hadError |= this.defaultArgument.Finish(destination);
            }

            return !hadError;
        }

        private struct ArgumentHelpStrings
        {
            public ArgumentHelpStrings(string syntax, string help)
            {
                this.syntax = syntax;
                this.help = help;
            }

            public string syntax;
            public string help;
        }

        /// <summary>
        /// A user firendly usage string describing the command line argument syntax.
        /// </summary>
        public string GetUsageString(int screenWidth)
        {
            ArgumentHelpStrings[] strings = GetAllHelpStrings();

            int maxParamLen = 0;
            foreach (ArgumentHelpStrings helpString in strings)
            {
                maxParamLen = Math.Max(maxParamLen, helpString.syntax.Length);
            }

            const int minimumNumberOfCharsForHelpText = 10;
            const int minimumHelpTextColumn = 5;
            const int minimumScreenWidth = minimumHelpTextColumn + minimumNumberOfCharsForHelpText;

            int helpTextColumn;
            int idealMinimumHelpTextColumn = maxParamLen + spaceBeforeParam;
            screenWidth = Math.Max(screenWidth, minimumScreenWidth);
            if (screenWidth < (idealMinimumHelpTextColumn + minimumNumberOfCharsForHelpText))
                helpTextColumn = minimumHelpTextColumn;
            else
                helpTextColumn = idealMinimumHelpTextColumn;

            const string newLine = "\n";
            StringBuilder builder = new StringBuilder();
            foreach (ArgumentHelpStrings helpStrings in strings)
            {
                // add syntax string
                int syntaxLength = helpStrings.syntax.Length;
                builder.Append(helpStrings.syntax);

                // start help text on new line if syntax string is too long
                int currentColumn = syntaxLength;
                if (syntaxLength >= helpTextColumn)
                {
                    builder.Append(newLine);
                    currentColumn = 0;
                }

                // add help text broken on spaces
                int charsPerLine = screenWidth - helpTextColumn;
                int index = 0;
                while (index < helpStrings.help.Length)
                {
                    // tab to start column
                    builder.Append(' ', helpTextColumn - currentColumn);
                    currentColumn = helpTextColumn;

                    // find number of chars to display on this line
                    int endIndex = index + charsPerLine;
                    if (endIndex >= helpStrings.help.Length)
                    {
                        // rest of text fits on this line
                        endIndex = helpStrings.help.Length;
                    }
                    else
                    {
                        endIndex = helpStrings.help.LastIndexOf(' ', endIndex - 1, Math.Min(endIndex - index, charsPerLine));
                        if (endIndex <= index)
                        {
                            // no spaces on this line, append full set of chars
                            endIndex = index + charsPerLine;
                        }
                    }

                    // add chars
                    builder.Append(helpStrings.help, index, endIndex - index);
                    index = endIndex;

                    // do new line
                    AddNewLine(newLine, builder, ref currentColumn);

                    // don't start a new line with spaces
                    while (index < helpStrings.help.Length && helpStrings.help[index] == ' ')
                        index++;
                }

                // add newline if there's no help text                
                if (helpStrings.help.Length == 0)
                {
                    builder.Append(newLine);
                }
            }

            return builder.ToString();
        }
        private static void AddNewLine(string newLine, StringBuilder builder, ref int currentColumn)
        {
            builder.Append(newLine);
            currentColumn = 0;
        }
        private ArgumentHelpStrings[] GetAllHelpStrings()
        {
            ArgumentHelpStrings[] strings = new ArgumentHelpStrings[NumberOfParametersToDisplay()];

            int index = 0;
            foreach (Argument arg in this.arguments)
            {
                strings[index] = GetHelpStrings(arg);
                index++;
            }
            strings[index++] = new ArgumentHelpStrings("@<file>", "Read response file for more options");
            if (this.defaultArgument != null)
                strings[index++] = GetHelpStrings(this.defaultArgument);

            return strings;
        }

        private static ArgumentHelpStrings GetHelpStrings(Argument arg)
        {
            return new ArgumentHelpStrings(arg.SyntaxHelp, arg.FullHelpText);
        }

        private int NumberOfParametersToDisplay()
        {
            int numberOfParameters = this.arguments.Count + 1;
            if (HasDefaultArgument)
                numberOfParameters += 1;
            return numberOfParameters;
        }

        /// <summary>
        /// Does this parser have a default argument.
        /// </summary>
        /// <value> Does this parser have a default argument. </value>
        public bool HasDefaultArgument
        {
            get { return this.defaultArgument != null; }
        }

        private bool LexFileArguments(string fileName, out string[] arguments)
        {
            string args = null;

            try
            {
                using (FileStream file = new FileStream(fileName, FileMode.Open, FileAccess.Read))
                {
                    args = (new StreamReader(file)).ReadToEnd();
                }
            }
            catch (Exception e)
            {
                this.reporter(string.Format("Error: Can't open command line argument file '{0}' : '{1}'", fileName, e.Message));
                arguments = null;
                return false;
            }

            bool hadError = false;
            ArrayList argArray = new ArrayList();
            StringBuilder currentArg = new StringBuilder();
            bool inQuotes = false;
            int index = 0;

            // while (index < args.Length)
            try
            {
                while (true)
                {
                    // skip whitespace
                    while (char.IsWhiteSpace(args[index]))
                    {
                        index += 1;
                    }

                    // # - comment to end of line
                    if (args[index] == '#')
                    {
                        index += 1;
                        while (args[index] != '\n')
                        {
                            index += 1;
                        }
                        continue;
                    }

                    // do one argument
                    do
                    {
                        if (args[index] == '\\')
                        {
                            int cSlashes = 1;
                            index += 1;
                            while (index == args.Length && args[index] == '\\')
                            {
                                cSlashes += 1;
                            }

                            if (index == args.Length || args[index] != '"')
                            {
                                currentArg.Append('\\', cSlashes);
                            }
                            else
                            {
                                currentArg.Append('\\', (cSlashes >> 1));
                                if (0 != (cSlashes & 1))
                                {
                                    currentArg.Append('"');
                                }
                                else
                                {
                                    inQuotes = !inQuotes;
                                }
                            }
                        }
                        else if (args[index] == '"')
                        {
                            inQuotes = !inQuotes;
                            index += 1;
                        }
                        else
                        {
                            currentArg.Append(args[index]);
                            index += 1;
                        }
                    } while (!char.IsWhiteSpace(args[index]) || inQuotes);
                    argArray.Add(currentArg.ToString());
                    currentArg.Length = 0;
                }
            }
            catch (System.IndexOutOfRangeException)
            {
                // got EOF 
                if (inQuotes)
                {
                    this.reporter(string.Format("Error: Unbalanced '\"' in command line argument file '{0}'", fileName));
                    hadError = true;
                }
                else if (currentArg.Length > 0)
                {
                    // valid argument can be terminated by EOF
                    argArray.Add(currentArg.ToString());
                }
            }

            arguments = (string[])argArray.ToArray(typeof(string));
            return hadError;
        }

        private static string LongName(ArgumentAttribute attribute, FieldInfo field)
        {
            return (attribute == null || attribute.DefaultLongName) ? field.Name : attribute.LongName;
        }

        private static string ShortName(ArgumentAttribute attribute, FieldInfo field)
        {
            if (attribute is DefaultArgumentAttribute)
                return null;
            if (!ExplicitShortName(attribute))
                return LongName(attribute, field).Substring(0, 1);
            return attribute.ShortName;
        }

        private static string HelpText(ArgumentAttribute attribute, FieldInfo field)
        {
            if (attribute == null)
                return null;
            else
                return attribute.HelpText;
        }

        private static bool HasHelpText(ArgumentAttribute attribute)
        {
            return (attribute != null && attribute.HasHelpText);
        }

        private static bool ExplicitShortName(ArgumentAttribute attribute)
        {
            return (attribute != null && !attribute.DefaultShortName);
        }

        private static object DefaultValue(ArgumentAttribute attribute, FieldInfo field)
        {
            return (attribute == null || !attribute.HasDefaultValue) ? null : attribute.DefaultValue;
        }

        private static Type ElementType(FieldInfo field)
        {
            if (IsCollectionType(field.FieldType))
                return field.FieldType.GetElementType();
            else
                return null;
        }

        private static ArgumentType Flags(ArgumentAttribute attribute, FieldInfo field)
        {
            if (attribute != null)
                return attribute.Type;
            else if (IsCollectionType(field.FieldType))
                return ArgumentType.MultipleUnique;
            else
                return ArgumentType.AtMostOnce;
        }

        private static bool IsCollectionType(Type type)
        {
            return type.IsArray;
        }

        private static bool IsValidElementType(Type type)
        {
            return type != null && (
                type == typeof(int) ||
                type == typeof(uint) ||
                type == typeof(string) ||
                type == typeof(bool) ||
                type.IsEnum);
        }

        [System.Diagnostics.DebuggerDisplay("Name = {LongName}")]
        private class Argument
        {
            public Argument(ArgumentAttribute attribute, FieldInfo field, ErrorReporter reporter)
            {
                this.longName = Parser.LongName(attribute, field);
                this.explicitShortName = Parser.ExplicitShortName(attribute);
                this.shortName = Parser.ShortName(attribute, field);
                this.hasHelpText = Parser.HasHelpText(attribute);
                this.helpText = Parser.HelpText(attribute, field);
                this.defaultValue = Parser.DefaultValue(attribute, field);
                this.elementType = ElementType(field);
                this.flags = Flags(attribute, field);
                this.field = field;
                this.seenValue = false;
                this.reporter = reporter;
                this.isDefault = attribute != null && attribute is DefaultArgumentAttribute;

                if (IsCollection)
                {
                    this.collectionValues = new ArrayList();
                }

                Debug.Assert(this.longName != null && this.longName != "");
                Debug.Assert(!this.isDefault || !this.ExplicitShortName);
                Debug.Assert(!IsCollection || AllowMultiple, "Collection arguments must have allow multiple");
                Debug.Assert(!Unique || IsCollection, "Unique only applicable to collection arguments");
                Debug.Assert(IsValidElementType(Type) ||
                    IsCollectionType(Type));
                Debug.Assert((IsCollection && IsValidElementType(elementType)) ||
                    (!IsCollection && elementType == null));
                Debug.Assert(!(this.IsRequired && this.HasDefaultValue), "Required arguments cannot have default value");
                Debug.Assert(!this.HasDefaultValue || (this.defaultValue.GetType() == field.FieldType), "Type of default value must match field type");
            }

            public bool Finish(object destination)
            {
                if (this.SeenValue)
                {
                    if (this.IsCollection)
                    {
                        this.field.SetValue(destination, this.collectionValues.ToArray(this.elementType));
                    }
                }
                else
                {
                    if (this.HasDefaultValue)
                    {
                        this.field.SetValue(destination, this.DefaultValue);
                    }
                }

                return ReportMissingRequiredArgument();
            }

            private bool ReportMissingRequiredArgument()
            {
                if (this.IsRequired && !this.SeenValue)
                {
                    if (this.IsDefault)
                        reporter(string.Format("Missing required argument '<{0}>'.", this.LongName));
                    else
                        reporter(string.Format("Missing required argument '/{0}'.", this.LongName));
                    return true;
                }
                return false;
            }

            private void ReportDuplicateArgumentValue(string value)
            {
                this.reporter(string.Format("Duplicate '{0}' argument '{1}'", this.LongName, value));
            }

            public bool SetValue(string value, object destination)
            {
                if (SeenValue && !AllowMultiple)
                {
                    this.reporter(string.Format("Duplicate '{0}' argument", this.LongName));
                    return false;
                }
                this.seenValue = true;

                object newValue;
                if (!ParseValue(this.ValueType, value, out newValue))
                    return false;
                if (this.IsCollection)
                {
                    if (this.Unique && this.collectionValues.Contains(newValue))
                    {
                        ReportDuplicateArgumentValue(value);
                        return false;
                    }
                    else
                    {
                        this.collectionValues.Add(newValue);
                    }
                }
                else
                {
                    this.field.SetValue(destination, newValue);
                }

                return true;
            }

            public Type ValueType
            {
                get { return this.IsCollection ? this.elementType : this.Type; }
            }

            private void ReportBadArgumentValue(string value)
            {
                this.reporter(string.Format("'{0}' is not a valid value for the '{1}' command line option", value, this.LongName));
            }

            private bool ParseValue(Type type, string stringData, out object value)
            {
                // null is only valid for bool variables
                // empty string is never valid
                if ((stringData != null || type == typeof(bool)) && (stringData == null || stringData.Length > 0))
                {
                    try
                    {
                        if (type == typeof(string))
                        {
                            value = stringData;
                            return true;
                        }
                        else if (type == typeof(bool))
                        {
                            if (stringData == null || stringData == "+")
                            {
                                value = true;
                                return true;
                            }
                            else if (stringData == "-")
                            {
                                value = false;
                                return true;
                            }
                        }
                        else if (type == typeof(int))
                        {
                            value = int.Parse(stringData);
                            return true;
                        }
                        else if (type == typeof(uint))
                        {
                            value = int.Parse(stringData);
                            return true;
                        }
                        else
                        {
                            Debug.Assert(type.IsEnum);

                            bool valid = false;
                            foreach (string name in Enum.GetNames(type))
                            {
                                if (name == stringData)
                                {
                                    valid = true;
                                    break;
                                }
                            }
                            if (valid)
                            {
                                value = Enum.Parse(type, stringData, true);
                                return true;
                            }
                        }
                    }
                    catch
                    {
                        // catch parse errors
                    }
                }

                ReportBadArgumentValue(stringData);
                value = null;
                return false;
            }

            private void AppendValue(StringBuilder builder, object value)
            {
                if (value is string || value is int || value is uint || value.GetType().IsEnum)
                {
                    builder.Append(value.ToString());
                }
                else if (value is bool)
                {
                    builder.Append((bool)value ? "+" : "-");
                }
                else
                {
                    bool first = true;
                    foreach (object o in (System.Array)value)
                    {
                        if (!first)
                        {
                            builder.Append(", ");
                        }
                        AppendValue(builder, o);
                        first = false;
                    }
                }
            }

            public string LongName
            {
                get { return this.longName; }
            }

            public bool ExplicitShortName
            {
                get { return this.explicitShortName; }
            }

            public string ShortName
            {
                get { return this.shortName; }
            }

            public bool HasShortName
            {
                get { return this.shortName != null; }
            }

            public void ClearShortName()
            {
                this.shortName = null;
            }

            public bool HasHelpText
            {
                get { return this.hasHelpText; }
            }

            public string HelpText
            {
                get { return this.helpText; }
            }

            public object DefaultValue
            {
                get { return this.defaultValue; }
            }

            public bool HasDefaultValue
            {
                get { return null != this.defaultValue; }
            }

            public string FullHelpText
            {
                get
                {
                    StringBuilder builder = new StringBuilder();
                    if (this.HasHelpText)
                    {
                        builder.Append(this.HelpText);
                    }
                    if (this.HasDefaultValue)
                    {
                        if (builder.Length > 0)
                            builder.Append(" ");
                        builder.Append("Default value:'");
                        AppendValue(builder, this.DefaultValue);
                        builder.Append('\'');
                    }
                    if (this.HasShortName)
                    {
                        if (builder.Length > 0)
                            builder.Append(" ");
                        builder.Append("(short form /");
                        builder.Append(this.ShortName);
                        builder.Append(")");
                    }
                    return builder.ToString();
                }
            }

            public string SyntaxHelp
            {
                get
                {
                    StringBuilder builder = new StringBuilder();

                    if (this.IsDefault)
                    {
                        builder.Append("<");
                        builder.Append(this.LongName);
                        builder.Append(">");
                    }
                    else
                    {
                        builder.Append("/");
                        builder.Append(this.LongName);
                        Type valueType = this.ValueType;
                        if (valueType == typeof(int))
                        {
                            builder.Append(":<int>");
                        }
                        else if (valueType == typeof(uint))
                        {
                            builder.Append(":<uint>");
                        }
                        else if (valueType == typeof(bool))
                        {
                            builder.Append("[+|-]");
                        }
                        else if (valueType == typeof(string))
                        {
                            builder.Append(":<string>");
                        }
                        else
                        {
                            Debug.Assert(valueType.IsEnum);

                            builder.Append(":{");
                            bool first = true;
                            foreach (FieldInfo field in valueType.GetFields())
                            {
                                if (field.IsStatic)
                                {
                                    if (first)
                                        first = false;
                                    else
                                        builder.Append('|');
                                    builder.Append(field.Name);
                                }
                            }
                            builder.Append('}');
                        }
                    }

                    return builder.ToString();
                }
            }

            public bool IsRequired
            {
                get { return 0 != (this.flags & ArgumentType.Required); }
            }

            public bool SeenValue
            {
                get { return this.seenValue; }
            }

            public bool AllowMultiple
            {
                get { return 0 != (this.flags & ArgumentType.Multiple); }
            }

            public bool Unique
            {
                get { return 0 != (this.flags & ArgumentType.Unique); }
            }

            public Type Type
            {
                get { return field.FieldType; }
            }

            public bool IsCollection
            {
                get { return IsCollectionType(Type); }
            }

            public bool IsDefault
            {
                get { return this.isDefault; }
            }

            private string longName;
            private string shortName;
            private string helpText;
            private bool hasHelpText;
            private bool explicitShortName;
            private object defaultValue;
            private bool seenValue;
            private FieldInfo field;
            private Type elementType;
            private ArgumentType flags;
            private ArrayList collectionValues;
            private ErrorReporter reporter;
            private bool isDefault;
        }

        private ArrayList arguments;
        private Hashtable argumentMap;
        private Argument defaultArgument;
        private ErrorReporter reporter;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup\Monitoring\LiveConnectPing\Program.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using System.Diagnostics;
using System.ServiceModel;
using System.ServiceModel.Security;
using System.Configuration;
using System.Net;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;

using LiveConnectWeb;
using CommandLine;

namespace LiveConnectPing
{
    /// <summary>
    /// 
    /// </summary>
    class Program
    {
        private const string LiveConnectPingEventSource = "LiveConnectPing";
        private const byte WindowsPhonePlatform = 15;
        private static char[] BadSnuidChars = "<>:\",\\".ToCharArray();
        private static string Hostname;
        private static StsToken stsTokenGen;

        /// <summary>
        /// 
        /// </summary>
        public enum SocialNetwork: ushort
        {
            WindowsLiveSpaces = 1,
            Facebook,
            Twitter,
        }

        /// <summary>
        /// 
        /// </summary>
        [Flags]
        public enum LiveConnectErrors : int
        {
            None = 0x0,
            SmokeTest = 0x1,
            DirectorySts = 0x2,
            AuthSts = 0x4,
            DirectoryCert = 0x10,
            AuthCert = 0x20,
            AuthTwitter = 0x40,
            Unknown = 0x80,
            InvalidArgs = 0x100,
            InvalidClientCert = 0x200,
            DirectoryWP7 = 0x400,
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="args"></param>
        static void Main(string[] args)
        {
            LiveConnectErrors errors = LiveConnectErrors.None;

            try
            {
                LiveConnectPingArguments lcArgs = new LiveConnectPingArguments();
                if (!Parser.ParseArgumentsWithUsage(args, lcArgs))
                {
                    TraceEx.TraceError(7000, "Invalid argument(s) provided: {0}", Environment.CommandLine);
                    errors = LiveConnectErrors.InvalidArgs;
                    return;
                }

                Hostname = lcArgs.Hostname;
                if(lcArgs.IgnoreServerSslErrors)
                    ServicePointManager.ServerCertificateValidationCallback = (sender, certificate, chain, sslPolicyErrors) => true;

                if (!EventLog.SourceExists(LiveConnectPingEventSource))
                {
                    EventLog.CreateEventSource(LiveConnectPingEventSource, "Application");
                    Trace.TraceInformation("***Added LiveConnectPing event source to Application log.");
                }

                //validate that the required client cert is installed and that the private key is accessible
                if (!ValidateClientCert())
                {
                    errors = LiveConnectErrors.InvalidClientCert;
                    return;
                }

                stsTokenGen = new StsToken(ConfigurationManager.AppSettings["ClientCertSubject"]);

                if (!SmokeTest())
                    errors |= LiveConnectErrors.SmokeTest;
                //sts token auth
                if (!DirectoryTest(Authentication.ConsoleStsToken))
                    errors |= LiveConnectErrors.DirectorySts;
                if (!AuthenticationTest(Authentication.ConsoleStsToken))
                    errors |= LiveConnectErrors.AuthSts;
                //client cert auth
                if (!DirectoryTest(Authentication.ClientCertificate))
                    errors |= LiveConnectErrors.DirectoryCert;
                if (!AuthenticationTest(Authentication.ClientCertificate))
                    errors |= LiveConnectErrors.AuthCert;
                //twitter-specific case
                if (!TwitterAuthenticationTest())
                    errors |= LiveConnectErrors.AuthTwitter;             
                //WP7/MCB specific case
                if (!WP7DirectoryTest())
                    errors |= LiveConnectErrors.DirectoryWP7;
            }
            catch (Exception e)
            {
                TraceEx.TraceError(6000, "Unexpected exception occurred;\r\n\r\n{0}", e.ToString());
                errors |= LiveConnectErrors.Unknown;
            }
            finally
            {
                string message;
                if (errors == LiveConnectErrors.None)
                    message = "LiveConnectPing successfully completed with no errors.";
                else
                    message = String.Format("LiveConnectPing finished with the following error code(s): {0}.  Review previous error events for more details.", ((int)errors));
                
                Trace.TraceInformation(message);
                Environment.Exit((int)errors);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        private static bool ValidateClientCert()
        {
            string subject = ConfigurationManager.AppSettings["ClientCertSubject"];
            X509Store localMachine = null;
            bool success = true;

            try
            {
                TraceEx.TraceVerbose("Attempting to validate that the required client certificate (CN={0}) is installed and that the private key is available/accessible.", subject);
                localMachine = new X509Store(StoreName.My, StoreLocation.LocalMachine);
                localMachine.Open(OpenFlags.ReadOnly);
                X509Certificate2Collection matches = localMachine.Certificates.Find(X509FindType.FindBySubjectName, subject, false);

                if (matches == null || matches.Count == 0)
                {
                    TraceEx.TraceError(8000, "No client certificate matching subject '{0}' were found in LOCAL_MACHINE\\My.", subject);
                    success = false;
                }
                else if (matches.Count > 1)
                {
                    TraceEx.TraceError(8000, "{0} client certificates were found, matching subject '{1}', in LOCAL_MACHINE\\My.  Remove any bad/expired certificates and try again.", matches.Count, subject);
                    success = false;
                }
                else if (!matches[0].HasPrivateKey || !(matches[0].PrivateKey is RSACryptoServiceProvider))
                {
                    TraceEx.TraceError(8000, "The specified client certificate, matching subject '{0}', does not contain or have access to private key material.  Verify that the certificate PFX was correctly installed and that the account running this application has appropriate access.", subject);
                    success = false;
                }
        
                TraceEx.TraceVerbose("Successfully verified client certificate.");
            }
            catch
            {
                success = false;
            }
            finally
            {
                if (localMachine != null)
                    localMachine.Close();                
            }

            return success;
        }

        /// <summary>
        /// 
        /// </summary>
        private static bool SmokeTest()
        {
            try
            {
                TraceEx.TraceStart("Starting Smoke Page Validation.");
                string url = String.Format("https://{0}/smoke.aspx", Hostname);
                TraceEx.TraceVerbose("Using Smoke Page Url: {0}", url);

                using (WebClient client = new WebClient())
                {
                    client.DownloadString(url);
                }

                TraceEx.TraceVerbose("Successfully Validated Smoke Page.");
                return true;
            }
            catch (Exception e)
            {
                string message = String.Format("Error validating Smoke page:\r\n\r\n{0}", e.ToString());
                TraceEx.TraceError(1000, message);
                return false;
            }
            finally
            {
                TraceEx.TraceStop("Finished Smoke Page Validation.");
            }
        }

        /// <summary>
        /// Executes a suite of LiveConnect Directory tests, using client certificate or console STS token auth.
        /// </summary>
        /// <param name="useCertAuth"></param>
        private static bool DirectoryTest(Authentication authMode)
        {
            LiveDirectoryClient directoryClient = null;
            bool success = true;

            try
            {
                TraceEx.TraceStart("Starting Live Connect Directory Validation (using {0} authentication).", GetAuthModeText(authMode)); 
                directoryClient = new LiveDirectoryClient((authMode == Authentication.ClientCertificate ? "LiveDirectoryCert" : "LiveDirectorySts"));
                directoryClient.Endpoint.Address = new EndpointAddress(UpdateClientEndpoint(directoryClient), directoryClient.Endpoint.Address.Identity, directoryClient.Endpoint.Address.Headers);
                TraceEx.TraceVerbose("Using Live Connect Endpoint \"{0}\", at {1}", directoryClient.Endpoint.Name, directoryClient.Endpoint.Address.Uri);

                SNUserInfo userInfo = new SNUserInfo();
                userInfo.SNUserID = "PingTest-" + Utility.GenerateRandomString(10, BadSnuidChars);
                userInfo.GamerTag = Utility.GenerateRandomString(10);
                userInfo.XUID = Utility.GenerateRandomUInt64();
                userInfo.Visibility = Visibility.Everyone;

                if (authMode == Authentication.ConsoleStsToken)
                {
                    StsTokenParameters stsParameters = new StsTokenParameters() { Xuid = userInfo.XUID, TitleId = NetworkToTitleID((ushort)SocialNetwork.Facebook) };
                    ConfigureStsAuth(directoryClient, authMode, stsParameters);
                }

                try
                {
                    TraceEx.TraceVerbose("Opening channel...");
                    directoryClient.Open();
                    TraceEx.TraceVerbose("Calling SetSNUserInfo with UserID={0}, XUID={1}, GamerTag={2}, Visibility={3}, Network=Facebook",
                                                userInfo.SNUserID,
                                                userInfo.XUID,
                                                userInfo.GamerTag,
                                                userInfo.Visibility);
                    directoryClient.SetSNUserInfo((ushort)SocialNetwork.Facebook, userInfo);
                }
                catch (Exception e)
                {
                    HandleError("SetSNUserInfo", authMode, e);
                    success = false;
                }

                try
                {
                    TraceEx.TraceVerbose("Calling GetSNUserInfoBySNUId with UserID={0}, Network=Facebook", userInfo.SNUserID);
                    SNUserInfo actualUserInfo = directoryClient.GetSNUserInfoBySNUId((ushort)SocialNetwork.Facebook, userInfo.SNUserID);
                    if (userInfo.SNUserID != actualUserInfo.SNUserID)
                        throw new ValidationException("SNUserInfo returned from GetSNUserInfoBySNUId does not match the original value; expected SNUserID {0}, got {1}.", userInfo.SNUserID, actualUserInfo.SNUserID);
                    if (userInfo.GamerTag != actualUserInfo.GamerTag)
                        throw new ValidationException("SNUserInfo returned from GetSNUserInfoBySNUId does not match the original value; expected GamerTag {0}, got {1}.", userInfo.GamerTag, actualUserInfo.GamerTag);
                    if (userInfo.XUID != actualUserInfo.XUID)
                        throw new ValidationException("SNUserInfo returned from GetSNUserInfoBySNUId does not match the original value; expected XUID {0}, got {1}.", userInfo.XUID, actualUserInfo.XUID);
                    if (userInfo.Visibility != actualUserInfo.Visibility)
                        throw new ValidationException("SNUserInfo returned from GetSNUserInfoBySNUId does not match the original value; expected Visibility {0}, got {1}.", userInfo.Visibility, actualUserInfo.Visibility);
                }
                catch (Exception e)
                {
                    HandleError("GetSNUserInfoBySNUId", authMode, e);
                    success = false;
                }

                try
                {
                    TraceEx.TraceVerbose("Calling GetSNUserInfoByXUID with XUID={0}, Network=Facebook", userInfo.XUID);
                    SNUserInfo actualUserInfo = directoryClient.GetSNUserInfoByXUID((ushort)SocialNetwork.Facebook, userInfo.XUID);
                    if (userInfo.SNUserID != actualUserInfo.SNUserID)
                        throw new ValidationException("SNUserInfo returned from GetSNUserInfoByXUID does not match the original value; expected SNUserID {0}, got {1}.", userInfo.SNUserID, actualUserInfo.SNUserID);
                    if (userInfo.GamerTag != actualUserInfo.GamerTag)
                        throw new ValidationException("SNUserInfo returned from GetSNUserInfoByXUID does not match the original value; expected GamerTag {0}, got {1}.", userInfo.GamerTag, actualUserInfo.GamerTag);
                    if (userInfo.XUID != actualUserInfo.XUID)
                        throw new ValidationException("SNUserInfo returned from GetSNUserInfoByXUID does not match the original value; expected XUID {0}, got {1}.", userInfo.XUID, actualUserInfo.XUID);
                    if (userInfo.Visibility != actualUserInfo.Visibility)
                        throw new ValidationException("SNUserInfo returned from GetSNUserInfoByXUID does not match the original value; expected Visibility {0}, got {1}.", userInfo.Visibility, actualUserInfo.Visibility);
                }
                catch (Exception e)
                {
                    HandleError("GetSNUserInfoByXUID", authMode, e);
                    success = false;
                }

                try
                {
                    TraceEx.TraceVerbose("Calling GetSNUserInfos with UserID={0}, Network=Facebook", userInfo.SNUserID);
                    SNUserInfo[] actualUserInfos = directoryClient.GetSNUserInfos((ushort)SocialNetwork.Facebook, new string[] { userInfo.SNUserID });
                    if (actualUserInfos.Length != 1)
                        throw new ValidationException("Expected GetSNUserInfos to return 1 user, but got {0}", actualUserInfos.Length);
                    if (userInfo.SNUserID != actualUserInfos[0].SNUserID)
                        throw new ValidationException("SNUserInfo returned from GetSNUserInfos does not match the original value; expected SNUserID {0}, got {1}.", userInfo.SNUserID, actualUserInfos[0].SNUserID);
                    if (userInfo.GamerTag != actualUserInfos[0].GamerTag)
                        throw new ValidationException("SNUserInfo returned from GetSNUserInfos does not match the original value; expected GamerTag {0}, got {1}.", userInfo.GamerTag, actualUserInfos[0].GamerTag);
                    if (userInfo.XUID != actualUserInfos[0].XUID)
                        throw new ValidationException("SNUserInfo returned from GetSNUserInfos does not match the original value; expected XUID {0}, got {1}.", userInfo.XUID, actualUserInfos[0].XUID);
                    if (userInfo.Visibility != actualUserInfos[0].Visibility)
                        throw new ValidationException("SNUserInfo returned from GetSNUserInfos does not match the original value; expected Visibility {0}, got {1}.", userInfo.Visibility, actualUserInfos[0].Visibility);
                }
                catch (Exception e)
                {
                    HandleError("GetSNUserInfos", authMode, e);
                    success = false;
                }

                try
                {
                    TraceEx.TraceVerbose("Calling RemoveSNUserInfo with XUID={0}, Network=Facebook", userInfo.XUID);
                    directoryClient.RemoveSNUserInfo((ushort)SocialNetwork.Facebook, userInfo.XUID);
                }
                catch (Exception e)
                {
                    HandleError("RemoveSNUserInfo", authMode, e);
                    success = false;
                }

                TraceEx.TraceVerbose("Successfully validated Live Connect Directory service.");
            }
            finally
            {
                TraceEx.TraceStop("Finished Live Connect Directory Validation.");
                directoryClient.CloseConnection();
            }

            return success;
        }

        /// <summary>
        /// Executes a suite of LiveConnect Authentication tests, using client certificate and console STS token auth.
        /// </summary>
        /// <param name="useCertAuth"></param>
        private static bool AuthenticationTest(Authentication authMode)
        {
            LiveAuthenticationClient authClient = null;
            bool success = true;

            try
            {
                TraceEx.TraceStart("Starting Live Connect Authentication Validation (using {0} authentication).", GetAuthModeText(authMode));
                authClient = new LiveAuthenticationClient((authMode == Authentication.ClientCertificate ? "LiveAuthenticationCert" : "LiveAuthenticationSts"));
                authClient.Endpoint.Address = new EndpointAddress(UpdateClientEndpoint(authClient), authClient.Endpoint.Address.Identity, authClient.Endpoint.Address.Headers);
                TraceEx.TraceVerbose("Using Live Connect Authentication Endpoint \"{0}\", at {1}", authClient.Endpoint.Name, authClient.Endpoint.Address.Uri);

                SNUserInfo userInfo = new SNUserInfo();
                userInfo.SNUserID = "PingTest-" + Utility.GenerateRandomString(10, BadSnuidChars);
                userInfo.GamerTag = Utility.GenerateRandomString(10);
                userInfo.XUID = Utility.GenerateRandomUInt64();
                userInfo.Visibility = Visibility.Everyone;

                string deviceId = Utility.GenerateRandomUInt64().ToString();

                SNAuthInfo authInfo = new SNAuthInfo();
                authInfo.SNUserID = userInfo.SNUserID;
                authInfo.Token = Utility.GenerateRandomString(150);

                if (authMode == Authentication.ConsoleStsToken)
                {
                    StsTokenParameters stsParameters = new StsTokenParameters() { Xuid = userInfo.XUID, TitleId = NetworkToTitleID((ushort)SocialNetwork.Twitter), MachineId=ulong.Parse(deviceId) };
                    ConfigureStsAuth(authClient, authMode, stsParameters);
                }

                try
                {
                    TraceEx.TraceVerbose("Opening channel...");
                    authClient.Open();
                    TraceEx.TraceVerbose("Calling SetAuthInfo with XUID={0}, GamerTag={1}, DeviceID={2}, Token={3}, Visibility={4}, Network=Twitter", 
                                                userInfo.XUID,
                                                userInfo.GamerTag,
                                                deviceId,
                                                authInfo.Token,
                                                userInfo.Visibility);
                    authClient.SetAuthInfo((ushort)SocialNetwork.Twitter, userInfo.XUID, userInfo.GamerTag, deviceId, authInfo, true, userInfo.Visibility);
                }
                catch (Exception e)
                {
                    HandleError("SetAuthInfo", authMode, e);
                    success = false;
                }

                try
                {
                    TraceEx.TraceVerbose("Calling GetAuthInfo with XUID={0}, DeviceID={1}, Network=Twitter", userInfo.XUID, deviceId);
                    SNAuthInfo actualAuthInfo = authClient.GetAuthInfo((ushort)SocialNetwork.Twitter, userInfo.XUID, deviceId);
                    if (authInfo.SNUserID != actualAuthInfo.SNUserID)
                        throw new ValidationException("SNAuthInfo returned from GetAuthInfo does not match the original value; expected SNUserID {0}, got {1}.", authInfo.SNUserID, actualAuthInfo.SNUserID);
                    if (authInfo.Token != actualAuthInfo.Token)
                        throw new ValidationException("SNAuthInfo returned from GetAuthInfo does not match the original value; expected Token {0}, got {1}.", authInfo.Token, actualAuthInfo.Token);                    
                }
                catch (Exception e)
                {
                    HandleError("GetAuthInfo", authMode, e);
                    success = false;
                }
                                
                try
                {
                    TraceEx.TraceVerbose("Calling RemoveAuthInfo with XUID={0}, DeviceID={1}, Network=Twitter", userInfo.XUID, deviceId);
                    authClient.RemoveAuthInfo((ushort)SocialNetwork.Twitter, userInfo.XUID, deviceId);
                }
                catch (Exception e)
                {
                    HandleError("RemoveAuthInfo", authMode, e);
                    success = false;
                }

                TraceEx.TraceVerbose("Successfully validated Live Connect Authentication service.");
            }
            finally
            {
                TraceEx.TraceStop("Finished Live Connect Authentication Validation.");
                authClient.CloseConnection();
            }

            return success;
        }

        /// <summary>
        /// 
        /// </summary>
        private static bool TwitterAuthenticationTest()
        {
            LiveAuthenticationClient authClient = null;
            bool success = true;

            try
            {
                TraceEx.TraceStart("Starting Live Connect Twitter Authentication Validation (using STS token authentication).");
                authClient = new LiveAuthenticationClient("LiveAuthenticationSts");
                authClient.Endpoint.Address = new EndpointAddress(UpdateClientEndpoint(authClient), authClient.Endpoint.Address.Identity, authClient.Endpoint.Address.Headers);
                TraceEx.TraceVerbose("Using Live Connect Authentication Endpoint \"{0}\", at {1}", authClient.Endpoint.Name, authClient.Endpoint.Address.Uri);

                SNUserInfo userInfo = new SNUserInfo();
                userInfo.SNUserID = "PingTest-" + Utility.GenerateRandomString(10, BadSnuidChars);
                userInfo.GamerTag = Utility.GenerateRandomString(10);
                userInfo.XUID = 0;  //Twitter special case value; Lua can't easily deal w/ ulong...
                userInfo.Visibility = Visibility.Everyone;

                ulong stsXuid = Utility.GenerateRandomUInt64();
                string stsMachineId = Utility.GenerateRandomUInt64().ToString();

                SNAuthInfo authInfo = new SNAuthInfo();
                authInfo.SNUserID = userInfo.SNUserID;
                authInfo.Token = Utility.GenerateRandomString(150);

                StsTokenParameters stsParameters = new StsTokenParameters() { Xuid = stsXuid, TitleId = NetworkToTitleID((ushort)SocialNetwork.Twitter), MachineId = ulong.Parse(stsMachineId) };
                ConfigureStsAuth(authClient, Authentication.ConsoleStsToken, stsParameters);
               
                try
                {
                    TraceEx.TraceVerbose("Opening channel...");
                    authClient.Open();
                    TraceEx.TraceVerbose("Calling SetAuthInfo with XUID={0}, GamerTag={1}, DeviceID=NULL, Token={2}, Visibility={3}, Network=Twitter",
                                                userInfo.XUID,
                                                userInfo.GamerTag,
                                                authInfo.Token,
                                                userInfo.Visibility);
                    authClient.SetAuthInfo((ushort)SocialNetwork.Twitter, userInfo.XUID, userInfo.GamerTag, null, authInfo, true, userInfo.Visibility);
                }
                catch (Exception e)
                {
                    HandleError("SetAuthInfo", Authentication.ConsoleStsToken, e);
                    success = false;
                }

                try
                {
                    TraceEx.TraceVerbose("Calling GetAuthInfo with XUID={0}, DeviceID={1}, Network=Twitter", stsXuid, stsMachineId);
                    SNAuthInfo actualAuthInfo = authClient.GetAuthInfo((ushort)SocialNetwork.Twitter, stsXuid, stsMachineId);
                    if (authInfo.SNUserID != actualAuthInfo.SNUserID)
                        throw new ValidationException("SNAuthInfo returned from GetAuthInfo does not match the original value; expected SNUserID {0}, got {1}.", authInfo.SNUserID, actualAuthInfo.SNUserID);
                    if (authInfo.Token != actualAuthInfo.Token)
                        throw new ValidationException("SNAuthInfo returned from GetAuthInfo does not match the original value; expected Token {0}, got {1}.", authInfo.Token, actualAuthInfo.Token);
                }
                catch (Exception e)
                {
                    HandleError("GetAuthInfo", Authentication.ConsoleStsToken, e);
                    success = false;
                }

                try
                {
                    TraceEx.TraceVerbose("Calling RemoveAuthInfo with XUID={0}, DeviceID={1}, Network=Twitter", stsXuid, stsMachineId);
                    authClient.RemoveAuthInfo((ushort)SocialNetwork.Twitter, stsXuid, stsMachineId);
                }
                catch (Exception e)
                {
                    HandleError("RemoveAuthInfo", Authentication.ConsoleStsToken, e);
                    success = false;
                }

                TraceEx.TraceVerbose("Successfully validated Live Connect Twitter Authentication service.");
            }
            finally
            {
                TraceEx.TraceStop("Finished Live Connect Twitter Authentication Validation.");
                authClient.CloseConnection();
            }

            return success;
        }

        /// <summary>
        /// Specific test for MCB/WP7 clients, which use user token STS auth.
        /// </summary>
        /// <returns></returns>
        private static bool WP7DirectoryTest()
        {
            LiveDirectoryClient directoryClient = null;
            bool success = true;

            try
            {
                TraceEx.TraceStart("Starting Live Connect WP7 Directory Validation (using STS user token authentication).");
                directoryClient = new LiveDirectoryClient("LiveDirectorySts");
                directoryClient.Endpoint.Address = new EndpointAddress(UpdateClientEndpoint(directoryClient), directoryClient.Endpoint.Address.Identity, directoryClient.Endpoint.Address.Headers);
                TraceEx.TraceVerbose("Using Live Connect Endpoint \"{0}\", at {1}", directoryClient.Endpoint.Name, directoryClient.Endpoint.Address.Uri);

                SNUserInfo userInfo = new SNUserInfo();
                userInfo.SNUserID = "PingTest-" + Utility.GenerateRandomString(10, BadSnuidChars);
                userInfo.GamerTag = Utility.GenerateRandomString(10);
                userInfo.XUID = Utility.GenerateRandomUInt64();
                userInfo.Visibility = Visibility.Everyone;

                StsTokenParameters stsParameters = new StsTokenParameters() { Xuid = userInfo.XUID, TitleId = (uint)XboxTitle.WP7GamesHub, TitleVersion = "1", PlatformType = WindowsPhonePlatform.ToString(), GamerTag = userInfo.GamerTag };
                ConfigureStsAuth(directoryClient, Authentication.UserStsToken, stsParameters);
                
                try
                {
                    TraceEx.TraceVerbose("Opening channel...");
                    directoryClient.Open();
                    TraceEx.TraceVerbose("Calling SetSNUserInfo with UserID={0}, XUID={1}, GamerTag={2}, Visibility={3}, Network=Facebook",
                                                userInfo.SNUserID,
                                                userInfo.XUID,
                                                userInfo.GamerTag,
                                                userInfo.Visibility);
                    directoryClient.SetSNUserInfo((ushort)SocialNetwork.Facebook, userInfo);
                }
                catch (Exception e)
                {
                    HandleError("SetSNUserInfo", Authentication.UserStsToken, e);
                    success = false;
                }

                try
                {
                    TraceEx.TraceVerbose("Calling GetSNUserInfoBySNUId with UserID={0}, Network=Facebook", userInfo.SNUserID);
                    SNUserInfo actualUserInfo = directoryClient.GetSNUserInfoBySNUId((ushort)SocialNetwork.Facebook, userInfo.SNUserID);
                    if (userInfo.SNUserID != actualUserInfo.SNUserID)
                        throw new ValidationException("SNUserInfo returned from GetSNUserInfoBySNUId does not match the original value; expected SNUserID {0}, got {1}.", userInfo.SNUserID, actualUserInfo.SNUserID);
                    if (userInfo.GamerTag != actualUserInfo.GamerTag)
                        throw new ValidationException("SNUserInfo returned from GetSNUserInfoBySNUId does not match the original value; expected GamerTag {0}, got {1}.", userInfo.GamerTag, actualUserInfo.GamerTag);
                    if (userInfo.XUID != actualUserInfo.XUID)
                        throw new ValidationException("SNUserInfo returned from GetSNUserInfoBySNUId does not match the original value; expected XUID {0}, got {1}.", userInfo.XUID, actualUserInfo.XUID);
                    if (userInfo.Visibility != actualUserInfo.Visibility)
                        throw new ValidationException("SNUserInfo returned from GetSNUserInfoBySNUId does not match the original value; expected Visibility {0}, got {1}.", userInfo.Visibility, actualUserInfo.Visibility);
                }
                catch (Exception e)
                {
                    HandleError("GetSNUserInfoBySNUId", Authentication.UserStsToken, e);
                    success = false;
                }
                finally
                {
                    directoryClient.CloseConnection();
                }

                //reset the client, to send a new gamertag in the token, in the call to GetSNUserInfos
                //this should update in the database
                directoryClient = new LiveDirectoryClient("LiveDirectorySts");
                directoryClient.Endpoint.Address = new EndpointAddress(UpdateClientEndpoint(directoryClient), directoryClient.Endpoint.Address.Identity, directoryClient.Endpoint.Address.Headers);
                
                string newGamerTag = Utility.GenerateRandomGamerTag(10);
                stsParameters.GamerTag = newGamerTag;
                ConfigureStsAuth(directoryClient, Authentication.UserStsToken, stsParameters);
                
                try
                {
                    TraceEx.TraceVerbose("Calling GetSNUserInfos with UserID={0}, Network=Facebook", userInfo.SNUserID);
                    SNUserInfo[] actualUserInfos = directoryClient.GetSNUserInfos((ushort)SocialNetwork.Facebook, new string[] { userInfo.SNUserID });
                    if (actualUserInfos.Length != 1)
                        throw new ValidationException("Expected GetSNUserInfos to return 1 user, but got {0}", actualUserInfos.Length);
                    if (userInfo.SNUserID != actualUserInfos[0].SNUserID)
                        throw new ValidationException("SNUserInfo returned from GetSNUserInfos does not match the original value; expected SNUserID {0}, got {1}.", userInfo.SNUserID, actualUserInfos[0].SNUserID);
                    if (userInfo.GamerTag != actualUserInfos[0].GamerTag)
                        throw new ValidationException("SNUserInfo returned from GetSNUserInfos does not match the original value; expected GamerTag {0}, got {1}.", userInfo.GamerTag, actualUserInfos[0].GamerTag);
                    //NOTE: special WP7 case; we zero out the xuid for user token calls to GetSNUserInfos
                    if (actualUserInfos[0].XUID != 0)
                        throw new ValidationException("SNUserInfo returned from GetSNUserInfos does not match the original value; expected XUID {0}, got {1}.", userInfo.XUID, actualUserInfos[0].XUID);
                    if (userInfo.Visibility != actualUserInfos[0].Visibility)
                        throw new ValidationException("SNUserInfo returned from GetSNUserInfos does not match the original value; expected Visibility {0}, got {1}.", userInfo.Visibility, actualUserInfos[0].Visibility);
                }
                catch (Exception e)
                {
                    HandleError("GetSNUserInfos", Authentication.UserStsToken, e);
                    success = false;
                }

                try
                {
                    TraceEx.TraceVerbose("Verifying gamertag refresh from {0} -> {1}...", userInfo.GamerTag, newGamerTag);
                    int attempts = 1;
                    bool verifiedChange = false;

                    do
                    {
                        SNUserInfo actualUserInfo = directoryClient.GetSNUserInfoBySNUId((ushort)SocialNetwork.Facebook, userInfo.SNUserID);
                        if (newGamerTag.Equals(actualUserInfo.GamerTag))
                        {
                            verifiedChange = true;
                            TraceEx.TraceVerbose("Successfully verified gamertag change, after {0} attempt(s)!", attempts);
                            break;
                        }

                        Thread.Sleep(500);  //wait just a bit...
                    }
                    while (attempts++ < 5);

                    if (!verifiedChange)
                        throw new ValidationException("Unable to verify gamertag refresh from {0} -> {1}, after 5 attempts.", userInfo.GamerTag, newGamerTag);
                }
                catch (Exception e)
                {
                    HandleError("GetSNUserInfoBySNUId", Authentication.UserStsToken, e);
                    success = false;
                }
            }
            finally
            {
                TraceEx.TraceStop("Finished Live Connect WP7 Directory Validation.");
                directoryClient.CloseConnection();
            }

            return success;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="e"></param>
        private static void HandleError(string api, Authentication authMode, Exception e)
        {
            string authModeText = GetAuthModeText(authMode);
            string message;
            int eventId;

            if (e is FaultException<SecurityAccessDeniedException>)
            {
                FaultException<SecurityAccessDeniedException> fault = e as FaultException<SecurityAccessDeniedException>;
                message = String.Format("{0} (using {2} auth) returned SecurityAccessDeniedException; STS or cert auth failed; SOAP fault Detail: {1}", api, fault.Detail.Message, authModeText);
                eventId = 2000;
            }
            else if (e is FaultException<ArgumentException>)
            {
                FaultException<ArgumentException> fault = e as FaultException<ArgumentException>;
                message = String.Format("{0} (using {2} auth) returned ArgumentException; invalid parameter(s) sent; SOAP fault Detail: {1}", api, fault.Detail.Message, authModeText);
                eventId = 2001;
            }
            else if (e is FaultException<ArgumentOutOfRangeException>)
            {
                FaultException<ArgumentOutOfRangeException> fault = e as FaultException<ArgumentOutOfRangeException>;
                message = String.Format("{0} (using {2} auth) returned ArgumentOutOfRangeException; out-of-range parameter(s) sent; SOAP fault Detail: {1}", api, fault.Detail.Message, authModeText);
                eventId = 2002;
            }
            else if (e is FaultException<ArgumentNullException>)
            {
                FaultException<ArgumentNullException> fault = e as FaultException<ArgumentNullException>;
                message = String.Format("{0} (using {2} auth) returned ArgumentNullException; null parameter(s) sent; SOAP fault Detail: {1}", api, fault.Detail.Message, authModeText);
                eventId = 2003;
            }
            else if (e is FaultException)
            {
                FaultException fault = e as FaultException;
                message = String.Format("Bug! {0} (using {2} auth) returned an unknown FaultException! {0}. An unexpected, internal error occurred: {1}", api, GetExceptionText(fault), authModeText);
                eventId = 2004;
            }
            else if (e is MessageSecurityException)
            {
                MessageSecurityException fault = e as MessageSecurityException;
                message = String.Format("{0} (using {2} auth) returned MessageSecurityException; invalid STS token or client certificate; SOAP fault Detail: {1}", api, GetExceptionText(fault), authModeText);
                eventId = 2005;
            }
            else if (e is TimeoutException)
            {
                TimeoutException fault = e as TimeoutException;
                message = String.Format("Encountered a timeout when calling {0} (using {2} auth): {1}", api, fault.Message, authModeText);
                eventId = 3000;
            }
            else if (e is CommunicationException)
            {
                CommunicationException fault = e as CommunicationException;
                message = String.Format("Encountered a communication issue when calling {0} (using {2} auth): {1}", api, GetExceptionText(fault), authModeText);
                eventId = 4000;
            }
            else if (e is ValidationException)
            {
                ValidationException fault = e as ValidationException;
                message = String.Format("Encountered a validation issue when calling {0} (using {2} auth); expected vs. actual data returned from the service did not match! {1}", api, fault.Message, authModeText);
                eventId = 5000;
            }
            else
            {
                message = String.Format("Unexpected exception occurred while calling {0} (using {2} auth)!\r\n\r\n{1}", api, e.ToString(), authModeText);
                eventId = 6000;
            }

            TraceEx.TraceError(eventId, message);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="client"></param>
        /// <param name="stsParameters"></param>
        private static void ConfigureStsAuth(LiveDirectoryClient client, Authentication authMode, StsTokenParameters stsParameters)
        {
            client.ChannelFactory.Endpoint.Behaviors.RemoveAll<System.ServiceModel.Description.ClientCredentials>();
            
            string stsToken = null;
            if (authMode == Authentication.UserStsToken)
            {
                stsToken = stsTokenGen.GenerateUserToken(stsParameters);
            }
            else
            {
                stsToken = stsTokenGen.GenerateConsoleToken(stsParameters);
            }

            client.ChannelFactory.Endpoint.Behaviors.Add(new StsClientCredentials(stsToken));
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="client"></param>
        /// <param name="stsParameters"></param>
        private static void ConfigureStsAuth(LiveAuthenticationClient client, Authentication authMode, StsTokenParameters stsParameters)
        {
            client.ChannelFactory.Endpoint.Behaviors.RemoveAll<System.ServiceModel.Description.ClientCredentials>();

            string stsToken = null;
            if (authMode == Authentication.UserStsToken)
            {
                stsToken = stsTokenGen.GenerateUserToken(stsParameters);
            }
            else
            {
                stsToken = stsTokenGen.GenerateConsoleToken(stsParameters);
            }

            client.ChannelFactory.Endpoint.Behaviors.Add(new StsClientCredentials(stsToken));
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="networkId"></param>
        /// <returns></returns>
        private static uint NetworkToTitleID(ushort networkId)
        {
            if (networkId == 2)
                return 0x584807E1;  //Facebook title ID
            return 0xFFFE07D1;      //Xbox 360 dash (BDEs - like twitter, get this title ID)
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="client"></param>
        /// <returns></returns>
        private static Uri UpdateClientEndpoint(LiveDirectoryClient client)
        {
            return new Uri(client.Endpoint.Address.Uri.Scheme + "://" + Hostname + client.Endpoint.Address.Uri.PathAndQuery);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="client"></param>
        /// <returns></returns>
        private static Uri UpdateClientEndpoint(LiveAuthenticationClient client)
        {
            return new Uri(client.Endpoint.Address.Uri.Scheme + "://" + Hostname + client.Endpoint.Address.Uri.PathAndQuery);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="e"></param>
        private static string GetExceptionText(Exception e)
        {
            if(e.InnerException != null)
                return e.InnerException.Message;
            return e.Message;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="authMode"></param>
        /// <returns></returns>
        private static string GetAuthModeText(Authentication authMode)
        {
            switch (authMode)
            {
                case Authentication.ClientCertificate:
                    {
                        return "client certificate";
                    }
                case Authentication.ConsoleStsToken:
                    {
                        return "console STS token";
                    }
                case Authentication.UserStsToken:
                    {
                        return "user STS token";
                    }
                default:
                    {
                        return "no authentication";
                    }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup\Monitoring\LiveConnectPing\ValidationException.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace LiveConnectPing
{
    /// <summary>
    /// 
    /// </summary>
    public class ValidationException: Exception
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="message"></param>
        public ValidationException(string message)
            : base(message)
        {

        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="format"></param>
        /// <param name="args"></param>
        public ValidationException(string format, params object[] args)
            : base(String.Format(format, args))
        {

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup\Monitoring\LiveConnectPing\XboxTitle.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace LiveConnectPing
{
    /// <summary>
    /// 
    /// </summary>
    public enum XboxTitle : uint
    {
        Default = XboxTitle.Xbox360Dash,
        Xbox360Dash = 0xFFFE07D1,
        Facebook = 0x584807E1,
        Twitter = XboxTitle.Xbox360Dash,    //Twitter is a BDE, so its title ID is the same as the 360 dash
        LastFM = 0x584807E3,
        WP7GamesHub = 0x584D07D6,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup\Monitoring\LiveConnectPing\TraceEx.cs ===
using System;
using System.Reflection;
using System.Diagnostics;

namespace LiveConnectPing
{
    /// <summary>
    /// 
    /// </summary>
    public static class TraceEx
    {
        private static Type internalTraceType = Type.GetType("System.Diagnostics.TraceInternal, System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089", true, true);
        private static MethodInfo traceEvent = internalTraceType.GetMethod("TraceEvent");

        /// <summary>
        /// 
        /// </summary>
        /// <param name="format"></param>
        /// <param name="args"></param>
        public static void TraceVerbose(string format, params object[] args)
        {
            TraceVerbose(String.Format(format, args));
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="message"></param>
        public static void TraceVerbose(string message)
        {
            traceEvent.Invoke(null, new object[] { TraceEventType.Verbose, 0, message, null });
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="format"></param>
        /// <param name="args"></param>
        public static void TraceStart(string format, params object[] args)
        {
            TraceStart(String.Format(format, args));
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="message"></param>
        public static void TraceStart(string message)
        {
            traceEvent.Invoke(null, new object[] { TraceEventType.Start, 0, message, null });
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="format"></param>
        /// <param name="args"></param>
        public static void TraceStop(string format, params object[] args)
        {
            TraceStop(String.Format(format, args));
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="message"></param>
        public static void TraceStop(string message)
        {
            traceEvent.Invoke(null, new object[] { TraceEventType.Stop, 0, message, null });
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="type"></param>
        /// <param name="id"></param>
        /// <param name="message"></param>
        public static void TraceEvent(TraceEventType type, int id, string message)
        {
            traceEvent.Invoke(null, new object[] { type, id, message, null });
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="type"></param>
        /// <param name="id"></param>
        /// <param name="format"></param>
        /// <param name="args"></param>
        public static void TraceEvent(TraceEventType type, int id, string format, params object[] args)
        {
            traceEvent.Invoke(null, new object[] { type, id, format, args });
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="format"></param>
        /// <param name="args"></param>
        public static void TraceError(string format, params object[] args)
        {
            TraceError(String.Format(format, args));
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="message"></param>
        public static void TraceError(string message)
        {
            traceEvent.Invoke(null, new object[] { TraceEventType.Error, 1000, message, null });
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="eventId"></param>
        /// <param name="format"></param>
        /// <param name="args"></param>
        public static void TraceError(int eventId, string format, params object[] args)
        {
            TraceError(eventId, String.Format(format, args));
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="message"></param>
        public static void TraceError(int eventId, string message)
        {
            traceEvent.Invoke(null, new object[] { TraceEventType.Error, eventId, message, null });
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="eventId"></param>
        /// <param name="format"></param>
        /// <param name="args"></param>
        public static void TraceWarning(int eventId, string format, params object[] args)
        {
            TraceWarning(eventId, String.Format(format, args));
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="message"></param>
        public static void TraceWarning(int eventId, string message)
        {
            traceEvent.Invoke(null, new object[] { TraceEventType.Warning, eventId, message, null });
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup\Monitoring\LiveConnectPing\Utility.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
using System.Reflection;
using System.IO;

namespace LiveConnectPing
{
    /// <summary>
    /// 
    /// </summary>
    public class Utility
    {
        private static Random rnd = new Random();
        private static object rndLock = new object();
        private static char[] whitespaceChars;
        private static string currentDirectory;
        private static string originalAssemblyDirectory;
        private static char[] gamerTagChars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 ".ToCharArray();        

        /// <summary>
        /// 
        /// </summary>
        static Utility()
        {
            FileInfo assemblyFile = new FileInfo(new Uri(Assembly.GetExecutingAssembly().CodeBase).LocalPath);
            currentDirectory = assemblyFile.DirectoryName;
            originalAssemblyDirectory = String.IsNullOrEmpty(AppDomain.CurrentDomain.SetupInformation.PrivateBinPath) ? String.Empty : AppDomain.CurrentDomain.SetupInformation.PrivateBinPath;
            if (!Directory.Exists(originalAssemblyDirectory))
            {
                originalAssemblyDirectory = String.Empty;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        private static char[] WhitespaceChars
        {
            get
            {
                if (whitespaceChars == null)
                {
                    Type stringType = typeof(string);
                    object chars = stringType.InvokeMember("WhitespaceChars", BindingFlags.GetField | BindingFlags.NonPublic | BindingFlags.Static, null, null, null);
                    whitespaceChars = chars as char[];
                }

                return whitespaceChars;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public static Random GlobalRandom
        {
            get
            {
                //NOTE: NOT thread safe!
                return rnd;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public static string CurrentDirectory
        {
            get
            {
                return currentDirectory;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public static string OriginalAssemblyDirectory
        {
            get
            {
                return originalAssemblyDirectory;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="max"></param>
        /// <returns></returns>
        public static int GenerateRandomNumber(int max)
        {
            lock (rndLock)
            {
                return rnd.Next(max);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="min"></param>
        /// <param name="max"></param>
        /// <returns></returns>
        public static int GenerateRandomNumber(int min, int max)
        {
            lock (rndLock)
            {
                return rnd.Next(min, max);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="length"></param>
        /// <returns></returns>
        public static string GenerateRandomString()
        {
            return GenerateRandomString(GenerateRandomNumber(1024));
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="length"></param>
        /// <returns></returns>
        public static string GenerateRandomString(int length)
        {
            return GenerateRandomString(length, null);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="length"></param>
        /// <returns></returns>
        public static string GenerateRandomString(int length, char[] excludeChars)
        {
            StringBuilder value = new StringBuilder(length);
            for (int i = 0; i < length; )
            {
                char temp = (char)GenerateRandomNumber(127);    //(char)GenerateRandomNumber(33, 127);
                if (!char.IsControl(temp) && (excludeChars == null || !excludeChars.Contains<char>(temp)))
                {
                    value.Append(temp);
                    i++;
                }
            }

            return value.ToString().Trim();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public static ulong GenerateRandomUInt64()
        {
            byte[] buffer = new byte[sizeof(ulong)];
            RNGCryptoServiceProvider rng = new RNGCryptoServiceProvider();
            rng.GetNonZeroBytes(buffer);
            return BitConverter.ToUInt64(buffer, 0);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public static uint GenerateRandomUInt32()
        {
            byte[] buffer = new byte[sizeof(uint)];
            RNGCryptoServiceProvider rng = new RNGCryptoServiceProvider();
            rng.GetNonZeroBytes(buffer);
            return BitConverter.ToUInt32(buffer, 0);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="array"></param>
        /// <returns></returns>
        public static string ArrayToString(Array array)
        {
            return ArrayToString(array, ", ");
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="array"></param>
        /// <returns></returns>
        public static string ArrayToString(Array array, string divider)
        {
            StringBuilder values = new StringBuilder();
            foreach (object obj in array)
            {
                values.Append(obj);
                values.Append(divider);
            }

            values.Length -= divider.Length;
            return values.ToString();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="length"></param>
        /// <returns></returns>
        public static string WhitespaceString(int length)
        {
            StringBuilder whitespace = new StringBuilder(length);
            Random rnd = new Random(unchecked((int)DateTime.Now.Ticks));

            for (int i = 0; i < length; i++)
                whitespace.Append(WhitespaceChars[rnd.Next(WhitespaceChars.Length)]);
            return whitespace.ToString();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="input"></param>    
        /// <returns></returns>
        public static string AppendWhitespace(object input)
        {
            return AppendWhitespace(input, true, true);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="input"></param>
        /// <param name="before"></param>
        /// <param name="after"></param>
        /// <returns></returns>
        public static string AppendWhitespace(object input, bool before, bool after)
        {
            StringBuilder newString = new StringBuilder(input.ToString());
            Random rnd = new Random(unchecked((int)DateTime.Now.Ticks));

            if (before)
                newString.Insert(0, WhitespaceString(rnd.Next(1, 5)));
            if (after)
                newString.Append(WhitespaceString(rnd.Next(1, 5)));
            return newString.ToString();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="length"></param>
        /// <returns></returns>
        public static string GenerateUnicodeString(int length)
        {
            StringBuilder sb = new StringBuilder();
            while (sb.Length < length)
            {
                char c = (char)GenerateRandomNumber(0x20, 0xfff0);
                if ((((c < '') || (c > '')) && ((c < 0xd800) || (c > 0xdfff))) && (((c < 0xe000) || (c > 0xf8ff)) && (c != 0xfeff)))
                {
                    sb.Append(c);
                }
            }
            return sb.ToString();

        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public static string GenerateRandomGamerTag(int length)
        {
            StringBuilder gamerTag = new StringBuilder(length);
            gamerTag.Append(gamerTagChars[Utility.GlobalRandom.Next(51)]);  //first char can't be a number/space

            int i = 0;
            while (i < length)
            {
                char nextChar = gamerTagChars[Utility.GlobalRandom.Next(gamerTagChars.Length - 1)];
                if (nextChar == ' ' && gamerTag[gamerTag.Length - 1] == ' ') //can't have consecutive spaces
                    continue;
                gamerTag.Append(nextChar);
                i++;
            }

            return gamerTag.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup\Monitoring\LiveConnectPing\STS\CustomSignedXml.cs ===
using System;
using System.Collections.Generic;
using System.Web;
using System.Xml;
using System.Xml.Serialization;
using System.Security.Cryptography;
using System.Security.Cryptography.Xml;


namespace LiveConnectPing
{

    // http://blogs.msdn.com/shawnfa/archive/2004/04/05/108098.aspx
    // Searching for Custom ID Tags With Signed XML
    // Excerpt... The biggest limitation with doing this is that you must refer to the nodes that are being signed by ID, 
    // which for v1.1 and 1.0 of the framework was given by an attribute named "Id". The problem there is that 
    // the Id attribute may already have another use in your schema, and you cannot reuse them for creating node names. 
    // Another problem that may come up is that the XML being signed may be generated by a tool or program, 
    // and it's not possible for you to add Id tags. Whidbey reduces this limitation somewhat by also allowing 
    // "id" and "ID", but the fundamental problem still exists.

    // Nodes that are being referred to by ID are resolved in the GetIdElement method of the SignedXml class. 
    // By subclassing SignedXml and overriding this method, its possible to create your own id node resolver. 


    public class CustomSignedXml : SignedXml
    {
        public CustomSignedXml(XmlDocument doc) :
            base(doc)
        {
        }

        public override XmlElement GetIdElement(XmlDocument doc, string id)
        {
            // check to see if it's a standard ID reference
            XmlElement idElem = base.GetIdElement(doc, id);
            if (idElem != null)
                return idElem;

            idElem = doc.SelectSingleNode("//*[@AssertionID=\"" + id + "\"]") as XmlElement;
            return idElem;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup1\LCWebService\CertNetworkMapper.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Configuration;
using System.Text.RegularExpressions;

namespace LiveConnectWeb
{
    internal sealed class CertNetworkMapper : NetworkMapper
    {
        private static readonly CertNetworkMapper instance = new CertNetworkMapper("CertId");

        private CertNetworkMapper(string key)
            : base(key)
        {
        }

        internal static CertNetworkMapper Instance
        {
            get
            {
                return instance;
            }
        }

        internal bool IsPeerAllowed(ushort networkId, string peerId)
        {
            return base.IsEntryAllowed(networkId, peerId);
        }

        internal string NormalizeSubject(string subject)
        {
            string normSubject= "";

            if (subject == null)
            {
                return null;
            }

            Match match = subjectReg.Match(subject);

            if (match.Success)
            {
                normSubject = match.Groups["subject"].Value;
            }
            else
            {
                normSubject = subject;
            }

            return normSubject;
        }

        Regex subjectReg = new Regex(@"CN\s*=\s*(?<subject>[^,]+)", RegexOptions.Compiled);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup\Monitoring\LiveConnectPing\STS\Player.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace LiveConnectPing
{
    /// <summary>
    /// 
    /// </summary>
    public class Player
    {
        /// <summary>
        /// 
        /// </summary>
        public ulong Xuid
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public byte Tier
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public byte Country
        {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup1\LCWebService\ILiveConnect.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.Serialization;
using System.ServiceModel;
using System.Text;
using System.ServiceModel.Security;

namespace LiveConnectWeb
{
    [ServiceContract(Namespace="http://liveconnect.xboxlive.com")]
    public interface ILiveDirectory
    {
        [OperationContract]
        [FaultContract(typeof(SecurityAccessDeniedException))]
        [FaultContract(typeof(ArgumentException))]
        [FaultContract(typeof(ArgumentOutOfRangeException))]
        [FaultContract(typeof(ArgumentNullException))]
        void SetSNUserInfo(ushort sNetworkId, SNUserInfo userInfo);

        [OperationContract]
        [FaultContract(typeof(SecurityAccessDeniedException))]
        [FaultContract(typeof(ArgumentException))]
        [FaultContract(typeof(ArgumentOutOfRangeException))]
        void RemoveSNUserInfo(ushort sNetworkId, ulong XUID);

        [OperationContract]
        [FaultContract(typeof(SecurityAccessDeniedException))]
        [FaultContract(typeof(ArgumentException))]
        [FaultContract(typeof(ArgumentOutOfRangeException))]
        SNUserInfo GetSNUserInfoByXUID(ushort sNetworkId, ulong XUID);

        [OperationContract]
        [FaultContract(typeof(SecurityAccessDeniedException))]
        [FaultContract(typeof(ArgumentException))]
        [FaultContract(typeof(ArgumentOutOfRangeException))]
        [FaultContract(typeof(ArgumentNullException))]
        SNUserInfo GetSNUserInfoBySNUId(ushort sNetworkId, string snUserId);

        [OperationContract]
        [FaultContract(typeof(SecurityAccessDeniedException))]
        [FaultContract(typeof(ArgumentException))]
        [FaultContract(typeof(ArgumentOutOfRangeException))]
        [FaultContract(typeof(ArgumentNullException))]
        SNUserInfo[] GetSNUserInfos(ushort sNetworkId, string[] sNUserIDs);

        [OperationContract]
        [FaultContract(typeof(ArgumentOutOfRangeException))]
        SNetworkInfo GetSNetworkInfo(ushort sNetworkId);

        [OperationContract]
        SNetworkInfo[] GetSNetworkInfos();
    }

    [ServiceContract(Namespace="http://liveconnect.xboxlive.com")]
    public interface ILiveAuthentication
    {
        //Each of these interfaces is tied to a device which is sent in the XAML token
        [OperationContract]
        [FaultContract(typeof(SecurityAccessDeniedException))]
        [FaultContract(typeof(ArgumentException))]
        [FaultContract(typeof(ArgumentOutOfRangeException))]
        [FaultContract(typeof(ArgumentNullException))]
        void SetAuthInfo(ushort sNetworkId, ulong XUID, string gamerTag, string deviceId, SNAuthInfo userInfo, bool addToDirectory, Visibility visibility);

        [OperationContract]
        [FaultContract(typeof(SecurityAccessDeniedException))]
        [FaultContract(typeof(ArgumentException))]
        [FaultContract(typeof(ArgumentOutOfRangeException))]
        [FaultContract(typeof(ArgumentNullException))]
        SNAuthInfo GetAuthInfo(ushort sNetworkId, ulong XUID, string deviceId);

        [OperationContract]
        [FaultContract(typeof(SecurityAccessDeniedException))]
        [FaultContract(typeof(ArgumentException))]
        [FaultContract(typeof(ArgumentOutOfRangeException))]
        [FaultContract(typeof(ArgumentNullException))]
        void RemoveAuthInfo(ushort sNetworkId, ulong XUID, string deviceId);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup\Monitoring\LiveConnectPing\WCF\ChannelFactoryExtensions.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.ServiceModel;

namespace LiveConnectPing
{
    /// <summary>
    /// 
    /// </summary>
    public static class ChannelFactoryExtensions
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="channel"></param>
        public static void CloseConnection(this ICommunicationObject channel)
        {
            if (channel == null || channel.State != CommunicationState.Opened)
            {
                return;
            }

            try
            {
                channel.Close();
            }
            catch (CommunicationException)
            {
                channel.Abort();
            }
            catch (TimeoutException)
            {
                channel.Abort();
            }
            catch (Exception)
            {
                channel.Abort();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup1\LCWebService\LiveConnectEventLogger.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Diagnostics;

namespace LiveConnectWeb
{
    enum EventErrorIds
    {
        InternalServerError = 1000,
        GeneralSQLError = 2000,
        GeneralSecurityViolation = 3000,
        STSSecurityTitleViolation = 4001,
        STSSecurityXUIDViolation = 4002,
        STSSecurityPrivacyViolation = 4003,
        X509NoValidCertFound = 5001,
        X509SubjectViolation = 5002
    }

    class LiveConnectEventLogger
    {
        private static readonly LiveConnectEventLogger instance = new LiveConnectEventLogger();

        private LiveConnectEventLogger()
        {
            eventLog = new EventLog();
            eventLog.Source = "LiveConnect";
        }

        internal static LiveConnectEventLogger Instance
        {
            get
            {
                return instance;
            }
        }

        public EventLog EventLog
        {
            get
            {
                return eventLog;
            }
        }
        
        EventLog eventLog;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup\Monitoring\LiveConnectPing\WCF\StsTokenManager.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.ServiceModel;
using System.ServiceModel.Description;
using System.IdentityModel;
using System.IdentityModel.Selectors;

namespace LiveConnectPing
{
    /// <summary>
    /// 
    /// </summary>
    public class StsTokenManager : ClientCredentialsSecurityTokenManager
    {
        StsClientCredentials stsCreds;

        /// <summary>
        /// 
        /// </summary>
        /// <param name="stsCreds"></param>
        public StsTokenManager(StsClientCredentials stsCreds): base(stsCreds)
        {
            this.stsCreds = stsCreds;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="tokenRequirement"></param>
        /// <returns></returns>
        public override SecurityTokenProvider CreateSecurityTokenProvider(SecurityTokenRequirement tokenRequirement)
        {
            return new StsTokenProvider(this.stsCreds.StsToken);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="tokenRequirement"></param>
        /// <param name="outOfBandTokenResolver"></param>
        /// <returns></returns>
        public override SecurityTokenAuthenticator CreateSecurityTokenAuthenticator(SecurityTokenRequirement tokenRequirement, out SecurityTokenResolver outOfBandTokenResolver)
        {
            return base.CreateSecurityTokenAuthenticator(tokenRequirement, out outOfBandTokenResolver);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="version"></param>
        /// <returns></returns>
        public override SecurityTokenSerializer CreateSecurityTokenSerializer(SecurityTokenVersion version)
        {
            //return new System.IdentityModel.Tokens.SamlSerializer();
            return base.CreateSecurityTokenSerializer(version);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup\Monitoring\LiveConnectPing\STS\StsToken.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using System.Security.Cryptography;
using System.Security.Cryptography.Xml;
using System.Security.Cryptography.X509Certificates;
using System.Xml;
using System.Diagnostics;

namespace LiveConnectPing
{
    /// <summary>
    /// 
    /// </summary>
    public class StsToken
    {
        public const string SamlNamespace = "urn:oasis:names:tc:SAML:1.0:assertion";
        public const string ConsoleTokenStsIssuer = "http://xboxlive.com";
        public const string UserTokenStsIssuer = "http://sts.xboxlive.com";
        public const string UserTokenSamlSubject = "XboxLive User security ticket";
        public const string PartnerTokenSamlSubject = "XboxLive Partner security ticket";

        // Token Signing Certificate
        //  this is the cert and associated private key that signs the SAML token
        private X509Certificate2 _certificate = null;
        private string certSubject;
        private object certStoreLock = new object();

        /// <summary>
        /// 
        /// </summary>
        /// <param name="certSubject"></param>
        public StsToken(string certSubject)
        {
            this.certSubject = certSubject;
        }

        /// <summary>
        /// 
        /// </summary>
        public string CertificateSubject
        {
            get
            {
                return this.certSubject;
            }
            set
            {
                this.certSubject = value;
                this._certificate = null;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="players"></param>
        /// <param name="audience"></param>
        /// <param name="machinePuid"></param>
        /// <param name="clientVersion"></param>
        /// <param name="title"></param>
        /// <param name="titleVersion"></param>
        /// <param name="minutesToExpire"></param>
        /// <returns></returns>
        public string GenerateConsoleToken(Player[] players, string audience, ulong machinePuid, uint clientVersion, uint title, uint titleVersion, int minutesToExpire)
        {
            DateTime now = DateTime.UtcNow;
            DateTime expires = now.Add(TimeSpan.FromMinutes(minutesToExpire));

            TextWriter textWriter = new StringWriter();
            XmlTextWriter writer = new XmlTextWriter(textWriter);

            string assertionID = WriteAssertionAttributes(writer, now.ToString("o"));
            WriteConditions(writer, now.ToString("o"), expires.ToString("o"), audience);

            writer.WriteStartElement("AttributeStatement", SamlNamespace);

            writer.WriteStartElement("Subject", SamlNamespace);
            writer.WriteElementString("NameIdentifier", SamlNamespace, string.Format("0x{0:X16}", players[0].Xuid)); // primary Subject is player1, in uppercase hex
            writer.WriteEndElement();

            // Write out machineID claim
            WriteClaim(writer, "PlatformType", string.Format("0x{0:X2}", 0x1)); //PlatformType 1 == Xbox360
            WriteClaim(writer, "MachineID", string.Format("0x{0:X16}", machinePuid));
            WriteClaim(writer, "ClientVersion", string.Format("0x{0:X8}", clientVersion));
            WriteClaim(writer, "TitleID", string.Format("0x{0:X8}", title));
            WriteClaim(writer, "TitleVersion", string.Format("0x{0:X8}", titleVersion));

            // Write out player claims
            for (int i = 0; i < players.Length; i++)
            {
                if (players[i] != null)
                {
                    WriteClaim(writer, String.Format("Xuid{0}", i + 1), string.Format("0x{0:X16}", players[i].Xuid)); //always return uppercase hex
                    WriteClaim(writer, String.Format("Tier{0}", i + 1), string.Format("0x{0:X2}", players[i].Tier));
                    WriteClaim(writer, String.Format("Country{0}", i + 1), string.Format("0x{0:X2}", players[i].Country));
                }
            }

            writer.WriteEndElement(); // AttributeStatement
            writer.WriteEndElement(); // Assertion

            textWriter.Flush();

            XmlDocument document = new XmlDocument();
            document.LoadXml(textWriter.ToString());

            SignXmlViaLocalCert(document, assertionID);

            TraceEx.TraceVerbose("Generated STS Token:\r\n{0}", document.OuterXml);
            return document.OuterXml;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="majorVersion"></param>
        /// <param name="minorVersion"></param>
        /// <param name="issuer"></param>
        /// <param name="notBefore"></param>
        /// <param name="notOnOrAfter"></param>
        /// <param name="audience"></param>
        /// <param name="subject"></param>
        /// <param name="omittedItem"></param>
        /// <returns></returns>
        public string GeneratePartnerToken(
            string majorVersion,
            string minorVersion,
            string issuer,
            string notBefore,
            string notOnOrAfter,
            string audience,
            string subject)
        {
            return GeneratePartnerToken(majorVersion, minorVersion, issuer, notBefore, notOnOrAfter, audience, subject, null);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="majorVersion"></param>
        /// <param name="minorVersion"></param>
        /// <param name="issuer"></param>
        /// <param name="notBefore"></param>
        /// <param name="notOnOrAfter"></param>
        /// <param name="audience"></param>
        /// <param name="subject"></param>
        /// <param name="omittedItem"></param>
        /// <param name="cert"></param>
        /// <param name="exceptionMessage"></param>
        /// <returns></returns>
        public string GeneratePartnerToken(
            string majorVersion,
            string minorVersion,
            string issuer,
            string notBefore,
            string notOnOrAfter,
            string audience,
            string subject,
            X509Certificate2 cert)
        {
            TextWriter textWriter = new StringWriter();
            XmlTextWriter writer = new XmlTextWriter(textWriter);

            string assertionID = WriteAssertionAttributes(writer, majorVersion, minorVersion, issuer, notBefore);
            // write conditions
            WriteConditions(writer, notBefore, notOnOrAfter, audience);

            writer.WriteStartElement("AttributeStatement", SamlNamespace);

            // write subject
            WriteSubject(writer, subject);

            // write the claims
            WriteClaim(writer, "TitleID", "4D5308E2");
            WriteClaim(writer, "TitleVersion", "1");
            WriteClaim(writer, "PartnerID0", "2600292641993623");
            WriteClaim(writer, "Gamertag0", "mpdev2");

            writer.WriteEndElement(); // AttributeStatement
            writer.WriteEndElement(); // Assertion

            textWriter.Flush();

            XmlDocument document = new XmlDocument();
            document.LoadXml(textWriter.ToString());

            SignXmlViaLocalCert(document, assertionID, cert);

            TraceEx.TraceVerbose("Generated Partner STS Token:\r\n{0}", document.OuterXml);
            return document.OuterXml;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="tokenParams"></param>
        /// <returns></returns>
        public string GenerateUserToken(StsTokenParameters tokenParams)
        {
            TraceEx.TraceVerbose("Generating console STS token for xuid0=0x{0}, Title ID=0x{1}, GamerTag={2}, PlatformType={3} good for 4 hours.", tokenParams.Xuid, tokenParams.TitleId.ToString("X8"), tokenParams.GamerTag, tokenParams.PlatformType);
            return GenerateUserToken(
                UserTokenStsIssuer,
                DateTime.Now.ToString("o"),
                DateTime.Now.Add(TimeSpan.FromHours(4)).ToString("o"),
                tokenParams.PlatformType,
                tokenParams.DeviceId,
                tokenParams.ClientVersion,
                tokenParams.TitleId.ToString("X8"),
                tokenParams.TitleVersion,
                tokenParams.Xuid.ToString(),
                tokenParams.GamerTag,
                tokenParams.Tier,
                tokenParams.MachineId.ToString(),
                tokenParams.Puid,
                tokenParams.CID,
                tokenParams.Country,
                tokenParams.Privileges,
                null);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="xuid"></param>
        /// <param name="titleId"></param>
        /// <param name="titleVersion"></param>
        /// <returns></returns>
        public string GenerateUserToken(
            string xuid,
            string titleId,
            string titleVersion)
        {
            return GenerateUserToken(UserTokenStsIssuer, DateTime.Now.ToString("o"), DateTime.Now.Add(TimeSpan.FromHours(4)).ToString("o"), "15", String.Empty, "1", titleId, titleVersion, xuid,
                                String.Empty, String.Empty, null);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="issuer"></param>
        /// <param name="notBefore"></param>
        /// <param name="notOnOrAfter"></param>
        /// <param name="platformType"></param>
        /// <param name="deviceId"></param>
        /// <param name="clientVersion"></param>
        /// <param name="titleId"></param>
        /// <param name="titleVersion"></param>
        /// <param name="xuid"></param>
        /// <param name="gamertag"></param>
        /// <param name="tier"></param>
        /// <param name="omittedItem"></param>
        /// <returns></returns>
        public string GenerateUserToken(
            string issuer,
            string notBefore,
            string notOnOrAfter,
            string platformType,
            string deviceId,
            string clientVersion,
            string titleId,
            string titleVersion,
            string xuid,
            string gamertag,
            string tier)
        {
            return GenerateUserToken(issuer, notBefore, notOnOrAfter, platformType, deviceId, clientVersion, titleId, titleVersion, xuid,
                                gamertag, tier, null);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="issuer"></param>
        /// <param name="notBefore"></param>
        /// <param name="notOnOrAfter"></param>
        /// <param name="platformType"></param>
        /// <param name="deviceId"></param>
        /// <param name="clientVersion"></param>
        /// <param name="titleId"></param>
        /// <param name="titleVersion"></param>
        /// <param name="xuid"></param>
        /// <param name="gamertag"></param>
        /// <param name="tier"></param>
        /// <param name="omittedItem"></param>
        /// <param name="cert"></param>
        /// <returns></returns>
        public string GenerateUserToken(
            string issuer,
            string notBefore,
            string notOnOrAfter,
            string platformType,
            string deviceId,
            string clientVersion,
            string titleId,
            string titleVersion,
            string xuid,
            string gamertag,
            string tier,
            X509Certificate2 cert)
        {
            return GenerateUserToken(issuer, notBefore, notOnOrAfter, platformType, deviceId, clientVersion, titleId, titleVersion, xuid,
                                gamertag, tier, String.Empty, String.Empty, String.Empty, String.Empty, String.Empty, null);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="issuer"></param>
        /// <param name="notBefore"></param>
        /// <param name="notOnOrAfter"></param>
        /// <param name="platformType"></param>
        /// <param name="deviceId"></param>
        /// <param name="clientVersion"></param>
        /// <param name="titleId"></param>
        /// <param name="titleVersion"></param>
        /// <param name="xuid"></param>
        /// <param name="gamertag"></param>
        /// <param name="tier"></param>
        /// <param name="omittedItem"></param>
        /// <param name="cert"></param>
        /// <param name="exceptionMessage"></param>
        /// <returns></returns>
        public string GenerateUserToken(
            string issuer,
            string notBefore,
            string notOnOrAfter,
            string platformType,
            string deviceId,
            string clientVersion,
            string titleId,
            string titleVersion,
            string xuid,
            string gamertag,
            string tier,
            string machineId,
            string puid,
            string cid,
            string country,
            string privledges,
            X509Certificate2 cert)
        {
            TextWriter textWriter = new StringWriter();
            XmlTextWriter writer = new XmlTextWriter(textWriter);

            string assertionID = WriteAssertionAttributes(writer, issuer, notBefore);
            // write conditions
            WriteConditions(writer, notBefore, notOnOrAfter, UserTokenStsIssuer);

            writer.WriteStartElement("AttributeStatement", SamlNamespace);
            // write subject
            WriteSubject(writer, UserTokenSamlSubject);

            // write claims
            WriteClaim(writer, "PlatformType", platformType);

            if (String.IsNullOrEmpty(machineId))
                machineId = Utility.GenerateRandomUInt64().ToString();
            WriteClaim(writer, "MachineID", machineId);

            if (String.IsNullOrEmpty(deviceId))
                deviceId = Utility.GenerateRandomUInt64().ToString();
            WriteClaim(writer, "DeviceID", deviceId);
            
            if (String.IsNullOrEmpty(clientVersion))
                clientVersion = "1";
            WriteClaim(writer, "ClientVersion", clientVersion);
            
            WriteClaim(writer, "TitleID", titleId);
            WriteClaim(writer, "TitleVersion", titleVersion);

            if (String.IsNullOrEmpty(puid))
                puid = Utility.GenerateRandomUInt64().ToString();
            WriteClaim(writer, "Puid0", puid);
        
            if (String.IsNullOrEmpty(cid))
                cid = Utility.GenerateRandomUInt64().ToString();
            WriteClaim(writer, "CID0", cid);
        
            if (String.IsNullOrEmpty(xuid))
                xuid = Utility.GenerateRandomUInt64().ToString();
            WriteClaim(writer, "Xuid0", xuid);
            
            if (String.IsNullOrEmpty(gamertag))
                gamertag = Utility.GenerateRandomGamerTag(10);
            WriteClaim(writer, "Gamertag0", gamertag);
            
            if (String.IsNullOrEmpty(tier))
                tier = "3"; //NOTE: not sure this is a 'great' default value; corresponds to silver acct
            WriteClaim(writer, "Tier0", tier);
            
            WriteClaim(writer, "Country0", "103");  //NOTE: hardcoded for US (103)

            //NOTE: the 'privledge' values were taken from a sample token, for a new, silver XBL account.
            WriteClaim(writer, "Privileges0", "212,220,226,227,228,229,230,231,234,235,237,240,241,243,244,245,246,247,248,249,251,252,254,255");

            writer.WriteEndElement(); // AttributeStatement
            writer.WriteEndElement(); // Assertion

            textWriter.Flush();

            XmlDocument document = new XmlDocument();
            document.LoadXml(textWriter.ToString());

            // sign the token
            SignXmlViaLocalCert(document, assertionID, cert);

            TraceEx.TraceVerbose("Generated User STS Token:\r\n{0}", document.OuterXml);
            return document.OuterXml;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="parameters"></param>
        /// <returns></returns>
        public string GenerateConsoleToken(StsTokenParameters parameters)
        {
            return GenerateConsoleToken(parameters.Xuid, parameters.TitleId, parameters.MachineId, parameters.MinutesToExpire);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="xuid"></param>
        /// <param name="titleId"></param>
        /// <param name="machinePuid"></param>
        /// <param name="minutesToExpire"></param>
        /// <returns></returns>
        public string GenerateConsoleToken(ulong xuid, uint titleId, ulong machinePuid, int minutesToExpire)
        {
            TraceEx.TraceVerbose("Generating console STS token for xuid0=0x{0}, Title ID=0x{1}, MachinePUID={2}, good for {3} minutes.", xuid.ToString("X16"), titleId.ToString("X8"), machinePuid.ToString("X16"), minutesToExpire);
            //103=US, 6=Gold
            Player player1 = new Player() { Xuid = xuid, Country = 103, Tier = 6 };

            //random machine puid, hard-coded client version, random title version
            return GenerateConsoleToken(new Player[] { player1 }, ConsoleTokenStsIssuer, machinePuid, 0x25223C00, titleId, Utility.GenerateRandomUInt32(), minutesToExpire);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="notBefore"></param>
        /// <param name="assertionID"></param>
        private static string WriteAssertionAttributes(XmlTextWriter writer, string notBefore)
        {
            return WriteAssertionAttributes(writer, "1", "1", UserTokenStsIssuer, notBefore);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="issuer"></param>
        /// <param name="notBefore"></param>
        /// <param name="OmittedUserTokenItems"></param>
        /// <param name="assertionID"></param>
        private static string WriteAssertionAttributes(XmlTextWriter writer, string issuer, string notBefore)
        {
            return WriteAssertionAttributes(writer, "1", "1", issuer, notBefore);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="majorVersion"></param>
        /// <param name="minorVersion"></param>
        /// <param name="issuer"></param>
        /// <param name="notBefore"></param>
        /// <param name="OmittedPartnerTokenItems"></param>
        /// <param name="OmittedUserTokenItems"></param>
        /// <param name="assertionID"></param>
        private static string WriteAssertionAttributes(
            XmlTextWriter writer,
            string majorVersion,
            string minorVersion,
            string issuer,
            string notBefore)
        {
            string assertionID = string.Format("SamlSecurityToken-{0}", Guid.NewGuid().ToString());

            writer.WriteProcessingInstruction("xml", "version='1.0' encoding='utf-16'");
            writer.WriteStartElement("saml", "Assertion", SamlNamespace);
            writer.WriteAttributeString("MajorVersion", majorVersion);
            writer.WriteAttributeString("MinorVersion", minorVersion);
            writer.WriteAttributeString("AssertionID", assertionID);

            writer.WriteAttributeString("Issuer", issuer);

            DateTime dateTimeNotBefore;
            if ((DateTime.TryParse(notBefore, out dateTimeNotBefore)) && (dateTimeNotBefore < DateTime.Now))
            {
                writer.WriteAttributeString("IssueInstant", dateTimeNotBefore.ToUniversalTime().ToString("o"));
            }
            else
                writer.WriteAttributeString("IssueInstant", DateTime.UtcNow.ToString("o"));

            return assertionID;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="notBefore"></param>
        /// <param name="notOnOrAfter"></param>
        /// <param name="audience"></param>
        /// <param name="OmittedPartnerTokenItems"></param>
        /// <param name="OmittedUserTokenItems"></param>
        private static void WriteConditions(XmlTextWriter writer, string notBefore, string notOnOrAfter, string audience)
        {
            writer.WriteStartElement("Conditions", SamlNamespace);
            writer.WriteAttributeString("NotBefore", notBefore);
            writer.WriteAttributeString("NotOnOrAfter", notOnOrAfter);
            writer.WriteStartElement("AudienceRestrictionCondition", SamlNamespace);
            writer.WriteElementString("Audience", SamlNamespace, audience);

            writer.WriteEndElement(); //AudienceRestrictionCondition
            writer.WriteEndElement(); // Conditions
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="subject"></param>
        private static void WriteSubject(XmlTextWriter writer, string subject)
        {
            writer.WriteStartElement("Subject", SamlNamespace);
            writer.WriteStartElement("NameIdentifier", SamlNamespace);
            writer.WriteAttributeString("Format", "/xboxlive/nameFormat");
            writer.WriteAttributeString("NameQualifier", "Microsoft-NameQualifier-domain");
            writer.WriteString(subject);
            writer.WriteEndElement(); // NameIdentifier
            writer.WriteEndElement(); // subject
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="claim"></param>
        /// <param name="value"></param>
        private static void WriteClaim(XmlTextWriter writer, string claim, string value)
        {
            writer.WriteStartElement("Attribute", SamlNamespace);
            writer.WriteAttributeString("AttributeName", claim);
            writer.WriteAttributeString("AttributeNamespace", "http://xboxlive.com/claims");
            writer.WriteElementString("AttributeValue", SamlNamespace, value);
            writer.WriteEndElement();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="document"></param>
        /// <param name="assertionID"></param>
        private void SignXmlViaLocalCert(XmlDocument document, string assertionID)
        {
            SignXmlViaLocalCert(document, assertionID, null);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="document"></param>
        /// <param name="assertionID"></param>
        /// <param name="cert"></param>
        /// <param name="exceptionMessage"></param>
        private void SignXmlViaLocalCert(XmlDocument document, string assertionID, X509Certificate2 cert)
        {
            // grab the cert so we don't have a race condition with it changing during a reload
            // we need this because we access the cert twice in this function and don't want to take a lock... but need to stay consistant
            X509Certificate2 signingCertificate;

            if (cert == null)
                signingCertificate = GetCertificate();
            else
                signingCertificate = cert;

            try
            {
                // Create a CustomSignedXml object.  
                // The CustomSigendXml object lets us change what attribute is used to find the node to sign.
                // The standard SignedXml signs the node identified by the attribute named 'id'.
                // We need to sign the node identified by the attribute named 'AssertionID'. 
                CustomSignedXml signedXml = new CustomSignedXml(document);
                signedXml.SignedInfo.CanonicalizationMethod = SignedXml.XmlDsigExcC14NTransformUrl;
                signedXml.SigningKey = (RSACryptoServiceProvider)signingCertificate.PrivateKey;

                // Create a reference which tells SignedXml what node to sign
                Reference reference = new Reference();
                reference.Uri = "#" + assertionID;

                // Add an enveloped transformation to the reference.
                XmlDsigEnvelopedSignatureTransform transform1 = new XmlDsigEnvelopedSignatureTransform();
                reference.AddTransform(transform1);

                XmlDsigExcC14NTransform transform2 = new XmlDsigExcC14NTransform();
                reference.AddTransform(transform2);

                // Add the reference to the SignedXml object.
                signedXml.AddReference(reference);

                // add key info
                KeyInfo keyInfo = new KeyInfo();
                keyInfo.AddClause(new KeyInfoX509Data(signingCertificate));
                signedXml.KeyInfo = keyInfo;

                // Compute the signature.
                signedXml.ComputeSignature();

                // Get the XML representation of the signature and save
                // it to an XmlElement object.
                XmlElement xmlDigitalSignature = signedXml.GetXml();

                // Append the element to the XML document.
                document.DocumentElement.AppendChild(document.ImportNode(xmlDigitalSignature, true));
            }
            catch (Exception e)
            {
                throw new ApplicationException(String.Format("Error signing SAML token with certificate '{0}'; {1}", cert.Subject, e.Message), e);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        private X509Certificate2 GetCertificate()
        {
            lock (certStoreLock)
            {
                X509Certificate2 certificate = this._certificate;

                // do I have a cert
                if (certificate != null)
                    return certificate;

                string subject = this.CertificateSubject;
                X509Store store = new X509Store(StoreName.My, StoreLocation.LocalMachine);
                store.Open(OpenFlags.ReadOnly);

                try
                {
                    // Find the certificate that matches the subject
                    X509Certificate2Collection matches = store.Certificates.Find(X509FindType.FindBySubjectName, subject, false);
                    if (matches == null || matches.Count == 0)
                        throw new ApplicationException(String.Format("No certificates with subject {0} were found in the specified store", subject));
                    if (matches.Count > 1)
                        throw new ApplicationException(String.Format("Multiple certificates with subject {0} were found in the specified store", subject));
                    if (!matches[0].HasPrivateKey)
                        throw new ApplicationException(String.Format("Certificate with subject {0} doesn't have a private key", subject));
                    _certificate = certificate = matches[0];
                }
                finally
                {
                    if (store != null)
                        store.Close();
                }
                return certificate;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup1\LCWebService\MessageInterceptor.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.ServiceModel.Dispatcher;
using System.ServiceModel.Description;
using System.ServiceModel;
using System.Collections.ObjectModel;
using System.ServiceModel.Channels;
using System.IO;

namespace LiveConnectWeb
{
    class MessageInterceptor : IDispatchMessageInspector, IServiceBehavior
    {
        DateTime timeToCheckSiteClosed;
        bool isUpdating = false;
        string siteClosedFileName;

        public MessageInterceptor()
        {
            timeToCheckSiteClosed = DateTime.Now;
            siteClosedFileName = System.Web.Hosting.HostingEnvironment.ApplicationPhysicalPath + "site.closed";
        }

        public object AfterReceiveRequest(ref System.ServiceModel.Channels.Message request, IClientChannel channel, InstanceContext instanceContext)
        {
            if (timeToCheckSiteClosed < DateTime.Now)
            {
                isUpdating = File.Exists(siteClosedFileName);
                timeToCheckSiteClosed = DateTime.Now + TimeSpan.FromSeconds(30);
            }

            // DeploymentStatus is just a static class, used throughout the project  web or otherwise  indicate the state of the site
            if (isUpdating)
            {
                throw new FaultException("Service is temporarily unavailable");
            }

            return null;
        }

        public void BeforeSendReply(ref System.ServiceModel.Channels.Message reply, object correlationState)
        {
        }

        public void ApplyDispatchBehavior(
            ServiceDescription desc, ServiceHostBase host)
        {
            foreach (
                ChannelDispatcher cDispatcher in host.ChannelDispatchers)
                foreach (EndpointDispatcher eDispatcher in
                    cDispatcher.Endpoints)
                    eDispatcher.DispatchRuntime.MessageInspectors.Add(
                        new MessageInterceptor());
        }

        public void AddBindingParameters(
            ServiceDescription serviceDescription,
            ServiceHostBase serviceHostBase,
            Collection<ServiceEndpoint> endpoints,
            BindingParameterCollection bindingParameters
        )
        {
            return;
        }

        public void Validate(
            ServiceDescription serviceDescription,
            ServiceHostBase serviceHostBase
        )
        {
            return;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup1\LCWebService\NetworkMapper.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Configuration;

namespace LiveConnectWeb
{
    internal abstract class NetworkMapper
    {
        protected NetworkMapper(string Key)
        {
            this.key = Key;
            key += ";";
        }

        internal void LoadFromConfig()
        {
            for (int i = 0; i < ConfigurationManager.AppSettings.Count; i++)
            {
                if (ConfigurationManager.AppSettings.GetKey(i).StartsWith(key))
                {
                    bool[] networks = new bool[MaxNetworks];

                    SetAllowedNetworks(ConfigurationManager.AppSettings[i], ref networks);

                    entries.Add(
                        ConfigurationManager.AppSettings.GetKey(i).Substring(key.Length, ConfigurationManager.AppSettings.GetKey(i).Length - key.Length).ToLower(),
                        networks);
                }
                else if (ConfigurationManager.AppSettings.GetKey(i).Equals("NumberOfNetworks"))
                {
                    ushort numNetworks = 0;

                    if (ushort.TryParse(ConfigurationManager.AppSettings[i], out numNetworks))
                    {
                        MaxNetworks = numNetworks;
                    }
                }
            }
        }

        internal bool IsEntryAllowed(ushort networkId, string entryId)
        {
            bool[] networks;

            if (networkId > MaxNetworks || entryId.Length == 0)
            {
                return false;
            }

            if (entries.TryGetValue(entryId.ToLower(), out networks))
            {
                return networks[networkId];
            }

            return false;
        }

        private void SetAllowedNetworks(string networkList, ref bool[] networks)
        {
            int first = 0, second = 0, network;
            bool done = false;

            if (networkList == null || networks == null || networkList.Length < 1 || networks.Length < 1)
            {
                return;
            }

            second = networkList.IndexOf(',', first);

            do
            {
                if (second == -1)
                {
                    second = networkList.Length;
                    done = true;
                }

                network = 0;
                if (int.TryParse(networkList.Substring(first, second - first), out network) && network <= networks.Length && network > 0)
                {
                    networks[network] = true;
                }

                if (!done)
                {
                    first = ++second;
                    second = networkList.IndexOf(',', first);
                }
            } while (!done);
        }

        internal ushort MaxNumNetworks { get { return MaxNetworks; } }

        protected ushort MaxNetworks = 5;
        private Dictionary<string, bool[]> entries = new Dictionary<string, bool[]>();
        private string key;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup1\LCWebService\ServiceFactory.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.ServiceModel.Activation;
using System.ServiceModel;

namespace LiveConnectWeb
{
    public class ServiceFactory : ServiceHostFactory
    {
        public override ServiceHostBase CreateServiceHost(string service, Uri[] baseAddresses)
        {
            ServiceHost serviceHost;

            serviceHost = new ServiceHost(typeof(LiveConnectWeb.LiveConnect), baseAddresses);
            serviceHost.Opening += new EventHandler(LiveConnect.Opening);

            serviceHost.Description.Behaviors.Add(new MessageInterceptor());

            return serviceHost;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup1\LCWebService\Smoke.aspx.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Globalization;
using System.Net;
using System.IO;
using System.Diagnostics;

/// <summary>
/// Summary description for Smoke.
/// </summary>
public partial class Smoke : System.Web.UI.Page
{
    private static string buildNumber;
    private static object buildLock = new object();

    /// <summary>
    /// 
    /// </summary>
    private string BuildNumber
    {
        get
        {
            if (buildNumber == null)
            {
                lock (buildLock)
                {
                    if (buildNumber == null)
                    {
                        buildNumber = typeof(LiveConnectWeb.LiveConnect).Assembly.GetName().Version.ToString();
                    }
                }
            }

            return buildNumber;
        }
    }

    /// <summary>
    /// 
    /// </summary>
    protected void DoSmokeTests()
    {
        bool result = true;
        result &= WriteHeaderInfo();
        result &= DoSqlStatementTest();
        //result &= DoStoredProcTest();
        
        if (!result)
            this.Response.StatusCode = 500; //one or more tests failed
    }


    /// <summary>
    /// 
    /// </summary>
    private bool WriteHeaderInfo()
    {
        try
        {
            Response.Write("<h2>Site Info</h2><br/>");
            string machineName = Environment.MachineName;
            if (machineName.Length < 5)
                machineName = "###";
            else
                machineName = machineName.Substring(0, 1) + "####" + machineName.Substring(machineName.Length - 4);
            Response.Write("Host: " + machineName + "<br/>");
            Response.Write(String.Format("{0}<br/>", BuildNumber));
            return true;
        }
        catch (Exception ex)
        {
            Response.Write(ex.ToString() + "<br/><br/>");
            return false;
        }
    }

    /// <summary>
    /// 
    /// </summary>
    /// <returns></returns>
    private bool DoSqlStatementTest()
    {
        try
        {
            Response.Write("<h2>Accessing DB</h2><br/>");
            Response.Write("<strong>SQL Statements:</strong><br/>");
            
            using(SqlConnection connection = new SqlConnection(System.Configuration.ConfigurationManager.ConnectionStrings["LiveConnect"].ConnectionString))
            using(SqlCommand command = new SqlCommand("SELECT * FROM NetworkInfo (nolock)", connection))
            {
            	connection.Open();
		using(SqlDataReader reader = command.ExecuteReader())
		{
			while(reader.Read())
			{
				Response.Write(String.Format("{0}, {1}, {2}<br/>", reader["SNetworkId"], reader["Description"], reader["Logo"]));
			}
		}
	    }
	    	    
            Response.Write("OK<br/><br/>");           
            return true;
        }
        catch (Exception ex)
        {
            Response.Write(ex.ToString() + "<br/><br/>");
            return false;
        }
    }

    /// <summary>
    /// 
    /// </summary>
    /// <returns></returns>
    /*private bool DoStoredProcTest()
    {
        try
        {
            Response.Write("<strong>Stored Procedures:</strong><br/>");
            using(SqlConnection connection = new SqlConnection("Persist Security Info=False;Integrated Security=SSPI;database=LiveConnect;server=LEOSQL"))
	    using(SqlCommand command = new SqlCommand("SELECT * FROM NetworkInfo (nolock)", connection))
	    {
	    	using(SqlDataReader reader = command.ExecuteReader())
	    	{
			while(reader.Read())
			{
				Response.Write(String.Format("{0}, {1}, {2}", reader["SNetworkId"], reader["Description"], reader["Logo"]));
			}
		}
	    }
            Response.Write("OK<br/><br/>");
            return true;
        }
        catch (Exception ex)
        {
            Response.Write(ex.ToString() + "<br/><br/>");
            return false;
        }
    }    */
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup1\LCWebService\SNAuthInfo.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Runtime.Serialization;

namespace LiveConnectWeb
{
    [DataContract]
    public class SNAuthInfo
    {
        string snUserId;
        string token;

        [DataMember]
        public string SNUserID
        {
            get
            {
                return snUserId;
            }

            set
            {
                snUserId = value;
            }
        }

        [DataMember]
        public string Token
        {
            get
            {
                return token;
            }

            set
            {
                token = value;
            }
        }

        public override string ToString()
        {
            return String.Format("SNUserID={0}, Token={1}", this.snUserId, this.token);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup\Monitoring\LiveConnectPing\STS\StsTokenParameters.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace LiveConnectPing
{
    /// <summary>
    /// 
    /// </summary>
    public class StsTokenParameters
    {
        /// <summary>
        /// 
        /// </summary>
        public StsTokenParameters()
        {
            //default to regular STS value of 60 mins for a valid token
            this.MinutesToExpire = 60;
            //only the Authentication interface calls (that use deviceId) need to make sure this value is in sync w/ the test
            this.MachineId = Utility.GenerateRandomUInt64();
        }

        /// <summary>
        /// 
        /// </summary>
        public ulong Xuid
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public uint TitleId
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string TitleVersion
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public ulong MachineId
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string DeviceId
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string ClientVersion
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string PlatformType
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string Puid
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string CID
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string GamerTag
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string Tier
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string Country
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string Privileges
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public int MinutesToExpire
        {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup1\LCWebService\SNInfo.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Runtime.Serialization;

namespace LiveConnectWeb
{
    [DataContract]
    public class SNetworkInfo
    {
        string description;
        string logo;
        uint networkId;

        [DataMember]
        public string Description
        {
            get
            {
                return description;
            }

            set
            {
                description = value;
            }
        }

        [DataMember]
        public string Logo
        {
            get
            {
                return logo;
            }

            set
            {
                logo = value;
            }
        }

        [DataMember]
        public uint Id
        {
            get
            {
                return networkId;
            }

            set
            {
                networkId = value;
            }
        }

        public override string ToString()
        {
            return String.Format("{0} (ID={1}) - {2}", this.Description, this.Id, this.Logo);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup1\LCWebService\SNUserInfo.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Runtime.Serialization;

namespace LiveConnectWeb
{
    [DataContract]
    public enum Visibility
    {
        [EnumMember] Me,
        [EnumMember] Everyone
    };

    [DataContract]
    public partial class SNUserInfo
    {
        string snUserId;
        string gamerTag;
        ulong xuid;
        Visibility visibility;

        [DataMember]
        public ulong XUID
        {
            get
            {
                return xuid;
            }
            set
            {
                xuid = value;
            }
        }

        [DataMember]
        public string GamerTag
        {
            get
            {
                return gamerTag;
            }

            set
            {
                gamerTag = value;
            }
        }

        [DataMember]
        public string SNUserID 
        { 
            get
            {
                return snUserId;
            }

            set
            {
                snUserId = value;
            }
        }

        [DataMember]
        public Visibility Visibility 
        {
            get
            {
                return visibility;
            }

            set
            {
                visibility = value;
            }
        }

        public override string ToString()
        {
            return ToString("\r\n");
        }

        public string ToString(string delimiter)
        {
            return String.Format("XUID={0}{4}GamerTag={1}{4}SNUserID={2}{4}Visibility={3}",
                                    this.xuid.ToString("X16"),
                                    this.gamerTag,
                                    this.snUserId,
                                    this.visibility,
                                    delimiter);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup\Monitoring\LiveConnectPing\WCF\StsTokenProvider.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IdentityModel;
using System.IdentityModel.Selectors;
using System.IdentityModel.Tokens;
using System.Xml;

namespace LiveConnectPing
{
    /// <summary>
    /// 
    /// </summary>
    public class StsTokenProvider: SecurityTokenProvider
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="stsToken"></param>
        public StsTokenProvider(string stsToken)
        {
            this.StsToken = stsToken;
        }

        /// <summary>
        /// 
        /// </summary>
        public string StsToken
        {
            get;
            private set;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="timeout"></param>
        /// <returns></returns>
        protected override SecurityToken GetTokenCore(TimeSpan timeout)
        {
            XmlDocument samlXml = new XmlDocument();

            try
            {
                samlXml.LoadXml(this.StsToken);
            }
            catch (XmlException e)
            {
                throw new ApplicationException("the specified STS token is invalid Xml.", e);
            }
            
            SecurityToken securityToken = new GenericXmlSecurityToken(samlXml.DocumentElement, null, DateTime.MinValue, DateTime.MaxValue, null, null, null);
            return securityToken;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup1\LCWebService\TitleNetworkMapper.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Configuration;

namespace LiveConnectWeb
{
    internal sealed class TitleNetworkMapper : NetworkMapper
    {
        private static readonly TitleNetworkMapper instance = new TitleNetworkMapper("TitleId");

        private TitleNetworkMapper(string key)
            : base(key)
        {
        }

        internal static TitleNetworkMapper Instance
        {
            get
            {
                return instance;
            }
        }

        internal bool IsTitleAllowed(ushort networkId, string titleId)
        {
            return base.IsEntryAllowed(networkId, titleId);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup1\LCWebService\X509ClientInfo.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.ServiceModel;
using System.Security.Principal;

namespace LiveConnectWeb
{
    internal class X509ClientInfo
    {
        internal static X509ClientInfo GetFromOperationContext()
        {
            X509ClientInfo clientInfo = null;
            char[] deliminator = {';'};

                if (OperationContext.Current.ServiceSecurityContext.PrimaryIdentity.AuthenticationType.CompareTo("X509") == 0)
                {
                    string[] values = OperationContext.Current.ServiceSecurityContext.PrimaryIdentity.Name.Split(deliminator);

                    if (values.Length == 2)
                    {
                        clientInfo = new X509ClientInfo();

                        clientInfo.Subject = CertNetworkMapper.Instance.NormalizeSubject(values[0]);

                        clientInfo.Thumbprint = values[1];
                    }
                }

                return clientInfo;
        }

        internal string Subject { get; private set; }
        internal string Thumbprint { get; private set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup\Monitoring\LiveConnectPing\WCF\StsClientCredentials.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.ServiceModel;
using System.ServiceModel.Description;
using System.IdentityModel.Selectors;

namespace LiveConnectPing
{
    /// <summary>
    /// 
    /// </summary>
    public class StsClientCredentials: ClientCredentials
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="stsToken"></param>
        public StsClientCredentials(string stsToken): base()
        {
            this.StsToken = stsToken;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="other"></param>
        protected StsClientCredentials(StsClientCredentials other)
            : base(other)
        {
            this.StsToken = other.StsToken;
        }

        /// <summary>
        /// 
        /// </summary>
        public string StsToken
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public override SecurityTokenManager CreateSecurityTokenManager()
        {
            return new StsTokenManager(this);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        protected override ClientCredentials CloneCore()
        {
            return new StsClientCredentials(this);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup1\LCWebService\XBoxClientInfo.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.ServiceModel;
using System.IdentityModel.Tokens;
using System.Globalization;

namespace LiveConnectWeb
{
    public class XBoxClientInfo
    {
        internal ushort Platform {get; private set;}
        internal string MachineId { get; private set; }
        internal uint ClientVersion { get; private set; }
        internal string TitleId { get; private set; }
        internal uint TitleVersion { get; private set; }
        internal ulong Xuid { get; private set; }
        internal ushort Tier { get; private set; }
        internal ushort Country { get; private set; }

        public static XBoxClientInfo GetFromSamlToken()
        {
            XBoxClientInfo clientInfo = null;

            if (OperationContext.Current.IncomingMessageProperties.Security.IncomingSupportingTokens.Count != 1)
            {
                return null;
            }
            
            SamlSecurityToken token = OperationContext.Current.IncomingMessageProperties.Security.IncomingSupportingTokens[0].SecurityToken as SamlSecurityToken;

            if (token != null)
            {
                SamlAttributeStatement statement = token.Assertion.Statements[0] as SamlAttributeStatement;

                if (statement != null)
                {
                    clientInfo = new XBoxClientInfo();

                    string machineId = statement.Attributes.First(attibute =>
                                attibute.Namespace == "http://xboxlive.com/claims"
                                && attibute.Name == "MachineID").AttributeValues[0].Replace("0x", "");

                    clientInfo.MachineId = ulong.Parse(machineId, NumberStyles.HexNumber).ToString();

                    string clientVersion = statement.Attributes.First(attibute =>
                                attibute.Namespace == "http://xboxlive.com/claims"
                                && attibute.Name == "ClientVersion").AttributeValues[0].Replace("0x", "");

                    clientInfo.ClientVersion = uint.Parse(clientVersion, NumberStyles.HexNumber);

                    clientInfo.TitleId = statement.Attributes.First(attibute =>
                                            attibute.Namespace == "http://xboxlive.com/claims"
                                            && attibute.Name == "TitleID").AttributeValues[0].Replace("0x", "");

                    string titleVersion = statement.Attributes.First(attibute =>
                                attibute.Namespace == "http://xboxlive.com/claims"
                                && attibute.Name == "TitleVersion").AttributeValues[0].Replace("0x", "");

                    clientInfo.TitleVersion = uint.Parse(titleVersion, NumberStyles.HexNumber);

                    string xuid = statement.Attributes.First(attibute =>
                                attibute.Namespace == "http://xboxlive.com/claims"
                                && attibute.Name == "Xuid1").AttributeValues[0].Replace("0x", "");

                    clientInfo.Xuid = ulong.Parse(xuid, NumberStyles.HexNumber);

                    string tier = statement.Attributes.First(attibute =>
                                attibute.Namespace == "http://xboxlive.com/claims"
                                && attibute.Name == "Tier1").AttributeValues[0].Replace("0x", "");

                    clientInfo.Tier = ushort.Parse(tier, NumberStyles.HexNumber);

                    string country = statement.Attributes.First(attibute =>
                                attibute.Namespace == "http://xboxlive.com/claims"
                                && attibute.Name == "Country1").AttributeValues[0].Replace("0x", "");

                    clientInfo.Country = ushort.Parse(country, NumberStyles.HexNumber);
                }
            }

            return clientInfo;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup1\LCWebService\LiveConnectCache.cs ===
using System;
using System.Text;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Data.Linq;
using System.Xml.Linq;

namespace LiveConnectWeb
{
    public class LiveConnectCache
    {
        private const string Snuids = "Snuids";
        private const string Snuid = "id";

        internal string ConnectionString
        {
            get
            {
                LiveConnectDataContext db = new LiveConnectDataContext();

                return db.Connection.ConnectionString;
            }
        }

        //This function removes the pairing from both the authentication table and the user table
        public void RemoveSNUserInfoByXUID(ushort sNetworkId, ulong XUID)
        {
            using (LiveConnectDataContext db = new LiveConnectDataContext())
            {
                int retVal = db.spRemoveUserInfo((short)sNetworkId, (long)XUID);

                //TODO: Add correct exception when error handling story is in place
                if (retVal != 0)
                {
                    throw new Exception();
                }
            }
        }

        public SNUserInfo GetSNUserInfoByXUID(ushort sNetworkId, ulong XUID)
        {
            using (LiveConnectDataContext db = new LiveConnectDataContext())
            {
                Directory directoryEntry = db.Directories.SingleOrDefault(record => record.XUID == (long)XUID && record.SNetworkId == sNetworkId);

                if (directoryEntry == null)
                {
                    return null;
                }

                return GetSNUserInfoFromRecord(directoryEntry);
            }
        }

        public SNUserInfo GetSNUserInfoBySNUId(ushort sNetworkId, string snUserId)
        {
            using (LiveConnectDataContext db = new LiveConnectDataContext())
            {
                Directory directoryEntry = db.Directories.SingleOrDefault(record => record.SNetworkId == sNetworkId && record.SNUserId == snUserId);

                if (directoryEntry == null)
                {
                    return null;
                }

                return GetSNUserInfoFromRecord(directoryEntry);
            }
        }

        private static SNUserInfo GetSNUserInfoFromRecord(Directory directoryEntry)
        {
            //TODO: Change this to a stored proc and add a call to update the LastAccessedTime
            return new SNUserInfo()
            {
                SNUserID = directoryEntry.SNUserId,
                XUID = (ulong)directoryEntry.XUID,
                GamerTag = directoryEntry.GamerTag,
                Visibility = (Visibility)directoryEntry.Flags
            };
        }

        public void SetSNUserInfo(ushort sNetworkId, SNUserInfo userInfo, ulong realXuid)
        {
            using (LiveConnectDataContext db = new LiveConnectDataContext())
            {
                int flags = 0;

                if (userInfo.Visibility == Visibility.Everyone)
                {
                    flags = 1;
                }

                int retVal = db.spSetAuthAndUserInfo((short)sNetworkId, (long)realXuid, userInfo.SNUserID, userInfo.GamerTag, null, null, flags, 1);

                //TODO: Add correct exception when error handling story is in place
                if (retVal != 0)
                {
                    throw new Exception();
                }
            }
        }

        public SNetworkInfo GetSNetworkInfo(ushort sNetworkId)
        {
            using (LiveConnectDataContext db = new LiveConnectDataContext())
            {

                NetworkInfo networkInfo = db.NetworkInfos.SingleOrDefault(record => record.SNetworkId == sNetworkId);

                if (networkInfo == null)
                {
                    return null;
                }

                return GetNetworkInfoFromRecord(networkInfo);
            }
        }

        public SNetworkInfo[] GetSNetworkInfos()
        {
            LiveConnectDataContext db = new LiveConnectDataContext();
            List<SNetworkInfo> networkList = new List<SNetworkInfo>();

            foreach (NetworkInfo networkInfo in db.NetworkInfos)
            {
                SNetworkInfo sni = new SNetworkInfo();

                sni.Description = networkInfo.Description;
                sni.Id = (uint)networkInfo.SNetworkId;
                sni.Logo = networkInfo.Logo;

                networkList.Add(sni);
            }

            return networkList.ToArray();
        }

        SNetworkInfo GetNetworkInfoFromRecord(NetworkInfo networkInfo)
        {
            return new SNetworkInfo()
            {
                Description = networkInfo.Description,
                Logo = networkInfo.Logo,
                Id = (uint)networkInfo.SNetworkId
            };
        }

        public void SetAuthInfo(ushort sNetworkId, ulong XUID, string gamerTag, string deviceId, SNAuthInfo userInfo, bool addToDirectory, Visibility visibility)
        {
            using (LiveConnectDataContext db = new LiveConnectDataContext())
            {
                int flags = 0;

                if (
                    gamerTag.Length <= 0 ||
                    deviceId.Length <= 0 ||
                    userInfo == null ||
                    XUID == 0 ||
                    userInfo.Token.Length <= 0 ||
                    userInfo.SNUserID.Length <= 0)
                {
                    throw new ArgumentException();
                }

                //We always add to the directory but default to private
                //Ignore visibility if adding to the directory was not specified
                if (visibility == Visibility.Everyone && addToDirectory)
                {
                    flags = 1;
                }

                int retVal = db.spSetAuthAndUserInfo((short)sNetworkId, (long)XUID, userInfo.SNUserID, gamerTag, userInfo.Token, deviceId, flags, 0);

                //TODO: Add correct exception when error handling story is in place
                if (retVal != 0)
                {
                    throw new Exception();
                }
            }
       }

        public SNAuthInfo GetAuthInfo(ushort sNetworkId, ulong XUID, string deviceId)
        {
            using (LiveConnectDataContext db = new LiveConnectDataContext())
            {

                Authentication authEntry = db.Authentications.SingleOrDefault(record => record.XUID == (long)XUID && record.SNetworkId == sNetworkId && record.DeviceId == deviceId);

                if (authEntry == null)
                {
                    return null;
                }

                return GetAuthInfoFromRecord(authEntry);
            }
        }

        private static SNAuthInfo GetAuthInfoFromRecord(Authentication authEntry)
        {
            return new SNAuthInfo()
            {
                SNUserID = authEntry.SNUserId,
                Token = authEntry.Token
            };
        }

        public SNUserInfo[] GetSNUserInfos(ushort sNetworkId, string[] sNUserIDs)
        {
            List<SNUserInfo> snUserInfos = new List<SNUserInfo>();

            using (LiveConnectDataContext db = new LiveConnectDataContext())
            {
                XElement xmlSnuidList = ConvertSnuidsToXml(sNUserIDs);

                using (ISingleResult<spGetXUIDSResult> xuidResults = db.spGetXUIDSEx((int)sNetworkId, xmlSnuidList))
                {
                    foreach (spGetXUIDSResult xuidResult in xuidResults)
                    {
                        SNUserInfo tmp;

                        tmp = new SNUserInfo();

                        tmp.XUID = (ulong)xuidResult.XUID;
                        tmp.SNUserID = xuidResult.SNUserId.ToString();
                        tmp.Visibility = (Visibility)xuidResult.Flags;
                        tmp.GamerTag = xuidResult.GamerTag;

                        snUserInfos.Add(tmp);
                    }
                }

                return snUserInfos.ToArray();
            }
        }

        //This nulls out the token and device but does not remove the user pairing
        public void RemoveAuthInfo(ushort sNetworkId, ulong XUID, string deviceId)
        {
            using (LiveConnectDataContext db = new LiveConnectDataContext())
            {
                int retVal = db.spRemoveSNAuthInfo((short)sNetworkId, (long)XUID);

                //TODO: Add correct exception when error handling story is in place
                if (retVal != 0)
                {
                    throw new Exception();
                }
            }
        }

        private static XElement ConvertSnuidsToXml(string[] sNUserIDs)
        {
            XElement root = new XElement(LiveConnectCache.Snuids);
            
            foreach (string snuid in sNUserIDs)
            {
                XElement newNode = new XElement(LiveConnectCache.Snuid, snuid);
                root.Add(newNode);
            }

            return root;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup1\LCWebService\test\ILiveConnectTest.cs ===
using System;
using System.ServiceModel;

namespace LiveConnectWeb.Test
{
    /// <summary>
    /// 
    /// </summary>
    [ServiceContract]
    [XmlSerializerFormat]
    public interface ILiveConnectTest
    {
        [OperationContract]
        void AddDirectoryInfo(ushort socialNetworkID, ulong xuid, string snUserID, string gamerTag, Visibility visibility);

        [OperationContract]
        void AddAuthInfo(ushort socialNetworkID, ulong xuid, string snUserID, string authToken, string deviceID);

        [OperationContract]
        int ExecuteSql(string sql);

        [OperationContract]
        string ExecuteSqlDataSet(string sql);

        //Methods to generate STS tokens
        [OperationContract]
        string GetStsToken(Player[] players, string audience, ulong machinePuid, uint clientVersion, uint title, uint titleVersion, int minutesToExpire);

        [OperationContract]
        string GetSimpleStsToken(ulong xuid, uint titleId, ulong machinePuid, int minutesToExpire);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup1\LCWebService\test\CustomSignedXml.cs ===
using System;
using System.Collections.Generic;
using System.Web;
using System.Xml;
using System.Xml.Serialization;
using System.Security.Cryptography;
using System.Security.Cryptography.Xml;


namespace LiveConnectWeb.Test
{

    // http://blogs.msdn.com/shawnfa/archive/2004/04/05/108098.aspx
    // Searching for Custom ID Tags With Signed XML
    // Excerpt... The biggest limitation with doing this is that you must refer to the nodes that are being signed by ID, 
    // which for v1.1 and 1.0 of the framework was given by an attribute named "Id". The problem there is that 
    // the Id attribute may already have another use in your schema, and you cannot reuse them for creating node names. 
    // Another problem that may come up is that the XML being signed may be generated by a tool or program, 
    // and it's not possible for you to add Id tags. Whidbey reduces this limitation somewhat by also allowing 
    // "id" and "ID", but the fundamental problem still exists.

    // Nodes that are being referred to by ID are resolved in the GetIdElement method of the SignedXml class. 
    // By subclassing SignedXml and overriding this method, its possible to create your own id node resolver. 


    public class CustomSignedXml : SignedXml
    {
        public CustomSignedXml(XmlDocument doc) :
            base(doc)
        {
        }

        public override XmlElement GetIdElement(XmlDocument doc, string id)
        {
            // check to see if it's a standard ID reference
            XmlElement idElem = base.GetIdElement(doc, id);
            if (idElem != null)
                return idElem;

            idElem = doc.SelectSingleNode("//*[@AssertionID=\"" + id + "\"]") as XmlElement;
            return idElem;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup1\LCWebService\test\Player.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace LiveConnectWeb.Test
{
    public class Player
    {
        public ulong Xuid
        {
            get;
            set;
        }

        public byte Tier
        {
            get;
            set;
        }

        public byte Country
        {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup1\Monitoring\LiveConnectPing\Authentication.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace LiveConnectPing
{
    /// <summary>
    /// 
    /// </summary>
    public enum Authentication
    {
        None,
        ClientCertificate,
        ConsoleStsToken,
        UserStsToken,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup1\Monitoring\LiveConnectPing\ColorConsoleTraceListener.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Diagnostics;
using System.Globalization;

namespace LiveConnectPing
{
    /// <summary>
    /// 
    /// </summary>
    public class ColorConsoleTraceListener : TextWriterTraceListener
    {
        private bool showSource;

        /// <summary>
        /// 
        /// </summary>
        public ColorConsoleTraceListener()
            : this(true)
        {

        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="showSource"></param>
        public ColorConsoleTraceListener(bool showSource)
            : base(Console.Out)
        {
            this.showSource = showSource;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="eventCache"></param>
        /// <param name="source"></param>
        /// <param name="eventType"></param>
        /// <param name="id"></param>
        /// <param name="message"></param>
        public override void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string message)
        {
            if ((this.Filter != null) && !this.Filter.ShouldTrace(eventCache, source, eventType, id, message, null, null, null))
                return;

            try
            {
                Console.ForegroundColor = ConsoleColor.White;
                this.WriteHeader(source, eventType, id);

                switch (eventType)
                {
                    case TraceEventType.Start:
                    case TraceEventType.Stop:
                        {
                            Console.ForegroundColor = ConsoleColor.Green;
                            break;
                        }
                    case TraceEventType.Verbose:
                        {
                            Console.ForegroundColor = ConsoleColor.Gray;
                            break;
                        }
                    case TraceEventType.Information:
                        {
                            Console.ForegroundColor = ConsoleColor.Blue;
                            break;
                        }
                    case TraceEventType.Warning:
                        {
                            Console.ForegroundColor = ConsoleColor.Yellow;
                            break;
                        }
                    case TraceEventType.Error:
                    case TraceEventType.Critical:
                        {
                            Console.ForegroundColor = ConsoleColor.Red;
                            break;
                        }
                }

                base.WriteLine(message);

                Console.ForegroundColor = ConsoleColor.White;
                this.WriteFooter(eventCache);
            }
            finally
            {
                Console.ResetColor();
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="eventCache"></param>
        /// <param name="source"></param>
        /// <param name="eventType"></param>
        /// <param name="id"></param>
        /// <param name="format"></param>
        /// <param name="args"></param>
        public override void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string format, params object[] args)
        {
            TraceEvent(eventCache, source, eventType, id, String.Format(format, args));
        }

        /// <summary>
        /// 
        /// </summary>
        protected override void WriteIndent()
        {
            this.NeedIndent = false;
            for (int i = 0; i < this.IndentLevel; i++)
            {
                for (int j = 0; j < this.IndentSize; j++)
                    this.Write("\t");
            }
            //base.WriteIndent();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="source"></param>
        /// <param name="type"></param>
        /// <param name="id"></param>
        protected virtual void WriteHeader(string source, TraceEventType type, int id)
        {
            StringBuilder header = new StringBuilder();
            if (this.showSource)
                header.AppendFormat("{0} ", source);
            header.AppendFormat("{0}: ", type);
            if (id != 0)
                header.AppendFormat("{0}: ", id);
            this.Write(header.ToString());
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="cache"></param>
        protected virtual void WriteFooter(TraceEventCache eventCache)
        {
            if (eventCache != null)
            {
                base.IndentLevel++;
                if (this.IsEnabled(TraceOptions.ProcessId))
                {
                    this.WriteLine("ProcessId=" + eventCache.ProcessId);
                }
                if (this.IsEnabled(TraceOptions.LogicalOperationStack))
                {
                    this.Write("LogicalOperationStack=");
                    Stack logicalOperationStack = eventCache.LogicalOperationStack;
                    bool flag = true;
                    foreach (object obj2 in logicalOperationStack)
                    {
                        if (!flag)
                        {
                            this.Write(", ");
                        }
                        else
                        {
                            flag = false;
                        }
                        this.Write(obj2.ToString());
                    }
                    this.WriteLine(string.Empty);
                }
                if (this.IsEnabled(TraceOptions.ThreadId))
                {
                    this.WriteLine("ThreadId=" + eventCache.ThreadId);
                }
                if (this.IsEnabled(TraceOptions.DateTime))
                {
                    //this POS is in UTC; convert to local
                    DateTime local = TimeZoneInfo.ConvertTimeFromUtc(eventCache.DateTime, TimeZoneInfo.Local);
                    this.WriteLine("DateTime=" + local.ToString("MM/dd/yyyy hh:mm:ss.ffff tt"));
                }
                if (this.IsEnabled(TraceOptions.Timestamp))
                {
                    this.WriteLine("Timestamp=" + eventCache.Timestamp);
                }
                if (this.IsEnabled(TraceOptions.Callstack))
                {
                    this.WriteLine("Callstack=" + eventCache.Callstack);
                }
                base.IndentLevel--;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="opts"></param>
        /// <returns></returns>
        protected bool IsEnabled(TraceOptions opts)
        {
            return ((opts & this.TraceOutputOptions) != TraceOptions.None);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup1\Monitoring\LiveConnectPing\LiveConnectPingArguments.cs ===
using System;
using CommandLine;

namespace LiveConnectPing
{
    /// <summary>
    /// 
    /// </summary>
    internal class LiveConnectPingArguments
    {
        /// <summary>
        /// 
        /// </summary>
        [Argument(ArgumentType.Required, LongName="hostname", ShortName="h", HelpText="Specifies the DNS hostname used in the WCF endpoint, to call Live Connect.")]
        public string Hostname = String.Empty;

        /// <summary>
        /// 
        /// </summary>
        [Argument(ArgumentType.AtMostOnce, DefaultValue=false, LongName="ignoresslerrrors", ShortName="ssl", HelpText="Specifies whether or not server-side SSL errors should be ignored, or result in errors.")]
        public bool IgnoreServerSslErrors = false;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup1\Monitoring\LiveConnectPing\TraceEx.cs ===
using System;
using System.Reflection;
using System.Diagnostics;

namespace LiveConnectPing
{
    /// <summary>
    /// 
    /// </summary>
    public static class TraceEx
    {
        private static Type internalTraceType = Type.GetType("System.Diagnostics.TraceInternal, System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089", true, true);
        private static MethodInfo traceEvent = internalTraceType.GetMethod("TraceEvent");

        /// <summary>
        /// 
        /// </summary>
        /// <param name="format"></param>
        /// <param name="args"></param>
        public static void TraceVerbose(string format, params object[] args)
        {
            TraceVerbose(String.Format(format, args));
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="message"></param>
        public static void TraceVerbose(string message)
        {
            traceEvent.Invoke(null, new object[] { TraceEventType.Verbose, 0, message, null });
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="format"></param>
        /// <param name="args"></param>
        public static void TraceStart(string format, params object[] args)
        {
            TraceStart(String.Format(format, args));
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="message"></param>
        public static void TraceStart(string message)
        {
            traceEvent.Invoke(null, new object[] { TraceEventType.Start, 0, message, null });
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="format"></param>
        /// <param name="args"></param>
        public static void TraceStop(string format, params object[] args)
        {
            TraceStop(String.Format(format, args));
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="message"></param>
        public static void TraceStop(string message)
        {
            traceEvent.Invoke(null, new object[] { TraceEventType.Stop, 0, message, null });
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="type"></param>
        /// <param name="id"></param>
        /// <param name="message"></param>
        public static void TraceEvent(TraceEventType type, int id, string message)
        {
            traceEvent.Invoke(null, new object[] { type, id, message, null });
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="type"></param>
        /// <param name="id"></param>
        /// <param name="format"></param>
        /// <param name="args"></param>
        public static void TraceEvent(TraceEventType type, int id, string format, params object[] args)
        {
            traceEvent.Invoke(null, new object[] { type, id, format, args });
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="format"></param>
        /// <param name="args"></param>
        public static void TraceError(string format, params object[] args)
        {
            TraceError(String.Format(format, args));
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="message"></param>
        public static void TraceError(string message)
        {
            traceEvent.Invoke(null, new object[] { TraceEventType.Error, 1000, message, null });
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="eventId"></param>
        /// <param name="format"></param>
        /// <param name="args"></param>
        public static void TraceError(int eventId, string format, params object[] args)
        {
            TraceError(eventId, String.Format(format, args));
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="message"></param>
        public static void TraceError(int eventId, string message)
        {
            traceEvent.Invoke(null, new object[] { TraceEventType.Error, eventId, message, null });
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="eventId"></param>
        /// <param name="format"></param>
        /// <param name="args"></param>
        public static void TraceWarning(int eventId, string format, params object[] args)
        {
            TraceWarning(eventId, String.Format(format, args));
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="message"></param>
        public static void TraceWarning(int eventId, string message)
        {
            traceEvent.Invoke(null, new object[] { TraceEventType.Warning, eventId, message, null });
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup1\LCWebService\LiveConnect.designer.cs ===
#pragma warning disable 1591
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3074
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace LiveConnectWeb
{
	using System.Data.Linq;
	using System.Data.Linq.Mapping;
	using System.Data;
	using System.Collections.Generic;
	using System.Reflection;
	using System.Linq;
	using System.Linq.Expressions;
	using System.ComponentModel;
	using System;
	
	
	[System.Data.Linq.Mapping.DatabaseAttribute(Name="LiveConnect")]
	public partial class LiveConnectDataContext : System.Data.Linq.DataContext
	{
		
		private static System.Data.Linq.Mapping.MappingSource mappingSource = new AttributeMappingSource();
		
    #region Extensibility Method Definitions
    partial void OnCreated();
    partial void InsertNetworkInfo(NetworkInfo instance);
    partial void UpdateNetworkInfo(NetworkInfo instance);
    partial void DeleteNetworkInfo(NetworkInfo instance);
    partial void InsertDirectory(Directory instance);
    partial void UpdateDirectory(Directory instance);
    partial void DeleteDirectory(Directory instance);
    partial void InsertAuthentication(Authentication instance);
    partial void UpdateAuthentication(Authentication instance);
    partial void DeleteAuthentication(Authentication instance);
    #endregion
		
		public LiveConnectDataContext() :
            base(System.Configuration.ConfigurationManager.ConnectionStrings["LiveConnect"].ConnectionString, mappingSource)
    {
			OnCreated();
		}
		
		public LiveConnectDataContext(string connection) : 
				base(connection, mappingSource)
		{
			OnCreated();
		}
		
		public LiveConnectDataContext(System.Data.IDbConnection connection) : 
				base(connection, mappingSource)
		{
			OnCreated();
		}
		
		public LiveConnectDataContext(string connection, System.Data.Linq.Mapping.MappingSource mappingSource) : 
				base(connection, mappingSource)
		{
			OnCreated();
		}
		
		public LiveConnectDataContext(System.Data.IDbConnection connection, System.Data.Linq.Mapping.MappingSource mappingSource) : 
				base(connection, mappingSource)
		{
			OnCreated();
		}
		
		public System.Data.Linq.Table<NetworkInfo> NetworkInfos
		{
			get
			{
				return this.GetTable<NetworkInfo>();
			}
		}
		
		public System.Data.Linq.Table<Directory> Directories
		{
			get
			{
				return this.GetTable<Directory>();
			}
		}
		
		public System.Data.Linq.Table<Authentication> Authentications
		{
			get
			{
				return this.GetTable<Authentication>();
			}
		}
		
		[Function(Name="dbo.spGetXUIDS")]
		public ISingleResult<spGetXUIDSResult> spGetXUIDS([Parameter(DbType="Int")] System.Nullable<int> sNetworkId, [Parameter(DbType="NVarChar(4000)")] string userList)
		{
			IExecuteResult result = this.ExecuteMethodCall(this, ((MethodInfo)(MethodInfo.GetCurrentMethod())), sNetworkId, userList);
			return ((ISingleResult<spGetXUIDSResult>)(result.ReturnValue));
		}

        [Function(Name = "dbo.spGetXUIDSEx")]
        public ISingleResult<spGetXUIDSResult> spGetXUIDSEx([Parameter(DbType = "Int")] System.Nullable<int> sNetworkId, 
                                                            [Parameter(DbType = "Xml")] System.Xml.Linq.XElement userList)
        {
            IExecuteResult result = this.ExecuteMethodCall(this, ((MethodInfo)(MethodInfo.GetCurrentMethod())), sNetworkId, userList);
            return ((ISingleResult<spGetXUIDSResult>)(result.ReturnValue));
        }

		
		[Function(Name="dbo.spSetSNUserInfo")]
		public int spSetSNUserInfo([Parameter(DbType="SmallInt")] System.Nullable<short> sNetworkId, [Parameter(DbType="BigInt")] System.Nullable<long> xuid, [Parameter(DbType="NVarChar(64)")] string snUserId, [Parameter(DbType="VarChar(16)")] string gamerTag, [Parameter(DbType="Int")] System.Nullable<int> flags)
		{
			IExecuteResult result = this.ExecuteMethodCall(this, ((MethodInfo)(MethodInfo.GetCurrentMethod())), sNetworkId, xuid, snUserId, gamerTag, flags);
			return ((int)(result.ReturnValue));
		}
		
		[Function(Name="dbo.spRemoveUserInfo")]
		public int spRemoveUserInfo([Parameter(DbType="SmallInt")] System.Nullable<short> sNetworkId, [Parameter(DbType="BigInt")] System.Nullable<long> xuid)
		{
			IExecuteResult result = this.ExecuteMethodCall(this, ((MethodInfo)(MethodInfo.GetCurrentMethod())), sNetworkId, xuid);
			return ((int)(result.ReturnValue));
		}
		
		[Function(Name="dbo.spRemoveSNAuthInfo")]
		public int spRemoveSNAuthInfo([Parameter(DbType="SmallInt")] System.Nullable<short> sNetworkId, [Parameter(DbType="BigInt")] System.Nullable<long> xuid)
		{
			IExecuteResult result = this.ExecuteMethodCall(this, ((MethodInfo)(MethodInfo.GetCurrentMethod())), sNetworkId, xuid);
			return ((int)(result.ReturnValue));
		}
		
		[Function(Name="dbo.spSetAuthAndUserInfo")]
		public int spSetAuthAndUserInfo([Parameter(DbType="SmallInt")] System.Nullable<short> sNetworkId, [Parameter(DbType="BigInt")] System.Nullable<long> xuid, [Parameter(DbType="NVarChar(64)")] string snUserId, [Parameter(DbType="VarChar(16)")] string gamerTag, [Parameter(DbType="VarChar(4096)")] string token, [Parameter(DbType="VarChar(32)")] string deviceId, [Parameter(DbType="Int")] System.Nullable<int> flags, [Parameter(DbType="SmallInt")] System.Nullable<short> preserveToken)
		{
			IExecuteResult result = this.ExecuteMethodCall(this, ((MethodInfo)(MethodInfo.GetCurrentMethod())), sNetworkId, xuid, snUserId, gamerTag, token, deviceId, flags, preserveToken);
			return ((int)(result.ReturnValue));
		}
		
		[Function(Name="dbo.spSetSNAuthInfo")]
		public int spSetSNAuthInfo([Parameter(DbType="SmallInt")] System.Nullable<short> sNetworkId, [Parameter(DbType="BigInt")] System.Nullable<long> xuid, [Parameter(DbType="NVarChar(64)")] string snUserId, [Parameter(DbType="VarChar(4096)")] string token, [Parameter(DbType="VarChar(32)")] string deviceId, [Parameter(DbType="SmallInt")] System.Nullable<short> preserveToken)
		{
			IExecuteResult result = this.ExecuteMethodCall(this, ((MethodInfo)(MethodInfo.GetCurrentMethod())), sNetworkId, xuid, snUserId, token, deviceId, preserveToken);
			return ((int)(result.ReturnValue));
		}
	}
	
	[Table(Name="dbo.NetworkInfo")]
	public partial class NetworkInfo : INotifyPropertyChanging, INotifyPropertyChanged
	{
		
		private static PropertyChangingEventArgs emptyChangingEventArgs = new PropertyChangingEventArgs(String.Empty);
		
		private short _SNetworkId;
		
		private string _Description;
		
		private string _Logo;
		
    #region Extensibility Method Definitions
    partial void OnLoaded();
    partial void OnValidate(System.Data.Linq.ChangeAction action);
    partial void OnCreated();
    partial void OnSNetworkIdChanging(short value);
    partial void OnSNetworkIdChanged();
    partial void OnDescriptionChanging(string value);
    partial void OnDescriptionChanged();
    partial void OnLogoChanging(string value);
    partial void OnLogoChanged();
    #endregion
		
		public NetworkInfo()
		{
			OnCreated();
		}
		
		[Column(Storage="_SNetworkId", DbType="SmallInt NOT NULL", IsPrimaryKey=true)]
		public short SNetworkId
		{
			get
			{
				return this._SNetworkId;
			}
			set
			{
				if ((this._SNetworkId != value))
				{
					this.OnSNetworkIdChanging(value);
					this.SendPropertyChanging();
					this._SNetworkId = value;
					this.SendPropertyChanged("SNetworkId");
					this.OnSNetworkIdChanged();
				}
			}
		}
		
		[Column(Storage="_Description", DbType="NVarChar(255) NOT NULL", CanBeNull=false)]
		public string Description
		{
			get
			{
				return this._Description;
			}
			set
			{
				if ((this._Description != value))
				{
					this.OnDescriptionChanging(value);
					this.SendPropertyChanging();
					this._Description = value;
					this.SendPropertyChanged("Description");
					this.OnDescriptionChanged();
				}
			}
		}
		
		[Column(Storage="_Logo", DbType="VarChar(255) NOT NULL", CanBeNull=false)]
		public string Logo
		{
			get
			{
				return this._Logo;
			}
			set
			{
				if ((this._Logo != value))
				{
					this.OnLogoChanging(value);
					this.SendPropertyChanging();
					this._Logo = value;
					this.SendPropertyChanged("Logo");
					this.OnLogoChanged();
				}
			}
		}
		
		public event PropertyChangingEventHandler PropertyChanging;
		
		public event PropertyChangedEventHandler PropertyChanged;
		
		protected virtual void SendPropertyChanging()
		{
			if ((this.PropertyChanging != null))
			{
				this.PropertyChanging(this, emptyChangingEventArgs);
			}
		}
		
		protected virtual void SendPropertyChanged(String propertyName)
		{
			if ((this.PropertyChanged != null))
			{
				this.PropertyChanged(this, new PropertyChangedEventArgs(propertyName));
			}
		}
	}
	
	[Table(Name="dbo.Directory")]
	public partial class Directory : INotifyPropertyChanging, INotifyPropertyChanged
	{
		
		private static PropertyChangingEventArgs emptyChangingEventArgs = new PropertyChangingEventArgs(String.Empty);
		
		private short _SNetworkId;
		
		private long _XUID;
		
		private string _SNUserId;
		
		private string _GamerTag;
		
		private int _Flags;
		
		private System.DateTime _LastAccessedTime;
		
    #region Extensibility Method Definitions
    partial void OnLoaded();
    partial void OnValidate(System.Data.Linq.ChangeAction action);
    partial void OnCreated();
    partial void OnSNetworkIdChanging(short value);
    partial void OnSNetworkIdChanged();
    partial void OnXUIDChanging(long value);
    partial void OnXUIDChanged();
    partial void OnSNUserIdChanging(string value);
    partial void OnSNUserIdChanged();
    partial void OnGamerTagChanging(string value);
    partial void OnGamerTagChanged();
    partial void OnFlagsChanging(int value);
    partial void OnFlagsChanged();
    partial void OnLastAccessedTimeChanging(System.DateTime value);
    partial void OnLastAccessedTimeChanged();
    #endregion
		
		public Directory()
		{
			OnCreated();
		}
		
		[Column(Storage="_SNetworkId", DbType="SmallInt NOT NULL", IsPrimaryKey=true)]
		public short SNetworkId
		{
			get
			{
				return this._SNetworkId;
			}
			set
			{
				if ((this._SNetworkId != value))
				{
					this.OnSNetworkIdChanging(value);
					this.SendPropertyChanging();
					this._SNetworkId = value;
					this.SendPropertyChanged("SNetworkId");
					this.OnSNetworkIdChanged();
				}
			}
		}
		
		[Column(Storage="_XUID", DbType="BigInt NOT NULL", IsPrimaryKey=true)]
		public long XUID
		{
			get
			{
				return this._XUID;
			}
			set
			{
				if ((this._XUID != value))
				{
					this.OnXUIDChanging(value);
					this.SendPropertyChanging();
					this._XUID = value;
					this.SendPropertyChanged("XUID");
					this.OnXUIDChanged();
				}
			}
		}
		
		[Column(Storage="_SNUserId", DbType="NVarChar(64) NOT NULL", CanBeNull=false)]
		public string SNUserId
		{
			get
			{
				return this._SNUserId;
			}
			set
			{
				if ((this._SNUserId != value))
				{
					this.OnSNUserIdChanging(value);
					this.SendPropertyChanging();
					this._SNUserId = value;
					this.SendPropertyChanged("SNUserId");
					this.OnSNUserIdChanged();
				}
			}
		}
		
		[Column(Storage="_GamerTag", DbType="VarChar(16) NOT NULL", CanBeNull=false)]
		public string GamerTag
		{
			get
			{
				return this._GamerTag;
			}
			set
			{
				if ((this._GamerTag != value))
				{
					this.OnGamerTagChanging(value);
					this.SendPropertyChanging();
					this._GamerTag = value;
					this.SendPropertyChanged("GamerTag");
					this.OnGamerTagChanged();
				}
			}
		}
		
		[Column(Storage="_Flags", DbType="Int NOT NULL")]
		public int Flags
		{
			get
			{
				return this._Flags;
			}
			set
			{
				if ((this._Flags != value))
				{
					this.OnFlagsChanging(value);
					this.SendPropertyChanging();
					this._Flags = value;
					this.SendPropertyChanged("Flags");
					this.OnFlagsChanged();
				}
			}
		}
		
		[Column(Storage="_LastAccessedTime", DbType="DateTime2 NOT NULL")]
		public System.DateTime LastAccessedTime
		{
			get
			{
				return this._LastAccessedTime;
			}
			set
			{
				if ((this._LastAccessedTime != value))
				{
					this.OnLastAccessedTimeChanging(value);
					this.SendPropertyChanging();
					this._LastAccessedTime = value;
					this.SendPropertyChanged("LastAccessedTime");
					this.OnLastAccessedTimeChanged();
				}
			}
		}
		
		public event PropertyChangingEventHandler PropertyChanging;
		
		public event PropertyChangedEventHandler PropertyChanged;
		
		protected virtual void SendPropertyChanging()
		{
			if ((this.PropertyChanging != null))
			{
				this.PropertyChanging(this, emptyChangingEventArgs);
			}
		}
		
		protected virtual void SendPropertyChanged(String propertyName)
		{
			if ((this.PropertyChanged != null))
			{
				this.PropertyChanged(this, new PropertyChangedEventArgs(propertyName));
			}
		}
	}
	
	[Table(Name="dbo.Authentication")]
	public partial class Authentication : INotifyPropertyChanging, INotifyPropertyChanged
	{
		
		private static PropertyChangingEventArgs emptyChangingEventArgs = new PropertyChangingEventArgs(String.Empty);
		
		private short _SNetworkId;
		
		private long _XUID;
		
		private string _SNUserId;
		
		private string _Token;
		
		private string _DeviceId;
		
		private System.DateTime _LastAccessedTime;
		
    #region Extensibility Method Definitions
    partial void OnLoaded();
    partial void OnValidate(System.Data.Linq.ChangeAction action);
    partial void OnCreated();
    partial void OnSNetworkIdChanging(short value);
    partial void OnSNetworkIdChanged();
    partial void OnXUIDChanging(long value);
    partial void OnXUIDChanged();
    partial void OnSNUserIdChanging(string value);
    partial void OnSNUserIdChanged();
    partial void OnTokenChanging(string value);
    partial void OnTokenChanged();
    partial void OnDeviceIdChanging(string value);
    partial void OnDeviceIdChanged();
    partial void OnLastAccessedTimeChanging(System.DateTime value);
    partial void OnLastAccessedTimeChanged();
    #endregion
		
		public Authentication()
		{
			OnCreated();
		}
		
		[Column(Storage="_SNetworkId", DbType="SmallInt NOT NULL", IsPrimaryKey=true)]
		public short SNetworkId
		{
			get
			{
				return this._SNetworkId;
			}
			set
			{
				if ((this._SNetworkId != value))
				{
					this.OnSNetworkIdChanging(value);
					this.SendPropertyChanging();
					this._SNetworkId = value;
					this.SendPropertyChanged("SNetworkId");
					this.OnSNetworkIdChanged();
				}
			}
		}
		
		[Column(Storage="_XUID", DbType="BigInt NOT NULL", IsPrimaryKey=true)]
		public long XUID
		{
			get
			{
				return this._XUID;
			}
			set
			{
				if ((this._XUID != value))
				{
					this.OnXUIDChanging(value);
					this.SendPropertyChanging();
					this._XUID = value;
					this.SendPropertyChanged("XUID");
					this.OnXUIDChanged();
				}
			}
		}
		
		[Column(Storage="_SNUserId", DbType="NVarChar(64) NOT NULL", CanBeNull=false)]
		public string SNUserId
		{
			get
			{
				return this._SNUserId;
			}
			set
			{
				if ((this._SNUserId != value))
				{
					this.OnSNUserIdChanging(value);
					this.SendPropertyChanging();
					this._SNUserId = value;
					this.SendPropertyChanged("SNUserId");
					this.OnSNUserIdChanged();
				}
			}
		}
		
		[Column(Storage="_Token", DbType="VarChar(4096) NOT NULL", CanBeNull=false)]
		public string Token
		{
			get
			{
				return this._Token;
			}
			set
			{
				if ((this._Token != value))
				{
					this.OnTokenChanging(value);
					this.SendPropertyChanging();
					this._Token = value;
					this.SendPropertyChanged("Token");
					this.OnTokenChanged();
				}
			}
		}
		
		[Column(Storage="_DeviceId", DbType="Char(32) NOT NULL", CanBeNull=false, IsPrimaryKey=true)]
		public string DeviceId
		{
			get
			{
				return this._DeviceId;
			}
			set
			{
				if ((this._DeviceId != value))
				{
					this.OnDeviceIdChanging(value);
					this.SendPropertyChanging();
					this._DeviceId = value;
					this.SendPropertyChanged("DeviceId");
					this.OnDeviceIdChanged();
				}
			}
		}
		
		[Column(Storage="_LastAccessedTime", DbType="DateTime2 NOT NULL")]
		public System.DateTime LastAccessedTime
		{
			get
			{
				return this._LastAccessedTime;
			}
			set
			{
				if ((this._LastAccessedTime != value))
				{
					this.OnLastAccessedTimeChanging(value);
					this.SendPropertyChanging();
					this._LastAccessedTime = value;
					this.SendPropertyChanged("LastAccessedTime");
					this.OnLastAccessedTimeChanged();
				}
			}
		}
		
		public event PropertyChangingEventHandler PropertyChanging;
		
		public event PropertyChangedEventHandler PropertyChanged;
		
		protected virtual void SendPropertyChanging()
		{
			if ((this.PropertyChanging != null))
			{
				this.PropertyChanging(this, emptyChangingEventArgs);
			}
		}
		
		protected virtual void SendPropertyChanged(String propertyName)
		{
			if ((this.PropertyChanged != null))
			{
				this.PropertyChanged(this, new PropertyChangedEventArgs(propertyName));
			}
		}
	}
	
	public partial class spGetXUIDSResult
	{
		
		private long _XUID;
		
		private string _SNUserId;
		
		private string _GamerTag;
		
		private int _Flags;
		
		public spGetXUIDSResult()
		{
		}
		
		[Column(Storage="_XUID", DbType="BigInt NOT NULL")]
		public long XUID
		{
			get
			{
				return this._XUID;
			}
			set
			{
				if ((this._XUID != value))
				{
					this._XUID = value;
				}
			}
		}
		
		[Column(Storage="_SNUserId", DbType="NVarChar(64) NOT NULL", CanBeNull=false)]
		public string SNUserId
		{
			get
			{
				return this._SNUserId;
			}
			set
			{
				if ((this._SNUserId != value))
				{
					this._SNUserId = value;
				}
			}
		}
		
		[Column(Storage="_GamerTag", DbType="VarChar(16) NOT NULL", CanBeNull=false)]
		public string GamerTag
		{
			get
			{
				return this._GamerTag;
			}
			set
			{
				if ((this._GamerTag != value))
				{
					this._GamerTag = value;
				}
			}
		}
		
		[Column(Storage="_Flags", DbType="Int NOT NULL")]
		public int Flags
		{
			get
			{
				return this._Flags;
			}
			set
			{
				if ((this._Flags != value))
				{
					this._Flags = value;
				}
			}
		}
	}
}
#pragma warning restore 1591
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup1\Monitoring\LiveConnectPing\ValidationException.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace LiveConnectPing
{
    /// <summary>
    /// 
    /// </summary>
    public class ValidationException: Exception
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="message"></param>
        public ValidationException(string message)
            : base(message)
        {

        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="format"></param>
        /// <param name="args"></param>
        public ValidationException(string format, params object[] args)
            : base(String.Format(format, args))
        {

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup1\Monitoring\LiveConnectPing\XboxTitle.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace LiveConnectPing
{
    /// <summary>
    /// 
    /// </summary>
    public enum XboxTitle : uint
    {
        Default = XboxTitle.Xbox360Dash,
        Xbox360Dash = 0xFFFE07D1,
        Facebook = 0x584807E1,
        Twitter = XboxTitle.Xbox360Dash,    //Twitter is a BDE, so its title ID is the same as the 360 dash
        LastFM = 0x584807E3,
        WP7GamesHub = 0x584D07D6,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup1\LCWebService\test\LiveConnectTest.cs ===
using System;
using System.Xml;
using System.IO;
using System.Data;
using System.Data.SqlClient;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using System.Security.Cryptography.Xml;

namespace LiveConnectWeb.Test
{
    /// <summary>
    /// 
    /// </summary>
    public class LiveConnectTest : ILiveConnectTest
    {
        // Token Signing Certificate
        //  this is the cert and associated private key that signs the SAML token
        static private X509Certificate2 _certificate = null;

        private const string samlNamespace = "urn:oasis:names:tc:SAML:1.0:assertion";
        private const string stsIssuer = "http://sts.xboxlive.com";
        private const string signingCertSubject = "lnconnect.redmond.corp.microsoft.com";

        /// <summary>
        /// 
        /// </summary>
        /// <param name="socialNetworkID"></param>
        /// <param name="xuid"></param>
        /// <param name="snUserID"></param>
        /// <param name="gamerTag"></param>
        /// <param name="visibility"></param>
        public void AddDirectoryInfo(ushort socialNetworkID, ulong xuid, string snUserID, string gamerTag, Visibility visibility)
        {
            LiveConnectDataContext db = new LiveConnectDataContext();

            //for now, ignore any issues related to primary key violations
            //an exception will be thrown back to the client
            Directory directoryEntry = new Directory();
            db.Directories.InsertOnSubmit(directoryEntry);

            directoryEntry.SNetworkId = (short)socialNetworkID;
            directoryEntry.XUID = (long)xuid;
            directoryEntry.GamerTag = gamerTag;
            directoryEntry.SNUserId = snUserID;
            directoryEntry.Flags = (int)visibility;
            directoryEntry.LastAccessedTime = DateTime.Now;

            db.SubmitChanges();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="socialNetworkID"></param>
        /// <param name="xuid"></param>
        /// <param name="snUserID"></param>
        /// <param name="authToken"></param>
        /// <param name="deviceID"></param>
        public void AddAuthInfo(ushort socialNetworkID, ulong xuid, string snUserID, string authToken, string deviceID)
        {
            LiveConnectDataContext db = new LiveConnectDataContext();

            //for now, ignore any issues related to primary key violations
            //an exception will be thrown back to the client
            Authentication authEntry = new Authentication();

            db.Authentications.InsertOnSubmit(authEntry);

            authEntry.SNetworkId = (short)socialNetworkID;
            authEntry.XUID = (long)xuid;
            authEntry.SNUserId = snUserID;
            authEntry.Token = authToken;
            authEntry.DeviceId = deviceID;
            authEntry.LastAccessedTime = DateTime.Now;

            db.SubmitChanges();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="sql"></param>
        public int ExecuteSql(string sql)
        {
            using (SqlConnection connection = new SqlConnection(System.Configuration.ConfigurationManager.ConnectionStrings["LiveConnect"].ConnectionString))
            using (SqlCommand command = new SqlCommand(sql, connection))
            {                               
                command.CommandType = CommandType.Text;
                connection.Open();
                return command.ExecuteNonQuery();
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="sql"></param>
        /// <returns></returns>
        public string ExecuteSqlDataSet(string sql)
        {
            using (SqlConnection connection = new SqlConnection(System.Configuration.ConfigurationManager.ConnectionStrings["LiveConnect"].ConnectionString))
            using (SqlDataAdapter dataAdapter = new SqlDataAdapter(sql, connection))
            {
                DataSet set = new DataSet();
                dataAdapter.Fill(set);
                return set.GetXml();                
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="players"></param>
        /// <param name="machinePuid"></param>
        /// <param name="clientVersion"></param>
        /// <param name="title"></param>
        /// <param name="titleVersion"></param>
        /// <returns></returns>
        public string GetStsToken(Player[] players, string audience, ulong machinePuid, uint clientVersion, uint title, uint titleVersion, int minutesToExpire)
        {
            string assertionID = string.Format("SamlSecurityToken-{0}", Guid.NewGuid().ToString());
            
            DateTime now = DateTime.UtcNow;
            DateTime expires = now.Add(TimeSpan.FromMinutes(minutesToExpire));

            TextWriter textWriter = new StringWriter();
            XmlTextWriter writer = new XmlTextWriter(textWriter);
            
            writer.WriteStartElement("saml", "Assertion", samlNamespace);
            writer.WriteAttributeString("MajorVersion", "1");
            writer.WriteAttributeString("MinorVersion", "1");
            writer.WriteAttributeString("AssertionID", assertionID);
            writer.WriteAttributeString("Issuer", stsIssuer);
            writer.WriteAttributeString("IssueInstant", now.ToString("o"));
            
            writer.WriteStartElement("Conditions", samlNamespace);
            writer.WriteAttributeString("NotBefore", now.ToString("o")); 
            writer.WriteAttributeString("NotOnOrAfter", expires.ToString("o"));
            writer.WriteStartElement("AudienceRestrictionCondition", samlNamespace);
            writer.WriteElementString("Audience", samlNamespace, audience);
            writer.WriteEndElement(); //AudienceRestrictionCondition
            writer.WriteEndElement(); // Conditions

            writer.WriteStartElement("AttributeStatement", samlNamespace);
            
            writer.WriteStartElement("Subject", samlNamespace);
            writer.WriteElementString("NameIdentifier", samlNamespace, string.Format("0x{0:X16}", players[0].Xuid)); // primary Subject is player1, in uppercase hex
            writer.WriteEndElement();

            // Write out machineID claim
            WriteClaim(writer, "PlatformType", string.Format("0x{0:X2}", 0x2));
            WriteClaim(writer, "MachineID", string.Format("0x{0:X16}", machinePuid));
            WriteClaim(writer, "ClientVersion", string.Format("0x{0:X8}", clientVersion));
            WriteClaim(writer, "TitleID", string.Format("0x{0:X8}", title));
            WriteClaim(writer, "TitleVersion", string.Format("0x{0:X8}", titleVersion));
                        
            // Write out player claims
            for (int i = 0; i < players.Length; i++)
            {
                if (players[i] != null)
                {
                    WriteClaim(writer, String.Format("Xuid{0}", i + 1), string.Format("0x{0:X16}", players[i].Xuid)); //always return uppercase hex
                    WriteClaim(writer, String.Format("Tier{0}", i + 1), string.Format("0x{0:X2}", players[i].Tier));
                    WriteClaim(writer, String.Format("Country{0}", i + 1), string.Format("0x{0:X2}", players[i].Country));
                }
            }
                        
            writer.WriteEndElement(); // AttributeStatement
            writer.WriteEndElement(); // Assertion
            
            textWriter.Flush();

            XmlDocument document = new XmlDocument();
            document.LoadXml(textWriter.ToString());
            
            SignXmlViaLocalCert(document, assertionID);
            
            return document.OuterXml;
        }

        public string GetSimpleStsToken(ulong xuid, uint titleId, ulong machinePuid, int minutesToExpire)
        {
            //103=US, 6=Gold
            Player player1 = new Player(){ Xuid=xuid, Country=103, Tier=6 };

            //random machine puid, hard-coded client version, random title version
            return GetStsToken(new Player[] { player1 }, "http://xboxlive.com", machinePuid, 0x25223C00, titleId, GenerateRandomUInt32(), minutesToExpire);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="claim"></param>
        /// <param name="value"></param>
        private static void WriteClaim(XmlTextWriter writer, string claim, string value)
        {
            writer.WriteStartElement("Attribute", samlNamespace);
            writer.WriteAttributeString("AttributeName", claim);
            writer.WriteAttributeString("AttributeNamespace", "http://xboxlive.com/claims");
            writer.WriteElementString("AttributeValue", samlNamespace, value);
            writer.WriteEndElement();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="document"></param>
        /// <param name="assertionID"></param>
        private void SignXmlViaLocalCert(XmlDocument document, string assertionID)
        {
            // grab the cert so we don't have a race condition with it changing during a reload
            // we need this because we access the cert twice in this function and don't want to take a lock... but need to stay consistant
            X509Certificate2 signingCertificate = GetCertificate();

            // Create a CustomSignedXml object.  
            // The CustomSigendXml object lets us change what attribute is used to find the node to sign.
            // The standard SignedXml signs the node identified by the attribute named 'id'.
            // We need to sign the node identified by the attribute named 'AssertionID'. 
            CustomSignedXml signedXml = new CustomSignedXml(document);
            signedXml.SignedInfo.CanonicalizationMethod = SignedXml.XmlDsigExcC14NTransformUrl;
            signedXml.SigningKey = (RSACryptoServiceProvider)signingCertificate.PrivateKey;

            // Create a reference which tells SignedXml what node to sign
            Reference reference = new Reference();
            reference.Uri = "#" + assertionID;

            // Add an enveloped transformation to the reference.
            XmlDsigEnvelopedSignatureTransform transform1 = new XmlDsigEnvelopedSignatureTransform();
            reference.AddTransform(transform1);

            XmlDsigExcC14NTransform transform2 = new XmlDsigExcC14NTransform();
            reference.AddTransform(transform2);

            // Add the reference to the SignedXml object.
            signedXml.AddReference(reference);

            // add key info
            KeyInfo keyInfo = new KeyInfo();
            keyInfo.AddClause(new KeyInfoX509Data(signingCertificate));
            signedXml.KeyInfo = keyInfo;

            // Compute the signature.
            signedXml.ComputeSignature();

            // Get the XML representation of the signature and save
            // it to an XmlElement object.
            XmlElement xmlDigitalSignature = signedXml.GetXml();

            // Append the element to the XML document.
            document.DocumentElement.AppendChild(document.ImportNode(xmlDigitalSignature, true));
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        private static X509Certificate2 GetCertificate()
        {
            X509Certificate2 certificate = _certificate;

            // do I have a cert
            if (certificate != null)
                return certificate;

            string certSubject = signingCertSubject;
            X509Store store = new X509Store(StoreName.My, StoreLocation.LocalMachine);
            store.Open(OpenFlags.ReadOnly);
            try
            {
                // Find the certificate that matches the subject
                X509Certificate2Collection matches = store.Certificates.Find(X509FindType.FindBySubjectName, certSubject, false);
                if (matches == null || matches.Count == 0)
                    throw new ApplicationException(String.Format("No certificates with subject {0} were found in the specified store", certSubject));
                if (matches.Count > 1)
                    throw new ApplicationException(String.Format("Multiple certificates with subject {0} were found in the specified store", certSubject));
                if (!matches[0].HasPrivateKey)
                    throw new ApplicationException(String.Format("Certificate with subject {0} doesn't have a private key", certSubject));
                _certificate = certificate = matches[0];
            }
            finally
            {
                store.Close();
            }
            return certificate;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public static ulong GenerateRandomUInt64()
        {
            byte[] buffer = new byte[sizeof(ulong)];
            RNGCryptoServiceProvider rng = new RNGCryptoServiceProvider();
            rng.GetNonZeroBytes(buffer);
            return BitConverter.ToUInt64(buffer, 0);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public static uint GenerateRandomUInt32()
        {
            byte[] buffer = new byte[sizeof(uint)];
            RNGCryptoServiceProvider rng = new RNGCryptoServiceProvider();
            rng.GetNonZeroBytes(buffer);
            return BitConverter.ToUInt32(buffer, 0);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup1\Monitoring\LiveConnectPing\LiveConnectService.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4016
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace LiveConnectWeb
{
    using System.Runtime.Serialization;


    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "SNUserInfo", Namespace = "http://schemas.datacontract.org/2004/07/LiveConnectWeb")]
    public partial class SNUserInfo : object, System.Runtime.Serialization.IExtensibleDataObject
    {

        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;

        private string GamerTagField;

        private string SNUserIDField;

        private LiveConnectWeb.Visibility VisibilityField;

        private ulong XUIDField;

        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string GamerTag
        {
            get
            {
                return this.GamerTagField;
            }
            set
            {
                this.GamerTagField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string SNUserID
        {
            get
            {
                return this.SNUserIDField;
            }
            set
            {
                this.SNUserIDField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public LiveConnectWeb.Visibility Visibility
        {
            get
            {
                return this.VisibilityField;
            }
            set
            {
                this.VisibilityField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public ulong XUID
        {
            get
            {
                return this.XUIDField;
            }
            set
            {
                this.XUIDField = value;
            }
        }
    }

    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "Visibility", Namespace = "http://schemas.datacontract.org/2004/07/LiveConnectWeb")]
    public enum Visibility : int
    {

        [System.Runtime.Serialization.EnumMemberAttribute()]
        Me = 0,

        [System.Runtime.Serialization.EnumMemberAttribute()]
        Everyone = 1,
    }

    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "SNetworkInfo", Namespace = "http://schemas.datacontract.org/2004/07/LiveConnectWeb")]
    public partial class SNetworkInfo : object, System.Runtime.Serialization.IExtensibleDataObject
    {

        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;

        private string DescriptionField;

        private uint IdField;

        private string LogoField;

        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Description
        {
            get
            {
                return this.DescriptionField;
            }
            set
            {
                this.DescriptionField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public uint Id
        {
            get
            {
                return this.IdField;
            }
            set
            {
                this.IdField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Logo
        {
            get
            {
                return this.LogoField;
            }
            set
            {
                this.LogoField = value;
            }
        }
    }

    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "SNAuthInfo", Namespace = "http://schemas.datacontract.org/2004/07/LiveConnectWeb")]
    public partial class SNAuthInfo : object, System.Runtime.Serialization.IExtensibleDataObject
    {

        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;

        private string SNUserIDField;

        private string TokenField;

        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string SNUserID
        {
            get
            {
                return this.SNUserIDField;
            }
            set
            {
                this.SNUserIDField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Token
        {
            get
            {
                return this.TokenField;
            }
            set
            {
                this.TokenField = value;
            }
        }
    }
}


[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
[System.ServiceModel.ServiceContractAttribute(Namespace = "http://liveconnect.xboxlive.com", ConfigurationName = "ILiveDirectory")]
public interface ILiveDirectory
{

    [System.ServiceModel.OperationContractAttribute(Action = "http://liveconnect.xboxlive.com/ILiveDirectory/SetSNUserInfo", ReplyAction = "http://liveconnect.xboxlive.com/ILiveDirectory/SetSNUserInfoResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/SetSNUserInfoArgumentExceptionFaul" +
        "t", Name = "ArgumentException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentNullException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/SetSNUserInfoArgumentNullException" +
        "Fault", Name = "ArgumentNullException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ServiceModel.Security.SecurityAccessDeniedException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/SetSNUserInfoSecurityAccessDeniedE" +
        "xceptionFault", Name = "SecurityAccessDeniedException", Namespace = "http://schemas.datacontract.org/2004/07/System.ServiceModel.Security")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentOutOfRangeException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/SetSNUserInfoArgumentOutOfRangeExc" +
        "eptionFault", Name = "ArgumentOutOfRangeException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    void SetSNUserInfo(ushort sNetworkId, LiveConnectWeb.SNUserInfo userInfo);

    [System.ServiceModel.OperationContractAttribute(Action = "http://liveconnect.xboxlive.com/ILiveDirectory/RemoveSNUserInfo", ReplyAction = "http://liveconnect.xboxlive.com/ILiveDirectory/RemoveSNUserInfoResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentOutOfRangeException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/RemoveSNUserInfoArgumentOutOfRange" +
        "ExceptionFault", Name = "ArgumentOutOfRangeException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/RemoveSNUserInfoArgumentExceptionF" +
        "ault", Name = "ArgumentException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ServiceModel.Security.SecurityAccessDeniedException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/RemoveSNUserInfoSecurityAccessDeni" +
        "edExceptionFault", Name = "SecurityAccessDeniedException", Namespace = "http://schemas.datacontract.org/2004/07/System.ServiceModel.Security")]
    void RemoveSNUserInfo(ushort sNetworkId, ulong XUID);

    [System.ServiceModel.OperationContractAttribute(Action = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNUserInfoByXUID", ReplyAction = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNUserInfoByXUIDResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNUserInfoByXUIDArgumentExcepti" +
        "onFault", Name = "ArgumentException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentOutOfRangeException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNUserInfoByXUIDArgumentOutOfRa" +
        "ngeExceptionFault", Name = "ArgumentOutOfRangeException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ServiceModel.Security.SecurityAccessDeniedException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNUserInfoByXUIDSecurityAccessD" +
        "eniedExceptionFault", Name = "SecurityAccessDeniedException", Namespace = "http://schemas.datacontract.org/2004/07/System.ServiceModel.Security")]
    LiveConnectWeb.SNUserInfo GetSNUserInfoByXUID(ushort sNetworkId, ulong XUID);

    [System.ServiceModel.OperationContractAttribute(Action = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNUserInfoBySNUId", ReplyAction = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNUserInfoBySNUIdResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNUserInfoBySNUIdArgumentExcept" +
        "ionFault", Name = "ArgumentException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentNullException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNUserInfoBySNUIdArgumentNullEx" +
        "ceptionFault", Name = "ArgumentNullException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ServiceModel.Security.SecurityAccessDeniedException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNUserInfoBySNUIdSecurityAccess" +
        "DeniedExceptionFault", Name = "SecurityAccessDeniedException", Namespace = "http://schemas.datacontract.org/2004/07/System.ServiceModel.Security")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentOutOfRangeException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNUserInfoBySNUIdArgumentOutOfR" +
        "angeExceptionFault", Name = "ArgumentOutOfRangeException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    LiveConnectWeb.SNUserInfo GetSNUserInfoBySNUId(ushort sNetworkId, string snUserId);

    [System.ServiceModel.OperationContractAttribute(Action = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNUserInfos", ReplyAction = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNUserInfosResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNUserInfosArgumentExceptionFau" +
        "lt", Name = "ArgumentException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentNullException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNUserInfosArgumentNullExceptio" +
        "nFault", Name = "ArgumentNullException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentOutOfRangeException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNUserInfosArgumentOutOfRangeEx" +
        "ceptionFault", Name = "ArgumentOutOfRangeException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ServiceModel.Security.SecurityAccessDeniedException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNUserInfosSecurityAccessDenied" +
        "ExceptionFault", Name = "SecurityAccessDeniedException", Namespace = "http://schemas.datacontract.org/2004/07/System.ServiceModel.Security")]
    LiveConnectWeb.SNUserInfo[] GetSNUserInfos(ushort sNetworkId, string[] sNUserIDs);

    [System.ServiceModel.OperationContractAttribute(Action = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNetworkInfo", ReplyAction = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNetworkInfoResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentOutOfRangeException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNetworkInfoArgumentOutOfRangeE" +
        "xceptionFault", Name = "ArgumentOutOfRangeException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    LiveConnectWeb.SNetworkInfo GetSNetworkInfo(ushort sNetworkId);

    [System.ServiceModel.OperationContractAttribute(Action = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNetworkInfos", ReplyAction = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNetworkInfosResponse")]
    LiveConnectWeb.SNetworkInfo[] GetSNetworkInfos();
}

[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
public interface ILiveDirectoryChannel : ILiveDirectory, System.ServiceModel.IClientChannel
{
}

[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
public partial class LiveDirectoryClient : System.ServiceModel.ClientBase<ILiveDirectory>, ILiveDirectory
{

    public LiveDirectoryClient()
    {
    }

    public LiveDirectoryClient(string endpointConfigurationName) :
        base(endpointConfigurationName)
    {
    }

    public LiveDirectoryClient(string endpointConfigurationName, string remoteAddress) :
        base(endpointConfigurationName, remoteAddress)
    {
    }

    public LiveDirectoryClient(string endpointConfigurationName, System.ServiceModel.EndpointAddress remoteAddress) :
        base(endpointConfigurationName, remoteAddress)
    {
    }

    public LiveDirectoryClient(System.ServiceModel.Channels.Binding binding, System.ServiceModel.EndpointAddress remoteAddress) :
        base(binding, remoteAddress)
    {
    }

    public void SetSNUserInfo(ushort sNetworkId, LiveConnectWeb.SNUserInfo userInfo)
    {
        base.Channel.SetSNUserInfo(sNetworkId, userInfo);
    }

    public void RemoveSNUserInfo(ushort sNetworkId, ulong XUID)
    {
        base.Channel.RemoveSNUserInfo(sNetworkId, XUID);
    }

    public LiveConnectWeb.SNUserInfo GetSNUserInfoByXUID(ushort sNetworkId, ulong XUID)
    {
        return base.Channel.GetSNUserInfoByXUID(sNetworkId, XUID);
    }

    public LiveConnectWeb.SNUserInfo GetSNUserInfoBySNUId(ushort sNetworkId, string snUserId)
    {
        return base.Channel.GetSNUserInfoBySNUId(sNetworkId, snUserId);
    }

    public LiveConnectWeb.SNUserInfo[] GetSNUserInfos(ushort sNetworkId, string[] sNUserIDs)
    {
        return base.Channel.GetSNUserInfos(sNetworkId, sNUserIDs);
    }

    public LiveConnectWeb.SNetworkInfo GetSNetworkInfo(ushort sNetworkId)
    {
        return base.Channel.GetSNetworkInfo(sNetworkId);
    }

    public LiveConnectWeb.SNetworkInfo[] GetSNetworkInfos()
    {
        return base.Channel.GetSNetworkInfos();
    }
}

[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
[System.ServiceModel.ServiceContractAttribute(Namespace = "http://liveconnect.xboxlive.com", ConfigurationName = "ILiveAuthentication")]
public interface ILiveAuthentication
{

    [System.ServiceModel.OperationContractAttribute(Action = "http://liveconnect.xboxlive.com/ILiveAuthentication/SetAuthInfo", ReplyAction = "http://liveconnect.xboxlive.com/ILiveAuthentication/SetAuthInfoResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ServiceModel.Security.SecurityAccessDeniedException), Action = "http://liveconnect.xboxlive.com/ILiveAuthentication/SetAuthInfoSecurityAccessDeni" +
        "edExceptionFault", Name = "SecurityAccessDeniedException", Namespace = "http://schemas.datacontract.org/2004/07/System.ServiceModel.Security")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentException), Action = "http://liveconnect.xboxlive.com/ILiveAuthentication/SetAuthInfoArgumentExceptionF" +
        "ault", Name = "ArgumentException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentOutOfRangeException), Action = "http://liveconnect.xboxlive.com/ILiveAuthentication/SetAuthInfoArgumentOutOfRange" +
        "ExceptionFault", Name = "ArgumentOutOfRangeException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentNullException), Action = "http://liveconnect.xboxlive.com/ILiveAuthentication/SetAuthInfoArgumentNullExcept" +
        "ionFault", Name = "ArgumentNullException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    void SetAuthInfo(ushort sNetworkId, ulong XUID, string gamerTag, string deviceId, LiveConnectWeb.SNAuthInfo userInfo, bool addToDirectory, LiveConnectWeb.Visibility visibility);

    [System.ServiceModel.OperationContractAttribute(Action = "http://liveconnect.xboxlive.com/ILiveAuthentication/GetAuthInfo", ReplyAction = "http://liveconnect.xboxlive.com/ILiveAuthentication/GetAuthInfoResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ServiceModel.Security.SecurityAccessDeniedException), Action = "http://liveconnect.xboxlive.com/ILiveAuthentication/GetAuthInfoSecurityAccessDeni" +
        "edExceptionFault", Name = "SecurityAccessDeniedException", Namespace = "http://schemas.datacontract.org/2004/07/System.ServiceModel.Security")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentNullException), Action = "http://liveconnect.xboxlive.com/ILiveAuthentication/GetAuthInfoArgumentNullExcept" +
        "ionFault", Name = "ArgumentNullException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentException), Action = "http://liveconnect.xboxlive.com/ILiveAuthentication/GetAuthInfoArgumentExceptionF" +
        "ault", Name = "ArgumentException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentOutOfRangeException), Action = "http://liveconnect.xboxlive.com/ILiveAuthentication/GetAuthInfoArgumentOutOfRange" +
        "ExceptionFault", Name = "ArgumentOutOfRangeException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    LiveConnectWeb.SNAuthInfo GetAuthInfo(ushort sNetworkId, ulong XUID, string deviceId);

    [System.ServiceModel.OperationContractAttribute(Action = "http://liveconnect.xboxlive.com/ILiveAuthentication/RemoveAuthInfo", ReplyAction = "http://liveconnect.xboxlive.com/ILiveAuthentication/RemoveAuthInfoResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentNullException), Action = "http://liveconnect.xboxlive.com/ILiveAuthentication/RemoveAuthInfoArgumentNullExc" +
        "eptionFault", Name = "ArgumentNullException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentException), Action = "http://liveconnect.xboxlive.com/ILiveAuthentication/RemoveAuthInfoArgumentExcepti" +
        "onFault", Name = "ArgumentException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ServiceModel.Security.SecurityAccessDeniedException), Action = "http://liveconnect.xboxlive.com/ILiveAuthentication/RemoveAuthInfoSecurityAccessD" +
        "eniedExceptionFault", Name = "SecurityAccessDeniedException", Namespace = "http://schemas.datacontract.org/2004/07/System.ServiceModel.Security")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentOutOfRangeException), Action = "http://liveconnect.xboxlive.com/ILiveAuthentication/RemoveAuthInfoArgumentOutOfRa" +
        "ngeExceptionFault", Name = "ArgumentOutOfRangeException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    void RemoveAuthInfo(ushort sNetworkId, ulong XUID, string deviceId);
}

[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
public interface ILiveAuthenticationChannel : ILiveAuthentication, System.ServiceModel.IClientChannel
{
}

[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
public partial class LiveAuthenticationClient : System.ServiceModel.ClientBase<ILiveAuthentication>, ILiveAuthentication
{

    public LiveAuthenticationClient()
    {
    }

    public LiveAuthenticationClient(string endpointConfigurationName) :
        base(endpointConfigurationName)
    {
    }

    public LiveAuthenticationClient(string endpointConfigurationName, string remoteAddress) :
        base(endpointConfigurationName, remoteAddress)
    {
    }

    public LiveAuthenticationClient(string endpointConfigurationName, System.ServiceModel.EndpointAddress remoteAddress) :
        base(endpointConfigurationName, remoteAddress)
    {
    }

    public LiveAuthenticationClient(System.ServiceModel.Channels.Binding binding, System.ServiceModel.EndpointAddress remoteAddress) :
        base(binding, remoteAddress)
    {
    }

    public void SetAuthInfo(ushort sNetworkId, ulong XUID, string gamerTag, string deviceId, LiveConnectWeb.SNAuthInfo userInfo, bool addToDirectory, LiveConnectWeb.Visibility visibility)
    {
        base.Channel.SetAuthInfo(sNetworkId, XUID, gamerTag, deviceId, userInfo, addToDirectory, visibility);
    }

    public LiveConnectWeb.SNAuthInfo GetAuthInfo(ushort sNetworkId, ulong XUID, string deviceId)
    {
        return base.Channel.GetAuthInfo(sNetworkId, XUID, deviceId);
    }

    public void RemoveAuthInfo(ushort sNetworkId, ulong XUID, string deviceId)
    {
        base.Channel.RemoveAuthInfo(sNetworkId, XUID, deviceId);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup1\Monitoring\LiveConnectPing\STS\CustomSignedXml.cs ===
using System;
using System.Collections.Generic;
using System.Web;
using System.Xml;
using System.Xml.Serialization;
using System.Security.Cryptography;
using System.Security.Cryptography.Xml;


namespace LiveConnectPing
{

    // http://blogs.msdn.com/shawnfa/archive/2004/04/05/108098.aspx
    // Searching for Custom ID Tags With Signed XML
    // Excerpt... The biggest limitation with doing this is that you must refer to the nodes that are being signed by ID, 
    // which for v1.1 and 1.0 of the framework was given by an attribute named "Id". The problem there is that 
    // the Id attribute may already have another use in your schema, and you cannot reuse them for creating node names. 
    // Another problem that may come up is that the XML being signed may be generated by a tool or program, 
    // and it's not possible for you to add Id tags. Whidbey reduces this limitation somewhat by also allowing 
    // "id" and "ID", but the fundamental problem still exists.

    // Nodes that are being referred to by ID are resolved in the GetIdElement method of the SignedXml class. 
    // By subclassing SignedXml and overriding this method, its possible to create your own id node resolver. 


    public class CustomSignedXml : SignedXml
    {
        public CustomSignedXml(XmlDocument doc) :
            base(doc)
        {
        }

        public override XmlElement GetIdElement(XmlDocument doc, string id)
        {
            // check to see if it's a standard ID reference
            XmlElement idElem = base.GetIdElement(doc, id);
            if (idElem != null)
                return idElem;

            idElem = doc.SelectSingleNode("//*[@AssertionID=\"" + id + "\"]") as XmlElement;
            return idElem;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup1\Monitoring\LiveConnectPing\STS\Player.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace LiveConnectPing
{
    /// <summary>
    /// 
    /// </summary>
    public class Player
    {
        /// <summary>
        /// 
        /// </summary>
        public ulong Xuid
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public byte Tier
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public byte Country
        {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup1\Monitoring\LiveConnectPing\Utility.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
using System.Reflection;
using System.IO;

namespace LiveConnectPing
{
    /// <summary>
    /// 
    /// </summary>
    public class Utility
    {
        private static Random rnd = new Random();
        private static object rndLock = new object();
        private static char[] whitespaceChars;
        private static string currentDirectory;
        private static string originalAssemblyDirectory;
        private static char[] gamerTagChars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 ".ToCharArray();        

        /// <summary>
        /// 
        /// </summary>
        static Utility()
        {
            FileInfo assemblyFile = new FileInfo(new Uri(Assembly.GetExecutingAssembly().CodeBase).LocalPath);
            currentDirectory = assemblyFile.DirectoryName;
            originalAssemblyDirectory = String.IsNullOrEmpty(AppDomain.CurrentDomain.SetupInformation.PrivateBinPath) ? String.Empty : AppDomain.CurrentDomain.SetupInformation.PrivateBinPath;
            if (!Directory.Exists(originalAssemblyDirectory))
            {
                originalAssemblyDirectory = String.Empty;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        private static char[] WhitespaceChars
        {
            get
            {
                if (whitespaceChars == null)
                {
                    Type stringType = typeof(string);
                    object chars = stringType.InvokeMember("WhitespaceChars", BindingFlags.GetField | BindingFlags.NonPublic | BindingFlags.Static, null, null, null);
                    whitespaceChars = chars as char[];
                }

                return whitespaceChars;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public static Random GlobalRandom
        {
            get
            {
                //NOTE: NOT thread safe!
                return rnd;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public static string CurrentDirectory
        {
            get
            {
                return currentDirectory;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public static string OriginalAssemblyDirectory
        {
            get
            {
                return originalAssemblyDirectory;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="max"></param>
        /// <returns></returns>
        public static int GenerateRandomNumber(int max)
        {
            lock (rndLock)
            {
                return rnd.Next(max);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="min"></param>
        /// <param name="max"></param>
        /// <returns></returns>
        public static int GenerateRandomNumber(int min, int max)
        {
            lock (rndLock)
            {
                return rnd.Next(min, max);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="length"></param>
        /// <returns></returns>
        public static string GenerateRandomString()
        {
            return GenerateRandomString(GenerateRandomNumber(1024));
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="length"></param>
        /// <returns></returns>
        public static string GenerateRandomString(int length)
        {
            return GenerateRandomString(length, null);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="length"></param>
        /// <returns></returns>
        public static string GenerateRandomString(int length, char[] excludeChars)
        {
            StringBuilder value = new StringBuilder(length);
            for (int i = 0; i < length; )
            {
                char temp = (char)GenerateRandomNumber(127);    //(char)GenerateRandomNumber(33, 127);
                if (!char.IsControl(temp) && (excludeChars == null || !excludeChars.Contains<char>(temp)))
                {
                    value.Append(temp);
                    i++;
                }
            }

            return value.ToString().Trim();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public static ulong GenerateRandomUInt64()
        {
            byte[] buffer = new byte[sizeof(ulong)];
            RNGCryptoServiceProvider rng = new RNGCryptoServiceProvider();
            rng.GetNonZeroBytes(buffer);
            return BitConverter.ToUInt64(buffer, 0);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public static uint GenerateRandomUInt32()
        {
            byte[] buffer = new byte[sizeof(uint)];
            RNGCryptoServiceProvider rng = new RNGCryptoServiceProvider();
            rng.GetNonZeroBytes(buffer);
            return BitConverter.ToUInt32(buffer, 0);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="array"></param>
        /// <returns></returns>
        public static string ArrayToString(Array array)
        {
            return ArrayToString(array, ", ");
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="array"></param>
        /// <returns></returns>
        public static string ArrayToString(Array array, string divider)
        {
            StringBuilder values = new StringBuilder();
            foreach (object obj in array)
            {
                values.Append(obj);
                values.Append(divider);
            }

            values.Length -= divider.Length;
            return values.ToString();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="length"></param>
        /// <returns></returns>
        public static string WhitespaceString(int length)
        {
            StringBuilder whitespace = new StringBuilder(length);
            Random rnd = new Random(unchecked((int)DateTime.Now.Ticks));

            for (int i = 0; i < length; i++)
                whitespace.Append(WhitespaceChars[rnd.Next(WhitespaceChars.Length)]);
            return whitespace.ToString();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="input"></param>    
        /// <returns></returns>
        public static string AppendWhitespace(object input)
        {
            return AppendWhitespace(input, true, true);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="input"></param>
        /// <param name="before"></param>
        /// <param name="after"></param>
        /// <returns></returns>
        public static string AppendWhitespace(object input, bool before, bool after)
        {
            StringBuilder newString = new StringBuilder(input.ToString());
            Random rnd = new Random(unchecked((int)DateTime.Now.Ticks));

            if (before)
                newString.Insert(0, WhitespaceString(rnd.Next(1, 5)));
            if (after)
                newString.Append(WhitespaceString(rnd.Next(1, 5)));
            return newString.ToString();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="length"></param>
        /// <returns></returns>
        public static string GenerateUnicodeString(int length)
        {
            StringBuilder sb = new StringBuilder();
            while (sb.Length < length)
            {
                char c = (char)GenerateRandomNumber(0x20, 0xfff0);
                if ((((c < '') || (c > '')) && ((c < 0xd800) || (c > 0xdfff))) && (((c < 0xe000) || (c > 0xf8ff)) && (c != 0xfeff)))
                {
                    sb.Append(c);
                }
            }
            return sb.ToString();

        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public static string GenerateRandomGamerTag(int length)
        {
            StringBuilder gamerTag = new StringBuilder(length);
            gamerTag.Append(gamerTagChars[Utility.GlobalRandom.Next(51)]);  //first char can't be a number/space

            int i = 0;
            while (i < length)
            {
                char nextChar = gamerTagChars[Utility.GlobalRandom.Next(gamerTagChars.Length - 1)];
                if (nextChar == ' ' && gamerTag[gamerTag.Length - 1] == ' ') //can't have consecutive spaces
                    continue;
                gamerTag.Append(nextChar);
                i++;
            }

            return gamerTag.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup1\Monitoring\LiveConnectPing\STS\StsTokenParameters.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace LiveConnectPing
{
    /// <summary>
    /// 
    /// </summary>
    public class StsTokenParameters
    {
        /// <summary>
        /// 
        /// </summary>
        public StsTokenParameters()
        {
            //default to regular STS value of 60 mins for a valid token
            this.MinutesToExpire = 60;
            //only the Authentication interface calls (that use deviceId) need to make sure this value is in sync w/ the test
            this.MachineId = Utility.GenerateRandomUInt64();
        }

        /// <summary>
        /// 
        /// </summary>
        public ulong Xuid
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public uint TitleId
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string TitleVersion
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public ulong MachineId
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string DeviceId
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string ClientVersion
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string PlatformType
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string Puid
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string CID
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string GamerTag
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string Tier
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string Country
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string Privileges
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public int MinutesToExpire
        {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup1\Monitoring\LiveConnectPing\CommandLineArguments.cs ===
//////////////////////////////////////////////////////////////////////////////
//    Command Line Argument Parser
//    ----------------------------
//
//    Author: hotweird@hotmail.com
//
//    Microsoft Public License (Ms-PL)
//
//    This license governs use of the accompanying software. If you use the software, you
//    accept this license. If you do not accept the license, do not use the software.
//
//    1. Definitions
//
//    The terms "reproduce," "reproduction," "derivative works," and "distribution" have the
//    same meaning here as under U.S. copyright law.
//
//    A "contribution" is the original software, or any additions or changes to the software.
//
//    A "contributor" is any person that distributes its contribution under this license.
//
//    "Licensed patents" are a contributor's patent claims that read directly on its contribution.
//
//    2. Grant of Rights
//
//    (A) Copyright Grant- Subject to the terms of this license, including the license conditions
//        and limitations in section 3, each contributor grants you a non-exclusive, worldwide,
//        royalty-free copyright license to reproduce its contribution, prepare derivative works
//        of its contribution, and distribute its contribution or any derivative works that you create.
//
//    (B) Patent Grant- Subject to the terms of this license, including the license conditions and
//        limitations in section 3, each contributor grants you a non-exclusive, worldwide,
//        royalty-free license under its licensed patents to make, have made, use, sell, offer for
//        sale, import, and/or otherwise dispose of its contribution in the software or derivative
//        works of the contribution in the software.
//
//    3. Conditions and Limitations
//
//    (A) No Trademark License- This license does not grant you rights to use any contributors'
//        name, logo, or trademarks.
//
//    (B) If you bring a patent claim against any contributor over patents that you claim are
//        infringed by the software, your patent license from such contributor to the software ends
//        automatically.
//
//    (C) If you distribute any portion of the software, you must retain all copyright, patent,
//        trademark, and attribution notices that are present in the software.
//
//    (D) If you distribute any portion of the software in source code form, you may do so only under
//        this license by including a complete copy of this license with your distribution. If you
//        distribute any portion of the software in compiled or object code form, you may only do so
//        under a license that complies with this license.
//
//    (E) The software is licensed "as-is." You bear the risk of using it. The contributors give no
//        express warranties, guarantees or conditions. You may have additional consumer rights under
//        your local laws which this license cannot change. To the extent permitted under your local
//        laws, the contributors exclude the implied warranties of merchantability, fitness for a
//        particular purpose and non-infringement.
//
//    Usage
//    -----
//
//    Parsing command line arguments to a console application is a common problem. 
//    This library handles the common task of reading arguments from a command line 
//    and filling in the values in a type.
//
//    To use this library, define a class whose fields represent the data that your 
//    application wants to receive from arguments on the command line. Then call 
//    CommandLine.ParseArguments() to fill the object with the data 
//    from the command line. Each field in the class defines a command line argument. 
//    The type of the field is used to validate the data read from the command line. 
//    The name of the field defines the name of the command line option.
//
//    The parser can handle fields of the following types:
//
//    - string
//    - int
//    - uint
//    - bool
//    - enum
//    - array of the above type
//
//    For example, suppose you want to read in the argument list for wc (word count). 
//    wc takes three optional boolean arguments: -l, -w, and -c and a list of files.
//
//    You could parse these arguments using the following code:
//
//    class WCArguments
//    {
//        public bool lines;
//        public bool words;
//        public bool chars;
//        public string[] files;
//    }
//
//    class WC
//    {
//        static void Main(string[] args)
//        {
//            if (CommandLine.ParseArgumentsWithUsage(args, parsedArgs))
//            {
//            //     insert application code here
//            }
//        }
//    }
//
//    So you could call this aplication with the following command line to count 
//    lines in the foo and bar files:
//
//        wc.exe /lines /files:foo /files:bar
//
//    The program will display the following usage message when bad command line 
//    arguments are used:
//
//        wc.exe -x
//
//    Unrecognized command line argument '-x'
//        /lines[+|-]                         short form /l
//        /words[+|-]                         short form /w
//        /chars[+|-]                         short form /c
//        /files:<string>                     short form /f
//        @<file>                             Read response file for more options
//
//    That was pretty easy. However, you realy want to omit the "/files:" for the 
//    list of files. The details of field parsing can be controled using custom 
//    attributes. The attributes which control parsing behaviour are:
//
//    ArgumentAttribute 
//        - controls short name, long name, required, allow duplicates, default value
//        and help text
//    DefaultArgumentAttribute 
//        - allows omition of the "/name".
//        - This attribute is allowed on only one field in the argument class.
//
//    So for the wc.exe program we want this:
//
//    using System;
//    using Utilities;
//
//    class WCArguments
//    {
//        [Argument(ArgumentType.AtMostOnce, HelpText="Count number of lines in the input text.")]
//        public bool lines;
//        [Argument(ArgumentType.AtMostOnce, HelpText="Count number of words in the input text.")]
//        public bool words;
//        [Argument(ArgumentType.AtMostOnce, HelpText="Count number of chars in the input text.")]
//        public bool chars;
//        [DefaultArgument(ArgumentType.MultipleUnique, HelpText="Input files to count.")]
//        public string[] files;
//    }
//
//    class WC
//    {
//        static void Main(string[] args)
//        {
//            WCArguments parsedArgs = new WCArguments();
//            if (CommandLine.ParseArgumentsWithUsage(args, parsedArgs))
//            {
//            //     insert application code here
//            }
//        }
//    }
//
//
//
//    So now we have the command line we want:
//
//        wc.exe /lines foo bar
//
//    This will set lines to true and will set files to an array containing the 
//    strings "foo" and "bar".
//
//    The new usage message becomes:
//
//        wc.exe -x
//
//    Unrecognized command line argument '-x'
//    /lines[+|-]  Count number of lines in the input text. (short form /l)
//    /words[+|-]  Count number of words in the input text. (short form /w)
//    /chars[+|-]  Count number of chars in the input text. (short form /c)
//    @<file>      Read response file for more options
//    <files>      Input files to count. (short form /f)
//
//    If you want more control over how error messages are reported, how /help is 
//    dealt with, etc you can instantiate the CommandLine.Parser class.
//
//
//
//    Cheers,
//    Peter Hallam
//    C# Compiler Developer
//    Microsoft Corp.
//
//
//
//
//    Release Notes
//    -------------
//
//    10/02/2002 Initial Release
//    10/14/2002 Bug Fix
//    01/08/2003 Bug Fix in @ include files
//    10/23/2004 Added user specified help text, formatting of help text to 
//            screen width. Added ParseHelp for /?.
//    11/23/2004 Added support for default values.
//    02/23/2005 Fix bug with short name and default arguments.
//////////////////////////////////////////////////////////////////////////////
namespace CommandLine
{
    using System;
    using System.Diagnostics;
    using System.Reflection;
    using System.Collections;
    using System.IO;
    using System.Text;
    using System.Runtime.InteropServices;

    /// <summary>
    /// Used to control parsing of command line arguments.
    /// </summary>
    [Flags]
    public enum ArgumentType
    {
        /// <summary>
        /// Indicates that this field is required. An error will be displayed
        /// if it is not present when parsing arguments.
        /// </summary>
        Required = 0x01,
        /// <summary>
        /// Only valid in conjunction with Multiple.
        /// Duplicate values will result in an error.
        /// </summary>
        Unique = 0x02,
        /// <summary>
        /// Inidicates that the argument may be specified more than once.
        /// Only valid if the argument is a collection
        /// </summary>
        Multiple = 0x04,

        /// <summary>
        /// The default type for non-collection arguments.
        /// The argument is not required, but an error will be reported if it is specified more than once.
        /// </summary>
        AtMostOnce = 0x00,

        /// <summary>
        /// For non-collection arguments, when the argument is specified more than
        /// once no error is reported and the value of the argument is the last
        /// value which occurs in the argument list.
        /// </summary>
        LastOccurenceWins = Multiple,

        /// <summary>
        /// The default type for collection arguments.
        /// The argument is permitted to occur multiple times, but duplicate 
        /// values will cause an error to be reported.
        /// </summary>
        MultipleUnique = Multiple | Unique,
    }

    /// <summary>
    /// Allows control of command line parsing.
    /// Attach this attribute to instance fields of types used
    /// as the destination of command line argument parsing.
    /// </summary>
    [AttributeUsage(AttributeTargets.Field)]
    public class ArgumentAttribute : Attribute
    {
        /// <summary>
        /// Allows control of command line parsing.
        /// </summary>
        /// <param name="type"> Specifies the error checking to be done on the argument. </param>
        public ArgumentAttribute(ArgumentType type)
        {
            this.type = type;
        }

        /// <summary>
        /// The error checking to be done on the argument.
        /// </summary>
        public ArgumentType Type
        {
            get { return this.type; }
        }
        /// <summary>
        /// Returns true if the argument did not have an explicit short name specified.
        /// </summary>
        public bool DefaultShortName { get { return null == this.shortName; } }

        /// <summary>
        /// The short name of the argument.
        /// Set to null means use the default short name if it does not
        /// conflict with any other parameter name.
        /// Set to String.Empty for no short name.
        /// This property should not be set for DefaultArgumentAttributes.
        /// </summary>
        public string ShortName
        {
            get { return this.shortName; }
            set { Debug.Assert(value == null || !(this is DefaultArgumentAttribute)); this.shortName = value; }
        }

        /// <summary>
        /// Returns true if the argument did not have an explicit long name specified.
        /// </summary>
        public bool DefaultLongName { get { return null == this.longName; } }

        /// <summary>
        /// The long name of the argument.
        /// Set to null means use the default long name.
        /// The long name for every argument must be unique.
        /// It is an error to specify a long name of String.Empty.
        /// </summary>
        public string LongName
        {
            get { Debug.Assert(!this.DefaultLongName); return this.longName; }
            set { Debug.Assert(value != ""); this.longName = value; }
        }

        /// <summary>
        /// The default value of the argument.
        /// </summary>
        public object DefaultValue
        {
            get { return this.defaultValue; }
            set { this.defaultValue = value; }
        }

        /// <summary>
        /// Returns true if the argument has a default value.
        /// </summary>
        public bool HasDefaultValue { get { return null != this.defaultValue; } }

        /// <summary>
        /// Returns true if the argument has help text specified.
        /// </summary>
        public bool HasHelpText { get { return null != this.helpText; } }

        /// <summary>
        /// The help text for the argument.
        /// </summary>
        public string HelpText
        {
            get { return this.helpText; }
            set { this.helpText = value; }
        }

        private string shortName;
        private string longName;
        private string helpText;
        private object defaultValue;
        private ArgumentType type;
    }

    /// <summary>
    /// Indicates that this argument is the default argument.
    /// '/' or '-' prefix only the argument value is specified.
    /// The ShortName property should not be set for DefaultArgumentAttribute
    /// instances. The LongName property is used for usage text only and
    /// does not affect the usage of the argument.
    /// </summary>
    [AttributeUsage(AttributeTargets.Field)]
    public class DefaultArgumentAttribute : ArgumentAttribute
    {
        /// <summary>
        /// Indicates that this argument is the default argument.
        /// </summary>
        /// <param name="type"> Specifies the error checking to be done on the argument. </param>
        public DefaultArgumentAttribute(ArgumentType type)
            : base(type)
        {
        }
    }

    /// <summary>
    /// A delegate used in error reporting.
    /// </summary>
    public delegate void ErrorReporter(string message);

    /// <summary>
    /// Parser for command line arguments.
    ///
    /// The parser specification is infered from the instance fields of the object
    /// specified as the destination of the parse.
    /// Valid argument types are: int, uint, string, bool, enums
    /// Also argument types of Array of the above types are also valid.
    /// 
    /// Error checking options can be controlled by adding a ArgumentAttribute
    /// to the instance fields of the destination object.
    ///
    /// At most one field may be marked with the DefaultArgumentAttribute
    /// indicating that arguments without a '-' or '/' prefix will be parsed as that argument.
    ///
    /// If not specified then the parser will infer default options for parsing each
    /// instance field. The default long name of the argument is the field name. The
    /// default short name is the first character of the long name. Long names and explicitly
    /// specified short names must be unique. Default short names will be used provided that
    /// the default short name does not conflict with a long name or an explicitly
    /// specified short name.
    ///
    /// Arguments which are array types are collection arguments. Collection
    /// arguments can be specified multiple times.
    /// </summary>
    public sealed class Parser
    {
        /// <summary>
        /// The System Defined new line string.
        /// </summary>
        public const string NewLine = "\r\n";

        /// <summary>
        /// Don't ever call this.
        /// </summary>
        private Parser() { }

        /// <summary>
        /// Parses Command Line Arguments. Displays usage message to Console.Out
        /// if /?, /help or invalid arguments are encounterd.
        /// Errors are output on Console.Error.
        /// Use ArgumentAttributes to control parsing behaviour.
        /// </summary>
        /// <param name="arguments"> The actual arguments. </param>
        /// <param name="destination"> The resulting parsed arguments. </param>
        /// <returns> true if no errors were detected. </returns>
        public static bool ParseArgumentsWithUsage(string[] arguments, object destination)
        {
            if (Parser.ParseHelp(arguments) || !Parser.ParseArguments(arguments, destination))
            {
                // error encountered in arguments. Display usage message
                System.Console.Write(Parser.ArgumentsUsage(destination.GetType()));
                return false;
            }

            return true;
        }

        /// <summary>
        /// Parses Command Line Arguments. 
        /// Errors are output on Console.Error.
        /// Use ArgumentAttributes to control parsing behaviour.
        /// </summary>
        /// <param name="arguments"> The actual arguments. </param>
        /// <param name="destination"> The resulting parsed arguments. </param>
        /// <returns> true if no errors were detected. </returns>
        public static bool ParseArguments(string[] arguments, object destination)
        {
            return Parser.ParseArguments(arguments, destination, new ErrorReporter(Console.Error.WriteLine));
        }

        /// <summary>
        /// Parses Command Line Arguments. 
        /// Use ArgumentAttributes to control parsing behaviour.
        /// </summary>
        /// <param name="arguments"> The actual arguments. </param>
        /// <param name="destination"> The resulting parsed arguments. </param>
        /// <param name="reporter"> The destination for parse errors. </param>
        /// <returns> true if no errors were detected. </returns>
        public static bool ParseArguments(string[] arguments, object destination, ErrorReporter reporter)
        {
            Parser parser = new Parser(destination.GetType(), reporter);
            return parser.Parse(arguments, destination);
        }

        private static void NullErrorReporter(string message)
        {
        }

        private class HelpArgument
        {
            [ArgumentAttribute(ArgumentType.AtMostOnce, ShortName = "?")]
            public bool help = false;
        }

        /// <summary>
        /// Checks if a set of arguments asks for help.
        /// </summary>
        /// <param name="args"> Args to check for help. </param>
        /// <returns> Returns true if args contains /? or /help. </returns>
        public static bool ParseHelp(string[] args)
        {
            Parser helpParser = new Parser(typeof(HelpArgument), new ErrorReporter(NullErrorReporter));
            HelpArgument helpArgument = new HelpArgument();
            helpParser.Parse(args, helpArgument);
            return helpArgument.help;
        }


        /// <summary>
        /// Returns a Usage string for command line argument parsing.
        /// Use ArgumentAttributes to control parsing behaviour.
        /// Formats the output to the width of the current console window.
        /// </summary>
        /// <param name="argumentType"> The type of the arguments to display usage for. </param>
        /// <returns> Printable string containing a user friendly description of command line arguments. </returns>
        public static string ArgumentsUsage(Type argumentType)
        {
            int screenWidth = Parser.GetConsoleWindowWidth();
            if (screenWidth == 0)
                screenWidth = 80;
            return ArgumentsUsage(argumentType, screenWidth);
        }

        /// <summary>
        /// Returns a Usage string for command line argument parsing.
        /// Use ArgumentAttributes to control parsing behaviour.
        /// </summary>
        /// <param name="argumentType"> The type of the arguments to display usage for. </param>
        /// <param name="columns"> The number of columns to format the output to. </param>
        /// <returns> Printable string containing a user friendly description of command line arguments. </returns>
        public static string ArgumentsUsage(Type argumentType, int columns)
        {
            return (new Parser(argumentType, null)).GetUsageString(columns);
        }

        private const int STD_OUTPUT_HANDLE = -11;

        private struct COORD
        {
            internal Int16 x;
            internal Int16 y;
        }

        private struct SMALL_RECT
        {
            internal Int16 Left;
            internal Int16 Top;
            internal Int16 Right;
            internal Int16 Bottom;
        }

        private struct CONSOLE_SCREEN_BUFFER_INFO
        {
            internal COORD dwSize;
            internal COORD dwCursorPosition;
            internal Int16 wAttributes;
            internal SMALL_RECT srWindow;
            internal COORD dwMaximumWindowSize;
        }

        [DllImport("kernel32.dll", EntryPoint = "GetStdHandle", SetLastError = true, CharSet = CharSet.Auto, CallingConvention = CallingConvention.StdCall)]
        private static extern int GetStdHandle(int nStdHandle);

        [DllImport("kernel32.dll", EntryPoint = "GetConsoleScreenBufferInfo", SetLastError = true, CharSet = CharSet.Auto, CallingConvention = CallingConvention.StdCall)]
        private static extern int GetConsoleScreenBufferInfo(int hConsoleOutput, ref CONSOLE_SCREEN_BUFFER_INFO lpConsoleScreenBufferInfo);

        /// <summary>
        /// Returns the number of columns in the current console window
        /// </summary>
        /// <returns>Returns the number of columns in the current console window</returns>
        public static int GetConsoleWindowWidth()
        {
            int screenWidth;
            CONSOLE_SCREEN_BUFFER_INFO csbi = new CONSOLE_SCREEN_BUFFER_INFO();

            int rc;
            rc = GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), ref csbi);
            screenWidth = csbi.dwSize.x;
            return screenWidth;
        }

        /// <summary>
        /// Searches a StringBuilder for a character
        /// </summary>
        /// <param name="text"> The text to search. </param>
        /// <param name="value"> The character value to search for. </param>
        /// <param name="startIndex"> The index to stat searching at. </param>
        /// <returns> The index of the first occurence of value or -1 if it is not found. </returns>
        public static int IndexOf(StringBuilder text, char value, int startIndex)
        {
            for (int index = startIndex; index < text.Length; index++)
            {
                if (text[index] == value)
                    return index;
            }

            return -1;
        }

        /// <summary>
        /// Searches a StringBuilder for a character in reverse
        /// </summary>
        /// <param name="text"> The text to search. </param>
        /// <param name="value"> The character to search for. </param>
        /// <param name="startIndex"> The index to start the search at. </param>
        /// <returns>The index of the last occurence of value in text or -1 if it is not found. </returns>
        public static int LastIndexOf(StringBuilder text, char value, int startIndex)
        {
            for (int index = Math.Min(startIndex, text.Length - 1); index >= 0; index--)
            {
                if (text[index] == value)
                    return index;
            }

            return -1;
        }

        private const int spaceBeforeParam = 2;

        /// <summary>
        /// Creates a new command line argument parser.
        /// </summary>
        /// <param name="argumentSpecification"> The type of object to  parse. </param>
        /// <param name="reporter"> The destination for parse errors. </param>
        public Parser(Type argumentSpecification, ErrorReporter reporter)
        {
            this.reporter = reporter;
            this.arguments = new ArrayList();
            this.argumentMap = new Hashtable();

            foreach (FieldInfo field in argumentSpecification.GetFields())
            {
                if (!field.IsStatic && !field.IsInitOnly && !field.IsLiteral)
                {
                    ArgumentAttribute attribute = GetAttribute(field);
                    if (attribute is DefaultArgumentAttribute)
                    {
                        Debug.Assert(this.defaultArgument == null);
                        this.defaultArgument = new Argument(attribute, field, reporter);
                    }
                    else
                    {
                        this.arguments.Add(new Argument(attribute, field, reporter));
                    }
                }
            }

            // add explicit names to map
            foreach (Argument argument in this.arguments)
            {
                Debug.Assert(!argumentMap.ContainsKey(argument.LongName));
                this.argumentMap[argument.LongName] = argument;
                if (argument.ExplicitShortName)
                {
                    if (argument.ShortName != null && argument.ShortName.Length > 0)
                    {
                        Debug.Assert(!argumentMap.ContainsKey(argument.ShortName));
                        this.argumentMap[argument.ShortName] = argument;
                    }
                    else
                    {
                        argument.ClearShortName();
                    }
                }
            }

            // add implicit names which don't collide to map
            foreach (Argument argument in this.arguments)
            {
                if (!argument.ExplicitShortName)
                {
                    if (argument.ShortName != null && argument.ShortName.Length > 0 && !argumentMap.ContainsKey(argument.ShortName))
                        this.argumentMap[argument.ShortName] = argument;
                    else
                        argument.ClearShortName();
                }
            }
        }

        private static ArgumentAttribute GetAttribute(FieldInfo field)
        {
            object[] attributes = field.GetCustomAttributes(typeof(ArgumentAttribute), false);
            if (attributes.Length == 1)
                return (ArgumentAttribute)attributes[0];

            Debug.Assert(attributes.Length == 0);
            return null;
        }

        private void ReportUnrecognizedArgument(string argument)
        {
            this.reporter(string.Format("Unrecognized command line argument '{0}'", argument));
        }

        /// <summary>
        /// Parses an argument list into an object
        /// </summary>
        /// <param name="args"></param>
        /// <param name="destination"></param>
        /// <returns> true if an error occurred </returns>
        private bool ParseArgumentList(string[] args, object destination)
        {
            bool hadError = false;
            if (args != null)
            {
                foreach (string argument in args)
                {
                    if (argument.Length > 0)
                    {
                        switch (argument[0])
                        {
                            case '-':
                            case '/':
                                int endIndex = argument.IndexOfAny(new char[] { ':', '+', '-' }, 1);
                                string option = argument.Substring(1, endIndex == -1 ? argument.Length - 1 : endIndex - 1);
                                string optionArgument;
                                if (option.Length + 1 == argument.Length)
                                {
                                    optionArgument = null;
                                }
                                else if (argument.Length > 1 + option.Length && argument[1 + option.Length] == ':')
                                {
                                    optionArgument = argument.Substring(option.Length + 2);
                                }
                                else
                                {
                                    optionArgument = argument.Substring(option.Length + 1);
                                }

                                Argument arg = (Argument)this.argumentMap[option];
                                if (arg == null)
                                {
                                    ReportUnrecognizedArgument(argument);
                                    hadError = true;
                                }
                                else
                                {
                                    hadError |= !arg.SetValue(optionArgument, destination);
                                }
                                break;
                            case '@':
                                string[] nestedArguments;
                                hadError |= LexFileArguments(argument.Substring(1), out nestedArguments);
                                hadError |= ParseArgumentList(nestedArguments, destination);
                                break;
                            default:
                                if (this.defaultArgument != null)
                                {
                                    hadError |= !this.defaultArgument.SetValue(argument, destination);
                                }
                                else
                                {
                                    ReportUnrecognizedArgument(argument);
                                    hadError = true;
                                }
                                break;
                        }
                    }
                }
            }

            return hadError;
        }

        /// <summary>
        /// Parses an argument list.
        /// </summary>
        /// <param name="args"> The arguments to parse. </param>
        /// <param name="destination"> The destination of the parsed arguments. </param>
        /// <returns> true if no parse errors were encountered. </returns>
        public bool Parse(string[] args, object destination)
        {
            bool hadError = ParseArgumentList(args, destination);

            // check for missing required arguments
            foreach (Argument arg in this.arguments)
            {
                hadError |= arg.Finish(destination);
            }
            if (this.defaultArgument != null)
            {
                hadError |= this.defaultArgument.Finish(destination);
            }

            return !hadError;
        }

        private struct ArgumentHelpStrings
        {
            public ArgumentHelpStrings(string syntax, string help)
            {
                this.syntax = syntax;
                this.help = help;
            }

            public string syntax;
            public string help;
        }

        /// <summary>
        /// A user firendly usage string describing the command line argument syntax.
        /// </summary>
        public string GetUsageString(int screenWidth)
        {
            ArgumentHelpStrings[] strings = GetAllHelpStrings();

            int maxParamLen = 0;
            foreach (ArgumentHelpStrings helpString in strings)
            {
                maxParamLen = Math.Max(maxParamLen, helpString.syntax.Length);
            }

            const int minimumNumberOfCharsForHelpText = 10;
            const int minimumHelpTextColumn = 5;
            const int minimumScreenWidth = minimumHelpTextColumn + minimumNumberOfCharsForHelpText;

            int helpTextColumn;
            int idealMinimumHelpTextColumn = maxParamLen + spaceBeforeParam;
            screenWidth = Math.Max(screenWidth, minimumScreenWidth);
            if (screenWidth < (idealMinimumHelpTextColumn + minimumNumberOfCharsForHelpText))
                helpTextColumn = minimumHelpTextColumn;
            else
                helpTextColumn = idealMinimumHelpTextColumn;

            const string newLine = "\n";
            StringBuilder builder = new StringBuilder();
            foreach (ArgumentHelpStrings helpStrings in strings)
            {
                // add syntax string
                int syntaxLength = helpStrings.syntax.Length;
                builder.Append(helpStrings.syntax);

                // start help text on new line if syntax string is too long
                int currentColumn = syntaxLength;
                if (syntaxLength >= helpTextColumn)
                {
                    builder.Append(newLine);
                    currentColumn = 0;
                }

                // add help text broken on spaces
                int charsPerLine = screenWidth - helpTextColumn;
                int index = 0;
                while (index < helpStrings.help.Length)
                {
                    // tab to start column
                    builder.Append(' ', helpTextColumn - currentColumn);
                    currentColumn = helpTextColumn;

                    // find number of chars to display on this line
                    int endIndex = index + charsPerLine;
                    if (endIndex >= helpStrings.help.Length)
                    {
                        // rest of text fits on this line
                        endIndex = helpStrings.help.Length;
                    }
                    else
                    {
                        endIndex = helpStrings.help.LastIndexOf(' ', endIndex - 1, Math.Min(endIndex - index, charsPerLine));
                        if (endIndex <= index)
                        {
                            // no spaces on this line, append full set of chars
                            endIndex = index + charsPerLine;
                        }
                    }

                    // add chars
                    builder.Append(helpStrings.help, index, endIndex - index);
                    index = endIndex;

                    // do new line
                    AddNewLine(newLine, builder, ref currentColumn);

                    // don't start a new line with spaces
                    while (index < helpStrings.help.Length && helpStrings.help[index] == ' ')
                        index++;
                }

                // add newline if there's no help text                
                if (helpStrings.help.Length == 0)
                {
                    builder.Append(newLine);
                }
            }

            return builder.ToString();
        }
        private static void AddNewLine(string newLine, StringBuilder builder, ref int currentColumn)
        {
            builder.Append(newLine);
            currentColumn = 0;
        }
        private ArgumentHelpStrings[] GetAllHelpStrings()
        {
            ArgumentHelpStrings[] strings = new ArgumentHelpStrings[NumberOfParametersToDisplay()];

            int index = 0;
            foreach (Argument arg in this.arguments)
            {
                strings[index] = GetHelpStrings(arg);
                index++;
            }
            strings[index++] = new ArgumentHelpStrings("@<file>", "Read response file for more options");
            if (this.defaultArgument != null)
                strings[index++] = GetHelpStrings(this.defaultArgument);

            return strings;
        }

        private static ArgumentHelpStrings GetHelpStrings(Argument arg)
        {
            return new ArgumentHelpStrings(arg.SyntaxHelp, arg.FullHelpText);
        }

        private int NumberOfParametersToDisplay()
        {
            int numberOfParameters = this.arguments.Count + 1;
            if (HasDefaultArgument)
                numberOfParameters += 1;
            return numberOfParameters;
        }

        /// <summary>
        /// Does this parser have a default argument.
        /// </summary>
        /// <value> Does this parser have a default argument. </value>
        public bool HasDefaultArgument
        {
            get { return this.defaultArgument != null; }
        }

        private bool LexFileArguments(string fileName, out string[] arguments)
        {
            string args = null;

            try
            {
                using (FileStream file = new FileStream(fileName, FileMode.Open, FileAccess.Read))
                {
                    args = (new StreamReader(file)).ReadToEnd();
                }
            }
            catch (Exception e)
            {
                this.reporter(string.Format("Error: Can't open command line argument file '{0}' : '{1}'", fileName, e.Message));
                arguments = null;
                return false;
            }

            bool hadError = false;
            ArrayList argArray = new ArrayList();
            StringBuilder currentArg = new StringBuilder();
            bool inQuotes = false;
            int index = 0;

            // while (index < args.Length)
            try
            {
                while (true)
                {
                    // skip whitespace
                    while (char.IsWhiteSpace(args[index]))
                    {
                        index += 1;
                    }

                    // # - comment to end of line
                    if (args[index] == '#')
                    {
                        index += 1;
                        while (args[index] != '\n')
                        {
                            index += 1;
                        }
                        continue;
                    }

                    // do one argument
                    do
                    {
                        if (args[index] == '\\')
                        {
                            int cSlashes = 1;
                            index += 1;
                            while (index == args.Length && args[index] == '\\')
                            {
                                cSlashes += 1;
                            }

                            if (index == args.Length || args[index] != '"')
                            {
                                currentArg.Append('\\', cSlashes);
                            }
                            else
                            {
                                currentArg.Append('\\', (cSlashes >> 1));
                                if (0 != (cSlashes & 1))
                                {
                                    currentArg.Append('"');
                                }
                                else
                                {
                                    inQuotes = !inQuotes;
                                }
                            }
                        }
                        else if (args[index] == '"')
                        {
                            inQuotes = !inQuotes;
                            index += 1;
                        }
                        else
                        {
                            currentArg.Append(args[index]);
                            index += 1;
                        }
                    } while (!char.IsWhiteSpace(args[index]) || inQuotes);
                    argArray.Add(currentArg.ToString());
                    currentArg.Length = 0;
                }
            }
            catch (System.IndexOutOfRangeException)
            {
                // got EOF 
                if (inQuotes)
                {
                    this.reporter(string.Format("Error: Unbalanced '\"' in command line argument file '{0}'", fileName));
                    hadError = true;
                }
                else if (currentArg.Length > 0)
                {
                    // valid argument can be terminated by EOF
                    argArray.Add(currentArg.ToString());
                }
            }

            arguments = (string[])argArray.ToArray(typeof(string));
            return hadError;
        }

        private static string LongName(ArgumentAttribute attribute, FieldInfo field)
        {
            return (attribute == null || attribute.DefaultLongName) ? field.Name : attribute.LongName;
        }

        private static string ShortName(ArgumentAttribute attribute, FieldInfo field)
        {
            if (attribute is DefaultArgumentAttribute)
                return null;
            if (!ExplicitShortName(attribute))
                return LongName(attribute, field).Substring(0, 1);
            return attribute.ShortName;
        }

        private static string HelpText(ArgumentAttribute attribute, FieldInfo field)
        {
            if (attribute == null)
                return null;
            else
                return attribute.HelpText;
        }

        private static bool HasHelpText(ArgumentAttribute attribute)
        {
            return (attribute != null && attribute.HasHelpText);
        }

        private static bool ExplicitShortName(ArgumentAttribute attribute)
        {
            return (attribute != null && !attribute.DefaultShortName);
        }

        private static object DefaultValue(ArgumentAttribute attribute, FieldInfo field)
        {
            return (attribute == null || !attribute.HasDefaultValue) ? null : attribute.DefaultValue;
        }

        private static Type ElementType(FieldInfo field)
        {
            if (IsCollectionType(field.FieldType))
                return field.FieldType.GetElementType();
            else
                return null;
        }

        private static ArgumentType Flags(ArgumentAttribute attribute, FieldInfo field)
        {
            if (attribute != null)
                return attribute.Type;
            else if (IsCollectionType(field.FieldType))
                return ArgumentType.MultipleUnique;
            else
                return ArgumentType.AtMostOnce;
        }

        private static bool IsCollectionType(Type type)
        {
            return type.IsArray;
        }

        private static bool IsValidElementType(Type type)
        {
            return type != null && (
                type == typeof(int) ||
                type == typeof(uint) ||
                type == typeof(string) ||
                type == typeof(bool) ||
                type.IsEnum);
        }

        [System.Diagnostics.DebuggerDisplay("Name = {LongName}")]
        private class Argument
        {
            public Argument(ArgumentAttribute attribute, FieldInfo field, ErrorReporter reporter)
            {
                this.longName = Parser.LongName(attribute, field);
                this.explicitShortName = Parser.ExplicitShortName(attribute);
                this.shortName = Parser.ShortName(attribute, field);
                this.hasHelpText = Parser.HasHelpText(attribute);
                this.helpText = Parser.HelpText(attribute, field);
                this.defaultValue = Parser.DefaultValue(attribute, field);
                this.elementType = ElementType(field);
                this.flags = Flags(attribute, field);
                this.field = field;
                this.seenValue = false;
                this.reporter = reporter;
                this.isDefault = attribute != null && attribute is DefaultArgumentAttribute;

                if (IsCollection)
                {
                    this.collectionValues = new ArrayList();
                }

                Debug.Assert(this.longName != null && this.longName != "");
                Debug.Assert(!this.isDefault || !this.ExplicitShortName);
                Debug.Assert(!IsCollection || AllowMultiple, "Collection arguments must have allow multiple");
                Debug.Assert(!Unique || IsCollection, "Unique only applicable to collection arguments");
                Debug.Assert(IsValidElementType(Type) ||
                    IsCollectionType(Type));
                Debug.Assert((IsCollection && IsValidElementType(elementType)) ||
                    (!IsCollection && elementType == null));
                Debug.Assert(!(this.IsRequired && this.HasDefaultValue), "Required arguments cannot have default value");
                Debug.Assert(!this.HasDefaultValue || (this.defaultValue.GetType() == field.FieldType), "Type of default value must match field type");
            }

            public bool Finish(object destination)
            {
                if (this.SeenValue)
                {
                    if (this.IsCollection)
                    {
                        this.field.SetValue(destination, this.collectionValues.ToArray(this.elementType));
                    }
                }
                else
                {
                    if (this.HasDefaultValue)
                    {
                        this.field.SetValue(destination, this.DefaultValue);
                    }
                }

                return ReportMissingRequiredArgument();
            }

            private bool ReportMissingRequiredArgument()
            {
                if (this.IsRequired && !this.SeenValue)
                {
                    if (this.IsDefault)
                        reporter(string.Format("Missing required argument '<{0}>'.", this.LongName));
                    else
                        reporter(string.Format("Missing required argument '/{0}'.", this.LongName));
                    return true;
                }
                return false;
            }

            private void ReportDuplicateArgumentValue(string value)
            {
                this.reporter(string.Format("Duplicate '{0}' argument '{1}'", this.LongName, value));
            }

            public bool SetValue(string value, object destination)
            {
                if (SeenValue && !AllowMultiple)
                {
                    this.reporter(string.Format("Duplicate '{0}' argument", this.LongName));
                    return false;
                }
                this.seenValue = true;

                object newValue;
                if (!ParseValue(this.ValueType, value, out newValue))
                    return false;
                if (this.IsCollection)
                {
                    if (this.Unique && this.collectionValues.Contains(newValue))
                    {
                        ReportDuplicateArgumentValue(value);
                        return false;
                    }
                    else
                    {
                        this.collectionValues.Add(newValue);
                    }
                }
                else
                {
                    this.field.SetValue(destination, newValue);
                }

                return true;
            }

            public Type ValueType
            {
                get { return this.IsCollection ? this.elementType : this.Type; }
            }

            private void ReportBadArgumentValue(string value)
            {
                this.reporter(string.Format("'{0}' is not a valid value for the '{1}' command line option", value, this.LongName));
            }

            private bool ParseValue(Type type, string stringData, out object value)
            {
                // null is only valid for bool variables
                // empty string is never valid
                if ((stringData != null || type == typeof(bool)) && (stringData == null || stringData.Length > 0))
                {
                    try
                    {
                        if (type == typeof(string))
                        {
                            value = stringData;
                            return true;
                        }
                        else if (type == typeof(bool))
                        {
                            if (stringData == null || stringData == "+")
                            {
                                value = true;
                                return true;
                            }
                            else if (stringData == "-")
                            {
                                value = false;
                                return true;
                            }
                        }
                        else if (type == typeof(int))
                        {
                            value = int.Parse(stringData);
                            return true;
                        }
                        else if (type == typeof(uint))
                        {
                            value = int.Parse(stringData);
                            return true;
                        }
                        else
                        {
                            Debug.Assert(type.IsEnum);

                            bool valid = false;
                            foreach (string name in Enum.GetNames(type))
                            {
                                if (name == stringData)
                                {
                                    valid = true;
                                    break;
                                }
                            }
                            if (valid)
                            {
                                value = Enum.Parse(type, stringData, true);
                                return true;
                            }
                        }
                    }
                    catch
                    {
                        // catch parse errors
                    }
                }

                ReportBadArgumentValue(stringData);
                value = null;
                return false;
            }

            private void AppendValue(StringBuilder builder, object value)
            {
                if (value is string || value is int || value is uint || value.GetType().IsEnum)
                {
                    builder.Append(value.ToString());
                }
                else if (value is bool)
                {
                    builder.Append((bool)value ? "+" : "-");
                }
                else
                {
                    bool first = true;
                    foreach (object o in (System.Array)value)
                    {
                        if (!first)
                        {
                            builder.Append(", ");
                        }
                        AppendValue(builder, o);
                        first = false;
                    }
                }
            }

            public string LongName
            {
                get { return this.longName; }
            }

            public bool ExplicitShortName
            {
                get { return this.explicitShortName; }
            }

            public string ShortName
            {
                get { return this.shortName; }
            }

            public bool HasShortName
            {
                get { return this.shortName != null; }
            }

            public void ClearShortName()
            {
                this.shortName = null;
            }

            public bool HasHelpText
            {
                get { return this.hasHelpText; }
            }

            public string HelpText
            {
                get { return this.helpText; }
            }

            public object DefaultValue
            {
                get { return this.defaultValue; }
            }

            public bool HasDefaultValue
            {
                get { return null != this.defaultValue; }
            }

            public string FullHelpText
            {
                get
                {
                    StringBuilder builder = new StringBuilder();
                    if (this.HasHelpText)
                    {
                        builder.Append(this.HelpText);
                    }
                    if (this.HasDefaultValue)
                    {
                        if (builder.Length > 0)
                            builder.Append(" ");
                        builder.Append("Default value:'");
                        AppendValue(builder, this.DefaultValue);
                        builder.Append('\'');
                    }
                    if (this.HasShortName)
                    {
                        if (builder.Length > 0)
                            builder.Append(" ");
                        builder.Append("(short form /");
                        builder.Append(this.ShortName);
                        builder.Append(")");
                    }
                    return builder.ToString();
                }
            }

            public string SyntaxHelp
            {
                get
                {
                    StringBuilder builder = new StringBuilder();

                    if (this.IsDefault)
                    {
                        builder.Append("<");
                        builder.Append(this.LongName);
                        builder.Append(">");
                    }
                    else
                    {
                        builder.Append("/");
                        builder.Append(this.LongName);
                        Type valueType = this.ValueType;
                        if (valueType == typeof(int))
                        {
                            builder.Append(":<int>");
                        }
                        else if (valueType == typeof(uint))
                        {
                            builder.Append(":<uint>");
                        }
                        else if (valueType == typeof(bool))
                        {
                            builder.Append("[+|-]");
                        }
                        else if (valueType == typeof(string))
                        {
                            builder.Append(":<string>");
                        }
                        else
                        {
                            Debug.Assert(valueType.IsEnum);

                            builder.Append(":{");
                            bool first = true;
                            foreach (FieldInfo field in valueType.GetFields())
                            {
                                if (field.IsStatic)
                                {
                                    if (first)
                                        first = false;
                                    else
                                        builder.Append('|');
                                    builder.Append(field.Name);
                                }
                            }
                            builder.Append('}');
                        }
                    }

                    return builder.ToString();
                }
            }

            public bool IsRequired
            {
                get { return 0 != (this.flags & ArgumentType.Required); }
            }

            public bool SeenValue
            {
                get { return this.seenValue; }
            }

            public bool AllowMultiple
            {
                get { return 0 != (this.flags & ArgumentType.Multiple); }
            }

            public bool Unique
            {
                get { return 0 != (this.flags & ArgumentType.Unique); }
            }

            public Type Type
            {
                get { return field.FieldType; }
            }

            public bool IsCollection
            {
                get { return IsCollectionType(Type); }
            }

            public bool IsDefault
            {
                get { return this.isDefault; }
            }

            private string longName;
            private string shortName;
            private string helpText;
            private bool hasHelpText;
            private bool explicitShortName;
            private object defaultValue;
            private bool seenValue;
            private FieldInfo field;
            private Type elementType;
            private ArgumentType flags;
            private ArrayList collectionValues;
            private ErrorReporter reporter;
            private bool isDefault;
        }

        private ArrayList arguments;
        private Hashtable argumentMap;
        private Argument defaultArgument;
        private ErrorReporter reporter;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup1\Monitoring\LiveConnectPing\WCF\ChannelFactoryExtensions.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.ServiceModel;

namespace LiveConnectPing
{
    /// <summary>
    /// 
    /// </summary>
    public static class ChannelFactoryExtensions
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="channel"></param>
        public static void CloseConnection(this ICommunicationObject channel)
        {
            if (channel == null || channel.State != CommunicationState.Opened)
            {
                return;
            }

            try
            {
                channel.Close();
            }
            catch (CommunicationException)
            {
                channel.Abort();
            }
            catch (TimeoutException)
            {
                channel.Abort();
            }
            catch (Exception)
            {
                channel.Abort();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup1\LCWebService\LiveConnectWeb.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.Serialization;
using System.ServiceModel;
using System.Text;
using System.ServiceModel.Security;
using System.Threading;
using System.Security.Principal;
using System.IdentityModel.Claims;
using System.Diagnostics;
using System.Text.RegularExpressions;
using System.Configuration;

namespace LiveConnectWeb
{
    [ServiceBehavior(Namespace="http://liveconnect.xboxlive.com")]
    public class LiveConnect : ILiveDirectory, ILiveAuthentication
    {
        private static int maxNumberOfLookups;

        #region Input Validation Routines
        private static ulong DefaultXuid(ulong Xuid, XblSamlSecurityToken xblToken)
        {
            if (xblToken != null)
            {
                return xblToken.Xuid;
            }

            return Xuid;
        }

        private string DefaultDeviceId(string deviceId, XblSamlSecurityToken xblToken)
        {
            if (xblToken != null)
            {
                return xblToken.MachineId;;
            }

            return deviceId;
        }

        private bool GamerTagIsValid(string gamerTag)
        {
            if (string.IsNullOrEmpty(gamerTag) || gamerTag.Length > 15)
            {
                return false;
            }

            string tmp = gamerTag;
            if (gamerTag.Trim().Length != tmp.Length)
            {
                return false;
            }

            if (Encoding.UTF8.GetByteCount(gamerTag) != gamerTag.Length)
            {
                return false;
            }

            return true;
        }

        private bool DeviceIdIsValid(string deviceId)
        {
            if (string.IsNullOrEmpty(deviceId))
            {
                return false;
            }

            string tmp = deviceId;
            if (deviceId.Trim().Length != tmp.Length)
            {
                return false;
            }

            return true;
        }

        private bool SNUserIDIsValid(string snUserId)
        {
            if (string.IsNullOrEmpty(snUserId) || snUserId.Length > 128 || badSnuidExp.Match(snUserId).Success)
            {
                return false;
            }
            string tmp = snUserId;

            if (snUserId.Trim().Length != tmp.Length)
            {
                return false;
            }

            return true;
        }

        private void ValidateUserInfo(SNUserInfo userInfo, XblSamlSecurityToken xblToken)
        {
            if (userInfo == null)
            {
                throw new FaultException<ArgumentNullException>(new ArgumentNullException("userInfo"));
            }

            if (DefaultXuid(userInfo.XUID, xblToken) == 0)
            {
                throw new FaultException<ArgumentOutOfRangeException>(new ArgumentOutOfRangeException("userInfo.XUID"));
            }

            // if we have a xblToken, and it's a phone token, use the gamertag from it.
            if (xblToken != null && xblToken.TokenType == XblSamlTokenType.User)
            {
                if (!string.IsNullOrEmpty(xblToken.GamerTag))
                {
                    userInfo.GamerTag = xblToken.GamerTag;
                }
            }

            if (!GamerTagIsValid(userInfo.GamerTag))
            {
                throw new FaultException<ArgumentException>(new ArgumentException("userInfo.GamerTag"));
            }

            if (!SNUserIDIsValid(userInfo.SNUserID))
            {
                throw new FaultException<ArgumentException>(new ArgumentException("userInfo.SNUserID"));
            }
        }

        private void ValidateAuthInfo(SNAuthInfo userInfo)
        {

            if (userInfo == null)
            {
                throw new FaultException<ArgumentNullException>(new ArgumentNullException("userInfo"));
            }

            if (!SNUserIDIsValid(userInfo.SNUserID))
            {
                throw new FaultException<ArgumentException>(new ArgumentException("userInfo.SNUserID"));
            }

            if (string.IsNullOrEmpty(userInfo.Token))
            {
                throw new FaultException<ArgumentException>(new ArgumentException("userInfo.Token"));
            }
        }

        private void AuthorizeTitleXuidPeer(ushort sNetworkId, XblSamlSecurityToken xblToken, ulong realXuid)
        {
            if (xblToken != null)
            {
                //Verify that the titleId is entitled to the network
                AuthorizeTitle(sNetworkId, xblToken);

                //Verify that that sts xuid matches the calling XUID
                AuthorizeXUID(sNetworkId, realXuid, xblToken);
            }
            else
            {
                AuthorizeServicePeer(sNetworkId);
            }
        }

        #endregion

        #region Authorization Check Routines
        // it is not valid to send in XUID in the parameter, that does NOT match the information in the securityToken.
        // Under the phone case, we expect to retrieve and use the Xuid information from the token explicitly.
        // this test is only valid for Console token and for nothing else.
        private void AuthorizeXUID(ushort sNetworkId, ulong XUID, XblSamlSecurityToken clientInfo)
        {
            if (clientInfo != null && clientInfo.TokenType == XblSamlTokenType.Console)
            {
                if (XUID != clientInfo.Xuid)
                {
                    LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                        string.Format("STS: XUID access denied: NetworkId: {0} Input XUID: {1} Token XUID: {2} {3}",
                        sNetworkId.ToString(),
                        XUID.ToString(),
                        clientInfo.Xuid.ToString(),
                        Environment.StackTrace),
                        EventLogEntryType.Warning,
                        (int)EventErrorIds.STSSecurityXUIDViolation);

                    throw new FaultException<SecurityAccessDeniedException>(new SecurityAccessDeniedException());
                }
            }
        }

        private void AuthorizeTitle(ushort sNetworkId, XblSamlSecurityToken clientInfo)
        {
            if (!TitleNetworkMapper.Instance.IsTitleAllowed(sNetworkId, clientInfo.TitleId.ToString("X8")))
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    string.Format("STS: Title access denied for network Id = {0} title ID = {1} {2}",
                    sNetworkId.ToString(),
                    clientInfo.TitleId,
                    Environment.StackTrace),
                    EventLogEntryType.Warning,
                    (int)EventErrorIds.STSSecurityTitleViolation);

                throw new FaultException<SecurityAccessDeniedException>(new SecurityAccessDeniedException());
            }
        }

        private void AuthorizeServicePeer(ushort sNetworkId)
        {
            X509ClientInfo xClientInfo = X509ClientInfo.GetFromOperationContext();

            if (xClientInfo != null)
            {
                //Verify that the subject that identifies the peer is entitled to the network
                if (!CertNetworkMapper.Instance.IsPeerAllowed(sNetworkId, xClientInfo.Subject))
                {
                    LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                        string.Format("X509: Certificate denied for social network ID = {0} with subject {1} {2}",
                        sNetworkId.ToString(),
                        xClientInfo.Subject,
                        Environment.StackTrace),
                        EventLogEntryType.Warning,
                        (int)EventErrorIds.X509SubjectViolation);

                    throw new FaultException<SecurityAccessDeniedException>(new SecurityAccessDeniedException());
                }

            }
            else
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    "X509: No Cert Found " + Environment.StackTrace,
                    EventLogEntryType.Warning,
                    (int)EventErrorIds.X509NoValidCertFound);

                throw new FaultException<SecurityAccessDeniedException>(new SecurityAccessDeniedException());
            }
        }
        #endregion

        internal static void Opening(Object sender, EventArgs e)
        {
            //Initalize title to network mapper from configuration
            TitleNetworkMapper.Instance.LoadFromConfig();

            //Initialize the certificate network mapper from configuration
            CertNetworkMapper.Instance.LoadFromConfig();

            string value = ConfigurationManager.AppSettings["MaxNumberOfLookups"];
            maxNumberOfLookups = int.Parse(value);

            return;
        }

        #region Interface Operations
        public void SetSNUserInfo(ushort sNetworkId, SNUserInfo userInfo)
        {
            if (sNetworkId > TitleNetworkMapper.Instance.MaxNumNetworks - 1)
            {
                throw new FaultException<ArgumentOutOfRangeException>(new ArgumentOutOfRangeException("sNetworkId"));
            }

            XblSamlSecurityToken xblToken = XblSamlSecurityToken.CreateFromSoapRequest();

            ValidateUserInfo(userInfo, xblToken);
            
            ulong realXuid = DefaultXuid(userInfo.XUID, xblToken);

            AuthorizeTitleXuidPeer(sNetworkId, xblToken, realXuid);

            try
            {
                cache.SetSNUserInfo(sNetworkId, userInfo, realXuid);
            }
            catch (System.Data.SqlClient.SqlException ex)
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    string.Format("ConnectionString: {0} Exception: {1}",
                    cache.ConnectionString,
                    ex.ToString()),
                    EventLogEntryType.Error,
                    (int)EventErrorIds.GeneralSQLError);

                throw new FaultException(genericErrorString);
            }
            catch (Exception ex)
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    string.Format("Exception: {1}",
                    ex.ToString()),
                    EventLogEntryType.Error,
                    (int)EventErrorIds.InternalServerError);

                throw new FaultException(genericErrorString);
            }
        }

        public void RemoveSNUserInfo(ushort sNetworkId, ulong XUID)
        {
            if (sNetworkId > TitleNetworkMapper.Instance.MaxNumNetworks - 1)
            {
                throw new FaultException<ArgumentOutOfRangeException>(new ArgumentOutOfRangeException("sNetworkId"));
            }

            XblSamlSecurityToken xblToken = XblSamlSecurityToken.CreateFromSoapRequest();

            ulong realXuid = DefaultXuid(XUID, xblToken);
            
            if (realXuid == 0)
            {
                throw new FaultException<ArgumentOutOfRangeException>(new ArgumentOutOfRangeException("XUID"));
            }

            AuthorizeTitleXuidPeer(sNetworkId, xblToken, realXuid);

            try
            {
                cache.RemoveSNUserInfoByXUID(sNetworkId, realXuid);
            }
            catch (System.Data.SqlClient.SqlException ex)
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    string.Format("ConnectionString: {0} Exception: {1}",
                    cache.ConnectionString,
                    ex.ToString()),
                    EventLogEntryType.Error,
                    (int)EventErrorIds.GeneralSQLError);

                throw new FaultException(genericErrorString);
            }
            catch (Exception ex)
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    string.Format("Exception: {1}",
                    ex.ToString()),
                    EventLogEntryType.Error,
                    (int)EventErrorIds.InternalServerError);

                throw new FaultException(genericErrorString);
            }

            return;
        }

        public SNUserInfo GetSNUserInfoByXUID(ushort sNetworkId, ulong XUID)
        {
            SNUserInfo userInfo;

            if (sNetworkId > TitleNetworkMapper.Instance.MaxNumNetworks - 1)
            {
                throw new FaultException<ArgumentOutOfRangeException>(new ArgumentOutOfRangeException("sNetworkId"));
            }

            XblSamlSecurityToken xblToken = XblSamlSecurityToken.CreateFromSoapRequest();

            ulong realXuid = DefaultXuid(XUID, xblToken);
            if (realXuid == 0)
            {
                throw new FaultException<ArgumentOutOfRangeException>(new ArgumentOutOfRangeException("XUID"));
            }

            AuthorizeTitleXuidPeer(sNetworkId, xblToken, realXuid);

            try
            {
                userInfo = cache.GetSNUserInfoByXUID(sNetworkId, realXuid);
            }
            catch (System.Data.SqlClient.SqlException ex)
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    string.Format("ConnectionString: {0} Exception: {1}",
                    cache.ConnectionString,
                    ex.ToString()),
                    EventLogEntryType.Error,
                    (int)EventErrorIds.GeneralSQLError);

                throw new FaultException(genericErrorString);
            }
            catch (Exception ex)
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    string.Format("Exception: {1}",
                    ex.ToString()),
                    EventLogEntryType.Error,
                    (int)EventErrorIds.InternalServerError);

                throw new FaultException(genericErrorString);
            }

            //Verify that that sts xuid matches the calling XUID
            //If the entry is not visible then the XUIDs must match
            if (xblToken != null)
            {
                if (userInfo != null && realXuid != XUID && userInfo.Visibility != Visibility.Everyone)
                {
                    //peterl:   suppressing this as per the xoc, bug# 11564.  These events are flooding the event log,
                    //          due to a bug in twitter/facebook console applications.
                    //LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    //    string.Format("STS: XUID Denied: NetworkId: {0} Input XUID: {1} Token XUID: {2} Visibility {3}",
                    //    sNetworkId.ToString(),
                    //    XUID.ToString(),
                    //    realXuid.ToString(),
                    //    userInfo.Visibility.ToString()),
                    //    EventLogEntryType.Warning,
                    //    (int)EventErrorIds.STSSecurityPrivacyViolation);

                    throw new FaultException<SecurityAccessDeniedException>(new SecurityAccessDeniedException());
                }
            }

            return userInfo;
        }

        public SNUserInfo GetSNUserInfoBySNUId(ushort sNetworkId, string snUserId)
        {
            SNUserInfo userInfo;

            if (sNetworkId > TitleNetworkMapper.Instance.MaxNumNetworks - 1)
            {
                throw new FaultException<ArgumentOutOfRangeException>(new ArgumentOutOfRangeException("sNetworkId"));
            }

            if (!SNUserIDIsValid(snUserId))
            {
                throw new FaultException<ArgumentException>(new ArgumentException("snUserId"));
            }

            try
            {
                userInfo = cache.GetSNUserInfoBySNUId(sNetworkId, snUserId);
            }
            catch (System.Data.SqlClient.SqlException ex)
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    string.Format("ConnectionString: {0} Exception: {1}",
                    cache.ConnectionString,
                    ex.ToString()),
                    EventLogEntryType.Error,
                    (int)EventErrorIds.GeneralSQLError);

                throw new FaultException(genericErrorString);
            }
            catch (Exception ex)
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    string.Format("Exception: {1}",
                    ex.ToString()),
                    EventLogEntryType.Error,
                    (int)EventErrorIds.InternalServerError);

                throw new FaultException(genericErrorString);
            }

            XblSamlSecurityToken xblToken = XblSamlSecurityToken.CreateFromSoapRequest();
            if (xblToken != null)
            {
                //Verify that the titleId is entitled to the network
                AuthorizeTitle(sNetworkId, xblToken);

                //Verify that that sts xuid matches the returned XUID
                //If the entry is not visible then the XUIDs must match
                if (userInfo != null && userInfo.XUID != xblToken.Xuid && userInfo.Visibility != Visibility.Everyone)
                {
                    //peterl:   suppressing this as per the xoc, bug# 11564.  These events are flooding the event log,
                    //          due to a bug in twitter/facebook console applications.
                    //LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    //    string.Format("STS: XUID Denied: Input XUID: {0} Token XUID: {1} Visibility {2}",
                    //    userInfo.XUID.ToString(),
                    //    xblToken.Xuid.ToString(),
                    //    userInfo.Visibility.ToString()),
                    //    EventLogEntryType.Warning,
                    //    (int)EventErrorIds.STSSecurityPrivacyViolation);

                    throw new FaultException<SecurityAccessDeniedException>(new SecurityAccessDeniedException());
                }
            }
            else
            {
                AuthorizeServicePeer(sNetworkId);
            }

            return userInfo;
        }

        public SNUserInfo[] GetSNUserInfos(ushort sNetworkId, string[] sNUserIDs)
        {
            if (sNetworkId > TitleNetworkMapper.Instance.MaxNumNetworks - 1)
            {
                throw new FaultException<ArgumentOutOfRangeException>(new ArgumentOutOfRangeException("sNetworkId"));
            }

            if (sNUserIDs == null || sNUserIDs.Length == 0)
            {
                throw new FaultException<ArgumentNullException>(new ArgumentNullException("sNUserIDs"));
            }

            if (sNUserIDs.Length > maxNumberOfLookups)
            {
                throw new FaultException<ArgumentOutOfRangeException>(new ArgumentOutOfRangeException("sNUserIDs"));
            }

            foreach (string userId in sNUserIDs)
            {
                if(!SNUserIDIsValid(userId))
                {
                    throw new FaultException<ArgumentException>(new ArgumentException("sNUserIDs"));
                }
            }

            XblSamlSecurityToken xblToken = XblSamlSecurityToken.CreateFromSoapRequest();

            if (xblToken != null)
            {
                //Verify that the titleId is entitled to the network
                AuthorizeTitle(sNetworkId, xblToken);
            }
            else
            {
                AuthorizeServicePeer(sNetworkId);
            }

            try
            {
                SNUserInfo[] userInfos = cache.GetSNUserInfos(sNetworkId, sNUserIDs);

                // scrub XUIDs from SNUI structure if the request is coming from WP7
                if (xblToken != null && xblToken.TokenType == XblSamlTokenType.User)
                {
                    foreach (SNUserInfo userInfo in userInfos)
                    {
                        userInfo.XUID = 0;
                    }
                }
                
                return userInfos;
            }
            catch (System.Data.SqlClient.SqlException ex)
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    string.Format("ConnectionString: {0} Exception: {1}",
                    cache.ConnectionString,
                    ex.ToString()),
                    EventLogEntryType.Error,
                    (int)EventErrorIds.GeneralSQLError);

                throw new FaultException(genericErrorString);
            }
            catch (Exception ex)
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    string.Format("Exception: {1}",
                    ex.ToString()),
                    EventLogEntryType.Error,
                    (int)EventErrorIds.InternalServerError);

                throw new FaultException(genericErrorString);
            }
            finally
            {
                ScheduleGamertagChangeCheck(sNetworkId, xblToken);
            }
        }

        private static void ScheduleGamertagChangeCheck(ushort sNetworkId, XblSamlSecurityToken xblToken)
        {
            // if we have a user token, schedule a gamerTag check and update worker Item.
            if (xblToken != null &&
                xblToken.TokenType == XblSamlTokenType.User &&
                !string.IsNullOrEmpty(xblToken.GamerTag) &&
                xblToken.Xuid != 0)
            {
                // update the gamerTag if it has changed.
                ThreadPool.QueueUserWorkItem(delegate(object state)
                {
                    try
                    {
                        string newGamerTag = xblToken.GamerTag;
                        ulong xuid = xblToken.Xuid;
                        ushort snid = sNetworkId;
                        SNUserInfo snUserInfo = cache.GetSNUserInfoByXUID(snid, xuid);

                        if (snUserInfo != null && snUserInfo.GamerTag != newGamerTag)
                        {
                            snUserInfo.GamerTag = newGamerTag;
                            cache.SetSNUserInfo(snid, snUserInfo, xuid);
                        }
                    }
                    catch (Exception ex)
                    {
                        LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                            string.Format("ConnectionString: {0} Exception: {1}",
                            cache.ConnectionString,
                            ex.ToString()),
                            EventLogEntryType.Error,
                            (int)EventErrorIds.GeneralSQLError);
                    }
                });
            }
        }

        public SNetworkInfo GetSNetworkInfo(ushort sNetworkId)
        {
            SNetworkInfo sNetworkInfo = null;

            if (sNetworkId > TitleNetworkMapper.Instance.MaxNumNetworks - 1)
            {
                throw new FaultException<ArgumentOutOfRangeException>(new ArgumentOutOfRangeException("sNetworkId"));
            }

            XblSamlSecurityToken xblToken = XblSamlSecurityToken.CreateFromSoapRequest();

            if (xblToken == null && X509ClientInfo.GetFromOperationContext() == null)
            {
                throw new FaultException<SecurityAccessDeniedException>(new SecurityAccessDeniedException());
            }

            try
            {
                sNetworkInfo = cache.GetSNetworkInfo(sNetworkId);
            }
            catch (System.Data.SqlClient.SqlException ex)
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    string.Format("ConnectionString: {0} Exception: {1}",
                    cache.ConnectionString,
                    ex.ToString()),
                    EventLogEntryType.Error,
                    (int)EventErrorIds.GeneralSQLError);

                throw new FaultException(genericErrorString);
            }
            catch (Exception ex)
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    string.Format("Exception: {1}",
                    ex.ToString()),
                    EventLogEntryType.Error,
                    (int)EventErrorIds.InternalServerError);

                throw new FaultException(genericErrorString);
            }

            return sNetworkInfo;
        }

        public SNetworkInfo[] GetSNetworkInfos()
        {
            SNetworkInfo[] networkInfos = null;
            XblSamlSecurityToken xblToken = XblSamlSecurityToken.CreateFromSoapRequest();

            if (xblToken == null && X509ClientInfo.GetFromOperationContext() == null)
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    "No STS token and no certificate found",
                    EventLogEntryType.Warning,
                    (int)EventErrorIds.GeneralSecurityViolation);

                throw new FaultException<SecurityAccessDeniedException>(new SecurityAccessDeniedException());
            }

            try
            {
                networkInfos = cache.GetSNetworkInfos();
            }
            catch (System.Data.SqlClient.SqlException ex)
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    string.Format("ConnectionString: {0} Exception: {1}",
                    cache.ConnectionString,
                    ex.ToString()),
                    EventLogEntryType.Error,
                    (int)EventErrorIds.GeneralSQLError);

                throw new FaultException(genericErrorString);
            }
            catch (Exception ex)
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    string.Format("Exception: {1}",
                    ex.ToString()),
                    EventLogEntryType.Error,
                    (int)EventErrorIds.InternalServerError);

                throw new FaultException(genericErrorString);
            }

            return networkInfos;
        }

        public void SetAuthInfo(ushort sNetworkId, ulong XUID, string gamerTag, string deviceId, SNAuthInfo userInfo, bool addToDirectory, Visibility visibility)
        {
            XblSamlSecurityToken xblToken = XblSamlSecurityToken.CreateFromSoapRequest();

            string machineId = DefaultDeviceId(deviceId, xblToken);

            if (sNetworkId > TitleNetworkMapper.Instance.MaxNumNetworks - 1)
            {
                throw new FaultException<ArgumentOutOfRangeException>(new ArgumentOutOfRangeException("sNetworkId"));
            }

            if (!GamerTagIsValid(gamerTag))
            {
                throw new FaultException<ArgumentNullException>(new ArgumentNullException("gamerTag"));
            }

            if (!DeviceIdIsValid(machineId))
            {
                throw new FaultException<ArgumentNullException>(new ArgumentNullException("deviceId"));
            }

            ValidateAuthInfo(userInfo);

            ulong realXuid = DefaultXuid(XUID, xblToken);

            AuthorizeTitleXuidPeer(sNetworkId, xblToken, realXuid);

            try
            {
                cache.SetAuthInfo(sNetworkId, realXuid, gamerTag, machineId, userInfo, addToDirectory, visibility);
            }
            catch (System.Data.SqlClient.SqlException ex)
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    string.Format("ConnectionString: {0} Exception: {1}",
                    cache.ConnectionString,
                    ex.ToString()),
                    EventLogEntryType.Error,
                    (int)EventErrorIds.GeneralSQLError);

                throw new FaultException(genericErrorString);
            }
            catch (Exception ex)
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    string.Format("Exception: {1}",
                    ex.ToString()),
                    EventLogEntryType.Error,
                    (int)EventErrorIds.InternalServerError);

                throw new FaultException(genericErrorString);
            }

            return;
        }

        public SNAuthInfo GetAuthInfo(ushort sNetworkId, ulong XUID, string deviceId)
        {
            XblSamlSecurityToken xblToken = XblSamlSecurityToken.CreateFromSoapRequest();
            SNAuthInfo authInfo = null;

            string machineId = DefaultDeviceId(deviceId, xblToken);

            if (sNetworkId > TitleNetworkMapper.Instance.MaxNumNetworks - 1)
            {
                throw new FaultException<ArgumentOutOfRangeException>(new ArgumentOutOfRangeException("sNetworkId"));
            }

            if (!DeviceIdIsValid(machineId))
            {
                throw new FaultException<ArgumentException>(new ArgumentException("deviceId"));
            }

            ulong realXuid = DefaultXuid(XUID, xblToken);

            AuthorizeTitleXuidPeer(sNetworkId, xblToken, realXuid);

            try
            {
                authInfo = cache.GetAuthInfo(sNetworkId, realXuid, machineId);
            }
            catch (System.Data.SqlClient.SqlException ex)
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    string.Format("ConnectionString: {0} Exception: {1}",
                    cache.ConnectionString,
                    ex.ToString()),
                    EventLogEntryType.Error,
                    (int)EventErrorIds.GeneralSQLError);

                throw new FaultException(genericErrorString);
            }
            catch (Exception ex)
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    string.Format("Exception: {1}",
                    ex.ToString()),
                    EventLogEntryType.Error,
                    (int)EventErrorIds.InternalServerError);

                throw new FaultException(genericErrorString);
            }

            return authInfo;
        }

        public void RemoveAuthInfo(ushort sNetworkId, ulong XUID, string deviceId)
        {
            XblSamlSecurityToken xblToken = XblSamlSecurityToken.CreateFromSoapRequest();

            string machineId = DefaultDeviceId(deviceId, xblToken);

            if (sNetworkId > TitleNetworkMapper.Instance.MaxNumNetworks - 1)
            {
                throw new FaultException<ArgumentOutOfRangeException>(new ArgumentOutOfRangeException("sNetworkId"));
            }

            if (!DeviceIdIsValid(machineId))
            {
                throw new FaultException<ArgumentException>(new ArgumentException("deviceId"));
            }

            ulong realXuid = DefaultXuid(XUID, xblToken);

            AuthorizeTitleXuidPeer(sNetworkId, xblToken, realXuid);

            try
            {
                cache.RemoveAuthInfo(sNetworkId, realXuid, machineId);
            }
            catch (System.Data.SqlClient.SqlException ex)
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    string.Format("ConnectionString: {0} Exception: {1}",
                    cache.ConnectionString,
                    ex.ToString()),
                    EventLogEntryType.Error,
                    (int)EventErrorIds.GeneralSQLError);

                throw new FaultException(genericErrorString);
            }
            catch (Exception ex)
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    string.Format("Exception: {1}",
                    ex.ToString()),
                    EventLogEntryType.Error,
                    (int)EventErrorIds.InternalServerError);

                throw new FaultException(genericErrorString);
            }

            return;
        }
        #endregion

        const string genericErrorString = "Internal Server Error";
        static LiveConnectCache cache = new LiveConnectCache();
        static Regex badSnuidExp = new Regex(@"[<>:"",\\]", RegexOptions.Compiled);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup1\LCWebService\XblSamlToken.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.ServiceModel;
using System.IdentityModel.Tokens;
using System.ServiceModel.Security;

namespace LiveConnectWeb
{
    /// <summary>
    /// 
    /// </summary>
    public enum XblSamlTokenType: byte
    {
        Console,
        User,
        Partner,
        Machine,
    }

    /// <summary>
    /// platform types, as defined in xonline
    /// </summary>
    public enum Platform: ushort
    {
        Xbox1 = 0,
        Xbox360 = 1,
        PC = 2,
        Web = 3,
        WindowsPhone = 15,
        WebGames = 16,
    }

    public abstract class XblSamlSecurityToken : SamlSecurityToken
    {
        protected const string XblAttributeNamespace = "http://xboxlive.com/claims";
        protected const string UserTokenSubject = "XboxLive User security ticket";

        internal const string PlatformTypeAttribute = "PlatformType";
        internal const string MachineIdAttribute = "MachineID";
        internal const string DeviceIdAttribute = "DeviceID";
        internal const string ClientVersionAttribute = "ClientVersion";
        internal const string TitleIdAttribute = "TitleID";
        internal const string TitleVersionAttribute = "TitleVersion";

        // future place holder
        public static XblSamlSecurityToken Create(String samlToken)
        {
            throw new NotImplementedException();
        }

        public static XblSamlSecurityToken CreateFromSamlToken(SamlSecurityToken samlToken)
        {
            XblSamlSecurityToken returnXblToken = null;
            // ensure assertions and statements w/ at least one element do exist in the token.
            if (samlToken == null ||
                samlToken.Assertion == null ||
                samlToken.Assertion.Statements == null  || 
                samlToken.Assertion.Statements.Count == 0)
            {
                throw new FaultException<SecurityAccessDeniedException>(new SecurityAccessDeniedException("Invalid token."));
            }

            //grabs the first <saml:AttributeStatement> in the token; our (if not all) tokens should only have one
            SamlAttributeStatement statement = samlToken.Assertion.Statements[0] as SamlAttributeStatement;

            if (string.Compare(statement.SamlSubject.Name, XblSamlSecurityToken.UserTokenSubject, true) == 0)
            {
                returnXblToken = new PhoneXmlSamlSecurityToken(samlToken);

                // ensure phone tokens have platform type as windows phone.
                if (returnXblToken.PlatformType != (ushort)Platform.WindowsPhone)
                {
                    throw new FaultException<SecurityAccessDeniedException>(new SecurityAccessDeniedException("Invalid platform type."));
                }

                if(String.IsNullOrEmpty(returnXblToken.DeviceId))
                {
                    throw new FaultException<SecurityAccessDeniedException>(new SecurityAccessDeniedException("Empty or null device id."));
                }
            }
            else
            {
                returnXblToken = new ConsoleXmlSamlSecurityToken(samlToken);

                // ensure phone tokens have platform type as Console.
                if (returnXblToken.PlatformType != (ushort)Platform.Xbox360)
                {
                    throw new FaultException<SecurityAccessDeniedException>(new SecurityAccessDeniedException("Invalid platform type."));
                }
            }

            return returnXblToken;
        }

        public static XblSamlSecurityToken CreateFromSoapRequest()
        {
            // If there is no token, simply return null
            if (OperationContext.Current.IncomingMessageProperties.Security.IncomingSupportingTokens.Count != 1)
            {
                return null;
            }

            // from this point on, any security token validation failure, now that we know it exists, is lethal.
            SamlSecurityToken token = null;

            try
            {
                token = OperationContext.Current.IncomingMessageProperties.Security.IncomingSupportingTokens[0].SecurityToken as SamlSecurityToken;
                
            }
            catch (Exception ex)
            {
                //at this point, if we can't get or parse the token, it's most likely an attack
                throw new FaultException<SecurityAccessDeniedException>(new SecurityAccessDeniedException("No SamlSecurityToken found, despite supporting Tokens being valid", ex));
            }

            if(token != null)
                return CreateFromSamlToken(token);
            return null;
        }

        public virtual XblSamlTokenType TokenType { get; protected set; }

        public virtual ulong Xuid { get; protected set; }

        public virtual string GamerTag { get; protected set; }

        public virtual ushort Tier { get; protected set; }

        public virtual ushort Country { get; protected set; }

        public virtual uint TitleId { get; set; }

        public virtual uint TitleVersion { get; protected set; }

        public virtual ushort ClientVersion { get; protected set; }

        public virtual string MachineId { get; protected set; }

        public virtual ushort PlatformType { get; protected set; }

        public virtual string DeviceId { get; protected set; }

        public virtual ulong Puid { get; protected set; }

        public virtual ulong Cid { get; protected set; }

        public virtual string Privileges { get; protected set; }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="attributes"></param>
        /// <param name="claimName"></param>
        /// <param name="isHex"></param>
        /// <returns></returns>
        protected static ulong ParseUInt64Attribute(IList<SamlAttribute> attributes, string claimName, bool isHex)
        {
            string value = attributes.First(attr => attr.Name.Equals(claimName) && attr.Namespace.Equals(XblAttributeNamespace)).AttributeValues[0];
            return Convert.ToUInt64(value, isHex ? 16 : 10);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="attributes"></param>
        /// <param name="claimName"></param>
        /// <param name="isHex"></param>
        /// <returns></returns>
        protected static uint ParseUInt32Attribute(IList<SamlAttribute> attributes, string claimName, bool isHex)
        {
            string value = attributes.First(attr => attr.Name.Equals(claimName) && attr.Namespace.Equals(XblAttributeNamespace)).AttributeValues[0];
            return Convert.ToUInt32(value, isHex ? 16 : 10);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="attributes"></param>
        /// <param name="claimName"></param>
        /// <param name="isHex"></param>
        /// <returns></returns>
        protected static ushort ParseUInt16Attribute(IList<SamlAttribute> attributes, string claimName, bool isHex)
        {
            string value = attributes.First(attr => attr.Name.Equals(claimName) && attr.Namespace.Equals(XblAttributeNamespace)).AttributeValues[0];
            return Convert.ToUInt16(value, isHex ? 16 : 10);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="attributes"></param>
        /// <param name="claimName"></param>
        /// <returns></returns>
        protected static string ParseStringAttribute(IList<SamlAttribute> attributes, string claimName)
        {
            return attributes.First(attr => attr.Name.Equals(claimName) && attr.Namespace.Equals(XblAttributeNamespace)).AttributeValues[0];
        }

        /// <summary>
        /// 
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="attributes"></param>
        /// <param name="claimName"></param>
        /// <returns></returns>
        protected static T ParseAttributeValue<T>(IList<SamlAttribute> attributes, string claimName)
        {
            string value = attributes.First(attr => attr.Name.Equals(claimName) && attr.Namespace.Equals(XblAttributeNamespace)).AttributeValues[0];
            return (T)Convert.ChangeType(value, typeof(T));
        }
    }

    public class PhoneXmlSamlSecurityToken : XblSamlSecurityToken
    {
        internal const string PuidPhoneAttribute = "Puid0";
        internal const string CidPhoneAttribute = "CID0";
        internal const string XuidPhoneAttribute = "Xuid0";
        internal const string GamertagPhoneAttribute = "Gamertag0";
        internal const string TierPhoneAttribute = "Tier0";
        internal const string CountryPhoneAttribute = "Country0";
        internal const string PrivilegesPhoneAttribute = "Privileges0";
        internal const string PartneridPhoneAttribute = "PartnerID0";

        public PhoneXmlSamlSecurityToken(SamlSecurityToken samlToken)
        {
            this.TokenType = XblSamlTokenType.User;

            IList<SamlAttribute> samlAttributes = (samlToken.Assertion.Statements[0] as SamlAttributeStatement).Attributes;
            try
            {
                // bug: 11643 and 11687
                // the linq queryes (specifically .First call) may result in InvalidOperationException if the item does NOT exist.
                // or the subsequent string to whatever-type does fail w/ a similar exception.
                this.Xuid = ParseUInt64Attribute(samlAttributes, PhoneXmlSamlSecurityToken.XuidPhoneAttribute, false);
                this.GamerTag = ParseStringAttribute(samlAttributes, PhoneXmlSamlSecurityToken.GamertagPhoneAttribute);
                this.PlatformType = ParseUInt16Attribute(samlAttributes, PhoneXmlSamlSecurityToken.PlatformTypeAttribute, false);
                this.MachineId = ParseUInt64Attribute(samlAttributes, PhoneXmlSamlSecurityToken.MachineIdAttribute, false).ToString();
                this.TitleId = ParseUInt32Attribute(samlAttributes, PhoneXmlSamlSecurityToken.TitleIdAttribute, true);
                this.TitleVersion = ParseUInt32Attribute(samlAttributes, PhoneXmlSamlSecurityToken.TitleVersionAttribute, false);
                this.DeviceId = ParseStringAttribute(samlAttributes, PhoneXmlSamlSecurityToken.DeviceIdAttribute);
            }
            catch (InvalidOperationException)
            {
                throw new FaultException<SecurityAccessDeniedException>(new SecurityAccessDeniedException("Missing or Invalid Field."));
            }
        }

        public override ushort Tier { get { throw new NotSupportedException(); } }
        public override ushort Country { get { throw new NotSupportedException(); } }
        public override ushort ClientVersion { get { throw new NotSupportedException(); } }
        public override ulong Puid { get { throw new NotSupportedException(); } }
        public override ulong Cid { get { throw new NotSupportedException(); } }
        public override string Privileges { get { throw new NotSupportedException(); } }
    }

    public class ConsoleXmlSamlSecurityToken : XblSamlSecurityToken
    {
        internal const string PuidConsoleAttribute = "Puid1";
        internal const string CidConsoleAttribute = "CID1";
        internal const string XuidConsoleAttribute = "Xuid1";
        internal const string GamertagConsoleAttribute = "Gamertag1";
        internal const string TierConsoleAttribute = "Tier1";
        internal const string CountryConsoleAttribute = "Country1";
        internal const string PrivilegesConsoleAttribute = "Privileges1";
        internal const string PartneridConsoleAttribute = "PartnerID1";

        public ConsoleXmlSamlSecurityToken(SamlSecurityToken samlToken)
        {
            this.TokenType = XblSamlTokenType.Console;

            IList<SamlAttribute> samlAttributes = (samlToken.Assertion.Statements[0] as SamlAttributeStatement).Attributes;

            try
            {
                // bug: 11643 and 11687
                // the linq queryes (specifically .First call) may result in InvalidOperationException if the item does NOT exist.
                // or the subsequent string to whatever-type does fail w/ a similar exception.
                this.Xuid = ParseUInt64Attribute(samlAttributes, ConsoleXmlSamlSecurityToken.XuidConsoleAttribute, true);
                this.PlatformType = ParseUInt16Attribute(samlAttributes, ConsoleXmlSamlSecurityToken.PlatformTypeAttribute, true);
                this.MachineId = ParseUInt64Attribute(samlAttributes, ConsoleXmlSamlSecurityToken.MachineIdAttribute, true).ToString();
                this.TitleId = ParseUInt32Attribute(samlAttributes, ConsoleXmlSamlSecurityToken.TitleIdAttribute, true);
                this.TitleVersion = ParseUInt32Attribute(samlAttributes, ConsoleXmlSamlSecurityToken.TitleVersionAttribute, true);
            }
            catch (InvalidOperationException)
            {
                throw new FaultException<SecurityAccessDeniedException>(new SecurityAccessDeniedException("Missing or Invalid Field."));
            }
        }

        public override string GamerTag { get { throw new NotSupportedException(); } }
        public override ushort Tier { get { throw new NotSupportedException(); } }
        public override ushort Country { get { throw new NotSupportedException(); } }
        public override ushort ClientVersion { get { throw new NotSupportedException(); } }
        public override ulong Puid { get { throw new NotSupportedException(); } }
        public override ulong Cid { get { throw new NotSupportedException(); } }
        public override string Privileges { get { throw new NotSupportedException(); } }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup1\Monitoring\LiveConnectPing\WCF\StsTokenManager.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.ServiceModel;
using System.ServiceModel.Description;
using System.IdentityModel;
using System.IdentityModel.Selectors;

namespace LiveConnectPing
{
    /// <summary>
    /// 
    /// </summary>
    public class StsTokenManager : ClientCredentialsSecurityTokenManager
    {
        StsClientCredentials stsCreds;

        /// <summary>
        /// 
        /// </summary>
        /// <param name="stsCreds"></param>
        public StsTokenManager(StsClientCredentials stsCreds): base(stsCreds)
        {
            this.stsCreds = stsCreds;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="tokenRequirement"></param>
        /// <returns></returns>
        public override SecurityTokenProvider CreateSecurityTokenProvider(SecurityTokenRequirement tokenRequirement)
        {
            return new StsTokenProvider(this.stsCreds.StsToken);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="tokenRequirement"></param>
        /// <param name="outOfBandTokenResolver"></param>
        /// <returns></returns>
        public override SecurityTokenAuthenticator CreateSecurityTokenAuthenticator(SecurityTokenRequirement tokenRequirement, out SecurityTokenResolver outOfBandTokenResolver)
        {
            return base.CreateSecurityTokenAuthenticator(tokenRequirement, out outOfBandTokenResolver);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="version"></param>
        /// <returns></returns>
        public override SecurityTokenSerializer CreateSecurityTokenSerializer(SecurityTokenVersion version)
        {
            //return new System.IdentityModel.Tokens.SamlSerializer();
            return base.CreateSecurityTokenSerializer(version);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup1\Monitoring\LiveConnectPing\WCF\StsClientCredentials.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.ServiceModel;
using System.ServiceModel.Description;
using System.IdentityModel.Selectors;

namespace LiveConnectPing
{
    /// <summary>
    /// 
    /// </summary>
    public class StsClientCredentials: ClientCredentials
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="stsToken"></param>
        public StsClientCredentials(string stsToken): base()
        {
            this.StsToken = stsToken;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="other"></param>
        protected StsClientCredentials(StsClientCredentials other)
            : base(other)
        {
            this.StsToken = other.StsToken;
        }

        /// <summary>
        /// 
        /// </summary>
        public string StsToken
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public override SecurityTokenManager CreateSecurityTokenManager()
        {
            return new StsTokenManager(this);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        protected override ClientCredentials CloneCore()
        {
            return new StsClientCredentials(this);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\LCWebService\CertNetworkMapper.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Configuration;
using System.Text.RegularExpressions;

namespace LiveConnectWeb
{
    internal sealed class CertNetworkMapper : NetworkMapper
    {
        private static readonly CertNetworkMapper instance = new CertNetworkMapper("CertId");

        private CertNetworkMapper(string key)
            : base(key)
        {
        }

        internal static CertNetworkMapper Instance
        {
            get
            {
                return instance;
            }
        }

        internal bool IsPeerAllowed(ushort networkId, string peerId)
        {
            return base.IsEntryAllowed(networkId, peerId);
        }

        internal string NormalizeSubject(string subject)
        {
            string normSubject= "";

            if (subject == null)
            {
                return null;
            }

            Match match = subjectReg.Match(subject);

            if (match.Success)
            {
                normSubject = match.Groups["subject"].Value;
            }
            else
            {
                normSubject = subject;
            }

            return normSubject;
        }

        Regex subjectReg = new Regex(@"CN\s*=\s*(?<subject>[^,]+)", RegexOptions.Compiled);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\LCWebService\ILiveConnect.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.Serialization;
using System.ServiceModel;
using System.Text;
using System.ServiceModel.Security;

namespace LiveConnectWeb
{
    [ServiceContract(Namespace="http://liveconnect.xboxlive.com")]
    public interface ILiveDirectory
    {
        [OperationContract]
        [FaultContract(typeof(SecurityAccessDeniedException))]
        [FaultContract(typeof(ArgumentException))]
        [FaultContract(typeof(ArgumentOutOfRangeException))]
        [FaultContract(typeof(ArgumentNullException))]
        void SetSNUserInfo(ushort sNetworkId, SNUserInfo userInfo);

        [OperationContract]
        [FaultContract(typeof(SecurityAccessDeniedException))]
        [FaultContract(typeof(ArgumentException))]
        [FaultContract(typeof(ArgumentOutOfRangeException))]
        void RemoveSNUserInfo(ushort sNetworkId, ulong XUID);

        [OperationContract]
        [FaultContract(typeof(SecurityAccessDeniedException))]
        [FaultContract(typeof(ArgumentException))]
        [FaultContract(typeof(ArgumentOutOfRangeException))]
        SNUserInfo GetSNUserInfoByXUID(ushort sNetworkId, ulong XUID);

        [OperationContract]
        [FaultContract(typeof(SecurityAccessDeniedException))]
        [FaultContract(typeof(ArgumentException))]
        [FaultContract(typeof(ArgumentOutOfRangeException))]
        [FaultContract(typeof(ArgumentNullException))]
        SNUserInfo GetSNUserInfoBySNUId(ushort sNetworkId, string snUserId);

        [OperationContract]
        [FaultContract(typeof(SecurityAccessDeniedException))]
        [FaultContract(typeof(ArgumentException))]
        [FaultContract(typeof(ArgumentOutOfRangeException))]
        [FaultContract(typeof(ArgumentNullException))]
        SNUserInfo[] GetSNUserInfos(ushort sNetworkId, string[] sNUserIDs);

        [OperationContract]
        [FaultContract(typeof(ArgumentOutOfRangeException))]
        SNetworkInfo GetSNetworkInfo(ushort sNetworkId);

        [OperationContract]
        SNetworkInfo[] GetSNetworkInfos();
    }

    [ServiceContract(Namespace="http://liveconnect.xboxlive.com")]
    public interface ILiveAuthentication
    {
        //Each of these interfaces is tied to a device which is sent in the XAML token
        [OperationContract]
        [FaultContract(typeof(SecurityAccessDeniedException))]
        [FaultContract(typeof(ArgumentException))]
        [FaultContract(typeof(ArgumentOutOfRangeException))]
        [FaultContract(typeof(ArgumentNullException))]
        void SetAuthInfo(ushort sNetworkId, ulong XUID, string gamerTag, string deviceId, SNAuthInfo userInfo, bool addToDirectory, Visibility visibility);

        [OperationContract]
        [FaultContract(typeof(SecurityAccessDeniedException))]
        [FaultContract(typeof(ArgumentException))]
        [FaultContract(typeof(ArgumentOutOfRangeException))]
        [FaultContract(typeof(ArgumentNullException))]
        SNAuthInfo GetAuthInfo(ushort sNetworkId, ulong XUID, string deviceId);

        [OperationContract]
        [FaultContract(typeof(SecurityAccessDeniedException))]
        [FaultContract(typeof(ArgumentException))]
        [FaultContract(typeof(ArgumentOutOfRangeException))]
        [FaultContract(typeof(ArgumentNullException))]
        void RemoveAuthInfo(ushort sNetworkId, ulong XUID, string deviceId);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup1\Monitoring\LiveConnectPing\WCF\StsTokenProvider.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IdentityModel;
using System.IdentityModel.Selectors;
using System.IdentityModel.Tokens;
using System.Xml;

namespace LiveConnectPing
{
    /// <summary>
    /// 
    /// </summary>
    public class StsTokenProvider: SecurityTokenProvider
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="stsToken"></param>
        public StsTokenProvider(string stsToken)
        {
            this.StsToken = stsToken;
        }

        /// <summary>
        /// 
        /// </summary>
        public string StsToken
        {
            get;
            private set;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="timeout"></param>
        /// <returns></returns>
        protected override SecurityToken GetTokenCore(TimeSpan timeout)
        {
            XmlDocument samlXml = new XmlDocument();

            try
            {
                samlXml.LoadXml(this.StsToken);
            }
            catch (XmlException e)
            {
                throw new ApplicationException("the specified STS token is invalid Xml.", e);
            }
            
            SecurityToken securityToken = new GenericXmlSecurityToken(samlXml.DocumentElement, null, DateTime.MinValue, DateTime.MaxValue, null, null, null);
            return securityToken;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup1\Monitoring\LiveConnectPing\Program.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using System.Diagnostics;
using System.ServiceModel;
using System.ServiceModel.Security;
using System.Configuration;
using System.Net;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;

using LiveConnectWeb;
using CommandLine;

namespace LiveConnectPing
{
    /// <summary>
    /// 
    /// </summary>
    class Program
    {
        private const string LiveConnectPingEventSource = "LiveConnectPing";
        private const byte WindowsPhonePlatform = 15;
        private static char[] BadSnuidChars = "<>:\",\\".ToCharArray();
        private static string Hostname;
        private static StsToken stsTokenGen;

        /// <summary>
        /// 
        /// </summary>
        public enum SocialNetwork: ushort
        {
            WindowsLiveSpaces = 1,
            Facebook,
            Twitter,
        }

        /// <summary>
        /// 
        /// </summary>
        [Flags]
        public enum LiveConnectErrors : int
        {
            None = 0x0,
            SmokeTest = 0x1,
            DirectorySts = 0x2,
            AuthSts = 0x4,
            DirectoryCert = 0x10,
            AuthCert = 0x20,
            AuthTwitter = 0x40,
            Unknown = 0x80,
            InvalidArgs = 0x100,
            InvalidClientCert = 0x200,
            DirectoryWP7 = 0x400,
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="args"></param>
        static void Main(string[] args)
        {
            LiveConnectErrors errors = LiveConnectErrors.None;

            try
            {
                LiveConnectPingArguments lcArgs = new LiveConnectPingArguments();
                if (!Parser.ParseArgumentsWithUsage(args, lcArgs))
                {
                    TraceEx.TraceError(7000, "Invalid argument(s) provided: {0}", Environment.CommandLine);
                    errors = LiveConnectErrors.InvalidArgs;
                    return;
                }

                Hostname = lcArgs.Hostname;
                if(lcArgs.IgnoreServerSslErrors)
                    ServicePointManager.ServerCertificateValidationCallback = (sender, certificate, chain, sslPolicyErrors) => true;

                if (!EventLog.SourceExists(LiveConnectPingEventSource))
                {
                    EventLog.CreateEventSource(LiveConnectPingEventSource, "Application");
                    Trace.TraceInformation("***Added LiveConnectPing event source to Application log.");
                }

                //validate that the required client cert is installed and that the private key is accessible
                if (!ValidateClientCert())
                {
                    errors = LiveConnectErrors.InvalidClientCert;
                    return;
                }

                stsTokenGen = new StsToken(ConfigurationManager.AppSettings["ClientCertSubject"]);

                if (!SmokeTest())
                    errors |= LiveConnectErrors.SmokeTest;
                //sts token auth
                if (!DirectoryTest(Authentication.ConsoleStsToken))
                    errors |= LiveConnectErrors.DirectorySts;
                if (!AuthenticationTest(Authentication.ConsoleStsToken))
                    errors |= LiveConnectErrors.AuthSts;
                //client cert auth
                if (!DirectoryTest(Authentication.ClientCertificate))
                    errors |= LiveConnectErrors.DirectoryCert;
                if (!AuthenticationTest(Authentication.ClientCertificate))
                    errors |= LiveConnectErrors.AuthCert;
                //twitter-specific case
                if (!TwitterAuthenticationTest())
                    errors |= LiveConnectErrors.AuthTwitter;             
                //WP7/MCB specific case
                if (!WP7DirectoryTest())
                    errors |= LiveConnectErrors.DirectoryWP7;
            }
            catch (Exception e)
            {
                TraceEx.TraceError(6000, "Unexpected exception occurred;\r\n\r\n{0}", e.ToString());
                errors |= LiveConnectErrors.Unknown;
            }
            finally
            {
                string message;
                if (errors == LiveConnectErrors.None)
                    message = "LiveConnectPing successfully completed with no errors.";
                else
                    message = String.Format("LiveConnectPing finished with the following error code(s): {0}.  Review previous error events for more details.", ((int)errors));
                
                Trace.TraceInformation(message);
                Environment.Exit((int)errors);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        private static bool ValidateClientCert()
        {
            string subject = ConfigurationManager.AppSettings["ClientCertSubject"];
            X509Store localMachine = null;
            bool success = true;

            try
            {
                TraceEx.TraceVerbose("Attempting to validate that the required client certificate (CN={0}) is installed and that the private key is available/accessible.", subject);
                localMachine = new X509Store(StoreName.My, StoreLocation.LocalMachine);
                localMachine.Open(OpenFlags.ReadOnly);
                X509Certificate2Collection matches = localMachine.Certificates.Find(X509FindType.FindBySubjectName, subject, false);

                if (matches == null || matches.Count == 0)
                {
                    TraceEx.TraceError(8000, "No client certificate matching subject '{0}' were found in LOCAL_MACHINE\\My.", subject);
                    success = false;
                }
                else if (matches.Count > 1)
                {
                    TraceEx.TraceError(8000, "{0} client certificates were found, matching subject '{1}', in LOCAL_MACHINE\\My.  Remove any bad/expired certificates and try again.", matches.Count, subject);
                    success = false;
                }
                else if (!matches[0].HasPrivateKey || !(matches[0].PrivateKey is RSACryptoServiceProvider))
                {
                    TraceEx.TraceError(8000, "The specified client certificate, matching subject '{0}', does not contain or have access to private key material.  Verify that the certificate PFX was correctly installed and that the account running this application has appropriate access.", subject);
                    success = false;
                }
        
                TraceEx.TraceVerbose("Successfully verified client certificate.");
            }
            catch
            {
                success = false;
            }
            finally
            {
                if (localMachine != null)
                    localMachine.Close();                
            }

            return success;
        }

        /// <summary>
        /// 
        /// </summary>
        private static bool SmokeTest()
        {
            try
            {
                TraceEx.TraceStart("Starting Smoke Page Validation.");
                string url = String.Format("https://{0}/smoke.aspx", Hostname);
                TraceEx.TraceVerbose("Using Smoke Page Url: {0}", url);

                using (WebClient client = new WebClient())
                {
                    client.DownloadString(url);
                }

                TraceEx.TraceVerbose("Successfully Validated Smoke Page.");
                return true;
            }
            catch (Exception e)
            {
                string message = String.Format("Error validating Smoke page:\r\n\r\n{0}", e.ToString());
                TraceEx.TraceError(1000, message);
                return false;
            }
            finally
            {
                TraceEx.TraceStop("Finished Smoke Page Validation.");
            }
        }

        /// <summary>
        /// Executes a suite of LiveConnect Directory tests, using client certificate or console STS token auth.
        /// </summary>
        /// <param name="useCertAuth"></param>
        private static bool DirectoryTest(Authentication authMode)
        {
            LiveDirectoryClient directoryClient = null;
            bool success = true;

            try
            {
                TraceEx.TraceStart("Starting Live Connect Directory Validation (using {0} authentication).", GetAuthModeText(authMode)); 
                directoryClient = new LiveDirectoryClient((authMode == Authentication.ClientCertificate ? "LiveDirectoryCert" : "LiveDirectorySts"));
                directoryClient.Endpoint.Address = new EndpointAddress(UpdateClientEndpoint(directoryClient), directoryClient.Endpoint.Address.Identity, directoryClient.Endpoint.Address.Headers);
                TraceEx.TraceVerbose("Using Live Connect Endpoint \"{0}\", at {1}", directoryClient.Endpoint.Name, directoryClient.Endpoint.Address.Uri);

                SNUserInfo userInfo = new SNUserInfo();
                userInfo.SNUserID = "PingTest-" + Utility.GenerateRandomString(10, BadSnuidChars);
                userInfo.GamerTag = Utility.GenerateRandomString(10);
                userInfo.XUID = Utility.GenerateRandomUInt64();
                userInfo.Visibility = Visibility.Everyone;

                if (authMode == Authentication.ConsoleStsToken)
                {
                    StsTokenParameters stsParameters = new StsTokenParameters() { Xuid = userInfo.XUID, TitleId = NetworkToTitleID((ushort)SocialNetwork.Facebook) };
                    ConfigureStsAuth(directoryClient, authMode, stsParameters);
                }

                try
                {
                    TraceEx.TraceVerbose("Opening channel...");
                    directoryClient.Open();
                    TraceEx.TraceVerbose("Calling SetSNUserInfo with UserID={0}, XUID={1}, GamerTag={2}, Visibility={3}, Network=Facebook",
                                                userInfo.SNUserID,
                                                userInfo.XUID,
                                                userInfo.GamerTag,
                                                userInfo.Visibility);
                    directoryClient.SetSNUserInfo((ushort)SocialNetwork.Facebook, userInfo);
                }
                catch (Exception e)
                {
                    HandleError("SetSNUserInfo", authMode, e);
                    success = false;
                }

                try
                {
                    TraceEx.TraceVerbose("Calling GetSNUserInfoBySNUId with UserID={0}, Network=Facebook", userInfo.SNUserID);
                    SNUserInfo actualUserInfo = directoryClient.GetSNUserInfoBySNUId((ushort)SocialNetwork.Facebook, userInfo.SNUserID);
                    if (userInfo.SNUserID != actualUserInfo.SNUserID)
                        throw new ValidationException("SNUserInfo returned from GetSNUserInfoBySNUId does not match the original value; expected SNUserID {0}, got {1}.", userInfo.SNUserID, actualUserInfo.SNUserID);
                    if (userInfo.GamerTag != actualUserInfo.GamerTag)
                        throw new ValidationException("SNUserInfo returned from GetSNUserInfoBySNUId does not match the original value; expected GamerTag {0}, got {1}.", userInfo.GamerTag, actualUserInfo.GamerTag);
                    if (userInfo.XUID != actualUserInfo.XUID)
                        throw new ValidationException("SNUserInfo returned from GetSNUserInfoBySNUId does not match the original value; expected XUID {0}, got {1}.", userInfo.XUID, actualUserInfo.XUID);
                    if (userInfo.Visibility != actualUserInfo.Visibility)
                        throw new ValidationException("SNUserInfo returned from GetSNUserInfoBySNUId does not match the original value; expected Visibility {0}, got {1}.", userInfo.Visibility, actualUserInfo.Visibility);
                }
                catch (Exception e)
                {
                    HandleError("GetSNUserInfoBySNUId", authMode, e);
                    success = false;
                }

                try
                {
                    TraceEx.TraceVerbose("Calling GetSNUserInfoByXUID with XUID={0}, Network=Facebook", userInfo.XUID);
                    SNUserInfo actualUserInfo = directoryClient.GetSNUserInfoByXUID((ushort)SocialNetwork.Facebook, userInfo.XUID);
                    if (userInfo.SNUserID != actualUserInfo.SNUserID)
                        throw new ValidationException("SNUserInfo returned from GetSNUserInfoByXUID does not match the original value; expected SNUserID {0}, got {1}.", userInfo.SNUserID, actualUserInfo.SNUserID);
                    if (userInfo.GamerTag != actualUserInfo.GamerTag)
                        throw new ValidationException("SNUserInfo returned from GetSNUserInfoByXUID does not match the original value; expected GamerTag {0}, got {1}.", userInfo.GamerTag, actualUserInfo.GamerTag);
                    if (userInfo.XUID != actualUserInfo.XUID)
                        throw new ValidationException("SNUserInfo returned from GetSNUserInfoByXUID does not match the original value; expected XUID {0}, got {1}.", userInfo.XUID, actualUserInfo.XUID);
                    if (userInfo.Visibility != actualUserInfo.Visibility)
                        throw new ValidationException("SNUserInfo returned from GetSNUserInfoByXUID does not match the original value; expected Visibility {0}, got {1}.", userInfo.Visibility, actualUserInfo.Visibility);
                }
                catch (Exception e)
                {
                    HandleError("GetSNUserInfoByXUID", authMode, e);
                    success = false;
                }

                try
                {
                    TraceEx.TraceVerbose("Calling GetSNUserInfos with UserID={0}, Network=Facebook", userInfo.SNUserID);
                    SNUserInfo[] actualUserInfos = directoryClient.GetSNUserInfos((ushort)SocialNetwork.Facebook, new string[] { userInfo.SNUserID });
                    if (actualUserInfos.Length != 1)
                        throw new ValidationException("Expected GetSNUserInfos to return 1 user, but got {0}", actualUserInfos.Length);
                    if (userInfo.SNUserID != actualUserInfos[0].SNUserID)
                        throw new ValidationException("SNUserInfo returned from GetSNUserInfos does not match the original value; expected SNUserID {0}, got {1}.", userInfo.SNUserID, actualUserInfos[0].SNUserID);
                    if (userInfo.GamerTag != actualUserInfos[0].GamerTag)
                        throw new ValidationException("SNUserInfo returned from GetSNUserInfos does not match the original value; expected GamerTag {0}, got {1}.", userInfo.GamerTag, actualUserInfos[0].GamerTag);
                    if (userInfo.XUID != actualUserInfos[0].XUID)
                        throw new ValidationException("SNUserInfo returned from GetSNUserInfos does not match the original value; expected XUID {0}, got {1}.", userInfo.XUID, actualUserInfos[0].XUID);
                    if (userInfo.Visibility != actualUserInfos[0].Visibility)
                        throw new ValidationException("SNUserInfo returned from GetSNUserInfos does not match the original value; expected Visibility {0}, got {1}.", userInfo.Visibility, actualUserInfos[0].Visibility);
                }
                catch (Exception e)
                {
                    HandleError("GetSNUserInfos", authMode, e);
                    success = false;
                }

                try
                {
                    TraceEx.TraceVerbose("Calling RemoveSNUserInfo with XUID={0}, Network=Facebook", userInfo.XUID);
                    directoryClient.RemoveSNUserInfo((ushort)SocialNetwork.Facebook, userInfo.XUID);
                }
                catch (Exception e)
                {
                    HandleError("RemoveSNUserInfo", authMode, e);
                    success = false;
                }

                TraceEx.TraceVerbose("Successfully validated Live Connect Directory service.");
            }
            finally
            {
                TraceEx.TraceStop("Finished Live Connect Directory Validation.");
                directoryClient.CloseConnection();
            }

            return success;
        }

        /// <summary>
        /// Executes a suite of LiveConnect Authentication tests, using client certificate and console STS token auth.
        /// </summary>
        /// <param name="useCertAuth"></param>
        private static bool AuthenticationTest(Authentication authMode)
        {
            LiveAuthenticationClient authClient = null;
            bool success = true;

            try
            {
                TraceEx.TraceStart("Starting Live Connect Authentication Validation (using {0} authentication).", GetAuthModeText(authMode));
                authClient = new LiveAuthenticationClient((authMode == Authentication.ClientCertificate ? "LiveAuthenticationCert" : "LiveAuthenticationSts"));
                authClient.Endpoint.Address = new EndpointAddress(UpdateClientEndpoint(authClient), authClient.Endpoint.Address.Identity, authClient.Endpoint.Address.Headers);
                TraceEx.TraceVerbose("Using Live Connect Authentication Endpoint \"{0}\", at {1}", authClient.Endpoint.Name, authClient.Endpoint.Address.Uri);

                SNUserInfo userInfo = new SNUserInfo();
                userInfo.SNUserID = "PingTest-" + Utility.GenerateRandomString(10, BadSnuidChars);
                userInfo.GamerTag = Utility.GenerateRandomString(10);
                userInfo.XUID = Utility.GenerateRandomUInt64();
                userInfo.Visibility = Visibility.Everyone;

                string deviceId = Utility.GenerateRandomUInt64().ToString();

                SNAuthInfo authInfo = new SNAuthInfo();
                authInfo.SNUserID = userInfo.SNUserID;
                authInfo.Token = Utility.GenerateRandomString(150);

                if (authMode == Authentication.ConsoleStsToken)
                {
                    StsTokenParameters stsParameters = new StsTokenParameters() { Xuid = userInfo.XUID, TitleId = NetworkToTitleID((ushort)SocialNetwork.Twitter), MachineId=ulong.Parse(deviceId) };
                    ConfigureStsAuth(authClient, authMode, stsParameters);
                }

                try
                {
                    TraceEx.TraceVerbose("Opening channel...");
                    authClient.Open();
                    TraceEx.TraceVerbose("Calling SetAuthInfo with XUID={0}, GamerTag={1}, DeviceID={2}, Token={3}, Visibility={4}, Network=Twitter", 
                                                userInfo.XUID,
                                                userInfo.GamerTag,
                                                deviceId,
                                                authInfo.Token,
                                                userInfo.Visibility);
                    authClient.SetAuthInfo((ushort)SocialNetwork.Twitter, userInfo.XUID, userInfo.GamerTag, deviceId, authInfo, true, userInfo.Visibility);
                }
                catch (Exception e)
                {
                    HandleError("SetAuthInfo", authMode, e);
                    success = false;
                }

                try
                {
                    TraceEx.TraceVerbose("Calling GetAuthInfo with XUID={0}, DeviceID={1}, Network=Twitter", userInfo.XUID, deviceId);
                    SNAuthInfo actualAuthInfo = authClient.GetAuthInfo((ushort)SocialNetwork.Twitter, userInfo.XUID, deviceId);
                    if (authInfo.SNUserID != actualAuthInfo.SNUserID)
                        throw new ValidationException("SNAuthInfo returned from GetAuthInfo does not match the original value; expected SNUserID {0}, got {1}.", authInfo.SNUserID, actualAuthInfo.SNUserID);
                    if (authInfo.Token != actualAuthInfo.Token)
                        throw new ValidationException("SNAuthInfo returned from GetAuthInfo does not match the original value; expected Token {0}, got {1}.", authInfo.Token, actualAuthInfo.Token);                    
                }
                catch (Exception e)
                {
                    HandleError("GetAuthInfo", authMode, e);
                    success = false;
                }
                                
                try
                {
                    TraceEx.TraceVerbose("Calling RemoveAuthInfo with XUID={0}, DeviceID={1}, Network=Twitter", userInfo.XUID, deviceId);
                    authClient.RemoveAuthInfo((ushort)SocialNetwork.Twitter, userInfo.XUID, deviceId);
                }
                catch (Exception e)
                {
                    HandleError("RemoveAuthInfo", authMode, e);
                    success = false;
                }

                TraceEx.TraceVerbose("Successfully validated Live Connect Authentication service.");
            }
            finally
            {
                TraceEx.TraceStop("Finished Live Connect Authentication Validation.");
                authClient.CloseConnection();
            }

            return success;
        }

        /// <summary>
        /// 
        /// </summary>
        private static bool TwitterAuthenticationTest()
        {
            LiveAuthenticationClient authClient = null;
            bool success = true;

            try
            {
                TraceEx.TraceStart("Starting Live Connect Twitter Authentication Validation (using STS token authentication).");
                authClient = new LiveAuthenticationClient("LiveAuthenticationSts");
                authClient.Endpoint.Address = new EndpointAddress(UpdateClientEndpoint(authClient), authClient.Endpoint.Address.Identity, authClient.Endpoint.Address.Headers);
                TraceEx.TraceVerbose("Using Live Connect Authentication Endpoint \"{0}\", at {1}", authClient.Endpoint.Name, authClient.Endpoint.Address.Uri);

                SNUserInfo userInfo = new SNUserInfo();
                userInfo.SNUserID = "PingTest-" + Utility.GenerateRandomString(10, BadSnuidChars);
                userInfo.GamerTag = Utility.GenerateRandomString(10);
                userInfo.XUID = 0;  //Twitter special case value; Lua can't easily deal w/ ulong...
                userInfo.Visibility = Visibility.Everyone;

                ulong stsXuid = Utility.GenerateRandomUInt64();
                string stsMachineId = Utility.GenerateRandomUInt64().ToString();

                SNAuthInfo authInfo = new SNAuthInfo();
                authInfo.SNUserID = userInfo.SNUserID;
                authInfo.Token = Utility.GenerateRandomString(150);

                StsTokenParameters stsParameters = new StsTokenParameters() { Xuid = stsXuid, TitleId = NetworkToTitleID((ushort)SocialNetwork.Twitter), MachineId = ulong.Parse(stsMachineId) };
                ConfigureStsAuth(authClient, Authentication.ConsoleStsToken, stsParameters);
               
                try
                {
                    TraceEx.TraceVerbose("Opening channel...");
                    authClient.Open();
                    TraceEx.TraceVerbose("Calling SetAuthInfo with XUID={0}, GamerTag={1}, DeviceID=NULL, Token={2}, Visibility={3}, Network=Twitter",
                                                userInfo.XUID,
                                                userInfo.GamerTag,
                                                authInfo.Token,
                                                userInfo.Visibility);
                    authClient.SetAuthInfo((ushort)SocialNetwork.Twitter, userInfo.XUID, userInfo.GamerTag, null, authInfo, true, userInfo.Visibility);
                }
                catch (Exception e)
                {
                    HandleError("SetAuthInfo", Authentication.ConsoleStsToken, e);
                    success = false;
                }

                try
                {
                    TraceEx.TraceVerbose("Calling GetAuthInfo with XUID={0}, DeviceID={1}, Network=Twitter", stsXuid, stsMachineId);
                    SNAuthInfo actualAuthInfo = authClient.GetAuthInfo((ushort)SocialNetwork.Twitter, stsXuid, stsMachineId);
                    if (authInfo.SNUserID != actualAuthInfo.SNUserID)
                        throw new ValidationException("SNAuthInfo returned from GetAuthInfo does not match the original value; expected SNUserID {0}, got {1}.", authInfo.SNUserID, actualAuthInfo.SNUserID);
                    if (authInfo.Token != actualAuthInfo.Token)
                        throw new ValidationException("SNAuthInfo returned from GetAuthInfo does not match the original value; expected Token {0}, got {1}.", authInfo.Token, actualAuthInfo.Token);
                }
                catch (Exception e)
                {
                    HandleError("GetAuthInfo", Authentication.ConsoleStsToken, e);
                    success = false;
                }

                try
                {
                    TraceEx.TraceVerbose("Calling RemoveAuthInfo with XUID={0}, DeviceID={1}, Network=Twitter", stsXuid, stsMachineId);
                    authClient.RemoveAuthInfo((ushort)SocialNetwork.Twitter, stsXuid, stsMachineId);
                }
                catch (Exception e)
                {
                    HandleError("RemoveAuthInfo", Authentication.ConsoleStsToken, e);
                    success = false;
                }

                TraceEx.TraceVerbose("Successfully validated Live Connect Twitter Authentication service.");
            }
            finally
            {
                TraceEx.TraceStop("Finished Live Connect Twitter Authentication Validation.");
                authClient.CloseConnection();
            }

            return success;
        }

        /// <summary>
        /// Specific test for MCB/WP7 clients, which use user token STS auth.
        /// </summary>
        /// <returns></returns>
        private static bool WP7DirectoryTest()
        {
            LiveDirectoryClient directoryClient = null;
            bool success = true;

            try
            {
                TraceEx.TraceStart("Starting Live Connect WP7 Directory Validation (using STS user token authentication).");
                directoryClient = new LiveDirectoryClient("LiveDirectorySts");
                directoryClient.Endpoint.Address = new EndpointAddress(UpdateClientEndpoint(directoryClient), directoryClient.Endpoint.Address.Identity, directoryClient.Endpoint.Address.Headers);
                TraceEx.TraceVerbose("Using Live Connect Endpoint \"{0}\", at {1}", directoryClient.Endpoint.Name, directoryClient.Endpoint.Address.Uri);

                SNUserInfo userInfo = new SNUserInfo();
                userInfo.SNUserID = "PingTest-" + Utility.GenerateRandomString(10, BadSnuidChars);
                userInfo.GamerTag = Utility.GenerateRandomString(10);
                userInfo.XUID = Utility.GenerateRandomUInt64();
                userInfo.Visibility = Visibility.Everyone;

                StsTokenParameters stsParameters = new StsTokenParameters() { Xuid = userInfo.XUID, TitleId = (uint)XboxTitle.WP7GamesHub, TitleVersion = "1", PlatformType = WindowsPhonePlatform.ToString(), GamerTag = userInfo.GamerTag };
                ConfigureStsAuth(directoryClient, Authentication.UserStsToken, stsParameters);
                
                try
                {
                    TraceEx.TraceVerbose("Opening channel...");
                    directoryClient.Open();
                    TraceEx.TraceVerbose("Calling SetSNUserInfo with UserID={0}, XUID={1}, GamerTag={2}, Visibility={3}, Network=Facebook",
                                                userInfo.SNUserID,
                                                userInfo.XUID,
                                                userInfo.GamerTag,
                                                userInfo.Visibility);
                    directoryClient.SetSNUserInfo((ushort)SocialNetwork.Facebook, userInfo);
                }
                catch (Exception e)
                {
                    HandleError("SetSNUserInfo", Authentication.UserStsToken, e);
                    success = false;
                }

                try
                {
                    TraceEx.TraceVerbose("Calling GetSNUserInfoBySNUId with UserID={0}, Network=Facebook", userInfo.SNUserID);
                    SNUserInfo actualUserInfo = directoryClient.GetSNUserInfoBySNUId((ushort)SocialNetwork.Facebook, userInfo.SNUserID);
                    if (userInfo.SNUserID != actualUserInfo.SNUserID)
                        throw new ValidationException("SNUserInfo returned from GetSNUserInfoBySNUId does not match the original value; expected SNUserID {0}, got {1}.", userInfo.SNUserID, actualUserInfo.SNUserID);
                    if (userInfo.GamerTag != actualUserInfo.GamerTag)
                        throw new ValidationException("SNUserInfo returned from GetSNUserInfoBySNUId does not match the original value; expected GamerTag {0}, got {1}.", userInfo.GamerTag, actualUserInfo.GamerTag);
                    if (userInfo.XUID != actualUserInfo.XUID)
                        throw new ValidationException("SNUserInfo returned from GetSNUserInfoBySNUId does not match the original value; expected XUID {0}, got {1}.", userInfo.XUID, actualUserInfo.XUID);
                    if (userInfo.Visibility != actualUserInfo.Visibility)
                        throw new ValidationException("SNUserInfo returned from GetSNUserInfoBySNUId does not match the original value; expected Visibility {0}, got {1}.", userInfo.Visibility, actualUserInfo.Visibility);
                }
                catch (Exception e)
                {
                    HandleError("GetSNUserInfoBySNUId", Authentication.UserStsToken, e);
                    success = false;
                }
                finally
                {
                    directoryClient.CloseConnection();
                }

                //reset the client, to send a new gamertag in the token, in the call to GetSNUserInfos
                //this should update in the database
                directoryClient = new LiveDirectoryClient("LiveDirectorySts");
                directoryClient.Endpoint.Address = new EndpointAddress(UpdateClientEndpoint(directoryClient), directoryClient.Endpoint.Address.Identity, directoryClient.Endpoint.Address.Headers);
                
                string newGamerTag = Utility.GenerateRandomGamerTag(10);
                stsParameters.GamerTag = newGamerTag;
                ConfigureStsAuth(directoryClient, Authentication.UserStsToken, stsParameters);
                
                try
                {
                    TraceEx.TraceVerbose("Calling GetSNUserInfos with UserID={0}, Network=Facebook", userInfo.SNUserID);
                    SNUserInfo[] actualUserInfos = directoryClient.GetSNUserInfos((ushort)SocialNetwork.Facebook, new string[] { userInfo.SNUserID });
                    if (actualUserInfos.Length != 1)
                        throw new ValidationException("Expected GetSNUserInfos to return 1 user, but got {0}", actualUserInfos.Length);
                    if (userInfo.SNUserID != actualUserInfos[0].SNUserID)
                        throw new ValidationException("SNUserInfo returned from GetSNUserInfos does not match the original value; expected SNUserID {0}, got {1}.", userInfo.SNUserID, actualUserInfos[0].SNUserID);
                    if (userInfo.GamerTag != actualUserInfos[0].GamerTag)
                        throw new ValidationException("SNUserInfo returned from GetSNUserInfos does not match the original value; expected GamerTag {0}, got {1}.", userInfo.GamerTag, actualUserInfos[0].GamerTag);
                    //NOTE: special WP7 case; we zero out the xuid for user token calls to GetSNUserInfos
                    if (actualUserInfos[0].XUID != 0)
                        throw new ValidationException("SNUserInfo returned from GetSNUserInfos does not match the original value; expected XUID {0}, got {1}.", userInfo.XUID, actualUserInfos[0].XUID);
                    if (userInfo.Visibility != actualUserInfos[0].Visibility)
                        throw new ValidationException("SNUserInfo returned from GetSNUserInfos does not match the original value; expected Visibility {0}, got {1}.", userInfo.Visibility, actualUserInfos[0].Visibility);
                }
                catch (Exception e)
                {
                    HandleError("GetSNUserInfos", Authentication.UserStsToken, e);
                    success = false;
                }

                try
                {
                    TraceEx.TraceVerbose("Verifying gamertag refresh from {0} -> {1}...", userInfo.GamerTag, newGamerTag);
                    int attempts = 1;
                    bool verifiedChange = false;

                    do
                    {
                        SNUserInfo actualUserInfo = directoryClient.GetSNUserInfoBySNUId((ushort)SocialNetwork.Facebook, userInfo.SNUserID);
                        if (newGamerTag.Equals(actualUserInfo.GamerTag))
                        {
                            verifiedChange = true;
                            TraceEx.TraceVerbose("Successfully verified gamertag change, after {0} attempt(s)!", attempts);
                            break;
                        }

                        Thread.Sleep(500);  //wait just a bit...
                    }
                    while (attempts++ < 5);

                    if (!verifiedChange)
                        throw new ValidationException("Unable to verify gamertag refresh from {0} -> {1}, after 5 attempts.", userInfo.GamerTag, newGamerTag);
                }
                catch (Exception e)
                {
                    HandleError("GetSNUserInfoBySNUId", Authentication.UserStsToken, e);
                    success = false;
                }
            }
            finally
            {
                TraceEx.TraceStop("Finished Live Connect WP7 Directory Validation.");
                directoryClient.CloseConnection();
            }

            return success;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="e"></param>
        private static void HandleError(string api, Authentication authMode, Exception e)
        {
            string authModeText = GetAuthModeText(authMode);
            string message;
            int eventId;

            if (e is FaultException<SecurityAccessDeniedException>)
            {
                FaultException<SecurityAccessDeniedException> fault = e as FaultException<SecurityAccessDeniedException>;
                message = String.Format("{0} (using {2} auth) returned SecurityAccessDeniedException; STS or cert auth failed; SOAP fault Detail: {1}", api, fault.Detail.Message, authModeText);
                eventId = 2000;
            }
            else if (e is FaultException<ArgumentException>)
            {
                FaultException<ArgumentException> fault = e as FaultException<ArgumentException>;
                message = String.Format("{0} (using {2} auth) returned ArgumentException; invalid parameter(s) sent; SOAP fault Detail: {1}", api, fault.Detail.Message, authModeText);
                eventId = 2001;
            }
            else if (e is FaultException<ArgumentOutOfRangeException>)
            {
                FaultException<ArgumentOutOfRangeException> fault = e as FaultException<ArgumentOutOfRangeException>;
                message = String.Format("{0} (using {2} auth) returned ArgumentOutOfRangeException; out-of-range parameter(s) sent; SOAP fault Detail: {1}", api, fault.Detail.Message, authModeText);
                eventId = 2002;
            }
            else if (e is FaultException<ArgumentNullException>)
            {
                FaultException<ArgumentNullException> fault = e as FaultException<ArgumentNullException>;
                message = String.Format("{0} (using {2} auth) returned ArgumentNullException; null parameter(s) sent; SOAP fault Detail: {1}", api, fault.Detail.Message, authModeText);
                eventId = 2003;
            }
            else if (e is FaultException)
            {
                FaultException fault = e as FaultException;
                message = String.Format("Bug! {0} (using {2} auth) returned an unknown FaultException! {0}. An unexpected, internal error occurred: {1}", api, GetExceptionText(fault), authModeText);
                eventId = 2004;
            }
            else if (e is MessageSecurityException)
            {
                MessageSecurityException fault = e as MessageSecurityException;
                message = String.Format("{0} (using {2} auth) returned MessageSecurityException; invalid STS token or client certificate; SOAP fault Detail: {1}", api, GetExceptionText(fault), authModeText);
                eventId = 2005;
            }
            else if (e is TimeoutException)
            {
                TimeoutException fault = e as TimeoutException;
                message = String.Format("Encountered a timeout when calling {0} (using {2} auth): {1}", api, fault.Message, authModeText);
                eventId = 3000;
            }
            else if (e is CommunicationException)
            {
                CommunicationException fault = e as CommunicationException;
                message = String.Format("Encountered a communication issue when calling {0} (using {2} auth): {1}", api, GetExceptionText(fault), authModeText);
                eventId = 4000;
            }
            else if (e is ValidationException)
            {
                ValidationException fault = e as ValidationException;
                message = String.Format("Encountered a validation issue when calling {0} (using {2} auth); expected vs. actual data returned from the service did not match! {1}", api, fault.Message, authModeText);
                eventId = 5000;
            }
            else
            {
                message = String.Format("Unexpected exception occurred while calling {0} (using {2} auth)!\r\n\r\n{1}", api, e.ToString(), authModeText);
                eventId = 6000;
            }

            TraceEx.TraceError(eventId, message);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="client"></param>
        /// <param name="stsParameters"></param>
        private static void ConfigureStsAuth(LiveDirectoryClient client, Authentication authMode, StsTokenParameters stsParameters)
        {
            client.ChannelFactory.Endpoint.Behaviors.RemoveAll<System.ServiceModel.Description.ClientCredentials>();
            
            string stsToken = null;
            if (authMode == Authentication.UserStsToken)
            {
                stsToken = stsTokenGen.GenerateUserToken(stsParameters);
            }
            else
            {
                stsToken = stsTokenGen.GenerateConsoleToken(stsParameters);
            }

            client.ChannelFactory.Endpoint.Behaviors.Add(new StsClientCredentials(stsToken));
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="client"></param>
        /// <param name="stsParameters"></param>
        private static void ConfigureStsAuth(LiveAuthenticationClient client, Authentication authMode, StsTokenParameters stsParameters)
        {
            client.ChannelFactory.Endpoint.Behaviors.RemoveAll<System.ServiceModel.Description.ClientCredentials>();

            string stsToken = null;
            if (authMode == Authentication.UserStsToken)
            {
                stsToken = stsTokenGen.GenerateUserToken(stsParameters);
            }
            else
            {
                stsToken = stsTokenGen.GenerateConsoleToken(stsParameters);
            }

            client.ChannelFactory.Endpoint.Behaviors.Add(new StsClientCredentials(stsToken));
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="networkId"></param>
        /// <returns></returns>
        private static uint NetworkToTitleID(ushort networkId)
        {
            if (networkId == 2)
                return 0x584807E1;  //Facebook title ID
            return 0xFFFE07D1;      //Xbox 360 dash (BDEs - like twitter, get this title ID)
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="client"></param>
        /// <returns></returns>
        private static Uri UpdateClientEndpoint(LiveDirectoryClient client)
        {
            return new Uri(client.Endpoint.Address.Uri.Scheme + "://" + Hostname + client.Endpoint.Address.Uri.PathAndQuery);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="client"></param>
        /// <returns></returns>
        private static Uri UpdateClientEndpoint(LiveAuthenticationClient client)
        {
            return new Uri(client.Endpoint.Address.Uri.Scheme + "://" + Hostname + client.Endpoint.Address.Uri.PathAndQuery);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="e"></param>
        private static string GetExceptionText(Exception e)
        {
            if(e.InnerException != null)
                return e.InnerException.Message;
            return e.Message;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="authMode"></param>
        /// <returns></returns>
        private static string GetAuthModeText(Authentication authMode)
        {
            switch (authMode)
            {
                case Authentication.ClientCertificate:
                    {
                        return "client certificate";
                    }
                case Authentication.ConsoleStsToken:
                    {
                        return "console STS token";
                    }
                case Authentication.UserStsToken:
                    {
                        return "user STS token";
                    }
                default:
                    {
                        return "no authentication";
                    }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\LCWebService\LiveConnectEventLogger.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Diagnostics;

namespace LiveConnectWeb
{
    enum EventErrorIds
    {
        InternalServerError = 1000,
        GeneralSQLError = 2000,
        GeneralSecurityViolation = 3000,
        STSSecurityTitleViolation = 4001,
        STSSecurityXUIDViolation = 4002,
        STSSecurityPrivacyViolation = 4003,
        X509NoValidCertFound = 5001,
        X509SubjectViolation = 5002
    }

    class LiveConnectEventLogger
    {
        private static readonly LiveConnectEventLogger instance = new LiveConnectEventLogger();

        private LiveConnectEventLogger()
        {
            eventLog = new EventLog();
            eventLog.Source = "LiveConnect";
        }

        internal static LiveConnectEventLogger Instance
        {
            get
            {
                return instance;
            }
        }

        public EventLog EventLog
        {
            get
            {
                return eventLog;
            }
        }
        
        EventLog eventLog;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\LCWebService\MessageInterceptor.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.ServiceModel.Dispatcher;
using System.ServiceModel.Description;
using System.ServiceModel;
using System.Collections.ObjectModel;
using System.ServiceModel.Channels;
using System.IO;

namespace LiveConnectWeb
{
    class MessageInterceptor : IDispatchMessageInspector, IServiceBehavior
    {
        DateTime timeToCheckSiteClosed;
        bool isUpdating = false;
        string siteClosedFileName;

        public MessageInterceptor()
        {
            timeToCheckSiteClosed = DateTime.Now;
            siteClosedFileName = System.Web.Hosting.HostingEnvironment.ApplicationPhysicalPath + "site.closed";
        }

        public object AfterReceiveRequest(ref System.ServiceModel.Channels.Message request, IClientChannel channel, InstanceContext instanceContext)
        {
            if (timeToCheckSiteClosed < DateTime.Now)
            {
                isUpdating = File.Exists(siteClosedFileName);
                timeToCheckSiteClosed = DateTime.Now + TimeSpan.FromSeconds(30);
            }

            // DeploymentStatus is just a static class, used throughout the project  web or otherwise  indicate the state of the site
            if (isUpdating)
            {
                throw new FaultException("Service is temporarily unavailable");
            }

            return null;
        }

        public void BeforeSendReply(ref System.ServiceModel.Channels.Message reply, object correlationState)
        {
        }

        public void ApplyDispatchBehavior(
            ServiceDescription desc, ServiceHostBase host)
        {
            foreach (
                ChannelDispatcher cDispatcher in host.ChannelDispatchers)
                foreach (EndpointDispatcher eDispatcher in
                    cDispatcher.Endpoints)
                    eDispatcher.DispatchRuntime.MessageInspectors.Add(
                        new MessageInterceptor());
        }

        public void AddBindingParameters(
            ServiceDescription serviceDescription,
            ServiceHostBase serviceHostBase,
            Collection<ServiceEndpoint> endpoints,
            BindingParameterCollection bindingParameters
        )
        {
            return;
        }

        public void Validate(
            ServiceDescription serviceDescription,
            ServiceHostBase serviceHostBase
        )
        {
            return;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\LCWebService\NetworkMapper.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Configuration;

namespace LiveConnectWeb
{
    internal abstract class NetworkMapper
    {
        protected NetworkMapper(string Key)
        {
            this.key = Key;
            key += ";";
        }

        internal void LoadFromConfig()
        {
            for (int i = 0; i < ConfigurationManager.AppSettings.Count; i++)
            {
                if (ConfigurationManager.AppSettings.GetKey(i).StartsWith(key))
                {
                    bool[] networks = new bool[MaxNetworks];

                    SetAllowedNetworks(ConfigurationManager.AppSettings[i], ref networks);

                    entries.Add(
                        ConfigurationManager.AppSettings.GetKey(i).Substring(key.Length, ConfigurationManager.AppSettings.GetKey(i).Length - key.Length).ToLower(),
                        networks);
                }
                else if (ConfigurationManager.AppSettings.GetKey(i).Equals("NumberOfNetworks"))
                {
                    ushort numNetworks = 0;

                    if (ushort.TryParse(ConfigurationManager.AppSettings[i], out numNetworks))
                    {
                        MaxNetworks = numNetworks;
                    }
                }
            }
        }

        internal bool IsEntryAllowed(ushort networkId, string entryId)
        {
            bool[] networks;

            if (networkId > MaxNetworks || entryId.Length == 0)
            {
                return false;
            }

            if (entries.TryGetValue(entryId.ToLower(), out networks))
            {
                return networks[networkId];
            }

            return false;
        }

        private void SetAllowedNetworks(string networkList, ref bool[] networks)
        {
            int first = 0, second = 0, network;
            bool done = false;

            if (networkList == null || networks == null || networkList.Length < 1 || networks.Length < 1)
            {
                return;
            }

            second = networkList.IndexOf(',', first);

            do
            {
                if (second == -1)
                {
                    second = networkList.Length;
                    done = true;
                }

                network = 0;
                if (int.TryParse(networkList.Substring(first, second - first), out network) && network <= networks.Length && network > 0)
                {
                    networks[network] = true;
                }

                if (!done)
                {
                    first = ++second;
                    second = networkList.IndexOf(',', first);
                }
            } while (!done);
        }

        internal ushort MaxNumNetworks { get { return MaxNetworks; } }

        protected ushort MaxNetworks = 5;
        private Dictionary<string, bool[]> entries = new Dictionary<string, bool[]>();
        private string key;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\LCWebService\ServiceFactory.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.ServiceModel.Activation;
using System.ServiceModel;

namespace LiveConnectWeb
{
    public class ServiceFactory : ServiceHostFactory
    {
        public override ServiceHostBase CreateServiceHost(string service, Uri[] baseAddresses)
        {
            ServiceHost serviceHost;

            serviceHost = new ServiceHost(typeof(LiveConnectWeb.LiveConnect), baseAddresses);
            serviceHost.Opening += new EventHandler(LiveConnect.Opening);

            serviceHost.Description.Behaviors.Add(new MessageInterceptor());

            return serviceHost;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\LCWebService\Smoke.aspx.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Globalization;
using System.Net;
using System.IO;
using System.Diagnostics;

/// <summary>
/// Summary description for Smoke.
/// </summary>
public partial class Smoke : System.Web.UI.Page
{
    private static string buildNumber;
    private static object buildLock = new object();

    /// <summary>
    /// 
    /// </summary>
    private string BuildNumber
    {
        get
        {
            if (buildNumber == null)
            {
                lock (buildLock)
                {
                    if (buildNumber == null)
                    {
                        buildNumber = typeof(LiveConnectWeb.LiveConnect).Assembly.GetName().Version.ToString();
                    }
                }
            }

            return buildNumber;
        }
    }

    /// <summary>
    /// 
    /// </summary>
    protected void DoSmokeTests()
    {
        bool result = true;
        result &= WriteHeaderInfo();
        result &= DoSqlStatementTest();
        //result &= DoStoredProcTest();
        
        if (!result)
            this.Response.StatusCode = 500; //one or more tests failed
    }


    /// <summary>
    /// 
    /// </summary>
    private bool WriteHeaderInfo()
    {
        try
        {
            Response.Write("<h2>Site Info</h2><br/>");
            string machineName = Environment.MachineName;
            if (machineName.Length < 5)
                machineName = "###";
            else
                machineName = machineName.Substring(0, 1) + "####" + machineName.Substring(machineName.Length - 4);
            Response.Write("Host: " + machineName + "<br/>");
            Response.Write(String.Format("{0}<br/>", BuildNumber));
            return true;
        }
        catch (Exception ex)
        {
            Response.Write(ex.ToString() + "<br/><br/>");
            return false;
        }
    }

    /// <summary>
    /// 
    /// </summary>
    /// <returns></returns>
    private bool DoSqlStatementTest()
    {
        try
        {
            Response.Write("<h2>Accessing DB</h2><br/>");
            Response.Write("<strong>SQL Statements:</strong><br/>");
            
            using(SqlConnection connection = new SqlConnection(System.Configuration.ConfigurationManager.ConnectionStrings["LiveConnect"].ConnectionString))
            using(SqlCommand command = new SqlCommand("SELECT * FROM NetworkInfo (nolock)", connection))
            {
            	connection.Open();
		using(SqlDataReader reader = command.ExecuteReader())
		{
			while(reader.Read())
			{
				Response.Write(String.Format("{0}, {1}, {2}<br/>", reader["SNetworkId"], reader["Description"], reader["Logo"]));
			}
		}
	    }
	    	    
            Response.Write("OK<br/><br/>");           
            return true;
        }
        catch (Exception ex)
        {
            Response.Write(ex.ToString() + "<br/><br/>");
            return false;
        }
    }

    /// <summary>
    /// 
    /// </summary>
    /// <returns></returns>
    /*private bool DoStoredProcTest()
    {
        try
        {
            Response.Write("<strong>Stored Procedures:</strong><br/>");
            using(SqlConnection connection = new SqlConnection("Persist Security Info=False;Integrated Security=SSPI;database=LiveConnect;server=LEOSQL"))
	    using(SqlCommand command = new SqlCommand("SELECT * FROM NetworkInfo (nolock)", connection))
	    {
	    	using(SqlDataReader reader = command.ExecuteReader())
	    	{
			while(reader.Read())
			{
				Response.Write(String.Format("{0}, {1}, {2}", reader["SNetworkId"], reader["Description"], reader["Logo"]));
			}
		}
	    }
            Response.Write("OK<br/><br/>");
            return true;
        }
        catch (Exception ex)
        {
            Response.Write(ex.ToString() + "<br/><br/>");
            return false;
        }
    }    */
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\LCWebService\SNAuthInfo.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Runtime.Serialization;

namespace LiveConnectWeb
{
    [DataContract]
    public class SNAuthInfo
    {
        string snUserId;
        string token;

        [DataMember]
        public string SNUserID
        {
            get
            {
                return snUserId;
            }

            set
            {
                snUserId = value;
            }
        }

        [DataMember]
        public string Token
        {
            get
            {
                return token;
            }

            set
            {
                token = value;
            }
        }

        public override string ToString()
        {
            return String.Format("SNUserID={0}, Token={1}", this.snUserId, this.token);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\LCWebService\SNInfo.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Runtime.Serialization;

namespace LiveConnectWeb
{
    [DataContract]
    public class SNetworkInfo
    {
        string description;
        string logo;
        uint networkId;

        [DataMember]
        public string Description
        {
            get
            {
                return description;
            }

            set
            {
                description = value;
            }
        }

        [DataMember]
        public string Logo
        {
            get
            {
                return logo;
            }

            set
            {
                logo = value;
            }
        }

        [DataMember]
        public uint Id
        {
            get
            {
                return networkId;
            }

            set
            {
                networkId = value;
            }
        }

        public override string ToString()
        {
            return String.Format("{0} (ID={1}) - {2}", this.Description, this.Id, this.Logo);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\LCWebService\TitleNetworkMapper.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Configuration;

namespace LiveConnectWeb
{
    internal sealed class TitleNetworkMapper : NetworkMapper
    {
        private static readonly TitleNetworkMapper instance = new TitleNetworkMapper("TitleId");

        private TitleNetworkMapper(string key)
            : base(key)
        {
        }

        internal static TitleNetworkMapper Instance
        {
            get
            {
                return instance;
            }
        }

        internal bool IsTitleAllowed(ushort networkId, string titleId)
        {
            return base.IsEntryAllowed(networkId, titleId);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\LCWebService\SNUserInfo.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Runtime.Serialization;

namespace LiveConnectWeb
{
    [DataContract]
    public enum Visibility
    {
        [EnumMember] Me,
        [EnumMember] Everyone
    };

    [DataContract]
    public partial class SNUserInfo
    {
        string snUserId;
        string gamerTag;
        ulong xuid;
        Visibility visibility;

        [DataMember]
        public ulong XUID
        {
            get
            {
                return xuid;
            }
            set
            {
                xuid = value;
            }
        }

        [DataMember]
        public string GamerTag
        {
            get
            {
                return gamerTag;
            }

            set
            {
                gamerTag = value;
            }
        }

        [DataMember]
        public string SNUserID 
        { 
            get
            {
                return snUserId;
            }

            set
            {
                snUserId = value;
            }
        }

        [DataMember]
        public Visibility Visibility 
        {
            get
            {
                return visibility;
            }

            set
            {
                visibility = value;
            }
        }

        public override string ToString()
        {
            return ToString("\r\n");
        }

        public string ToString(string delimiter)
        {
            return String.Format("XUID={0}{4}GamerTag={1}{4}SNUserID={2}{4}Visibility={3}",
                                    this.xuid.ToString("X16"),
                                    this.gamerTag,
                                    this.snUserId,
                                    this.visibility,
                                    delimiter);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\LCWebService\X509ClientInfo.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.ServiceModel;
using System.Security.Principal;

namespace LiveConnectWeb
{
    internal class X509ClientInfo
    {
        internal static X509ClientInfo GetFromOperationContext()
        {
            X509ClientInfo clientInfo = null;
            char[] deliminator = {';'};

                if (OperationContext.Current.ServiceSecurityContext.PrimaryIdentity.AuthenticationType.CompareTo("X509") == 0)
                {
                    string[] values = OperationContext.Current.ServiceSecurityContext.PrimaryIdentity.Name.Split(deliminator);

                    if (values.Length == 2)
                    {
                        clientInfo = new X509ClientInfo();

                        clientInfo.Subject = CertNetworkMapper.Instance.NormalizeSubject(values[0]);

                        clientInfo.Thumbprint = values[1];
                    }
                }

                return clientInfo;
        }

        internal string Subject { get; private set; }
        internal string Thumbprint { get; private set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\LCWebService\XBoxClientInfo.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.ServiceModel;
using System.IdentityModel.Tokens;
using System.Globalization;

namespace LiveConnectWeb
{
    public class XBoxClientInfo
    {
        internal ushort Platform {get; private set;}
        internal string MachineId { get; private set; }
        internal uint ClientVersion { get; private set; }
        internal string TitleId { get; private set; }
        internal uint TitleVersion { get; private set; }
        internal ulong Xuid { get; private set; }
        internal ushort Tier { get; private set; }
        internal ushort Country { get; private set; }

        public static XBoxClientInfo GetFromSamlToken()
        {
            XBoxClientInfo clientInfo = null;

            if (OperationContext.Current.IncomingMessageProperties.Security.IncomingSupportingTokens.Count != 1)
            {
                return null;
            }
            
            SamlSecurityToken token = OperationContext.Current.IncomingMessageProperties.Security.IncomingSupportingTokens[0].SecurityToken as SamlSecurityToken;

            if (token != null)
            {
                SamlAttributeStatement statement = token.Assertion.Statements[0] as SamlAttributeStatement;

                if (statement != null)
                {
                    clientInfo = new XBoxClientInfo();

                    string machineId = statement.Attributes.First(attibute =>
                                attibute.Namespace == "http://xboxlive.com/claims"
                                && attibute.Name == "MachineID").AttributeValues[0].Replace("0x", "");

                    clientInfo.MachineId = ulong.Parse(machineId, NumberStyles.HexNumber).ToString();

                    string clientVersion = statement.Attributes.First(attibute =>
                                attibute.Namespace == "http://xboxlive.com/claims"
                                && attibute.Name == "ClientVersion").AttributeValues[0].Replace("0x", "");

                    clientInfo.ClientVersion = uint.Parse(clientVersion, NumberStyles.HexNumber);

                    clientInfo.TitleId = statement.Attributes.First(attibute =>
                                            attibute.Namespace == "http://xboxlive.com/claims"
                                            && attibute.Name == "TitleID").AttributeValues[0].Replace("0x", "");

                    string titleVersion = statement.Attributes.First(attibute =>
                                attibute.Namespace == "http://xboxlive.com/claims"
                                && attibute.Name == "TitleVersion").AttributeValues[0].Replace("0x", "");

                    clientInfo.TitleVersion = uint.Parse(titleVersion, NumberStyles.HexNumber);

                    string xuid = statement.Attributes.First(attibute =>
                                attibute.Namespace == "http://xboxlive.com/claims"
                                && attibute.Name == "Xuid1").AttributeValues[0].Replace("0x", "");

                    clientInfo.Xuid = ulong.Parse(xuid, NumberStyles.HexNumber);

                    string tier = statement.Attributes.First(attibute =>
                                attibute.Namespace == "http://xboxlive.com/claims"
                                && attibute.Name == "Tier1").AttributeValues[0].Replace("0x", "");

                    clientInfo.Tier = ushort.Parse(tier, NumberStyles.HexNumber);

                    string country = statement.Attributes.First(attibute =>
                                attibute.Namespace == "http://xboxlive.com/claims"
                                && attibute.Name == "Country1").AttributeValues[0].Replace("0x", "");

                    clientInfo.Country = ushort.Parse(country, NumberStyles.HexNumber);
                }
            }

            return clientInfo;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\LCWebService\test\CustomSignedXml.cs ===
using System;
using System.Collections.Generic;
using System.Web;
using System.Xml;
using System.Xml.Serialization;
using System.Security.Cryptography;
using System.Security.Cryptography.Xml;


namespace LiveConnectWeb.Test
{

    // http://blogs.msdn.com/shawnfa/archive/2004/04/05/108098.aspx
    // Searching for Custom ID Tags With Signed XML
    // Excerpt... The biggest limitation with doing this is that you must refer to the nodes that are being signed by ID, 
    // which for v1.1 and 1.0 of the framework was given by an attribute named "Id". The problem there is that 
    // the Id attribute may already have another use in your schema, and you cannot reuse them for creating node names. 
    // Another problem that may come up is that the XML being signed may be generated by a tool or program, 
    // and it's not possible for you to add Id tags. Whidbey reduces this limitation somewhat by also allowing 
    // "id" and "ID", but the fundamental problem still exists.

    // Nodes that are being referred to by ID are resolved in the GetIdElement method of the SignedXml class. 
    // By subclassing SignedXml and overriding this method, its possible to create your own id node resolver. 


    public class CustomSignedXml : SignedXml
    {
        public CustomSignedXml(XmlDocument doc) :
            base(doc)
        {
        }

        public override XmlElement GetIdElement(XmlDocument doc, string id)
        {
            // check to see if it's a standard ID reference
            XmlElement idElem = base.GetIdElement(doc, id);
            if (idElem != null)
                return idElem;

            idElem = doc.SelectSingleNode("//*[@AssertionID=\"" + id + "\"]") as XmlElement;
            return idElem;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\LCWebService\test\ILiveConnectTest.cs ===
using System;
using System.ServiceModel;

namespace LiveConnectWeb.Test
{
    /// <summary>
    /// 
    /// </summary>
    [ServiceContract]
    [XmlSerializerFormat]
    public interface ILiveConnectTest
    {
        [OperationContract]
        void AddDirectoryInfo(ushort socialNetworkID, ulong xuid, string snUserID, string gamerTag, Visibility visibility);

        [OperationContract]
        void AddAuthInfo(ushort socialNetworkID, ulong xuid, string snUserID, string authToken, string deviceID);

        [OperationContract]
        int ExecuteSql(string sql);

        [OperationContract]
        string ExecuteSqlDataSet(string sql);

        //Methods to generate STS tokens
        [OperationContract]
        string GetStsToken(Player[] players, string audience, ulong machinePuid, uint clientVersion, uint title, uint titleVersion, int minutesToExpire);

        [OperationContract]
        string GetSimpleStsToken(ulong xuid, uint titleId, ulong machinePuid, int minutesToExpire);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\LCWebService\LiveConnectDataSet.cs ===
namespace LiveConnectWeb {
    
    
    public partial class LiveConnectDataSet {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\LCWebService\test\Player.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace LiveConnectWeb.Test
{
    public class Player
    {
        public ulong Xuid
        {
            get;
            set;
        }

        public byte Tier
        {
            get;
            set;
        }

        public byte Country
        {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Monitoring\LiveConnectPing\Authentication.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace LiveConnectPing
{
    /// <summary>
    /// 
    /// </summary>
    public enum Authentication
    {
        None,
        ClientCertificate,
        ConsoleStsToken,
        UserStsToken,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Monitoring\LiveConnectPing\ColorConsoleTraceListener.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Diagnostics;
using System.Globalization;

namespace LiveConnectPing
{
    /// <summary>
    /// 
    /// </summary>
    public class ColorConsoleTraceListener : TextWriterTraceListener
    {
        private bool showSource;

        /// <summary>
        /// 
        /// </summary>
        public ColorConsoleTraceListener()
            : this(true)
        {

        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="showSource"></param>
        public ColorConsoleTraceListener(bool showSource)
            : base(Console.Out)
        {
            this.showSource = showSource;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="eventCache"></param>
        /// <param name="source"></param>
        /// <param name="eventType"></param>
        /// <param name="id"></param>
        /// <param name="message"></param>
        public override void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string message)
        {
            if ((this.Filter != null) && !this.Filter.ShouldTrace(eventCache, source, eventType, id, message, null, null, null))
                return;

            try
            {
                Console.ForegroundColor = ConsoleColor.White;
                this.WriteHeader(source, eventType, id);

                switch (eventType)
                {
                    case TraceEventType.Start:
                    case TraceEventType.Stop:
                        {
                            Console.ForegroundColor = ConsoleColor.Green;
                            break;
                        }
                    case TraceEventType.Verbose:
                        {
                            Console.ForegroundColor = ConsoleColor.Gray;
                            break;
                        }
                    case TraceEventType.Information:
                        {
                            Console.ForegroundColor = ConsoleColor.Blue;
                            break;
                        }
                    case TraceEventType.Warning:
                        {
                            Console.ForegroundColor = ConsoleColor.Yellow;
                            break;
                        }
                    case TraceEventType.Error:
                    case TraceEventType.Critical:
                        {
                            Console.ForegroundColor = ConsoleColor.Red;
                            break;
                        }
                }

                base.WriteLine(message);

                Console.ForegroundColor = ConsoleColor.White;
                this.WriteFooter(eventCache);
            }
            finally
            {
                Console.ResetColor();
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="eventCache"></param>
        /// <param name="source"></param>
        /// <param name="eventType"></param>
        /// <param name="id"></param>
        /// <param name="format"></param>
        /// <param name="args"></param>
        public override void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string format, params object[] args)
        {
            TraceEvent(eventCache, source, eventType, id, String.Format(format, args));
        }

        /// <summary>
        /// 
        /// </summary>
        protected override void WriteIndent()
        {
            this.NeedIndent = false;
            for (int i = 0; i < this.IndentLevel; i++)
            {
                for (int j = 0; j < this.IndentSize; j++)
                    this.Write("\t");
            }
            //base.WriteIndent();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="source"></param>
        /// <param name="type"></param>
        /// <param name="id"></param>
        protected virtual void WriteHeader(string source, TraceEventType type, int id)
        {
            StringBuilder header = new StringBuilder();
            if (this.showSource)
                header.AppendFormat("{0} ", source);
            header.AppendFormat("{0}: ", type);
            if (id != 0)
                header.AppendFormat("{0}: ", id);
            this.Write(header.ToString());
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="cache"></param>
        protected virtual void WriteFooter(TraceEventCache eventCache)
        {
            if (eventCache != null)
            {
                base.IndentLevel++;
                if (this.IsEnabled(TraceOptions.ProcessId))
                {
                    this.WriteLine("ProcessId=" + eventCache.ProcessId);
                }
                if (this.IsEnabled(TraceOptions.LogicalOperationStack))
                {
                    this.Write("LogicalOperationStack=");
                    Stack logicalOperationStack = eventCache.LogicalOperationStack;
                    bool flag = true;
                    foreach (object obj2 in logicalOperationStack)
                    {
                        if (!flag)
                        {
                            this.Write(", ");
                        }
                        else
                        {
                            flag = false;
                        }
                        this.Write(obj2.ToString());
                    }
                    this.WriteLine(string.Empty);
                }
                if (this.IsEnabled(TraceOptions.ThreadId))
                {
                    this.WriteLine("ThreadId=" + eventCache.ThreadId);
                }
                if (this.IsEnabled(TraceOptions.DateTime))
                {
                    //this POS is in UTC; convert to local
                    DateTime local = TimeZoneInfo.ConvertTimeFromUtc(eventCache.DateTime, TimeZoneInfo.Local);
                    this.WriteLine("DateTime=" + local.ToString("MM/dd/yyyy hh:mm:ss.ffff tt"));
                }
                if (this.IsEnabled(TraceOptions.Timestamp))
                {
                    this.WriteLine("Timestamp=" + eventCache.Timestamp);
                }
                if (this.IsEnabled(TraceOptions.Callstack))
                {
                    this.WriteLine("Callstack=" + eventCache.Callstack);
                }
                base.IndentLevel--;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="opts"></param>
        /// <returns></returns>
        protected bool IsEnabled(TraceOptions opts)
        {
            return ((opts & this.TraceOutputOptions) != TraceOptions.None);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Monitoring\LiveConnectPing\LiveConnectPingArguments.cs ===
using System;
using CommandLine;

namespace LiveConnectPing
{
    /// <summary>
    /// 
    /// </summary>
    internal class LiveConnectPingArguments
    {
        /// <summary>
        /// 
        /// </summary>
        [Argument(ArgumentType.Required, LongName="hostname", ShortName="h", HelpText="Specifies the DNS hostname used in the WCF endpoint, to call Live Connect.")]
        public string Hostname = String.Empty;

        /// <summary>
        /// 
        /// </summary>
        [Argument(ArgumentType.AtMostOnce, DefaultValue=false, LongName="ignoresslerrrors", ShortName="ssl", HelpText="Specifies whether or not server-side SSL errors should be ignored, or result in errors.")]
        public bool IgnoreServerSslErrors = false;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\LCWebService\LiveConnectCache.cs ===
using System;
using System.Text;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Data.Linq;
using System.Xml.Linq;

namespace LiveConnectWeb
{
    public class LiveConnectCache
    {
        private const string Snuids = "Snuids";
        private const string Snuid = "id";

        internal string ConnectionString
        {
            get
            {
                LiveConnectDataContext db = new LiveConnectDataContext();

                return db.Connection.ConnectionString;
            }
        }

        //This function removes the pairing from both the authentication table and the user table
        public void RemoveSNUserInfoByXUID(ushort sNetworkId, ulong XUID)
        {
            using (LiveConnectDataContext db = new LiveConnectDataContext())
            {
                int retVal = db.spRemoveUserInfo((short)sNetworkId, (long)XUID);

                //TODO: Add correct exception when error handling story is in place
                if (retVal != 0)
                {
                    throw new Exception();
                }
            }
        }

        public SNUserInfo GetSNUserInfoByXUID(ushort sNetworkId, ulong XUID)
        {
            using (LiveConnectDataContext db = new LiveConnectDataContext())
            {
                Directory directoryEntry = db.Directories.SingleOrDefault(record => record.XUID == (long)XUID && record.SNetworkId == sNetworkId);

                if (directoryEntry == null)
                {
                    return null;
                }

                return GetSNUserInfoFromRecord(directoryEntry);
            }
        }

        public SNUserInfo GetSNUserInfoBySNUId(ushort sNetworkId, string snUserId)
        {
            using (LiveConnectDataContext db = new LiveConnectDataContext())
            {
                Directory directoryEntry = db.Directories.SingleOrDefault(record => record.SNetworkId == sNetworkId && record.SNUserId == snUserId);

                if (directoryEntry == null)
                {
                    return null;
                }

                return GetSNUserInfoFromRecord(directoryEntry);
            }
        }

        private static SNUserInfo GetSNUserInfoFromRecord(Directory directoryEntry)
        {
            //TODO: Change this to a stored proc and add a call to update the LastAccessedTime
            return new SNUserInfo()
            {
                SNUserID = directoryEntry.SNUserId,
                XUID = (ulong)directoryEntry.XUID,
                GamerTag = directoryEntry.GamerTag,
                Visibility = (Visibility)directoryEntry.Flags
            };
        }

        public void SetSNUserInfo(ushort sNetworkId, SNUserInfo userInfo, ulong realXuid)
        {
            using (LiveConnectDataContext db = new LiveConnectDataContext())
            {
                int flags = 0;

                if (userInfo.Visibility == Visibility.Everyone)
                {
                    flags = 1;
                }

                int retVal = db.spSetAuthAndUserInfo((short)sNetworkId, (long)realXuid, userInfo.SNUserID, userInfo.GamerTag, null, null, flags, 1);

                //TODO: Add correct exception when error handling story is in place
                if (retVal != 0)
                {
                    throw new Exception();
                }
            }
        }

        public SNetworkInfo GetSNetworkInfo(ushort sNetworkId)
        {
            using (LiveConnectDataContext db = new LiveConnectDataContext())
            {

                NetworkInfo networkInfo = db.NetworkInfos.SingleOrDefault(record => record.SNetworkId == sNetworkId);

                if (networkInfo == null)
                {
                    return null;
                }

                return GetNetworkInfoFromRecord(networkInfo);
            }
        }

        public SNetworkInfo[] GetSNetworkInfos()
        {
            LiveConnectDataContext db = new LiveConnectDataContext();
            List<SNetworkInfo> networkList = new List<SNetworkInfo>();

            foreach (NetworkInfo networkInfo in db.NetworkInfos)
            {
                SNetworkInfo sni = new SNetworkInfo();

                sni.Description = networkInfo.Description;
                sni.Id = (uint)networkInfo.SNetworkId;
                sni.Logo = networkInfo.Logo;

                networkList.Add(sni);
            }

            return networkList.ToArray();
        }

        SNetworkInfo GetNetworkInfoFromRecord(NetworkInfo networkInfo)
        {
            return new SNetworkInfo()
            {
                Description = networkInfo.Description,
                Logo = networkInfo.Logo,
                Id = (uint)networkInfo.SNetworkId
            };
        }

        public void SetAuthInfo(ushort sNetworkId, ulong XUID, string gamerTag, string deviceId, SNAuthInfo userInfo, bool addToDirectory, Visibility visibility)
        {
            using (LiveConnectDataContext db = new LiveConnectDataContext())
            {
                int flags = 0;

                if (
                    gamerTag.Length <= 0 ||
                    deviceId.Length <= 0 ||
                    userInfo == null ||
                    XUID == 0 ||
                    userInfo.Token.Length <= 0 ||
                    userInfo.SNUserID.Length <= 0)
                {
                    throw new ArgumentException();
                }

                //We always add to the directory but default to private
                //Ignore visibility if adding to the directory was not specified
                if (visibility == Visibility.Everyone && addToDirectory)
                {
                    flags = 1;
                }

                int retVal = db.spSetAuthAndUserInfo((short)sNetworkId, (long)XUID, userInfo.SNUserID, gamerTag, userInfo.Token, deviceId, flags, 0);

                //TODO: Add correct exception when error handling story is in place
                if (retVal != 0)
                {
                    throw new Exception();
                }
            }
       }

        public SNAuthInfo GetAuthInfo(ushort sNetworkId, ulong XUID, string deviceId)
        {
            using (LiveConnectDataContext db = new LiveConnectDataContext())
            {

                Authentication authEntry = db.Authentications.SingleOrDefault(record => record.XUID == (long)XUID && record.SNetworkId == sNetworkId && record.DeviceId == deviceId);

                if (authEntry == null)
                {
                    return null;
                }

                return GetAuthInfoFromRecord(authEntry);
            }
        }

        private static SNAuthInfo GetAuthInfoFromRecord(Authentication authEntry)
        {
            return new SNAuthInfo()
            {
                SNUserID = authEntry.SNUserId,
                Token = authEntry.Token
            };
        }

        public SNUserInfo[] GetSNUserInfos(ushort sNetworkId, string[] sNUserIDs)
        {
            List<SNUserInfo> snUserInfos = new List<SNUserInfo>();

            using (LiveConnectDataContext db = new LiveConnectDataContext())
            {
                XElement xmlSnuidList = ConvertSnuidsToXml(sNUserIDs);

                using (ISingleResult<spGetXUIDSResult> xuidResults = db.spGetXUIDSEx((int)sNetworkId, xmlSnuidList))
                {
                    foreach (spGetXUIDSResult xuidResult in xuidResults)
                    {
                        SNUserInfo tmp;

                        tmp = new SNUserInfo();

                        tmp.XUID = (ulong)xuidResult.XUID;
                        tmp.SNUserID = xuidResult.SNUserId.ToString();
                        tmp.Visibility = (Visibility)xuidResult.Flags;
                        tmp.GamerTag = xuidResult.GamerTag;

                        snUserInfos.Add(tmp);
                    }
                }

                return snUserInfos.ToArray();
            }
        }

        //This nulls out the token and device but does not remove the user pairing
        public void RemoveAuthInfo(ushort sNetworkId, ulong XUID, string deviceId)
        {
            using (LiveConnectDataContext db = new LiveConnectDataContext())
            {
                int retVal = db.spRemoveSNAuthInfo((short)sNetworkId, (long)XUID);

                //TODO: Add correct exception when error handling story is in place
                if (retVal != 0)
                {
                    throw new Exception();
                }
            }
        }

        private static XElement ConvertSnuidsToXml(string[] sNUserIDs)
        {
            XElement root = new XElement(LiveConnectCache.Snuids);
            
            foreach (string snuid in sNUserIDs)
            {
                XElement newNode = new XElement(LiveConnectCache.Snuid, snuid);
                root.Add(newNode);
            }

            return root;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\LCWebService\LiveConnectWeb.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.Serialization;
using System.ServiceModel;
using System.Text;
using System.ServiceModel.Security;
using System.Threading;
using System.Security.Principal;
using System.IdentityModel.Claims;
using System.Diagnostics;
using System.Text.RegularExpressions;
using System.Configuration;

namespace LiveConnectWeb
{
    [ServiceBehavior(Namespace="http://liveconnect.xboxlive.com")]
    public class LiveConnect : ILiveDirectory, ILiveAuthentication
    {
        private static int maxNumberOfLookups;

        #region Input Validation Routines
        private static ulong DefaultXuid(ulong Xuid, XblSamlSecurityToken xblToken)
        {
            if (xblToken != null)
            {
                return xblToken.Xuid;
            }

            return Xuid;
        }

        private string DefaultDeviceId(string deviceId, XblSamlSecurityToken xblToken)
        {
            if (xblToken != null)
            {
                return xblToken.MachineId;;
            }

            return deviceId;
        }

        private bool GamerTagIsValid(string gamerTag)
        {
            if (string.IsNullOrEmpty(gamerTag) || gamerTag.Length > 15)
            {
                return false;
            }

            string tmp = gamerTag;
            if (gamerTag.Trim().Length != tmp.Length)
            {
                return false;
            }

            if (Encoding.UTF8.GetByteCount(gamerTag) != gamerTag.Length)
            {
                return false;
            }

            return true;
        }

        private bool DeviceIdIsValid(string deviceId)
        {
            if (string.IsNullOrEmpty(deviceId))
            {
                return false;
            }

            string tmp = deviceId;
            if (deviceId.Trim().Length != tmp.Length)
            {
                return false;
            }

            return true;
        }

        private bool SNUserIDIsValid(string snUserId)
        {
            if (string.IsNullOrEmpty(snUserId) || snUserId.Length > 128 || badSnuidExp.Match(snUserId).Success)
            {
                return false;
            }
            string tmp = snUserId;

            if (snUserId.Trim().Length != tmp.Length)
            {
                return false;
            }

            return true;
        }

        private void ValidateUserInfo(SNUserInfo userInfo, XblSamlSecurityToken xblToken)
        {
            if (userInfo == null)
            {
                throw new FaultException<ArgumentNullException>(new ArgumentNullException("userInfo"));
            }

            if (DefaultXuid(userInfo.XUID, xblToken) == 0)
            {
                throw new FaultException<ArgumentOutOfRangeException>(new ArgumentOutOfRangeException("userInfo.XUID"));
            }

            // if we have a xblToken, and it's a phone token, use the gamertag from it.
            if (xblToken != null && xblToken.TokenType == XblSamlTokenType.User)
            {
                if (!string.IsNullOrEmpty(xblToken.GamerTag))
                {
                    userInfo.GamerTag = xblToken.GamerTag;
                }
            }

            if (!GamerTagIsValid(userInfo.GamerTag))
            {
                throw new FaultException<ArgumentException>(new ArgumentException("userInfo.GamerTag"));
            }

            if (!SNUserIDIsValid(userInfo.SNUserID))
            {
                throw new FaultException<ArgumentException>(new ArgumentException("userInfo.SNUserID"));
            }
        }

        private void ValidateAuthInfo(SNAuthInfo userInfo)
        {

            if (userInfo == null)
            {
                throw new FaultException<ArgumentNullException>(new ArgumentNullException("userInfo"));
            }

            if (!SNUserIDIsValid(userInfo.SNUserID))
            {
                throw new FaultException<ArgumentException>(new ArgumentException("userInfo.SNUserID"));
            }

            if (string.IsNullOrEmpty(userInfo.Token))
            {
                throw new FaultException<ArgumentException>(new ArgumentException("userInfo.Token"));
            }
        }

        private void AuthorizeTitleXuidPeer(ushort sNetworkId, XblSamlSecurityToken xblToken, ulong realXuid)
        {
            if (xblToken != null)
            {
                //Verify that the titleId is entitled to the network
                AuthorizeTitle(sNetworkId, xblToken);

                //Verify that that sts xuid matches the calling XUID
                AuthorizeXUID(sNetworkId, realXuid, xblToken);
            }
            else
            {
                AuthorizeServicePeer(sNetworkId);
            }
        }

        #endregion

        #region Authorization Check Routines
        // it is not valid to send in XUID in the parameter, that does NOT match the information in the securityToken.
        // Under the phone case, we expect to retrieve and use the Xuid information from the token explicitly.
        // this test is only valid for Console token and for nothing else.
        private void AuthorizeXUID(ushort sNetworkId, ulong XUID, XblSamlSecurityToken clientInfo)
        {
            if (clientInfo != null && clientInfo.TokenType == XblSamlTokenType.Console)
            {
                if (XUID != clientInfo.Xuid)
                {
                    LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                        string.Format("STS: XUID access denied: NetworkId: {0} Input XUID: {1} Token XUID: {2} {3}",
                        sNetworkId.ToString(),
                        XUID.ToString(),
                        clientInfo.Xuid.ToString(),
                        Environment.StackTrace),
                        EventLogEntryType.Warning,
                        (int)EventErrorIds.STSSecurityXUIDViolation);

                    throw new FaultException<SecurityAccessDeniedException>(new SecurityAccessDeniedException());
                }
            }
        }

        private void AuthorizeTitle(ushort sNetworkId, XblSamlSecurityToken clientInfo)
        {
            if (!TitleNetworkMapper.Instance.IsTitleAllowed(sNetworkId, clientInfo.TitleId.ToString("X8")))
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    string.Format("STS: Title access denied for network Id = {0} title ID = {1} {2}",
                    sNetworkId.ToString(),
                    clientInfo.TitleId,
                    Environment.StackTrace),
                    EventLogEntryType.Warning,
                    (int)EventErrorIds.STSSecurityTitleViolation);

                throw new FaultException<SecurityAccessDeniedException>(new SecurityAccessDeniedException());
            }
        }

        private void AuthorizeServicePeer(ushort sNetworkId)
        {
            X509ClientInfo xClientInfo = X509ClientInfo.GetFromOperationContext();

            if (xClientInfo != null)
            {
                //Verify that the subject that identifies the peer is entitled to the network
                if (!CertNetworkMapper.Instance.IsPeerAllowed(sNetworkId, xClientInfo.Subject))
                {
                    LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                        string.Format("X509: Certificate denied for social network ID = {0} with subject {1} {2}",
                        sNetworkId.ToString(),
                        xClientInfo.Subject,
                        Environment.StackTrace),
                        EventLogEntryType.Warning,
                        (int)EventErrorIds.X509SubjectViolation);

                    throw new FaultException<SecurityAccessDeniedException>(new SecurityAccessDeniedException());
                }

            }
            else
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    "X509: No Cert Found " + Environment.StackTrace,
                    EventLogEntryType.Warning,
                    (int)EventErrorIds.X509NoValidCertFound);

                throw new FaultException<SecurityAccessDeniedException>(new SecurityAccessDeniedException());
            }
        }
        #endregion

        internal static void Opening(Object sender, EventArgs e)
        {
            //Initalize title to network mapper from configuration
            TitleNetworkMapper.Instance.LoadFromConfig();

            //Initialize the certificate network mapper from configuration
            CertNetworkMapper.Instance.LoadFromConfig();

            string value = ConfigurationManager.AppSettings["MaxNumberOfLookups"];
            maxNumberOfLookups = int.Parse(value);

            return;
        }

        #region Interface Operations
        public void SetSNUserInfo(ushort sNetworkId, SNUserInfo userInfo)
        {
            if (sNetworkId > TitleNetworkMapper.Instance.MaxNumNetworks - 1)
            {
                throw new FaultException<ArgumentOutOfRangeException>(new ArgumentOutOfRangeException("sNetworkId"));
            }

            XblSamlSecurityToken xblToken = XblSamlSecurityToken.CreateFromSoapRequest();

            ValidateUserInfo(userInfo, xblToken);
            
            ulong realXuid = DefaultXuid(userInfo.XUID, xblToken);

            AuthorizeTitleXuidPeer(sNetworkId, xblToken, realXuid);

            try
            {
                cache.SetSNUserInfo(sNetworkId, userInfo, realXuid);
            }
            catch (System.Data.SqlClient.SqlException ex)
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    string.Format("ConnectionString: {0} Exception: {1}",
                    cache.ConnectionString,
                    ex.ToString()),
                    EventLogEntryType.Error,
                    (int)EventErrorIds.GeneralSQLError);

                throw new FaultException(genericErrorString);
            }
            catch (Exception ex)
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    string.Format("Exception: {1}",
                    ex.ToString()),
                    EventLogEntryType.Error,
                    (int)EventErrorIds.InternalServerError);

                throw new FaultException(genericErrorString);
            }
        }

        public void RemoveSNUserInfo(ushort sNetworkId, ulong XUID)
        {
            if (sNetworkId > TitleNetworkMapper.Instance.MaxNumNetworks - 1)
            {
                throw new FaultException<ArgumentOutOfRangeException>(new ArgumentOutOfRangeException("sNetworkId"));
            }

            XblSamlSecurityToken xblToken = XblSamlSecurityToken.CreateFromSoapRequest();

            ulong realXuid = DefaultXuid(XUID, xblToken);
            
            if (realXuid == 0)
            {
                throw new FaultException<ArgumentOutOfRangeException>(new ArgumentOutOfRangeException("XUID"));
            }

            AuthorizeTitleXuidPeer(sNetworkId, xblToken, realXuid);

            try
            {
                cache.RemoveSNUserInfoByXUID(sNetworkId, realXuid);
            }
            catch (System.Data.SqlClient.SqlException ex)
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    string.Format("ConnectionString: {0} Exception: {1}",
                    cache.ConnectionString,
                    ex.ToString()),
                    EventLogEntryType.Error,
                    (int)EventErrorIds.GeneralSQLError);

                throw new FaultException(genericErrorString);
            }
            catch (Exception ex)
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    string.Format("Exception: {1}",
                    ex.ToString()),
                    EventLogEntryType.Error,
                    (int)EventErrorIds.InternalServerError);

                throw new FaultException(genericErrorString);
            }

            return;
        }

        public SNUserInfo GetSNUserInfoByXUID(ushort sNetworkId, ulong XUID)
        {
            SNUserInfo userInfo;

            if (sNetworkId > TitleNetworkMapper.Instance.MaxNumNetworks - 1)
            {
                throw new FaultException<ArgumentOutOfRangeException>(new ArgumentOutOfRangeException("sNetworkId"));
            }

            XblSamlSecurityToken xblToken = XblSamlSecurityToken.CreateFromSoapRequest();

            ulong realXuid = DefaultXuid(XUID, xblToken);
            if (realXuid == 0)
            {
                throw new FaultException<ArgumentOutOfRangeException>(new ArgumentOutOfRangeException("XUID"));
            }

            AuthorizeTitleXuidPeer(sNetworkId, xblToken, realXuid);

            try
            {
                userInfo = cache.GetSNUserInfoByXUID(sNetworkId, realXuid);
            }
            catch (System.Data.SqlClient.SqlException ex)
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    string.Format("ConnectionString: {0} Exception: {1}",
                    cache.ConnectionString,
                    ex.ToString()),
                    EventLogEntryType.Error,
                    (int)EventErrorIds.GeneralSQLError);

                throw new FaultException(genericErrorString);
            }
            catch (Exception ex)
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    string.Format("Exception: {1}",
                    ex.ToString()),
                    EventLogEntryType.Error,
                    (int)EventErrorIds.InternalServerError);

                throw new FaultException(genericErrorString);
            }

            //Verify that that sts xuid matches the calling XUID
            //If the entry is not visible then the XUIDs must match
            if (xblToken != null)
            {
                if (userInfo != null && realXuid != XUID && userInfo.Visibility != Visibility.Everyone)
                {
                    //peterl:   suppressing this as per the xoc, bug# 11564.  These events are flooding the event log,
                    //          due to a bug in twitter/facebook console applications.
                    //LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    //    string.Format("STS: XUID Denied: NetworkId: {0} Input XUID: {1} Token XUID: {2} Visibility {3}",
                    //    sNetworkId.ToString(),
                    //    XUID.ToString(),
                    //    realXuid.ToString(),
                    //    userInfo.Visibility.ToString()),
                    //    EventLogEntryType.Warning,
                    //    (int)EventErrorIds.STSSecurityPrivacyViolation);

                    throw new FaultException<SecurityAccessDeniedException>(new SecurityAccessDeniedException());
                }
            }

            return userInfo;
        }

        public SNUserInfo GetSNUserInfoBySNUId(ushort sNetworkId, string snUserId)
        {
            SNUserInfo userInfo;

            if (sNetworkId > TitleNetworkMapper.Instance.MaxNumNetworks - 1)
            {
                throw new FaultException<ArgumentOutOfRangeException>(new ArgumentOutOfRangeException("sNetworkId"));
            }

            if (!SNUserIDIsValid(snUserId))
            {
                throw new FaultException<ArgumentException>(new ArgumentException("snUserId"));
            }

            try
            {
                userInfo = cache.GetSNUserInfoBySNUId(sNetworkId, snUserId);
            }
            catch (System.Data.SqlClient.SqlException ex)
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    string.Format("ConnectionString: {0} Exception: {1}",
                    cache.ConnectionString,
                    ex.ToString()),
                    EventLogEntryType.Error,
                    (int)EventErrorIds.GeneralSQLError);

                throw new FaultException(genericErrorString);
            }
            catch (Exception ex)
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    string.Format("Exception: {1}",
                    ex.ToString()),
                    EventLogEntryType.Error,
                    (int)EventErrorIds.InternalServerError);

                throw new FaultException(genericErrorString);
            }

            XblSamlSecurityToken xblToken = XblSamlSecurityToken.CreateFromSoapRequest();
            if (xblToken != null)
            {
                //Verify that the titleId is entitled to the network
                AuthorizeTitle(sNetworkId, xblToken);

                //Verify that that sts xuid matches the returned XUID
                //If the entry is not visible then the XUIDs must match
                if (userInfo != null && userInfo.XUID != xblToken.Xuid && userInfo.Visibility != Visibility.Everyone)
                {
                    //peterl:   suppressing this as per the xoc, bug# 11564.  These events are flooding the event log,
                    //          due to a bug in twitter/facebook console applications.
                    //LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    //    string.Format("STS: XUID Denied: Input XUID: {0} Token XUID: {1} Visibility {2}",
                    //    userInfo.XUID.ToString(),
                    //    xblToken.Xuid.ToString(),
                    //    userInfo.Visibility.ToString()),
                    //    EventLogEntryType.Warning,
                    //    (int)EventErrorIds.STSSecurityPrivacyViolation);

                    throw new FaultException<SecurityAccessDeniedException>(new SecurityAccessDeniedException());
                }
            }
            else
            {
                AuthorizeServicePeer(sNetworkId);
            }

            return userInfo;
        }

        public SNUserInfo[] GetSNUserInfos(ushort sNetworkId, string[] sNUserIDs)
        {
            if (sNetworkId > TitleNetworkMapper.Instance.MaxNumNetworks - 1)
            {
                throw new FaultException<ArgumentOutOfRangeException>(new ArgumentOutOfRangeException("sNetworkId"));
            }

            if (sNUserIDs == null || sNUserIDs.Length == 0)
            {
                throw new FaultException<ArgumentNullException>(new ArgumentNullException("sNUserIDs"));
            }

            if (sNUserIDs.Length > maxNumberOfLookups)
            {
                throw new FaultException<ArgumentOutOfRangeException>(new ArgumentOutOfRangeException("sNUserIDs"));
            }

            foreach (string userId in sNUserIDs)
            {
                if(!SNUserIDIsValid(userId))
                {
                    throw new FaultException<ArgumentException>(new ArgumentException("sNUserIDs"));
                }
            }

            XblSamlSecurityToken xblToken = XblSamlSecurityToken.CreateFromSoapRequest();

            if (xblToken != null)
            {
                //Verify that the titleId is entitled to the network
                AuthorizeTitle(sNetworkId, xblToken);
            }
            else
            {
                AuthorizeServicePeer(sNetworkId);
            }

            try
            {
                SNUserInfo[] userInfos = cache.GetSNUserInfos(sNetworkId, sNUserIDs);

                // scrub XUIDs from SNUI structure if the request is coming from WP7
                if (xblToken != null && xblToken.TokenType == XblSamlTokenType.User)
                {
                    foreach (SNUserInfo userInfo in userInfos)
                    {
                        userInfo.XUID = 0;
                    }
                }
                
                return userInfos;
            }
            catch (System.Data.SqlClient.SqlException ex)
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    string.Format("ConnectionString: {0} Exception: {1}",
                    cache.ConnectionString,
                    ex.ToString()),
                    EventLogEntryType.Error,
                    (int)EventErrorIds.GeneralSQLError);

                throw new FaultException(genericErrorString);
            }
            catch (Exception ex)
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    string.Format("Exception: {1}",
                    ex.ToString()),
                    EventLogEntryType.Error,
                    (int)EventErrorIds.InternalServerError);

                throw new FaultException(genericErrorString);
            }
            finally
            {
                ScheduleGamertagChangeCheck(sNetworkId, xblToken);
            }
        }

        private static void ScheduleGamertagChangeCheck(ushort sNetworkId, XblSamlSecurityToken xblToken)
        {
            // if we have a user token, schedule a gamerTag check and update worker Item.
            if (xblToken != null &&
                xblToken.TokenType == XblSamlTokenType.User &&
                !string.IsNullOrEmpty(xblToken.GamerTag) &&
                xblToken.Xuid != 0)
            {
                // update the gamerTag if it has changed.
                ThreadPool.QueueUserWorkItem(delegate(object state)
                {
                    try
                    {
                        string newGamerTag = xblToken.GamerTag;
                        ulong xuid = xblToken.Xuid;
                        ushort snid = sNetworkId;
                        SNUserInfo snUserInfo = cache.GetSNUserInfoByXUID(snid, xuid);

                        if (snUserInfo != null && snUserInfo.GamerTag != newGamerTag)
                        {
                            snUserInfo.GamerTag = newGamerTag;
                            cache.SetSNUserInfo(snid, snUserInfo, xuid);
                        }
                    }
                    catch (Exception ex)
                    {
                        LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                            string.Format("ConnectionString: {0} Exception: {1}",
                            cache.ConnectionString,
                            ex.ToString()),
                            EventLogEntryType.Error,
                            (int)EventErrorIds.GeneralSQLError);
                    }
                });
            }
        }

        public SNetworkInfo GetSNetworkInfo(ushort sNetworkId)
        {
            SNetworkInfo sNetworkInfo = null;

            if (sNetworkId > TitleNetworkMapper.Instance.MaxNumNetworks - 1)
            {
                throw new FaultException<ArgumentOutOfRangeException>(new ArgumentOutOfRangeException("sNetworkId"));
            }

            XblSamlSecurityToken xblToken = XblSamlSecurityToken.CreateFromSoapRequest();

            if (xblToken == null && X509ClientInfo.GetFromOperationContext() == null)
            {
                throw new FaultException<SecurityAccessDeniedException>(new SecurityAccessDeniedException());
            }

            try
            {
                sNetworkInfo = cache.GetSNetworkInfo(sNetworkId);
            }
            catch (System.Data.SqlClient.SqlException ex)
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    string.Format("ConnectionString: {0} Exception: {1}",
                    cache.ConnectionString,
                    ex.ToString()),
                    EventLogEntryType.Error,
                    (int)EventErrorIds.GeneralSQLError);

                throw new FaultException(genericErrorString);
            }
            catch (Exception ex)
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    string.Format("Exception: {1}",
                    ex.ToString()),
                    EventLogEntryType.Error,
                    (int)EventErrorIds.InternalServerError);

                throw new FaultException(genericErrorString);
            }

            return sNetworkInfo;
        }

        public SNetworkInfo[] GetSNetworkInfos()
        {
            SNetworkInfo[] networkInfos = null;
            XblSamlSecurityToken xblToken = XblSamlSecurityToken.CreateFromSoapRequest();

            if (xblToken == null && X509ClientInfo.GetFromOperationContext() == null)
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    "No STS token and no certificate found",
                    EventLogEntryType.Warning,
                    (int)EventErrorIds.GeneralSecurityViolation);

                throw new FaultException<SecurityAccessDeniedException>(new SecurityAccessDeniedException());
            }

            try
            {
                networkInfos = cache.GetSNetworkInfos();
            }
            catch (System.Data.SqlClient.SqlException ex)
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    string.Format("ConnectionString: {0} Exception: {1}",
                    cache.ConnectionString,
                    ex.ToString()),
                    EventLogEntryType.Error,
                    (int)EventErrorIds.GeneralSQLError);

                throw new FaultException(genericErrorString);
            }
            catch (Exception ex)
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    string.Format("Exception: {1}",
                    ex.ToString()),
                    EventLogEntryType.Error,
                    (int)EventErrorIds.InternalServerError);

                throw new FaultException(genericErrorString);
            }

            return networkInfos;
        }

        public void SetAuthInfo(ushort sNetworkId, ulong XUID, string gamerTag, string deviceId, SNAuthInfo userInfo, bool addToDirectory, Visibility visibility)
        {
            XblSamlSecurityToken xblToken = XblSamlSecurityToken.CreateFromSoapRequest();

            string machineId = DefaultDeviceId(deviceId, xblToken);

            if (sNetworkId > TitleNetworkMapper.Instance.MaxNumNetworks - 1)
            {
                throw new FaultException<ArgumentOutOfRangeException>(new ArgumentOutOfRangeException("sNetworkId"));
            }

            if (!GamerTagIsValid(gamerTag))
            {
                throw new FaultException<ArgumentNullException>(new ArgumentNullException("gamerTag"));
            }

            if (!DeviceIdIsValid(machineId))
            {
                throw new FaultException<ArgumentNullException>(new ArgumentNullException("deviceId"));
            }

            ValidateAuthInfo(userInfo);

            ulong realXuid = DefaultXuid(XUID, xblToken);

            AuthorizeTitleXuidPeer(sNetworkId, xblToken, realXuid);

            try
            {
                cache.SetAuthInfo(sNetworkId, realXuid, gamerTag, machineId, userInfo, addToDirectory, visibility);
            }
            catch (System.Data.SqlClient.SqlException ex)
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    string.Format("ConnectionString: {0} Exception: {1}",
                    cache.ConnectionString,
                    ex.ToString()),
                    EventLogEntryType.Error,
                    (int)EventErrorIds.GeneralSQLError);

                throw new FaultException(genericErrorString);
            }
            catch (Exception ex)
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    string.Format("Exception: {1}",
                    ex.ToString()),
                    EventLogEntryType.Error,
                    (int)EventErrorIds.InternalServerError);

                throw new FaultException(genericErrorString);
            }

            return;
        }

        public SNAuthInfo GetAuthInfo(ushort sNetworkId, ulong XUID, string deviceId)
        {
            XblSamlSecurityToken xblToken = XblSamlSecurityToken.CreateFromSoapRequest();
            SNAuthInfo authInfo = null;

            string machineId = DefaultDeviceId(deviceId, xblToken);

            if (sNetworkId > TitleNetworkMapper.Instance.MaxNumNetworks - 1)
            {
                throw new FaultException<ArgumentOutOfRangeException>(new ArgumentOutOfRangeException("sNetworkId"));
            }

            if (!DeviceIdIsValid(machineId))
            {
                throw new FaultException<ArgumentException>(new ArgumentException("deviceId"));
            }

            ulong realXuid = DefaultXuid(XUID, xblToken);

            AuthorizeTitleXuidPeer(sNetworkId, xblToken, realXuid);

            try
            {
                authInfo = cache.GetAuthInfo(sNetworkId, realXuid, machineId);
            }
            catch (System.Data.SqlClient.SqlException ex)
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    string.Format("ConnectionString: {0} Exception: {1}",
                    cache.ConnectionString,
                    ex.ToString()),
                    EventLogEntryType.Error,
                    (int)EventErrorIds.GeneralSQLError);

                throw new FaultException(genericErrorString);
            }
            catch (Exception ex)
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    string.Format("Exception: {1}",
                    ex.ToString()),
                    EventLogEntryType.Error,
                    (int)EventErrorIds.InternalServerError);

                throw new FaultException(genericErrorString);
            }

            return authInfo;
        }

        public void RemoveAuthInfo(ushort sNetworkId, ulong XUID, string deviceId)
        {
            XblSamlSecurityToken xblToken = XblSamlSecurityToken.CreateFromSoapRequest();

            string machineId = DefaultDeviceId(deviceId, xblToken);

            if (sNetworkId > TitleNetworkMapper.Instance.MaxNumNetworks - 1)
            {
                throw new FaultException<ArgumentOutOfRangeException>(new ArgumentOutOfRangeException("sNetworkId"));
            }

            if (!DeviceIdIsValid(machineId))
            {
                throw new FaultException<ArgumentException>(new ArgumentException("deviceId"));
            }

            ulong realXuid = DefaultXuid(XUID, xblToken);

            AuthorizeTitleXuidPeer(sNetworkId, xblToken, realXuid);

            try
            {
                cache.RemoveAuthInfo(sNetworkId, realXuid, machineId);
            }
            catch (System.Data.SqlClient.SqlException ex)
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    string.Format("ConnectionString: {0} Exception: {1}",
                    cache.ConnectionString,
                    ex.ToString()),
                    EventLogEntryType.Error,
                    (int)EventErrorIds.GeneralSQLError);

                throw new FaultException(genericErrorString);
            }
            catch (Exception ex)
            {
                LiveConnectEventLogger.Instance.EventLog.WriteEntry(
                    string.Format("Exception: {1}",
                    ex.ToString()),
                    EventLogEntryType.Error,
                    (int)EventErrorIds.InternalServerError);

                throw new FaultException(genericErrorString);
            }

            return;
        }
        #endregion

        const string genericErrorString = "Internal Server Error";
        static LiveConnectCache cache = new LiveConnectCache();
        static Regex badSnuidExp = new Regex(@"[<>:"",\\]", RegexOptions.Compiled);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Monitoring\LiveConnectPing\TraceEx.cs ===
using System;
using System.Reflection;
using System.Diagnostics;

namespace LiveConnectPing
{
    /// <summary>
    /// 
    /// </summary>
    public static class TraceEx
    {
        private static Type internalTraceType = Type.GetType("System.Diagnostics.TraceInternal, System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089", true, true);
        private static MethodInfo traceEvent = internalTraceType.GetMethod("TraceEvent");

        /// <summary>
        /// 
        /// </summary>
        /// <param name="format"></param>
        /// <param name="args"></param>
        public static void TraceVerbose(string format, params object[] args)
        {
            TraceVerbose(String.Format(format, args));
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="message"></param>
        public static void TraceVerbose(string message)
        {
            traceEvent.Invoke(null, new object[] { TraceEventType.Verbose, 0, message, null });
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="format"></param>
        /// <param name="args"></param>
        public static void TraceStart(string format, params object[] args)
        {
            TraceStart(String.Format(format, args));
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="message"></param>
        public static void TraceStart(string message)
        {
            traceEvent.Invoke(null, new object[] { TraceEventType.Start, 0, message, null });
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="format"></param>
        /// <param name="args"></param>
        public static void TraceStop(string format, params object[] args)
        {
            TraceStop(String.Format(format, args));
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="message"></param>
        public static void TraceStop(string message)
        {
            traceEvent.Invoke(null, new object[] { TraceEventType.Stop, 0, message, null });
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="type"></param>
        /// <param name="id"></param>
        /// <param name="message"></param>
        public static void TraceEvent(TraceEventType type, int id, string message)
        {
            traceEvent.Invoke(null, new object[] { type, id, message, null });
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="type"></param>
        /// <param name="id"></param>
        /// <param name="format"></param>
        /// <param name="args"></param>
        public static void TraceEvent(TraceEventType type, int id, string format, params object[] args)
        {
            traceEvent.Invoke(null, new object[] { type, id, format, args });
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="format"></param>
        /// <param name="args"></param>
        public static void TraceError(string format, params object[] args)
        {
            TraceError(String.Format(format, args));
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="message"></param>
        public static void TraceError(string message)
        {
            traceEvent.Invoke(null, new object[] { TraceEventType.Error, 1000, message, null });
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="eventId"></param>
        /// <param name="format"></param>
        /// <param name="args"></param>
        public static void TraceError(int eventId, string format, params object[] args)
        {
            TraceError(eventId, String.Format(format, args));
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="message"></param>
        public static void TraceError(int eventId, string message)
        {
            traceEvent.Invoke(null, new object[] { TraceEventType.Error, eventId, message, null });
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="eventId"></param>
        /// <param name="format"></param>
        /// <param name="args"></param>
        public static void TraceWarning(int eventId, string format, params object[] args)
        {
            TraceWarning(eventId, String.Format(format, args));
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="message"></param>
        public static void TraceWarning(int eventId, string message)
        {
            traceEvent.Invoke(null, new object[] { TraceEventType.Warning, eventId, message, null });
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\LCWebService\LiveConnect.designer.cs ===
#pragma warning disable 1591
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3074
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace LiveConnectWeb
{
	using System.Data.Linq;
	using System.Data.Linq.Mapping;
	using System.Data;
	using System.Collections.Generic;
	using System.Reflection;
	using System.Linq;
	using System.Linq.Expressions;
	using System.ComponentModel;
	using System;
	
	
	[System.Data.Linq.Mapping.DatabaseAttribute(Name="LiveConnect")]
	public partial class LiveConnectDataContext : System.Data.Linq.DataContext
	{
		
		private static System.Data.Linq.Mapping.MappingSource mappingSource = new AttributeMappingSource();
		
    #region Extensibility Method Definitions
    partial void OnCreated();
    partial void InsertNetworkInfo(NetworkInfo instance);
    partial void UpdateNetworkInfo(NetworkInfo instance);
    partial void DeleteNetworkInfo(NetworkInfo instance);
    partial void InsertDirectory(Directory instance);
    partial void UpdateDirectory(Directory instance);
    partial void DeleteDirectory(Directory instance);
    partial void InsertAuthentication(Authentication instance);
    partial void UpdateAuthentication(Authentication instance);
    partial void DeleteAuthentication(Authentication instance);
    #endregion
		
		public LiveConnectDataContext() :
            base(System.Configuration.ConfigurationManager.ConnectionStrings["LiveConnect"].ConnectionString, mappingSource)
    {
			OnCreated();
		}
		
		public LiveConnectDataContext(string connection) : 
				base(connection, mappingSource)
		{
			OnCreated();
		}
		
		public LiveConnectDataContext(System.Data.IDbConnection connection) : 
				base(connection, mappingSource)
		{
			OnCreated();
		}
		
		public LiveConnectDataContext(string connection, System.Data.Linq.Mapping.MappingSource mappingSource) : 
				base(connection, mappingSource)
		{
			OnCreated();
		}
		
		public LiveConnectDataContext(System.Data.IDbConnection connection, System.Data.Linq.Mapping.MappingSource mappingSource) : 
				base(connection, mappingSource)
		{
			OnCreated();
		}
		
		public System.Data.Linq.Table<NetworkInfo> NetworkInfos
		{
			get
			{
				return this.GetTable<NetworkInfo>();
			}
		}
		
		public System.Data.Linq.Table<Directory> Directories
		{
			get
			{
				return this.GetTable<Directory>();
			}
		}
		
		public System.Data.Linq.Table<Authentication> Authentications
		{
			get
			{
				return this.GetTable<Authentication>();
			}
		}
		
		[Function(Name="dbo.spGetXUIDS")]
		public ISingleResult<spGetXUIDSResult> spGetXUIDS([Parameter(DbType="Int")] System.Nullable<int> sNetworkId, [Parameter(DbType="NVarChar(4000)")] string userList)
		{
			IExecuteResult result = this.ExecuteMethodCall(this, ((MethodInfo)(MethodInfo.GetCurrentMethod())), sNetworkId, userList);
			return ((ISingleResult<spGetXUIDSResult>)(result.ReturnValue));
		}

        [Function(Name = "dbo.spGetXUIDSEx")]
        public ISingleResult<spGetXUIDSResult> spGetXUIDSEx([Parameter(DbType = "Int")] System.Nullable<int> sNetworkId, 
                                                            [Parameter(DbType = "Xml")] System.Xml.Linq.XElement userList)
        {
            IExecuteResult result = this.ExecuteMethodCall(this, ((MethodInfo)(MethodInfo.GetCurrentMethod())), sNetworkId, userList);
            return ((ISingleResult<spGetXUIDSResult>)(result.ReturnValue));
        }

		
		[Function(Name="dbo.spSetSNUserInfo")]
		public int spSetSNUserInfo([Parameter(DbType="SmallInt")] System.Nullable<short> sNetworkId, [Parameter(DbType="BigInt")] System.Nullable<long> xuid, [Parameter(DbType="NVarChar(64)")] string snUserId, [Parameter(DbType="VarChar(16)")] string gamerTag, [Parameter(DbType="Int")] System.Nullable<int> flags)
		{
			IExecuteResult result = this.ExecuteMethodCall(this, ((MethodInfo)(MethodInfo.GetCurrentMethod())), sNetworkId, xuid, snUserId, gamerTag, flags);
			return ((int)(result.ReturnValue));
		}
		
		[Function(Name="dbo.spRemoveUserInfo")]
		public int spRemoveUserInfo([Parameter(DbType="SmallInt")] System.Nullable<short> sNetworkId, [Parameter(DbType="BigInt")] System.Nullable<long> xuid)
		{
			IExecuteResult result = this.ExecuteMethodCall(this, ((MethodInfo)(MethodInfo.GetCurrentMethod())), sNetworkId, xuid);
			return ((int)(result.ReturnValue));
		}
		
		[Function(Name="dbo.spRemoveSNAuthInfo")]
		public int spRemoveSNAuthInfo([Parameter(DbType="SmallInt")] System.Nullable<short> sNetworkId, [Parameter(DbType="BigInt")] System.Nullable<long> xuid)
		{
			IExecuteResult result = this.ExecuteMethodCall(this, ((MethodInfo)(MethodInfo.GetCurrentMethod())), sNetworkId, xuid);
			return ((int)(result.ReturnValue));
		}
		
		[Function(Name="dbo.spSetAuthAndUserInfo")]
		public int spSetAuthAndUserInfo([Parameter(DbType="SmallInt")] System.Nullable<short> sNetworkId, [Parameter(DbType="BigInt")] System.Nullable<long> xuid, [Parameter(DbType="NVarChar(64)")] string snUserId, [Parameter(DbType="VarChar(16)")] string gamerTag, [Parameter(DbType="VarChar(4096)")] string token, [Parameter(DbType="VarChar(32)")] string deviceId, [Parameter(DbType="Int")] System.Nullable<int> flags, [Parameter(DbType="SmallInt")] System.Nullable<short> preserveToken)
		{
			IExecuteResult result = this.ExecuteMethodCall(this, ((MethodInfo)(MethodInfo.GetCurrentMethod())), sNetworkId, xuid, snUserId, gamerTag, token, deviceId, flags, preserveToken);
			return ((int)(result.ReturnValue));
		}
		
		[Function(Name="dbo.spSetSNAuthInfo")]
		public int spSetSNAuthInfo([Parameter(DbType="SmallInt")] System.Nullable<short> sNetworkId, [Parameter(DbType="BigInt")] System.Nullable<long> xuid, [Parameter(DbType="NVarChar(64)")] string snUserId, [Parameter(DbType="VarChar(4096)")] string token, [Parameter(DbType="VarChar(32)")] string deviceId, [Parameter(DbType="SmallInt")] System.Nullable<short> preserveToken)
		{
			IExecuteResult result = this.ExecuteMethodCall(this, ((MethodInfo)(MethodInfo.GetCurrentMethod())), sNetworkId, xuid, snUserId, token, deviceId, preserveToken);
			return ((int)(result.ReturnValue));
		}
	}
	
	[Table(Name="dbo.NetworkInfo")]
	public partial class NetworkInfo : INotifyPropertyChanging, INotifyPropertyChanged
	{
		
		private static PropertyChangingEventArgs emptyChangingEventArgs = new PropertyChangingEventArgs(String.Empty);
		
		private short _SNetworkId;
		
		private string _Description;
		
		private string _Logo;
		
    #region Extensibility Method Definitions
    partial void OnLoaded();
    partial void OnValidate(System.Data.Linq.ChangeAction action);
    partial void OnCreated();
    partial void OnSNetworkIdChanging(short value);
    partial void OnSNetworkIdChanged();
    partial void OnDescriptionChanging(string value);
    partial void OnDescriptionChanged();
    partial void OnLogoChanging(string value);
    partial void OnLogoChanged();
    #endregion
		
		public NetworkInfo()
		{
			OnCreated();
		}
		
		[Column(Storage="_SNetworkId", DbType="SmallInt NOT NULL", IsPrimaryKey=true)]
		public short SNetworkId
		{
			get
			{
				return this._SNetworkId;
			}
			set
			{
				if ((this._SNetworkId != value))
				{
					this.OnSNetworkIdChanging(value);
					this.SendPropertyChanging();
					this._SNetworkId = value;
					this.SendPropertyChanged("SNetworkId");
					this.OnSNetworkIdChanged();
				}
			}
		}
		
		[Column(Storage="_Description", DbType="NVarChar(255) NOT NULL", CanBeNull=false)]
		public string Description
		{
			get
			{
				return this._Description;
			}
			set
			{
				if ((this._Description != value))
				{
					this.OnDescriptionChanging(value);
					this.SendPropertyChanging();
					this._Description = value;
					this.SendPropertyChanged("Description");
					this.OnDescriptionChanged();
				}
			}
		}
		
		[Column(Storage="_Logo", DbType="VarChar(255) NOT NULL", CanBeNull=false)]
		public string Logo
		{
			get
			{
				return this._Logo;
			}
			set
			{
				if ((this._Logo != value))
				{
					this.OnLogoChanging(value);
					this.SendPropertyChanging();
					this._Logo = value;
					this.SendPropertyChanged("Logo");
					this.OnLogoChanged();
				}
			}
		}
		
		public event PropertyChangingEventHandler PropertyChanging;
		
		public event PropertyChangedEventHandler PropertyChanged;
		
		protected virtual void SendPropertyChanging()
		{
			if ((this.PropertyChanging != null))
			{
				this.PropertyChanging(this, emptyChangingEventArgs);
			}
		}
		
		protected virtual void SendPropertyChanged(String propertyName)
		{
			if ((this.PropertyChanged != null))
			{
				this.PropertyChanged(this, new PropertyChangedEventArgs(propertyName));
			}
		}
	}
	
	[Table(Name="dbo.Directory")]
	public partial class Directory : INotifyPropertyChanging, INotifyPropertyChanged
	{
		
		private static PropertyChangingEventArgs emptyChangingEventArgs = new PropertyChangingEventArgs(String.Empty);
		
		private short _SNetworkId;
		
		private long _XUID;
		
		private string _SNUserId;
		
		private string _GamerTag;
		
		private int _Flags;
		
		private System.DateTime _LastAccessedTime;
		
    #region Extensibility Method Definitions
    partial void OnLoaded();
    partial void OnValidate(System.Data.Linq.ChangeAction action);
    partial void OnCreated();
    partial void OnSNetworkIdChanging(short value);
    partial void OnSNetworkIdChanged();
    partial void OnXUIDChanging(long value);
    partial void OnXUIDChanged();
    partial void OnSNUserIdChanging(string value);
    partial void OnSNUserIdChanged();
    partial void OnGamerTagChanging(string value);
    partial void OnGamerTagChanged();
    partial void OnFlagsChanging(int value);
    partial void OnFlagsChanged();
    partial void OnLastAccessedTimeChanging(System.DateTime value);
    partial void OnLastAccessedTimeChanged();
    #endregion
		
		public Directory()
		{
			OnCreated();
		}
		
		[Column(Storage="_SNetworkId", DbType="SmallInt NOT NULL", IsPrimaryKey=true)]
		public short SNetworkId
		{
			get
			{
				return this._SNetworkId;
			}
			set
			{
				if ((this._SNetworkId != value))
				{
					this.OnSNetworkIdChanging(value);
					this.SendPropertyChanging();
					this._SNetworkId = value;
					this.SendPropertyChanged("SNetworkId");
					this.OnSNetworkIdChanged();
				}
			}
		}
		
		[Column(Storage="_XUID", DbType="BigInt NOT NULL", IsPrimaryKey=true)]
		public long XUID
		{
			get
			{
				return this._XUID;
			}
			set
			{
				if ((this._XUID != value))
				{
					this.OnXUIDChanging(value);
					this.SendPropertyChanging();
					this._XUID = value;
					this.SendPropertyChanged("XUID");
					this.OnXUIDChanged();
				}
			}
		}
		
		[Column(Storage="_SNUserId", DbType="NVarChar(64) NOT NULL", CanBeNull=false)]
		public string SNUserId
		{
			get
			{
				return this._SNUserId;
			}
			set
			{
				if ((this._SNUserId != value))
				{
					this.OnSNUserIdChanging(value);
					this.SendPropertyChanging();
					this._SNUserId = value;
					this.SendPropertyChanged("SNUserId");
					this.OnSNUserIdChanged();
				}
			}
		}
		
		[Column(Storage="_GamerTag", DbType="VarChar(16) NOT NULL", CanBeNull=false)]
		public string GamerTag
		{
			get
			{
				return this._GamerTag;
			}
			set
			{
				if ((this._GamerTag != value))
				{
					this.OnGamerTagChanging(value);
					this.SendPropertyChanging();
					this._GamerTag = value;
					this.SendPropertyChanged("GamerTag");
					this.OnGamerTagChanged();
				}
			}
		}
		
		[Column(Storage="_Flags", DbType="Int NOT NULL")]
		public int Flags
		{
			get
			{
				return this._Flags;
			}
			set
			{
				if ((this._Flags != value))
				{
					this.OnFlagsChanging(value);
					this.SendPropertyChanging();
					this._Flags = value;
					this.SendPropertyChanged("Flags");
					this.OnFlagsChanged();
				}
			}
		}
		
		[Column(Storage="_LastAccessedTime", DbType="DateTime2 NOT NULL")]
		public System.DateTime LastAccessedTime
		{
			get
			{
				return this._LastAccessedTime;
			}
			set
			{
				if ((this._LastAccessedTime != value))
				{
					this.OnLastAccessedTimeChanging(value);
					this.SendPropertyChanging();
					this._LastAccessedTime = value;
					this.SendPropertyChanged("LastAccessedTime");
					this.OnLastAccessedTimeChanged();
				}
			}
		}
		
		public event PropertyChangingEventHandler PropertyChanging;
		
		public event PropertyChangedEventHandler PropertyChanged;
		
		protected virtual void SendPropertyChanging()
		{
			if ((this.PropertyChanging != null))
			{
				this.PropertyChanging(this, emptyChangingEventArgs);
			}
		}
		
		protected virtual void SendPropertyChanged(String propertyName)
		{
			if ((this.PropertyChanged != null))
			{
				this.PropertyChanged(this, new PropertyChangedEventArgs(propertyName));
			}
		}
	}
	
	[Table(Name="dbo.Authentication")]
	public partial class Authentication : INotifyPropertyChanging, INotifyPropertyChanged
	{
		
		private static PropertyChangingEventArgs emptyChangingEventArgs = new PropertyChangingEventArgs(String.Empty);
		
		private short _SNetworkId;
		
		private long _XUID;
		
		private string _SNUserId;
		
		private string _Token;
		
		private string _DeviceId;
		
		private System.DateTime _LastAccessedTime;
		
    #region Extensibility Method Definitions
    partial void OnLoaded();
    partial void OnValidate(System.Data.Linq.ChangeAction action);
    partial void OnCreated();
    partial void OnSNetworkIdChanging(short value);
    partial void OnSNetworkIdChanged();
    partial void OnXUIDChanging(long value);
    partial void OnXUIDChanged();
    partial void OnSNUserIdChanging(string value);
    partial void OnSNUserIdChanged();
    partial void OnTokenChanging(string value);
    partial void OnTokenChanged();
    partial void OnDeviceIdChanging(string value);
    partial void OnDeviceIdChanged();
    partial void OnLastAccessedTimeChanging(System.DateTime value);
    partial void OnLastAccessedTimeChanged();
    #endregion
		
		public Authentication()
		{
			OnCreated();
		}
		
		[Column(Storage="_SNetworkId", DbType="SmallInt NOT NULL", IsPrimaryKey=true)]
		public short SNetworkId
		{
			get
			{
				return this._SNetworkId;
			}
			set
			{
				if ((this._SNetworkId != value))
				{
					this.OnSNetworkIdChanging(value);
					this.SendPropertyChanging();
					this._SNetworkId = value;
					this.SendPropertyChanged("SNetworkId");
					this.OnSNetworkIdChanged();
				}
			}
		}
		
		[Column(Storage="_XUID", DbType="BigInt NOT NULL", IsPrimaryKey=true)]
		public long XUID
		{
			get
			{
				return this._XUID;
			}
			set
			{
				if ((this._XUID != value))
				{
					this.OnXUIDChanging(value);
					this.SendPropertyChanging();
					this._XUID = value;
					this.SendPropertyChanged("XUID");
					this.OnXUIDChanged();
				}
			}
		}
		
		[Column(Storage="_SNUserId", DbType="NVarChar(64) NOT NULL", CanBeNull=false)]
		public string SNUserId
		{
			get
			{
				return this._SNUserId;
			}
			set
			{
				if ((this._SNUserId != value))
				{
					this.OnSNUserIdChanging(value);
					this.SendPropertyChanging();
					this._SNUserId = value;
					this.SendPropertyChanged("SNUserId");
					this.OnSNUserIdChanged();
				}
			}
		}
		
		[Column(Storage="_Token", DbType="VarChar(4096) NOT NULL", CanBeNull=false)]
		public string Token
		{
			get
			{
				return this._Token;
			}
			set
			{
				if ((this._Token != value))
				{
					this.OnTokenChanging(value);
					this.SendPropertyChanging();
					this._Token = value;
					this.SendPropertyChanged("Token");
					this.OnTokenChanged();
				}
			}
		}
		
		[Column(Storage="_DeviceId", DbType="Char(32) NOT NULL", CanBeNull=false, IsPrimaryKey=true)]
		public string DeviceId
		{
			get
			{
				return this._DeviceId;
			}
			set
			{
				if ((this._DeviceId != value))
				{
					this.OnDeviceIdChanging(value);
					this.SendPropertyChanging();
					this._DeviceId = value;
					this.SendPropertyChanged("DeviceId");
					this.OnDeviceIdChanged();
				}
			}
		}
		
		[Column(Storage="_LastAccessedTime", DbType="DateTime2 NOT NULL")]
		public System.DateTime LastAccessedTime
		{
			get
			{
				return this._LastAccessedTime;
			}
			set
			{
				if ((this._LastAccessedTime != value))
				{
					this.OnLastAccessedTimeChanging(value);
					this.SendPropertyChanging();
					this._LastAccessedTime = value;
					this.SendPropertyChanged("LastAccessedTime");
					this.OnLastAccessedTimeChanged();
				}
			}
		}
		
		public event PropertyChangingEventHandler PropertyChanging;
		
		public event PropertyChangedEventHandler PropertyChanged;
		
		protected virtual void SendPropertyChanging()
		{
			if ((this.PropertyChanging != null))
			{
				this.PropertyChanging(this, emptyChangingEventArgs);
			}
		}
		
		protected virtual void SendPropertyChanged(String propertyName)
		{
			if ((this.PropertyChanged != null))
			{
				this.PropertyChanged(this, new PropertyChangedEventArgs(propertyName));
			}
		}
	}
	
	public partial class spGetXUIDSResult
	{
		
		private long _XUID;
		
		private string _SNUserId;
		
		private string _GamerTag;
		
		private int _Flags;
		
		public spGetXUIDSResult()
		{
		}
		
		[Column(Storage="_XUID", DbType="BigInt NOT NULL")]
		public long XUID
		{
			get
			{
				return this._XUID;
			}
			set
			{
				if ((this._XUID != value))
				{
					this._XUID = value;
				}
			}
		}
		
		[Column(Storage="_SNUserId", DbType="NVarChar(64) NOT NULL", CanBeNull=false)]
		public string SNUserId
		{
			get
			{
				return this._SNUserId;
			}
			set
			{
				if ((this._SNUserId != value))
				{
					this._SNUserId = value;
				}
			}
		}
		
		[Column(Storage="_GamerTag", DbType="VarChar(16) NOT NULL", CanBeNull=false)]
		public string GamerTag
		{
			get
			{
				return this._GamerTag;
			}
			set
			{
				if ((this._GamerTag != value))
				{
					this._GamerTag = value;
				}
			}
		}
		
		[Column(Storage="_Flags", DbType="Int NOT NULL")]
		public int Flags
		{
			get
			{
				return this._Flags;
			}
			set
			{
				if ((this._Flags != value))
				{
					this._Flags = value;
				}
			}
		}
	}
}
#pragma warning restore 1591
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Monitoring\LiveConnectPing\ValidationException.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace LiveConnectPing
{
    /// <summary>
    /// 
    /// </summary>
    public class ValidationException: Exception
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="message"></param>
        public ValidationException(string message)
            : base(message)
        {

        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="format"></param>
        /// <param name="args"></param>
        public ValidationException(string format, params object[] args)
            : base(String.Format(format, args))
        {

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Monitoring\LiveConnectPing\XboxTitle.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace LiveConnectPing
{
    /// <summary>
    /// 
    /// </summary>
    public enum XboxTitle : uint
    {
        Default = XboxTitle.Xbox360Dash,
        Xbox360Dash = 0xFFFE07D1,
        Facebook = 0x584807E1,
        Twitter = XboxTitle.Xbox360Dash,    //Twitter is a BDE, so its title ID is the same as the 360 dash
        LastFM = 0x584807E3,
        WP7GamesHub = 0x584D07D6,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Backup1\Monitoring\LiveConnectPing\STS\StsToken.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using System.Security.Cryptography;
using System.Security.Cryptography.Xml;
using System.Security.Cryptography.X509Certificates;
using System.Xml;
using System.Diagnostics;

namespace LiveConnectPing
{
    /// <summary>
    /// 
    /// </summary>
    public class StsToken
    {
        public const string SamlNamespace = "urn:oasis:names:tc:SAML:1.0:assertion";
        public const string ConsoleTokenStsIssuer = "http://xboxlive.com";
        public const string UserTokenStsIssuer = "http://sts.xboxlive.com";
        public const string UserTokenSamlSubject = "XboxLive User security ticket";
        public const string PartnerTokenSamlSubject = "XboxLive Partner security ticket";

        // Token Signing Certificate
        //  this is the cert and associated private key that signs the SAML token
        private X509Certificate2 _certificate = null;
        private string certSubject;
        private object certStoreLock = new object();

        /// <summary>
        /// 
        /// </summary>
        /// <param name="certSubject"></param>
        public StsToken(string certSubject)
        {
            this.certSubject = certSubject;
        }

        /// <summary>
        /// 
        /// </summary>
        public string CertificateSubject
        {
            get
            {
                return this.certSubject;
            }
            set
            {
                this.certSubject = value;
                this._certificate = null;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="players"></param>
        /// <param name="audience"></param>
        /// <param name="machinePuid"></param>
        /// <param name="clientVersion"></param>
        /// <param name="title"></param>
        /// <param name="titleVersion"></param>
        /// <param name="minutesToExpire"></param>
        /// <returns></returns>
        public string GenerateConsoleToken(Player[] players, string audience, ulong machinePuid, uint clientVersion, uint title, uint titleVersion, int minutesToExpire)
        {
            DateTime now = DateTime.UtcNow;
            DateTime expires = now.Add(TimeSpan.FromMinutes(minutesToExpire));

            TextWriter textWriter = new StringWriter();
            XmlTextWriter writer = new XmlTextWriter(textWriter);

            string assertionID = WriteAssertionAttributes(writer, now.ToString("o"));
            WriteConditions(writer, now.ToString("o"), expires.ToString("o"), audience);

            writer.WriteStartElement("AttributeStatement", SamlNamespace);

            writer.WriteStartElement("Subject", SamlNamespace);
            writer.WriteElementString("NameIdentifier", SamlNamespace, string.Format("0x{0:X16}", players[0].Xuid)); // primary Subject is player1, in uppercase hex
            writer.WriteEndElement();

            // Write out machineID claim
            WriteClaim(writer, "PlatformType", string.Format("0x{0:X2}", 0x1)); //PlatformType 1 == Xbox360
            WriteClaim(writer, "MachineID", string.Format("0x{0:X16}", machinePuid));
            WriteClaim(writer, "ClientVersion", string.Format("0x{0:X8}", clientVersion));
            WriteClaim(writer, "TitleID", string.Format("0x{0:X8}", title));
            WriteClaim(writer, "TitleVersion", string.Format("0x{0:X8}", titleVersion));

            // Write out player claims
            for (int i = 0; i < players.Length; i++)
            {
                if (players[i] != null)
                {
                    WriteClaim(writer, String.Format("Xuid{0}", i + 1), string.Format("0x{0:X16}", players[i].Xuid)); //always return uppercase hex
                    WriteClaim(writer, String.Format("Tier{0}", i + 1), string.Format("0x{0:X2}", players[i].Tier));
                    WriteClaim(writer, String.Format("Country{0}", i + 1), string.Format("0x{0:X2}", players[i].Country));
                }
            }

            writer.WriteEndElement(); // AttributeStatement
            writer.WriteEndElement(); // Assertion

            textWriter.Flush();

            XmlDocument document = new XmlDocument();
            document.LoadXml(textWriter.ToString());

            SignXmlViaLocalCert(document, assertionID);

            TraceEx.TraceVerbose("Generated STS Token:\r\n{0}", document.OuterXml);
            return document.OuterXml;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="majorVersion"></param>
        /// <param name="minorVersion"></param>
        /// <param name="issuer"></param>
        /// <param name="notBefore"></param>
        /// <param name="notOnOrAfter"></param>
        /// <param name="audience"></param>
        /// <param name="subject"></param>
        /// <param name="omittedItem"></param>
        /// <returns></returns>
        public string GeneratePartnerToken(
            string majorVersion,
            string minorVersion,
            string issuer,
            string notBefore,
            string notOnOrAfter,
            string audience,
            string subject)
        {
            return GeneratePartnerToken(majorVersion, minorVersion, issuer, notBefore, notOnOrAfter, audience, subject, null);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="majorVersion"></param>
        /// <param name="minorVersion"></param>
        /// <param name="issuer"></param>
        /// <param name="notBefore"></param>
        /// <param name="notOnOrAfter"></param>
        /// <param name="audience"></param>
        /// <param name="subject"></param>
        /// <param name="omittedItem"></param>
        /// <param name="cert"></param>
        /// <param name="exceptionMessage"></param>
        /// <returns></returns>
        public string GeneratePartnerToken(
            string majorVersion,
            string minorVersion,
            string issuer,
            string notBefore,
            string notOnOrAfter,
            string audience,
            string subject,
            X509Certificate2 cert)
        {
            TextWriter textWriter = new StringWriter();
            XmlTextWriter writer = new XmlTextWriter(textWriter);

            string assertionID = WriteAssertionAttributes(writer, majorVersion, minorVersion, issuer, notBefore);
            // write conditions
            WriteConditions(writer, notBefore, notOnOrAfter, audience);

            writer.WriteStartElement("AttributeStatement", SamlNamespace);

            // write subject
            WriteSubject(writer, subject);

            // write the claims
            WriteClaim(writer, "TitleID", "4D5308E2");
            WriteClaim(writer, "TitleVersion", "1");
            WriteClaim(writer, "PartnerID0", "2600292641993623");
            WriteClaim(writer, "Gamertag0", "mpdev2");

            writer.WriteEndElement(); // AttributeStatement
            writer.WriteEndElement(); // Assertion

            textWriter.Flush();

            XmlDocument document = new XmlDocument();
            document.LoadXml(textWriter.ToString());

            SignXmlViaLocalCert(document, assertionID, cert);

            TraceEx.TraceVerbose("Generated Partner STS Token:\r\n{0}", document.OuterXml);
            return document.OuterXml;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="tokenParams"></param>
        /// <returns></returns>
        public string GenerateUserToken(StsTokenParameters tokenParams)
        {
            TraceEx.TraceVerbose("Generating console STS token for xuid0=0x{0}, Title ID=0x{1}, GamerTag={2}, PlatformType={3} good for 4 hours.", tokenParams.Xuid, tokenParams.TitleId.ToString("X8"), tokenParams.GamerTag, tokenParams.PlatformType);
            return GenerateUserToken(
                UserTokenStsIssuer,
                DateTime.Now.ToString("o"),
                DateTime.Now.Add(TimeSpan.FromHours(4)).ToString("o"),
                tokenParams.PlatformType,
                tokenParams.DeviceId,
                tokenParams.ClientVersion,
                tokenParams.TitleId.ToString("X8"),
                tokenParams.TitleVersion,
                tokenParams.Xuid.ToString(),
                tokenParams.GamerTag,
                tokenParams.Tier,
                tokenParams.MachineId.ToString(),
                tokenParams.Puid,
                tokenParams.CID,
                tokenParams.Country,
                tokenParams.Privileges,
                null);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="xuid"></param>
        /// <param name="titleId"></param>
        /// <param name="titleVersion"></param>
        /// <returns></returns>
        public string GenerateUserToken(
            string xuid,
            string titleId,
            string titleVersion)
        {
            return GenerateUserToken(UserTokenStsIssuer, DateTime.Now.ToString("o"), DateTime.Now.Add(TimeSpan.FromHours(4)).ToString("o"), "15", String.Empty, "1", titleId, titleVersion, xuid,
                                String.Empty, String.Empty, null);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="issuer"></param>
        /// <param name="notBefore"></param>
        /// <param name="notOnOrAfter"></param>
        /// <param name="platformType"></param>
        /// <param name="deviceId"></param>
        /// <param name="clientVersion"></param>
        /// <param name="titleId"></param>
        /// <param name="titleVersion"></param>
        /// <param name="xuid"></param>
        /// <param name="gamertag"></param>
        /// <param name="tier"></param>
        /// <param name="omittedItem"></param>
        /// <returns></returns>
        public string GenerateUserToken(
            string issuer,
            string notBefore,
            string notOnOrAfter,
            string platformType,
            string deviceId,
            string clientVersion,
            string titleId,
            string titleVersion,
            string xuid,
            string gamertag,
            string tier)
        {
            return GenerateUserToken(issuer, notBefore, notOnOrAfter, platformType, deviceId, clientVersion, titleId, titleVersion, xuid,
                                gamertag, tier, null);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="issuer"></param>
        /// <param name="notBefore"></param>
        /// <param name="notOnOrAfter"></param>
        /// <param name="platformType"></param>
        /// <param name="deviceId"></param>
        /// <param name="clientVersion"></param>
        /// <param name="titleId"></param>
        /// <param name="titleVersion"></param>
        /// <param name="xuid"></param>
        /// <param name="gamertag"></param>
        /// <param name="tier"></param>
        /// <param name="omittedItem"></param>
        /// <param name="cert"></param>
        /// <returns></returns>
        public string GenerateUserToken(
            string issuer,
            string notBefore,
            string notOnOrAfter,
            string platformType,
            string deviceId,
            string clientVersion,
            string titleId,
            string titleVersion,
            string xuid,
            string gamertag,
            string tier,
            X509Certificate2 cert)
        {
            return GenerateUserToken(issuer, notBefore, notOnOrAfter, platformType, deviceId, clientVersion, titleId, titleVersion, xuid,
                                gamertag, tier, String.Empty, String.Empty, String.Empty, String.Empty, String.Empty, null);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="issuer"></param>
        /// <param name="notBefore"></param>
        /// <param name="notOnOrAfter"></param>
        /// <param name="platformType"></param>
        /// <param name="deviceId"></param>
        /// <param name="clientVersion"></param>
        /// <param name="titleId"></param>
        /// <param name="titleVersion"></param>
        /// <param name="xuid"></param>
        /// <param name="gamertag"></param>
        /// <param name="tier"></param>
        /// <param name="omittedItem"></param>
        /// <param name="cert"></param>
        /// <param name="exceptionMessage"></param>
        /// <returns></returns>
        public string GenerateUserToken(
            string issuer,
            string notBefore,
            string notOnOrAfter,
            string platformType,
            string deviceId,
            string clientVersion,
            string titleId,
            string titleVersion,
            string xuid,
            string gamertag,
            string tier,
            string machineId,
            string puid,
            string cid,
            string country,
            string privledges,
            X509Certificate2 cert)
        {
            TextWriter textWriter = new StringWriter();
            XmlTextWriter writer = new XmlTextWriter(textWriter);

            string assertionID = WriteAssertionAttributes(writer, issuer, notBefore);
            // write conditions
            WriteConditions(writer, notBefore, notOnOrAfter, UserTokenStsIssuer);

            writer.WriteStartElement("AttributeStatement", SamlNamespace);
            // write subject
            WriteSubject(writer, UserTokenSamlSubject);

            // write claims
            WriteClaim(writer, "PlatformType", platformType);

            if (String.IsNullOrEmpty(machineId))
                machineId = Utility.GenerateRandomUInt64().ToString();
            WriteClaim(writer, "MachineID", machineId);

            if (String.IsNullOrEmpty(deviceId))
                deviceId = Utility.GenerateRandomUInt64().ToString();
            WriteClaim(writer, "DeviceID", deviceId);
            
            if (String.IsNullOrEmpty(clientVersion))
                clientVersion = "1";
            WriteClaim(writer, "ClientVersion", clientVersion);
            
            WriteClaim(writer, "TitleID", titleId);
            WriteClaim(writer, "TitleVersion", titleVersion);

            if (String.IsNullOrEmpty(puid))
                puid = Utility.GenerateRandomUInt64().ToString();
            WriteClaim(writer, "Puid0", puid);
        
            if (String.IsNullOrEmpty(cid))
                cid = Utility.GenerateRandomUInt64().ToString();
            WriteClaim(writer, "CID0", cid);
        
            if (String.IsNullOrEmpty(xuid))
                xuid = Utility.GenerateRandomUInt64().ToString();
            WriteClaim(writer, "Xuid0", xuid);
            
            if (String.IsNullOrEmpty(gamertag))
                gamertag = Utility.GenerateRandomGamerTag(10);
            WriteClaim(writer, "Gamertag0", gamertag);
            
            if (String.IsNullOrEmpty(tier))
                tier = "3"; //NOTE: not sure this is a 'great' default value; corresponds to silver acct
            WriteClaim(writer, "Tier0", tier);
            
            WriteClaim(writer, "Country0", "103");  //NOTE: hardcoded for US (103)

            //NOTE: the 'privledge' values were taken from a sample token, for a new, silver XBL account.
            WriteClaim(writer, "Privileges0", "212,220,226,227,228,229,230,231,234,235,237,240,241,243,244,245,246,247,248,249,251,252,254,255");

            writer.WriteEndElement(); // AttributeStatement
            writer.WriteEndElement(); // Assertion

            textWriter.Flush();

            XmlDocument document = new XmlDocument();
            document.LoadXml(textWriter.ToString());

            // sign the token
            SignXmlViaLocalCert(document, assertionID, cert);

            TraceEx.TraceVerbose("Generated User STS Token:\r\n{0}", document.OuterXml);
            return document.OuterXml;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="parameters"></param>
        /// <returns></returns>
        public string GenerateConsoleToken(StsTokenParameters parameters)
        {
            return GenerateConsoleToken(parameters.Xuid, parameters.TitleId, parameters.MachineId, parameters.MinutesToExpire);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="xuid"></param>
        /// <param name="titleId"></param>
        /// <param name="machinePuid"></param>
        /// <param name="minutesToExpire"></param>
        /// <returns></returns>
        public string GenerateConsoleToken(ulong xuid, uint titleId, ulong machinePuid, int minutesToExpire)
        {
            TraceEx.TraceVerbose("Generating console STS token for xuid0=0x{0}, Title ID=0x{1}, MachinePUID={2}, good for {3} minutes.", xuid.ToString("X16"), titleId.ToString("X8"), machinePuid.ToString("X16"), minutesToExpire);
            //103=US, 6=Gold
            Player player1 = new Player() { Xuid = xuid, Country = 103, Tier = 6 };

            //random machine puid, hard-coded client version, random title version
            return GenerateConsoleToken(new Player[] { player1 }, ConsoleTokenStsIssuer, machinePuid, 0x25223C00, titleId, Utility.GenerateRandomUInt32(), minutesToExpire);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="notBefore"></param>
        /// <param name="assertionID"></param>
        private static string WriteAssertionAttributes(XmlTextWriter writer, string notBefore)
        {
            return WriteAssertionAttributes(writer, "1", "1", UserTokenStsIssuer, notBefore);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="issuer"></param>
        /// <param name="notBefore"></param>
        /// <param name="OmittedUserTokenItems"></param>
        /// <param name="assertionID"></param>
        private static string WriteAssertionAttributes(XmlTextWriter writer, string issuer, string notBefore)
        {
            return WriteAssertionAttributes(writer, "1", "1", issuer, notBefore);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="majorVersion"></param>
        /// <param name="minorVersion"></param>
        /// <param name="issuer"></param>
        /// <param name="notBefore"></param>
        /// <param name="OmittedPartnerTokenItems"></param>
        /// <param name="OmittedUserTokenItems"></param>
        /// <param name="assertionID"></param>
        private static string WriteAssertionAttributes(
            XmlTextWriter writer,
            string majorVersion,
            string minorVersion,
            string issuer,
            string notBefore)
        {
            string assertionID = string.Format("SamlSecurityToken-{0}", Guid.NewGuid().ToString());

            writer.WriteProcessingInstruction("xml", "version='1.0' encoding='utf-16'");
            writer.WriteStartElement("saml", "Assertion", SamlNamespace);
            writer.WriteAttributeString("MajorVersion", majorVersion);
            writer.WriteAttributeString("MinorVersion", minorVersion);
            writer.WriteAttributeString("AssertionID", assertionID);

            writer.WriteAttributeString("Issuer", issuer);

            DateTime dateTimeNotBefore;
            if ((DateTime.TryParse(notBefore, out dateTimeNotBefore)) && (dateTimeNotBefore < DateTime.Now))
            {
                writer.WriteAttributeString("IssueInstant", dateTimeNotBefore.ToUniversalTime().ToString("o"));
            }
            else
                writer.WriteAttributeString("IssueInstant", DateTime.UtcNow.ToString("o"));

            return assertionID;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="notBefore"></param>
        /// <param name="notOnOrAfter"></param>
        /// <param name="audience"></param>
        /// <param name="OmittedPartnerTokenItems"></param>
        /// <param name="OmittedUserTokenItems"></param>
        private static void WriteConditions(XmlTextWriter writer, string notBefore, string notOnOrAfter, string audience)
        {
            writer.WriteStartElement("Conditions", SamlNamespace);
            writer.WriteAttributeString("NotBefore", notBefore);
            writer.WriteAttributeString("NotOnOrAfter", notOnOrAfter);
            writer.WriteStartElement("AudienceRestrictionCondition", SamlNamespace);
            writer.WriteElementString("Audience", SamlNamespace, audience);

            writer.WriteEndElement(); //AudienceRestrictionCondition
            writer.WriteEndElement(); // Conditions
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="subject"></param>
        private static void WriteSubject(XmlTextWriter writer, string subject)
        {
            writer.WriteStartElement("Subject", SamlNamespace);
            writer.WriteStartElement("NameIdentifier", SamlNamespace);
            writer.WriteAttributeString("Format", "/xboxlive/nameFormat");
            writer.WriteAttributeString("NameQualifier", "Microsoft-NameQualifier-domain");
            writer.WriteString(subject);
            writer.WriteEndElement(); // NameIdentifier
            writer.WriteEndElement(); // subject
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="claim"></param>
        /// <param name="value"></param>
        private static void WriteClaim(XmlTextWriter writer, string claim, string value)
        {
            writer.WriteStartElement("Attribute", SamlNamespace);
            writer.WriteAttributeString("AttributeName", claim);
            writer.WriteAttributeString("AttributeNamespace", "http://xboxlive.com/claims");
            writer.WriteElementString("AttributeValue", SamlNamespace, value);
            writer.WriteEndElement();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="document"></param>
        /// <param name="assertionID"></param>
        private void SignXmlViaLocalCert(XmlDocument document, string assertionID)
        {
            SignXmlViaLocalCert(document, assertionID, null);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="document"></param>
        /// <param name="assertionID"></param>
        /// <param name="cert"></param>
        /// <param name="exceptionMessage"></param>
        private void SignXmlViaLocalCert(XmlDocument document, string assertionID, X509Certificate2 cert)
        {
            // grab the cert so we don't have a race condition with it changing during a reload
            // we need this because we access the cert twice in this function and don't want to take a lock... but need to stay consistant
            X509Certificate2 signingCertificate;

            if (cert == null)
                signingCertificate = GetCertificate();
            else
                signingCertificate = cert;

            try
            {
                // Create a CustomSignedXml object.  
                // The CustomSigendXml object lets us change what attribute is used to find the node to sign.
                // The standard SignedXml signs the node identified by the attribute named 'id'.
                // We need to sign the node identified by the attribute named 'AssertionID'. 
                CustomSignedXml signedXml = new CustomSignedXml(document);
                signedXml.SignedInfo.CanonicalizationMethod = SignedXml.XmlDsigExcC14NTransformUrl;
                signedXml.SigningKey = (RSACryptoServiceProvider)signingCertificate.PrivateKey;

                // Create a reference which tells SignedXml what node to sign
                Reference reference = new Reference();
                reference.Uri = "#" + assertionID;

                // Add an enveloped transformation to the reference.
                XmlDsigEnvelopedSignatureTransform transform1 = new XmlDsigEnvelopedSignatureTransform();
                reference.AddTransform(transform1);

                XmlDsigExcC14NTransform transform2 = new XmlDsigExcC14NTransform();
                reference.AddTransform(transform2);

                // Add the reference to the SignedXml object.
                signedXml.AddReference(reference);

                // add key info
                KeyInfo keyInfo = new KeyInfo();
                keyInfo.AddClause(new KeyInfoX509Data(signingCertificate));
                signedXml.KeyInfo = keyInfo;

                // Compute the signature.
                signedXml.ComputeSignature();

                // Get the XML representation of the signature and save
                // it to an XmlElement object.
                XmlElement xmlDigitalSignature = signedXml.GetXml();

                // Append the element to the XML document.
                document.DocumentElement.AppendChild(document.ImportNode(xmlDigitalSignature, true));
            }
            catch (Exception e)
            {
                throw new ApplicationException(String.Format("Error signing SAML token with certificate '{0}'; {1}", cert.Subject, e.Message), e);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        private X509Certificate2 GetCertificate()
        {
            lock (certStoreLock)
            {
                X509Certificate2 certificate = this._certificate;

                // do I have a cert
                if (certificate != null)
                    return certificate;

                string subject = this.CertificateSubject;
                X509Store store = new X509Store(StoreName.My, StoreLocation.LocalMachine);
                store.Open(OpenFlags.ReadOnly);

                try
                {
                    // Find the certificate that matches the subject
                    X509Certificate2Collection matches = store.Certificates.Find(X509FindType.FindBySubjectName, subject, false);
                    if (matches == null || matches.Count == 0)
                        throw new ApplicationException(String.Format("No certificates with subject {0} were found in the specified store", subject));
                    if (matches.Count > 1)
                        throw new ApplicationException(String.Format("Multiple certificates with subject {0} were found in the specified store", subject));
                    if (!matches[0].HasPrivateKey)
                        throw new ApplicationException(String.Format("Certificate with subject {0} doesn't have a private key", subject));
                    _certificate = certificate = matches[0];
                }
                finally
                {
                    if (store != null)
                        store.Close();
                }
                return certificate;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Monitoring\LiveConnectPing\STS\CustomSignedXml.cs ===
using System;
using System.Collections.Generic;
using System.Web;
using System.Xml;
using System.Xml.Serialization;
using System.Security.Cryptography;
using System.Security.Cryptography.Xml;


namespace LiveConnectPing
{

    // http://blogs.msdn.com/shawnfa/archive/2004/04/05/108098.aspx
    // Searching for Custom ID Tags With Signed XML
    // Excerpt... The biggest limitation with doing this is that you must refer to the nodes that are being signed by ID, 
    // which for v1.1 and 1.0 of the framework was given by an attribute named "Id". The problem there is that 
    // the Id attribute may already have another use in your schema, and you cannot reuse them for creating node names. 
    // Another problem that may come up is that the XML being signed may be generated by a tool or program, 
    // and it's not possible for you to add Id tags. Whidbey reduces this limitation somewhat by also allowing 
    // "id" and "ID", but the fundamental problem still exists.

    // Nodes that are being referred to by ID are resolved in the GetIdElement method of the SignedXml class. 
    // By subclassing SignedXml and overriding this method, its possible to create your own id node resolver. 


    public class CustomSignedXml : SignedXml
    {
        public CustomSignedXml(XmlDocument doc) :
            base(doc)
        {
        }

        public override XmlElement GetIdElement(XmlDocument doc, string id)
        {
            // check to see if it's a standard ID reference
            XmlElement idElem = base.GetIdElement(doc, id);
            if (idElem != null)
                return idElem;

            idElem = doc.SelectSingleNode("//*[@AssertionID=\"" + id + "\"]") as XmlElement;
            return idElem;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Monitoring\LiveConnectPing\STS\Player.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace LiveConnectPing
{
    /// <summary>
    /// 
    /// </summary>
    public class Player
    {
        /// <summary>
        /// 
        /// </summary>
        public ulong Xuid
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public byte Tier
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public byte Country
        {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Monitoring\LiveConnectPing\STS\StsTokenParameters.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace LiveConnectPing
{
    /// <summary>
    /// 
    /// </summary>
    public class StsTokenParameters
    {
        /// <summary>
        /// 
        /// </summary>
        public StsTokenParameters()
        {
            //default to regular STS value of 60 mins for a valid token
            this.MinutesToExpire = 60;
            //only the Authentication interface calls (that use deviceId) need to make sure this value is in sync w/ the test
            this.MachineId = Utility.GenerateRandomUInt64();
        }

        /// <summary>
        /// 
        /// </summary>
        public ulong Xuid
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public uint TitleId
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string TitleVersion
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public ulong MachineId
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string DeviceId
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string ClientVersion
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string PlatformType
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string Puid
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string CID
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string GamerTag
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string Tier
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string Country
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string Privileges
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public int MinutesToExpire
        {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Monitoring\LiveConnectPing\WCF\ChannelFactoryExtensions.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.ServiceModel;

namespace LiveConnectPing
{
    /// <summary>
    /// 
    /// </summary>
    public static class ChannelFactoryExtensions
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="channel"></param>
        public static void CloseConnection(this ICommunicationObject channel)
        {
            if (channel == null || channel.State != CommunicationState.Opened)
            {
                return;
            }

            try
            {
                channel.Close();
            }
            catch (CommunicationException)
            {
                channel.Abort();
            }
            catch (TimeoutException)
            {
                channel.Abort();
            }
            catch (Exception)
            {
                channel.Abort();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\LCWebService\test\LiveConnectTest.cs ===
using System;
using System.Xml;
using System.IO;
using System.Data;
using System.Data.SqlClient;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using System.Security.Cryptography.Xml;

namespace LiveConnectWeb.Test
{
    /// <summary>
    /// 
    /// </summary>
    public class LiveConnectTest : ILiveConnectTest
    {
        // Token Signing Certificate
        //  this is the cert and associated private key that signs the SAML token
        static private X509Certificate2 _certificate = null;

        private const string samlNamespace = "urn:oasis:names:tc:SAML:1.0:assertion";
        private const string stsIssuer = "http://sts.xboxlive.com";
        private const string signingCertSubject = "lnconnect.redmond.corp.microsoft.com";

        /// <summary>
        /// 
        /// </summary>
        /// <param name="socialNetworkID"></param>
        /// <param name="xuid"></param>
        /// <param name="snUserID"></param>
        /// <param name="gamerTag"></param>
        /// <param name="visibility"></param>
        public void AddDirectoryInfo(ushort socialNetworkID, ulong xuid, string snUserID, string gamerTag, Visibility visibility)
        {
            LiveConnectDataContext db = new LiveConnectDataContext();

            //for now, ignore any issues related to primary key violations
            //an exception will be thrown back to the client
            Directory directoryEntry = new Directory();
            db.Directories.InsertOnSubmit(directoryEntry);

            directoryEntry.SNetworkId = (short)socialNetworkID;
            directoryEntry.XUID = (long)xuid;
            directoryEntry.GamerTag = gamerTag;
            directoryEntry.SNUserId = snUserID;
            directoryEntry.Flags = (int)visibility;
            directoryEntry.LastAccessedTime = DateTime.Now;

            db.SubmitChanges();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="socialNetworkID"></param>
        /// <param name="xuid"></param>
        /// <param name="snUserID"></param>
        /// <param name="authToken"></param>
        /// <param name="deviceID"></param>
        public void AddAuthInfo(ushort socialNetworkID, ulong xuid, string snUserID, string authToken, string deviceID)
        {
            LiveConnectDataContext db = new LiveConnectDataContext();

            //for now, ignore any issues related to primary key violations
            //an exception will be thrown back to the client
            Authentication authEntry = new Authentication();

            db.Authentications.InsertOnSubmit(authEntry);

            authEntry.SNetworkId = (short)socialNetworkID;
            authEntry.XUID = (long)xuid;
            authEntry.SNUserId = snUserID;
            authEntry.Token = authToken;
            authEntry.DeviceId = deviceID;
            authEntry.LastAccessedTime = DateTime.Now;

            db.SubmitChanges();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="sql"></param>
        public int ExecuteSql(string sql)
        {
            using (SqlConnection connection = new SqlConnection(System.Configuration.ConfigurationManager.ConnectionStrings["LiveConnect"].ConnectionString))
            using (SqlCommand command = new SqlCommand(sql, connection))
            {                               
                command.CommandType = CommandType.Text;
                connection.Open();
                return command.ExecuteNonQuery();
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="sql"></param>
        /// <returns></returns>
        public string ExecuteSqlDataSet(string sql)
        {
            using (SqlConnection connection = new SqlConnection(System.Configuration.ConfigurationManager.ConnectionStrings["LiveConnect"].ConnectionString))
            using (SqlDataAdapter dataAdapter = new SqlDataAdapter(sql, connection))
            {
                DataSet set = new DataSet();
                dataAdapter.Fill(set);
                return set.GetXml();                
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="players"></param>
        /// <param name="machinePuid"></param>
        /// <param name="clientVersion"></param>
        /// <param name="title"></param>
        /// <param name="titleVersion"></param>
        /// <returns></returns>
        public string GetStsToken(Player[] players, string audience, ulong machinePuid, uint clientVersion, uint title, uint titleVersion, int minutesToExpire)
        {
            string assertionID = string.Format("SamlSecurityToken-{0}", Guid.NewGuid().ToString());
            
            DateTime now = DateTime.UtcNow;
            DateTime expires = now.Add(TimeSpan.FromMinutes(minutesToExpire));

            TextWriter textWriter = new StringWriter();
            XmlTextWriter writer = new XmlTextWriter(textWriter);
            
            writer.WriteStartElement("saml", "Assertion", samlNamespace);
            writer.WriteAttributeString("MajorVersion", "1");
            writer.WriteAttributeString("MinorVersion", "1");
            writer.WriteAttributeString("AssertionID", assertionID);
            writer.WriteAttributeString("Issuer", stsIssuer);
            writer.WriteAttributeString("IssueInstant", now.ToString("o"));
            
            writer.WriteStartElement("Conditions", samlNamespace);
            writer.WriteAttributeString("NotBefore", now.ToString("o")); 
            writer.WriteAttributeString("NotOnOrAfter", expires.ToString("o"));
            writer.WriteStartElement("AudienceRestrictionCondition", samlNamespace);
            writer.WriteElementString("Audience", samlNamespace, audience);
            writer.WriteEndElement(); //AudienceRestrictionCondition
            writer.WriteEndElement(); // Conditions

            writer.WriteStartElement("AttributeStatement", samlNamespace);
            
            writer.WriteStartElement("Subject", samlNamespace);
            writer.WriteElementString("NameIdentifier", samlNamespace, string.Format("0x{0:X16}", players[0].Xuid)); // primary Subject is player1, in uppercase hex
            writer.WriteEndElement();

            // Write out machineID claim
            WriteClaim(writer, "PlatformType", string.Format("0x{0:X2}", 0x2));
            WriteClaim(writer, "MachineID", string.Format("0x{0:X16}", machinePuid));
            WriteClaim(writer, "ClientVersion", string.Format("0x{0:X8}", clientVersion));
            WriteClaim(writer, "TitleID", string.Format("0x{0:X8}", title));
            WriteClaim(writer, "TitleVersion", string.Format("0x{0:X8}", titleVersion));
                        
            // Write out player claims
            for (int i = 0; i < players.Length; i++)
            {
                if (players[i] != null)
                {
                    WriteClaim(writer, String.Format("Xuid{0}", i + 1), string.Format("0x{0:X16}", players[i].Xuid)); //always return uppercase hex
                    WriteClaim(writer, String.Format("Tier{0}", i + 1), string.Format("0x{0:X2}", players[i].Tier));
                    WriteClaim(writer, String.Format("Country{0}", i + 1), string.Format("0x{0:X2}", players[i].Country));
                }
            }
                        
            writer.WriteEndElement(); // AttributeStatement
            writer.WriteEndElement(); // Assertion
            
            textWriter.Flush();

            XmlDocument document = new XmlDocument();
            document.LoadXml(textWriter.ToString());
            
            SignXmlViaLocalCert(document, assertionID);
            
            return document.OuterXml;
        }

        public string GetSimpleStsToken(ulong xuid, uint titleId, ulong machinePuid, int minutesToExpire)
        {
            //103=US, 6=Gold
            Player player1 = new Player(){ Xuid=xuid, Country=103, Tier=6 };

            //random machine puid, hard-coded client version, random title version
            return GetStsToken(new Player[] { player1 }, "http://xboxlive.com", machinePuid, 0x25223C00, titleId, GenerateRandomUInt32(), minutesToExpire);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="claim"></param>
        /// <param name="value"></param>
        private static void WriteClaim(XmlTextWriter writer, string claim, string value)
        {
            writer.WriteStartElement("Attribute", samlNamespace);
            writer.WriteAttributeString("AttributeName", claim);
            writer.WriteAttributeString("AttributeNamespace", "http://xboxlive.com/claims");
            writer.WriteElementString("AttributeValue", samlNamespace, value);
            writer.WriteEndElement();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="document"></param>
        /// <param name="assertionID"></param>
        private void SignXmlViaLocalCert(XmlDocument document, string assertionID)
        {
            // grab the cert so we don't have a race condition with it changing during a reload
            // we need this because we access the cert twice in this function and don't want to take a lock... but need to stay consistant
            X509Certificate2 signingCertificate = GetCertificate();

            // Create a CustomSignedXml object.  
            // The CustomSigendXml object lets us change what attribute is used to find the node to sign.
            // The standard SignedXml signs the node identified by the attribute named 'id'.
            // We need to sign the node identified by the attribute named 'AssertionID'. 
            CustomSignedXml signedXml = new CustomSignedXml(document);
            signedXml.SignedInfo.CanonicalizationMethod = SignedXml.XmlDsigExcC14NTransformUrl;
            signedXml.SigningKey = (RSACryptoServiceProvider)signingCertificate.PrivateKey;

            // Create a reference which tells SignedXml what node to sign
            Reference reference = new Reference();
            reference.Uri = "#" + assertionID;

            // Add an enveloped transformation to the reference.
            XmlDsigEnvelopedSignatureTransform transform1 = new XmlDsigEnvelopedSignatureTransform();
            reference.AddTransform(transform1);

            XmlDsigExcC14NTransform transform2 = new XmlDsigExcC14NTransform();
            reference.AddTransform(transform2);

            // Add the reference to the SignedXml object.
            signedXml.AddReference(reference);

            // add key info
            KeyInfo keyInfo = new KeyInfo();
            keyInfo.AddClause(new KeyInfoX509Data(signingCertificate));
            signedXml.KeyInfo = keyInfo;

            // Compute the signature.
            signedXml.ComputeSignature();

            // Get the XML representation of the signature and save
            // it to an XmlElement object.
            XmlElement xmlDigitalSignature = signedXml.GetXml();

            // Append the element to the XML document.
            document.DocumentElement.AppendChild(document.ImportNode(xmlDigitalSignature, true));
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        private static X509Certificate2 GetCertificate()
        {
            X509Certificate2 certificate = _certificate;

            // do I have a cert
            if (certificate != null)
                return certificate;

            string certSubject = signingCertSubject;
            X509Store store = new X509Store(StoreName.My, StoreLocation.LocalMachine);
            store.Open(OpenFlags.ReadOnly);
            try
            {
                // Find the certificate that matches the subject
                X509Certificate2Collection matches = store.Certificates.Find(X509FindType.FindBySubjectName, certSubject, false);
                if (matches == null || matches.Count == 0)
                    throw new ApplicationException(String.Format("No certificates with subject {0} were found in the specified store", certSubject));
                if (matches.Count > 1)
                    throw new ApplicationException(String.Format("Multiple certificates with subject {0} were found in the specified store", certSubject));
                if (!matches[0].HasPrivateKey)
                    throw new ApplicationException(String.Format("Certificate with subject {0} doesn't have a private key", certSubject));
                _certificate = certificate = matches[0];
            }
            finally
            {
                store.Close();
            }
            return certificate;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public static ulong GenerateRandomUInt64()
        {
            byte[] buffer = new byte[sizeof(ulong)];
            RNGCryptoServiceProvider rng = new RNGCryptoServiceProvider();
            rng.GetNonZeroBytes(buffer);
            return BitConverter.ToUInt64(buffer, 0);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public static uint GenerateRandomUInt32()
        {
            byte[] buffer = new byte[sizeof(uint)];
            RNGCryptoServiceProvider rng = new RNGCryptoServiceProvider();
            rng.GetNonZeroBytes(buffer);
            return BitConverter.ToUInt32(buffer, 0);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Monitoring\LiveConnectPing\WCF\StsTokenManager.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.ServiceModel;
using System.ServiceModel.Description;
using System.IdentityModel;
using System.IdentityModel.Selectors;

namespace LiveConnectPing
{
    /// <summary>
    /// 
    /// </summary>
    public class StsTokenManager : ClientCredentialsSecurityTokenManager
    {
        StsClientCredentials stsCreds;

        /// <summary>
        /// 
        /// </summary>
        /// <param name="stsCreds"></param>
        public StsTokenManager(StsClientCredentials stsCreds): base(stsCreds)
        {
            this.stsCreds = stsCreds;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="tokenRequirement"></param>
        /// <returns></returns>
        public override SecurityTokenProvider CreateSecurityTokenProvider(SecurityTokenRequirement tokenRequirement)
        {
            return new StsTokenProvider(this.stsCreds.StsToken);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="tokenRequirement"></param>
        /// <param name="outOfBandTokenResolver"></param>
        /// <returns></returns>
        public override SecurityTokenAuthenticator CreateSecurityTokenAuthenticator(SecurityTokenRequirement tokenRequirement, out SecurityTokenResolver outOfBandTokenResolver)
        {
            return base.CreateSecurityTokenAuthenticator(tokenRequirement, out outOfBandTokenResolver);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="version"></param>
        /// <returns></returns>
        public override SecurityTokenSerializer CreateSecurityTokenSerializer(SecurityTokenVersion version)
        {
            //return new System.IdentityModel.Tokens.SamlSerializer();
            return base.CreateSecurityTokenSerializer(version);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Monitoring\LiveConnectPing\WCF\StsClientCredentials.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.ServiceModel;
using System.ServiceModel.Description;
using System.IdentityModel.Selectors;

namespace LiveConnectPing
{
    /// <summary>
    /// 
    /// </summary>
    public class StsClientCredentials: ClientCredentials
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="stsToken"></param>
        public StsClientCredentials(string stsToken): base()
        {
            this.StsToken = stsToken;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="other"></param>
        protected StsClientCredentials(StsClientCredentials other)
            : base(other)
        {
            this.StsToken = other.StsToken;
        }

        /// <summary>
        /// 
        /// </summary>
        public string StsToken
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public override SecurityTokenManager CreateSecurityTokenManager()
        {
            return new StsTokenManager(this);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        protected override ClientCredentials CloneCore()
        {
            return new StsClientCredentials(this);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Monitoring\LiveConnectPing\CommandLineArguments.cs ===
//////////////////////////////////////////////////////////////////////////////
//    Command Line Argument Parser
//    ----------------------------
//
//    Author: hotweird@hotmail.com
//
//    Microsoft Public License (Ms-PL)
//
//    This license governs use of the accompanying software. If you use the software, you
//    accept this license. If you do not accept the license, do not use the software.
//
//    1. Definitions
//
//    The terms "reproduce," "reproduction," "derivative works," and "distribution" have the
//    same meaning here as under U.S. copyright law.
//
//    A "contribution" is the original software, or any additions or changes to the software.
//
//    A "contributor" is any person that distributes its contribution under this license.
//
//    "Licensed patents" are a contributor's patent claims that read directly on its contribution.
//
//    2. Grant of Rights
//
//    (A) Copyright Grant- Subject to the terms of this license, including the license conditions
//        and limitations in section 3, each contributor grants you a non-exclusive, worldwide,
//        royalty-free copyright license to reproduce its contribution, prepare derivative works
//        of its contribution, and distribute its contribution or any derivative works that you create.
//
//    (B) Patent Grant- Subject to the terms of this license, including the license conditions and
//        limitations in section 3, each contributor grants you a non-exclusive, worldwide,
//        royalty-free license under its licensed patents to make, have made, use, sell, offer for
//        sale, import, and/or otherwise dispose of its contribution in the software or derivative
//        works of the contribution in the software.
//
//    3. Conditions and Limitations
//
//    (A) No Trademark License- This license does not grant you rights to use any contributors'
//        name, logo, or trademarks.
//
//    (B) If you bring a patent claim against any contributor over patents that you claim are
//        infringed by the software, your patent license from such contributor to the software ends
//        automatically.
//
//    (C) If you distribute any portion of the software, you must retain all copyright, patent,
//        trademark, and attribution notices that are present in the software.
//
//    (D) If you distribute any portion of the software in source code form, you may do so only under
//        this license by including a complete copy of this license with your distribution. If you
//        distribute any portion of the software in compiled or object code form, you may only do so
//        under a license that complies with this license.
//
//    (E) The software is licensed "as-is." You bear the risk of using it. The contributors give no
//        express warranties, guarantees or conditions. You may have additional consumer rights under
//        your local laws which this license cannot change. To the extent permitted under your local
//        laws, the contributors exclude the implied warranties of merchantability, fitness for a
//        particular purpose and non-infringement.
//
//    Usage
//    -----
//
//    Parsing command line arguments to a console application is a common problem. 
//    This library handles the common task of reading arguments from a command line 
//    and filling in the values in a type.
//
//    To use this library, define a class whose fields represent the data that your 
//    application wants to receive from arguments on the command line. Then call 
//    CommandLine.ParseArguments() to fill the object with the data 
//    from the command line. Each field in the class defines a command line argument. 
//    The type of the field is used to validate the data read from the command line. 
//    The name of the field defines the name of the command line option.
//
//    The parser can handle fields of the following types:
//
//    - string
//    - int
//    - uint
//    - bool
//    - enum
//    - array of the above type
//
//    For example, suppose you want to read in the argument list for wc (word count). 
//    wc takes three optional boolean arguments: -l, -w, and -c and a list of files.
//
//    You could parse these arguments using the following code:
//
//    class WCArguments
//    {
//        public bool lines;
//        public bool words;
//        public bool chars;
//        public string[] files;
//    }
//
//    class WC
//    {
//        static void Main(string[] args)
//        {
//            if (CommandLine.ParseArgumentsWithUsage(args, parsedArgs))
//            {
//            //     insert application code here
//            }
//        }
//    }
//
//    So you could call this aplication with the following command line to count 
//    lines in the foo and bar files:
//
//        wc.exe /lines /files:foo /files:bar
//
//    The program will display the following usage message when bad command line 
//    arguments are used:
//
//        wc.exe -x
//
//    Unrecognized command line argument '-x'
//        /lines[+|-]                         short form /l
//        /words[+|-]                         short form /w
//        /chars[+|-]                         short form /c
//        /files:<string>                     short form /f
//        @<file>                             Read response file for more options
//
//    That was pretty easy. However, you realy want to omit the "/files:" for the 
//    list of files. The details of field parsing can be controled using custom 
//    attributes. The attributes which control parsing behaviour are:
//
//    ArgumentAttribute 
//        - controls short name, long name, required, allow duplicates, default value
//        and help text
//    DefaultArgumentAttribute 
//        - allows omition of the "/name".
//        - This attribute is allowed on only one field in the argument class.
//
//    So for the wc.exe program we want this:
//
//    using System;
//    using Utilities;
//
//    class WCArguments
//    {
//        [Argument(ArgumentType.AtMostOnce, HelpText="Count number of lines in the input text.")]
//        public bool lines;
//        [Argument(ArgumentType.AtMostOnce, HelpText="Count number of words in the input text.")]
//        public bool words;
//        [Argument(ArgumentType.AtMostOnce, HelpText="Count number of chars in the input text.")]
//        public bool chars;
//        [DefaultArgument(ArgumentType.MultipleUnique, HelpText="Input files to count.")]
//        public string[] files;
//    }
//
//    class WC
//    {
//        static void Main(string[] args)
//        {
//            WCArguments parsedArgs = new WCArguments();
//            if (CommandLine.ParseArgumentsWithUsage(args, parsedArgs))
//            {
//            //     insert application code here
//            }
//        }
//    }
//
//
//
//    So now we have the command line we want:
//
//        wc.exe /lines foo bar
//
//    This will set lines to true and will set files to an array containing the 
//    strings "foo" and "bar".
//
//    The new usage message becomes:
//
//        wc.exe -x
//
//    Unrecognized command line argument '-x'
//    /lines[+|-]  Count number of lines in the input text. (short form /l)
//    /words[+|-]  Count number of words in the input text. (short form /w)
//    /chars[+|-]  Count number of chars in the input text. (short form /c)
//    @<file>      Read response file for more options
//    <files>      Input files to count. (short form /f)
//
//    If you want more control over how error messages are reported, how /help is 
//    dealt with, etc you can instantiate the CommandLine.Parser class.
//
//
//
//    Cheers,
//    Peter Hallam
//    C# Compiler Developer
//    Microsoft Corp.
//
//
//
//
//    Release Notes
//    -------------
//
//    10/02/2002 Initial Release
//    10/14/2002 Bug Fix
//    01/08/2003 Bug Fix in @ include files
//    10/23/2004 Added user specified help text, formatting of help text to 
//            screen width. Added ParseHelp for /?.
//    11/23/2004 Added support for default values.
//    02/23/2005 Fix bug with short name and default arguments.
//////////////////////////////////////////////////////////////////////////////
namespace CommandLine
{
    using System;
    using System.Diagnostics;
    using System.Reflection;
    using System.Collections;
    using System.IO;
    using System.Text;
    using System.Runtime.InteropServices;

    /// <summary>
    /// Used to control parsing of command line arguments.
    /// </summary>
    [Flags]
    public enum ArgumentType
    {
        /// <summary>
        /// Indicates that this field is required. An error will be displayed
        /// if it is not present when parsing arguments.
        /// </summary>
        Required = 0x01,
        /// <summary>
        /// Only valid in conjunction with Multiple.
        /// Duplicate values will result in an error.
        /// </summary>
        Unique = 0x02,
        /// <summary>
        /// Inidicates that the argument may be specified more than once.
        /// Only valid if the argument is a collection
        /// </summary>
        Multiple = 0x04,

        /// <summary>
        /// The default type for non-collection arguments.
        /// The argument is not required, but an error will be reported if it is specified more than once.
        /// </summary>
        AtMostOnce = 0x00,

        /// <summary>
        /// For non-collection arguments, when the argument is specified more than
        /// once no error is reported and the value of the argument is the last
        /// value which occurs in the argument list.
        /// </summary>
        LastOccurenceWins = Multiple,

        /// <summary>
        /// The default type for collection arguments.
        /// The argument is permitted to occur multiple times, but duplicate 
        /// values will cause an error to be reported.
        /// </summary>
        MultipleUnique = Multiple | Unique,
    }

    /// <summary>
    /// Allows control of command line parsing.
    /// Attach this attribute to instance fields of types used
    /// as the destination of command line argument parsing.
    /// </summary>
    [AttributeUsage(AttributeTargets.Field)]
    public class ArgumentAttribute : Attribute
    {
        /// <summary>
        /// Allows control of command line parsing.
        /// </summary>
        /// <param name="type"> Specifies the error checking to be done on the argument. </param>
        public ArgumentAttribute(ArgumentType type)
        {
            this.type = type;
        }

        /// <summary>
        /// The error checking to be done on the argument.
        /// </summary>
        public ArgumentType Type
        {
            get { return this.type; }
        }
        /// <summary>
        /// Returns true if the argument did not have an explicit short name specified.
        /// </summary>
        public bool DefaultShortName { get { return null == this.shortName; } }

        /// <summary>
        /// The short name of the argument.
        /// Set to null means use the default short name if it does not
        /// conflict with any other parameter name.
        /// Set to String.Empty for no short name.
        /// This property should not be set for DefaultArgumentAttributes.
        /// </summary>
        public string ShortName
        {
            get { return this.shortName; }
            set { Debug.Assert(value == null || !(this is DefaultArgumentAttribute)); this.shortName = value; }
        }

        /// <summary>
        /// Returns true if the argument did not have an explicit long name specified.
        /// </summary>
        public bool DefaultLongName { get { return null == this.longName; } }

        /// <summary>
        /// The long name of the argument.
        /// Set to null means use the default long name.
        /// The long name for every argument must be unique.
        /// It is an error to specify a long name of String.Empty.
        /// </summary>
        public string LongName
        {
            get { Debug.Assert(!this.DefaultLongName); return this.longName; }
            set { Debug.Assert(value != ""); this.longName = value; }
        }

        /// <summary>
        /// The default value of the argument.
        /// </summary>
        public object DefaultValue
        {
            get { return this.defaultValue; }
            set { this.defaultValue = value; }
        }

        /// <summary>
        /// Returns true if the argument has a default value.
        /// </summary>
        public bool HasDefaultValue { get { return null != this.defaultValue; } }

        /// <summary>
        /// Returns true if the argument has help text specified.
        /// </summary>
        public bool HasHelpText { get { return null != this.helpText; } }

        /// <summary>
        /// The help text for the argument.
        /// </summary>
        public string HelpText
        {
            get { return this.helpText; }
            set { this.helpText = value; }
        }

        private string shortName;
        private string longName;
        private string helpText;
        private object defaultValue;
        private ArgumentType type;
    }

    /// <summary>
    /// Indicates that this argument is the default argument.
    /// '/' or '-' prefix only the argument value is specified.
    /// The ShortName property should not be set for DefaultArgumentAttribute
    /// instances. The LongName property is used for usage text only and
    /// does not affect the usage of the argument.
    /// </summary>
    [AttributeUsage(AttributeTargets.Field)]
    public class DefaultArgumentAttribute : ArgumentAttribute
    {
        /// <summary>
        /// Indicates that this argument is the default argument.
        /// </summary>
        /// <param name="type"> Specifies the error checking to be done on the argument. </param>
        public DefaultArgumentAttribute(ArgumentType type)
            : base(type)
        {
        }
    }

    /// <summary>
    /// A delegate used in error reporting.
    /// </summary>
    public delegate void ErrorReporter(string message);

    /// <summary>
    /// Parser for command line arguments.
    ///
    /// The parser specification is infered from the instance fields of the object
    /// specified as the destination of the parse.
    /// Valid argument types are: int, uint, string, bool, enums
    /// Also argument types of Array of the above types are also valid.
    /// 
    /// Error checking options can be controlled by adding a ArgumentAttribute
    /// to the instance fields of the destination object.
    ///
    /// At most one field may be marked with the DefaultArgumentAttribute
    /// indicating that arguments without a '-' or '/' prefix will be parsed as that argument.
    ///
    /// If not specified then the parser will infer default options for parsing each
    /// instance field. The default long name of the argument is the field name. The
    /// default short name is the first character of the long name. Long names and explicitly
    /// specified short names must be unique. Default short names will be used provided that
    /// the default short name does not conflict with a long name or an explicitly
    /// specified short name.
    ///
    /// Arguments which are array types are collection arguments. Collection
    /// arguments can be specified multiple times.
    /// </summary>
    public sealed class Parser
    {
        /// <summary>
        /// The System Defined new line string.
        /// </summary>
        public const string NewLine = "\r\n";

        /// <summary>
        /// Don't ever call this.
        /// </summary>
        private Parser() { }

        /// <summary>
        /// Parses Command Line Arguments. Displays usage message to Console.Out
        /// if /?, /help or invalid arguments are encounterd.
        /// Errors are output on Console.Error.
        /// Use ArgumentAttributes to control parsing behaviour.
        /// </summary>
        /// <param name="arguments"> The actual arguments. </param>
        /// <param name="destination"> The resulting parsed arguments. </param>
        /// <returns> true if no errors were detected. </returns>
        public static bool ParseArgumentsWithUsage(string[] arguments, object destination)
        {
            if (Parser.ParseHelp(arguments) || !Parser.ParseArguments(arguments, destination))
            {
                // error encountered in arguments. Display usage message
                System.Console.Write(Parser.ArgumentsUsage(destination.GetType()));
                return false;
            }

            return true;
        }

        /// <summary>
        /// Parses Command Line Arguments. 
        /// Errors are output on Console.Error.
        /// Use ArgumentAttributes to control parsing behaviour.
        /// </summary>
        /// <param name="arguments"> The actual arguments. </param>
        /// <param name="destination"> The resulting parsed arguments. </param>
        /// <returns> true if no errors were detected. </returns>
        public static bool ParseArguments(string[] arguments, object destination)
        {
            return Parser.ParseArguments(arguments, destination, new ErrorReporter(Console.Error.WriteLine));
        }

        /// <summary>
        /// Parses Command Line Arguments. 
        /// Use ArgumentAttributes to control parsing behaviour.
        /// </summary>
        /// <param name="arguments"> The actual arguments. </param>
        /// <param name="destination"> The resulting parsed arguments. </param>
        /// <param name="reporter"> The destination for parse errors. </param>
        /// <returns> true if no errors were detected. </returns>
        public static bool ParseArguments(string[] arguments, object destination, ErrorReporter reporter)
        {
            Parser parser = new Parser(destination.GetType(), reporter);
            return parser.Parse(arguments, destination);
        }

        private static void NullErrorReporter(string message)
        {
        }

        private class HelpArgument
        {
            [ArgumentAttribute(ArgumentType.AtMostOnce, ShortName = "?")]
            public bool help = false;
        }

        /// <summary>
        /// Checks if a set of arguments asks for help.
        /// </summary>
        /// <param name="args"> Args to check for help. </param>
        /// <returns> Returns true if args contains /? or /help. </returns>
        public static bool ParseHelp(string[] args)
        {
            Parser helpParser = new Parser(typeof(HelpArgument), new ErrorReporter(NullErrorReporter));
            HelpArgument helpArgument = new HelpArgument();
            helpParser.Parse(args, helpArgument);
            return helpArgument.help;
        }


        /// <summary>
        /// Returns a Usage string for command line argument parsing.
        /// Use ArgumentAttributes to control parsing behaviour.
        /// Formats the output to the width of the current console window.
        /// </summary>
        /// <param name="argumentType"> The type of the arguments to display usage for. </param>
        /// <returns> Printable string containing a user friendly description of command line arguments. </returns>
        public static string ArgumentsUsage(Type argumentType)
        {
            int screenWidth = Parser.GetConsoleWindowWidth();
            if (screenWidth == 0)
                screenWidth = 80;
            return ArgumentsUsage(argumentType, screenWidth);
        }

        /// <summary>
        /// Returns a Usage string for command line argument parsing.
        /// Use ArgumentAttributes to control parsing behaviour.
        /// </summary>
        /// <param name="argumentType"> The type of the arguments to display usage for. </param>
        /// <param name="columns"> The number of columns to format the output to. </param>
        /// <returns> Printable string containing a user friendly description of command line arguments. </returns>
        public static string ArgumentsUsage(Type argumentType, int columns)
        {
            return (new Parser(argumentType, null)).GetUsageString(columns);
        }

        private const int STD_OUTPUT_HANDLE = -11;

        private struct COORD
        {
            internal Int16 x;
            internal Int16 y;
        }

        private struct SMALL_RECT
        {
            internal Int16 Left;
            internal Int16 Top;
            internal Int16 Right;
            internal Int16 Bottom;
        }

        private struct CONSOLE_SCREEN_BUFFER_INFO
        {
            internal COORD dwSize;
            internal COORD dwCursorPosition;
            internal Int16 wAttributes;
            internal SMALL_RECT srWindow;
            internal COORD dwMaximumWindowSize;
        }

        [DllImport("kernel32.dll", EntryPoint = "GetStdHandle", SetLastError = true, CharSet = CharSet.Auto, CallingConvention = CallingConvention.StdCall)]
        private static extern int GetStdHandle(int nStdHandle);

        [DllImport("kernel32.dll", EntryPoint = "GetConsoleScreenBufferInfo", SetLastError = true, CharSet = CharSet.Auto, CallingConvention = CallingConvention.StdCall)]
        private static extern int GetConsoleScreenBufferInfo(int hConsoleOutput, ref CONSOLE_SCREEN_BUFFER_INFO lpConsoleScreenBufferInfo);

        /// <summary>
        /// Returns the number of columns in the current console window
        /// </summary>
        /// <returns>Returns the number of columns in the current console window</returns>
        public static int GetConsoleWindowWidth()
        {
            int screenWidth;
            CONSOLE_SCREEN_BUFFER_INFO csbi = new CONSOLE_SCREEN_BUFFER_INFO();

            int rc;
            rc = GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), ref csbi);
            screenWidth = csbi.dwSize.x;
            return screenWidth;
        }

        /// <summary>
        /// Searches a StringBuilder for a character
        /// </summary>
        /// <param name="text"> The text to search. </param>
        /// <param name="value"> The character value to search for. </param>
        /// <param name="startIndex"> The index to stat searching at. </param>
        /// <returns> The index of the first occurence of value or -1 if it is not found. </returns>
        public static int IndexOf(StringBuilder text, char value, int startIndex)
        {
            for (int index = startIndex; index < text.Length; index++)
            {
                if (text[index] == value)
                    return index;
            }

            return -1;
        }

        /// <summary>
        /// Searches a StringBuilder for a character in reverse
        /// </summary>
        /// <param name="text"> The text to search. </param>
        /// <param name="value"> The character to search for. </param>
        /// <param name="startIndex"> The index to start the search at. </param>
        /// <returns>The index of the last occurence of value in text or -1 if it is not found. </returns>
        public static int LastIndexOf(StringBuilder text, char value, int startIndex)
        {
            for (int index = Math.Min(startIndex, text.Length - 1); index >= 0; index--)
            {
                if (text[index] == value)
                    return index;
            }

            return -1;
        }

        private const int spaceBeforeParam = 2;

        /// <summary>
        /// Creates a new command line argument parser.
        /// </summary>
        /// <param name="argumentSpecification"> The type of object to  parse. </param>
        /// <param name="reporter"> The destination for parse errors. </param>
        public Parser(Type argumentSpecification, ErrorReporter reporter)
        {
            this.reporter = reporter;
            this.arguments = new ArrayList();
            this.argumentMap = new Hashtable();

            foreach (FieldInfo field in argumentSpecification.GetFields())
            {
                if (!field.IsStatic && !field.IsInitOnly && !field.IsLiteral)
                {
                    ArgumentAttribute attribute = GetAttribute(field);
                    if (attribute is DefaultArgumentAttribute)
                    {
                        Debug.Assert(this.defaultArgument == null);
                        this.defaultArgument = new Argument(attribute, field, reporter);
                    }
                    else
                    {
                        this.arguments.Add(new Argument(attribute, field, reporter));
                    }
                }
            }

            // add explicit names to map
            foreach (Argument argument in this.arguments)
            {
                Debug.Assert(!argumentMap.ContainsKey(argument.LongName));
                this.argumentMap[argument.LongName] = argument;
                if (argument.ExplicitShortName)
                {
                    if (argument.ShortName != null && argument.ShortName.Length > 0)
                    {
                        Debug.Assert(!argumentMap.ContainsKey(argument.ShortName));
                        this.argumentMap[argument.ShortName] = argument;
                    }
                    else
                    {
                        argument.ClearShortName();
                    }
                }
            }

            // add implicit names which don't collide to map
            foreach (Argument argument in this.arguments)
            {
                if (!argument.ExplicitShortName)
                {
                    if (argument.ShortName != null && argument.ShortName.Length > 0 && !argumentMap.ContainsKey(argument.ShortName))
                        this.argumentMap[argument.ShortName] = argument;
                    else
                        argument.ClearShortName();
                }
            }
        }

        private static ArgumentAttribute GetAttribute(FieldInfo field)
        {
            object[] attributes = field.GetCustomAttributes(typeof(ArgumentAttribute), false);
            if (attributes.Length == 1)
                return (ArgumentAttribute)attributes[0];

            Debug.Assert(attributes.Length == 0);
            return null;
        }

        private void ReportUnrecognizedArgument(string argument)
        {
            this.reporter(string.Format("Unrecognized command line argument '{0}'", argument));
        }

        /// <summary>
        /// Parses an argument list into an object
        /// </summary>
        /// <param name="args"></param>
        /// <param name="destination"></param>
        /// <returns> true if an error occurred </returns>
        private bool ParseArgumentList(string[] args, object destination)
        {
            bool hadError = false;
            if (args != null)
            {
                foreach (string argument in args)
                {
                    if (argument.Length > 0)
                    {
                        switch (argument[0])
                        {
                            case '-':
                            case '/':
                                int endIndex = argument.IndexOfAny(new char[] { ':', '+', '-' }, 1);
                                string option = argument.Substring(1, endIndex == -1 ? argument.Length - 1 : endIndex - 1);
                                string optionArgument;
                                if (option.Length + 1 == argument.Length)
                                {
                                    optionArgument = null;
                                }
                                else if (argument.Length > 1 + option.Length && argument[1 + option.Length] == ':')
                                {
                                    optionArgument = argument.Substring(option.Length + 2);
                                }
                                else
                                {
                                    optionArgument = argument.Substring(option.Length + 1);
                                }

                                Argument arg = (Argument)this.argumentMap[option];
                                if (arg == null)
                                {
                                    ReportUnrecognizedArgument(argument);
                                    hadError = true;
                                }
                                else
                                {
                                    hadError |= !arg.SetValue(optionArgument, destination);
                                }
                                break;
                            case '@':
                                string[] nestedArguments;
                                hadError |= LexFileArguments(argument.Substring(1), out nestedArguments);
                                hadError |= ParseArgumentList(nestedArguments, destination);
                                break;
                            default:
                                if (this.defaultArgument != null)
                                {
                                    hadError |= !this.defaultArgument.SetValue(argument, destination);
                                }
                                else
                                {
                                    ReportUnrecognizedArgument(argument);
                                    hadError = true;
                                }
                                break;
                        }
                    }
                }
            }

            return hadError;
        }

        /// <summary>
        /// Parses an argument list.
        /// </summary>
        /// <param name="args"> The arguments to parse. </param>
        /// <param name="destination"> The destination of the parsed arguments. </param>
        /// <returns> true if no parse errors were encountered. </returns>
        public bool Parse(string[] args, object destination)
        {
            bool hadError = ParseArgumentList(args, destination);

            // check for missing required arguments
            foreach (Argument arg in this.arguments)
            {
                hadError |= arg.Finish(destination);
            }
            if (this.defaultArgument != null)
            {
                hadError |= this.defaultArgument.Finish(destination);
            }

            return !hadError;
        }

        private struct ArgumentHelpStrings
        {
            public ArgumentHelpStrings(string syntax, string help)
            {
                this.syntax = syntax;
                this.help = help;
            }

            public string syntax;
            public string help;
        }

        /// <summary>
        /// A user firendly usage string describing the command line argument syntax.
        /// </summary>
        public string GetUsageString(int screenWidth)
        {
            ArgumentHelpStrings[] strings = GetAllHelpStrings();

            int maxParamLen = 0;
            foreach (ArgumentHelpStrings helpString in strings)
            {
                maxParamLen = Math.Max(maxParamLen, helpString.syntax.Length);
            }

            const int minimumNumberOfCharsForHelpText = 10;
            const int minimumHelpTextColumn = 5;
            const int minimumScreenWidth = minimumHelpTextColumn + minimumNumberOfCharsForHelpText;

            int helpTextColumn;
            int idealMinimumHelpTextColumn = maxParamLen + spaceBeforeParam;
            screenWidth = Math.Max(screenWidth, minimumScreenWidth);
            if (screenWidth < (idealMinimumHelpTextColumn + minimumNumberOfCharsForHelpText))
                helpTextColumn = minimumHelpTextColumn;
            else
                helpTextColumn = idealMinimumHelpTextColumn;

            const string newLine = "\n";
            StringBuilder builder = new StringBuilder();
            foreach (ArgumentHelpStrings helpStrings in strings)
            {
                // add syntax string
                int syntaxLength = helpStrings.syntax.Length;
                builder.Append(helpStrings.syntax);

                // start help text on new line if syntax string is too long
                int currentColumn = syntaxLength;
                if (syntaxLength >= helpTextColumn)
                {
                    builder.Append(newLine);
                    currentColumn = 0;
                }

                // add help text broken on spaces
                int charsPerLine = screenWidth - helpTextColumn;
                int index = 0;
                while (index < helpStrings.help.Length)
                {
                    // tab to start column
                    builder.Append(' ', helpTextColumn - currentColumn);
                    currentColumn = helpTextColumn;

                    // find number of chars to display on this line
                    int endIndex = index + charsPerLine;
                    if (endIndex >= helpStrings.help.Length)
                    {
                        // rest of text fits on this line
                        endIndex = helpStrings.help.Length;
                    }
                    else
                    {
                        endIndex = helpStrings.help.LastIndexOf(' ', endIndex - 1, Math.Min(endIndex - index, charsPerLine));
                        if (endIndex <= index)
                        {
                            // no spaces on this line, append full set of chars
                            endIndex = index + charsPerLine;
                        }
                    }

                    // add chars
                    builder.Append(helpStrings.help, index, endIndex - index);
                    index = endIndex;

                    // do new line
                    AddNewLine(newLine, builder, ref currentColumn);

                    // don't start a new line with spaces
                    while (index < helpStrings.help.Length && helpStrings.help[index] == ' ')
                        index++;
                }

                // add newline if there's no help text                
                if (helpStrings.help.Length == 0)
                {
                    builder.Append(newLine);
                }
            }

            return builder.ToString();
        }
        private static void AddNewLine(string newLine, StringBuilder builder, ref int currentColumn)
        {
            builder.Append(newLine);
            currentColumn = 0;
        }
        private ArgumentHelpStrings[] GetAllHelpStrings()
        {
            ArgumentHelpStrings[] strings = new ArgumentHelpStrings[NumberOfParametersToDisplay()];

            int index = 0;
            foreach (Argument arg in this.arguments)
            {
                strings[index] = GetHelpStrings(arg);
                index++;
            }
            strings[index++] = new ArgumentHelpStrings("@<file>", "Read response file for more options");
            if (this.defaultArgument != null)
                strings[index++] = GetHelpStrings(this.defaultArgument);

            return strings;
        }

        private static ArgumentHelpStrings GetHelpStrings(Argument arg)
        {
            return new ArgumentHelpStrings(arg.SyntaxHelp, arg.FullHelpText);
        }

        private int NumberOfParametersToDisplay()
        {
            int numberOfParameters = this.arguments.Count + 1;
            if (HasDefaultArgument)
                numberOfParameters += 1;
            return numberOfParameters;
        }

        /// <summary>
        /// Does this parser have a default argument.
        /// </summary>
        /// <value> Does this parser have a default argument. </value>
        public bool HasDefaultArgument
        {
            get { return this.defaultArgument != null; }
        }

        private bool LexFileArguments(string fileName, out string[] arguments)
        {
            string args = null;

            try
            {
                using (FileStream file = new FileStream(fileName, FileMode.Open, FileAccess.Read))
                {
                    args = (new StreamReader(file)).ReadToEnd();
                }
            }
            catch (Exception e)
            {
                this.reporter(string.Format("Error: Can't open command line argument file '{0}' : '{1}'", fileName, e.Message));
                arguments = null;
                return false;
            }

            bool hadError = false;
            ArrayList argArray = new ArrayList();
            StringBuilder currentArg = new StringBuilder();
            bool inQuotes = false;
            int index = 0;

            // while (index < args.Length)
            try
            {
                while (true)
                {
                    // skip whitespace
                    while (char.IsWhiteSpace(args[index]))
                    {
                        index += 1;
                    }

                    // # - comment to end of line
                    if (args[index] == '#')
                    {
                        index += 1;
                        while (args[index] != '\n')
                        {
                            index += 1;
                        }
                        continue;
                    }

                    // do one argument
                    do
                    {
                        if (args[index] == '\\')
                        {
                            int cSlashes = 1;
                            index += 1;
                            while (index == args.Length && args[index] == '\\')
                            {
                                cSlashes += 1;
                            }

                            if (index == args.Length || args[index] != '"')
                            {
                                currentArg.Append('\\', cSlashes);
                            }
                            else
                            {
                                currentArg.Append('\\', (cSlashes >> 1));
                                if (0 != (cSlashes & 1))
                                {
                                    currentArg.Append('"');
                                }
                                else
                                {
                                    inQuotes = !inQuotes;
                                }
                            }
                        }
                        else if (args[index] == '"')
                        {
                            inQuotes = !inQuotes;
                            index += 1;
                        }
                        else
                        {
                            currentArg.Append(args[index]);
                            index += 1;
                        }
                    } while (!char.IsWhiteSpace(args[index]) || inQuotes);
                    argArray.Add(currentArg.ToString());
                    currentArg.Length = 0;
                }
            }
            catch (System.IndexOutOfRangeException)
            {
                // got EOF 
                if (inQuotes)
                {
                    this.reporter(string.Format("Error: Unbalanced '\"' in command line argument file '{0}'", fileName));
                    hadError = true;
                }
                else if (currentArg.Length > 0)
                {
                    // valid argument can be terminated by EOF
                    argArray.Add(currentArg.ToString());
                }
            }

            arguments = (string[])argArray.ToArray(typeof(string));
            return hadError;
        }

        private static string LongName(ArgumentAttribute attribute, FieldInfo field)
        {
            return (attribute == null || attribute.DefaultLongName) ? field.Name : attribute.LongName;
        }

        private static string ShortName(ArgumentAttribute attribute, FieldInfo field)
        {
            if (attribute is DefaultArgumentAttribute)
                return null;
            if (!ExplicitShortName(attribute))
                return LongName(attribute, field).Substring(0, 1);
            return attribute.ShortName;
        }

        private static string HelpText(ArgumentAttribute attribute, FieldInfo field)
        {
            if (attribute == null)
                return null;
            else
                return attribute.HelpText;
        }

        private static bool HasHelpText(ArgumentAttribute attribute)
        {
            return (attribute != null && attribute.HasHelpText);
        }

        private static bool ExplicitShortName(ArgumentAttribute attribute)
        {
            return (attribute != null && !attribute.DefaultShortName);
        }

        private static object DefaultValue(ArgumentAttribute attribute, FieldInfo field)
        {
            return (attribute == null || !attribute.HasDefaultValue) ? null : attribute.DefaultValue;
        }

        private static Type ElementType(FieldInfo field)
        {
            if (IsCollectionType(field.FieldType))
                return field.FieldType.GetElementType();
            else
                return null;
        }

        private static ArgumentType Flags(ArgumentAttribute attribute, FieldInfo field)
        {
            if (attribute != null)
                return attribute.Type;
            else if (IsCollectionType(field.FieldType))
                return ArgumentType.MultipleUnique;
            else
                return ArgumentType.AtMostOnce;
        }

        private static bool IsCollectionType(Type type)
        {
            return type.IsArray;
        }

        private static bool IsValidElementType(Type type)
        {
            return type != null && (
                type == typeof(int) ||
                type == typeof(uint) ||
                type == typeof(string) ||
                type == typeof(bool) ||
                type.IsEnum);
        }

        [System.Diagnostics.DebuggerDisplay("Name = {LongName}")]
        private class Argument
        {
            public Argument(ArgumentAttribute attribute, FieldInfo field, ErrorReporter reporter)
            {
                this.longName = Parser.LongName(attribute, field);
                this.explicitShortName = Parser.ExplicitShortName(attribute);
                this.shortName = Parser.ShortName(attribute, field);
                this.hasHelpText = Parser.HasHelpText(attribute);
                this.helpText = Parser.HelpText(attribute, field);
                this.defaultValue = Parser.DefaultValue(attribute, field);
                this.elementType = ElementType(field);
                this.flags = Flags(attribute, field);
                this.field = field;
                this.seenValue = false;
                this.reporter = reporter;
                this.isDefault = attribute != null && attribute is DefaultArgumentAttribute;

                if (IsCollection)
                {
                    this.collectionValues = new ArrayList();
                }

                Debug.Assert(this.longName != null && this.longName != "");
                Debug.Assert(!this.isDefault || !this.ExplicitShortName);
                Debug.Assert(!IsCollection || AllowMultiple, "Collection arguments must have allow multiple");
                Debug.Assert(!Unique || IsCollection, "Unique only applicable to collection arguments");
                Debug.Assert(IsValidElementType(Type) ||
                    IsCollectionType(Type));
                Debug.Assert((IsCollection && IsValidElementType(elementType)) ||
                    (!IsCollection && elementType == null));
                Debug.Assert(!(this.IsRequired && this.HasDefaultValue), "Required arguments cannot have default value");
                Debug.Assert(!this.HasDefaultValue || (this.defaultValue.GetType() == field.FieldType), "Type of default value must match field type");
            }

            public bool Finish(object destination)
            {
                if (this.SeenValue)
                {
                    if (this.IsCollection)
                    {
                        this.field.SetValue(destination, this.collectionValues.ToArray(this.elementType));
                    }
                }
                else
                {
                    if (this.HasDefaultValue)
                    {
                        this.field.SetValue(destination, this.DefaultValue);
                    }
                }

                return ReportMissingRequiredArgument();
            }

            private bool ReportMissingRequiredArgument()
            {
                if (this.IsRequired && !this.SeenValue)
                {
                    if (this.IsDefault)
                        reporter(string.Format("Missing required argument '<{0}>'.", this.LongName));
                    else
                        reporter(string.Format("Missing required argument '/{0}'.", this.LongName));
                    return true;
                }
                return false;
            }

            private void ReportDuplicateArgumentValue(string value)
            {
                this.reporter(string.Format("Duplicate '{0}' argument '{1}'", this.LongName, value));
            }

            public bool SetValue(string value, object destination)
            {
                if (SeenValue && !AllowMultiple)
                {
                    this.reporter(string.Format("Duplicate '{0}' argument", this.LongName));
                    return false;
                }
                this.seenValue = true;

                object newValue;
                if (!ParseValue(this.ValueType, value, out newValue))
                    return false;
                if (this.IsCollection)
                {
                    if (this.Unique && this.collectionValues.Contains(newValue))
                    {
                        ReportDuplicateArgumentValue(value);
                        return false;
                    }
                    else
                    {
                        this.collectionValues.Add(newValue);
                    }
                }
                else
                {
                    this.field.SetValue(destination, newValue);
                }

                return true;
            }

            public Type ValueType
            {
                get { return this.IsCollection ? this.elementType : this.Type; }
            }

            private void ReportBadArgumentValue(string value)
            {
                this.reporter(string.Format("'{0}' is not a valid value for the '{1}' command line option", value, this.LongName));
            }

            private bool ParseValue(Type type, string stringData, out object value)
            {
                // null is only valid for bool variables
                // empty string is never valid
                if ((stringData != null || type == typeof(bool)) && (stringData == null || stringData.Length > 0))
                {
                    try
                    {
                        if (type == typeof(string))
                        {
                            value = stringData;
                            return true;
                        }
                        else if (type == typeof(bool))
                        {
                            if (stringData == null || stringData == "+")
                            {
                                value = true;
                                return true;
                            }
                            else if (stringData == "-")
                            {
                                value = false;
                                return true;
                            }
                        }
                        else if (type == typeof(int))
                        {
                            value = int.Parse(stringData);
                            return true;
                        }
                        else if (type == typeof(uint))
                        {
                            value = int.Parse(stringData);
                            return true;
                        }
                        else
                        {
                            Debug.Assert(type.IsEnum);

                            bool valid = false;
                            foreach (string name in Enum.GetNames(type))
                            {
                                if (name == stringData)
                                {
                                    valid = true;
                                    break;
                                }
                            }
                            if (valid)
                            {
                                value = Enum.Parse(type, stringData, true);
                                return true;
                            }
                        }
                    }
                    catch
                    {
                        // catch parse errors
                    }
                }

                ReportBadArgumentValue(stringData);
                value = null;
                return false;
            }

            private void AppendValue(StringBuilder builder, object value)
            {
                if (value is string || value is int || value is uint || value.GetType().IsEnum)
                {
                    builder.Append(value.ToString());
                }
                else if (value is bool)
                {
                    builder.Append((bool)value ? "+" : "-");
                }
                else
                {
                    bool first = true;
                    foreach (object o in (System.Array)value)
                    {
                        if (!first)
                        {
                            builder.Append(", ");
                        }
                        AppendValue(builder, o);
                        first = false;
                    }
                }
            }

            public string LongName
            {
                get { return this.longName; }
            }

            public bool ExplicitShortName
            {
                get { return this.explicitShortName; }
            }

            public string ShortName
            {
                get { return this.shortName; }
            }

            public bool HasShortName
            {
                get { return this.shortName != null; }
            }

            public void ClearShortName()
            {
                this.shortName = null;
            }

            public bool HasHelpText
            {
                get { return this.hasHelpText; }
            }

            public string HelpText
            {
                get { return this.helpText; }
            }

            public object DefaultValue
            {
                get { return this.defaultValue; }
            }

            public bool HasDefaultValue
            {
                get { return null != this.defaultValue; }
            }

            public string FullHelpText
            {
                get
                {
                    StringBuilder builder = new StringBuilder();
                    if (this.HasHelpText)
                    {
                        builder.Append(this.HelpText);
                    }
                    if (this.HasDefaultValue)
                    {
                        if (builder.Length > 0)
                            builder.Append(" ");
                        builder.Append("Default value:'");
                        AppendValue(builder, this.DefaultValue);
                        builder.Append('\'');
                    }
                    if (this.HasShortName)
                    {
                        if (builder.Length > 0)
                            builder.Append(" ");
                        builder.Append("(short form /");
                        builder.Append(this.ShortName);
                        builder.Append(")");
                    }
                    return builder.ToString();
                }
            }

            public string SyntaxHelp
            {
                get
                {
                    StringBuilder builder = new StringBuilder();

                    if (this.IsDefault)
                    {
                        builder.Append("<");
                        builder.Append(this.LongName);
                        builder.Append(">");
                    }
                    else
                    {
                        builder.Append("/");
                        builder.Append(this.LongName);
                        Type valueType = this.ValueType;
                        if (valueType == typeof(int))
                        {
                            builder.Append(":<int>");
                        }
                        else if (valueType == typeof(uint))
                        {
                            builder.Append(":<uint>");
                        }
                        else if (valueType == typeof(bool))
                        {
                            builder.Append("[+|-]");
                        }
                        else if (valueType == typeof(string))
                        {
                            builder.Append(":<string>");
                        }
                        else
                        {
                            Debug.Assert(valueType.IsEnum);

                            builder.Append(":{");
                            bool first = true;
                            foreach (FieldInfo field in valueType.GetFields())
                            {
                                if (field.IsStatic)
                                {
                                    if (first)
                                        first = false;
                                    else
                                        builder.Append('|');
                                    builder.Append(field.Name);
                                }
                            }
                            builder.Append('}');
                        }
                    }

                    return builder.ToString();
                }
            }

            public bool IsRequired
            {
                get { return 0 != (this.flags & ArgumentType.Required); }
            }

            public bool SeenValue
            {
                get { return this.seenValue; }
            }

            public bool AllowMultiple
            {
                get { return 0 != (this.flags & ArgumentType.Multiple); }
            }

            public bool Unique
            {
                get { return 0 != (this.flags & ArgumentType.Unique); }
            }

            public Type Type
            {
                get { return field.FieldType; }
            }

            public bool IsCollection
            {
                get { return IsCollectionType(Type); }
            }

            public bool IsDefault
            {
                get { return this.isDefault; }
            }

            private string longName;
            private string shortName;
            private string helpText;
            private bool hasHelpText;
            private bool explicitShortName;
            private object defaultValue;
            private bool seenValue;
            private FieldInfo field;
            private Type elementType;
            private ArgumentType flags;
            private ArrayList collectionValues;
            private ErrorReporter reporter;
            private bool isDefault;
        }

        private ArrayList arguments;
        private Hashtable argumentMap;
        private Argument defaultArgument;
        private ErrorReporter reporter;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Monitoring\LiveConnectPing\WCF\StsTokenProvider.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IdentityModel;
using System.IdentityModel.Selectors;
using System.IdentityModel.Tokens;
using System.Xml;

namespace LiveConnectPing
{
    /// <summary>
    /// 
    /// </summary>
    public class StsTokenProvider: SecurityTokenProvider
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="stsToken"></param>
        public StsTokenProvider(string stsToken)
        {
            this.StsToken = stsToken;
        }

        /// <summary>
        /// 
        /// </summary>
        public string StsToken
        {
            get;
            private set;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="timeout"></param>
        /// <returns></returns>
        protected override SecurityToken GetTokenCore(TimeSpan timeout)
        {
            XmlDocument samlXml = new XmlDocument();

            try
            {
                samlXml.LoadXml(this.StsToken);
            }
            catch (XmlException e)
            {
                throw new ApplicationException("the specified STS token is invalid Xml.", e);
            }
            
            SecurityToken securityToken = new GenericXmlSecurityToken(samlXml.DocumentElement, null, DateTime.MinValue, DateTime.MaxValue, null, null, null);
            return securityToken;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\LCWebService\XblSamlToken.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.ServiceModel;
using System.IdentityModel.Tokens;
using System.ServiceModel.Security;

namespace LiveConnectWeb
{
    /// <summary>
    /// 
    /// </summary>
    public enum XblSamlTokenType: byte
    {
        Console,
        User,
        Partner,
        Machine,
    }

    /// <summary>
    /// platform types, as defined in xonline
    /// </summary>
    public enum Platform: ushort
    {
        Xbox1 = 0,
        Xbox360 = 1,
        PC = 2,
        Web = 3,
        WindowsPhone = 15,
        WebGames = 16,
    }

    public abstract class XblSamlSecurityToken : SamlSecurityToken
    {
        protected const string XblAttributeNamespace = "http://xboxlive.com/claims";
        protected const string UserTokenSubject = "XboxLive User security ticket";

        internal const string PlatformTypeAttribute = "PlatformType";
        internal const string MachineIdAttribute = "MachineID";
        internal const string DeviceIdAttribute = "DeviceID";
        internal const string ClientVersionAttribute = "ClientVersion";
        internal const string TitleIdAttribute = "TitleID";
        internal const string TitleVersionAttribute = "TitleVersion";

        // future place holder
        public static XblSamlSecurityToken Create(String samlToken)
        {
            throw new NotImplementedException();
        }

        public static XblSamlSecurityToken CreateFromSamlToken(SamlSecurityToken samlToken)
        {
            XblSamlSecurityToken returnXblToken = null;
            // ensure assertions and statements w/ at least one element do exist in the token.
            if (samlToken == null ||
                samlToken.Assertion == null ||
                samlToken.Assertion.Statements == null  || 
                samlToken.Assertion.Statements.Count == 0)
            {
                throw new FaultException<SecurityAccessDeniedException>(new SecurityAccessDeniedException("Invalid token."));
            }

            //grabs the first <saml:AttributeStatement> in the token; our (if not all) tokens should only have one
            SamlAttributeStatement statement = samlToken.Assertion.Statements[0] as SamlAttributeStatement;

            if (string.Compare(statement.SamlSubject.Name, XblSamlSecurityToken.UserTokenSubject, true) == 0)
            {
                returnXblToken = new PhoneXmlSamlSecurityToken(samlToken);

                // ensure phone tokens have platform type as windows phone.
                if (returnXblToken.PlatformType != (ushort)Platform.WindowsPhone)
                {
                    throw new FaultException<SecurityAccessDeniedException>(new SecurityAccessDeniedException("Invalid platform type."));
                }

                if(String.IsNullOrEmpty(returnXblToken.DeviceId))
                {
                    throw new FaultException<SecurityAccessDeniedException>(new SecurityAccessDeniedException("Empty or null device id."));
                }
            }
            else
            {
                returnXblToken = new ConsoleXmlSamlSecurityToken(samlToken);

                // ensure phone tokens have platform type as Console.
                if (returnXblToken.PlatformType != (ushort)Platform.Xbox360)
                {
                    throw new FaultException<SecurityAccessDeniedException>(new SecurityAccessDeniedException("Invalid platform type."));
                }
            }

            return returnXblToken;
        }

        public static XblSamlSecurityToken CreateFromSoapRequest()
        {
            // If there is no token, simply return null
            if (OperationContext.Current.IncomingMessageProperties.Security.IncomingSupportingTokens.Count != 1)
            {
                return null;
            }

            // from this point on, any security token validation failure, now that we know it exists, is lethal.
            SamlSecurityToken token = null;

            try
            {
                token = OperationContext.Current.IncomingMessageProperties.Security.IncomingSupportingTokens[0].SecurityToken as SamlSecurityToken;
                
            }
            catch (Exception ex)
            {
                //at this point, if we can't get or parse the token, it's most likely an attack
                throw new FaultException<SecurityAccessDeniedException>(new SecurityAccessDeniedException("No SamlSecurityToken found, despite supporting Tokens being valid", ex));
            }

            if(token != null)
                return CreateFromSamlToken(token);
            return null;
        }

        public virtual XblSamlTokenType TokenType { get; protected set; }

        public virtual ulong Xuid { get; protected set; }

        public virtual string GamerTag { get; protected set; }

        public virtual ushort Tier { get; protected set; }

        public virtual ushort Country { get; protected set; }

        public virtual uint TitleId { get; set; }

        public virtual uint TitleVersion { get; protected set; }

        public virtual ushort ClientVersion { get; protected set; }

        public virtual string MachineId { get; protected set; }

        public virtual ushort PlatformType { get; protected set; }

        public virtual string DeviceId { get; protected set; }

        public virtual ulong Puid { get; protected set; }

        public virtual ulong Cid { get; protected set; }

        public virtual string Privileges { get; protected set; }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="attributes"></param>
        /// <param name="claimName"></param>
        /// <param name="isHex"></param>
        /// <returns></returns>
        protected static ulong ParseUInt64Attribute(IList<SamlAttribute> attributes, string claimName, bool isHex)
        {
            string value = attributes.First(attr => attr.Name.Equals(claimName) && attr.Namespace.Equals(XblAttributeNamespace)).AttributeValues[0];
            return Convert.ToUInt64(value, isHex ? 16 : 10);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="attributes"></param>
        /// <param name="claimName"></param>
        /// <param name="isHex"></param>
        /// <returns></returns>
        protected static uint ParseUInt32Attribute(IList<SamlAttribute> attributes, string claimName, bool isHex)
        {
            string value = attributes.First(attr => attr.Name.Equals(claimName) && attr.Namespace.Equals(XblAttributeNamespace)).AttributeValues[0];
            return Convert.ToUInt32(value, isHex ? 16 : 10);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="attributes"></param>
        /// <param name="claimName"></param>
        /// <param name="isHex"></param>
        /// <returns></returns>
        protected static ushort ParseUInt16Attribute(IList<SamlAttribute> attributes, string claimName, bool isHex)
        {
            string value = attributes.First(attr => attr.Name.Equals(claimName) && attr.Namespace.Equals(XblAttributeNamespace)).AttributeValues[0];
            return Convert.ToUInt16(value, isHex ? 16 : 10);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="attributes"></param>
        /// <param name="claimName"></param>
        /// <returns></returns>
        protected static string ParseStringAttribute(IList<SamlAttribute> attributes, string claimName)
        {
            return attributes.First(attr => attr.Name.Equals(claimName) && attr.Namespace.Equals(XblAttributeNamespace)).AttributeValues[0];
        }

        /// <summary>
        /// 
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="attributes"></param>
        /// <param name="claimName"></param>
        /// <returns></returns>
        protected static T ParseAttributeValue<T>(IList<SamlAttribute> attributes, string claimName)
        {
            string value = attributes.First(attr => attr.Name.Equals(claimName) && attr.Namespace.Equals(XblAttributeNamespace)).AttributeValues[0];
            return (T)Convert.ChangeType(value, typeof(T));
        }
    }

    public class PhoneXmlSamlSecurityToken : XblSamlSecurityToken
    {
        internal const string PuidPhoneAttribute = "Puid0";
        internal const string CidPhoneAttribute = "CID0";
        internal const string XuidPhoneAttribute = "Xuid0";
        internal const string GamertagPhoneAttribute = "Gamertag0";
        internal const string TierPhoneAttribute = "Tier0";
        internal const string CountryPhoneAttribute = "Country0";
        internal const string PrivilegesPhoneAttribute = "Privileges0";
        internal const string PartneridPhoneAttribute = "PartnerID0";

        public PhoneXmlSamlSecurityToken(SamlSecurityToken samlToken)
        {
            this.TokenType = XblSamlTokenType.User;

            IList<SamlAttribute> samlAttributes = (samlToken.Assertion.Statements[0] as SamlAttributeStatement).Attributes;
            try
            {
                // bug: 11643 and 11687
                // the linq queryes (specifically .First call) may result in InvalidOperationException if the item does NOT exist.
                // or the subsequent string to whatever-type does fail w/ a similar exception.
                this.Xuid = ParseUInt64Attribute(samlAttributes, PhoneXmlSamlSecurityToken.XuidPhoneAttribute, false);
                this.GamerTag = ParseStringAttribute(samlAttributes, PhoneXmlSamlSecurityToken.GamertagPhoneAttribute);
                this.PlatformType = ParseUInt16Attribute(samlAttributes, PhoneXmlSamlSecurityToken.PlatformTypeAttribute, false);
                this.MachineId = ParseUInt64Attribute(samlAttributes, PhoneXmlSamlSecurityToken.MachineIdAttribute, false).ToString();
                this.TitleId = ParseUInt32Attribute(samlAttributes, PhoneXmlSamlSecurityToken.TitleIdAttribute, true);
                this.TitleVersion = ParseUInt32Attribute(samlAttributes, PhoneXmlSamlSecurityToken.TitleVersionAttribute, false);
                this.DeviceId = ParseStringAttribute(samlAttributes, PhoneXmlSamlSecurityToken.DeviceIdAttribute);
            }
            catch (InvalidOperationException)
            {
                throw new FaultException<SecurityAccessDeniedException>(new SecurityAccessDeniedException("Missing or Invalid Field."));
            }
        }

        public override ushort Tier { get { throw new NotSupportedException(); } }
        public override ushort Country { get { throw new NotSupportedException(); } }
        public override ushort ClientVersion { get { throw new NotSupportedException(); } }
        public override ulong Puid { get { throw new NotSupportedException(); } }
        public override ulong Cid { get { throw new NotSupportedException(); } }
        public override string Privileges { get { throw new NotSupportedException(); } }
    }

    public class ConsoleXmlSamlSecurityToken : XblSamlSecurityToken
    {
        internal const string PuidConsoleAttribute = "Puid1";
        internal const string CidConsoleAttribute = "CID1";
        internal const string XuidConsoleAttribute = "Xuid1";
        internal const string GamertagConsoleAttribute = "Gamertag1";
        internal const string TierConsoleAttribute = "Tier1";
        internal const string CountryConsoleAttribute = "Country1";
        internal const string PrivilegesConsoleAttribute = "Privileges1";
        internal const string PartneridConsoleAttribute = "PartnerID1";

        public ConsoleXmlSamlSecurityToken(SamlSecurityToken samlToken)
        {
            this.TokenType = XblSamlTokenType.Console;

            IList<SamlAttribute> samlAttributes = (samlToken.Assertion.Statements[0] as SamlAttributeStatement).Attributes;

            try
            {
                // bug: 11643 and 11687
                // the linq queryes (specifically .First call) may result in InvalidOperationException if the item does NOT exist.
                // or the subsequent string to whatever-type does fail w/ a similar exception.
                this.Xuid = ParseUInt64Attribute(samlAttributes, ConsoleXmlSamlSecurityToken.XuidConsoleAttribute, true);
                this.PlatformType = ParseUInt16Attribute(samlAttributes, ConsoleXmlSamlSecurityToken.PlatformTypeAttribute, true);
                this.MachineId = ParseUInt64Attribute(samlAttributes, ConsoleXmlSamlSecurityToken.MachineIdAttribute, true).ToString();
                this.TitleId = ParseUInt32Attribute(samlAttributes, ConsoleXmlSamlSecurityToken.TitleIdAttribute, true);
                this.TitleVersion = ParseUInt32Attribute(samlAttributes, ConsoleXmlSamlSecurityToken.TitleVersionAttribute, true);
            }
            catch (InvalidOperationException)
            {
                throw new FaultException<SecurityAccessDeniedException>(new SecurityAccessDeniedException("Missing or Invalid Field."));
            }
        }

        public override string GamerTag { get { throw new NotSupportedException(); } }
        public override ushort Tier { get { throw new NotSupportedException(); } }
        public override ushort Country { get { throw new NotSupportedException(); } }
        public override ushort ClientVersion { get { throw new NotSupportedException(); } }
        public override ulong Puid { get { throw new NotSupportedException(); } }
        public override ulong Cid { get { throw new NotSupportedException(); } }
        public override string Privileges { get { throw new NotSupportedException(); } }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Monitoring\LiveConnectPing\LiveConnectService.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4016
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace LiveConnectWeb
{
    using System.Runtime.Serialization;


    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "SNUserInfo", Namespace = "http://schemas.datacontract.org/2004/07/LiveConnectWeb")]
    public partial class SNUserInfo : object, System.Runtime.Serialization.IExtensibleDataObject
    {

        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;

        private string GamerTagField;

        private string SNUserIDField;

        private LiveConnectWeb.Visibility VisibilityField;

        private ulong XUIDField;

        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string GamerTag
        {
            get
            {
                return this.GamerTagField;
            }
            set
            {
                this.GamerTagField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string SNUserID
        {
            get
            {
                return this.SNUserIDField;
            }
            set
            {
                this.SNUserIDField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public LiveConnectWeb.Visibility Visibility
        {
            get
            {
                return this.VisibilityField;
            }
            set
            {
                this.VisibilityField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public ulong XUID
        {
            get
            {
                return this.XUIDField;
            }
            set
            {
                this.XUIDField = value;
            }
        }
    }

    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "Visibility", Namespace = "http://schemas.datacontract.org/2004/07/LiveConnectWeb")]
    public enum Visibility : int
    {

        [System.Runtime.Serialization.EnumMemberAttribute()]
        Me = 0,

        [System.Runtime.Serialization.EnumMemberAttribute()]
        Everyone = 1,
    }

    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "SNetworkInfo", Namespace = "http://schemas.datacontract.org/2004/07/LiveConnectWeb")]
    public partial class SNetworkInfo : object, System.Runtime.Serialization.IExtensibleDataObject
    {

        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;

        private string DescriptionField;

        private uint IdField;

        private string LogoField;

        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Description
        {
            get
            {
                return this.DescriptionField;
            }
            set
            {
                this.DescriptionField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public uint Id
        {
            get
            {
                return this.IdField;
            }
            set
            {
                this.IdField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Logo
        {
            get
            {
                return this.LogoField;
            }
            set
            {
                this.LogoField = value;
            }
        }
    }

    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "SNAuthInfo", Namespace = "http://schemas.datacontract.org/2004/07/LiveConnectWeb")]
    public partial class SNAuthInfo : object, System.Runtime.Serialization.IExtensibleDataObject
    {

        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;

        private string SNUserIDField;

        private string TokenField;

        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string SNUserID
        {
            get
            {
                return this.SNUserIDField;
            }
            set
            {
                this.SNUserIDField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Token
        {
            get
            {
                return this.TokenField;
            }
            set
            {
                this.TokenField = value;
            }
        }
    }
}


[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
[System.ServiceModel.ServiceContractAttribute(Namespace = "http://liveconnect.xboxlive.com", ConfigurationName = "ILiveDirectory")]
public interface ILiveDirectory
{

    [System.ServiceModel.OperationContractAttribute(Action = "http://liveconnect.xboxlive.com/ILiveDirectory/SetSNUserInfo", ReplyAction = "http://liveconnect.xboxlive.com/ILiveDirectory/SetSNUserInfoResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/SetSNUserInfoArgumentExceptionFaul" +
        "t", Name = "ArgumentException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentNullException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/SetSNUserInfoArgumentNullException" +
        "Fault", Name = "ArgumentNullException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ServiceModel.Security.SecurityAccessDeniedException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/SetSNUserInfoSecurityAccessDeniedE" +
        "xceptionFault", Name = "SecurityAccessDeniedException", Namespace = "http://schemas.datacontract.org/2004/07/System.ServiceModel.Security")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentOutOfRangeException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/SetSNUserInfoArgumentOutOfRangeExc" +
        "eptionFault", Name = "ArgumentOutOfRangeException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    void SetSNUserInfo(ushort sNetworkId, LiveConnectWeb.SNUserInfo userInfo);

    [System.ServiceModel.OperationContractAttribute(Action = "http://liveconnect.xboxlive.com/ILiveDirectory/RemoveSNUserInfo", ReplyAction = "http://liveconnect.xboxlive.com/ILiveDirectory/RemoveSNUserInfoResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentOutOfRangeException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/RemoveSNUserInfoArgumentOutOfRange" +
        "ExceptionFault", Name = "ArgumentOutOfRangeException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/RemoveSNUserInfoArgumentExceptionF" +
        "ault", Name = "ArgumentException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ServiceModel.Security.SecurityAccessDeniedException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/RemoveSNUserInfoSecurityAccessDeni" +
        "edExceptionFault", Name = "SecurityAccessDeniedException", Namespace = "http://schemas.datacontract.org/2004/07/System.ServiceModel.Security")]
    void RemoveSNUserInfo(ushort sNetworkId, ulong XUID);

    [System.ServiceModel.OperationContractAttribute(Action = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNUserInfoByXUID", ReplyAction = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNUserInfoByXUIDResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNUserInfoByXUIDArgumentExcepti" +
        "onFault", Name = "ArgumentException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentOutOfRangeException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNUserInfoByXUIDArgumentOutOfRa" +
        "ngeExceptionFault", Name = "ArgumentOutOfRangeException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ServiceModel.Security.SecurityAccessDeniedException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNUserInfoByXUIDSecurityAccessD" +
        "eniedExceptionFault", Name = "SecurityAccessDeniedException", Namespace = "http://schemas.datacontract.org/2004/07/System.ServiceModel.Security")]
    LiveConnectWeb.SNUserInfo GetSNUserInfoByXUID(ushort sNetworkId, ulong XUID);

    [System.ServiceModel.OperationContractAttribute(Action = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNUserInfoBySNUId", ReplyAction = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNUserInfoBySNUIdResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNUserInfoBySNUIdArgumentExcept" +
        "ionFault", Name = "ArgumentException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentNullException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNUserInfoBySNUIdArgumentNullEx" +
        "ceptionFault", Name = "ArgumentNullException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ServiceModel.Security.SecurityAccessDeniedException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNUserInfoBySNUIdSecurityAccess" +
        "DeniedExceptionFault", Name = "SecurityAccessDeniedException", Namespace = "http://schemas.datacontract.org/2004/07/System.ServiceModel.Security")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentOutOfRangeException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNUserInfoBySNUIdArgumentOutOfR" +
        "angeExceptionFault", Name = "ArgumentOutOfRangeException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    LiveConnectWeb.SNUserInfo GetSNUserInfoBySNUId(ushort sNetworkId, string snUserId);

    [System.ServiceModel.OperationContractAttribute(Action = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNUserInfos", ReplyAction = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNUserInfosResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNUserInfosArgumentExceptionFau" +
        "lt", Name = "ArgumentException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentNullException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNUserInfosArgumentNullExceptio" +
        "nFault", Name = "ArgumentNullException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentOutOfRangeException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNUserInfosArgumentOutOfRangeEx" +
        "ceptionFault", Name = "ArgumentOutOfRangeException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ServiceModel.Security.SecurityAccessDeniedException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNUserInfosSecurityAccessDenied" +
        "ExceptionFault", Name = "SecurityAccessDeniedException", Namespace = "http://schemas.datacontract.org/2004/07/System.ServiceModel.Security")]
    LiveConnectWeb.SNUserInfo[] GetSNUserInfos(ushort sNetworkId, string[] sNUserIDs);

    [System.ServiceModel.OperationContractAttribute(Action = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNetworkInfo", ReplyAction = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNetworkInfoResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentOutOfRangeException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNetworkInfoArgumentOutOfRangeE" +
        "xceptionFault", Name = "ArgumentOutOfRangeException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    LiveConnectWeb.SNetworkInfo GetSNetworkInfo(ushort sNetworkId);

    [System.ServiceModel.OperationContractAttribute(Action = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNetworkInfos", ReplyAction = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNetworkInfosResponse")]
    LiveConnectWeb.SNetworkInfo[] GetSNetworkInfos();
}

[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
public interface ILiveDirectoryChannel : ILiveDirectory, System.ServiceModel.IClientChannel
{
}

[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
public partial class LiveDirectoryClient : System.ServiceModel.ClientBase<ILiveDirectory>, ILiveDirectory
{

    public LiveDirectoryClient()
    {
    }

    public LiveDirectoryClient(string endpointConfigurationName) :
        base(endpointConfigurationName)
    {
    }

    public LiveDirectoryClient(string endpointConfigurationName, string remoteAddress) :
        base(endpointConfigurationName, remoteAddress)
    {
    }

    public LiveDirectoryClient(string endpointConfigurationName, System.ServiceModel.EndpointAddress remoteAddress) :
        base(endpointConfigurationName, remoteAddress)
    {
    }

    public LiveDirectoryClient(System.ServiceModel.Channels.Binding binding, System.ServiceModel.EndpointAddress remoteAddress) :
        base(binding, remoteAddress)
    {
    }

    public void SetSNUserInfo(ushort sNetworkId, LiveConnectWeb.SNUserInfo userInfo)
    {
        base.Channel.SetSNUserInfo(sNetworkId, userInfo);
    }

    public void RemoveSNUserInfo(ushort sNetworkId, ulong XUID)
    {
        base.Channel.RemoveSNUserInfo(sNetworkId, XUID);
    }

    public LiveConnectWeb.SNUserInfo GetSNUserInfoByXUID(ushort sNetworkId, ulong XUID)
    {
        return base.Channel.GetSNUserInfoByXUID(sNetworkId, XUID);
    }

    public LiveConnectWeb.SNUserInfo GetSNUserInfoBySNUId(ushort sNetworkId, string snUserId)
    {
        return base.Channel.GetSNUserInfoBySNUId(sNetworkId, snUserId);
    }

    public LiveConnectWeb.SNUserInfo[] GetSNUserInfos(ushort sNetworkId, string[] sNUserIDs)
    {
        return base.Channel.GetSNUserInfos(sNetworkId, sNUserIDs);
    }

    public LiveConnectWeb.SNetworkInfo GetSNetworkInfo(ushort sNetworkId)
    {
        return base.Channel.GetSNetworkInfo(sNetworkId);
    }

    public LiveConnectWeb.SNetworkInfo[] GetSNetworkInfos()
    {
        return base.Channel.GetSNetworkInfos();
    }
}

[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
[System.ServiceModel.ServiceContractAttribute(Namespace = "http://liveconnect.xboxlive.com", ConfigurationName = "ILiveAuthentication")]
public interface ILiveAuthentication
{

    [System.ServiceModel.OperationContractAttribute(Action = "http://liveconnect.xboxlive.com/ILiveAuthentication/SetAuthInfo", ReplyAction = "http://liveconnect.xboxlive.com/ILiveAuthentication/SetAuthInfoResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ServiceModel.Security.SecurityAccessDeniedException), Action = "http://liveconnect.xboxlive.com/ILiveAuthentication/SetAuthInfoSecurityAccessDeni" +
        "edExceptionFault", Name = "SecurityAccessDeniedException", Namespace = "http://schemas.datacontract.org/2004/07/System.ServiceModel.Security")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentException), Action = "http://liveconnect.xboxlive.com/ILiveAuthentication/SetAuthInfoArgumentExceptionF" +
        "ault", Name = "ArgumentException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentOutOfRangeException), Action = "http://liveconnect.xboxlive.com/ILiveAuthentication/SetAuthInfoArgumentOutOfRange" +
        "ExceptionFault", Name = "ArgumentOutOfRangeException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentNullException), Action = "http://liveconnect.xboxlive.com/ILiveAuthentication/SetAuthInfoArgumentNullExcept" +
        "ionFault", Name = "ArgumentNullException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    void SetAuthInfo(ushort sNetworkId, ulong XUID, string gamerTag, string deviceId, LiveConnectWeb.SNAuthInfo userInfo, bool addToDirectory, LiveConnectWeb.Visibility visibility);

    [System.ServiceModel.OperationContractAttribute(Action = "http://liveconnect.xboxlive.com/ILiveAuthentication/GetAuthInfo", ReplyAction = "http://liveconnect.xboxlive.com/ILiveAuthentication/GetAuthInfoResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ServiceModel.Security.SecurityAccessDeniedException), Action = "http://liveconnect.xboxlive.com/ILiveAuthentication/GetAuthInfoSecurityAccessDeni" +
        "edExceptionFault", Name = "SecurityAccessDeniedException", Namespace = "http://schemas.datacontract.org/2004/07/System.ServiceModel.Security")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentNullException), Action = "http://liveconnect.xboxlive.com/ILiveAuthentication/GetAuthInfoArgumentNullExcept" +
        "ionFault", Name = "ArgumentNullException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentException), Action = "http://liveconnect.xboxlive.com/ILiveAuthentication/GetAuthInfoArgumentExceptionF" +
        "ault", Name = "ArgumentException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentOutOfRangeException), Action = "http://liveconnect.xboxlive.com/ILiveAuthentication/GetAuthInfoArgumentOutOfRange" +
        "ExceptionFault", Name = "ArgumentOutOfRangeException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    LiveConnectWeb.SNAuthInfo GetAuthInfo(ushort sNetworkId, ulong XUID, string deviceId);

    [System.ServiceModel.OperationContractAttribute(Action = "http://liveconnect.xboxlive.com/ILiveAuthentication/RemoveAuthInfo", ReplyAction = "http://liveconnect.xboxlive.com/ILiveAuthentication/RemoveAuthInfoResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentNullException), Action = "http://liveconnect.xboxlive.com/ILiveAuthentication/RemoveAuthInfoArgumentNullExc" +
        "eptionFault", Name = "ArgumentNullException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentException), Action = "http://liveconnect.xboxlive.com/ILiveAuthentication/RemoveAuthInfoArgumentExcepti" +
        "onFault", Name = "ArgumentException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ServiceModel.Security.SecurityAccessDeniedException), Action = "http://liveconnect.xboxlive.com/ILiveAuthentication/RemoveAuthInfoSecurityAccessD" +
        "eniedExceptionFault", Name = "SecurityAccessDeniedException", Namespace = "http://schemas.datacontract.org/2004/07/System.ServiceModel.Security")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentOutOfRangeException), Action = "http://liveconnect.xboxlive.com/ILiveAuthentication/RemoveAuthInfoArgumentOutOfRa" +
        "ngeExceptionFault", Name = "ArgumentOutOfRangeException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    void RemoveAuthInfo(ushort sNetworkId, ulong XUID, string deviceId);
}

[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
public interface ILiveAuthenticationChannel : ILiveAuthentication, System.ServiceModel.IClientChannel
{
}

[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
public partial class LiveAuthenticationClient : System.ServiceModel.ClientBase<ILiveAuthentication>, ILiveAuthentication
{

    public LiveAuthenticationClient()
    {
    }

    public LiveAuthenticationClient(string endpointConfigurationName) :
        base(endpointConfigurationName)
    {
    }

    public LiveAuthenticationClient(string endpointConfigurationName, string remoteAddress) :
        base(endpointConfigurationName, remoteAddress)
    {
    }

    public LiveAuthenticationClient(string endpointConfigurationName, System.ServiceModel.EndpointAddress remoteAddress) :
        base(endpointConfigurationName, remoteAddress)
    {
    }

    public LiveAuthenticationClient(System.ServiceModel.Channels.Binding binding, System.ServiceModel.EndpointAddress remoteAddress) :
        base(binding, remoteAddress)
    {
    }

    public void SetAuthInfo(ushort sNetworkId, ulong XUID, string gamerTag, string deviceId, LiveConnectWeb.SNAuthInfo userInfo, bool addToDirectory, LiveConnectWeb.Visibility visibility)
    {
        base.Channel.SetAuthInfo(sNetworkId, XUID, gamerTag, deviceId, userInfo, addToDirectory, visibility);
    }

    public LiveConnectWeb.SNAuthInfo GetAuthInfo(ushort sNetworkId, ulong XUID, string deviceId)
    {
        return base.Channel.GetAuthInfo(sNetworkId, XUID, deviceId);
    }

    public void RemoveAuthInfo(ushort sNetworkId, ulong XUID, string deviceId)
    {
        base.Channel.RemoveAuthInfo(sNetworkId, XUID, deviceId);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Monitoring\LiveConnectPing\Utility.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;
using System.Reflection;
using System.IO;

namespace LiveConnectPing
{
    /// <summary>
    /// 
    /// </summary>
    public class Utility
    {
        private static Random rnd = new Random();
        private static object rndLock = new object();
        private static char[] whitespaceChars;
        private static string currentDirectory;
        private static string originalAssemblyDirectory;
        private static char[] gamerTagChars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 ".ToCharArray();        

        /// <summary>
        /// 
        /// </summary>
        static Utility()
        {
            FileInfo assemblyFile = new FileInfo(new Uri(Assembly.GetExecutingAssembly().CodeBase).LocalPath);
            currentDirectory = assemblyFile.DirectoryName;
            originalAssemblyDirectory = String.IsNullOrEmpty(AppDomain.CurrentDomain.SetupInformation.PrivateBinPath) ? String.Empty : AppDomain.CurrentDomain.SetupInformation.PrivateBinPath;
            if (!Directory.Exists(originalAssemblyDirectory))
            {
                originalAssemblyDirectory = String.Empty;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        private static char[] WhitespaceChars
        {
            get
            {
                if (whitespaceChars == null)
                {
                    Type stringType = typeof(string);
                    object chars = stringType.InvokeMember("WhitespaceChars", BindingFlags.GetField | BindingFlags.NonPublic | BindingFlags.Static, null, null, null);
                    whitespaceChars = chars as char[];
                }

                return whitespaceChars;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public static Random GlobalRandom
        {
            get
            {
                //NOTE: NOT thread safe!
                return rnd;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public static string CurrentDirectory
        {
            get
            {
                return currentDirectory;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public static string OriginalAssemblyDirectory
        {
            get
            {
                return originalAssemblyDirectory;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="max"></param>
        /// <returns></returns>
        public static int GenerateRandomNumber(int max)
        {
            lock (rndLock)
            {
                return rnd.Next(max);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="min"></param>
        /// <param name="max"></param>
        /// <returns></returns>
        public static int GenerateRandomNumber(int min, int max)
        {
            lock (rndLock)
            {
                return rnd.Next(min, max);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="length"></param>
        /// <returns></returns>
        public static string GenerateRandomString()
        {
            return GenerateRandomString(GenerateRandomNumber(1024));
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="length"></param>
        /// <returns></returns>
        public static string GenerateRandomString(int length)
        {
            return GenerateRandomString(length, null);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="length"></param>
        /// <returns></returns>
        public static string GenerateRandomString(int length, char[] excludeChars)
        {
            StringBuilder value = new StringBuilder(length);
            for (int i = 0; i < length; )
            {
                char temp = (char)GenerateRandomNumber(127);    //(char)GenerateRandomNumber(33, 127);
                if (!char.IsControl(temp) && (excludeChars == null || !excludeChars.Contains<char>(temp)))
                {
                    value.Append(temp);
                    i++;
                }
            }

            return value.ToString().Trim();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public static ulong GenerateRandomUInt64()
        {
            byte[] buffer = new byte[sizeof(ulong)];
            RNGCryptoServiceProvider rng = new RNGCryptoServiceProvider();
            rng.GetNonZeroBytes(buffer);
            return BitConverter.ToUInt64(buffer, 0);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public static uint GenerateRandomUInt32()
        {
            byte[] buffer = new byte[sizeof(uint)];
            RNGCryptoServiceProvider rng = new RNGCryptoServiceProvider();
            rng.GetNonZeroBytes(buffer);
            return BitConverter.ToUInt32(buffer, 0);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="array"></param>
        /// <returns></returns>
        public static string ArrayToString(Array array)
        {
            return ArrayToString(array, ", ");
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="array"></param>
        /// <returns></returns>
        public static string ArrayToString(Array array, string divider)
        {
            StringBuilder values = new StringBuilder();
            foreach (object obj in array)
            {
                values.Append(obj);
                values.Append(divider);
            }

            values.Length -= divider.Length;
            return values.ToString();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="length"></param>
        /// <returns></returns>
        public static string WhitespaceString(int length)
        {
            StringBuilder whitespace = new StringBuilder(length);
            Random rnd = new Random(unchecked((int)DateTime.Now.Ticks));

            for (int i = 0; i < length; i++)
                whitespace.Append(WhitespaceChars[rnd.Next(WhitespaceChars.Length)]);
            return whitespace.ToString();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="input"></param>    
        /// <returns></returns>
        public static string AppendWhitespace(object input)
        {
            return AppendWhitespace(input, true, true);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="input"></param>
        /// <param name="before"></param>
        /// <param name="after"></param>
        /// <returns></returns>
        public static string AppendWhitespace(object input, bool before, bool after)
        {
            StringBuilder newString = new StringBuilder(input.ToString());
            Random rnd = new Random(unchecked((int)DateTime.Now.Ticks));

            if (before)
                newString.Insert(0, WhitespaceString(rnd.Next(1, 5)));
            if (after)
                newString.Append(WhitespaceString(rnd.Next(1, 5)));
            return newString.ToString();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="length"></param>
        /// <returns></returns>
        public static string GenerateUnicodeString(int length)
        {
            StringBuilder sb = new StringBuilder();
            while (sb.Length < length)
            {
                char c = (char)GenerateRandomNumber(0x20, 0xfff0);
                if ((((c < '') || (c > '')) && ((c < 0xd800) || (c > 0xdfff))) && (((c < 0xe000) || (c > 0xf8ff)) && (c != 0xfeff)))
                {
                    sb.Append(c);
                }
            }
            return sb.ToString();

        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public static string GenerateRandomGamerTag(int length)
        {
            StringBuilder gamerTag = new StringBuilder(length);
            gamerTag.Append(gamerTagChars[Utility.GlobalRandom.Next(51)]);  //first char can't be a number/space

            int i = 0;
            while (i < length)
            {
                char nextChar = gamerTagChars[Utility.GlobalRandom.Next(gamerTagChars.Length - 1)];
                if (nextChar == ' ' && gamerTag[gamerTag.Length - 1] == ' ') //can't have consecutive spaces
                    continue;
                gamerTag.Append(nextChar);
                i++;
            }

            return gamerTag.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Monitoring\LiveConnectPing\Program.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using System.Diagnostics;
using System.ServiceModel;
using System.ServiceModel.Security;
using System.Configuration;
using System.Net;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;

using LiveConnectWeb;
using CommandLine;

namespace LiveConnectPing
{
    /// <summary>
    /// 
    /// </summary>
    class Program
    {
        private const string LiveConnectPingEventSource = "LiveConnectPing";
        private const byte WindowsPhonePlatform = 15;
        private static char[] BadSnuidChars = "<>:\",\\".ToCharArray();
        private static string Hostname;
        private static StsToken stsTokenGen;

        /// <summary>
        /// 
        /// </summary>
        public enum SocialNetwork: ushort
        {
            WindowsLiveSpaces = 1,
            Facebook,
            Twitter,
        }

        /// <summary>
        /// 
        /// </summary>
        [Flags]
        public enum LiveConnectErrors : int
        {
            None = 0x0,
            SmokeTest = 0x1,
            DirectorySts = 0x2,
            AuthSts = 0x4,
            DirectoryCert = 0x10,
            AuthCert = 0x20,
            AuthTwitter = 0x40,
            Unknown = 0x80,
            InvalidArgs = 0x100,
            InvalidClientCert = 0x200,
            DirectoryWP7 = 0x400,
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="args"></param>
        static void Main(string[] args)
        {
            LiveConnectErrors errors = LiveConnectErrors.None;

            try
            {
                LiveConnectPingArguments lcArgs = new LiveConnectPingArguments();
                if (!Parser.ParseArgumentsWithUsage(args, lcArgs))
                {
                    TraceEx.TraceError(7000, "Invalid argument(s) provided: {0}", Environment.CommandLine);
                    errors = LiveConnectErrors.InvalidArgs;
                    return;
                }

                Hostname = lcArgs.Hostname;
                if(lcArgs.IgnoreServerSslErrors)
                    ServicePointManager.ServerCertificateValidationCallback = (sender, certificate, chain, sslPolicyErrors) => true;

                if (!EventLog.SourceExists(LiveConnectPingEventSource))
                {
                    EventLog.CreateEventSource(LiveConnectPingEventSource, "Application");
                    Trace.TraceInformation("***Added LiveConnectPing event source to Application log.");
                }

                //validate that the required client cert is installed and that the private key is accessible
                if (!ValidateClientCert())
                {
                    errors = LiveConnectErrors.InvalidClientCert;
                    return;
                }

                stsTokenGen = new StsToken(ConfigurationManager.AppSettings["ClientCertSubject"]);

                if (!SmokeTest())
                    errors |= LiveConnectErrors.SmokeTest;
                //sts token auth
                if (!DirectoryTest(Authentication.ConsoleStsToken))
                    errors |= LiveConnectErrors.DirectorySts;
                if (!AuthenticationTest(Authentication.ConsoleStsToken))
                    errors |= LiveConnectErrors.AuthSts;
                //client cert auth
                if (!DirectoryTest(Authentication.ClientCertificate))
                    errors |= LiveConnectErrors.DirectoryCert;
                if (!AuthenticationTest(Authentication.ClientCertificate))
                    errors |= LiveConnectErrors.AuthCert;
                //twitter-specific case
                if (!TwitterAuthenticationTest())
                    errors |= LiveConnectErrors.AuthTwitter;             
                //WP7/MCB specific case
                if (!WP7DirectoryTest())
                    errors |= LiveConnectErrors.DirectoryWP7;
            }
            catch (Exception e)
            {
                TraceEx.TraceError(6000, "Unexpected exception occurred;\r\n\r\n{0}", e.ToString());
                errors |= LiveConnectErrors.Unknown;
            }
            finally
            {
                string message;
                if (errors == LiveConnectErrors.None)
                    message = "LiveConnectPing successfully completed with no errors.";
                else
                    message = String.Format("LiveConnectPing finished with the following error code(s): {0}.  Review previous error events for more details.", ((int)errors));
                
                Trace.TraceInformation(message);
                Environment.Exit((int)errors);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        private static bool ValidateClientCert()
        {
            string subject = ConfigurationManager.AppSettings["ClientCertSubject"];
            X509Store localMachine = null;
            bool success = true;

            try
            {
                TraceEx.TraceVerbose("Attempting to validate that the required client certificate (CN={0}) is installed and that the private key is available/accessible.", subject);
                localMachine = new X509Store(StoreName.My, StoreLocation.LocalMachine);
                localMachine.Open(OpenFlags.ReadOnly);
                X509Certificate2Collection matches = localMachine.Certificates.Find(X509FindType.FindBySubjectName, subject, false);

                if (matches == null || matches.Count == 0)
                {
                    TraceEx.TraceError(8000, "No client certificate matching subject '{0}' were found in LOCAL_MACHINE\\My.", subject);
                    success = false;
                }
                else if (matches.Count > 1)
                {
                    TraceEx.TraceError(8000, "{0} client certificates were found, matching subject '{1}', in LOCAL_MACHINE\\My.  Remove any bad/expired certificates and try again.", matches.Count, subject);
                    success = false;
                }
                else if (!matches[0].HasPrivateKey || !(matches[0].PrivateKey is RSACryptoServiceProvider))
                {
                    TraceEx.TraceError(8000, "The specified client certificate, matching subject '{0}', does not contain or have access to private key material.  Verify that the certificate PFX was correctly installed and that the account running this application has appropriate access.", subject);
                    success = false;
                }
        
                TraceEx.TraceVerbose("Successfully verified client certificate.");
            }
            catch
            {
                success = false;
            }
            finally
            {
                if (localMachine != null)
                    localMachine.Close();                
            }

            return success;
        }

        /// <summary>
        /// 
        /// </summary>
        private static bool SmokeTest()
        {
            try
            {
                TraceEx.TraceStart("Starting Smoke Page Validation.");
                string url = String.Format("https://{0}/smoke.aspx", Hostname);
                TraceEx.TraceVerbose("Using Smoke Page Url: {0}", url);

                using (WebClient client = new WebClient())
                {
                    client.DownloadString(url);
                }

                TraceEx.TraceVerbose("Successfully Validated Smoke Page.");
                return true;
            }
            catch (Exception e)
            {
                string message = String.Format("Error validating Smoke page:\r\n\r\n{0}", e.ToString());
                TraceEx.TraceError(1000, message);
                return false;
            }
            finally
            {
                TraceEx.TraceStop("Finished Smoke Page Validation.");
            }
        }

        /// <summary>
        /// Executes a suite of LiveConnect Directory tests, using client certificate or console STS token auth.
        /// </summary>
        /// <param name="useCertAuth"></param>
        private static bool DirectoryTest(Authentication authMode)
        {
            LiveDirectoryClient directoryClient = null;
            bool success = true;

            try
            {
                TraceEx.TraceStart("Starting Live Connect Directory Validation (using {0} authentication).", GetAuthModeText(authMode)); 
                directoryClient = new LiveDirectoryClient((authMode == Authentication.ClientCertificate ? "LiveDirectoryCert" : "LiveDirectorySts"));
                directoryClient.Endpoint.Address = new EndpointAddress(UpdateClientEndpoint(directoryClient), directoryClient.Endpoint.Address.Identity, directoryClient.Endpoint.Address.Headers);
                TraceEx.TraceVerbose("Using Live Connect Endpoint \"{0}\", at {1}", directoryClient.Endpoint.Name, directoryClient.Endpoint.Address.Uri);

                SNUserInfo userInfo = new SNUserInfo();
                userInfo.SNUserID = "PingTest-" + Utility.GenerateRandomString(10, BadSnuidChars);
                userInfo.GamerTag = Utility.GenerateRandomString(10);
                userInfo.XUID = Utility.GenerateRandomUInt64();
                userInfo.Visibility = Visibility.Everyone;

                if (authMode == Authentication.ConsoleStsToken)
                {
                    StsTokenParameters stsParameters = new StsTokenParameters() { Xuid = userInfo.XUID, TitleId = NetworkToTitleID((ushort)SocialNetwork.Facebook) };
                    ConfigureStsAuth(directoryClient, authMode, stsParameters);
                }

                try
                {
                    TraceEx.TraceVerbose("Opening channel...");
                    directoryClient.Open();
                    TraceEx.TraceVerbose("Calling SetSNUserInfo with UserID={0}, XUID={1}, GamerTag={2}, Visibility={3}, Network=Facebook",
                                                userInfo.SNUserID,
                                                userInfo.XUID,
                                                userInfo.GamerTag,
                                                userInfo.Visibility);
                    directoryClient.SetSNUserInfo((ushort)SocialNetwork.Facebook, userInfo);
                }
                catch (Exception e)
                {
                    HandleError("SetSNUserInfo", authMode, e);
                    success = false;
                }

                try
                {
                    TraceEx.TraceVerbose("Calling GetSNUserInfoBySNUId with UserID={0}, Network=Facebook", userInfo.SNUserID);
                    SNUserInfo actualUserInfo = directoryClient.GetSNUserInfoBySNUId((ushort)SocialNetwork.Facebook, userInfo.SNUserID);
                    if (userInfo.SNUserID != actualUserInfo.SNUserID)
                        throw new ValidationException("SNUserInfo returned from GetSNUserInfoBySNUId does not match the original value; expected SNUserID {0}, got {1}.", userInfo.SNUserID, actualUserInfo.SNUserID);
                    if (userInfo.GamerTag != actualUserInfo.GamerTag)
                        throw new ValidationException("SNUserInfo returned from GetSNUserInfoBySNUId does not match the original value; expected GamerTag {0}, got {1}.", userInfo.GamerTag, actualUserInfo.GamerTag);
                    if (userInfo.XUID != actualUserInfo.XUID)
                        throw new ValidationException("SNUserInfo returned from GetSNUserInfoBySNUId does not match the original value; expected XUID {0}, got {1}.", userInfo.XUID, actualUserInfo.XUID);
                    if (userInfo.Visibility != actualUserInfo.Visibility)
                        throw new ValidationException("SNUserInfo returned from GetSNUserInfoBySNUId does not match the original value; expected Visibility {0}, got {1}.", userInfo.Visibility, actualUserInfo.Visibility);
                }
                catch (Exception e)
                {
                    HandleError("GetSNUserInfoBySNUId", authMode, e);
                    success = false;
                }

                try
                {
                    TraceEx.TraceVerbose("Calling GetSNUserInfoByXUID with XUID={0}, Network=Facebook", userInfo.XUID);
                    SNUserInfo actualUserInfo = directoryClient.GetSNUserInfoByXUID((ushort)SocialNetwork.Facebook, userInfo.XUID);
                    if (userInfo.SNUserID != actualUserInfo.SNUserID)
                        throw new ValidationException("SNUserInfo returned from GetSNUserInfoByXUID does not match the original value; expected SNUserID {0}, got {1}.", userInfo.SNUserID, actualUserInfo.SNUserID);
                    if (userInfo.GamerTag != actualUserInfo.GamerTag)
                        throw new ValidationException("SNUserInfo returned from GetSNUserInfoByXUID does not match the original value; expected GamerTag {0}, got {1}.", userInfo.GamerTag, actualUserInfo.GamerTag);
                    if (userInfo.XUID != actualUserInfo.XUID)
                        throw new ValidationException("SNUserInfo returned from GetSNUserInfoByXUID does not match the original value; expected XUID {0}, got {1}.", userInfo.XUID, actualUserInfo.XUID);
                    if (userInfo.Visibility != actualUserInfo.Visibility)
                        throw new ValidationException("SNUserInfo returned from GetSNUserInfoByXUID does not match the original value; expected Visibility {0}, got {1}.", userInfo.Visibility, actualUserInfo.Visibility);
                }
                catch (Exception e)
                {
                    HandleError("GetSNUserInfoByXUID", authMode, e);
                    success = false;
                }

                try
                {
                    TraceEx.TraceVerbose("Calling GetSNUserInfos with UserID={0}, Network=Facebook", userInfo.SNUserID);
                    SNUserInfo[] actualUserInfos = directoryClient.GetSNUserInfos((ushort)SocialNetwork.Facebook, new string[] { userInfo.SNUserID });
                    if (actualUserInfos.Length != 1)
                        throw new ValidationException("Expected GetSNUserInfos to return 1 user, but got {0}", actualUserInfos.Length);
                    if (userInfo.SNUserID != actualUserInfos[0].SNUserID)
                        throw new ValidationException("SNUserInfo returned from GetSNUserInfos does not match the original value; expected SNUserID {0}, got {1}.", userInfo.SNUserID, actualUserInfos[0].SNUserID);
                    if (userInfo.GamerTag != actualUserInfos[0].GamerTag)
                        throw new ValidationException("SNUserInfo returned from GetSNUserInfos does not match the original value; expected GamerTag {0}, got {1}.", userInfo.GamerTag, actualUserInfos[0].GamerTag);
                    if (userInfo.XUID != actualUserInfos[0].XUID)
                        throw new ValidationException("SNUserInfo returned from GetSNUserInfos does not match the original value; expected XUID {0}, got {1}.", userInfo.XUID, actualUserInfos[0].XUID);
                    if (userInfo.Visibility != actualUserInfos[0].Visibility)
                        throw new ValidationException("SNUserInfo returned from GetSNUserInfos does not match the original value; expected Visibility {0}, got {1}.", userInfo.Visibility, actualUserInfos[0].Visibility);
                }
                catch (Exception e)
                {
                    HandleError("GetSNUserInfos", authMode, e);
                    success = false;
                }

                try
                {
                    TraceEx.TraceVerbose("Calling RemoveSNUserInfo with XUID={0}, Network=Facebook", userInfo.XUID);
                    directoryClient.RemoveSNUserInfo((ushort)SocialNetwork.Facebook, userInfo.XUID);
                }
                catch (Exception e)
                {
                    HandleError("RemoveSNUserInfo", authMode, e);
                    success = false;
                }

                TraceEx.TraceVerbose("Successfully validated Live Connect Directory service.");
            }
            finally
            {
                TraceEx.TraceStop("Finished Live Connect Directory Validation.");
                directoryClient.CloseConnection();
            }

            return success;
        }

        /// <summary>
        /// Executes a suite of LiveConnect Authentication tests, using client certificate and console STS token auth.
        /// </summary>
        /// <param name="useCertAuth"></param>
        private static bool AuthenticationTest(Authentication authMode)
        {
            LiveAuthenticationClient authClient = null;
            bool success = true;

            try
            {
                TraceEx.TraceStart("Starting Live Connect Authentication Validation (using {0} authentication).", GetAuthModeText(authMode));
                authClient = new LiveAuthenticationClient((authMode == Authentication.ClientCertificate ? "LiveAuthenticationCert" : "LiveAuthenticationSts"));
                authClient.Endpoint.Address = new EndpointAddress(UpdateClientEndpoint(authClient), authClient.Endpoint.Address.Identity, authClient.Endpoint.Address.Headers);
                TraceEx.TraceVerbose("Using Live Connect Authentication Endpoint \"{0}\", at {1}", authClient.Endpoint.Name, authClient.Endpoint.Address.Uri);

                SNUserInfo userInfo = new SNUserInfo();
                userInfo.SNUserID = "PingTest-" + Utility.GenerateRandomString(10, BadSnuidChars);
                userInfo.GamerTag = Utility.GenerateRandomString(10);
                userInfo.XUID = Utility.GenerateRandomUInt64();
                userInfo.Visibility = Visibility.Everyone;

                string deviceId = Utility.GenerateRandomUInt64().ToString();

                SNAuthInfo authInfo = new SNAuthInfo();
                authInfo.SNUserID = userInfo.SNUserID;
                authInfo.Token = Utility.GenerateRandomString(150);

                if (authMode == Authentication.ConsoleStsToken)
                {
                    StsTokenParameters stsParameters = new StsTokenParameters() { Xuid = userInfo.XUID, TitleId = NetworkToTitleID((ushort)SocialNetwork.Twitter), MachineId=ulong.Parse(deviceId) };
                    ConfigureStsAuth(authClient, authMode, stsParameters);
                }

                try
                {
                    TraceEx.TraceVerbose("Opening channel...");
                    authClient.Open();
                    TraceEx.TraceVerbose("Calling SetAuthInfo with XUID={0}, GamerTag={1}, DeviceID={2}, Token={3}, Visibility={4}, Network=Twitter", 
                                                userInfo.XUID,
                                                userInfo.GamerTag,
                                                deviceId,
                                                authInfo.Token,
                                                userInfo.Visibility);
                    authClient.SetAuthInfo((ushort)SocialNetwork.Twitter, userInfo.XUID, userInfo.GamerTag, deviceId, authInfo, true, userInfo.Visibility);
                }
                catch (Exception e)
                {
                    HandleError("SetAuthInfo", authMode, e);
                    success = false;
                }

                try
                {
                    TraceEx.TraceVerbose("Calling GetAuthInfo with XUID={0}, DeviceID={1}, Network=Twitter", userInfo.XUID, deviceId);
                    SNAuthInfo actualAuthInfo = authClient.GetAuthInfo((ushort)SocialNetwork.Twitter, userInfo.XUID, deviceId);
                    if (authInfo.SNUserID != actualAuthInfo.SNUserID)
                        throw new ValidationException("SNAuthInfo returned from GetAuthInfo does not match the original value; expected SNUserID {0}, got {1}.", authInfo.SNUserID, actualAuthInfo.SNUserID);
                    if (authInfo.Token != actualAuthInfo.Token)
                        throw new ValidationException("SNAuthInfo returned from GetAuthInfo does not match the original value; expected Token {0}, got {1}.", authInfo.Token, actualAuthInfo.Token);                    
                }
                catch (Exception e)
                {
                    HandleError("GetAuthInfo", authMode, e);
                    success = false;
                }
                                
                try
                {
                    TraceEx.TraceVerbose("Calling RemoveAuthInfo with XUID={0}, DeviceID={1}, Network=Twitter", userInfo.XUID, deviceId);
                    authClient.RemoveAuthInfo((ushort)SocialNetwork.Twitter, userInfo.XUID, deviceId);
                }
                catch (Exception e)
                {
                    HandleError("RemoveAuthInfo", authMode, e);
                    success = false;
                }

                TraceEx.TraceVerbose("Successfully validated Live Connect Authentication service.");
            }
            finally
            {
                TraceEx.TraceStop("Finished Live Connect Authentication Validation.");
                authClient.CloseConnection();
            }

            return success;
        }

        /// <summary>
        /// 
        /// </summary>
        private static bool TwitterAuthenticationTest()
        {
            LiveAuthenticationClient authClient = null;
            bool success = true;

            try
            {
                TraceEx.TraceStart("Starting Live Connect Twitter Authentication Validation (using STS token authentication).");
                authClient = new LiveAuthenticationClient("LiveAuthenticationSts");
                authClient.Endpoint.Address = new EndpointAddress(UpdateClientEndpoint(authClient), authClient.Endpoint.Address.Identity, authClient.Endpoint.Address.Headers);
                TraceEx.TraceVerbose("Using Live Connect Authentication Endpoint \"{0}\", at {1}", authClient.Endpoint.Name, authClient.Endpoint.Address.Uri);

                SNUserInfo userInfo = new SNUserInfo();
                userInfo.SNUserID = "PingTest-" + Utility.GenerateRandomString(10, BadSnuidChars);
                userInfo.GamerTag = Utility.GenerateRandomString(10);
                userInfo.XUID = 0;  //Twitter special case value; Lua can't easily deal w/ ulong...
                userInfo.Visibility = Visibility.Everyone;

                ulong stsXuid = Utility.GenerateRandomUInt64();
                string stsMachineId = Utility.GenerateRandomUInt64().ToString();

                SNAuthInfo authInfo = new SNAuthInfo();
                authInfo.SNUserID = userInfo.SNUserID;
                authInfo.Token = Utility.GenerateRandomString(150);

                StsTokenParameters stsParameters = new StsTokenParameters() { Xuid = stsXuid, TitleId = NetworkToTitleID((ushort)SocialNetwork.Twitter), MachineId = ulong.Parse(stsMachineId) };
                ConfigureStsAuth(authClient, Authentication.ConsoleStsToken, stsParameters);
               
                try
                {
                    TraceEx.TraceVerbose("Opening channel...");
                    authClient.Open();
                    TraceEx.TraceVerbose("Calling SetAuthInfo with XUID={0}, GamerTag={1}, DeviceID=NULL, Token={2}, Visibility={3}, Network=Twitter",
                                                userInfo.XUID,
                                                userInfo.GamerTag,
                                                authInfo.Token,
                                                userInfo.Visibility);
                    authClient.SetAuthInfo((ushort)SocialNetwork.Twitter, userInfo.XUID, userInfo.GamerTag, null, authInfo, true, userInfo.Visibility);
                }
                catch (Exception e)
                {
                    HandleError("SetAuthInfo", Authentication.ConsoleStsToken, e);
                    success = false;
                }

                try
                {
                    TraceEx.TraceVerbose("Calling GetAuthInfo with XUID={0}, DeviceID={1}, Network=Twitter", stsXuid, stsMachineId);
                    SNAuthInfo actualAuthInfo = authClient.GetAuthInfo((ushort)SocialNetwork.Twitter, stsXuid, stsMachineId);
                    if (authInfo.SNUserID != actualAuthInfo.SNUserID)
                        throw new ValidationException("SNAuthInfo returned from GetAuthInfo does not match the original value; expected SNUserID {0}, got {1}.", authInfo.SNUserID, actualAuthInfo.SNUserID);
                    if (authInfo.Token != actualAuthInfo.Token)
                        throw new ValidationException("SNAuthInfo returned from GetAuthInfo does not match the original value; expected Token {0}, got {1}.", authInfo.Token, actualAuthInfo.Token);
                }
                catch (Exception e)
                {
                    HandleError("GetAuthInfo", Authentication.ConsoleStsToken, e);
                    success = false;
                }

                try
                {
                    TraceEx.TraceVerbose("Calling RemoveAuthInfo with XUID={0}, DeviceID={1}, Network=Twitter", stsXuid, stsMachineId);
                    authClient.RemoveAuthInfo((ushort)SocialNetwork.Twitter, stsXuid, stsMachineId);
                }
                catch (Exception e)
                {
                    HandleError("RemoveAuthInfo", Authentication.ConsoleStsToken, e);
                    success = false;
                }

                TraceEx.TraceVerbose("Successfully validated Live Connect Twitter Authentication service.");
            }
            finally
            {
                TraceEx.TraceStop("Finished Live Connect Twitter Authentication Validation.");
                authClient.CloseConnection();
            }

            return success;
        }

        /// <summary>
        /// Specific test for MCB/WP7 clients, which use user token STS auth.
        /// </summary>
        /// <returns></returns>
        private static bool WP7DirectoryTest()
        {
            LiveDirectoryClient directoryClient = null;
            bool success = true;

            try
            {
                TraceEx.TraceStart("Starting Live Connect WP7 Directory Validation (using STS user token authentication).");
                directoryClient = new LiveDirectoryClient("LiveDirectorySts");
                directoryClient.Endpoint.Address = new EndpointAddress(UpdateClientEndpoint(directoryClient), directoryClient.Endpoint.Address.Identity, directoryClient.Endpoint.Address.Headers);
                TraceEx.TraceVerbose("Using Live Connect Endpoint \"{0}\", at {1}", directoryClient.Endpoint.Name, directoryClient.Endpoint.Address.Uri);

                SNUserInfo userInfo = new SNUserInfo();
                userInfo.SNUserID = "PingTest-" + Utility.GenerateRandomString(10, BadSnuidChars);
                userInfo.GamerTag = Utility.GenerateRandomString(10);
                userInfo.XUID = Utility.GenerateRandomUInt64();
                userInfo.Visibility = Visibility.Everyone;

                StsTokenParameters stsParameters = new StsTokenParameters() { Xuid = userInfo.XUID, TitleId = (uint)XboxTitle.WP7GamesHub, TitleVersion = "1", PlatformType = WindowsPhonePlatform.ToString(), GamerTag = userInfo.GamerTag };
                ConfigureStsAuth(directoryClient, Authentication.UserStsToken, stsParameters);
                
                try
                {
                    TraceEx.TraceVerbose("Opening channel...");
                    directoryClient.Open();
                    TraceEx.TraceVerbose("Calling SetSNUserInfo with UserID={0}, XUID={1}, GamerTag={2}, Visibility={3}, Network=Facebook",
                                                userInfo.SNUserID,
                                                userInfo.XUID,
                                                userInfo.GamerTag,
                                                userInfo.Visibility);
                    directoryClient.SetSNUserInfo((ushort)SocialNetwork.Facebook, userInfo);
                }
                catch (Exception e)
                {
                    HandleError("SetSNUserInfo", Authentication.UserStsToken, e);
                    success = false;
                }

                try
                {
                    TraceEx.TraceVerbose("Calling GetSNUserInfoBySNUId with UserID={0}, Network=Facebook", userInfo.SNUserID);
                    SNUserInfo actualUserInfo = directoryClient.GetSNUserInfoBySNUId((ushort)SocialNetwork.Facebook, userInfo.SNUserID);
                    if (userInfo.SNUserID != actualUserInfo.SNUserID)
                        throw new ValidationException("SNUserInfo returned from GetSNUserInfoBySNUId does not match the original value; expected SNUserID {0}, got {1}.", userInfo.SNUserID, actualUserInfo.SNUserID);
                    if (userInfo.GamerTag != actualUserInfo.GamerTag)
                        throw new ValidationException("SNUserInfo returned from GetSNUserInfoBySNUId does not match the original value; expected GamerTag {0}, got {1}.", userInfo.GamerTag, actualUserInfo.GamerTag);
                    if (userInfo.XUID != actualUserInfo.XUID)
                        throw new ValidationException("SNUserInfo returned from GetSNUserInfoBySNUId does not match the original value; expected XUID {0}, got {1}.", userInfo.XUID, actualUserInfo.XUID);
                    if (userInfo.Visibility != actualUserInfo.Visibility)
                        throw new ValidationException("SNUserInfo returned from GetSNUserInfoBySNUId does not match the original value; expected Visibility {0}, got {1}.", userInfo.Visibility, actualUserInfo.Visibility);
                }
                catch (Exception e)
                {
                    HandleError("GetSNUserInfoBySNUId", Authentication.UserStsToken, e);
                    success = false;
                }
                finally
                {
                    directoryClient.CloseConnection();
                }

                //reset the client, to send a new gamertag in the token, in the call to GetSNUserInfos
                //this should update in the database
                directoryClient = new LiveDirectoryClient("LiveDirectorySts");
                directoryClient.Endpoint.Address = new EndpointAddress(UpdateClientEndpoint(directoryClient), directoryClient.Endpoint.Address.Identity, directoryClient.Endpoint.Address.Headers);
                
                string newGamerTag = Utility.GenerateRandomGamerTag(10);
                stsParameters.GamerTag = newGamerTag;
                ConfigureStsAuth(directoryClient, Authentication.UserStsToken, stsParameters);
                
                try
                {
                    TraceEx.TraceVerbose("Calling GetSNUserInfos with UserID={0}, Network=Facebook", userInfo.SNUserID);
                    SNUserInfo[] actualUserInfos = directoryClient.GetSNUserInfos((ushort)SocialNetwork.Facebook, new string[] { userInfo.SNUserID });
                    if (actualUserInfos.Length != 1)
                        throw new ValidationException("Expected GetSNUserInfos to return 1 user, but got {0}", actualUserInfos.Length);
                    if (userInfo.SNUserID != actualUserInfos[0].SNUserID)
                        throw new ValidationException("SNUserInfo returned from GetSNUserInfos does not match the original value; expected SNUserID {0}, got {1}.", userInfo.SNUserID, actualUserInfos[0].SNUserID);
                    if (userInfo.GamerTag != actualUserInfos[0].GamerTag)
                        throw new ValidationException("SNUserInfo returned from GetSNUserInfos does not match the original value; expected GamerTag {0}, got {1}.", userInfo.GamerTag, actualUserInfos[0].GamerTag);
                    //NOTE: special WP7 case; we zero out the xuid for user token calls to GetSNUserInfos
                    if (actualUserInfos[0].XUID != 0)
                        throw new ValidationException("SNUserInfo returned from GetSNUserInfos does not match the original value; expected XUID {0}, got {1}.", userInfo.XUID, actualUserInfos[0].XUID);
                    if (userInfo.Visibility != actualUserInfos[0].Visibility)
                        throw new ValidationException("SNUserInfo returned from GetSNUserInfos does not match the original value; expected Visibility {0}, got {1}.", userInfo.Visibility, actualUserInfos[0].Visibility);
                }
                catch (Exception e)
                {
                    HandleError("GetSNUserInfos", Authentication.UserStsToken, e);
                    success = false;
                }

                try
                {
                    TraceEx.TraceVerbose("Verifying gamertag refresh from {0} -> {1}...", userInfo.GamerTag, newGamerTag);
                    int attempts = 1;
                    bool verifiedChange = false;

                    do
                    {
                        SNUserInfo actualUserInfo = directoryClient.GetSNUserInfoBySNUId((ushort)SocialNetwork.Facebook, userInfo.SNUserID);
                        if (newGamerTag.Equals(actualUserInfo.GamerTag))
                        {
                            verifiedChange = true;
                            TraceEx.TraceVerbose("Successfully verified gamertag change, after {0} attempt(s)!", attempts);
                            break;
                        }

                        Thread.Sleep(500);  //wait just a bit...
                    }
                    while (attempts++ < 5);

                    if (!verifiedChange)
                        throw new ValidationException("Unable to verify gamertag refresh from {0} -> {1}, after 5 attempts.", userInfo.GamerTag, newGamerTag);
                }
                catch (Exception e)
                {
                    HandleError("GetSNUserInfoBySNUId", Authentication.UserStsToken, e);
                    success = false;
                }
            }
            finally
            {
                TraceEx.TraceStop("Finished Live Connect WP7 Directory Validation.");
                directoryClient.CloseConnection();
            }

            return success;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="e"></param>
        private static void HandleError(string api, Authentication authMode, Exception e)
        {
            string authModeText = GetAuthModeText(authMode);
            string message;
            int eventId;

            if (e is FaultException<SecurityAccessDeniedException>)
            {
                FaultException<SecurityAccessDeniedException> fault = e as FaultException<SecurityAccessDeniedException>;
                message = String.Format("{0} (using {2} auth) returned SecurityAccessDeniedException; STS or cert auth failed; SOAP fault Detail: {1}", api, fault.Detail.Message, authModeText);
                eventId = 2000;
            }
            else if (e is FaultException<ArgumentException>)
            {
                FaultException<ArgumentException> fault = e as FaultException<ArgumentException>;
                message = String.Format("{0} (using {2} auth) returned ArgumentException; invalid parameter(s) sent; SOAP fault Detail: {1}", api, fault.Detail.Message, authModeText);
                eventId = 2001;
            }
            else if (e is FaultException<ArgumentOutOfRangeException>)
            {
                FaultException<ArgumentOutOfRangeException> fault = e as FaultException<ArgumentOutOfRangeException>;
                message = String.Format("{0} (using {2} auth) returned ArgumentOutOfRangeException; out-of-range parameter(s) sent; SOAP fault Detail: {1}", api, fault.Detail.Message, authModeText);
                eventId = 2002;
            }
            else if (e is FaultException<ArgumentNullException>)
            {
                FaultException<ArgumentNullException> fault = e as FaultException<ArgumentNullException>;
                message = String.Format("{0} (using {2} auth) returned ArgumentNullException; null parameter(s) sent; SOAP fault Detail: {1}", api, fault.Detail.Message, authModeText);
                eventId = 2003;
            }
            else if (e is FaultException)
            {
                FaultException fault = e as FaultException;
                message = String.Format("Bug! {0} (using {2} auth) returned an unknown FaultException! {0}. An unexpected, internal error occurred: {1}", api, GetExceptionText(fault), authModeText);
                eventId = 2004;
            }
            else if (e is MessageSecurityException)
            {
                MessageSecurityException fault = e as MessageSecurityException;
                message = String.Format("{0} (using {2} auth) returned MessageSecurityException; invalid STS token or client certificate; SOAP fault Detail: {1}", api, GetExceptionText(fault), authModeText);
                eventId = 2005;
            }
            else if (e is TimeoutException)
            {
                TimeoutException fault = e as TimeoutException;
                message = String.Format("Encountered a timeout when calling {0} (using {2} auth): {1}", api, fault.Message, authModeText);
                eventId = 3000;
            }
            else if (e is CommunicationException)
            {
                CommunicationException fault = e as CommunicationException;
                message = String.Format("Encountered a communication issue when calling {0} (using {2} auth): {1}", api, GetExceptionText(fault), authModeText);
                eventId = 4000;
            }
            else if (e is ValidationException)
            {
                ValidationException fault = e as ValidationException;
                message = String.Format("Encountered a validation issue when calling {0} (using {2} auth); expected vs. actual data returned from the service did not match! {1}", api, fault.Message, authModeText);
                eventId = 5000;
            }
            else
            {
                message = String.Format("Unexpected exception occurred while calling {0} (using {2} auth)!\r\n\r\n{1}", api, e.ToString(), authModeText);
                eventId = 6000;
            }

            TraceEx.TraceError(eventId, message);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="client"></param>
        /// <param name="stsParameters"></param>
        private static void ConfigureStsAuth(LiveDirectoryClient client, Authentication authMode, StsTokenParameters stsParameters)
        {
            client.ChannelFactory.Endpoint.Behaviors.RemoveAll<System.ServiceModel.Description.ClientCredentials>();
            
            string stsToken = null;
            if (authMode == Authentication.UserStsToken)
            {
                stsToken = stsTokenGen.GenerateUserToken(stsParameters);
            }
            else
            {
                stsToken = stsTokenGen.GenerateConsoleToken(stsParameters);
            }

            client.ChannelFactory.Endpoint.Behaviors.Add(new StsClientCredentials(stsToken));
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="client"></param>
        /// <param name="stsParameters"></param>
        private static void ConfigureStsAuth(LiveAuthenticationClient client, Authentication authMode, StsTokenParameters stsParameters)
        {
            client.ChannelFactory.Endpoint.Behaviors.RemoveAll<System.ServiceModel.Description.ClientCredentials>();

            string stsToken = null;
            if (authMode == Authentication.UserStsToken)
            {
                stsToken = stsTokenGen.GenerateUserToken(stsParameters);
            }
            else
            {
                stsToken = stsTokenGen.GenerateConsoleToken(stsParameters);
            }

            client.ChannelFactory.Endpoint.Behaviors.Add(new StsClientCredentials(stsToken));
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="networkId"></param>
        /// <returns></returns>
        private static uint NetworkToTitleID(ushort networkId)
        {
            if (networkId == 2)
                return 0x584807E1;  //Facebook title ID
            return 0xFFFE07D1;      //Xbox 360 dash (BDEs - like twitter, get this title ID)
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="client"></param>
        /// <returns></returns>
        private static Uri UpdateClientEndpoint(LiveDirectoryClient client)
        {
            return new Uri(client.Endpoint.Address.Uri.Scheme + "://" + Hostname + client.Endpoint.Address.Uri.PathAndQuery);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="client"></param>
        /// <returns></returns>
        private static Uri UpdateClientEndpoint(LiveAuthenticationClient client)
        {
            return new Uri(client.Endpoint.Address.Uri.Scheme + "://" + Hostname + client.Endpoint.Address.Uri.PathAndQuery);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="e"></param>
        private static string GetExceptionText(Exception e)
        {
            if(e.InnerException != null)
                return e.InnerException.Message;
            return e.Message;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="authMode"></param>
        /// <returns></returns>
        private static string GetAuthModeText(Authentication authMode)
        {
            switch (authMode)
            {
                case Authentication.ClientCertificate:
                    {
                        return "client certificate";
                    }
                case Authentication.ConsoleStsToken:
                    {
                        return "console STS token";
                    }
                case Authentication.UserStsToken:
                    {
                        return "user STS token";
                    }
                default:
                    {
                        return "no authentication";
                    }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveConnect\Monitoring\LiveConnectPing\STS\StsToken.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using System.Security.Cryptography;
using System.Security.Cryptography.Xml;
using System.Security.Cryptography.X509Certificates;
using System.Xml;
using System.Diagnostics;

namespace LiveConnectPing
{
    /// <summary>
    /// 
    /// </summary>
    public class StsToken
    {
        public const string SamlNamespace = "urn:oasis:names:tc:SAML:1.0:assertion";
        public const string ConsoleTokenStsIssuer = "http://xboxlive.com";
        public const string UserTokenStsIssuer = "http://sts.xboxlive.com";
        public const string UserTokenSamlSubject = "XboxLive User security ticket";
        public const string PartnerTokenSamlSubject = "XboxLive Partner security ticket";

        // Token Signing Certificate
        //  this is the cert and associated private key that signs the SAML token
        private X509Certificate2 _certificate = null;
        private string certSubject;
        private object certStoreLock = new object();

        /// <summary>
        /// 
        /// </summary>
        /// <param name="certSubject"></param>
        public StsToken(string certSubject)
        {
            this.certSubject = certSubject;
        }

        /// <summary>
        /// 
        /// </summary>
        public string CertificateSubject
        {
            get
            {
                return this.certSubject;
            }
            set
            {
                this.certSubject = value;
                this._certificate = null;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="players"></param>
        /// <param name="audience"></param>
        /// <param name="machinePuid"></param>
        /// <param name="clientVersion"></param>
        /// <param name="title"></param>
        /// <param name="titleVersion"></param>
        /// <param name="minutesToExpire"></param>
        /// <returns></returns>
        public string GenerateConsoleToken(Player[] players, string audience, ulong machinePuid, uint clientVersion, uint title, uint titleVersion, int minutesToExpire)
        {
            DateTime now = DateTime.UtcNow;
            DateTime expires = now.Add(TimeSpan.FromMinutes(minutesToExpire));

            TextWriter textWriter = new StringWriter();
            XmlTextWriter writer = new XmlTextWriter(textWriter);

            string assertionID = WriteAssertionAttributes(writer, now.ToString("o"));
            WriteConditions(writer, now.ToString("o"), expires.ToString("o"), audience);

            writer.WriteStartElement("AttributeStatement", SamlNamespace);

            writer.WriteStartElement("Subject", SamlNamespace);
            writer.WriteElementString("NameIdentifier", SamlNamespace, string.Format("0x{0:X16}", players[0].Xuid)); // primary Subject is player1, in uppercase hex
            writer.WriteEndElement();

            // Write out machineID claim
            WriteClaim(writer, "PlatformType", string.Format("0x{0:X2}", 0x1)); //PlatformType 1 == Xbox360
            WriteClaim(writer, "MachineID", string.Format("0x{0:X16}", machinePuid));
            WriteClaim(writer, "ClientVersion", string.Format("0x{0:X8}", clientVersion));
            WriteClaim(writer, "TitleID", string.Format("0x{0:X8}", title));
            WriteClaim(writer, "TitleVersion", string.Format("0x{0:X8}", titleVersion));

            // Write out player claims
            for (int i = 0; i < players.Length; i++)
            {
                if (players[i] != null)
                {
                    WriteClaim(writer, String.Format("Xuid{0}", i + 1), string.Format("0x{0:X16}", players[i].Xuid)); //always return uppercase hex
                    WriteClaim(writer, String.Format("Tier{0}", i + 1), string.Format("0x{0:X2}", players[i].Tier));
                    WriteClaim(writer, String.Format("Country{0}", i + 1), string.Format("0x{0:X2}", players[i].Country));
                }
            }

            writer.WriteEndElement(); // AttributeStatement
            writer.WriteEndElement(); // Assertion

            textWriter.Flush();

            XmlDocument document = new XmlDocument();
            document.LoadXml(textWriter.ToString());

            SignXmlViaLocalCert(document, assertionID);

            TraceEx.TraceVerbose("Generated STS Token:\r\n{0}", document.OuterXml);
            return document.OuterXml;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="majorVersion"></param>
        /// <param name="minorVersion"></param>
        /// <param name="issuer"></param>
        /// <param name="notBefore"></param>
        /// <param name="notOnOrAfter"></param>
        /// <param name="audience"></param>
        /// <param name="subject"></param>
        /// <param name="omittedItem"></param>
        /// <returns></returns>
        public string GeneratePartnerToken(
            string majorVersion,
            string minorVersion,
            string issuer,
            string notBefore,
            string notOnOrAfter,
            string audience,
            string subject)
        {
            return GeneratePartnerToken(majorVersion, minorVersion, issuer, notBefore, notOnOrAfter, audience, subject, null);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="majorVersion"></param>
        /// <param name="minorVersion"></param>
        /// <param name="issuer"></param>
        /// <param name="notBefore"></param>
        /// <param name="notOnOrAfter"></param>
        /// <param name="audience"></param>
        /// <param name="subject"></param>
        /// <param name="omittedItem"></param>
        /// <param name="cert"></param>
        /// <param name="exceptionMessage"></param>
        /// <returns></returns>
        public string GeneratePartnerToken(
            string majorVersion,
            string minorVersion,
            string issuer,
            string notBefore,
            string notOnOrAfter,
            string audience,
            string subject,
            X509Certificate2 cert)
        {
            TextWriter textWriter = new StringWriter();
            XmlTextWriter writer = new XmlTextWriter(textWriter);

            string assertionID = WriteAssertionAttributes(writer, majorVersion, minorVersion, issuer, notBefore);
            // write conditions
            WriteConditions(writer, notBefore, notOnOrAfter, audience);

            writer.WriteStartElement("AttributeStatement", SamlNamespace);

            // write subject
            WriteSubject(writer, subject);

            // write the claims
            WriteClaim(writer, "TitleID", "4D5308E2");
            WriteClaim(writer, "TitleVersion", "1");
            WriteClaim(writer, "PartnerID0", "2600292641993623");
            WriteClaim(writer, "Gamertag0", "mpdev2");

            writer.WriteEndElement(); // AttributeStatement
            writer.WriteEndElement(); // Assertion

            textWriter.Flush();

            XmlDocument document = new XmlDocument();
            document.LoadXml(textWriter.ToString());

            SignXmlViaLocalCert(document, assertionID, cert);

            TraceEx.TraceVerbose("Generated Partner STS Token:\r\n{0}", document.OuterXml);
            return document.OuterXml;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="tokenParams"></param>
        /// <returns></returns>
        public string GenerateUserToken(StsTokenParameters tokenParams)
        {
            TraceEx.TraceVerbose("Generating console STS token for xuid0=0x{0}, Title ID=0x{1}, GamerTag={2}, PlatformType={3} good for 4 hours.", tokenParams.Xuid, tokenParams.TitleId.ToString("X8"), tokenParams.GamerTag, tokenParams.PlatformType);
            return GenerateUserToken(
                UserTokenStsIssuer,
                DateTime.Now.ToString("o"),
                DateTime.Now.Add(TimeSpan.FromHours(4)).ToString("o"),
                tokenParams.PlatformType,
                tokenParams.DeviceId,
                tokenParams.ClientVersion,
                tokenParams.TitleId.ToString("X8"),
                tokenParams.TitleVersion,
                tokenParams.Xuid.ToString(),
                tokenParams.GamerTag,
                tokenParams.Tier,
                tokenParams.MachineId.ToString(),
                tokenParams.Puid,
                tokenParams.CID,
                tokenParams.Country,
                tokenParams.Privileges,
                null);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="xuid"></param>
        /// <param name="titleId"></param>
        /// <param name="titleVersion"></param>
        /// <returns></returns>
        public string GenerateUserToken(
            string xuid,
            string titleId,
            string titleVersion)
        {
            return GenerateUserToken(UserTokenStsIssuer, DateTime.Now.ToString("o"), DateTime.Now.Add(TimeSpan.FromHours(4)).ToString("o"), "15", String.Empty, "1", titleId, titleVersion, xuid,
                                String.Empty, String.Empty, null);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="issuer"></param>
        /// <param name="notBefore"></param>
        /// <param name="notOnOrAfter"></param>
        /// <param name="platformType"></param>
        /// <param name="deviceId"></param>
        /// <param name="clientVersion"></param>
        /// <param name="titleId"></param>
        /// <param name="titleVersion"></param>
        /// <param name="xuid"></param>
        /// <param name="gamertag"></param>
        /// <param name="tier"></param>
        /// <param name="omittedItem"></param>
        /// <returns></returns>
        public string GenerateUserToken(
            string issuer,
            string notBefore,
            string notOnOrAfter,
            string platformType,
            string deviceId,
            string clientVersion,
            string titleId,
            string titleVersion,
            string xuid,
            string gamertag,
            string tier)
        {
            return GenerateUserToken(issuer, notBefore, notOnOrAfter, platformType, deviceId, clientVersion, titleId, titleVersion, xuid,
                                gamertag, tier, null);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="issuer"></param>
        /// <param name="notBefore"></param>
        /// <param name="notOnOrAfter"></param>
        /// <param name="platformType"></param>
        /// <param name="deviceId"></param>
        /// <param name="clientVersion"></param>
        /// <param name="titleId"></param>
        /// <param name="titleVersion"></param>
        /// <param name="xuid"></param>
        /// <param name="gamertag"></param>
        /// <param name="tier"></param>
        /// <param name="omittedItem"></param>
        /// <param name="cert"></param>
        /// <returns></returns>
        public string GenerateUserToken(
            string issuer,
            string notBefore,
            string notOnOrAfter,
            string platformType,
            string deviceId,
            string clientVersion,
            string titleId,
            string titleVersion,
            string xuid,
            string gamertag,
            string tier,
            X509Certificate2 cert)
        {
            return GenerateUserToken(issuer, notBefore, notOnOrAfter, platformType, deviceId, clientVersion, titleId, titleVersion, xuid,
                                gamertag, tier, String.Empty, String.Empty, String.Empty, String.Empty, String.Empty, null);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="issuer"></param>
        /// <param name="notBefore"></param>
        /// <param name="notOnOrAfter"></param>
        /// <param name="platformType"></param>
        /// <param name="deviceId"></param>
        /// <param name="clientVersion"></param>
        /// <param name="titleId"></param>
        /// <param name="titleVersion"></param>
        /// <param name="xuid"></param>
        /// <param name="gamertag"></param>
        /// <param name="tier"></param>
        /// <param name="omittedItem"></param>
        /// <param name="cert"></param>
        /// <param name="exceptionMessage"></param>
        /// <returns></returns>
        public string GenerateUserToken(
            string issuer,
            string notBefore,
            string notOnOrAfter,
            string platformType,
            string deviceId,
            string clientVersion,
            string titleId,
            string titleVersion,
            string xuid,
            string gamertag,
            string tier,
            string machineId,
            string puid,
            string cid,
            string country,
            string privledges,
            X509Certificate2 cert)
        {
            TextWriter textWriter = new StringWriter();
            XmlTextWriter writer = new XmlTextWriter(textWriter);

            string assertionID = WriteAssertionAttributes(writer, issuer, notBefore);
            // write conditions
            WriteConditions(writer, notBefore, notOnOrAfter, UserTokenStsIssuer);

            writer.WriteStartElement("AttributeStatement", SamlNamespace);
            // write subject
            WriteSubject(writer, UserTokenSamlSubject);

            // write claims
            WriteClaim(writer, "PlatformType", platformType);

            if (String.IsNullOrEmpty(machineId))
                machineId = Utility.GenerateRandomUInt64().ToString();
            WriteClaim(writer, "MachineID", machineId);

            if (String.IsNullOrEmpty(deviceId))
                deviceId = Utility.GenerateRandomUInt64().ToString();
            WriteClaim(writer, "DeviceID", deviceId);
            
            if (String.IsNullOrEmpty(clientVersion))
                clientVersion = "1";
            WriteClaim(writer, "ClientVersion", clientVersion);
            
            WriteClaim(writer, "TitleID", titleId);
            WriteClaim(writer, "TitleVersion", titleVersion);

            if (String.IsNullOrEmpty(puid))
                puid = Utility.GenerateRandomUInt64().ToString();
            WriteClaim(writer, "Puid0", puid);
        
            if (String.IsNullOrEmpty(cid))
                cid = Utility.GenerateRandomUInt64().ToString();
            WriteClaim(writer, "CID0", cid);
        
            if (String.IsNullOrEmpty(xuid))
                xuid = Utility.GenerateRandomUInt64().ToString();
            WriteClaim(writer, "Xuid0", xuid);
            
            if (String.IsNullOrEmpty(gamertag))
                gamertag = Utility.GenerateRandomGamerTag(10);
            WriteClaim(writer, "Gamertag0", gamertag);
            
            if (String.IsNullOrEmpty(tier))
                tier = "3"; //NOTE: not sure this is a 'great' default value; corresponds to silver acct
            WriteClaim(writer, "Tier0", tier);
            
            WriteClaim(writer, "Country0", "103");  //NOTE: hardcoded for US (103)

            //NOTE: the 'privledge' values were taken from a sample token, for a new, silver XBL account.
            WriteClaim(writer, "Privileges0", "212,220,226,227,228,229,230,231,234,235,237,240,241,243,244,245,246,247,248,249,251,252,254,255");

            writer.WriteEndElement(); // AttributeStatement
            writer.WriteEndElement(); // Assertion

            textWriter.Flush();

            XmlDocument document = new XmlDocument();
            document.LoadXml(textWriter.ToString());

            // sign the token
            SignXmlViaLocalCert(document, assertionID, cert);

            TraceEx.TraceVerbose("Generated User STS Token:\r\n{0}", document.OuterXml);
            return document.OuterXml;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="parameters"></param>
        /// <returns></returns>
        public string GenerateConsoleToken(StsTokenParameters parameters)
        {
            return GenerateConsoleToken(parameters.Xuid, parameters.TitleId, parameters.MachineId, parameters.MinutesToExpire);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="xuid"></param>
        /// <param name="titleId"></param>
        /// <param name="machinePuid"></param>
        /// <param name="minutesToExpire"></param>
        /// <returns></returns>
        public string GenerateConsoleToken(ulong xuid, uint titleId, ulong machinePuid, int minutesToExpire)
        {
            TraceEx.TraceVerbose("Generating console STS token for xuid0=0x{0}, Title ID=0x{1}, MachinePUID={2}, good for {3} minutes.", xuid.ToString("X16"), titleId.ToString("X8"), machinePuid.ToString("X16"), minutesToExpire);
            //103=US, 6=Gold
            Player player1 = new Player() { Xuid = xuid, Country = 103, Tier = 6 };

            //random machine puid, hard-coded client version, random title version
            return GenerateConsoleToken(new Player[] { player1 }, ConsoleTokenStsIssuer, machinePuid, 0x25223C00, titleId, Utility.GenerateRandomUInt32(), minutesToExpire);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="notBefore"></param>
        /// <param name="assertionID"></param>
        private static string WriteAssertionAttributes(XmlTextWriter writer, string notBefore)
        {
            return WriteAssertionAttributes(writer, "1", "1", UserTokenStsIssuer, notBefore);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="issuer"></param>
        /// <param name="notBefore"></param>
        /// <param name="OmittedUserTokenItems"></param>
        /// <param name="assertionID"></param>
        private static string WriteAssertionAttributes(XmlTextWriter writer, string issuer, string notBefore)
        {
            return WriteAssertionAttributes(writer, "1", "1", issuer, notBefore);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="majorVersion"></param>
        /// <param name="minorVersion"></param>
        /// <param name="issuer"></param>
        /// <param name="notBefore"></param>
        /// <param name="OmittedPartnerTokenItems"></param>
        /// <param name="OmittedUserTokenItems"></param>
        /// <param name="assertionID"></param>
        private static string WriteAssertionAttributes(
            XmlTextWriter writer,
            string majorVersion,
            string minorVersion,
            string issuer,
            string notBefore)
        {
            string assertionID = string.Format("SamlSecurityToken-{0}", Guid.NewGuid().ToString());

            writer.WriteProcessingInstruction("xml", "version='1.0' encoding='utf-16'");
            writer.WriteStartElement("saml", "Assertion", SamlNamespace);
            writer.WriteAttributeString("MajorVersion", majorVersion);
            writer.WriteAttributeString("MinorVersion", minorVersion);
            writer.WriteAttributeString("AssertionID", assertionID);

            writer.WriteAttributeString("Issuer", issuer);

            DateTime dateTimeNotBefore;
            if ((DateTime.TryParse(notBefore, out dateTimeNotBefore)) && (dateTimeNotBefore < DateTime.Now))
            {
                writer.WriteAttributeString("IssueInstant", dateTimeNotBefore.ToUniversalTime().ToString("o"));
            }
            else
                writer.WriteAttributeString("IssueInstant", DateTime.UtcNow.ToString("o"));

            return assertionID;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="notBefore"></param>
        /// <param name="notOnOrAfter"></param>
        /// <param name="audience"></param>
        /// <param name="OmittedPartnerTokenItems"></param>
        /// <param name="OmittedUserTokenItems"></param>
        private static void WriteConditions(XmlTextWriter writer, string notBefore, string notOnOrAfter, string audience)
        {
            writer.WriteStartElement("Conditions", SamlNamespace);
            writer.WriteAttributeString("NotBefore", notBefore);
            writer.WriteAttributeString("NotOnOrAfter", notOnOrAfter);
            writer.WriteStartElement("AudienceRestrictionCondition", SamlNamespace);
            writer.WriteElementString("Audience", SamlNamespace, audience);

            writer.WriteEndElement(); //AudienceRestrictionCondition
            writer.WriteEndElement(); // Conditions
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="subject"></param>
        private static void WriteSubject(XmlTextWriter writer, string subject)
        {
            writer.WriteStartElement("Subject", SamlNamespace);
            writer.WriteStartElement("NameIdentifier", SamlNamespace);
            writer.WriteAttributeString("Format", "/xboxlive/nameFormat");
            writer.WriteAttributeString("NameQualifier", "Microsoft-NameQualifier-domain");
            writer.WriteString(subject);
            writer.WriteEndElement(); // NameIdentifier
            writer.WriteEndElement(); // subject
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="claim"></param>
        /// <param name="value"></param>
        private static void WriteClaim(XmlTextWriter writer, string claim, string value)
        {
            writer.WriteStartElement("Attribute", SamlNamespace);
            writer.WriteAttributeString("AttributeName", claim);
            writer.WriteAttributeString("AttributeNamespace", "http://xboxlive.com/claims");
            writer.WriteElementString("AttributeValue", SamlNamespace, value);
            writer.WriteEndElement();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="document"></param>
        /// <param name="assertionID"></param>
        private void SignXmlViaLocalCert(XmlDocument document, string assertionID)
        {
            SignXmlViaLocalCert(document, assertionID, null);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="document"></param>
        /// <param name="assertionID"></param>
        /// <param name="cert"></param>
        /// <param name="exceptionMessage"></param>
        private void SignXmlViaLocalCert(XmlDocument document, string assertionID, X509Certificate2 cert)
        {
            // grab the cert so we don't have a race condition with it changing during a reload
            // we need this because we access the cert twice in this function and don't want to take a lock... but need to stay consistant
            X509Certificate2 signingCertificate;

            if (cert == null)
                signingCertificate = GetCertificate();
            else
                signingCertificate = cert;

            try
            {
                // Create a CustomSignedXml object.  
                // The CustomSigendXml object lets us change what attribute is used to find the node to sign.
                // The standard SignedXml signs the node identified by the attribute named 'id'.
                // We need to sign the node identified by the attribute named 'AssertionID'. 
                CustomSignedXml signedXml = new CustomSignedXml(document);
                signedXml.SignedInfo.CanonicalizationMethod = SignedXml.XmlDsigExcC14NTransformUrl;
                signedXml.SigningKey = (RSACryptoServiceProvider)signingCertificate.PrivateKey;

                // Create a reference which tells SignedXml what node to sign
                Reference reference = new Reference();
                reference.Uri = "#" + assertionID;

                // Add an enveloped transformation to the reference.
                XmlDsigEnvelopedSignatureTransform transform1 = new XmlDsigEnvelopedSignatureTransform();
                reference.AddTransform(transform1);

                XmlDsigExcC14NTransform transform2 = new XmlDsigExcC14NTransform();
                reference.AddTransform(transform2);

                // Add the reference to the SignedXml object.
                signedXml.AddReference(reference);

                // add key info
                KeyInfo keyInfo = new KeyInfo();
                keyInfo.AddClause(new KeyInfoX509Data(signingCertificate));
                signedXml.KeyInfo = keyInfo;

                // Compute the signature.
                signedXml.ComputeSignature();

                // Get the XML representation of the signature and save
                // it to an XmlElement object.
                XmlElement xmlDigitalSignature = signedXml.GetXml();

                // Append the element to the XML document.
                document.DocumentElement.AppendChild(document.ImportNode(xmlDigitalSignature, true));
            }
            catch (Exception e)
            {
                throw new ApplicationException(String.Format("Error signing SAML token with certificate '{0}'; {1}", cert.Subject, e.Message), e);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        private X509Certificate2 GetCertificate()
        {
            lock (certStoreLock)
            {
                X509Certificate2 certificate = this._certificate;

                // do I have a cert
                if (certificate != null)
                    return certificate;

                string subject = this.CertificateSubject;
                X509Store store = new X509Store(StoreName.My, StoreLocation.LocalMachine);
                store.Open(OpenFlags.ReadOnly);

                try
                {
                    // Find the certificate that matches the subject
                    X509Certificate2Collection matches = store.Certificates.Find(X509FindType.FindBySubjectName, subject, false);
                    if (matches == null || matches.Count == 0)
                        throw new ApplicationException(String.Format("No certificates with subject {0} were found in the specified store", subject));
                    if (matches.Count > 1)
                        throw new ApplicationException(String.Format("Multiple certificates with subject {0} were found in the specified store", subject));
                    if (!matches[0].HasPrivateKey)
                        throw new ApplicationException(String.Format("Certificate with subject {0} doesn't have a private key", subject));
                    _certificate = certificate = matches[0];
                }
                finally
                {
                    if (store != null)
                        store.Close();
                }
                return certificate;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveMonitor\makefile.inc ===
# this is a slight modification of the makefile.def target that skips ComVisible since it's specified per project.

$(OBJ_PATH)\$O\_generated.cs: $(SOURCES_USED)
    -$(_DEL)
    set createfile=<<$@.temp
!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES) && "$(MUI)" == "1" && "$(URT_VER)" == "2.0"
[assembly:System.Resources.NeutralResourcesLanguage("en")]
!endif
[assembly:System.Reflection.AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")]
!ifdef VER_PRODUCTNAME_STR
[assembly:System.Reflection.AssemblyProduct("$(VER_PRODUCTNAME_STR)")]
!endif
!ifdef VER_LEGALCOPYRIGHT_STR
[assembly:System.Reflection.AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")]
!endif
!ifdef VER_COMPANYNAME_STR
[assembly:System.Reflection.AssemblyCompany("$(VER_COMPANYNAME_STR)")]
!endif
!ifdef VER_PRODUCTVERSION_STR
[assembly:System.Reflection.AssemblyFileVersion("$(VER_PRODUCTVERSION_STR)")]
!endif
<<KEEP
!if defined(_ASSEMBLY_IDENTITY) \
        && "$(_ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME_LOWERCASE)" != "none" \
        && "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)" \
        && !defined(_MANAGED_CXX_LIBRARY) \
        && "$(MANAGED_TARGET_TYPE)" != "module"
    asmIdToAttribs.cmd "$(_ASSEMBLY_IDENTITY)" $@.temp csharp
!endif
    $(_MOVE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveMonitor\LiveStatusMonitorService\Configuration.cs ===
using System;
using System.IO;

namespace LiveStatusMonitorService
{
    public class Configuration
    {
        private static Configuration instance;

        public static Configuration Instance
        {
            get
            {
                if (instance == null)
                {
                    instance = new Configuration();
                }

                return instance;
            }
        }

        internal string WorkingDirectory
        {
            get
            {
                return AppDomain.CurrentDomain.BaseDirectory;
            }
        }

        internal static string ResolvePath(string path)
        {
            return Path.Combine(Configuration.Instance.WorkingDirectory, path);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveMonitor\HealthCheckUrlFetcher\Properties\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("HealthCheckUrlFetcher")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("52205961-ea08-4e31-bde6-4134f9b1d6a2")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveMonitor\HealthCheckUrlFetcher\Fetcher.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Data.SqlClient;
using System.Threading;
using System.Data;

namespace WebFetcher
{    
    public class Fetcher
    {
        private string connectionstring;
        private SqlConnection sqlconnection = null;
        private Mutex sqlMutex = null;

        public Fetcher(string _connectionstring)
        {
            // make sure all non-log parameters are non-null. An empty array is ok, just not null.
            if (_connectionstring == null)
            {
                throw new ArgumentNullException("_connectionstring");
            }

            connectionstring = _connectionstring;

            // Create a sql connection. Note, I've decided not to track
            // the opened state of this connection. I'll rely on the
            // sql classes to throw the appropriate exceptions if someone
            // calls Close on this class and then attempts to use some
            // other methods.
            try
            {
                sqlconnection = new SqlConnection(connectionstring);
                sqlconnection.Open();
                sqlMutex = new Mutex(false);
            }
            catch (SqlException sqlException)
            {
                string sErr = "Fetcher.ctor: "
                    + "Opening a connection to "
                    + connectionstring
                    + " caused a SqlException. Exception details: "
                    + sqlException.Message;

                throw new Exception(sErr, sqlException);
            }
            catch (ArgumentException ArgumentException)
            {
                // this gets thrown if the connection string is improperly formatted
                string sErr = "Fetcher.ctor: "
                    + "Opening a connection to "
                    + connectionstring
                    + " caused an ArgumentException. Exception details: "
                    + ArgumentException.Message;

                throw new Exception(sErr, ArgumentException);
            }
        }

        public void Close()
        {
            if (sqlconnection != null && sqlconnection.State != ConnectionState.Closed)
            {
                sqlconnection.Close();
            }

            if (sqlMutex != null)
            {
                sqlMutex.Close();
            }
        }

        public string Get(string name, string npdb, string domain, bool dynamicurl)
        {
            SqlCommand sqlCommand = sqlconnection.CreateCommand();
            sqlCommand.CommandText = "p_config_get_server_healthchecks";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            Dictionary<string, string> contents = new Dictionary<string, string>();

            SqlDataReader sqlDataReader = null;
            try
            {
                sqlDataReader = sqlCommand.ExecuteReader();
                while (sqlDataReader.Read())
                {
                    string vc_healthcheck_url = (string)sqlDataReader["vc_healthcheck_url"];
                    string vc_component = (string)sqlDataReader["vc_component"];

                    if (!contents.ContainsKey(vc_component))
                    {
                        contents.Add(vc_component, vc_healthcheck_url);
                    }
                    else
                    {
                        contents[vc_component] += ";" + vc_healthcheck_url;
                    }
                }
            }
            catch (SqlException sqlException)
            {
                string sErr = "Fetcher.Get: "
                    + "Calling the stored procedure "
                    + sqlCommand.CommandText
                    + " or reading the results caused a SqlException. Exception details: "
                    + sqlException.Message;

                throw new Exception(sErr, sqlException);
            }
            finally
            {
                // clean up the sqlDataReader if we need to
                if (sqlDataReader != null && !sqlDataReader.IsClosed)
                {
                    sqlDataReader.Close();
                }
            }

            string xml = "<?xml version=\"1.0\" encoding=\"utf-8\" ?>";
            xml += Environment.NewLine;
            xml += "<config>";
            xml += Environment.NewLine;
            xml += "  <configenv environment=\""+ name + "\" domain=\"" + domain + "\" npdb=\"" + npdb + "\" dynamicurl=\"" + dynamicurl + "\">";
            xml += Environment.NewLine;

            foreach (KeyValuePair<string, string> pair in contents)
            {
                string url = pair.Value;
                if (name == "#xblob#")
                {
                    url = pair.Value.ToLower().Replace(npdb, name);
                }
                xml += "    <healthcheck name=\"" + pair.Key + "\" url=\"" + url + "\"/>";
                xml += Environment.NewLine;
            }            
            xml += "  </configenv>";
            xml += Environment.NewLine;
            xml += "</config>";
            return xml;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveMonitor\HealthCheckUrlFetcher\Program.cs ===
using System;
using System.Collections.Generic;
using System.Text;

namespace WebFetcher
{
    class Program
    {
        static void Main(string[] args)
        {
            if (args.Length != 2)
            {
                string usage = "HealthCheckUrlFetcher.exe NAME NPDBDATABASE"
                    + Environment.NewLine
                    + "  testnet TxXblXallSql003"
                    + Environment.NewLine
                    + "  stressnet s1xblnpdbsql001"
                    + Environment.NewLine
                    + "  stressnet2 St2LsNPDBSQL001"
                    + Environment.NewLine
                    + "  #xblob# yixuanl-xblob01";
                Console.WriteLine("Usage: " + usage);
                return;
            }
            string name = args[0].Trim().ToLower();
            string npdb = args[1].Trim().ToLower();

            string connectionstr = "data source=" + npdb +
                ";initial catalog=LIVEN_NPDB" +
                ";integrated security=SSPI;" +
                "Packet Size=16384"; // bigger than usual for faster bulk inserts
            string xml = null;

            try
            {
                Fetcher fetcher = new Fetcher(connectionstr);
                xml = fetcher.Get(name, npdb, null, false);
                fetcher.Close();
            }
            catch
            {
                throw;
            }

            Console.WriteLine("HealthCheck urls we get:" + Environment.NewLine);
            Console.WriteLine(xml);
            Console.WriteLine(Environment.NewLine);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveMonitor\LiveStatusMonitorService\Data.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3074
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System.Xml.Serialization;
using System;
using System.Collections.Generic;

// 
// This source code was auto-generated by xsd, Version=2.0.50727.3038.
// 


/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "2.0.50727.3038")]
[System.SerializableAttribute()]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Xml.Serialization.XmlTypeAttribute(AnonymousType=true)]
[System.Xml.Serialization.XmlRootAttribute(Namespace="", IsNullable=false)]
public partial class Environments {
    
    private List<EnvironmentsEnvironment> itemsField;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute("Environment", Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
    public List<EnvironmentsEnvironment> Items {
        get {
            return this.itemsField;
        }
        set {
            this.itemsField = value;
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "2.0.50727.3038")]
[System.SerializableAttribute()]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Xml.Serialization.XmlTypeAttribute(AnonymousType=true)]
public partial class EnvironmentsEnvironment {
    
    private List<EnvironmentsEnvironmentContent> contentField;
    
    private string nameField;

    private string domainField;

    private bool dynamicUrlField;

    private string npdbField;
    
    private string statusField;

    private string buildField;

    private DateTime lastRanField;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute("Content", Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
    public List<EnvironmentsEnvironmentContent> Content {
        get {
            return this.contentField;
        }
        set {
            this.contentField = value;
        }
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlAttributeAttribute()]
    public string Name {
        get {
            return this.nameField;
        }
        set {
            this.nameField = value;
        }
    }

    [XmlIgnore]
    public string Domain
    {
        get
        {
            return this.domainField;
        }
        set
        {
            this.domainField = value;
        }
    }

    [XmlIgnore]
    public bool DynamicUrl
    {
        get
        {
            return this.dynamicUrlField;
        }
        set
        {
            this.dynamicUrlField = value;
        }
    }

    [XmlIgnore]
    public string NPDB
    {
        get
        {
            return this.npdbField;
        }
        set
        {
            this.npdbField = value;
        }
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlAttributeAttribute()]
    public string Status {
        get {
            return this.statusField;
        }
        set {
            this.statusField = value;
        }
    }

    /// <remarks/>
    [System.Xml.Serialization.XmlAttributeAttribute()]
    public string Build
    {
        get
        {
            return this.buildField;
        }
        set
        {
            this.buildField = value;
        }
    }
        
    /// <remarks/>
    [XmlIgnore]
    public DateTime LastRanTime
    {
        get
        {
            return this.lastRanField;
        }
        set
        {
            this.lastRanField = value;
        }
    }

    /// <remarks/>
    [System.Xml.Serialization.XmlAttributeAttribute()]
    public string LastRan
    {
        get
        {
            return this.lastRanField.ToString("yyyy/MM/dd HH:mm:ss");
        }
        set
        {
            this.lastRanField = DateTime.Parse(value);
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "2.0.50727.3038")]
[System.SerializableAttribute()]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Xml.Serialization.XmlTypeAttribute(AnonymousType=true)]
public partial class EnvironmentsEnvironmentContent {
    
    private string nameField;
    
    private string statusField;

    private string buildField;
    
    private string messageField;

    private string urlField;
    
    private DateTime lastRanField;

    private bool countedField = true;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlAttributeAttribute()]
    public string Name {
        get {
            return this.nameField;
        }
        set {
            this.nameField = value;
        }
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlAttributeAttribute()]
    public string Status {
        get {
            return this.statusField;
        }
        set {
            this.statusField = value;
        }
    }

    /// <remarks/>
    [System.Xml.Serialization.XmlAttributeAttribute()]
    public string Build
    {
        get
        {
            return this.buildField;
        }
        set
        {
            this.buildField = value;
        }
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlAttributeAttribute()]
    public string Message {
        get {
            return this.messageField;
        }
        set {
            this.messageField = value;
        }
    }

    /// <remarks/>
    [System.Xml.Serialization.XmlAttributeAttribute()]
    public string Url
    {
        get
        {
            return this.urlField;
        }
        set
        {
            this.urlField = value;
        }
    }

    /// <remarks/>
    [XmlIgnore]
    public DateTime LastRanTime {
        get {
            return this.lastRanField;
        }
        set {
            this.lastRanField = DateTime.SpecifyKind(value, DateTimeKind.Utc);
        }
    }

    /// <remarks/>
    [System.Xml.Serialization.XmlAttributeAttribute()]
    public string LastRan
    {
        get
        {
            return this.lastRanField.ToString("yyyy/MM/dd HH:mm:ss");
        }
        set
        {
            this.lastRanField = DateTime.Parse(value);
        }
    }

    /// <remarks/>
    [System.Xml.Serialization.XmlAttributeAttribute()]
    [System.ComponentModel.DefaultValue(true)]
    public bool Counted
    {
        get
        {
            return this.countedField;
        }
        set
        {
            this.countedField = value;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveMonitor\LiveStatusMonitorService\StatusFetcher.cs ===
using System;
using System.Collections.Generic;
using System.Data;
using System.IO;
using System.Xml.Serialization;
using System.Xml;
using System.Net;
using System.Net.Sockets;
using System.Text.RegularExpressions;
using System.Threading;

namespace LiveStatusMonitorService
{
    public abstract class CFetcher
    {
        protected Logger m_LogObj;
        public List<EnvironmentsEnvironment> m_EnvironmentsObj = null;

        public abstract void Init();
        public abstract void Despose();
        public abstract void DoWork();

        public void SetStatus(List<EnvironmentsEnvironment> environmentsObj)
        {
            if (environmentsObj == null)
            {
                return;
            }
            for (int i = 0; i < environmentsObj.Count; i++)
            {
                string status = "unknown";
                string build = "0.0.0.0";
                DateTime lastRan = DateTime.MinValue;
                int numberOfSuccess = 0;

                if (environmentsObj[i] == null)
                {
                    continue;
                }

                foreach (EnvironmentsEnvironmentContent content in environmentsObj[i].Content)
                {
                    if (content == null)
                        continue;
                    //Fill in Status
                    if (!String.IsNullOrEmpty(content.Status) && content.Counted == true)
                    {
                        switch (content.Status.ToLower())
                        {
                            case "green":
                                numberOfSuccess++;
                                if (status == "unknown")
                                {
                                    status = "green";
                                }
                                break;
                            case "red":
                                status = "red";
                                break;
                            case "yellow":
                                if (status != "red")
                                {
                                    status = "yellow";
                                }
                                break;
                            default:
                                break;
                        }
                    }
                    //Fill in build
                    if (!String.IsNullOrEmpty(content.Build))
                    {
                        try
                        {
                            Version versionNew = new Version(content.Build);
                            Version versionOld = new Version(build);
                            if (versionNew.CompareTo(versionOld) > 0)
                            {
                                build = content.Build;
                            }
                        }
                        catch
                        {
                            //If anything wrong here, we just keep the old version. Ignore the exception.
                        }
                    }
                    //Fill in lastRan
                    if (content.LastRanTime != null && content.LastRanTime > lastRan)
                    {
                        lastRan = content.LastRanTime;
                    }                    
                }                
                environmentsObj[i].Status = status;
                environmentsObj[i].LastRanTime = lastRan;
                environmentsObj[i].Build = build;
            }            
        }

        public string Serialize(List<EnvironmentsEnvironment> environmentsObj)
        {
            Environments environments = new Environments();
            environments.Items = environmentsObj;

            StringWriter sw = new StringWriter();
            XmlSerializerNamespaces customNamespace = new XmlSerializerNamespaces();
            customNamespace.Add("", "");
            MemoryStream memStream = new MemoryStream();
            try
            {
                XmlSerializer xmlSerializer = new XmlSerializer(typeof(Environments));
                xmlSerializer.Serialize(memStream, environments, customNamespace);
                XmlDocument doc = new XmlDocument();
                memStream.Seek(0, SeekOrigin.Begin);
                doc.Load(memStream);                
                String PItext = string.Format("type='text/xsl' href='{0}'", "XboxLiveStatusReport.xslt");
                XmlProcessingInstruction newPI = doc.CreateProcessingInstruction("xml-stylesheet", PItext);
                doc.InsertAfter(newPI, doc.FirstChild);                
                XmlTextWriter xw = new XmlTextWriter(sw);
                doc.WriteTo(xw);                
            }
            finally
            {
                memStream.Flush();
            }            
            return sw.ToString();
        }
    }

    public class HealthCheckFetcher : CFetcher
    {
        private string m_XblobServerName = null;
        private static readonly int m_maxQueueThread = 10;

        public List<EnvironmentsEnvironment> m_XblobEnvironmentsObj = null;
        
        public override void Init()
        {
            string configFile = Configuration.ResolvePath(Properties.Settings.Default.HealthCheckConfigFile);
            if (!File.Exists(configFile))
            {
                throw new FileNotFoundException("File " + configFile + " was not found!");
            }

            XmlDocument config = new XmlDocument();
            config.Load(configFile);
            m_EnvironmentsObj = new List<EnvironmentsEnvironment>();
            m_XblobEnvironmentsObj = new List<EnvironmentsEnvironment>();
            UpdateUrls(config);
        }

        private void UpdateUrls(XmlDocument config)
        {
            XmlNodeList environmentList = config.GetElementsByTagName("configenv");
            
            for (int i = 0; i < environmentList.Count; i++)
            {
                XmlNode n = environmentList.Item(i);

                if (n.Attributes["environment"] == null)
                {
                    continue;
                }

                EnvironmentsEnvironment env = new EnvironmentsEnvironment();

                env.Name = n.Attributes["environment"].Value;
                if (env.Name == "#xblob#" && String.IsNullOrEmpty(m_XblobServerName))
                {
                    continue;
                }
                env.Domain = n.Attributes["domain"].Value;
                env.DynamicUrl = n.Attributes["dynamicurl"].Value.ToLower() == "true" ? true : false;
                if (env.DynamicUrl)
                {
                    env.NPDB = n.Attributes["npdb"].Value;
                }

                List<EnvironmentsEnvironmentContent> contents = new List<EnvironmentsEnvironmentContent>();
                for (int j = 0; j < n.ChildNodes.Count; j++)
                {
                    XmlNode subNodes = n.ChildNodes.Item(j);
                    if (subNodes.Name == "healthcheck")
                    {
                        //Do we need to remove possible duplicate entry here?
                        EnvironmentsEnvironmentContent content = new EnvironmentsEnvironmentContent();
                        content.Name = (subNodes.Attributes["name"] == null) ? null : subNodes.Attributes["name"].Value;
                        content.Url = (subNodes.Attributes["url"] == null) ? null : subNodes.Attributes["url"].Value;
                        content.Status = "unknown";
                        content.LastRanTime = DateTime.UtcNow;
                        if(subNodes.Attributes["counted"] != null && subNodes.Attributes["counted"].Value == "false")
                        {
                            content.Counted = false;
                        }

                        if (env.Name == "#xblob#")
                        {
                            content.Url = content.Url.Replace("#xblob#", m_XblobServerName);
                        }
                        contents.Add(content);
                    }
                }
                env.Content = contents;

                bool found = false;
                if (env.Name == "#xblob#")
                {
                    env.Name = m_XblobServerName;
                    foreach (EnvironmentsEnvironment envObj in m_XblobEnvironmentsObj)
                    {
                        if (envObj.Name == env.Name)
                        {
                            envObj.Content = contents;
                            found = true;
                            break;
                        }
                    }
                    if (!found)
                    {
                        m_XblobEnvironmentsObj.Add(env);
                    }
                }
                else
                {
                    foreach (EnvironmentsEnvironment envObj in m_EnvironmentsObj)
                    {
                        if (envObj.Name == env.Name)
                        {
                            envObj.Content = contents;
                            found = true;
                            break;
                        }
                    }
                    if (!found)
                    {
                        m_EnvironmentsObj.Add(env);
                    }                    
                }
            }
        }

        public void SetXblob(string serverNameOrIpAddress)
        {
            m_XblobServerName = serverNameOrIpAddress;               
        }

        public override void Despose()
        {

        }

        public override void DoWork()
        {
            if (m_EnvironmentsObj == null || m_EnvironmentsObj.Count == 0)
            {
                return;
            }
            for (int i = 0; i < m_EnvironmentsObj.Count; i++)
            {
                ManualResetEvent[] doneEvents = null;

                EnvironmentsEnvironment environment = m_EnvironmentsObj[i];
                Domains domain = (Domains)Enum.Parse(typeof(Domains), environment.Domain);

                #region dynamicurl needs to update url list
                if (environment.DynamicUrl)
                {
                    string xml = null;
                    try
                    {
                        switch (domain)
                        {
                            case Domains.hyper:
                                {
                                    WebFetcherForHyperDomain.WebFetcherService service = new WebFetcherForHyperDomain.WebFetcherService();
                                    service.Timeout = 60 * 1000;
                                    xml = service.UpdateUrls(environment.Name, environment.NPDB, environment.Domain, environment.DynamicUrl);
                                    break;
                                }
                            case Domains.internet:
                                {
                                    WebFetcherForInternetDomain.WebFetcherService service = new WebFetcherForInternetDomain.WebFetcherService();
                                    service.Timeout = 60 * 1000;
                                    xml = service.UpdateUrls(environment.Name, environment.NPDB, environment.Domain, environment.DynamicUrl);
                                    break;
                                }
                            case Domains.core:
                                {
                                    WebFetcherForCoreDomain.WebFetcherService service = new WebFetcherForCoreDomain.WebFetcherService();
                                    service.Timeout = 60 * 1000;
                                    xml = service.UpdateUrls(environment.Name, environment.NPDB, environment.Domain, environment.DynamicUrl);
                                    break;
                                }
                            case Domains.redmond:
                                {
                                    WebFetcherForRedmondDomain.WebFetcherService service = new WebFetcherForRedmondDomain.WebFetcherService();
                                    service.Timeout = 60 * 1000;
                                    xml = service.UpdateUrls(environment.Name, environment.NPDB, environment.Domain, environment.DynamicUrl);
                                    break;
                                }
                            case Domains.int2:
                                {
                                    WebFetcherForInt2Domain.WebFetcherService service = new WebFetcherForInt2Domain.WebFetcherService();
                                    service.Timeout = 60 * 1000;
                                    xml = service.UpdateUrls(environment.Name, environment.NPDB, environment.Domain, environment.DynamicUrl);
                                    break;
                                }
                            case Domains.cert:
                                {
                                    WebFetcherForCertDomain.WebFetcherService service = new WebFetcherForCertDomain.WebFetcherService();
                                    service.Timeout = 60 * 1000;
                                    xml = service.UpdateUrls(environment.Name, environment.NPDB, environment.Domain, environment.DynamicUrl);
                                    break;
                                }
                            case Domains.part:
                                {
                                    WebFetcherForPartDomain.WebFetcherService service = new WebFetcherForPartDomain.WebFetcherService();
                                    service.Timeout = 60 * 1000;
                                    xml = service.UpdateUrls(environment.Name, environment.NPDB, environment.Domain, environment.DynamicUrl);
                                    break;
                                }
                            default:
                                break;
                        }
                    }
                    catch (Exception ex)
                    {
                        Logger.Instance.LogException("Update Urls Failed!", ex);                    
                    }
                    if (!String.IsNullOrEmpty(xml))
                    {
                        XmlDocument config = new XmlDocument();
                        config.LoadXml(xml);
                        UpdateUrls(config);
                    }
                    else
                    {
                        //Something bad happened if xml is empty
                        continue;
                    }
                }
                #endregion

                int index = 0;
                int threadCount = 0;
                int arraySize = environment.Content.Count < m_maxQueueThread ? environment.Content.Count : m_maxQueueThread;
                if (arraySize <= 0)
                {
                    // Empty? UpdateURL must fail.
                    continue;
                }
                doneEvents = new ManualResetEvent[arraySize];                
                foreach (EnvironmentsEnvironmentContent content in environment.Content)
                {
                    if (content != null)
                    {
                        if (threadCount < m_maxQueueThread)
                        {
                            index = threadCount;
                        }
                        else
                        {
                            index = WaitHandle.WaitAny(doneEvents);
                        }
                        doneEvents[index] = new ManualResetEvent(false);
                        WebFetcherThread workerThread = new WebFetcherThread(doneEvents[index], domain, environment.Name, content);
                        ThreadPool.QueueUserWorkItem(workerThread.WebFetcherCallback, index);
                        threadCount++;
                    }
                }
                if (Thread.CurrentThread.GetApartmentState() == ApartmentState.STA)
                {
                    if (doneEvents != null)
                    {
                        foreach (WaitHandle myWaitHandle in doneEvents)
                        {
                            WaitHandle.WaitAny(new WaitHandle[] { myWaitHandle });
                        }
                    }
                }
                else
                {
                    WaitHandle.WaitAll(doneEvents);
                }                
            }
        }

        public void DoWorkForXblob()
        {
            if (m_XblobEnvironmentsObj != null || m_XblobEnvironmentsObj.Count != 0)
            {
                int index = 0;
                int threadCount = 0;
                int arraySize = m_XblobEnvironmentsObj[0].Content.Count < m_maxQueueThread ? m_XblobEnvironmentsObj[0].Content.Count : m_maxQueueThread;
                ManualResetEvent[] doneEvents = new ManualResetEvent[arraySize];

                foreach (EnvironmentsEnvironmentContent content in m_XblobEnvironmentsObj[0].Content)
                {
                    if (threadCount < m_maxQueueThread)
                    {
                        index = threadCount;
                    }
                    else
                    {
                        index = WaitHandle.WaitAny(doneEvents);
                    }
                    doneEvents[index] = new ManualResetEvent(false);                    
                    WebFetcherThread workerThread = new WebFetcherThread(doneEvents[index], Domains.redmond, m_XblobEnvironmentsObj[0].Name, content);
                    ThreadPool.QueueUserWorkItem(workerThread.WebFetcherCallback, index);
                    threadCount++;
                }
                if (Thread.CurrentThread.GetApartmentState() == ApartmentState.STA)
                {
                    foreach (WaitHandle myWaitHandle in doneEvents)
                    {
                        WaitHandle.WaitAny(new WaitHandle[] { myWaitHandle });
                    }
                }
                else
                {
                    WaitHandle.WaitAll(doneEvents);
                }
            }
        }        
    }

    internal class WebFetcherThread
    {
        private ManualResetEvent _doneEvent;
        private string _environmentName;
        private Domains _domainName;
        private EnvironmentsEnvironmentContent _content;

        internal WebFetcherThread(ManualResetEvent doneEvent, Domains domainName, string envName, EnvironmentsEnvironmentContent content)
        {
            _doneEvent = doneEvent;
            _domainName = domainName;
            _environmentName = envName;
            _content = content;
        }

        internal void WebFetcherCallback(Object threadContext)
        {
            int threadIndex = (int)threadContext;
            WebFetch();
            _doneEvent.Set();
        }

        internal object WebFetch(Delegate method, string[] urls)
        {
            string htmlContent = null;
            for (int i = 0; i < urls.Length; i++)
            {               
                object[] args = {urls[i]};
                htmlContent = Convert.ToString(method.DynamicInvoke(args));
                if (!String.IsNullOrEmpty(htmlContent) && !htmlContent.Contains(urls[i]))
                {
                    break;
                }
            }
            return (object)htmlContent;
        }

        public delegate TResult Func1<T, TResult>(T arg);

        internal void WebFetch()
        {            
            if (String.IsNullOrEmpty(_content.Url))
            {
                return;
            }

            string[] urls = _content.Url.Split(new char[]{';'});
            string url = null;
            
            try
            {
                string htmlContent = null;
                switch (_domainName)
                {
                    case Domains.redmond:
                        {
                            WebFetcherForRedmondDomain.WebFetcherService service = new WebFetcherForRedmondDomain.WebFetcherService();
                            service.Timeout = 60 * 1000;
                            htmlContent = (string)WebFetch(new Func1<string, string>(service.WebFetcher), urls);
                            break;
                        }
                    case Domains.core:
                        {
                            WebFetcherForCoreDomain.WebFetcherService service = new WebFetcherForCoreDomain.WebFetcherService();
                            service.Timeout = 60 * 1000;
                            htmlContent = (string)WebFetch(new Func1<string, string>(service.WebFetcher), urls);
                            break;
                        }
                    case Domains.hyper:
                        {
                            WebFetcherForHyperDomain.WebFetcherService service = new WebFetcherForHyperDomain.WebFetcherService();
                            service.Timeout = 60 * 1000;
                            htmlContent = (string)WebFetch(new Func1<string, string>(service.WebFetcher), urls);
                            break;
                        }
                    case Domains.internet:
                        {
                            WebFetcherForInternetDomain.WebFetcherService service = new WebFetcherForInternetDomain.WebFetcherService();
                            service.Timeout = 60 * 1000;
                            htmlContent = (string)WebFetch(new Func1<string, string>(service.WebFetcher), urls);
                            break;
                        }
                    case Domains.int2:
                        {
                            WebFetcherForInt2Domain.WebFetcherService service = new WebFetcherForInt2Domain.WebFetcherService();
                            service.Timeout = 60 * 1000;
                            htmlContent = (string)WebFetch(new Func1<string, string>(service.WebFetcher), urls);
                            break;
                        }
                    case Domains.cert:
                        {
                            WebFetcherForCertDomain.WebFetcherService service = new WebFetcherForCertDomain.WebFetcherService();
                            service.Timeout = 60 * 1000;
                            htmlContent = (string)WebFetch(new Func1<string, string>(service.WebFetcher), urls);
                            break;
                        }
                    case Domains.part:
                        {
                            WebFetcherForPartDomain.WebFetcherService service = new WebFetcherForPartDomain.WebFetcherService();
                            service.Timeout = 60 * 1000;
                            htmlContent = (string)WebFetch(new Func1<string, string>(service.WebFetcher), urls);
                            break;
                        }
                    default:
                        return;
                }
                
                if (String.IsNullOrEmpty(htmlContent))
                {
                    Logger.Instance.LogError("Web Fetch Return Empty. Url " + url);
                    return;
                }

                string relativePath = "HealthCheck_" + _environmentName + "_" + _content.Name + ".xml";
                string filePath = Configuration.ResolvePath("Log\\" + relativePath);
                if (htmlContent.StartsWith("Http Request"))
                {
                    relativePath = "HealthCheck_" + _environmentName + "_" + _content.Name + ".txt";
                    filePath = Configuration.ResolvePath("Log\\" + relativePath);
                    if (File.Exists(filePath))
                    {
                        File.Delete(filePath);
                    }
                    File.AppendAllText(filePath, htmlContent + Environment.NewLine + "Please Check the service " + _content.Name + ".");
                    lock (_content)
                    {
                        _content.LastRanTime = DateTime.UtcNow;
                        _content.Status = "red";
                        _content.Build = "";
                        _content.Message = relativePath;
                    }
                    return;
                }
                XmlDocument xmlDocument = new XmlDocument();
                xmlDocument.LoadXml(htmlContent);

                XmlNodeList nodeList = xmlDocument.GetElementsByTagName("LastHealthcheckTime");
                if (nodeList.Count <= 0)
                {
                    Logger.Instance.LogError("Web Fetch Return with no LastHealthcheckTime node. Url " + url);
                    return;
                }
                XmlNode node = nodeList.Item(0);
                DateTime lastRan = Convert.ToDateTime(node.InnerText);
                node = xmlDocument.FirstChild.NextSibling;
                node.Value = "href='health.xslt' type='text/xsl'";

                nodeList = xmlDocument.GetElementsByTagName("Healthcheck");
                if (nodeList.Count <= 0)
                {
                    Logger.Instance.LogError("Web Fetch Return with no Healthcheck node. Url " + url);
                    return;
                }
                node = nodeList.Item(0);
                string status = (node.Attributes["HealthStatus"] == null) ? null : node.Attributes["HealthStatus"].Value.ToLower();

                nodeList = xmlDocument.GetElementsByTagName("FileVersion");
                if (nodeList.Count <= 0)
                {
                    throw new ArgumentException("FileVersion node are not been found!");
                }
                node = nodeList.Item(0);
                string build = node.InnerText;

                if (File.Exists(filePath))
                {
                    File.Delete(filePath);
                }
                xmlDocument.Save(filePath);
                lock (_content)
                {
                    _content.LastRanTime = lastRan;
                    _content.Status = status;
                    _content.Build = build;
                    _content.Message = relativePath;
                }
            }
            catch (Exception ex)
            {
                Logger.Instance.LogException("Parse Xml Failed with Url " + url, ex);
            }
        }
    }

    public class XonWatchFetcher : CFetcher
    {
        XonWatchDB DBObj = null;

        public override void Init()
        {
            string connectionstr = "data source=xon123" +
                ";initial catalog=xonwatch" +
                ";integrated security=SSPI;" +
                "Packet Size=16384"; // bigger than usual for faster bulk inserts

            try
            {
                DBObj = new XonWatchDB(connectionstr);
            }
            catch (Exception e)
            {
                throw new XonWatchDBException("XonWatchFetcher unable to connect to database.", e);
            }
        }

        public override void Despose()
        {
            DBObj.Close();
        }

        public override void DoWork()
        {
            List<int> environmentids = DBObj.EnvironmentListGet();

            if (environmentids == null || environmentids.Count == 0)
            {
                return;
            }

            m_EnvironmentsObj = new List<EnvironmentsEnvironment>();
            for (int i = 0; i < environmentids.Count; i++)
            {
                string networkid = string.Empty;
                string name = string.Empty;
                string location = string.Empty;
                string useraccounts = string.Empty;
                DBObj.EnvironmentGet(environmentids[i], out networkid, out location, out useraccounts);

                EnvironmentsEnvironment environmentObj = new EnvironmentsEnvironment();
                environmentObj.Name = location;

                DataTable dt = DBObj.StatusGet(environmentids[i]);
                if (dt == null || dt.Rows.Count == 0)
                {
                    continue;
                }

                environmentObj.Content = new List<EnvironmentsEnvironmentContent>();
                for (int j = 0; j < dt.Rows.Count; j++)
                {
                    DataRow row = dt.Rows[j];
                    EnvironmentsEnvironmentContent content = new EnvironmentsEnvironmentContent();
                    content.Name = row["vc_command"].ToString();
                    content.LastRanTime = Convert.ToDateTime(row["dt_logged"]);                    

                    string status = "unknown";
                    switch (row["vc_result"].ToString().ToLower())
                    {
                        case "success":
                            TimeSpan span = DateTime.UtcNow.Subtract(content.LastRanTime);
                            if (span.TotalHours > Properties.Settings.Default.XeOnWatchResultsExpiredDurationinHours)
                            {
                                status = "yellow";
                            }
                            else
                            {
                                status = "green";
                            }
                            break;
                        case "failure":
                            status = "red";
                            break;
                        default:                            
                            break;
                    }
                    content.Status = status;

                    string relativePath = "XeOnWatch_" + environmentObj.Name + "_" + content.Name + ".txt";
                    string filePath = Configuration.ResolvePath("Log\\" + relativePath);
                    
                    if(File.Exists(filePath))
                    {
                        File.Delete(filePath);
                    }
                    System.IO.File.WriteAllText(filePath, row["vc_message"].ToString());
                    content.Message = relativePath;
                                        
                    environmentObj.Content.Add(content);
                }
                m_EnvironmentsObj.Add(environmentObj);
            }
        }
    }

    public class XonWatchDBException : ApplicationException
    {
        public XonWatchDBException() : base() { }
        public XonWatchDBException(string s) : base(s) { }
        protected XonWatchDBException(
            System.Runtime.Serialization.SerializationInfo si,
            System.Runtime.Serialization.StreamingContext sc
            )
            : base(si, sc) { }
        public XonWatchDBException(string s, Exception e) : base(s, e) { }
    }

    public enum Domains
    {
        int2,
        cert,
        part,
        core,
        test,
        hyper,
        internet,
        redmond
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveMonitor\LiveStatusMonitorService\Logger.cs ===
using System;
using System.IO;

namespace LiveStatusMonitorService
{
    public class Logger
    {
        private const string DefaultLogName = "Main";

        internal static Logger Instance
        {
            get
            {
                return GetLogger();
            }
        }


        /// <summary>
        /// The folder containing the logs for this logger
        /// </summary>
        private string logFolder
        {
            get
            {
                // if this is the default logger, place the logs in the application
                // folder, otherwise place them in the debug log path
                return Configuration.ResolvePath("Log");
            }
        }


        /// <summary>
        /// The log file for this logger
        /// </summary>
        internal string LogFile
        {
            get
            {
                return Path.Combine(this.logFolder,
                    String.Format("{0}.{1}", this.logName, LogExtension));
            }
        }

        /// <summary>
        /// The error log file for this logger
        /// </summary>
        internal string ErrorLogFile
        {
            get
            {
                return Path.Combine(this.logFolder,
                    String.Format("{0}.{1}", this.logName, ErrorLogExtension));
            }
        }

        private string logName;
        private object writeLock = new object();
        private static Logger MainLogger;
        private const string EventSource = "XboxLiveMonitor";
        private const string EventLogName = "Application";
        private const int MaxLogFileLengthInMegaBytes = 10;
        private const string LogExtension = "info";
        private const string ErrorLogExtension = "err";

        protected Logger()
            : this(DefaultLogName)
        {
        }

        protected Logger(string logName)
        {
            this.logName = logName;
        }

        public static Logger GetLogger()
        {
            // If the requested logger does not exist in the dictionary,
            // create a new one
            if (MainLogger != null)
            {
                return MainLogger;
            }
            else
            {
                MainLogger = new Logger();
                return MainLogger;
            }
        }

        public void LogException(string text, Exception e)
        {
            string message = 
                text + Environment.NewLine
                + e.Message
                + Environment.NewLine
                + e.StackTrace
                + Environment.NewLine;
            if (e.InnerException != null)
            {
                text = e.InnerException.Message
                    + Environment.NewLine
                    + e.InnerException.StackTrace
                    + Environment.NewLine;
            }

            WriteLogToFile(message, this.ErrorLogFile, this.writeLock);
        }

        public void LogError(string text)
        {
            WriteLogToFile(text, this.ErrorLogFile, this.writeLock);
        }

        public void LogInformation(string text)
        {
            WriteLogToFile(text, this.LogFile, this.writeLock);
        }

        private static void WriteLogToFile(string text, string file, object writeLock)
        {
            if (!String.IsNullOrEmpty(text))
            {
                text = String.Format("[{0}] {1}{2}", DateTime.Now.ToString(),
                    text, Environment.NewLine);
            }
            else
            {
                text = Environment.NewLine;
            }

            try
            {
                lock (writeLock)
                {
                    FileInfo fileInfo = new FileInfo(file);

                    if (fileInfo.Exists && fileInfo.Length >
                        MaxLogFileLengthInMegaBytes * 1000000)
                    {
                        File.Delete(file);
                    }

                    File.AppendAllText(file, text);
                }
            }
            catch (Exception e)
            {
                WriteExceptionToEventLog(e,
                    "An exception occurred while writing to log file " + file,
                    System.Diagnostics.EventLogEntryType.Error);
            }
        }

        public static void WriteToEventLog(string text, System.Diagnostics.EventLogEntryType type)
        {

            if (!System.Diagnostics.EventLog.SourceExists(EventSource))
                System.Diagnostics.EventLog.CreateEventSource(EventSource, EventLogName);

            System.Diagnostics.EventLog.WriteEntry(EventSource, text, type);
        }

        /// <summary>
        /// This method writes an exception to the event log.
        /// </summary>
        /// <param name="e">exception</param>
        /// <param name="format">additional format describing the event</param>
        /// <param name="type">the event type (info, warning, error, etc)</param>
        public static void WriteExceptionToEventLog(
            Exception e,
            string text,
            System.Diagnostics.EventLogEntryType type)
        {
            string eventText = text + ": " + e.Message + Environment.NewLine + e.StackTrace + Environment.NewLine;

            WriteToEventLog(eventText, type);
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveMonitor\LiveStatusMonitorService\XonWatchDB.cs ===
using System;
using System.Collections.Generic;
using System.Data.SqlClient;
using System.Data;
using System.Threading;

namespace LiveStatusMonitorService
{
    public class XonWatchDB
    {
        private string connectionstring;
        private SqlConnection sqlconnection = null;
        private Mutex sqlMutex = null;
        
        public XonWatchDB(string _connectionstring)
        {
        
            // make sure all non-log parameters are non-null. An empty array is ok, just not null.
            if (_connectionstring == null)
            {
                throw new ArgumentNullException("_connectionstring");
            }

            connectionstring = _connectionstring;

            // Create a sql connection. Note, I've decided not to track
            // the opened state of this connection. I'll rely on the
            // sql classes to throw the appropriate exceptions if someone
            // calls Close on this class and then attempts to use some
            // other methods.
            try
            {
                sqlconnection = new SqlConnection(connectionstring);
                sqlconnection.Open();
                sqlMutex = new Mutex(false);
            }
            catch (SqlException sqlException)
            {
                string sErr = "XonWatch.XonWatchDB.ctor: "
                    + "Opening a connection to "
                    + connectionstring
                    + " caused a SqlException. Exception details: "
                    + sqlException.Message;

                throw new XonWatchDBException(sErr, sqlException);
            }
            catch (ArgumentException ArgumentException)
            {
                // this gets thrown if the connection string is improperly formatted
                string sErr = "XonWatch.XonWatchDB.ctor: "
                    + "Opening a connection to "
                    + connectionstring
                    + " caused an ArgumentException. Exception details: "
                    + ArgumentException.Message;

                throw new XonWatchDBException(sErr, ArgumentException);
            }
        }

        public void Close()
        {
            if (sqlconnection != null && sqlconnection.State != ConnectionState.Closed)
            {
                sqlconnection.Close();
            }

            if (sqlMutex != null)
            {
                sqlMutex.Close();
            }
        }
                
        public List<int> EnvironmentListGet()
        {
            SqlCommand sqlCommand = sqlconnection.CreateCommand();
            sqlCommand.CommandText = "p_XonWatchDB_environment_list_get";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            List<int> arrayList = new List<int>();
            SqlDataReader sqlDataReader = null;
            try
            {
                sqlDataReader = sqlCommand.ExecuteReader();
                while (sqlDataReader.Read())
                {
                    int envid = (int)sqlDataReader["i_id"];
                    arrayList.Add(envid);
                }

                // close the reader so we can check the return code
                sqlDataReader.Close();

                int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                if (iRet != 0)
                {
                    string sErr = "XonWatch.XonWatchDB.EnvironmentListGet: The stored procedure "
                        + sqlCommand.CommandText
                        + " returned "
                        + iRet;

                    throw new XonWatchDBException(sErr);
                }
            }
            catch (SqlException sqlException)
            {
                string sErr = "XonWatch.XonWatchDB.EnvironmentListGet: "
                    + "Calling the stored procedure "
                    + sqlCommand.CommandText
                    + " or reading the results caused a SqlException. Exception details: "
                    + sqlException.Message;

                throw new XonWatchDBException(sErr, sqlException);
            }
            finally
            {
                // clean up the sqlDataReader if we need to
                if (sqlDataReader != null && !sqlDataReader.IsClosed)
                {
                    sqlDataReader.Close();
                }
            }

            return arrayList;
        }

        public bool EnvironmentGet(
            int id,
            out string networkid,
            out string location,
            out string useraccounts)
        {

            if (id == 0)
            {
                throw new ArgumentNullException("id");
            }

            SqlCommand sqlCommand = sqlconnection.CreateCommand();
            sqlCommand.CommandText = "p_XonWatchDB_environment_get";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_id", SqlDbType.Int).Value = id;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;
            
            bool bFound = false;
            networkid = string.Empty;
            location = string.Empty;
            useraccounts = string.Empty;
            SqlDataReader sqlDataReader = null;
            try
            {
                // run the command!
                sqlDataReader = sqlCommand.ExecuteReader();

                // get the results
                int iRowsRead = 0;
                while (sqlDataReader.Read())
                {

                    ++iRowsRead;
                    if (iRowsRead > 1)
                    {
                        string sErr = "XonWatch.XonWatchDB.EnvironmentGet: "
                            + " more than one row was returned by "
                            + sqlCommand.CommandText;

                        throw new XonWatchDBException(sErr);
                    }

                    networkid = (string)sqlDataReader["vc_networkid"];
                    location = (string)sqlDataReader["vc_location"];
                    useraccounts = (string)sqlDataReader["txt_useraccounts"];
                }

                // close the reader so we can check the return code
                sqlDataReader.Close();

                int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                if (iRet != 0)
                {
                    string sErr = "XonWatch.XonWatchDB.EnvironmentGet: The stored procedure "
                        + sqlCommand.CommandText
                        + " returned "
                        + iRet;

                    throw new XonWatchDBException(sErr);
                }

                // if we found exactly one row, then we want to return true
                if (iRowsRead == 1)
                {
                    bFound = true;
                }
            }
            catch (SqlException sqlException)
            {
                string sErr = "XonWatchFetcher.EnvironmentGet: "
                    + "Calling the stored procedure "
                    + sqlCommand.CommandText
                    + " or reading the results caused a SqlException. Exception details: "
                    + sqlException.Message;

                throw new XonWatchDBException(sErr, sqlException);
            }
            finally
            {
                // clean up the sqlDataReader if we need to
                if (sqlDataReader != null && !sqlDataReader.IsClosed)
                {
                    sqlDataReader.Close();
                }
            }

            return bFound;
        }

        public DataTable StatusGet(int id)
        {
            DataTable dt = null;
            SqlDataAdapter adapter = null;
            SqlCommand sqlCommand = null;

            try
            {
                sqlCommand = sqlconnection.CreateCommand();
                sqlCommand.CommandText = "p_xonwatchdb_environment_status_get";
                sqlCommand.CommandType = CommandType.StoredProcedure;
                sqlCommand.Parameters.Add("@i_id", SqlDbType.Int).Value = id;
                sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

                adapter = new SqlDataAdapter(sqlCommand);
                dt = new DataTable();
                adapter.Fill(dt);
            }
            catch (SqlException sqlException)
            {
                string sErr = "XonWatchFetcher.StatusGet: "
                + "Calling the stored procedure "
                + sqlCommand.CommandText
                + " or reading the results caused a SqlException. Exception details: "
                + sqlException.Message;

                throw new XonWatchDBException(sErr, sqlException);
            }
            return dt;            
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveMonitor\LiveStatusMonitorService\LiveStatusMonitor.asmx.cs ===
using System;
using System.Web;
using System.Web.Services;

namespace LiveStatusMonitorService
{    
    /// <summary>
    /// Summary description for Service1
    /// </summary>
    [WebService(Namespace = "http://tempuri.org/")]
    [WebServiceBinding(ConformsTo = WsiProfiles.BasicProfile1_1)]
    [System.ComponentModel.ToolboxItem(false)]
    // To allow this Web Service to be called from script, using ASP.NET AJAX, uncomment the following line. 
    // [System.Web.Script.Services.ScriptService]
    public class LiveStatusMonitorService : System.Web.Services.WebService
    {
        [WebMethod(CacheDuration=60)]
        public string XeOnWatchMonitor()
        {
            string xml = null;
            XonWatchFetcher fetcher = new XonWatchFetcher();
            try
            {
                fetcher.Init();
                fetcher.DoWork();
                fetcher.SetStatus(fetcher.m_EnvironmentsObj);
                xml = fetcher.Serialize(fetcher.m_EnvironmentsObj);
            }
            catch (Exception ex)
            {
                string logInfo = "XeOnWatch Monitor Catch an Exception When Process Request From "
                    + HttpContext.Current.Request.UserHostAddress + ".";                    
                Logger.Instance.LogException(logInfo, ex);
            }
            finally
            {
                fetcher.Despose();
            }
            string path = Configuration.ResolvePath("Log\\XeOnWatchMonitor.xml");            
            System.IO.File.WriteAllText(path, xml);
            return xml;
        }

        [WebMethod(CacheDuration = 200)]
        public string HealthCheckMonitor()
        {
            string xml = null;
            HealthCheckFetcher fetcher = new HealthCheckFetcher();
            try
            {
                fetcher.Init();
                fetcher.DoWork();
                fetcher.SetStatus(fetcher.m_EnvironmentsObj);
                xml = fetcher.Serialize(fetcher.m_EnvironmentsObj);
            }
            catch (Exception ex)
            {
                string logInfo = "HealthCheck Monitor Catch an Exception When Process Request From "
                    + HttpContext.Current.Request.UserHostAddress + ".";
                Logger.Instance.LogException(logInfo, ex);
            }
            finally
            {
                fetcher.Despose();
            }
            string path = Configuration.ResolvePath("Log\\HealthCheckMonitor.xml");
            System.IO.File.WriteAllText(path, xml);
            return xml;
        }

        [WebMethod(CacheDuration = 60)]
        public string HealthCheckMonitorForXblob(string serverNameOrIpAddress)
        {
            if (String.IsNullOrEmpty(serverNameOrIpAddress))
            {
                return null;
            }
            
            string xml = null;            
            HealthCheckFetcher fetcher = new HealthCheckFetcher();
            try
            {
                fetcher.SetXblob(serverNameOrIpAddress);
                fetcher.Init();
                fetcher.DoWorkForXblob();
                fetcher.SetStatus(fetcher.m_XblobEnvironmentsObj);
                xml = fetcher.Serialize(fetcher.m_XblobEnvironmentsObj);
            }
            catch (Exception ex)
            {
                string logInfo = "HealthCheck Monitor Catch an Exception When Process Request From "
                    + HttpContext.Current.Request.UserHostAddress + " For Xblob "
                    + serverNameOrIpAddress + ".";                    
                Logger.Instance.LogException(logInfo, ex);
            }
            finally
            {
                fetcher.Despose();
            }
            string path = Configuration.ResolvePath("Log\\HealthCheckMonitor_" + serverNameOrIpAddress + ".xml");
            System.IO.File.WriteAllText(path, xml);
            return xml;
        }

        [WebMethod]
        public bool IsUpdateNeeded(string ver)
        {
            string path = Configuration.ResolvePath(Properties.Settings.Default.LatestWidgetVersionFile);
            bool isUpdateNeeded = false;
            if (System.IO.File.Exists(path))
            {
                string text = System.IO.File.ReadAllText(path);
                System.Version version = new Version(ver);
                if (version.CompareTo(new Version(text)) < 0)
                {
                    isUpdateNeeded = true;
                }
            }
            return isUpdateNeeded;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveMonitor\LiveStatusMonitorService\Properties\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("LiveStatusMonitorService")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("3d5900ae-111a-45be-96b3-d9e4606ca793")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveMonitor\LiveStatusMonitorService\WebFetcherForCoreDomain\Reference.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3603
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by Microsoft.VSDesigner, Version 2.0.50727.3603.
// 
#pragma warning disable 1591

namespace LiveStatusMonitorService.WebFetcherForCoreDomain {
    using System.Diagnostics;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Xml.Serialization;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.3053")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="WebFetcherServiceSoap", Namespace="http://www.xbox.com/")]
    public partial class WebFetcherService : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        private System.Threading.SendOrPostCallback WebFetcherOperationCompleted;
        
        private System.Threading.SendOrPostCallback UpdateUrlsOperationCompleted;
        
        private bool useDefaultCredentialsSetExplicitly;
        
        /// <remarks/>
        public WebFetcherService() {
            this.Url = global::LiveStatusMonitorService.Properties.Settings.Default.LiveStatusMonitorService_WebFetcherForCoreDomain_WebFetcherService;
            if ((this.IsLocalFileSystemWebService(this.Url) == true)) {
                this.UseDefaultCredentials = true;
                this.useDefaultCredentialsSetExplicitly = false;
            }
            else {
                this.useDefaultCredentialsSetExplicitly = true;
            }
        }
        
        public new string Url {
            get {
                return base.Url;
            }
            set {
                if ((((this.IsLocalFileSystemWebService(base.Url) == true) 
                            && (this.useDefaultCredentialsSetExplicitly == false)) 
                            && (this.IsLocalFileSystemWebService(value) == false))) {
                    base.UseDefaultCredentials = false;
                }
                base.Url = value;
            }
        }
        
        public new bool UseDefaultCredentials {
            get {
                return base.UseDefaultCredentials;
            }
            set {
                base.UseDefaultCredentials = value;
                this.useDefaultCredentialsSetExplicitly = true;
            }
        }
        
        /// <remarks/>
        public event WebFetcherCompletedEventHandler WebFetcherCompleted;
        
        /// <remarks/>
        public event UpdateUrlsCompletedEventHandler UpdateUrlsCompleted;
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.xbox.com/WebFetcher", RequestNamespace="http://www.xbox.com/", ResponseNamespace="http://www.xbox.com/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string WebFetcher(string url) {
            object[] results = this.Invoke("WebFetcher", new object[] {
                        url});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void WebFetcherAsync(string url) {
            this.WebFetcherAsync(url, null);
        }
        
        /// <remarks/>
        public void WebFetcherAsync(string url, object userState) {
            if ((this.WebFetcherOperationCompleted == null)) {
                this.WebFetcherOperationCompleted = new System.Threading.SendOrPostCallback(this.OnWebFetcherOperationCompleted);
            }
            this.InvokeAsync("WebFetcher", new object[] {
                        url}, this.WebFetcherOperationCompleted, userState);
        }
        
        private void OnWebFetcherOperationCompleted(object arg) {
            if ((this.WebFetcherCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.WebFetcherCompleted(this, new WebFetcherCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.xbox.com/UpdateUrls", RequestNamespace="http://www.xbox.com/", ResponseNamespace="http://www.xbox.com/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string UpdateUrls(string name, string npdb, string domain, bool dynamicurl) {
            object[] results = this.Invoke("UpdateUrls", new object[] {
                        name,
                        npdb,
                        domain,
                        dynamicurl});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void UpdateUrlsAsync(string name, string npdb, string domain, bool dynamicurl) {
            this.UpdateUrlsAsync(name, npdb, domain, dynamicurl, null);
        }
        
        /// <remarks/>
        public void UpdateUrlsAsync(string name, string npdb, string domain, bool dynamicurl, object userState) {
            if ((this.UpdateUrlsOperationCompleted == null)) {
                this.UpdateUrlsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnUpdateUrlsOperationCompleted);
            }
            this.InvokeAsync("UpdateUrls", new object[] {
                        name,
                        npdb,
                        domain,
                        dynamicurl}, this.UpdateUrlsOperationCompleted, userState);
        }
        
        private void OnUpdateUrlsOperationCompleted(object arg) {
            if ((this.UpdateUrlsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.UpdateUrlsCompleted(this, new UpdateUrlsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        public new void CancelAsync(object userState) {
            base.CancelAsync(userState);
        }
        
        private bool IsLocalFileSystemWebService(string url) {
            if (((url == null) 
                        || (url == string.Empty))) {
                return false;
            }
            System.Uri wsUri = new System.Uri(url);
            if (((wsUri.Port >= 1024) 
                        && (string.Compare(wsUri.Host, "localHost", System.StringComparison.OrdinalIgnoreCase) == 0))) {
                return true;
            }
            return false;
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.3053")]
    public delegate void WebFetcherCompletedEventHandler(object sender, WebFetcherCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.3053")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class WebFetcherCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal WebFetcherCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.3053")]
    public delegate void UpdateUrlsCompletedEventHandler(object sender, UpdateUrlsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.3053")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class UpdateUrlsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal UpdateUrlsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
}

#pragma warning restore 1591
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveMonitor\LiveStatusMonitorService\WebFetcherForHyperDomain\Reference.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3074
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by Microsoft.VSDesigner, Version 2.0.50727.3074.
// 
#pragma warning disable 1591

namespace LiveStatusMonitorService.WebFetcherForHyperDomain {
    using System.Diagnostics;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Xml.Serialization;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.3053")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="WebFetcherServiceSoap", Namespace="http://www.xbox.com/")]
    public partial class WebFetcherService : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        private System.Threading.SendOrPostCallback WebFetcherOperationCompleted;
        
        private System.Threading.SendOrPostCallback UpdateUrlsOperationCompleted;
        
        private bool useDefaultCredentialsSetExplicitly;
        
        /// <remarks/>
        public WebFetcherService() {
            this.Url = global::LiveStatusMonitorService.Properties.Settings.Default.LiveStatusMonitorService_WebFetcherForHyperDomain_WebFetcherService;
            if ((this.IsLocalFileSystemWebService(this.Url) == true)) {
                this.UseDefaultCredentials = true;
                this.useDefaultCredentialsSetExplicitly = false;
            }
            else {
                this.useDefaultCredentialsSetExplicitly = true;
            }
        }
        
        public new string Url {
            get {
                return base.Url;
            }
            set {
                if ((((this.IsLocalFileSystemWebService(base.Url) == true) 
                            && (this.useDefaultCredentialsSetExplicitly == false)) 
                            && (this.IsLocalFileSystemWebService(value) == false))) {
                    base.UseDefaultCredentials = false;
                }
                base.Url = value;
            }
        }
        
        public new bool UseDefaultCredentials {
            get {
                return base.UseDefaultCredentials;
            }
            set {
                base.UseDefaultCredentials = value;
                this.useDefaultCredentialsSetExplicitly = true;
            }
        }
        
        /// <remarks/>
        public event WebFetcherCompletedEventHandler WebFetcherCompleted;
        
        /// <remarks/>
        public event UpdateUrlsCompletedEventHandler UpdateUrlsCompleted;
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.xbox.com/WebFetcher", RequestNamespace="http://www.xbox.com/", ResponseNamespace="http://www.xbox.com/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string WebFetcher(string url) {
            object[] results = this.Invoke("WebFetcher", new object[] {
                        url});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void WebFetcherAsync(string url) {
            this.WebFetcherAsync(url, null);
        }
        
        /// <remarks/>
        public void WebFetcherAsync(string url, object userState) {
            if ((this.WebFetcherOperationCompleted == null)) {
                this.WebFetcherOperationCompleted = new System.Threading.SendOrPostCallback(this.OnWebFetcherOperationCompleted);
            }
            this.InvokeAsync("WebFetcher", new object[] {
                        url}, this.WebFetcherOperationCompleted, userState);
        }
        
        private void OnWebFetcherOperationCompleted(object arg) {
            if ((this.WebFetcherCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.WebFetcherCompleted(this, new WebFetcherCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.xbox.com/UpdateUrls", RequestNamespace="http://www.xbox.com/", ResponseNamespace="http://www.xbox.com/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string UpdateUrls(string name, string npdb, string domain, bool dynamicurl) {
            object[] results = this.Invoke("UpdateUrls", new object[] {
                        name,
                        npdb,
                        domain,
                        dynamicurl});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void UpdateUrlsAsync(string name, string npdb, string domain, bool dynamicurl) {
            this.UpdateUrlsAsync(name, npdb, domain, dynamicurl, null);
        }
        
        /// <remarks/>
        public void UpdateUrlsAsync(string name, string npdb, string domain, bool dynamicurl, object userState) {
            if ((this.UpdateUrlsOperationCompleted == null)) {
                this.UpdateUrlsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnUpdateUrlsOperationCompleted);
            }
            this.InvokeAsync("UpdateUrls", new object[] {
                        name,
                        npdb,
                        domain,
                        dynamicurl}, this.UpdateUrlsOperationCompleted, userState);
        }
        
        private void OnUpdateUrlsOperationCompleted(object arg) {
            if ((this.UpdateUrlsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.UpdateUrlsCompleted(this, new UpdateUrlsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        public new void CancelAsync(object userState) {
            base.CancelAsync(userState);
        }
        
        private bool IsLocalFileSystemWebService(string url) {
            if (((url == null) 
                        || (url == string.Empty))) {
                return false;
            }
            System.Uri wsUri = new System.Uri(url);
            if (((wsUri.Port >= 1024) 
                        && (string.Compare(wsUri.Host, "localHost", System.StringComparison.OrdinalIgnoreCase) == 0))) {
                return true;
            }
            return false;
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.3053")]
    public delegate void WebFetcherCompletedEventHandler(object sender, WebFetcherCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.3053")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class WebFetcherCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal WebFetcherCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.3053")]
    public delegate void UpdateUrlsCompletedEventHandler(object sender, UpdateUrlsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.3053")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class UpdateUrlsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal UpdateUrlsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
}

#pragma warning restore 1591
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveMonitor\LiveStatusMonitorService\WebFetcherForCertDomain\Reference.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3603
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by Microsoft.VSDesigner, Version 2.0.50727.3603.
// 
#pragma warning disable 1591

namespace LiveStatusMonitorService.WebFetcherForCertDomain {
    using System.Diagnostics;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Xml.Serialization;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.3053")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="WebFetcherServiceSoap", Namespace="http://www.xbox.com/")]
    public partial class WebFetcherService : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        private System.Threading.SendOrPostCallback WebFetcherOperationCompleted;
        
        private System.Threading.SendOrPostCallback UpdateUrlsOperationCompleted;
        
        private bool useDefaultCredentialsSetExplicitly;
        
        /// <remarks/>
        public WebFetcherService() {
            this.Url = global::LiveStatusMonitorService.Properties.Settings.Default.LiveStatusMonitorService_WebFetcherForCertDomain_WebFetcherService;
            if ((this.IsLocalFileSystemWebService(this.Url) == true)) {
                this.UseDefaultCredentials = true;
                this.useDefaultCredentialsSetExplicitly = false;
            }
            else {
                this.useDefaultCredentialsSetExplicitly = true;
            }
        }
        
        public new string Url {
            get {
                return base.Url;
            }
            set {
                if ((((this.IsLocalFileSystemWebService(base.Url) == true) 
                            && (this.useDefaultCredentialsSetExplicitly == false)) 
                            && (this.IsLocalFileSystemWebService(value) == false))) {
                    base.UseDefaultCredentials = false;
                }
                base.Url = value;
            }
        }
        
        public new bool UseDefaultCredentials {
            get {
                return base.UseDefaultCredentials;
            }
            set {
                base.UseDefaultCredentials = value;
                this.useDefaultCredentialsSetExplicitly = true;
            }
        }
        
        /// <remarks/>
        public event WebFetcherCompletedEventHandler WebFetcherCompleted;
        
        /// <remarks/>
        public event UpdateUrlsCompletedEventHandler UpdateUrlsCompleted;
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.xbox.com/WebFetcher", RequestNamespace="http://www.xbox.com/", ResponseNamespace="http://www.xbox.com/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string WebFetcher(string url) {
            object[] results = this.Invoke("WebFetcher", new object[] {
                        url});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void WebFetcherAsync(string url) {
            this.WebFetcherAsync(url, null);
        }
        
        /// <remarks/>
        public void WebFetcherAsync(string url, object userState) {
            if ((this.WebFetcherOperationCompleted == null)) {
                this.WebFetcherOperationCompleted = new System.Threading.SendOrPostCallback(this.OnWebFetcherOperationCompleted);
            }
            this.InvokeAsync("WebFetcher", new object[] {
                        url}, this.WebFetcherOperationCompleted, userState);
        }
        
        private void OnWebFetcherOperationCompleted(object arg) {
            if ((this.WebFetcherCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.WebFetcherCompleted(this, new WebFetcherCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.xbox.com/UpdateUrls", RequestNamespace="http://www.xbox.com/", ResponseNamespace="http://www.xbox.com/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string UpdateUrls(string name, string npdb, string domain, bool dynamicurl) {
            object[] results = this.Invoke("UpdateUrls", new object[] {
                        name,
                        npdb,
                        domain,
                        dynamicurl});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void UpdateUrlsAsync(string name, string npdb, string domain, bool dynamicurl) {
            this.UpdateUrlsAsync(name, npdb, domain, dynamicurl, null);
        }
        
        /// <remarks/>
        public void UpdateUrlsAsync(string name, string npdb, string domain, bool dynamicurl, object userState) {
            if ((this.UpdateUrlsOperationCompleted == null)) {
                this.UpdateUrlsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnUpdateUrlsOperationCompleted);
            }
            this.InvokeAsync("UpdateUrls", new object[] {
                        name,
                        npdb,
                        domain,
                        dynamicurl}, this.UpdateUrlsOperationCompleted, userState);
        }
        
        private void OnUpdateUrlsOperationCompleted(object arg) {
            if ((this.UpdateUrlsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.UpdateUrlsCompleted(this, new UpdateUrlsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        public new void CancelAsync(object userState) {
            base.CancelAsync(userState);
        }
        
        private bool IsLocalFileSystemWebService(string url) {
            if (((url == null) 
                        || (url == string.Empty))) {
                return false;
            }
            System.Uri wsUri = new System.Uri(url);
            if (((wsUri.Port >= 1024) 
                        && (string.Compare(wsUri.Host, "localHost", System.StringComparison.OrdinalIgnoreCase) == 0))) {
                return true;
            }
            return false;
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.3053")]
    public delegate void WebFetcherCompletedEventHandler(object sender, WebFetcherCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.3053")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class WebFetcherCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal WebFetcherCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.3053")]
    public delegate void UpdateUrlsCompletedEventHandler(object sender, UpdateUrlsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.3053")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class UpdateUrlsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal UpdateUrlsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
}

#pragma warning restore 1591
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveMonitor\LiveStatusMonitorService\Properties\Settings.Designer.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4952
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace LiveStatusMonitorService.Properties {
    
    
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "9.0.0.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase {
        
        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));
        
        public static Settings Default {
            get {
                return defaultInstance;
            }
        }
        
        [global::System.Configuration.ApplicationScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("HealthCheckConfig.xml")]
        public string HealthCheckConfigFile {
            get {
                return ((string)(this["HealthCheckConfigFile"]));
            }
        }
        
        [global::System.Configuration.ApplicationScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("1")]
        public int XeOnWatchResultsExpiredDurationinHours {
            get {
                return ((int)(this["XeOnWatchResultsExpiredDurationinHours"]));
            }
        }
        
        [global::System.Configuration.ApplicationScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.SpecialSettingAttribute(global::System.Configuration.SpecialSetting.WebServiceUrl)]
        [global::System.Configuration.DefaultSettingValueAttribute("http://10.184.227.50/LiveMonitor/WebFetcherService.asmx")]
        public string LiveStatusMonitorService_WebFetcherForHyperDomain_WebFetcherService {
            get {
                return ((string)(this["LiveStatusMonitorService_WebFetcherForHyperDomain_WebFetcherService"]));
            }
        }
        
        [global::System.Configuration.ApplicationScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.SpecialSettingAttribute(global::System.Configuration.SpecialSetting.WebServiceUrl)]
        [global::System.Configuration.DefaultSettingValueAttribute("http://10.193.108.64/LiveMonitor/WebFetcherService.asmx")]
        public string LiveStatusMonitorService_WebFetcherForInternetDomain_WebFetcherService {
            get {
                return ((string)(this["LiveStatusMonitorService_WebFetcherForInternetDomain_WebFetcherService"]));
            }
        }
        
        [global::System.Configuration.ApplicationScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("LatestWidgetVersion.txt")]
        public string LatestWidgetVersionFile {
            get {
                return ((string)(this["LatestWidgetVersionFile"]));
            }
        }
        
        [global::System.Configuration.ApplicationScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.SpecialSettingAttribute(global::System.Configuration.SpecialSetting.WebServiceUrl)]
        [global::System.Configuration.DefaultSettingValueAttribute("http://lesthealthfetch.test.xboxlive.com/WebFetcherService.asmx")]
        public string LiveStatusMonitorService_WebFetcherForCoreDomain_WebFetcherService {
            get {
                return ((string)(this["LiveStatusMonitorService_WebFetcherForCoreDomain_WebFetcherService"]));
            }
        }
        
        [global::System.Configuration.ApplicationScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.SpecialSettingAttribute(global::System.Configuration.SpecialSetting.WebServiceUrl)]
        [global::System.Configuration.DefaultSettingValueAttribute("http://lesthealthfetch.dev.xboxlive.com/webfetcherservice.asmx")]
        public string LiveStatusMonitorService_WebFetcherForRedmondDomain_WebFetcherService {
            get {
                return ((string)(this["LiveStatusMonitorService_WebFetcherForRedmondDomain_WebFetcherService"]));
            }
        }
        
        [global::System.Configuration.ApplicationScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("http://lesthealthfetch.int2.xboxlive.com/WebFetcherService.asmx")]
        public string LiveStatusMonitorService_WebFetcherForInt2Domain_WebFetcherService {
            get {
                return ((string)(this["LiveStatusMonitorService_WebFetcherForInt2Domain_WebFetcherService"]));
            }
        }
        
        [global::System.Configuration.ApplicationScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("http://lesthealthfetch.part.xboxlive.com/WebFetcherService.asmx")]
        public string LiveStatusMonitorService_WebFetcherForPartDomain_WebFetcherService {
            get {
                return ((string)(this["LiveStatusMonitorService_WebFetcherForPartDomain_WebFetcherService"]));
            }
        }
        
        [global::System.Configuration.ApplicationScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("http://lesthealthfetch.cert.xboxlive.com/WebFetcherService.asmx")]
        public string LiveStatusMonitorService_WebFetcherForCertDomain_WebFetcherService {
            get {
                return ((string)(this["LiveStatusMonitorService_WebFetcherForCertDomain_WebFetcherService"]));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveMonitor\LiveStatusMonitorService\WebFetcherForInternetDomain\Reference.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3074
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by Microsoft.VSDesigner, Version 2.0.50727.3074.
// 
#pragma warning disable 1591

namespace LiveStatusMonitorService.WebFetcherForInternetDomain {
    using System.Diagnostics;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Xml.Serialization;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.3053")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="WebFetcherServiceSoap", Namespace="http://www.xbox.com/")]
    public partial class WebFetcherService : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        private System.Threading.SendOrPostCallback WebFetcherOperationCompleted;
        
        private System.Threading.SendOrPostCallback UpdateUrlsOperationCompleted;
        
        private bool useDefaultCredentialsSetExplicitly;
        
        /// <remarks/>
        public WebFetcherService() {
            this.Url = global::LiveStatusMonitorService.Properties.Settings.Default.LiveStatusMonitorService_WebFetcherForInternetDomain_WebFetcherService;
            if ((this.IsLocalFileSystemWebService(this.Url) == true)) {
                this.UseDefaultCredentials = true;
                this.useDefaultCredentialsSetExplicitly = false;
            }
            else {
                this.useDefaultCredentialsSetExplicitly = true;
            }
        }
        
        public new string Url {
            get {
                return base.Url;
            }
            set {
                if ((((this.IsLocalFileSystemWebService(base.Url) == true) 
                            && (this.useDefaultCredentialsSetExplicitly == false)) 
                            && (this.IsLocalFileSystemWebService(value) == false))) {
                    base.UseDefaultCredentials = false;
                }
                base.Url = value;
            }
        }
        
        public new bool UseDefaultCredentials {
            get {
                return base.UseDefaultCredentials;
            }
            set {
                base.UseDefaultCredentials = value;
                this.useDefaultCredentialsSetExplicitly = true;
            }
        }
        
        /// <remarks/>
        public event WebFetcherCompletedEventHandler WebFetcherCompleted;
        
        /// <remarks/>
        public event UpdateUrlsCompletedEventHandler UpdateUrlsCompleted;
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.xbox.com/WebFetcher", RequestNamespace="http://www.xbox.com/", ResponseNamespace="http://www.xbox.com/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string WebFetcher(string url) {
            object[] results = this.Invoke("WebFetcher", new object[] {
                        url});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void WebFetcherAsync(string url) {
            this.WebFetcherAsync(url, null);
        }
        
        /// <remarks/>
        public void WebFetcherAsync(string url, object userState) {
            if ((this.WebFetcherOperationCompleted == null)) {
                this.WebFetcherOperationCompleted = new System.Threading.SendOrPostCallback(this.OnWebFetcherOperationCompleted);
            }
            this.InvokeAsync("WebFetcher", new object[] {
                        url}, this.WebFetcherOperationCompleted, userState);
        }
        
        private void OnWebFetcherOperationCompleted(object arg) {
            if ((this.WebFetcherCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.WebFetcherCompleted(this, new WebFetcherCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.xbox.com/UpdateUrls", RequestNamespace="http://www.xbox.com/", ResponseNamespace="http://www.xbox.com/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string UpdateUrls(string name, string npdb, string domain, bool dynamicurl) {
            object[] results = this.Invoke("UpdateUrls", new object[] {
                        name,
                        npdb,
                        domain,
                        dynamicurl});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void UpdateUrlsAsync(string name, string npdb, string domain, bool dynamicurl) {
            this.UpdateUrlsAsync(name, npdb, domain, dynamicurl, null);
        }
        
        /// <remarks/>
        public void UpdateUrlsAsync(string name, string npdb, string domain, bool dynamicurl, object userState) {
            if ((this.UpdateUrlsOperationCompleted == null)) {
                this.UpdateUrlsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnUpdateUrlsOperationCompleted);
            }
            this.InvokeAsync("UpdateUrls", new object[] {
                        name,
                        npdb,
                        domain,
                        dynamicurl}, this.UpdateUrlsOperationCompleted, userState);
        }
        
        private void OnUpdateUrlsOperationCompleted(object arg) {
            if ((this.UpdateUrlsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.UpdateUrlsCompleted(this, new UpdateUrlsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        public new void CancelAsync(object userState) {
            base.CancelAsync(userState);
        }
        
        private bool IsLocalFileSystemWebService(string url) {
            if (((url == null) 
                        || (url == string.Empty))) {
                return false;
            }
            System.Uri wsUri = new System.Uri(url);
            if (((wsUri.Port >= 1024) 
                        && (string.Compare(wsUri.Host, "localHost", System.StringComparison.OrdinalIgnoreCase) == 0))) {
                return true;
            }
            return false;
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.3053")]
    public delegate void WebFetcherCompletedEventHandler(object sender, WebFetcherCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.3053")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class WebFetcherCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal WebFetcherCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.3053")]
    public delegate void UpdateUrlsCompletedEventHandler(object sender, UpdateUrlsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.3053")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class UpdateUrlsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal UpdateUrlsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
}

#pragma warning restore 1591
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveMonitor\LiveStatusMonitorService\WebFetcherForPartDomain\Reference.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3603
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by Microsoft.VSDesigner, Version 2.0.50727.3603.
// 
#pragma warning disable 1591

namespace LiveStatusMonitorService.WebFetcherForPartDomain {
    using System.Diagnostics;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Xml.Serialization;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.3053")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="WebFetcherServiceSoap", Namespace="http://www.xbox.com/")]
    public partial class WebFetcherService : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        private System.Threading.SendOrPostCallback WebFetcherOperationCompleted;
        
        private System.Threading.SendOrPostCallback UpdateUrlsOperationCompleted;
        
        private bool useDefaultCredentialsSetExplicitly;
        
        /// <remarks/>
        public WebFetcherService() {
            this.Url = global::LiveStatusMonitorService.Properties.Settings.Default.LiveStatusMonitorService_WebFetcherForPartDomain_WebFetcherService;
            if ((this.IsLocalFileSystemWebService(this.Url) == true)) {
                this.UseDefaultCredentials = true;
                this.useDefaultCredentialsSetExplicitly = false;
            }
            else {
                this.useDefaultCredentialsSetExplicitly = true;
            }
        }
        
        public new string Url {
            get {
                return base.Url;
            }
            set {
                if ((((this.IsLocalFileSystemWebService(base.Url) == true) 
                            && (this.useDefaultCredentialsSetExplicitly == false)) 
                            && (this.IsLocalFileSystemWebService(value) == false))) {
                    base.UseDefaultCredentials = false;
                }
                base.Url = value;
            }
        }
        
        public new bool UseDefaultCredentials {
            get {
                return base.UseDefaultCredentials;
            }
            set {
                base.UseDefaultCredentials = value;
                this.useDefaultCredentialsSetExplicitly = true;
            }
        }
        
        /// <remarks/>
        public event WebFetcherCompletedEventHandler WebFetcherCompleted;
        
        /// <remarks/>
        public event UpdateUrlsCompletedEventHandler UpdateUrlsCompleted;
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.xbox.com/WebFetcher", RequestNamespace="http://www.xbox.com/", ResponseNamespace="http://www.xbox.com/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string WebFetcher(string url) {
            object[] results = this.Invoke("WebFetcher", new object[] {
                        url});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void WebFetcherAsync(string url) {
            this.WebFetcherAsync(url, null);
        }
        
        /// <remarks/>
        public void WebFetcherAsync(string url, object userState) {
            if ((this.WebFetcherOperationCompleted == null)) {
                this.WebFetcherOperationCompleted = new System.Threading.SendOrPostCallback(this.OnWebFetcherOperationCompleted);
            }
            this.InvokeAsync("WebFetcher", new object[] {
                        url}, this.WebFetcherOperationCompleted, userState);
        }
        
        private void OnWebFetcherOperationCompleted(object arg) {
            if ((this.WebFetcherCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.WebFetcherCompleted(this, new WebFetcherCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.xbox.com/UpdateUrls", RequestNamespace="http://www.xbox.com/", ResponseNamespace="http://www.xbox.com/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string UpdateUrls(string name, string npdb, string domain, bool dynamicurl) {
            object[] results = this.Invoke("UpdateUrls", new object[] {
                        name,
                        npdb,
                        domain,
                        dynamicurl});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void UpdateUrlsAsync(string name, string npdb, string domain, bool dynamicurl) {
            this.UpdateUrlsAsync(name, npdb, domain, dynamicurl, null);
        }
        
        /// <remarks/>
        public void UpdateUrlsAsync(string name, string npdb, string domain, bool dynamicurl, object userState) {
            if ((this.UpdateUrlsOperationCompleted == null)) {
                this.UpdateUrlsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnUpdateUrlsOperationCompleted);
            }
            this.InvokeAsync("UpdateUrls", new object[] {
                        name,
                        npdb,
                        domain,
                        dynamicurl}, this.UpdateUrlsOperationCompleted, userState);
        }
        
        private void OnUpdateUrlsOperationCompleted(object arg) {
            if ((this.UpdateUrlsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.UpdateUrlsCompleted(this, new UpdateUrlsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        public new void CancelAsync(object userState) {
            base.CancelAsync(userState);
        }
        
        private bool IsLocalFileSystemWebService(string url) {
            if (((url == null) 
                        || (url == string.Empty))) {
                return false;
            }
            System.Uri wsUri = new System.Uri(url);
            if (((wsUri.Port >= 1024) 
                        && (string.Compare(wsUri.Host, "localHost", System.StringComparison.OrdinalIgnoreCase) == 0))) {
                return true;
            }
            return false;
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.3053")]
    public delegate void WebFetcherCompletedEventHandler(object sender, WebFetcherCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.3053")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class WebFetcherCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal WebFetcherCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.3053")]
    public delegate void UpdateUrlsCompletedEventHandler(object sender, UpdateUrlsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.3053")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class UpdateUrlsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal UpdateUrlsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
}

#pragma warning restore 1591
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveMonitor\LiveStatusMonitorService\WebFetcherForInt2Domain\Reference.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3603
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by Microsoft.VSDesigner, Version 2.0.50727.3603.
// 
#pragma warning disable 1591

namespace LiveStatusMonitorService.WebFetcherForInt2Domain {
    using System.Diagnostics;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Xml.Serialization;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.3053")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="WebFetcherServiceSoap", Namespace="http://www.xbox.com/")]
    public partial class WebFetcherService : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        private System.Threading.SendOrPostCallback WebFetcherOperationCompleted;
        
        private System.Threading.SendOrPostCallback UpdateUrlsOperationCompleted;
        
        private bool useDefaultCredentialsSetExplicitly;
        
        /// <remarks/>
        public WebFetcherService() {
            this.Url = global::LiveStatusMonitorService.Properties.Settings.Default.LiveStatusMonitorService_WebFetcherForInt2Domain_WebFetcherService;
            if ((this.IsLocalFileSystemWebService(this.Url) == true)) {
                this.UseDefaultCredentials = true;
                this.useDefaultCredentialsSetExplicitly = false;
            }
            else {
                this.useDefaultCredentialsSetExplicitly = true;
            }
        }
        
        public new string Url {
            get {
                return base.Url;
            }
            set {
                if ((((this.IsLocalFileSystemWebService(base.Url) == true) 
                            && (this.useDefaultCredentialsSetExplicitly == false)) 
                            && (this.IsLocalFileSystemWebService(value) == false))) {
                    base.UseDefaultCredentials = false;
                }
                base.Url = value;
            }
        }
        
        public new bool UseDefaultCredentials {
            get {
                return base.UseDefaultCredentials;
            }
            set {
                base.UseDefaultCredentials = value;
                this.useDefaultCredentialsSetExplicitly = true;
            }
        }
        
        /// <remarks/>
        public event WebFetcherCompletedEventHandler WebFetcherCompleted;
        
        /// <remarks/>
        public event UpdateUrlsCompletedEventHandler UpdateUrlsCompleted;
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.xbox.com/WebFetcher", RequestNamespace="http://www.xbox.com/", ResponseNamespace="http://www.xbox.com/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string WebFetcher(string url) {
            object[] results = this.Invoke("WebFetcher", new object[] {
                        url});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void WebFetcherAsync(string url) {
            this.WebFetcherAsync(url, null);
        }
        
        /// <remarks/>
        public void WebFetcherAsync(string url, object userState) {
            if ((this.WebFetcherOperationCompleted == null)) {
                this.WebFetcherOperationCompleted = new System.Threading.SendOrPostCallback(this.OnWebFetcherOperationCompleted);
            }
            this.InvokeAsync("WebFetcher", new object[] {
                        url}, this.WebFetcherOperationCompleted, userState);
        }
        
        private void OnWebFetcherOperationCompleted(object arg) {
            if ((this.WebFetcherCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.WebFetcherCompleted(this, new WebFetcherCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.xbox.com/UpdateUrls", RequestNamespace="http://www.xbox.com/", ResponseNamespace="http://www.xbox.com/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string UpdateUrls(string name, string npdb, string domain, bool dynamicurl) {
            object[] results = this.Invoke("UpdateUrls", new object[] {
                        name,
                        npdb,
                        domain,
                        dynamicurl});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void UpdateUrlsAsync(string name, string npdb, string domain, bool dynamicurl) {
            this.UpdateUrlsAsync(name, npdb, domain, dynamicurl, null);
        }
        
        /// <remarks/>
        public void UpdateUrlsAsync(string name, string npdb, string domain, bool dynamicurl, object userState) {
            if ((this.UpdateUrlsOperationCompleted == null)) {
                this.UpdateUrlsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnUpdateUrlsOperationCompleted);
            }
            this.InvokeAsync("UpdateUrls", new object[] {
                        name,
                        npdb,
                        domain,
                        dynamicurl}, this.UpdateUrlsOperationCompleted, userState);
        }
        
        private void OnUpdateUrlsOperationCompleted(object arg) {
            if ((this.UpdateUrlsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.UpdateUrlsCompleted(this, new UpdateUrlsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        public new void CancelAsync(object userState) {
            base.CancelAsync(userState);
        }
        
        private bool IsLocalFileSystemWebService(string url) {
            if (((url == null) 
                        || (url == string.Empty))) {
                return false;
            }
            System.Uri wsUri = new System.Uri(url);
            if (((wsUri.Port >= 1024) 
                        && (string.Compare(wsUri.Host, "localHost", System.StringComparison.OrdinalIgnoreCase) == 0))) {
                return true;
            }
            return false;
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.3053")]
    public delegate void WebFetcherCompletedEventHandler(object sender, WebFetcherCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.3053")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class WebFetcherCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal WebFetcherCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.3053")]
    public delegate void UpdateUrlsCompletedEventHandler(object sender, UpdateUrlsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.3053")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class UpdateUrlsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal UpdateUrlsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
}

#pragma warning restore 1591
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveMonitor\LiveStatusMonitorService\WebFetcherForRedmondDomain\Reference.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4952
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by Microsoft.VSDesigner, Version 2.0.50727.4952.
// 
#pragma warning disable 1591

namespace LiveStatusMonitorService.WebFetcherForRedmondDomain {
    using System.Diagnostics;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Xml.Serialization;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.4927")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="WebFetcherServiceSoap", Namespace="http://www.xbox.com/")]
    public partial class WebFetcherService : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        private System.Threading.SendOrPostCallback WebFetcherOperationCompleted;
        
        private System.Threading.SendOrPostCallback UpdateUrlsOperationCompleted;
        
        private bool useDefaultCredentialsSetExplicitly;
        
        /// <remarks/>
        public WebFetcherService() {
            this.Url = "http://lesthealthfetch.dev.xboxlive.com/webfetcherservice.asmx";
            if ((this.IsLocalFileSystemWebService(this.Url) == true)) {
                this.UseDefaultCredentials = true;
                this.useDefaultCredentialsSetExplicitly = false;
            }
            else {
                this.useDefaultCredentialsSetExplicitly = true;
            }
        }
        
        public new string Url {
            get {
                return base.Url;
            }
            set {
                if ((((this.IsLocalFileSystemWebService(base.Url) == true) 
                            && (this.useDefaultCredentialsSetExplicitly == false)) 
                            && (this.IsLocalFileSystemWebService(value) == false))) {
                    base.UseDefaultCredentials = false;
                }
                base.Url = value;
            }
        }
        
        public new bool UseDefaultCredentials {
            get {
                return base.UseDefaultCredentials;
            }
            set {
                base.UseDefaultCredentials = value;
                this.useDefaultCredentialsSetExplicitly = true;
            }
        }
        
        /// <remarks/>
        public event WebFetcherCompletedEventHandler WebFetcherCompleted;
        
        /// <remarks/>
        public event UpdateUrlsCompletedEventHandler UpdateUrlsCompleted;
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.xbox.com/WebFetcher", RequestNamespace="http://www.xbox.com/", ResponseNamespace="http://www.xbox.com/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string WebFetcher(string url) {
            object[] results = this.Invoke("WebFetcher", new object[] {
                        url});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void WebFetcherAsync(string url) {
            this.WebFetcherAsync(url, null);
        }
        
        /// <remarks/>
        public void WebFetcherAsync(string url, object userState) {
            if ((this.WebFetcherOperationCompleted == null)) {
                this.WebFetcherOperationCompleted = new System.Threading.SendOrPostCallback(this.OnWebFetcherOperationCompleted);
            }
            this.InvokeAsync("WebFetcher", new object[] {
                        url}, this.WebFetcherOperationCompleted, userState);
        }
        
        private void OnWebFetcherOperationCompleted(object arg) {
            if ((this.WebFetcherCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.WebFetcherCompleted(this, new WebFetcherCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.xbox.com/UpdateUrls", RequestNamespace="http://www.xbox.com/", ResponseNamespace="http://www.xbox.com/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string UpdateUrls(string name, string npdb, string domain, bool dynamicurl) {
            object[] results = this.Invoke("UpdateUrls", new object[] {
                        name,
                        npdb,
                        domain,
                        dynamicurl});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void UpdateUrlsAsync(string name, string npdb, string domain, bool dynamicurl) {
            this.UpdateUrlsAsync(name, npdb, domain, dynamicurl, null);
        }
        
        /// <remarks/>
        public void UpdateUrlsAsync(string name, string npdb, string domain, bool dynamicurl, object userState) {
            if ((this.UpdateUrlsOperationCompleted == null)) {
                this.UpdateUrlsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnUpdateUrlsOperationCompleted);
            }
            this.InvokeAsync("UpdateUrls", new object[] {
                        name,
                        npdb,
                        domain,
                        dynamicurl}, this.UpdateUrlsOperationCompleted, userState);
        }
        
        private void OnUpdateUrlsOperationCompleted(object arg) {
            if ((this.UpdateUrlsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.UpdateUrlsCompleted(this, new UpdateUrlsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        public new void CancelAsync(object userState) {
            base.CancelAsync(userState);
        }
        
        private bool IsLocalFileSystemWebService(string url) {
            if (((url == null) 
                        || (url == string.Empty))) {
                return false;
            }
            System.Uri wsUri = new System.Uri(url);
            if (((wsUri.Port >= 1024) 
                        && (string.Compare(wsUri.Host, "localHost", System.StringComparison.OrdinalIgnoreCase) == 0))) {
                return true;
            }
            return false;
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.4927")]
    public delegate void WebFetcherCompletedEventHandler(object sender, WebFetcherCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.4927")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class WebFetcherCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal WebFetcherCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.4927")]
    public delegate void UpdateUrlsCompletedEventHandler(object sender, UpdateUrlsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.4927")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class UpdateUrlsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal UpdateUrlsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
}

#pragma warning restore 1591
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveMonitor\WebFetcherService\Logger.cs ===
using System;
using System.IO;

namespace WebFetcher
{
    public class Logger
    {
        private const string DefaultLogName = "Main";

        internal static Logger Instance
        {
            get
            {
                return GetLogger();
            }
        }


        /// <summary>
        /// The folder containing the logs for this logger
        /// </summary>
        private string logFolder
        {
            get
            {
                // if this is the default logger, place the logs in the application
                // folder, otherwise place them in the debug log path
                return Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Log");
            }
        }


        /// <summary>
        /// The log file for this logger
        /// </summary>
        internal string LogFile
        {
            get
            {
                return Path.Combine(this.logFolder,
                    String.Format("{0}.{1}", this.logName, LogExtension));
            }
        }

        /// <summary>
        /// The error log file for this logger
        /// </summary>
        internal string ErrorLogFile
        {
            get
            {
                return Path.Combine(this.logFolder,
                    String.Format("{0}.{1}", this.logName, ErrorLogExtension));
            }
        }

        private string logName;
        private object writeLock = new object();
        private static Logger MainLogger;
        private const string EventSource = "XboxLiveWebFetcherService";
        private const string EventLogName = "Application";
        private const int MaxLogFileLengthInMegaBytes = 10;
        private const string LogExtension = "info";
        private const string ErrorLogExtension = "err";

        protected Logger()
            : this(DefaultLogName)
        {
        }

        protected Logger(string logName)
        {
            this.logName = logName;
        }

        public static Logger GetLogger()
        {
            // If the requested logger does not exist in the dictionary,
            // create a new one
            if (MainLogger != null)
            {
                return MainLogger;
            }
            else
            {
                MainLogger = new Logger();
                return MainLogger;
            }
        }

        public void LogException(string text, Exception e)
        {
            string message = 
                text + Environment.NewLine
                + e.Message
                + Environment.NewLine
                + e.StackTrace
                + Environment.NewLine;
            if (e.InnerException != null)
            {
                text = e.InnerException.Message
                    + Environment.NewLine
                    + e.InnerException.StackTrace
                    + Environment.NewLine;
            }

            WriteLogToFile(message, this.ErrorLogFile, this.writeLock);
        }

        public void LogError(string text)
        {
            WriteLogToFile(text, this.ErrorLogFile, this.writeLock);
        }

        public void LogInformation(string text)
        {
            WriteLogToFile(text, this.LogFile, this.writeLock);
        }

        private static void WriteLogToFile(string text, string file, object writeLock)
        {
            if (!String.IsNullOrEmpty(text))
            {
                text = String.Format("[{0}] {1}{2}", DateTime.Now.ToString(),
                    text, Environment.NewLine);
            }
            else
            {
                text = Environment.NewLine;
            }

            try
            {
                lock (writeLock)
                {
                    FileInfo fileInfo = new FileInfo(file);

                    if (fileInfo.Exists && fileInfo.Length >
                        MaxLogFileLengthInMegaBytes * 1000000)
                    {
                        File.Delete(file);
                    }

                    File.AppendAllText(file, text);
                }
            }
            catch (Exception e)
            {
                WriteExceptionToEventLog(e,
                    "An exception occurred while writing to log file " + file,
                    System.Diagnostics.EventLogEntryType.Error);
            }
        }

        public static void WriteToEventLog(string text, System.Diagnostics.EventLogEntryType type)
        {

            if (!System.Diagnostics.EventLog.SourceExists(EventSource))
                System.Diagnostics.EventLog.CreateEventSource(EventSource, EventLogName);

            System.Diagnostics.EventLog.WriteEntry(EventSource, text, type);
        }

        /// <summary>
        /// This method writes an exception to the event log.
        /// </summary>
        /// <param name="e">exception</param>
        /// <param name="format">additional format describing the event</param>
        /// <param name="type">the event type (info, warning, error, etc)</param>
        public static void WriteExceptionToEventLog(
            Exception e,
            string text,
            System.Diagnostics.EventLogEntryType type)
        {
            string eventText = text + ": " + e.Message + Environment.NewLine + e.StackTrace + Environment.NewLine;

            WriteToEventLog(eventText, type);
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveMonitor\WebFetcherService\Properties\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("WebFetcher")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveMonitor\LiveStatusMonitorTest\UnitTest1.cs ===
using System;
using System.Text;
using System.Collections.Generic;
using System.Linq;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using LiveStatusMonitorService;


namespace LiveStatusMonitorTest
{
    /// <summary>
    /// Summary description for UnitTest1
    /// </summary>
    [TestClass]
    public class UnitTest1
    {
        public UnitTest1()
        {
            //
            // TODO: Add constructor logic here
            //
        }

        private TestContext testContextInstance;

        /// <summary>
        ///Gets or sets the test context which provides
        ///information about and functionality for the current test run.
        ///</summary>
        public TestContext TestContext
        {
            get
            {
                return testContextInstance;
            }
            set
            {
                testContextInstance = value;
            }
        }

        #region Additional test attributes
        //
        // You can use the following additional attributes as you write your tests:
        //
        // Use ClassInitialize to run code before running the first test in the class
        [ClassInitialize()]
        public static void MyClassInitialize(TestContext testContext) 
        {
            System.IO.File.Copy(@"D:\LEST\product\Source\LiveMonitor\LiveStatusMonitorService\HealthCheckConfig.xml"
                , AppDomain.CurrentDomain.BaseDirectory + "\\HealthCheckConfig.xml");
            System.IO.Directory.CreateDirectory(AppDomain.CurrentDomain.BaseDirectory + "\\log");

            
        }
        //
        // Use ClassCleanup to run code after all tests in a class have run
        // [ClassCleanup()]
        // public static void MyClassCleanup() { }
        //
        // Use TestInitialize to run code before running each test 
        // [TestInitialize()]
        // public void MyTestInitialize() { }
        //
        // Use TestCleanup to run code after each test has run
        // [TestCleanup()]
        // public void MyTestCleanup() { }
        //
        #endregion


        [TestMethod]
        public void HealthCheckTest()
        {
            string xml = null;
            HealthCheckFetcher fetcher = new HealthCheckFetcher();
            try
            {
                fetcher.Init();
                fetcher.DoWork();
                fetcher.SetStatus(fetcher.m_EnvironmentsObj);
                xml = fetcher.Serialize(fetcher.m_EnvironmentsObj);
            }
            catch (Exception)
            {
                throw;
            }
            finally
            {
                fetcher.Despose();
            }
            string path = "HealthCheckMonitor.xml";
            System.IO.File.WriteAllText(path, xml);
        }

        [TestMethod]
        [Ignore]
        public void HealthCheckMonitorForXblob()
        {
            string serverNameOrIpAddress = "yixuanl-xblob01";
            if (String.IsNullOrEmpty(serverNameOrIpAddress))
            {
                return;
            }

            string xml = null;
            HealthCheckFetcher fetcher = new HealthCheckFetcher();
            try
            {
                fetcher.SetXblob(serverNameOrIpAddress);
                fetcher.Init();
                fetcher.DoWorkForXblob();
                fetcher.SetStatus(fetcher.m_XblobEnvironmentsObj);
                xml = fetcher.Serialize(fetcher.m_XblobEnvironmentsObj);
            }
            catch (Exception)
            {
                throw;
            }
            finally
            {
                fetcher.Despose();
            }
            string path = "HealthCheckMonitor_" + serverNameOrIpAddress + ".xml";
            System.IO.File.WriteAllText(path, xml);            
        }

        [TestMethod]
        [Ignore]
        public void XeOnWatchTest()
        {
            string xml = null;
            XonWatchFetcher fetcher = new XonWatchFetcher();
            try
            {
                fetcher.Init();
                fetcher.DoWork();
                fetcher.SetStatus(fetcher.m_EnvironmentsObj);
                xml = fetcher.Serialize(fetcher.m_EnvironmentsObj);
            }
            catch (Exception)
            {
                throw;
            }
            finally
            {
                fetcher.Despose();
            }
            string path = "XeOnWatchMonitor.xml";
            System.IO.File.WriteAllText(path, xml, System.Text.Encoding.UTF8);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveMonitor\WebFetcherService\WebFetcherService.asmx.cs ===
using System;
using System.IO;
using System.Net;
using System.Text;
using System.Web.Services;
using System.Security.Cryptography.X509Certificates;

namespace WebFetcher
{
    /// <summary>
    /// Summary description for Service1
    /// </summary>
    [WebService(Namespace = "http://www.xbox.com/")]
    [WebServiceBinding(ConformsTo = WsiProfiles.BasicProfile1_1)]
    [System.ComponentModel.ToolboxItem(false)]
    // To allow this Web Service to be called from script, using ASP.NET AJAX, uncomment the following line. 
    // [System.Web.Script.Services.ScriptService]
    public class WebFetcherService : System.Web.Services.WebService
    {

        [WebMethod(CacheDuration = 60)]
        public string WebFetcher(string url)
        {
            if (String.IsNullOrEmpty(url))
            {
                return null;
            }

            StringBuilder sb = new StringBuilder();
            byte[] buf = new byte[8192];

            try
            {
                if (url.Trim().ToLower().StartsWith("https"))
                {
                    ServicePointManager.ServerCertificateValidationCallback +=
                            delegate(
                            object sender,
                            X509Certificate certificate,
                            X509Chain chain,
                            System.Net.Security.SslPolicyErrors sslPolicyErrors)
                            {
                                return true;
                            };
                }

                HttpWebRequest request = (HttpWebRequest)
                    WebRequest.Create(url);

                // execute the request
                HttpWebResponse response = (HttpWebResponse)
                    request.GetResponse();

                // we will read data via the response stream
                Stream resStream = response.GetResponseStream();

                string tempString = null;
                int count = 0;

                do
                {
                    // fill the buffer with data
                    count = resStream.Read(buf, 0, buf.Length);

                    // make sure we read some data
                    if (count != 0)
                    {
                        // translate from bytes to ASCII text
                        tempString = Encoding.ASCII.GetString(buf, 0, count);

                        // continue building the string
                        sb.Append(tempString);
                    }
                }
                while (count > 0); // any more data to read?
                response.Close();                
            }
            catch(WebException e)
            {
                string message = String.Format("Http Request for Url {0} Failed and Threw a WebException.{1}Exception Message: {2}."                
                    , url
                    , Environment.NewLine
                    , e.Message);
                if (e.Status == WebExceptionStatus.ProtocolError)
                {
                    message += Environment.NewLine;
                    message += String.Format("Status Code : {0}.", ((HttpWebResponse)e.Response).StatusCode);
                    message += Environment.NewLine;
                    message += String.Format("Status Description : {0}.", ((HttpWebResponse)e.Response).StatusDescription);
                    message += Environment.NewLine;
                }
                return message;
            }
            catch(Exception ex)
            {
                Logger.Instance.LogException(
                    "Web Fetcher for Url " + url + " Failed!" , ex);
            }

            return sb.ToString();
        }

        [WebMethod(CacheDuration = 60)]
        public string UpdateUrls(string name, string npdb, string domain, bool dynamicurl)
        {
            if (String.IsNullOrEmpty(name) || String.IsNullOrEmpty(npdb))
            {
                return null;
            }

            string connectionstr = String.Format("data source={0};initial catalog=LIVEN_NPDB;integrated security=SSPI;Packet Size=16384", npdb);

            Fetcher fetcher = null;
            string healthUrls = String.Empty;
            try
            {
                fetcher = new Fetcher(connectionstr);
                healthUrls = fetcher.Get(name, npdb, domain, dynamicurl);
            }
            catch (Exception ex)
            {
                Logger.Instance.LogException("UpdateUrls  Failed!", ex);
            }
            finally
            {
                if (fetcher != null)
                {
                    fetcher.Close();
                }
            }

            return healthUrls;
        }
                
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveMonitorClient\About.g.cs ===
#pragma checksum "..\..\About.xaml" "{406ea660-64cf-4c82-b6f0-42d48172a799}" "371E544D7FE8B931B6AE5666FE96AE29"
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3074
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using LiveMonitor;
using System;
using System.Diagnostics;
using System.Windows;
using System.Windows.Automation;
using System.Windows.Controls;
using System.Windows.Controls.Primitives;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Ink;
using System.Windows.Input;
using System.Windows.Markup;
using System.Windows.Media;
using System.Windows.Media.Animation;
using System.Windows.Media.Effects;
using System.Windows.Media.Imaging;
using System.Windows.Media.Media3D;
using System.Windows.Media.TextFormatting;
using System.Windows.Navigation;
using System.Windows.Shapes;


namespace LiveMonitor {
    
    
    /// <summary>
    /// About
    /// </summary>
    public partial class About : System.Windows.Window, System.Windows.Markup.IComponentConnector {
        
        
        #line 8 "..\..\About.xaml"
        internal System.Windows.Controls.TextBlock TitleText;
        
        #line default
        #line hidden
        
        
        #line 10 "..\..\About.xaml"
        internal System.Windows.Controls.TextBlock VersionText;
        
        #line default
        #line hidden
        
        
        #line 11 "..\..\About.xaml"
        internal System.Windows.Controls.TextBlock CopyrightText;
        
        #line default
        #line hidden
        
        private bool _contentLoaded;
        
        /// <summary>
        /// InitializeComponent
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public void InitializeComponent() {
            if (_contentLoaded) {
                return;
            }
            _contentLoaded = true;
            System.Uri resourceLocater = new System.Uri("/LiveMonitor;component/about.xaml", System.UriKind.Relative);
            
            #line 1 "..\..\About.xaml"
            System.Windows.Application.LoadComponent(this, resourceLocater);
            
            #line default
            #line hidden
        }
        
        [System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Design", "CA1033:InterfaceMethodsShouldBeCallableByChildTypes")]
        void System.Windows.Markup.IComponentConnector.Connect(int connectionId, object target) {
            switch (connectionId)
            {
            case 1:
            
            #line 4 "..\..\About.xaml"
            ((LiveMonitor.About)(target)).Loaded += new System.Windows.RoutedEventHandler(this.OnLoaded);
            
            #line default
            #line hidden
            return;
            case 2:
            this.TitleText = ((System.Windows.Controls.TextBlock)(target));
            return;
            case 3:
            this.VersionText = ((System.Windows.Controls.TextBlock)(target));
            return;
            case 4:
            this.CopyrightText = ((System.Windows.Controls.TextBlock)(target));
            return;
            }
            this._contentLoaded = true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveMonitorClient\makefile.inc ===
# this is a slight modification of the makefile.def target that skips ComVisible since it's specified per project.

$(OBJ_PATH)\$O\_generated.cs: $(SOURCES_USED)
    -$(_DEL)
    set createfile=<<$@.temp
!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES) && "$(MUI)" == "1" && "$(URT_VER)" == "2.0"
[assembly:System.Resources.NeutralResourcesLanguage("en")]
!endif
[assembly:System.Reflection.AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")]
!ifdef VER_PRODUCTNAME_STR
[assembly:System.Reflection.AssemblyProduct("$(VER_PRODUCTNAME_STR)")]
!endif
!ifdef VER_LEGALCOPYRIGHT_STR
[assembly:System.Reflection.AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")]
!endif
!ifdef VER_COMPANYNAME_STR
[assembly:System.Reflection.AssemblyCompany("$(VER_COMPANYNAME_STR)")]
!endif
!ifdef VER_PRODUCTVERSION_STR
[assembly:System.Reflection.AssemblyFileVersion("$(VER_PRODUCTVERSION_STR)")]
!endif
<<KEEP
!if defined(_ASSEMBLY_IDENTITY) \
        && "$(_ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME_LOWERCASE)" != "none" \
        && "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)" \
        && !defined(_MANAGED_CXX_LIBRARY) \
        && "$(MANAGED_TARGET_TYPE)" != "module"
    asmIdToAttribs.cmd "$(_ASSEMBLY_IDENTITY)" $@.temp csharp
!endif
    $(_MOVE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveMonitorClient\AddXblobDialog.g.cs ===
#pragma checksum "..\..\AddXblobDialog.xaml" "{406ea660-64cf-4c82-b6f0-42d48172a799}" "8BA2C611BF47EF36EEF7C1ECA206CBC9"
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3074
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Diagnostics;
using System.Windows;
using System.Windows.Automation;
using System.Windows.Controls;
using System.Windows.Controls.Primitives;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Ink;
using System.Windows.Input;
using System.Windows.Markup;
using System.Windows.Media;
using System.Windows.Media.Animation;
using System.Windows.Media.Effects;
using System.Windows.Media.Imaging;
using System.Windows.Media.Media3D;
using System.Windows.Media.TextFormatting;
using System.Windows.Navigation;
using System.Windows.Shapes;


namespace LiveMonitor {
    
    
    /// <summary>
    /// AddXblobDialog
    /// </summary>
    public partial class AddXblobDialog : System.Windows.Window, System.Windows.Markup.IComponentConnector {
        
        
        #line 40 "..\..\AddXblobDialog.xaml"
        internal System.Windows.Controls.TextBox ServerNameOrIpTextBox;
        
        #line default
        #line hidden
        
        
        #line 43 "..\..\AddXblobDialog.xaml"
        internal System.Windows.Controls.Button okButton;
        
        #line default
        #line hidden
        
        
        #line 44 "..\..\AddXblobDialog.xaml"
        internal System.Windows.Controls.Button cancelButton;
        
        #line default
        #line hidden
        
        private bool _contentLoaded;
        
        /// <summary>
        /// InitializeComponent
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public void InitializeComponent() {
            if (_contentLoaded) {
                return;
            }
            _contentLoaded = true;
            System.Uri resourceLocater = new System.Uri("/LiveMonitor;component/addxblobdialog.xaml", System.UriKind.Relative);
            
            #line 1 "..\..\AddXblobDialog.xaml"
            System.Windows.Application.LoadComponent(this, resourceLocater);
            
            #line default
            #line hidden
        }
        
        [System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Design", "CA1033:InterfaceMethodsShouldBeCallableByChildTypes")]
        void System.Windows.Markup.IComponentConnector.Connect(int connectionId, object target) {
            switch (connectionId)
            {
            case 1:
            this.ServerNameOrIpTextBox = ((System.Windows.Controls.TextBox)(target));
            return;
            case 2:
            this.okButton = ((System.Windows.Controls.Button)(target));
            
            #line 43 "..\..\AddXblobDialog.xaml"
            this.okButton.Click += new System.Windows.RoutedEventHandler(this.okButton_Click);
            
            #line default
            #line hidden
            return;
            case 3:
            this.cancelButton = ((System.Windows.Controls.Button)(target));
            
            #line 44 "..\..\AddXblobDialog.xaml"
            this.cancelButton.Click += new System.Windows.RoutedEventHandler(this.cancelButton_Click);
            
            #line default
            #line hidden
            return;
            }
            this._contentLoaded = true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveMonitorClient\AddXblobDialog.xaml.cs ===
using System;
using System.Collections.Generic;
using System.Windows;

namespace LiveMonitor
{
    /// <summary>
    /// Interaction logic for AddXblobDialog.xaml
    /// </summary>
    public partial class AddXblobDialog : Window
    {
        public List<string> ServerNameOrIpAddress
        {
            get;
            set;
        }

        public AddXblobDialog()
        {
            InitializeComponent();
            ServerNameOrIpAddress = new List<string>();
        }

        public void Dispose()
        {
            ServerNameOrIpAddress.Clear();
        }

        private void cancelButton_Click(object sender, RoutedEventArgs e)
        {
            this.DialogResult = false;
        }

        private void okButton_Click(object sender, RoutedEventArgs e)
        {
            if (String.IsNullOrEmpty(ServerNameOrIpTextBox.Text))
            {
                this.DialogResult = false;
            }
            else
            {
                char[] charSeparators = new char[] { ',' };
                string[] text = ServerNameOrIpTextBox.Text.Trim().ToLower().Split(charSeparators);
                foreach (string server in text)
                {
                    ServerNameOrIpAddress.Add(server);                    
                }
                this.DialogResult = true;
            }

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveMonitorClient\App.g.cs ===
#pragma checksum "..\..\App.xaml" "{406ea660-64cf-4c82-b6f0-42d48172a799}" "B633CA6195E83330F4F2A1F204ECC29C"
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3074
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using LiveMonitor;
using System;
using System.Diagnostics;
using System.Windows;
using System.Windows.Automation;
using System.Windows.Controls;
using System.Windows.Controls.Primitives;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Ink;
using System.Windows.Input;
using System.Windows.Markup;
using System.Windows.Media;
using System.Windows.Media.Animation;
using System.Windows.Media.Effects;
using System.Windows.Media.Imaging;
using System.Windows.Media.Media3D;
using System.Windows.Media.TextFormatting;
using System.Windows.Navigation;
using System.Windows.Shapes;


namespace LiveMonitor {
    
    
    /// <summary>
    /// App
    /// </summary>
    public partial class App : System.Windows.Application {
        
        private bool _contentLoaded;
        
        /// <summary>
        /// InitializeComponent
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public void InitializeComponent() {
            if (_contentLoaded) {
                return;
            }
            _contentLoaded = true;
            
            #line 5 "..\..\App.xaml"
            this.Startup += new System.Windows.StartupEventHandler(this.AppStartup);
            
            #line default
            #line hidden
            System.Uri resourceLocater = new System.Uri("/LiveMonitor;component/app.xaml", System.UriKind.Relative);
            
            #line 1 "..\..\App.xaml"
            System.Windows.Application.LoadComponent(this, resourceLocater);
            
            #line default
            #line hidden
        }
        
        /// <summary>
        /// Application Entry Point.
        /// </summary>
        [System.STAThreadAttribute()]
        [System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public static void Main() {
            LiveMonitor.App app = new LiveMonitor.App();
            app.InitializeComponent();
            app.Run();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveMonitorClient\App.xaml.cs ===
using System.Windows;
using System.Diagnostics;

namespace LiveMonitor
{
    /// <summary>
    /// Interaction logic for App.xaml
    /// </summary>
    public partial class App : Application
    {
        private void AppStartup(object sender, StartupEventArgs e)
        {
            MonitorWindow mainWindow = new MonitorWindow();
            mainWindow.Show();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveMonitorClient\About.xaml.cs ===
using System.Windows;

namespace LiveMonitor
{
    /// <summary>
    /// Interaction logic for About.xaml
    /// </summary>
    public partial class About : Window
    {
        public About()
        {
            InitializeComponent();
        }

        private void OnLoaded(object sender, RoutedEventArgs e)
        {
            System.Reflection.Assembly assembly = System.Reflection.Assembly.GetExecutingAssembly();
            System.Version version = assembly.GetName().Version;
            System.Diagnostics.FileVersionInfo oFileVersionInfo = System.Diagnostics.FileVersionInfo.GetVersionInfo(assembly.Location);
            TitleText.Text = oFileVersionInfo.FileDescription;
            VersionText.Text = "Version " + version.ToString();
            CopyrightText.Text = oFileVersionInfo.LegalCopyright;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveMonitorClient\Data.cs ===
using System;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Windows.Threading;

namespace LiveMonitor
{
    /// <summary>
    /// This is to solve the problem in WPF while worker thread updating ObservableCollection will result in NotSupportedException.
    /// Exception says: This type of CollectionView does not support changes to its SourceCollection from a thread different from the Dispatcher thread
    /// Now, derive from ObservableColletion and do manually walk through the event's invocation list
    /// </summary>
    /// <typeparam name="T"></typeparam>
    public class MyObservableCollection<T> : ObservableCollection<T>
    {
        public override event System.Collections.Specialized.NotifyCollectionChangedEventHandler CollectionChanged;

        protected override void OnCollectionChanged(System.Collections.Specialized.NotifyCollectionChangedEventArgs e)
        {
            // Be nice - use BlockReentrancy like MSDN said
            using (BlockReentrancy())
            {
                System.Collections.Specialized.NotifyCollectionChangedEventHandler eventHandler = CollectionChanged;
                if (eventHandler == null)
                    return;
                Delegate[] delegates = eventHandler.GetInvocationList();
                // Walk thru invocation list
                foreach (System.Collections.Specialized.NotifyCollectionChangedEventHandler handler in delegates)
                {
                    DispatcherObject dispatcherObject = handler.Target as DispatcherObject;
                    // If the subscriber is a DispatcherObject and different thread
                    if (dispatcherObject != null && dispatcherObject.CheckAccess() == false)
                    {
                        // Invoke handler in the target dispatcher's thread
                        dispatcherObject.Dispatcher.Invoke(DispatcherPriority.DataBind, handler, this, e);
                    }
                    else // Execute handler as is
                        handler(this, e);
                }
            }
        }
    }

    public class EnviromentSettings : MyObservableCollection<EnviromentSetting>
    {        
    }

    public class EnviromentSetting : INotifyPropertyChanged
    {
        public EnviromentSetting()
        {            
        }

        public EnviromentSetting(string name)
        {
            _name = name;
            _lastRan = DateTime.UtcNow;
        }

        private string _name;        
        public string Name
        {
            get { return _name; }
            set 
            { 
                _name = value; 
                OnPropertyChanged("Name"); 
            }
        }
        
        private LiveStatus _status;
        [DefaultValue(LiveStatus.unknown)]
        public LiveStatus Status
        {
            set { _status = value;  OnPropertyChanged("Status"); }
            get { return _status; }
        }

        private string _build;
        [DefaultValue("Unknown")]
        public string Build
        {
            get { return _build; }
            set { _build = value; }
        }
                
        private DateTime _lastRan;        
        public DateTime LastRan
        {
            get { return _lastRan; }
            set { _lastRan = value; }
        }

        public event PropertyChangedEventHandler PropertyChanged;
        private void OnPropertyChanged(String info)
        {
            if (PropertyChanged != null)
                PropertyChanged(this, new PropertyChangedEventArgs(info));
        }
    }

    public enum LiveStatus
    {
        unknown,
        green,
        yellow,
        red
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveMonitorClient\Logger.cs ===
using System;
using System.IO;
using System.Reflection;

namespace LiveMonitor
{
    public class Logger
    {
        private const string DefaultLogName = "LiveMonitorWidgetError";

        internal static Logger Instance
        {
            get
            {
                return GetLogger();
            }
        }

        private string logName;
        private static object writeLock = new object();
        private static volatile Logger MainLogger;
        private const int MaxLogFileLengthInMegaBytes = 10;
        private const string LogExtension = "log";

        protected Logger() : this(DefaultLogName)
        {
        }

        protected Logger(string logName)
        {
            this.logName = logName;
        }

        public static Logger GetLogger()
        {
            // If the requested logger does not exist in the dictionary,
            // create a new one
            if (MainLogger == null)
            {
                lock(writeLock)
                {
                    if(MainLogger == null)
                        MainLogger = new Logger();
                }
            }
            return MainLogger;
        }

        /// <summary>
        /// The log file for this logger
        /// </summary>
        internal string LogFile
        {
            get
            {
                return Path.Combine(System.Environment.ExpandEnvironmentVariables("%APPDATA%"),
                    String.Format("{0}.{1}", this.logName, LogExtension));
            }
        }

        public void LogError(string text)
        {
            WriteLogToFile(text, this.LogFile);
        }

        private static void WriteLogToFile(string text, string file)
        {
            if (!String.IsNullOrEmpty(text))
            {
                text = String.Format("[{0}] {3} {1}{2}", DateTime.Now.ToString(),
                    text, Environment.NewLine, System.Threading.Thread.CurrentThread.ManagedThreadId);
            }
            else
            {
                text = Environment.NewLine;
            }

            try
            {
                lock (MainLogger)
                {
                    FileInfo fileInfo = new FileInfo(file);

                    if (fileInfo.Exists && fileInfo.Length >
                        MaxLogFileLengthInMegaBytes * 1000000)
                    {
                        File.Delete(file);
                    }

                    File.AppendAllText(file, text);
                }
            }
            catch (Exception e)
            {
                throw new Exception("An exception occurred while writing to log file " + file, e);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveMonitorClient\NotifyIcon.cs ===
using System;
using System.ComponentModel;
using System.Windows;
using System.Windows.Input;
using System.Windows.Markup;
using System.Windows.Media;
using Drawing = System.Drawing;
using Forms = System.Windows.Forms;

namespace LiveMonitor
{
    [ContentProperty("Text")]
    [DefaultEvent("MouseDoubleClick")]
    public partial class NotifyIcon : FrameworkElement, IAddChild
    {
        public static readonly RoutedEvent MouseClickEvent = EventManager.RegisterRoutedEvent(
            "MouseClick",
            RoutingStrategy.Bubble,
            typeof(MouseButtonEventHandler),
            typeof(NotifyIcon));

        public static readonly RoutedEvent MouseDoubleClickEvent = EventManager.RegisterRoutedEvent(
            "MouseDoubleClick",
            RoutingStrategy.Bubble,
            typeof(MouseButtonEventHandler),
            typeof(NotifyIcon));
                
        public static readonly DependencyProperty IconProperty = DependencyProperty.Register(
            "Icon",
            typeof(ImageSource),
            typeof(NotifyIcon),
            new FrameworkPropertyMetadata(OnIconChanged));

        public static readonly DependencyProperty TextProperty = DependencyProperty.Register(
            "Text",
            typeof(string),
            typeof(NotifyIcon),
            new PropertyMetadata(OnTextChanged));

        private Forms.NotifyIcon notifyIcon;

        static NotifyIcon()
        {
            VisibilityProperty.OverrideMetadata(typeof(NotifyIcon), new PropertyMetadata(OnVisibilityChanged));
        }

        public event MouseButtonEventHandler MouseClick
        {
            add { this.AddHandler(MouseClickEvent, value); }
            remove { this.RemoveHandler(MouseClickEvent, value); }
        }

        public event MouseButtonEventHandler MouseDoubleClick
        {
            add { this.AddHandler(MouseDoubleClickEvent, value); }
            remove { this.RemoveHandler(MouseDoubleClickEvent, value); }
        }
                
        public ImageSource Icon
        {
            get { return (ImageSource)this.GetValue(IconProperty); }
            set { this.SetValue(IconProperty, value); }
        }

        public string Text
        {
            get { return (string)this.GetValue(TextProperty); }
            set { this.SetValue(TextProperty, value); }
        }

        public override void BeginInit()
        {
            base.BeginInit();
            this.InitializeNotifyIcon();
        }
                
        #region IAddChild Members

        void IAddChild.AddChild(object value)
        {
            throw new InvalidOperationException();
        }

        void IAddChild.AddText(string text)
        {
            if (text == null)
            {
                throw new ArgumentNullException("text");
            }

            this.Text = text;
        }

        #endregion

        protected override void OnVisualParentChanged(DependencyObject oldParent)
        {
            base.OnVisualParentChanged(oldParent);
            this.AttachToWindowClose();
        }

        private static MouseButtonEventArgs CreateMouseButtonEventArgs(
            RoutedEvent handler,
            Forms.MouseButtons button)
        {
            return new MouseButtonEventArgs(InputManager.Current.PrimaryMouseDevice, 0, ToMouseButton(button))
            {
                RoutedEvent = handler
            };
        }

        private static Drawing.Icon FromImageSource(ImageSource icon)
        {
            if (icon == null)
            {
                return null;
            }

            Uri iconUri = new Uri(icon.ToString());
            return new Drawing.Icon(Application.GetResourceStream(iconUri).Stream);
        }

        private static void OnIconChanged(DependencyObject target, DependencyPropertyChangedEventArgs e)
        {
            if (!DesignerProperties.GetIsInDesignMode(target))
            {
                NotifyIcon control = (NotifyIcon)target;
                control.notifyIcon.Icon = FromImageSource(control.Icon);
            }
        }

        private static void OnTextChanged(DependencyObject target, DependencyPropertyChangedEventArgs e)
        {
            NotifyIcon control = (NotifyIcon)target;
            control.notifyIcon.Text = control.Text;
        }

        private static void OnVisibilityChanged(DependencyObject target, DependencyPropertyChangedEventArgs e)
        {
            NotifyIcon control = (NotifyIcon)target;
            control.notifyIcon.Visible = control.Visibility == Visibility.Visible;
        }

        private static MouseButton ToMouseButton(Forms.MouseButtons button)
        {
            switch (button)
            {
                case Forms.MouseButtons.Left:
                    return MouseButton.Left;
                case Forms.MouseButtons.Right:
                    return MouseButton.Right;
                case Forms.MouseButtons.Middle:
                    return MouseButton.Middle;
                case Forms.MouseButtons.XButton1:
                    return MouseButton.XButton1;
                case Forms.MouseButtons.XButton2:
                    return MouseButton.XButton2;
            }

            throw new InvalidOperationException();
        }

        private void AttachToWindowClose()
        {
            var window = Window.GetWindow(this);
            if (window != null)
            {
                window.Closed += (s, a) => this.notifyIcon.Dispose();
            }
        }

        private void InitializeNotifyIcon()
        {
            this.notifyIcon = new Forms.NotifyIcon();
            this.notifyIcon.Text = this.Text;
            this.notifyIcon.Visible = this.Visibility == Visibility.Visible;

            this.notifyIcon.MouseDown += this.OnMouseDown;
            this.notifyIcon.MouseUp += this.OnMouseUp;
            this.notifyIcon.MouseClick += this.OnMouseClick;
            this.notifyIcon.MouseDoubleClick += this.OnMouseDoubleClick;

            this.InitializeNativeHooks();
        }

        private void OnMouseDown(object sender, Forms.MouseEventArgs e)
        {
            this.RaiseEvent(CreateMouseButtonEventArgs(MouseDownEvent, e.Button));
        }

        private void OnMouseDoubleClick(object sender, Forms.MouseEventArgs e)
        {
            this.RaiseEvent(CreateMouseButtonEventArgs(MouseDoubleClickEvent, e.Button));
        }

        private void OnMouseClick(object sender, Forms.MouseEventArgs e)
        {
            this.RaiseEvent(CreateMouseButtonEventArgs(MouseClickEvent, e.Button));
        }

        private void OnMouseUp(object sender, Forms.MouseEventArgs e)
        {
            if (e.Button == Forms.MouseButtons.Right)
            {
                this.ShowContextMenu();
            }

            this.RaiseEvent(CreateMouseButtonEventArgs(MouseUpEvent, e.Button));
        }

        private void ShowContextMenu()
        {
            if (this.ContextMenu != null)
            {
                this.AttachContextMenu();
                this.ContextMenu.IsOpen = true;
            }
        }

        partial void AttachContextMenu();

        partial void InitializeNativeHooks();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveMonitorClient\MonitorWindow.g.cs ===
#pragma checksum "..\..\MonitorWindow.xaml" "{406ea660-64cf-4c82-b6f0-42d48172a799}" "53F584A9E9F645236BB1BB9FB855DEBA"
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3603
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using LiveMonitor;
using System;
using System.Diagnostics;
using System.Windows;
using System.Windows.Automation;
using System.Windows.Controls;
using System.Windows.Controls.Primitives;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Ink;
using System.Windows.Input;
using System.Windows.Markup;
using System.Windows.Media;
using System.Windows.Media.Animation;
using System.Windows.Media.Effects;
using System.Windows.Media.Imaging;
using System.Windows.Media.Media3D;
using System.Windows.Media.TextFormatting;
using System.Windows.Navigation;
using System.Windows.Shapes;


namespace LiveMonitor {
    
    
    /// <summary>
    /// MonitorWindow
    /// </summary>
    public partial class MonitorWindow : System.Windows.Window, System.Windows.Markup.IComponentConnector {
        
        
        #line 13 "..\..\MonitorWindow.xaml"
        internal LiveMonitor.NotifyIcon NotifyIconC;
        
        #line default
        #line hidden
        
        
        #line 24 "..\..\MonitorWindow.xaml"
        internal System.Windows.Controls.StackPanel MonitorWindowPanel;
        
        #line default
        #line hidden
        
        
        #line 25 "..\..\MonitorWindow.xaml"
        internal System.Windows.Controls.Image LoadingImage;
        
        #line default
        #line hidden
        
        
        #line 29 "..\..\MonitorWindow.xaml"
        internal System.Windows.Controls.Control BusyAnimation;
        
        #line default
        #line hidden
        
        
        #line 47 "..\..\MonitorWindow.xaml"
        internal System.Windows.Controls.MenuItem RemoveXblobMenuItem;
        
        #line default
        #line hidden
        
        
        #line 72 "..\..\MonitorWindow.xaml"
        internal System.Windows.Controls.TextBlock CurrentTabName;
        
        #line default
        #line hidden
        
        private bool _contentLoaded;
        
        /// <summary>
        /// InitializeComponent
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public void InitializeComponent() {
            if (_contentLoaded) {
                return;
            }
            _contentLoaded = true;
            System.Uri resourceLocater = new System.Uri("/LiveMonitor;component/monitorwindow.xaml", System.UriKind.Relative);
            
            #line 1 "..\..\MonitorWindow.xaml"
            System.Windows.Application.LoadComponent(this, resourceLocater);
            
            #line default
            #line hidden
        }
        
        [System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal System.Delegate _CreateDelegate(System.Type delegateType, string handler) {
            return System.Delegate.CreateDelegate(delegateType, this, handler);
        }
        
        [System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Design", "CA1033:InterfaceMethodsShouldBeCallableByChildTypes")]
        void System.Windows.Markup.IComponentConnector.Connect(int connectionId, object target) {
            switch (connectionId)
            {
            case 1:
            
            #line 6 "..\..\MonitorWindow.xaml"
            ((LiveMonitor.MonitorWindow)(target)).Loaded += new System.Windows.RoutedEventHandler(this.OnLoaded);
            
            #line default
            #line hidden
            return;
            case 2:
            this.NotifyIconC = ((LiveMonitor.NotifyIcon)(target));
            return;
            case 3:
            
            #line 17 "..\..\MonitorWindow.xaml"
            ((System.Windows.Controls.MenuItem)(target)).Click += new System.Windows.RoutedEventHandler(this.OnShowClick);
            
            #line default
            #line hidden
            return;
            case 4:
            
            #line 18 "..\..\MonitorWindow.xaml"
            ((System.Windows.Controls.MenuItem)(target)).Click += new System.Windows.RoutedEventHandler(this.ExitClick);
            
            #line default
            #line hidden
            return;
            case 5:
            this.MonitorWindowPanel = ((System.Windows.Controls.StackPanel)(target));
            return;
            case 6:
            this.LoadingImage = ((System.Windows.Controls.Image)(target));
            return;
            case 7:
            this.BusyAnimation = ((System.Windows.Controls.Control)(target));
            
            #line 34 "..\..\MonitorWindow.xaml"
            this.BusyAnimation.MouseDown += new System.Windows.Input.MouseButtonEventHandler(this.LoadingImage_MouseDown);
            
            #line default
            #line hidden
            return;
            case 8:
            
            #line 40 "..\..\MonitorWindow.xaml"
            ((System.Windows.Controls.Image)(target)).MouseLeftButtonDown += new System.Windows.Input.MouseButtonEventHandler(this.Window_MouseLeftButtonDown);
            
            #line default
            #line hidden
            return;
            case 9:
            
            #line 46 "..\..\MonitorWindow.xaml"
            ((System.Windows.Controls.MenuItem)(target)).Click += new System.Windows.RoutedEventHandler(this.AddXblobClick);
            
            #line default
            #line hidden
            return;
            case 10:
            this.RemoveXblobMenuItem = ((System.Windows.Controls.MenuItem)(target));
            
            #line 47 "..\..\MonitorWindow.xaml"
            this.RemoveXblobMenuItem.Click += new System.Windows.RoutedEventHandler(this.RemoveXblobClick);
            
            #line default
            #line hidden
            return;
            case 11:
            
            #line 49 "..\..\MonitorWindow.xaml"
            ((System.Windows.Controls.MenuItem)(target)).Click += new System.Windows.RoutedEventHandler(this.AboutClick);
            
            #line default
            #line hidden
            return;
            case 12:
            
            #line 50 "..\..\MonitorWindow.xaml"
            ((System.Windows.Controls.MenuItem)(target)).Click += new System.Windows.RoutedEventHandler(this.ExitClick);
            
            #line default
            #line hidden
            return;
            case 13:
            
            #line 62 "..\..\MonitorWindow.xaml"
            ((System.Windows.Controls.Image)(target)).MouseDown += new System.Windows.Input.MouseButtonEventHandler(this.OnNext);
            
            #line default
            #line hidden
            return;
            case 14:
            
            #line 67 "..\..\MonitorWindow.xaml"
            ((System.Windows.Controls.Image)(target)).MouseDown += new System.Windows.Input.MouseButtonEventHandler(this.OnNext);
            
            #line default
            #line hidden
            return;
            case 15:
            this.CurrentTabName = ((System.Windows.Controls.TextBlock)(target));
            return;
            }
            this._contentLoaded = true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveMonitorClient\MonitorWindow.xaml.cs ===
using System.Windows;
using System.Threading;
using System.Windows.Controls;
using System.Windows.Threading;
using System;
using System.IO;
using System.Reflection;
using System.Collections.Generic;
using System.Windows.Input;
using LiveMonitor.LiveStatusMonitorReference;

namespace LiveMonitor
{
    /// <summary>
    /// Interaction logic for MonitorWindow.xaml
    /// </summary>
    public partial class MonitorWindow : Window
    {
        private WindowState lastWindowState;

        public MonitorWindow()
        {
            InitializeComponent();
            this.Top = 30;
            this.Left = System.Windows.SystemParameters.PrimaryScreenWidth - 160;
        }
        
        /// <summary>
        /// This is how to move the window
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void Window_MouseLeftButtonDown(object sender, System.Windows.Input.MouseButtonEventArgs e)
        {
            this.DragMove();
        }

        private void ExitClick(object sender, RoutedEventArgs e)
        {
            //Save added xblob into file
            string fileName = Path.Combine(System.Environment.ExpandEnvironmentVariables("%APPDATA%"), Properties.Settings.Default.AddedXblobLogFile);
            if (System.IO.File.Exists(fileName))
            {
                System.IO.File.Delete(fileName);
            }
            if (HealthCheckInstance != null && HealthCheckInstance.XblobServerList != null && HealthCheckInstance.XblobServerList.Count > 0)
            {
                string text = null;
                foreach (string name in HealthCheckInstance.XblobServerList)
                {
                    text = name + Environment.NewLine;
                }
                System.IO.File.AppendAllText(fileName, text);
            }

            this.Close();
        }

        private void AboutClick(object sender, RoutedEventArgs e)
        {
            About dlg = new About();
            dlg.Owner = this;
            dlg.ShowDialog();
        }

        private void MinimizeClick(object sender, RoutedEventArgs e)
        {
            this.Hide();
            this.WindowState = this.lastWindowState;
        }

        private HealthCheckControl HealthCheckInstance = null;
        private XonWatchControl XeOnWatchInstance = null;
        private HealthCheckControl.DoWorkCompleteHandler HealthCheckDoWorkCompleteHandler = null;
        
        private Timer timer = null;

        /// <summary>
        /// This is what timer do. Do the real work! Call server and update the UI.
        /// </summary>
        /// <param name="state"></param>
        private void CheckStatus(object state)
        {
            ThreadPool.QueueUserWorkItem(new WaitCallback(HealthCheckInstance.DoWork));
            // Removing XeOnWatch call as it isn't used by our LIVEn services
            //ThreadPool.QueueUserWorkItem(new WaitCallback(XeOnWatchInstance.DoWork));
        }

        private void OnLoaded(object sender, RoutedEventArgs e)
        {
            this.lastWindowState = WindowState;

            if (CheckIsUpdateNeeded())
            {
                TextBlock tb = new TextBlock();                
                tb.TextWrapping = TextWrapping.Wrap;
                tb.Text = "Update Needed! Click or go to the latest build tree to install the latest version.";
                tb.Foreground = System.Windows.Media.Brushes.White;
                tb.Margin = new Thickness(10, 10, 5, 5);
                tb.Cursor = Cursors.Hand;
                tb.MouseDown += new MouseButtonEventHandler(InstallUpdate);
                if (MonitorWindowPanel.Children.Count > 0)
                {
                    MonitorWindowPanel.Children.Clear();
                }
                MonitorWindowPanel.Children.Add(tb);
            }
            else
            {
                HealthCheckInstance = new HealthCheckControl();
                XeOnWatchInstance = new XonWatchControl();
                HealthCheckDoWorkCompleteHandler = new HealthCheckControl.DoWorkCompleteHandler(HealthCheckInstance_DoWorkComplete);

                HealthCheckInstance.DoWorkComplete += HealthCheckDoWorkCompleteHandler;
                //Start the timer when loaded
                timer = new Timer(new TimerCallback(CheckStatus), null, 0, Properties.Settings.Default.UpdateIntervalInSeconds * 1000);

                //Save added xblob into file
                string fileName = Path.Combine(System.Environment.ExpandEnvironmentVariables("%APPDATA%"), Properties.Settings.Default.AddedXblobLogFile);
                if (System.IO.File.Exists(fileName))
                {
                    string[] text = System.IO.File.ReadAllLines(fileName);

                    List<string> name = new List<string>();
                    for (int i = 0; i < text.Length; i++)
                    {
                        name.Add(text[i]);
                    }
                    AddXblob(name);
                }
            }
        }

        void InstallUpdate(object sender, MouseButtonEventArgs e)
        {
            string url = Properties.Settings.Default.LatestWidgetLocation;
            try
            {
                System.Diagnostics.Process.Start(url);
                this.Close();
            }
            catch (Exception ex)
            {
                Logger.Instance.LogError("Failed to navigate " + url + ". Exception: " + ex.Message + " " + ex.StackTrace);
            }
        }

        bool CheckIsUpdateNeeded()
        {            
            bool isUpdateNeeded = false;
            try
            {
                LiveStatusMonitorService service = new LiveStatusMonitorService();
                service.Timeout = 5 * 1000;
                string version = Convert.ToString(System.Reflection.Assembly.GetExecutingAssembly().GetName().Version);
                isUpdateNeeded = service.IsUpdateNeeded(version);
            }
            catch (Exception ex)
            {
                Logger.Instance.LogError("CheckIsUpdateNeeded Catch an Exception: " + ex.Message + Environment.NewLine + ex.StackTrace);
            }
            return isUpdateNeeded;
        }
                
        /// <summary>
        /// This is only used for initialize.
        /// Initially, we will show the spin image. After we get data from server, we will show either Healthcheck window or XeonWatch window.
        /// </summary>
        void HealthCheckInstance_DoWorkComplete()
        {
            this.Dispatcher.Invoke(DispatcherPriority.Normal, (Action)(() =>
            {
                if (MonitorWindowPanel.Children.Count > 0)
                {
                    MonitorWindowPanel.Children.Clear();
                }
                MonitorWindowPanel.Children.Add(HealthCheckInstance);
                HealthCheckInstance.DoWorkComplete -= HealthCheckDoWorkCompleteHandler;
                HealthCheckInstance.IsInit = false;
                CurrentTabName.Text = "HealthCheck";
            }));                        
        }

        /// <summary>
        /// Switch UI between Healthcheck and XeonWatch
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void OnNext(object sender, System.Windows.Input.MouseButtonEventArgs e)
        {
            if (MonitorWindowPanel.Children == null || MonitorWindowPanel.Children.Count <= 0 || (MonitorWindowPanel.Children[0] is TextBlock))
            {
                return;
            }
            if (CurrentTabName.Text == "XeOnWatch")
            {
                CurrentTabName.Text = "HealthCheck";
            }
            else if (CurrentTabName.Text == "HealthCheck")
            {
                CurrentTabName.Text = "XeOnWatch";
            }
            if (((MonitorWindowPanel.Children[0] is HealthCheckControl)
                || (MonitorWindowPanel.Children[0]) is Image) && !XeOnWatchInstance.IsInit)
            {
                MonitorWindowPanel.Children.Clear();
                MonitorWindowPanel.Children.Add(XeOnWatchInstance);                
            }
            else if (((MonitorWindowPanel.Children[0] is XonWatchControl)
                || (MonitorWindowPanel.Children[0]) is Image) && !HealthCheckInstance.IsInit)
            {
                MonitorWindowPanel.Children.Clear();
                MonitorWindowPanel.Children.Add(HealthCheckInstance);
            }
            else
            {
                if(!(MonitorWindowPanel.Children[0] is Image))
                {
                    MonitorWindowPanel.Children.Clear();
                    MonitorWindowPanel.Children.Add(LoadingImage);
                    MonitorWindowPanel.Children.Add(BusyAnimation);
                }
            }
        }

        private void AddXblobClick(object sender, RoutedEventArgs e)
        {
            //AddXblobDialog dlg = new AddXblobDialog();
            //dlg.ShowDialog();
            //if(dlg.DialogResult == true)
            //{
            //    AddXblob(dlg.ServerNameOrIpAddress);
            //}
            //dlg.Dispose();
        }

        private void AddXblob(List<string> name)
        {
            //HealthCheckInstance.AddXblob(name);
            //ThreadPool.QueueUserWorkItem(new WaitCallback(HealthCheckInstance.DoWork));
            ////Enable remove xblob button
            //if (HealthCheckInstance.XblobServerList.Count > 0)
            //{
            //    RemoveXblobMenuItem.IsEnabled = true;
            //}
        }

        private void RemoveXblobClick(object sender, RoutedEventArgs e)
        {
            //if (HealthCheckInstance.XblobServerList == null || HealthCheckInstance.XblobServerList.Count == 0)
            //{
            //    //We should never be here.
            //    return;
            //}
            //RemoveXblobDialog dlg = new RemoveXblobDialog(HealthCheckInstance.XblobServerList);
            //dlg.ShowDialog();
            //if (dlg.DialogResult == true)
            //{
            //    foreach (string name in dlg.m_NeedsToRemove)
            //    {                    
            //        HealthCheckInstance.RemoveEnvironments(name);
            //    }
            //}
            //dlg.Dispose();
            //if (HealthCheckInstance.XblobServerList.Count == 0)
            //{
            //    //Disable remove xblob button
            //    RemoveXblobMenuItem.IsEnabled = false;
            //}
        }

        private void OnShowClick(object sender, RoutedEventArgs e)
        {
            this.Activate();
            this.WindowState = this.lastWindowState;
        }

        private void OnNotifyIconDoubleClick(object sender, MouseButtonEventArgs e)
        {
            if (e.ChangedButton == MouseButton.Left)
            {
                this.Activate();
                this.WindowState = this.lastWindowState;
            }
        }

        protected override void OnStateChanged(EventArgs e)
        {
            if (this.WindowState == WindowState.Minimized)
            {
                this.Hide();
            }
            else
            {
                this.lastWindowState = this.WindowState;
            }
        }

        private void LoadingImage_MouseDown(object sender, MouseButtonEventArgs e)
        {   
            string url = null;

            if (CurrentTabName.Text == "HealthCheck")
            {
                url = Properties.Settings.Default.HealthCheckReportLocation;
            }
            else if (CurrentTabName.Text == "XeOnWatch")
            {
                url = Properties.Settings.Default.XeOnWatchReportLocation;
            }

            try
            {
                if (!String.IsNullOrEmpty(url))
                {
                    System.Diagnostics.Process.Start(url);
                }
            }
            catch (Exception ex)
            {
                Logger.Instance.LogError("Failed to navigate " + url + ". Exception: " + ex.Message + " " + ex.StackTrace);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveMonitorClient\RemoveXblobDialog.xaml.cs ===
using System.Collections.Generic;
using System.Windows;
using System.Windows.Controls;

namespace LiveMonitor
{
    /// <summary>
    /// Interaction logic for RemoveXblobDialog.xaml
    /// </summary>
    public partial class RemoveXblobDialog : Window
    {
        public List<string> m_NeedsToRemove = new List<string>();
        public List<string> m_XblobNameOrIpAddress = null;
        
        public void Dispose()
        {
            m_NeedsToRemove.Clear();
            XblobsList.Items.Clear();
        }

        public RemoveXblobDialog(List<string> xblobNameOrIpAddress)
        {
            InitializeComponent();
            m_XblobNameOrIpAddress = xblobNameOrIpAddress;
        }

        private void cancelButton_Click(object sender, RoutedEventArgs e)
        {
            this.DialogResult = false;
        }

        private void okButton_Click(object sender, RoutedEventArgs e)
        {
            if (XblobsList == null || XblobsList.Items.Count == 0)
            {
                this.DialogResult = false;
            }
            else
            {
                foreach (ListBoxItem item in XblobsList.Items)
                {
                    if (item.IsSelected)
                    {
                        m_NeedsToRemove.Add(item.Content.ToString());
                    }
                }
                this.DialogResult = true;
            }
        }

        private void Window_Loaded(object sender, RoutedEventArgs e)
        {
            if (m_XblobNameOrIpAddress == null || m_XblobNameOrIpAddress.Count == 0)
            {
                return;
            }
            else
            {
                foreach (string xblob in m_XblobNameOrIpAddress)
                {
                    ListBoxItem item = new ListBoxItem();
                    item.Content = xblob;
                    XblobsList.Items.Add(item);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveMonitorClient\Notify.Interop.cs ===
using System;
using System.ComponentModel;
using System.Runtime.InteropServices;
using System.Windows;
using System.Windows.Controls;
using System.Diagnostics;

namespace LiveMonitor
{
    public partial class NotifyIcon
    {
        private const int MouseGlobal = 14;
        private const int LeftButtonDown = 0x201;
        private const int RightButtonDown = 0x204;

        private int mouseHookHandle;
        private HookProc hookProcRef;

        private delegate int HookProc(int code, int wParam, IntPtr structPointer);

        [DllImport("user32.dll", CharSet = CharSet.Auto, CallingConvention = CallingConvention.StdCall)]
        private static extern int CallNextHookEx(int hookId, int code, int param, IntPtr dataPointer);

        [DllImport("kernel32.dll", CharSet = CharSet.Auto)]
        private static extern IntPtr GetModuleHandle(string moduleName);

        [DllImport("user32.dll", CharSet = CharSet.Auto, CallingConvention = CallingConvention.StdCall)]
        private static extern int SetWindowsHookEx(int hookId, HookProc function, IntPtr instance, int threadId);

        [DllImport("user32.dll", CharSet = CharSet.Auto, CallingConvention = CallingConvention.StdCall, SetLastError = true)]
        private static extern int UnhookWindowsHookEx(int hookId);

        private static Rect GetContextMenuRect(ContextMenu menu)
        {
            var begin = menu.PointToScreen(new Point(0, 0));
            var end = menu.PointToScreen(new Point(menu.ActualWidth, menu.ActualHeight));
            return new Rect(begin, end);
        }

        private static Point GetHitPoint(IntPtr structPointer)
        {
            MouseLLHook mouseHook = (MouseLLHook)Marshal.PtrToStructure(structPointer, typeof(MouseLLHook));
            return new Point(mouseHook.X, mouseHook.Y);
        }

        partial void AttachContextMenu()
        {
            this.ContextMenu.Opened += this.OnContextMenuOpened;
            this.ContextMenu.Closed += this.OnContextMenuClosed;
        }

        partial void InitializeNativeHooks()
        {
            this.hookProcRef = this.OnMouseEventProc;
        }

        private void OnContextMenuClosed(object sender, RoutedEventArgs e)
        {
            UnhookWindowsHookEx(this.mouseHookHandle);

            this.ContextMenu.Opened -= this.OnContextMenuOpened;
            this.ContextMenu.Closed -= this.OnContextMenuClosed;
        }

        private void OnContextMenuOpened(object sender, RoutedEventArgs e)
        {
            using (var process = Process.GetCurrentProcess())
            using (var module = process.MainModule)
            {
                this.mouseHookHandle = SetWindowsHookEx(
                    MouseGlobal,
                    this.hookProcRef,
                    GetModuleHandle(module.ModuleName),
                    0);
            }

            if (this.mouseHookHandle == 0)
            {
                throw new Win32Exception(Marshal.GetLastWin32Error());
            }
        }

        private int OnMouseEventProc(int code, int button, IntPtr dataPointer)
        {
            if (button == LeftButtonDown || button == RightButtonDown)
            {
                var contextMenuRect = GetContextMenuRect(this.ContextMenu);
                var hitPoint = GetHitPoint(dataPointer);

                if (!contextMenuRect.Contains(hitPoint))
                {
                    this.ContextMenu.IsOpen = false;
                }
            }

            return CallNextHookEx(this.mouseHookHandle, code, button, dataPointer);
        }

        [StructLayout(LayoutKind.Sequential)]
        private struct MouseLLHook
        {
            internal int X;
            internal int Y;
            internal int MouseData;
            internal int Flags;
            internal int Time;
            internal int ExtraInfo;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveMonitorClient\RemoveXblobDialog.g.cs ===
#pragma checksum "..\..\RemoveXblobDialog.xaml" "{406ea660-64cf-4c82-b6f0-42d48172a799}" "2D42659D879E8C23594E896DC81335A7"
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3074
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Diagnostics;
using System.Windows;
using System.Windows.Automation;
using System.Windows.Controls;
using System.Windows.Controls.Primitives;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Ink;
using System.Windows.Input;
using System.Windows.Markup;
using System.Windows.Media;
using System.Windows.Media.Animation;
using System.Windows.Media.Effects;
using System.Windows.Media.Imaging;
using System.Windows.Media.Media3D;
using System.Windows.Media.TextFormatting;
using System.Windows.Navigation;
using System.Windows.Shapes;


namespace LiveMonitor {
    
    
    /// <summary>
    /// RemoveXblobDialog
    /// </summary>
    public partial class RemoveXblobDialog : System.Windows.Window, System.Windows.Markup.IComponentConnector {
        
        
        #line 52 "..\..\RemoveXblobDialog.xaml"
        internal System.Windows.Controls.ListBox XblobsList;
        
        #line default
        #line hidden
        
        
        #line 54 "..\..\RemoveXblobDialog.xaml"
        internal System.Windows.Controls.Button okButton;
        
        #line default
        #line hidden
        
        
        #line 55 "..\..\RemoveXblobDialog.xaml"
        internal System.Windows.Controls.Button cancelButton;
        
        #line default
        #line hidden
        
        private bool _contentLoaded;
        
        /// <summary>
        /// InitializeComponent
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public void InitializeComponent() {
            if (_contentLoaded) {
                return;
            }
            _contentLoaded = true;
            System.Uri resourceLocater = new System.Uri("/LiveMonitor;component/removexblobdialog.xaml", System.UriKind.Relative);
            
            #line 1 "..\..\RemoveXblobDialog.xaml"
            System.Windows.Application.LoadComponent(this, resourceLocater);
            
            #line default
            #line hidden
        }
        
        [System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Design", "CA1033:InterfaceMethodsShouldBeCallableByChildTypes")]
        void System.Windows.Markup.IComponentConnector.Connect(int connectionId, object target) {
            switch (connectionId)
            {
            case 1:
            
            #line 8 "..\..\RemoveXblobDialog.xaml"
            ((LiveMonitor.RemoveXblobDialog)(target)).Loaded += new System.Windows.RoutedEventHandler(this.Window_Loaded);
            
            #line default
            #line hidden
            return;
            case 2:
            this.XblobsList = ((System.Windows.Controls.ListBox)(target));
            return;
            case 3:
            this.okButton = ((System.Windows.Controls.Button)(target));
            
            #line 54 "..\..\RemoveXblobDialog.xaml"
            this.okButton.Click += new System.Windows.RoutedEventHandler(this.okButton_Click);
            
            #line default
            #line hidden
            return;
            case 4:
            this.cancelButton = ((System.Windows.Controls.Button)(target));
            
            #line 55 "..\..\RemoveXblobDialog.xaml"
            this.cancelButton.Click += new System.Windows.RoutedEventHandler(this.cancelButton_Click);
            
            #line default
            #line hidden
            return;
            }
            this._contentLoaded = true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveMonitorClient\Properties\Resources.Designer.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3074
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace LiveMonitor.Properties {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "2.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("LiveMonitor.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveMonitorClient\Properties\AssemblyInfo.cs ===
using System.Reflection;
using System.Resources;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Windows;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Xbox Live Status Monitor")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("Xbox Live Status Monitor")]
[assembly: AssemblyCopyright("Copyright  Microsoft 2009")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

//In order to begin building localizable applications, set 
//<UICulture>CultureYouAreCodingWith</UICulture> in your .csproj file
//inside a <PropertyGroup>.  For example, if you are using US english
//in your source files, set the <UICulture> to en-US.  Then uncomment
//the NeutralResourceLanguage attribute below.  Update the "en-US" in
//the line below to match the UICulture setting in the project file.

//[assembly: NeutralResourcesLanguage("en-US", UltimateResourceFallbackLocation.Satellite)]


[assembly: ThemeInfo(
    ResourceDictionaryLocation.None, //where theme specific resource dictionaries are located
    //(used if a resource is not found in the page, 
    // or application resource dictionaries)
    ResourceDictionaryLocation.SourceAssembly //where the generic resource dictionary is located
    //(used if a resource is not found in the page, 
    // app, or any theme specific resource dictionaries)
)]


// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.1")]
[assembly: AssemblyFileVersion("1.0.0.1")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveMonitorClient\StatusControl.g.cs ===
#pragma checksum "..\..\StatusControl.xaml" "{406ea660-64cf-4c82-b6f0-42d48172a799}" "4DA5A0BC4A389F81CFCB5B19FBFC4A2D"
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3074
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Diagnostics;
using System.Windows;
using System.Windows.Automation;
using System.Windows.Controls;
using System.Windows.Controls.Primitives;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Ink;
using System.Windows.Input;
using System.Windows.Markup;
using System.Windows.Media;
using System.Windows.Media.Animation;
using System.Windows.Media.Effects;
using System.Windows.Media.Imaging;
using System.Windows.Media.Media3D;
using System.Windows.Media.TextFormatting;
using System.Windows.Navigation;
using System.Windows.Shapes;


namespace LiveMonitor {
    
    
    /// <summary>
    /// StatusControl
    /// </summary>
    public partial class StatusControl : System.Windows.Controls.UserControl, System.Windows.Markup.IComponentConnector, System.Windows.Markup.IStyleConnector {
        
        
        #line 24 "..\..\StatusControl.xaml"
        internal System.Windows.Controls.ListView EnviromentListView;
        
        #line default
        #line hidden
        
        
        #line 34 "..\..\StatusControl.xaml"
        internal System.Windows.Controls.TextBlock ListViewToolTip;
        
        #line default
        #line hidden
        
        private bool _contentLoaded;
        
        /// <summary>
        /// InitializeComponent
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public void InitializeComponent() {
            if (_contentLoaded) {
                return;
            }
            _contentLoaded = true;
            System.Uri resourceLocater = new System.Uri("/LiveMonitor;component/statuscontrol.xaml", System.UriKind.Relative);
            
            #line 1 "..\..\StatusControl.xaml"
            System.Windows.Application.LoadComponent(this, resourceLocater);
            
            #line default
            #line hidden
        }
        
        [System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Design", "CA1033:InterfaceMethodsShouldBeCallableByChildTypes")]
        void System.Windows.Markup.IComponentConnector.Connect(int connectionId, object target) {
            switch (connectionId)
            {
            case 3:
            this.EnviromentListView = ((System.Windows.Controls.ListView)(target));
            
            #line 28 "..\..\StatusControl.xaml"
            this.EnviromentListView.SelectionChanged += new System.Windows.Controls.SelectionChangedEventHandler(this.EnviromentListView_SelectionChanged);
            
            #line default
            #line hidden
            return;
            case 4:
            this.ListViewToolTip = ((System.Windows.Controls.TextBlock)(target));
            return;
            }
            this._contentLoaded = true;
        }
        
        [System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Design", "CA1033:InterfaceMethodsShouldBeCallableByChildTypes")]
        void System.Windows.Markup.IStyleConnector.Connect(int connectionId, object target) {
            System.Windows.EventSetter eventSetter;
            switch (connectionId)
            {
            case 1:
            
            #line 7 "..\..\StatusControl.xaml"
            ((System.Windows.Controls.Image)(target)).Loaded += new System.Windows.RoutedEventHandler(this.Image_Loaded);
            
            #line default
            #line hidden
            break;
            case 2:
            eventSetter = new System.Windows.EventSetter();
            eventSetter.Event = System.Windows.UIElement.MouseEnterEvent;
            
            #line 12 "..\..\StatusControl.xaml"
            eventSetter.Handler = new System.Windows.Input.MouseEventHandler(this.OnMouseEnter);
            
            #line default
            #line hidden
            ((System.Windows.Style)(target)).Setters.Add(eventSetter);
            break;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveMonitorClient\StatusControl.xaml.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Documents;
using System.Windows.Input;
using System.Net;
using System.Xml;
using LiveMonitor.LiveStatusMonitorReference;


namespace LiveMonitor
{
    /// <summary>
    /// Interaction logic for HealthCheckControl.xaml
    /// </summary>
    public abstract partial class StatusControl : UserControl
    {        
        public StatusControl()
        {
            InitializeComponent();
            EnviromentListView.ItemsSource = Environments;
        }

        protected EnviromentSettings Environments = new EnviromentSettings();
        
        /// <summary>
        /// Add a xblob into HealthCheck list. This is specified by user.
        /// </summary>
        /// <param name="serverNameOrIpAddress"></param>
        public void AddXblob(List<string> xblobsNameOrIpAddress)
        {
            foreach (string server in xblobsNameOrIpAddress)
            {
                if (String.IsNullOrEmpty(server) || m_XblobServerNameOrIpAddress.Contains(server))
                {
                    continue;
                }
                try
                {
                    IPHostEntry ipHost = Dns.GetHostEntry(server);
                    string name = ipHost.HostName.Split(new char[] { '.' })[0];

                    lock (m_XblobServerNameOrIpAddress)
                    {
                        m_XblobServerNameOrIpAddress.Add(name);
                    }

                    EnviromentSetting env = new EnviromentSetting(name);
                    lock(Environments)
                    {                        
                        Environments.Add(env);
                    }
                }
                catch
                {                    
                    MessageBox.Show(String.Format("Added Xblob {0} is Invalid!", server), server,
                        MessageBoxButton.OK, MessageBoxImage.Warning);
                }
            }
        }

        protected List<string> m_XblobServerNameOrIpAddress = new List<string>();

        public List<string> XblobServerList
        {
            get
            {
                return m_XblobServerNameOrIpAddress;
            }
        }

        /// <summary>
        /// Show the status image green/red/yellow/unknown
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void Image_Loaded(object sender, RoutedEventArgs e)
        {
            GridView gridView = EnviromentListView.View as GridView;
            if (gridView != null && gridView.Columns.Count >= 2)
            {
                Image image = (Image)sender;
                ContentPresenter contentPresenter = System.Windows.Media.VisualTreeHelper.GetParent(image) as ContentPresenter;
                if (contentPresenter != null)
                {
                    contentPresenter.Margin = new Thickness(0);
                }
            }
        }

        /// <summary>
        /// Parse xml and get env info out
        /// Add into UI if it is new, Remove from UI if server didn't contains it
        /// </summary>
        /// <param name="xml"></param>
        protected void AddEnvironments(string xml)
        {
            if (String.IsNullOrEmpty(xml))
            {
                return;
            }
            
            XmlDocument doc = new XmlDocument();
            doc.LoadXml(xml);
            
            XmlNodeList environmentList = doc.GetElementsByTagName("Environment");
            List<string> envNeedToAdd = new List<string>();
                        
            foreach (XmlNode node in environmentList)
            {
                EnviromentSetting env = new EnviromentSetting();
                env.Name = (node.Attributes["Name"] == null) ? null : node.Attributes["Name"].Value;
                env.Status = (node.Attributes["Status"] == null) ? LiveStatus.unknown : (LiveStatus)Enum.Parse(typeof(LiveStatus), node.Attributes["Status"].Value);
                env.LastRan = (node.Attributes["LastRan"] == null) ? DateTime.UtcNow : Convert.ToDateTime(node.Attributes["LastRan"].Value);
                env.Build = (node.Attributes["Build"] == null) ? null : node.Attributes["Build"].Value;
                envNeedToAdd.Add(env.Name);
                AddEnvironments(env);
            }
            //We don't need to worry about xblob here because it is not managed by server.
            if (envNeedToAdd.Count > 0 && m_XblobServerNameOrIpAddress.Contains(envNeedToAdd[0]))
            {
                return;
            }

            //For environments other than xblob, we need to remove it if it is no longer supported on the server.
            lock (Environments)
            {
                foreach (EnviromentSetting setting in Environments.ToArray())
                {
                    if (!envNeedToAdd.Contains(setting.Name) && !m_XblobServerNameOrIpAddress.Contains(setting.Name))
                    {
                        Environments.Remove(setting);
                    }
                }
            }
        }

        /// <summary>
        /// Add environment into UI
        /// If it already exists, update the env information
        /// </summary>
        /// <param name="env"></param>
        protected void AddEnvironments(EnviromentSetting env)
        {
            lock (Environments)
            {
                bool bFound = false;
                foreach (EnviromentSetting setting in Environments)
                {
                    if (setting.Name == env.Name)
                    {
                        setting.Build = env.Build;
                        setting.Status = env.Status;
                        setting.LastRan = env.LastRan;
                        bFound = true;
                        break;
                    }
                }
                if (!bFound)
                {
                    Environments.Add(env);
                }
            }
        }

        /// <summary>
        /// Remove xblob from UI by name
        /// </summary>
        /// <param name="name"></param>
        public void RemoveEnvironments(string name)
        {
            lock (m_XblobServerNameOrIpAddress)
            {
                m_XblobServerNameOrIpAddress.Remove(name);
            }
            foreach (EnviromentSetting setting in Environments)
            {
                if (setting.Name == name)
                {
                    lock (Environments)
                    {
                        Environments.Remove(setting);
                    }
                    break;
                }
            }
        }

        /// <summary>
        /// user click on selected item in the list, it will go to show the detailed url.
        /// </summary>
        /// <param name="selectedIndex"></param>
        protected abstract void LinkDetails(int selectedIndex);
                       
        protected void EnviromentListView_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            int index = EnviromentListView.SelectedIndex;
            if (index < 0)
            {
                return;
            }
            LinkDetails(index);
            //reset the selectedindex, otherwise it will not response next time
            EnviromentListView.SelectedIndex = -1;            
        }

        /// <summary>
        /// Call server API and get the status and update the UI
        /// </summary>
        /// <param name="state"></param>
        public abstract void DoWork(Object state);

        /// <summary>
        /// Show Tooltip. This is a hack.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void OnMouseEnter(object sender, MouseEventArgs e)
        {
            ListViewItem item = (ListViewItem)sender as ListViewItem;
            EnviromentSetting content = (EnviromentSetting)item.Content as EnviromentSetting;
            if (content != null)
            {
                ListViewToolTip.Text = "Live Status Monitor:"
                        + Environment.NewLine + "Name: " + content.Name
                        + Environment.NewLine + "Status: " + content.Status.ToString()
                        + Environment.NewLine + "Build: " + content.Build
                        + Environment.NewLine + "Latest Update: " + content.LastRan.ToString()
                        + Environment.NewLine + "Click For Details.";
            }                        
        }
    }

    public class HealthCheckControl : StatusControl
    {
        public delegate void DoWorkCompleteHandler();
        public event DoWorkCompleteHandler DoWorkComplete;

        public volatile bool IsInit = true;

        public override void DoWork(Object state)
        {
            try
            {
                LiveStatusMonitorService service = new LiveStatusMonitorService();
                service.Timeout = 60 * 1000;

                //Call server to get Healcheck info for public environment
                string xml = service.HealthCheckMonitor();
                AddEnvironments(xml);

                //Call server to get Healcheck info for xblob
                foreach (string xblob in m_XblobServerNameOrIpAddress)
                {
                    xml = service.HealthCheckMonitorForXblob(xblob);
                    if (String.IsNullOrEmpty(xml))
                    {
                        //Xblob may not be available. But we still need to show it to user.
                        //User can decide to delete it or not.
                        EnviromentSetting env = new EnviromentSetting(xblob);
                        AddEnvironments(env);
                    }
                    else
                    {
                        AddEnvironments(xml);
                    }
                }                                
                if (IsInit)
                {
                    DoWorkComplete();
                }
            }
            catch (Exception ex)
            {
                Logger.Instance.LogError("HealthCheck Background Catch an Exception: " + ex.Message + Environment.NewLine + ex.StackTrace);
            }
        }

        protected override void LinkDetails(int selectedIndex)
        {
            string url = null;

            if (m_XblobServerNameOrIpAddress.Contains(Environments[selectedIndex].Name))
            {
                url = Properties.Settings.Default.HealthCheckForXblobReportLocation;
                url = url.Replace("[XBLOBSERVERNAMEORIPADDRESS]", Environments[selectedIndex].Name);
            }
            else
            {
                url = Properties.Settings.Default.HealthCheckReportLocation;
            }

            try
            {
                System.Diagnostics.Process.Start(url);
            }
            catch (Exception ex)
            {
                Logger.Instance.LogError("Failed to navigate " + url + ". Exception: " + ex.Message + " " + ex.StackTrace);
            }
        }
    }

    public class XonWatchControl : StatusControl
    {
        public volatile bool IsInit = true;

        public override void DoWork(Object state)
        {
            try
            {
                LiveStatusMonitorService service = new LiveStatusMonitorService();
                string xml = service.XeOnWatchMonitor();
                AddEnvironments(xml);
                IsInit = false;
            }
            catch (Exception ex)
            {
                Logger.Instance.LogError("XeOnWatch Background Catch an Exception: " + ex.Message + " " + ex.StackTrace);
            }
        }

        protected override void LinkDetails(int selectedIndex)
        {
            string url = Properties.Settings.Default.XeOnWatchReportLocation;
            try
            {

                System.Diagnostics.Process.Start(url);
            }
            catch (Exception ex)
            {
                Logger.Instance.LogError("Failed to navigate " + url + ". Exception: " + ex.Message + " " + ex.StackTrace);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveMonitorClient\Properties\Settings.Designer.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3603
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace LiveMonitor.Properties {
    
    
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "9.0.0.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase {
        
        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));
        
        public static Settings Default {
            get {
                return defaultInstance;
            }
        }
        
        [global::System.Configuration.UserScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("120")]
        public int UpdateIntervalInSeconds {
            get {
                return ((int)(this["UpdateIntervalInSeconds"]));
            }
            set {
                this["UpdateIntervalInSeconds"] = value;
            }
        }
        
        [global::System.Configuration.UserScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("http://xon123/xwcreports/XeOnReport.asp")]
        public string XeOnWatchReportLocation {
            get {
                return ((string)(this["XeOnWatchReportLocation"]));
            }
            set {
                this["XeOnWatchReportLocation"] = value;
            }
        }
        
        [global::System.Configuration.UserScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("http://xon123:8888/Log/HealthCheckMonitor.xml")]
        public string HealthCheckReportLocation {
            get {
                return ((string)(this["HealthCheckReportLocation"]));
            }
            set {
                this["HealthCheckReportLocation"] = value;
            }
        }
        
        [global::System.Configuration.UserScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("http://xon123:8888/Log/HealthCheckMonitor_[XBLOBSERVERNAMEORIPADDRESS].xml")]
        public string HealthCheckForXblobReportLocation {
            get {
                return ((string)(this["HealthCheckForXblobReportLocation"]));
            }
            set {
                this["HealthCheckForXblobReportLocation"] = value;
            }
        }
        
        [global::System.Configuration.ApplicationScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.SpecialSettingAttribute(global::System.Configuration.SpecialSetting.WebServiceUrl)]
        [global::System.Configuration.DefaultSettingValueAttribute("http://xon123:8888/LiveStatusMonitor.asmx")]
        public string LiveMonitor_LiveStatusMonitorReference_LiveStatusMonitorService {
            get {
                return ((string)(this["LiveMonitor_LiveStatusMonitorReference_LiveStatusMonitorService"]));
            }
        }
        
        [global::System.Configuration.UserScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("LiveMonitorWidgetXblobList.txt")]
        public string AddedXblobLogFile {
            get {
                return ((string)(this["AddedXblobLogFile"]));
            }
            set {
                this["AddedXblobLogFile"] = value;
            }
        }
        
        [global::System.Configuration.UserScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("\\\\xon123\\LatestWidget")]
        public string LatestWidgetLocation {
            get {
                return ((string)(this["LatestWidgetLocation"]));
            }
            set {
                this["LatestWidgetLocation"] = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\LiveMonitorClient\WebReferences\LiveStatusMonitorReference\Reference.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3603
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by Microsoft.VSDesigner, Version 2.0.50727.3603.
// 
#pragma warning disable 1591

namespace LiveMonitor.LiveStatusMonitorReference {
    using System.Diagnostics;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Xml.Serialization;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.3053")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="LiveStatusMonitorServiceSoap", Namespace="http://tempuri.org/")]
    public partial class LiveStatusMonitorService : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        private System.Threading.SendOrPostCallback XeOnWatchMonitorOperationCompleted;
        
        private System.Threading.SendOrPostCallback HealthCheckMonitorOperationCompleted;
        
        private System.Threading.SendOrPostCallback HealthCheckMonitorForXblobOperationCompleted;
        
        private System.Threading.SendOrPostCallback IsUpdateNeededOperationCompleted;
        
        private bool useDefaultCredentialsSetExplicitly;
        
        /// <remarks/>
        public LiveStatusMonitorService() {
            this.Url = global::LiveMonitor.Properties.Settings.Default.LiveMonitor_LiveStatusMonitorReference_LiveStatusMonitorService;
            if ((this.IsLocalFileSystemWebService(this.Url) == true)) {
                this.UseDefaultCredentials = true;
                this.useDefaultCredentialsSetExplicitly = false;
            }
            else {
                this.useDefaultCredentialsSetExplicitly = true;
            }
        }
        
        public new string Url {
            get {
                return base.Url;
            }
            set {
                if ((((this.IsLocalFileSystemWebService(base.Url) == true) 
                            && (this.useDefaultCredentialsSetExplicitly == false)) 
                            && (this.IsLocalFileSystemWebService(value) == false))) {
                    base.UseDefaultCredentials = false;
                }
                base.Url = value;
            }
        }
        
        public new bool UseDefaultCredentials {
            get {
                return base.UseDefaultCredentials;
            }
            set {
                base.UseDefaultCredentials = value;
                this.useDefaultCredentialsSetExplicitly = true;
            }
        }
        
        /// <remarks/>
        public event XeOnWatchMonitorCompletedEventHandler XeOnWatchMonitorCompleted;
        
        /// <remarks/>
        public event HealthCheckMonitorCompletedEventHandler HealthCheckMonitorCompleted;
        
        /// <remarks/>
        public event HealthCheckMonitorForXblobCompletedEventHandler HealthCheckMonitorForXblobCompleted;
        
        /// <remarks/>
        public event IsUpdateNeededCompletedEventHandler IsUpdateNeededCompleted;
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://tempuri.org/XeOnWatchMonitor", RequestNamespace="http://tempuri.org/", ResponseNamespace="http://tempuri.org/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string XeOnWatchMonitor() {
            object[] results = this.Invoke("XeOnWatchMonitor", new object[0]);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void XeOnWatchMonitorAsync() {
            this.XeOnWatchMonitorAsync(null);
        }
        
        /// <remarks/>
        public void XeOnWatchMonitorAsync(object userState) {
            if ((this.XeOnWatchMonitorOperationCompleted == null)) {
                this.XeOnWatchMonitorOperationCompleted = new System.Threading.SendOrPostCallback(this.OnXeOnWatchMonitorOperationCompleted);
            }
            this.InvokeAsync("XeOnWatchMonitor", new object[0], this.XeOnWatchMonitorOperationCompleted, userState);
        }
        
        private void OnXeOnWatchMonitorOperationCompleted(object arg) {
            if ((this.XeOnWatchMonitorCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.XeOnWatchMonitorCompleted(this, new XeOnWatchMonitorCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://tempuri.org/HealthCheckMonitor", RequestNamespace="http://tempuri.org/", ResponseNamespace="http://tempuri.org/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string HealthCheckMonitor() {
            object[] results = this.Invoke("HealthCheckMonitor", new object[0]);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void HealthCheckMonitorAsync() {
            this.HealthCheckMonitorAsync(null);
        }
        
        /// <remarks/>
        public void HealthCheckMonitorAsync(object userState) {
            if ((this.HealthCheckMonitorOperationCompleted == null)) {
                this.HealthCheckMonitorOperationCompleted = new System.Threading.SendOrPostCallback(this.OnHealthCheckMonitorOperationCompleted);
            }
            this.InvokeAsync("HealthCheckMonitor", new object[0], this.HealthCheckMonitorOperationCompleted, userState);
        }
        
        private void OnHealthCheckMonitorOperationCompleted(object arg) {
            if ((this.HealthCheckMonitorCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.HealthCheckMonitorCompleted(this, new HealthCheckMonitorCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://tempuri.org/HealthCheckMonitorForXblob", RequestNamespace="http://tempuri.org/", ResponseNamespace="http://tempuri.org/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string HealthCheckMonitorForXblob(string serverNameOrIpAddress) {
            object[] results = this.Invoke("HealthCheckMonitorForXblob", new object[] {
                        serverNameOrIpAddress});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void HealthCheckMonitorForXblobAsync(string serverNameOrIpAddress) {
            this.HealthCheckMonitorForXblobAsync(serverNameOrIpAddress, null);
        }
        
        /// <remarks/>
        public void HealthCheckMonitorForXblobAsync(string serverNameOrIpAddress, object userState) {
            if ((this.HealthCheckMonitorForXblobOperationCompleted == null)) {
                this.HealthCheckMonitorForXblobOperationCompleted = new System.Threading.SendOrPostCallback(this.OnHealthCheckMonitorForXblobOperationCompleted);
            }
            this.InvokeAsync("HealthCheckMonitorForXblob", new object[] {
                        serverNameOrIpAddress}, this.HealthCheckMonitorForXblobOperationCompleted, userState);
        }
        
        private void OnHealthCheckMonitorForXblobOperationCompleted(object arg) {
            if ((this.HealthCheckMonitorForXblobCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.HealthCheckMonitorForXblobCompleted(this, new HealthCheckMonitorForXblobCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://tempuri.org/IsUpdateNeeded", RequestNamespace="http://tempuri.org/", ResponseNamespace="http://tempuri.org/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public bool IsUpdateNeeded(string ver) {
            object[] results = this.Invoke("IsUpdateNeeded", new object[] {
                        ver});
            return ((bool)(results[0]));
        }
        
        /// <remarks/>
        public void IsUpdateNeededAsync(string ver) {
            this.IsUpdateNeededAsync(ver, null);
        }
        
        /// <remarks/>
        public void IsUpdateNeededAsync(string ver, object userState) {
            if ((this.IsUpdateNeededOperationCompleted == null)) {
                this.IsUpdateNeededOperationCompleted = new System.Threading.SendOrPostCallback(this.OnIsUpdateNeededOperationCompleted);
            }
            this.InvokeAsync("IsUpdateNeeded", new object[] {
                        ver}, this.IsUpdateNeededOperationCompleted, userState);
        }
        
        private void OnIsUpdateNeededOperationCompleted(object arg) {
            if ((this.IsUpdateNeededCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.IsUpdateNeededCompleted(this, new IsUpdateNeededCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        public new void CancelAsync(object userState) {
            base.CancelAsync(userState);
        }
        
        private bool IsLocalFileSystemWebService(string url) {
            if (((url == null) 
                        || (url == string.Empty))) {
                return false;
            }
            System.Uri wsUri = new System.Uri(url);
            if (((wsUri.Port >= 1024) 
                        && (string.Compare(wsUri.Host, "localHost", System.StringComparison.OrdinalIgnoreCase) == 0))) {
                return true;
            }
            return false;
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.3053")]
    public delegate void XeOnWatchMonitorCompletedEventHandler(object sender, XeOnWatchMonitorCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.3053")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class XeOnWatchMonitorCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal XeOnWatchMonitorCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.3053")]
    public delegate void HealthCheckMonitorCompletedEventHandler(object sender, HealthCheckMonitorCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.3053")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class HealthCheckMonitorCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal HealthCheckMonitorCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.3053")]
    public delegate void HealthCheckMonitorForXblobCompletedEventHandler(object sender, HealthCheckMonitorForXblobCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.3053")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class HealthCheckMonitorForXblobCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal HealthCheckMonitorForXblobCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.3053")]
    public delegate void IsUpdateNeededCompletedEventHandler(object sender, IsUpdateNeededCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Web.Services", "2.0.50727.3053")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class IsUpdateNeededCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal IsUpdateNeededCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public bool Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((bool)(this.results[0]));
            }
        }
    }
}

#pragma warning restore 1591
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Monitoring\DiagnosticDAL\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
#if (!RAZZLE_BUILD)
[assembly: AssemblyTitle("DiagnosticDAL")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("DiagnosticDAL")]
[assembly: AssemblyCopyright("Copyright  Microsoft 2008")]
[assembly: AssemblyTrademark("")]
#endif
[assembly: AssemblyCulture("")]
#if (!RAZZLE_BUILD)
// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("ad4c94f6-d43f-4dfa-9d69-3de64b472ae8")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Monitoring\DiagnosticDAL\DiagnosticDBDataSet.Designer.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3053
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#pragma warning disable 1591

namespace Wgx.Services.Monitoring {
    
    
    /// <summary>
    ///Represents a strongly typed in-memory cache of data.
    ///</summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Data.Design.TypedDataSetGenerator", "2.0.0.0")]
    [global::System.Serializable()]
    [global::System.ComponentModel.DesignerCategoryAttribute("code")]
    [global::System.ComponentModel.ToolboxItem(true)]
    [global::System.Xml.Serialization.XmlSchemaProviderAttribute("GetTypedDataSetSchema")]
    [global::System.Xml.Serialization.XmlRootAttribute("DiagnosticDBDataSet")]
    [global::System.ComponentModel.Design.HelpKeywordAttribute("vs.data.DataSet")]
    public partial class DiagnosticDBDataSet : global::System.Data.DataSet {
        
        private MessageIDTransformTblDataTable tableMessageIDTransformTbl;
        
        private ListenerFilterDataTable tableListenerFilter;
        
        private TraceConfigurationSettingsDataTable tableTraceConfigurationSettings;
        
        private EventsXmlDataTable tableEventsXml;
        
        private EventsDataTable tableEvents;
        
        private GetSummaryEventsDataTable tableGetSummaryEvents;
        
        private EventsReportingDataTable tableEventsReporting;
        
        private EventsSummaryDataTable tableEventsSummary;
        
        private global::System.Data.SchemaSerializationMode _schemaSerializationMode = global::System.Data.SchemaSerializationMode.IncludeSchema;
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public DiagnosticDBDataSet() {
            this.BeginInit();
            this.InitClass();
            global::System.ComponentModel.CollectionChangeEventHandler schemaChangedHandler = new global::System.ComponentModel.CollectionChangeEventHandler(this.SchemaChanged);
            base.Tables.CollectionChanged += schemaChangedHandler;
            base.Relations.CollectionChanged += schemaChangedHandler;
            this.EndInit();
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        protected DiagnosticDBDataSet(global::System.Runtime.Serialization.SerializationInfo info, global::System.Runtime.Serialization.StreamingContext context) : 
                base(info, context, false) {
            if ((this.IsBinarySerialized(info, context) == true)) {
                this.InitVars(false);
                global::System.ComponentModel.CollectionChangeEventHandler schemaChangedHandler1 = new global::System.ComponentModel.CollectionChangeEventHandler(this.SchemaChanged);
                this.Tables.CollectionChanged += schemaChangedHandler1;
                this.Relations.CollectionChanged += schemaChangedHandler1;
                return;
            }
            string strSchema = ((string)(info.GetValue("XmlSchema", typeof(string))));
            if ((this.DetermineSchemaSerializationMode(info, context) == global::System.Data.SchemaSerializationMode.IncludeSchema)) {
                global::System.Data.DataSet ds = new global::System.Data.DataSet();
                ds.ReadXmlSchema(new global::System.Xml.XmlTextReader(new global::System.IO.StringReader(strSchema)));
                if ((ds.Tables["MessageIDTransformTbl"] != null)) {
                    base.Tables.Add(new MessageIDTransformTblDataTable(ds.Tables["MessageIDTransformTbl"]));
                }
                if ((ds.Tables["ListenerFilter"] != null)) {
                    base.Tables.Add(new ListenerFilterDataTable(ds.Tables["ListenerFilter"]));
                }
                if ((ds.Tables["TraceConfigurationSettings"] != null)) {
                    base.Tables.Add(new TraceConfigurationSettingsDataTable(ds.Tables["TraceConfigurationSettings"]));
                }
                if ((ds.Tables["EventsXml"] != null)) {
                    base.Tables.Add(new EventsXmlDataTable(ds.Tables["EventsXml"]));
                }
                if ((ds.Tables["Events"] != null)) {
                    base.Tables.Add(new EventsDataTable(ds.Tables["Events"]));
                }
                if ((ds.Tables["GetSummaryEvents"] != null)) {
                    base.Tables.Add(new GetSummaryEventsDataTable(ds.Tables["GetSummaryEvents"]));
                }
                if ((ds.Tables["EventsReporting"] != null)) {
                    base.Tables.Add(new EventsReportingDataTable(ds.Tables["EventsReporting"]));
                }
                if ((ds.Tables["EventsSummary"] != null)) {
                    base.Tables.Add(new EventsSummaryDataTable(ds.Tables["EventsSummary"]));
                }
                this.DataSetName = ds.DataSetName;
                this.Prefix = ds.Prefix;
                this.Namespace = ds.Namespace;
                this.Locale = ds.Locale;
                this.CaseSensitive = ds.CaseSensitive;
                this.EnforceConstraints = ds.EnforceConstraints;
                this.Merge(ds, false, global::System.Data.MissingSchemaAction.Add);
                this.InitVars();
            }
            else {
                this.ReadXmlSchema(new global::System.Xml.XmlTextReader(new global::System.IO.StringReader(strSchema)));
            }
            this.GetSerializationData(info, context);
            global::System.ComponentModel.CollectionChangeEventHandler schemaChangedHandler = new global::System.ComponentModel.CollectionChangeEventHandler(this.SchemaChanged);
            base.Tables.CollectionChanged += schemaChangedHandler;
            this.Relations.CollectionChanged += schemaChangedHandler;
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Browsable(false)]
        [global::System.ComponentModel.DesignerSerializationVisibility(global::System.ComponentModel.DesignerSerializationVisibility.Content)]
        public MessageIDTransformTblDataTable MessageIDTransformTbl {
            get {
                return this.tableMessageIDTransformTbl;
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Browsable(false)]
        [global::System.ComponentModel.DesignerSerializationVisibility(global::System.ComponentModel.DesignerSerializationVisibility.Content)]
        public ListenerFilterDataTable ListenerFilter {
            get {
                return this.tableListenerFilter;
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Browsable(false)]
        [global::System.ComponentModel.DesignerSerializationVisibility(global::System.ComponentModel.DesignerSerializationVisibility.Content)]
        public TraceConfigurationSettingsDataTable TraceConfigurationSettings {
            get {
                return this.tableTraceConfigurationSettings;
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Browsable(false)]
        [global::System.ComponentModel.DesignerSerializationVisibility(global::System.ComponentModel.DesignerSerializationVisibility.Content)]
        public EventsXmlDataTable EventsXml {
            get {
                return this.tableEventsXml;
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Browsable(false)]
        [global::System.ComponentModel.DesignerSerializationVisibility(global::System.ComponentModel.DesignerSerializationVisibility.Content)]
        public new EventsDataTable Events {
            get {
                return this.tableEvents;
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Browsable(false)]
        [global::System.ComponentModel.DesignerSerializationVisibility(global::System.ComponentModel.DesignerSerializationVisibility.Content)]
        public GetSummaryEventsDataTable GetSummaryEvents {
            get {
                return this.tableGetSummaryEvents;
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Browsable(false)]
        [global::System.ComponentModel.DesignerSerializationVisibility(global::System.ComponentModel.DesignerSerializationVisibility.Content)]
        public EventsReportingDataTable EventsReporting {
            get {
                return this.tableEventsReporting;
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Browsable(false)]
        [global::System.ComponentModel.DesignerSerializationVisibility(global::System.ComponentModel.DesignerSerializationVisibility.Content)]
        public EventsSummaryDataTable EventsSummary {
            get {
                return this.tableEventsSummary;
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.BrowsableAttribute(true)]
        [global::System.ComponentModel.DesignerSerializationVisibilityAttribute(global::System.ComponentModel.DesignerSerializationVisibility.Visible)]
        public override global::System.Data.SchemaSerializationMode SchemaSerializationMode {
            get {
                return this._schemaSerializationMode;
            }
            set {
                this._schemaSerializationMode = value;
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.DesignerSerializationVisibilityAttribute(global::System.ComponentModel.DesignerSerializationVisibility.Hidden)]
        public new global::System.Data.DataTableCollection Tables {
            get {
                return base.Tables;
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.DesignerSerializationVisibilityAttribute(global::System.ComponentModel.DesignerSerializationVisibility.Hidden)]
        public new global::System.Data.DataRelationCollection Relations {
            get {
                return base.Relations;
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        protected override void InitializeDerivedDataSet() {
            this.BeginInit();
            this.InitClass();
            this.EndInit();
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public override global::System.Data.DataSet Clone() {
            DiagnosticDBDataSet cln = ((DiagnosticDBDataSet)(base.Clone()));
            cln.InitVars();
            cln.SchemaSerializationMode = this.SchemaSerializationMode;
            return cln;
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        protected override bool ShouldSerializeTables() {
            return false;
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        protected override bool ShouldSerializeRelations() {
            return false;
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        protected override void ReadXmlSerializable(global::System.Xml.XmlReader reader) {
            if ((this.DetermineSchemaSerializationMode(reader) == global::System.Data.SchemaSerializationMode.IncludeSchema)) {
                this.Reset();
                global::System.Data.DataSet ds = new global::System.Data.DataSet();
                ds.ReadXml(reader);
                if ((ds.Tables["MessageIDTransformTbl"] != null)) {
                    base.Tables.Add(new MessageIDTransformTblDataTable(ds.Tables["MessageIDTransformTbl"]));
                }
                if ((ds.Tables["ListenerFilter"] != null)) {
                    base.Tables.Add(new ListenerFilterDataTable(ds.Tables["ListenerFilter"]));
                }
                if ((ds.Tables["TraceConfigurationSettings"] != null)) {
                    base.Tables.Add(new TraceConfigurationSettingsDataTable(ds.Tables["TraceConfigurationSettings"]));
                }
                if ((ds.Tables["EventsXml"] != null)) {
                    base.Tables.Add(new EventsXmlDataTable(ds.Tables["EventsXml"]));
                }
                if ((ds.Tables["Events"] != null)) {
                    base.Tables.Add(new EventsDataTable(ds.Tables["Events"]));
                }
                if ((ds.Tables["GetSummaryEvents"] != null)) {
                    base.Tables.Add(new GetSummaryEventsDataTable(ds.Tables["GetSummaryEvents"]));
                }
                if ((ds.Tables["EventsReporting"] != null)) {
                    base.Tables.Add(new EventsReportingDataTable(ds.Tables["EventsReporting"]));
                }
                if ((ds.Tables["EventsSummary"] != null)) {
                    base.Tables.Add(new EventsSummaryDataTable(ds.Tables["EventsSummary"]));
                }
                this.DataSetName = ds.DataSetName;
                this.Prefix = ds.Prefix;
                this.Namespace = ds.Namespace;
                this.Locale = ds.Locale;
                this.CaseSensitive = ds.CaseSensitive;
                this.EnforceConstraints = ds.EnforceConstraints;
                this.Merge(ds, false, global::System.Data.MissingSchemaAction.Add);
                this.InitVars();
            }
            else {
                this.ReadXml(reader);
                this.InitVars();
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        protected override global::System.Xml.Schema.XmlSchema GetSchemaSerializable() {
            global::System.IO.MemoryStream stream = new global::System.IO.MemoryStream();
            this.WriteXmlSchema(new global::System.Xml.XmlTextWriter(stream, null));
            stream.Position = 0;
            return global::System.Xml.Schema.XmlSchema.Read(new global::System.Xml.XmlTextReader(stream), null);
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        internal void InitVars() {
            this.InitVars(true);
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        internal void InitVars(bool initTable) {
            this.tableMessageIDTransformTbl = ((MessageIDTransformTblDataTable)(base.Tables["MessageIDTransformTbl"]));
            if ((initTable == true)) {
                if ((this.tableMessageIDTransformTbl != null)) {
                    this.tableMessageIDTransformTbl.InitVars();
                }
            }
            this.tableListenerFilter = ((ListenerFilterDataTable)(base.Tables["ListenerFilter"]));
            if ((initTable == true)) {
                if ((this.tableListenerFilter != null)) {
                    this.tableListenerFilter.InitVars();
                }
            }
            this.tableTraceConfigurationSettings = ((TraceConfigurationSettingsDataTable)(base.Tables["TraceConfigurationSettings"]));
            if ((initTable == true)) {
                if ((this.tableTraceConfigurationSettings != null)) {
                    this.tableTraceConfigurationSettings.InitVars();
                }
            }
            this.tableEventsXml = ((EventsXmlDataTable)(base.Tables["EventsXml"]));
            if ((initTable == true)) {
                if ((this.tableEventsXml != null)) {
                    this.tableEventsXml.InitVars();
                }
            }
            this.tableEvents = ((EventsDataTable)(base.Tables["Events"]));
            if ((initTable == true)) {
                if ((this.tableEvents != null)) {
                    this.tableEvents.InitVars();
                }
            }
            this.tableGetSummaryEvents = ((GetSummaryEventsDataTable)(base.Tables["GetSummaryEvents"]));
            if ((initTable == true)) {
                if ((this.tableGetSummaryEvents != null)) {
                    this.tableGetSummaryEvents.InitVars();
                }
            }
            this.tableEventsReporting = ((EventsReportingDataTable)(base.Tables["EventsReporting"]));
            if ((initTable == true)) {
                if ((this.tableEventsReporting != null)) {
                    this.tableEventsReporting.InitVars();
                }
            }
            this.tableEventsSummary = ((EventsSummaryDataTable)(base.Tables["EventsSummary"]));
            if ((initTable == true)) {
                if ((this.tableEventsSummary != null)) {
                    this.tableEventsSummary.InitVars();
                }
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        private void InitClass() {
            this.DataSetName = "DiagnosticDBDataSet";
            this.Prefix = "";
            this.Namespace = "http://tempuri.org/DiagnosticDBDataSet.xsd";
            this.EnforceConstraints = true;
            this.SchemaSerializationMode = global::System.Data.SchemaSerializationMode.IncludeSchema;
            this.tableMessageIDTransformTbl = new MessageIDTransformTblDataTable();
            base.Tables.Add(this.tableMessageIDTransformTbl);
            this.tableListenerFilter = new ListenerFilterDataTable();
            base.Tables.Add(this.tableListenerFilter);
            this.tableTraceConfigurationSettings = new TraceConfigurationSettingsDataTable();
            base.Tables.Add(this.tableTraceConfigurationSettings);
            this.tableEventsXml = new EventsXmlDataTable();
            base.Tables.Add(this.tableEventsXml);
            this.tableEvents = new EventsDataTable();
            base.Tables.Add(this.tableEvents);
            this.tableGetSummaryEvents = new GetSummaryEventsDataTable();
            base.Tables.Add(this.tableGetSummaryEvents);
            this.tableEventsReporting = new EventsReportingDataTable();
            base.Tables.Add(this.tableEventsReporting);
            this.tableEventsSummary = new EventsSummaryDataTable();
            base.Tables.Add(this.tableEventsSummary);
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        private bool ShouldSerializeMessageIDTransformTbl() {
            return false;
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        private bool ShouldSerializeListenerFilter() {
            return false;
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        private bool ShouldSerializeTraceConfigurationSettings() {
            return false;
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        private bool ShouldSerializeEventsXml() {
            return false;
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        private bool ShouldSerializeEvents() {
            return false;
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        private bool ShouldSerializeGetSummaryEvents() {
            return false;
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        private bool ShouldSerializeEventsReporting() {
            return false;
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        private bool ShouldSerializeEventsSummary() {
            return false;
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        private void SchemaChanged(object sender, global::System.ComponentModel.CollectionChangeEventArgs e) {
            if ((e.Action == global::System.ComponentModel.CollectionChangeAction.Remove)) {
                this.InitVars();
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public static global::System.Xml.Schema.XmlSchemaComplexType GetTypedDataSetSchema(global::System.Xml.Schema.XmlSchemaSet xs) {
            DiagnosticDBDataSet ds = new DiagnosticDBDataSet();
            global::System.Xml.Schema.XmlSchemaComplexType type = new global::System.Xml.Schema.XmlSchemaComplexType();
            global::System.Xml.Schema.XmlSchemaSequence sequence = new global::System.Xml.Schema.XmlSchemaSequence();
            global::System.Xml.Schema.XmlSchemaAny any = new global::System.Xml.Schema.XmlSchemaAny();
            any.Namespace = ds.Namespace;
            sequence.Items.Add(any);
            type.Particle = sequence;
            global::System.Xml.Schema.XmlSchema dsSchema = ds.GetSchemaSerializable();
            if (xs.Contains(dsSchema.TargetNamespace)) {
                global::System.IO.MemoryStream s1 = new global::System.IO.MemoryStream();
                global::System.IO.MemoryStream s2 = new global::System.IO.MemoryStream();
                try {
                    global::System.Xml.Schema.XmlSchema schema = null;
                    dsSchema.Write(s1);
                    for (global::System.Collections.IEnumerator schemas = xs.Schemas(dsSchema.TargetNamespace).GetEnumerator(); schemas.MoveNext(); ) {
                        schema = ((global::System.Xml.Schema.XmlSchema)(schemas.Current));
                        s2.SetLength(0);
                        schema.Write(s2);
                        if ((s1.Length == s2.Length)) {
                            s1.Position = 0;
                            s2.Position = 0;
                            for (; ((s1.Position != s1.Length) 
                                        && (s1.ReadByte() == s2.ReadByte())); ) {
                                ;
                            }
                            if ((s1.Position == s1.Length)) {
                                return type;
                            }
                        }
                    }
                }
                finally {
                    if ((s1 != null)) {
                        s1.Close();
                    }
                    if ((s2 != null)) {
                        s2.Close();
                    }
                }
            }
            xs.Add(dsSchema);
            return type;
        }
        
        public delegate void MessageIDTransformTblRowChangeEventHandler(object sender, MessageIDTransformTblRowChangeEvent e);
        
        public delegate void ListenerFilterRowChangeEventHandler(object sender, ListenerFilterRowChangeEvent e);
        
        public delegate void TraceConfigurationSettingsRowChangeEventHandler(object sender, TraceConfigurationSettingsRowChangeEvent e);
        
        public delegate void EventsXmlRowChangeEventHandler(object sender, EventsXmlRowChangeEvent e);
        
        public delegate void EventsRowChangeEventHandler(object sender, EventsRowChangeEvent e);
        
        public delegate void GetSummaryEventsRowChangeEventHandler(object sender, GetSummaryEventsRowChangeEvent e);
        
        public delegate void EventsReportingRowChangeEventHandler(object sender, EventsReportingRowChangeEvent e);
        
        public delegate void EventsSummaryRowChangeEventHandler(object sender, EventsSummaryRowChangeEvent e);
        
        /// <summary>
        ///Represents the strongly named DataTable class.
        ///</summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Data.Design.TypedDataSetGenerator", "2.0.0.0")]
        [global::System.Serializable()]
        [global::System.Xml.Serialization.XmlSchemaProviderAttribute("GetTypedTableSchema")]
        public partial class MessageIDTransformTblDataTable : global::System.Data.TypedTableBase<MessageIDTransformTblRow> {
            
            private global::System.Data.DataColumn columnMessageID;
            
            private global::System.Data.DataColumn columnNewSeverity;
            
            private global::System.Data.DataColumn columnPK_MessageIDTransform;
            
            private global::System.Data.DataColumn columnShouldTrace;
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public MessageIDTransformTblDataTable() {
                this.TableName = "MessageIDTransformTbl";
                this.BeginInit();
                this.InitClass();
                this.EndInit();
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            internal MessageIDTransformTblDataTable(global::System.Data.DataTable table) {
                this.TableName = table.TableName;
                if ((table.CaseSensitive != table.DataSet.CaseSensitive)) {
                    this.CaseSensitive = table.CaseSensitive;
                }
                if ((table.Locale.ToString() != table.DataSet.Locale.ToString())) {
                    this.Locale = table.Locale;
                }
                if ((table.Namespace != table.DataSet.Namespace)) {
                    this.Namespace = table.Namespace;
                }
                this.Prefix = table.Prefix;
                this.MinimumCapacity = table.MinimumCapacity;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected MessageIDTransformTblDataTable(global::System.Runtime.Serialization.SerializationInfo info, global::System.Runtime.Serialization.StreamingContext context) : 
                    base(info, context) {
                this.InitVars();
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn MessageIDColumn {
                get {
                    return this.columnMessageID;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn NewSeverityColumn {
                get {
                    return this.columnNewSeverity;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn PK_MessageIDTransformColumn {
                get {
                    return this.columnPK_MessageIDTransform;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn ShouldTraceColumn {
                get {
                    return this.columnShouldTrace;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            [global::System.ComponentModel.Browsable(false)]
            public int Count {
                get {
                    return this.Rows.Count;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public MessageIDTransformTblRow this[int index] {
                get {
                    return ((MessageIDTransformTblRow)(this.Rows[index]));
                }
            }
            
            public event MessageIDTransformTblRowChangeEventHandler MessageIDTransformTblRowChanging;
            
            public event MessageIDTransformTblRowChangeEventHandler MessageIDTransformTblRowChanged;
            
            public event MessageIDTransformTblRowChangeEventHandler MessageIDTransformTblRowDeleting;
            
            public event MessageIDTransformTblRowChangeEventHandler MessageIDTransformTblRowDeleted;
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void AddMessageIDTransformTblRow(MessageIDTransformTblRow row) {
                this.Rows.Add(row);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public MessageIDTransformTblRow AddMessageIDTransformTblRow(int MessageID, int NewSeverity, bool ShouldTrace) {
                MessageIDTransformTblRow rowMessageIDTransformTblRow = ((MessageIDTransformTblRow)(this.NewRow()));
                object[] columnValuesArray = new object[] {
                        MessageID,
                        NewSeverity,
                        null,
                        ShouldTrace};
                rowMessageIDTransformTblRow.ItemArray = columnValuesArray;
                this.Rows.Add(rowMessageIDTransformTblRow);
                return rowMessageIDTransformTblRow;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public MessageIDTransformTblRow FindByPK_MessageIDTransform(int PK_MessageIDTransform) {
                return ((MessageIDTransformTblRow)(this.Rows.Find(new object[] {
                            PK_MessageIDTransform})));
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public override global::System.Data.DataTable Clone() {
                MessageIDTransformTblDataTable cln = ((MessageIDTransformTblDataTable)(base.Clone()));
                cln.InitVars();
                return cln;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override global::System.Data.DataTable CreateInstance() {
                return new MessageIDTransformTblDataTable();
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            internal void InitVars() {
                this.columnMessageID = base.Columns["MessageID"];
                this.columnNewSeverity = base.Columns["NewSeverity"];
                this.columnPK_MessageIDTransform = base.Columns["PK_MessageIDTransform"];
                this.columnShouldTrace = base.Columns["ShouldTrace"];
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            private void InitClass() {
                this.columnMessageID = new global::System.Data.DataColumn("MessageID", typeof(int), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnMessageID);
                this.columnNewSeverity = new global::System.Data.DataColumn("NewSeverity", typeof(int), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnNewSeverity);
                this.columnPK_MessageIDTransform = new global::System.Data.DataColumn("PK_MessageIDTransform", typeof(int), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnPK_MessageIDTransform);
                this.columnShouldTrace = new global::System.Data.DataColumn("ShouldTrace", typeof(bool), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnShouldTrace);
                this.Constraints.Add(new global::System.Data.UniqueConstraint("Constraint1", new global::System.Data.DataColumn[] {
                                this.columnPK_MessageIDTransform}, true));
                this.columnMessageID.AllowDBNull = false;
                this.columnPK_MessageIDTransform.AutoIncrement = true;
                this.columnPK_MessageIDTransform.AutoIncrementSeed = -1;
                this.columnPK_MessageIDTransform.AutoIncrementStep = -1;
                this.columnPK_MessageIDTransform.AllowDBNull = false;
                this.columnPK_MessageIDTransform.ReadOnly = true;
                this.columnPK_MessageIDTransform.Unique = true;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public MessageIDTransformTblRow NewMessageIDTransformTblRow() {
                return ((MessageIDTransformTblRow)(this.NewRow()));
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override global::System.Data.DataRow NewRowFromBuilder(global::System.Data.DataRowBuilder builder) {
                return new MessageIDTransformTblRow(builder);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override global::System.Type GetRowType() {
                return typeof(MessageIDTransformTblRow);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override void OnRowChanged(global::System.Data.DataRowChangeEventArgs e) {
                base.OnRowChanged(e);
                if ((this.MessageIDTransformTblRowChanged != null)) {
                    this.MessageIDTransformTblRowChanged(this, new MessageIDTransformTblRowChangeEvent(((MessageIDTransformTblRow)(e.Row)), e.Action));
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override void OnRowChanging(global::System.Data.DataRowChangeEventArgs e) {
                base.OnRowChanging(e);
                if ((this.MessageIDTransformTblRowChanging != null)) {
                    this.MessageIDTransformTblRowChanging(this, new MessageIDTransformTblRowChangeEvent(((MessageIDTransformTblRow)(e.Row)), e.Action));
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override void OnRowDeleted(global::System.Data.DataRowChangeEventArgs e) {
                base.OnRowDeleted(e);
                if ((this.MessageIDTransformTblRowDeleted != null)) {
                    this.MessageIDTransformTblRowDeleted(this, new MessageIDTransformTblRowChangeEvent(((MessageIDTransformTblRow)(e.Row)), e.Action));
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override void OnRowDeleting(global::System.Data.DataRowChangeEventArgs e) {
                base.OnRowDeleting(e);
                if ((this.MessageIDTransformTblRowDeleting != null)) {
                    this.MessageIDTransformTblRowDeleting(this, new MessageIDTransformTblRowChangeEvent(((MessageIDTransformTblRow)(e.Row)), e.Action));
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void RemoveMessageIDTransformTblRow(MessageIDTransformTblRow row) {
                this.Rows.Remove(row);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public static global::System.Xml.Schema.XmlSchemaComplexType GetTypedTableSchema(global::System.Xml.Schema.XmlSchemaSet xs) {
                global::System.Xml.Schema.XmlSchemaComplexType type = new global::System.Xml.Schema.XmlSchemaComplexType();
                global::System.Xml.Schema.XmlSchemaSequence sequence = new global::System.Xml.Schema.XmlSchemaSequence();
                DiagnosticDBDataSet ds = new DiagnosticDBDataSet();
                global::System.Xml.Schema.XmlSchemaAny any1 = new global::System.Xml.Schema.XmlSchemaAny();
                any1.Namespace = "http://www.w3.org/2001/XMLSchema";
                any1.MinOccurs = new decimal(0);
                any1.MaxOccurs = decimal.MaxValue;
                any1.ProcessContents = global::System.Xml.Schema.XmlSchemaContentProcessing.Lax;
                sequence.Items.Add(any1);
                global::System.Xml.Schema.XmlSchemaAny any2 = new global::System.Xml.Schema.XmlSchemaAny();
                any2.Namespace = "urn:schemas-microsoft-com:xml-diffgram-v1";
                any2.MinOccurs = new decimal(1);
                any2.ProcessContents = global::System.Xml.Schema.XmlSchemaContentProcessing.Lax;
                sequence.Items.Add(any2);
                global::System.Xml.Schema.XmlSchemaAttribute attribute1 = new global::System.Xml.Schema.XmlSchemaAttribute();
                attribute1.Name = "namespace";
                attribute1.FixedValue = ds.Namespace;
                type.Attributes.Add(attribute1);
                global::System.Xml.Schema.XmlSchemaAttribute attribute2 = new global::System.Xml.Schema.XmlSchemaAttribute();
                attribute2.Name = "tableTypeName";
                attribute2.FixedValue = "MessageIDTransformTblDataTable";
                type.Attributes.Add(attribute2);
                type.Particle = sequence;
                global::System.Xml.Schema.XmlSchema dsSchema = ds.GetSchemaSerializable();
                if (xs.Contains(dsSchema.TargetNamespace)) {
                    global::System.IO.MemoryStream s1 = new global::System.IO.MemoryStream();
                    global::System.IO.MemoryStream s2 = new global::System.IO.MemoryStream();
                    try {
                        global::System.Xml.Schema.XmlSchema schema = null;
                        dsSchema.Write(s1);
                        for (global::System.Collections.IEnumerator schemas = xs.Schemas(dsSchema.TargetNamespace).GetEnumerator(); schemas.MoveNext(); ) {
                            schema = ((global::System.Xml.Schema.XmlSchema)(schemas.Current));
                            s2.SetLength(0);
                            schema.Write(s2);
                            if ((s1.Length == s2.Length)) {
                                s1.Position = 0;
                                s2.Position = 0;
                                for (; ((s1.Position != s1.Length) 
                                            && (s1.ReadByte() == s2.ReadByte())); ) {
                                    ;
                                }
                                if ((s1.Position == s1.Length)) {
                                    return type;
                                }
                            }
                        }
                    }
                    finally {
                        if ((s1 != null)) {
                            s1.Close();
                        }
                        if ((s2 != null)) {
                            s2.Close();
                        }
                    }
                }
                xs.Add(dsSchema);
                return type;
            }
        }
        
        /// <summary>
        ///Represents the strongly named DataTable class.
        ///</summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Data.Design.TypedDataSetGenerator", "2.0.0.0")]
        [global::System.Serializable()]
        [global::System.Xml.Serialization.XmlSchemaProviderAttribute("GetTypedTableSchema")]
        public partial class ListenerFilterDataTable : global::System.Data.TypedTableBase<ListenerFilterRow> {
            
            private global::System.Data.DataColumn columnListenerName;
            
            private global::System.Data.DataColumn columnTraceThresholdMask;
            
            private global::System.Data.DataColumn columnTraceOutputOptions;
            
            private global::System.Data.DataColumn columnPK_FilterID;
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public ListenerFilterDataTable() {
                this.TableName = "ListenerFilter";
                this.BeginInit();
                this.InitClass();
                this.EndInit();
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            internal ListenerFilterDataTable(global::System.Data.DataTable table) {
                this.TableName = table.TableName;
                if ((table.CaseSensitive != table.DataSet.CaseSensitive)) {
                    this.CaseSensitive = table.CaseSensitive;
                }
                if ((table.Locale.ToString() != table.DataSet.Locale.ToString())) {
                    this.Locale = table.Locale;
                }
                if ((table.Namespace != table.DataSet.Namespace)) {
                    this.Namespace = table.Namespace;
                }
                this.Prefix = table.Prefix;
                this.MinimumCapacity = table.MinimumCapacity;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected ListenerFilterDataTable(global::System.Runtime.Serialization.SerializationInfo info, global::System.Runtime.Serialization.StreamingContext context) : 
                    base(info, context) {
                this.InitVars();
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn ListenerNameColumn {
                get {
                    return this.columnListenerName;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn TraceThresholdMaskColumn {
                get {
                    return this.columnTraceThresholdMask;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn TraceOutputOptionsColumn {
                get {
                    return this.columnTraceOutputOptions;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn PK_FilterIDColumn {
                get {
                    return this.columnPK_FilterID;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            [global::System.ComponentModel.Browsable(false)]
            public int Count {
                get {
                    return this.Rows.Count;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public ListenerFilterRow this[int index] {
                get {
                    return ((ListenerFilterRow)(this.Rows[index]));
                }
            }
            
            public event ListenerFilterRowChangeEventHandler ListenerFilterRowChanging;
            
            public event ListenerFilterRowChangeEventHandler ListenerFilterRowChanged;
            
            public event ListenerFilterRowChangeEventHandler ListenerFilterRowDeleting;
            
            public event ListenerFilterRowChangeEventHandler ListenerFilterRowDeleted;
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void AddListenerFilterRow(ListenerFilterRow row) {
                this.Rows.Add(row);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public ListenerFilterRow AddListenerFilterRow(string ListenerName, int TraceThresholdMask, int TraceOutputOptions) {
                ListenerFilterRow rowListenerFilterRow = ((ListenerFilterRow)(this.NewRow()));
                object[] columnValuesArray = new object[] {
                        ListenerName,
                        TraceThresholdMask,
                        TraceOutputOptions,
                        null};
                rowListenerFilterRow.ItemArray = columnValuesArray;
                this.Rows.Add(rowListenerFilterRow);
                return rowListenerFilterRow;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public ListenerFilterRow FindByPK_FilterID(int PK_FilterID) {
                return ((ListenerFilterRow)(this.Rows.Find(new object[] {
                            PK_FilterID})));
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public override global::System.Data.DataTable Clone() {
                ListenerFilterDataTable cln = ((ListenerFilterDataTable)(base.Clone()));
                cln.InitVars();
                return cln;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override global::System.Data.DataTable CreateInstance() {
                return new ListenerFilterDataTable();
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            internal void InitVars() {
                this.columnListenerName = base.Columns["ListenerName"];
                this.columnTraceThresholdMask = base.Columns["TraceThresholdMask"];
                this.columnTraceOutputOptions = base.Columns["TraceOutputOptions"];
                this.columnPK_FilterID = base.Columns["PK_FilterID"];
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            private void InitClass() {
                this.columnListenerName = new global::System.Data.DataColumn("ListenerName", typeof(string), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnListenerName);
                this.columnTraceThresholdMask = new global::System.Data.DataColumn("TraceThresholdMask", typeof(int), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnTraceThresholdMask);
                this.columnTraceOutputOptions = new global::System.Data.DataColumn("TraceOutputOptions", typeof(int), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnTraceOutputOptions);
                this.columnPK_FilterID = new global::System.Data.DataColumn("PK_FilterID", typeof(int), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnPK_FilterID);
                this.Constraints.Add(new global::System.Data.UniqueConstraint("Constraint1", new global::System.Data.DataColumn[] {
                                this.columnPK_FilterID}, true));
                this.columnListenerName.MaxLength = 2147483647;
                this.columnPK_FilterID.AutoIncrement = true;
                this.columnPK_FilterID.AutoIncrementSeed = -1;
                this.columnPK_FilterID.AutoIncrementStep = -1;
                this.columnPK_FilterID.AllowDBNull = false;
                this.columnPK_FilterID.ReadOnly = true;
                this.columnPK_FilterID.Unique = true;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public ListenerFilterRow NewListenerFilterRow() {
                return ((ListenerFilterRow)(this.NewRow()));
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override global::System.Data.DataRow NewRowFromBuilder(global::System.Data.DataRowBuilder builder) {
                return new ListenerFilterRow(builder);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override global::System.Type GetRowType() {
                return typeof(ListenerFilterRow);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override void OnRowChanged(global::System.Data.DataRowChangeEventArgs e) {
                base.OnRowChanged(e);
                if ((this.ListenerFilterRowChanged != null)) {
                    this.ListenerFilterRowChanged(this, new ListenerFilterRowChangeEvent(((ListenerFilterRow)(e.Row)), e.Action));
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override void OnRowChanging(global::System.Data.DataRowChangeEventArgs e) {
                base.OnRowChanging(e);
                if ((this.ListenerFilterRowChanging != null)) {
                    this.ListenerFilterRowChanging(this, new ListenerFilterRowChangeEvent(((ListenerFilterRow)(e.Row)), e.Action));
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override void OnRowDeleted(global::System.Data.DataRowChangeEventArgs e) {
                base.OnRowDeleted(e);
                if ((this.ListenerFilterRowDeleted != null)) {
                    this.ListenerFilterRowDeleted(this, new ListenerFilterRowChangeEvent(((ListenerFilterRow)(e.Row)), e.Action));
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override void OnRowDeleting(global::System.Data.DataRowChangeEventArgs e) {
                base.OnRowDeleting(e);
                if ((this.ListenerFilterRowDeleting != null)) {
                    this.ListenerFilterRowDeleting(this, new ListenerFilterRowChangeEvent(((ListenerFilterRow)(e.Row)), e.Action));
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void RemoveListenerFilterRow(ListenerFilterRow row) {
                this.Rows.Remove(row);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public static global::System.Xml.Schema.XmlSchemaComplexType GetTypedTableSchema(global::System.Xml.Schema.XmlSchemaSet xs) {
                global::System.Xml.Schema.XmlSchemaComplexType type = new global::System.Xml.Schema.XmlSchemaComplexType();
                global::System.Xml.Schema.XmlSchemaSequence sequence = new global::System.Xml.Schema.XmlSchemaSequence();
                DiagnosticDBDataSet ds = new DiagnosticDBDataSet();
                global::System.Xml.Schema.XmlSchemaAny any1 = new global::System.Xml.Schema.XmlSchemaAny();
                any1.Namespace = "http://www.w3.org/2001/XMLSchema";
                any1.MinOccurs = new decimal(0);
                any1.MaxOccurs = decimal.MaxValue;
                any1.ProcessContents = global::System.Xml.Schema.XmlSchemaContentProcessing.Lax;
                sequence.Items.Add(any1);
                global::System.Xml.Schema.XmlSchemaAny any2 = new global::System.Xml.Schema.XmlSchemaAny();
                any2.Namespace = "urn:schemas-microsoft-com:xml-diffgram-v1";
                any2.MinOccurs = new decimal(1);
                any2.ProcessContents = global::System.Xml.Schema.XmlSchemaContentProcessing.Lax;
                sequence.Items.Add(any2);
                global::System.Xml.Schema.XmlSchemaAttribute attribute1 = new global::System.Xml.Schema.XmlSchemaAttribute();
                attribute1.Name = "namespace";
                attribute1.FixedValue = ds.Namespace;
                type.Attributes.Add(attribute1);
                global::System.Xml.Schema.XmlSchemaAttribute attribute2 = new global::System.Xml.Schema.XmlSchemaAttribute();
                attribute2.Name = "tableTypeName";
                attribute2.FixedValue = "ListenerFilterDataTable";
                type.Attributes.Add(attribute2);
                type.Particle = sequence;
                global::System.Xml.Schema.XmlSchema dsSchema = ds.GetSchemaSerializable();
                if (xs.Contains(dsSchema.TargetNamespace)) {
                    global::System.IO.MemoryStream s1 = new global::System.IO.MemoryStream();
                    global::System.IO.MemoryStream s2 = new global::System.IO.MemoryStream();
                    try {
                        global::System.Xml.Schema.XmlSchema schema = null;
                        dsSchema.Write(s1);
                        for (global::System.Collections.IEnumerator schemas = xs.Schemas(dsSchema.TargetNamespace).GetEnumerator(); schemas.MoveNext(); ) {
                            schema = ((global::System.Xml.Schema.XmlSchema)(schemas.Current));
                            s2.SetLength(0);
                            schema.Write(s2);
                            if ((s1.Length == s2.Length)) {
                                s1.Position = 0;
                                s2.Position = 0;
                                for (; ((s1.Position != s1.Length) 
                                            && (s1.ReadByte() == s2.ReadByte())); ) {
                                    ;
                                }
                                if ((s1.Position == s1.Length)) {
                                    return type;
                                }
                            }
                        }
                    }
                    finally {
                        if ((s1 != null)) {
                            s1.Close();
                        }
                        if ((s2 != null)) {
                            s2.Close();
                        }
                    }
                }
                xs.Add(dsSchema);
                return type;
            }
        }
        
        /// <summary>
        ///Represents the strongly named DataTable class.
        ///</summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Data.Design.TypedDataSetGenerator", "2.0.0.0")]
        [global::System.Serializable()]
        [global::System.Xml.Serialization.XmlSchemaProviderAttribute("GetTypedTableSchema")]
        public partial class TraceConfigurationSettingsDataTable : global::System.Data.TypedTableBase<TraceConfigurationSettingsRow> {
            
            private global::System.Data.DataColumn columnSwitchValue;
            
            private global::System.Data.DataColumn columnUpdateInterval;
            
            private global::System.Data.DataColumn columnSwitchName;
            
            private global::System.Data.DataColumn columnTraceOutputOptions;
            
            private global::System.Data.DataColumn columnPK_TraceConfigSettings;
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public TraceConfigurationSettingsDataTable() {
                this.TableName = "TraceConfigurationSettings";
                this.BeginInit();
                this.InitClass();
                this.EndInit();
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            internal TraceConfigurationSettingsDataTable(global::System.Data.DataTable table) {
                this.TableName = table.TableName;
                if ((table.CaseSensitive != table.DataSet.CaseSensitive)) {
                    this.CaseSensitive = table.CaseSensitive;
                }
                if ((table.Locale.ToString() != table.DataSet.Locale.ToString())) {
                    this.Locale = table.Locale;
                }
                if ((table.Namespace != table.DataSet.Namespace)) {
                    this.Namespace = table.Namespace;
                }
                this.Prefix = table.Prefix;
                this.MinimumCapacity = table.MinimumCapacity;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected TraceConfigurationSettingsDataTable(global::System.Runtime.Serialization.SerializationInfo info, global::System.Runtime.Serialization.StreamingContext context) : 
                    base(info, context) {
                this.InitVars();
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn SwitchValueColumn {
                get {
                    return this.columnSwitchValue;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn UpdateIntervalColumn {
                get {
                    return this.columnUpdateInterval;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn SwitchNameColumn {
                get {
                    return this.columnSwitchName;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn TraceOutputOptionsColumn {
                get {
                    return this.columnTraceOutputOptions;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn PK_TraceConfigSettingsColumn {
                get {
                    return this.columnPK_TraceConfigSettings;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            [global::System.ComponentModel.Browsable(false)]
            public int Count {
                get {
                    return this.Rows.Count;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public TraceConfigurationSettingsRow this[int index] {
                get {
                    return ((TraceConfigurationSettingsRow)(this.Rows[index]));
                }
            }
            
            public event TraceConfigurationSettingsRowChangeEventHandler TraceConfigurationSettingsRowChanging;
            
            public event TraceConfigurationSettingsRowChangeEventHandler TraceConfigurationSettingsRowChanged;
            
            public event TraceConfigurationSettingsRowChangeEventHandler TraceConfigurationSettingsRowDeleting;
            
            public event TraceConfigurationSettingsRowChangeEventHandler TraceConfigurationSettingsRowDeleted;
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void AddTraceConfigurationSettingsRow(TraceConfigurationSettingsRow row) {
                this.Rows.Add(row);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public TraceConfigurationSettingsRow AddTraceConfigurationSettingsRow(int SwitchValue, int UpdateInterval, string SwitchName, int TraceOutputOptions) {
                TraceConfigurationSettingsRow rowTraceConfigurationSettingsRow = ((TraceConfigurationSettingsRow)(this.NewRow()));
                object[] columnValuesArray = new object[] {
                        SwitchValue,
                        UpdateInterval,
                        SwitchName,
                        TraceOutputOptions,
                        null};
                rowTraceConfigurationSettingsRow.ItemArray = columnValuesArray;
                this.Rows.Add(rowTraceConfigurationSettingsRow);
                return rowTraceConfigurationSettingsRow;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public TraceConfigurationSettingsRow FindByPK_TraceConfigSettings(int PK_TraceConfigSettings) {
                return ((TraceConfigurationSettingsRow)(this.Rows.Find(new object[] {
                            PK_TraceConfigSettings})));
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public override global::System.Data.DataTable Clone() {
                TraceConfigurationSettingsDataTable cln = ((TraceConfigurationSettingsDataTable)(base.Clone()));
                cln.InitVars();
                return cln;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override global::System.Data.DataTable CreateInstance() {
                return new TraceConfigurationSettingsDataTable();
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            internal void InitVars() {
                this.columnSwitchValue = base.Columns["SwitchValue"];
                this.columnUpdateInterval = base.Columns["UpdateInterval"];
                this.columnSwitchName = base.Columns["SwitchName"];
                this.columnTraceOutputOptions = base.Columns["TraceOutputOptions"];
                this.columnPK_TraceConfigSettings = base.Columns["PK_TraceConfigSettings"];
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            private void InitClass() {
                this.columnSwitchValue = new global::System.Data.DataColumn("SwitchValue", typeof(int), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnSwitchValue);
                this.columnUpdateInterval = new global::System.Data.DataColumn("UpdateInterval", typeof(int), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnUpdateInterval);
                this.columnSwitchName = new global::System.Data.DataColumn("SwitchName", typeof(string), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnSwitchName);
                this.columnTraceOutputOptions = new global::System.Data.DataColumn("TraceOutputOptions", typeof(int), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnTraceOutputOptions);
                this.columnPK_TraceConfigSettings = new global::System.Data.DataColumn("PK_TraceConfigSettings", typeof(int), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnPK_TraceConfigSettings);
                this.Constraints.Add(new global::System.Data.UniqueConstraint("Constraint1", new global::System.Data.DataColumn[] {
                                this.columnPK_TraceConfigSettings}, true));
                this.columnSwitchName.MaxLength = 2147483647;
                this.columnPK_TraceConfigSettings.AutoIncrement = true;
                this.columnPK_TraceConfigSettings.AutoIncrementSeed = -1;
                this.columnPK_TraceConfigSettings.AutoIncrementStep = -1;
                this.columnPK_TraceConfigSettings.AllowDBNull = false;
                this.columnPK_TraceConfigSettings.ReadOnly = true;
                this.columnPK_TraceConfigSettings.Unique = true;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public TraceConfigurationSettingsRow NewTraceConfigurationSettingsRow() {
                return ((TraceConfigurationSettingsRow)(this.NewRow()));
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override global::System.Data.DataRow NewRowFromBuilder(global::System.Data.DataRowBuilder builder) {
                return new TraceConfigurationSettingsRow(builder);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override global::System.Type GetRowType() {
                return typeof(TraceConfigurationSettingsRow);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override void OnRowChanged(global::System.Data.DataRowChangeEventArgs e) {
                base.OnRowChanged(e);
                if ((this.TraceConfigurationSettingsRowChanged != null)) {
                    this.TraceConfigurationSettingsRowChanged(this, new TraceConfigurationSettingsRowChangeEvent(((TraceConfigurationSettingsRow)(e.Row)), e.Action));
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override void OnRowChanging(global::System.Data.DataRowChangeEventArgs e) {
                base.OnRowChanging(e);
                if ((this.TraceConfigurationSettingsRowChanging != null)) {
                    this.TraceConfigurationSettingsRowChanging(this, new TraceConfigurationSettingsRowChangeEvent(((TraceConfigurationSettingsRow)(e.Row)), e.Action));
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override void OnRowDeleted(global::System.Data.DataRowChangeEventArgs e) {
                base.OnRowDeleted(e);
                if ((this.TraceConfigurationSettingsRowDeleted != null)) {
                    this.TraceConfigurationSettingsRowDeleted(this, new TraceConfigurationSettingsRowChangeEvent(((TraceConfigurationSettingsRow)(e.Row)), e.Action));
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override void OnRowDeleting(global::System.Data.DataRowChangeEventArgs e) {
                base.OnRowDeleting(e);
                if ((this.TraceConfigurationSettingsRowDeleting != null)) {
                    this.TraceConfigurationSettingsRowDeleting(this, new TraceConfigurationSettingsRowChangeEvent(((TraceConfigurationSettingsRow)(e.Row)), e.Action));
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void RemoveTraceConfigurationSettingsRow(TraceConfigurationSettingsRow row) {
                this.Rows.Remove(row);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public static global::System.Xml.Schema.XmlSchemaComplexType GetTypedTableSchema(global::System.Xml.Schema.XmlSchemaSet xs) {
                global::System.Xml.Schema.XmlSchemaComplexType type = new global::System.Xml.Schema.XmlSchemaComplexType();
                global::System.Xml.Schema.XmlSchemaSequence sequence = new global::System.Xml.Schema.XmlSchemaSequence();
                DiagnosticDBDataSet ds = new DiagnosticDBDataSet();
                global::System.Xml.Schema.XmlSchemaAny any1 = new global::System.Xml.Schema.XmlSchemaAny();
                any1.Namespace = "http://www.w3.org/2001/XMLSchema";
                any1.MinOccurs = new decimal(0);
                any1.MaxOccurs = decimal.MaxValue;
                any1.ProcessContents = global::System.Xml.Schema.XmlSchemaContentProcessing.Lax;
                sequence.Items.Add(any1);
                global::System.Xml.Schema.XmlSchemaAny any2 = new global::System.Xml.Schema.XmlSchemaAny();
                any2.Namespace = "urn:schemas-microsoft-com:xml-diffgram-v1";
                any2.MinOccurs = new decimal(1);
                any2.ProcessContents = global::System.Xml.Schema.XmlSchemaContentProcessing.Lax;
                sequence.Items.Add(any2);
                global::System.Xml.Schema.XmlSchemaAttribute attribute1 = new global::System.Xml.Schema.XmlSchemaAttribute();
                attribute1.Name = "namespace";
                attribute1.FixedValue = ds.Namespace;
                type.Attributes.Add(attribute1);
                global::System.Xml.Schema.XmlSchemaAttribute attribute2 = new global::System.Xml.Schema.XmlSchemaAttribute();
                attribute2.Name = "tableTypeName";
                attribute2.FixedValue = "TraceConfigurationSettingsDataTable";
                type.Attributes.Add(attribute2);
                type.Particle = sequence;
                global::System.Xml.Schema.XmlSchema dsSchema = ds.GetSchemaSerializable();
                if (xs.Contains(dsSchema.TargetNamespace)) {
                    global::System.IO.MemoryStream s1 = new global::System.IO.MemoryStream();
                    global::System.IO.MemoryStream s2 = new global::System.IO.MemoryStream();
                    try {
                        global::System.Xml.Schema.XmlSchema schema = null;
                        dsSchema.Write(s1);
                        for (global::System.Collections.IEnumerator schemas = xs.Schemas(dsSchema.TargetNamespace).GetEnumerator(); schemas.MoveNext(); ) {
                            schema = ((global::System.Xml.Schema.XmlSchema)(schemas.Current));
                            s2.SetLength(0);
                            schema.Write(s2);
                            if ((s1.Length == s2.Length)) {
                                s1.Position = 0;
                                s2.Position = 0;
                                for (; ((s1.Position != s1.Length) 
                                            && (s1.ReadByte() == s2.ReadByte())); ) {
                                    ;
                                }
                                if ((s1.Position == s1.Length)) {
                                    return type;
                                }
                            }
                        }
                    }
                    finally {
                        if ((s1 != null)) {
                            s1.Close();
                        }
                        if ((s2 != null)) {
                            s2.Close();
                        }
                    }
                }
                xs.Add(dsSchema);
                return type;
            }
        }
        
        /// <summary>
        ///Represents the strongly named DataTable class.
        ///</summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Data.Design.TypedDataSetGenerator", "2.0.0.0")]
        [global::System.Serializable()]
        [global::System.Xml.Serialization.XmlSchemaProviderAttribute("GetTypedTableSchema")]
        public partial class EventsXmlDataTable : global::System.Data.TypedTableBase<EventsXmlRow> {
            
            private global::System.Data.DataColumn columnPK_Events;
            
            private global::System.Data.DataColumn columnEventData;
            
            private global::System.Data.DataColumn columnRowNumber;
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public EventsXmlDataTable() {
                this.TableName = "EventsXml";
                this.BeginInit();
                this.InitClass();
                this.EndInit();
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            internal EventsXmlDataTable(global::System.Data.DataTable table) {
                this.TableName = table.TableName;
                if ((table.CaseSensitive != table.DataSet.CaseSensitive)) {
                    this.CaseSensitive = table.CaseSensitive;
                }
                if ((table.Locale.ToString() != table.DataSet.Locale.ToString())) {
                    this.Locale = table.Locale;
                }
                if ((table.Namespace != table.DataSet.Namespace)) {
                    this.Namespace = table.Namespace;
                }
                this.Prefix = table.Prefix;
                this.MinimumCapacity = table.MinimumCapacity;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected EventsXmlDataTable(global::System.Runtime.Serialization.SerializationInfo info, global::System.Runtime.Serialization.StreamingContext context) : 
                    base(info, context) {
                this.InitVars();
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn PK_EventsColumn {
                get {
                    return this.columnPK_Events;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn EventDataColumn {
                get {
                    return this.columnEventData;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn RowNumberColumn {
                get {
                    return this.columnRowNumber;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            [global::System.ComponentModel.Browsable(false)]
            public int Count {
                get {
                    return this.Rows.Count;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public EventsXmlRow this[int index] {
                get {
                    return ((EventsXmlRow)(this.Rows[index]));
                }
            }
            
            public event EventsXmlRowChangeEventHandler EventsXmlRowChanging;
            
            public event EventsXmlRowChangeEventHandler EventsXmlRowChanged;
            
            public event EventsXmlRowChangeEventHandler EventsXmlRowDeleting;
            
            public event EventsXmlRowChangeEventHandler EventsXmlRowDeleted;
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void AddEventsXmlRow(EventsXmlRow row) {
                this.Rows.Add(row);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public EventsXmlRow AddEventsXmlRow(string EventData, int RowNumber) {
                EventsXmlRow rowEventsXmlRow = ((EventsXmlRow)(this.NewRow()));
                object[] columnValuesArray = new object[] {
                        null,
                        EventData,
                        RowNumber};
                rowEventsXmlRow.ItemArray = columnValuesArray;
                this.Rows.Add(rowEventsXmlRow);
                return rowEventsXmlRow;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public EventsXmlRow FindByPK_Events(int PK_Events) {
                return ((EventsXmlRow)(this.Rows.Find(new object[] {
                            PK_Events})));
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public override global::System.Data.DataTable Clone() {
                EventsXmlDataTable cln = ((EventsXmlDataTable)(base.Clone()));
                cln.InitVars();
                return cln;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override global::System.Data.DataTable CreateInstance() {
                return new EventsXmlDataTable();
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            internal void InitVars() {
                this.columnPK_Events = base.Columns["PK_Events"];
                this.columnEventData = base.Columns["EventData"];
                this.columnRowNumber = base.Columns["RowNumber"];
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            private void InitClass() {
                this.columnPK_Events = new global::System.Data.DataColumn("PK_Events", typeof(int), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnPK_Events);
                this.columnEventData = new global::System.Data.DataColumn("EventData", typeof(string), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnEventData);
                this.columnRowNumber = new global::System.Data.DataColumn("RowNumber", typeof(int), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnRowNumber);
                this.Constraints.Add(new global::System.Data.UniqueConstraint("Constraint1", new global::System.Data.DataColumn[] {
                                this.columnPK_Events}, true));
                this.columnPK_Events.AutoIncrement = true;
                this.columnPK_Events.AutoIncrementSeed = -1;
                this.columnPK_Events.AutoIncrementStep = -1;
                this.columnPK_Events.AllowDBNull = false;
                this.columnPK_Events.ReadOnly = true;
                this.columnPK_Events.Unique = true;
                this.columnEventData.MaxLength = 2147483647;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public EventsXmlRow NewEventsXmlRow() {
                return ((EventsXmlRow)(this.NewRow()));
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override global::System.Data.DataRow NewRowFromBuilder(global::System.Data.DataRowBuilder builder) {
                return new EventsXmlRow(builder);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override global::System.Type GetRowType() {
                return typeof(EventsXmlRow);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override void OnRowChanged(global::System.Data.DataRowChangeEventArgs e) {
                base.OnRowChanged(e);
                if ((this.EventsXmlRowChanged != null)) {
                    this.EventsXmlRowChanged(this, new EventsXmlRowChangeEvent(((EventsXmlRow)(e.Row)), e.Action));
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override void OnRowChanging(global::System.Data.DataRowChangeEventArgs e) {
                base.OnRowChanging(e);
                if ((this.EventsXmlRowChanging != null)) {
                    this.EventsXmlRowChanging(this, new EventsXmlRowChangeEvent(((EventsXmlRow)(e.Row)), e.Action));
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override void OnRowDeleted(global::System.Data.DataRowChangeEventArgs e) {
                base.OnRowDeleted(e);
                if ((this.EventsXmlRowDeleted != null)) {
                    this.EventsXmlRowDeleted(this, new EventsXmlRowChangeEvent(((EventsXmlRow)(e.Row)), e.Action));
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override void OnRowDeleting(global::System.Data.DataRowChangeEventArgs e) {
                base.OnRowDeleting(e);
                if ((this.EventsXmlRowDeleting != null)) {
                    this.EventsXmlRowDeleting(this, new EventsXmlRowChangeEvent(((EventsXmlRow)(e.Row)), e.Action));
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void RemoveEventsXmlRow(EventsXmlRow row) {
                this.Rows.Remove(row);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public static global::System.Xml.Schema.XmlSchemaComplexType GetTypedTableSchema(global::System.Xml.Schema.XmlSchemaSet xs) {
                global::System.Xml.Schema.XmlSchemaComplexType type = new global::System.Xml.Schema.XmlSchemaComplexType();
                global::System.Xml.Schema.XmlSchemaSequence sequence = new global::System.Xml.Schema.XmlSchemaSequence();
                DiagnosticDBDataSet ds = new DiagnosticDBDataSet();
                global::System.Xml.Schema.XmlSchemaAny any1 = new global::System.Xml.Schema.XmlSchemaAny();
                any1.Namespace = "http://www.w3.org/2001/XMLSchema";
                any1.MinOccurs = new decimal(0);
                any1.MaxOccurs = decimal.MaxValue;
                any1.ProcessContents = global::System.Xml.Schema.XmlSchemaContentProcessing.Lax;
                sequence.Items.Add(any1);
                global::System.Xml.Schema.XmlSchemaAny any2 = new global::System.Xml.Schema.XmlSchemaAny();
                any2.Namespace = "urn:schemas-microsoft-com:xml-diffgram-v1";
                any2.MinOccurs = new decimal(1);
                any2.ProcessContents = global::System.Xml.Schema.XmlSchemaContentProcessing.Lax;
                sequence.Items.Add(any2);
                global::System.Xml.Schema.XmlSchemaAttribute attribute1 = new global::System.Xml.Schema.XmlSchemaAttribute();
                attribute1.Name = "namespace";
                attribute1.FixedValue = ds.Namespace;
                type.Attributes.Add(attribute1);
                global::System.Xml.Schema.XmlSchemaAttribute attribute2 = new global::System.Xml.Schema.XmlSchemaAttribute();
                attribute2.Name = "tableTypeName";
                attribute2.FixedValue = "EventsXmlDataTable";
                type.Attributes.Add(attribute2);
                type.Particle = sequence;
                global::System.Xml.Schema.XmlSchema dsSchema = ds.GetSchemaSerializable();
                if (xs.Contains(dsSchema.TargetNamespace)) {
                    global::System.IO.MemoryStream s1 = new global::System.IO.MemoryStream();
                    global::System.IO.MemoryStream s2 = new global::System.IO.MemoryStream();
                    try {
                        global::System.Xml.Schema.XmlSchema schema = null;
                        dsSchema.Write(s1);
                        for (global::System.Collections.IEnumerator schemas = xs.Schemas(dsSchema.TargetNamespace).GetEnumerator(); schemas.MoveNext(); ) {
                            schema = ((global::System.Xml.Schema.XmlSchema)(schemas.Current));
                            s2.SetLength(0);
                            schema.Write(s2);
                            if ((s1.Length == s2.Length)) {
                                s1.Position = 0;
                                s2.Position = 0;
                                for (; ((s1.Position != s1.Length) 
                                            && (s1.ReadByte() == s2.ReadByte())); ) {
                                    ;
                                }
                                if ((s1.Position == s1.Length)) {
                                    return type;
                                }
                            }
                        }
                    }
                    finally {
                        if ((s1 != null)) {
                            s1.Close();
                        }
                        if ((s2 != null)) {
                            s2.Close();
                        }
                    }
                }
                xs.Add(dsSchema);
                return type;
            }
        }
        
        /// <summary>
        ///Represents the strongly named DataTable class.
        ///</summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Data.Design.TypedDataSetGenerator", "2.0.0.0")]
        [global::System.Serializable()]
        [global::System.Xml.Serialization.XmlSchemaProviderAttribute("GetTypedTableSchema")]
        public partial class EventsDataTable : global::System.Data.TypedTableBase<EventsRow> {
            
            private global::System.Data.DataColumn columnEventID;
            
            private global::System.Data.DataColumn columnMachineName;
            
            private global::System.Data.DataColumn columnSource;
            
            private global::System.Data.DataColumn columnMessageID;
            
            private global::System.Data.DataColumn columnMessage;
            
            private global::System.Data.DataColumn columnFileName;
            
            private global::System.Data.DataColumn columnLineNumber;
            
            private global::System.Data.DataColumn columnMethodName;
            
            private global::System.Data.DataColumn columnDateTime;
            
            private global::System.Data.DataColumn columnTimeStamp;
            
            private global::System.Data.DataColumn columnProcessID;
            
            private global::System.Data.DataColumn columnThreadID;
            
            private global::System.Data.DataColumn columnCallStack;
            
            private global::System.Data.DataColumn columnLogicalStack;
            
            private global::System.Data.DataColumn columnEventType;
            
            private global::System.Data.DataColumn columnAssemblyName;
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public EventsDataTable() {
                this.TableName = "Events";
                this.BeginInit();
                this.InitClass();
                this.EndInit();
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            internal EventsDataTable(global::System.Data.DataTable table) {
                this.TableName = table.TableName;
                if ((table.CaseSensitive != table.DataSet.CaseSensitive)) {
                    this.CaseSensitive = table.CaseSensitive;
                }
                if ((table.Locale.ToString() != table.DataSet.Locale.ToString())) {
                    this.Locale = table.Locale;
                }
                if ((table.Namespace != table.DataSet.Namespace)) {
                    this.Namespace = table.Namespace;
                }
                this.Prefix = table.Prefix;
                this.MinimumCapacity = table.MinimumCapacity;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected EventsDataTable(global::System.Runtime.Serialization.SerializationInfo info, global::System.Runtime.Serialization.StreamingContext context) : 
                    base(info, context) {
                this.InitVars();
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn EventIDColumn {
                get {
                    return this.columnEventID;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn MachineNameColumn {
                get {
                    return this.columnMachineName;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn SourceColumn {
                get {
                    return this.columnSource;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn MessageIDColumn {
                get {
                    return this.columnMessageID;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn MessageColumn {
                get {
                    return this.columnMessage;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn FileNameColumn {
                get {
                    return this.columnFileName;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn LineNumberColumn {
                get {
                    return this.columnLineNumber;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn MethodNameColumn {
                get {
                    return this.columnMethodName;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn DateTimeColumn {
                get {
                    return this.columnDateTime;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn TimeStampColumn {
                get {
                    return this.columnTimeStamp;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn ProcessIDColumn {
                get {
                    return this.columnProcessID;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn ThreadIDColumn {
                get {
                    return this.columnThreadID;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn CallStackColumn {
                get {
                    return this.columnCallStack;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn LogicalStackColumn {
                get {
                    return this.columnLogicalStack;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn EventTypeColumn {
                get {
                    return this.columnEventType;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn AssemblyNameColumn {
                get {
                    return this.columnAssemblyName;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            [global::System.ComponentModel.Browsable(false)]
            public int Count {
                get {
                    return this.Rows.Count;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public EventsRow this[int index] {
                get {
                    return ((EventsRow)(this.Rows[index]));
                }
            }
            
            public event EventsRowChangeEventHandler EventsRowChanging;
            
            public event EventsRowChangeEventHandler EventsRowChanged;
            
            public event EventsRowChangeEventHandler EventsRowDeleting;
            
            public event EventsRowChangeEventHandler EventsRowDeleted;
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void AddEventsRow(EventsRow row) {
                this.Rows.Add(row);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public EventsRow AddEventsRow(string MachineName, string Source, int MessageID, string Message, string FileName, int LineNumber, string MethodName, System.DateTime DateTime, long TimeStamp, int ProcessID, string ThreadID, string CallStack, string LogicalStack, string EventType, string AssemblyName) {
                EventsRow rowEventsRow = ((EventsRow)(this.NewRow()));
                object[] columnValuesArray = new object[] {
                        null,
                        MachineName,
                        Source,
                        MessageID,
                        Message,
                        FileName,
                        LineNumber,
                        MethodName,
                        DateTime,
                        TimeStamp,
                        ProcessID,
                        ThreadID,
                        CallStack,
                        LogicalStack,
                        EventType,
                        AssemblyName};
                rowEventsRow.ItemArray = columnValuesArray;
                this.Rows.Add(rowEventsRow);
                return rowEventsRow;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public EventsRow FindByEventID(int EventID) {
                return ((EventsRow)(this.Rows.Find(new object[] {
                            EventID})));
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public override global::System.Data.DataTable Clone() {
                EventsDataTable cln = ((EventsDataTable)(base.Clone()));
                cln.InitVars();
                return cln;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override global::System.Data.DataTable CreateInstance() {
                return new EventsDataTable();
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            internal void InitVars() {
                this.columnEventID = base.Columns["EventID"];
                this.columnMachineName = base.Columns["MachineName"];
                this.columnSource = base.Columns["Source"];
                this.columnMessageID = base.Columns["MessageID"];
                this.columnMessage = base.Columns["Message"];
                this.columnFileName = base.Columns["FileName"];
                this.columnLineNumber = base.Columns["LineNumber"];
                this.columnMethodName = base.Columns["MethodName"];
                this.columnDateTime = base.Columns["DateTime"];
                this.columnTimeStamp = base.Columns["TimeStamp"];
                this.columnProcessID = base.Columns["ProcessID"];
                this.columnThreadID = base.Columns["ThreadID"];
                this.columnCallStack = base.Columns["CallStack"];
                this.columnLogicalStack = base.Columns["LogicalStack"];
                this.columnEventType = base.Columns["EventType"];
                this.columnAssemblyName = base.Columns["AssemblyName"];
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            private void InitClass() {
                this.columnEventID = new global::System.Data.DataColumn("EventID", typeof(int), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnEventID);
                this.columnMachineName = new global::System.Data.DataColumn("MachineName", typeof(string), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnMachineName);
                this.columnSource = new global::System.Data.DataColumn("Source", typeof(string), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnSource);
                this.columnMessageID = new global::System.Data.DataColumn("MessageID", typeof(int), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnMessageID);
                this.columnMessage = new global::System.Data.DataColumn("Message", typeof(string), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnMessage);
                this.columnFileName = new global::System.Data.DataColumn("FileName", typeof(string), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnFileName);
                this.columnLineNumber = new global::System.Data.DataColumn("LineNumber", typeof(int), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnLineNumber);
                this.columnMethodName = new global::System.Data.DataColumn("MethodName", typeof(string), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnMethodName);
                this.columnDateTime = new global::System.Data.DataColumn("DateTime", typeof(global::System.DateTime), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnDateTime);
                this.columnTimeStamp = new global::System.Data.DataColumn("TimeStamp", typeof(long), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnTimeStamp);
                this.columnProcessID = new global::System.Data.DataColumn("ProcessID", typeof(int), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnProcessID);
                this.columnThreadID = new global::System.Data.DataColumn("ThreadID", typeof(string), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnThreadID);
                this.columnCallStack = new global::System.Data.DataColumn("CallStack", typeof(string), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnCallStack);
                this.columnLogicalStack = new global::System.Data.DataColumn("LogicalStack", typeof(string), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnLogicalStack);
                this.columnEventType = new global::System.Data.DataColumn("EventType", typeof(string), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnEventType);
                this.columnAssemblyName = new global::System.Data.DataColumn("AssemblyName", typeof(string), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnAssemblyName);
                this.Constraints.Add(new global::System.Data.UniqueConstraint("Constraint1", new global::System.Data.DataColumn[] {
                                this.columnEventID}, true));
                this.columnEventID.AutoIncrement = true;
                this.columnEventID.AutoIncrementSeed = -1;
                this.columnEventID.AutoIncrementStep = -1;
                this.columnEventID.AllowDBNull = false;
                this.columnEventID.ReadOnly = true;
                this.columnEventID.Unique = true;
                this.columnMachineName.MaxLength = 2147483647;
                this.columnSource.MaxLength = 2147483647;
                this.columnMessage.MaxLength = 2147483647;
                this.columnFileName.MaxLength = 2147483647;
                this.columnMethodName.MaxLength = 2147483647;
                this.columnThreadID.MaxLength = 2147483647;
                this.columnCallStack.MaxLength = 2147483647;
                this.columnLogicalStack.MaxLength = 2147483647;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public EventsRow NewEventsRow() {
                return ((EventsRow)(this.NewRow()));
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override global::System.Data.DataRow NewRowFromBuilder(global::System.Data.DataRowBuilder builder) {
                return new EventsRow(builder);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override global::System.Type GetRowType() {
                return typeof(EventsRow);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override void OnRowChanged(global::System.Data.DataRowChangeEventArgs e) {
                base.OnRowChanged(e);
                if ((this.EventsRowChanged != null)) {
                    this.EventsRowChanged(this, new EventsRowChangeEvent(((EventsRow)(e.Row)), e.Action));
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override void OnRowChanging(global::System.Data.DataRowChangeEventArgs e) {
                base.OnRowChanging(e);
                if ((this.EventsRowChanging != null)) {
                    this.EventsRowChanging(this, new EventsRowChangeEvent(((EventsRow)(e.Row)), e.Action));
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override void OnRowDeleted(global::System.Data.DataRowChangeEventArgs e) {
                base.OnRowDeleted(e);
                if ((this.EventsRowDeleted != null)) {
                    this.EventsRowDeleted(this, new EventsRowChangeEvent(((EventsRow)(e.Row)), e.Action));
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override void OnRowDeleting(global::System.Data.DataRowChangeEventArgs e) {
                base.OnRowDeleting(e);
                if ((this.EventsRowDeleting != null)) {
                    this.EventsRowDeleting(this, new EventsRowChangeEvent(((EventsRow)(e.Row)), e.Action));
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void RemoveEventsRow(EventsRow row) {
                this.Rows.Remove(row);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public static global::System.Xml.Schema.XmlSchemaComplexType GetTypedTableSchema(global::System.Xml.Schema.XmlSchemaSet xs) {
                global::System.Xml.Schema.XmlSchemaComplexType type = new global::System.Xml.Schema.XmlSchemaComplexType();
                global::System.Xml.Schema.XmlSchemaSequence sequence = new global::System.Xml.Schema.XmlSchemaSequence();
                DiagnosticDBDataSet ds = new DiagnosticDBDataSet();
                global::System.Xml.Schema.XmlSchemaAny any1 = new global::System.Xml.Schema.XmlSchemaAny();
                any1.Namespace = "http://www.w3.org/2001/XMLSchema";
                any1.MinOccurs = new decimal(0);
                any1.MaxOccurs = decimal.MaxValue;
                any1.ProcessContents = global::System.Xml.Schema.XmlSchemaContentProcessing.Lax;
                sequence.Items.Add(any1);
                global::System.Xml.Schema.XmlSchemaAny any2 = new global::System.Xml.Schema.XmlSchemaAny();
                any2.Namespace = "urn:schemas-microsoft-com:xml-diffgram-v1";
                any2.MinOccurs = new decimal(1);
                any2.ProcessContents = global::System.Xml.Schema.XmlSchemaContentProcessing.Lax;
                sequence.Items.Add(any2);
                global::System.Xml.Schema.XmlSchemaAttribute attribute1 = new global::System.Xml.Schema.XmlSchemaAttribute();
                attribute1.Name = "namespace";
                attribute1.FixedValue = ds.Namespace;
                type.Attributes.Add(attribute1);
                global::System.Xml.Schema.XmlSchemaAttribute attribute2 = new global::System.Xml.Schema.XmlSchemaAttribute();
                attribute2.Name = "tableTypeName";
                attribute2.FixedValue = "EventsDataTable";
                type.Attributes.Add(attribute2);
                type.Particle = sequence;
                global::System.Xml.Schema.XmlSchema dsSchema = ds.GetSchemaSerializable();
                if (xs.Contains(dsSchema.TargetNamespace)) {
                    global::System.IO.MemoryStream s1 = new global::System.IO.MemoryStream();
                    global::System.IO.MemoryStream s2 = new global::System.IO.MemoryStream();
                    try {
                        global::System.Xml.Schema.XmlSchema schema = null;
                        dsSchema.Write(s1);
                        for (global::System.Collections.IEnumerator schemas = xs.Schemas(dsSchema.TargetNamespace).GetEnumerator(); schemas.MoveNext(); ) {
                            schema = ((global::System.Xml.Schema.XmlSchema)(schemas.Current));
                            s2.SetLength(0);
                            schema.Write(s2);
                            if ((s1.Length == s2.Length)) {
                                s1.Position = 0;
                                s2.Position = 0;
                                for (; ((s1.Position != s1.Length) 
                                            && (s1.ReadByte() == s2.ReadByte())); ) {
                                    ;
                                }
                                if ((s1.Position == s1.Length)) {
                                    return type;
                                }
                            }
                        }
                    }
                    finally {
                        if ((s1 != null)) {
                            s1.Close();
                        }
                        if ((s2 != null)) {
                            s2.Close();
                        }
                    }
                }
                xs.Add(dsSchema);
                return type;
            }
        }
        
        /// <summary>
        ///Represents the strongly named DataTable class.
        ///</summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Data.Design.TypedDataSetGenerator", "2.0.0.0")]
        [global::System.Serializable()]
        [global::System.Xml.Serialization.XmlSchemaProviderAttribute("GetTypedTableSchema")]
        public partial class GetSummaryEventsDataTable : global::System.Data.TypedTableBase<GetSummaryEventsRow> {
            
            private global::System.Data.DataColumn columnMachineName;
            
            private global::System.Data.DataColumn columnTotalErrors;
            
            private global::System.Data.DataColumn columnTotalWarnings;
            
            private global::System.Data.DataColumn columnTotalCriticals;
            
            private global::System.Data.DataColumn columnTotalInformational;
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public GetSummaryEventsDataTable() {
                this.TableName = "GetSummaryEvents";
                this.BeginInit();
                this.InitClass();
                this.EndInit();
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            internal GetSummaryEventsDataTable(global::System.Data.DataTable table) {
                this.TableName = table.TableName;
                if ((table.CaseSensitive != table.DataSet.CaseSensitive)) {
                    this.CaseSensitive = table.CaseSensitive;
                }
                if ((table.Locale.ToString() != table.DataSet.Locale.ToString())) {
                    this.Locale = table.Locale;
                }
                if ((table.Namespace != table.DataSet.Namespace)) {
                    this.Namespace = table.Namespace;
                }
                this.Prefix = table.Prefix;
                this.MinimumCapacity = table.MinimumCapacity;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected GetSummaryEventsDataTable(global::System.Runtime.Serialization.SerializationInfo info, global::System.Runtime.Serialization.StreamingContext context) : 
                    base(info, context) {
                this.InitVars();
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn MachineNameColumn {
                get {
                    return this.columnMachineName;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn TotalErrorsColumn {
                get {
                    return this.columnTotalErrors;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn TotalWarningsColumn {
                get {
                    return this.columnTotalWarnings;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn TotalCriticalsColumn {
                get {
                    return this.columnTotalCriticals;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn TotalInformationalColumn {
                get {
                    return this.columnTotalInformational;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            [global::System.ComponentModel.Browsable(false)]
            public int Count {
                get {
                    return this.Rows.Count;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public GetSummaryEventsRow this[int index] {
                get {
                    return ((GetSummaryEventsRow)(this.Rows[index]));
                }
            }
            
            public event GetSummaryEventsRowChangeEventHandler GetSummaryEventsRowChanging;
            
            public event GetSummaryEventsRowChangeEventHandler GetSummaryEventsRowChanged;
            
            public event GetSummaryEventsRowChangeEventHandler GetSummaryEventsRowDeleting;
            
            public event GetSummaryEventsRowChangeEventHandler GetSummaryEventsRowDeleted;
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void AddGetSummaryEventsRow(GetSummaryEventsRow row) {
                this.Rows.Add(row);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public GetSummaryEventsRow AddGetSummaryEventsRow(string MachineName, int TotalErrors, int TotalWarnings, int TotalCriticals, int TotalInformational) {
                GetSummaryEventsRow rowGetSummaryEventsRow = ((GetSummaryEventsRow)(this.NewRow()));
                object[] columnValuesArray = new object[] {
                        MachineName,
                        TotalErrors,
                        TotalWarnings,
                        TotalCriticals,
                        TotalInformational};
                rowGetSummaryEventsRow.ItemArray = columnValuesArray;
                this.Rows.Add(rowGetSummaryEventsRow);
                return rowGetSummaryEventsRow;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public override global::System.Data.DataTable Clone() {
                GetSummaryEventsDataTable cln = ((GetSummaryEventsDataTable)(base.Clone()));
                cln.InitVars();
                return cln;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override global::System.Data.DataTable CreateInstance() {
                return new GetSummaryEventsDataTable();
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            internal void InitVars() {
                this.columnMachineName = base.Columns["MachineName"];
                this.columnTotalErrors = base.Columns["TotalErrors"];
                this.columnTotalWarnings = base.Columns["TotalWarnings"];
                this.columnTotalCriticals = base.Columns["TotalCriticals"];
                this.columnTotalInformational = base.Columns["TotalInformational"];
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            private void InitClass() {
                this.columnMachineName = new global::System.Data.DataColumn("MachineName", typeof(string), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnMachineName);
                this.columnTotalErrors = new global::System.Data.DataColumn("TotalErrors", typeof(int), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnTotalErrors);
                this.columnTotalWarnings = new global::System.Data.DataColumn("TotalWarnings", typeof(int), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnTotalWarnings);
                this.columnTotalCriticals = new global::System.Data.DataColumn("TotalCriticals", typeof(int), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnTotalCriticals);
                this.columnTotalInformational = new global::System.Data.DataColumn("TotalInformational", typeof(int), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnTotalInformational);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public GetSummaryEventsRow NewGetSummaryEventsRow() {
                return ((GetSummaryEventsRow)(this.NewRow()));
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override global::System.Data.DataRow NewRowFromBuilder(global::System.Data.DataRowBuilder builder) {
                return new GetSummaryEventsRow(builder);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override global::System.Type GetRowType() {
                return typeof(GetSummaryEventsRow);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override void OnRowChanged(global::System.Data.DataRowChangeEventArgs e) {
                base.OnRowChanged(e);
                if ((this.GetSummaryEventsRowChanged != null)) {
                    this.GetSummaryEventsRowChanged(this, new GetSummaryEventsRowChangeEvent(((GetSummaryEventsRow)(e.Row)), e.Action));
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override void OnRowChanging(global::System.Data.DataRowChangeEventArgs e) {
                base.OnRowChanging(e);
                if ((this.GetSummaryEventsRowChanging != null)) {
                    this.GetSummaryEventsRowChanging(this, new GetSummaryEventsRowChangeEvent(((GetSummaryEventsRow)(e.Row)), e.Action));
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override void OnRowDeleted(global::System.Data.DataRowChangeEventArgs e) {
                base.OnRowDeleted(e);
                if ((this.GetSummaryEventsRowDeleted != null)) {
                    this.GetSummaryEventsRowDeleted(this, new GetSummaryEventsRowChangeEvent(((GetSummaryEventsRow)(e.Row)), e.Action));
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override void OnRowDeleting(global::System.Data.DataRowChangeEventArgs e) {
                base.OnRowDeleting(e);
                if ((this.GetSummaryEventsRowDeleting != null)) {
                    this.GetSummaryEventsRowDeleting(this, new GetSummaryEventsRowChangeEvent(((GetSummaryEventsRow)(e.Row)), e.Action));
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void RemoveGetSummaryEventsRow(GetSummaryEventsRow row) {
                this.Rows.Remove(row);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public static global::System.Xml.Schema.XmlSchemaComplexType GetTypedTableSchema(global::System.Xml.Schema.XmlSchemaSet xs) {
                global::System.Xml.Schema.XmlSchemaComplexType type = new global::System.Xml.Schema.XmlSchemaComplexType();
                global::System.Xml.Schema.XmlSchemaSequence sequence = new global::System.Xml.Schema.XmlSchemaSequence();
                DiagnosticDBDataSet ds = new DiagnosticDBDataSet();
                global::System.Xml.Schema.XmlSchemaAny any1 = new global::System.Xml.Schema.XmlSchemaAny();
                any1.Namespace = "http://www.w3.org/2001/XMLSchema";
                any1.MinOccurs = new decimal(0);
                any1.MaxOccurs = decimal.MaxValue;
                any1.ProcessContents = global::System.Xml.Schema.XmlSchemaContentProcessing.Lax;
                sequence.Items.Add(any1);
                global::System.Xml.Schema.XmlSchemaAny any2 = new global::System.Xml.Schema.XmlSchemaAny();
                any2.Namespace = "urn:schemas-microsoft-com:xml-diffgram-v1";
                any2.MinOccurs = new decimal(1);
                any2.ProcessContents = global::System.Xml.Schema.XmlSchemaContentProcessing.Lax;
                sequence.Items.Add(any2);
                global::System.Xml.Schema.XmlSchemaAttribute attribute1 = new global::System.Xml.Schema.XmlSchemaAttribute();
                attribute1.Name = "namespace";
                attribute1.FixedValue = ds.Namespace;
                type.Attributes.Add(attribute1);
                global::System.Xml.Schema.XmlSchemaAttribute attribute2 = new global::System.Xml.Schema.XmlSchemaAttribute();
                attribute2.Name = "tableTypeName";
                attribute2.FixedValue = "GetSummaryEventsDataTable";
                type.Attributes.Add(attribute2);
                type.Particle = sequence;
                global::System.Xml.Schema.XmlSchema dsSchema = ds.GetSchemaSerializable();
                if (xs.Contains(dsSchema.TargetNamespace)) {
                    global::System.IO.MemoryStream s1 = new global::System.IO.MemoryStream();
                    global::System.IO.MemoryStream s2 = new global::System.IO.MemoryStream();
                    try {
                        global::System.Xml.Schema.XmlSchema schema = null;
                        dsSchema.Write(s1);
                        for (global::System.Collections.IEnumerator schemas = xs.Schemas(dsSchema.TargetNamespace).GetEnumerator(); schemas.MoveNext(); ) {
                            schema = ((global::System.Xml.Schema.XmlSchema)(schemas.Current));
                            s2.SetLength(0);
                            schema.Write(s2);
                            if ((s1.Length == s2.Length)) {
                                s1.Position = 0;
                                s2.Position = 0;
                                for (; ((s1.Position != s1.Length) 
                                            && (s1.ReadByte() == s2.ReadByte())); ) {
                                    ;
                                }
                                if ((s1.Position == s1.Length)) {
                                    return type;
                                }
                            }
                        }
                    }
                    finally {
                        if ((s1 != null)) {
                            s1.Close();
                        }
                        if ((s2 != null)) {
                            s2.Close();
                        }
                    }
                }
                xs.Add(dsSchema);
                return type;
            }
        }
        
        /// <summary>
        ///Represents the strongly named DataTable class.
        ///</summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Data.Design.TypedDataSetGenerator", "2.0.0.0")]
        [global::System.Serializable()]
        [global::System.Xml.Serialization.XmlSchemaProviderAttribute("GetTypedTableSchema")]
        public partial class EventsReportingDataTable : global::System.Data.TypedTableBase<EventsReportingRow> {
            
            private global::System.Data.DataColumn columnEventType;
            
            private global::System.Data.DataColumn columnMachineName;
            
            private global::System.Data.DataColumn columnAssemblyName;
            
            private global::System.Data.DataColumn columnSourceName;
            
            private global::System.Data.DataColumn columnDateTime;
            
            private global::System.Data.DataColumn columnMethodName;
            
            private global::System.Data.DataColumn columnProcessID;
            
            private global::System.Data.DataColumn columnThreadID;
            
            private global::System.Data.DataColumn columnMessage;
            
            private global::System.Data.DataColumn columnCallStack;
            
            private global::System.Data.DataColumn columnMessageID;
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public EventsReportingDataTable() {
                this.TableName = "EventsReporting";
                this.BeginInit();
                this.InitClass();
                this.EndInit();
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            internal EventsReportingDataTable(global::System.Data.DataTable table) {
                this.TableName = table.TableName;
                if ((table.CaseSensitive != table.DataSet.CaseSensitive)) {
                    this.CaseSensitive = table.CaseSensitive;
                }
                if ((table.Locale.ToString() != table.DataSet.Locale.ToString())) {
                    this.Locale = table.Locale;
                }
                if ((table.Namespace != table.DataSet.Namespace)) {
                    this.Namespace = table.Namespace;
                }
                this.Prefix = table.Prefix;
                this.MinimumCapacity = table.MinimumCapacity;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected EventsReportingDataTable(global::System.Runtime.Serialization.SerializationInfo info, global::System.Runtime.Serialization.StreamingContext context) : 
                    base(info, context) {
                this.InitVars();
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn EventTypeColumn {
                get {
                    return this.columnEventType;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn MachineNameColumn {
                get {
                    return this.columnMachineName;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn AssemblyNameColumn {
                get {
                    return this.columnAssemblyName;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn SourceNameColumn {
                get {
                    return this.columnSourceName;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn DateTimeColumn {
                get {
                    return this.columnDateTime;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn MethodNameColumn {
                get {
                    return this.columnMethodName;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn ProcessIDColumn {
                get {
                    return this.columnProcessID;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn ThreadIDColumn {
                get {
                    return this.columnThreadID;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn MessageColumn {
                get {
                    return this.columnMessage;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn CallStackColumn {
                get {
                    return this.columnCallStack;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn MessageIDColumn {
                get {
                    return this.columnMessageID;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            [global::System.ComponentModel.Browsable(false)]
            public int Count {
                get {
                    return this.Rows.Count;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public EventsReportingRow this[int index] {
                get {
                    return ((EventsReportingRow)(this.Rows[index]));
                }
            }
            
            public event EventsReportingRowChangeEventHandler EventsReportingRowChanging;
            
            public event EventsReportingRowChangeEventHandler EventsReportingRowChanged;
            
            public event EventsReportingRowChangeEventHandler EventsReportingRowDeleting;
            
            public event EventsReportingRowChangeEventHandler EventsReportingRowDeleted;
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void AddEventsReportingRow(EventsReportingRow row) {
                this.Rows.Add(row);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public EventsReportingRow AddEventsReportingRow(string EventType, string MachineName, string AssemblyName, string SourceName, System.DateTime DateTime, string MethodName, string ProcessID, string ThreadID, string Message, string CallStack, int MessageID) {
                EventsReportingRow rowEventsReportingRow = ((EventsReportingRow)(this.NewRow()));
                object[] columnValuesArray = new object[] {
                        EventType,
                        MachineName,
                        AssemblyName,
                        SourceName,
                        DateTime,
                        MethodName,
                        ProcessID,
                        ThreadID,
                        Message,
                        CallStack,
                        MessageID};
                rowEventsReportingRow.ItemArray = columnValuesArray;
                this.Rows.Add(rowEventsReportingRow);
                return rowEventsReportingRow;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public override global::System.Data.DataTable Clone() {
                EventsReportingDataTable cln = ((EventsReportingDataTable)(base.Clone()));
                cln.InitVars();
                return cln;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override global::System.Data.DataTable CreateInstance() {
                return new EventsReportingDataTable();
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            internal void InitVars() {
                this.columnEventType = base.Columns["EventType"];
                this.columnMachineName = base.Columns["MachineName"];
                this.columnAssemblyName = base.Columns["AssemblyName"];
                this.columnSourceName = base.Columns["SourceName"];
                this.columnDateTime = base.Columns["DateTime"];
                this.columnMethodName = base.Columns["MethodName"];
                this.columnProcessID = base.Columns["ProcessID"];
                this.columnThreadID = base.Columns["ThreadID"];
                this.columnMessage = base.Columns["Message"];
                this.columnCallStack = base.Columns["CallStack"];
                this.columnMessageID = base.Columns["MessageID"];
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            private void InitClass() {
                this.columnEventType = new global::System.Data.DataColumn("EventType", typeof(string), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnEventType);
                this.columnMachineName = new global::System.Data.DataColumn("MachineName", typeof(string), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnMachineName);
                this.columnAssemblyName = new global::System.Data.DataColumn("AssemblyName", typeof(string), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnAssemblyName);
                this.columnSourceName = new global::System.Data.DataColumn("SourceName", typeof(string), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnSourceName);
                this.columnDateTime = new global::System.Data.DataColumn("DateTime", typeof(global::System.DateTime), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnDateTime);
                this.columnMethodName = new global::System.Data.DataColumn("MethodName", typeof(string), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnMethodName);
                this.columnProcessID = new global::System.Data.DataColumn("ProcessID", typeof(string), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnProcessID);
                this.columnThreadID = new global::System.Data.DataColumn("ThreadID", typeof(string), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnThreadID);
                this.columnMessage = new global::System.Data.DataColumn("Message", typeof(string), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnMessage);
                this.columnCallStack = new global::System.Data.DataColumn("CallStack", typeof(string), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnCallStack);
                this.columnMessageID = new global::System.Data.DataColumn("MessageID", typeof(int), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnMessageID);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public EventsReportingRow NewEventsReportingRow() {
                return ((EventsReportingRow)(this.NewRow()));
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override global::System.Data.DataRow NewRowFromBuilder(global::System.Data.DataRowBuilder builder) {
                return new EventsReportingRow(builder);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override global::System.Type GetRowType() {
                return typeof(EventsReportingRow);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override void OnRowChanged(global::System.Data.DataRowChangeEventArgs e) {
                base.OnRowChanged(e);
                if ((this.EventsReportingRowChanged != null)) {
                    this.EventsReportingRowChanged(this, new EventsReportingRowChangeEvent(((EventsReportingRow)(e.Row)), e.Action));
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override void OnRowChanging(global::System.Data.DataRowChangeEventArgs e) {
                base.OnRowChanging(e);
                if ((this.EventsReportingRowChanging != null)) {
                    this.EventsReportingRowChanging(this, new EventsReportingRowChangeEvent(((EventsReportingRow)(e.Row)), e.Action));
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override void OnRowDeleted(global::System.Data.DataRowChangeEventArgs e) {
                base.OnRowDeleted(e);
                if ((this.EventsReportingRowDeleted != null)) {
                    this.EventsReportingRowDeleted(this, new EventsReportingRowChangeEvent(((EventsReportingRow)(e.Row)), e.Action));
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override void OnRowDeleting(global::System.Data.DataRowChangeEventArgs e) {
                base.OnRowDeleting(e);
                if ((this.EventsReportingRowDeleting != null)) {
                    this.EventsReportingRowDeleting(this, new EventsReportingRowChangeEvent(((EventsReportingRow)(e.Row)), e.Action));
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void RemoveEventsReportingRow(EventsReportingRow row) {
                this.Rows.Remove(row);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public static global::System.Xml.Schema.XmlSchemaComplexType GetTypedTableSchema(global::System.Xml.Schema.XmlSchemaSet xs) {
                global::System.Xml.Schema.XmlSchemaComplexType type = new global::System.Xml.Schema.XmlSchemaComplexType();
                global::System.Xml.Schema.XmlSchemaSequence sequence = new global::System.Xml.Schema.XmlSchemaSequence();
                DiagnosticDBDataSet ds = new DiagnosticDBDataSet();
                global::System.Xml.Schema.XmlSchemaAny any1 = new global::System.Xml.Schema.XmlSchemaAny();
                any1.Namespace = "http://www.w3.org/2001/XMLSchema";
                any1.MinOccurs = new decimal(0);
                any1.MaxOccurs = decimal.MaxValue;
                any1.ProcessContents = global::System.Xml.Schema.XmlSchemaContentProcessing.Lax;
                sequence.Items.Add(any1);
                global::System.Xml.Schema.XmlSchemaAny any2 = new global::System.Xml.Schema.XmlSchemaAny();
                any2.Namespace = "urn:schemas-microsoft-com:xml-diffgram-v1";
                any2.MinOccurs = new decimal(1);
                any2.ProcessContents = global::System.Xml.Schema.XmlSchemaContentProcessing.Lax;
                sequence.Items.Add(any2);
                global::System.Xml.Schema.XmlSchemaAttribute attribute1 = new global::System.Xml.Schema.XmlSchemaAttribute();
                attribute1.Name = "namespace";
                attribute1.FixedValue = ds.Namespace;
                type.Attributes.Add(attribute1);
                global::System.Xml.Schema.XmlSchemaAttribute attribute2 = new global::System.Xml.Schema.XmlSchemaAttribute();
                attribute2.Name = "tableTypeName";
                attribute2.FixedValue = "EventsReportingDataTable";
                type.Attributes.Add(attribute2);
                type.Particle = sequence;
                global::System.Xml.Schema.XmlSchema dsSchema = ds.GetSchemaSerializable();
                if (xs.Contains(dsSchema.TargetNamespace)) {
                    global::System.IO.MemoryStream s1 = new global::System.IO.MemoryStream();
                    global::System.IO.MemoryStream s2 = new global::System.IO.MemoryStream();
                    try {
                        global::System.Xml.Schema.XmlSchema schema = null;
                        dsSchema.Write(s1);
                        for (global::System.Collections.IEnumerator schemas = xs.Schemas(dsSchema.TargetNamespace).GetEnumerator(); schemas.MoveNext(); ) {
                            schema = ((global::System.Xml.Schema.XmlSchema)(schemas.Current));
                            s2.SetLength(0);
                            schema.Write(s2);
                            if ((s1.Length == s2.Length)) {
                                s1.Position = 0;
                                s2.Position = 0;
                                for (; ((s1.Position != s1.Length) 
                                            && (s1.ReadByte() == s2.ReadByte())); ) {
                                    ;
                                }
                                if ((s1.Position == s1.Length)) {
                                    return type;
                                }
                            }
                        }
                    }
                    finally {
                        if ((s1 != null)) {
                            s1.Close();
                        }
                        if ((s2 != null)) {
                            s2.Close();
                        }
                    }
                }
                xs.Add(dsSchema);
                return type;
            }
        }
        
        /// <summary>
        ///Represents the strongly named DataTable class.
        ///</summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Data.Design.TypedDataSetGenerator", "2.0.0.0")]
        [global::System.Serializable()]
        [global::System.Xml.Serialization.XmlSchemaProviderAttribute("GetTypedTableSchema")]
        public partial class EventsSummaryDataTable : global::System.Data.TypedTableBase<EventsSummaryRow> {
            
            private global::System.Data.DataColumn columnMachineName;
            
            private global::System.Data.DataColumn columnTotalErrors;
            
            private global::System.Data.DataColumn columnTotalWarnings;
            
            private global::System.Data.DataColumn columnTotalCriticals;
            
            private global::System.Data.DataColumn columnTotalInformational;
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public EventsSummaryDataTable() {
                this.TableName = "EventsSummary";
                this.BeginInit();
                this.InitClass();
                this.EndInit();
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            internal EventsSummaryDataTable(global::System.Data.DataTable table) {
                this.TableName = table.TableName;
                if ((table.CaseSensitive != table.DataSet.CaseSensitive)) {
                    this.CaseSensitive = table.CaseSensitive;
                }
                if ((table.Locale.ToString() != table.DataSet.Locale.ToString())) {
                    this.Locale = table.Locale;
                }
                if ((table.Namespace != table.DataSet.Namespace)) {
                    this.Namespace = table.Namespace;
                }
                this.Prefix = table.Prefix;
                this.MinimumCapacity = table.MinimumCapacity;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected EventsSummaryDataTable(global::System.Runtime.Serialization.SerializationInfo info, global::System.Runtime.Serialization.StreamingContext context) : 
                    base(info, context) {
                this.InitVars();
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn MachineNameColumn {
                get {
                    return this.columnMachineName;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn TotalErrorsColumn {
                get {
                    return this.columnTotalErrors;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn TotalWarningsColumn {
                get {
                    return this.columnTotalWarnings;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn TotalCriticalsColumn {
                get {
                    return this.columnTotalCriticals;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn TotalInformationalColumn {
                get {
                    return this.columnTotalInformational;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            [global::System.ComponentModel.Browsable(false)]
            public int Count {
                get {
                    return this.Rows.Count;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public EventsSummaryRow this[int index] {
                get {
                    return ((EventsSummaryRow)(this.Rows[index]));
                }
            }
            
            public event EventsSummaryRowChangeEventHandler EventsSummaryRowChanging;
            
            public event EventsSummaryRowChangeEventHandler EventsSummaryRowChanged;
            
            public event EventsSummaryRowChangeEventHandler EventsSummaryRowDeleting;
            
            public event EventsSummaryRowChangeEventHandler EventsSummaryRowDeleted;
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void AddEventsSummaryRow(EventsSummaryRow row) {
                this.Rows.Add(row);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public EventsSummaryRow AddEventsSummaryRow(string MachineName, int TotalErrors, int TotalWarnings, int TotalCriticals, int TotalInformational) {
                EventsSummaryRow rowEventsSummaryRow = ((EventsSummaryRow)(this.NewRow()));
                object[] columnValuesArray = new object[] {
                        MachineName,
                        TotalErrors,
                        TotalWarnings,
                        TotalCriticals,
                        TotalInformational};
                rowEventsSummaryRow.ItemArray = columnValuesArray;
                this.Rows.Add(rowEventsSummaryRow);
                return rowEventsSummaryRow;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public override global::System.Data.DataTable Clone() {
                EventsSummaryDataTable cln = ((EventsSummaryDataTable)(base.Clone()));
                cln.InitVars();
                return cln;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override global::System.Data.DataTable CreateInstance() {
                return new EventsSummaryDataTable();
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            internal void InitVars() {
                this.columnMachineName = base.Columns["MachineName"];
                this.columnTotalErrors = base.Columns["TotalErrors"];
                this.columnTotalWarnings = base.Columns["TotalWarnings"];
                this.columnTotalCriticals = base.Columns["TotalCriticals"];
                this.columnTotalInformational = base.Columns["TotalInformational"];
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            private void InitClass() {
                this.columnMachineName = new global::System.Data.DataColumn("MachineName", typeof(string), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnMachineName);
                this.columnTotalErrors = new global::System.Data.DataColumn("TotalErrors", typeof(int), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnTotalErrors);
                this.columnTotalWarnings = new global::System.Data.DataColumn("TotalWarnings", typeof(int), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnTotalWarnings);
                this.columnTotalCriticals = new global::System.Data.DataColumn("TotalCriticals", typeof(int), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnTotalCriticals);
                this.columnTotalInformational = new global::System.Data.DataColumn("TotalInformational", typeof(int), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnTotalInformational);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public EventsSummaryRow NewEventsSummaryRow() {
                return ((EventsSummaryRow)(this.NewRow()));
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override global::System.Data.DataRow NewRowFromBuilder(global::System.Data.DataRowBuilder builder) {
                return new EventsSummaryRow(builder);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override global::System.Type GetRowType() {
                return typeof(EventsSummaryRow);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override void OnRowChanged(global::System.Data.DataRowChangeEventArgs e) {
                base.OnRowChanged(e);
                if ((this.EventsSummaryRowChanged != null)) {
                    this.EventsSummaryRowChanged(this, new EventsSummaryRowChangeEvent(((EventsSummaryRow)(e.Row)), e.Action));
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override void OnRowChanging(global::System.Data.DataRowChangeEventArgs e) {
                base.OnRowChanging(e);
                if ((this.EventsSummaryRowChanging != null)) {
                    this.EventsSummaryRowChanging(this, new EventsSummaryRowChangeEvent(((EventsSummaryRow)(e.Row)), e.Action));
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override void OnRowDeleted(global::System.Data.DataRowChangeEventArgs e) {
                base.OnRowDeleted(e);
                if ((this.EventsSummaryRowDeleted != null)) {
                    this.EventsSummaryRowDeleted(this, new EventsSummaryRowChangeEvent(((EventsSummaryRow)(e.Row)), e.Action));
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override void OnRowDeleting(global::System.Data.DataRowChangeEventArgs e) {
                base.OnRowDeleting(e);
                if ((this.EventsSummaryRowDeleting != null)) {
                    this.EventsSummaryRowDeleting(this, new EventsSummaryRowChangeEvent(((EventsSummaryRow)(e.Row)), e.Action));
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void RemoveEventsSummaryRow(EventsSummaryRow row) {
                this.Rows.Remove(row);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public static global::System.Xml.Schema.XmlSchemaComplexType GetTypedTableSchema(global::System.Xml.Schema.XmlSchemaSet xs) {
                global::System.Xml.Schema.XmlSchemaComplexType type = new global::System.Xml.Schema.XmlSchemaComplexType();
                global::System.Xml.Schema.XmlSchemaSequence sequence = new global::System.Xml.Schema.XmlSchemaSequence();
                DiagnosticDBDataSet ds = new DiagnosticDBDataSet();
                global::System.Xml.Schema.XmlSchemaAny any1 = new global::System.Xml.Schema.XmlSchemaAny();
                any1.Namespace = "http://www.w3.org/2001/XMLSchema";
                any1.MinOccurs = new decimal(0);
                any1.MaxOccurs = decimal.MaxValue;
                any1.ProcessContents = global::System.Xml.Schema.XmlSchemaContentProcessing.Lax;
                sequence.Items.Add(any1);
                global::System.Xml.Schema.XmlSchemaAny any2 = new global::System.Xml.Schema.XmlSchemaAny();
                any2.Namespace = "urn:schemas-microsoft-com:xml-diffgram-v1";
                any2.MinOccurs = new decimal(1);
                any2.ProcessContents = global::System.Xml.Schema.XmlSchemaContentProcessing.Lax;
                sequence.Items.Add(any2);
                global::System.Xml.Schema.XmlSchemaAttribute attribute1 = new global::System.Xml.Schema.XmlSchemaAttribute();
                attribute1.Name = "namespace";
                attribute1.FixedValue = ds.Namespace;
                type.Attributes.Add(attribute1);
                global::System.Xml.Schema.XmlSchemaAttribute attribute2 = new global::System.Xml.Schema.XmlSchemaAttribute();
                attribute2.Name = "tableTypeName";
                attribute2.FixedValue = "EventsSummaryDataTable";
                type.Attributes.Add(attribute2);
                type.Particle = sequence;
                global::System.Xml.Schema.XmlSchema dsSchema = ds.GetSchemaSerializable();
                if (xs.Contains(dsSchema.TargetNamespace)) {
                    global::System.IO.MemoryStream s1 = new global::System.IO.MemoryStream();
                    global::System.IO.MemoryStream s2 = new global::System.IO.MemoryStream();
                    try {
                        global::System.Xml.Schema.XmlSchema schema = null;
                        dsSchema.Write(s1);
                        for (global::System.Collections.IEnumerator schemas = xs.Schemas(dsSchema.TargetNamespace).GetEnumerator(); schemas.MoveNext(); ) {
                            schema = ((global::System.Xml.Schema.XmlSchema)(schemas.Current));
                            s2.SetLength(0);
                            schema.Write(s2);
                            if ((s1.Length == s2.Length)) {
                                s1.Position = 0;
                                s2.Position = 0;
                                for (; ((s1.Position != s1.Length) 
                                            && (s1.ReadByte() == s2.ReadByte())); ) {
                                    ;
                                }
                                if ((s1.Position == s1.Length)) {
                                    return type;
                                }
                            }
                        }
                    }
                    finally {
                        if ((s1 != null)) {
                            s1.Close();
                        }
                        if ((s2 != null)) {
                            s2.Close();
                        }
                    }
                }
                xs.Add(dsSchema);
                return type;
            }
        }
        
        /// <summary>
        ///Represents strongly named DataRow class.
        ///</summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Data.Design.TypedDataSetGenerator", "2.0.0.0")]
        public partial class MessageIDTransformTblRow : global::System.Data.DataRow {
            
            private MessageIDTransformTblDataTable tableMessageIDTransformTbl;
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            internal MessageIDTransformTblRow(global::System.Data.DataRowBuilder rb) : 
                    base(rb) {
                this.tableMessageIDTransformTbl = ((MessageIDTransformTblDataTable)(this.Table));
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public int MessageID {
                get {
                    return ((int)(this[this.tableMessageIDTransformTbl.MessageIDColumn]));
                }
                set {
                    this[this.tableMessageIDTransformTbl.MessageIDColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public int NewSeverity {
                get {
                    try {
                        return ((int)(this[this.tableMessageIDTransformTbl.NewSeverityColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'NewSeverity\' in table \'MessageIDTransformTbl\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableMessageIDTransformTbl.NewSeverityColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public int PK_MessageIDTransform {
                get {
                    return ((int)(this[this.tableMessageIDTransformTbl.PK_MessageIDTransformColumn]));
                }
                set {
                    this[this.tableMessageIDTransformTbl.PK_MessageIDTransformColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool ShouldTrace {
                get {
                    try {
                        return ((bool)(this[this.tableMessageIDTransformTbl.ShouldTraceColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'ShouldTrace\' in table \'MessageIDTransformTbl\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableMessageIDTransformTbl.ShouldTraceColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsNewSeverityNull() {
                return this.IsNull(this.tableMessageIDTransformTbl.NewSeverityColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetNewSeverityNull() {
                this[this.tableMessageIDTransformTbl.NewSeverityColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsShouldTraceNull() {
                return this.IsNull(this.tableMessageIDTransformTbl.ShouldTraceColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetShouldTraceNull() {
                this[this.tableMessageIDTransformTbl.ShouldTraceColumn] = global::System.Convert.DBNull;
            }
        }
        
        /// <summary>
        ///Represents strongly named DataRow class.
        ///</summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Data.Design.TypedDataSetGenerator", "2.0.0.0")]
        public partial class ListenerFilterRow : global::System.Data.DataRow {
            
            private ListenerFilterDataTable tableListenerFilter;
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            internal ListenerFilterRow(global::System.Data.DataRowBuilder rb) : 
                    base(rb) {
                this.tableListenerFilter = ((ListenerFilterDataTable)(this.Table));
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public string ListenerName {
                get {
                    try {
                        return ((string)(this[this.tableListenerFilter.ListenerNameColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'ListenerName\' in table \'ListenerFilter\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableListenerFilter.ListenerNameColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public int TraceThresholdMask {
                get {
                    try {
                        return ((int)(this[this.tableListenerFilter.TraceThresholdMaskColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'TraceThresholdMask\' in table \'ListenerFilter\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableListenerFilter.TraceThresholdMaskColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public int TraceOutputOptions {
                get {
                    try {
                        return ((int)(this[this.tableListenerFilter.TraceOutputOptionsColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'TraceOutputOptions\' in table \'ListenerFilter\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableListenerFilter.TraceOutputOptionsColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public int PK_FilterID {
                get {
                    return ((int)(this[this.tableListenerFilter.PK_FilterIDColumn]));
                }
                set {
                    this[this.tableListenerFilter.PK_FilterIDColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsListenerNameNull() {
                return this.IsNull(this.tableListenerFilter.ListenerNameColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetListenerNameNull() {
                this[this.tableListenerFilter.ListenerNameColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsTraceThresholdMaskNull() {
                return this.IsNull(this.tableListenerFilter.TraceThresholdMaskColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetTraceThresholdMaskNull() {
                this[this.tableListenerFilter.TraceThresholdMaskColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsTraceOutputOptionsNull() {
                return this.IsNull(this.tableListenerFilter.TraceOutputOptionsColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetTraceOutputOptionsNull() {
                this[this.tableListenerFilter.TraceOutputOptionsColumn] = global::System.Convert.DBNull;
            }
        }
        
        /// <summary>
        ///Represents strongly named DataRow class.
        ///</summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Data.Design.TypedDataSetGenerator", "2.0.0.0")]
        public partial class TraceConfigurationSettingsRow : global::System.Data.DataRow {
            
            private TraceConfigurationSettingsDataTable tableTraceConfigurationSettings;
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            internal TraceConfigurationSettingsRow(global::System.Data.DataRowBuilder rb) : 
                    base(rb) {
                this.tableTraceConfigurationSettings = ((TraceConfigurationSettingsDataTable)(this.Table));
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public int SwitchValue {
                get {
                    try {
                        return ((int)(this[this.tableTraceConfigurationSettings.SwitchValueColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'SwitchValue\' in table \'TraceConfigurationSettings\' is DBNul" +
                                "l.", e);
                    }
                }
                set {
                    this[this.tableTraceConfigurationSettings.SwitchValueColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public int UpdateInterval {
                get {
                    try {
                        return ((int)(this[this.tableTraceConfigurationSettings.UpdateIntervalColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'UpdateInterval\' in table \'TraceConfigurationSettings\' is DB" +
                                "Null.", e);
                    }
                }
                set {
                    this[this.tableTraceConfigurationSettings.UpdateIntervalColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public string SwitchName {
                get {
                    try {
                        return ((string)(this[this.tableTraceConfigurationSettings.SwitchNameColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'SwitchName\' in table \'TraceConfigurationSettings\' is DBNull" +
                                ".", e);
                    }
                }
                set {
                    this[this.tableTraceConfigurationSettings.SwitchNameColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public int TraceOutputOptions {
                get {
                    try {
                        return ((int)(this[this.tableTraceConfigurationSettings.TraceOutputOptionsColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'TraceOutputOptions\' in table \'TraceConfigurationSettings\' i" +
                                "s DBNull.", e);
                    }
                }
                set {
                    this[this.tableTraceConfigurationSettings.TraceOutputOptionsColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public int PK_TraceConfigSettings {
                get {
                    return ((int)(this[this.tableTraceConfigurationSettings.PK_TraceConfigSettingsColumn]));
                }
                set {
                    this[this.tableTraceConfigurationSettings.PK_TraceConfigSettingsColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsSwitchValueNull() {
                return this.IsNull(this.tableTraceConfigurationSettings.SwitchValueColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetSwitchValueNull() {
                this[this.tableTraceConfigurationSettings.SwitchValueColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsUpdateIntervalNull() {
                return this.IsNull(this.tableTraceConfigurationSettings.UpdateIntervalColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetUpdateIntervalNull() {
                this[this.tableTraceConfigurationSettings.UpdateIntervalColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsSwitchNameNull() {
                return this.IsNull(this.tableTraceConfigurationSettings.SwitchNameColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetSwitchNameNull() {
                this[this.tableTraceConfigurationSettings.SwitchNameColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsTraceOutputOptionsNull() {
                return this.IsNull(this.tableTraceConfigurationSettings.TraceOutputOptionsColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetTraceOutputOptionsNull() {
                this[this.tableTraceConfigurationSettings.TraceOutputOptionsColumn] = global::System.Convert.DBNull;
            }
        }
        
        /// <summary>
        ///Represents strongly named DataRow class.
        ///</summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Data.Design.TypedDataSetGenerator", "2.0.0.0")]
        public partial class EventsXmlRow : global::System.Data.DataRow {
            
            private EventsXmlDataTable tableEventsXml;
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            internal EventsXmlRow(global::System.Data.DataRowBuilder rb) : 
                    base(rb) {
                this.tableEventsXml = ((EventsXmlDataTable)(this.Table));
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public int PK_Events {
                get {
                    return ((int)(this[this.tableEventsXml.PK_EventsColumn]));
                }
                set {
                    this[this.tableEventsXml.PK_EventsColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public string EventData {
                get {
                    try {
                        return ((string)(this[this.tableEventsXml.EventDataColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'EventData\' in table \'EventsXml\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableEventsXml.EventDataColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public int RowNumber {
                get {
                    try {
                        return ((int)(this[this.tableEventsXml.RowNumberColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'RowNumber\' in table \'EventsXml\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableEventsXml.RowNumberColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsEventDataNull() {
                return this.IsNull(this.tableEventsXml.EventDataColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetEventDataNull() {
                this[this.tableEventsXml.EventDataColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsRowNumberNull() {
                return this.IsNull(this.tableEventsXml.RowNumberColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetRowNumberNull() {
                this[this.tableEventsXml.RowNumberColumn] = global::System.Convert.DBNull;
            }
        }
        
        /// <summary>
        ///Represents strongly named DataRow class.
        ///</summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Data.Design.TypedDataSetGenerator", "2.0.0.0")]
        public partial class EventsRow : global::System.Data.DataRow {
            
            private EventsDataTable tableEvents;
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            internal EventsRow(global::System.Data.DataRowBuilder rb) : 
                    base(rb) {
                this.tableEvents = ((EventsDataTable)(this.Table));
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public int EventID {
                get {
                    return ((int)(this[this.tableEvents.EventIDColumn]));
                }
                set {
                    this[this.tableEvents.EventIDColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public string MachineName {
                get {
                    try {
                        return ((string)(this[this.tableEvents.MachineNameColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'MachineName\' in table \'Events\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableEvents.MachineNameColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public string Source {
                get {
                    try {
                        return ((string)(this[this.tableEvents.SourceColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'Source\' in table \'Events\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableEvents.SourceColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public int MessageID {
                get {
                    try {
                        return ((int)(this[this.tableEvents.MessageIDColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'MessageID\' in table \'Events\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableEvents.MessageIDColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public string Message {
                get {
                    try {
                        return ((string)(this[this.tableEvents.MessageColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'Message\' in table \'Events\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableEvents.MessageColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public string FileName {
                get {
                    try {
                        return ((string)(this[this.tableEvents.FileNameColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'FileName\' in table \'Events\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableEvents.FileNameColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public int LineNumber {
                get {
                    try {
                        return ((int)(this[this.tableEvents.LineNumberColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'LineNumber\' in table \'Events\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableEvents.LineNumberColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public string MethodName {
                get {
                    try {
                        return ((string)(this[this.tableEvents.MethodNameColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'MethodName\' in table \'Events\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableEvents.MethodNameColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public System.DateTime DateTime {
                get {
                    try {
                        return ((global::System.DateTime)(this[this.tableEvents.DateTimeColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'DateTime\' in table \'Events\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableEvents.DateTimeColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public long TimeStamp {
                get {
                    try {
                        return ((long)(this[this.tableEvents.TimeStampColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'TimeStamp\' in table \'Events\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableEvents.TimeStampColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public int ProcessID {
                get {
                    try {
                        return ((int)(this[this.tableEvents.ProcessIDColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'ProcessID\' in table \'Events\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableEvents.ProcessIDColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public string ThreadID {
                get {
                    try {
                        return ((string)(this[this.tableEvents.ThreadIDColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'ThreadID\' in table \'Events\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableEvents.ThreadIDColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public string CallStack {
                get {
                    try {
                        return ((string)(this[this.tableEvents.CallStackColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'CallStack\' in table \'Events\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableEvents.CallStackColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public string LogicalStack {
                get {
                    try {
                        return ((string)(this[this.tableEvents.LogicalStackColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'LogicalStack\' in table \'Events\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableEvents.LogicalStackColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public string EventType {
                get {
                    try {
                        return ((string)(this[this.tableEvents.EventTypeColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'EventType\' in table \'Events\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableEvents.EventTypeColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public string AssemblyName {
                get {
                    try {
                        return ((string)(this[this.tableEvents.AssemblyNameColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'AssemblyName\' in table \'Events\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableEvents.AssemblyNameColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsMachineNameNull() {
                return this.IsNull(this.tableEvents.MachineNameColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetMachineNameNull() {
                this[this.tableEvents.MachineNameColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsSourceNull() {
                return this.IsNull(this.tableEvents.SourceColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetSourceNull() {
                this[this.tableEvents.SourceColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsMessageIDNull() {
                return this.IsNull(this.tableEvents.MessageIDColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetMessageIDNull() {
                this[this.tableEvents.MessageIDColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsMessageNull() {
                return this.IsNull(this.tableEvents.MessageColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetMessageNull() {
                this[this.tableEvents.MessageColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsFileNameNull() {
                return this.IsNull(this.tableEvents.FileNameColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetFileNameNull() {
                this[this.tableEvents.FileNameColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsLineNumberNull() {
                return this.IsNull(this.tableEvents.LineNumberColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetLineNumberNull() {
                this[this.tableEvents.LineNumberColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsMethodNameNull() {
                return this.IsNull(this.tableEvents.MethodNameColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetMethodNameNull() {
                this[this.tableEvents.MethodNameColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsDateTimeNull() {
                return this.IsNull(this.tableEvents.DateTimeColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetDateTimeNull() {
                this[this.tableEvents.DateTimeColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsTimeStampNull() {
                return this.IsNull(this.tableEvents.TimeStampColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetTimeStampNull() {
                this[this.tableEvents.TimeStampColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsProcessIDNull() {
                return this.IsNull(this.tableEvents.ProcessIDColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetProcessIDNull() {
                this[this.tableEvents.ProcessIDColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsThreadIDNull() {
                return this.IsNull(this.tableEvents.ThreadIDColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetThreadIDNull() {
                this[this.tableEvents.ThreadIDColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsCallStackNull() {
                return this.IsNull(this.tableEvents.CallStackColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetCallStackNull() {
                this[this.tableEvents.CallStackColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsLogicalStackNull() {
                return this.IsNull(this.tableEvents.LogicalStackColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetLogicalStackNull() {
                this[this.tableEvents.LogicalStackColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsEventTypeNull() {
                return this.IsNull(this.tableEvents.EventTypeColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetEventTypeNull() {
                this[this.tableEvents.EventTypeColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsAssemblyNameNull() {
                return this.IsNull(this.tableEvents.AssemblyNameColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetAssemblyNameNull() {
                this[this.tableEvents.AssemblyNameColumn] = global::System.Convert.DBNull;
            }
        }
        
        /// <summary>
        ///Represents strongly named DataRow class.
        ///</summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Data.Design.TypedDataSetGenerator", "2.0.0.0")]
        public partial class GetSummaryEventsRow : global::System.Data.DataRow {
            
            private GetSummaryEventsDataTable tableGetSummaryEvents;
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            internal GetSummaryEventsRow(global::System.Data.DataRowBuilder rb) : 
                    base(rb) {
                this.tableGetSummaryEvents = ((GetSummaryEventsDataTable)(this.Table));
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public string MachineName {
                get {
                    try {
                        return ((string)(this[this.tableGetSummaryEvents.MachineNameColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'MachineName\' in table \'GetSummaryEvents\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableGetSummaryEvents.MachineNameColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public int TotalErrors {
                get {
                    try {
                        return ((int)(this[this.tableGetSummaryEvents.TotalErrorsColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'TotalErrors\' in table \'GetSummaryEvents\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableGetSummaryEvents.TotalErrorsColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public int TotalWarnings {
                get {
                    try {
                        return ((int)(this[this.tableGetSummaryEvents.TotalWarningsColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'TotalWarnings\' in table \'GetSummaryEvents\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableGetSummaryEvents.TotalWarningsColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public int TotalCriticals {
                get {
                    try {
                        return ((int)(this[this.tableGetSummaryEvents.TotalCriticalsColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'TotalCriticals\' in table \'GetSummaryEvents\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableGetSummaryEvents.TotalCriticalsColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public int TotalInformational {
                get {
                    try {
                        return ((int)(this[this.tableGetSummaryEvents.TotalInformationalColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'TotalInformational\' in table \'GetSummaryEvents\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableGetSummaryEvents.TotalInformationalColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsMachineNameNull() {
                return this.IsNull(this.tableGetSummaryEvents.MachineNameColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetMachineNameNull() {
                this[this.tableGetSummaryEvents.MachineNameColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsTotalErrorsNull() {
                return this.IsNull(this.tableGetSummaryEvents.TotalErrorsColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetTotalErrorsNull() {
                this[this.tableGetSummaryEvents.TotalErrorsColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsTotalWarningsNull() {
                return this.IsNull(this.tableGetSummaryEvents.TotalWarningsColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetTotalWarningsNull() {
                this[this.tableGetSummaryEvents.TotalWarningsColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsTotalCriticalsNull() {
                return this.IsNull(this.tableGetSummaryEvents.TotalCriticalsColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetTotalCriticalsNull() {
                this[this.tableGetSummaryEvents.TotalCriticalsColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsTotalInformationalNull() {
                return this.IsNull(this.tableGetSummaryEvents.TotalInformationalColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetTotalInformationalNull() {
                this[this.tableGetSummaryEvents.TotalInformationalColumn] = global::System.Convert.DBNull;
            }
        }
        
        /// <summary>
        ///Represents strongly named DataRow class.
        ///</summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Data.Design.TypedDataSetGenerator", "2.0.0.0")]
        public partial class EventsReportingRow : global::System.Data.DataRow {
            
            private EventsReportingDataTable tableEventsReporting;
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            internal EventsReportingRow(global::System.Data.DataRowBuilder rb) : 
                    base(rb) {
                this.tableEventsReporting = ((EventsReportingDataTable)(this.Table));
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public string EventType {
                get {
                    try {
                        return ((string)(this[this.tableEventsReporting.EventTypeColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'EventType\' in table \'EventsReporting\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableEventsReporting.EventTypeColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public string MachineName {
                get {
                    try {
                        return ((string)(this[this.tableEventsReporting.MachineNameColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'MachineName\' in table \'EventsReporting\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableEventsReporting.MachineNameColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public string AssemblyName {
                get {
                    try {
                        return ((string)(this[this.tableEventsReporting.AssemblyNameColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'AssemblyName\' in table \'EventsReporting\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableEventsReporting.AssemblyNameColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public string SourceName {
                get {
                    try {
                        return ((string)(this[this.tableEventsReporting.SourceNameColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'SourceName\' in table \'EventsReporting\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableEventsReporting.SourceNameColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public System.DateTime DateTime {
                get {
                    try {
                        return ((global::System.DateTime)(this[this.tableEventsReporting.DateTimeColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'DateTime\' in table \'EventsReporting\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableEventsReporting.DateTimeColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public string MethodName {
                get {
                    try {
                        return ((string)(this[this.tableEventsReporting.MethodNameColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'MethodName\' in table \'EventsReporting\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableEventsReporting.MethodNameColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public string ProcessID {
                get {
                    try {
                        return ((string)(this[this.tableEventsReporting.ProcessIDColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'ProcessID\' in table \'EventsReporting\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableEventsReporting.ProcessIDColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public string ThreadID {
                get {
                    try {
                        return ((string)(this[this.tableEventsReporting.ThreadIDColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'ThreadID\' in table \'EventsReporting\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableEventsReporting.ThreadIDColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public string Message {
                get {
                    try {
                        return ((string)(this[this.tableEventsReporting.MessageColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'Message\' in table \'EventsReporting\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableEventsReporting.MessageColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public string CallStack {
                get {
                    try {
                        return ((string)(this[this.tableEventsReporting.CallStackColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'CallStack\' in table \'EventsReporting\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableEventsReporting.CallStackColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public int MessageID {
                get {
                    try {
                        return ((int)(this[this.tableEventsReporting.MessageIDColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'MessageID\' in table \'EventsReporting\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableEventsReporting.MessageIDColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsEventTypeNull() {
                return this.IsNull(this.tableEventsReporting.EventTypeColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetEventTypeNull() {
                this[this.tableEventsReporting.EventTypeColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsMachineNameNull() {
                return this.IsNull(this.tableEventsReporting.MachineNameColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetMachineNameNull() {
                this[this.tableEventsReporting.MachineNameColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsAssemblyNameNull() {
                return this.IsNull(this.tableEventsReporting.AssemblyNameColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetAssemblyNameNull() {
                this[this.tableEventsReporting.AssemblyNameColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsSourceNameNull() {
                return this.IsNull(this.tableEventsReporting.SourceNameColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetSourceNameNull() {
                this[this.tableEventsReporting.SourceNameColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsDateTimeNull() {
                return this.IsNull(this.tableEventsReporting.DateTimeColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetDateTimeNull() {
                this[this.tableEventsReporting.DateTimeColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsMethodNameNull() {
                return this.IsNull(this.tableEventsReporting.MethodNameColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetMethodNameNull() {
                this[this.tableEventsReporting.MethodNameColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsProcessIDNull() {
                return this.IsNull(this.tableEventsReporting.ProcessIDColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetProcessIDNull() {
                this[this.tableEventsReporting.ProcessIDColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsThreadIDNull() {
                return this.IsNull(this.tableEventsReporting.ThreadIDColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetThreadIDNull() {
                this[this.tableEventsReporting.ThreadIDColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsMessageNull() {
                return this.IsNull(this.tableEventsReporting.MessageColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetMessageNull() {
                this[this.tableEventsReporting.MessageColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsCallStackNull() {
                return this.IsNull(this.tableEventsReporting.CallStackColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetCallStackNull() {
                this[this.tableEventsReporting.CallStackColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsMessageIDNull() {
                return this.IsNull(this.tableEventsReporting.MessageIDColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetMessageIDNull() {
                this[this.tableEventsReporting.MessageIDColumn] = global::System.Convert.DBNull;
            }
        }
        
        /// <summary>
        ///Represents strongly named DataRow class.
        ///</summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Data.Design.TypedDataSetGenerator", "2.0.0.0")]
        public partial class EventsSummaryRow : global::System.Data.DataRow {
            
            private EventsSummaryDataTable tableEventsSummary;
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            internal EventsSummaryRow(global::System.Data.DataRowBuilder rb) : 
                    base(rb) {
                this.tableEventsSummary = ((EventsSummaryDataTable)(this.Table));
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public string MachineName {
                get {
                    try {
                        return ((string)(this[this.tableEventsSummary.MachineNameColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'MachineName\' in table \'EventsSummary\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableEventsSummary.MachineNameColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public int TotalErrors {
                get {
                    try {
                        return ((int)(this[this.tableEventsSummary.TotalErrorsColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'TotalErrors\' in table \'EventsSummary\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableEventsSummary.TotalErrorsColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public int TotalWarnings {
                get {
                    try {
                        return ((int)(this[this.tableEventsSummary.TotalWarningsColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'TotalWarnings\' in table \'EventsSummary\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableEventsSummary.TotalWarningsColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public int TotalCriticals {
                get {
                    try {
                        return ((int)(this[this.tableEventsSummary.TotalCriticalsColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'TotalCriticals\' in table \'EventsSummary\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableEventsSummary.TotalCriticalsColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public int TotalInformational {
                get {
                    try {
                        return ((int)(this[this.tableEventsSummary.TotalInformationalColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'TotalInformational\' in table \'EventsSummary\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableEventsSummary.TotalInformationalColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsMachineNameNull() {
                return this.IsNull(this.tableEventsSummary.MachineNameColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetMachineNameNull() {
                this[this.tableEventsSummary.MachineNameColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsTotalErrorsNull() {
                return this.IsNull(this.tableEventsSummary.TotalErrorsColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetTotalErrorsNull() {
                this[this.tableEventsSummary.TotalErrorsColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsTotalWarningsNull() {
                return this.IsNull(this.tableEventsSummary.TotalWarningsColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetTotalWarningsNull() {
                this[this.tableEventsSummary.TotalWarningsColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsTotalCriticalsNull() {
                return this.IsNull(this.tableEventsSummary.TotalCriticalsColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetTotalCriticalsNull() {
                this[this.tableEventsSummary.TotalCriticalsColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsTotalInformationalNull() {
                return this.IsNull(this.tableEventsSummary.TotalInformationalColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetTotalInformationalNull() {
                this[this.tableEventsSummary.TotalInformationalColumn] = global::System.Convert.DBNull;
            }
        }
        
        /// <summary>
        ///Row event argument class
        ///</summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Data.Design.TypedDataSetGenerator", "2.0.0.0")]
        public class MessageIDTransformTblRowChangeEvent : global::System.EventArgs {
            
            private MessageIDTransformTblRow eventRow;
            
            private global::System.Data.DataRowAction eventAction;
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public MessageIDTransformTblRowChangeEvent(MessageIDTransformTblRow row, global::System.Data.DataRowAction action) {
                this.eventRow = row;
                this.eventAction = action;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public MessageIDTransformTblRow Row {
                get {
                    return this.eventRow;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataRowAction Action {
                get {
                    return this.eventAction;
                }
            }
        }
        
        /// <summary>
        ///Row event argument class
        ///</summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Data.Design.TypedDataSetGenerator", "2.0.0.0")]
        public class ListenerFilterRowChangeEvent : global::System.EventArgs {
            
            private ListenerFilterRow eventRow;
            
            private global::System.Data.DataRowAction eventAction;
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public ListenerFilterRowChangeEvent(ListenerFilterRow row, global::System.Data.DataRowAction action) {
                this.eventRow = row;
                this.eventAction = action;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public ListenerFilterRow Row {
                get {
                    return this.eventRow;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataRowAction Action {
                get {
                    return this.eventAction;
                }
            }
        }
        
        /// <summary>
        ///Row event argument class
        ///</summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Data.Design.TypedDataSetGenerator", "2.0.0.0")]
        public class TraceConfigurationSettingsRowChangeEvent : global::System.EventArgs {
            
            private TraceConfigurationSettingsRow eventRow;
            
            private global::System.Data.DataRowAction eventAction;
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public TraceConfigurationSettingsRowChangeEvent(TraceConfigurationSettingsRow row, global::System.Data.DataRowAction action) {
                this.eventRow = row;
                this.eventAction = action;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public TraceConfigurationSettingsRow Row {
                get {
                    return this.eventRow;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataRowAction Action {
                get {
                    return this.eventAction;
                }
            }
        }
        
        /// <summary>
        ///Row event argument class
        ///</summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Data.Design.TypedDataSetGenerator", "2.0.0.0")]
        public class EventsXmlRowChangeEvent : global::System.EventArgs {
            
            private EventsXmlRow eventRow;
            
            private global::System.Data.DataRowAction eventAction;
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public EventsXmlRowChangeEvent(EventsXmlRow row, global::System.Data.DataRowAction action) {
                this.eventRow = row;
                this.eventAction = action;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public EventsXmlRow Row {
                get {
                    return this.eventRow;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataRowAction Action {
                get {
                    return this.eventAction;
                }
            }
        }
        
        /// <summary>
        ///Row event argument class
        ///</summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Data.Design.TypedDataSetGenerator", "2.0.0.0")]
        public class EventsRowChangeEvent : global::System.EventArgs {
            
            private EventsRow eventRow;
            
            private global::System.Data.DataRowAction eventAction;
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public EventsRowChangeEvent(EventsRow row, global::System.Data.DataRowAction action) {
                this.eventRow = row;
                this.eventAction = action;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public EventsRow Row {
                get {
                    return this.eventRow;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataRowAction Action {
                get {
                    return this.eventAction;
                }
            }
        }
        
        /// <summary>
        ///Row event argument class
        ///</summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Data.Design.TypedDataSetGenerator", "2.0.0.0")]
        public class GetSummaryEventsRowChangeEvent : global::System.EventArgs {
            
            private GetSummaryEventsRow eventRow;
            
            private global::System.Data.DataRowAction eventAction;
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public GetSummaryEventsRowChangeEvent(GetSummaryEventsRow row, global::System.Data.DataRowAction action) {
                this.eventRow = row;
                this.eventAction = action;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public GetSummaryEventsRow Row {
                get {
                    return this.eventRow;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataRowAction Action {
                get {
                    return this.eventAction;
                }
            }
        }
        
        /// <summary>
        ///Row event argument class
        ///</summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Data.Design.TypedDataSetGenerator", "2.0.0.0")]
        public class EventsReportingRowChangeEvent : global::System.EventArgs {
            
            private EventsReportingRow eventRow;
            
            private global::System.Data.DataRowAction eventAction;
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public EventsReportingRowChangeEvent(EventsReportingRow row, global::System.Data.DataRowAction action) {
                this.eventRow = row;
                this.eventAction = action;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public EventsReportingRow Row {
                get {
                    return this.eventRow;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataRowAction Action {
                get {
                    return this.eventAction;
                }
            }
        }
        
        /// <summary>
        ///Row event argument class
        ///</summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Data.Design.TypedDataSetGenerator", "2.0.0.0")]
        public class EventsSummaryRowChangeEvent : global::System.EventArgs {
            
            private EventsSummaryRow eventRow;
            
            private global::System.Data.DataRowAction eventAction;
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public EventsSummaryRowChangeEvent(EventsSummaryRow row, global::System.Data.DataRowAction action) {
                this.eventRow = row;
                this.eventAction = action;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public EventsSummaryRow Row {
                get {
                    return this.eventRow;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataRowAction Action {
                get {
                    return this.eventAction;
                }
            }
        }
    }
}
namespace Wgx.Services.Monitoring.DiagnosticDBDataSetTableAdapters {
    
    
    /// <summary>
    ///Represents the connection and commands used to retrieve and save data.
    ///</summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Data.Design.TypedDataSetGenerator", "2.0.0.0")]
    [global::System.ComponentModel.DesignerCategoryAttribute("code")]
    [global::System.ComponentModel.ToolboxItem(true)]
    [global::System.ComponentModel.DataObjectAttribute(true)]
    [global::System.ComponentModel.DesignerAttribute("Microsoft.VSDesigner.DataSource.Design.TableAdapterDesigner, Microsoft.VSDesigner" +
        ", Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
    [global::System.ComponentModel.Design.HelpKeywordAttribute("vs.data.TableAdapter")]
    public partial class MessageIDTransformTblTableAdapter : global::System.ComponentModel.Component {
        
        private global::System.Data.SqlClient.SqlDataAdapter _adapter;
        
        private global::System.Data.SqlClient.SqlConnection _connection;
        
        private global::System.Data.SqlClient.SqlTransaction _transaction;
        
        private global::System.Data.SqlClient.SqlCommand[] _commandCollection;
        
        private bool _clearBeforeFill;
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public MessageIDTransformTblTableAdapter() {
            this.ClearBeforeFill = true;
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        protected internal global::System.Data.SqlClient.SqlDataAdapter Adapter {
            get {
                if ((this._adapter == null)) {
                    this.InitAdapter();
                }
                return this._adapter;
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        internal global::System.Data.SqlClient.SqlConnection Connection {
            get {
                if ((this._connection == null)) {
                    this.InitConnection();
                }
                return this._connection;
            }
            set {
                this._connection = value;
                if ((this.Adapter.InsertCommand != null)) {
                    this.Adapter.InsertCommand.Connection = value;
                }
                if ((this.Adapter.DeleteCommand != null)) {
                    this.Adapter.DeleteCommand.Connection = value;
                }
                if ((this.Adapter.UpdateCommand != null)) {
                    this.Adapter.UpdateCommand.Connection = value;
                }
                for (int i = 0; (i < this.CommandCollection.Length); i = (i + 1)) {
                    if ((this.CommandCollection[i] != null)) {
                        ((global::System.Data.SqlClient.SqlCommand)(this.CommandCollection[i])).Connection = value;
                    }
                }
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        internal global::System.Data.SqlClient.SqlTransaction Transaction {
            get {
                return this._transaction;
            }
            set {
                this._transaction = value;
                for (int i = 0; (i < this.CommandCollection.Length); i = (i + 1)) {
                    this.CommandCollection[i].Transaction = this._transaction;
                }
                if (((this.Adapter != null) 
                            && (this.Adapter.DeleteCommand != null))) {
                    this.Adapter.DeleteCommand.Transaction = this._transaction;
                }
                if (((this.Adapter != null) 
                            && (this.Adapter.InsertCommand != null))) {
                    this.Adapter.InsertCommand.Transaction = this._transaction;
                }
                if (((this.Adapter != null) 
                            && (this.Adapter.UpdateCommand != null))) {
                    this.Adapter.UpdateCommand.Transaction = this._transaction;
                }
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        protected global::System.Data.SqlClient.SqlCommand[] CommandCollection {
            get {
                if ((this._commandCollection == null)) {
                    this.InitCommandCollection();
                }
                return this._commandCollection;
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public bool ClearBeforeFill {
            get {
                return this._clearBeforeFill;
            }
            set {
                this._clearBeforeFill = value;
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        private void InitAdapter() {
            this._adapter = new global::System.Data.SqlClient.SqlDataAdapter();
            global::System.Data.Common.DataTableMapping tableMapping = new global::System.Data.Common.DataTableMapping();
            tableMapping.SourceTable = "Table";
            tableMapping.DataSetTable = "MessageIDTransformTbl";
            tableMapping.ColumnMappings.Add("MessageID", "MessageID");
            tableMapping.ColumnMappings.Add("NewSeverity", "NewSeverity");
            tableMapping.ColumnMappings.Add("PK_MessageIDTransform", "PK_MessageIDTransform");
            tableMapping.ColumnMappings.Add("ShouldTrace", "ShouldTrace");
            this._adapter.TableMappings.Add(tableMapping);
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        private void InitConnection() {
            this._connection = new global::System.Data.SqlClient.SqlConnection();
            this._connection.ConnectionString = global::Wgx.Services.Monitoring.Properties.Settings.Default.EventAggregatorConnectionString;
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        private void InitCommandCollection() {
            this._commandCollection = new global::System.Data.SqlClient.SqlCommand[2];
            this._commandCollection[0] = new global::System.Data.SqlClient.SqlCommand();
            this._commandCollection[0].Connection = this.Connection;
            this._commandCollection[0].CommandText = "dbo.SelectMessageIDTable";
            this._commandCollection[0].CommandType = global::System.Data.CommandType.StoredProcedure;
            this._commandCollection[0].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@RETURN_VALUE", global::System.Data.SqlDbType.Int, 4, global::System.Data.ParameterDirection.ReturnValue, 10, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[1] = new global::System.Data.SqlClient.SqlCommand();
            this._commandCollection[1].Connection = this.Connection;
            this._commandCollection[1].CommandText = "dbo.GetMessageIDTransformTable";
            this._commandCollection[1].CommandType = global::System.Data.CommandType.StoredProcedure;
            this._commandCollection[1].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@RETURN_VALUE", global::System.Data.SqlDbType.Int, 4, global::System.Data.ParameterDirection.ReturnValue, 10, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Design.HelpKeywordAttribute("vs.data.TableAdapter")]
        [global::System.ComponentModel.DataObjectMethodAttribute(global::System.ComponentModel.DataObjectMethodType.Fill, true)]
        public virtual int Fill(DiagnosticDBDataSet.MessageIDTransformTblDataTable dataTable) {
            this.Adapter.SelectCommand = this.CommandCollection[0];
            if ((this.ClearBeforeFill == true)) {
                dataTable.Clear();
            }
            int returnValue = this.Adapter.Fill(dataTable);
            return returnValue;
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Design.HelpKeywordAttribute("vs.data.TableAdapter")]
        [global::System.ComponentModel.DataObjectMethodAttribute(global::System.ComponentModel.DataObjectMethodType.Select, true)]
        public virtual DiagnosticDBDataSet.MessageIDTransformTblDataTable GetData() {
            this.Adapter.SelectCommand = this.CommandCollection[0];
            DiagnosticDBDataSet.MessageIDTransformTblDataTable dataTable = new DiagnosticDBDataSet.MessageIDTransformTblDataTable();
            this.Adapter.Fill(dataTable);
            return dataTable;
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Design.HelpKeywordAttribute("vs.data.TableAdapter")]
        [global::System.ComponentModel.DataObjectMethodAttribute(global::System.ComponentModel.DataObjectMethodType.Fill, false)]
        public virtual int FillBy(DiagnosticDBDataSet.MessageIDTransformTblDataTable dataTable) {
            this.Adapter.SelectCommand = this.CommandCollection[1];
            if ((this.ClearBeforeFill == true)) {
                dataTable.Clear();
            }
            int returnValue = this.Adapter.Fill(dataTable);
            return returnValue;
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Design.HelpKeywordAttribute("vs.data.TableAdapter")]
        [global::System.ComponentModel.DataObjectMethodAttribute(global::System.ComponentModel.DataObjectMethodType.Select, false)]
        public virtual DiagnosticDBDataSet.MessageIDTransformTblDataTable GetMessageIDTransformTable() {
            this.Adapter.SelectCommand = this.CommandCollection[1];
            DiagnosticDBDataSet.MessageIDTransformTblDataTable dataTable = new DiagnosticDBDataSet.MessageIDTransformTblDataTable();
            this.Adapter.Fill(dataTable);
            return dataTable;
        }
    }
    
    /// <summary>
    ///Represents the connection and commands used to retrieve and save data.
    ///</summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Data.Design.TypedDataSetGenerator", "2.0.0.0")]
    [global::System.ComponentModel.DesignerCategoryAttribute("code")]
    [global::System.ComponentModel.ToolboxItem(true)]
    [global::System.ComponentModel.DataObjectAttribute(true)]
    [global::System.ComponentModel.DesignerAttribute("Microsoft.VSDesigner.DataSource.Design.TableAdapterDesigner, Microsoft.VSDesigner" +
        ", Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
    [global::System.ComponentModel.Design.HelpKeywordAttribute("vs.data.TableAdapter")]
    public partial class ListenerFilterTableAdapter : global::System.ComponentModel.Component {
        
        private global::System.Data.SqlClient.SqlDataAdapter _adapter;
        
        private global::System.Data.SqlClient.SqlConnection _connection;
        
        private global::System.Data.SqlClient.SqlTransaction _transaction;
        
        private global::System.Data.SqlClient.SqlCommand[] _commandCollection;
        
        private bool _clearBeforeFill;
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public ListenerFilterTableAdapter() {
            this.ClearBeforeFill = true;
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        protected internal global::System.Data.SqlClient.SqlDataAdapter Adapter {
            get {
                if ((this._adapter == null)) {
                    this.InitAdapter();
                }
                return this._adapter;
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        internal global::System.Data.SqlClient.SqlConnection Connection {
            get {
                if ((this._connection == null)) {
                    this.InitConnection();
                }
                return this._connection;
            }
            set {
                this._connection = value;
                if ((this.Adapter.InsertCommand != null)) {
                    this.Adapter.InsertCommand.Connection = value;
                }
                if ((this.Adapter.DeleteCommand != null)) {
                    this.Adapter.DeleteCommand.Connection = value;
                }
                if ((this.Adapter.UpdateCommand != null)) {
                    this.Adapter.UpdateCommand.Connection = value;
                }
                for (int i = 0; (i < this.CommandCollection.Length); i = (i + 1)) {
                    if ((this.CommandCollection[i] != null)) {
                        ((global::System.Data.SqlClient.SqlCommand)(this.CommandCollection[i])).Connection = value;
                    }
                }
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        internal global::System.Data.SqlClient.SqlTransaction Transaction {
            get {
                return this._transaction;
            }
            set {
                this._transaction = value;
                for (int i = 0; (i < this.CommandCollection.Length); i = (i + 1)) {
                    this.CommandCollection[i].Transaction = this._transaction;
                }
                if (((this.Adapter != null) 
                            && (this.Adapter.DeleteCommand != null))) {
                    this.Adapter.DeleteCommand.Transaction = this._transaction;
                }
                if (((this.Adapter != null) 
                            && (this.Adapter.InsertCommand != null))) {
                    this.Adapter.InsertCommand.Transaction = this._transaction;
                }
                if (((this.Adapter != null) 
                            && (this.Adapter.UpdateCommand != null))) {
                    this.Adapter.UpdateCommand.Transaction = this._transaction;
                }
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        protected global::System.Data.SqlClient.SqlCommand[] CommandCollection {
            get {
                if ((this._commandCollection == null)) {
                    this.InitCommandCollection();
                }
                return this._commandCollection;
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public bool ClearBeforeFill {
            get {
                return this._clearBeforeFill;
            }
            set {
                this._clearBeforeFill = value;
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        private void InitAdapter() {
            this._adapter = new global::System.Data.SqlClient.SqlDataAdapter();
            global::System.Data.Common.DataTableMapping tableMapping = new global::System.Data.Common.DataTableMapping();
            tableMapping.SourceTable = "Table";
            tableMapping.DataSetTable = "ListenerFilter";
            tableMapping.ColumnMappings.Add("ListenerName", "ListenerName");
            tableMapping.ColumnMappings.Add("TraceThresholdMask", "TraceThresholdMask");
            tableMapping.ColumnMappings.Add("TraceOutputOptions", "TraceOutputOptions");
            tableMapping.ColumnMappings.Add("PK_FilterID", "PK_FilterID");
            this._adapter.TableMappings.Add(tableMapping);
            this._adapter.DeleteCommand = new global::System.Data.SqlClient.SqlCommand();
            this._adapter.DeleteCommand.Connection = this.Connection;
            this._adapter.DeleteCommand.CommandText = "dbo.DeleteFilter";
            this._adapter.DeleteCommand.CommandType = global::System.Data.CommandType.StoredProcedure;
            this._adapter.DeleteCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@RETURN_VALUE", global::System.Data.SqlDbType.Variant, 0, global::System.Data.ParameterDirection.ReturnValue, 0, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._adapter.DeleteCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@IsNull_TraceThresholdMask", global::System.Data.SqlDbType.Int, 0, global::System.Data.ParameterDirection.Input, 0, 0, "TraceThresholdMask", global::System.Data.DataRowVersion.Original, true, null, "", "", ""));
            this._adapter.DeleteCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@Original_TraceThresholdMask", global::System.Data.SqlDbType.Int, 0, global::System.Data.ParameterDirection.Input, 0, 0, "TraceThresholdMask", global::System.Data.DataRowVersion.Original, false, null, "", "", ""));
            this._adapter.DeleteCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@IsNull_TraceOutputOptions", global::System.Data.SqlDbType.Int, 0, global::System.Data.ParameterDirection.Input, 0, 0, "TraceOutputOptions", global::System.Data.DataRowVersion.Original, true, null, "", "", ""));
            this._adapter.DeleteCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@Original_TraceOutputOptions", global::System.Data.SqlDbType.Int, 0, global::System.Data.ParameterDirection.Input, 0, 0, "TraceOutputOptions", global::System.Data.DataRowVersion.Original, false, null, "", "", ""));
            this._adapter.DeleteCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@Original_PK_FilterID", global::System.Data.SqlDbType.Int, 0, global::System.Data.ParameterDirection.Input, 0, 0, "PK_FilterID", global::System.Data.DataRowVersion.Original, false, null, "", "", ""));
            this._adapter.InsertCommand = new global::System.Data.SqlClient.SqlCommand();
            this._adapter.InsertCommand.Connection = this.Connection;
            this._adapter.InsertCommand.CommandText = "dbo.InsertFilter";
            this._adapter.InsertCommand.CommandType = global::System.Data.CommandType.StoredProcedure;
            this._adapter.InsertCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@RETURN_VALUE", global::System.Data.SqlDbType.Variant, 0, global::System.Data.ParameterDirection.ReturnValue, 0, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._adapter.InsertCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@ListenerName", global::System.Data.SqlDbType.NVarChar, 0, global::System.Data.ParameterDirection.Input, 0, 0, "ListenerName", global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._adapter.InsertCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@TraceThresholdMask", global::System.Data.SqlDbType.Int, 0, global::System.Data.ParameterDirection.Input, 0, 0, "TraceThresholdMask", global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._adapter.InsertCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@TraceOutputOptions", global::System.Data.SqlDbType.Int, 0, global::System.Data.ParameterDirection.Input, 0, 0, "TraceOutputOptions", global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._adapter.UpdateCommand = new global::System.Data.SqlClient.SqlCommand();
            this._adapter.UpdateCommand.Connection = this.Connection;
            this._adapter.UpdateCommand.CommandText = "dbo.UpdateFilter";
            this._adapter.UpdateCommand.CommandType = global::System.Data.CommandType.StoredProcedure;
            this._adapter.UpdateCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@RETURN_VALUE", global::System.Data.SqlDbType.Variant, 0, global::System.Data.ParameterDirection.ReturnValue, 0, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._adapter.UpdateCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@ListenerName", global::System.Data.SqlDbType.NVarChar, 0, global::System.Data.ParameterDirection.Input, 0, 0, "ListenerName", global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._adapter.UpdateCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@TraceThresholdMask", global::System.Data.SqlDbType.Int, 0, global::System.Data.ParameterDirection.Input, 0, 0, "TraceThresholdMask", global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._adapter.UpdateCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@TraceOutputOptions", global::System.Data.SqlDbType.Int, 0, global::System.Data.ParameterDirection.Input, 0, 0, "TraceOutputOptions", global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._adapter.UpdateCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@IsNull_TraceThresholdMask", global::System.Data.SqlDbType.Int, 0, global::System.Data.ParameterDirection.Input, 0, 0, "TraceThresholdMask", global::System.Data.DataRowVersion.Original, true, null, "", "", ""));
            this._adapter.UpdateCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@Original_TraceThresholdMask", global::System.Data.SqlDbType.Int, 0, global::System.Data.ParameterDirection.Input, 0, 0, "TraceThresholdMask", global::System.Data.DataRowVersion.Original, false, null, "", "", ""));
            this._adapter.UpdateCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@IsNull_TraceOutputOptions", global::System.Data.SqlDbType.Int, 0, global::System.Data.ParameterDirection.Input, 0, 0, "TraceOutputOptions", global::System.Data.DataRowVersion.Original, true, null, "", "", ""));
            this._adapter.UpdateCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@Original_TraceOutputOptions", global::System.Data.SqlDbType.Int, 0, global::System.Data.ParameterDirection.Input, 0, 0, "TraceOutputOptions", global::System.Data.DataRowVersion.Original, false, null, "", "", ""));
            this._adapter.UpdateCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@Original_PK_FilterID", global::System.Data.SqlDbType.Int, 0, global::System.Data.ParameterDirection.Input, 0, 0, "PK_FilterID", global::System.Data.DataRowVersion.Original, false, null, "", "", ""));
            this._adapter.UpdateCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@PK_FilterID", global::System.Data.SqlDbType.Int, 4, global::System.Data.ParameterDirection.Input, 0, 0, "PK_FilterID", global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        private void InitConnection() {
            this._connection = new global::System.Data.SqlClient.SqlConnection();
            this._connection.ConnectionString = global::Wgx.Services.Monitoring.Properties.Settings.Default.EventAggregatorConnectionString;
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        private void InitCommandCollection() {
            this._commandCollection = new global::System.Data.SqlClient.SqlCommand[2];
            this._commandCollection[0] = new global::System.Data.SqlClient.SqlCommand();
            this._commandCollection[0].Connection = this.Connection;
            this._commandCollection[0].CommandText = "dbo.SelectFilter";
            this._commandCollection[0].CommandType = global::System.Data.CommandType.StoredProcedure;
            this._commandCollection[0].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@RETURN_VALUE", global::System.Data.SqlDbType.Variant, 0, global::System.Data.ParameterDirection.ReturnValue, 0, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[1] = new global::System.Data.SqlClient.SqlCommand();
            this._commandCollection[1].Connection = this.Connection;
            this._commandCollection[1].CommandText = "SELECT     TraceThresholdMask AS Expr1, ListenerFilter.*\r\nFROM         ListenerFi" +
                "lter\r\nWHERE     (ListenerName = @ListenerName)";
            this._commandCollection[1].CommandType = global::System.Data.CommandType.Text;
            this._commandCollection[1].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@ListenerName", global::System.Data.SqlDbType.NVarChar, 2147483647, global::System.Data.ParameterDirection.Input, 0, 0, "ListenerName", global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Design.HelpKeywordAttribute("vs.data.TableAdapter")]
        [global::System.ComponentModel.DataObjectMethodAttribute(global::System.ComponentModel.DataObjectMethodType.Fill, true)]
        public virtual int Fill(DiagnosticDBDataSet.ListenerFilterDataTable dataTable) {
            this.Adapter.SelectCommand = this.CommandCollection[0];
            if ((this.ClearBeforeFill == true)) {
                dataTable.Clear();
            }
            int returnValue = this.Adapter.Fill(dataTable);
            return returnValue;
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Design.HelpKeywordAttribute("vs.data.TableAdapter")]
        [global::System.ComponentModel.DataObjectMethodAttribute(global::System.ComponentModel.DataObjectMethodType.Select, true)]
        public virtual DiagnosticDBDataSet.ListenerFilterDataTable GetData() {
            this.Adapter.SelectCommand = this.CommandCollection[0];
            DiagnosticDBDataSet.ListenerFilterDataTable dataTable = new DiagnosticDBDataSet.ListenerFilterDataTable();
            this.Adapter.Fill(dataTable);
            return dataTable;
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Design.HelpKeywordAttribute("vs.data.TableAdapter")]
        [global::System.ComponentModel.DataObjectMethodAttribute(global::System.ComponentModel.DataObjectMethodType.Fill, false)]
        public virtual int FillByListenerName(DiagnosticDBDataSet.ListenerFilterDataTable dataTable, string ListenerName) {
            this.Adapter.SelectCommand = this.CommandCollection[1];
            if ((ListenerName == null)) {
                this.Adapter.SelectCommand.Parameters[0].Value = global::System.DBNull.Value;
            }
            else {
                this.Adapter.SelectCommand.Parameters[0].Value = ((string)(ListenerName));
            }
            if ((this.ClearBeforeFill == true)) {
                dataTable.Clear();
            }
            int returnValue = this.Adapter.Fill(dataTable);
            return returnValue;
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Design.HelpKeywordAttribute("vs.data.TableAdapter")]
        [global::System.ComponentModel.DataObjectMethodAttribute(global::System.ComponentModel.DataObjectMethodType.Select, false)]
        public virtual DiagnosticDBDataSet.ListenerFilterDataTable GetDataByListenerName(string ListenerName) {
            this.Adapter.SelectCommand = this.CommandCollection[1];
            if ((ListenerName == null)) {
                this.Adapter.SelectCommand.Parameters[0].Value = global::System.DBNull.Value;
            }
            else {
                this.Adapter.SelectCommand.Parameters[0].Value = ((string)(ListenerName));
            }
            DiagnosticDBDataSet.ListenerFilterDataTable dataTable = new DiagnosticDBDataSet.ListenerFilterDataTable();
            this.Adapter.Fill(dataTable);
            return dataTable;
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Design.HelpKeywordAttribute("vs.data.TableAdapter")]
        public virtual int Update(DiagnosticDBDataSet.ListenerFilterDataTable dataTable) {
            return this.Adapter.Update(dataTable);
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Design.HelpKeywordAttribute("vs.data.TableAdapter")]
        public virtual int Update(DiagnosticDBDataSet dataSet) {
            return this.Adapter.Update(dataSet, "ListenerFilter");
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Design.HelpKeywordAttribute("vs.data.TableAdapter")]
        public virtual int Update(global::System.Data.DataRow dataRow) {
            return this.Adapter.Update(new global::System.Data.DataRow[] {
                        dataRow});
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Design.HelpKeywordAttribute("vs.data.TableAdapter")]
        public virtual int Update(global::System.Data.DataRow[] dataRows) {
            return this.Adapter.Update(dataRows);
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Design.HelpKeywordAttribute("vs.data.TableAdapter")]
        [global::System.ComponentModel.DataObjectMethodAttribute(global::System.ComponentModel.DataObjectMethodType.Delete, true)]
        public virtual int Delete(global::System.Nullable<int> Original_TraceThresholdMask, global::System.Nullable<int> Original_TraceOutputOptions, int Original_PK_FilterID) {
            if ((Original_TraceThresholdMask.HasValue == true)) {
                this.Adapter.DeleteCommand.Parameters[1].Value = ((object)(0));
                this.Adapter.DeleteCommand.Parameters[2].Value = ((int)(Original_TraceThresholdMask.Value));
            }
            else {
                this.Adapter.DeleteCommand.Parameters[1].Value = ((object)(1));
                this.Adapter.DeleteCommand.Parameters[2].Value = global::System.DBNull.Value;
            }
            if ((Original_TraceOutputOptions.HasValue == true)) {
                this.Adapter.DeleteCommand.Parameters[3].Value = ((object)(0));
                this.Adapter.DeleteCommand.Parameters[4].Value = ((int)(Original_TraceOutputOptions.Value));
            }
            else {
                this.Adapter.DeleteCommand.Parameters[3].Value = ((object)(1));
                this.Adapter.DeleteCommand.Parameters[4].Value = global::System.DBNull.Value;
            }
            this.Adapter.DeleteCommand.Parameters[5].Value = ((int)(Original_PK_FilterID));
            global::System.Data.ConnectionState previousConnectionState = this.Adapter.DeleteCommand.Connection.State;
            if (((this.Adapter.DeleteCommand.Connection.State & global::System.Data.ConnectionState.Open) 
                        != global::System.Data.ConnectionState.Open)) {
                this.Adapter.DeleteCommand.Connection.Open();
            }
            try {
                int returnValue = this.Adapter.DeleteCommand.ExecuteNonQuery();
                return returnValue;
            }
            finally {
                if ((previousConnectionState == global::System.Data.ConnectionState.Closed)) {
                    this.Adapter.DeleteCommand.Connection.Close();
                }
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Design.HelpKeywordAttribute("vs.data.TableAdapter")]
        [global::System.ComponentModel.DataObjectMethodAttribute(global::System.ComponentModel.DataObjectMethodType.Insert, true)]
        public virtual int Insert(string ListenerName, global::System.Nullable<int> TraceThresholdMask, global::System.Nullable<int> TraceOutputOptions) {
            if ((ListenerName == null)) {
                this.Adapter.InsertCommand.Parameters[1].Value = global::System.DBNull.Value;
            }
            else {
                this.Adapter.InsertCommand.Parameters[1].Value = ((string)(ListenerName));
            }
            if ((TraceThresholdMask.HasValue == true)) {
                this.Adapter.InsertCommand.Parameters[2].Value = ((int)(TraceThresholdMask.Value));
            }
            else {
                this.Adapter.InsertCommand.Parameters[2].Value = global::System.DBNull.Value;
            }
            if ((TraceOutputOptions.HasValue == true)) {
                this.Adapter.InsertCommand.Parameters[3].Value = ((int)(TraceOutputOptions.Value));
            }
            else {
                this.Adapter.InsertCommand.Parameters[3].Value = global::System.DBNull.Value;
            }
            global::System.Data.ConnectionState previousConnectionState = this.Adapter.InsertCommand.Connection.State;
            if (((this.Adapter.InsertCommand.Connection.State & global::System.Data.ConnectionState.Open) 
                        != global::System.Data.ConnectionState.Open)) {
                this.Adapter.InsertCommand.Connection.Open();
            }
            try {
                int returnValue = this.Adapter.InsertCommand.ExecuteNonQuery();
                return returnValue;
            }
            finally {
                if ((previousConnectionState == global::System.Data.ConnectionState.Closed)) {
                    this.Adapter.InsertCommand.Connection.Close();
                }
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Design.HelpKeywordAttribute("vs.data.TableAdapter")]
        [global::System.ComponentModel.DataObjectMethodAttribute(global::System.ComponentModel.DataObjectMethodType.Update, true)]
        public virtual int Update(string ListenerName, global::System.Nullable<int> TraceThresholdMask, global::System.Nullable<int> TraceOutputOptions, global::System.Nullable<int> Original_TraceThresholdMask, global::System.Nullable<int> Original_TraceOutputOptions, int Original_PK_FilterID, int PK_FilterID) {
            if ((ListenerName == null)) {
                this.Adapter.UpdateCommand.Parameters[1].Value = global::System.DBNull.Value;
            }
            else {
                this.Adapter.UpdateCommand.Parameters[1].Value = ((string)(ListenerName));
            }
            if ((TraceThresholdMask.HasValue == true)) {
                this.Adapter.UpdateCommand.Parameters[2].Value = ((int)(TraceThresholdMask.Value));
            }
            else {
                this.Adapter.UpdateCommand.Parameters[2].Value = global::System.DBNull.Value;
            }
            if ((TraceOutputOptions.HasValue == true)) {
                this.Adapter.UpdateCommand.Parameters[3].Value = ((int)(TraceOutputOptions.Value));
            }
            else {
                this.Adapter.UpdateCommand.Parameters[3].Value = global::System.DBNull.Value;
            }
            if ((Original_TraceThresholdMask.HasValue == true)) {
                this.Adapter.UpdateCommand.Parameters[4].Value = ((object)(0));
                this.Adapter.UpdateCommand.Parameters[5].Value = ((int)(Original_TraceThresholdMask.Value));
            }
            else {
                this.Adapter.UpdateCommand.Parameters[4].Value = ((object)(1));
                this.Adapter.UpdateCommand.Parameters[5].Value = global::System.DBNull.Value;
            }
            if ((Original_TraceOutputOptions.HasValue == true)) {
                this.Adapter.UpdateCommand.Parameters[6].Value = ((object)(0));
                this.Adapter.UpdateCommand.Parameters[7].Value = ((int)(Original_TraceOutputOptions.Value));
            }
            else {
                this.Adapter.UpdateCommand.Parameters[6].Value = ((object)(1));
                this.Adapter.UpdateCommand.Parameters[7].Value = global::System.DBNull.Value;
            }
            this.Adapter.UpdateCommand.Parameters[8].Value = ((int)(Original_PK_FilterID));
            this.Adapter.UpdateCommand.Parameters[9].Value = ((int)(PK_FilterID));
            global::System.Data.ConnectionState previousConnectionState = this.Adapter.UpdateCommand.Connection.State;
            if (((this.Adapter.UpdateCommand.Connection.State & global::System.Data.ConnectionState.Open) 
                        != global::System.Data.ConnectionState.Open)) {
                this.Adapter.UpdateCommand.Connection.Open();
            }
            try {
                int returnValue = this.Adapter.UpdateCommand.ExecuteNonQuery();
                return returnValue;
            }
            finally {
                if ((previousConnectionState == global::System.Data.ConnectionState.Closed)) {
                    this.Adapter.UpdateCommand.Connection.Close();
                }
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Design.HelpKeywordAttribute("vs.data.TableAdapter")]
        [global::System.ComponentModel.DataObjectMethodAttribute(global::System.ComponentModel.DataObjectMethodType.Update, true)]
        public virtual int Update(string ListenerName, global::System.Nullable<int> TraceThresholdMask, global::System.Nullable<int> TraceOutputOptions, global::System.Nullable<int> Original_TraceThresholdMask, global::System.Nullable<int> Original_TraceOutputOptions, int Original_PK_FilterID) {
            return this.Update(ListenerName, TraceThresholdMask, TraceOutputOptions, Original_TraceThresholdMask, Original_TraceOutputOptions, Original_PK_FilterID, Original_PK_FilterID);
        }
    }
    
    /// <summary>
    ///Represents the connection and commands used to retrieve and save data.
    ///</summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Data.Design.TypedDataSetGenerator", "2.0.0.0")]
    [global::System.ComponentModel.DesignerCategoryAttribute("code")]
    [global::System.ComponentModel.ToolboxItem(true)]
    [global::System.ComponentModel.DataObjectAttribute(true)]
    [global::System.ComponentModel.DesignerAttribute("Microsoft.VSDesigner.DataSource.Design.TableAdapterDesigner, Microsoft.VSDesigner" +
        ", Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
    [global::System.ComponentModel.Design.HelpKeywordAttribute("vs.data.TableAdapter")]
    public partial class TraceConfigurationSettingsTableAdapter : global::System.ComponentModel.Component {
        
        private global::System.Data.SqlClient.SqlDataAdapter _adapter;
        
        private global::System.Data.SqlClient.SqlConnection _connection;
        
        private global::System.Data.SqlClient.SqlTransaction _transaction;
        
        private global::System.Data.SqlClient.SqlCommand[] _commandCollection;
        
        private bool _clearBeforeFill;
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public TraceConfigurationSettingsTableAdapter() {
            this.ClearBeforeFill = true;
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        protected internal global::System.Data.SqlClient.SqlDataAdapter Adapter {
            get {
                if ((this._adapter == null)) {
                    this.InitAdapter();
                }
                return this._adapter;
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        internal global::System.Data.SqlClient.SqlConnection Connection {
            get {
                if ((this._connection == null)) {
                    this.InitConnection();
                }
                return this._connection;
            }
            set {
                this._connection = value;
                if ((this.Adapter.InsertCommand != null)) {
                    this.Adapter.InsertCommand.Connection = value;
                }
                if ((this.Adapter.DeleteCommand != null)) {
                    this.Adapter.DeleteCommand.Connection = value;
                }
                if ((this.Adapter.UpdateCommand != null)) {
                    this.Adapter.UpdateCommand.Connection = value;
                }
                for (int i = 0; (i < this.CommandCollection.Length); i = (i + 1)) {
                    if ((this.CommandCollection[i] != null)) {
                        ((global::System.Data.SqlClient.SqlCommand)(this.CommandCollection[i])).Connection = value;
                    }
                }
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        internal global::System.Data.SqlClient.SqlTransaction Transaction {
            get {
                return this._transaction;
            }
            set {
                this._transaction = value;
                for (int i = 0; (i < this.CommandCollection.Length); i = (i + 1)) {
                    this.CommandCollection[i].Transaction = this._transaction;
                }
                if (((this.Adapter != null) 
                            && (this.Adapter.DeleteCommand != null))) {
                    this.Adapter.DeleteCommand.Transaction = this._transaction;
                }
                if (((this.Adapter != null) 
                            && (this.Adapter.InsertCommand != null))) {
                    this.Adapter.InsertCommand.Transaction = this._transaction;
                }
                if (((this.Adapter != null) 
                            && (this.Adapter.UpdateCommand != null))) {
                    this.Adapter.UpdateCommand.Transaction = this._transaction;
                }
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        protected global::System.Data.SqlClient.SqlCommand[] CommandCollection {
            get {
                if ((this._commandCollection == null)) {
                    this.InitCommandCollection();
                }
                return this._commandCollection;
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public bool ClearBeforeFill {
            get {
                return this._clearBeforeFill;
            }
            set {
                this._clearBeforeFill = value;
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        private void InitAdapter() {
            this._adapter = new global::System.Data.SqlClient.SqlDataAdapter();
            global::System.Data.Common.DataTableMapping tableMapping = new global::System.Data.Common.DataTableMapping();
            tableMapping.SourceTable = "Table";
            tableMapping.DataSetTable = "TraceConfigurationSettings";
            tableMapping.ColumnMappings.Add("SwitchValue", "SwitchValue");
            tableMapping.ColumnMappings.Add("UpdateInterval", "UpdateInterval");
            tableMapping.ColumnMappings.Add("SwitchName", "SwitchName");
            tableMapping.ColumnMappings.Add("TraceOutputOptions", "TraceOutputOptions");
            tableMapping.ColumnMappings.Add("PK_TraceConfigSettings", "PK_TraceConfigSettings");
            this._adapter.TableMappings.Add(tableMapping);
            this._adapter.DeleteCommand = new global::System.Data.SqlClient.SqlCommand();
            this._adapter.DeleteCommand.Connection = this.Connection;
            this._adapter.DeleteCommand.CommandText = "dbo.DeleteTraceConfigurationSettings";
            this._adapter.DeleteCommand.CommandType = global::System.Data.CommandType.StoredProcedure;
            this._adapter.DeleteCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@RETURN_VALUE", global::System.Data.SqlDbType.Variant, 0, global::System.Data.ParameterDirection.ReturnValue, 0, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._adapter.DeleteCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@IsNull_SwitchValue", global::System.Data.SqlDbType.Int, 0, global::System.Data.ParameterDirection.Input, 0, 0, "SwitchValue", global::System.Data.DataRowVersion.Original, true, null, "", "", ""));
            this._adapter.DeleteCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@Original_SwitchValue", global::System.Data.SqlDbType.Int, 0, global::System.Data.ParameterDirection.Input, 0, 0, "SwitchValue", global::System.Data.DataRowVersion.Original, false, null, "", "", ""));
            this._adapter.DeleteCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@IsNull_UpdateInterval", global::System.Data.SqlDbType.Int, 0, global::System.Data.ParameterDirection.Input, 0, 0, "UpdateInterval", global::System.Data.DataRowVersion.Original, true, null, "", "", ""));
            this._adapter.DeleteCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@Original_UpdateInterval", global::System.Data.SqlDbType.Int, 0, global::System.Data.ParameterDirection.Input, 0, 0, "UpdateInterval", global::System.Data.DataRowVersion.Original, false, null, "", "", ""));
            this._adapter.DeleteCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@IsNull_TraceOutputOptions", global::System.Data.SqlDbType.Int, 0, global::System.Data.ParameterDirection.Input, 0, 0, "TraceOutputOptions", global::System.Data.DataRowVersion.Original, true, null, "", "", ""));
            this._adapter.DeleteCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@Original_TraceOutputOptions", global::System.Data.SqlDbType.Int, 0, global::System.Data.ParameterDirection.Input, 0, 0, "TraceOutputOptions", global::System.Data.DataRowVersion.Original, false, null, "", "", ""));
            this._adapter.DeleteCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@Original_PK_TraceConfigSettings", global::System.Data.SqlDbType.Int, 0, global::System.Data.ParameterDirection.Input, 0, 0, "PK_TraceConfigSettings", global::System.Data.DataRowVersion.Original, false, null, "", "", ""));
            this._adapter.InsertCommand = new global::System.Data.SqlClient.SqlCommand();
            this._adapter.InsertCommand.Connection = this.Connection;
            this._adapter.InsertCommand.CommandText = "dbo.InsertTraceConfigurationSettings";
            this._adapter.InsertCommand.CommandType = global::System.Data.CommandType.StoredProcedure;
            this._adapter.InsertCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@RETURN_VALUE", global::System.Data.SqlDbType.Variant, 0, global::System.Data.ParameterDirection.ReturnValue, 0, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._adapter.InsertCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@SwitchValue", global::System.Data.SqlDbType.Int, 0, global::System.Data.ParameterDirection.Input, 0, 0, "SwitchValue", global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._adapter.InsertCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@UpdateInterval", global::System.Data.SqlDbType.Int, 0, global::System.Data.ParameterDirection.Input, 0, 0, "UpdateInterval", global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._adapter.InsertCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@SwitchName", global::System.Data.SqlDbType.NVarChar, 0, global::System.Data.ParameterDirection.Input, 0, 0, "SwitchName", global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._adapter.InsertCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@TraceOutputOptions", global::System.Data.SqlDbType.Int, 0, global::System.Data.ParameterDirection.Input, 0, 0, "TraceOutputOptions", global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._adapter.UpdateCommand = new global::System.Data.SqlClient.SqlCommand();
            this._adapter.UpdateCommand.Connection = this.Connection;
            this._adapter.UpdateCommand.CommandText = "dbo.UpdateTraceConfigurationSettings";
            this._adapter.UpdateCommand.CommandType = global::System.Data.CommandType.StoredProcedure;
            this._adapter.UpdateCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@RETURN_VALUE", global::System.Data.SqlDbType.Variant, 0, global::System.Data.ParameterDirection.ReturnValue, 0, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._adapter.UpdateCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@SwitchValue", global::System.Data.SqlDbType.Int, 0, global::System.Data.ParameterDirection.Input, 0, 0, "SwitchValue", global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._adapter.UpdateCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@UpdateInterval", global::System.Data.SqlDbType.Int, 0, global::System.Data.ParameterDirection.Input, 0, 0, "UpdateInterval", global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._adapter.UpdateCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@SwitchName", global::System.Data.SqlDbType.NVarChar, 0, global::System.Data.ParameterDirection.Input, 0, 0, "SwitchName", global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._adapter.UpdateCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@TraceOutputOptions", global::System.Data.SqlDbType.Int, 0, global::System.Data.ParameterDirection.Input, 0, 0, "TraceOutputOptions", global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._adapter.UpdateCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@IsNull_SwitchValue", global::System.Data.SqlDbType.Int, 0, global::System.Data.ParameterDirection.Input, 0, 0, "SwitchValue", global::System.Data.DataRowVersion.Original, true, null, "", "", ""));
            this._adapter.UpdateCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@Original_SwitchValue", global::System.Data.SqlDbType.Int, 0, global::System.Data.ParameterDirection.Input, 0, 0, "SwitchValue", global::System.Data.DataRowVersion.Original, false, null, "", "", ""));
            this._adapter.UpdateCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@IsNull_UpdateInterval", global::System.Data.SqlDbType.Int, 0, global::System.Data.ParameterDirection.Input, 0, 0, "UpdateInterval", global::System.Data.DataRowVersion.Original, true, null, "", "", ""));
            this._adapter.UpdateCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@Original_UpdateInterval", global::System.Data.SqlDbType.Int, 0, global::System.Data.ParameterDirection.Input, 0, 0, "UpdateInterval", global::System.Data.DataRowVersion.Original, false, null, "", "", ""));
            this._adapter.UpdateCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@IsNull_TraceOutputOptions", global::System.Data.SqlDbType.Int, 0, global::System.Data.ParameterDirection.Input, 0, 0, "TraceOutputOptions", global::System.Data.DataRowVersion.Original, true, null, "", "", ""));
            this._adapter.UpdateCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@Original_TraceOutputOptions", global::System.Data.SqlDbType.Int, 0, global::System.Data.ParameterDirection.Input, 0, 0, "TraceOutputOptions", global::System.Data.DataRowVersion.Original, false, null, "", "", ""));
            this._adapter.UpdateCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@Original_PK_TraceConfigSettings", global::System.Data.SqlDbType.Int, 0, global::System.Data.ParameterDirection.Input, 0, 0, "PK_TraceConfigSettings", global::System.Data.DataRowVersion.Original, false, null, "", "", ""));
            this._adapter.UpdateCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@PK_TraceConfigSettings", global::System.Data.SqlDbType.Int, 4, global::System.Data.ParameterDirection.Input, 0, 0, "PK_TraceConfigSettings", global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        private void InitConnection() {
            this._connection = new global::System.Data.SqlClient.SqlConnection();
            this._connection.ConnectionString = global::Wgx.Services.Monitoring.Properties.Settings.Default.EventAggregatorConnectionString;
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        private void InitCommandCollection() {
            this._commandCollection = new global::System.Data.SqlClient.SqlCommand[1];
            this._commandCollection[0] = new global::System.Data.SqlClient.SqlCommand();
            this._commandCollection[0].Connection = this.Connection;
            this._commandCollection[0].CommandText = "dbo.SelectTraceConfigurationSettings";
            this._commandCollection[0].CommandType = global::System.Data.CommandType.StoredProcedure;
            this._commandCollection[0].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@RETURN_VALUE", global::System.Data.SqlDbType.Variant, 0, global::System.Data.ParameterDirection.ReturnValue, 0, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Design.HelpKeywordAttribute("vs.data.TableAdapter")]
        [global::System.ComponentModel.DataObjectMethodAttribute(global::System.ComponentModel.DataObjectMethodType.Fill, true)]
        public virtual int Fill(DiagnosticDBDataSet.TraceConfigurationSettingsDataTable dataTable) {
            this.Adapter.SelectCommand = this.CommandCollection[0];
            if ((this.ClearBeforeFill == true)) {
                dataTable.Clear();
            }
            int returnValue = this.Adapter.Fill(dataTable);
            return returnValue;
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Design.HelpKeywordAttribute("vs.data.TableAdapter")]
        [global::System.ComponentModel.DataObjectMethodAttribute(global::System.ComponentModel.DataObjectMethodType.Select, true)]
        public virtual DiagnosticDBDataSet.TraceConfigurationSettingsDataTable GetData() {
            this.Adapter.SelectCommand = this.CommandCollection[0];
            DiagnosticDBDataSet.TraceConfigurationSettingsDataTable dataTable = new DiagnosticDBDataSet.TraceConfigurationSettingsDataTable();
            this.Adapter.Fill(dataTable);
            return dataTable;
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Design.HelpKeywordAttribute("vs.data.TableAdapter")]
        public virtual int Update(DiagnosticDBDataSet.TraceConfigurationSettingsDataTable dataTable) {
            return this.Adapter.Update(dataTable);
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Design.HelpKeywordAttribute("vs.data.TableAdapter")]
        public virtual int Update(DiagnosticDBDataSet dataSet) {
            return this.Adapter.Update(dataSet, "TraceConfigurationSettings");
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Design.HelpKeywordAttribute("vs.data.TableAdapter")]
        public virtual int Update(global::System.Data.DataRow dataRow) {
            return this.Adapter.Update(new global::System.Data.DataRow[] {
                        dataRow});
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Design.HelpKeywordAttribute("vs.data.TableAdapter")]
        public virtual int Update(global::System.Data.DataRow[] dataRows) {
            return this.Adapter.Update(dataRows);
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Design.HelpKeywordAttribute("vs.data.TableAdapter")]
        [global::System.ComponentModel.DataObjectMethodAttribute(global::System.ComponentModel.DataObjectMethodType.Delete, true)]
        public virtual int Delete(global::System.Nullable<int> Original_SwitchValue, global::System.Nullable<int> Original_UpdateInterval, global::System.Nullable<int> Original_TraceOutputOptions, int Original_PK_TraceConfigSettings) {
            if ((Original_SwitchValue.HasValue == true)) {
                this.Adapter.DeleteCommand.Parameters[1].Value = ((object)(0));
                this.Adapter.DeleteCommand.Parameters[2].Value = ((int)(Original_SwitchValue.Value));
            }
            else {
                this.Adapter.DeleteCommand.Parameters[1].Value = ((object)(1));
                this.Adapter.DeleteCommand.Parameters[2].Value = global::System.DBNull.Value;
            }
            if ((Original_UpdateInterval.HasValue == true)) {
                this.Adapter.DeleteCommand.Parameters[3].Value = ((object)(0));
                this.Adapter.DeleteCommand.Parameters[4].Value = ((int)(Original_UpdateInterval.Value));
            }
            else {
                this.Adapter.DeleteCommand.Parameters[3].Value = ((object)(1));
                this.Adapter.DeleteCommand.Parameters[4].Value = global::System.DBNull.Value;
            }
            if ((Original_TraceOutputOptions.HasValue == true)) {
                this.Adapter.DeleteCommand.Parameters[5].Value = ((object)(0));
                this.Adapter.DeleteCommand.Parameters[6].Value = ((int)(Original_TraceOutputOptions.Value));
            }
            else {
                this.Adapter.DeleteCommand.Parameters[5].Value = ((object)(1));
                this.Adapter.DeleteCommand.Parameters[6].Value = global::System.DBNull.Value;
            }
            this.Adapter.DeleteCommand.Parameters[7].Value = ((int)(Original_PK_TraceConfigSettings));
            global::System.Data.ConnectionState previousConnectionState = this.Adapter.DeleteCommand.Connection.State;
            if (((this.Adapter.DeleteCommand.Connection.State & global::System.Data.ConnectionState.Open) 
                        != global::System.Data.ConnectionState.Open)) {
                this.Adapter.DeleteCommand.Connection.Open();
            }
            try {
                int returnValue = this.Adapter.DeleteCommand.ExecuteNonQuery();
                return returnValue;
            }
            finally {
                if ((previousConnectionState == global::System.Data.ConnectionState.Closed)) {
                    this.Adapter.DeleteCommand.Connection.Close();
                }
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Design.HelpKeywordAttribute("vs.data.TableAdapter")]
        [global::System.ComponentModel.DataObjectMethodAttribute(global::System.ComponentModel.DataObjectMethodType.Insert, true)]
        public virtual int Insert(global::System.Nullable<int> SwitchValue, global::System.Nullable<int> UpdateInterval, string SwitchName, global::System.Nullable<int> TraceOutputOptions) {
            if ((SwitchValue.HasValue == true)) {
                this.Adapter.InsertCommand.Parameters[1].Value = ((int)(SwitchValue.Value));
            }
            else {
                this.Adapter.InsertCommand.Parameters[1].Value = global::System.DBNull.Value;
            }
            if ((UpdateInterval.HasValue == true)) {
                this.Adapter.InsertCommand.Parameters[2].Value = ((int)(UpdateInterval.Value));
            }
            else {
                this.Adapter.InsertCommand.Parameters[2].Value = global::System.DBNull.Value;
            }
            if ((SwitchName == null)) {
                this.Adapter.InsertCommand.Parameters[3].Value = global::System.DBNull.Value;
            }
            else {
                this.Adapter.InsertCommand.Parameters[3].Value = ((string)(SwitchName));
            }
            if ((TraceOutputOptions.HasValue == true)) {
                this.Adapter.InsertCommand.Parameters[4].Value = ((int)(TraceOutputOptions.Value));
            }
            else {
                this.Adapter.InsertCommand.Parameters[4].Value = global::System.DBNull.Value;
            }
            global::System.Data.ConnectionState previousConnectionState = this.Adapter.InsertCommand.Connection.State;
            if (((this.Adapter.InsertCommand.Connection.State & global::System.Data.ConnectionState.Open) 
                        != global::System.Data.ConnectionState.Open)) {
                this.Adapter.InsertCommand.Connection.Open();
            }
            try {
                int returnValue = this.Adapter.InsertCommand.ExecuteNonQuery();
                return returnValue;
            }
            finally {
                if ((previousConnectionState == global::System.Data.ConnectionState.Closed)) {
                    this.Adapter.InsertCommand.Connection.Close();
                }
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Design.HelpKeywordAttribute("vs.data.TableAdapter")]
        [global::System.ComponentModel.DataObjectMethodAttribute(global::System.ComponentModel.DataObjectMethodType.Update, true)]
        public virtual int Update(global::System.Nullable<int> SwitchValue, global::System.Nullable<int> UpdateInterval, string SwitchName, global::System.Nullable<int> TraceOutputOptions, global::System.Nullable<int> Original_SwitchValue, global::System.Nullable<int> Original_UpdateInterval, global::System.Nullable<int> Original_TraceOutputOptions, int Original_PK_TraceConfigSettings, int PK_TraceConfigSettings) {
            if ((SwitchValue.HasValue == true)) {
                this.Adapter.UpdateCommand.Parameters[1].Value = ((int)(SwitchValue.Value));
            }
            else {
                this.Adapter.UpdateCommand.Parameters[1].Value = global::System.DBNull.Value;
            }
            if ((UpdateInterval.HasValue == true)) {
                this.Adapter.UpdateCommand.Parameters[2].Value = ((int)(UpdateInterval.Value));
            }
            else {
                this.Adapter.UpdateCommand.Parameters[2].Value = global::System.DBNull.Value;
            }
            if ((SwitchName == null)) {
                this.Adapter.UpdateCommand.Parameters[3].Value = global::System.DBNull.Value;
            }
            else {
                this.Adapter.UpdateCommand.Parameters[3].Value = ((string)(SwitchName));
            }
            if ((TraceOutputOptions.HasValue == true)) {
                this.Adapter.UpdateCommand.Parameters[4].Value = ((int)(TraceOutputOptions.Value));
            }
            else {
                this.Adapter.UpdateCommand.Parameters[4].Value = global::System.DBNull.Value;
            }
            if ((Original_SwitchValue.HasValue == true)) {
                this.Adapter.UpdateCommand.Parameters[5].Value = ((object)(0));
                this.Adapter.UpdateCommand.Parameters[6].Value = ((int)(Original_SwitchValue.Value));
            }
            else {
                this.Adapter.UpdateCommand.Parameters[5].Value = ((object)(1));
                this.Adapter.UpdateCommand.Parameters[6].Value = global::System.DBNull.Value;
            }
            if ((Original_UpdateInterval.HasValue == true)) {
                this.Adapter.UpdateCommand.Parameters[7].Value = ((object)(0));
                this.Adapter.UpdateCommand.Parameters[8].Value = ((int)(Original_UpdateInterval.Value));
            }
            else {
                this.Adapter.UpdateCommand.Parameters[7].Value = ((object)(1));
                this.Adapter.UpdateCommand.Parameters[8].Value = global::System.DBNull.Value;
            }
            if ((Original_TraceOutputOptions.HasValue == true)) {
                this.Adapter.UpdateCommand.Parameters[9].Value = ((object)(0));
                this.Adapter.UpdateCommand.Parameters[10].Value = ((int)(Original_TraceOutputOptions.Value));
            }
            else {
                this.Adapter.UpdateCommand.Parameters[9].Value = ((object)(1));
                this.Adapter.UpdateCommand.Parameters[10].Value = global::System.DBNull.Value;
            }
            this.Adapter.UpdateCommand.Parameters[11].Value = ((int)(Original_PK_TraceConfigSettings));
            this.Adapter.UpdateCommand.Parameters[12].Value = ((int)(PK_TraceConfigSettings));
            global::System.Data.ConnectionState previousConnectionState = this.Adapter.UpdateCommand.Connection.State;
            if (((this.Adapter.UpdateCommand.Connection.State & global::System.Data.ConnectionState.Open) 
                        != global::System.Data.ConnectionState.Open)) {
                this.Adapter.UpdateCommand.Connection.Open();
            }
            try {
                int returnValue = this.Adapter.UpdateCommand.ExecuteNonQuery();
                return returnValue;
            }
            finally {
                if ((previousConnectionState == global::System.Data.ConnectionState.Closed)) {
                    this.Adapter.UpdateCommand.Connection.Close();
                }
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Design.HelpKeywordAttribute("vs.data.TableAdapter")]
        [global::System.ComponentModel.DataObjectMethodAttribute(global::System.ComponentModel.DataObjectMethodType.Update, true)]
        public virtual int Update(global::System.Nullable<int> SwitchValue, global::System.Nullable<int> UpdateInterval, string SwitchName, global::System.Nullable<int> TraceOutputOptions, global::System.Nullable<int> Original_SwitchValue, global::System.Nullable<int> Original_UpdateInterval, global::System.Nullable<int> Original_TraceOutputOptions, int Original_PK_TraceConfigSettings) {
            return this.Update(SwitchValue, UpdateInterval, SwitchName, TraceOutputOptions, Original_SwitchValue, Original_UpdateInterval, Original_TraceOutputOptions, Original_PK_TraceConfigSettings, Original_PK_TraceConfigSettings);
        }
    }
    
    /// <summary>
    ///Represents the connection and commands used to retrieve and save data.
    ///</summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Data.Design.TypedDataSetGenerator", "2.0.0.0")]
    [global::System.ComponentModel.DesignerCategoryAttribute("code")]
    [global::System.ComponentModel.ToolboxItem(true)]
    [global::System.ComponentModel.DataObjectAttribute(true)]
    [global::System.ComponentModel.DesignerAttribute("Microsoft.VSDesigner.DataSource.Design.TableAdapterDesigner, Microsoft.VSDesigner" +
        ", Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
    [global::System.ComponentModel.Design.HelpKeywordAttribute("vs.data.TableAdapter")]
    public partial class EventsXmlTableAdapter : global::System.ComponentModel.Component {
        
        private global::System.Data.SqlClient.SqlDataAdapter _adapter;
        
        private global::System.Data.SqlClient.SqlConnection _connection;
        
        private global::System.Data.SqlClient.SqlTransaction _transaction;
        
        private global::System.Data.SqlClient.SqlCommand[] _commandCollection;
        
        private bool _clearBeforeFill;
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public EventsXmlTableAdapter() {
            this.ClearBeforeFill = true;
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        protected internal global::System.Data.SqlClient.SqlDataAdapter Adapter {
            get {
                if ((this._adapter == null)) {
                    this.InitAdapter();
                }
                return this._adapter;
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        internal global::System.Data.SqlClient.SqlConnection Connection {
            get {
                if ((this._connection == null)) {
                    this.InitConnection();
                }
                return this._connection;
            }
            set {
                this._connection = value;
                if ((this.Adapter.InsertCommand != null)) {
                    this.Adapter.InsertCommand.Connection = value;
                }
                if ((this.Adapter.DeleteCommand != null)) {
                    this.Adapter.DeleteCommand.Connection = value;
                }
                if ((this.Adapter.UpdateCommand != null)) {
                    this.Adapter.UpdateCommand.Connection = value;
                }
                for (int i = 0; (i < this.CommandCollection.Length); i = (i + 1)) {
                    if ((this.CommandCollection[i] != null)) {
                        ((global::System.Data.SqlClient.SqlCommand)(this.CommandCollection[i])).Connection = value;
                    }
                }
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        internal global::System.Data.SqlClient.SqlTransaction Transaction {
            get {
                return this._transaction;
            }
            set {
                this._transaction = value;
                for (int i = 0; (i < this.CommandCollection.Length); i = (i + 1)) {
                    this.CommandCollection[i].Transaction = this._transaction;
                }
                if (((this.Adapter != null) 
                            && (this.Adapter.DeleteCommand != null))) {
                    this.Adapter.DeleteCommand.Transaction = this._transaction;
                }
                if (((this.Adapter != null) 
                            && (this.Adapter.InsertCommand != null))) {
                    this.Adapter.InsertCommand.Transaction = this._transaction;
                }
                if (((this.Adapter != null) 
                            && (this.Adapter.UpdateCommand != null))) {
                    this.Adapter.UpdateCommand.Transaction = this._transaction;
                }
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        protected global::System.Data.SqlClient.SqlCommand[] CommandCollection {
            get {
                if ((this._commandCollection == null)) {
                    this.InitCommandCollection();
                }
                return this._commandCollection;
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public bool ClearBeforeFill {
            get {
                return this._clearBeforeFill;
            }
            set {
                this._clearBeforeFill = value;
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        private void InitAdapter() {
            this._adapter = new global::System.Data.SqlClient.SqlDataAdapter();
            global::System.Data.Common.DataTableMapping tableMapping = new global::System.Data.Common.DataTableMapping();
            tableMapping.SourceTable = "Table";
            tableMapping.DataSetTable = "EventsXml";
            tableMapping.ColumnMappings.Add("PK_Events", "PK_Events");
            tableMapping.ColumnMappings.Add("EventData", "EventData");
            tableMapping.ColumnMappings.Add("RowNumber", "RowNumber");
            this._adapter.TableMappings.Add(tableMapping);
            this._adapter.DeleteCommand = new global::System.Data.SqlClient.SqlCommand();
            this._adapter.DeleteCommand.Connection = this.Connection;
            this._adapter.DeleteCommand.CommandText = "DELETE FROM [EventsXml] WHERE (([PK_Events] = @Original_PK_Events))";
            this._adapter.DeleteCommand.CommandType = global::System.Data.CommandType.Text;
            this._adapter.DeleteCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@Original_PK_Events", global::System.Data.SqlDbType.Int, 0, global::System.Data.ParameterDirection.Input, 0, 0, "PK_Events", global::System.Data.DataRowVersion.Original, false, null, "", "", ""));
            this._adapter.InsertCommand = new global::System.Data.SqlClient.SqlCommand();
            this._adapter.InsertCommand.Connection = this.Connection;
            this._adapter.InsertCommand.CommandText = "INSERT INTO [EventsXml] ([EventData]) VALUES (@EventData);\r\nSELECT PK_Events, Eve" +
                "ntData FROM EventsXml WHERE (PK_Events = SCOPE_IDENTITY())";
            this._adapter.InsertCommand.CommandType = global::System.Data.CommandType.Text;
            this._adapter.InsertCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@EventData", global::System.Data.SqlDbType.Xml, 0, global::System.Data.ParameterDirection.Input, 0, 0, "EventData", global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        private void InitConnection() {
            this._connection = new global::System.Data.SqlClient.SqlConnection();
            this._connection.ConnectionString = global::Wgx.Services.Monitoring.Properties.Settings.Default.EventAggregatorConnectionString;
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        private void InitCommandCollection() {
            this._commandCollection = new global::System.Data.SqlClient.SqlCommand[3];
            this._commandCollection[0] = new global::System.Data.SqlClient.SqlCommand();
            this._commandCollection[0].Connection = this.Connection;
            this._commandCollection[0].CommandText = "SELECT     EventsXml.*\r\nFROM         EventsXml";
            this._commandCollection[0].CommandType = global::System.Data.CommandType.Text;
            this._commandCollection[1] = new global::System.Data.SqlClient.SqlCommand();
            this._commandCollection[1].Connection = this.Connection;
            this._commandCollection[1].CommandText = "dbo.GetFilteredEvents";
            this._commandCollection[1].CommandType = global::System.Data.CommandType.StoredProcedure;
            this._commandCollection[1].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@RETURN_VALUE", global::System.Data.SqlDbType.Int, 4, global::System.Data.ParameterDirection.ReturnValue, 10, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[1].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@sDate", global::System.Data.SqlDbType.NVarChar, 100, global::System.Data.ParameterDirection.Input, 0, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[1].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@eDate", global::System.Data.SqlDbType.NVarChar, 100, global::System.Data.ParameterDirection.Input, 0, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[1].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@MachineName", global::System.Data.SqlDbType.NVarChar, 2147483647, global::System.Data.ParameterDirection.Input, 0, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[1].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@MachineOp", global::System.Data.SqlDbType.Int, 4, global::System.Data.ParameterDirection.Input, 10, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[1].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@SourceName", global::System.Data.SqlDbType.NVarChar, 2147483647, global::System.Data.ParameterDirection.Input, 0, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[1].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@SourceNameOp", global::System.Data.SqlDbType.Int, 4, global::System.Data.ParameterDirection.Input, 10, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[1].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@EventType", global::System.Data.SqlDbType.NVarChar, 2147483647, global::System.Data.ParameterDirection.Input, 0, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[1].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@MessageId", global::System.Data.SqlDbType.Int, 4, global::System.Data.ParameterDirection.Input, 10, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[1].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@MessageIdOp", global::System.Data.SqlDbType.Int, 4, global::System.Data.ParameterDirection.Input, 10, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[1].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@PageNum", global::System.Data.SqlDbType.Int, 4, global::System.Data.ParameterDirection.Input, 10, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[1].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@PageSize", global::System.Data.SqlDbType.Int, 4, global::System.Data.ParameterDirection.Input, 10, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[1].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@RowCountOnly", global::System.Data.SqlDbType.Int, 4, global::System.Data.ParameterDirection.Input, 10, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[2] = new global::System.Data.SqlClient.SqlCommand();
            this._commandCollection[2].Connection = this.Connection;
            this._commandCollection[2].CommandText = "dbo.GetFilteredEvents";
            this._commandCollection[2].CommandType = global::System.Data.CommandType.StoredProcedure;
            this._commandCollection[2].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@RETURN_VALUE", global::System.Data.SqlDbType.Int, 4, global::System.Data.ParameterDirection.ReturnValue, 10, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[2].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@sDate", global::System.Data.SqlDbType.NVarChar, 100, global::System.Data.ParameterDirection.Input, 0, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[2].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@eDate", global::System.Data.SqlDbType.NVarChar, 100, global::System.Data.ParameterDirection.Input, 0, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[2].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@MachineName", global::System.Data.SqlDbType.NVarChar, 2147483647, global::System.Data.ParameterDirection.Input, 0, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[2].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@MachineOp", global::System.Data.SqlDbType.Int, 4, global::System.Data.ParameterDirection.Input, 10, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[2].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@SourceName", global::System.Data.SqlDbType.NVarChar, 2147483647, global::System.Data.ParameterDirection.Input, 0, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[2].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@SourceNameOp", global::System.Data.SqlDbType.Int, 4, global::System.Data.ParameterDirection.Input, 10, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[2].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@EventType", global::System.Data.SqlDbType.NVarChar, 2147483647, global::System.Data.ParameterDirection.Input, 0, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[2].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@MessageId", global::System.Data.SqlDbType.Int, 4, global::System.Data.ParameterDirection.Input, 10, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[2].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@MessageIdOp", global::System.Data.SqlDbType.Int, 4, global::System.Data.ParameterDirection.Input, 10, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[2].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@PageNum", global::System.Data.SqlDbType.Int, 4, global::System.Data.ParameterDirection.Input, 10, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[2].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@PageSize", global::System.Data.SqlDbType.Int, 4, global::System.Data.ParameterDirection.Input, 10, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[2].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@RowCountOnly", global::System.Data.SqlDbType.Int, 4, global::System.Data.ParameterDirection.Input, 10, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Design.HelpKeywordAttribute("vs.data.TableAdapter")]
        [global::System.ComponentModel.DataObjectMethodAttribute(global::System.ComponentModel.DataObjectMethodType.Fill, true)]
        public virtual int Fill(DiagnosticDBDataSet.EventsXmlDataTable dataTable) {
            this.Adapter.SelectCommand = this.CommandCollection[0];
            if ((this.ClearBeforeFill == true)) {
                dataTable.Clear();
            }
            int returnValue = this.Adapter.Fill(dataTable);
            return returnValue;
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Design.HelpKeywordAttribute("vs.data.TableAdapter")]
        [global::System.ComponentModel.DataObjectMethodAttribute(global::System.ComponentModel.DataObjectMethodType.Select, true)]
        public virtual DiagnosticDBDataSet.EventsXmlDataTable GetData() {
            this.Adapter.SelectCommand = this.CommandCollection[0];
            DiagnosticDBDataSet.EventsXmlDataTable dataTable = new DiagnosticDBDataSet.EventsXmlDataTable();
            this.Adapter.Fill(dataTable);
            return dataTable;
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Design.HelpKeywordAttribute("vs.data.TableAdapter")]
        [global::System.ComponentModel.DataObjectMethodAttribute(global::System.ComponentModel.DataObjectMethodType.Fill, false)]
        public virtual int FillBy(DiagnosticDBDataSet.EventsXmlDataTable dataTable, string sDate, string eDate, string MachineName, global::System.Nullable<int> MachineOp, string SourceName, global::System.Nullable<int> SourceNameOp, string EventType, global::System.Nullable<int> MessageId, global::System.Nullable<int> MessageIdOp, global::System.Nullable<int> PageNum, global::System.Nullable<int> PageSize, global::System.Nullable<int> RowCountOnly) {
            this.Adapter.SelectCommand = this.CommandCollection[1];
            if ((sDate == null)) {
                this.Adapter.SelectCommand.Parameters[1].Value = global::System.DBNull.Value;
            }
            else {
                this.Adapter.SelectCommand.Parameters[1].Value = ((string)(sDate));
            }
            if ((eDate == null)) {
                this.Adapter.SelectCommand.Parameters[2].Value = global::System.DBNull.Value;
            }
            else {
                this.Adapter.SelectCommand.Parameters[2].Value = ((string)(eDate));
            }
            if ((MachineName == null)) {
                this.Adapter.SelectCommand.Parameters[3].Value = global::System.DBNull.Value;
            }
            else {
                this.Adapter.SelectCommand.Parameters[3].Value = ((string)(MachineName));
            }
            if ((MachineOp.HasValue == true)) {
                this.Adapter.SelectCommand.Parameters[4].Value = ((int)(MachineOp.Value));
            }
            else {
                this.Adapter.SelectCommand.Parameters[4].Value = global::System.DBNull.Value;
            }
            if ((SourceName == null)) {
                this.Adapter.SelectCommand.Parameters[5].Value = global::System.DBNull.Value;
            }
            else {
                this.Adapter.SelectCommand.Parameters[5].Value = ((string)(SourceName));
            }
            if ((SourceNameOp.HasValue == true)) {
                this.Adapter.SelectCommand.Parameters[6].Value = ((int)(SourceNameOp.Value));
            }
            else {
                this.Adapter.SelectCommand.Parameters[6].Value = global::System.DBNull.Value;
            }
            if ((EventType == null)) {
                this.Adapter.SelectCommand.Parameters[7].Value = global::System.DBNull.Value;
            }
            else {
                this.Adapter.SelectCommand.Parameters[7].Value = ((string)(EventType));
            }
            if ((MessageId.HasValue == true)) {
                this.Adapter.SelectCommand.Parameters[8].Value = ((int)(MessageId.Value));
            }
            else {
                this.Adapter.SelectCommand.Parameters[8].Value = global::System.DBNull.Value;
            }
            if ((MessageIdOp.HasValue == true)) {
                this.Adapter.SelectCommand.Parameters[9].Value = ((int)(MessageIdOp.Value));
            }
            else {
                this.Adapter.SelectCommand.Parameters[9].Value = global::System.DBNull.Value;
            }
            if ((PageNum.HasValue == true)) {
                this.Adapter.SelectCommand.Parameters[10].Value = ((int)(PageNum.Value));
            }
            else {
                this.Adapter.SelectCommand.Parameters[10].Value = global::System.DBNull.Value;
            }
            if ((PageSize.HasValue == true)) {
                this.Adapter.SelectCommand.Parameters[11].Value = ((int)(PageSize.Value));
            }
            else {
                this.Adapter.SelectCommand.Parameters[11].Value = global::System.DBNull.Value;
            }
            if ((RowCountOnly.HasValue == true)) {
                this.Adapter.SelectCommand.Parameters[12].Value = ((int)(RowCountOnly.Value));
            }
            else {
                this.Adapter.SelectCommand.Parameters[12].Value = global::System.DBNull.Value;
            }
            if ((this.ClearBeforeFill == true)) {
                dataTable.Clear();
            }
            int returnValue = this.Adapter.Fill(dataTable);
            return returnValue;
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Design.HelpKeywordAttribute("vs.data.TableAdapter")]
        [global::System.ComponentModel.DataObjectMethodAttribute(global::System.ComponentModel.DataObjectMethodType.Select, false)]
        public virtual DiagnosticDBDataSet.EventsXmlDataTable GetFilteredEvents(string sDate, string eDate, string MachineName, global::System.Nullable<int> MachineOp, string SourceName, global::System.Nullable<int> SourceNameOp, string EventType, global::System.Nullable<int> MessageId, global::System.Nullable<int> MessageIdOp, global::System.Nullable<int> PageNum, global::System.Nullable<int> PageSize, global::System.Nullable<int> RowCountOnly) {
            this.Adapter.SelectCommand = this.CommandCollection[1];
            if ((sDate == null)) {
                this.Adapter.SelectCommand.Parameters[1].Value = global::System.DBNull.Value;
            }
            else {
                this.Adapter.SelectCommand.Parameters[1].Value = ((string)(sDate));
            }
            if ((eDate == null)) {
                this.Adapter.SelectCommand.Parameters[2].Value = global::System.DBNull.Value;
            }
            else {
                this.Adapter.SelectCommand.Parameters[2].Value = ((string)(eDate));
            }
            if ((MachineName == null)) {
                this.Adapter.SelectCommand.Parameters[3].Value = global::System.DBNull.Value;
            }
            else {
                this.Adapter.SelectCommand.Parameters[3].Value = ((string)(MachineName));
            }
            if ((MachineOp.HasValue == true)) {
                this.Adapter.SelectCommand.Parameters[4].Value = ((int)(MachineOp.Value));
            }
            else {
                this.Adapter.SelectCommand.Parameters[4].Value = global::System.DBNull.Value;
            }
            if ((SourceName == null)) {
                this.Adapter.SelectCommand.Parameters[5].Value = global::System.DBNull.Value;
            }
            else {
                this.Adapter.SelectCommand.Parameters[5].Value = ((string)(SourceName));
            }
            if ((SourceNameOp.HasValue == true)) {
                this.Adapter.SelectCommand.Parameters[6].Value = ((int)(SourceNameOp.Value));
            }
            else {
                this.Adapter.SelectCommand.Parameters[6].Value = global::System.DBNull.Value;
            }
            if ((EventType == null)) {
                this.Adapter.SelectCommand.Parameters[7].Value = global::System.DBNull.Value;
            }
            else {
                this.Adapter.SelectCommand.Parameters[7].Value = ((string)(EventType));
            }
            if ((MessageId.HasValue == true)) {
                this.Adapter.SelectCommand.Parameters[8].Value = ((int)(MessageId.Value));
            }
            else {
                this.Adapter.SelectCommand.Parameters[8].Value = global::System.DBNull.Value;
            }
            if ((MessageIdOp.HasValue == true)) {
                this.Adapter.SelectCommand.Parameters[9].Value = ((int)(MessageIdOp.Value));
            }
            else {
                this.Adapter.SelectCommand.Parameters[9].Value = global::System.DBNull.Value;
            }
            if ((PageNum.HasValue == true)) {
                this.Adapter.SelectCommand.Parameters[10].Value = ((int)(PageNum.Value));
            }
            else {
                this.Adapter.SelectCommand.Parameters[10].Value = global::System.DBNull.Value;
            }
            if ((PageSize.HasValue == true)) {
                this.Adapter.SelectCommand.Parameters[11].Value = ((int)(PageSize.Value));
            }
            else {
                this.Adapter.SelectCommand.Parameters[11].Value = global::System.DBNull.Value;
            }
            if ((RowCountOnly.HasValue == true)) {
                this.Adapter.SelectCommand.Parameters[12].Value = ((int)(RowCountOnly.Value));
            }
            else {
                this.Adapter.SelectCommand.Parameters[12].Value = global::System.DBNull.Value;
            }
            DiagnosticDBDataSet.EventsXmlDataTable dataTable = new DiagnosticDBDataSet.EventsXmlDataTable();
            this.Adapter.Fill(dataTable);
            return dataTable;
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Design.HelpKeywordAttribute("vs.data.TableAdapter")]
        public virtual int Update(DiagnosticDBDataSet.EventsXmlDataTable dataTable) {
            return this.Adapter.Update(dataTable);
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Design.HelpKeywordAttribute("vs.data.TableAdapter")]
        public virtual int Update(DiagnosticDBDataSet dataSet) {
            return this.Adapter.Update(dataSet, "EventsXml");
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Design.HelpKeywordAttribute("vs.data.TableAdapter")]
        public virtual int Update(global::System.Data.DataRow dataRow) {
            return this.Adapter.Update(new global::System.Data.DataRow[] {
                        dataRow});
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Design.HelpKeywordAttribute("vs.data.TableAdapter")]
        public virtual int Update(global::System.Data.DataRow[] dataRows) {
            return this.Adapter.Update(dataRows);
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Design.HelpKeywordAttribute("vs.data.TableAdapter")]
        [global::System.ComponentModel.DataObjectMethodAttribute(global::System.ComponentModel.DataObjectMethodType.Delete, true)]
        public virtual int Delete(int Original_PK_Events) {
            this.Adapter.DeleteCommand.Parameters[0].Value = ((int)(Original_PK_Events));
            global::System.Data.ConnectionState previousConnectionState = this.Adapter.DeleteCommand.Connection.State;
            if (((this.Adapter.DeleteCommand.Connection.State & global::System.Data.ConnectionState.Open) 
                        != global::System.Data.ConnectionState.Open)) {
                this.Adapter.DeleteCommand.Connection.Open();
            }
            try {
                int returnValue = this.Adapter.DeleteCommand.ExecuteNonQuery();
                return returnValue;
            }
            finally {
                if ((previousConnectionState == global::System.Data.ConnectionState.Closed)) {
                    this.Adapter.DeleteCommand.Connection.Close();
                }
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Design.HelpKeywordAttribute("vs.data.TableAdapter")]
        [global::System.ComponentModel.DataObjectMethodAttribute(global::System.ComponentModel.DataObjectMethodType.Insert, true)]
        public virtual int Insert(object EventData) {
            if ((EventData == null)) {
                this.Adapter.InsertCommand.Parameters[0].Value = global::System.DBNull.Value;
            }
            else {
                this.Adapter.InsertCommand.Parameters[0].Value = ((object)(EventData));
            }
            global::System.Data.ConnectionState previousConnectionState = this.Adapter.InsertCommand.Connection.State;
            if (((this.Adapter.InsertCommand.Connection.State & global::System.Data.ConnectionState.Open) 
                        != global::System.Data.ConnectionState.Open)) {
                this.Adapter.InsertCommand.Connection.Open();
            }
            try {
                int returnValue = this.Adapter.InsertCommand.ExecuteNonQuery();
                return returnValue;
            }
            finally {
                if ((previousConnectionState == global::System.Data.ConnectionState.Closed)) {
                    this.Adapter.InsertCommand.Connection.Close();
                }
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Design.HelpKeywordAttribute("vs.data.TableAdapter")]
        public virtual object GetFilteredEventsTotalRowCount(string sDate, string eDate, string MachineName, global::System.Nullable<int> MachineOp, string SourceName, global::System.Nullable<int> SourceNameOp, string EventType, global::System.Nullable<int> MessageId, global::System.Nullable<int> MessageIdOp, global::System.Nullable<int> PageNum, global::System.Nullable<int> PageSize, global::System.Nullable<int> RowCountOnly) {
            global::System.Data.SqlClient.SqlCommand command = this.CommandCollection[2];
            if ((sDate == null)) {
                command.Parameters[1].Value = global::System.DBNull.Value;
            }
            else {
                command.Parameters[1].Value = ((string)(sDate));
            }
            if ((eDate == null)) {
                command.Parameters[2].Value = global::System.DBNull.Value;
            }
            else {
                command.Parameters[2].Value = ((string)(eDate));
            }
            if ((MachineName == null)) {
                command.Parameters[3].Value = global::System.DBNull.Value;
            }
            else {
                command.Parameters[3].Value = ((string)(MachineName));
            }
            if ((MachineOp.HasValue == true)) {
                command.Parameters[4].Value = ((int)(MachineOp.Value));
            }
            else {
                command.Parameters[4].Value = global::System.DBNull.Value;
            }
            if ((SourceName == null)) {
                command.Parameters[5].Value = global::System.DBNull.Value;
            }
            else {
                command.Parameters[5].Value = ((string)(SourceName));
            }
            if ((SourceNameOp.HasValue == true)) {
                command.Parameters[6].Value = ((int)(SourceNameOp.Value));
            }
            else {
                command.Parameters[6].Value = global::System.DBNull.Value;
            }
            if ((EventType == null)) {
                command.Parameters[7].Value = global::System.DBNull.Value;
            }
            else {
                command.Parameters[7].Value = ((string)(EventType));
            }
            if ((MessageId.HasValue == true)) {
                command.Parameters[8].Value = ((int)(MessageId.Value));
            }
            else {
                command.Parameters[8].Value = global::System.DBNull.Value;
            }
            if ((MessageIdOp.HasValue == true)) {
                command.Parameters[9].Value = ((int)(MessageIdOp.Value));
            }
            else {
                command.Parameters[9].Value = global::System.DBNull.Value;
            }
            if ((PageNum.HasValue == true)) {
                command.Parameters[10].Value = ((int)(PageNum.Value));
            }
            else {
                command.Parameters[10].Value = global::System.DBNull.Value;
            }
            if ((PageSize.HasValue == true)) {
                command.Parameters[11].Value = ((int)(PageSize.Value));
            }
            else {
                command.Parameters[11].Value = global::System.DBNull.Value;
            }
            if ((RowCountOnly.HasValue == true)) {
                command.Parameters[12].Value = ((int)(RowCountOnly.Value));
            }
            else {
                command.Parameters[12].Value = global::System.DBNull.Value;
            }
            global::System.Data.ConnectionState previousConnectionState = command.Connection.State;
            if (((command.Connection.State & global::System.Data.ConnectionState.Open) 
                        != global::System.Data.ConnectionState.Open)) {
                command.Connection.Open();
            }
            object returnValue;
            try {
                returnValue = command.ExecuteScalar();
            }
            finally {
                if ((previousConnectionState == global::System.Data.ConnectionState.Closed)) {
                    command.Connection.Close();
                }
            }
            if (((returnValue == null) 
                        || (returnValue.GetType() == typeof(global::System.DBNull)))) {
                return null;
            }
            else {
                return ((object)(returnValue));
            }
        }
    }
    
    /// <summary>
    ///Represents the connection and commands used to retrieve and save data.
    ///</summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Data.Design.TypedDataSetGenerator", "2.0.0.0")]
    [global::System.ComponentModel.DesignerCategoryAttribute("code")]
    [global::System.ComponentModel.ToolboxItem(true)]
    [global::System.ComponentModel.DataObjectAttribute(true)]
    [global::System.ComponentModel.DesignerAttribute("Microsoft.VSDesigner.DataSource.Design.TableAdapterDesigner, Microsoft.VSDesigner" +
        ", Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
    [global::System.ComponentModel.Design.HelpKeywordAttribute("vs.data.TableAdapter")]
    public partial class EventsTableAdapter : global::System.ComponentModel.Component {
        
        private global::System.Data.SqlClient.SqlDataAdapter _adapter;
        
        private global::System.Data.SqlClient.SqlConnection _connection;
        
        private global::System.Data.SqlClient.SqlTransaction _transaction;
        
        private global::System.Data.SqlClient.SqlCommand[] _commandCollection;
        
        private bool _clearBeforeFill;
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public EventsTableAdapter() {
            this.ClearBeforeFill = true;
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        protected internal global::System.Data.SqlClient.SqlDataAdapter Adapter {
            get {
                if ((this._adapter == null)) {
                    this.InitAdapter();
                }
                return this._adapter;
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        internal global::System.Data.SqlClient.SqlConnection Connection {
            get {
                if ((this._connection == null)) {
                    this.InitConnection();
                }
                return this._connection;
            }
            set {
                this._connection = value;
                if ((this.Adapter.InsertCommand != null)) {
                    this.Adapter.InsertCommand.Connection = value;
                }
                if ((this.Adapter.DeleteCommand != null)) {
                    this.Adapter.DeleteCommand.Connection = value;
                }
                if ((this.Adapter.UpdateCommand != null)) {
                    this.Adapter.UpdateCommand.Connection = value;
                }
                for (int i = 0; (i < this.CommandCollection.Length); i = (i + 1)) {
                    if ((this.CommandCollection[i] != null)) {
                        ((global::System.Data.SqlClient.SqlCommand)(this.CommandCollection[i])).Connection = value;
                    }
                }
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        internal global::System.Data.SqlClient.SqlTransaction Transaction {
            get {
                return this._transaction;
            }
            set {
                this._transaction = value;
                for (int i = 0; (i < this.CommandCollection.Length); i = (i + 1)) {
                    this.CommandCollection[i].Transaction = this._transaction;
                }
                if (((this.Adapter != null) 
                            && (this.Adapter.DeleteCommand != null))) {
                    this.Adapter.DeleteCommand.Transaction = this._transaction;
                }
                if (((this.Adapter != null) 
                            && (this.Adapter.InsertCommand != null))) {
                    this.Adapter.InsertCommand.Transaction = this._transaction;
                }
                if (((this.Adapter != null) 
                            && (this.Adapter.UpdateCommand != null))) {
                    this.Adapter.UpdateCommand.Transaction = this._transaction;
                }
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        protected global::System.Data.SqlClient.SqlCommand[] CommandCollection {
            get {
                if ((this._commandCollection == null)) {
                    this.InitCommandCollection();
                }
                return this._commandCollection;
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public bool ClearBeforeFill {
            get {
                return this._clearBeforeFill;
            }
            set {
                this._clearBeforeFill = value;
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        private void InitAdapter() {
            this._adapter = new global::System.Data.SqlClient.SqlDataAdapter();
            global::System.Data.Common.DataTableMapping tableMapping = new global::System.Data.Common.DataTableMapping();
            tableMapping.SourceTable = "Table";
            tableMapping.DataSetTable = "Events";
            tableMapping.ColumnMappings.Add("EventID", "EventID");
            tableMapping.ColumnMappings.Add("MachineName", "MachineName");
            tableMapping.ColumnMappings.Add("Source", "Source");
            tableMapping.ColumnMappings.Add("MessageID", "MessageID");
            tableMapping.ColumnMappings.Add("Message", "Message");
            tableMapping.ColumnMappings.Add("FileName", "FileName");
            tableMapping.ColumnMappings.Add("LineNumber", "LineNumber");
            tableMapping.ColumnMappings.Add("MethodName", "MethodName");
            tableMapping.ColumnMappings.Add("DateTime", "DateTime");
            tableMapping.ColumnMappings.Add("TimeStamp", "TimeStamp");
            tableMapping.ColumnMappings.Add("ProcessID", "ProcessID");
            tableMapping.ColumnMappings.Add("ThreadID", "ThreadID");
            tableMapping.ColumnMappings.Add("CallStack", "CallStack");
            tableMapping.ColumnMappings.Add("LogicalStack", "LogicalStack");
            tableMapping.ColumnMappings.Add("EventType", "EventType");
            tableMapping.ColumnMappings.Add("AssemblyName", "AssemblyName");
            this._adapter.TableMappings.Add(tableMapping);
            this._adapter.DeleteCommand = new global::System.Data.SqlClient.SqlCommand();
            this._adapter.DeleteCommand.Connection = this.Connection;
            this._adapter.DeleteCommand.CommandText = @"DELETE FROM [Events] WHERE (([EventID] = @Original_EventID) AND ((@IsNull_MessageID = 1 AND [MessageID] IS NULL) OR ([MessageID] = @Original_MessageID)) AND ((@IsNull_LineNumber = 1 AND [LineNumber] IS NULL) OR ([LineNumber] = @Original_LineNumber)) AND ((@IsNull_DateTime = 1 AND [DateTime] IS NULL) OR ([DateTime] = @Original_DateTime)) AND ((@IsNull_TimeStamp = 1 AND [TimeStamp] IS NULL) OR ([TimeStamp] = @Original_TimeStamp)) AND ((@IsNull_ProcessID = 1 AND [ProcessID] IS NULL) OR ([ProcessID] = @Original_ProcessID)))";
            this._adapter.DeleteCommand.CommandType = global::System.Data.CommandType.Text;
            this._adapter.DeleteCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@Original_EventID", global::System.Data.SqlDbType.Int, 0, global::System.Data.ParameterDirection.Input, 0, 0, "EventID", global::System.Data.DataRowVersion.Original, false, null, "", "", ""));
            this._adapter.DeleteCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@IsNull_MessageID", global::System.Data.SqlDbType.Int, 0, global::System.Data.ParameterDirection.Input, 0, 0, "MessageID", global::System.Data.DataRowVersion.Original, true, null, "", "", ""));
            this._adapter.DeleteCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@Original_MessageID", global::System.Data.SqlDbType.Int, 0, global::System.Data.ParameterDirection.Input, 0, 0, "MessageID", global::System.Data.DataRowVersion.Original, false, null, "", "", ""));
            this._adapter.DeleteCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@IsNull_LineNumber", global::System.Data.SqlDbType.Int, 0, global::System.Data.ParameterDirection.Input, 0, 0, "LineNumber", global::System.Data.DataRowVersion.Original, true, null, "", "", ""));
            this._adapter.DeleteCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@Original_LineNumber", global::System.Data.SqlDbType.Int, 0, global::System.Data.ParameterDirection.Input, 0, 0, "LineNumber", global::System.Data.DataRowVersion.Original, false, null, "", "", ""));
            this._adapter.DeleteCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@IsNull_DateTime", global::System.Data.SqlDbType.Int, 0, global::System.Data.ParameterDirection.Input, 0, 0, "DateTime", global::System.Data.DataRowVersion.Original, true, null, "", "", ""));
            this._adapter.DeleteCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@Original_DateTime", global::System.Data.SqlDbType.DateTime, 0, global::System.Data.ParameterDirection.Input, 0, 0, "DateTime", global::System.Data.DataRowVersion.Original, false, null, "", "", ""));
            this._adapter.DeleteCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@IsNull_TimeStamp", global::System.Data.SqlDbType.Int, 0, global::System.Data.ParameterDirection.Input, 0, 0, "TimeStamp", global::System.Data.DataRowVersion.Original, true, null, "", "", ""));
            this._adapter.DeleteCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@Original_TimeStamp", global::System.Data.SqlDbType.BigInt, 0, global::System.Data.ParameterDirection.Input, 0, 0, "TimeStamp", global::System.Data.DataRowVersion.Original, false, null, "", "", ""));
            this._adapter.DeleteCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@IsNull_ProcessID", global::System.Data.SqlDbType.Int, 0, global::System.Data.ParameterDirection.Input, 0, 0, "ProcessID", global::System.Data.DataRowVersion.Original, true, null, "", "", ""));
            this._adapter.DeleteCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@Original_ProcessID", global::System.Data.SqlDbType.Int, 0, global::System.Data.ParameterDirection.Input, 0, 0, "ProcessID", global::System.Data.DataRowVersion.Original, false, null, "", "", ""));
            this._adapter.InsertCommand = new global::System.Data.SqlClient.SqlCommand();
            this._adapter.InsertCommand.Connection = this.Connection;
            this._adapter.InsertCommand.CommandText = @"INSERT INTO [Events] ([MachineName], [Source], [MessageID], [Message], [FileName], [LineNumber], [MethodName], [DateTime], [TimeStamp], [ProcessID], [ThreadID], [CallStack], [LogicalStack]) VALUES (@MachineName, @Source, @MessageID, @Message, @FileName, @LineNumber, @MethodName, @DateTime, @TimeStamp, @ProcessID, @ThreadID, @CallStack, @LogicalStack);
SELECT EventID, MachineName, Source, MessageID, Message, FileName, LineNumber, MethodName, DateTime, TimeStamp, ProcessID, ThreadID, CallStack, LogicalStack FROM Events WHERE (EventID = SCOPE_IDENTITY())";
            this._adapter.InsertCommand.CommandType = global::System.Data.CommandType.Text;
            this._adapter.InsertCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@MachineName", global::System.Data.SqlDbType.NVarChar, 0, global::System.Data.ParameterDirection.Input, 0, 0, "MachineName", global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._adapter.InsertCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@Source", global::System.Data.SqlDbType.NVarChar, 0, global::System.Data.ParameterDirection.Input, 0, 0, "Source", global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._adapter.InsertCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@MessageID", global::System.Data.SqlDbType.Int, 0, global::System.Data.ParameterDirection.Input, 0, 0, "MessageID", global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._adapter.InsertCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@Message", global::System.Data.SqlDbType.NVarChar, 0, global::System.Data.ParameterDirection.Input, 0, 0, "Message", global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._adapter.InsertCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@FileName", global::System.Data.SqlDbType.NVarChar, 0, global::System.Data.ParameterDirection.Input, 0, 0, "FileName", global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._adapter.InsertCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@LineNumber", global::System.Data.SqlDbType.Int, 0, global::System.Data.ParameterDirection.Input, 0, 0, "LineNumber", global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._adapter.InsertCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@MethodName", global::System.Data.SqlDbType.NVarChar, 0, global::System.Data.ParameterDirection.Input, 0, 0, "MethodName", global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._adapter.InsertCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@DateTime", global::System.Data.SqlDbType.DateTime, 0, global::System.Data.ParameterDirection.Input, 0, 0, "DateTime", global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._adapter.InsertCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@TimeStamp", global::System.Data.SqlDbType.BigInt, 0, global::System.Data.ParameterDirection.Input, 0, 0, "TimeStamp", global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._adapter.InsertCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@ProcessID", global::System.Data.SqlDbType.Int, 0, global::System.Data.ParameterDirection.Input, 0, 0, "ProcessID", global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._adapter.InsertCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@ThreadID", global::System.Data.SqlDbType.NVarChar, 0, global::System.Data.ParameterDirection.Input, 0, 0, "ThreadID", global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._adapter.InsertCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@CallStack", global::System.Data.SqlDbType.NVarChar, 0, global::System.Data.ParameterDirection.Input, 0, 0, "CallStack", global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._adapter.InsertCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@LogicalStack", global::System.Data.SqlDbType.NVarChar, 0, global::System.Data.ParameterDirection.Input, 0, 0, "LogicalStack", global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._adapter.UpdateCommand = new global::System.Data.SqlClient.SqlCommand();
            this._adapter.UpdateCommand.Connection = this.Connection;
            this._adapter.UpdateCommand.CommandText = @"UPDATE [Events] SET [MachineName] = @MachineName, [Source] = @Source, [MessageID] = @MessageID, [Message] = @Message, [FileName] = @FileName, [LineNumber] = @LineNumber, [MethodName] = @MethodName, [DateTime] = @DateTime, [TimeStamp] = @TimeStamp, [ProcessID] = @ProcessID, [ThreadID] = @ThreadID, [CallStack] = @CallStack, [LogicalStack] = @LogicalStack WHERE (([EventID] = @Original_EventID) AND ((@IsNull_MessageID = 1 AND [MessageID] IS NULL) OR ([MessageID] = @Original_MessageID)) AND ((@IsNull_LineNumber = 1 AND [LineNumber] IS NULL) OR ([LineNumber] = @Original_LineNumber)) AND ((@IsNull_DateTime = 1 AND [DateTime] IS NULL) OR ([DateTime] = @Original_DateTime)) AND ((@IsNull_TimeStamp = 1 AND [TimeStamp] IS NULL) OR ([TimeStamp] = @Original_TimeStamp)) AND ((@IsNull_ProcessID = 1 AND [ProcessID] IS NULL) OR ([ProcessID] = @Original_ProcessID)));
SELECT EventID, MachineName, Source, MessageID, Message, FileName, LineNumber, MethodName, DateTime, TimeStamp, ProcessID, ThreadID, CallStack, LogicalStack FROM Events WHERE (EventID = @EventID)";
            this._adapter.UpdateCommand.CommandType = global::System.Data.CommandType.Text;
            this._adapter.UpdateCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@MachineName", global::System.Data.SqlDbType.NVarChar, 0, global::System.Data.ParameterDirection.Input, 0, 0, "MachineName", global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._adapter.UpdateCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@Source", global::System.Data.SqlDbType.NVarChar, 0, global::System.Data.ParameterDirection.Input, 0, 0, "Source", global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._adapter.UpdateCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@MessageID", global::System.Data.SqlDbType.Int, 0, global::System.Data.ParameterDirection.Input, 0, 0, "MessageID", global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._adapter.UpdateCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@Message", global::System.Data.SqlDbType.NVarChar, 0, global::System.Data.ParameterDirection.Input, 0, 0, "Message", global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._adapter.UpdateCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@FileName", global::System.Data.SqlDbType.NVarChar, 0, global::System.Data.ParameterDirection.Input, 0, 0, "FileName", global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._adapter.UpdateCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@LineNumber", global::System.Data.SqlDbType.Int, 0, global::System.Data.ParameterDirection.Input, 0, 0, "LineNumber", global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._adapter.UpdateCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@MethodName", global::System.Data.SqlDbType.NVarChar, 0, global::System.Data.ParameterDirection.Input, 0, 0, "MethodName", global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._adapter.UpdateCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@DateTime", global::System.Data.SqlDbType.DateTime, 0, global::System.Data.ParameterDirection.Input, 0, 0, "DateTime", global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._adapter.UpdateCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@TimeStamp", global::System.Data.SqlDbType.BigInt, 0, global::System.Data.ParameterDirection.Input, 0, 0, "TimeStamp", global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._adapter.UpdateCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@ProcessID", global::System.Data.SqlDbType.Int, 0, global::System.Data.ParameterDirection.Input, 0, 0, "ProcessID", global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._adapter.UpdateCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@ThreadID", global::System.Data.SqlDbType.NVarChar, 0, global::System.Data.ParameterDirection.Input, 0, 0, "ThreadID", global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._adapter.UpdateCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@CallStack", global::System.Data.SqlDbType.NVarChar, 0, global::System.Data.ParameterDirection.Input, 0, 0, "CallStack", global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._adapter.UpdateCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@LogicalStack", global::System.Data.SqlDbType.NVarChar, 0, global::System.Data.ParameterDirection.Input, 0, 0, "LogicalStack", global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._adapter.UpdateCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@Original_EventID", global::System.Data.SqlDbType.Int, 0, global::System.Data.ParameterDirection.Input, 0, 0, "EventID", global::System.Data.DataRowVersion.Original, false, null, "", "", ""));
            this._adapter.UpdateCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@IsNull_MessageID", global::System.Data.SqlDbType.Int, 0, global::System.Data.ParameterDirection.Input, 0, 0, "MessageID", global::System.Data.DataRowVersion.Original, true, null, "", "", ""));
            this._adapter.UpdateCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@Original_MessageID", global::System.Data.SqlDbType.Int, 0, global::System.Data.ParameterDirection.Input, 0, 0, "MessageID", global::System.Data.DataRowVersion.Original, false, null, "", "", ""));
            this._adapter.UpdateCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@IsNull_LineNumber", global::System.Data.SqlDbType.Int, 0, global::System.Data.ParameterDirection.Input, 0, 0, "LineNumber", global::System.Data.DataRowVersion.Original, true, null, "", "", ""));
            this._adapter.UpdateCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@Original_LineNumber", global::System.Data.SqlDbType.Int, 0, global::System.Data.ParameterDirection.Input, 0, 0, "LineNumber", global::System.Data.DataRowVersion.Original, false, null, "", "", ""));
            this._adapter.UpdateCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@IsNull_DateTime", global::System.Data.SqlDbType.Int, 0, global::System.Data.ParameterDirection.Input, 0, 0, "DateTime", global::System.Data.DataRowVersion.Original, true, null, "", "", ""));
            this._adapter.UpdateCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@Original_DateTime", global::System.Data.SqlDbType.DateTime, 0, global::System.Data.ParameterDirection.Input, 0, 0, "DateTime", global::System.Data.DataRowVersion.Original, false, null, "", "", ""));
            this._adapter.UpdateCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@IsNull_TimeStamp", global::System.Data.SqlDbType.Int, 0, global::System.Data.ParameterDirection.Input, 0, 0, "TimeStamp", global::System.Data.DataRowVersion.Original, true, null, "", "", ""));
            this._adapter.UpdateCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@Original_TimeStamp", global::System.Data.SqlDbType.BigInt, 0, global::System.Data.ParameterDirection.Input, 0, 0, "TimeStamp", global::System.Data.DataRowVersion.Original, false, null, "", "", ""));
            this._adapter.UpdateCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@IsNull_ProcessID", global::System.Data.SqlDbType.Int, 0, global::System.Data.ParameterDirection.Input, 0, 0, "ProcessID", global::System.Data.DataRowVersion.Original, true, null, "", "", ""));
            this._adapter.UpdateCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@Original_ProcessID", global::System.Data.SqlDbType.Int, 0, global::System.Data.ParameterDirection.Input, 0, 0, "ProcessID", global::System.Data.DataRowVersion.Original, false, null, "", "", ""));
            this._adapter.UpdateCommand.Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@EventID", global::System.Data.SqlDbType.Int, 4, global::System.Data.ParameterDirection.Input, 0, 0, "EventID", global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        private void InitConnection() {
            this._connection = new global::System.Data.SqlClient.SqlConnection();
            this._connection.ConnectionString = global::Wgx.Services.Monitoring.Properties.Settings.Default.EventAggregatorConnectionString;
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        private void InitCommandCollection() {
            this._commandCollection = new global::System.Data.SqlClient.SqlCommand[3];
            this._commandCollection[0] = new global::System.Data.SqlClient.SqlCommand();
            this._commandCollection[0].Connection = this.Connection;
            this._commandCollection[0].CommandText = "SELECT     Events.*\r\nFROM         Events";
            this._commandCollection[0].CommandType = global::System.Data.CommandType.Text;
            this._commandCollection[1] = new global::System.Data.SqlClient.SqlCommand();
            this._commandCollection[1].Connection = this.Connection;
            this._commandCollection[1].CommandText = "dbo.GetFilteredEvents";
            this._commandCollection[1].CommandType = global::System.Data.CommandType.StoredProcedure;
            this._commandCollection[1].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@RETURN_VALUE", global::System.Data.SqlDbType.Int, 4, global::System.Data.ParameterDirection.ReturnValue, 10, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[1].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@sDate", global::System.Data.SqlDbType.NVarChar, 100, global::System.Data.ParameterDirection.Input, 0, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[1].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@eDate", global::System.Data.SqlDbType.NVarChar, 100, global::System.Data.ParameterDirection.Input, 0, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[1].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@MachineName", global::System.Data.SqlDbType.NVarChar, 2147483647, global::System.Data.ParameterDirection.Input, 0, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[1].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@MachineOp", global::System.Data.SqlDbType.Int, 4, global::System.Data.ParameterDirection.Input, 10, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[1].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@SourceName", global::System.Data.SqlDbType.NVarChar, 2147483647, global::System.Data.ParameterDirection.Input, 0, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[1].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@SourceNameOp", global::System.Data.SqlDbType.Int, 4, global::System.Data.ParameterDirection.Input, 10, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[1].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@EventType", global::System.Data.SqlDbType.NVarChar, 2147483647, global::System.Data.ParameterDirection.Input, 0, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[1].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@MessageId", global::System.Data.SqlDbType.Int, 4, global::System.Data.ParameterDirection.Input, 10, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[1].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@MessageIdOp", global::System.Data.SqlDbType.Int, 4, global::System.Data.ParameterDirection.Input, 10, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[1].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@PageNum", global::System.Data.SqlDbType.Int, 4, global::System.Data.ParameterDirection.Input, 10, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[1].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@PageSize", global::System.Data.SqlDbType.Int, 4, global::System.Data.ParameterDirection.Input, 10, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[1].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@SortKey", global::System.Data.SqlDbType.NVarChar, 100, global::System.Data.ParameterDirection.Input, 0, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[1].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@Ascending", global::System.Data.SqlDbType.Int, 4, global::System.Data.ParameterDirection.Input, 10, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[1].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@RowCountOnly", global::System.Data.SqlDbType.Int, 4, global::System.Data.ParameterDirection.Input, 10, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[2] = new global::System.Data.SqlClient.SqlCommand();
            this._commandCollection[2].Connection = this.Connection;
            this._commandCollection[2].CommandText = "dbo.GetFilteredEvents";
            this._commandCollection[2].CommandType = global::System.Data.CommandType.StoredProcedure;
            this._commandCollection[2].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@RETURN_VALUE", global::System.Data.SqlDbType.Int, 4, global::System.Data.ParameterDirection.ReturnValue, 10, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[2].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@sDate", global::System.Data.SqlDbType.NVarChar, 100, global::System.Data.ParameterDirection.Input, 0, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[2].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@eDate", global::System.Data.SqlDbType.NVarChar, 100, global::System.Data.ParameterDirection.Input, 0, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[2].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@MachineName", global::System.Data.SqlDbType.NVarChar, 2147483647, global::System.Data.ParameterDirection.Input, 0, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[2].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@MachineOp", global::System.Data.SqlDbType.Int, 4, global::System.Data.ParameterDirection.Input, 10, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[2].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@SourceName", global::System.Data.SqlDbType.NVarChar, 2147483647, global::System.Data.ParameterDirection.Input, 0, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[2].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@SourceNameOp", global::System.Data.SqlDbType.Int, 4, global::System.Data.ParameterDirection.Input, 10, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[2].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@EventType", global::System.Data.SqlDbType.NVarChar, 2147483647, global::System.Data.ParameterDirection.Input, 0, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[2].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@MessageId", global::System.Data.SqlDbType.Int, 4, global::System.Data.ParameterDirection.Input, 10, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[2].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@MessageIdOp", global::System.Data.SqlDbType.Int, 4, global::System.Data.ParameterDirection.Input, 10, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[2].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@PageNum", global::System.Data.SqlDbType.Int, 4, global::System.Data.ParameterDirection.Input, 10, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[2].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@PageSize", global::System.Data.SqlDbType.Int, 4, global::System.Data.ParameterDirection.Input, 10, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[2].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@SortKey", global::System.Data.SqlDbType.NVarChar, 100, global::System.Data.ParameterDirection.Input, 0, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[2].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@Ascending", global::System.Data.SqlDbType.Int, 4, global::System.Data.ParameterDirection.Input, 10, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[2].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@RowCountOnly", global::System.Data.SqlDbType.Int, 4, global::System.Data.ParameterDirection.Input, 10, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Design.HelpKeywordAttribute("vs.data.TableAdapter")]
        [global::System.ComponentModel.DataObjectMethodAttribute(global::System.ComponentModel.DataObjectMethodType.Fill, true)]
        public virtual int Fill(DiagnosticDBDataSet.EventsDataTable dataTable) {
            this.Adapter.SelectCommand = this.CommandCollection[0];
            if ((this.ClearBeforeFill == true)) {
                dataTable.Clear();
            }
            int returnValue = this.Adapter.Fill(dataTable);
            return returnValue;
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Design.HelpKeywordAttribute("vs.data.TableAdapter")]
        [global::System.ComponentModel.DataObjectMethodAttribute(global::System.ComponentModel.DataObjectMethodType.Select, true)]
        public virtual DiagnosticDBDataSet.EventsDataTable GetData() {
            this.Adapter.SelectCommand = this.CommandCollection[0];
            DiagnosticDBDataSet.EventsDataTable dataTable = new DiagnosticDBDataSet.EventsDataTable();
            this.Adapter.Fill(dataTable);
            return dataTable;
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Design.HelpKeywordAttribute("vs.data.TableAdapter")]
        [global::System.ComponentModel.DataObjectMethodAttribute(global::System.ComponentModel.DataObjectMethodType.Select, false)]
        public virtual DiagnosticDBDataSet.EventsDataTable GetFilteredEvents(string sDate, string eDate, string MachineName, global::System.Nullable<int> MachineOp, string SourceName, global::System.Nullable<int> SourceNameOp, string EventType, global::System.Nullable<int> MessageId, global::System.Nullable<int> MessageIdOp, global::System.Nullable<int> PageNum, global::System.Nullable<int> PageSize, string SortKey, global::System.Nullable<int> Ascending, global::System.Nullable<int> RowCountOnly) {
            this.Adapter.SelectCommand = this.CommandCollection[1];
            if ((sDate == null)) {
                this.Adapter.SelectCommand.Parameters[1].Value = global::System.DBNull.Value;
            }
            else {
                this.Adapter.SelectCommand.Parameters[1].Value = ((string)(sDate));
            }
            if ((eDate == null)) {
                this.Adapter.SelectCommand.Parameters[2].Value = global::System.DBNull.Value;
            }
            else {
                this.Adapter.SelectCommand.Parameters[2].Value = ((string)(eDate));
            }
            if ((MachineName == null)) {
                this.Adapter.SelectCommand.Parameters[3].Value = global::System.DBNull.Value;
            }
            else {
                this.Adapter.SelectCommand.Parameters[3].Value = ((string)(MachineName));
            }
            if ((MachineOp.HasValue == true)) {
                this.Adapter.SelectCommand.Parameters[4].Value = ((int)(MachineOp.Value));
            }
            else {
                this.Adapter.SelectCommand.Parameters[4].Value = global::System.DBNull.Value;
            }
            if ((SourceName == null)) {
                this.Adapter.SelectCommand.Parameters[5].Value = global::System.DBNull.Value;
            }
            else {
                this.Adapter.SelectCommand.Parameters[5].Value = ((string)(SourceName));
            }
            if ((SourceNameOp.HasValue == true)) {
                this.Adapter.SelectCommand.Parameters[6].Value = ((int)(SourceNameOp.Value));
            }
            else {
                this.Adapter.SelectCommand.Parameters[6].Value = global::System.DBNull.Value;
            }
            if ((EventType == null)) {
                this.Adapter.SelectCommand.Parameters[7].Value = global::System.DBNull.Value;
            }
            else {
                this.Adapter.SelectCommand.Parameters[7].Value = ((string)(EventType));
            }
            if ((MessageId.HasValue == true)) {
                this.Adapter.SelectCommand.Parameters[8].Value = ((int)(MessageId.Value));
            }
            else {
                this.Adapter.SelectCommand.Parameters[8].Value = global::System.DBNull.Value;
            }
            if ((MessageIdOp.HasValue == true)) {
                this.Adapter.SelectCommand.Parameters[9].Value = ((int)(MessageIdOp.Value));
            }
            else {
                this.Adapter.SelectCommand.Parameters[9].Value = global::System.DBNull.Value;
            }
            if ((PageNum.HasValue == true)) {
                this.Adapter.SelectCommand.Parameters[10].Value = ((int)(PageNum.Value));
            }
            else {
                this.Adapter.SelectCommand.Parameters[10].Value = global::System.DBNull.Value;
            }
            if ((PageSize.HasValue == true)) {
                this.Adapter.SelectCommand.Parameters[11].Value = ((int)(PageSize.Value));
            }
            else {
                this.Adapter.SelectCommand.Parameters[11].Value = global::System.DBNull.Value;
            }
            if ((SortKey == null)) {
                this.Adapter.SelectCommand.Parameters[12].Value = global::System.DBNull.Value;
            }
            else {
                this.Adapter.SelectCommand.Parameters[12].Value = ((string)(SortKey));
            }
            if ((Ascending.HasValue == true)) {
                this.Adapter.SelectCommand.Parameters[13].Value = ((int)(Ascending.Value));
            }
            else {
                this.Adapter.SelectCommand.Parameters[13].Value = global::System.DBNull.Value;
            }
            if ((RowCountOnly.HasValue == true)) {
                this.Adapter.SelectCommand.Parameters[14].Value = ((int)(RowCountOnly.Value));
            }
            else {
                this.Adapter.SelectCommand.Parameters[14].Value = global::System.DBNull.Value;
            }
            DiagnosticDBDataSet.EventsDataTable dataTable = new DiagnosticDBDataSet.EventsDataTable();
            this.Adapter.Fill(dataTable);
            return dataTable;
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Design.HelpKeywordAttribute("vs.data.TableAdapter")]
        public virtual int Update(DiagnosticDBDataSet.EventsDataTable dataTable) {
            return this.Adapter.Update(dataTable);
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Design.HelpKeywordAttribute("vs.data.TableAdapter")]
        public virtual int Update(DiagnosticDBDataSet dataSet) {
            return this.Adapter.Update(dataSet, "Events");
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Design.HelpKeywordAttribute("vs.data.TableAdapter")]
        public virtual int Update(global::System.Data.DataRow dataRow) {
            return this.Adapter.Update(new global::System.Data.DataRow[] {
                        dataRow});
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Design.HelpKeywordAttribute("vs.data.TableAdapter")]
        public virtual int Update(global::System.Data.DataRow[] dataRows) {
            return this.Adapter.Update(dataRows);
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Design.HelpKeywordAttribute("vs.data.TableAdapter")]
        [global::System.ComponentModel.DataObjectMethodAttribute(global::System.ComponentModel.DataObjectMethodType.Delete, true)]
        public virtual int Delete(int Original_EventID, global::System.Nullable<int> Original_MessageID, global::System.Nullable<int> Original_LineNumber, global::System.Nullable<global::System.DateTime> Original_DateTime, global::System.Nullable<long> Original_TimeStamp, global::System.Nullable<int> Original_ProcessID) {
            this.Adapter.DeleteCommand.Parameters[0].Value = ((int)(Original_EventID));
            if ((Original_MessageID.HasValue == true)) {
                this.Adapter.DeleteCommand.Parameters[1].Value = ((object)(0));
                this.Adapter.DeleteCommand.Parameters[2].Value = ((int)(Original_MessageID.Value));
            }
            else {
                this.Adapter.DeleteCommand.Parameters[1].Value = ((object)(1));
                this.Adapter.DeleteCommand.Parameters[2].Value = global::System.DBNull.Value;
            }
            if ((Original_LineNumber.HasValue == true)) {
                this.Adapter.DeleteCommand.Parameters[3].Value = ((object)(0));
                this.Adapter.DeleteCommand.Parameters[4].Value = ((int)(Original_LineNumber.Value));
            }
            else {
                this.Adapter.DeleteCommand.Parameters[3].Value = ((object)(1));
                this.Adapter.DeleteCommand.Parameters[4].Value = global::System.DBNull.Value;
            }
            if ((Original_DateTime.HasValue == true)) {
                this.Adapter.DeleteCommand.Parameters[5].Value = ((object)(0));
                this.Adapter.DeleteCommand.Parameters[6].Value = ((System.DateTime)(Original_DateTime.Value));
            }
            else {
                this.Adapter.DeleteCommand.Parameters[5].Value = ((object)(1));
                this.Adapter.DeleteCommand.Parameters[6].Value = global::System.DBNull.Value;
            }
            if ((Original_TimeStamp.HasValue == true)) {
                this.Adapter.DeleteCommand.Parameters[7].Value = ((object)(0));
                this.Adapter.DeleteCommand.Parameters[8].Value = ((long)(Original_TimeStamp.Value));
            }
            else {
                this.Adapter.DeleteCommand.Parameters[7].Value = ((object)(1));
                this.Adapter.DeleteCommand.Parameters[8].Value = global::System.DBNull.Value;
            }
            if ((Original_ProcessID.HasValue == true)) {
                this.Adapter.DeleteCommand.Parameters[9].Value = ((object)(0));
                this.Adapter.DeleteCommand.Parameters[10].Value = ((int)(Original_ProcessID.Value));
            }
            else {
                this.Adapter.DeleteCommand.Parameters[9].Value = ((object)(1));
                this.Adapter.DeleteCommand.Parameters[10].Value = global::System.DBNull.Value;
            }
            global::System.Data.ConnectionState previousConnectionState = this.Adapter.DeleteCommand.Connection.State;
            if (((this.Adapter.DeleteCommand.Connection.State & global::System.Data.ConnectionState.Open) 
                        != global::System.Data.ConnectionState.Open)) {
                this.Adapter.DeleteCommand.Connection.Open();
            }
            try {
                int returnValue = this.Adapter.DeleteCommand.ExecuteNonQuery();
                return returnValue;
            }
            finally {
                if ((previousConnectionState == global::System.Data.ConnectionState.Closed)) {
                    this.Adapter.DeleteCommand.Connection.Close();
                }
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Design.HelpKeywordAttribute("vs.data.TableAdapter")]
        [global::System.ComponentModel.DataObjectMethodAttribute(global::System.ComponentModel.DataObjectMethodType.Insert, true)]
        public virtual int Insert(string MachineName, string Source, global::System.Nullable<int> MessageID, string Message, string FileName, global::System.Nullable<int> LineNumber, string MethodName, global::System.Nullable<global::System.DateTime> DateTime, global::System.Nullable<long> TimeStamp, global::System.Nullable<int> ProcessID, string ThreadID, string CallStack, string LogicalStack) {
            if ((MachineName == null)) {
                this.Adapter.InsertCommand.Parameters[0].Value = global::System.DBNull.Value;
            }
            else {
                this.Adapter.InsertCommand.Parameters[0].Value = ((string)(MachineName));
            }
            if ((Source == null)) {
                this.Adapter.InsertCommand.Parameters[1].Value = global::System.DBNull.Value;
            }
            else {
                this.Adapter.InsertCommand.Parameters[1].Value = ((string)(Source));
            }
            if ((MessageID.HasValue == true)) {
                this.Adapter.InsertCommand.Parameters[2].Value = ((int)(MessageID.Value));
            }
            else {
                this.Adapter.InsertCommand.Parameters[2].Value = global::System.DBNull.Value;
            }
            if ((Message == null)) {
                this.Adapter.InsertCommand.Parameters[3].Value = global::System.DBNull.Value;
            }
            else {
                this.Adapter.InsertCommand.Parameters[3].Value = ((string)(Message));
            }
            if ((FileName == null)) {
                this.Adapter.InsertCommand.Parameters[4].Value = global::System.DBNull.Value;
            }
            else {
                this.Adapter.InsertCommand.Parameters[4].Value = ((string)(FileName));
            }
            if ((LineNumber.HasValue == true)) {
                this.Adapter.InsertCommand.Parameters[5].Value = ((int)(LineNumber.Value));
            }
            else {
                this.Adapter.InsertCommand.Parameters[5].Value = global::System.DBNull.Value;
            }
            if ((MethodName == null)) {
                this.Adapter.InsertCommand.Parameters[6].Value = global::System.DBNull.Value;
            }
            else {
                this.Adapter.InsertCommand.Parameters[6].Value = ((string)(MethodName));
            }
            if ((DateTime.HasValue == true)) {
                this.Adapter.InsertCommand.Parameters[7].Value = ((System.DateTime)(DateTime.Value));
            }
            else {
                this.Adapter.InsertCommand.Parameters[7].Value = global::System.DBNull.Value;
            }
            if ((TimeStamp.HasValue == true)) {
                this.Adapter.InsertCommand.Parameters[8].Value = ((long)(TimeStamp.Value));
            }
            else {
                this.Adapter.InsertCommand.Parameters[8].Value = global::System.DBNull.Value;
            }
            if ((ProcessID.HasValue == true)) {
                this.Adapter.InsertCommand.Parameters[9].Value = ((int)(ProcessID.Value));
            }
            else {
                this.Adapter.InsertCommand.Parameters[9].Value = global::System.DBNull.Value;
            }
            if ((ThreadID == null)) {
                this.Adapter.InsertCommand.Parameters[10].Value = global::System.DBNull.Value;
            }
            else {
                this.Adapter.InsertCommand.Parameters[10].Value = ((string)(ThreadID));
            }
            if ((CallStack == null)) {
                this.Adapter.InsertCommand.Parameters[11].Value = global::System.DBNull.Value;
            }
            else {
                this.Adapter.InsertCommand.Parameters[11].Value = ((string)(CallStack));
            }
            if ((LogicalStack == null)) {
                this.Adapter.InsertCommand.Parameters[12].Value = global::System.DBNull.Value;
            }
            else {
                this.Adapter.InsertCommand.Parameters[12].Value = ((string)(LogicalStack));
            }
            global::System.Data.ConnectionState previousConnectionState = this.Adapter.InsertCommand.Connection.State;
            if (((this.Adapter.InsertCommand.Connection.State & global::System.Data.ConnectionState.Open) 
                        != global::System.Data.ConnectionState.Open)) {
                this.Adapter.InsertCommand.Connection.Open();
            }
            try {
                int returnValue = this.Adapter.InsertCommand.ExecuteNonQuery();
                return returnValue;
            }
            finally {
                if ((previousConnectionState == global::System.Data.ConnectionState.Closed)) {
                    this.Adapter.InsertCommand.Connection.Close();
                }
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Design.HelpKeywordAttribute("vs.data.TableAdapter")]
        [global::System.ComponentModel.DataObjectMethodAttribute(global::System.ComponentModel.DataObjectMethodType.Update, true)]
        public virtual int Update(
                    string MachineName, 
                    string Source, 
                    global::System.Nullable<int> MessageID, 
                    string Message, 
                    string FileName, 
                    global::System.Nullable<int> LineNumber, 
                    string MethodName, 
                    global::System.Nullable<global::System.DateTime> DateTime, 
                    global::System.Nullable<long> TimeStamp, 
                    global::System.Nullable<int> ProcessID, 
                    string ThreadID, 
                    string CallStack, 
                    string LogicalStack, 
                    int Original_EventID, 
                    global::System.Nullable<int> Original_MessageID, 
                    global::System.Nullable<int> Original_LineNumber, 
                    global::System.Nullable<global::System.DateTime> Original_DateTime, 
                    global::System.Nullable<long> Original_TimeStamp, 
                    global::System.Nullable<int> Original_ProcessID, 
                    int EventID) {
            if ((MachineName == null)) {
                this.Adapter.UpdateCommand.Parameters[0].Value = global::System.DBNull.Value;
            }
            else {
                this.Adapter.UpdateCommand.Parameters[0].Value = ((string)(MachineName));
            }
            if ((Source == null)) {
                this.Adapter.UpdateCommand.Parameters[1].Value = global::System.DBNull.Value;
            }
            else {
                this.Adapter.UpdateCommand.Parameters[1].Value = ((string)(Source));
            }
            if ((MessageID.HasValue == true)) {
                this.Adapter.UpdateCommand.Parameters[2].Value = ((int)(MessageID.Value));
            }
            else {
                this.Adapter.UpdateCommand.Parameters[2].Value = global::System.DBNull.Value;
            }
            if ((Message == null)) {
                this.Adapter.UpdateCommand.Parameters[3].Value = global::System.DBNull.Value;
            }
            else {
                this.Adapter.UpdateCommand.Parameters[3].Value = ((string)(Message));
            }
            if ((FileName == null)) {
                this.Adapter.UpdateCommand.Parameters[4].Value = global::System.DBNull.Value;
            }
            else {
                this.Adapter.UpdateCommand.Parameters[4].Value = ((string)(FileName));
            }
            if ((LineNumber.HasValue == true)) {
                this.Adapter.UpdateCommand.Parameters[5].Value = ((int)(LineNumber.Value));
            }
            else {
                this.Adapter.UpdateCommand.Parameters[5].Value = global::System.DBNull.Value;
            }
            if ((MethodName == null)) {
                this.Adapter.UpdateCommand.Parameters[6].Value = global::System.DBNull.Value;
            }
            else {
                this.Adapter.UpdateCommand.Parameters[6].Value = ((string)(MethodName));
            }
            if ((DateTime.HasValue == true)) {
                this.Adapter.UpdateCommand.Parameters[7].Value = ((System.DateTime)(DateTime.Value));
            }
            else {
                this.Adapter.UpdateCommand.Parameters[7].Value = global::System.DBNull.Value;
            }
            if ((TimeStamp.HasValue == true)) {
                this.Adapter.UpdateCommand.Parameters[8].Value = ((long)(TimeStamp.Value));
            }
            else {
                this.Adapter.UpdateCommand.Parameters[8].Value = global::System.DBNull.Value;
            }
            if ((ProcessID.HasValue == true)) {
                this.Adapter.UpdateCommand.Parameters[9].Value = ((int)(ProcessID.Value));
            }
            else {
                this.Adapter.UpdateCommand.Parameters[9].Value = global::System.DBNull.Value;
            }
            if ((ThreadID == null)) {
                this.Adapter.UpdateCommand.Parameters[10].Value = global::System.DBNull.Value;
            }
            else {
                this.Adapter.UpdateCommand.Parameters[10].Value = ((string)(ThreadID));
            }
            if ((CallStack == null)) {
                this.Adapter.UpdateCommand.Parameters[11].Value = global::System.DBNull.Value;
            }
            else {
                this.Adapter.UpdateCommand.Parameters[11].Value = ((string)(CallStack));
            }
            if ((LogicalStack == null)) {
                this.Adapter.UpdateCommand.Parameters[12].Value = global::System.DBNull.Value;
            }
            else {
                this.Adapter.UpdateCommand.Parameters[12].Value = ((string)(LogicalStack));
            }
            this.Adapter.UpdateCommand.Parameters[13].Value = ((int)(Original_EventID));
            if ((Original_MessageID.HasValue == true)) {
                this.Adapter.UpdateCommand.Parameters[14].Value = ((object)(0));
                this.Adapter.UpdateCommand.Parameters[15].Value = ((int)(Original_MessageID.Value));
            }
            else {
                this.Adapter.UpdateCommand.Parameters[14].Value = ((object)(1));
                this.Adapter.UpdateCommand.Parameters[15].Value = global::System.DBNull.Value;
            }
            if ((Original_LineNumber.HasValue == true)) {
                this.Adapter.UpdateCommand.Parameters[16].Value = ((object)(0));
                this.Adapter.UpdateCommand.Parameters[17].Value = ((int)(Original_LineNumber.Value));
            }
            else {
                this.Adapter.UpdateCommand.Parameters[16].Value = ((object)(1));
                this.Adapter.UpdateCommand.Parameters[17].Value = global::System.DBNull.Value;
            }
            if ((Original_DateTime.HasValue == true)) {
                this.Adapter.UpdateCommand.Parameters[18].Value = ((object)(0));
                this.Adapter.UpdateCommand.Parameters[19].Value = ((System.DateTime)(Original_DateTime.Value));
            }
            else {
                this.Adapter.UpdateCommand.Parameters[18].Value = ((object)(1));
                this.Adapter.UpdateCommand.Parameters[19].Value = global::System.DBNull.Value;
            }
            if ((Original_TimeStamp.HasValue == true)) {
                this.Adapter.UpdateCommand.Parameters[20].Value = ((object)(0));
                this.Adapter.UpdateCommand.Parameters[21].Value = ((long)(Original_TimeStamp.Value));
            }
            else {
                this.Adapter.UpdateCommand.Parameters[20].Value = ((object)(1));
                this.Adapter.UpdateCommand.Parameters[21].Value = global::System.DBNull.Value;
            }
            if ((Original_ProcessID.HasValue == true)) {
                this.Adapter.UpdateCommand.Parameters[22].Value = ((object)(0));
                this.Adapter.UpdateCommand.Parameters[23].Value = ((int)(Original_ProcessID.Value));
            }
            else {
                this.Adapter.UpdateCommand.Parameters[22].Value = ((object)(1));
                this.Adapter.UpdateCommand.Parameters[23].Value = global::System.DBNull.Value;
            }
            this.Adapter.UpdateCommand.Parameters[24].Value = ((int)(EventID));
            global::System.Data.ConnectionState previousConnectionState = this.Adapter.UpdateCommand.Connection.State;
            if (((this.Adapter.UpdateCommand.Connection.State & global::System.Data.ConnectionState.Open) 
                        != global::System.Data.ConnectionState.Open)) {
                this.Adapter.UpdateCommand.Connection.Open();
            }
            try {
                int returnValue = this.Adapter.UpdateCommand.ExecuteNonQuery();
                return returnValue;
            }
            finally {
                if ((previousConnectionState == global::System.Data.ConnectionState.Closed)) {
                    this.Adapter.UpdateCommand.Connection.Close();
                }
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Design.HelpKeywordAttribute("vs.data.TableAdapter")]
        [global::System.ComponentModel.DataObjectMethodAttribute(global::System.ComponentModel.DataObjectMethodType.Update, true)]
        public virtual int Update(
                    string MachineName, 
                    string Source, 
                    global::System.Nullable<int> MessageID, 
                    string Message, 
                    string FileName, 
                    global::System.Nullable<int> LineNumber, 
                    string MethodName, 
                    global::System.Nullable<global::System.DateTime> DateTime, 
                    global::System.Nullable<long> TimeStamp, 
                    global::System.Nullable<int> ProcessID, 
                    string ThreadID, 
                    string CallStack, 
                    string LogicalStack, 
                    int Original_EventID, 
                    global::System.Nullable<int> Original_MessageID, 
                    global::System.Nullable<int> Original_LineNumber, 
                    global::System.Nullable<global::System.DateTime> Original_DateTime, 
                    global::System.Nullable<long> Original_TimeStamp, 
                    global::System.Nullable<int> Original_ProcessID) {
            return this.Update(MachineName, Source, MessageID, Message, FileName, LineNumber, MethodName, DateTime, TimeStamp, ProcessID, ThreadID, CallStack, LogicalStack, Original_EventID, Original_MessageID, Original_LineNumber, Original_DateTime, Original_TimeStamp, Original_ProcessID, Original_EventID);
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Design.HelpKeywordAttribute("vs.data.TableAdapter")]
        public virtual object GetFilteredEventsRowCount(string sDate, string eDate, string MachineName, global::System.Nullable<int> MachineOp, string SourceName, global::System.Nullable<int> SourceNameOp, string EventType, global::System.Nullable<int> MessageId, global::System.Nullable<int> MessageIdOp, global::System.Nullable<int> PageNum, global::System.Nullable<int> PageSize, string SortKey, global::System.Nullable<int> Ascending, global::System.Nullable<int> RowCountOnly) {
            global::System.Data.SqlClient.SqlCommand command = this.CommandCollection[2];
            if ((sDate == null)) {
                command.Parameters[1].Value = global::System.DBNull.Value;
            }
            else {
                command.Parameters[1].Value = ((string)(sDate));
            }
            if ((eDate == null)) {
                command.Parameters[2].Value = global::System.DBNull.Value;
            }
            else {
                command.Parameters[2].Value = ((string)(eDate));
            }
            if ((MachineName == null)) {
                command.Parameters[3].Value = global::System.DBNull.Value;
            }
            else {
                command.Parameters[3].Value = ((string)(MachineName));
            }
            if ((MachineOp.HasValue == true)) {
                command.Parameters[4].Value = ((int)(MachineOp.Value));
            }
            else {
                command.Parameters[4].Value = global::System.DBNull.Value;
            }
            if ((SourceName == null)) {
                command.Parameters[5].Value = global::System.DBNull.Value;
            }
            else {
                command.Parameters[5].Value = ((string)(SourceName));
            }
            if ((SourceNameOp.HasValue == true)) {
                command.Parameters[6].Value = ((int)(SourceNameOp.Value));
            }
            else {
                command.Parameters[6].Value = global::System.DBNull.Value;
            }
            if ((EventType == null)) {
                command.Parameters[7].Value = global::System.DBNull.Value;
            }
            else {
                command.Parameters[7].Value = ((string)(EventType));
            }
            if ((MessageId.HasValue == true)) {
                command.Parameters[8].Value = ((int)(MessageId.Value));
            }
            else {
                command.Parameters[8].Value = global::System.DBNull.Value;
            }
            if ((MessageIdOp.HasValue == true)) {
                command.Parameters[9].Value = ((int)(MessageIdOp.Value));
            }
            else {
                command.Parameters[9].Value = global::System.DBNull.Value;
            }
            if ((PageNum.HasValue == true)) {
                command.Parameters[10].Value = ((int)(PageNum.Value));
            }
            else {
                command.Parameters[10].Value = global::System.DBNull.Value;
            }
            if ((PageSize.HasValue == true)) {
                command.Parameters[11].Value = ((int)(PageSize.Value));
            }
            else {
                command.Parameters[11].Value = global::System.DBNull.Value;
            }
            if ((SortKey == null)) {
                command.Parameters[12].Value = global::System.DBNull.Value;
            }
            else {
                command.Parameters[12].Value = ((string)(SortKey));
            }
            if ((Ascending.HasValue == true)) {
                command.Parameters[13].Value = ((int)(Ascending.Value));
            }
            else {
                command.Parameters[13].Value = global::System.DBNull.Value;
            }
            if ((RowCountOnly.HasValue == true)) {
                command.Parameters[14].Value = ((int)(RowCountOnly.Value));
            }
            else {
                command.Parameters[14].Value = global::System.DBNull.Value;
            }
            global::System.Data.ConnectionState previousConnectionState = command.Connection.State;
            if (((command.Connection.State & global::System.Data.ConnectionState.Open) 
                        != global::System.Data.ConnectionState.Open)) {
                command.Connection.Open();
            }
            object returnValue;
            try {
                returnValue = command.ExecuteScalar();
            }
            finally {
                if ((previousConnectionState == global::System.Data.ConnectionState.Closed)) {
                    command.Connection.Close();
                }
            }
            if (((returnValue == null) 
                        || (returnValue.GetType() == typeof(global::System.DBNull)))) {
                return null;
            }
            else {
                return ((object)(returnValue));
            }
        }
    }
    
    /// <summary>
    ///Represents the connection and commands used to retrieve and save data.
    ///</summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Data.Design.TypedDataSetGenerator", "2.0.0.0")]
    [global::System.ComponentModel.DesignerCategoryAttribute("code")]
    [global::System.ComponentModel.ToolboxItem(true)]
    [global::System.ComponentModel.DataObjectAttribute(true)]
    [global::System.ComponentModel.DesignerAttribute("Microsoft.VSDesigner.DataSource.Design.TableAdapterDesigner, Microsoft.VSDesigner" +
        ", Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
    [global::System.ComponentModel.Design.HelpKeywordAttribute("vs.data.TableAdapter")]
    public partial class GetSummaryEventsTableAdapter : global::System.ComponentModel.Component {
        
        private global::System.Data.SqlClient.SqlDataAdapter _adapter;
        
        private global::System.Data.SqlClient.SqlConnection _connection;
        
        private global::System.Data.SqlClient.SqlTransaction _transaction;
        
        private global::System.Data.SqlClient.SqlCommand[] _commandCollection;
        
        private bool _clearBeforeFill;
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public GetSummaryEventsTableAdapter() {
            this.ClearBeforeFill = true;
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        protected internal global::System.Data.SqlClient.SqlDataAdapter Adapter {
            get {
                if ((this._adapter == null)) {
                    this.InitAdapter();
                }
                return this._adapter;
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        internal global::System.Data.SqlClient.SqlConnection Connection {
            get {
                if ((this._connection == null)) {
                    this.InitConnection();
                }
                return this._connection;
            }
            set {
                this._connection = value;
                if ((this.Adapter.InsertCommand != null)) {
                    this.Adapter.InsertCommand.Connection = value;
                }
                if ((this.Adapter.DeleteCommand != null)) {
                    this.Adapter.DeleteCommand.Connection = value;
                }
                if ((this.Adapter.UpdateCommand != null)) {
                    this.Adapter.UpdateCommand.Connection = value;
              