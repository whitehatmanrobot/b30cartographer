ve(void);
	DllExport NURBSXFormCurve & operator=(const NURBSXFormCurve& curve);
	DllExport void SetParent(int index);
	DllExport void SetParentId(NURBSId id);
	DllExport int GetParent(void);
	DllExport NURBSId GetParentId(void);
	DllExport void SetXForm(TimeValue t, Matrix3& mat);
	DllExport Matrix3& GetXForm(TimeValue t);
};

class NURBSMirrorCurve : public NURBSCurve {
	friend class NURBSSet;
	NURBSId mParentId;
	int mParentIndex;
	NURBSMirrorAxis mAxis;
	Matrix3 mXForm;
	double mDistance;
	DllExport void Clean(NURBSIdTab ids);
public:
	DllExport NURBSMirrorCurve(void);
	DllExport virtual ~NURBSMirrorCurve(void);
	DllExport NURBSMirrorCurve & operator=(const NURBSMirrorCurve& curve);
	DllExport void SetParent(int index);
	DllExport void SetParentId(NURBSId id);
	DllExport int GetParent(void);
	DllExport NURBSId GetParentId(void);
	DllExport void SetAxis(NURBSMirrorAxis axis);
	DllExport NURBSMirrorAxis GetAxis(void);
	DllExport void SetXForm(TimeValue t, Matrix3& mat);
	DllExport Matrix3& GetXForm(TimeValue t);
	DllExport void SetDistance(TimeValue t, double d);
	DllExport double GetDistance(TimeValue t);
};


class NURBSFilletCurve : public NURBSCurve {
	friend class NURBSSet;
	NURBSId mParentId[2];
	int mParentIndex[2];
	BOOL mParentEnd[2];
	double mRadius;
    BOOL mTrimCurve[2];
    BOOL mFlipTrim[2];

	DllExport void Clean(NURBSIdTab ids);
public:
	DllExport NURBSFilletCurve(void);
	DllExport virtual ~NURBSFilletCurve(void);
	DllExport NURBSFilletCurve & operator=(const NURBSFilletCurve& curve);
	DllExport void SetParent(int pnum, int index);
	DllExport void SetParentId(int pnum, NURBSId id);
	DllExport int GetParent(int pnum);
	DllExport NURBSId GetParentId(int pnum);
	DllExport void SetEnd(int pnum, BOOL end);
	DllExport BOOL GetEnd(int pnum);
	DllExport void SetRadius(TimeValue t, double radius);
	DllExport double GetRadius(TimeValue t);

    DllExport BOOL GetTrimCurve(int pnum);
    DllExport void SetTrimCurve(int pnum, BOOL trim);
    DllExport BOOL GetFlipTrim(int pnum);
    DllExport void SetFlipTrim(int pnum, BOOL flip);
};


class NURBSChamferCurve : public NURBSCurve {
	friend class NURBSSet;
	NURBSId mParentId[2];
	int mParentIndex[2];
	BOOL mParentEnd[2];
	double mLength[2];
    BOOL mTrimCurve[2];
    BOOL mFlipTrim[2];

	DllExport void Clean(NURBSIdTab ids);
public:
	DllExport NURBSChamferCurve(void);
	DllExport virtual ~NURBSChamferCurve(void);
	DllExport NURBSChamferCurve & operator=(const NURBSChamferCurve& curve);
	DllExport void SetParent(int pnum, int index);
	DllExport void SetParentId(int pnum, NURBSId id);
	DllExport int GetParent(int pnum);
	DllExport NURBSId GetParentId(int pnum);
	DllExport void SetEnd(int pnum, BOOL end);
	DllExport BOOL GetEnd(int pnum);
	DllExport void SetLength(TimeValue t, int pnum, double length);
	DllExport double GetLength(TimeValue t, int pnum);

    DllExport BOOL GetTrimCurve(int pnum);
    DllExport void SetTrimCurve(int pnum, BOOL trim);
    DllExport BOOL GetFlipTrim(int pnum);
    DllExport void SetFlipTrim(int pnum, BOOL flip);
};


class NURBSIsoCurve : public NURBSCurve {
	friend class NURBSSet;
	NURBSId mParentId;
	int mParentIndex;
	BOOL mIsU;  // false for V...
	double mParam;
	BOOL mTrim;
	BOOL mFlipTrim;
	Point2 mSeed;
	DllExport void Clean(NURBSIdTab ids);
public:
	DllExport NURBSIsoCurve(void);
	DllExport virtual ~NURBSIsoCurve(void);
	DllExport NURBSIsoCurve & operator=(const NURBSIsoCurve& curve);
	DllExport void SetParent(int index);
	DllExport void SetParentId(NURBSId id);
	DllExport int GetParent(void);
	DllExport NURBSId GetParentId(void);
	DllExport void SetDirection(BOOL isU);
	DllExport BOOL GetDirection(void);
	DllExport void SetParam(TimeValue t, double p);
	DllExport double GetParam(TimeValue t);
	DllExport BOOL GetTrim();
	DllExport void SetTrim(BOOL trim);
	DllExport BOOL GetFlipTrim();
	DllExport void SetFlipTrim(BOOL flip);
	DllExport Point2 GetSeed();
	DllExport void SetSeed(Point2& seed);
};


class NURBSSurfaceEdgeCurve : public NURBSCurve {
	friend class NURBSSet;
	NURBSId mParentId;
	int mParentIndex;
	Point2 mSeed;
	DllExport void Clean(NURBSIdTab ids);
public:
	DllExport NURBSSurfaceEdgeCurve(void);
	DllExport virtual ~NURBSSurfaceEdgeCurve(void);
	DllExport NURBSSurfaceEdgeCurve & operator=(const NURBSSurfaceEdgeCurve& curve);
	DllExport void SetParent(int index);
	DllExport void SetParentId(NURBSId id);
	DllExport int GetParent(void);
	DllExport NURBSId GetParentId(void);
	DllExport Point2 GetSeed();
	DllExport void SetSeed(Point2& seed);
};


class NURBSProjectVectorCurve : public NURBSCurve {
	friend class NURBSSet;
	// parent 0 should be the surface parent 1 should be the curve
	NURBSId mParentId[2];
	int mParentIndex[2];
	BOOL mTrim;
	BOOL mFlipTrim;
	Point2 mSeed;
	Point3 mPVec;
	DllExport void Clean(NURBSIdTab ids);
public:
	DllExport NURBSProjectVectorCurve(void);
	DllExport virtual ~NURBSProjectVectorCurve(void);
	DllExport NURBSProjectVectorCurve & operator=(const NURBSProjectVectorCurve& curve);
	DllExport void SetParent(int pnum, int index);
	DllExport void SetParentId(int pnum, NURBSId id);
	DllExport int GetParent(int pnum);
	DllExport NURBSId GetParentId(int pnum);
	DllExport BOOL GetTrim();
	DllExport void SetTrim(BOOL trim);
	DllExport BOOL GetFlipTrim();
	DllExport void SetFlipTrim(BOOL flip);
	DllExport Point2 GetSeed();
	DllExport void SetSeed(Point2& seed);
	DllExport void SetPVec(TimeValue t, Point3& pvec); // projection vector
	DllExport Point3& GetPVec(TimeValue t);
};



class NURBSProjectNormalCurve : public NURBSCurve {
	friend class NURBSSet;
	// parent 0 should be the surface parent 1 should be the curve
	NURBSId mParentId[2];
	int mParentIndex[2];
	BOOL mTrim;
	BOOL mFlipTrim;
	Point2 mSeed;
	DllExport void Clean(NURBSIdTab ids);
public:
	DllExport NURBSProjectNormalCurve(void);
	DllExport virtual ~NURBSProjectNormalCurve(void);
	DllExport NURBSProjectNormalCurve & operator=(const NURBSProjectNormalCurve& curve);
	DllExport void SetParent(int pnum, int index);
	DllExport void SetParentId(int pnum, NURBSId id);
	DllExport int GetParent(int pnum);
	DllExport NURBSId GetParentId(int pnum);
	DllExport BOOL GetTrim();
	DllExport void SetTrim(BOOL trim);
	DllExport BOOL GetFlipTrim();
	DllExport void SetFlipTrim(BOOL flip);
	DllExport Point2 GetSeed();
	DllExport void SetSeed(Point2& seed);
};


class NURBSSurfSurfIntersectionCurve : public NURBSCurve {
	friend class NURBSSet;
	// parent 0 should be the surface parent 1 should be the curve
	NURBSId mParentId[2];
	int mParentIndex[2];
	BOOL mTrim[2];
	BOOL mFlipTrim[2];
	Point2 mSeed;
	DllExport void Clean(NURBSIdTab ids);
public:
	DllExport NURBSSurfSurfIntersectionCurve(void);
	DllExport virtual ~NURBSSurfSurfIntersectionCurve(void);
	DllExport NURBSSurfSurfIntersectionCurve & operator=(const NURBSSurfSurfIntersectionCurve& curve);
	DllExport void SetParent(int pnum, int index);
	DllExport void SetParentId(int pnum, NURBSId id);
	DllExport int GetParent(int pnum);
	DllExport NURBSId GetParentId(int pnum);
	DllExport BOOL GetTrim(int tnum);
	DllExport void SetTrim(int tnum, BOOL trim);
	DllExport BOOL GetFlipTrim(int tnum);
	DllExport void SetFlipTrim(int tnum, BOOL flip);
	DllExport Point2 GetSeed();
	DllExport void SetSeed(Point2& seed);
};



class NURBSCurveOnSurface : public NURBSCVCurve {
	friend class NURBSSet;
	NURBSId mParentId;
	int mParentIndex;
	BOOL mTrim;
	BOOL mFlipTrim;
	DllExport void Clean(NURBSIdTab ids);
public:
	DllExport NURBSCurveOnSurface(void);
	DllExport virtual ~NURBSCurveOnSurface(void);
	DllExport NURBSCurveOnSurface & operator=(const NURBSCurveOnSurface& curve);
	DllExport void SetParent(int index);
	DllExport void SetParentId(NURBSId id);
	DllExport int GetParent();
	DllExport NURBSId GetParentId();
	DllExport BOOL GetTrim();
	DllExport void SetTrim(BOOL trim);
	DllExport BOOL GetFlipTrim();
	DllExport void SetFlipTrim(BOOL flip);
};

class NURBSPointCurveOnSurface : public NURBSPointCurve {
	friend class NURBSSet;
	NURBSId mParentId;
	int mParentIndex;
	BOOL mTrim;
	BOOL mFlipTrim;
	DllExport void Clean(NURBSIdTab ids);
public:
	DllExport NURBSPointCurveOnSurface(void);
	DllExport virtual ~NURBSPointCurveOnSurface(void);
	DllExport NURBSPointCurveOnSurface & operator=(const NURBSPointCurveOnSurface& curve);
	DllExport void SetParent(int index);
	DllExport void SetParentId(NURBSId id);
	DllExport int GetParent();
	DllExport NURBSId GetParentId();
	DllExport BOOL GetTrim();
	DllExport void SetTrim(BOOL trim);
	DllExport BOOL GetFlipTrim();
	DllExport void SetFlipTrim(BOOL flip);
};


class NURBSSurfaceNormalCurve : public NURBSCurve {
	friend class NURBSSet;
	NURBSId mParentId;
	int mParentIndex;
	double mDistance;
	DllExport void Clean(NURBSIdTab ids);
public:
	DllExport NURBSSurfaceNormalCurve(void);
	DllExport virtual ~NURBSSurfaceNormalCurve(void);
	DllExport NURBSSurfaceNormalCurve & operator=(const NURBSSurfaceNormalCurve& curve);
	DllExport void SetParent(int index);
	DllExport void SetParentId(NURBSId id);
	DllExport int GetParent();
	DllExport NURBSId GetParentId();
	DllExport void SetDistance(TimeValue t, double dist);
	DllExport double GetDistance(TimeValue t);
};




enum NURBSTexSurfType {
	kNMapDefault,
	kNMapUserDefined,
	kNMapSufaceMapper
};

class NURBSTextureSurface {
	NURBSTexSurfType mMapperType;
	NURBSTexturePoint *mpPoints;
	int mNumUPoints;
	int mNumVPoints;

	NURBSId mParentId;
	int mParentIndex;
public:
	DllExport NURBSTextureSurface(void);
	DllExport ~NURBSTextureSurface(void);
	DllExport NURBSTextureSurface(NURBSTextureSurface& tsurf);
	DllExport NURBSTextureSurface & operator=(const NURBSTextureSurface& surf);
	DllExport NURBSTexSurfType MapperType();
	DllExport void SetMapperType(NURBSTexSurfType type);

	DllExport void SetParent(int index);
	DllExport void SetParentId(NURBSId id);
	DllExport int GetParent();
	DllExport NURBSId GetParentId();

	DllExport void SetNumPoints(int u, int v);
	DllExport int GetNumUPoints(void);
	DllExport int GetNumVPoints(void);
	DllExport void GetNumPoints(int &u, int &v);
	DllExport NURBSTexturePoint* GetPoint(int u, int v);
	DllExport void SetPoint(int u, int v, NURBSTexturePoint& pnt);
};



class NURBSTextureChannel;

class NURBSTextureChannelSet {
	friend class NURBSSurface;
    ~NURBSTextureChannelSet();

private:
    NURBSTextureChannel* GetChannelByIndex(int index) { return mTextureChannels[index]; }
    NURBSTextureChannel* GetChannel(int channel);
    NURBSTextureChannel* AddChannel(int channel);
    int NumChannels() { return mTextureChannels.Count(); }

    Tab<NURBSTextureChannel*> mTextureChannels;
};

class NURBSTextureChannel {
	friend class NURBSSurface;
	friend class NURBSTextureChannelSet;
private:
    DllExport NURBSTextureChannel(int channel);

    DllExport int GetChannel() { return mChannel; }

    DllExport BOOL GenerateUVs();
	DllExport void SetGenerateUVs(BOOL state);
	DllExport Point2 GetTextureUVs(TimeValue t, int i);
	DllExport void SetTextureUVs(TimeValue t, int i, Point2 pt);
	DllExport void GetTileOffset(TimeValue t, float &ut, float &vt, float &uo, float &vo, float &a);
	DllExport void SetTileOffset(TimeValue t, float ut, float vt, float uo, float vo, float a);

    DllExport NURBSTextureSurface& GetTextureSurface() {return mTexSurface; }
    DllExport void SetTextureSurface(NURBSTextureSurface& texSurf);

    int mChannel;

	BOOL mGenUVs;
	Point2 mTexUVs[4];

	float mUTile;
    float mVTile;
    float mUOffset;
    float mVOffset;
    float mAngle;

	NURBSTextureSurface mTexSurface;
};

class NURBSSurface : public NURBSObject {
	friend class NURBSCVSurface;
	friend class NURBSPointSurface;
	friend class NURBSBlendSurface;
	friend class NURBSNBlendSurface;
	friend class NURBSOffsetSurface;
	friend class NURBSXFormSurface;
	friend class NURBSMirrorSurface;
	friend class NURBSCapSurface;
	friend class NURBSIsoCurve;
	friend class NURBSProjectVectorCurve;
	friend class NURBSProjectNormalCurve;
	friend class NURBSSurfSurfIntersectionCurve;
	friend class NURBSCurveOnSurface;
	friend class NURBSPointCurveOnSurface;
	friend class NURBSMultiCurveTrimSurface;
	friend class NURBSTextureChannel;
	friend class NURBSTextureChannelSet;

private:
	DllExport NURBSTextureChannel* GetChannel(int index);

protected:
    NURBSTextureChannelSet mTextureChannelSet;

	BOOL mFlipNormals;
	BOOL mRenderable;
	int mMatID;
	BOOL mClosedInU, mClosedInV;

	// new for R3 -- optional
	TessApprox *mpVTess;
	TessApprox *mpRTess;
	TessApprox *mpRTessDisp;
	TessApprox *mpVTessCurve;
	TessApprox *mpRTessCurve;

    // Internal surface cache
    // 
    void* mpSurfCache;

public:

    // Internal use only cache
    void* GetSurfCache() { return mpSurfCache; }
    void SetSurfCache(void* pCache) { mpSurfCache = pCache; }

	DllExport NURBSSurface(void);
	DllExport virtual ~NURBSSurface(void);
	DllExport NURBSSurface & operator=(const NURBSSurface& surf);
	DllExport BOOL Renderable();
	DllExport void Renderable(BOOL state);
	DllExport BOOL FlipNormals();
	DllExport void FlipNormals(BOOL state);
	DllExport BOOL GenerateUVs(int channel = 0);
	DllExport void SetGenerateUVs(BOOL state, int channel = 0);
	DllExport int MatID();
	DllExport void MatID(int id);
	DllExport Point2 GetTextureUVs(TimeValue t, int i, int channel = 0);
	DllExport void SetTextureUVs(TimeValue t, int i, Point2 pt, int channel = 0);
	DllExport void GetTileOffset(TimeValue t, float &ut, float &vt, float &uo, float &vo, float &a, int channel = 0);
	DllExport void SetTileOffset(TimeValue t, float ut, float vt, float uo, float vo, float a, int channel = 0);

    DllExport NURBSTextureSurface& GetTextureSurface(int channel);
    DllExport void SetTextureSurface(int channel, NURBSTextureSurface& texSurf);

    DllExport int NumChannels();
	DllExport int GetChannelFromIndex(int index);



	DllExport BOOL IsClosedInU(void);
	DllExport BOOL IsClosedInV(void);

	DllExport BOOL Evaluate(TimeValue t, double u, double v, Point3& pt,
			Point3& dPdU, Point3& dPdV);
	DllExport BOOL Evaluate(TimeValue t, double u, double v, Point3& pt,
			Point3& dPdU, Point3& dPdV, Point3& d2PdU2, Point3& d2PdV2, Point3& d2PdUdV);
	DllExport void GetParameterRange(TimeValue t, double& uMin, double& uMax, double& vMin, double& vMax);
	DllExport BOOL GetNURBSData(TimeValue t,
								int& degreeInU,
								int& degreeInV,
								int& numInU,
								int& numInV,
								NURBSCVTab& cvs,
								int& numKnotsInU,
								int& numKnotsInV,
								NURBSKnotTab& uKnots, 
								NURBSKnotTab& vKnots);
	DllExport BOOL GetCLPTextureSurfaceData(TimeValue t, int channel,
								int& degreeInU,
								int& degreeInV,
								int& numInU,
								int& numInV,
								NURBSCVTab& cvs,
								int& numKnotsInU,
								int& numKnotsInV,
								NURBSKnotTab& uKnots, 
								NURBSKnotTab& vKnots);
	DllExport int NumTrimLoops(TimeValue t);
	DllExport int NumCurvesInLoop(TimeValue t, int loop);
    DllExport BOOL Get2dTrimCurveData(TimeValue t, int loop, int curve,
                                        int& degree,
                                        int& numCVs,
                                        NURBSCVTab& cvs,
                                        int& numKnots,
                                        NURBSKnotTab& knots);
	DllExport BOOL Get3dTrimCurveData(TimeValue t, int loop, int curve,
										int& degree,
										int& numCVs,
										NURBSCVTab& cvs,
										int& numKnots,
										NURBSKnotTab& knots);
	DllExport TessApprox* GetProdTess(NURBSTessType type=kNTessSurface);
	DllExport TessApprox* GetViewTess(NURBSTessType type=kNTessSurface);
	DllExport void SetProdTess(TessApprox& tess, NURBSTessType type=kNTessSurface);
	DllExport void SetViewTess(TessApprox& tess, NURBSTessType type=kNTessSurface);
	DllExport void ClearViewTess(NURBSTessType type=kNTessSurface);
	DllExport void ClearProdTess(NURBSTessType type=kNTessSurface);
};


class NURBSCVSurface : public NURBSSurface {
	friend class NURBSSet;
	NURBSControlVertex *mpCVs;
	double *mpUKnots;
	double *mpVKnots;
	int mUOrder;
	int mVOrder;
	int mNumUCVs;
	int mNumVCVs;
	int mNumUKnots;
	int mNumVKnots;
	BOOL mRigid;
	NURBSAutoParam mAutoParam;
public:
	DllExport NURBSCVSurface(void);
	DllExport virtual ~NURBSCVSurface(void);
	DllExport NURBSCVSurface & operator=(const NURBSCVSurface& surf);
	DllExport BOOL IsRigid();
	DllExport void SetRigid(BOOL isRigid);
	DllExport NURBSAutoParam AutoParam();
	DllExport void AutoParam(TimeValue t, NURBSAutoParam param);
	DllExport void Reparameterize(TimeValue t, NURBSParamaterization param);
	DllExport void CloseInU(void);
	DllExport void CloseInV(void);
	DllExport void SetUOrder(int order);
	DllExport int GetUOrder(void);
	DllExport int GetVOrder(void);
	DllExport void SetVOrder(int order);
	DllExport void SetNumUKnots(int num);         // data is NOT maintained
	DllExport void SetNumVKnots(int num);         // data is NOT maintained
	DllExport int GetNumUKnots(void);
	DllExport int GetNumVKnots(void);
	DllExport void SetNumCVs(int u, int v);       // data is NOT maintained
	DllExport int GetNumUCVs(void);
	DllExport int GetNumVCVs(void);
	DllExport void GetNumCVs(int &u, int &v);
	DllExport double GetUKnot(int index);
	DllExport double GetVKnot(int index);
	DllExport void SetUKnot(int index, double value);
	DllExport void SetVKnot(int index, double value);
	DllExport NURBSControlVertex* GetCV(int u, int v);
	DllExport void SetCV(int u, int v, NURBSControlVertex& cv);

	DllExport void SetTransformMatrix(TimeValue t, SetXFormPacket& mat);
	DllExport Matrix3 GetTransformMatrix(TimeValue t);

	DllExport void EdgesOverlap(BOOL& uOverlap, BOOL& vOverlap);
	// If you refine in U (U_V_Both = 0) you must specify v
	// If you refine in V (U_V_Both = 1) you must specify u
	// If you refine in U and (U_V_Both = -1) you must specify u and v
	DllExport void Refine(TimeValue t, double u, double v, int U_V_Both);
	DllExport void Insert(TimeValue t, double u, double v, int U_V_Both);
};


class NURBSPointSurface : public NURBSSurface {
	friend class NURBSSet;
	NURBSIndependentPoint *mpPts;
	int mNumUPts;
	int mNumVPts;
public:
	DllExport NURBSPointSurface(void);
	DllExport virtual ~NURBSPointSurface(void);
	DllExport NURBSPointSurface & operator=(const NURBSPointSurface& surf);
	DllExport void CloseInU(void);
	DllExport void CloseInV(void);
	DllExport void SetNumPts(int u, int v);       // data is NOT maintained
	DllExport int GetNumUPts(void);
	DllExport int GetNumVPts(void);
	DllExport void GetNumPts(int &u, int &v);
	DllExport NURBSIndependentPoint* GetPoint(int u, int v);
	DllExport void SetPoint(int u, int v, NURBSIndependentPoint& pt);

	DllExport void SetTransformMatrix(TimeValue t, SetXFormPacket& mat);
	DllExport Matrix3 GetTransformMatrix(TimeValue t);

	// If you refine in U (U_V_Both = 0) you must specify v
	// If you refine in V (U_V_Both = 1) you must specify u
	// If you refine in U and (U_V_Both = -1) you must specify u and v
	DllExport void Refine(TimeValue t, double u, double v, int U_V_Both);
};

class NURBSBlendSurface : public NURBSSurface {
	friend class NURBSSet;
	NURBSId mParentId[2];
	int mParentIndex[2];
	int mParentEdge[2];
	BOOL mFlip[2];
	double mTension[2];
	double mCurveStartParam[2];
	DllExport void Clean(NURBSIdTab ids);
public:
	DllExport NURBSBlendSurface(void);
	DllExport virtual ~NURBSBlendSurface(void);
	DllExport NURBSBlendSurface & operator=(const NURBSBlendSurface& surf);
	DllExport void SetParent(int pnum, int index);
	DllExport void SetParentId(int pnum, NURBSId id);
	DllExport int GetParent(int pnum);
	DllExport NURBSId GetParentId(int pnum);
	DllExport void SetEdge(int pnum, int edge);
	DllExport int GetEdge(int pnum);
	DllExport void SetTension(TimeValue t, int pnum, double ten);
	DllExport double GetTension(TimeValue t, int pnum);
	DllExport void SetFlip(int pnum, BOOL flip);
	DllExport BOOL GetFlip(int pnum);

	// only if the parent is a closed curve
	DllExport void SetCurveStartPoint(TimeValue t, int pnum, double startpoint);
	DllExport double GetCurveStartPoint(TimeValue t, int pnum);
};


class NURBSNBlendSurface : public NURBSSurface {
	friend class NURBSSet;
	// The parents can be either curves or surfaces (with edge IDs)
	NURBSId mParentId[4];
	int mParentIndex[4];
	int mParentEdge[4];  // used only if the parent is a surface
	DllExport void Clean(NURBSIdTab ids);
public:
	DllExport NURBSNBlendSurface(void);
	DllExport virtual ~NURBSNBlendSurface(void);
	DllExport NURBSNBlendSurface & operator=(const NURBSNBlendSurface& surf);
	DllExport void SetParent(int pnum, int index);
	DllExport void SetParentId(int pnum, NURBSId id);
	DllExport int GetParent(int pnum);
	DllExport NURBSId GetParentId(int pnum);
	DllExport void SetEdge(int pnum, int edge);
	DllExport int GetEdge(int pnum);
};

class NURBSOffsetSurface : public NURBSSurface {
	friend class NURBSSet;
	NURBSId mParentId;
	int mParentIndex;
	double mDistance;
	DllExport void Clean(NURBSIdTab ids);
public:
	DllExport NURBSOffsetSurface(void);
	DllExport virtual ~NURBSOffsetSurface(void);
	DllExport NURBSOffsetSurface & operator=(const NURBSOffsetSurface& surf);
	DllExport void SetParent(int index);
	DllExport void SetParentId(NURBSId id);
	DllExport int GetParent(void);
	DllExport NURBSId GetParentId(void);
	DllExport void SetDistance(TimeValue t, double d);
	DllExport double GetDistance(TimeValue t);
};

class NURBSXFormSurface : public NURBSSurface {
	friend class NURBSSet;
	NURBSId mParentId;
	int mParentIndex;
	Matrix3 mXForm;
	DllExport void Clean(NURBSIdTab ids);
public:
	DllExport NURBSXFormSurface(void);
	DllExport virtual ~NURBSXFormSurface(void);
	DllExport NURBSXFormSurface & operator=(const NURBSXFormSurface& surf);
	DllExport void SetParent(int index);
	DllExport void SetParentId(NURBSId id);
	DllExport int GetParent(void);
	DllExport NURBSId GetParentId(void);
	DllExport void SetXForm(TimeValue t, Matrix3& mat);
	DllExport Matrix3& GetXForm(TimeValue t);
};

class NURBSMirrorSurface : public NURBSSurface {
	friend class NURBSSet;
	NURBSId mParentId;
	int mParentIndex;
	NURBSMirrorAxis mAxis;
	Matrix3 mXForm;
	double mDistance;
	DllExport void Clean(NURBSIdTab ids);
public:
	DllExport NURBSMirrorSurface(void);
	DllExport virtual ~NURBSMirrorSurface(void);
	DllExport NURBSMirrorSurface & operator=(const NURBSMirrorSurface& surf);
	DllExport void SetParent(int index);
	DllExport void SetParentId(NURBSId id);
	DllExport int GetParent(void);
	DllExport NURBSId GetParentId(void);
	DllExport void SetAxis(NURBSMirrorAxis axis);
	DllExport NURBSMirrorAxis GetAxis(void);
	DllExport void SetXForm(TimeValue t, Matrix3& mat);
	DllExport Matrix3& GetXForm(TimeValue t);
	DllExport void SetDistance(TimeValue t, double d);
	DllExport double GetDistance(TimeValue t);
};

class NURBSRuledSurface : public NURBSSurface {
	friend class NURBSSet;
	NURBSId mParentId[2];
	int mParentIndex[2];
	BOOL mFlip[2];
	double mCurveStartParam[2];
	DllExport void Clean(NURBSIdTab ids);
public:
	DllExport NURBSRuledSurface(void);
	DllExport virtual ~NURBSRuledSurface(void);
	DllExport NURBSRuledSurface & operator=(const NURBSRuledSurface& surf);
	DllExport void SetParent(int pnum, int index);
	DllExport void SetParentId(int pnum, NURBSId id);
	DllExport int GetParent(int pnum);
	DllExport NURBSId GetParentId(int pnum);
	DllExport void SetFlip(int pnum, BOOL flip);
	DllExport BOOL GetFlip(int pnum);
	DllExport void SetCurveStartPoint(TimeValue t, int pnum, double startpoint);
	DllExport double GetCurveStartPoint(TimeValue t, int pnum);
};


class NURBSULoftSurface : public NURBSSurface {
	friend class NURBSSet;
	Tab<NURBSId> mParentId;
	Tab<int> mParentIndex;
	Tab<BOOL> mFlip;
	Tab<double>mCurveStartParam;
	Tab<double>mTension;
	Tab<BOOL> mUseTangents;
	Tab<BOOL> mFlipTangents;
	BOOL mAutoAlign;
	BOOL mCloseLoft;
	DllExport void Clean(NURBSIdTab ids);
public:
	DllExport NURBSULoftSurface(void);
	DllExport virtual ~NURBSULoftSurface(void);
	DllExport NURBSULoftSurface & operator=(const NURBSULoftSurface& surf);
	DllExport void SetNumCurves(int num);
	DllExport int GetNumCurves(void);
	DllExport int AppendCurve(int index, BOOL flip, double startpoint=0.0,
								double tension=0.0, BOOL useTangent=FALSE, BOOL flipTangent=FALSE);
	DllExport int AppendCurve(NURBSId id, BOOL flip, double startpoint=0.0,
								double tension=0.0, BOOL useTangent=FALSE, BOOL flipTangent=FALSE);
	DllExport void SetParent(int pnum, int index);
	DllExport void SetParentId(int pnum, NURBSId id);
	DllExport int GetParent(int pnum);
	DllExport NURBSId GetParentId(int pnum);
	DllExport void SetFlip(int pnum, BOOL flip);
	DllExport BOOL GetFlip(int pnum);
	DllExport void SetCurveStartPoint(TimeValue t, int pnum, double startpoint);
	DllExport double GetCurveStartPoint(TimeValue t, int pnum);

	DllExport void SetCurveTension(TimeValue t, int pnum, double tension);
	DllExport double GetCurveTension(TimeValue t, int pnum);
	DllExport void SetCurveUseSurfaceTangent(int pnum, BOOL useTangent);
	DllExport BOOL GetCurveUseSurfaceTangent(int pnum);
	DllExport void SetFlipTangent(int pnum, BOOL flipTangent);
	DllExport BOOL GetFlipTangent(int pnum);
	DllExport void SetAutoAlign(BOOL autoalign);
	DllExport BOOL GetAutoAlign();
	DllExport void SetCloseLoft(BOOL closeLoft);
	DllExport BOOL GetCloseLoft();
};


class NURBSUVLoftSurface : public NURBSSurface {
	friend class NURBSSet;
	Tab<NURBSId> mUParentId;
	Tab<int> mUParentIndex;
	Tab<NURBSId> mVParentId;
	Tab<int> mVParentIndex;
	DllExport void Clean(NURBSIdTab ids);
public:
	DllExport NURBSUVLoftSurface(void);
	DllExport virtual ~NURBSUVLoftSurface(void);
	DllExport NURBSUVLoftSurface & operator=(const NURBSUVLoftSurface& surf);

	DllExport void SetNumUCurves(int num);
	DllExport int GetNumUCurves(void);
	DllExport int AppendUCurve(int index);
	DllExport int AppendUCurve(NURBSId id);
	DllExport void SetUParent(int pnum, int index);
	DllExport void SetUParentId(int pnum, NURBSId id);
	DllExport int GetUParent(int pnum);
	DllExport NURBSId GetUParentId(int pnum);

	DllExport void SetNumVCurves(int num);
	DllExport int GetNumVCurves(void);
	DllExport int AppendVCurve(int index);
	DllExport int AppendVCurve(NURBSId id);
	DllExport void SetVParent(int pnum, int index);
	DllExport void SetVParentId(int pnum, NURBSId id);
	DllExport int GetVParent(int pnum);
	DllExport NURBSId GetVParentId(int pnum);
};



class NURBSExtrudeSurface : public NURBSSurface {
	friend class NURBSSet;
	NURBSId mParentId;
	int mParentIndex;
	Matrix3 mXForm;
	double mDistance;
	double mCurveStartParam;
	DllExport void Clean(NURBSIdTab ids);
public:
	DllExport NURBSExtrudeSurface(void);
	DllExport virtual ~NURBSExtrudeSurface(void);
	DllExport NURBSExtrudeSurface & operator=(const NURBSExtrudeSurface& surf);
	DllExport void SetParent(int index);
	DllExport void SetParentId(NURBSId id);
	DllExport int GetParent(void);
	DllExport NURBSId GetParentId(void);
	DllExport void SetAxis(TimeValue t, Matrix3& ray);
	DllExport Matrix3& GetAxis(TimeValue t);
	DllExport void SetDistance(TimeValue t, double d);
	DllExport double GetDistance(TimeValue t);
	DllExport void SetCurveStartPoint(TimeValue t, double startpoint);
	DllExport double GetCurveStartPoint(TimeValue t);
};


class NURBSLatheSurface : public NURBSSurface {
	friend class NURBSSet;
	NURBSId mParentId;
	int mParentIndex;
	Matrix3 mXForm;
	double mRotation;
	double mCurveStartParam;
	DllExport void Clean(NURBSIdTab ids);
public:
	DllExport NURBSLatheSurface(void);
	DllExport virtual ~NURBSLatheSurface(void);
	DllExport NURBSLatheSurface & operator=(const NURBSLatheSurface& surf);
	DllExport void SetParent(int index);
	DllExport void SetParentId(NURBSId id);
	DllExport int GetParent(void);
	DllExport NURBSId GetParentId(void);
	DllExport void SetAxis(TimeValue t, Matrix3& ray);
	DllExport Matrix3& GetAxis(TimeValue t);
	DllExport void SetRotation(TimeValue t, double degrees);
	DllExport double GetRotation(TimeValue t);
	DllExport void SetCurveStartPoint(TimeValue t, double startpoint);
	DllExport double GetCurveStartPoint(TimeValue t);
};


class NURBSCapSurface : public NURBSSurface {
	friend class NURBSSet;
	NURBSId mParentId;
	int mParentIndex;
	int mParentEdge;
	double mCurveStartParam;
	DllExport void Clean(NURBSIdTab ids);
public:
	DllExport NURBSCapSurface(void);
	DllExport virtual ~NURBSCapSurface(void);
	DllExport NURBSCapSurface & operator=(const NURBSCapSurface& surf);
	DllExport void SetParent(int index);
	DllExport void SetParentId(NURBSId id);
	DllExport int GetParent(void);
	DllExport NURBSId GetParentId(void);
	DllExport void SetEdge(int edge);
	DllExport int GetEdge();

	// only if the parent is a closed curve
	DllExport void SetCurveStartPoint(TimeValue t, double startpoint);
	DllExport double GetCurveStartPoint(TimeValue t);
};


class NURBS1RailSweepSurface : public NURBSSurface {
	friend class NURBSSet;
	NURBSId mRailId;
	int mRailIndex;
	Tab<NURBSId> mParentId;
	Tab<int> mParentIndex;
	Tab<BOOL> mFlip;
	Tab<double> mCurveStartParam;
	BOOL mParallel;
	BOOL mSnapCrossSections;
	BOOL mRoadlike;
	Matrix3 mXForm;
	DllExport void Clean(NURBSIdTab ids);
public:
	DllExport NURBS1RailSweepSurface(void);
	DllExport virtual ~NURBS1RailSweepSurface(void);
	DllExport NURBS1RailSweepSurface & operator=(const NURBS1RailSweepSurface& surf);
	DllExport void SetParentRail(int index);
	DllExport void SetParentRailId(NURBSId id);
	DllExport int GetParentRail();
	DllExport NURBSId GetParentRailId();
	DllExport void SetNumCurves(int num);
	DllExport int GetNumCurves(void);
	DllExport int AppendCurve(int index, BOOL flip, double startpoint=0.0);
	DllExport int AppendCurve(NURBSId id, BOOL flip, double startpoint=0.0);
	DllExport void SetParent(int pnum, int index);
	DllExport void SetParentId(int pnum, NURBSId id);
	DllExport int GetParent(int pnum);
	DllExport NURBSId GetParentId(int pnum);
	DllExport void SetFlip(int pnum, BOOL flip);
	DllExport BOOL GetFlip(int pnum);
	DllExport void SetParallel(BOOL para);
	DllExport BOOL GetParallel();
	DllExport void SetCurveStartPoint(TimeValue t, int pnum, double startpoint);
	DllExport double GetCurveStartPoint(TimeValue t, int pnum);
	DllExport void SetSnapCS(BOOL snapCS);
	DllExport BOOL GetSnapCS();
	DllExport void SetRoadlike(BOOL roadlike);
	DllExport BOOL GetRoadlike();
	DllExport void SetAxis(TimeValue t, Matrix3& ray);
	DllExport Matrix3& GetAxis(TimeValue t);
};


class NURBS2RailSweepSurface : public NURBSSurface {
	friend class NURBSSet;
	Tab<NURBSId> mParentId;
	Tab<int> mParentIndex;
	Tab<BOOL> mFlip;
	NURBSId mRailParentId[2];
	int mRailParentIndex[2];
	BOOL mParallel;
	BOOL mScale;
	BOOL mSnapCrossSections;
	Tab<double> mCurveStartParam;
	DllExport void Clean(NURBSIdTab ids);
public:
	DllExport NURBS2RailSweepSurface(void);
	DllExport virtual ~NURBS2RailSweepSurface(void);
	DllExport NURBS2RailSweepSurface & operator=(const NURBS2RailSweepSurface& surf);

	DllExport void SetNumCurves(int num);
	DllExport int GetNumCurves(void);
	DllExport int AppendCurve(int index, BOOL flip, double startpoint=0.0);
	DllExport int AppendCurve(NURBSId id, BOOL flip, double startpoint=0.0);
	DllExport void SetParent(int pnum, int index);
	DllExport void SetParentId(int pnum, NURBSId id);
	DllExport int GetParent(int pnum);
	DllExport NURBSId GetParentId(int pnum);
	DllExport void SetFlip(int pnum, BOOL flip);
	DllExport BOOL GetFlip(int pnum);
	DllExport void SetParallel(BOOL para);
	DllExport BOOL GetParallel();
	DllExport void SetScale(BOOL scale);
	DllExport BOOL GetScale();
	DllExport void SetSnapCS(BOOL snapCS);
	DllExport BOOL GetSnapCS();

	DllExport void SetRailParent(int pnum, int index);
	DllExport void SetRailParentId(int pnum, NURBSId id);
	DllExport int GetRailParent(int pnum);
	DllExport NURBSId GetRailParentId(int pnum);

	DllExport void SetCurveStartPoint(TimeValue t, int pnum, double startpoint);
	DllExport double GetCurveStartPoint(TimeValue t, int pnum);
};



class NURBSMultiCurveTrimSurface : public NURBSSurface {
	friend class NURBSSet;
	Tab<NURBSId> mParentId;
	Tab<int> mParentIndex;
	NURBSId mSurfaceId;
	int mSurfaceIndex;
	BOOL mFlipTrim;
	DllExport void Clean(NURBSIdTab ids);
public:
	DllExport NURBSMultiCurveTrimSurface(void);
	DllExport virtual ~NURBSMultiCurveTrimSurface(void);
	DllExport NURBSMultiCurveTrimSurface & operator=(const NURBSMultiCurveTrimSurface& surf);

	DllExport void SetNumCurves(int num);
	DllExport int GetNumCurves(void);
	DllExport int AppendCurve(int index);
	DllExport int AppendCurve(NURBSId id);
	DllExport void SetParent(int pnum, int index);
	DllExport void SetParentId(int pnum, NURBSId id);
	DllExport int GetParent(int pnum);
	DllExport NURBSId GetParentId(int pnum);

	DllExport void SetSurfaceParent(int index);
	DllExport void SetSurfaceParentId(NURBSId id);
	DllExport int GetSurfaceParent();
	DllExport NURBSId GetSurfaceParentId();

	DllExport BOOL GetFlipTrim();
	DllExport void SetFlipTrim(BOOL flip);
};



class NURBSFilletSurface : public NURBSSurface {
	friend class NURBSSet;
	// parent 0 should be the surface parent 1 should be the curve
	NURBSId mParentId[2];
	int mParentIndex[2];
	BOOL mCubic;
	float mRadius[2];
	Point2 mSeed[2];
    BOOL mTrimSurface[2];
    BOOL mFlipTrim[2];
	DllExport void Clean(NURBSIdTab ids);
public:
	DllExport NURBSFilletSurface(void);
	DllExport virtual ~NURBSFilletSurface(void);
	DllExport NURBSFilletSurface & operator=(const NURBSFilletSurface& curve);
	DllExport void SetParent(int pnum, int index);
	DllExport void SetParentId(int pnum, NURBSId id);
	DllExport int GetParent(int pnum);
	DllExport NURBSId GetParentId(int pnum);
	DllExport Point2 GetSeed(int pnum);
	DllExport void SetSeed(int pnum, Point2& seed);
	DllExport BOOL IsCubic();
	DllExport void SetCubic(BOOL cubic);
	DllExport float GetRadius(TimeValue t, int rnum);
	DllExport void SetRadius(TimeValue t, int rnum, float radius);

    DllExport BOOL GetTrimSurface(int pnum);
    DllExport void SetTrimSurface(int pnum, BOOL trim);
    DllExport BOOL GetFlipTrim(int pnum);
    DllExport void SetFlipTrim(int pnum, BOOL flip);
};



class NURBSDisplay {
public:
	DllExport NURBSDisplay();
	DllExport NURBSDisplay & operator=(const NURBSDisplay& disp);

	BOOL mDisplayCurves;
	BOOL mDisplaySurfaces;
	BOOL mDisplayLattices;
	BOOL mDisplaySurfCVLattices;
	BOOL mDisplayCurveCVLattices;
	BOOL mDisplayDependents;
	BOOL mDisplayTrimming;
	BOOL mDegradeOnMove;
    BOOL mDisplayShadedLattice;
};



class NURBSFuseSurfaceCV {
public:
	DllExport NURBSFuseSurfaceCV();
	int mSurf1, mSurf2;
	int mRow1, mCol1, mRow2, mCol2;
};


class NURBSFuseCurveCV {
public:
	DllExport NURBSFuseCurveCV();
	int mCurve1, mCurve2;
	int mCV1, mCV2;
};

class NURBSSet {
protected:
	friend DllExport Object* CreateNURBSObject(IObjParam* ip, NURBSSet *nset, Matrix3& mat);
	friend DllExport int AddNURBSObjects(Object* MAXobj, IObjParam* ip, NURBSSet *nset);
    friend DllExport BOOL GetNURBSSet(Object *object, TimeValue t, NURBSSet &nset, BOOL Relational);
	TessApprox *mpVTess;
	TessApprox *mpRTess;
	// new for R3 -- optional
	TessApprox *mpRTessDisp;
	TessApprox *mpVTessCurve;
	TessApprox *mpRTessCurve;

	float mTessMerge;
	Tab<NURBSObject*> mObjects;
	Object *mpObject;
	NURBSDisplay mDisplay;

public:
	DllExport NURBSSet(void);
	DllExport virtual ~NURBSSet(void);
	DllExport void Clean();	// this method removes any relation to a live NURBS object
	DllExport int GetNumObjects();
	DllExport void SetObject(int index, NURBSObject* obj);
	DllExport int AppendObject(NURBSObject* obj);
	DllExport void RemoveObject(int index);
	DllExport void DeleteObjects();
	DllExport NURBSObject* GetNURBSObject(int index);
	DllExport NURBSObject* GetNURBSObject(NURBSId id);
	DllExport TessApprox* GetProdTess(NURBSTessType type=kNTessSurface);
	DllExport TessApprox* GetViewTess(NURBSTessType type=kNTessSurface);
	DllExport void SetProdTess(TessApprox& tess, NURBSTessType type=kNTessSurface);
	DllExport void SetViewTess(TessApprox& tess, NURBSTessType type=kNTessSurface);
	DllExport void ClearViewTess(NURBSTessType type=kNTessSurface);
	DllExport void ClearProdTess(NURBSTessType type=kNTessSurface);
	DllExport float GetTessMerge();
	DllExport void SetTessMerge(float merge);
	DllExport Object* GetMAXObject();
	DllExport NURBSDisplay GetDisplaySettings();
	DllExport void SetDisplaySettings(NURBSDisplay& disp);


	Tab<NURBSFuseSurfaceCV> mSurfFuse;
	Tab<NURBSFuseCurveCV> mCurveFuse;
};




typedef NURBSResult (*SurfParamRangeProc)(double& uMin, double& uMax, double& vMin, double& vMax);
typedef NURBSResult (*SurfEvalProc)(double u, double v, Point3& pt);
typedef NURBSResult (*SurfEvalTan)(double u, double v, Point3& uTan, Point3& vTan);
typedef NURBSResult (*SurfEvalMixedProc)(double u, double v, Point3& mixed);

// base class for a proceedurally defined surfaces
// NOTE THIS IS NOT SUBCLASSED FROM NURBSObject
// You must use the GenNURBSCVSurfaceProcedurally
class NURBSProceeduralSurface {
public:
	SurfParamRangeProc	mParamProc;		// this one MUST be implemented
	SurfEvalProc		mEvalProc;		// this one MUST be implemented
	SurfEvalTan			mEvalTanProc;	// this one is optional
	SurfEvalMixedProc	mEvalMixedProc; // this one is optional
	DllExport NURBSProceeduralSurface(SurfParamRangeProc param, SurfEvalProc eval,
							SurfEvalTan tan, SurfEvalMixedProc mixed);
};
DllExport NURBSResult GenNURBSCVSurfaceProceedurally(NURBSProceeduralSurface *pSurf, double tolerence, NURBSCVSurface& surf);



typedef NURBSResult (*CurveParamRangeProc)(double& tMin, double& tMax);
typedef NURBSResult (*CurveEvalProc)(double u, Point3& pt);
typedef NURBSResult (*CurveEvalTan)(double u, Point3& pt, Point3& tan);
typedef NURBSResult (*CurveArcLengthProc)(double& arcLength);
// base class for a proceedurally defined curves
// NOTE THIS IS NOT SUBCLASSED FROM NURBSObject
// You must use the GenNURBSCVCurveProcedurally
class NURBSProceeduralCurve {
public:
	CurveParamRangeProc	mParamProc;		// this one MUST be implemented
	CurveEvalProc		mEvalProc;		// this one MUST be implemented
	CurveEvalTan		mEvalTanProc;	// this one is optional
	CurveArcLengthProc	mArcLengthProc; // this one is optional
	DllExport NURBSProceeduralCurve(CurveParamRangeProc param, CurveEvalProc eval,
							CurveEvalTan tan, CurveArcLengthProc arclen);
};

DllExport NURBSResult GenNURBSCVCurveProceedurally(NURBSProceeduralCurve *pCrv, double tolerence, NURBSCVCurve& crv);






DllExport NURBSResult GenNURBSLatheSurface(NURBSCVCurve& curve, Point3& origin, Point3& north,
									float start, float end, NURBSCVSurface& surf);
DllExport NURBSResult GenNURBSSphereSurface(float radius, Point3& center, Point3& northAxis, Point3& refAxis,
					float startAngleU, float endAngleU, float startAngleV, float endAngleV, BOOL open, NURBSCVSurface& surf);
DllExport NURBSResult GenNURBSCylinderSurface(float radius, float height, Point3& origin, Point3& symAxis, Point3& refAxis,
					float startAngle, float endAngle, BOOL open, NURBSCVSurface& surf);
DllExport NURBSResult GenNURBSConeSurface(float radius1, float radius2, float height, Point3& origin, Point3& symAxis, Point3& refAxis,
					float startAngle, float endAngle, BOOL open, NURBSCVSurface& surf);
DllExport NURBSResult GenNURBSTorusSurface(float majorRadius, float minorRadius, Point3& origin,
					Point3& symAxis, Point3& refAxis, float startAngleU, float endAngleU,
					float startAngleV, float endAngleV, BOOL open, NURBSCVSurface& surf);

DllExport Object *CreateNURBSObject(IObjParam* ip, NURBSSet *nset, Matrix3& mat);
DllExport int AddNURBSObjects(Object* obj, IObjParam* ip, NURBSSet *nset);

DllExport Object *CreateNURBSLatheShape(IObjParam* ip, TSTR name, TimeValue t, ShapeObject *shape,
                     Matrix3& axis, float degrees, int capStart, int capEnd,
                     int capType, BOOL weldCore, BOOL flipNormals, BOOL texturing,
					 int segs, BOOL matIds, BOOL shapeIDs);
DllExport Object *CreateNURBSExtrudeShape(IObjParam* ip, TSTR name, TimeValue t, ShapeObject *shape, float amount,
					   int capStart, int capEnd, int capType, BOOL texturing,
					   BOOL matIds, BOOL shapeIDs);

DllExport BOOL GetNURBSSet(Object *object, TimeValue t, NURBSSet &nset, BOOL Relational);



// modify extant objects
DllExport NURBSResult SetSurfaceApprox(Object* obj, BOOL viewport, TessApprox *tess, BOOL clearSurfs=FALSE);
DllExport NURBSResult SetCurveApprox(Object* obj, BOOL viewport, TessApprox *tess, BOOL clearSurfs);
DllExport NURBSResult SetDispApprox(Object* obj, TessApprox *tess, BOOL clearSurfs);
DllExport NURBSResult SetSurfaceDisplaySettings(Object* obj, NURBSDisplay& disp);
DllExport NURBSResult GetSurfaceDisplaySettings(Object* obj, NURBSDisplay& disp);

DllExport NURBSResult Transform(Object* obj, NURBSIdTab& ids, SetXFormPacket& xPack, Matrix3& mat, TimeValue t);

DllExport NURBSResult BreakCurve(Object* obj, NURBSId id, double u, TimeValue t);
DllExport NURBSResult BreakSurface(Object* obj, NURBSId id, BOOL breakU, double param, TimeValue t);

DllExport NURBSResult JoinCurves(Object* obj, NURBSId id1, NURBSId id2, BOOL begin1, BOOL begin2,
								 double tolerance, double ten1, double ten2, TimeValue t);
DllExport NURBSResult JoinSurfaces(Object* obj, NURBSId id1, NURBSId id2, int edge1, int edge2,
								   double tolerance, double ten1, double ten2, TimeValue t);

DllExport NURBSResult ZipCurves(Object* obj, NURBSId id1, NURBSId id2, BOOL begin1, BOOL begin2,
								 double tolerance, TimeValue t);
DllExport NURBSResult ZipSurfaces(Object* obj, NURBSId id1, NURBSId id2, int edge1, int edge2,
								   double tolerance, TimeValue t);

DllExport NURBSId MakeIndependent(Object* obj, NURBSId id, TimeValue t);
DllExport NURBSId MakeRigid(Object* obj, NURBSId id, TimeValue t);
DllExport void SetApproxPreset(Object* pObj, int i);
DllExport void ToggleShadedLattice(Object* pObj);
DllExport TessApprox* GetTessPreset(int which, int preset);
DllExport void SetTessPreset(int which, int preset, TessApprox& tess);

DllExport Object *BuildEMObjectFromLofterObject(Object *loftObject, double tolerance);
DllExport Object *BuildEMObjectFromPatchObject(Object *patchObject);

typedef Tab<NURBSId> NURBSIdList;

DllExport Object *DetachObjects(TimeValue t, INode *pNode, Object* pobj, NURBSIdList list, char *newObjName, BOOL copy, BOOL relational);


DllExport NURBSSubObjectLevel GetSelectionLevel(Object* pObj);
DllExport NURBSResult SetSelectionLLevel(Object* pObj, NURBSSubObjectLevel level);

DllExport NURBSResult GetSelection(Object* pObj, NURBSSubObjectLevel level,
                                   BitArray& selset);

DllExport NURBSResult SetSelection(Object* pObj, NURBSSubObjectLevel level,
                                   BitArray& selset);

DllExport NURBSResult
MoveCurrentSelection(Object* pObj, NURBSSubObjectLevel level,
                     TimeValue t, Matrix3& partm, Matrix3& tmAxis,
                     Point3& val, BOOL localOrigin);

DllExport NURBSResult
RotateCurrentSelection(Object* pObj, NURBSSubObjectLevel level,
                       TimeValue t, Matrix3& partm, Matrix3& tmAxis,
                       Quat& val, BOOL localOrigin);

DllExport NURBSResult 
ScaleCurrentSelection(Object* pObj, NURBSSubObjectLevel level,
                      TimeValue t, Matrix3& partm, Matrix3& tmAxis,
                      Point3& val, BOOL localOrigin);


// Get the number of sub-objects at a particular level
DllExport int
SubObjectCount(Object* pObj, NURBSSubObjectLevel level);

// number of named sets at a particular level
DllExport int 
NamedSelSetCount(Object* pObj, NURBSSubObjectLevel level);

// Get ith named sel set name
DllExport TCHAR* 
GetNamedSelSetName(Object* pObj, NURBSSubObjectLevel level, int i);  

// Set the bit array to the named selection set
DllExport NURBSResult 
GetNamedSelSet(Object* pObj, NURBSSubObjectLevel level, TCHAR* name, BitArray& selSet);

// Set the named selection set the selection in BitArray
DllExport NURBSResult 
SetNamedSelSet(Object* pObj, NURBSSubObjectLevel level, TCHAR* name, BitArray& sel); 

// Add a new named selection set
DllExport NURBSResult
AppendNamedSelSet(Object* pObj, NURBSSubObjectLevel level, TCHAR* name, BitArray& sel); 

DllExport NURBSResult
DeleteCurrentSelection(Object* pObj, NURBSSubObjectLevel level);

DllExport NURBSResult
MapNURBSIdToSelSetIndex(Object* pObj, NURBSId id, int& index, NURBSSubObjectLevel& level);

DllExport NURBSResult
MapSelSetIndexToNURBSId(Object* pObj, int index, NURBSSubObjectLevel level, NURBSId& id);

DllExport void 
ApplyUVWMapAsTextureSurface(Object* pObj, int type, float utile, float vtile,
                            float wtile, int uflip, int vflip, int wflip, int cap,
                            const Matrix3 &tm,int channel);

// Has the same affect as the "Update" button on the "Surface Mapper" WSM.
DllExport void UpdateSurfaceMapper(Modifier* pMod);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\tcbgraph.h ===
/**********************************************************************
 *<
	FILE: TCBGraph.h

	DESCRIPTION:  UI gadget to display TCB graph

	CREATED BY: Rolf Berteig

	HISTORY: created 2/12/96

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef _TCBGRAPH_
#define _TCBGRAPH_

// The class name of the UI gadget
#define TCBGRAPHCLASS _T("TCBGraph")

// Send this message to the graph control with lParam
// pointing to a TCBGraphParams structure to set the
// garph parameters
#define WM_SETTCBGRAPHPARAMS	(WM_USER + 0xbb34)

class TCBGraphParams {
	public:
		float tens, cont, bias, easeFrom, easeTo;
	};

CoreExport void InitTCBGraph(HINSTANCE hInst);

#endif //_TCBGRAPH_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\templt.h ===
/**********************************************************************
 *<
	FILE: templt.h

	DESCRIPTION:  Defines 2D Template Object

	CREATED BY: Tom Hudson

	HISTORY: created 31 October 1995

 *>	Copyright (c) 1995, All Rights Reserved.
 **********************************************************************/

#ifndef __TEMPLT_H__ 

#define __TEMPLT_H__

class PolyLine;
class Spline3D;

// Intersection callbacks

class IntersectionCallback2D {
	public:
		virtual BOOL Intersect(Point2 p, int piece)=0; // Return FALSE to stop intersect tests
	};

class IntersectionCallback3D {
	public:
		virtual BOOL Intersect(Point3 p, int piece)=0; // Return FALSE to stop intersect tests
	};

// A handy 2D floating-point box class

class Box2D {
	public:
		BOOL empty;
		Point2 min, max;
		Box2D() { empty = TRUE; }
		void SetEmpty() { empty = TRUE; }
		CoreExport Box2D& operator+=(const Point2& p);	// expand this box to include p
	};

// This object is used to test shapes for self-intersection, clockwise status, point
// surrounding and intersection with other templates.  The last and first points will be the
// same if it is closed.

class Template3D;

class Template {
	public:
		int points;
		BOOL closed;
		Point2 *pts;
		Template(Spline3D *spline);
		Template(PolyLine *line);
		Template(Template3D *t3);
		void Create(PolyLine *line);
		~Template();
		int Points() { return points; }
		BOOL SurroundsPoint(Point2& point);
		BOOL IsClockWise();
		BOOL SelfIntersects(BOOL findAll = FALSE, IntersectionCallback2D *cb = NULL);
		BOOL Intersects(Template &t, BOOL findAll = FALSE, IntersectionCallback2D *cb = NULL);
		Box2D Bound();
	};

// This is a version for 3D use -- the various tests (SurroundsPoint, SelfIntersects, etc.
// are all performed on the X and Y coordinates only, discarding Z.  The IntersectionCallback
// returns the intersection point on the template in 3D.

class Template3D {
	private:
		Template *template2D;
	public:
		int points;
		BOOL closed;
		Point3 *pts;
		Template3D(Spline3D *spline);
		Template3D(PolyLine *line);
		void Create(PolyLine *line);
		~Template3D();
		int Points() { return points; }
		BOOL SurroundsPoint(Point2& point);	// 2D test!
		BOOL IsClockWise(); // 2D test!
		BOOL SelfIntersects(BOOL findAll = FALSE, IntersectionCallback3D *cb = NULL);	// 2D test!
		BOOL Intersects(Template3D &t, BOOL findAll = FALSE, IntersectionCallback3D *cb = NULL); // 2D test!
		Box2D Bound();
		Box3 Bound3D();
		void Ready2DTemplate();
	};

#endif // __TEMPLT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\tcp.h ===
//-----------------------------------------------------------------------------
// ----------------
// File ....: tcp.h
// ----------------
// Author...: Gus J Grubba
// Date ....: September 1995
// O.S. ....: Windows NT 3.51
//
// Note ....: Copyright 1991, 1995 Gus J Grubba
//
// History .: Sep, 03 1995 - Ported to C++ / WinNT
//
//-----------------------------------------------------------------------------

#ifndef _TCPINCLUDE_
#define _TCPINCLUDE_

#include <winsock.h>

//-- Constants ----------------------------------------------------------------

#define MAXUDPLEN           512
#define LOCALHOSTADDRESSH   0x0100007F  //-- (Host Order)
#define LOCALHOSTADDRESSN   0x7F000001  //-- (Network Order)

//-----------------------------------------------------------------------------
//-- Error Codes

#define GCRES_SERVICEERROR        0x1000
#define GCRES_GETHOSTERROR        0x1001
#define GCRES_CANNOTCREATESOCKET  0x1002
#define GCRES_CANNOTCONNECT       0x1003
#define GCRES_BINDERROR           0x1004
#define GCRES_CANNOTSERVE         0x1005
#define GCRES_DISCONNECTED        0x1006
#define GCRES_READERROR           0x1007
#define GCRES_INVALIDSERVERTHREAD 0x1008
#define GCRES_INVALIDPORT         0x1009
#define GCRES_NOTINITIALIZED      0x100A
#define GCRES_TOOBIG              0x100B
#define GCRES_WRITEERROR          0x100C
#define GCRES_TIMEOUT             0x100D

//-- Forward References ------------------------------------------------------

class ConnectionInfo;
class TCPcomm;

//-----------------------------------------------------------------------------
//-- Server Thread

typedef void (WINAPI *SERVER_THREAD)(
     ConnectionInfo *ci
);

typedef struct tag_tcpSRV {
     ConnectionInfo *ci;
     TCPcomm       *tcp;
} tcpSRV;

//-----------------------------------------------------------------------------
//-- Connection data

class ConnectionInfo {

        //-- All kept in host order

        void    *ptr, *param;        //-- Generic Pointers
        
        BOOL     blocking,dns;

        SOCKET   c_sock;             //-- The "client" socket
        DWORD    c_address;          //-- The "client" inet address
        char     c_name[MAX_PATH];   //-- The "client" hostname
        WORD     c_port;             //-- The "client" port

        SOCKET   s_sock;             //-- The "server" socket
        DWORD    s_address;          //-- The "server" inet address
        char     s_name[MAX_PATH];   //-- The "server" hostname
        WORD     s_port;             //-- The "server" port

        DWORD    bytes_s, bytes_r;
        
     public:
     
        GCOMMEXPORT          ConnectionInfo ( ) { Reset(); dns = FALSE;}

        GCOMMEXPORT void     Reset( ) {
                    ptr     = NULL;
                    param   = NULL;
                    bytes_s = 0;
                    bytes_r = 0;
                    ResetClient();
                    ResetServer();
                 }
        
        GCOMMEXPORT void     ResetClient ( ) {
                    c_sock    = INVALID_SOCKET;
                    c_address = 0;
                    c_name[0] = 0;
                 }
        
        GCOMMEXPORT void     ResetServer ( ) {
                    s_sock    = INVALID_SOCKET;
                    s_address = 0;
                    s_name[0] = 0;
                 }
        
        GCOMMEXPORT void     SetClientSocket    ( SOCKET s) { c_sock    = s;    }
        GCOMMEXPORT void     SetClientAddress   ( DWORD  a) { c_address = a;    }
        GCOMMEXPORT void     SetClientName      ( char  *n) { strcpy(c_name,n); }
        GCOMMEXPORT void     SetClientPort      ( WORD p)   { c_port    = p;    }
     
        GCOMMEXPORT void     SetServerSocket    ( SOCKET s) { s_sock    = s;    }
        GCOMMEXPORT void     SetServerAddress   ( DWORD  a) { s_address = a;    }
        GCOMMEXPORT void     SetServerName      ( char  *n) { strcpy(s_name,n); }
        GCOMMEXPORT void     SetServerPort      ( WORD p)   { s_port    = p;    }
     
        GCOMMEXPORT SOCKET   ClientSocket       ( ) { return c_sock;    }
        GCOMMEXPORT DWORD    ClientAddress      ( ) { return c_address; }
        GCOMMEXPORT WORD     ClientPort         ( ) { return c_port;    }
        GCOMMEXPORT char    *ClientName         ( ) { return c_name;    }
     
        GCOMMEXPORT SOCKET   ServerSocket       ( ) { return s_sock;    }
        GCOMMEXPORT WORD     ServerPort         ( ) { return s_port;    }
        GCOMMEXPORT DWORD    ServerAddress      ( ) { return s_address; }
        GCOMMEXPORT char    *ServerName         ( ) { return s_name;    }
     
        GCOMMEXPORT void     AddToBytesSent     ( DWORD b ) { bytes_s += b; }
        GCOMMEXPORT void     AddToBytesReceived ( DWORD b ) { bytes_r += b; }

        GCOMMEXPORT DWORD    BytesSent          ( ) { return bytes_s; }
        GCOMMEXPORT DWORD    BytesReceived      ( ) { return bytes_r; }

        GCOMMEXPORT void     ResetBytesSent     ( ) { bytes_s = 0; }
        GCOMMEXPORT void     ResetBytesReceived ( ) { bytes_r = 0; }
     
        GCOMMEXPORT void    *Ptr                ( ) { return ptr;         }
        GCOMMEXPORT void     SetPtr             ( void * p ) { ptr = p;   }
        GCOMMEXPORT void    *Param              ( ) { return param;       }
        GCOMMEXPORT void     SetParam           ( void * p ) { param = p; }

        GCOMMEXPORT void     SetBlocking        ( BOOL b ) { blocking = b; }
        GCOMMEXPORT BOOL     Blocking           ( ) { return blocking; }
        
        GCOMMEXPORT void     SetUseDns			( BOOL b ) { dns = b; }
        GCOMMEXPORT BOOL     UseDns				( ) { return dns; }
        
};

//-----------------------------------------------------------------------------
//--  BSD Socket Class Definition ---------------------------------------------
//-----------------------------------------------------------------------------
// #> TCPcomm
//
     
class TCPcomm : public tcCOMM {

     private:
     
        BOOL        initialized;
        WSADATA     WSAData;
        SOCKET      sSocket;
        
        BOOL        HandleStandardErrors    ( int err, TCHAR *msg );
        
     public:

        GCOMMEXPORT        TCPcomm          ( );
        GCOMMEXPORT       ~TCPcomm          ( );
     
        //-- House Keeping --------------------------------

        GCOMMEXPORT BOOL   Init             ( HWND hWnd );
        GCOMMEXPORT BOOL   Setup            ( void * ) { return TRUE; }
        GCOMMEXPORT void   Close            ( );
        GCOMMEXPORT BOOL   SaveSession      ( void *ptr ) { return TRUE; }
        GCOMMEXPORT BOOL   LoadSession      ( void *ptr ) { return TRUE; }
        GCOMMEXPORT DWORD  EvaluateDataSize ( )           { return 0;    }

        //-- Helpers --------------------------------------

        GCOMMEXPORT GCRES  GetHostAddress   ( DWORD *addr, char *name, char *fullname = NULL );
                    
        //-- TCP Transport --------------------------------

        GCOMMEXPORT GCRES  Serve            ( WORD port, SERVER_THREAD func, void *param );
        GCOMMEXPORT void   StopServer       ( );
        GCOMMEXPORT GCRES  Send             ( ConnectionInfo *ci, void *buf, int len, float timeout = 5.0f );
        GCOMMEXPORT GCRES  Receive          ( ConnectionInfo *ci, void *buf, int len, float timeout = 5.0f );
        GCOMMEXPORT GCRES  rlogin           ( ConnectionInfo *ci );
        GCOMMEXPORT GCRES  Connect          ( ConnectionInfo *ci );
        GCOMMEXPORT void   Disconnect       ( ConnectionInfo *ci );
        
        //-- UDP Transport --------------------------------
        
        #define UDP_BLOCK    1
        #define UDP_NONBLOCK 0

        GCOMMEXPORT GCRES  CreateUDPServer  ( ConnectionInfo *ci, BOOL block = UDP_NONBLOCK );
        GCOMMEXPORT GCRES  CloseUDPServer   ( ConnectionInfo *ci );
        GCOMMEXPORT GCRES  SendUDP          ( ConnectionInfo *ci, void *buf, int len, int *written, float timeout = 5.0f);
        GCOMMEXPORT GCRES  ReceiveUDP       ( ConnectionInfo *ci, void *buf, int len, int *read,    float timeout = 5.0f);

};

#endif

//-- EOF: tcp.h ---------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\SvCore.h ===
#pragma once

typedef enum
	{
	SVT_PROCEED,
	SVT_EXISTS,
	SVT_DO_NOT_PROCEED,
	} SvTraverseStatus;

typedef enum
	{
	REFTYPE_CHILD,
	REFTYPE_SUBANIM,
	REFTYPE_PLUGIN,
	} SvReferenceType;

// Filter bits...
static const DWORD SV_FILTER_SELOBJECTS     = (1<<0);
static const DWORD SV_FILTER_OBJECTMODS     = (1<<1);
static const DWORD SV_FILTER_BASEPARAMS     = (1<<2);
static const DWORD SV_FILTER_MATPARAMS      = (1<<3);
static const DWORD SV_FILTER_GEOM           = (1<<4);
static const DWORD SV_FILTER_SHAPES         = (1<<5);
static const DWORD SV_FILTER_LIGHTS         = (1<<6);
static const DWORD SV_FILTER_CAMERAS        = (1<<7);
static const DWORD SV_FILTER_HELPERS        = (1<<8);
static const DWORD SV_FILTER_WARPS          = (1<<9);
static const DWORD SV_FILTER_VISIBLE_OBJS   = (1<<10);
static const DWORD SV_FILTER_CONTROLLERS    = (1<<11);
static const DWORD SV_FILTER_ANIMATEDONLY   = (1<<12);
static const DWORD SV_FILTER_MAPS           = (1<<13);
static const DWORD SV_FILTER_BONES          = (1<<14);

// Schematic view UI colors...
static const int SV_UICLR_WINBK               = 0;
static const int SV_UICLR_NODEBK              = 1;
static const int SV_UICLR_SELNODEBK           = 2;
static const int SV_UICLR_NODE_HIGHLIGHT      = 3;
static const int SV_UICLR_MATERIAL_HIGHLIGHT  = 4;
static const int SV_UICLR_MODIFIER_HIGHLIGHT  = 5;
static const int SV_UICLR_PLUGIN_HIGHLIGHT    = 6;
static const int SV_UICLR_SUBANIM_LINE        = 7;
static const int SV_UICLR_CHILD_LINE          = 8;
static const int SV_UICLR_FRAME               = 9;
static const int SV_UICLR_SELTEXT             = 10;
static const int SV_UICLR_TEXT                = 11;
static const int SV_UICLR_FOCUS               = 12;
static const int SV_UICLR_MARQUIS             = 13;
static const int SV_UICLR_COLLAPSEARROW       = 14;
static const int SV_UICLR_GEOMOBJECT_BK       = 15;
static const int SV_UICLR_LIGHT_BK            = 16;
static const int SV_UICLR_CAMERA_BK           = 17;
static const int SV_UICLR_SHAPE_BK            = 18;
static const int SV_UICLR_HELPER_BK           = 19;
static const int SV_UICLR_SYSTEM_BK           = 20;
static const int SV_UICLR_CONTROLLER_BK       = 21;
static const int SV_UICLR_MODIFIER_BK         = 22;
static const int SV_UICLR_MATERIAL_BK         = 23;
static const int SV_UICLR_MAP_BK              = 24;

static const int SV_UICLR_CACHE_SIZE          = 25;

// Magic value returned from Animatable::SvGetSwatchColor(...)
// to indicate that no swatch is to be drawn...
static const int SV_NO_SWATCH							= 0xFFFFFFFF;

//-------------------------------------------------------------------------
// Bit flags which can be passed to IGraphObjectManager::AddAnimatable(...)
// and Animatable::SvTraverseAnimGraph(....)
//-------------------------------------------------------------------------

// If set, newly created node will be in the hidden state.  If the node
// already exists in the graph, the flag is ignored...
static const DWORD SV_INITIALLY_HIDDEN          = 0x00000001;

// If set, shared instances of an animatable will produce multiple
// graph nodes in the schematic view instead of a single shared graph node...
static const DWORD SV_DUPLICATE_INSTANCES       = 0x00000002;

// If set, the newly created children of the newly created node
// will be in the hidden state.  If the node already exists in the graph,
// the flag is ignored.  Children of this node that already exist in
// the graph will not have their visibility state changed...
static const DWORD SV_INITIALLY_CLOSED          = 0x00000004;

//-------------------------------------------------------------------------
// Flags which can be passed to IGraphObjectManager::PushLevel(...)
//-------------------------------------------------------------------------

// This id, when passed to PushLevel(), indicates that no id is to be associated
// with Animatable being pushed onto the stack...
static const int SV_NO_ID                       = 0x80000000;

class IGraphNode;
class Animatable;
class IGraphObjectManager;

class MultiSelectCallback
	{
	public:
	virtual int Priority() = 0;		// Used for sorting select order.
	virtual void Begin(IGraphObjectManager *gom, bool clear) = 0;
	virtual void Select(IGraphObjectManager *gom, IGraphNode *gNode, bool isSelected) = 0;
	virtual void End(IGraphObjectManager *gom) = 0;
	};

class IGraphRef
	{
	public:
	};

class IGraphNode
	{
	public:

		// Returns the Animatable associated with this node...
	virtual Animatable *GetAnim() = 0;

		// Returns the "primary parent" of this node.  Nodes
		// can have multiple parents (objects referencing
		// this node) so this function is not strictly
		// accurate.  That said, many nodes have the
		// concept of an owner node, which is what this
		// function returns.
	virtual IGraphNode *GetParentNode() = 0;

		// Returns the "owner" of this node.  Some nodes
		// have multiple owners.  When this is the case, this
		// function returns the "first" owner (the object
		// that first added this node to the schematic view)...
	virtual Animatable *GetOwner() = 0;

		// Return the "id" of this node.  When nodes are
		// added to the schematic view (via the
		// IGraphObjectManager::AddAnimatable(...) method),
		// an integer is provided.  This value is is not
		// used internally by the schematic view.  Rather,
		// it is available to implementers of the 
		// Animatable::Sv*() methods to aid in identifying
		// the node.
	virtual int GetID() = 0;
	};

class SvGraphNodeReference
	{
	public:

	IGraphNode *gNode;
	SvTraverseStatus stat;

	SvGraphNodeReference()
		{
		gNode= NULL;
		stat = SVT_DO_NOT_PROCEED;
		}
	};

class IGraphObjectManager
	{
	public:

		// During traversal of the Animatable graph via SvTraverseAnimGraph(...),
		// PushLevel() and PopLevel() should be called appropriately to
		// maintain an ownership stack.  This is required by the schematic view
		// when nodes are added to the graph with the "SV_DUPLICATE_INSTANCES"
		// flag set...
	virtual void PushLevel(Animatable *anim, int id = SV_NO_ID) = 0;
	virtual void PopLevel() = 0;

		// Adds an Animatable to the schematic view...
	virtual SvGraphNodeReference AddAnimatable(Animatable *anim, Animatable *owner, int id, DWORD flags = 0) = 0;

		// Add a reference from "maker" node to "target"...
	virtual IGraphRef *AddReference(IGraphNode *maker, IGraphNode *target, SvReferenceType type) = 0;

		// Pops up the property editor dialog on the
		// selected nodes in the schematic view...
	virtual void SvEditSelectedNodeProperties() = 0;

		// Selects the given node in the material editor.
		// Does nothing if "gNode" does not represent a
		// material or map...
	virtual void SvSelectInMaterialEditor(IGraphNode *gNode) = 0;

		// Selects the given node in the modifier panel.
		// Does nothing if "gNode" does not represent an
		// object...
	virtual void SvSetCurEditObject(IGraphNode *gNode) = 0;

		// Returns true if the given node is current
		// in the modifier panel...
	virtual bool SvIsCurEditObject(IGraphNode *gNode) = 0;

	virtual bool ApplyModifier(IGraphNode *gModNode, IGraphNode *gParentNode) = 0;
	virtual bool DeleteModifier(IGraphNode *gNode) = 0;

		// Invalidates the schematic view window...
	virtual void SvInvalidateView() = 0;

		// Invalidates a node in the schematic view window...
	virtual void SvInvalidateNode(IGraphNode *gNode) = 0;

		// Forces the material editor to update...
	virtual void SvUpdateMaterialEditor() = 0;

		// Forces the modifier panel to update...
	virtual void SvUpdateModifierPanel() = 0;

		// Set, Clear and Test filter flags...
	virtual void SetFilter(DWORD mask) = 0;
	virtual void ClearFilter(DWORD mask) = 0;
	virtual bool TestFilter(DWORD mask) = 0;

		// Get a SV UI color given a color index...
	virtual COLORREF SvGetUIColor(int colorIndex) = 0;
	};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Toolmap.h ===
/**********************************************************************
 *<
	FILE: toolmap.h

	DESCRIPTION:  defines a mapping between control identifiers and osnaps 

	CREATED BY: John Hutchinson

	HISTORY: January 15, 1996
 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef __TOOLMAP__
#define __TOOLMAP__


class msgdata {
public:
	int recipient;
	int subindex;
	int msg;
	msgdata(){};
	msgdata(int r, int s, int m):recipient(r), subindex(s), msg(m){};
};



class tooltabentry {

private:

	int indexer;
	msgdata data;

public:

	tooltabentry(){};
	tooltabentry(int i, int r, int s, int m);
	msgdata *Query(int i);

};


class ToolTab : public Tab<tooltabentry *> {
	public:         
		msgdata *Lookup(int toolid); 
	};




#endif //_TOOLMAP_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\tessint.h ===
/**********************************************************************
 *<
	FILE: tessint.h

	DESCRIPTION: include file for gap integration

	CREATED BY: Charles Thaeler

	HISTORY: created 10 Jan 1997

 *>	Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/

#ifndef TESSINT_H
#define TESSINT_H

#ifdef BLD_TESS
#define TExport __declspec(dllexport)
#else
#define TExport __declspec(dllimport)
#endif

#include "max.h"
#include "maxtess.h"

class GmSurface;

// This class describes the parameters for a projective mapper.  They
// are set when a UVW mapper modifer is applied.
// SteveA 6/98: I moved the guts of this into "UVWMapper" in the mesh library.
class UVWMapperDesc : public UVWMapper {
public:
    int     channel;

    UVWMapperDesc() {channel=0;}
    UVWMapperDesc(int type, float utile, float vtile, float wtile,
                  int uflip, int vflip, int wflip, int cap,
                  const Matrix3 &tm,int channel);
    UVWMapperDesc(UVWMapperDesc& m) : UVWMapper (m)
        {
            this->channel = m.channel;
        }

    void ApplyMapper(Mesh* pMesh);
    void InvalidateMapping(Mesh* pMesh);
    IOResult Load(ILoad* iload);
    IOResult Save(ISave* isave);
};

struct SurfTabEntry {
	GmSurface *gmsurf;
    UVWMapperDesc* mpChannel1Mapper;
    UVWMapperDesc* mpChannel2Mapper;

    SurfTabEntry() {
        gmsurf = NULL;
        mpChannel1Mapper = NULL;
        mpChannel2Mapper = NULL;
    }
};

typedef Tab<SurfTabEntry> SurfTab;


typedef enum {
	BEZIER_PATCH,
	GMSURFACE,
	MAX_MESH,
	MODEL_OP
} SurfaceType;

TExport TCHAR* GapVersion(void);
TExport int GapTessellate(void *surf, SurfaceType type, Matrix3 *otm, Mesh *mesh,
							TessApprox *tess, TessApprox *disp, 
							View *view, Mtl* mtl, BOOL dumpMiFile, BOOL splitmesh);

TExport int GapInit(void);     // this should never be used by user code
TExport int GapShutdown(void); // this should never be used by user code

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\tab.h ===
/**********************************************************************
 *<
	FILE: tab.h

	DESCRIPTION:  Defines Tab Class

	CREATED BY: Dan Silva

	HISTORY: created 13 September 1994

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

/*-------------------------------------------------------------------------------

 A Generic "Table" class.      
  
  (DSilva 9-13-94)

  This is a type-safe variable length array which also supports list-like
  operations of insertion, appending and deleting.  Two instance variables
  are maintained: "nalloc" is the number elements allocated in the
  array; "count" is the number actual used. (count<=nalloc).
  Allocation is performed automatically when Insert or Append operations
  are performed.  It can also be done manually by calling Resize or Shrink.
  Note: Delete does not resize the storage: to do this call Shrink().  
  If you are going to do a sequence of Appends, it's more efficient to 
  first call Resize to make room for them.  Beware of using the Addr 
  function: it returns a pointer which may be invalid after subsequent 
  Insert, Append, Delete, Resize, or Shrink operations.  
  
  
  The implementation minimizes the storage of empty Tables: they are
  represented by a single NULL pointer.  Also, the major part of the
  code is generic, shared by different Tabs for different types of elements.

------------------------------------------------------------------------------*/

#ifndef __TAB__ 

#define __TAB__

#include <malloc.h>
#include <stdlib.h>

typedef int CNT;

typedef struct {											
	CNT count;
	CNT nalloc;
	} TabHdr;

////////////////////////////////////////////////////////////////////////////////
// Functions for internal use only: Clients should never call these.
//
UtilExport int TBMakeSize(TabHdr** pth, int num, int elsize); 
UtilExport int TBInsertAt(TabHdr** pth,int at, int num, void *el, int elsize, int extra); 
UtilExport int TBCopy(TabHdr** pth,int at, int num, void *el, int elsize); 
UtilExport int TBDelete(TabHdr** pth,int starting, int num, int elsize);
UtilExport void TBSetCount(TabHdr** pth,int n, int elsize);
UtilExport void zfree(void**p);
////////////////////////////////////////////////////////////////////////////////

#define NoExport
		
template <class T> class NoExport TabHd {
	public:
		CNT count;
		CNT nalloc;
		T data[100];
		TabHd() { count = 0; nalloc = 0; }
	};


// Type of function to pass to Sort.
// Note: Sort just uses the C lib qsort function. If we restricted
// all Tab elements to have well defined <,>,== then we wouldn't need
// this callback function.
typedef int( __cdecl *CompareFnc) ( const void *elem1, const void *elem2 );



template <class T> class NoExport Tab {
private:
 	TabHd<T> *th;
 	/*
 	struct TabHd {
		CNT count;
		CNT nalloc;
		T data[1];
		} *th;
	*/
public:
	Tab() { th = 0; }
	// Copy constructor
	Tab(const Tab& tb) {  
		th = 0;
		TBCopy((TabHdr** )&th,0, tb.Count(), &tb.th->data, sizeof(T)); 
		}
	// Assignment operator
	Tab& operator=(const Tab& tb) {
		TBCopy((TabHdr** )&th,0, tb.Count(), &tb.th->data, sizeof(T)); 
		return *this;
		}
	
	~Tab() { zfree((void**)&th); }  // destructor

	int Count() const { if (th) return(th->count); return 0; }  // return number of entries being used

	void ZeroCount() { if (th) th->count=0; }
	void SetCount(int n) { TBSetCount((TabHdr **)&th, n, sizeof(T)); }

	T& operator[](const int i) const {       // access ith entry.
		assert(th&&(i<th->count)); return(th->data[i]); 
		}
	T* Addr(const int i) const {             // use with caution  
		assert(th&&(i<th->count)); return(&th->data[i]); 
		}
//	void *MemAddr() {	return((void *)th);	}
//	long MemSize() { return(th? (2*sizeof(CNT)+th->nalloc*sizeof(T)): 0);}

	// Insert "num" elements position "at" 
	int Insert(int at, int num, T *el) {
		return(TBInsertAt((TabHdr**)&th, at, num, (void *)el, sizeof(T),0));
		}
	// Append "num" elements position on end of array" 
	// If need to enlarge the array, allocate "allocExtra" extra slots
	int Append(int num, T *el, int allocExtra=0) {
		return(TBInsertAt((TabHdr**)&th,th?th->count:0,num,	(void *)el,sizeof(T),allocExtra)); 
		}
	// List-type delete of "num" elements starting with "start" 
	int Delete(int start,int num) { 
		return(TBDelete((TabHdr**)&th,start,num,sizeof(T)));
		} 
	// Change number of allocated items to num
	int Resize(int num) { 
		return(TBMakeSize((TabHdr**)&th,num, sizeof(T)));
		}	
	// Reallocate so there is no wasted space (nalloc = count)
	void Shrink() {
		TBMakeSize((TabHdr**)&th, th?th->count:0, sizeof(T)); 
		}

	void Sort(CompareFnc cmp) {
		if (th) {
			qsort(th->data,th->count,sizeof(T),cmp);
			}
		}																		
	};

#ifndef __tab_name2
#define __tab_name2(a,b) a##b
#endif

#define MakeTab(TYPE) typedef Tab<TYPE> __tab_name2(TYPE,Tab); 															


UtilExport void TabStartRecording();
UtilExport void TabStopRecording();
UtilExport void TabPrintAllocs();
UtilExport void TabAssertAllocNum(int i);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\texutil.h ===
/**********************************************************************
 *<
	FILE: texutil.h

	DESCRIPTION:

	CREATED BY: Dan Silva

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/


#ifndef __TEXUTIL__H

#define __TEXUTIL__H

//
//	Misc. noise functions from Texturing and Modeling A Procedural Approach
//  Perlin, Musgrave...
//

CoreExport float bias(float a, float b);
CoreExport float gain(float a, float b);
CoreExport float clamp(float x, float a, float b);

CoreExport float boxstep(float a, float b, float x); // linear from (a,0) to (b,1)
CoreExport float smoothstep(float a, float b, float x);  // Hermite cubic from (a,0) to (b,1)
CoreExport float mod(float x, float m); // returns x Mod m, handles negatives correctly
CoreExport int mod(int x, int m); // returns x Mod m, handles negatives correctly

// This function makes a sort of straight segment S curve.
// sramp() is a for x < a-d and b for x > b+d.
// for a+d < x < b-d sramp(x) = x
// for a-d < x < a+d sramp makes a smooth transition (parabolic) from
//     sramp' = 0 to sramp' = 1
// for b-d < x < b+d sramp makes a smooth transition (parabolic) from
//     sramp' = 1 to sramp' = 0
CoreExport float sramp(float x,float a, float b, float d);

// returns 0 if x<a, 1 if x>b otherwise x.
CoreExport float threshold(float x,float a, float b);

CoreExport void  setdebug(int i);
CoreExport float noise1(float arg);
CoreExport float noise2(Point2 p);
CoreExport float noise3(Point3 p);
CoreExport float noise4(Point3 p,float time);

// This is 3DStudio's Noise function: its only slightly different from noise3:
//  scaled up by factor of 1.65 and clamped to -1,+1.
CoreExport float noise3DS(Point3 p);

CoreExport float turbulence(Point3& p, float freq);

CoreExport int Perm(int v);

#define MAX_OCTAVES	50
CoreExport float fBm1(float  point, float H, float lacunarity, float octaves);
CoreExport float fBm1(Point2 point, float H, float lacunarity, float octaves);
CoreExport float fBm1(Point3 point, float H, float lacunarity, float octaves);

CoreExport float spline(float x, int nknots, float *knot);

CoreExport Color color_spline(float x, int nknots, Color *knot);


// faster version of floor
inline int FLOOR( float x) { return ((int)(x)-((x)<0.0f)); }

inline float frac(float x) { return x - (float)FLOOR(x); }
inline float fmax(float x, float y) { return x>y?x:y;	}
inline float fmin(float x, float y) { return x<y?x:y;	}

// Macro to map it into interval [0,1]
#define NOISE(p) ((1.0f+noise3DS(p))*.5f)

// alpha-composite ctop on top of cbot, assuming pre-multiplied alpha
inline AColor AComp(AColor cbot, AColor ctop) {
	float ia = 1.0f - ctop.a;
	return (ctop + ia*cbot);
	}


//-----------------------------------------------------------
// Based on: A Cellular Basis Function
//                   Steven Worley
//
// SIGGRAPH 1996 Conference Procedings
//
#define MAX_CELL_LEVELS	20

CoreExport void CellFunction(Point3 v,int n,float *dist,int *celIDs=NULL,Point3 *grads=NULL,float gradSmooth=0.0f);
CoreExport void FractalCellFunction(Point3 v,float iterations, float lacunarity,int n,float *dist,int *celIDs=NULL,Point3 *grads=NULL,float gradSmooth=0.0f);
CoreExport float RandFromCellID(int id);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\trig.h ===
/**********************************************************************
 *<
	FILE: trig.h

	DESCRIPTION:  Useful trigonometry macros

	CREATED BY: Rolf Berteig

	HISTORY: created 19 November 1994

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef __TRIG__
#define __TRIG__

#define PI  ((float)3.1415926535)
#define TWOPI ((float)6.283185307)
#define HALFPI ((float)1.570796326794895)

#define DEG_TO_RAD (PI/(float)180.0)
#define RAD_TO_DEG ((float)180.0/PI)
#define DegToRad(deg) (((float)deg)*DEG_TO_RAD)
#define RadToDeg(rad) (((float)rad)*RAD_TO_DEG)


#endif // __TRIG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\tvnode.h ===
/**********************************************************************
 *<
	FILE: tvnode.h

	DESCRIPTION: Track View Node Class

	CREATED BY: Rolf Berteig

	HISTORY: 11-14-96

 *>	Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/


#ifndef __TVNODE_H__
#define __TVNODE_H__

#define TVNODE_CLASS_ID	Class_ID(0x8d73b8aa, 0x90f2ee71)

// Default position for appending
#define TVNODE_APPEND -1


// TrackViewNodes can contain one or more sub nodes or controllers.
// Sub-nodes and controllers are identified by a unique ID in the
// form of a Class_ID variable. This does not necessarily have to
// be the class ID of an existing plug-in, however plug-ins may
// wish to use thier class ID for any items they add to be sure they
// are unique.
//
// The Interface class provides access to the root track view node.
// From this node, new nodes can be added. There are two defined
// sub nodes:

#define GLOBAL_VAR_TVNODE_CLASS_ID		Class_ID(0xb27e9f2a, 0x73fad370)
#define VIDEO_POST_TVNODE_CLASS_ID		Class_ID(0x482b8d30, 0xb72c8511)

// These can be retreived by calling GetNode() on the track view root
// node and passing in one of the above IDs.


// These can be registered with a TVNode to intercept reference notifications
class TVNodeNotify {
	public:
		virtual RefResult NotifyRefChanged(
			Interval changeInt, RefTargetHandle hTarget, 
			PartID& partID,  RefMessage message)=0;
	};
 
class ITrackViewNode : public ReferenceTarget {
	public:
		virtual void AddNode(ITrackViewNode *node, TCHAR *name, Class_ID cid, int pos=TVNODE_APPEND)=0;
		virtual void AddController(Control *c, TCHAR *name, Class_ID cid, int pos=TVNODE_APPEND)=0;
		virtual int FindItem(Class_ID cid)=0;
		virtual void RemoveItem(int i)=0;
		virtual void RemoveItem(Class_ID cid)=0;
		virtual Control *GetController(int i)=0;
		virtual Control *GetController(Class_ID cid)=0;
		virtual ITrackViewNode *GetNode(int i)=0;
		virtual ITrackViewNode *GetNode(Class_ID cid)=0;
		virtual int NumItems()=0;
		virtual void SwapPositions(int i1, int i2)=0;
		virtual TCHAR *GetName(int i)=0;
		virtual void SetName(int i,TCHAR *name)=0;
		virtual void RegisterTVNodeNotify(TVNodeNotify *notify)=0;
		virtual void UnRegisterTVNodeNotify(TVNodeNotify *notify)=0;
	};

CoreExport ITrackViewNode *CreateITrackViewNode(BOOL hidden=FALSE);

#endif // __TVNODE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\triobj.h ===
/**********************************************************************
 *<
	FILE: triobj.h

	DESCRIPTION:  Defines Triangle Mesh Object

	CREATED BY: Dan Silva

	HISTORY: created 9 September 1994

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef __TRIOBJ__ 

#define __TRIOBJ__

#include "meshlib.h"
#include "snap.h"
#include "maxtess.h"

#define TRI_MULTI_PROCESSING TRUE

extern CoreExport Class_ID triObjectClassID;

class TriObject: public GeomObject {
	protected:
		Interval geomValid;
		Interval topoValid;
		Interval texmapValid;
		Interval selectValid;
		Interval vcolorValid;
		Interval gfxdataValid;
		DWORD validBits; // for the remaining constant channels
		CoreExport void CopyValidity(TriObject *fromOb, ChannelMask channels);
#if TRI_MULTI_PROCESSING
		static int		refCount;
		static HANDLE	defThread;
		static HANDLE	defMutex;
		static HANDLE	defStartEvent;
		static HANDLE	defEndEvent;
		friend DWORD WINAPI defFunc(LPVOID ptr);
#endif	
		//  inherited virtual methods for Reference-management
		CoreExport RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, PartID& partID, RefMessage message );
	public:
		Mesh  mesh;
		TessApprox mDispApprox;
		bool mSubDivideDisplacement;
		bool mDisableDisplacement;
		bool mSplitMesh;

		CoreExport TriObject();
		CoreExport ~TriObject();

		//  inherited virtual methods:

		//from animatable
		CoreExport void* GetInterface(ULONG id);
		CoreExport void ReleaseInterface(ULONG id,void *i);

		// From BaseObject
		CoreExport int HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt);
		CoreExport int Display(TimeValue t, INode* inode, ViewExp *vpt, int flags);
		CoreExport void Snap(TimeValue t, INode* inode, SnapInfo *snap, IPoint2 *p, ViewExp *vpt);
		CoreExport CreateMouseCallBack* GetCreateMouseCallBack();
		CoreExport RefTargetHandle Clone(RemapDir& remap = NoRemap());

		// From Object			 
		CoreExport ObjectState Eval(TimeValue time);
		CoreExport Interval ObjectValidity(TimeValue t);
		CoreExport BOOL HasUVW();
		CoreExport BOOL HasUVW (int mapChannel);

		// get and set the validity interval for the nth channel
	   	CoreExport Interval ChannelValidity(TimeValue t, int nchan);
		CoreExport void SetChannelValidity(int i, Interval v);
		CoreExport void InvalidateChannels(ChannelMask channels);

		// Convert-to-type validity
		CoreExport Interval ConvertValidity(TimeValue t);

		// Deformable object procs	
		int IsDeformable() { return 1; }  
		int NumPoints() { return mesh.getNumVerts(); }
		Point3 GetPoint(int i) { return mesh.getVert(i); }
		void SetPoint(int i, const Point3& p) { mesh.setVert(i,p); }

		CoreExport BOOL IsPointSelected (int i);
		CoreExport float PointSelection (int i);

		// Mappable object procs
		int IsMappable() { return 1; }
		int NumMapChannels () { return MAX_MESHMAPS; }
		int NumMapsUsed () { return mesh.getNumMaps(); }
		void ApplyUVWMap(int type, float utile, float vtile, float wtile,
			int uflip, int vflip, int wflip, int cap,const Matrix3 &tm,int channel=1) {
				mesh.ApplyUVWMap(type,utile,vtile,wtile,uflip,vflip,wflip,cap,tm,channel); }
				
        CoreExport BOOL PolygonCount(TimeValue t, int& numFaces, int& numVerts);
		void PointsWereChanged(){ mesh.InvalidateGeomCache(); }
		CoreExport void GetDeformBBox(TimeValue t, Box3& box, Matrix3 *tm=NULL,BOOL useSel=FALSE );
		CoreExport void Deform(Deformer *defProc, int useSel);

		CoreExport int CanConvertToType(Class_ID obtype);
		CoreExport Object* ConvertToType(TimeValue t, Class_ID obtype);
		CoreExport void FreeChannels(ChannelMask chan);
		CoreExport Object *MakeShallowCopy(ChannelMask channels);
		CoreExport void ShallowCopy(Object* fromOb, ChannelMask channels);
		CoreExport void NewAndCopyChannels(ChannelMask channels);

		CoreExport DWORD GetSubselState();
		CoreExport void SetSubSelState(DWORD s);

		CoreExport BOOL CheckObjectIntegrity();

		// From GeomObject
		CoreExport int IntersectRay(TimeValue t, Ray& ray, float& at, Point3& norm);
		CoreExport ObjectHandle CreateTriObjRep(TimeValue t);  // for rendering, also for deformation		
		CoreExport void GetWorldBoundBox(TimeValue t, INode *inode, ViewExp* vpt, Box3& box );
		CoreExport void GetLocalBoundBox(TimeValue t, INode *inode, ViewExp* vpt, Box3& box );
		CoreExport Mesh* GetRenderMesh(TimeValue t, INode *inode, View &view,  BOOL& needDelete);
		
		// for displacement mapping
		CoreExport BOOL CanDoDisplacementMapping();
		CoreExport TessApprox& DisplacmentApprox() { return mDispApprox; }
		CoreExport bool& DoSubdivisionDisplacment() { return mSubDivideDisplacement; }
		CoreExport bool& SplitMeshForDisplacement() { return mSplitMesh; }
		CoreExport void SetDisplacmentApproxToPreset(int preset);
		CoreExport void DisableDisplacementMapping(BOOL disable);

		CoreExport void TopologyChanged();

		Mesh& GetMesh() { return mesh; }

		// Animatable methods

		void DeleteThis() { delete this; }
		void FreeCaches() {mesh.InvalidateGeomCache(); }
		Class_ID ClassID() { return Class_ID(TRIOBJ_CLASS_ID,0); }
		void GetClassName(TSTR& s) { s = TSTR(_T("TriObject")); }
		void NotifyMe(Animatable *subAnim, int message) {}
		int IsKeyable() { return 0;}
		int Update(TimeValue t) { return 0; }
		//BOOL BypassTreeView() { return TRUE; }
		// This is the name that will appear in the history browser.
		TCHAR *GetObjectName() { return _T("Mesh"); }

		CoreExport void RescaleWorldUnits(float f);

		// IO
		CoreExport IOResult Save(ISave *isave);
		CoreExport IOResult Load(ILoad *iload);

		// TriObject-specific methods


	};

CoreExport void SetDisplacmentPreset(int preset, TessApprox approx);

// Regular TriObject
CoreExport ClassDesc* GetTriObjDescriptor();

// A new decsriptor can be registered to replace the default
// tri object descriptor. This new descriptor will then
// be used to create tri objects.

CoreExport void RegisterEditTriObjDesc(ClassDesc* desc);
CoreExport ClassDesc* GetEditTriObjDesc(); // Returns default of none have been registered

// Use this instead of new TriObject. It will use the registered descriptor
// if one is registered, otherwise you'll get a default tri-object.
CoreExport TriObject *CreateNewTriObject();


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\utilexp.h ===
/**********************************************************************
 *<
	FILE: utilexp.h

	DESCRIPTION:

	CREATED BY: Dan Silva

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef __UTILEXPORT__H
#define __UTILEXPORT__H

#ifdef BLD_UTIL
#define UtilExport __declspec( dllexport )
#else
#define UtilExport __declspec( dllimport )
#endif

#endif // __UTILEXPORT__H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\utilapi.h ===
/**********************************************************************
*<
	FILE: utilapi.h

	DESCRIPTION: Utility plug-ins interface

	CREATED BY: Rolf Berteig

	HISTORY: 12-23-95 file created

*>	Copyright (c) 1994, All Rights Reserved.
**********************************************************************/

#ifndef __UTILAPI__
#define __UTILAPI__

class IUtil {
	public:
		// Closes the current utility in the command panel
		virtual void CloseUtility()=0;
	};

// A utility plug-in object
class UtilityObj {
	public:
		virtual void BeginEditParams(Interface *ip,IUtil *iu)=0;
		virtual void EndEditParams(Interface *ip,IUtil *iu)=0;
		virtual void SelectionSetChanged(Interface *ip,IUtil *iu) {}
		virtual void DeleteThis()=0;
		virtual void SetStartupParam(TSTR param) {}
	};


#endif //__UTILAPI__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\tvutil.h ===
/**********************************************************************
 *<
	FILE: tvutil.h

	DESCRIPTION: Track view utility plug-in class

	CREATED BY:	Rolf Berteig

	HISTORY: 12/18/96

 *>	Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/

#ifndef __TVUTIL_H__
#define __TVUTIL_H__

class TrackViewUtility;

// The five track view major modes
#define TVMODE_EDITKEYS			0
#define TVMODE_EDITTIME			1
#define TVMODE_EDITRANGES		2
#define TVMODE_POSRANGES		3
#define TVMODE_EDITFCURVE		4

// This is an interface that is given to track view utilities
// that allows them to access the track view they were launched from.
class ITVUtility {
	public:
		virtual int GetNumTracks()=0;
		virtual Animatable *GetAnim(int i)=0;
		virtual Animatable *GetClient(int i)=0;
		virtual int GetSubNum(int i)=0;
		virtual TSTR GetTrackName(int i)=0;
		virtual BOOL IsSelected(int i)=0;
		virtual void SetSelect(int i,BOOL sel)=0;
		virtual HWND GetTrackViewHWnd()=0;
		virtual int GetMajorMode()=0;
		virtual Interval GetTimeSelection()=0;
		virtual BOOL SubTreeMode()=0;
		virtual Animatable *GetTVRoot()=0;

		// This must be called when a track view utility is closing
		// so that it can be unregistered from notifications
		virtual void TVUtilClosing(TrackViewUtility *util)=0;
	};

// This is the base class for track view utilities. Plug-ins will
// derive their classes from this class.
class TrackViewUtility {
	public:
		virtual void DeleteThis()=0;		
		virtual void BeginEditParams(Interface *ip,ITVUtility *iu) {}
		virtual void EndEditParams(Interface *ip,ITVUtility *iu) {}

		virtual void TrackSelectionChanged() {}
		virtual void NodeSelectionChanged() {}
		virtual void KeySelectionChanged() {}
		virtual void TimeSelectionChanged() {}
		virtual void MajorModeChanged() {}
		virtual void TrackListChanged() {}
	};



#endif //__TVUTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\utillib.h ===
/**********************************************************************
 *<
	FILE: utillib.h

	DESCRIPTION:

	CREATED BY: Dan Silva

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#include "utilexp.h"
#include "assert1.h"
#include "tab.h"
#include "strclass.h"
#include "ptrvec.h"
#include "genhier.h"
#include "dbgprint.h"
#include "nametab.h"
#include "random.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\vedge.h ===
#ifndef VEDGE_H_DEFINED
#define  VEDGE_H_DEFINED

class VEdge {
	DWORD f[2];
	public:
		void SetFace(int i, DWORD n) { f[i] =(f[i]&0xc0000000)|n;}
		void SetWhichSide(int i, int s) { f[i] =(f[i]&0x3FFFFFFF)|((s&3)<<30); }
		DWORD GetFace(int i){ return f[i]&0x3fffffff; }
		int GetWhichSide(int i) { return (f[i]>>30)&3; }
	};

typedef struct {
	unsigned short flags;
	DWORD v[2];  /* indices of two vertices defining edge */
	DWORD f[2];  /* indices of two neighboring faces  */
	} Edge;


// Moved from VEDGE.CPP -TH
#define UNDEF 0xFFFFFFFF
#define UNDEF_FACE 0x3FFFFFFF

#endif //  VEDGE_H_DEFINED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\units.h ===
/**********************************************************************
 *<
	FILE: units.h

	DESCRIPTION: Include file for real-world units support

	CREATED BY: Tom Hudson

	HISTORY:

 *>	Copyright (c) 1995, All Rights Reserved.
 **********************************************************************/

#ifndef _UNITS_H_

#define _UNITS_H_

// The unit types we support
#define UNITS_INCHES		0
#define UNITS_FEET			1
#define UNITS_MILES			2
#define UNITS_MILLIMETERS	3
#define UNITS_CENTIMETERS	4
#define UNITS_METERS		5
#define UNITS_KILOMETERS	6

#define MAX_UNIT_TYPES 7

// The unit display types
#define UNITDISP_GENERIC	0
#define UNITDISP_METRIC		1
#define UNITDISP_US			2
#define UNITDISP_CUSTOM		3

#define MAX_UNITDISP_TYPES 4

// Metric display options
#define UNIT_METRIC_DISP_MM	0
#define UNIT_METRIC_DISP_CM	1
#define UNIT_METRIC_DISP_M	2
#define UNIT_METRIC_DISP_KM	3

#define MAX_METRIC_DISP_TYPES 4

// US display options
#define UNIT_US_DISP_FRAC_IN	0
#define UNIT_US_DISP_DEC_IN		1
#define UNIT_US_DISP_FRAC_FT	2
#define UNIT_US_DISP_DEC_FT		3
#define UNIT_US_DISP_FT_FRAC_IN	4
#define UNIT_US_DISP_FT_DEC_IN	5

#define MAX_US_DISP_TYPES 6

// US display options
#define UNIT_FRAC_1_1	0
#define UNIT_FRAC_1_2	1
#define UNIT_FRAC_1_4	2
#define UNIT_FRAC_1_8	3
#define UNIT_FRAC_1_10	4
#define UNIT_FRAC_1_16	5
#define UNIT_FRAC_1_32	6
#define UNIT_FRAC_1_64	7
#define UNIT_FRAC_1_100	8

#define MAX_FRAC_TYPES 9

// Units designator types
#define UNIT_DESIG_MM		0
#define UNIT_DESIG_CM		1
#define UNIT_DESIG_M		2
#define UNIT_DESIG_KM		3
#define UNIT_DESIG_IN		4
#define UNIT_DESIG_FT		5
#define UNIT_DESIG_CUSTOM	6

#define UNIT_DESIG_TYPES	 7

// Display information structure

typedef struct {
	int dispType;				// Display type	(UNITDISP_GENERIC, UNITDISP_METRIC, UNITDISP_US, UNITDISP_CUSTOM)
	int metricDisp;				// Metric display option
	int usDisp;					// US display option
	int usFrac;					// US fraction option
	TSTR customName;			// Custom unit name
	float customValue;			// Custom unit value
	int customUnit;				// Custom unit reference
	} DispInfo;

// Get the master scale in terms of the specified unit type
// i.e. GetMasterScale(UNITS_INCHES) gives number of inches per unit
// Returns -1.0 if invalid unit type supplied
double CoreExport GetMasterScale(int type);

void CoreExport GetMasterUnitInfo(int *type,float *scale);
int CoreExport SetMasterUnitInfo(int type,float scale);
void CoreExport GetUnitDisplayInfo(DispInfo *info);
int CoreExport SetUnitDisplayInfo(DispInfo *info);
int CoreExport GetUnitDisplayType();
int CoreExport SetUnitDisplayType(int type);
BOOL CoreExport IsValidUnitCharacter(int ch);	// Returns TRUE if character valid for unit type

// The US unit defaults
#define US_UNIT_DEFAULT_FEET 0
#define US_UNIT_DEFAULT_INCHES 1

// Get/set the default units for US entry fields -- Inches or feet
CoreExport void SetUSDefaultUnit(int type);
CoreExport int GetUSDefaultUnit();

TCHAR CoreExport *GetFirstUnitName();
TCHAR CoreExport *GetNextUnitName();
TCHAR CoreExport *GetFirstMetricDisp();
TCHAR CoreExport *GetNextMetricDisp();
TCHAR CoreExport *GetFirstUSDisp();
TCHAR CoreExport *GetNextUSDisp();
TCHAR CoreExport *GetFirstFraction();
TCHAR CoreExport *GetNextFraction();
TCHAR CoreExport *FormatUniverseValue(float value);
float CoreExport DecodeUniverseValue(TCHAR *string, BOOL *valid = NULL);


//
// Time units
//

// Ways to display time
enum TimeDisp {
	DISPTIME_FRAMES,
	DISPTIME_SMPTE,
	DISPTIME_FRAMETICKS,
	DISPTIME_TIMETICKS
	};

// Formats a time value into a string based on the current frame rate, etc.
void CoreExport TimeToString(TimeValue t,TSTR &string);
BOOL CoreExport StringToTime(TSTR string,TimeValue &t);

CoreExport int GetFrameRate();
CoreExport void SetFrameRate(int rate);
CoreExport int GetTicksPerFrame();
CoreExport void SetTicksPerFrame(int ticks);
CoreExport TimeDisp GetTimeDisplayMode();
CoreExport void SetTimeDisplayMode(TimeDisp m);
CoreExport int LegalFrameRate(int r);

#ifdef DESIGN_VER
TCHAR CoreExport *FormatUniverseValue(TCHAR *value);
#endif

#endif // _UNITS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\viewfile.h ===
//-----------------------------------------------------------------------------
// ---------------------
// File ....: ViewFile.h
// ---------------------
// Author...: Gus J Grubba
// Date ....: September 1995
// O.S. ....: Windows NT 3.51
//
// History .: Nov, 02 1995 - Created
//
// This is the "View File" option in MAX's File menu.
//
//-----------------------------------------------------------------------------

#ifndef _VIEWFINCLUDE_
#define _VIEWFINCLUDE_

#ifndef  VWFEXPORT
#define  VWFEXPORT __declspec( dllimport )
#endif

//-----------------------------------------------------------------------------
//--  Base Class Definition ---------------------------------------------------
//-----------------------------------------------------------------------------
// #> ViewFile
//
     
class ViewFile {

     private:   
        
        //-- Windows Specific -------------------------------------------------
        
        HWND              hWnd;

     public:

        //-- Constructors/Destructors -----------------------------------------

        VWFEXPORT         ViewFile           ( );
        VWFEXPORT        ~ViewFile           ( );
     
        //-- The Method -------------------------------------------------------
        //

        VWFEXPORT void    View              ( HWND hWnd );

};

//-----------------------------------------------------------------------------
//-- Interface

VWFEXPORT void *ViewFileCreate  ( );
VWFEXPORT void  ViewFileDestroy ( ViewFile *v);

#endif

//-- EOF: ViewFile.h ----------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\arraypro.h ===
/*	
 *		array_protocol.h - def_generics for Array protocol
 *
 *		see def_abstract_generics.h for more info.
 *
 *	
 *			Copyright  John Wainwright 1996
 *
 */

	def_generic        (get,		"get");
	def_generic        (put,		"put");
	def_visible_generic(append,		"append");
	def_visible_generic(deleteItem, "deleteItem");
	def_visible_generic(findItem,   "findItem");
	def_visible_generic(join,		"join");
	def_visible_generic(sort,		"sort");
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\VIZFunc.h ===
/**********************************************************************
 *<
	FILE: VIZFunc.h

	DESCRIPTION:  General header file for VIZ functionality that
	needs to be exposed across projects.

	CREATED BY: Michael Larson

	HISTORY: created 11/12/98

 *>	Copyright (c) 1998, All Rights Reserved.
 **********************************************************************/
#pragma once
#ifndef _VIZFUNC_H_
#define _VIZFUNC_H_

//This class is a catch all for functionality that will show up in VIZ
//Note that this guy will be instantiated only once.
class VIZFunc
{
private:
  static bool mIsInstantiated;

public:
//methods
VIZFunc();
~VIZFunc() {;}
CoreExport bool IsSubObjAnimEnabled(SClass_ID sclID, Class_ID clID);   //for checking to see if subobject is enabled for this class ID
CoreExport bool IsPluginPresent(SClass_ID sclID, Class_ID clID);
};

extern CoreExport VIZFunc gVIZFunc;

inline TSTR TwiddleResString(int MAXName, int VIZName)
	{
#ifdef DESIGN_VER
	return GetResString(VIZName);
#else
	return GetResString(MAXName);
#endif
	}

#endif //_VIZFunc_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\atmspro.h ===
/*	
 *		atmspro.h - def_generics for the operations on MAX atmosphere objects
 *
 *			Copyright  John Wainwright 1996
 *
 */
 
/* gizmo operations */

	def_visible_generic  ( getGizmo,	"getGizmo");
	def_visible_generic  ( deleteGizmo,	"deleteGizmo");
	def_visible_generic  ( appendGizmo,	"appendGizmo");
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\Arrays.h ===
/*		Arrays.h - the Array family of classes for MAXScript
 *
 *		Copyright (c) John Wainwright, 1996
 *		
 *
 */

#ifndef _H_ARRAYS
#define _H_ARRAYS

#include "Collect.h"

/* ------------------------ Array ------------------------------ */

visible_class (Array)

class Array : public Value, public Collection
{
public:
	int			size;					// array size
	int			data_size;				// allocated array buffer size (in Value*'s)
	Value**		data;					// the array elements (uninitialized are set to undefined)

	static CRITICAL_SECTION array_update;	// for syncing array updates

	ScripterExport	 Array(int init_size);
	ScripterExport	~Array() { if (data) free(data); }

				classof_methods (Array, Value);

	static Value* make(Value** arg_list, int count);
	static void	setup();

	Value*& operator[](const int i) const { return data[i]; } // access ith array entry.
	
#	define		is_array(v) ((v)->tag == class_tag(Array))
	BOOL		_is_collection() { return 1; }
	BOOL		_is_selection() { return 1; }
	void		gc_trace();
	void		collect() { delete this; }
	ScripterExport void sprin1(CharStream* s);

	// operations
#include "defimpfn.h"
#	include "arraypro.h"
	use_generic( plus, "+" );
	use_generic( copy, "copy" );

	ScripterExport Value* map(node_map& m);
	ScripterExport Value* map_path(PathName* path, node_map& m);
	ScripterExport Value* find_first(BOOL (*test_fn)(INode* node, int level, void* arg), void* test_arg);
	ScripterExport Value* get_path(PathName* path);

	// built-in property accessors 
	def_property ( count );

	ScripterExport Value* append(Value*);
	ScripterExport Value* join(Value*);
	ScripterExport Value* sort();
	ScripterExport Value* push(Value*);
	ScripterExport Value* drop();
	ScripterExport Value* get(int index);
	ScripterExport BOOL	  deep_eq(Value* other);

	// get selection iterator for an array
	SelectionIterator* selection_iterator();

	// scene I/O 
	IOResult Save(ISave* isave);
	static Value* Load(ILoad* iload, USHORT chunkID, ValueLoader* vload);
};

/* ------------------------ BitArray ------------------------------ */

visible_class (BitArrayValue)

class BitArrayValue : public Value
{
public:
	BitArray	bits;		// the bits

	ScripterExport BitArrayValue();
	ScripterExport BitArrayValue(BitArray& b);

				classof_methods (BitArrayValue, Value);

	static Value* make(Value** arg_list, int count);

#	define		is_BitArrayValue(v) ((v)->tag == class_tag(BitArrayValue))
//	BOOL		_is_collection() { return 1; }
	BOOL		_is_selection() { return 1; }
	void		collect() { delete this; }
	void		sprin1(CharStream* s);
	void can_hold(int index) { if (bits.GetSize() <= index) bits.SetSize(index); }

	// operations
#include "defimpfn.h"
#	include "arraypro.h"
	use_generic( plus, "+" );
	use_generic( minus, "-" );
	def_generic( uminus, "u-");
	use_generic( copy, "copy" );

	ScripterExport Value* map(node_map& m);

	// built-in property accessors
	def_property ( count );

	SelectionIterator* selection_iterator();

	BitArray&	to_bitarray() { return bits; }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\3DMath.h ===
/*		3DMath.h - the 3D math family of classes - vectors, rays, quat, matrices for MAXScript
 *
 *		Copyright (c) John Wainwright, 1996
 *		
 *
 */

#ifndef _H_3DMATH
#define _H_3DMATH

#include "Max.h"

extern ScripterExport void _QuatToEuler(Quat &q, float *ang);
extern ScripterExport void _EulerToQuat(float *ang, Quat &q);

/* ------------------------ Point3Value ------------------------------ */

applyable_class (Point3Value)

class Point3Value : public Value
{
public:
	Point3		p;

 ScripterExport Point3Value(Point3 init_point);
 ScripterExport Point3Value(float x, float y, float z);
 ScripterExport Point3Value(Value* x, Value* y, Value* z);

				classof_methods(Point3Value, Value);
	void		collect() { delete this; }
	ScripterExport void		sprin1(CharStream* s);
#	define		is_point3(p) ((p)->tag == class_tag(Point3Value))

	static Value* make(Value**arg_list, int count);
	
	/* operations */

#include "defimpfn.h"
#	include "vectpro.h"
	use_generic  ( coerce,	"coerce");
	use_generic  ( copy,	"copy");

	/* built-in property accessors */

	def_property ( x );
	def_property ( y );
	def_property ( z );

	Point3		to_point3() { return p; }
	AColor		to_acolor() { return AColor (p.x / 255.0f, p.y / 255.0f, p.z / 255.0f); }
	Point2		to_point2() { return Point2 (p.x, p.y); }

	// scene I/O 
	IOResult Save(ISave* isave);
	static Value* Load(ILoad* iload, USHORT chunkID, ValueLoader* vload);
};

class ConstPoint3Value : public Point3Value
{
public:
 ScripterExport ConstPoint3Value(float x, float y, float z)
	 : Point3Value (x, y, z) { }

	void		collect() { delete this; }
	BOOL		is_const() { return TRUE; }

	Value* set_x(Value** arg_list, int count) { throw RuntimeError (_T("Constant vector, not settable")); }
	Value* set_y(Value** arg_list, int count) { throw RuntimeError (_T("Constant vector, not settable")); }
	Value* set_z(Value** arg_list, int count) { throw RuntimeError (_T("Constant vector, not settable")); }
};

/* ------------------------ RayValue ------------------------------ */

applyable_class (RayValue)

class RayValue : public Value
{
public:
	Ray			r;

 ScripterExport RayValue(Point3 init_origin, Point3 init_dir);
 ScripterExport RayValue(Ray init_ray);

				classof_methods (RayValue, Value);
	void		collect() { delete this; }
	ScripterExport void sprin1(CharStream* s);

	/* operations */
	
	use_generic  ( copy,	"copy");

	/* built-in property accessors */

	def_property ( pos );
	def_property_alias ( position, pos );
	def_property ( dir );

	Ray			to_ray() { return r; }

	// scene I/O 
	IOResult Save(ISave* isave);
	static Value* Load(ILoad* iload, USHORT chunkID, ValueLoader* vload);
};

/* ------------------------ QuatValue ------------------------------ */

applyable_class (QuatValue)

class QuatValue : public Value
{
public:
	Quat		q;

 ScripterExport QuatValue(const Quat& init_quat);
 ScripterExport QuatValue(float w, float x, float y, float z);
 ScripterExport QuatValue(Value* w, Value* x, Value* y, Value* z);
 ScripterExport QuatValue(Value* val);
 ScripterExport QuatValue(AngAxis& aa);
 ScripterExport QuatValue(float* angles);
 ScripterExport QuatValue(Matrix3& m);

				classof_methods (QuatValue, Value);
#	define		is_quat(o) ((o)->tag == class_tag(QuatValue))
	void		collect() { delete this; }
	ScripterExport void sprin1(CharStream* s);

	/* operations */

#include "defimpfn.h"
#	include "quatpro.h"
	use_generic  ( copy,	"copy");

	/* built-in property accessors */

	def_property ( w );
	def_property ( x );
	def_property ( y );
	def_property ( z );
	def_property ( angle );
	def_property ( axis );

	Quat		to_quat() { return q; }
	AngAxis		to_angaxis() { return AngAxis(q); }

	// scene I/O 
	IOResult Save(ISave* isave);
	static Value* Load(ILoad* iload, USHORT chunkID, ValueLoader* vload);
};

/* ------------------------ AngleAxis ------------------------------ */

applyable_class (AngAxisValue)

class AngAxisValue : public Value
{
public:
	AngAxis		aa;

 ScripterExport AngAxisValue(const AngAxis& iaa);
 ScripterExport AngAxisValue(const Quat& q);
 ScripterExport AngAxisValue(const Matrix3& m);
 ScripterExport AngAxisValue(float* angles);
 ScripterExport AngAxisValue(float angle, Point3 axis);
 ScripterExport AngAxisValue(Value*);
 ScripterExport AngAxisValue(Value* angle, Value* axis);

				classof_methods (AngAxisValue, Value);
#	define		is_angaxis(o) ((o)->tag == class_tag(AngAxisValue))
	void		collect() { delete this; }
	ScripterExport void sprin1(CharStream* s);

	/* operations */
	
#include "defimpfn.h"

	use_generic( coerce,	"coerce" );
	use_generic( eq,		"=");
	use_generic( ne,		"!=");
	use_generic( random,	"random");
	use_generic( copy,		"copy");

	/* built-in property accessors */

	def_property ( angle );
	def_property ( axis );
	def_property ( numrevs );

	AngAxis		to_angaxis() { return aa; }
	Quat		to_quat() { return Quat (aa); }

	// scene I/O 
	IOResult Save(ISave* isave);
	static Value* Load(ILoad* iload, USHORT chunkID, ValueLoader* vload);
};

/* ------------------------ EulerAngles ------------------------------ */

applyable_class (EulerAnglesValue)

class EulerAnglesValue : public Value
{
public:
	float		angles[3];

 ScripterExport EulerAnglesValue(float ax, float ay, float az);
 ScripterExport EulerAnglesValue(const Quat&);
 ScripterExport EulerAnglesValue(const Matrix3&);
 ScripterExport EulerAnglesValue(const AngAxis&);

				classof_methods (EulerAnglesValue, Value);
#	define		is_eulerangles(o) ((o)->tag == class_tag(EulerAnglesValue))
	void		collect() { delete this; }
	ScripterExport void sprin1(CharStream* s);

	/* operations */
	
#include "defimpfn.h"

	use_generic( coerce,	"coerce" );
	use_generic( eq,		"=");
	use_generic( ne,		"!=");
	use_generic( random,	"random");
	use_generic( copy,		"copy");

	/* built-in property accessors */

	def_property ( x );
	def_property ( y );
	def_property ( z );
	def_property ( x_rotation );
	def_property ( y_rotation );
	def_property ( z_rotation );

	AngAxis		to_angaxis() { return AngAxis (to_quat()); }
	Quat		to_quat() { Quat q; _EulerToQuat(angles, q); return Quat (q); }

	// scene I/O 
	IOResult Save(ISave* isave);
	static Value* Load(ILoad* iload, USHORT chunkID, ValueLoader* vload);
};

/* ------------------------ Matrix ------------------------------ */

applyable_class (Matrix3Value)

class Matrix3Value : public Value
{
public:
	Matrix3		m;

 ScripterExport Matrix3Value(int i);
 ScripterExport Matrix3Value(const Matrix3& im);
 ScripterExport Matrix3Value(const Quat& q);
 ScripterExport Matrix3Value(const AngAxis& aa);
 ScripterExport Matrix3Value(float* angles);
 ScripterExport Matrix3Value(const Point3& row0, const Point3& row1, const Point3& row2, const Point3& row3);

				classof_methods (Matrix3Value, Value);
	void		collect() { delete this; }
	ScripterExport void sprin1(CharStream* s);
#	define		is_matrix3(p) ((p)->tag == class_tag(Matrix3Value))

	/* operations */
	
#include "defimpfn.h"
#	include "matpro.h"
	use_generic( copy,		"copy");

	/* built-in property accessors */

	def_property ( row1 );
	def_property ( row2 );
	def_property ( row3 );
	def_property ( row4 );
	def_property ( translation );
	def_property ( pos );
	def_property ( rotation );
	def_property ( scale );


	Value*		get_property(Value** arg_list, int count);
	Value*		set_property(Value** arg_list, int count);

	Matrix3&	to_matrix3() { return m; }
	Quat		to_quat() { return Quat (m); }

	// scene I/O 
	IOResult Save(ISave* isave);
	static Value* Load(ILoad* iload, USHORT chunkID, ValueLoader* vload);
};

/* ------------------------ Point2Value ------------------------------ */

applyable_class (Point2Value)

class Point2Value : public Value
{
public:
	Point2		p;

	ScripterExport Point2Value(Point2 ipoint);
	ScripterExport Point2Value(POINT ipoint);
	ScripterExport Point2Value(float x, float y);
	ScripterExport Point2Value(Value* x, Value* y);

				classof_methods(Point2Value, Value);
	void		collect() { delete this; }
	ScripterExport void sprin1(CharStream* s);
#	define		is_point2(p) ((p)->tag == class_tag(Point2Value))

	static Value* make(Value**arg_list, int count);
	
	/* operations */

#include "defimpfn.h"
	use_generic( plus,		"+" );
	use_generic( minus,		"-" );
	use_generic( times,		"*" );
	use_generic( div,		"/" );
	use_generic( eq,		"=");
	use_generic( ne,		"!=");
	use_generic( random,	"random");
	use_generic( length,	"length");
	use_generic( distance,	"distance");
	use_generic( normalize,	"normalize");
	use_generic( copy,		"copy");

	/* built-in property accessors */

	def_property ( x );
	def_property ( y );

	Point2		to_point2() { return p; }

	// scene I/O 
	IOResult Save(ISave* isave);
	static Value* Load(ILoad* iload, USHORT chunkID, ValueLoader* vload);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\zlibdll.h ===
/* zlibdll.h -- interface of the 'zlib' general purpose compression library
  version 1.0.4, Jul 24th, 1996.

  Copyright (C) 1995-1996 Jean-loup Gailly and Mark Adler

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  Jean-loup Gailly        Mark Adler
  gzip@prep.ai.mit.edu    madler@alumni.caltech.edu


  The data format used by the zlib library is described by RFCs (Request for
  Comments) 1950 to 1952 in the files ftp://ds.internic.net/rfc/rfc1950.txt
  (zlib format), rfc1951.txt (deflate format) and rfc1952.txt (gzip format).
*/

/* Modifications:
 *     conversion to C++; to handle IStream objects; to be a DLL
 * Copyright (C) 1998 Autodesk, Inc.
 *
 * Written by Pete Samson, Kinetix
 */

#ifndef _ZLIBDLL_H
#define _ZLIBDLL_H

#define ZLIB_VERSION "1.0.4"

#define USE_ISTREAMS

#define Z_NO_FLUSH      0
#define Z_PARTIAL_FLUSH 1
#define Z_SYNC_FLUSH    2
#define Z_FULL_FLUSH    3
#define Z_FINISH        4
/* Allowed flush values; see deflate() below for details */

#define Z_OK            0
#define Z_STREAM_END    1
#define Z_NEED_DICT     2
#define Z_ERRNO        (-1)
#define Z_STREAM_ERROR (-2)
#define Z_DATA_ERROR   (-3)
#define Z_MEM_ERROR    (-4)
#define Z_BUF_ERROR    (-5)
#define Z_VERSION_ERROR (-6)
/* Return codes for the compression/decompression functions. Negative
 * values are errors, positive values are used for special but normal events.
 */


#define Z_NULL  0  /* for initializing zalloc, zfree, opaque */

#define Z_NO_COMPRESSION         0
#define Z_BEST_SPEED             1
#define Z_BEST_COMPRESSION       9
#define Z_DEFAULT_COMPRESSION  (-1)
/* compression levels */

#define Z_FILTERED            1
#define Z_HUFFMAN_ONLY        2
#define Z_DEFAULT_STRATEGY    0
/* compression strategy; see deflateInit2() below for details */


typedef unsigned char  Byte;  /* 8 bits */
typedef unsigned int   uInt;  /* 16 bits or more */
typedef unsigned long  uLong; /* 32 bits or more */
typedef void     *voidpf;
typedef void     *voidp;
typedef voidpf (*alloc_func) (voidpf opaque, uInt items, uInt size);
typedef void   (*free_func)  (voidpf opaque, voidpf address);
typedef Byte  Bytef;
typedef char   charf;
typedef int    intf;
typedef uInt   uIntf;
typedef uLong  uLongf;

typedef struct z_stream_s {
    Bytef    *next_in;  /* next input byte */
    uInt     avail_in;  /* number of bytes available at next_in */
    uLong    total_in;  /* total nb of input bytes read so far */

    Bytef    *next_out; /* next output byte should be put there */
    uInt     avail_out; /* remaining free space at next_out */
    uLong    total_out; /* total nb of bytes output so far */

    char     *msg;      /* last error message, NULL if no error */
    struct internal_state *state; /* not visible by applications */

    alloc_func zalloc;  /* used to allocate the internal state */
    free_func  zfree;   /* used to free the internal state */
    voidpf     opaque;  /* private data object passed to zalloc and zfree */

    int     data_type;  /* best guess about the data type: ascii or binary */
    uLong   adler;      /* adler32 value of the uncompressed data */
    uLong   reserved;   /* reserved for future use */
} z_stream;

typedef z_stream *z_streamp;

typedef wchar_t WCHAR;


                        /* basic functions */

extern const char *  zlibVersion(void);
/* The application can compare zlibVersion and ZLIB_VERSION for consistency.
   If the first character differs, the library code actually used is
   not compatible with the zlib.h header file used by the application.
   This check is automatically made by deflateInit and inflateInit.
 */

/* 
extern int  deflateInit(z_streamp strm, int level);

     Initializes the internal stream state for compression. The fields
   zalloc, zfree and opaque must be initialized before by the caller.
   If zalloc and zfree are set to Z_NULL, deflateInit updates them to
   use default allocation functions.

     The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:
   1 gives best speed, 9 gives best compression, 0 gives no compression at
   all (the input data is simply copied a block at a time).
   Z_DEFAULT_COMPRESSION requests a default compromise between speed and
   compression (currently equivalent to level 6).

     deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_STREAM_ERROR if level is not a valid compression level,
   Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible
   with the version assumed by the caller (ZLIB_VERSION).
   msg is set to null if there is no error message.  deflateInit does not
   perform any compression: this will be done by deflate().
*/


extern int  deflate(z_streamp strm, int flush);
/*
  Performs one or both of the following actions:

  - Compress more input starting at next_in and update next_in and avail_in
    accordingly. If not all input can be processed (because there is not
    enough room in the output buffer), next_in and avail_in are updated and
    processing will resume at this point for the next call of deflate().

  - Provide more output starting at next_out and update next_out and avail_out
    accordingly. This action is forced if the parameter flush is non zero.
    Forcing flush frequently degrades the compression ratio, so this parameter
    should be set only when necessary (in interactive applications).
    Some output may be provided even if flush is not set.

  Before the call of deflate(), the application should ensure that at least
  one of the actions is possible, by providing more input and/or consuming
  more output, and updating avail_in or avail_out accordingly; avail_out
  should never be zero before the call. The application can consume the
  compressed output when it wants, for example when the output buffer is full
  (avail_out == 0), or after each call of deflate(). If deflate returns Z_OK
  and with zero avail_out, it must be called again after making room in the
  output buffer because there might be more output pending.

    If the parameter flush is set to Z_PARTIAL_FLUSH, the current compression
  block is terminated and flushed to the output buffer so that the
  decompressor can get all input data available so far. For method 9, a future
  variant on method 8, the current block will be flushed but not terminated.
  Z_SYNC_FLUSH has the same effect as partial flush except that the compressed
  output is byte aligned (the compressor can clear its internal bit buffer)
  and the current block is always terminated; this can be useful if the
  compressor has to be restarted from scratch after an interruption (in which
  case the internal state of the compressor may be lost).
    If flush is set to Z_FULL_FLUSH, the compression block is terminated, a
  special marker is output and the compression dictionary is discarded; this
  is useful to allow the decompressor to synchronize if one compressed block
  has been damaged (see inflateSync below).  Flushing degrades compression and
  so should be used only when necessary.  Using Z_FULL_FLUSH too often can
  seriously degrade the compression. If deflate returns with avail_out == 0,
  this function must be called again with the same value of the flush
  parameter and more output space (updated avail_out), until the flush is
  complete (deflate returns with non-zero avail_out).

    If the parameter flush is set to Z_FINISH, pending input is processed,
  pending output is flushed and deflate returns with Z_STREAM_END if there
  was enough output space; if deflate returns with Z_OK, this function must be
  called again with Z_FINISH and more output space (updated avail_out) but no
  more input data, until it returns with Z_STREAM_END or an error. After
  deflate has returned Z_STREAM_END, the only possible operations on the
  stream are deflateReset or deflateEnd.
  
    Z_FINISH can be used immediately after deflateInit if all the compression
  is to be done in a single step. In this case, avail_out must be at least
  0.1% larger than avail_in plus 12 bytes.  If deflate does not return
  Z_STREAM_END, then it must be called again as described above.

    deflate() may update data_type if it can make a good guess about
  the input data type (Z_ASCII or Z_BINARY). In doubt, the data is considered
  binary. This field is only for information purposes and does not affect
  the compression algorithm in any manner.

    deflate() returns Z_OK if some progress has been made (more input
  processed or more output produced), Z_STREAM_END if all input has been
  consumed and all output has been produced (only when flush is set to
  Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example
  if next_in or next_out was NULL), Z_BUF_ERROR if no progress is possible.
*/


extern int  deflateEnd(z_streamp strm);
/*
     All dynamically allocated data structures for this stream are freed.
   This function discards any unprocessed input and does not flush any
   pending output.

     deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the
   stream state was inconsistent, Z_DATA_ERROR if the stream was freed
   prematurely (some input or output was discarded). In the error case,
   msg may be set but then points to a static string (which must not be
   deallocated).
*/


 
extern int  inflateInit(z_streamp strm);

/*
     Initializes the internal stream state for decompression. The fields
   zalloc, zfree and opaque must be initialized before by the caller.  If
   zalloc and zfree are set to Z_NULL, inflateInit updates them to use default
   allocation functions.

     inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_VERSION_ERROR if the zlib library version is incompatible
   with the version assumed by the caller.  msg is set to null if there is no
   error message. inflateInit does not perform any decompression: this will be
   done by inflate().
*/


extern int  inflate(z_streamp strm, int flush);
/*
  Performs one or both of the following actions:

  - Decompress more input starting at next_in and update next_in and avail_in
    accordingly. If not all input can be processed (because there is not
    enough room in the output buffer), next_in is updated and processing
    will resume at this point for the next call of inflate().

  - Provide more output starting at next_out and update next_out and avail_out
    accordingly.  inflate() provides as much output as possible, until there
    is no more input data or no more space in the output buffer (see below
    about the flush parameter).

  Before the call of inflate(), the application should ensure that at least
  one of the actions is possible, by providing more input and/or consuming
  more output, and updating the next_* and avail_* values accordingly.
  The application can consume the uncompressed output when it wants, for
  example when the output buffer is full (avail_out == 0), or after each
  call of inflate(). If inflate returns Z_OK and with zero avail_out, it
  must be called again after making room in the output buffer because there
  might be more output pending.

    If the parameter flush is set to Z_PARTIAL_FLUSH, inflate flushes as much
  output as possible to the output buffer. The flushing behavior of inflate is
  not specified for values of the flush parameter other than Z_PARTIAL_FLUSH
  and Z_FINISH, but the current implementation actually flushes as much output
  as possible anyway.

    inflate() should normally be called until it returns Z_STREAM_END or an
  error. However if all decompression is to be performed in a single step
  (a single call of inflate), the parameter flush should be set to
  Z_FINISH. In this case all pending input is processed and all pending
  output is flushed; avail_out must be large enough to hold all the
  uncompressed data. (The size of the uncompressed data may have been saved
  by the compressor for this purpose.) The next operation on this stream must
  be inflateEnd to deallocate the decompression state. The use of Z_FINISH
  is never required, but can be used to inform inflate that a faster routine
  may be used for the single inflate() call.

    inflate() returns Z_OK if some progress has been made (more input
  processed or more output produced), Z_STREAM_END if the end of the
  compressed data has been reached and all uncompressed output has been
  produced, Z_NEED_DICT if a preset dictionary is needed at this point (see
  inflateSetDictionary below), Z_DATA_ERROR if the input data was corrupted,
  Z_STREAM_ERROR if the stream structure was inconsistent (for example if
  next_in or next_out was NULL), Z_MEM_ERROR if there was not enough memory,
  Z_BUF_ERROR if no progress is possible or if there was not enough room in
  the output buffer when Z_FINISH is used. In the Z_DATA_ERROR case, the
  application may then call inflateSync to look for a good compression block.
  In the Z_NEED_DICT case, strm->adler is set to the Adler32 value of the
  dictionary chosen by the compressor.
*/


extern int  inflateEnd(z_streamp strm);
/*
     All dynamically allocated data structures for this stream are freed.
   This function discards any unprocessed input and does not flush any
   pending output.

     inflateEnd returns Z_OK if success, Z_STREAM_ERROR if the stream state
   was inconsistent. In the error case, msg may be set but then points to a
   static string (which must not be deallocated).
*/

                        /* Advanced functions */

/*
    The following functions are needed only in some special applications.
*/

extern int  deflateInit2(z_streamp strm,
                                   int  level,
                                   int  method,
                                   int  windowBits,
                                   int  memLevel,
                                   int  strategy);

/*
     This is another version of deflateInit with more compression options. The
   fields next_in, zalloc, zfree and opaque must be initialized before by
   the caller.

     The method parameter is the compression method. It must be Z_DEFLATED in
   this version of the library. (Method 9 will allow a 64K history buffer and
   partial block flushes.)

     The windowBits parameter is the base two logarithm of the window size
   (the size of the history buffer).  It should be in the range 8..15 for this
   version of the library (the value 16 will be allowed for method 9). Larger
   values of this parameter result in better compression at the expense of
   memory usage. The default value is 15 if deflateInit is used instead.

     The memLevel parameter specifies how much memory should be allocated
   for the internal compression state. memLevel=1 uses minimum memory but
   is slow and reduces compression ratio; memLevel=9 uses maximum memory
   for optimal speed. The default value is 8. See zconf.h for total memory
   usage as a function of windowBits and memLevel.

     The strategy parameter is used to tune the compression algorithm. Use the
   value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a
   filter (or predictor), or Z_HUFFMAN_ONLY to force Huffman encoding only (no
   string match).  Filtered data consists mostly of small values with a
   somewhat random distribution. In this case, the compression algorithm is
   tuned to compress them better. The effect of Z_FILTERED is to force more
   Huffman coding and less string matching; it is somewhat intermediate
   between Z_DEFAULT and Z_HUFFMAN_ONLY. The strategy parameter only affects
   the compression ratio but not the correctness of the compressed output even
   if it is not set appropriately.

     If next_in is not null, the library will use this buffer to hold also
   some history information; the buffer must either hold the entire input
   data, or have at least 1<<(windowBits+1) bytes and be writable. If next_in
   is null, the library will allocate its own history buffer (and leave next_in
   null). next_out need not be provided here but must be provided by the
   application for the next call of deflate().

     If the history buffer is provided by the application, next_in must
   must never be changed by the application since the compressor maintains
   information inside this buffer from call to call; the application
   must provide more input only by increasing avail_in. next_in is always
   reset by the library in this case.

      deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was
   not enough memory, Z_STREAM_ERROR if a parameter is invalid (such as
   an invalid method). msg is set to null if there is no error message.
   deflateInit2 does not perform any compression: this will be done by
   deflate(). 

                            
extern int  deflateSetDictionary(z_streamp strm,
                                           const Bytef *dictionary,
				           uInt  dictLength);
/*
     Initializes the compression dictionary (history buffer) from the given
   byte sequence without producing any compressed output. This function must
   be called immediately after deflateInit or deflateInit2, before any call
   of deflate. The compressor and decompressor must use exactly the same
   dictionary (see inflateSetDictionary).
     The dictionary should consist of strings (byte sequences) that are likely
   to be encountered later in the data to be compressed, with the most commonly
   used strings preferably put towards the end of the dictionary. Using a
   dictionary is most useful when the data to be compressed is short and
   can be predicted with good accuracy; the data can then be compressed better
   than with the default empty dictionary. In this version of the library,
   only the last 32K bytes of the dictionary are used.
     Upon return of this function, strm->adler is set to the Adler32 value
   of the dictionary; the decompressor may later use this value to determine
   which dictionary has been used by the compressor. (The Adler32 value
   applies to the whole dictionary even if only a subset of the dictionary is
   actually used by the compressor.)

     deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a
   parameter is invalid (such as NULL dictionary) or the stream state
   is inconsistent (for example if deflate has already been called for this
   stream). deflateSetDictionary does not perform any compression: this will
   be done by deflate(). 
*/


extern int  deflateReset(z_streamp strm);
/*
     This function is equivalent to deflateEnd followed by deflateInit,
   but does not free and reallocate all the internal compression state.
   The stream will keep the same compression level and any other attributes
   that may have been set by deflateInit2.

      deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
   stream state was inconsistent (such as zalloc or state being NULL).
*/


/*   
extern int  inflateInit2(z_streamp strm,
                                   int  windowBits);

     This is another version of inflateInit with more compression options. The
   fields next_out, zalloc, zfree and opaque must be initialized before by
   the caller.

     The windowBits parameter is the base two logarithm of the maximum window
   size (the size of the history buffer).  It should be in the range 8..15 for
   this version of the library (the value 16 will be allowed soon). The
   default value is 15 if inflateInit is used instead. If a compressed stream
   with a larger window size is given as input, inflate() will return with
   the error code Z_DATA_ERROR instead of trying to allocate a larger window.

     If next_out is not null, the library will use this buffer for the history
   buffer; the buffer must either be large enough to hold the entire output
   data, or have at least 1<<windowBits bytes.  If next_out is null, the
   library will allocate its own buffer (and leave next_out null). next_in
   need not be provided here but must be provided by the application for the
   next call of inflate().

     If the history buffer is provided by the application, next_out must
   never be changed by the application since the decompressor maintains
   history information inside this buffer from call to call; the application
   can only reset next_out to the beginning of the history buffer when
   avail_out is zero and all output has been consumed.

      inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was
   not enough memory, Z_STREAM_ERROR if a parameter is invalid (such as
   windowBits < 8). msg is set to null if there is no error message.
   inflateInit2 does not perform any decompression: this will be done by
   inflate().
*/

extern int  inflateSetDictionary(z_streamp strm,
				           const Bytef *dictionary,
					   uInt  dictLength);
/*
     Initializes the decompression dictionary (history buffer) from the given
   uncompressed byte sequence. This function must be called immediately after
   a call of inflate if this call returned Z_NEED_DICT. The dictionary chosen
   by the compressor can be determined from the Adler32 value returned by this
   call of inflate. The compressor and decompressor must use exactly the same
   dictionary (see deflateSetDictionary).

     inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a
   parameter is invalid (such as NULL dictionary) or the stream state is
   inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the
   expected one (incorrect Adler32 value). inflateSetDictionary does not
   perform any decompression: this will be done by subsequent calls of
   inflate().
*/

extern int  inflateSync(z_streamp strm);
/* 
    Skips invalid compressed data until the special marker (see deflate()
  above) can be found, or until all available input is skipped. No output
  is provided.

    inflateSync returns Z_OK if the special marker has been found, Z_BUF_ERROR
  if no more input was provided, Z_DATA_ERROR if no marker has been found,
  or Z_STREAM_ERROR if the stream structure was inconsistent. In the success
  case, the application may save the current current value of total_in which
  indicates where valid compressed data was found. In the error case, the
  application may repeatedly call inflateSync, providing more input each time,
  until success or end of the input data.
*/


extern int  inflateReset(z_streamp strm);
/*
     This function is equivalent to inflateEnd followed by inflateInit,
   but does not free and reallocate all the internal decompression state.
   The stream will keep attributes that may have been set by inflateInit2.

      inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
   stream state was inconsistent (such as zalloc or state being NULL).
*/



                        /* utility functions */

/*
     The following utility functions are implemented on top of the
   basic stream-oriented functions. To simplify the interface, some
   default options are assumed (compression level, window size,
   standard memory allocation functions). The source code of these
   utility functions can easily be modified if you need special options.
*/

extern int  compress(Bytef *dest,   uLongf *destLen,
			       const Bytef *source, uLong sourceLen);
/*
     Compresses the source buffer into the destination buffer.  sourceLen is
   the byte length of the source buffer. Upon entry, destLen is the total
   size of the destination buffer, which must be at least 0.1% larger than
   sourceLen plus 12 bytes. Upon exit, destLen is the actual size of the
   compressed buffer.
     This function can be used to compress a whole file at once if the
   input file is mmap'ed.
     compress returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_BUF_ERROR if there was not enough room in the output
   buffer.
*/

extern int  uncompress(Bytef *dest,   uLongf *destLen,
				 const Bytef *source, uLong sourceLen);
/*
     Decompresses the source buffer into the destination buffer.  sourceLen is
   the byte length of the source buffer. Upon entry, destLen is the total
   size of the destination buffer, which must be large enough to hold the
   entire uncompressed data. (The size of the uncompressed data must have
   been saved previously by the compressor and transmitted to the decompressor
   by some mechanism outside the scope of this compression library.)
   Upon exit, destLen is the actual size of the compressed buffer.
     This function can be used to decompress a whole file at once if the
   input file is mmap'ed.

     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_BUF_ERROR if there was not enough room in the output
   buffer, or Z_DATA_ERROR if the input data was corrupted.
*/

typedef void     *voidp;
typedef voidp gzFile;

struct IStorage;
struct IStream;

#ifdef USE_ISTREAMS
extern gzFile  gzopen(IStream *, const WCHAR *ipath, const char *path, const char *mode);
#else
extern gzFile  gzopen(const char *path, const char *mode);
#endif
/*
     Opens a gzip (.gz) file for reading or writing. The mode parameter
   is as in fopen ("rb" or "wb") but can also include a compression level
   ("wb9").  gzopen can be used to read a file which is not in gzip format;
   in this case gzread will directly read from the file without decompression.
     gzopen returns NULL if the file could not be opened or if there was
   insufficient memory to allocate the (de)compression state; errno
   can be checked to distinguish the two cases (if errno is zero, the
   zlib error is Z_MEM_ERROR).
*/


extern int     gzread(gzFile file, voidp buf, unsigned len);
/*
     Reads the given number of uncompressed bytes from the compressed file.
   If the input file was not in gzip format, gzread copies the given number
   of bytes into the buffer.
     gzread returns the number of uncompressed bytes actually read (0 for
   end of file, -1 for error). */

extern int     gzwrite(gzFile file, const voidp buf, unsigned len);
/*
     Writes the given number of uncompressed bytes into the compressed file.
   gzwrite returns the number of uncompressed bytes actually written
   (0 in case of error).
*/

extern int     gzflush(gzFile file, int flush);
/*
     Flushes all pending output into the compressed file. The parameter
   flush is as in the deflate() function. The return value is the zlib
   error number (see function gzerror below). gzflush returns Z_OK if
   the flush parameter is Z_FINISH and all output could be flushed.
     gzflush should be called only when strictly necessary because it can
   degrade compression.
*/

#if 0
extern int     gzseek(gzFile file, long int address, uInt mode);
/*
     Seeks (if read); fails (if write).
*/
#endif

extern int     gzclose(gzFile file);
/*
     Flushes all pending output if necessary, closes the compressed file
   and deallocates all the (de)compression state. The return value is the zlib
   error number (see function gzerror below).
*/

extern const char *  gzerror(gzFile file, int *errnum);
/*
     Returns the error message for the last error which occurred on the
   given compressed file. errnum is set to zlib error number. If an
   error occurred in the file system and not in the compression library,
   errnum is set to Z_ERRNO and the application may consult errno
   to get the exact error code.
*/

                        /* checksum functions */
extern uLong crc32   (uLong crc, const Bytef *buf, uInt len);
/*
     Update a running crc with the bytes buf[0..len-1] and return the updated
   crc. If buf is NULL, this function returns the required initial value
   for the crc. Pre- and post-conditioning (one's complement) is performed
   within this function so it shouldn't be done by the application.
   Usage example:

     uLong crc = crc32(0L, Z_NULL, 0);

     while (read_buffer(buffer, length) != EOF) {
       crc = crc32(crc, buffer, length);
     }
     if (crc != original_crc) error();
*/


                        /* various hacks, don't look :) */

/* deflateInit and inflateInit are macros to allow checking the zlib version
 * and the compiler's view of z_stream:
 */
extern int  deflateInit_(z_streamp strm, int level,
			           const char *version, int stream_size);
extern int  inflateInit_(z_streamp strm,
				   const char *version, int stream_size);
extern int  deflateInit2_(z_streamp strm, int  level, int  method,
				    int windowBits, int memLevel, int strategy,
				    const char *version, int stream_size);
extern int  inflateInit2_(z_streamp strm, int  windowBits,
				    const char *version, int stream_size);
#define deflateInit(strm, level) \
        deflateInit_((strm), (level),       ZLIB_VERSION, sizeof(z_stream))
#define inflateInit(strm) \
        inflateInit_((strm),                ZLIB_VERSION, sizeof(z_stream))
#define deflateInit2(strm, level, method, windowBits, memLevel, strategy) \
        deflateInit2_((strm),(level),(method),(windowBits),(memLevel),\
		      (strategy),           ZLIB_VERSION, sizeof(z_stream))
#define inflateInit2(strm, windowBits) \
        inflateInit2_((strm), (windowBits), ZLIB_VERSION, sizeof(z_stream))


#endif /* _ZLIBDLL_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\winutil.h ===
/**********************************************************************
 *<
	FILE: winutil.h

	DESCRIPTION: Misc. windows related functions

	CREATED BY: Rolf Berteig

	HISTORY: 1-6-95 file created

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef __WINUTIL__
#define __WINUTIL__

#include <limits>

float CoreExport GetWindowFloat(HWND hwnd,BOOL *valid=NULL);
int CoreExport GetWindowInt(HWND hwnd,BOOL *valid=NULL);
BOOL CoreExport SetWindowTextInt( HWND hwnd, int i );
BOOL CoreExport SetWindowTextFloat( HWND hwnd, float f, int precision=3 );
BOOL CoreExport SetDlgItemFloat( HWND hwnd, int idControl, float val );
float CoreExport GetDlgItemFloat( HWND hwnd, int idControl, BOOL *valid=NULL );
void CoreExport SetDlgFont( HWND hDlg, HFONT hFont );
void CoreExport SlideWindow( HWND hwnd, int x, int y );
void CoreExport StretchWindow( HWND hwnd, int w, int h );
BOOL CoreExport CenterWindow(HWND hWndChild, HWND hWndParent);
void CoreExport GetClientRectP( HWND hwnd, Rect *rect );
void CoreExport DrawIconButton( HDC hdc, HBITMAP hBitmap, Rect& wrect, Rect& brect, BOOL in );
int CoreExport GetListHieght( HWND hList );
void CoreExport ShadedVertLine( HDC hdc, int x, int y0, int y1, BOOL in );
void CoreExport ShadedHorizLine( HDC hdc, int y, int x0, int x1, BOOL in );
void CoreExport ShadedRect( HDC hdc, RECT& rect );
void CoreExport Rect3D( HDC hdc, RECT& rect, BOOL in );
void CoreExport WhiteRect3D( HDC hdc, RECT rect, BOOL in );
void CoreExport DrawButton( HDC hdc, RECT rect, BOOL in );
void CoreExport XORDottedRect( HWND hwnd, IPoint2 p0, IPoint2 p1 );
void CoreExport XORDottedCircle( HWND hwnd, IPoint2 p0, IPoint2 p1 );
void CoreExport XORDottedPolyline( HWND hwnd, int count, IPoint2 *pts);
void CoreExport XORRect(HDC hdc, RECT& r, int border=1);
void CoreExport MakeButton2State(HWND hCtrl);
void CoreExport MakeButton3State(HWND hCtrl);
int CoreExport GetCheckBox(HWND hw, int id);
void CoreExport SetCheckBox(HWND hw, int id, BOOL b);
BOOL CoreExport DoesFileExist(const TCHAR *file);
int CoreExport GetBitsPerPixel();

// Delete superfluous zeroes from float string: 1.2300000 -> 1.23
void CoreExport StripTrailingZeros(TCHAR* buf);

template<class T> void LimitValue( T& value, T min, T max )
	{
	if ( value < min ) value = min;
	if ( value > max ) value = max;
	}

// mjm - 1.26.99 - safely casts double to float - valid flag will indicate overflow
inline float Dbl2Flt(double val, BOOL *valid = NULL)
{
	if ( val < 0.0f )
	{
		if ( val < -FLT_MAX )
		{
			if (valid) *valid = FALSE;
			return -FLT_MAX;
		}
		if ( val > -FLT_MIN )
		{
			if (valid) *valid = FALSE;
			return -FLT_MIN;
		}
		if (valid) *valid = TRUE;
		return (float)val;
	}

	if ( val > FLT_MAX )
	{
		if (valid) *valid = FALSE;
		return FLT_MAX;
	}
	if ( val < FLT_MIN && val != 0.0 )
	{
		if (valid) *valid = FALSE;
		return FLT_MIN;
	}
	if (valid) *valid = TRUE;
	return (float)val;
}

// mjm - 1.26.99 - safely casts double to int - valid flag will indicate overflow
inline int Dbl2Int(double val, BOOL *valid = NULL)
{
	if ( val > INT_MAX )
	{
		if (valid) *valid = FALSE;
		return INT_MAX;
	}
	if ( val < INT_MIN )
	{
		if (valid) *valid = FALSE;
		return INT_MIN;
	}
	if (valid) *valid = TRUE;
	return (int)val;
}

#define MAKEPOINT( lparam, pt ) { pt.x = (short)LOWORD(lparam); pt.y = (short)HIWORD(lparam); }

// The following two functions extend list boxes. Set the list box to be
// owner draw and then call these two methods in response to the
// WM_MEASUREITEM and WM_DRAWITEM messages.
// 

// Flags to pass to CustListDrawItem
#define CUSTLIST_DISABLED		(1<<0)		// Text is gray
#define CUSTLIST_MED_DISABLED	(1<<1)		// Test is darker gray
#define CUSTLIST_SEPARATOR		(1<<2)		// Draws a separator instead of text
#define CUSTLIST_DBL_SERPARATOR	(1<<3)		// Draw a double line seperator
#define CUSTLIST_RED			(1<<4)      // Text is red

CoreExport void CustListMeasureItem(HWND hList,WPARAM wParam, LPARAM lParam);
CoreExport void CustListDrawItem(HWND hList,WPARAM wParam, LPARAM lParam,DWORD flags);


// MAX extended message box functionality  DB 7/98

#define MAX_MB_HOLD				0x0001		// add "Hold" button
#define MAX_MB_DONTSHOWAGAIN	0x0002		// add "Don't show this dialog again" checkbox

// The first four parameters are just like the Win32 MessageBox routine (but not
// all MessageBox functionality is supported!)
//
// The last two optional args add the functionality listed above -- exType is used
// for adding the additional buttons, and exRet is used for getting the extra
// return info.  For example, if exType includes MAX_MB_DONTSHOWAGAIN, and exRet
// is non-NULL, then exRet will have MAX_MB_DONTSHOWAGAIN set if that checkbox was
// checked by the user.

CoreExport int MaxMsgBox(HWND hWnd, LPCTSTR lpText, LPCTSTR lpCaption, UINT type, UINT exType=0, DWORD *exRet=NULL);

/**********************************************************************
 *
 * alpha blended icon support...
 *
 **********************************************************************/
#include "plugapi.h"

enum LoadMAXIconErrors
	{
	LMI_Ok,
	LMI_ResourceNotFound,
	LMI_ResourceLoadFailed,
	LMI_ImageAndMaskNotCompatible,
	};

CoreExport LoadMAXIconErrors LoadMAXIcon(HINSTANCE hInstance, LPCTSTR resID, LPCTSTR resMaskID, COLORREF bkColor,
		HIMAGELIST imageList, int imageIndex, int preMultAlpha=TRUE);

// returns index of first image into existing imageList
CoreExport int LoadMAXIconFromBMI(LPBITMAPINFOHEADER biImage, LPBITMAPINFOHEADER biMask, COLORREF bkColor, HIMAGELIST imageList, int preMultAlpha=TRUE);

CoreExport void DrawMAXIcon(HDC hDC, Rect &r, HIMAGELIST hList32, HIMAGELIST hList16, int index);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\bipedpro.h ===
// Protocols for biped export classes
	
	def_visible_generic(SetNonUniformScale,			"SetNonUniformScale");
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\BitMaps.h ===
/*	
 *		BitMaps.h - MAX bitmap access classes
 *
 *			Copyright  John Wainwright 1996
 *
 */

#ifndef _H_BITMAPS
#define _H_BITMAPS

#include "Max.h"
#include "MAXObj.h"
#include "COMMDLG.H"
#include "bmmlib.h"

class MAXBitMapWindow;
class MotionTracker;
class MAXBitMap;

typedef struct				// entry in MAXBitMap window table
{
	HWND		window;
	MAXBitMap*	mbm;
} mbm_window;

/* ------------------------ MAXBitMap ------------------------------ */

applyable_class (MAXBitMap)

class MAXBitMap : public Value
{
public:
	BitmapInfo			  bi;					// our BitMapInfo 
	Bitmap*				  bm;					// the actual bitmap
	Tab<MotionTracker*>	  trackers;				// any motion trackers
	MotionTracker*		  dragger;				// tracker currently under drag
	WNDPROC				  main_window_proc;		// original display window proc if ours installed
	GBuffer*			  gb;					// GBuffer if non-NULL
	GBufReader*			  gbr;					// current GBuffer reader if non-NULL
	short				  flags;	

	static Tab<mbm_window> windows;				// table of MAXBitMap windows currently open

	ScripterExport MAXBitMap();
	ScripterExport MAXBitMap(BitmapInfo bi, Bitmap* bm);
			   ~MAXBitMap();

	static void setup();
	static MAXBitMap* find_window_mbm(HWND hwnd);

				classof_methods (MAXBitMap, Value);
#	define		is_bitmap(o) ((o)->tag == class_tag(MAXBitMap))
	void		collect() { delete this; }
	void		gc_trace();
	ScripterExport void sprin1(CharStream* s);

	Value*		new_motionTracker();
	void		install_window_proc();

#include "defimpfn.h"
	def_visible_generic ( display,			"display"); 
	def_visible_generic ( unDisplay,		"unDisplay" ); 
	def_visible_generic ( save,				"save" ); 
	def_visible_generic ( gotoFrame,		"gotoFrame"); 
	def_visible_generic ( close,			"close");
	def_visible_generic ( getTracker,		"getTracker" ); 
	def_visible_generic ( deleteTracker,	"deleteTracker" ); 
	use_generic			( copy,				"copy" ); 
	def_visible_generic ( zoom,				"zoom" ); 
	def_visible_generic ( crop,				"crop" ); 
	def_visible_generic ( setAsBackground,	"setAsBackground" ); 
	def_visible_generic ( getPixels,		"getPixels" ); 
	def_visible_generic ( setPixels,		"setPixels" ); 
	def_visible_generic ( getIndexedPixels, "getIndexedPixels" ); 
	def_visible_generic ( setIndexedPixels, "setIndexedPixels" ); 
	def_visible_generic ( getChannel,		"getChannel" ); 
	def_visible_generic ( getChannelAsMask, "getChannelAsMask" ); 

	Value*		get_property(Value** arg_list, int count);
	Value*		set_property(Value** arg_list, int count);
};

#define BM_SAVED	0x0001			// bitmap has been written to.
#define BM_READONLY	0x0002			// existing bitmap opened (and so readonly).

/* -------------------- MotionTracker -------------------------- */

applyable_class (MotionTracker)

class MotionTracker : public Value
{
public:
	MAXBitMap*	mbm;			// the bitmap I'm tracking
	int			index;			// which tracker in that bitmap
	int			cur_frame;		// frame I last tracked
	POINT		center;			// current feature center
	RECT		bounds;			// feature bounds relative to center
	RECT		motion_bounds;	// maximum frame-to-frame motion relative to feature center
	POINT		mouse_down_at;	// mouse pos at mousedown
	int			handle_x;		// handle pos at mouse_down..
	int			handle_y;		// handle pos at mouse_down..
	int			handle;			// which handle is dragging
	BYTE*		target;			// current target image as 3 BYTE RGB per pixel
	POINT*		track_cache;	// keeps a cache of tracking coords, one per frame (inval if change gizmo)
	short		compare_mode;	// feature matching space: rgb color, luminence, edge-filtered, etc.
	float		match_distance;	// last tracking match 'distance'
	HBITMAP		id_bitmap;		// unbelievable - I need to use a bitmap copy to do XOR text drawing
	short		flags;

				MotionTracker(MAXBitMap* imbm, int iindex);
			   ~MotionTracker();

				classof_methods(MotionTracker, Value);
	void		collect() { delete this; }
	ScripterExport void sprin1(CharStream* s);
	void		gc_trace();

	void		track();
	void		clear_track_cache();
	void		set_center(int x, int y);
	void		set_index(int i);
	void		copy_target();
	void		draw(HWND hWnd);
	void		draw_gizmo(HDC hdc);
	void		inval_gizmo();
	BOOL		start_drag(HWND hwnd, int wParam, long lParam);
	void		drag(HWND hwnd, int wParam, long lParam);
	void		end_drag(HWND hwnd);
	void		move(HWND hwnd, int dx, int dy);
	void		deselect(HWND hwnd);

	def_visible_generic ( resample,    "resample");
	def_visible_generic ( reset,	   "reset");

	def_property ( center );
	Value*		get_property(Value** arg_list, int count);
	Value*		set_property(Value** arg_list, int count);
};

#define MT_GIZMO_SELECTED		0x0001
#define MT_GIZMO_MOVED			0x0002
#define MT_ENABLED				0x0004

#define MT_MATCH_RGB			0
#define MT_MATCH_GRAY			1
#define MT_MATCH_EDGE			2
#define MT_MATCH_RANK			3

#define MT_NO_HANDLE			0		// handle codes...
#define MT_CENTER				1		
#define MT_TOPLEFT_BOUNDS		2
#define MT_BOTLEFT_BOUNDS		3
#define MT_TOPRIGHT_BOUNDS		4
#define MT_BOTRIGHT_BOUNDS		5
#define MT_TOPLEFT_MBOUNDS		6
#define MT_BOTLEFT_MBOUNDS		7
#define MT_TOPRIGHT_MBOUNDS		8
#define MT_BOTRIGHT_MBOUNDS		9

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\classIDs.h ===
/*	
 *		class_ids.h - OLE Automation class id defs for MAXScript
 *
 *			Copyright  John Wainwright 1996
 *
 */

/* our class ID */

// {7FA22CB1-D26F-11d0-B260-00A0240CEEA3}
DEFINE_GUID(CLSID_MAXScript, 0x7fa22cb1, 0xd26f, 0x11d0, 0xb2, 0x60, 0x0, 0xa0, 0x24, 0xc, 0xee, 0xa3);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\bmatpro.h ===
// Protocol for BigMatrix class
	
	use_generic( get,			"get");
	use_generic( put,			"put");	
	use_generic( identity,		"identity");	//Should actually be mapped_generic
	use_generic( plus,			"+");

	def_visible_generic( invert,		"invert");	
	def_visible_generic( transpose,		"transpose");
	def_visible_generic( clear,			"clear");
	def_visible_generic( setSize,		"setSize");
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\biprops.h ===
/*	
 *		built_in_properties.h - known core property defs for MAXScript
 *
 *			Copyright  John Wainwright 1996
 *
 */

// MUST BE maintained in alpha order for parser lookup table use
// sort path props as though concatenated with '.', nested props as though
// prefixed with '*.'

	def_nested_prop		  ( angle )	
	def_nested_prop		  ( axis )	
	def_nested_prop		  ( b )
	def_nested_prop		  ( blue )	
	def_nested_prop		  ( controller )
	def_nested_prop		  ( g )
	def_nested_prop		  ( green )
	def_nested_prop		  ( isAnimated )
	def_nested_prop		  ( keys )
	def_nested_prop		  ( r )
	def_nested_prop		  ( red )
	def_nested_prop_alias ( track, controller )
	def_nested_prop		  ( x )
	def_nested_prop		  ( x_rotation )
	def_nested_prop		  ( y )
	def_nested_prop		  ( y_rotation )
	def_nested_prop		  ( z )
	def_nested_prop		  ( z_rotation )

	def_property		  ( a )
	def_property		  ( alpha )	
	def_property		  ( angle )
	def_property		  ( autoParam )
	def_property		  ( autoUpdate )	
	def_property		  ( axis )	
	def_property		  ( axisTM )	
	def_property		  ( b )
	def_property		  ( bias )
	def_property		  ( blue )
	def_property		  ( bottom )
	def_property		  ( boxDisp )
	def_property		  ( categories )
	def_property	      ( category )
	def_property		  ( center )
	def_property		  ( children )
	def_property		  ( classID )
	def_property		  ( closedInU )
	def_property		  ( closedInV )
	def_property		  ( clp )
	def_property		  ( config )
	def_property		  ( constantVelocity )
	def_property		  ( continuity)
	def_property	  	  ( controller )
	def_property	  	  ( controllers )
	def_property	  	  ( count )
	def_property		  ( cubic )
	def_property		  ( curvatureAngle )
	def_property		  ( curvatureDistance )
	def_property		  ( curveCVs )
	def_property		  ( curves )
	def_property		  ( curveStartPoint )
	def_property		  ( curveStartPoint1 )
	def_property		  ( curveStartPoint2 )
	def_property		  ( degradeOnMove )
	def_property		  ( dir )
	def_property		  ( disabled )
	def_property		  ( displacementMapping )
	def_property		  ( display )
	def_property		  ( displayCurveCVLattices )
	def_property		  ( displayCurves )
	def_property		  ( displayDependents )
	def_property		  ( displayLattices )
	def_property		  ( displayShadedLattice )
	def_property		  ( displaySurfaces )
	def_property		  ( displaySurfCVLattices )
	def_property		  ( displayTrimming )
	def_property		  ( distance )
	def_property		  ( easeFrom )
	def_property		  ( easeTo)
	def_property		  ( edge )
	def_property		  ( edge1 )
	def_property		  ( edge2 )
	def_property		  ( edges )
	def_property		  ( effectsChannel )
	def_property		  ( end )
	def_property		  ( endsOverlap )
	def_property		  ( extrudeVector )
	def_property		  ( faces )
	def_property		  ( fileName )
	def_property		  ( flip1 )
	def_property		  ( flip2 )
	def_property		  ( flipNormals )
	def_property		  ( flipTrim )
	def_property		  ( flipTrim1 )
	def_property		  ( flipTrim2 )
	def_property		  ( frame )
	def_property		  ( g )
	def_property		  ( generateUVs1 )
	def_property		  ( generateUVs2 )
	def_property		  ( green )
	def_property		  ( h )	
	def_property		  ( hidden )
	def_property		  ( hue )
	def_property		  ( ignoreAnimation )
	def_property		  ( ignoreCameras )
	def_property		  ( ignoreHelpers )
	def_property		  ( ignoreLights )
	def_property		  ( ignoreShapes )
	def_property		  ( imports )
	def_property		  ( index )
	def_property		  ( inTangent )
	def_property		  ( inTangentType )
	def_property		  ( isAnimated )
	def_property		  ( isClosed )
	def_property		  ( isoULines )
	def_property		  ( isoVLines )
	def_property		  ( keys )
	def_property		  ( left )
	def_property		  ( length1 )
	def_property		  ( length2 )
	def_property		  ( mat )
	def_property_alias	  ( material, mat )
	def_property		  ( matID )
	def_property		  ( max )
	def_property_alias	  ( maximum, max )
	def_property		  ( merge )
	def_property		  ( mesh )
	def_property		  ( meshApproxType )
	def_property		  ( meshUSteps )
	def_property		  ( meshVSteps )
	def_property		  ( min )
	def_property_alias	  ( minimum, min )
	def_property		  ( modifiers )
	def_property		  ( name )
	def_property		  ( normal )
	def_property		  ( normalized )
	def_property		  ( numChannels )
	def_property		  ( numcpvverts )
	def_property		  ( numCurves )
	def_property		  ( numCVs )
	def_property		  ( numfaces )
	def_property		  ( numGizmos )
	def_property		  ( numKnots )
	def_property_alias	  ( nummaterials, numsubs )
	def_property		  ( numObjects )
	def_property		  ( numPoints )
	def_property		  ( numrevs )
	def_property		  ( numsplines )
	def_property		  ( numsubs )
	def_property		  ( numTrimPoints )
	def_property		  ( numtverts )
	def_property		  ( numUCurves )
	def_property		  ( numUCVs )
	def_property		  ( numUKnots )
	def_property		  ( numUPoints )
	def_property		  ( numVCurves )
	def_property		  ( numVCVs )
	def_property		  ( numverts )
	def_property		  ( numVKnots )
	def_property		  ( numVPoints )
	def_property		  ( nurbsID )
	def_property		  ( nurbsSet )
	def_property		  ( object )
	def_property		  ( objectoffsetpos )
	def_property		  ( objectoffsetrot )
	def_property		  ( objectoffsetscale )
	def_property		  ( objecttransform )
	def_property		  ( offset )
	def_property		  ( optimize )
	def_property		  ( order )
	def_property		  ( outTangent )
	def_property		  ( outTangentType )
	def_property		  ( parallel )
	def_property		  ( parameter )
	def_property		  ( parameterRangeMax )
	def_property		  ( parameterRangeMin )
	def_property		  ( parent )
	def_property		  ( parent1 )
	def_property		  ( parent1ID )
	def_property		  ( parent2 )
	def_property		  ( parent2ID )
	def_property		  ( parentID )
	def_property		  ( pivot )
	def_2_prop_path		  ( pivot, x )
	def_2_prop_path		  ( pivot, y )
	def_2_prop_path		  ( pivot, z )
	def_property		  ( points )
	def_property		  ( pos )
	def_2_prop_path		  ( pos, controller )
	def_2_prop_path		  ( pos, isAnimated )
	def_2_prop_path		  ( pos, keys )
	def_2_prop_path_alias ( pos, track, pos, controller )
	def_2_prop_path		  ( pos, x )
	def_2_prop_path		  ( pos, y )
	def_2_prop_path		  ( pos, z )
	def_property_alias	  ( position, pos )
	def_2_prop_path_alias ( position, controller, pos, controller )
	def_2_prop_path_alias ( position, isAnimated, pos, isAnimated )
	def_2_prop_path_alias ( position, keys, pos, keys )
	def_2_prop_path_alias ( position, track, pos, controller )
	def_2_prop_path_alias ( position, x, pos, x)
	def_2_prop_path_alias ( position, y, pos, y )
	def_2_prop_path_alias ( position, z, pos, z )
	def_property		  ( pVec )
	def_property		  ( r )
	def_property		  ( radius )
	def_property		  ( rail )
	def_property		  ( rail1 )
	def_property		  ( rail1ID )
	def_property		  ( rail2 )
	def_property		  ( rail2ID )
	def_property		  ( railID )
	def_property		  ( red )
	def_property		  ( renderable )
	def_property		  ( renderApproximation )
	def_property		  ( renderConfig )
	def_property		  ( renderCurvatureAngle )
	def_property		  ( renderCurvatureDistance )
	def_property		  ( renderIsoULines )
	def_property		  ( renderIsoVLines )
	def_property		  ( renderMeshApproxType )
	def_property		  ( renderMeshUSteps )
	def_property		  ( renderMeshVSteps )
	def_property		  ( renderSpacialEdge )
	def_property		  ( renderViewDependent )
	def_property		  ( right )
	def_property		  ( rigid )
	def_property		  ( rotation )
	def_2_prop_path		  ( rotation, angle )
	def_2_prop_path		  ( rotation, axis )
	def_2_prop_path		  ( rotation, controller )
	def_2_prop_path		  ( rotation, isAnimated )
	def_2_prop_path		  ( rotation, keys )
	def_2_prop_path_alias ( rotation, track, rotation, controller )
	def_2_prop_path		  ( rotation, x_rotation )
	def_2_prop_path		  ( rotation, y_rotation )
	def_2_prop_path		  ( rotation, z_rotation )
	def_property		  ( row1 )
	def_property		  ( row2 )
	def_property		  ( row3 )
	def_property		  ( row4 )
	def_property		  ( s )
	def_property		  ( saturation )
	def_property		  ( scale )
	def_2_prop_path		  ( scale, axis )
	def_2_prop_path		  ( scale, controller )
	def_2_prop_path		  ( scale, isAnimated )
	def_2_prop_path		  ( scale, keys )
	def_2_prop_path_alias ( scale, track, scale, controller )
	def_2_prop_path		  ( scale, x )
	def_2_prop_path		  ( scale, y )
	def_2_prop_path		  ( scale, z )
	def_property		  ( seed )
	def_property		  ( selected )
	def_property		  ( selectedCurveCVs )
	def_property		  ( selectedCurves )
	def_property		  ( selectedEdges )
	def_property		  ( selectedFaces )
	def_property		  ( selectedImports )
	def_property		  ( selectedPoints )
	def_property		  ( selectedSurfaces )
	def_property		  ( selectedSurfCVs )
	def_property		  ( selectedVertices )
	def_property_alias	  ( selectedVerts, selectedVertices )
	def_property		  ( selSetNames )
	def_property		  ( spacialEdge )
	def_property		  ( splitMesh )
	def_property		  ( start )
	def_property		  ( steps )
	def_property		  ( subdivisionDisplacement )
	def_property		  ( surfaces )
	def_property		  ( surfCVs )
	def_property		  ( sweep )
	def_property		  ( target )
	def_property		  ( tension )
	def_property		  ( tension1 )
	def_property		  ( tension2 )
	def_property		  ( textureSurface1 )
	def_property		  ( textureSurface2 )
	def_property		  ( ticks )
	def_property		  ( time )
	def_property		  ( top )
	def_property_alias	  ( track, controller )
	def_property		  ( transform )
	def_property		  ( translation )
	def_property		  ( tree )
	def_property		  ( trim )
	def_property		  ( trim1 )
	def_property		  ( trim2 )
	def_property		  ( trimCurve )
	def_property		  ( trimCurve1 )
	def_property		  ( trimCurve2 )
	def_property		  ( type )
	def_property		  ( uEdgesOverlap )
	def_property		  ( uOrder )
	def_property		  ( uParam )
	def_property		  ( uParameterRangeMax )
	def_property		  ( uParameterRangeMin )
	def_property		  ( uTangent )
	def_property		  ( v )
	def_property		  ( value)
	def_property		  ( vEdgesOverlap )
	def_property		  ( vertices)
	def_property_alias	  ( verts, vertices )
	def_property		  ( viewApproximation )
	def_property		  ( viewConfig )
	def_property		  ( viewCurvatureAngle )
	def_property		  ( viewCurvatureDistance )
	def_property		  ( viewDependent )
	def_property		  ( viewIsoULines )
	def_property		  ( viewIsoVLines )
	def_property		  ( viewMeshApproxType )
	def_property		  ( viewMeshUSteps )
	def_property		  ( viewMeshVSteps )
	def_property		  ( viewSpacialEdge )
	def_property		  ( viewViewDependent )
	def_property		  ( vOrder )
	def_property		  ( vParam )
	def_property		  ( vParameterRangeMax )
	def_property		  ( vParameterRangeMin )
	def_property		  ( vTangent )
	def_property		  ( w )
	def_property		  ( weight )
	def_property		  ( x )
	def_property		  ( x_locked )
	def_property		  ( x_rotation )
	def_property		  ( y )
	def_property		  ( y_locked )
	def_property		  ( y_rotation )
	def_property		  ( z )
	def_property		  ( z_locked )
	def_property		  ( z_rotation )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\boxpro.h ===
// Protocols for Box classes

	use_generic( eq,		"=");
	use_generic( ne,		"!=");
	use_generic( scale,		"scale");
	use_generic( translate,	"translate");

	def_visible_generic( isEmpty,	"isEmpty");			
	def_visible_generic( contains,	"contains");
	def_visible_generic( rectify,	"rectify");
	def_visible_generic( empty,		"empty");
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\bitmapro.h ===
/*	
 *		bitmap_protocol.h - protocol for MAX bitmaps
 *
 *			Copyright  John Wainwright 1996
 *
 */
 
// BitMap

	def_visible_primitive( openBitMap,		"openBitMap" ); 
	def_visible_primitive( selectBitMap,	"selectBitMap" ); 
	def_visible_generic  ( display,			"display" ); 
	def_visible_generic  ( unDisplay,		"unDisplay" ); 
	def_visible_generic  ( save,			"save" ); 
	use_generic          ( close,			"close" ); 
	def_visible_generic  ( gotoFrame,		"gotoFrame" ); 
	def_visible_generic  ( getTracker,		"getTracker" ); 
	def_visible_generic  ( deleteTracker,	"deleteTracker" ); 
//	def_visible_generic  ( perspectiveMatch, "perspectiveMatch" ); 

	use_generic			 ( copy,			"copy" ); 
	def_visible_generic  ( zoom,			"zoom" ); 
	def_visible_generic  ( crop,			"crop" ); 
	def_visible_generic  ( setAsBackground, "setAsBackground" ); 

	def_visible_generic  ( getPixels,		 "getPixels" ); 
	def_visible_generic  ( setPixels,		 "setPixels" ); 
	def_visible_generic  ( getIndexedPixels, "getIndexedPixels" ); 
	def_visible_generic  ( setIndexedPixels, "setIndexedPixels" ); 
	def_visible_generic  ( getChannel,		 "getChannel" ); 
	def_visible_generic  ( getChannelAsMask, "getChannelAsMask" ); 

// BitMapWIndow
	
// MotionTracker
	
	def_visible_generic ( resample,			"resample");
	def_visible_generic ( reset,			"reset");
	def_visible_generic ( clearCacheEntry,  "clearCacheEntry");
	def_visible_generic ( setCacheEntry,    "setCacheEntry");
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\Colctble.h ===
/*	Collectable.h - Collectables include
 *
 *			Copyright (c) John Wainwright, 1996
 *
 */

#ifndef _H_COLLECTIBLE
#define _H_COLLECTIBLE

enum col_state {booting, pre_gc, in_mutator, in_mark, in_sweep, closing_down };

typedef struct free_mem free_mem;		// free mem linked list entry
struct free_mem
{
	free_mem*	next;
	free_mem*	prev;
	size_t		size;
};
		
/* collection flag bits ... */

enum gc_flags
{
	GC_IN_USE			= 0x0001,
	GC_GARBAGE			= 0x0002,
	GC_PERMANENT		= 0x0004,
	GC_IN_HEAP			= 0x0008,
	GC_NOT_NEW			= 0x0010,
	GC_STATIC			= 0x0020,
};

// free-list is kept in a number of separate size-related sub-lists, specifically
// for the high-bandwidth low size allocs.
// the heads of these are in the free_list static array in Collectable.
// each consecutive sub-list is for chunks one GC_ALLOC_MULTIPLE greater than the previous.
// the following defines determine the number of sub-lists.  

#define GC_NUM_SUBLISTS				128 
#define GC_LOW_SUBLIST				16   // <16, 16, 20, 24, 28, 32, ... 512, >512
#define GC_SUBLIST_INDEX_SHIFT		4    // log2(LOW_SUBLIST)

class Value;
class ValueMapper;

class Collectable
{
public:
	Collectable*	next;					// links (in whichever list instance is in)
	Collectable*	prev;
	static CRITICAL_SECTION list_update;	// for syncing allocation list updates
	short			flags;					// collection flags

	static Collectable* collectable_list;	// head of the collectable list
	static Collectable* permanent_list;		// head of the permanent list
	static free_mem* free_list[GC_NUM_SUBLISTS];				// head of the free list
	static size_t heap_allocated;			// running count of MAXScript heap usage
	static size_t heap_size;				// alloc'd heap size
	static col_state state;					// current collector state
	
	ScripterExport Collectable();
	ScripterExport ~Collectable();

	static ScripterExport void for_all_values(void (*map_fn)(Value* val), ValueMapper* mapper = NULL, ValueMetaClass* c = NULL);

	ScripterExport void* operator new (size_t);
	ScripterExport void operator delete (void *);
	
	static void	mark();
	static void	sweep();
	static void	setup(size_t);
	ScripterExport static void	gc();
	static void	coalesce_free_list();
	virtual void collect() = 0;				  // does the actual collecting, needs to be virtual to get right size to operator delete
	virtual void gc_trace() { mark_in_use(); } // the marking scanner, default is mark me in use
	static void close_down();
	static void drop_maxwrapper_refs();

	ScripterExport void	make_static() { make_permanent(); flags |= GC_STATIC; }
	ScripterExport void	make_permanent();
	ScripterExport void	make_collectable();

	int		is_marked()			{ return (flags & GC_IN_USE); }
	int		is_not_marked()		{ return !is_marked(); }
	int		is_garbage()		{ return is_not_marked(); }
	int		is_permanent()		{ return (flags & GC_PERMANENT); }
	void	mark_in_use()		{ flags |= GC_IN_USE; }
	void	unmark_in_use()		{ flags &= ~GC_IN_USE; }
};

// mapping object for Collectable::for_all_values()
class ValueMapper 
{
public:
	virtual void map(Value* val)=0;
};

ScripterExport void ms_free(void* p);
ScripterExport void* ms_malloc(size_t sz);
inline void ms_make_collectable(Collectable* v) { if (v != NULL && Collectable::state != closing_down) v->make_collectable(); }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\Collect.h ===
/*		Collection.h - MAXScript Collection classes
 *
 *		Copyright (c) John Wainwright, 1996
 *		
 *
 */

#ifndef _H_COLLECTION
#define _H_COLLECTION

class PathName;

class Collection
{
public:
#	define  is_collection(v) ((v)->_is_collection())

	virtual Value* map_path(PathName* path, value_vf vfn_ptr, value_cf cfn_ptr, Value** arg_list, int count);
	virtual Value* find_first(BOOL (*test_fn)(INode* node, int  level, void* arg), void* test_arg);
	virtual Value* get_path(PathName* path_name);
};

class SelectionIterator
{
public:
#	define  is_selection(v) ((v)->_is_selection())
	virtual int next() { return -1; }
	virtual BOOL more() { return FALSE; }
	virtual void rewind() { }
	virtual BOOL selected(int index) { return FALSE; }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\CodeTree.h ===
/*		CodeTree.h - the CodeTree class - parser output
 *
 *		Copyright (c) John Wainwright, 1996
 *		
 *
 */

#ifndef _H_CODETREE
#define _H_CODETREE

class CodeTree : public Value
{
public:
	Value*	fn;				/* the function to apply					*/
	short	count;			/* number of arguments						*/
	Value**	arg_list;		/* the argument list						*/
	long	pos;			/* source stream pos						*/

			CodeTree(CharStream* source, Value* codeFn, ...);
			~CodeTree();

	void	gc_trace();
	void	collect() { delete this; }
	ScripterExport void	sprin1(CharStream* s);

    ScripterExport Value* eval();

	Value*	add(Value* arg1, ...);
	Value*	append(Value* arg);
	Value*	put(int index, Value* arg);
};

/*  Maker class, a special CodeTree node that encodes runtime object 
 *               instantiation.  contains a reference to a maker
 *               static method on the class to be instantiated.  It is
 *				 supplied an arg_list like any other codetree fn apply
 */
 
class Maker : public Value
{
	value_cf maker;			/* the maker class static fn				*/
	short	count;			/* number of arguments						*/
	Value**	arg_list;		/* the argument list						*/

public:
			Maker(value_cf maker_fn, ...);
			Maker(Value** arg_list, int count, value_cf maker_fn);
			~Maker();

	void	gc_trace();
	void	collect() { delete this; }
	ScripterExport void	sprin1(CharStream* s);

	ScripterExport Value* eval();

	Value*	add(Value* arg1, ...);
	Value*	append(Value* arg);
};

/* ------------- debugging support classes -------------- */

// SourceFileWrapper wraps a piece of code in a source file
// context.  Evaling this pushes the 'source-file' thread-local,
// evals the wrapped code & pops source-file.

class SourceFileWrapper : public Value
{
public:
	Value*	file_name;
	int		pos;
	Value*	code;

			SourceFileWrapper(Value* file_name, Value* code, int pos = -1);

	void	gc_trace();
	void	collect() { delete this; }
	ScripterExport void	sprin1(CharStream* s) { code->sprin1(s); }
	BOOL	_is_function() { return code->_is_function(); }

				   Value* classOf_vf(Value** arg_list, int count) { return code->classOf_vf(arg_list, count); }
				   Value* superClassOf_vf(Value** arg_list, int count) { return code->superClassOf_vf(arg_list, count); }
				   Value* isKindOf_vf(Value** arg_list, int count) { return code->isKindOf_vf(arg_list, count); }
				   BOOL	  is_kind_of(ValueMetaClass* c) { return code->is_kind_of(c); }
    ScripterExport Value* eval();
 	ScripterExport Value* eval_no_wrapper();
    ScripterExport Value* apply(Value** arglist, int count);
};

// SourceLineMarker instances are stuck in code
// as lines are change

class SourceLineMarker : public Value
{
public:
	int		pos;

			SourceLineMarker(int pos);

	void	collect() { delete this; }
	ScripterExport void	sprin1(CharStream* s) { s->printf(_T("<line %d>"), pos); }

    ScripterExport Value* eval() { thread_local(source_pos) = pos; return &ok; }
};

// top-level code block, provides a storage for top-level locals

class CodeBlock : public Value
{
public:
	Value*		code;			// the code
	Value**		locals;			// local var array	
	int			local_count;	//   "    "  count	

				CodeBlock() { tag = INTERNAL_CODEBLOCK_TAG; code = NULL; locals = NULL; local_count = 0; }
	void		init(Value* code) { this->code = code; }
			   ~CodeBlock();

	void		collect() { delete this; }
	void		gc_trace();
	void		sprin1(CharStream* s);

	void		add_local();
	Value*		eval();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\colorpro.h ===
/*	
 *		color_protocol.h - def_generics for MAXScript Color protocol
 *
 *		see def_abstract_generics.h for more info.
 *
 *	
 *			Author John Wainwright
 *			Copyright  Autodesk Inc., 1997
 *
 */

	use_generic( plus,		"+" );
	use_generic( minus,		"-" );
	use_generic( times,		"*" );
	use_generic( div,		"/" );
	use_generic( uminus,	"u-");

	use_generic( eq,		"=");
	use_generic( ne,		"!=");

	use_generic( random,	"random");
	def_visible_generic( composite,	"composite");
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\ColorVal.h ===
/*		ColorValue.h - the color class for MAXScript
 *
 *		Copyright (c) John Wainwright, 1997
 *		
 */

#ifndef _H_COLORVALUE
#define _H_COLORVALUE

#include "Max.h"
#include "COMMDLG.H"
#include "bmmlib.h"
#include "3DMath.h"

#define COLOR_CACHE_SIZE	1024	// must be power of 2

/* ------------------------ Color ------------------------------ */

applyable_class (ColorValue)

class ColorValue : public Value
{
public:
	AColor		color;

 ScripterExport ColorValue (AColor col);
 ScripterExport ColorValue (Color col);
 ScripterExport ColorValue (COLORREF col);
 ScripterExport ColorValue (BMM_Color_64& col);
 ScripterExport ColorValue (Point3 col);
 ScripterExport ColorValue (Point3Value* col);
 ScripterExport ColorValue (float r, float g, float b, float a = 1.0f);

	static ScripterExport Value* intern(AColor col);
	static ScripterExport Value* intern(float r, float g, float b, float a = 1.0f);
	static ScripterExport Value* intern(BMM_Color_64& col);

				classof_methods (ColorValue, Value);
	void		collect() { delete this; }
	ScripterExport void sprin1(CharStream* s);
#	define		is_color(c) ((c)->tag == class_tag(ColorValue))

#include "defimpfn.h"
#	include "colorpro.h"
	def_generic  ( coerce,	"coerce");
	def_generic  ( copy,	"copy");

	def_property		 ( red );
	def_local_prop_alias ( r, red );
	def_property		 ( green );
	def_local_prop_alias ( g, green );
	def_property		 ( blue );
	def_local_prop_alias ( b, blue );
	def_property		 ( alpha );
	def_local_prop_alias ( a, alpha );
	def_property		 ( hue );
	def_local_prop_alias ( h, hue );
	def_property		 ( saturation );
	def_local_prop_alias ( s, saturation );
	def_property		 ( value );
	def_local_prop_alias ( v, value );

	AColor		to_acolor() { return color; }
	Color		to_color() { return Color (color.r, color.g, color.b); }
	COLORREF	to_colorref() { return RGB((int)(color.r * 255.0f), (int)(color.g * 255.0f), (int)(color.b * 255.0f)); }
	Point3		to_point3() { return Point3 (color.r * 255.0, color.g * 255.0, color.b * 255.0); }

	// scene I/O 
	IOResult Save(ISave* isave);
	static Value* Load(ILoad* iload, USHORT chunkID, ValueLoader* vload);
};

class ConstColorValue : public ColorValue
{
public:
 ScripterExport ConstColorValue (float r, float g, float b, float a = 1.0f) 
					: ColorValue(r, g, b, a) { }

	void		collect() { delete this; }
	BOOL		is_const() { return TRUE; }
	Value*		set_red(Value** arg_list, int count) { throw RuntimeError (_T("Constant color, not settable")); }
	Value*		set_green(Value** arg_list, int count) { throw RuntimeError (_T("Constant color, not settable")); }
	Value*		set_blue(Value** arg_list, int count) { throw RuntimeError (_T("Constant color, not settable")); }
	Value*		set_alpha(Value** arg_list, int count) { throw RuntimeError (_T("Constant color, not settable")); }
	Value*		set_hue(Value** arg_list, int count) { throw RuntimeError (_T("Constant color, not settable")); }
	Value*		set_h(Value** arg_list, int count) { throw RuntimeError (_T("Constant color, not settable")); }
	Value*		set_saturation(Value** arg_list, int count) { throw RuntimeError (_T("Constant color, not settable")); }
	Value*		set_value(Value** arg_list, int count) { throw RuntimeError (_T("Constant color, not settable")); }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\corename.h ===
/*	
 *		core_names.h - def_names for all the name objects that the MAXScript substrate code uses
 *
 *			Copyright  John Wainwright 1996
 *
 */
 
/* useful interned names */

	def_name(2D)
	def_name(3D)
	def_name(abort)
	def_name(about)
	def_name(active)
	def_name(across)
	def_name(align)
	def_name(all)
	def_name(angle)
	def_name(animate)
	def_name(animatable)
	def_name(antiAliasFilter)
	def_name(antiAliasFilterSize)
	def_name(any)
	def_name(apply)
	def_name(aspect)
	def_name(atmospheric)
	def_name(automatic)
	def_name(axis)
	def_name(b)
	def_name(beep)
	def_name(before)
	def_name(bitmap)
	def_name(blowUp)
	def_name(blue)
	def_name(blur)
	def_name(bold)
	def_name(buildMesh)
	def_name(button)
	def_name(buttonDown)
	def_name(buttonText)
	def_name(buttonUp)
	def_name(camera)
	def_name(category)
	def_name(caption)
	def_name(center)
	def_name(centripetal)
	def_name(change)
	def_name(changed)
	def_name(changes)
	def_name(channels)
	def_name(channelsRequired)
	def_name(checkbox)
	def_name(checkbutton)
	def_name(checked)
	def_name(class)
	def_name(classID)
	def_name(clone)
	def_name(close)
	def_name(rgb)
	def_name(color)
	def_name(colorPicker)
	def_name(columns)
	def_name(combobox)
	def_name(common)
	def_name(continue)
	def_name(contrast)
	def_name(controller)
	def_name(coordsys)
	def_name(count)
	def_name(create)
	def_name(current)
	def_name(default)
	def_name(deleted)
	def_name(determinantsign)
	def_name(deinterlace)
	def_name(dir)
	def_name(display)
	def_name(distance)
	def_name(doubleClicked)
	def_name(draft)
	def_name(dropdownList)
	def_name(dynamicOnly)
	def_name(edittext)
	def_name(edge)
	def_name(enabled)
	def_name(enabledInViews)
	def_name(enablePixelSampler)
	def_name(encryptFile)
	def_name(entered)
	def_name(error)
	def_name(errPrompt)
	def_name(escape)
	def_name(even)
	def_name(extend)
	def_name(extends)
	def_name(faces)
	def_name(featureBounds)
	def_name(fieldorder)
	def_name(fieldwidth)
	def_name(filename)
	def_name(filmback)
	def_name(filmbackCropEnabled)
	def_name(filter)
	def_name(float)
	def_name(for)
	def_name(force2sided)
	def_name(frame)
	def_name(framerange)
	def_name(freeMove)
	def_name(from)
	def_name(fromframe)
	def_name(g)
	def_name(get)
	def_name(gamma)
	def_name(gizmo)
	def_name(grayscale)
	def_name(green)
	def_name(grid)
	def_name(group)
	def_name(handleAt)
	def_name(hasAlpha)
	def_name(hasUVW)
	def_name(height)
	def_name(helper)
	def_name(hidden)
	def_name(high)
	def_name(highlightColor)
	def_name(horizontal)
	def_name(image)
	def_name(images)
	def_name(icon)
	def_name(id)
	def_name(incleft)
	def_name(include)
	def_name(incright)
	def_name(independent)
	def_name(indices)
	def_name(infinite)
	def_name(integer)
	def_name(into)
	def_name(invert)
	def_name(invisible)
	def_name(isAnimated)
	def_name(isSelected)
	def_name(items)
	def_name(keyboard)
	def_name(keep)
	def_name(keys)
	def_name(keyDown)
	def_name(keyUp)
	def_name(keyword)
	def_name(label)
	def_name(labels)
	def_name(layer)
	def_name(left)
	def_name(length)
	def_name(lengthsegs)
	def_name(light)
	def_name(listbox)
	def_name(level)
	def_name(load)
	def_name(local)
	def_name(low)
	def_name(map)
	def_name(mapButton)
	def_name(matchSpace)
	def_name(material)
	def_name(materialButton)
	def_name(materialIDs)
	def_name(matID)
	def_name(matIDs)
	def_name(max)
	def_name(medium)
	def_name(merge)
	def_name(message)
	def_name(middle)
	def_name(mode)
	def_name(modifier)
	def_name(modLimitZMin)
	def_name(modLimitZMax)
	def_name(modLimitAxis)
	def_name(mouseAbort)
	def_name(mouseMove)
	def_name(mousePoint)
	def_name(mouseMoveCallback)
	def_name(motionBounds)
	def_name(moved)
	def_name(multiple)
	def_name(name)
	def_name(names)
	def_name(netrender)
	def_name(noCloseButton)
	def_name(node)
	def_name(nodeTM)
	def_name(noLoad)
	def_name(noMap)
	def_name(none)
	def_name(noPrompt)
	def_name(noRedraw)
	def_name(normal)
	def_name(normals)
	def_name(noslide)
	def_name(nthframe)
	def_name(numfaces)
	def_name(numframes)
	def_name(numtrackers)
	def_name(numverts)
	def_name(numsubs)
	def_name(object)
	def_name(objectID)
	def_name(odd)
	def_name(off)
	def_name(offset)
	def_name(okToClose)
	def_name(okToDisplay)
	def_name(on)
	def_name(onObject)
	def_name(open)
	def_name(openEncryptedFile)
	def_name(options)
	def_name(orient)
	def_name(outputdevice)
	def_name(outputheight)
	def_name(outputfile)
	def_name(outputOnly)
	def_name(outputSize)
	def_name(outputwidth)
	def_name(palette)
	def_name(parallel)
	def_name(parameters)
	def_name(parent)
	def_name(persistent)
	def_name(pickbutton)
	def_name(picked)
	def_name(pickedobject)
	def_name(pivot)
	def_name(pixelaspect)
	def_name(point3)
	def_name(pos)
	def_name(position)
	def_name(preApply)
	def_name(prefix)
	def_name(pressed)
	def_name(production)
	def_name(progressBar)
 	def_name(project)
 	def_name(projected)
	def_name(prompt)
	def_name(pt2Prompt)
	def_name(quiet)
	def_name(radiobuttons)
	def_name(r)
	def_name(range)
	def_name(rank)
	def_name(rankDistance)
	def_name(red)
	def_name(redraw)
	def_name(redrawViews)
	def_name(region)
	def_name(regionCrop)
	def_name(reload)
	def_name(renderApproximation)
	def_name(renderatmosphericeffects)
	def_name(renderEffect)
	def_name(renderer)
	def_name(renderfields)
	def_name(renderhiddenobjects)
	def_name(renderType)
	def_name(replaceUI)
	def_name(resized)
	def_name(right)
	def_name(rightClick)
	def_name(rollout)
	def_name(rolledUp)
	def_name(rotation)
	def_name(rotationpart)
	def_name(rubberBand)
	def_name(scale)
	def_name(scalepart)
	def_name(scalerotationpart)
	def_name(screen)
	def_name(scrollPos)
	def_name(selectedtracker)
	def_name(set)
	def_name(setTime)
	def_name(setGenUVW)
	def_name(shape)
	def_name(showHidden)
	def_name(showTracks)
	def_name(silentErrors)
	def_name(simple)
	def_name(simpleMod)
	def_name(simpleObject)
	def_name(single)
	def_name(size)
	def_name(slider)
	def_name(snap)
	def_name(spinner)
	def_name(standard)
	def_name(start)
	def_name(state)
	def_name(steps)
	def_name(stop)
	def_name(subAnim)
	def_name(subAnimStructure)
	def_name(superblack)
	def_name(tabSize)
	def_name(tabSizeVariable)
	def_name(tangent)
	def_name(target)
	def_name(terminators)
	def_name(text)
	def_name(textureMap)
	def_name(textureSurface1)
	def_name(textureSurface2)
	def_name(textureVerts)
	def_name(time)
	def_name(timeChange)
	def_name(ticks)
	def_name(title)
	def_name(to)
	def_name(toframe)
	def_name(toolTip)
	def_name(topology)
	def_name(trackCallback)
	def_name(transform)
	def_name(translationpart)
	def_name(tverts)
	def_name(type)
	def_name(types)
	def_name(ui)
	def_name(uniform)
	def_name(update)
	def_name(userDefined)
	def_name(worldUnits)
	def_name(value)
	def_name(velocity)
	def_name(version)
	def_name(vertical)
	def_name(verts)
	def_name(vertices)
	def_name(view)
	def_name(viewApproximation)
	def_name(visible)
	def_name(vfb)
	def_name(videocolorcheck)
	def_name(width)
	def_name(widthsegs)
	def_name(world)
	def_name(x)
	def_name(x_rotation)
	def_name(y)
	def_name(y_rotation)
	def_name(z)
	def_name(z_rotation)

	def_name(ambientMap)  // HEY!! is there a better way?
	def_name(diffuseMap)
	def_name(specularMap)
	def_name(shininessMap)
	def_name(shinestrengthMap)
	def_name(selfillumMap)
	def_name(opacityMap)
	def_name(filterMap)
	def_name(bumpMap)
	def_name(reflectionMap)
	def_name(refractionMap)
	def_name(displacementMap)

	def_name(ambientMapAmount)
	def_name(diffuseMapAmount)
	def_name(specularMapAmount)
	def_name(shininessMapAmount)
	def_name(shinestrengthMapAmount)
	def_name(selfillumMapAmount)
	def_name(opacityMapAmount)
	def_name(filterMapAmount)
	def_name(bumpMapAmount)
	def_name(reflectionMapAmount)
	def_name(refractionMapAmount)
	def_name(displacementMapAmount)

	def_name(ambientMapEnable)
	def_name(diffuseMapEnable)
	def_name(specularMapEnable)
	def_name(shininessMapEnable)
	def_name(shinestrengthMapEnable)
	def_name(selfillumMapEnable)
	def_name(opacityMapEnable)
	def_name(filterMapEnable)
	def_name(bumpMapEnable)
	def_name(reflectionMapEnable)
	def_name(refractionMapEnable)
	def_name(displacementMapEnable)

	def_name(objects)
	def_name(geometry)
	def_name(lights)
	def_name(cameras)
	def_name(helpers)
	def_name(shapes)
	def_name(systems)
	def_name(spacewarps)
	def_name(selection)

	def_name(menuitem)
	def_name(separator)
	def_name(seperator)
	def_name(submenu)

	def_name(selOnly)
	def_name(allKeys)
	def_name(children)
	def_name(linkToKeys)
	def_name(selected)
	def_name(select)
	def_name(interpolate)
	def_name(slide)
	def_name(rightToLeft)
	def_name(dontSort)

	def_name(smooth)
	def_name(linear)
	def_name(step)
	def_name(fast)
	def_name(slow)
	def_name(custom)

	def_name(inTangent)
	def_name(outTangent)
	def_name(inTangentType)
	def_name(outTangentType)
	def_name(x_locked)
	def_name(y_locked)
	def_name(z_locked)
	def_name(constantVelocity)
	def_name(tension)
	def_name(bias)
	def_name(continuity)
	def_name(easeTo)
	def_name(easeFrom)

	def_name(corner)
	def_name(bezier)
	def_name(bezierCorner)
	def_name(curve)
	def_name(line)

	def_name(constant)
	def_name(cycle)
	def_name(loop)
	def_name(pingPong)
	def_name(relativeRepeat)

	def_name(deleteOldDups)
	def_name(mergeDups)
	def_name(skipDups)
	def_name(promptDups)

	//RK: Added these
	def_name(omni)
	def_name(targetSpot)
	def_name(freeSpot)
	def_name(freeDirect)
	def_name(targetDirect)
	def_name(free)

	def_name(mapping)
	def_name(shadows)
	def_name(autoReflect)
	def_name(forceWireframe)
	def_name(wireThickness)
	def_name(antiAliasing)
	def_name(filterMaps)
	def_name(pixelSize)
	def_name(objectMotionBlur)
	def_name(objectBlurSamples)
	def_name(objectBlurDuration)
	def_name(objectBlurSubdivisions)
	def_name(imageMotionBlur)
	def_name(imageBlurDuration)
	def_name(imageBlurEnvironmentMap)
	def_name(raytracedShadowDepth)
	def_name(autoReflectLevels)

	def_name(aperture)
	def_name(ditherTrueColor)
	def_name(ditherPaletted)
	def_name(renderPAL)
	def_name(superBlackThreshold)
	def_name(maxPixelSize)

	def_name(inactive)
	def_name(videoPost)
	def_name(render)
	def_name(missing)
	def_name(localOnly)

	def_name ( uParam )
	def_name ( uTangent )
	def_name ( trimCurve )
	def_name ( flipTrim )
	def_name ( parent1 )
	def_name ( parent2 )
	def_name ( surfaceParent )
	def_name ( parentID )
	def_name ( surfaceParentID )
	def_name ( parent1ID )
	def_name ( parent2ID )
	def_name ( trimCurve1 )
	def_name ( trimCurve2 )
	def_name ( flipTrim1 )
	def_name ( flipTrim2 )
	def_name ( vParam )
	def_name ( vTangent )
	def_name ( parameter )
	def_name ( positive )
	def_name ( negative )
	def_name ( cubic )

	def_name ( isClosed );
	def_name ( numTrimPoints );
	def_name ( parameterRangeMin );
	def_name ( parameterRangeMax );
	def_name ( order );
	def_name ( closed );
	def_name ( numKnots );
	def_name ( numCVs );
	def_name ( endsOverlap );
	def_name ( numPoints );
	def_name ( flip1 );
	def_name ( flip2 );
	def_name ( tension1 );
	def_name ( tension2 );
	def_name ( radius );
	def_name ( trim1 );
	def_name ( trim2 );
	def_name ( length1 );
	def_name ( length2 );
	def_name ( X );
	def_name ( Y );
	def_name ( Z );
	def_name ( XY );
	def_name ( XZ );
	def_name ( YZ );
	def_name ( U );
	def_name ( V );
	def_name ( channel );
	def_name ( uOrder );
	def_name ( vOrder );
	def_name ( numUKnots );
	def_name ( numVKnots );
	def_name ( numUCVs );
	def_name ( numVCVs );
	def_name ( closedU );
	def_name ( closedV );
	def_name ( edge1 );
	def_name ( edge2 );
	def_name ( numCurves );
	def_name ( flip );
	def_name ( extrudeVector );
	def_name ( axisTM );
	def_name ( sweep );
	def_name ( relational );
	def_name ( uEdgesOverlap );
	def_name ( vEdgesOverlap );
	def_name ( viewConfig )
	def_name ( viewIsoULines )
	def_name ( viewIsoVLines )
	def_name ( viewMeshUSteps )
	def_name ( viewMeshVSteps )
	def_name ( viewMeshApproxType )
	def_name ( viewSpacialEdge )
	def_name ( viewCurvatureAngle )
	def_name ( viewCurvatureDistance )
	def_name ( viewViewDependent )
	def_name ( renderConfig )
	def_name ( renderIsoULines )
	def_name ( renderIsoVLines )
	def_name ( renderMeshUSteps )
	def_name ( renderMeshVSteps )
	def_name ( renderMeshApproxType )
	def_name ( renderSpacialEdge )
	def_name ( renderCurvatureAngle )
	def_name ( renderCurvatureDistance )
	def_name ( renderViewDependent )
	def_name ( config )
	def_name ( isoULines )
	def_name ( isoVLines )
	def_name ( meshUSteps )
	def_name ( meshVSteps )
	def_name ( meshApproxType )
	def_name ( spacialEdge )
	def_name ( curvatureAngle )
	def_name ( curvatureDistance )
	def_name ( viewDependent )
	def_name ( startPoint )
	def_name ( useTangent )
	def_name ( flipTangent )
	def_name ( autoParam )
	def_name ( shapeIDs )
	def_name ( rigid )
	def_name ( curveStartPoint )
	def_name ( curveStartPoint1 )
	def_name ( curveStartPoint2 )
	def_name ( displayShadedLattice )

	def_name ( seed )
	def_name ( trim )
	def_name ( pVec )
	def_name ( clp )
	def_name ( numUCurves )
	def_name ( numVCurves )
	def_name ( rail )
	def_name ( railID )
	def_name ( rail1 )
	def_name ( rail1ID )
	def_name ( rail2 )
	def_name ( rail2ID )
	def_name ( displayCurves )
	def_name ( displaySurfaces )
	def_name ( displayLattices )
	def_name ( displaySurfCVLattices )
	def_name ( displayCurveCVLattices )
	def_name ( displayDependents )
	def_name ( displayTrimming )
	def_name ( degradeOnMove )
	def_name ( renderable )
	def_name ( generateUVs1 )
	def_name ( generateUVs2 )

	def_name ( isoOnly )
	def_name ( isoAndMesh )
	def_name ( meshOnly )
	def_name ( parametric )
	def_name ( spatial )
	def_name ( curvature )
	def_name ( regular )
	def_name ( spatialAndCurvature )

	def_name ( capStart )
	def_name ( capEnd )
	def_name ( capType )
	def_name ( weldCore )
	def_name ( flipNormals )
	def_name ( mapCoords )
	def_name ( segs )
	def_name ( matIDS )

	def_name ( cvDelta )
	def_name ( jumpDelta )
	def_name ( subpixelLevel )

/* distinguished marker values, un-interned names */

	def_marker(keyarg_marker, "#keys")
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\creatpro.h ===
/*	
 *		MAX_create_protocol.h - def_generics for the create MAX objects
 *
 *		see def_abstract_generics.h for more info.
 *
 *	
 *			Copyright  John Wainwright 1996
 *
 */
 
	def_generic(create,	"create");
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\ctrlrpro.h ===
/*	
 *		MAX_controller_protocol.h - def_generics for the operations on MAX controller objects
 *
 *			Copyright  John Wainwright 1996
 *
 */
 
/* controller operations */

	use_generic			 (copy,						"copy");

/* time operations */

	def_visible_generic  ( supportsTimeOperations,	"supportsTimeOperations");
	def_mapped_generic   ( deleteTime,				"deleteTime");
	def_mapped_generic   ( reverseTime,				"reverseTime");
	def_mapped_generic   ( scaleTime,				"scaleTime");
	def_mapped_generic   ( insertTime,				"insertTime");
	
	def_visible_generic  ( getTimeRange,			"getTimeRange");
	def_mapped_generic   ( setTimeRange,			"setTimeRange");

/* key operations */

	def_mapped_generic   ( addNewKey,				"addNewKey");
	def_mapped_generic   ( deleteKeys,				"deleteKeys");
	def_visible_generic  ( deleteKey,				"deleteKey");
	def_mapped_generic   ( selectKeys,				"selectKeys");
	def_visible_generic  ( selectKey,				"selectKey");
	def_mapped_generic   ( deselectKeys,			"deselectKeys");
	def_visible_generic  ( deselectKey,				"deselectKey");
	def_visible_generic  ( isKeySelected,			"isKeySelected");
	def_mapped_generic   ( moveKeys,				"moveKeys");
	def_visible_generic  ( moveKey,					"moveKey");
	def_visible_generic  ( numKeys,					"numKeys");
	def_visible_generic  ( getKey,					"getKey");
	def_visible_generic  ( getKeyTime,				"getKeyTime");
	def_visible_generic  ( getKeyIndex,				"getKeyIndex");
	def_visible_generic  ( numSelKeys,				"numSelKeys");
	def_mapped_generic   ( sortKeys,				"sortKeys");
	def_mapped_generic   ( reduceKeys,				"reduceKeys");

/* ORT, ease curve functions */

	def_mapped_generic   ( addEaseCurve,			"addEaseCurve");
	def_mapped_generic   ( deleteEaseCurve,			"deleteEaseCurve");
	def_visible_generic  ( numEaseCurves,			"numEaseCurves");
	def_visible_generic  ( applyEaseCurve,			"applyEaseCurve");
	def_visible_generic  ( addMultiplierCurve,		"addMultiplierCurve");
	def_visible_generic  ( deleteMultiplierCurve,	"deleteMultiplierCurve");
	def_visible_generic  ( numMultiplierCurves,		"numMultiplierCurves");
	def_visible_generic  ( getMultiplierValue,		"getMultiplierValue");

	def_visible_generic  ( getBeforeORT,			"getBeforeORT");
	def_visible_generic  ( getAfterORT,				"getAfterORT");
	def_mapped_generic   ( setBeforeORT,			"setBeforeORT");
	def_mapped_generic   ( setAfterORT,				"setAfterORT");
	def_mapped_generic   ( enableORTs,				"enableORTs");
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\defabs21.h ===
/*	
 *	defabs21.h - macros for making abstract declarations for MAXScript functions
 *
 *     abstract def_ macros for MAX R2.1
 *
 *	John Wainwright
 *	Copyright  Autodesk, Inc. 1998
 *
 */

/* def_generic macro for abstract declaration in Value class */

#ifdef def_generic
#	undef def_generic
#	undef def_node_generic
#	undef def_mapped_generic
#	undef def_visible_generic
#	undef def_struct_generic
#	undef use_generic
#	undef def_primitive
#	undef def_mapped_primitive
#	undef def_lazy_primitive
#	undef def_visible_lazy_primitive
#	undef def_visible_primitive
#	undef def_struct_primitive
#	undef def_property
#	undef def_property_alias
#	undef def_2_prop_path
#	undef def_2_prop_path_alias
#	undef def_nested_prop
#	undef def_nested_prop_alias
#endif
#ifdef def_prop_getter
#	undef def_prop_getter
#	undef def_prop_setter
#endif

#define def_generic(fn, name)
#define def_visible_generic(fn, name) def_generic(fn, name)
#define def_struct_generic(fn, name) def_generic(fn, name)
#define def_node_generic(fn, name) def_generic(fn, name)
#define def_mapped_generic(fn, name) def_generic(fn, name)
#define use_generic(fn, name)

#define def_primitive(fn, name)		// no member function declarations for primitives
#define def_visible_primitive(fn, name)
#define def_mapped_primitive(fn, name)
#define def_lazy_primitive(fn, name)
#define def_visible_lazy_primitive(fn, name)
#define def_struct_primitive(fn, _struct, name)
#define def_property(p) 
#define def_property_alias(p, real_p)
#define def_2_prop_path(p1, p2) 
#define def_2_prop_path_alias(p1, p2, real_p1, real_p2)
#define def_nested_prop(p1) 
#define def_nested_prop_alias(p1, real_p1)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\ctbmapro.h ===
/*	
 *		ctbmpro.h - protocol for MAX camera tracker bitmaps
 *
 *			Copyright  Autodesk, Inc 1998, John Wainwright
 *
 */
 //CTBitMap
	def_visible_primitive  ( openCTBitMap,		"openCTBitMap" ); 
	def_visible_primitive  ( selectCTBitMap,	"selectCTBitMap" ); 
	use_generic		  	   ( display,			"display" ); 
	use_generic			   ( unDisplay,			"unDisplay" ); 
	use_generic			   ( save,				"save" ); 
	use_generic            ( close,				"close" ); 
	use_generic            ( gotoFrame,			"gotoFrame" ); 
	use_generic            ( getTracker,		"getTracker" ); 
	use_generic            ( deleteTracker,		"deleteTracker" ); 
	def_visible_generic    ( perspectiveMatch,	 "perspectiveMatch" ); 
	def_visible_generic    ( loadFrames,		"loadFrames" ); 

	use_generic			   ( copy,				"copy" ); 
	use_generic            ( zoom,				"zoom" ); 
	def_visible_generic    ( resetZoom,			"resetZoom" ); 
	def_visible_generic    ( setFade,			"setFade" ); 

// CTMotionTracker
	use_generic            ( resample,			"resample");
	use_generic            ( reset,				"reset");
	def_visible_generic    ( setStruct,			"setStruct");
	def_visible_generic    ( showTrack,			"showTrack");
	def_visible_generic    ( invalTrack,		"invalTrack");
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\defextfn.h ===
/*	
 *		def_extern_functions.h - macros for reference extern declarations
 *									for MAXScript functions
 *
 *	This will typically be used along with protocol definition files in 
 *  the code wants to reference MAXScript core function objects.
 *
 *  see def_abstract_functions.h for more info.
 *
 *	
 *	Copyright  John Wainwright 1996
 *
 */

/* def_generic macro for extern declarations */

#ifdef def_generic
#	undef def_generic
#	undef def_node_generic
#	undef def_mapped_generic
#	undef def_visible_generic
#	undef def_struct_generic
#	undef use_generic
#	undef def_primitive
#	undef def_mapped_primitive
#	undef def_lazy_primitive
#	undef def_visible_lazy_primitive
#	undef def_visible_primitive
#	undef def_struct_primitive
#	undef def_property
#	undef def_property_alias
#	undef def_2_prop_path
#	undef def_2_prop_path_alias
#	undef def_nested_prop
#	undef def_nested_prop_alias
#endif

#define def_generic(fn, name)	\
	extern Generic fn##_gf
#define def_visible_generic(fn, name) def_generic(fn, name)
#define def_struct_generic(fn, name) def_generic(fn, name)
#define def_node_generic(fn, name) def_generic(fn, name)
#define def_mapped_generic(fn, name) def_generic(fn, name)
#define use_generic(fn, name) def_generic(fn, name)

#define def_primitive(fn, name)	\
	extern Primitive fn##_pf

#define def_lazy_primitive(fn, name) def_primitive(fn, name)
#define def_visible_lazy_primitive(fn, name) def_primitive(fn, name)
#define def_visible_primitive(fn, name) def_primitive(fn, name)
#define def_mapped_primitive(fn, name) def_primitive(fn, name)
#define def_struct_primitive(fn, _struct, name) def_primitive(fn, name)

#undef def_name
#define def_name(name)	extern ScripterExport Value* n_##name;	
	
#undef def_marker
#define def_marker(var, str) extern ScripterExport Name var;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\defabsfn.h ===
/*	
 *		def_abstract_functions.h - macros for making abstract declarations for MAXScript functions
 *
 *	This will typically be used along with protocol definition files in Value.h
 *	to declare all the possible scripter-visible operations on MAXScript values.
 *
 *	MAXScript generics are scripter-visible first-class values that wrap a
 *	reference to a virtual function declared on class Value.  All core generics
 *	are defined this way via a set of defining macros and protocol files for
 *  each suite of operations.  The core generics are all globally declared
 *  Generic instances, with names of the form xxx_gf. Corresponding virtuals
 *  are declared abstractly in class Value and have names of the form xxx_vf.
 *
 *  All thusly declared genrics have the same signature:  
 *			Value* xxx_vf(Value** arglist, int arg_count);
 *	That is, they are polymorphic up to Values and take an argument list array &
 *  actual count which they should check for conformance at runtime.
 *
 *  Value subclasses that implement a particular protocol should use 
 *  def_implement_generics.h macros to declare implementations.  And one
 *  of these classes should use def_instance_generics.h to actually globally
 *  instantiate the generic objects.  The abstract declarations in Value
 *  all contain type error signals, so that any generic invoked on a
 *  Value subclass instance that doesn't implement the generic will
 *  get a runtime type error.
 *
 *  Similarly, scripter-visible primitive functions (non-generic) are 
 *  represented by instances of the Primitive class and declared using
 *  these same def macro headers & corresponding def_primitive macros.
 *	
 *	Copyright  John Wainwright 1996
 *
 */

/* def_generic macro for abstract declaration in Value class */

#ifdef def_generic
#	undef def_generic
#	undef def_node_generic
#	undef def_mapped_generic
#	undef def_visible_generic
#	undef def_struct_generic
#	undef use_generic
#	undef def_primitive
#	undef def_mapped_primitive
#	undef def_lazy_primitive
#	undef def_visible_lazy_primitive
#	undef def_visible_primitive
#	undef def_struct_primitive
#	undef def_property
#	undef def_property_alias
#	undef def_2_prop_path
#	undef def_2_prop_path_alias
#	undef def_nested_prop
#	undef def_nested_prop_alias
#endif
#ifdef def_prop_getter
#	undef def_prop_getter
#	undef def_prop_setter
#endif

#define def_generic(fn, name)	\
	virtual Value* fn##_vf(Value** arglist, int arg_count) { ABSTRACT_FUNCTION(_T(#name), this, Value*); }
#define def_visible_generic(fn, name) def_generic(fn, name)
#define def_struct_generic(fn, name) def_generic(fn, name)
#define def_node_generic(fn, name) def_generic(fn, name)
#define def_mapped_generic(fn, name) def_generic(fn, name)
#define use_generic(fn, name)

#define def_primitive(fn, name)		// no member function declarations for primitives
#define def_visible_primitive(fn, name)
#define def_mapped_primitive(fn, name)
#define def_lazy_primitive(fn, name)
#define def_visible_lazy_primitive(fn, name)
#define def_struct_primitive(fn, _struct, name)
#define def_property(p)																						\
			virtual Value*	get_##p(Value** arg_list, int count) { return get_property(arg_list, count); }	\
			virtual Value*	set_##p(Value** arg_list, int count) { return set_property(arg_list, count); }	
#define def_property_alias(p, real_p)
#define def_2_prop_path(p1, p2)												\
			virtual Value*	get_##p1##_##p2(Value** arg_list, int count)	\
			{																\
				two_value_locals(cont, result);								\
				vl.cont = get_##p1(&n_##p1, 1);								\
				vl.result = vl.cont->get_##p2(&n_##p2, 1);					\
				return_value(vl.result);									\
			}																\
			virtual Value*	set_##p1##_##p2(Value** arg_list, int count)	\
			{																\
				one_value_local(cont);										\
				Value* args[2] = { arg_list[0], n_##p2 };					\
				vl.cont = get_##p1(&n_##p1, 1);								\
				vl.cont->set_##p2(args, 2);									\
				args[0] = vl.cont; args[1] = n_##p1;						\
				set_##p1(args, 2);											\
				pop_value_locals();											\
				return arg_list[0];											\
			}
#define def_2_prop_path_alias(p1, p2, real_p1, real_p2)
#define def_nested_prop(p1)													\
			virtual Value*	get_nested_##p1(Value** arg_list, int count)	\
			{																\
				two_value_locals(cont, result);								\
				vl.cont = _get_property(arg_list[0]);						\
				vl.result = vl.cont->get_##p1(&n_##p1, 1);					\
				return_value(vl.result);									\
			}																\
			virtual Value*	set_nested_##p1(Value** arg_list, int count)	\
			{																\
				one_value_local(cont);										\
				Value* args[2] = { arg_list[0], n_##p1 };					\
				vl.cont = _get_property(arg_list[1]);						\
				vl.cont->set_##p1(args, 2);									\
				_set_property(arg_list[1], vl.cont);						\
				pop_value_locals();											\
				return arg_list[0];											\
			}

#define def_nested_prop_alias(p1, real_p1)									

/* abstract function 'bodies'... if these are called, we have a 'type doesnt implement' error  */

#define ABSTRACT_FUNCTION(m, v, t) throw NoMethodError (m, v); return (t)0		  
#define ABSTRACT_CONVERTER(t, l) throw ConversionError (this, _T(#l)); return (t)0
#define ABSTRACT_WIDENER(a) throw IncompatibleTypes (this, a); return (Value*)&undefined
#define ABSTRACT_GETTER() throw AccessorError (this, arg_list[0]); return (Value*)&undefined
#define ABSTRACT_SETTER() throw AccessorError (this, arg_list[1]); return (Value*)&undefined
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\evalprms.h ===
/*	
 *		eval_prims.h - evaluator primitive function defs for MAXScript
 *
 *			Copyright  John Wainwright 1996
 *
 */


	def_primitive(progn, "progn")
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\definsfn.h ===
/*	
 *		def_instantiate_functions.h - macros for making instantiating declarations
 *									for MAXScript functions
 *
 *	This will typically be used along with protocol definition files in 
 *  distinguished Value subclasses that will host the static instantiation
 *  of MAXScript function objects.
 *
 *  see def_abstract_functions.h for more info.
 *
 *	
 *	Copyright  John Wainwright 1996
 *
 */
/* def_generic macro for instantiation declarations */

#include "Funcs.h"

#ifdef def_generic
#	undef def_generic
#	undef def_node_generic
#	undef def_mapped_generic
#	undef def_visible_generic
#	undef def_struct_generic
#	undef use_generic
#	undef def_primitive
#	undef def_mapped_primitive
#	undef def_lazy_primitive
#	undef def_visible_lazy_primitive
#	undef def_visible_primitive
#	undef def_struct_primitive
#	undef def_property
#	undef def_property_alias
#	undef def_2_prop_path
#	undef def_2_prop_path_alias
#	undef def_nested_prop
#	undef def_nested_prop_alias
#endif
#ifdef def_prop_getter
#	undef def_prop_getter
#	undef def_prop_setter
#endif

#pragma pointers_to_members(full_generality, virtual_inheritance)

#define def_generic(fn, name)											\
	Generic fn##_gf (&_T("%"#name), &Value::fn##_vf)
#define def_visible_generic(fn, name)									\
	Generic fn##_gf (_T(name), &Value::fn##_vf)
#define def_struct_generic(fn, _struct, name)							\
	Generic fn##_gf (_T(name), &Value::fn##_vf, _T(#_struct))
#define def_node_generic(fn, name)										\
	NodeGeneric fn##_gf (_T(name), &Value::fn##_vf)
#define def_mapped_generic(fn, name)									\
	MappedGeneric fn##_gf (_T(name), &Value::fn##_vf)
#define use_generic(fn, name)

#define def_primitive(fn, name)											\
	Value* fn##_cf(Value**,int);										\
	Primitive fn##_pf (&_T("%"#name), fn##_cf)  /* scripter-hidden name */
#define def_visible_primitive(fn, name)									\
	Value* fn##_cf(Value**,int);										\
	Primitive fn##_pf (_T(name), fn##_cf)
#define def_struct_primitive(fn, _struct, name)							\
	Value* fn##_cf(Value**,int);										\
	Primitive fn##_pf (_T(name), _T(#_struct), fn##_cf)
#define def_mapped_primitive(fn, name)									\
	Value* fn##_cf(Value**,int);										\
	MappedPrimitive fn##_pf (_T("%"#name), fn##_cf)
#define def_lazy_primitive(fn, name)									\
	Value* fn##_cf(Value**,int);										\
	Primitive fn##_pf (&_T("%"#name), fn##_cf, LAZY_PRIMITIVE)
#define def_visible_lazy_primitive(fn, name)							\
	Value* fn##_cf(Value**,int);										\
	Primitive fn##_pf (_T(name), fn##_cf, LAZY_PRIMITIVE)

#define def_property(p)													\
	_T(#p), &Value::get_##p, &Value::set_##p,
#define def_property_alias(p, real_p)									\
	_T(#p), &Value::get_##real_p, &Value::set_##real_p,
#define def_2_prop_path(p1, p2)											\
	_T(#p1"."#p2), &Value::get_##p1##_##p2, &Value::set_##p1##_##p2,
#define def_2_prop_path_alias(p1, p2, real_p1, real_p2)					\
	_T(#p1"."#p2), &Value::get_##real_p1##_##real_p2, &Value::set_##real_p1##_##real_p2,
#define def_nested_prop(p1)												\
	_T("*."#p1), &Value::get_nested_##p1, &Value::set_nested_##p1,
#define def_nested_prop_alias(p1, real_p1)								\
	_T("*."#p1), &Value::get_nested_##real_p1, &Value::set_nested_##real_p1,

#undef def_name
#define def_name(name)	ScripterExport Value* n_##name;	
	
#undef def_marker
#define def_marker(var, str) ScripterExport Name var (_T(str));
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\evalpro.h ===
/*	
 *		math_protocol.h - def_generics for the generic function in the Math protocol
 *
 *		see def_abstract_generics.h for more info.
 *
 *	
 *			Copyright  John Wainwright 1996
 *
 */

	def_generic(plus,	"+");
	def_generic(minus,	"-");
	def_generic(times,	"*");
	def_generic(div,	"/");
	def_generic(uminus,	"u-");

	use_generic(eq,		"=");
	def_generic(ne,		"!=");
	def_generic(gt,		">");
	def_generic(lt,		"<");
	def_generic(ge,		">=");
	def_generic(le,		"<=");
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\defimpfn.h ===
/*	
 *		def_implement_functions.h - macros for making implementation declarations
 *									for MAXscript functions
 *
 *	This will typically be used along with protocol definition files in 
 *  the Value subclasses that actually implement those protocols.
 *
 *  see def_abstract_functionss.h for more info.
 *
 *	
 *	Copyright  John Wainwright 1996
 *
 */

/* def_generic macro for implementation declaration in Value subclasses */

#ifdef def_generic
#	undef def_generic
#	undef def_node_generic
#	undef def_mapped_generic
#	undef def_visible_generic
#	undef def_struct_generic
#	undef use_generic
#	undef def_primitive
#	undef def_mapped_primitive
#	undef def_lazy_primitive
#	undef def_visible_lazy_primitive
#	undef def_visible_primitive
#	undef def_struct_primitive
#	undef def_property
#	undef def_property_alias
#	undef def_2_prop_path
#	undef def_2_prop_path_alias
#	undef def_nested_prop
#	undef def_nested_prop_alias
#endif
#ifdef def_prop_getter
#	undef def_prop_getter
#	undef def_prop_setter
#endif

#define def_generic(fn, name)	\
	Value* fn##_vf(Value** arglist, int arg_count)
#define def_visible_generic(fn, name) def_generic(fn, name)
#define def_struct_generic(fn, name) def_generic(fn, name)
#define def_node_generic(fn, name) def_generic(fn, name)
#define def_mapped_generic(fn, name) def_generic(fn, name)
#define use_generic(fn, name) def_generic(fn, name)

#define def_primitive(fn, name)		// nothing for implementation...
#define def_lazy_primitive(fn, name) def_primitive(fn, name)
#define def_visible_lazy_primitive(fn, name) def_primitive(fn, name)
#define def_visible_primitive(fn, name) def_primitive(fn, name)
#define def_mapped_primitive(fn, name) def_primitive(fn, name)
#define def_struct_primitive(fn, _struct, name) def_primitive(fn, name)

#define def_property(p)										\
			Value*	get_##p(Value** arg_list, int count);	\
			Value*	set_##p(Value** arg_list, int count)
#define def_prop_getter(p)									\
			Value*	get_##p(Value** arg_list, int count)
#define def_prop_setter(p)									\
			Value*	set_##p(Value** arg_list, int count)
#define def_property_alias(p, real_p)
#define def_2_prop_path(p1, p2)										\
			Value*	get_##p1##_##p2(Value** arg_list, int count);	\
			Value*	set_##p1##_##p2(Value** arg_list, int count)
#define def_2_prop_path_alias(p1, p2, real_p1, real_p2)
#define def_nested_prop(p1)											\
			Value*	get_nested_##p1(Value** arg_list, int count);	\
			Value*	set_nested_##p1(Value** arg_list, int count)

#define def_backpatched_setter(_prop, _superclass)					\
			Value*													\
			set_##_prop(Value** arg_list, int count)				\
			{														\
				_superclass::set_##_prop(arg_list, count);			\
				back_patch();										\
				return arg_list[0];									\
			};

#define def_local_prop_alias(p, real_p)																\
			Value*	get_##p(Value** arg_list, int count) { return get_##real_p(arg_list, count); }   \
			Value*	set_##p(Value** arg_list, int count) { return set_##real_p(arg_list, count); }   \

#ifdef def_time_fn
#	undef def_time_fn
#endif
#define def_time_fn(_fn)	\
	Value* _fn##_vf(Value** arglist, int arg_count)

#undef def_name
#define def_name(name)	n_##name = Name::intern(_T(#name));		

#undef def_marker
#define def_marker(var, str)

/* ---------------------------- utility macros ---------------------*/

#define _def_num_bin_op(_class, _conv, _op_fn, _op, _member)	\
	Value*														\
	_class::_op_fn##_vf(Value** arg_list, int count)			\
	{															\
		one_value_local(widened);								\
		Value *arg, *result;									\
		arg = arg_list[0];										\
		if (tag != arg->tag && (vl.widened = widen_to(arg, arg_list)))	\
			result = vl.widened->_op_fn##_vf(arg_list, 1);		\
		else													\
			result = _class::intern(_member _op (arg_list[0])->_conv()); \
		pop_value_locals();										\
		return result;											\
	}

#define _def_bin_op(_class, _conv, _op_fn, _op, _member)		\
	Value*														\
	_class::_op_fn##_vf(Value** arg_list, int count)			\
	{															\
		one_value_local(widened);								\
		Value *arg, *result;									\
		arg = arg_list[0];										\
		if (tag != arg->tag && (vl.widened = widen_to(arg, arg_list)))	\
			result = vl.widened->_op_fn##_vf(arg_list, 1);		\
		else													\
			result = new _class (_member _op (arg_list[0])->_conv()); \
		pop_value_locals();										\
		return result;											\
	}

#define _def_rel_op(_class, _conv, _op_fn, _rel_op, _member)	\
	Value*														\
	_class::_op_fn##_vf(Value** arg_list, int count)			\
	{															\
		Value *cmpnd = arg_list[0], *result;					\
		if (comparable(cmpnd))									\
			result = (_member _rel_op cmpnd->_conv()) ?			\
						&true_value : &false_value;				\
		else													\
			throw IncompatibleTypes(this, cmpnd);				\
		return result;											\
	}

#define def_eq_op(_class, _conv, _member)						\
	Value*														\
	_class::eq_vf(Value** arg_list, int count)					\
	{															\
		Value *cmpnd = arg_list[0], *result;					\
		if (comparable(cmpnd))									\
			result = (_member == cmpnd->_conv()) ?				\
						&true_value : &false_value;				\
		else													\
			result = &false_value;								\
		return result;											\
	}
#define def_ne_op(_class, _conv, _member)						\
	Value*														\
	_class::ne_vf(Value** arg_list, int count)					\
	{															\
		Value *cmpnd = arg_list[0], *result;					\
		if (comparable(cmpnd))									\
			result = (_member == cmpnd->_conv()) ?				\
						&false_value : &true_value;				\
		else													\
			result = &true_value;								\
		return result;											\
	}


#define _def_num_un_op(_class, _op_fn, _op, _member)			\
	Value*														\
	_class::_op_fn##_vf(Value** arg_list, int count)			\
	{															\
		return _class::intern(_op _member);						\
	}

#define _def_un_op(_class, _op_fn, _op, _member)				\
	Value*														\
	_class::_op_fn##_vf(Value** arg_list, int count)			\
	{															\
		return new _class (_op _member);						\
	}

#define def_bin_op(_class, _conv, _op_fn, _op)					\
			_def_num_bin_op(_class, _conv, _op_fn, _op, value)
#define def_rel_op(_class, _conv, _op_fn, _rel_op)				\
			_def_rel_op(_class, _conv, _op_fn, _rel_op, value)
#define def_un_op(_class, _op_fn, _op)							\
			_def_num_un_op(_class, _op_fn, _op, value)

#define def_math_fn(_fn)										\
	Value*														\
	_fn##_cf(Value** arg_list, int count)						\
	{															\
		check_arg_count(_fn, 1, count);							\
		return Float::intern((float)_fn(arg_list[0]->to_float()));	\
	}

#define def_angle_trig_fn(_fn)									\
	Value*														\
	_fn##_cf(Value** arg_list, int count)						\
	{															\
		check_arg_count(_fn, 1, count);							\
		return Float::intern(RadToDeg((float)_fn(arg_list[0]->to_float()))); \
	}

#define def_float_trig_fn(_fn)									\
	Value*														\
	_fn##_cf(Value** arg_list, int count)						\
	{															\
		check_arg_count(_fn, 1, count);							\
		return Float::intern((float)_fn(DegToRad(arg_list[0]->to_float()))); \
	}

#define def_math_bin_fn(_fn)									\
	Value*														\
	_fn##_cf(Value** arg_list, int count)						\
	{															\
		check_arg_count(_fn, 2, count);							\
		return Float::intern((float)_fn(arg_list[0]->to_float(), \
							  arg_list[1]->to_float()));		\
	}

#define def_angle_trig_bin_fn(_fn)								\
	Value*														\
	_fn##_cf(Value** arg_list, int count)						\
	{															\
		check_arg_count(_fn, 2, count);							\
		return Float::intern(RadToDeg((float)_fn(arg_list[0]->to_float(), \
							  arg_list[1]->to_float())));		\
	}

#define def_num_prop_accessors(_class, _prop, _member, _type, _conv ) \
	Value*															\
	_class::get_##_prop(Value** arg_list, int count)				\
	{																\
		return _type::intern(_member);								\
	}																\
	Value*															\
	_class::set_##_prop(Value** arg_list, int count)				\
	{																\
		Value*  val = arg_list[0];									\
		_member = val->_conv();										\
		return val;													\
	}

#define def_prop_accessors(_class, _prop, _member, _type, _conv ) \
	Value*															\
	_class::get_##_prop(Value** arg_list, int count)				\
	{																\
		return new _type (_member);									\
	}																\
	Value*															\
	_class::set_##_prop(Value** arg_list, int count)				\
	{																\
		Value*  val = arg_list[0];									\
		_member = val->_conv();										\
		return val;													\
	}

#define def_fn_prop_accessors(_class, _prop, _getter, _setter)		\
	Value*															\
	_class::get_##_prop(Value** arg_list, int count)				\
	{																\
		return _getter;												\
	}																\
	Value*															\
	_class::set_##_prop(Value** arg_list, int count)				\
	{																\
		Value*  val = arg_list[0];									\
		_setter;													\
		return val;													\
	}

#define def_fn_prop_getter(_class, _prop, _getter)					\
	Value*															\
	_class::get_##_prop(Value** arg_list, int count)				\
	{																\
		return _getter;												\
	}																

#define def_fn_prop_setter(_class, _prop, _setter)					\
	Value*															\
	_class::set_##_prop(Value** arg_list, int count)				\
	{																\
		Value*  val = arg_list[0];									\
		_setter;													\
		return val;													\
	}

#define def_float_prop_accessors(_class, _prop, _member)				\
			def_num_prop_accessors(_class, _prop, _member, Float, to_float)

#define def_int_prop_accessors(_class, _prop, _member)					\
			def_num_prop_accessors(_class, _prop, _member, Integer, to_int)

#define def_point3_prop_accessors(_class, _prop, _member)				\
			def_fn_prop_accessors(_class, _prop, new Point3Value (_member), _member = val->to_point3())

#define def_angle_prop_accessors(_class, _prop, _member)				\
			def_fn_prop_accessors(_class, _prop, Float::intern(RadToDeg(_member)), _member = DegToRad(val->to_float()))

#define def_time_bin_op(_op_fn, _op)							\
			_def_bin_op(MSTime, to_timevalue, _op_fn, _op, time)
#define def_time_rel_op(_op_fn, _rel_op)						\
			_def_rel_op(MSTime, to_timevalue, _op_fn, _rel_op, time)
#define def_time_un_op(_op_fn, _op)								\
			_def_un_op(MSTime, _op_fn, _op, time)

#define def_quat_bin_op(_class, _conv, _op_fn, _op)				\
			_def_bin_op(_class, _conv, _op_fn, _op, q)
#define def_quat_rel_op(_class, _conv, _op_fn, _rel_op)			\
			_def_rel_op(_class, _conv, _op_fn, _rel_op, q)
#define def_quat_un_op(_class, _op_fn, _op)						\
			_def_un_op(_class, _op_fn, _op, q)
				
#define def_new_quat_fn(_fn, _arg_count, _call)				\
	Value*													\
	QuatValue::_fn##_vf(Value** arg_list, int count)		\
	{														\
		check_arg_count(_fn, _arg_count, count + 1);		\
		return new QuatValue (_call);						\
	}

#define def_mut_quat_fn(_fn, _arg_count, _call)				\
	Value*													\
	QuatValue::_fn##_vf(Value** arg_list, int count)		\
	{														\
		check_arg_count(_fn, _arg_count, count + 1);		\
		_call;												\
		return this;										\
	}

#define def_new_mat_fn(_fn, _arg_count, _call)				\
	Value*													\
	Matrix3Value::_fn##_vf(Value** arg_list, int count)		\
	{														\
		check_arg_count(_fn, _arg_count, count + 1);		\
		return new Matrix3Value (_call);						\
	}

#define def_mut_mat_fn(_fn, _arg_count, _call)				\
	Value*													\
	Matrix3Value::_fn##_vf(Value** arg_list, int count)		\
	{														\
		check_arg_count(_fn, _arg_count, count + 1);		\
		_call;												\
		return this;										\
	}

#define def_mat_primitive(_fn, _arg_count, _call)			\
	Value*													\
	_fn##_cf(Value** arg_list, int count)					\
	{														\
		check_arg_count(_fn, _arg_count, count);			\
		return new Matrix3Value (_call);					\
	}

#define def_mat_bin_op(_class, _conv, _op_fn, _op)			\
			_def_bin_op(_class, _conv, _op_fn, _op, m)
#define def_mat_rel_op(_class, _conv, _op_fn, _rel_op)		\
			_def_rel_op(_class, _conv, _op_fn, _rel_op, m)
#define def_mat_un_op(_class, _op_fn, _op)					\
			_def_un_op(_class, _op_fn, _op, m)
				
#define def_bool_node_fns(name, getter, setter)													\
	Value* node_get_##name(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid)		\
	{																							\
		return ((INode*)obj)->getter() ? &true_value : &false_value;							\
	}																							\
	void node_set_##name(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val)			\
	{																							\
		((INode*)obj)->setter(val->to_bool());													\
		MAXScript_interface->NodeInvalidateRect((INode*)obj);									\
		needs_redraw_set();																		\
	}

#define def_bool_node_getter(name, getter)														\
	Value* node_get_##name(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid)		\
	{																							\
		return ((INode*)obj)->getter() ? &true_value : &false_value;							\
	}																							\
	void node_set_##name(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val)			\
	{																							\
		throw RuntimeError (_T("Property not settable: "), #name);									\
	}
																							
#define def_ulong_node_fns(name, getter, setter)												\
	Value* node_get_##name(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid)		\
	{																							\
		return Integer::intern((int)((INode*)obj)->getter());									\
	}																							\
	void node_set_##name(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val)			\
	{																							\
		((INode*)obj)->setter((ULONG)val->to_int());											\
		MAXScript_interface->NodeInvalidateRect((INode*)obj);									\
		needs_redraw_set();																		\
	}

#define def_color_node_fns(name, getter, setter)												\
	Value* node_get_##name(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid)		\
	{																							\
		DWORD rgb = ((INode*)obj)->getter();													\
		return ColorValue::intern(GetRValue(rgb) / 255.0f, GetGValue(rgb) / 255.0f, GetBValue(rgb) / 255.0f);	\
	}																							\
	void node_set_##name(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val)			\
	{																							\
		AColor c;																				\
		c = val->to_acolor();																	\
		((INode*)obj)->setter(RGB((BYTE)(c.r * 255), (BYTE)(c.g * 255), (BYTE)(c.b * 255)));	\
		MAXScript_interface->NodeInvalidateRect((INode*)obj);									\
		needs_redraw_set();																		\
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\kernlpro.h ===
/*	
 *		kernel_protocol.h - def_generics for the MAXScript kernel protocol
 *
 *		see def_abstract_generics.h for more info.
 *
 *	
 *			Copyright  John Wainwright 1996
 *
 */

	def_mapped_generic( print,			"print");

	def_generic        ( eq,			"==");
	def_generic        ( ne,			"!=");

	def_generic        ( coerce,		"coerce");

	def_visible_generic( classOf,		"classOf");
	def_visible_generic( superClassOf,	"superClassOf");
	def_visible_generic( isKindOf,		"isKindOf");
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\Lclclass.h ===
/*		LclClass.h - macros for defining local classes and generics in a MAXScript extension .dlx
 *
 *	
 *		Copyright (c) Autodesk, Inc.  1988.  John Wainwright.
 *
 */

#ifndef _H_LOCALCLASS
#define _H_LOCALCLASS

#include "ClassCfg.h"

#define local_visible_class(_cls)										\
	class _cls##Class : public ValueMetaClass							\
	{																	\
	public:																\
				_cls##Class(TCHAR* name) : ValueMetaClass (name) { }	\
		void	collect() { delete this; }								\
	};																	\
	extern _cls##Class _cls##_class;

#define local_applyable_class(_cls)										\
	class _cls##Class : public ValueMetaClass							\
	{																	\
	public:																\
				_cls##Class(TCHAR* name) : ValueMetaClass (name) { }	\
		void	collect() { delete this; }								\
		Value* apply(Value** arglist, int count);						\
	};																	\
	extern _cls##Class _cls##_class;

#define local_visible_class_instance(_cls, _name)						\
	_cls##Class _cls##_class (_T(_name));

class MS_LOCAL_ROOT_CLASS;
typedef Value* (MS_LOCAL_ROOT_CLASS::*local_value_vf)(Value**, int);
#define cat0(_a) _a
#define cat1(_a) cat0(_a)
#define cat2(_a, _b) cat0(_a)##cat0(_b)
#define MS_LOCAL_ROOT_CLASS_TAG &cat2(MS_LOCAL_ROOT_CLASS, _class)
#define MS_LOCAL_GENERIC_CLASS_TAG &cat2(MS_LOCAL_GENERIC_CLASS, _class)
#define MS_LOCAL_GENERIC_CLASS_CLASS cat2(MS_LOCAL_GENERIC_CLASS, Class)
#define MS_LOCAL_GENERIC_CLASS_class cat2(MS_LOCAL_GENERIC_CLASS, _class)
#define str0(_c) #_c
#define str1(_c) str0(_c)

#define declare_local_generic_class										\
	class MS_LOCAL_GENERIC_CLASS_CLASS : public ValueMetaClass			\
	{																	\
	public:																\
				MS_LOCAL_GENERIC_CLASS_CLASS(TCHAR* name) : ValueMetaClass (name) { } \
		void	collect() { delete this; }								\
	};																	\
	extern MS_LOCAL_GENERIC_CLASS_CLASS MS_LOCAL_GENERIC_CLASS_class;	\
	class MS_LOCAL_GENERIC_CLASS : public Generic						\
	{																	\
	public:																\
				local_value_vf	fn_ptr;									\
				MS_LOCAL_GENERIC_CLASS() { }							\
				MS_LOCAL_GENERIC_CLASS(TCHAR* name, local_value_vf fn);	\
				classof_methods (MS_LOCAL_GENERIC_CLASS, Generic);		\
		void	collect() { delete this; }								\
		Value* apply(Value** arglist, int count);						\
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\Excepts.h ===
/*		Exception.h - exception class for MAXScript
 *
 *		Copyright (c) John Wainwright, 1996
 *		
 *
 */

#ifndef _H_EXCEPTION
#define _H_EXCEPTION

class Value;
class Thunk;
class ValueMetaClass;

extern TCHAR* null_string;

class ScripterExport MAXScriptException
{
public:
	virtual void sprin1(CharStream* s);
};

class ScripterExport UnknownSystemException : public MAXScriptException
{
public:
			UnknownSystemException() {}
	void	sprin1(CharStream* s);
};

class ScripterExport SignalException : public MAXScriptException
{
public:
	void	sprin1(CharStream* s);
};

class ScripterExport CompileError : public MAXScriptException
{
	TCHAR*	description;
	TCHAR*	info;
	TCHAR*   line;
public:
			CompileError (TCHAR* d, TCHAR* i, TCHAR* l);
			CompileError () { description = NULL; info = null_string; line = null_string; }
		   ~CompileError ();

	void	sprin1(CharStream* s);
};

class ScripterExport SyntaxError : public CompileError
{
	TCHAR*	wanted;
	TCHAR*	got;
	TCHAR*   line;
public:
			SyntaxError (TCHAR* w, TCHAR* g, TCHAR* l = null_string);
		   ~SyntaxError ();

	void	sprin1(CharStream* s);
};

class ScripterExport TypeError : public MAXScriptException
{
	Value*	target;
	ValueMetaClass* wanted_class;
	TCHAR*	description;
public:
			TypeError (TCHAR* d, Value* t, ValueMetaClass* c = NULL);
		   ~TypeError ();

	void	sprin1(CharStream* s);
};

class ScripterExport NoMethodError : public MAXScriptException
{
	Value*	target;
	TCHAR*	fn_name;
public:
			NoMethodError (TCHAR* fn, Value* t);
		   ~NoMethodError ();

	void	sprin1(CharStream* s);
};

#define unimplemented(m, t) throw NoMethodError (m, t)

class ScripterExport AccessorError : public MAXScriptException
{
	Value*	target;
	Value*	prop;
public:
			AccessorError (Value* t, Value* p) { target = t; prop = p; }

	void	sprin1(CharStream* s);
};

class ScripterExport AssignToConstError : public MAXScriptException
{
	Thunk*	thunk;
public:
			AssignToConstError (Thunk* t) { thunk = t; }

	void	sprin1(CharStream* s);
};

class ScripterExport ArgCountError : public MAXScriptException
{
	int		wanted;
	int		got;
	TCHAR*	fn_name;
public:
			ArgCountError (TCHAR* fn, int w, int g);
		   ~ArgCountError ();

	void	sprin1(CharStream* s);
};

class ScripterExport RuntimeError : public MAXScriptException
{
	TCHAR*	desc1;
	TCHAR*   desc2;
	Value*  info;
public:
			RuntimeError (TCHAR* d1);
			RuntimeError (TCHAR* d1, TCHAR* d2);
			RuntimeError (TCHAR* d1, Value* ii);
			RuntimeError (TCHAR* d1, TCHAR* d2, Value* ii);
			RuntimeError (Value* ii);
		   ~RuntimeError ();

	void	init(TCHAR* d1, TCHAR* d2, Value* ii);
	void	sprin1(CharStream* s);
};

class ScripterExport IncompatibleTypes : public MAXScriptException
{
	Value*	val1;
	Value*  val2;
public:
			IncompatibleTypes (Value* v1, Value* v2) { val1 = v1; val2 = v2; }

	void	sprin1(CharStream* s);
};

class ScripterExport ConversionError : public MAXScriptException
{
	Value*	val;
	TCHAR*   type;
public:
			ConversionError (Value* v, TCHAR* t);
		   ~ConversionError ();

	void	sprin1(CharStream* s);
};

class FunctionReturn : public MAXScriptException
{
public:
	Value*	return_result;
			FunctionReturn (Value* v) { return_result = v; }

	void	sprin1(CharStream* s);
};

class LoopExit : public MAXScriptException
{
public:
	Value*	loop_result;
			LoopExit (Value* v) { loop_result = v; }

	void	sprin1(CharStream* s);
};

class LoopContinue : public MAXScriptException
{
public:
			LoopContinue () { }

	void	sprin1(CharStream* s);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\Lclextfn.h ===
/*	
 *	lclextfn.h - abstract generic function definitions for MAXScript SDK plug-ins
 */

#include "ClassCfg.h"

#ifdef def_local_generic
#	undef def_local_generic
#	undef use_local_generic
#endif
#ifdef use_generic
#	undef use_generic
#endif


#define def_local_generic(fn, name)	\
	extern MS_LOCAL_GENERIC_CLASS fn##_gf
#define use_local_generic(fn, name) \
	def_local_generic(fn, name)
#define use_generic(fn, name) \
	extern Generic fn##_gf

#undef def_name
#define def_name(name)	extern Value* n_##name;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\Funcs.h ===
/*		Functions.h - the Function family class - primitives, generics
 *
 *		Copyright (c) John Wainwright, 1996
 *		
 */

#ifndef _H_FUNCTION
#define _H_FUNCTION

/* --- function base class -- */

visible_class (Function)

class Function : public Value
{
public:
	TCHAR*		name;
	TCHAR*		struct_name;	// packaged in a struct if non-null

				   Function() { name = NULL; struct_name = NULL; }
	ScripterExport Function(TCHAR* name, TCHAR* struct_name=NULL);
	ScripterExport ~Function();

				classof_methods (Function, Value);
#	define		is_function(o) ((o)->_is_function())
	BOOL		_is_function() { return 1; }

	ScripterExport void sprin1(CharStream* s);
	ScripterExport void export_to_scripter();
};
 
/* ----------------------- Generics ------------------------- */

visible_class (Generic)

class Generic : public Function
{
public:
	value_vf	fn_ptr;

				Generic() { }
 ScripterExport Generic(TCHAR* name, value_vf fn, TCHAR* struct_name = NULL);
			    Generic(TCHAR* name) : Function(name) { }

				classof_methods (Generic, Function);
	BOOL		_is_function() { return 1; }
	ScripterExport void init(TCHAR* name, value_vf fn);
	void		collect() { delete this; }

	ScripterExport Value* apply(Value** arglist, int count);
};

visible_class (MappedGeneric)

class MappedGeneric : public Generic
{
public:
				MappedGeneric() { }
 ScripterExport MappedGeneric(TCHAR* name, value_vf fn);
			    MappedGeneric(TCHAR* name) : Generic(name) { }

				classof_methods (MappedGeneric, Generic);
	BOOL		_is_function() { return 1; }
	void		collect() { delete this; }

	ScripterExport Value* apply(Value** arglist, int count);
};

visible_class (NodeGeneric)

class NodeGeneric : public MappedGeneric
{
public:
 ScripterExport NodeGeneric(TCHAR* name, value_vf fn);
			    NodeGeneric(TCHAR* name) : MappedGeneric(name) { }

				classof_methods (NodeGeneric, MappedGeneric);
	BOOL		_is_function() { return 1; }
	void		collect() { delete this; }

	ScripterExport Value* apply(Value** arglist, int count);
};

/* -------------------------- Primitives ------------------------------ */

#define LAZY_PRIMITIVE	0x0001

visible_class (Primitive)

class Primitive : public Function
{ 
public:
	short		flags;
	value_cf	fn_ptr;

			    Primitive() { }
 ScripterExport Primitive(TCHAR* name, value_cf fn, short init_flags=0);
 ScripterExport Primitive(TCHAR* name, TCHAR* struct, value_cf fn, short init_flags=0);
			    Primitive(TCHAR* name) : Function(name) { }

				classof_methods (Primitive, Function);
	BOOL		_is_function() { return 1; }
	void		collect() { delete this; }

	ScripterExport Value* apply(Value** arglist, int count);
};

visible_class (MappedPrimitive)

class MappedPrimitive : public Primitive
{ 
public:
 ScripterExport MappedPrimitive(TCHAR* name, value_cf fn);

				classof_methods (MappedPrimitive, Primitive);
	BOOL		_is_function() { return 1; }
	void		collect() { delete this; }

	ScripterExport Value* apply(Value** arglist, int count);
};

/* ----- */

visible_class (MAXScriptFunction)

class MAXScriptFunction : public Function
{
public:
	short		parameter_count;
	short		local_count;
	short		keyparm_count;
	short		flags;
	Value**		keyparms;
	Value*		body;
	HashTable*	local_scope;
	value_cf	c_callable_fn;

 ScripterExport MAXScriptFunction(TCHAR* name, int parm_count, int keyparm_count, Value** keyparms,
								  int local_count, Value* body, HashTable* local_scope, short flags = 0);
				~MAXScriptFunction();

				classof_methods (MAXScriptFunction, Function);
	BOOL		_is_function() { return TRUE; }
	void		collect() { delete this; }
	void		gc_trace();
	void		sprin1(CharStream* s);

	Value*		apply(Value** arglist, int count);

	value_cf	get_c_callable_fn();
};

#define FN_MAPPED_FN	0x0001		// declared a collection-mapped function
#define FN_BODY_FN		0x0002		// a loop or other body function, don't trap exits here


// UserProp & UserGeneric instances represent dynamically-added, user-defined generics
//  on built-in classes.  They are kept in sorted tables in ValueMetaClass instances,
// suitable for bsearching.
class UserProp
{
public:
	Value*		prop;
	value_cf	getter;
	value_cf	setter;
				UserProp (Value* p, value_cf g, value_cf s) { prop = p; getter = g; setter = s; }
};

class UserGeneric
{
public:
	Value*		name;
	value_cf	fn;
				
				UserGeneric(Value* n, value_cf f) { name = n; fn = f; }
};

// UserGenericValue is the scripter-visible generic fn value that dispatches the
// UserGeneric 'methods' in a target object's class

visible_class (UserGenericValue)

class UserGenericValue : public Function
{
public:
	Value*		fn_name;
	Value*		old_fn;   // if non-NULL, the original global fn that this usergeneric replaced
				
 ScripterExport UserGenericValue(Value* name, Value* old_fn);

				classof_methods (UserGenericValue, Function);
	BOOL		_is_function() { return TRUE; }
	void		collect() { delete this; }
	void		gc_trace();

	Value*		apply(Value** arglist, int count);
};

#define	def_user_prop(_prop, _cls, _getter, _setter)		\
	_cls##_class.add_user_prop(#_prop, _getter, _setter)

#define	def_user_generic(_fn, _cls, _name)					\
	_cls##_class.add_user_generic(#_name, _fn)





#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\HashTab.h ===
/*	
 *		HashTable.h - HashTable class for MAXScript
 *
 *			Copyright  John Wainwright 1996
 *
 */

#ifndef _H_HASHTABLE
#define _H_HASHTABLE

typedef struct 
{
	void*	key;
	void*	value;
} binding;

typedef struct						/* secondary extent struct			*/
{
	size_t		size;				/* size of secondary extent			*/
	binding*	bindings;			/* table of bindings				*/
} secondary;
	
#define KEY_IS_OBJECT	0x0001		/* init flags that indicate whether keys & values are full MXS collectable objects */
#define VALUE_IS_OBJECT	0x0002

int	default_eq_fn(void* key1, void* key2);  /* default comparator & hash fns */
int default_hash_fn(void* key);

class HashTabMapper;

visible_class (HashTable)

class HashTable : public Value
{
	secondary	**table;			/* primary extent: tbl of second's	*/
	size_t		size;				/* table size						*/
	int			n_entries;			/* no. entries in primary extent	*/
	int			(*eq_fn)(void*, void*); /* key equivalence function		*/
	int			(*hash_fn)(void*);	/* key hgashing function			*/
	int			cursor;				/* cursors used for sequencing...	*/
	int			secondCursor;			
	short		flags;
	HashTable*	inner;				/* links to next & prev tables when */
	HashTable*	outer;				/* used as a lexical scope table	*/


	static CRITICAL_SECTION hash_update;	// for syncing allocation hashtable updates

public:
	ScripterExport HashTable(size_t primary_size, int (*key_eq_fn)(void*, void*), int (*key_hash_fn)(void*), int flags);
				HashTable() { init(17, default_eq_fn, default_hash_fn, KEY_IS_OBJECT + VALUE_IS_OBJECT); }
				HashTable(size_t primary_size) { init(primary_size, default_eq_fn, default_hash_fn, KEY_IS_OBJECT + VALUE_IS_OBJECT); }
				~HashTable();
	void		init(size_t primary_size, int (*key_eq_fn)(void*, void*), int (*key_hash_fn)(void*), int flags);

	static void	setup();

				classof_methods (HashTable, Value);
	void		collect() { delete this;}
	void		gc_trace();

	ScripterExport Value*	get(void* key);
	ScripterExport Value*	put(void* key, void* val);
	ScripterExport Value*	put_new(void* key, void* val);
	ScripterExport Value*	find_key(void *val);
	ScripterExport Value*	set(void* key, void* val);
	ScripterExport void		remove(void* key);
	ScripterExport void		map_keys_and_vals(void (*fn)(void* key, void* val, void* arg), void* arg);
	ScripterExport void		map_keys_and_vals(HashTabMapper* mapper);

	HashTable*	enter_scope();
	HashTable*	leave_scope();
	HashTable*	next_scope();
};

class HashTabMapper 
{
public:
	virtual void map(void* key, void* val)=0;
};

#define SECONDARY_BUCKET	5

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\Lclabsfn.h ===
/*	
 *	lclabsfn.h - abstract generic function definitions for MAXScript SDK plug-ins
 */

#include "ClassCfg.h"

#ifdef def_local_generic
#	undef def_local_generic
#	undef use_local_generic
#endif
#ifdef use_generic
#	undef use_generic
#endif

#define def_local_generic(fn, name)	\
	virtual Value* fn##_vf(Value** arglist, int arg_count) { ABSTRACT_FUNCTION(_T(#name), this, Value*); }
#define use_generic(fn, name)
#define use_local_generic(fn, name)

/* abstract function 'bodies'... if these are called, we have a 'type doesnt implement' error  */

#ifndef ABSTRACT_FUNCTION
#	define ABSTRACT_FUNCTION(m, v, t) throw NoMethodError (m, v); return (t)0		  
#	define ABSTRACT_CONVERTER(t, l) throw ConversionError (this, _T(#l)); return (t)0
#	define ABSTRACT_WIDENER(a) throw IncompatibleTypes (this, a); return (Value*)&undefined
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\Lclimpfn.h ===
/*	
 *	lclimpfn.h -  generic function implementation macros for MAXScript SDK plug-ins
 */

#include "ClassCfg.h"

#ifdef def_local_generic
#	undef def_local_generic
#	undef use_local_generic
#endif
#ifdef use_generic
#	undef use_generic
#endif


#define def_local_generic(fn, name)	\
	Value* fn##_vf(Value** arglist, int arg_count)
#define use_local_generic(fn, name)	\
	def_local_generic(fn, name)
#define use_generic(fn, name)		\
	Value* fn##_vf(Value** arglist, int arg_count)

#undef def_name
#define def_name(name)	n_##name = Name::intern(_T(#name));
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\matpro.h ===
/*	
 *		matrix_protocol.h - def_generics for matrix protocol
 *
 *	
 *			Copyright  John Wainwright 1996
 *
 */

	use_generic(coerce,			"coerce");

	use_generic( plus,			"+" );
	use_generic( minus,			"-" );
	use_generic( times,			"*" );

	use_generic( isIdentity,	"isIdentity" );
	use_generic( inverse,		"Inverse" );

	def_visible_primitive( rotateXMatrix,	"RotateXMatrix");   
	def_visible_primitive( rotateYMatrix,	"RotateYMatrix");
	def_visible_primitive( rotateZMatrix,	"RotateZMatrix");
	def_visible_primitive( transMatrix,		"TransMatrix");
	def_visible_primitive( scaleMatrix,		"ScaleMatrix");
	def_visible_primitive( rotateYPRMatrix, "RotateYPRMatrix");

	def_visible_generic( xFormMat,		"XFormMat" );
	def_mapped_generic ( identity,		"Identity" );
	def_mapped_generic ( zero,			"Zero" );
	def_mapped_generic ( orthogonalize,	"Orthogonalize" );

	def_mapped_generic ( translate,		"Translate" );
	def_mapped_generic ( rotateX,		"RotateX" );
	def_mapped_generic ( rotateY,		"RotateY" );
	def_mapped_generic ( rotateZ,		"RotateZ" );
	use_generic        ( scale,			"Scale" );
	def_mapped_generic ( preTranslate,	"PreTranslate" );
	def_mapped_generic ( preRotateX,	"PreRotateX" );
	def_mapped_generic ( preRotateY,	"PreRotateY" );
	def_mapped_generic ( preRotateZ,	"PreRotateZ" );
	def_mapped_generic ( preScale,		"PreScale" );

	use_generic        ( rotate,		"Rotate" );
	def_mapped_generic ( preRotate,		"PreRotate" );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\Listener.h ===
/*		Listener.h - the Listener class - MAXScript listener windows
 *
 *		Copyright (c) John Wainwright, 1996
 *		
 */

#ifndef _H_LISTENER
#define _H_LISTENER

#include <windowsx.h>
#include "Pipe.h"
#include "Thunks.h"

extern GlobalThunk* listener_result_thunk;

extern ScripterExport BOOL end_keyboard_input;
extern ScripterExport BOOL start_keyboard_input;
extern ScripterExport TCHAR* keyboard_input;
extern ScripterExport Value* keyboard_terminator;
extern ScripterExport Array* keyboard_input_terminators;

// listener flag values
#define LSNR_INPUT_MODE_MASK	0x000F
#define LSNR_KEYINPUT_OFF		0x0000
#define LSNR_KEYINPUT_LINE		0x0001
#define LSNR_KEYINPUT_CHAR		0x0002
#define LSNR_SHOWING			0x0010	// MAXScript is forcing a show, ignore all other ShowWindows
#define LSNR_NO_MACRO_REDRAW	0x0020	// disable drawing in macro-rec box (to get round bug in WM_SETREDRAW)

#define EDIT_BOX_ITEM			1001	// listener edit box dlg item #
#define MACROREC_BOX_ITEM		1002	// listener macro-recorder edit box dlg item #

class ListenerViewWindow;

class Listener : public Value
{
	HANDLE		listener_thread;
	DWORD		thread_id;
public:
	HWND		listener_window;		// main listener window
	HWND		edit_box;				// edit control for main type-in
	HWND		macrorec_box;			// edit control for macro-recorder output
	HWND		mini_listener;			// mini-listener parent window in the MAX status panel
	HWND		mini_edit;				// mini-listener edit control for type_in
	HWND		mini_macrorec;			// mini-listener edit control for macro-recorder output
	WindowStream* edit_stream;			// stream for the main edit box
	WindowStream* macrorec_stream;		// stream for the macro-recorder edit box
	WindowStream* mini_edit_stream;		// stream for the mini edit box
	WindowStream* mini_macrorec_stream;	// stream for the mini macro-recorder edit box
	Pipe*		source_pipe;			// the source pipe for the listener, source written to, compiler reads from
	int			flags;
	ListenerViewWindow* lvw;			// the ViewWindow instance for the listener

				Listener(HINSTANCE mxs_instance, HWND MAX_window);
				~Listener();

	static DWORD run(Listener *l);
	void		create_listener_window(HINSTANCE hInstance, HWND hwnd);

	void		gc_trace();
	void		collect() { delete this; }

	ScripterExport void set_keyinput_mode(int mode) { flags = (flags & ~LSNR_INPUT_MODE_MASK) | mode; }
};

// ViewWindow subclass for putting the listener in a MAX viewport
class ListenerViewWindow : public ViewWindow
{
public:
	TCHAR *GetName();
	HWND CreateViewWindow(HWND hParent, int x, int y, int w, int h);
	void DestroyViewWindow(HWND hWnd);
	BOOL CanCreate();
};

class ListenerMessageData 
{
public:
	WPARAM wParam;
	LPARAM lParam;
	HANDLE message_event;
	ListenerMessageData(WPARAM wp, LPARAM lp, HANDLE me) { wParam = wp; lParam = lp; message_event = me; }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\Lclinsfn.h ===
/*	
 *	lclinsfn.h -  generic function instantiation macros for MAXScript SDK plug-ins
 */

#include "ClassCfg.h"

#ifdef def_local_generic
#	undef def_local_generic
#	undef use_local_generic
#endif
#ifdef use_generic
#	undef use_generic
#endif


#pragma pointers_to_members(full_generality, virtual_inheritance)

#define def_local_generic(fn, name)										\
	MS_LOCAL_GENERIC_CLASS fn##_gf (_T(name), &MS_LOCAL_ROOT_CLASS::fn##_vf)
#define use_generic(fn, name)
#define use_local_generic(fn, name)

#undef def_name
#define def_name(name) Value* n_##name;	

#define define_local_generic_class 													\
	MS_LOCAL_GENERIC_CLASS::MS_LOCAL_GENERIC_CLASS(TCHAR*fn_name, local_value_vf fn)\
	{																				\
		tag = MS_LOCAL_GENERIC_CLASS_TAG;											\
		fn_ptr = fn;																\
		name = save_string(fn_name);												\
	}																				\
	Value* MS_LOCAL_GENERIC_CLASS::apply(Value** arg_list, int count)				\
	{																				\
		Value*  result;																\
		Value**	evald_args;															\
		Value	**ap, **eap;														\
		int		i;																	\
		if (count < 1)																\
			throw ArgCountError("Generic apply", 1, count);							\
		value_local_array(evald_args, count);										\
		for (i = count, ap = arg_list, eap = evald_args; i--; eap++, ap++)			\
			*eap = (*ap)->eval();													\
		if (evald_args[0]->local_base_class() == MS_LOCAL_ROOT_CLASS_TAG)			\
			result = (((MS_LOCAL_ROOT_CLASS*)evald_args[0])->*fn_ptr)(&evald_args[1], count - 1); \
		else																		\
			throw NoMethodError (name, evald_args[0]);								\
		pop_value_local_array(evald_args);											\
		return result;																\
	}																				\
	MS_LOCAL_GENERIC_CLASS_CLASS MS_LOCAL_GENERIC_CLASS_class (str1(MS_LOCAL_GENERIC_CLASS));
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\Maxclses.h ===
/*	
 *		MAX_classes.h - class object for all the MAX built-in types
 *
 *			Copyright  John Wainwright 1996
 *
 */

#ifndef _H_MAX_CLASSES
#define _H_MAX_CLASSES

#include "MAXObj.h"

extern ScripterExport MAXSuperClass maxwrapper_class;
extern ScripterExport MAXSuperClass node_class;
extern ScripterExport MAXClass	    inode_object;
extern ScripterExport MAXSuperClass geom_class;
extern ScripterExport MAXSuperClass modifier;
extern ScripterExport MAXSuperClass shape;
extern ScripterExport MAXSuperClass helper_object;
extern ScripterExport MAXSuperClass spacewarp_object;
extern ScripterExport MAXSuperClass spacewarp_modifier;
extern ScripterExport MAXSuperClass float_controller;
extern ScripterExport MAXSuperClass point3_controller;
extern ScripterExport MAXSuperClass position_controller;
extern ScripterExport MAXSuperClass quat_controller;
extern ScripterExport MAXSuperClass rotation_controller;
extern ScripterExport MAXSuperClass scale_controller;
extern ScripterExport MAXSuperClass matrix3_controller;
extern ScripterExport MAXSuperClass morph_controller;
extern ScripterExport MAXSuperClass light_object;
extern ScripterExport MAXSuperClass camera_object;
extern ScripterExport MAXSuperClass material_class;
extern ScripterExport MAXSuperClass texture_map;
extern ScripterExport MAXSuperClass system_object;
extern ScripterExport MAXSuperClass utility_plugin;
extern ScripterExport MAXSuperClass atmos_object;
extern ScripterExport MAXSuperClass render_effect;	// RK: Added this
extern ScripterExport MAXSuperClass shadowtype_class; //LE Added this

extern MAXClass box;
extern MAXClass sphere;

extern Value*  node_get_ishidden(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    node_set_ishidden(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  node_get_boxmode(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    node_set_boxmode(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  node_get_alledges(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    node_set_alledges(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  node_get_backfacecull(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    node_set_backfacecull(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  node_get_castshadows(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    node_set_castshadows(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  node_get_receiveshadows(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void	   node_set_receiveshadows(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  node_get_motionblur(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    node_set_motionblur(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  node_get_wirecolor(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    node_set_wirecolor(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  node_get_isselected(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    node_set_isselected(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  node_get_isdependent(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    node_set_isdependent(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  node_get_istarget(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    node_set_istarget(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  node_get_gbufferchannel(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    node_set_gbufferchannel(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  node_get_visibility(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    node_set_visibility(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  node_get_targetDistance(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    node_set_targetDistance(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  node_get_imageblurMultiplier(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    node_set_imageblurMultiplier(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  node_get_showLinks(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    node_set_showLinks(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  node_get_showLinksOnly(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    node_set_showLinksOnly(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  node_get_isfrozen(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    node_set_isfrozen(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  node_get_showTrajectory(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    node_set_showTrajectory(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  node_get_renderable(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    node_set_renderable(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  node_get_showVertexColors(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    node_set_showVertexColors(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  node_get_vertexColorsShaded(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    node_set_vertexColorsShaded(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  node_get_inheritVisibility(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    node_set_inheritVisibility(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  node_get_baseObject(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    node_set_baseObject(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  node_get_lookAtNode(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    node_set_lookAtNode(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  node_get_transform(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    node_set_transform(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);

//RK: Added these
extern Value*  node_get_ignoreExtents(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    node_set_ignoreExtents(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  node_get_xray(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    node_set_xray(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  node_get_renderOccluded(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    node_set_renderOccluded(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  node_get_motionbluron(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    node_set_motionbluron(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  node_get_motionbluroncontroller(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    node_set_motionbluroncontroller(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  node_get_rcvCaustics(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    node_set_rcvCaustics(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  node_get_generateCaustics(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    node_set_generateCaustics(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  node_get_rcvGlobalIllum(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    node_set_rcvGlobalIllum(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  node_get_generateGlobalIllum(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    node_set_generateGlobalIllum(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  node_get_primaryVisibility(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    node_set_primaryVisibility(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  node_get_secondaryVisibility(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    node_set_secondaryVisibility(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);

extern Value*  campoint_get_showAxis(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    campoint_set_showAxis(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  campoint_get_axisLength(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    campoint_set_axisLength(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  point_get_showAxis(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    point_set_showAxis(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  point_get_axisLength(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    point_set_axisLength(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);

extern Value*  get_pa_emitter(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    set_pa_emitter(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_pa_instancingObject(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    set_pa_instancingObject(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_pa_lifespanValueQueue(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    set_pa_lifespanValueQueue(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_pa_objectMutationQueue(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    set_pa_objectMutationQueue(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);

extern Value*  get_ss_instancingObject(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    set_ss_instancingObject(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_ss_lifespanValueQueue(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    set_ss_lifespanValueQueue(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_ss_objectMutationQueue(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    set_ss_objectMutationQueue(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);

extern Value*  get_bliz_instancingObject(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    set_bliz_instancingObject(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_bliz_lifespanValueQueue(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    set_bliz_lifespanValueQueue(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_bliz_objectMutationQueue(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    set_bliz_objectMutationQueue(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);

extern Value*  get_pc_emitter(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    set_pc_emitter(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_pc_motionReferenceObject(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    set_pc_motionReferenceObject(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_pc_instancingObject(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    set_pc_instancingObject(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_pc_lifespanValueQueue(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    set_pc_lifespanValueQueue(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_pc_objectMutationQueue(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    set_pc_objectMutationQueue(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);

extern Value*  get_light_on(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    set_light_on(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_light_hsv(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    set_light_hsv(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_light_hue(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    set_light_hue(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_light_sat(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    set_light_sat(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_light_val(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    set_light_val(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_light_excludeList(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    set_light_excludeList(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_light_includeList(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    set_light_includeList(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_light_softenDiffuseEdge(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    set_light_softenDiffuseEdge(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_light_affectDiffuse(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    set_light_affectDiffuse(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_light_affectSpecular(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    set_light_affectSpecular(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_light_useNearAtten(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    set_light_useNearAtten(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_light_showNearAtten(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    set_light_showNearAtten(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_light_useFarAtten(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    set_light_useFarAtten(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_light_showFarAtten(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    set_light_showFarAtten(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_light_attenDecay(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    set_light_attenDecay(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_light_projector(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    set_light_projector(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_light_projectorMap(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    set_light_projectorMap(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_light_castShadows(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    set_light_castShadows(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_light_useGlobalShadowSettings(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    set_light_useGlobalShadowSettings(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_light_absoluteMapBias(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    set_light_absoluteMapBias(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_light_raytracedShadows(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    set_light_raytracedShadows(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_light_showCone(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    set_light_showCone(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_light_overShoot(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    set_light_overShoot(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_light_coneShape(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    set_light_coneShape(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);

// RK: Added these
extern Value*  get_light_atmosShadows(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    set_light_atmosShadows(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_light_lightAffectsShadow(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    set_light_lightAffectsShadow(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_light_shadowProjMap(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    set_light_shadowProjMap(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_light_ambientOnly(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    set_light_ambientOnly(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_light_type(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    set_light_type(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern void	   set_light_shadowGenerator(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_light_shadowGenerator(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);

//extern Value*  get_cam_lens(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
//extern void    set_cam_lens(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
//extern Value*  get_cam_fovType(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
//extern void    set_cam_fovType(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_cam_orthoProjection(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    set_cam_orthoProjection(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_cam_showCone(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    set_cam_showCone(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_cam_showHorizon(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    set_cam_showHorizon(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_cam_showRanges(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    set_cam_showRanges(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_cam_clipManualy(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    set_cam_clipManualy(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
// RK: Added these
extern Value*  get_cam_type(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    set_cam_type(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);

extern Value*  get_stdmat_map(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    set_stdmat_map(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_stdmat_mapamount(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    set_stdmat_mapamount(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_stdmat_mapenable(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    set_stdmat_mapenable(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_stdmat_shading(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    set_stdmat_shading(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_stdmat_soften(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    set_stdmat_soften(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_stdmat_facemap(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    set_stdmat_facemap(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_stdmat_twosided(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    set_stdmat_twosided(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_stdmat_wire(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    set_stdmat_wire(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_stdmat_wireunits(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    set_stdmat_wireunits(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_stdmat_falloff(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    set_stdmat_falloff(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_stdmat_opacitytype(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    set_stdmat_opacitytype(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_stdmat_lockambientdiffuse(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    set_stdmat_lockambientdiffuse(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_stdmat_superSample(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    set_stdmat_superSample(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_stdmat_applyReflectionDimming(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    set_stdmat_applyReflectionDimming(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);

extern Value*  get_mtl_gbufID(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid) ;
extern void    set_mtl_gbufID(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);

extern Value*  get_blend_material1(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    set_blend_material1(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_blend_material2(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    set_blend_material2(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_blend_mask(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    set_blend_mask(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_blend_material1Enabled(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    set_blend_material1Enabled(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_blend_material2Enabled(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    set_blend_material2Enabled(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_blend_maskEnabled(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    set_blend_maskEnabled(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_blend_useCurve(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    set_blend_useCurve(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);

extern Value*  get_double_facingMat(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    set_double_facingMat(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_double_backMat(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    set_double_backMat(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_double_facingEnabled(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    set_double_facingEnabled(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_double_backEnabled(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    set_double_backEnabled(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_topbot_coordinates(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    set_topbot_coordinates(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);

extern Value*  get_topbot_topMat(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    set_topbot_topMat(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_topbot_bottomMat(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    set_topbot_bottomMat(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_topbot_topEnabled(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    set_topbot_topEnabled(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_topbot_bottomEnabled(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    set_topbot_bottomEnabled(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);

extern Value*  get_raymat_map(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    set_raymat_map(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_raymat_mapamount(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    set_raymat_mapamount(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_raymat_mapenable(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    set_raymat_mapenable(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);

extern Value*  get_matte_opaqueAlpha(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    set_matte_opaqueAlpha(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_matte_applyAtmosphere(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    set_matte_applyAtmosphere(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_matte_atmosphereDepth(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    set_matte_atmosphereDepth(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_matte_receiveShadows(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    set_matte_receiveShadows(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_matte_affectAlpha(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid); 
extern void    set_matte_affectAlpha(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
				
extern Value*  bmt_get_filename(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    bmt_set_filename(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  bmt_get_filtertype(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    bmt_set_filtertype(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  bmt_get_alphasource(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    bmt_set_alphasource(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  bmt_get_endcondition(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    bmt_set_endcondition(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  bmt_get_monooutput(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    bmt_set_monooutput(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  bmt_get_playbackrate(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    bmt_set_playbackrate(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  bmt_get_starttime(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    bmt_set_starttime(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);

extern Value*  bmt_get_mappingtype(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    bmt_set_mappingtype(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  bmt_get_uoffset(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    bmt_set_uoffset(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  bmt_get_voffset(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    bmt_set_voffset(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  bmt_get_utiling(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    bmt_set_utiling(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  bmt_get_vtiling(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    bmt_set_vtiling(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  bmt_get_angle(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    bmt_set_angle(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  bmt_get_blur(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    bmt_set_blur(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  bmt_get_bluroffset(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    bmt_set_bluroffset(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  bmt_get_umirror(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    bmt_set_umirror(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  bmt_get_utile(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    bmt_set_utile(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  bmt_get_vmirror(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    bmt_set_vmirror(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  bmt_get_vtile(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    bmt_set_vtile(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  bmt_get_showmap(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    bmt_set_showmap(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);

//RK: Added these
extern Value*  bmt_get_bitmap(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    bmt_set_bitmap(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);

extern Value*  msk_get_map(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    msk_set_map(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  msk_get_mask(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    msk_set_mask(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  msk_get_mapEnabled(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    msk_set_mapEnabled(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  msk_get_maskEnabled(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    msk_set_maskEnabled(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  msk_get_maskInverted(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    msk_set_maskInverted(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);

extern Value*  noise_get_noiseType(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    noise_set_noiseType(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  noise_get_map1(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    noise_set_map1(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  noise_get_map2(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    noise_set_map2(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  noise_get_map1Enabled(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    noise_set_map1Enabled(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  noise_get_map2Enabled(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    noise_set_map2Enabled(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);

extern Value*  planet_get_blend(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    planet_set_blend(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);

extern Value*  grad_get_map1(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    grad_set_map1(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  grad_get_map2(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    grad_set_map2(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  grad_get_map3(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    grad_set_map3(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  grad_get_map1Enabled(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    grad_set_map1Enabled(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  grad_get_map2Enabled(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    grad_set_map2Enabled(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  grad_get_map3Enabled(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    grad_set_map3Enabled(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);

extern Value*  flatm_get_applyBlur(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    flatm_set_applyBlur(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  flatm_get_renderType(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    flatm_set_renderType(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  flatm_get_renderFrameStep(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    flatm_set_renderFrameStep(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  flatm_get_useEnvMap(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    flatm_set_useEnvMap(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  flatm_get_applyToMatIDFaces(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    flatm_set_applyToMatIDFaces(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  flatm_get_matID(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    flatm_set_matID(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  flatm_get_distortionType(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    flatm_set_distortionType(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  flatm_get_noiseType(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    flatm_set_noiseType(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);

extern Value*  uvg_get_mappingType(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    uvg_set_mappingType(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  uvg_get_mapping(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    uvg_set_mapping(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  uvg_get_mapChannel(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    uvg_set_mapChannel(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);

extern Value*  xyzg_get_coordType(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    xyzg_set_coordType(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  xyzg_get_mapChannel(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    xyzg_set_mapChannel(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);

extern Value*  get_text_string(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    set_text_string(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_text_font(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    set_text_font(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_text_italic(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    set_text_italic(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_text_underline(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    set_text_underline(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);

extern Value*  get_lxform_control(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    set_lxform_control(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_cammap_cam(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    set_cammap_cam(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);

extern Value*  pth_get_path(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    pth_set_path(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  pth_get_follow(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    pth_set_follow(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  pth_get_bank(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    pth_set_bank(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  pth_get_bankAmount(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    pth_set_bankAmount(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  pth_get_smoothness(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    pth_set_smoothness(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  pth_get_constantVelocity(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    pth_set_constantVelocity(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  pth_get_allowUpsideDown(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    pth_set_allowUpsideDown(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  pth_get_axis(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    pth_set_axis(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  pth_get_axisFlip(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    pth_set_axisFlip(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);

extern Value*  noiz_get_seed(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    noiz_set_seed(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  noiz_get_frequency(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    noiz_set_frequency(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  noiz_get_fractal(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    noiz_set_fractal(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  noiz_get_roughness(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    noiz_set_roughness(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  noiz_get_strength(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    noiz_set_strength(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  noiz_get_x_strength(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    noiz_set_x_strength(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  noiz_get_y_strength(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    noiz_set_y_strength(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  noiz_get_z_strength(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    noiz_set_z_strength(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  noiz_get_rampin(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    noiz_set_rampin(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  noiz_get_rampout(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    noiz_set_rampout(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  noiz_get_positive(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    noiz_set_positive(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  noiz_get_x_positive(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    noiz_set_x_positive(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  noiz_get_y_positive(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    noiz_set_y_positive(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  noiz_get_z_positive(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    noiz_set_z_positive(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);


extern Value*  spcdsp_get_bitmap(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    spcdsp_set_bitmap(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  spcdsp_get_map(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    spcdsp_set_map(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  dsp_get_bitmap(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    dsp_set_bitmap(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  dsp_get_map(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    dsp_set_map(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);

extern Value*  pathdef_get_path(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    pathdef_set_path(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);

extern Value*  surfdef_get_surface(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    surfdef_set_surface(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);

extern Value*  scriptctrl_get_script(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    scriptctrl_set_script(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);

extern Value*  shape_get_renderable(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    shape_set_renderable(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  shape_get_thickness(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    shape_set_thickness(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  shape_get_mapcoords(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    shape_set_mapcoords(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);

extern Value*  spline_get_steps(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    spline_set_steps(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  spline_get_optimize(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    spline_set_optimize(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  spline_get_adaptive(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    spline_set_adaptive(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);

extern Value*  smplspline_get_steps(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    smplspline_set_steps(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  smplspline_get_optimize(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    smplspline_set_optimize(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  smplspline_get_adaptive(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    smplspline_set_adaptive(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);

extern Value*  mirror_get_copy(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    mirror_set_copy(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);

//LE added this

extern Value*  get_shadow_absMapBias(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    set_shadow_absMapBias(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);

//end LE

// RK: Start -- object xrefs
extern Value*  get_oxref_proxyFileName(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    set_oxref_proxyFileName(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_oxref_fileName(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    set_oxref_fileName(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_oxref_currentFileName(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    set_oxref_currentFileName(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_oxref_proxyObjectName(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    set_oxref_proxyObjectName(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_oxref_objectName(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    set_oxref_objectName(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_oxref_currentObjectName(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    set_oxref_currentObjectName(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_oxref_useProxy(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    set_oxref_useProxy(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_oxref_renderProxy(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    set_oxref_renderProxy(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_oxref_updateMaterial(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    set_oxref_updateMaterial(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  get_oxref_ignoreAnimation(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    set_oxref_ignoreAnimation(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);

// RK: End

/* -------------- Added by AF 4/5/99 ------------------------------------*/
extern Value*  surfctrl_get_surface(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    surfctrl_set_surface(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  surfctrl_get_align(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    surfctrl_set_align(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
extern Value*  surfctrl_get_flip(ReferenceTarget* obj, Value* prop, TimeValue t, Interval& valid);
extern void    surfctrl_set_flip(ReferenceTarget* obj, Value* prop, TimeValue t, Value* val);
//AF: End


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\mathpro.h ===
/*	
 *		math_protocol.h - def_generics for the generic function in the Math protocol
 *
 *		see def_abstract_generics.h for more info.
 *
 *	
 *			Copyright  John Wainwright 1996
 *
 */

	def_generic(plus,	"+");
	def_generic(minus,	"-");
	def_generic(times,	"*");
	def_generic(div,	"/");
	def_generic(pwr,	"^");
	def_generic(uminus,	"u-");

	use_generic(eq,		"=");
	use_generic(ne,		"!=");
	def_generic(gt,		">");
	def_generic(lt,		"<");
	def_generic(ge,		">=");
	def_generic(le,		"<=");

	def_visible_generic ( random,	"random");
	def_visible_generic ( abs,		"abs");

	/* scripter-visible math primitives - implemented as prims since they are type-specific */
	
	def_visible_primitive( include, "include");
	
	def_visible_primitive( acos,	"acos");
	def_visible_primitive( asin,	"asin");
	def_visible_primitive( atan,	"atan");
	def_visible_primitive( ceil,	"ceil");
	def_visible_primitive( cos,		"cos");
	def_visible_primitive( cosh,	"cosh");
	def_visible_generic  ( exp,		"exp");  // exp is polymorphic (floats & quats)
	def_visible_primitive( floor,	"floor");
	def_visible_primitive( log,		"log");
	def_visible_primitive( log10,	"log10");
	def_visible_primitive( sin,		"sin");
	def_visible_primitive( sinh,	"sinh");
	def_visible_primitive( sqrt,	"sqrt");
	def_visible_primitive( tan,		"tan");
	def_visible_primitive( tanh,	"tanh");
 
	def_visible_primitive( atan2,	"atan2");
	def_visible_primitive( fmod,	"mod");
	def_visible_primitive( pow,		"pow");
	
	def_visible_primitive( seed,	"seed");
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\MAXMats.h ===
/*	
 *		MAXMaterials.h - MAX material & map wrapper classes
 *
 *			Copyright  John Wainwright 1996
 *
 */

#ifndef _H_MAXMATERIALS
#define _H_MAXMATERIALS

#include "Max.h"
#include "MaxObj.h"
//#include "sceneapi.h"

#if 0 // HEY!! add material library access
		virtual int LoadMaterialLib(const TCHAR *name)=0;
		virtual int SaveMaterialLib(const TCHAR *name)=0;
		virtual MtlBaseLib& GetMaterialLibrary()=0;
		static Class_ID mtlBaseLibClassID(MTLBASE_LIB_CLASS_ID,0);
#endif

/* -------------------------- MAXMaterial -------------------------- */

visible_class (MAXMaterial)

class MAXMaterial : public MAXWrapper
{
public:
	Mtl*		mat;				/* the MAX-side material	*/

				MAXMaterial(Mtl* imat);
	static ScripterExport MAXMaterial* intern(Mtl* imat);

	static Value* make(MAXClass* cls, Value** arg_list, int count);

	BOOL		is_kind_of(ValueMetaClass* c) { return (c == class_tag(MAXMaterial)) ? 1 : MAXWrapper::is_kind_of(c); }
	void		collect() { delete this; }
	ScripterExport void sprin1(CharStream* s);
	TCHAR*		class_name();

#include "defimpfn.h"
	Value*		copy_vf(Value** arg_list, int count) { return MAXWrapper::copy_no_undo(arg_list, count); }

	def_property( name );
	def_property( effectsChannel );

	Mtl*		to_mtl() { check_for_deletion(); return mat; }
	MtlBase*	to_mtlbase() { check_for_deletion(); return mat; }
};

/* ---------------------- MAXMultiMaterial ----------------------- */

visible_class (MAXMultiMaterial)

class MAXMultiMaterial : public MAXWrapper
{
public:
	MultiMtl*	mat;				/* the MAX-side material	*/

				MAXMultiMaterial(MultiMtl* imat);
	static ScripterExport MAXMultiMaterial* intern(MultiMtl* imat);

	static Value* make(MAXClass* cls, Value** arg_list, int count);

	BOOL		is_kind_of(ValueMetaClass* c) { return (c == class_tag(MAXMultiMaterial)) ? 1 : MAXWrapper::is_kind_of(c); }
	void		collect() { delete this; }
	ScripterExport void sprin1(CharStream* s);
	TCHAR*		class_name();

	def_generic (get, "get");
	def_generic (put, "put");
	Value*		copy_vf(Value** arg_list, int count) { return MAXWrapper::copy_no_undo(arg_list, count); }

	ScripterExport Value* map(node_map& m);

	def_property( name );
	def_property( numsubs );
	def_property( count );

	Mtl*		to_mtl() { return mat; }
	MtlBase*	to_mtlbase() { check_for_deletion(); return mat; }
};

/* ---------------------- Material Library ----------------------- */

applyable_class (MAXMaterialLibrary)

class MAXMaterialLibrary : public MAXWrapper
{
public:
	MtlBaseLib	new_lib;
	MtlBaseLib&	lib;

				MAXMaterialLibrary(MtlBaseLib& ilib);
				MAXMaterialLibrary(MtlBaseLib* ilib);
				MAXMaterialLibrary();
	static ScripterExport Value* intern(MtlBaseLib& ilib);
	static ScripterExport Value* intern(MtlBaseLib* ilib);

				classof_methods (MAXMaterialLibrary, MAXWrapper);
	void		collect() { delete this; }
	ScripterExport void sprin1(CharStream* s);
	MtlBase*	get_mtlbase(int index);
	MtlBase*	find_mtlbase(TCHAR* name);
	TCHAR*		class_name();

	/* operations */
	
	ScripterExport Value* map(node_map& m);

#include "defimpfn.h"
#	include "arraypro.h"
	Value*		copy_vf(Value** arg_list, int count) { return MAXWrapper::copy_no_undo(arg_list, count); }

	/* built-in property accessors */

	def_property ( count );
};

/* ------------------------- MAXTexture ------------------------ */

visible_class (MAXTexture)

class MAXTexture : public MAXWrapper
{
public:
	Texmap*	map;				/* the MAX-side map	*/

				MAXTexture(Texmap* imap);
	static ScripterExport MAXTexture* intern(Texmap* imap);

	static Value* make(MAXClass* cls, Value** arg_list, int count);

	BOOL		is_kind_of(ValueMetaClass* c) { return (c == class_tag(MAXTexture)) ? 1 : MAXWrapper::is_kind_of(c); }
	void		collect() { delete this; }
	ScripterExport void sprin1(CharStream* s);
	TCHAR*		class_name();

#include "defimpfn.h"
#	include "texmapro.h"
	Value*		copy_vf(Value** arg_list, int count) { return MAXWrapper::copy_no_undo(arg_list, count); }

	def_property( name );

	Texmap*		to_texmap() { check_for_deletion(); return map; }
	MtlBase*	to_mtlbase() { check_for_deletion(); return map; }
};

/* -------------------------- MAXMtlBase -------------------------- */

// a generic wrapper for MtlBase classes such as UVGen, XYZGen, TexOut, etc.

visible_class (MAXMtlBase)

class MAXMtlBase : public MAXWrapper
{
public:
	MtlBase*	mtl;				/* the MAX-side mtlbase	*/

				MAXMtlBase(MtlBase* imtl);
	static ScripterExport MAXMtlBase* intern(MtlBase* imtl);

	static Value* make(MAXClass* cls, Value** arg_list, int count);

	BOOL		is_kind_of(ValueMetaClass* c) { return (c == class_tag(MAXMtlBase)) ? 1 : MAXWrapper::is_kind_of(c); }
	void		collect() { delete this; }
	ScripterExport void sprin1(CharStream* s);
	TCHAR*		class_name() { return _T("MapSupportClass"); }
	Value*		copy_vf(Value** arg_list, int count) { return MAXWrapper::copy_no_undo(arg_list, count); }

	MtlBase*	to_mtlbase() { check_for_deletion(); return mtl; }
};

/* ------------------ MEdit materials virtual array -------------------- */

visible_class (MAXMeditMaterials)

class MAXMeditMaterials : public Value
{
public:
				MAXMeditMaterials() { tag = &MAXMeditMaterials_class; }

				classof_methods (MAXMeditMaterials, Value);
	void		collect() { delete this; }
	ScripterExport void sprin1(CharStream* s);
	MtlBase*	get_mtl(int index);
	MtlBase*	find_mtl(TCHAR* name);
	static SceneAPI	*sceneapi;
	static void setup();

	// operations
	ScripterExport Value* map(node_map& m);

#include "defimpfn.h"
#	include "arraypro.h"

	// built-in property accessors
	def_property ( count );
};

extern ScripterExport MAXMeditMaterials medit_materials;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\MAXKeys.h ===
/*	
 *		MAXKeys.h - MAX controller keyframe access classes
 *
 *			Copyright  John Wainwright 1996
 *
 */

#ifndef _H_MAXKEYS
#define _H_MAXKEYS

#include "Max.h"
#include "MaxObj.h"

visible_class (MAXKeyArray)

class MAXKeyArray : public MAXWrapper
{
public:
	Control*		 controller;		/* the controller							*/
	ParamDimension*  dim;				/* dimension from originating animatable	*/
	IKeyControl*	 ik;	

				MAXKeyArray(Control* icont, ParamDimension* idim);
	static ScripterExport Value* intern(Control* icont, ParamDimension* idim);

				classof_methods (MAXKeyArray, MAXWrapper);
	BOOL		_is_collection() { return 1; }
	void		collect() { delete this; }
	ScripterExport void sprin1(CharStream* s);
	TCHAR*		class_name();

	/* operations */
	
#include "defimpfn.h"
#	include "arraypro.h"
	def_generic ( sortKeys,			"sortKeys");
	def_generic ( addNewKey,		"addNewKey");
	def_generic ( deleteKeys,		"deleteKeys");
	def_generic ( deleteKey,		"deleteKey");
	def_generic (show_props,		"showProperties");
	def_generic (get_props,			"getPropNames");

	ScripterExport Value* map(node_map& m);

	/* built-in property accessors */

	def_property ( count );
};

typedef union AnyKey AnyKey;
union AnyKey
{
	TCHAR lfk[sizeof ILinFloatKey];
	TCHAR lp3k[sizeof ILinPoint3Key];
	TCHAR lrk[sizeof ILinRotKey];
	TCHAR lsk[sizeof ILinScaleKey];
	TCHAR bfk[sizeof IBezFloatKey];
	TCHAR bp3k[sizeof IBezPoint3Key];
	TCHAR bqk[sizeof IBezQuatKey];
	TCHAR bsk[sizeof IBezScaleKey];
	TCHAR tfk[sizeof ITCBFloatKey];
	TCHAR tp3k[sizeof ITCBPoint3Key];
	TCHAR trk[sizeof ITCBRotKey];
	TCHAR tsk[sizeof ITCBScaleKey];
};

#define ToTCBUI(a) (((a)+1.0f)*25.0f)  // HEY!! pinched from TCBINTRP.CPP, why not in a header or documented?
#define FromTCBUI(a) (((a)/25.0f)-1.0f)
#define ToEaseUI(a) ((a)*50.0f)
#define FromEaseUI(a) ((a)/50.0f)

visible_class (MAXKey)

class MAXKey : public MAXWrapper
{
public:
	Control*	controller;			/* MAX-side controller						*/
	ParamDimension* dim;			/* dimension from originating animatable	*/
	int			key_index;

	ScripterExport MAXKey (Control* icont, int ikey, ParamDimension* dim);
	ScripterExport MAXKey (Control* icont, int ikey);
	static ScripterExport Value* intern(Control* icont, int ikey, ParamDimension* dim);
	static ScripterExport Value* intern(Control* icont, int ikey);

	static void setup();

				classof_methods (MAXKey, MAXWrapper);
	void		collect() { delete this; }
	ScripterExport void sprin1(CharStream* s);
	TCHAR*		class_name();

	def_generic ( delete,		"delete");
	def_generic ( copy,			"copy");
	def_generic	( show_props,	"showProperties");
	def_generic ( get_props,	"getPropNames");

	ScripterExport IKey* setup_key_access(AnyKey& ak, IKeyControl** kip);

	def_property	(time);
	def_property	(selected);
	def_property	(value);
	def_property	(inTangent);
	def_property	(outTangent);
	def_property	(inTangentType);
	def_property	(outTangentType);
	def_property	(x_locked);
	def_property	(y_locked);
	def_property	(z_locked);
	def_property	(constantVelocity);
	def_property	(tension);
	def_property	(continuity);
	def_property	(bias);
	def_property	(easeTo);
	def_property	(easeFrom);

#if 0 // HEY!! obsolete
	def_nested_prop	( angle );
	def_nested_prop	( x_rotation );
	def_nested_prop	( y_rotation );
	def_nested_prop	( z_rotation );
	def_nested_prop	( axis );
	def_nested_prop	( x );
	def_nested_prop	( y );
	def_nested_prop	( z );
#endif

// add implementations of the recursive time controller fns here to complain
// since they wuill default to operating on the key's controller which can be very confusing
// the user should use them on the controller or track, not the key
#ifdef def_time_fn
#	undef def_time_fn
#endif
#define def_time_fn(_fn)									\
	Value* MAXKey::_fn##_vf(Value** arg_list, int count) { ABSTRACT_FUNCTION(#_fn, this, Value*); }	 
#include "time_fns.h"

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\MAXNURBS.h ===
/*	
 *		MAXNURBS.h - MAX NURBS access classes
 *
 *			Copyright  Autodesk, Inc. 1997
 *			Author: John Wainwright
 *
 */

#ifndef _H_MAXNURBS
#define _H_MAXNURBS

#include "Max.h"
#include "MaxObj.h"

#ifndef NO_NURBS

class NURBSSetValue;

/* ----------- base class for MAXScript NURBS wrapper classes -------- */

visible_class (NURBSObjectValue)

class NURBSObjectValue : public Value
{
public:
//	NURBSSetValue*		nset;			// NURBBSet I'm in
	static HashTable*	intern_table;
	static void			setup();
	BOOL				in_set;			// TRUE if residing in a NURBSSet (can only be in one and the NS owns deletion)

				NURBSObjectValue() { in_set = FALSE; }
				classof_methods(NURBSObjectValue, Value);
	void		collect() { delete this; }

	// operations
#include "defimpfn.h"
	// standard props
	def_property    ( name );
	def_prop_getter ( nurbsID );
	def_property    ( selected );
	def_prop_getter ( index );
//	def_prop_getter ( nurbsSet );

	void		common_nurbs_params(Value** arg_list, int count);

};

#define NRB_DIRECT		0x0001	// direct access

/* --------------- base class for NURBSPoints ----------------------- */

visible_class_s (NURBSPointValue, NURBSObjectValue)

class NURBSPointValue : public NURBSObjectValue
{
public:
				classof_methods(NURBSPointValue, NURBSObjectValue);
	void		collect() { delete this; }
	
	// operations
#include "defimpfn.h"
	// built-in property accessors
	def_prop_getter ( pos );
	def_prop_getter ( x );
	def_prop_getter ( y );
	def_prop_getter ( z );

	Point3	to_point3() { return to_nurbspoint()->GetPosition(MAXScript_time()); }
};

/* ---------------  wrapper for NURBSIndependentPoints ----------------------- */

applyable_class_s (NURBSIndependentPointValue, NURBSPointValue)

class NURBSIndependentPointValue : public NURBSPointValue
{
public:
	NURBSIndependentPoint* point;

	ScripterExport NURBSIndependentPointValue(Point3 pt);
	ScripterExport NURBSIndependentPointValue(NURBSIndependentPoint* pt);
	static ScripterExport NURBSIndependentPointValue* intern(NURBSIndependentPoint* pt);
	ScripterExport ~NURBSIndependentPointValue() { if (!in_set) delete point; }

				classof_methods(NURBSIndependentPointValue, NURBSPointValue);
	void		collect() { delete this; }
	ScripterExport void		sprin1(CharStream* s);
	
	// operations
#include "defimpfn.h"
	use_generic  ( eq,	"=");
	use_generic  ( ne,	"!=");

	// built-in property accessors
	def_prop_setter ( pos );
	def_prop_setter ( x );
	def_prop_setter ( y );
	def_prop_setter ( z );

	NURBSIndependentPoint*	to_nurbsindependentpoint() { return point; }
	NURBSPoint*				to_nurbspoint() { return point; }
	NURBSObject*			to_nurbsobject() { return point; }
};

/* ---------------  wrapper for NURBSPointConstPoints ----------------------- */

applyable_class_s (NURBSPointConstPointValue, NURBSPointValue)

class NURBSPointConstPointValue : public NURBSPointValue
{
public:
	NURBSPointConstPoint* point;

	ScripterExport NURBSPointConstPointValue();
	ScripterExport NURBSPointConstPointValue(NURBSPointConstPoint* pt);
	static ScripterExport NURBSPointConstPointValue* intern(NURBSPointConstPoint* pt);
	ScripterExport ~NURBSPointConstPointValue() { if (!in_set) delete point; }

				classof_methods(NURBSPointConstPointValue, NURBSPointValue);
	void		collect() { delete this; }
	ScripterExport void		sprin1(CharStream* s);
	 
	// operations
#include "defimpfn.h"

	// built-in property accessors
	def_property ( parent );
	def_property ( parentID );
	def_property ( type );
	def_property ( offset );

	NURBSPointConstPoint*	to_nurbspointconstpoint() { return point; }
	NURBSPoint*				to_nurbspoint() { return point; }
	NURBSObject*			to_nurbsobject() { return point; }
};

/* ---------------  wrapper for NURBSCurveConstPoints ----------------------- */

applyable_class_s (NURBSCurveConstPointValue, NURBSPointValue)

class NURBSCurveConstPointValue : public NURBSPointValue
{
public:
	NURBSCurveConstPoint* point;

	ScripterExport NURBSCurveConstPointValue();
	ScripterExport NURBSCurveConstPointValue(NURBSCurveConstPoint* pt);
	static ScripterExport NURBSCurveConstPointValue* intern(NURBSCurveConstPoint* pt);
	ScripterExport ~NURBSCurveConstPointValue() { if (!in_set) delete point; }

				classof_methods(NURBSCurveConstPointValue, NURBSPointValue);
	void		collect() { delete this; }
	ScripterExport void		sprin1(CharStream* s);
	
	// operations
#include "defimpfn.h"
	// built-in property accessors
	def_property ( parent );
	def_property ( parentID );
	def_property ( type );
	def_property ( offset );
	def_property ( uParam );
	def_property ( normal );
	def_property ( uTangent );
	def_property ( trimCurve );
	def_property ( flipTrim );

	NURBSCurveConstPoint*	to_nurbscurveconstpoint() { return point; }
	NURBSPoint*				to_nurbspoint() { return point; }
	NURBSObject*			to_nurbsobject() { return point; }
};

/* --------------- wrapper for NURBSCurveIntersectPoint ----------------------- */

applyable_class_s (NURBSCurveIntersectPointValue, NURBSPointValue)

class NURBSCurveIntersectPointValue : public NURBSPointValue
{
public:
	NURBSCurveCurveIntersectionPoint* point;

	ScripterExport NURBSCurveIntersectPointValue();
	ScripterExport NURBSCurveIntersectPointValue(NURBSCurveCurveIntersectionPoint* pt);
	static ScripterExport NURBSCurveIntersectPointValue* intern(NURBSCurveCurveIntersectionPoint* pt);
	ScripterExport ~NURBSCurveIntersectPointValue() { if (!in_set) delete point; }

				classof_methods(NURBSCurveIntersectPointValue, NURBSPointValue);
	void		collect() { delete this; }
	ScripterExport void		sprin1(CharStream* s);
	
	// operations
#include "defimpfn.h"
	// built-in property accessors
	def_property ( parent1 );
	def_property ( parent1ID );
	def_property ( parent2 );
	def_property ( parent2ID );
	def_property ( trimCurve1 );
	def_property ( trimCurve2 );
	def_property ( flipTrim1 );
	def_property ( flipTrim2 );

	NURBSCurveCurveIntersectionPoint*	to_nurbscurvecurveintersectionpoint() { return point; }
	NURBSPoint*							to_nurbspoint() { return point; }
	NURBSObject*						to_nurbsobject() { return point; }
};

/* --------------- wrapper for NURBSCurveSurfaceIntersectPoint ----------------------- */

applyable_class_s (NURBSCurveSurfaceIntersectPointValue, NURBSPointValue)

class NURBSCurveSurfaceIntersectPointValue : public NURBSPointValue
{
public:
	NURBSCurveSurfaceIntersectionPoint* point;

	ScripterExport NURBSCurveSurfaceIntersectPointValue();
	ScripterExport NURBSCurveSurfaceIntersectPointValue(NURBSCurveSurfaceIntersectionPoint* pt);
	static ScripterExport NURBSCurveSurfaceIntersectPointValue* intern(NURBSCurveSurfaceIntersectionPoint* pt);
	ScripterExport ~NURBSCurveSurfaceIntersectPointValue() { if (!in_set) delete point; }

				classof_methods(NURBSCurveSurfaceIntersectPointValue, NURBSPointValue);
	void		collect() { delete this; }
	ScripterExport void		sprin1(CharStream* s);
	
	// operations
#include "defimpfn.h"
	// built-in property accessors
	def_property ( seed );
	def_property ( parent1 );
	def_property ( parent1ID );
	def_property ( parent2 );
	def_property ( parent2ID );
	def_property ( trimCurve );
	def_property ( flipTrim );

	NURBSCurveSurfaceIntersectionPoint*	to_nurbscurvesurfaceintersectionpoint() { return point; }
	NURBSPoint*							to_nurbspoint() { return point; }
	NURBSObject*						to_nurbsobject() { return point; }
};

/* --------------- wrapper for NURBSSurfConstPoint ----------------------- */

applyable_class_s (NURBSSurfConstPointValue, NURBSPointValue)

class NURBSSurfConstPointValue : public NURBSPointValue
{
public:
	NURBSSurfConstPoint* point;

	ScripterExport NURBSSurfConstPointValue();
	ScripterExport NURBSSurfConstPointValue(NURBSSurfConstPoint* pt);
	static ScripterExport NURBSSurfConstPointValue* intern(NURBSSurfConstPoint* pt);
	ScripterExport ~NURBSSurfConstPointValue() { if (!in_set) delete point; }

				classof_methods(NURBSSurfConstPointValue, NURBSPointValue);
	void		collect() { delete this; }
	ScripterExport void		sprin1(CharStream* s);
	
	// operations
#include "defimpfn.h"
	// built-in property accessors
	def_property ( parent );
	def_property ( parentID );
	def_property ( type );
	def_property ( offset );
	def_property ( uParam );
	def_property ( vParam );
	def_property ( normal );
	def_property ( uTangent );
	def_property ( vTangent );

	NURBSSurfConstPoint*	to_nurbssurfconstpoint() { return point; }
	NURBSPoint*				to_nurbspoint() { return point; }
	NURBSObject*			to_nurbsobject() { return point; }
};

#ifdef WAITING_ON_APT
	/* --------------- 	wrapper for NURBSTrimPoint ----------------------- */

	applyable_class_s (NURBSTrimPointValue, NURBSPointValue)

	class NURBSTrimPointValue : public Value
	{
	public:
		NURBSTrimPoint point;

		ScripterExport NURBSTrimPointValue(double param, NURBSTrimDirection dir);
		ScripterExport NURBSTrimPointValue(NURBSTrimPoint* pt);

					classof_methods(NURBSTrimPointValue, Value);
		void		collect() { delete this; }
		ScripterExport void		sprin1(CharStream* s);
		
		// operations
	#include "defimpfn.h"
		// built-in property accessors
		def_prop_getter ( parameter );
		def_prop_setter ( dir );

		NURBSTrimPoint*			to_nurbstrimpoint() { return point; }
	};
#endif

/* --------------- wrapper for NURBSControlVertex ----------------------- */

applyable_class_s (NURBSControlVertexValue, NURBSObjectValue)

class NURBSControlVertexValue : public NURBSObjectValue
{
public:
	NURBSControlVertex*	cv;

	ScripterExport NURBSControlVertexValue(NURBSControlVertex* icv);
	ScripterExport NURBSControlVertexValue(Point3 pt, float weight);
	static ScripterExport NURBSControlVertexValue* intern(NURBSControlVertex* icv);
	ScripterExport ~NURBSControlVertexValue() { if (!in_set) delete cv; }

				classof_methods(NURBSControlVertexValue, NURBSObjectValue);
	void		collect() { delete this; }
	ScripterExport void		sprin1(CharStream* s);
#	define		is_nurbscontrolvertex(p) ((p)->tag == class_tag(NURBSControlVertexValue))
	
	// operations
#include "defimpfn.h"
	use_generic  ( eq,	"=");
	use_generic  ( ne,	"!=");

	// built-in property accessors
	def_property ( weight );
	def_property ( pos );
	def_property ( x );
	def_property ( y );
	def_property ( z );

	Point3				to_point3() { return cv->GetPosition(MAXScript_time()); }
	NURBSControlVertex* to_nurbscontrolvertex() { return cv; }
	NURBSObject*		to_nurbsobject() { return cv; }
};

/* --------------- base class for NURBSCurve ----------------------- */

class NURBSCurveValueClass : public ValueMetaClass  // visible_class_s (NURBSCurveValue)
{
	public:	
				NURBSCurveValueClass(TCHAR* name) : ValueMetaClass (name) { }
	Value*		classOf_vf(Value** arg_list, int count) { return class_tag(NURBSObjectValue); }
	Value*		superClassOf_vf(Value** arg_list, int count) { return NURBSObjectValue_class.classOf_vf(NULL, 0);}
	void		collect() { delete this; }
	Class_ID	get_max_class_id() { return EDITABLE_CVCURVE_CLASS_ID; }
};
extern ScripterExport NURBSCurveValueClass NURBSCurveValue_class;

class NURBSCurveValue : public NURBSObjectValue
{
public:
				classof_methods(NURBSCurveValue, NURBSObjectValue);
	void		collect() { delete this; }
	
	// operations
#include "defimpfn.h"
	def_generic ( evalPos,	   "evalPos" );
	def_generic ( evalTangent, "evalTangent" );

	// built-in property accessors
	def_prop_getter ( isClosed );
	def_prop_getter ( numTrimPoints );
	def_prop_getter ( parameterRangeMin );
	def_prop_getter ( parameterRangeMax );
	def_property	( matID );

	void		common_curve_params(Value** arg_list, int count);
};

/* --------------- wrapper for NURBSCVCurve ----------------------- */

applyable_class_s (NURBSCVCurveValue, NURBSCurveValue)

class NURBSCVCurveValue : public NURBSCurveValue
{
public:
	NURBSCVCurve* curve;

	ScripterExport NURBSCVCurveValue();
	ScripterExport NURBSCVCurveValue(NURBSCVCurve* pt);
	static ScripterExport NURBSCVCurveValue* intern(NURBSCVCurve* pt);
	ScripterExport ~NURBSCVCurveValue() { if (!in_set) delete curve; }

				classof_methods(NURBSCVCurveValue, NURBSCurveValue);
	void		collect() { delete this; }
	ScripterExport void		sprin1(CharStream* s);
	
	// operations
#include "defimpfn.h"
	use_generic ( close,	"close" );
	def_generic ( getKnot,	"getKnot" );
	def_generic ( setKnot,	"setKnot" );
	def_generic ( getCV,	"getCV" );
	def_generic ( setCV,	"setCV" );
	def_generic ( refine,	"refine" );
	def_generic ( reparameterize, "reparameterize" );

	// built-in property accessors
	def_property ( order );
	def_property ( numKnots );
	def_property ( numCVs );
	def_property ( transform );
	def_property ( autoParam );
	def_prop_getter ( endsOverlap );

	NURBSCurve*		to_nurbscurve() { return curve; }
	NURBSCVCurve*	to_nurbscvcurve() { return curve;  }
	NURBSObject*	to_nurbsobject() { return curve; }

};

/* --------------- wrapper for NURBSPointCurve ----------------------- */

applyable_class_s (NURBSPointCurveValue, NURBSCurveValue)

class NURBSPointCurveValue : public NURBSCurveValue
{
public:
	NURBSPointCurve* curve;

	ScripterExport NURBSPointCurveValue();
	ScripterExport NURBSPointCurveValue(NURBSPointCurve* pt);
	static ScripterExport NURBSPointCurveValue* intern(NURBSPointCurve* pt);
	ScripterExport ~NURBSPointCurveValue() { if (!in_set) delete curve; }

				classof_methods(NURBSPointCurveValue, NURBSCurveValue);
	void		collect() { delete this; }
	ScripterExport void		sprin1(CharStream* s);
	
	// operations
#include "defimpfn.h"
	use_generic ( close,	"close" );
	def_generic ( getPoint,	"getPoint" );
	def_generic ( setPoint,	"setPoint" );
	def_generic ( refine,	"refine" );

	// built-in property accessors
	def_property ( numPoints );
	def_property ( transform );

	NURBSCurve*		to_nurbscurve() { return curve; }
	NURBSObject*	to_nurbsobject() { return curve; }
};

/* --------------- wrapper for NURBSBlendCurve ----------------------- */

applyable_class_s (NURBSBlendCurveValue, NURBSCurveValue)

class NURBSBlendCurveValue : public NURBSCurveValue
{
public:
	NURBSBlendCurve* curve;

	ScripterExport NURBSBlendCurveValue();
	ScripterExport NURBSBlendCurveValue(NURBSBlendCurve* pt);
	static ScripterExport NURBSBlendCurveValue* intern(NURBSBlendCurve* pt);
	ScripterExport ~NURBSBlendCurveValue() { if (!in_set) delete curve; }

				classof_methods(NURBSBlendCurveValue, NURBSCurveValue);
	void		collect() { delete this; }
	ScripterExport void		sprin1(CharStream* s);
	
	// operations
#include "defimpfn.h"

	// built-in property accessors
	def_property ( parent1 );
	def_property ( parent1ID );
	def_property ( parent2 );
	def_property ( parent2ID );
	def_property ( flip1 );
	def_property ( flip2 );
	def_property ( tension1 );
	def_property ( tension2 );

	NURBSCurve*		to_nurbscurve() { return curve; }
	NURBSObject*	to_nurbsobject() { return curve; }
};

/* --------------- wrapper for NURBSOffsetCurve ----------------------- */

applyable_class_s (NURBSOffsetCurveValue, NURBSCurveValue)

class NURBSOffsetCurveValue : public NURBSCurveValue
{
public:
	NURBSOffsetCurve* curve;

	ScripterExport NURBSOffsetCurveValue();
	ScripterExport NURBSOffsetCurveValue(NURBSOffsetCurve* pt);
	static ScripterExport NURBSOffsetCurveValue* intern(NURBSOffsetCurve* pt);
	ScripterExport ~NURBSOffsetCurveValue() { if (!in_set) delete curve; }

				classof_methods(NURBSOffsetCurveValue, NURBSCurveValue);
	void		collect() { delete this; }
	ScripterExport void		sprin1(CharStream* s);
	
	// operations
#include "defimpfn.h"

	// built-in property accessors
	def_property ( parent );
	def_property ( parentID );
	def_property ( distance );

	NURBSCurve*		to_nurbscurve() { return curve; }
	NURBSObject*	to_nurbsobject() { return curve; }
};

/* --------------- wrapper for NURBSXFormCurve ----------------------- */

applyable_class_s (NURBSXFormCurveValue, NURBSCurveValue)

class NURBSXFormCurveValue : public NURBSCurveValue
{
public:
	NURBSXFormCurve* curve;

	ScripterExport NURBSXFormCurveValue();
	ScripterExport NURBSXFormCurveValue(NURBSXFormCurve* pt);
	static ScripterExport NURBSXFormCurveValue* intern(NURBSXFormCurve* pt);
	ScripterExport ~NURBSXFormCurveValue() { if (!in_set) delete curve; }

				classof_methods(NURBSXFormCurveValue, NURBSCurveValue);
	void		collect() { delete this; }
	ScripterExport void		sprin1(CharStream* s);
	
	// operations
#include "defimpfn.h"

	// built-in property accessors
	def_property ( parent );
	def_property ( parentID );
	def_property ( transform );

	NURBSCurve*		to_nurbscurve() { return curve; }
	NURBSObject*	to_nurbsobject() { return curve; }
};

/* --------------- wrapper for NURBSMirrorCurve ----------------------- */

applyable_class_s (NURBSMirrorCurveValue, NURBSCurveValue)

class NURBSMirrorCurveValue : public NURBSCurveValue
{
public:
	NURBSMirrorCurve* curve;

	ScripterExport NURBSMirrorCurveValue();
	ScripterExport NURBSMirrorCurveValue(NURBSMirrorCurve* pt);
	static ScripterExport NURBSMirrorCurveValue* intern(NURBSMirrorCurve* pt);
	ScripterExport ~NURBSMirrorCurveValue() { if (!in_set) delete curve; }

				classof_methods(NURBSMirrorCurveValue, NURBSCurveValue);
	void		collect() { delete this; }
	ScripterExport void		sprin1(CharStream* s);
	
	// operations
#include "defimpfn.h"

	// built-in property accessors
	def_property ( parent );
	def_property ( parentID );
	def_property ( axis );
	def_property ( distance );
	def_property ( transform );

	NURBSCurve*		to_nurbscurve() { return curve; }
	NURBSObject*	to_nurbsobject() { return curve; }
};

/* --------------- wrapper for NURBSFilletCurve ----------------------- */

applyable_class_s (NURBSFilletCurveValue, NURBSCurveValue)

class NURBSFilletCurveValue : public NURBSCurveValue
{
public:
	NURBSFilletCurve* curve;

	ScripterExport NURBSFilletCurveValue();
	ScripterExport NURBSFilletCurveValue(NURBSFilletCurve* pt);
	static ScripterExport NURBSFilletCurveValue* intern(NURBSFilletCurve* pt);
	ScripterExport ~NURBSFilletCurveValue() { if (!in_set) delete curve; }

				classof_methods(NURBSFilletCurveValue, NURBSCurveValue);
	void		collect() { delete this; }
	ScripterExport void		sprin1(CharStream* s);
	
	// operations
#include "defimpfn.h"

	// built-in property accessors
	def_property ( parent1 );
	def_property ( parent1ID );
	def_property ( parent2 );
	def_property ( parent2ID );
	def_property ( flip1 );
	def_property ( flip2 );
	def_property ( radius );
	def_property ( trim1 );
	def_property ( trim2 );
	def_property ( flipTrim1 );
	def_property ( flipTrim2 );

	NURBSCurve*		to_nurbscurve() { return curve; }
	NURBSObject*	to_nurbsobject() { return curve; }
};

/* --------------- wrapper for NURBSChamferCurve ----------------------- */

applyable_class_s (NURBSChamferCurveValue, NURBSCurveValue)

class NURBSChamferCurveValue : public NURBSCurveValue
{
public:
	NURBSChamferCurve* curve;

	ScripterExport NURBSChamferCurveValue();
	ScripterExport NURBSChamferCurveValue(NURBSChamferCurve* pt);
	static ScripterExport NURBSChamferCurveValue* intern(NURBSChamferCurve* pt);
	ScripterExport ~NURBSChamferCurveValue() { if (!in_set) delete curve; }

				classof_methods(NURBSChamferCurveValue, NURBSCurveValue);
	void		collect() { delete this; }
	ScripterExport void		sprin1(CharStream* s);
	
	// operations
#include "defimpfn.h"

	// built-in property accessors
	def_property ( parent1 );
	def_property ( parent1ID );
	def_property ( parent2 );
	def_property ( parent2ID );
	def_property ( flip1 );
	def_property ( flip2 );
	def_property ( length1 );
	def_property ( length2 );
	def_property ( trim1 );
	def_property ( trim2 );
	def_property ( flipTrim1 );
	def_property ( flipTrim2 );

	NURBSCurve*		to_nurbscurve() { return curve; }
	NURBSObject*	to_nurbsobject() { return curve; }
};

/* --------------- wrapper for NURBSIsoCurve ----------------------- */

applyable_class_s (NURBSIsoCurveValue, NURBSCurveValue)

class NURBSIsoCurveValue : public NURBSCurveValue
{
public:
	NURBSIsoCurve* curve;

	ScripterExport NURBSIsoCurveValue();
	ScripterExport NURBSIsoCurveValue(NURBSIsoCurve* pt);
	static ScripterExport NURBSIsoCurveValue* intern(NURBSIsoCurve* pt);
	ScripterExport ~NURBSIsoCurveValue() { if (!in_set) delete curve; }

				classof_methods(NURBSIsoCurveValue, NURBSCurveValue);
	void		collect() { delete this; }
	ScripterExport void		sprin1(CharStream* s);
	
	// operations
#include "defimpfn.h"

	// built-in property accessors
	def_property ( parent );
	def_property ( parentID );
	def_property ( dir );
	def_property ( parameter );
	def_property ( trim );
	def_property ( flipTrim );
	def_property ( seed );

	NURBSCurve*		to_nurbscurve() { return curve; }
	NURBSObject*	to_nurbsobject() { return curve; }
};

/* --------------- wrapper for NURBSProjectVectorCurve ----------------------- */

applyable_class_s (NURBSProjectVectorCurveValue, NURBSCurveValue)

class NURBSProjectVectorCurveValue : public NURBSCurveValue
{
public:
	NURBSProjectVectorCurve* curve;

	ScripterExport NURBSProjectVectorCurveValue();
	ScripterExport NURBSProjectVectorCurveValue(NURBSProjectVectorCurve* pt);
	static ScripterExport NURBSProjectVectorCurveValue* intern(NURBSProjectVectorCurve* pt);
	ScripterExport ~NURBSProjectVectorCurveValue() { if (!in_set) delete curve; }

				classof_methods(NURBSProjectVectorCurveValue, NURBSCurveValue);
	void		collect() { delete this; }
	ScripterExport void		sprin1(CharStream* s);
	
	// operations
#include "defimpfn.h"

	// built-in property accessors
	def_property ( parent1 );
	def_property ( parent1ID );
	def_property ( parent2 );
	def_property ( parent2ID );
	def_property ( trim );
	def_property ( flipTrim );
	def_property ( seed );
	def_property ( pVec );

	NURBSCurve*		to_nurbscurve() { return curve; }
	NURBSObject*	to_nurbsobject() { return curve; }
};

/* --------------- wrapper for NURBSProjectNormalCurve ----------------------- */

applyable_class_s (NURBSProjectNormalCurveValue, NURBSCurveValue)

class NURBSProjectNormalCurveValue : public NURBSCurveValue
{
public:
	NURBSProjectNormalCurve* curve;

	ScripterExport NURBSProjectNormalCurveValue();
	ScripterExport NURBSProjectNormalCurveValue(NURBSProjectNormalCurve* pt);
	static ScripterExport NURBSProjectNormalCurveValue* intern(NURBSProjectNormalCurve* pt);
	ScripterExport ~NURBSProjectNormalCurveValue() { if (!in_set) delete curve; }

				classof_methods(NURBSProjectNormalCurveValue, NURBSCurveValue);
	void		collect() { delete this; }
	ScripterExport void		sprin1(CharStream* s);
	
	// operations
#include "defimpfn.h"

	// built-in property accessors
	def_property ( parent1 );
	def_property ( parent1ID );
	def_property ( parent2 );
	def_property ( parent2ID );
	def_property ( trim );
	def_property ( flipTrim );
	def_property ( seed );

	NURBSCurve*		to_nurbscurve() { return curve; }
	NURBSObject*	to_nurbsobject() { return curve; }
};

/* --------------- wrapper for NURBSSurfSurfIntersectionCurve ----------------------- */

applyable_class_s (NURBSSurfSurfIntersectionCurveValue, NURBSCurveValue)

class NURBSSurfSurfIntersectionCurveValue : public NURBSCurveValue
{
public:
	NURBSSurfSurfIntersectionCurve* curve;

	ScripterExport NURBSSurfSurfIntersectionCurveValue();
	ScripterExport NURBSSurfSurfIntersectionCurveValue(NURBSSurfSurfIntersectionCurve* pt);
	static ScripterExport NURBSSurfSurfIntersectionCurveValue* intern(NURBSSurfSurfIntersectionCurve* pt);
	ScripterExport ~NURBSSurfSurfIntersectionCurveValue() { if (!in_set) delete curve; }

				classof_methods(NURBSSurfSurfIntersectionCurveValue, NURBSCurveValue);
	void		collect() { delete this; }
	ScripterExport void		sprin1(CharStream* s);
	
	// operations
#include "defimpfn.h"

	// built-in property accessors
	def_property ( parent1 );
	def_property ( parent1ID );
	def_property ( parent2 );
	def_property ( parent2ID );
	def_property ( trim1 );
	def_property ( flipTrim1 );
	def_property ( trim2 );
	def_property ( flipTrim2 );
	def_property ( seed );

	NURBSCurve*		to_nurbscurve() { return curve; }
	NURBSObject*	to_nurbsobject() { return curve; }
};

/* --------------- wrapper for NURBSCurveOnSurface ----------------------- */

applyable_class_s (NURBSCurveOnSurfaceValue, NURBSCVCurveValue)

class NURBSCurveOnSurfaceValue : public NURBSCVCurveValue
{
public:
	NURBSCurveOnSurface* curve;

	ScripterExport NURBSCurveOnSurfaceValue();
	ScripterExport NURBSCurveOnSurfaceValue(NURBSCurveOnSurface* pt);
	static ScripterExport NURBSCurveOnSurfaceValue* intern(NURBSCurveOnSurface* pt);
	ScripterExport ~NURBSCurveOnSurfaceValue() { if (!in_set) delete curve; }

				classof_methods(NURBSCurveOnSurfaceValue, NURBSCVCurveValue);
	void		collect() { delete this; }
	ScripterExport void		sprin1(CharStream* s);
	
	// operations
#include "defimpfn.h"
	// operations
#include "defimpfn.h"
	// from NURBSCVCurve
	use_generic ( close,	"close" );
	def_generic ( getKnot,	"getKnot" );
	def_generic ( setKnot,	"setKnot" );
	def_generic ( getCV,	"getCV" );
	def_generic ( setCV,	"setCV" );
	def_generic ( refine,	"refine" );

	// built-in property accessors
	// from NURBSCVCurve
	def_property ( order ); 
	def_property ( numKnots );
	def_property ( numCVs );
	def_property ( transform );
	def_prop_getter ( endsOverlap );

	// from NURBSCurveOnSurface
	def_property ( parent );
	def_property ( parentID );
	def_property ( trim );
	def_property ( flipTrim );

	NURBSCurve*		to_nurbscurve() { return curve; }
	NURBSObject*	to_nurbsobject() { return curve; }
};

/* --------------- wrapper for NURBSPointCurveOnSurface ----------------------- */

applyable_class_s (NURBSPointCurveOnSurfaceValue, NURBSPointCurveValue)

class NURBSPointCurveOnSurfaceValue : public NURBSPointCurveValue
{
public:
	NURBSPointCurveOnSurface* curve;

	ScripterExport NURBSPointCurveOnSurfaceValue();
	ScripterExport NURBSPointCurveOnSurfaceValue(NURBSPointCurveOnSurface* pt);
	static ScripterExport NURBSPointCurveOnSurfaceValue* intern(NURBSPointCurveOnSurface* pt);
	ScripterExport ~NURBSPointCurveOnSurfaceValue() { if (!in_set) delete curve; }

				classof_methods(NURBSPointCurveOnSurfaceValue, NURBSPointCurveValue);
	void		collect() { delete this; }
	ScripterExport void		sprin1(CharStream* s);
	
	// operations
#include "defimpfn.h"
	// operations
#include "defimpfn.h"
	// from NURBSPointCurve
	use_generic ( close,	"close" );
	def_generic ( getPoint,	"getPoint" );
	def_generic ( setPoint,	"setPoint" );
	def_generic ( refine,	"refine" );

	// built-in property accessors
	// from NURBSPointCurve
	def_property ( numPoints );
	def_property ( transform );

	// from NURBSPointCurveOnSurface
	def_property ( parent );
	def_property ( parentID );
	def_property ( trim );
	def_property ( flipTrim );

	NURBSCurve*		to_nurbscurve() { return curve; }
	NURBSObject*	to_nurbsobject() { return curve; }
};

/* --------------- wrapper for NURBSSurfaceNormalCurve ----------------------- */

applyable_class_s (NURBSSurfaceNormalCurveValue, NURBSCurveValue)

class NURBSSurfaceNormalCurveValue : public NURBSCurveValue
{
public:
	NURBSSurfaceNormalCurve* curve;

	ScripterExport NURBSSurfaceNormalCurveValue();
	ScripterExport NURBSSurfaceNormalCurveValue(NURBSSurfaceNormalCurve* pt);
	static ScripterExport NURBSSurfaceNormalCurveValue* intern(NURBSSurfaceNormalCurve* pt);
	ScripterExport ~NURBSSurfaceNormalCurveValue() { if (!in_set) delete curve; }

				classof_methods(NURBSSurfaceNormalCurveValue, NURBSCurveValue);
	void		collect() { delete this; }
	ScripterExport void		sprin1(CharStream* s);
	
	// operations
#include "defimpfn.h"

	// built-in property accessors
	def_property ( parent );
	def_property ( parentID );
	def_property ( distance );

	NURBSCurve*		to_nurbscurve() { return curve; }
	NURBSObject*	to_nurbsobject() { return curve; }
};

/* --------------- wrapper for NURBSIsoCurve ----------------------- */

applyable_class_s (NURBSSurfaceEdgeCurveValue, NURBSCurveValue)

class NURBSSurfaceEdgeCurveValue : public NURBSCurveValue
{
public:
	NURBSSurfaceEdgeCurve* curve;

	ScripterExport NURBSSurfaceEdgeCurveValue();
	ScripterExport NURBSSurfaceEdgeCurveValue(NURBSSurfaceEdgeCurve* c);
	static ScripterExport NURBSSurfaceEdgeCurveValue* intern(NURBSSurfaceEdgeCurve* c);
	ScripterExport ~NURBSSurfaceEdgeCurveValue() { if (!in_set) delete curve; }

				classof_methods(NURBSSurfaceEdgeCurveValue, NURBSCurveValue);
	void		collect() { delete this; }
	ScripterExport void		sprin1(CharStream* s);
	
	// operations
#include "defimpfn.h"

	// built-in property accessors
	def_property ( parent );
	def_property ( parentID );
	def_property ( seed );

	NURBSCurve*		to_nurbscurve() { return curve; }
	NURBSObject*	to_nurbsobject() { return curve; }
};

/* --------------- wrapper for NURBSTextureSurfaceValue ----------------------- */

applyable_class (NURBSTextureSurfaceValue)

class NURBSTextureSurfaceValue : public Value
{
public:
	NURBSTextureSurface	surface;		// surface texture

	ScripterExport NURBSTextureSurfaceValue();
	ScripterExport NURBSTextureSurfaceValue(NURBSTextureSurface& surf);

				classof_methods(NURBSTextureSurfaceValue, Value);
	void		collect() { delete this; }
	ScripterExport void		sprin1(CharStream* s);
#	define		is_nurbstexturesurface(p) ((p)->tag == class_tag(NURBSTextureSurfaceValue))
	
	// operations
#include "defimpfn.h"
	def_generic ( getPoint,		"getPoint" );
	def_generic ( setPoint,		"setPoint" );

	// built-in property accessors
	def_property ( type );
	def_property ( numPoints );
	def_prop_getter ( numUPoints );
	def_prop_getter ( numVPoints );
	def_property ( parent );
	def_property ( parentID );

	NURBSTextureSurface*	to_nurbstexturesurface() { return &surface; }
};

/* --------------- base class for NURBSSurface ----------------------- */

class NURBSSurfaceValueClass : public ValueMetaClass  // visible_class_s (NURBSSurfaceValue)
{
	public:	
				NURBSSurfaceValueClass(TCHAR* name) : ValueMetaClass (name) { }
	Value*		classOf_vf(Value** arg_list, int count) { return class_tag(NURBSObjectValue); }
	Value*		superClassOf_vf(Value** arg_list, int count) { return NURBSObjectValue_class.classOf_vf(NULL, 0);}
	void		collect() { delete this; }
	Class_ID	get_max_class_id() { return EDITABLE_SURF_CLASS_ID; }
};
extern ScripterExport NURBSSurfaceValueClass NURBSSurfaceValue_class;

class NURBSSurfaceValue : public NURBSObjectValue
{
public:
	void		common_surface_params(Value** arg_list, int count);
				classof_methods(NURBSSurfaceValue, NURBSObjectValue);
	void		collect() { delete this; }

	// operations
#include "defimpfn.h"
	def_generic ( evalPos,			"evalPos" );
	def_generic ( evalUTangent,		"evalUTangent" );
	def_generic ( evalVTangent,		"evalVTangent" );
	def_generic ( setTiling,		"setTiling" );
	def_generic ( getTiling,		"getTiling" );
	def_generic ( setTilingOffset,	"setTilingOffset" );
	def_generic ( getTilingOffset,	"getTilingOffset" );
	def_generic ( setTextureUVs,	"setTextureUVs" );
	def_generic ( getTextureUVs,	"getTextureUVs" );
	def_generic ( setGenerateUVs,	"setGenerateUVs" );
	def_generic ( getGenerateUVs,	"getGenerateUVs" );
	def_generic ( setTextureSurface, "setTextureSurface" );
	def_generic ( getTextureSurface, "getTextureSurface" );
	def_generic ( getProdTess,		"getProdTess" );
	def_generic ( setProdTess,		"setProdTess" );
	def_generic ( getViewTess,		"getViewTess" );
	def_generic ( setViewTess,		"setViewTess" );
	def_generic ( clearViewTess,	"clearViewTess" );
	def_generic ( clearProdTess,	"clearProdTess" );

	// built-in property accessors
	def_property ( renderable );
	def_property ( flipNormals );
	def_property ( generateUVs1 );
	def_property ( generateUVs2 );
	def_property ( textureSurface1 );
	def_property ( textureSurface2 );
	def_property ( matID );
	def_prop_getter ( closedInU );
	def_prop_getter ( closedInV );
	def_prop_getter ( uParameterRangeMin );
	def_prop_getter ( vParameterRangeMin );
	def_prop_getter ( uParameterRangeMax );
	def_prop_getter ( vParameterRangeMax );
	def_prop_getter ( numChannels );
};

/* --------------- wrapper for NURBSCVSurface ----------------------- */

applyable_class_s (NURBSCVSurfaceValue, NURBSSurfaceValue)

class NURBSCVSurfaceValue : public NURBSSurfaceValue
{
public:
	NURBSCVSurface* surface;

	ScripterExport NURBSCVSurfaceValue();
	ScripterExport NURBSCVSurfaceValue(NURBSCVSurface* pt);
	static ScripterExport NURBSCVSurfaceValue* intern(NURBSCVSurface* pt);
	ScripterExport ~NURBSCVSurfaceValue() { if (!in_set) delete surface; }

				classof_methods(NURBSCVSurfaceValue, NURBSSurfaceValue);
	void		collect() { delete this; }
	ScripterExport void		sprin1(CharStream* s);
	
	// operations
#include "defimpfn.h"
	def_generic ( closeU,	"closeU" );
	def_generic ( closeV,	"closeV" );
	def_generic ( getUKnot,	"getUKnot" );
	def_generic ( getVKnot,	"getVKnot" );
	def_generic ( setUKnot,	"setUKnot" );
	def_generic ( setVKnot,	"setVKnot" );
	def_generic ( getCV,	"getCV" );
	def_generic ( setCV,	"setCV" );
	def_generic ( refineU,	"refineU" );
	def_generic ( refineV,	"refineV" );
	def_generic ( refine,	"refine" );
	def_generic ( reparameterize, "reparameterize" );

	// built-in property accessors
	def_property ( uOrder );
	def_property ( vOrder );
	def_property ( numUKnots );
	def_property ( numVKnots );
	def_property ( numCVs );
	def_property ( transform );
	def_property ( rigid );
	def_property ( autoParam );
	def_prop_getter ( uEdgesOverlap );
	def_prop_getter ( vEdgesOverlap );

	NURBSSurface*	to_nurbssurface() { return surface; }
	NURBSObject*	to_nurbsobject() { return surface; }
};

/* --------------- wrapper for NURBSPointSurface ----------------------- */

applyable_class_s (NURBSPointSurfaceValue, NURBSSurfaceValue)

class NURBSPointSurfaceValue : public NURBSSurfaceValue
{
public:
	NURBSPointSurface* surface;

	ScripterExport NURBSPointSurfaceValue();
	ScripterExport NURBSPointSurfaceValue(NURBSPointSurface* pt);
	static ScripterExport NURBSPointSurfaceValue* intern(NURBSPointSurface* pt);
	ScripterExport ~NURBSPointSurfaceValue() { if (!in_set) delete surface; }

				classof_methods(NURBSPointSurfaceValue, NURBSSurfaceValue);
	void		collect() { delete this; }
	ScripterExport void		sprin1(CharStream* s);
	
	// operations
#include "defimpfn.h"
	def_generic ( closeU,	"closeU" );
	def_generic ( closeV,	"closeV" );
	def_generic ( getPoint,	"getPoint" );
	def_generic ( setPoint,	"setPoint" );
	def_generic ( refineU,	"refineU" );
	def_generic ( refineV,	"refineV" );
	def_generic ( refine,	"refine" );

	// built-in property accessors
	def_property ( numPoints );
	def_property ( transform );

	NURBSSurface*	to_nurbssurface() { return surface; }
	NURBSObject*	to_nurbsobject() { return surface; }
};

/* --------------- wrapper for NURBSBlendSurface ----------------------- */

applyable_class_s (NURBSBlendSurfaceValue, NURBSSurfaceValue)

class NURBSBlendSurfaceValue : public NURBSSurfaceValue
{
public:
	NURBSBlendSurface* surface;

	ScripterExport NURBSBlendSurfaceValue();
	ScripterExport NURBSBlendSurfaceValue(NURBSBlendSurface* pt);
	static ScripterExport NURBSBlendSurfaceValue* intern(NURBSBlendSurface* pt);
	ScripterExport ~NURBSBlendSurfaceValue() { if (!in_set) delete surface; }

				classof_methods(NURBSBlendSurfaceValue, NURBSSurfaceValue);
	void		collect() { delete this; }
	ScripterExport void		sprin1(CharStream* s);
	
	// operations
#include "defimpfn.h"

	// built-in property accessors
	def_property ( parent1 );
	def_property ( parent1ID );
	def_property ( parent2ID );
	def_property ( parent2 );
	def_property ( edge1 );
	def_property ( edge2 );
	def_property ( flip1 );
	def_property ( flip2 );
	def_property ( tension1 );
	def_property ( tension2 );
	def_property ( curveStartPoint1 );
	def_property ( curveStartPoint2 );

	NURBSSurface*	to_nurbssurface() { return surface; }
	NURBSObject*	to_nurbsobject() { return surface; }
};

/* --------------- wrapper for NURBSNBlendSurface ----------------------- */

applyable_class_s (NURBSNBlendSurfaceValue, NURBSSurfaceValue)

class NURBSNBlendSurfaceValue : public NURBSSurfaceValue
{
public:
	NURBSNBlendSurface* surface;

	ScripterExport NURBSNBlendSurfaceValue();
	ScripterExport NURBSNBlendSurfaceValue(NURBSNBlendSurface* pt);
	static ScripterExport NURBSNBlendSurfaceValue* intern(NURBSNBlendSurface* pt);
	ScripterExport ~NURBSNBlendSurfaceValue() { if (!in_set) delete surface; }

				classof_methods(NURBSNBlendSurfaceValue, NURBSSurfaceValue);
	void		collect() { delete this; }
	ScripterExport void		sprin1(CharStream* s);
	
	// operations
#include "defimpfn.h"

	def_generic ( setParent,	"setParent" );
	def_generic ( getParent,	"getParent" );
	def_generic ( setParentID,	"setParentID" );
	def_generic ( getParentID,	"getParentID" );
	def_generic ( setEdge,		"setEdge" );
	def_generic ( getEdge,		"getEdge" );

	// built-in property accessors

	NURBSSurface*	to_nurbssurface() { return surface; }
	NURBSObject*	to_nurbsobject() { return surface; }
};

/* --------------- wrapper for NURBSMultiCurveTrimSurfaceValue ----------------------- */

applyable_class_s (NURBSMultiCurveTrimSurfaceValue, NURBSSurfaceValue)

class NURBSMultiCurveTrimSurfaceValue : public NURBSSurfaceValue
{
public:
	NURBSMultiCurveTrimSurface* surface;

	ScripterExport NURBSMultiCurveTrimSurfaceValue();
	ScripterExport NURBSMultiCurveTrimSurfaceValue(NURBSMultiCurveTrimSurface* pt);
	static ScripterExport NURBSMultiCurveTrimSurfaceValue* intern(NURBSMultiCurveTrimSurface* pt);
	ScripterExport ~NURBSMultiCurveTrimSurfaceValue() { if (!in_set) delete surface; }

				classof_methods(NURBSMultiCurveTrimSurfaceValue, NURBSSurfaceValue);
	void		collect() { delete this; }
	ScripterExport void		sprin1(CharStream* s);
	
	// operations
#include "defimpfn.h"

	def_generic ( setParent,		"setParent" );
	def_generic ( getParent,		"getParent" );
	def_generic ( setParentID,		"setParentID" );
	def_generic ( getParentID,		"getParentID" );
	def_generic ( appendCurve,		"appendCurve" );
	def_generic ( appendCurveByID,	"appendCurveByID" );

	// built-in property accessors
	def_property ( numCurves );
	def_property ( flipTrim );
	def_property ( surfaceParent );
	def_property ( surfaceParentID );

	NURBSSurface*	to_nurbssurface() { return surface; }
	NURBSObject*	to_nurbsobject() { return surface; }
};

/* --------------- wrapper for NURBSFilletSurfaceValue ----------------------- */

applyable_class_s (NURBSFilletSurfaceValue, NURBSSurfaceValue)

class NURBSFilletSurfaceValue : public NURBSSurfaceValue
{
public:
	NURBSFilletSurface* surface;

	ScripterExport NURBSFilletSurfaceValue();
	ScripterExport NURBSFilletSurfaceValue(NURBSFilletSurface* pt);
	static ScripterExport NURBSFilletSurfaceValue* intern(NURBSFilletSurface* pt);
	ScripterExport ~NURBSFilletSurfaceValue() { if (!in_set) delete surface; }

				classof_methods(NURBSFilletSurfaceValue, NURBSSurfaceValue);
	void		collect() { delete this; }
	ScripterExport void		sprin1(CharStream* s);
	
	// operations
#include "defimpfn.h"

	def_generic ( setParent,		"setParent" );
	def_generic ( getParent,		"getParent" );
	def_generic ( setParentID,		"setParentID" );
	def_generic ( getParentID,		"getParentID" );
	def_generic ( setSeed,			"setSeed" );
	def_generic ( getSeed,			"getSeed" );
	def_generic ( getRadius,		"getRadius" );
	def_generic ( setRadius,		"setRadius" );
	def_generic ( getTrimSurface,	"getTrimSurface" );
	def_generic ( setTrimSurface,	"setTrimSurface" );
	def_generic ( getFlipTrim,		"getFlipTrim" );
	def_generic ( setFlipTrim,		"setFlipTrim" );

	// built-in property accessors
	def_property ( cubic );

	NURBSSurface*	to_nurbssurface() { return surface; }
	NURBSObject*	to_nurbsobject() { return surface; }
};

/* --------------- wrapper for NURBSOffsetSurface ----------------------- */

applyable_class_s (NURBSOffsetSurfaceValue, NURBSSurfaceValue)

class NURBSOffsetSurfaceValue : public NURBSSurfaceValue
{
public:
	NURBSOffsetSurface* surface;

	ScripterExport NURBSOffsetSurfaceValue();
	ScripterExport NURBSOffsetSurfaceValue(NURBSOffsetSurface* pt);
	static ScripterExport NURBSOffsetSurfaceValue* intern(NURBSOffsetSurface* pt);
	ScripterExport ~NURBSOffsetSurfaceValue() { if (!in_set) delete surface; }

				classof_methods(NURBSOffsetSurfaceValue, NURBSSurfaceValue);
	void		collect() { delete this; }
	ScripterExport void		sprin1(CharStream* s);
	
	// operations
#include "defimpfn.h"

	// built-in property accessors
	def_property ( parent );
	def_property ( parentID );
	def_property ( distance );

	NURBSSurface*	to_nurbssurface() { return surface; }
	NURBSObject*	to_nurbsobject() { return surface; }
};

/* --------------- wrapper for NURBSXFormSurface ----------------------- */

applyable_class_s (NURBSXFormSurfaceValue, NURBSSurfaceValue)

class NURBSXFormSurfaceValue : public NURBSSurfaceValue
{
public:
	NURBSXFormSurface* surface;

	ScripterExport NURBSXFormSurfaceValue();
	ScripterExport NURBSXFormSurfaceValue(NURBSXFormSurface* pt);
	static ScripterExport NURBSXFormSurfaceValue* intern(NURBSXFormSurface* pt);
	ScripterExport ~NURBSXFormSurfaceValue() { if (!in_set) delete surface; }

				classof_methods(NURBSXFormSurfaceValue, NURBSSurfaceValue);
	void		collect() { delete this; }
	ScripterExport void		sprin1(CharStream* s);
	
	// operations
#include "defimpfn.h"

	// built-in property accessors
	def_property ( parent );
	def_property ( parentID );
	def_property ( transform );

	NURBSSurface*	to_nurbssurface() { return surface; }
	NURBSObject*	to_nurbsobject() { return surface; }
};

/* --------------- wrapper for NURBSMirrorSurface ----------------------- */

applyable_class_s (NURBSMirrorSurfaceValue, NURBSSurfaceValue)

class NURBSMirrorSurfaceValue : public NURBSSurfaceValue
{
public:
	NURBSMirrorSurface* surface;

	ScripterExport NURBSMirrorSurfaceValue();
	ScripterExport NURBSMirrorSurfaceValue(NURBSMirrorSurface* pt);
	static ScripterExport NURBSMirrorSurfaceValue* intern(NURBSMirrorSurface* pt);
	ScripterExport ~NURBSMirrorSurfaceValue() { if (!in_set) delete surface; }

				classof_methods(NURBSMirrorSurfaceValue, NURBSSurfaceValue);
	void		collect() { delete this; }
	ScripterExport void		sprin1(CharStream* s);
	
	// operations
#include "defimpfn.h"

	// built-in property accessors
	def_property ( parent );
	def_property ( parentID );
	def_property ( axis );
	def_property ( distance );
	def_property ( transform );

	NURBSSurface*	to_nurbssurface() { return surface; }
	NURBSObject*	to_nurbsobject() { return surface; }
};

/* --------------- wrapper for NURBSRuledSurface ----------------------- */

applyable_class_s (NURBSRuledSurfaceValue, NURBSSurfaceValue)

class NURBSRuledSurfaceValue : public NURBSSurfaceValue
{
public:
	NURBSRuledSurface* surface;

	ScripterExport NURBSRuledSurfaceValue();
	ScripterExport NURBSRuledSurfaceValue(NURBSRuledSurface* pt);
	static ScripterExport NURBSRuledSurfaceValue* intern(NURBSRuledSurface* pt);
	ScripterExport ~NURBSRuledSurfaceValue() { if (!in_set) delete surface; }

				classof_methods(NURBSRuledSurfaceValue, NURBSSurfaceValue);
	void		collect() { delete this; }
	ScripterExport void		sprin1(CharStream* s);
	
	// operations
#include "defimpfn.h"

	// built-in property accessors
	def_property ( parent1 );
	def_property ( parent1ID );
	def_property ( parent2 );
	def_property ( parent2ID );
	def_property ( flip1 );
	def_property ( flip2 );
	def_property ( curveStartPoint1 );
	def_property ( curveStartPoint2 );

	NURBSSurface*	to_nurbssurface() { return surface; }
	NURBSObject*	to_nurbsobject() { return surface; }
};

/* --------------- wrapper for NURBSULoftSurface ----------------------- */

applyable_class_s (NURBSULoftSurfaceValue, NURBSSurfaceValue)

class NURBSULoftSurfaceValue : public NURBSSurfaceValue
{
public:
	NURBSULoftSurface* surface;

	ScripterExport NURBSULoftSurfaceValue();
	ScripterExport NURBSULoftSurfaceValue(NURBSULoftSurface* pt);
	static ScripterExport NURBSULoftSurfaceValue* intern(NURBSULoftSurface* pt);
	ScripterExport ~NURBSULoftSurfaceValue() { if (!in_set) delete surface; }

				classof_methods(NURBSULoftSurfaceValue, NURBSSurfaceValue);
	void		collect() { delete this; }
	ScripterExport void		sprin1(CharStream* s);
	
	// operations
#include "defimpfn.h"
	def_generic ( appendCurve,		"appendCurve" );
	def_generic ( appendCurveByID,	"appendCurveByID" );
	def_generic ( getCurve,			"getCurve" );
	def_generic ( getCurveID,		"getCurveID" );
	def_generic ( setCurve,			"setCurve" );
	def_generic ( setCurveByID,		"setCurveByID" );
	def_generic ( getFlip,			"getFlip" );
	def_generic ( setFlip,			"setFlip" );

	// built-in property accessors
	def_property ( numCurves );

	NURBSSurface*	to_nurbssurface() { return surface; }
	NURBSObject*	to_nurbsobject() { return surface; }
};

/* --------------- wrapper for NURBSUVLoftSurface ----------------------- */

applyable_class_s (NURBSUVLoftSurfaceValue, NURBSSurfaceValue)

class NURBSUVLoftSurfaceValue : public NURBSSurfaceValue
{
public:
	NURBSUVLoftSurface* surface;

	ScripterExport NURBSUVLoftSurfaceValue();
	ScripterExport NURBSUVLoftSurfaceValue(NURBSUVLoftSurface* pt);
	static ScripterExport NURBSUVLoftSurfaceValue* intern(NURBSUVLoftSurface* pt);
	ScripterExport ~NURBSUVLoftSurfaceValue() { if (!in_set) delete surface; }

				classof_methods(NURBSUVLoftSurfaceValue, NURBSSurfaceValue);
	void		collect() { delete this; }
	ScripterExport void		sprin1(CharStream* s);
	
	// operations
#include "defimpfn.h"
	def_generic ( appendUCurve,		"appendCurve" );
	def_generic ( appendUCurveByID,	"appendCurveByID" );
	def_generic ( getUCurve,		"getCurve" );
	def_generic ( getUCurveID,		"getCurveID" );
	def_generic ( setUCurve,		"setCurve" );
	def_generic ( setUCurveByID,	"setCurveByID" );

	def_generic ( appendVCurve,		"appendCurve" );
	def_generic ( appendVCurveByID,	"appendCurveByID" );
	def_generic ( getVCurve,		"getCurve" );
	def_generic ( getVCurveID,		"getCurveID" );
	def_generic ( setVCurve,		"setCurve" );
	def_generic ( setVCurveByID,	"setCurveByID" );

	// built-in property accessors
	def_property ( numUCurves );
	def_property ( numVCurves );

	NURBSSurface*	to_nurbssurface() { return surface; }
	NURBSObject*	to_nurbsobject() { return surface; }
};

/* --------------- wrapper for NURBSExtrudeSurface ----------------------- */

applyable_class_s (NURBSExtrudeSurfaceValue, NURBSSurfaceValue)

class NURBSExtrudeSurfaceValue : public NURBSSurfaceValue
{
public:
	NURBSExtrudeSurface* surface;

	ScripterExport NURBSExtrudeSurfaceValue();
	ScripterExport NURBSExtrudeSurfaceValue(NURBSExtrudeSurface* pt);
	static ScripterExport NURBSExtrudeSurfaceValue* intern(NURBSExtrudeSurface* pt);
	ScripterExport ~NURBSExtrudeSurfaceValue() { if (!in_set) delete surface; }

				classof_methods(NURBSExtrudeSurfaceValue, NURBSSurfaceValue);
	void		collect() { delete this; }
	ScripterExport void		sprin1(CharStream* s);
	
	// operations
#include "defimpfn.h"

	// built-in property accessors
	def_property ( parent );
	def_property ( parentID );
	def_property ( axisTM );
	def_property ( distance );
	def_property ( curveStartPoint );

	NURBSSurface*	to_nurbssurface() { return surface; }
	NURBSObject*	to_nurbsobject() { return surface; }
};

/* --------------- wrapper for NURBSLatheSurface ----------------------- */

applyable_class_s (NURBSLatheSurfaceValue, NURBSSurfaceValue)

class NURBSLatheSurfaceValue : public NURBSSurfaceValue
{
public:
	NURBSLatheSurface* surface;

	ScripterExport NURBSLatheSurfaceValue();
	ScripterExport NURBSLatheSurfaceValue(NURBSLatheSurface* pt);
	static ScripterExport NURBSLatheSurfaceValue* intern(NURBSLatheSurface* pt);
	ScripterExport ~NURBSLatheSurfaceValue() { if (!in_set) delete surface; }

				classof_methods(NURBSLatheSurfaceValue, NURBSSurfaceValue);
	void		collect() { delete this; }
	ScripterExport void		sprin1(CharStream* s);
	
	// operations
#include "defimpfn.h"

	// built-in property accessors
	def_property ( parent );
	def_property ( parentID );
	def_property ( axisTM );
	def_property ( sweep );
	def_property ( curveStartPoint );

	NURBSSurface*	to_nurbssurface() { return surface; }
	NURBSObject*	to_nurbsobject() { return surface; }
};

/* --------------- wrapper for NURBSCapSurface ----------------------- */

applyable_class_s (NURBSCapSurfaceValue, NURBSSurfaceValue)

class NURBSCapSurfaceValue : public NURBSSurfaceValue
{
public:
	NURBSCapSurface* surface;

	ScripterExport NURBSCapSurfaceValue();
	ScripterExport NURBSCapSurfaceValue(NURBSCapSurface* pt);
	static ScripterExport NURBSCapSurfaceValue* intern(NURBSCapSurface* pt);
	ScripterExport ~NURBSCapSurfaceValue() { if (!in_set) delete surface; }

				classof_methods(NURBSCapSurfaceValue, NURBSSurfaceValue);
	void		collect() { delete this; }
	ScripterExport void		sprin1(CharStream* s);
	
	// operations
#include "defimpfn.h"

	// built-in property accessors
	def_property ( parent );
	def_property ( parentID );
	def_property ( edge );
	def_property ( curveStartPoint );

	NURBSSurface*	to_nurbssurface() { return surface; }
	NURBSObject*	to_nurbsobject() { return surface; }
};

/* --------------- wrapper for NURBS1RailSweepSurface ----------------------- */

applyable_class_s (NURBS1RailSweepSurfaceValue, NURBSSurfaceValue)

class NURBS1RailSweepSurfaceValue : public NURBSSurfaceValue
{
public:
	NURBS1RailSweepSurface* surface;

	ScripterExport NURBS1RailSweepSurfaceValue();
	ScripterExport NURBS1RailSweepSurfaceValue(NURBS1RailSweepSurface* pt);
	static ScripterExport NURBS1RailSweepSurfaceValue* intern(NURBS1RailSweepSurface* pt);
	ScripterExport ~NURBS1RailSweepSurfaceValue() { if (!in_set) delete surface; }

				classof_methods(NURBS1RailSweepSurfaceValue, NURBSSurfaceValue);
	void		collect() { delete this; }
	ScripterExport void		sprin1(CharStream* s);
	
	// operations
#include "defimpfn.h"
	def_generic ( appendCurve,		"appendCurve" );
	def_generic ( appendCurveByID,	"appendCurveByID" );
	def_generic ( getCurve,			"getCurve" );
	def_generic ( getCurveID,		"getCurveID" );
	def_generic ( setCurve,			"setCurve" );
	def_generic ( setCurveByID,		"setCurveByID" );
	def_generic ( getFlip,			"getFlip" );
	def_generic ( setFlip,			"setFlip" );
	def_generic ( getCurveStartPoint, "getCurveStartPoint" );
	def_generic ( setCurveStartPoint, "setCurveStartPoint" );

	// built-in property accessors
	def_property ( rail );
	def_property ( railID );
	def_property ( numCurves );
	def_property ( parallel );
	def_property ( axisTM );

	NURBSSurface*	to_nurbssurface() { return surface; }
	NURBSObject*	to_nurbsobject() { return surface; }
};
/* --------------- wrapper for NURBS2RailSweepSurface ----------------------- */

applyable_class_s (NURBS2RailSweepSurfaceValue, NURBSSurfaceValue)

class NURBS2RailSweepSurfaceValue : public NURBSSurfaceValue
{
public:
	NURBS2RailSweepSurface* surface;

	ScripterExport NURBS2RailSweepSurfaceValue();
	ScripterExport NURBS2RailSweepSurfaceValue(NURBS2RailSweepSurface* pt);
	static ScripterExport NURBS2RailSweepSurfaceValue* intern(NURBS2RailSweepSurface* pt);
	ScripterExport ~NURBS2RailSweepSurfaceValue() { if (!in_set) delete surface; }

				classof_methods(NURBS2RailSweepSurfaceValue, NURBSSurfaceValue);
	void		collect() { delete this; }
	ScripterExport void		sprin1(CharStream* s);
	
	// operations
#include "defimpfn.h"
	def_generic ( appendCurve,		"appendCurve" );
	def_generic ( appendCurveByID,	"appendCurveByID" );
	def_generic ( getCurve,			"getCurve" );
	def_generic ( getCurveID,		"getCurveID" );
	def_generic ( setCurve,			"setCurve" );
	def_generic ( setCurveByID,		"setCurveByID" );
	def_generic ( getFlip,			"getFlip" );
	def_generic ( setFlip,			"setFlip" );
	def_generic ( getCurveStartPoint, "getCurveStartPoint" );
	def_generic ( setCurveStartPoint, "setCurveStartPoint" );

	// built-in property accessors
	def_property ( rail1 );
	def_property ( rail1ID );
	def_property ( rail2 );
	def_property ( rail2ID );
	def_property ( numCurves );
	def_property ( parallel );

	NURBSSurface*	to_nurbssurface() { return surface; }
	NURBSObject*	to_nurbsobject() { return surface; }
};

/* --------------- wrapper for NURBSDisplay ----------------------- */

applyable_class (NURBSDisplayValue)

class NURBSDisplayValue : public Value
{
public:
	NURBSDisplay	display;		// surface texture

	ScripterExport NURBSDisplayValue();
	ScripterExport NURBSDisplayValue(NURBSDisplay& surf);

				classof_methods(NURBSDisplayValue, Value);
	void		collect() { delete this; }
	ScripterExport void		sprin1(CharStream* s);
#	define		is_nurbsdisplay(p) ((p)->tag == class_tag(NURBSDisplayValue))
	
	// operations
#include "defimpfn.h"

	// built-in property accessors
	def_property ( displayCurves );
	def_property ( displaySurfaces );
	def_property ( displayLattices );
	def_property ( displaySurfCVLattices );
	def_property ( displayCurveCVLattices );
	def_property ( displayDependents );
	def_property ( displayTrimming );
	def_property ( degradeOnMove );
	def_property ( displayShadedLattice );

	NURBSDisplay*	to_nurbsdisplay() { return &display; }
};

/* --------------- wrapper for NURBSSurfaceApproximation ----------------------- */

applyable_class (NURBSSurfaceApproximationValue)

class NURBSSurfaceApproximationValue : public Value
{
public:
	TessApprox	tess;		// surface approximation

	ScripterExport NURBSSurfaceApproximationValue();
	ScripterExport NURBSSurfaceApproximationValue(TessApprox& surf);

				classof_methods(NURBSSurfaceApproximationValue, Value);
	void		collect() { delete this; }
	ScripterExport void		sprin1(CharStream* s);
#	define		is_NURBSSurfaceApproximation(p) ((p)->tag == class_tag(NURBSSurfaceApproximationValue))
	
	// operations
#include "defimpfn.h"

	// built-in property accessors
	def_property ( config );
	def_property ( isoULines );
	def_property ( isoVLines );
	def_property ( meshUSteps );
	def_property ( meshVSteps );
	def_property ( meshApproxType );
	def_property ( spacialEdge );
	def_property ( curvatureAngle );
	def_property ( curvatureDistance );
	def_property ( viewDependent );

	TessApprox*	to_tessapprox() { return &tess; }
};

/* --------------- wrapper for NURBSTexturePoint ----------------------- */

applyable_class_s (NURBSTexturePointValue, NURBSObjectValue)

class NURBSTexturePointValue : public NURBSObjectValue
{
public:
	NURBSTexturePoint* point;

	ScripterExport NURBSTexturePointValue();
	ScripterExport NURBSTexturePointValue(Point2 pt);
	ScripterExport NURBSTexturePointValue(NURBSTexturePoint* pt);
	static ScripterExport NURBSTexturePointValue* intern(NURBSTexturePoint* pt);
	ScripterExport ~NURBSTexturePointValue() { if (!in_set) delete point; }

				classof_methods(NURBSTexturePointValue, NURBSObjectValue);
	void		collect() { delete this; }
	ScripterExport void		sprin1(CharStream* s);
	
	// operations
#include "defimpfn.h"
	// built-in property accessors
	def_property ( pos );

	def_generic ( setIndices,		"setIndices" );

	NURBSTexturePoint*	to_nurbstexturepoint() { return point; }
	NURBSObject*		to_nurbsobject() { return point; }
};

/* --------------- wrapper for NURBSSet ----------------------- */

applyable_class (NURBSSetValue)

class NURBSSetValue : public Value
{
public:
	NURBSSet set;							// wrapped NURBSet

	ScripterExport NURBSSetValue();
	ScripterExport NURBSSetValue(NURBSSet& set);

				classof_methods(NURBSSetValue, Value);
	void		collect() { delete this; }
	ScripterExport void		sprin1(CharStream* s);
#	define		is_nurbsset(p) ((p)->tag == class_tag(NURBSSetValue))
	NURBSObject* sel_index_to_obj(int i);

	// operations
#include "defimpfn.h"
	def_generic ( getObject,		"getObject" );
	def_generic ( setObject,		"setObject" );
	def_generic ( appendObject,		"appendObject" );
	def_generic ( removeObject,		"removeObject" );
	def_generic ( deleteObjects,	"deleteObjects" );
	def_generic ( disconnect,		"disconnect" );
	def_generic ( getProdTess,		"getProdTess" );
	def_generic ( setProdTess,		"setProdTess" );
	def_generic ( getViewTess,		"getViewTess" );
	def_generic ( setViewTess,		"setViewTess" );
	def_generic ( clearViewTess,	"clearViewTess" );
	def_generic ( clearProdTess,	"clearProdTess" );

	// built-in property accessors
	def_prop_getter ( numObjects );

	// tesselation properties
	def_property ( viewConfig );
	def_property ( viewIsoULines );
	def_property ( viewIsoVLines );
	def_property ( viewMeshUSteps );
	def_property ( viewMeshVSteps );
	def_property ( viewMeshApproxType );
	def_property ( viewSpacialEdge );
	def_property ( viewCurvatureAngle );
	def_property ( viewCurvatureDistance );
	def_property ( viewViewDependent );
	def_property ( renderConfig );
	def_property ( renderIsoULines );
	def_property ( renderIsoVLines );
	def_property ( renderMeshUSteps );
	def_property ( renderMeshVSteps );
	def_property ( renderMeshApproxType );
	def_property ( renderSpacialEdge );
	def_property ( renderCurvatureAngle );
	def_property ( renderCurvatureDistance );
	def_property ( renderViewDependent );
	def_property ( merge );
	def_property ( display );
	def_property ( viewApproximation );
	def_property ( renderApproximation );

	NURBSSet*	to_nurbsset() { return &set; }

	// add array protocol
	def_generic ( get,		"get" );
	def_generic ( put,		"put" );
	ScripterExport Value* map(node_map& m);

	def_prop_getter(count);
};

extern void check_nurbs_result(NURBSResult r);

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\MAX_cmds.h ===
/*	
 *		MAX_commands.h - defines all the invocable MAX UI commands - for the 'max' scripter construct
 *
 *			Copyright  John Wainwright 1996
 *
 */

#ifndef _H_MAX_COMMANDS
#define _H_MAX_COMMANDS

#include "maxcom.h"

 /* the commands... these are the command codes defined in "maxcom.h".  they MUST be in
 * alphabetical order */

	"accel pan",				MAXCOM_ACCEL_PAN,				0,
	"acthomegrid",				MAXCOM_ACTHOMEGRID,				MR_R2,
	"activate grid object",		MAXCOM_ACTGRIDOBJ ,				0,
	"activate home grid",		MAXCOM_ACTHOMEGRID,				0,
	"adaptive persp grid",		MAXCOM_ADAPTIVE_PERSP_GRID_TOGGLE,	0,
	"adaptive perspective grid toggle",	MAXCOM_ADAPTIVE_PERSP_GRID_TOGGLE,	MR_R2,
	"align",					MAXCOM_ALIGN,					0,
	"align camera",				MAXCOM_TOOLS_ALIGNCAMERA,		0,
	"align normals",			MAXCOM_ALIGNNORMALS,			0,
	"alignnormals",				MAXCOM_ALIGNNORMALS,			MR_R2,
	"angle snap toggle",		MAXCOM_ANGLE_SNAP_TOGGLE,		0,
	"apply ik",					MAXCOM_APPLY_IK,				0,
	"array",					MAXCOM_ARRAY,					0,
	"backface",					MAXCOM_BACKFACE,				MR_R2,
	"backface cull toggle",		MAXCOM_BACKFACE,				0,
	"background",				MAXCOM_BACKGROUND,				MR_R2,
	"background display toggle", MAXCOM_BACKGROUND,				0,
	"bind space warp mode",		MAXCOM_BINDWSM,					0,
	"bindwsm",					MAXCOM_BINDWSM,					MR_R2,
	"box mode",					MAXCOM_BOX_MODE,				MR_R2,
	"box mode selected",		MAXCOM_BOX_MODE,				0,
	"box mode toggle",			MAXCOM_BOX_TOGGLE,				0,
	"box toggle",				MAXCOM_BOX_TOGGLE,				MR_R2,
	"configure paths",			MAXCOM_CONFIGURE_PATHS,			0,
	"create mode",				MAXCOM_CREATE_MODE,				0,
	"customize UI",				MAXCOM_CUSTOMIZE_CUSTOMIZEUI,	0,
	"cycle select",				MAXCOM_CYCLE_SELECT_METHOD ,	0,
	"cycle sublevel",			MAXCOM_CYCLE_SUBLEVEL,			MR_R2,
	"cycle subobject level",	MAXCOM_CYCLE_SUBLEVEL,			0,
	"def lgt toggle",			MAXCOM_DEF_LGT_TOGGLE,			MR_R2,
	"default lighting toggle",	MAXCOM_DEF_LGT_TOGGLE,			0,
	"delete",					MAXCOM_EDIT_DELETE ,			0,
	"display floater",			MAXCOM_TOOLS_DISPLAYFLOATER,	0,
	"display mode",				MAXCOM_DISPLAY_MODE,			0,
	"dolly",					MAXCOM_DOLLY,					MR_R2,
	"dolly mode",				MAXCOM_DOLLY,					0,
	"drawing aids",				MAXCOM_DRAWINGAIDS,				0,
	"drawingaids",				MAXCOM_DRAWINGAIDS,				MR_R2,
	"fetch",					MAXCOM_FETCH,					0,
	"file archive",				MAXCOM_FILE_ARCHIVE,			0,
	"file export",				MAXCOM_FILE_EXPORT,				0,
	"file export selected",		MAXCOM_FILE_EXPORTSELECTED,		0,
	"file import",				MAXCOM_FILE_IMPORT,				0,
	"file insert tracks",		MAXCOM_FILE_INSERTTRACKS,		0,
	"file merge",				MAXCOM_FILE_MERGE,				0,
	"file new",					MAXCOM_FILE_NEW,				0,
	"file open",				MAXCOM_FILE_OPEN,				0,
	"file preferences",			MAXCOM_FILE_PREFERENCES,		0,
	"file replace",				MAXCOM_FILE_REPLACE,			0,
	"file save",				MAXCOM_FILE_SAVE,				0,
	"file save selected",		MAXCOM_FILE_SAVESELECTED,		0,
	"file saveas",				MAXCOM_FILE_SAVEAS,				0,
	"file summary",				MAXCOM_FILE_SUMMARYINFO,		0,
	"file xref object",			MAXCOM_FILE_XREFOBJECT,			0,
	"file xref scene",			MAXCOM_FILE_XREFSCENE,			0,
	"fov",						MAXCOM_FOV,	0,
	"freeze inv",				MAXCOM_FREEZE_INV,	0,
	"freeze selection",			MAXCOM_FREEZE_SELECTION,	0,
	"fullinteract",				MAXCOM_FULLINTERACT,	0,
	"grid nudge down",			MAXCOM_GRID_NUDGE_DOWN,	0,
	"grid nudge up",			MAXCOM_GRID_NUDGE_UP,	0,
	"grid toggle",				MAXCOM_GRID_TOGGLE,	0,
	"grids align",				MAXCOM_GRIDS_ALIGN,	0,
	"group attach",				MAXCOM_GROUP_ATTACH,	0,
	"group close",				MAXCOM_GROUP_CLOSE,	0,
	"group detach",				MAXCOM_GROUP_DETACH,	0,
	"group explode",			MAXCOM_GROUP_EXPLODE,	0,
	"group group",				MAXCOM_GROUP_GROUP,	0,
	"group open",				MAXCOM_GROUP_OPEN,	0,
	"group ungroup",			MAXCOM_GROUP_UNGROUP,	0,
	"help about",				MAXCOM_HELP_ABOUT,	0,
	"hide camera toggle",		MAXCOM_HIDE_CAMERA_TOGGLE,	0,
	"hide command panel toggle", MAXCOM_HIDE_CMD_PAN,	0,
	"hide floating toolbars toggle", MAXCOM_HIDE_FLOATERS,	0,
	"hide helper toggle",		MAXCOM_HIDE_HELPER_TOGGLE,	0,
	"hide inv",					MAXCOM_HIDE_INV,	0,
	"hide light toggle",		MAXCOM_HIDE_LIGHT_TOGGLE,	0,
	"hide main toolbar toggle",	MAXCOM_HIDE_MAIN_TB,	0,
	"hide object toggle",		MAXCOM_HIDE_OBJECT_TOGGLE,	0,
	"hide selection",			MAXCOM_HIDE_SELECTION,	0,
	"hide shape toggle",		MAXCOM_HIDE_SHAPE_TOGGLE,	0,
	"hide system toggle",		MAXCOM_HIDE_SYSTEM_TOGGLE,	0,
	"hide tab panel toggle",	MAXCOM_HIDE_SHELF,	0,
	"hide wsm toggle",			MAXCOM_HIDE_WSM_TOGGLE,	0,
	"hierarchy mode",			MAXCOM_HIERARCHY_MODE,	0,
	"hold",						MAXCOM_HOLD,	0,
	"ik terminator",			MAXCOM_IK_TERMINATOR,	0,
	"ipan",						MAXCOM_IPAN,	0,
	"izoom in",					MAXCOM_IZOOM_IN,	0,
	"izoom out",				MAXCOM_IZOOM_OUT,	0,
	"key mode",					MAXCOM_KEY_MODE,	0,
	"link",						MAXCOM_LINK,	0,
	"load custom UI",			MAXCOM_CUSTOMIZE_LOADCUI,	0,
	"lock UI layout",			MAXCOM_CUSTOMIZE_LOCKUILAYOUT,	0,
	"material browser",			MAXCOM_TOOLS_MTLMAPBROWSER,	0,
	"mirror",					MAXCOM_MIRROR,	0,
	"modify mode",				MAXCOM_MODIFY_MODE,	0,
	"motion mode",				MAXCOM_MOTION_MODE,	0,
	"move",						MAXCOM_MOVE,	0,
	"mtledit",					MAXCOM_MTLEDIT,	0,
	"next mod",					MAXCOM_NEXT_MOD,	0,
	"override",					MAXCOM_OVERRIDE,	0,
	"pancamera",				MAXCOM_PANCAMERA,	0,
	"panview",					MAXCOM_PANVIEW,	0,
	"percent snap toggle",		MAXCOM_PERCENT_SNAP_TOGGLE,	0,
	"persp",					MAXCOM_PERSP,	0,
	"place highlight",			MAXCOM_EDIT_PLACEHIGHLIGHT,	0,
	"prev mod",					MAXCOM_PREV_MOD,	0,
	"preview",					MAXCOM_PREVIEW,	0,
	"properties",				MAXCOM_PROPERTIES,	0,
	"quick render",				MAXCOM_QUICK_RENDER,	0,
	"redo",						MAXCOM_EDIT_REDO ,	0,
	"renamepreview",			MAXCOM_RENAMEPREVIEW,	0,
	"render last",				MAXCOM_RENDER_LAST,	0,
	"render scene",				MAXCOM_RENDER_SCENE,	0,
	"reset file",				MAXCOM_RESET_FILE,	0,
	"revert custom UI",			MAXCOM_CUSTOMIZE_REVERTCUI,	0,
	"rns",						MAXCOM_RNS,	0,
	"roll",						MAXCOM_ROLL,	0,
	"rotate",					MAXCOM_ROTATE,	0,
	"rotateview",				MAXCOM_ROTATEVIEW,	0,
	"safeframe toggle",			MAXCOM_SAFEFRAME_TOGGLE,	0,
	"save custom UI as",		MAXCOM_CUSTOMIZE_SAVECUIAS,	0,
	"saveplus",					MAXCOM_SAVEPLUS,	0,
	"scale",					MAXCOM_SCALE,	0,
	"scale cycle",				MAXCOM_SCALE_CYCLE,	0,
	"select",					MAXCOM_SELECT,	0,
	"select all",				MAXCOM_EDIT_SELECTALL ,	0,
	"select by color",			MAXCOM_SELECT_BY_COLOR,	0,
	"select child",				MAXCOM_SELECT_CHILD,	0,
	"select invert",			MAXCOM_EDIT_SELECTINVERT ,	0,
	"select none",				MAXCOM_EDIT_SELECTNONE ,	0,
	"select parent",			MAXCOM_SELECT_PARENT,	0,
	"selection floater",		MAXCOM_TOOLS_SELECTIONFLOATER,	0,
	"shade selected",			MAXCOM_SHADE_SELECTED,	0,
	"show last img",			MAXCOM_SHOW_LAST_IMG,	0,
	"showaxisicon",				MAXCOM_SHOWAXISICON,	0,
	"showhomegrid",				MAXCOM_SHOWHOMEGRID,	0,
	"snap toggle",				MAXCOM_SNAP_TOGGLE,	0,
	"snapshot",					MAXCOM_EDIT_SNAPSHOT,	0,
	"spacebar",					MAXCOM_SPACEBAR,	0,
	"spacing tool",				MAXCOM_TOOLS_SPACINGTOOL,	0,
	"spinsnap toggle",			MAXCOM_SPINSNAP_TOGGLE,	0,
	"subobject sel",			MAXCOM_SUBOBJECT_SEL,	0,
	"swap layouts",				MAXCOM_SWAP_LAYOUTS,	0,
	"texture correct",			MAXCOM_TEXTURE_CORRECT,	0,
	"time back",				MAXCOM_TIME_BACK,	MR_DISABLED,
	"time config",				MAXCOM_TIME_CONFIG,	0,
	"time end",					MAXCOM_TIME_END,	0,
	"time forward",				MAXCOM_TIME_FORWARD,	MR_DISABLED,
	"time play",				MAXCOM_TIME_PLAY,	0,
	"time start",				MAXCOM_TIME_START,	0,
	"toggle ik",				MAXCOM_TOGGLE_IK,	0,
	"toggle key mode",			MAXCOM_KEYMODE_TOGGLE,	0,
	"toggle keyboard shortcuts",MAXCOM_KBDSHORTCUT_TOGGLE,	0,
	"toggle sound",				MAXCOM_TOGGLE_SOUND,	0,
	"tool animmode",			MAXCOM_TOOL_ANIMMODE,	0,
	"tool center",				MAXCOM_TOOL_CENTER,	0,
	"tool dualplanes",			MAXCOM_TOOL_DUALPLANES,	0,
	"tool hlist",				MAXCOM_TOOL_HLIST,	0,
	"tool maximize",			MAXCOM_TOOL_MAXIMIZE,	0,
	"tool region toggle",		MAXCOM_TOOL_REGION_TOGGLE,	0,
	"tool x",					MAXCOM_TOOL_X,	0,
	"tool xy",					MAXCOM_TOOL_XY,	0,
	"tool y",					MAXCOM_TOOL_Y,	0,
	"tool z",					MAXCOM_TOOL_Z,	0,
	"tool zoom",				MAXCOM_TOOL_ZOOM,	0,
	"tool zoomall",				MAXCOM_TOOL_ZOOMALL,	0,
	"tool zoomextents",			MAXCOM_TOOL_ZOOMEXTENTS,	0,
	"tool zoomextents all",		MAXCOM_TOOL_ZOOMEXTENTS_ALL,	0,
	"tool zoomregion",			MAXCOM_TOOL_ZOOMREGION,	0,
	"trajectories",				MAXCOM_TRAJECTORIES,	0,
	"treeview",					MAXCOM_TREEVIEW,	0,
	"truck",					MAXCOM_TRUCK,	0,
	"tti",						MAXCOM_TTI,	0,
	"undo",						MAXCOM_EDIT_UNDO ,	0,
	"unfreeze all",				MAXCOM_UNFREEZE_ALL,	0,
	"unfreeze by hit",			MAXCOM_UNFREEZE_BY_HIT,	0,
	"unfreeze by name",			MAXCOM_UNFREEZE_BY_NAME,	0,
	"unhide all",				MAXCOM_UNHIDE_ALL,	0,
	"unhide by name",			MAXCOM_UNHIDE_BY_NAME,	0,
	"unitsetup",				MAXCOM_UNITSETUP,	0,
	"unlink",					MAXCOM_UNLINK,	0,
	"utility mode",				MAXCOM_UTILITY_MODE,	0,
	"videopost",				MAXCOM_VIDEOPOST,	0,
	"view file",				MAXCOM_VIEW_FILE,	0,
	"view redo",				MAXCOM_VIEW_REDO,	0,
	"viewpreview",				MAXCOM_VIEWPREVIEW,	0,
	"views redraw",				MAXCOM_VIEWS_REDRAW,	0,
	"views undo",				MAXCOM_VIEWS_UNDO,	0,
	"vpt back",					MAXCOM_VPT_BACK,	0,
	"vpt bottom",				MAXCOM_VPT_BOTTOM,	0,
	"vpt camera",				MAXCOM_VPT_CAMERA,	0,
	"vpt disable",				MAXCOM_VPT_DISABLE,	0,
	"vpt front",				MAXCOM_VPT_FRONT,	0,
	"vpt grid",					MAXCOM_VPT_GRID,	0,
	"vpt iso user",				MAXCOM_VPT_ISO_USER,	0,
	"vpt left",					MAXCOM_VPT_LEFT,	0,
	"vpt persp user",			MAXCOM_VPT_PERSP_USER,	0,
	"vpt right",				MAXCOM_VPT_RIGHT,	0,
	"vpt shape",				MAXCOM_VPT_SHAPE,	0,
	"vpt spot",					MAXCOM_VPT_SPOT,	0,
	"vpt tab",					MAXCOM_VPT_TAB,	0,
	"vpt top",					MAXCOM_VPT_TOP,	0,
	"vpt track",				MAXCOM_VPT_TRACK,	0,
	"vptconfig",				MAXCOM_VPTCONFIG,	0,
	"wire facet",				MAXCOM_WIRE_FACET,	0,
	"wire smooth",				MAXCOM_WIRE_SMOOTH,	0,
	"zoom in 2x",				MAXCOM_ZOOM_IN_2X,	0,
	"zoom in 2x all",			MAXCOM_ZOOM_IN_2X_ALL,	0,
	"zoom out 2x",				MAXCOM_ZOOM_OUT_2X,	0,
	"zoom out 2x all",			MAXCOM_ZOOM_OUT_2X_ALL,	0,
	"zoomext sel",				MAXCOM_ZOOMEXT_SEL,	0,
	"zoomext sel all",			MAXCOM_ZOOMEXT_SEL_ALL,	0,

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\Maxscrpt.h ===
/*		MAXScript.h - main include for MAXScript sources
 *
 *		Copyright (c) John Wainwright, 1996
 *		
 *
 */

#ifndef _H_MAXSCRIPT
#define _H_MAXSCRIPT

#define STRICT					// strict type-checking - conformance with MAX SDK libs
#define WIN32_LEAN_AND_MEAN		// trims win32 includes

#include <stdlib.h> 
#include <stdio.h>
#include <windows.h>
#include <float.h>

#include "Max.h"

/* utility defines */

#define END				NULL					// null varargs arg list terminator

class Value;
class CharStream;
class Rollout;
class MAXScriptException;
class MSPlugin;
class Struct;

#define MAXSCRIPT_UTILITY_CLASS_ID	Class_ID(0x4d64858, 0x16d1751d)
#define MAX_SCRIPT_DIR				_T("scripts")
#define SCRIPT_AUTOLOAD_DIR			_T("Startup\\")

#ifdef BLD_MAXSCRIPT
#	define ScripterExport __declspec( dllexport )
#else
#	define ScripterExport __declspec( dllimport )
#endif

// check whether we are UNICODE or Code page 0 (==> no mbcs code)
#ifdef _UNICODE
#	define	no_mb_chars		TRUE
#	define	bytelen(s)		(sizeof(wchar_t) * wcslen(s))
#else
#	define	no_mb_chars     (MB_CUR_MAX == 1)
#	define	bytelen(s)		strlen(s)
#endif

inline double EPS(double v) { return _isnan(v) ? (v) : fabs(v) < FLT_EPSILON ? 0.0 : (v); }  // small number round down for %g float printing

/* MAXScript-specific window messages */

#define MXS_ADD_ROLLOUT_PAGE		(WM_USER + 0x100)
#define MXS_DELETE_ROLLOUT_PAGE		(WM_USER + 0x101)
#define MXS_REDRAW_VIEWS			(WM_USER + 0x102)
#define MXS_EDIT_SCRIPT				(WM_USER + 0x103)
#define MXS_NEW_SCRIPT				(WM_USER + 0x104)
#define MXS_DISPLAY_BITMAP			(WM_USER + 0x105)
#define MXS_ERROR_MESSAGE_BOX		(WM_USER + 0x106)
#define MXS_PRINT_STRING			(WM_USER + 0x107)
#define MXS_LISTENER_EVAL			(WM_USER + 0x108)
#define MXS_MESSAGE_BOX				(WM_USER + 0x109)
#define MXS_INITIALIZE_MAXSCRIPT	(WM_USER + 0x10A)
#define MXS_KEYBOARD_INPUT			(WM_USER + 0x10B)
#define MXS_SHOW_SOURCE				(WM_USER + 0x10C)
#define MXS_TAKE_FOCUS				(WM_USER + 0x10D)
#define MXS_STOP_CREATING			(WM_USER + 0x10E)
#define MXS_CLOSE_DOWN				(WM_USER + 0x10F)
#define MXS_STOP_EDITING			(WM_USER + 0x110)

typedef struct			// LPARAM for MXS_MESSAGE_BOX contains a pointer to this structure
{
	TCHAR* title;
	TCHAR* message;
	BOOL beep;
	int flags;
	BOOL result;
} message_box_data;

/* thread-local storage struct decl & access macros */

typedef struct MAXScript_TLS MAXScript_TLS;
struct MAXScript_TLS
{
	MAXScript_TLS*	next;				/* links...							*/
	MAXScript_TLS*	prev;
	HANDLE			my_thread;			/* thread that owns this TLS struct	*/
	DWORD			my_thread_id;

#undef def_thread_local
#define def_thread_local(type, lcl, init_val) type lcl
#	include "thrdlcls.h"

};

#define thread_local(x)			(((MAXScript_TLS*)TlsGetValue(thread_locals_index))->x)

/* index, tls struct list globals */

extern ScripterExport int thread_locals_index;
extern int thread_id_index;
extern MAXScript_TLS* MAXScript_TLS_list;

#define needs_redraw_set()			thread_local(needs_redraw) = 1
#define needs_complete_redraw_set()	thread_local(needs_redraw) = 2
#define needs_redraw_clear()		thread_local(needs_redraw) = 0

#define MAXScript_time()	\
	(thread_local(use_time_context) ? thread_local(current_time) : MAXScript_interface->GetTime())

			   void alloc_thread_locals();
ScripterExport void init_thread_locals();
			   void free_thread_locals();

/* error handlers */

void out_of_memory();
void bad_delete();

/* arg count check & keyword arg accessors (assume conventional names for arg_list & count in using function) */

extern ScripterExport Value* _get_key_arg(Value** arg_list, int count, Value* key_name);
extern ScripterExport Value* _get_key_arg_or_default(Value** arg_list, int count, Value* key_name, Value* def);

#define key_arg(key)					_get_key_arg(arg_list, count, n_##key)
#define key_arg_or_default(key, def)	_get_key_arg_or_default(arg_list, count, n_##key##, def)
#define int_key_arg(key, var, def)		((var = _get_key_arg(arg_list, count, n_##key)) == &unsupplied ? def : var->to_int())
#define float_key_arg(key, var, def)	((var = _get_key_arg(arg_list, count, n_##key)) == &unsupplied ? def : var->to_float())
#define bool_key_arg(key, var, def)		((var = _get_key_arg(arg_list, count, n_##key)) == &unsupplied ? def : var->to_bool())

#define check_arg_count(fn, w, g)			if ((w) != (g)) throw ArgCountError (_T(#fn), w, g)
#define check_gen_arg_count(fn, w, g)		if ((w) != (g + 1)) throw ArgCountError (_T(#fn), w, g + 1)
#define check_arg_count_with_keys(fn, w, g) if (!(g == w || (g > w && arg_list[w] == &keyarg_marker))) throw ArgCountError (_T(#fn), w, g)
#define check_gen_arg_count_with_keys(fn, w, g) if (!(g == w || (g > w && arg_list[w-1] == &keyarg_marker))) throw ArgCountError (_T(#fn), w, g)
#define count_with_keys()					_count_with_keys(arg_list, count)

/* value local macros - for managing C local variable references to Value*'s for the collector - see Collectable.cpp */

#define one_value_local(n1)											\
	struct { int count; Value** link; Value* n1; } vl =				\
		{ 1, NULL, NULL };											\
	vl.link = thread_local(current_locals_frame);					\
	thread_local(current_locals_frame) = (Value**)&vl;
	
#define one_typed_value_local(n1)									\
	struct { int count; Value** link; n1; } vl =					\
		{ 1, NULL, NULL };											\
	vl.link = thread_local(current_locals_frame);					\
	thread_local(current_locals_frame) = (Value**)&vl;
	
#define two_value_locals(n1, n2)									\
	struct { int count; Value** link; Value *n1, *n2; } vl =		\
		{ 2, NULL, NULL, NULL };									\
	vl.link = thread_local(current_locals_frame);					\
	thread_local(current_locals_frame) = (Value**)&vl;
	
#define two_typed_value_locals(n1, n2)								\
	struct { int count; Value** link; n1; n2; } vl =				\
		{ 2, NULL, NULL, NULL };									\
	vl.link = thread_local(current_locals_frame);					\
	thread_local(current_locals_frame) = (Value**)&vl;
	
#define three_value_locals(n1, n2, n3)								\
	struct { int count; Value** link; Value *n1, *n2, *n3; } vl =	\
		{ 3, NULL, NULL, NULL, NULL };								\
	vl.link = thread_local(current_locals_frame);					\
	thread_local(current_locals_frame) = (Value**)&vl;
	
#define three_typed_value_locals(n1, n2, n3)						\
	struct { int count; Value** link; n1; n2; n3; } vl =			\
		{ 3, NULL, NULL, NULL, NULL };								\
	vl.link = thread_local(current_locals_frame);					\
	thread_local(current_locals_frame) = (Value**)&vl;
	
#define four_value_locals(n1, n2, n3, n4)								\
	struct { int count; Value** link; Value *n1, *n2, *n3, *n4; } vl =	\
		{ 4, NULL, NULL, NULL, NULL, NULL };							\
	vl.link = thread_local(current_locals_frame);						\
	thread_local(current_locals_frame) = (Value**)&vl;
	
#define four_typed_value_locals(n1, n2, n3, n4)						\
	struct { int count; Value** link; n1; n2; n3; n4; } vl =		\
		{ 4, NULL, NULL, NULL, NULL, NULL };						\
	vl.link = thread_local(current_locals_frame);					\
	thread_local(current_locals_frame) = (Value**)&vl;
	
#define five_value_locals(n1, n2, n3, n4, n5)								\
	struct { int count; Value** link; Value *n1, *n2, *n3, *n4, *n5; } vl =	\
		{ 5, NULL, NULL, NULL, NULL, NULL, NULL };						    \
	vl.link = thread_local(current_locals_frame);						    \
	thread_local(current_locals_frame) = (Value**)&vl;
	
#define five_typed_value_locals(n1, n2, n3, n4, n5)							\
	struct { int count; Value** link; n1; n2; n3; n4; n5; } vl =			\
		{ 5, NULL, NULL, NULL, NULL, NULL, NULL };						    \
	vl.link = thread_local(current_locals_frame);						    \
	thread_local(current_locals_frame) = (Value**)&vl;
	
#define six_value_locals(n1, n2, n3, n4, n5, n6)								 \
	struct { int count; Value** link; Value *n1, *n2, *n3, *n4, *n5, *n6; } vl = \
		{ 6, NULL, NULL, NULL, NULL, NULL, NULL, NULL };						 \
	vl.link = thread_local(current_locals_frame);								 \
	thread_local(current_locals_frame) = (Value**)&vl;
	
#define six_typed_value_locals(n1, n2, n3, n4, n5, n6)						\
	struct { int count; Value** link; n1; n2; n3; n4; n5; n6; } vl =		\
		{ 6, NULL, NULL, NULL, NULL, NULL, NULL, NULL };					\
	vl.link = thread_local(current_locals_frame);							\
	thread_local(current_locals_frame) = (Value**)&vl;
	
#define seven_value_locals(n1, n2, n3, n4, n5, n6, n7)								  \
	struct { int count; Value** link; Value *n1, *n2, *n3, *n4, *n5, *n6, *n7; } vl = \
		{ 7, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };						  \
	vl.link = thread_local(current_locals_frame);									  \
	thread_local(current_locals_frame) = (Value**)&vl;
	
#define seven_typed_value_locals(n1, n2, n3, n4, n5, n6, n7)				\
	struct { int count; Value** link; n1; n2; n3; n4; n5; n6; n7; } vl =	\
		{ 7, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };				\
	vl.link = thread_local(current_locals_frame);							\
	thread_local(current_locals_frame) = (Value**)&vl;
	
#define eight_value_locals(n1, n2, n3, n4, n5, n6, n7, n8)								   \
	struct { int count; Value** link; Value *n1, *n2, *n3, *n4, *n5, *n6, *n7, *n8; } vl = \
		{ 8, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };					   \
	vl.link = thread_local(current_locals_frame);										   \
	thread_local(current_locals_frame) = (Value**)&vl;
	
#define value_local_array(var, count) {								\
	var = &((Value**)_alloca(((count) + 2) * sizeof(Value*)))[2];	\
	memset(var, 0, (count) * sizeof(Value*));						\
	var[-2] = (Value*)(count);										\
	var[-1] = (Value*)thread_local(current_locals_frame);			\
	thread_local(current_locals_frame) = &var[-2]; }

#define pop_value_local_array(var)									\
	thread_local(current_locals_frame) = (Value**)var[-1];
	
#define value_temp_array(var, count)	{							\
	var = &((Value**)malloc(((count) + 2) * sizeof(Value*)))[2];	\
	memset(var, 0, (count) * sizeof(Value*));						\
	var[-2] = (Value*)(count);										\
	var[-1] = (Value*)thread_local(current_locals_frame);			\
	thread_local(current_locals_frame) = &var[-2];  }

#define realloc_value_temp_array(var, count, old_count)	{						\
	var = &((Value**)realloc(&var[-2], ((count) + 2) * sizeof(Value*)))[2];		\
	if ((count) > (old_count))													\
		memset(&var[(old_count)], 0, ((count) - (old_count)) * sizeof(Value*));	\
	var[-2] = (Value*)(count);													\
	thread_local(current_locals_frame) = &var[-2]; }

#define pop_value_temp_array(var)	{							\
	thread_local(current_locals_frame) = (Value**)var[-1];		\
	free(&var[-2]); }
	
#define return_value(r)	{										\
	thread_local(current_result) = r;							\
	thread_local(current_locals_frame) = vl.link;				\
	return r; }
	 
#define return_value_no_pop(r) {								\
	thread_local(current_result) = r;							\
	return r; }

#define return_protected(r) {									\
	thread_local(current_result) = r;							\
	return r; }

#define pop_value_locals()										\
	thread_local(current_locals_frame) = vl.link;

#define reset_locals_frame()									\
	thread_local(current_locals_frame) = (Value**)&vl;

#define reset_locals_array_frame(var)							\
	thread_local(current_locals_frame) = &var[-2]; 

#define clear_current_frames()									\
	thread_local(current_locals_frame) = NULL;					\
	thread_local(current_frame) = NULL;

#define save_current_frames()									\
	Value** _sclf = thread_local(current_locals_frame);			\
	Value** _scsf = thread_local(current_scan_frame);			\
	Value** _scf = thread_local(current_frame);
	
#define restore_current_frames()								\
	thread_local(current_locals_frame) = _sclf;					\
	thread_local(current_scan_frame) = _scsf;					\
	thread_local(current_frame) = _scf;

/* general utilities */

ScripterExport TCHAR* save_string(TCHAR* str);
TCHAR  wputch(HWND w, TCHAR* buf, TCHAR* bufp, const TCHAR c);					/* edit window output... */
TCHAR* wputs(HWND w, TCHAR* buf, TCHAR* bufp, const TCHAR *str);		
int    wprintf(HWND w, TCHAR* buf, TCHAR* bufp, const TCHAR *format, ...);
void   wflush(HWND w, TCHAR* buf, TCHAR* bufp);		
#define mputs	thread_local(current_stdout)->puts	/* current MAXScript stdout output... */
#define mprintf	thread_local(current_stdout)->printf
#define mflush	thread_local(current_stdout)->flush
extern TCHAR *GetString(int id);

class Rollout;
class HashTable;
ScripterExport void  install_utility_page(Rollout* rollout);

class Value;
typedef Value* (Value::*value_vf)(Value**, int);
typedef Value* (*value_cf)(Value**, int);
typedef Value* (Value::*getter_vf)(Value**, int);
typedef Value* (Value::*setter_vf)(Value**, int);
typedef Value* (*max_getter_cf)(ReferenceTarget*, Value*, TimeValue, Interval&);
typedef void   (*max_setter_cf)(ReferenceTarget*, Value*, TimeValue, Value*);

/* MAXScript signal flags */

#define INTERRUPT_EVAL		0x0001
#define EXIT_LISTENER		0x0002

extern ScripterExport Interface* MAXScript_interface;
extern ScripterExport int		MAXScript_signals;
extern ScripterExport BOOL		check_maxscript_interrupt;
extern ScripterExport void		escape_checker();
extern ScripterExport BOOL		MAXScript_detaching;
extern ScripterExport int		mxs_rand();
extern ScripterExport void		mxs_seed(int);
extern ScripterExport void		dlx_detaching(HINSTANCE hinstance);
extern ScripterExport void		define_system_global(TCHAR* name, Value* (*getter)(), Value* (*setter)(Value*));
extern ScripterExport void		define_struct_global(TCHAR* name, TCHAR* struct_name, Value* (*getter)(), Value* (*setter)(Value*));
extern ScripterExport HashTable* english_to_local;
extern ScripterExport HashTable* local_to_english;
extern ScripterExport BOOL		non_english_numerics;
extern ScripterExport void	    printable_name(TSTR& name);
extern ScripterExport void		show_source_pos();
extern ScripterExport void		show_listener();

extern ScripterExport void		init_MAXScript();
extern ScripterExport BOOL		MAXScript_running;
extern ScripterExport HWND		main_thread_window;
extern ScripterExport BOOL		progress_bar_up;
extern ScripterExport BOOL		trace_back_active;
extern ScripterExport BOOL		disable_trace_back;
typedef void (*utility_installer)(Rollout* ro);
extern ScripterExport void		set_utility_installer(utility_installer ui);
extern ScripterExport void		reset_utility_installer();
extern ScripterExport void		error_message_box(MAXScriptException& e, TCHAR* caption);
typedef Value* (*autocad_point_reader)(TCHAR* str);
extern ScripterExport void		set_autocad_point_reader(autocad_point_reader apr);

#define check_interrupts()	if (check_maxscript_interrupt) escape_checker(); if (MAXScript_signals) throw SignalException()

#define type_check(val, cl, where) if (val->tag != class_tag(cl)) throw TypeError (where, val, &cl##_class);

// macros for setting numeric printing to English locale and back again - all numeric output in MAXScript is English
#define set_english_numerics()						\
	TCHAR* locale;									\
	TCHAR slocale[256];								\
	if (non_english_numerics != NULL)				\
	{												\
		locale = setlocale(LC_NUMERIC, NULL);		\
		_tcsncpy(slocale, locale, sizeof(slocale));	\
		setlocale(LC_NUMERIC, "C");					\
	}

#define reset_numerics()							\
	if (non_english_numerics != NULL)				\
		setlocale(LC_NUMERIC, slocale);	

#include "Excepts.h"
#include "Value.h"
#include "Streams.h"
#include "SceneIO.h"
#include <IParamb2.h>

class HashTable;
class Listener;
extern ScripterExport HashTable* globals;
extern ScripterExport HashTable* persistents;
extern ScripterExport Listener*  the_listener;
extern ScripterExport HWND		  the_listener_window;
extern                HINSTANCE  hInstance;
extern ScripterExport void       listener_message(UINT iMsg, WPARAM wParam, LPARAM lParam, BOOL block_flag);

inline int _count_with_keys(Value** arg_list, int count)
{
	// compute # args before any key-args
	for (int i = 0; i < count; i++)
		if (arg_list[i] == (Value*)&keyarg_marker)
			return i;
	return count;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\MouseTool.h ===
/*	
 *		MouseTool.h - scriptable mouse CommandModes for MAX
 *
 *			Copyright  Autodesk, Inc, 1998.  John Wainwright.
 *
 */

#ifndef _H_MOUSETOOL
#define _H_MOUSETOOL

class MouseTool;
class MSPlugin;

// tool context local indexes - MUST match order in Parser::tool_def()
enum { cl_viewPoint, cl_worldPoint, cl_worldDist, cl_worldAngle, cl_gridPoint, cl_gridDist, cl_gridAngle, cl_nodeTM, cl_shift, cl_ctrl, cl_alt, cl_lbutton, cl_mbutton, cl_rbutton, };

/* --------- MouseTool command mode & callback classes ------------- */

class MouseToolCallBack : public MouseCallBack 
{
	public:
		MouseTool*	tool;
		IPoint2		last_mp;
		Point3		last_wp;
		Point3		last_cpp;

		MouseToolCallBack() {}
		int proc(HWND hwnd, int msg, int point, int flags, IPoint2 m);
		int mouse_proc(ViewExp *vpt, int msg, int point, int flags, IPoint2 m, Matrix3& mat, BOOL createMouseCallback = FALSE);
		void set_context_locals(ViewExp* vpx, int snap, int point, int flag, IPoint2 mp, Point3 cpp, Matrix3& mat);
};

#define MOUSE_TOOL_COMMAND	7364
#define CID_MOUSE_TOOL		CID_USER + 45237

class MouseToolCommandMode : public CommandMode 
{
public:
	MouseToolCallBack	proc;
	BOOL				active;
	TCHAR*				prompt;
	int					num_points;
	int					cmd_class;

	int Class() { return cmd_class; }
	int ID() { return CID_MOUSE_TOOL; }
	MouseCallBack *MouseProc(int *points) { *points = num_points; return &proc; }
	ChangeForegroundCallback *ChangeFGProc() { return NULL; }
	BOOL ChangeFG(CommandMode *oldMode) { return FALSE; }
	void EnterMode(); 
	void ExitMode();
};

/* ------------- MouseTool MAXScript value class -------------- */

visible_class (MouseTool)

class MouseTool : public Value
{
public:
	Value*		name;						// tool name
	HashTable*  local_scope;				// local name space	
	Value**		locals;						// local var array	
	Value**		local_inits;				//   "    "    "  init vals	
	int			local_count;				//   "    "  count	
	HashTable*	handlers;					// handler tables	
	short		flags;						// tool flags
	int			cmd_class;					// command mode class
	int			num_points;					// number of points
	Value*		prompt;						// staus line prompt if non-null
	BOOL		init_values;				// whether to init ctrl/local values on (re)open 
	BOOL		end_tool_mode;				// signals end of tool cmd mode
	MouseToolCommandMode cmdmode;			// my command mode
	// command mode locals...
	Value*		result;						// tool result
	Value*		snap_mode;					// #2D or #3D or #none
	Value*		point_num;					// point count
	MSPlugin*	plugin;						// current plugin under manip if non-NULL

				MouseTool(short iflags);
	void		init(Value* name, int local_count, Value** inits, HashTable* local_scope, HashTable* handlers);
			   ~MouseTool();

				classof_methods (MouseTool, Value);
	void		collect() { delete this; }
	void		gc_trace();
	ScripterExport void sprin1(CharStream* s);

	BOOL		call_event_handler(Value* handler, Value** arg_list, int count, BOOL enable_redraw = TRUE);
	void		init_locals();

	virtual	Value*	get_property(Value** arg_list, int count);
	virtual	Value*	set_property(Value** arg_list, int count);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\MSPlugIn.h ===
/*	
 *		MSPlugin.h - MAXScript scriptable plugins for MAX
 *
 *	 A typical scripted plugin is defined by 3 MAXScript classes:
 *
 *		MSPlugin			base mixin for all scripted MAX plug-in classes
 *							this class inherits from Value so it can live
 *							in the MAXScript garbage-collected heap.
 * 
 *		MSPluginGeomObject	scripted GeomObjects
 *		MSPluginModifier	scripted Modifiers
 *		MSPluginControl		scripted Controls
 *		MSPluginLight		scripted Lights
 *		MSPluginMtl			scripted Materials, etc...
 *
 *		MSGeomObjectXtnd
 *		MSModifierXtnd
 *		MSControlXtnd		... These are subclasses of the above MSPlugin classes that
 *							extend an existing class (specified in the extends: param).  
 *							Instances contain a delegate, a ref to an owned instance of 
 *							the class under extension and
 *							bounce all calls to it (delegation) then specialize UI calls 
 *							to allow UI replacement or extra rollouts for the delegate.  
 *
 *      MSPluginClass		MAXClass specialization whose instances represent scripted
 *							plugin classes, contains all the definition-level stuff
 *							and a pointer to the MSPluginDesc for the class.
 *							It is applyable for scripted instance creation.  It is also 
 *							kept in a special 
 *							hashtable to enable repeated re-definition in the scripter,
 *							the same value is updated on each re-definition.
 *							This class inherits also from MAXClass and so lives in
 *							the MAXScript heap. 
 *
 *		MSPluginDesc		ClassDesc2 specialization for MSPlugin classes.
 *							Unlike most ClassDescs, many instances of this are
 *						    created, one per scripted plugin.
 *							Instances contain a pointer to the corresponding
 *							MSPluginClass instance from which info for the implementing
 *							the standard ClassDesc2 interface is derived.
 *
 *			Copyright  Autodesk, Inc, 1998.  John Wainwright.
 *
 */

#ifndef _H_MSPLUGIN
#define _H_MSPLUGIN

class MSPlugin;
class MSPluginDesc;
class MSPluginClass;
class MSAutoMParamDlg;
class MSAutoEParamDlg;

#include <iparamm2.h>
#include <simpmod.h>

// plugin context predefined local indexes - MUST match order in Parser::plugin_def()
enum { 
	pl_this, pl_version, pl_delegate						// common
};

enum { 
	pl_extent = pl_delegate + 1, pl_min, pl_max, pl_center   // for SimpleMods
};

enum { 
	pl_mesh = pl_delegate + 1								// for SimpleObjects 
};

typedef RefTargetHandle (*creator_fn)(MSPluginClass* pic, BOOL loading);
//extern void show_source_pos();

// parameter reference (used by subtex and submtl mechanism in scripted texmaps & mtls)
class ParamRef
{
public:
	BlockID	block_id;
	ParamID param_id;
	int		tabIndex;
	ParamRef(BlockID bid, ParamID pid, int index) { block_id = bid; param_id = pid; tabIndex = index; }
};

// ----------------------- MSPluginClass -----------------------
//	MAXClass specialization for scripted plug-in classes

visible_class (MSPluginClass)

class MSPluginClass : public MAXClass
{
public:
	Value*			class_name;		// UI-visible class name
	HINSTANCE		hInstance;		// owning module
	ClassDesc*		extend_cd;		// if extending, ClassDesc of class to extend
	creator_fn		obj_creator;	// obj maker for the appropriate MSPlugin subclass	
	HashTable*		local_scope;	// local name space	
	Value**			local_inits;	// local var init vals	
	int				local_count;	//   "    "  count	
	HashTable*		handlers;		// handler tables	
	Array*			rollouts;		// UI rollouts
	MouseTool*		create_tool;	// scripted creation tool if non-NULL
	Array*			pblock_defs;	// parameter block definition data from compiler (used to build the PB2 descs)
	Array*			loading_pblock_defs; // parameter block definition data for currently loading scene file (to permit old version schema migration)
	Tab<ParamBlockDesc2*> pbds;		// parameter block descriptors
	ReferenceTarget* alternate;		// any alternate UI object system-style during create mode
	Tab<ParamRef>	sub_texmaps;	// param references to any texmaps in pblocks in instances of this class in subobjno order
	Tab<ParamRef>	sub_mtls;		// param references to any mtls in pblocks in instances of this class in subobjno order
	int				version;		// plugin version (from version: param on def header)
	short			mpc_flags;		// flags	
	DWORD			rollup_state;	// initial rollup state

	static HashTable* msp_classes;	// table of existing scripted plugin classes to enable redefinition
	static MSPlugin* creating;		// object currently being created if non-NULL

					MSPluginClass(Value* name, MAXSuperClass* supcls, creator_fn cfn);
				   ~MSPluginClass();

	// definition and redefinition
	static MSPluginClass* intern(Value* name, MAXSuperClass* supcls, creator_fn cfn);
	void			init(int local_count, Value** inits, HashTable* local_scope, HashTable* handlers, Array* pblock_defs, Array* rollouts, MouseTool* create_tool);

	// MAXScript required
	BOOL			is_kind_of(ValueMetaClass* c) { return (c == class_tag(MSPluginClass)) ? 1 : Value::is_kind_of(c); }
#	define			is_msplugin_class(v) ((v)->tag == class_tag(MSPluginClass))
	void			gc_trace();
	void			collect() { delete this; }

	// from Value 
	Value*			apply(Value** arglist, int count);		// object creation by applying class object

	// local
	void			SetClassID(Value* cidv);
	void			SetExtension(Value* cls);
	void			SetVersion(Value* ver) { version = ver->to_int(); }
	void			StopEditing(int stop_flags = 0);
	void			RestartEditing();
	ParamType2		lookup_type(Value* name);
	Value*			call_handler(Value* handler, Value** arg_list, int count, TimeValue t, BOOL disable_on_error=FALSE);

	// alternate UI
	void			install_alternate(ReferenceTarget* ref);
	// schema migration
	void			build_paramblk_descs();
	void			redefine(MSPlugin* val, HashTable* old_locals, Array* old_pblock_defs);
	Array*			find_pblock_def(Value* name, Array* pblock_defs);
	// scene I/O
	static void		save_class_defs(ISave* isave);
	static IOResult load_class_def(ILoad* iload);
	static void		post_load();

	// ClassDesc delegates
	RefTargetHandle	Create(BOOL loading);
	const TCHAR*	ClassName() { return class_name->to_string(); }
	SClass_ID		SuperClassID() { return sclass_id; }
	Class_ID		ClassID() { return class_id; }
	const TCHAR* 	Category() { return category->to_string(); }
	const TCHAR*	InternalName() { return name->to_string(); }
	HINSTANCE		HInstance() { return hInstance; }
};

// plugin class flags
#define MPC_TEMPORARY			0x0001	// no classID: temporary, cannot be saved in a scene file, shouldn't be wired in to the scene anywhere
#define MPC_REDEFINITION		0x0002	// class redefinition under way
#define MPC_MS_CREATING			0x0004	// currently creating new object
#define MPC_MS_WAS_CREATING		0x0008	// MAXScript was creating during a redefinition
#define MPC_EDITING_IN_CP		0x0010	// currently editing obj in command panel
#define MPC_EDITING_IN_MTLEDT	0x0020	// currently editing obj in material editor
#define MPC_EDITING_IN_EFX		0x0040	// currently editing obj in render effects/environment editor
#define MPC_REPLACE_UI			0x0080	// for extending classes, scripted UI completely replaces delegates UI
#define MPC_INVISIBLE			0x0100	// doesn't show up in create panel buttons, useful for controlling dummies, etc.
#define MPC_SILENTERRORS		0x0200  // don't report errors
#define MPC_MAX_CREATING		0x0400  // in default MAX creation mode
#define MPC_ABORT_CREATE		0x0800  // plugin should abort MAX create mode on next GetMouseCreateCallback
#define MPC_LEVEL_6				0x1000  // level 6 plugin; supports full, stand-alone creatability

// for accessing keyword params in pblock_defs
#define key_parm(_key)	_get_key_param(keys, n_##_key)
extern Value* _get_key_param(Array* keys, Value* key_name);

// ----------------------- MSPluginDesc -----------------------
//	ClassDescs for scripted classes, created dynamically for each scripted class

class MSPluginDesc : public ClassDesc2
{
public:
	MSPluginClass*	pc;			// my MAXScript-side plugin class
	MSPlugin*		plugin;		// object under creation, MSPlugin interface
	RefTargetHandle base_obj;	//   "      "       "     base object interface

					MSPluginDesc(MSPluginClass* ipc) { pc = ipc; }

	// from ClassDesc
	int 			IsPublic();
	void*			Create(BOOL loading = FALSE) { return pc->Create(loading); }
	const TCHAR*	ClassName() { return pc->ClassName(); }
	SClass_ID		SuperClassID() { return pc->SuperClassID(); }
	Class_ID		ClassID() { return pc->ClassID(); }
	const TCHAR* 	Category() { return pc->Category(); }
	int 			BeginCreate(Interface *i);
	int 			EndCreate(Interface *i);
	void			ResetClassParams(BOOL fileReset);
	DWORD			InitialRollupPageState();
	// from ClassDesc2
	const TCHAR*	InternalName() { return pc->InternalName(); }
	HINSTANCE		HInstance() { return pc->HInstance(); }

	// local 
	void			StartTool(IObjCreate *iob);   // start up scripted create tool
	void			StopTool(IObjCreate *iob);   // stop scripted create tool
};

// ----------------------- MSPluginPBAccessor -----------------------
//	paramblock accessor topass gets & sets to scripted handlers

class MSPluginPBAccessor : public PBAccessor
{
	BlockID			bid;
	MSPluginClass*	pc;
public:
	MSPluginPBAccessor(MSPluginClass* ipc, BlockID id) { pc = ipc; bid = id; }
	void Set(PB2Value& v, ReferenceMaker* owner, ParamID id, int tabIndex, TimeValue t); // set from v
	void Get(PB2Value& v, ReferenceMaker* owner, ParamID id, int tabIndex, TimeValue t, Interval& valid); // set from v
	BOOL KeyFrameAtTime(ReferenceMaker* owner, ParamID id, int tabIndex, TimeValue t);
	Value* to_value(PB2Value& v, ParamDef& pd);
	void from_value(PB2Value& v, ParamDef& pd, Value* val);
};

// ----------------------- MSPlugin -----------------------
//	base mixin class for MAX-side scripted classes

#define MSP_LOADING		0x0001			// instance is currently being loaded from a scene
#define MSP_DISABLED	0x0002			// general disablement flag, used to diable plugin in case of handler errors, reset by redefinition
#define MSP_DELETED		0x0004			// I'm deleted in the MAX world

class MSPlugin : public Value
{
public:
	MSPluginClass*	pc;				// my class
	Value**			locals;			// local var array	
	short			flags;			// plugin flags	
	int				version;		// plugin version
	ReferenceTarget* ref;			// ReferenceTarget interface to me
	Tab<IParamBlock2*> pblocks;		// parameter blocks
	
					MSPlugin() { flags = 0; }
	virtual		   ~MSPlugin();
	void			init(MSPluginClass* pc);

	void			gc_trace();
	void			collect() { delete this; }

	void			DeleteThis();
	void			RefDeleted();

	// code management
	void			init_locals();
	Value*			call_handler(Value* handler, Value** arg_list, int count, TimeValue t, BOOL disable_on_error=FALSE);
	void			post_create(ReferenceTarget* me, BOOL loading);
	void			call_all_set_handlers();
	void			disable() { flags |= MSP_DISABLED; }
	void			enable() { flags &= ~MSP_DISABLED; }
	BOOL			enabled() { return !(flags & MSP_DISABLED); }

	// locals
	int				get_local_index(Value* prop);
	Value*			get_local(int index) { return locals[index]; }
	void			set_local(int index, Value* val) { locals[index] = val; }

	// block management
	IParamBlock2*	GetParamBlockByID(BlockID id);

	// UI 
	virtual HWND	AddRollupPage(HINSTANCE hInst, TCHAR *dlgTemplate, DLGPROC dlgProc, TCHAR *title, LPARAM param=0,DWORD flags=0)=0;
	virtual void	DeleteRollupPage(HWND hRollup)=0;
	virtual IRollupWindow* GetRollupWindow()=0;

	// factored ReferenceTarget stuff
	RefResult		NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, PartID& partID, RefMessage message);
	RefTargetHandle clone_from(MSPlugin* obj, ReferenceTarget* obj_as_ref, RemapDir& remap);

	// delegate access 
	virtual ReferenceTarget* get_delegate()=0;

	// I/O
	IOResult		Save(ISave *isave);
    IOResult		Load(ILoad *iload);
	void			post_load();
};

// used for in-memory instance migration when a scripted plugin class is redefined
class MSPluginValueMigrator : public ValueMapper
{
	MSPluginClass*	pc;
	HashTable*		old_locals;
	Array*			old_pblock_defs;
public:

	MSPluginValueMigrator(MSPluginClass* pc, HashTable* old_locals, Array* old_pblock_defs)
	{
		this->pc = pc;
		this->old_locals = old_locals;
		this->old_pblock_defs = old_pblock_defs;
	}

	void map(Value* val) 
	{ 
		if (((MSPlugin*)val)->pc == pc) 
			pc->redefine((MSPlugin*)val, old_locals, old_pblock_defs); 
	}
};

#define MSPLUGIN_CHUNK	0x0010

// ----------------------- MSPluginObject ----------------------

//	template for MSPlugin classes derived from Object
template <class TYPE>
class MSPluginObject : public MSPlugin, public TYPE
{
public:
	IObjParam*		ip;					// ip for any currently open command panel dialogs

	void			DeleteThis();

	// From MSPlugin
	HWND			AddRollupPage(HINSTANCE hInst, TCHAR *dlgTemplate, DLGPROC dlgProc, TCHAR *title, LPARAM param=0,DWORD flags=0);
	void			DeleteRollupPage(HWND hRollup);
	IRollupWindow* GetRollupWindow();
	ReferenceTarget* get_delegate() { return NULL; }  // no delegate 

	// From Animatable
	void			GetClassName(TSTR& s) { s = TSTR(pc->class_name->to_string()); }  
	Class_ID		ClassID() { return pc->class_id; }
	void			FreeCaches() { } 		
	int				NumSubs() { return pblocks.Count(); }  
	Animatable*		SubAnim(int i) { return pblocks[i]; }
	TSTR			SubAnimName(int i) { return pblocks[i]->GetLocalName(); }
	int				NumParamBlocks() { return pblocks.Count(); }
	IParamBlock2*	GetParamBlock(int i) { return pblocks[i]; }
	IParamBlock2*	GetParamBlockByID(BlockID id) { return MSPlugin::GetParamBlockByID(id); }
	void*			GetInterface(ULONG id) { if (id == I_MAXSCRIPTPLUGIN) return (MSPlugin*)this; else return NULL; }

	// From ReferenceMaker
	RefResult		NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, PartID& partID, RefMessage message) 
					{ 
						return ((MSPlugin*)this)->NotifyRefChanged(changeInt, hTarget, partID, message); 
					}

	// From ReferenceTarget
	int				NumRefs() { return pblocks.Count(); }
	RefTargetHandle GetReference(int i) { return pblocks[i]; }
	void			SetReference(int i, RefTargetHandle rtarg) 
					{ 
						if (i >= pblocks.Count()) pblocks.SetCount(i+1); pblocks[i] = (IParamBlock2*)rtarg; 
					}
	void			RefDeleted() { MSPlugin::RefDeleted(); }
	IOResult		Save(ISave *isave) { return MSPlugin::Save(isave); }
    IOResult		Load(ILoad *iload) { return MSPlugin::Load(iload); }

	// From BaseObject
	TCHAR *			GetObjectName() { return pc->class_name->to_string(); }
	void			BeginEditParams( IObjParam  *ip, ULONG flags,Animatable *prev);
	void			EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
	int				HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt) { return 0; }
	int				Display(TimeValue t, INode* inode, ViewExp *vpt, int flags) { return 0; }		
	void			GetWorldBoundBox(TimeValue t,INode* inode, ViewExp *vpt, Box3& box) { }
	void			GetLocalBoundBox(TimeValue t, INode *inode,ViewExp* vpt,  Box3& box ) { }
	void			Snap(TimeValue t, INode* inode, SnapInfo *snap, IPoint2 *p, ViewExp *vpt) { }
	CreateMouseCallBack* GetCreateMouseCallBack() { return NULL; } 	
	BOOL			HasUVW() { return 1; }
	void			SetGenUVW(BOOL sw) { }
	
	// From Object
	ObjectState		Eval(TimeValue time) { return ObjectState(this); }
	void			InitNodeName(TSTR& s) {s = GetObjectName();}
	Interval		ObjectValidity(TimeValue t) { return FOREVER; }
	int				CanConvertToType(Class_ID obtype) { return 0; }
	Object*			ConvertToType(TimeValue t, Class_ID obtype) { return NULL; }
	void			GetCollapseTypes(Tab<Class_ID> &clist, Tab<TSTR*> &nlist) { }
	void			GetDeformBBox(TimeValue t, Box3& box, Matrix3 *tm, BOOL useSel) { Object::GetDeformBBox(t, box, tm, useSel); }
	int				IntersectRay(TimeValue t, Ray& r, float& at, Point3& norm) { return 0; }

};

//	template for MSPlugin Xtnd classes derived from Object
template <class TYPE, class MS_SUPER>
class MSObjectXtnd : public MS_SUPER
{
public:
	TYPE*			delegate;		// my delegate

	void			DeleteThis();

	// From MSPlugin
	ReferenceTarget* get_delegate() { return delegate; } 

	// From Animatable
	void			GetClassName(TSTR& s) { s = TSTR(pc->class_name->to_string()); }  
	Class_ID		ClassID() { return pc->class_id; }
	void			FreeCaches() { }; // { delegate->FreeCaches(); } 		
	int				NumSubs() { return pblocks.Count() + 1; }  
	Animatable*		SubAnim(int i) { if (i == 0) return delegate; else return pblocks[i-1]; }
	TSTR			SubAnimName(int i) { if (i == 0) return delegate->GetObjectName(); else return pblocks[i-1]->GetLocalName(); }
	int				NumParamBlocks() { return pblocks.Count(); }
	IParamBlock2*	GetParamBlock(int i) { return pblocks[i]; }
	IParamBlock2*	GetParamBlockByID(BlockID id) { return MSPlugin::GetParamBlockByID(id); }
	void*			GetInterface(ULONG id) { if (id == I_MAXSCRIPTPLUGIN) return (MSPlugin*)this; else return NULL; }
	
	// From ReferenceMaker
//	RefResult		NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, PartID& partID, RefMessage message) { return REF_SUCCEED; }

	// From ReferenceTarget
	int				NumRefs() { return pblocks.Count() + 1; }
	RefTargetHandle GetReference(int i) { if (i == 0) return delegate; else return pblocks[i-1]; }
	void			SetReference(int i, RefTargetHandle rtarg) 
					{ 
						if (i == 0) 
						{
							if (rtarg == NULL)
								delegate->FreeCaches();
							delegate = (TYPE*)rtarg; 
						}
						else { if (i - 1 >= pblocks.Count()) pblocks.SetCount(i); pblocks[i-1] = (IParamBlock2*)rtarg; }
					}

	// From BaseObject
	TCHAR *			GetObjectName() { return pc->class_name->to_string(); }
	void			BeginEditParams( IObjParam  *ip, ULONG flags,Animatable *prev);
	void			EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
	int				HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt)
						{ return delegate->HitTest(t, inode, type, crossing, flags, p, vpt); }
	int				Display(TimeValue t, INode* inode, ViewExp *vpt, int flags) 
						{ return delegate->Display(t, inode, vpt, flags); }		
	void			GetWorldBoundBox(TimeValue t,INode* inode, ViewExp *vpt, Box3& box) { delegate->GetWorldBoundBox(t, inode, vpt, box); }
	void			GetLocalBoundBox(TimeValue t, INode *inode,ViewExp* vpt,  Box3& box ) { delegate->GetLocalBoundBox(t, inode, vpt,  box ); }
	void			Snap(TimeValue t, INode* inode, SnapInfo *snap, IPoint2 *p, ViewExp *vpt) { delegate->Snap(t, inode, snap, p, vpt); }
	CreateMouseCallBack* GetCreateMouseCallBack();
	BOOL			HasUVW() { return delegate->HasUVW(); }
	void			SetGenUVW(BOOL sw) { delegate->SetGenUVW(sw); }
	void			SetExtendedDisplay(int flags) { delegate->SetExtendedDisplay( flags); }      // for setting mode-dependent display attributes

	// From Object
	ObjectState		Eval(TimeValue time);
	void			InitNodeName(TSTR& s) {s = GetObjectName();}
	Interval		ObjectValidity(TimeValue t) { return delegate->ObjectValidity(t); }
	int				CanConvertToType(Class_ID obtype) { return delegate->CanConvertToType(obtype); }
	Object*			ConvertToType(TimeValue t, Class_ID obtype) { return delegate->ConvertToType(t, obtype); }
	void			GetCollapseTypes(Tab<Class_ID> &clist, Tab<TSTR*> &nlist) { delegate->GetCollapseTypes(clist, nlist); }
	void			GetDeformBBox(TimeValue t, Box3& box, Matrix3 *tm, BOOL useSel) { delegate->GetDeformBBox(t, box, tm, useSel); }
	int				IntersectRay(TimeValue t, Ray& r, float& at, Point3& norm) { return delegate->IntersectRay(t, r, at, norm); }

};

// ----------------------- MSPluginGeomObject ----------------------
//  scripted GeomObject 

class MSPluginGeomObject : public MSPluginObject<GeomObject>
{
public:
					MSPluginGeomObject() { }
					MSPluginGeomObject(MSPluginClass* pc, BOOL loading);
				   ~MSPluginGeomObject() { DeleteAllRefsFromMe(); }

	static RefTargetHandle create(MSPluginClass* pc, BOOL loading);
	RefTargetHandle Clone(RemapDir& remap = NoRemap());

	// From GeomObject
	int				IsRenderable() { return 0; }		
	Mesh*			GetRenderMesh(TimeValue t, INode *inode, View &view, BOOL& needDelete) { return GeomObject::GetRenderMesh(t, inode, view, needDelete); }
};

class MSGeomObjectXtnd : public MSObjectXtnd<GeomObject, MSPluginGeomObject>
{
public:
					MSGeomObjectXtnd(MSPluginClass* pc, BOOL loading);
				   ~MSGeomObjectXtnd() { DeleteAllRefsFromMe(); }

	RefTargetHandle Clone(RemapDir& remap = NoRemap());
	// From GeomObject
	int				IsRenderable() { return delegate->IsRenderable(); }		
	Mesh*			GetRenderMesh(TimeValue t, INode *inode, View &view, BOOL& needDelete) { return delegate->GetRenderMesh(t, inode, view, needDelete); }
};

// ----------------------- MSPluginHelper ----------------------
// scripted HelperObject

class MSPluginHelper : public MSPluginObject<HelperObject>
{
public:
					MSPluginHelper() { }
					MSPluginHelper(MSPluginClass* pc, BOOL loading);
				   ~MSPluginHelper() { DeleteAllRefsFromMe(); }

	static RefTargetHandle create(MSPluginClass* pc, BOOL loading);
	RefTargetHandle Clone(RemapDir& remap = NoRemap());

	// From HelperObject
	int				UsesWireColor() { return HelperObject::UsesWireColor(); }   // TRUE if the object color is used for display
	BOOL			NormalAlignVector(TimeValue t,Point3 &pt, Point3 &norm) { return HelperObject::NormalAlignVector(t, pt, norm); }
};

class MSHelperXtnd : public MSObjectXtnd<HelperObject, MSPluginHelper>
{
public:
					MSHelperXtnd(MSPluginClass* pc, BOOL loading);
				   ~MSHelperXtnd() { DeleteAllRefsFromMe(); }

	RefTargetHandle Clone(RemapDir& remap = NoRemap());
	// From HelperObject
	int				UsesWireColor() { return delegate->UsesWireColor(); }
	BOOL			NormalAlignVector(TimeValue t,Point3 &pt, Point3 &norm) { return delegate->NormalAlignVector(t, pt, norm); }
};

// ----------------------- MSPluginLight ----------------------
// scripted GenLight

class MSPluginLight : public MSPluginObject<GenLight>
{
public:
	NameTab			exclusionList;

					MSPluginLight() { }
					MSPluginLight(MSPluginClass* pc, BOOL loading);
				   ~MSPluginLight() { DeleteAllRefsFromMe(); }

	static RefTargetHandle create(MSPluginClass* pc, BOOL loading);
	RefTargetHandle Clone(RemapDir& remap = NoRemap());

	// From LightObject
	RefResult		EvalLightState(TimeValue time, Interval& valid, LightState *ls) { return REF_SUCCEED; }
	ObjLightDesc *	CreateLightDesc(INode *n) { return LightObject::CreateLightDesc(n); }
	void			SetUseLight(int onOff) { }
	BOOL			GetUseLight(void) { return FALSE; }
	void			SetHotspot(TimeValue time, float f) { } 
	float			GetHotspot(TimeValue t, Interval& valid = Interval(0,0)) { return 0.0f; }
	void			SetFallsize(TimeValue time, float f) { }
	float			GetFallsize(TimeValue t, Interval& valid = Interval(0,0)) { return 0.0f; }
	void			SetAtten(TimeValue time, int which, float f) { }
	float			GetAtten(TimeValue t, int which, Interval& valid = Interval(0,0)) { return 0.0f; }
	void			SetTDist(TimeValue time, float f) { }
	float			GetTDist(TimeValue t, Interval& valid = Interval(0,0)) { return 0.0f; }
	void			SetConeDisplay(int s, int notify=TRUE) { }
	BOOL			GetConeDisplay(void) { return FALSE; }
	int 			GetShadowMethod() {return LIGHTSHADOW_NONE;}
	void 			SetRGBColor(TimeValue t, Point3& rgb) { }
	Point3 			GetRGBColor(TimeValue t, Interval &valid = Interval(0,0)) {return Point3(0,0,0);}        
	void 			SetIntensity(TimeValue time, float f) { }
	float 			GetIntensity(TimeValue t, Interval& valid = Interval(0,0)) {return 0.0f;}
	void 			SetAspect(TimeValue t, float f) { }
	float			GetAspect(TimeValue t, Interval& valid = Interval(0,0)) {return 0.0f;}    
	void 			SetUseAtten(int s) { }
	BOOL 			GetUseAtten(void) {return FALSE;}
	void 			SetAttenDisplay(int s) { }
	BOOL 			GetAttenDisplay(void) {return FALSE;}      
	void 			Enable(int enab) { }
	void 			SetMapBias(TimeValue t, float f) { }
	float 			GetMapBias(TimeValue t, Interval& valid = Interval(0,0)) {return 0.0f;}
	void 			SetMapRange(TimeValue t, float f) { }
	float 			GetMapRange(TimeValue t, Interval& valid = Interval(0,0)) {return 0.0f;}
	void 			SetMapSize(TimeValue t, int f) { }
	int 			GetMapSize(TimeValue t, Interval& valid = Interval(0,0)) {return 0;}
	void 			SetRayBias(TimeValue t, float f) { }
	float 			GetRayBias(TimeValue t, Interval& valid = Interval(0,0)) {return 0.0f;}
	int 			GetUseGlobal() {return 0;}
	void 			SetUseGlobal(int a) { }
	int 			GetShadow() {return 0;}
	void 			SetShadow(int a) { }
	int 			GetShadowType() {return 0;}
	void 			SetShadowType(int a) { }
	int 			GetAbsMapBias() {return 0;}
	void 			SetAbsMapBias(int a) { }
	int 			GetOvershoot() {return 0;}
	void 			SetOvershoot(int a) { }
	int 			GetProjector() {return 0;}
	void 			SetProjector(int a) { }
	NameTab* 		GetExclList() { return &exclusionList; }
	BOOL 			Include() {return FALSE;}
	Texmap* 		GetProjMap() {return NULL;}
	void 			SetProjMap(Texmap* pmap) { }
	void 			UpdateTargDistance(TimeValue t, INode* inode) { }

	// From GenLight

	GenLight *		NewLight(int type) { return NULL; }
	int				Type() { return 0; }  // OMNI_LIGHT, TSPOT_LIGHT, DIR_LIGHT, FSPOT_LIGHT, TDIR_LIGHT
	void			SetType(int tp) { } // OMNI_LIGHT, TSPOT_LIGHT, DIR_LIGHT, FSPOT_LIGHT, TDIR_LIGHT      
	BOOL			IsSpot() { return FALSE; }
	BOOL			IsDir() { return FALSE; }
	void			SetSpotShape(int s) { }
	int				GetSpotShape(void) { return 0; }
	void 			SetHSVColor(TimeValue t, Point3& hsv) { }
	Point3 			GetHSVColor(TimeValue t, Interval &valid = Interval(0,0)) { return Point3(0.0f, 0.0f, 0.0f); }
	void 			SetContrast(TimeValue time, float f) { }
	float 			GetContrast(TimeValue t, Interval& valid = Interval(0,0)) { return 0.0f; }
	void 			SetUseAttenNear(int s) { }
	BOOL 			GetUseAttenNear(void) { return FALSE; }
	void 			SetAttenNearDisplay(int s) { }
	BOOL 			GetAttenNearDisplay(void) { return FALSE; }

	NameTab&		GetExclusionList() { return exclusionList; }
	void 			SetExclusionList(NameTab &list) { }

	BOOL 			SetHotSpotControl(Control *c) { return FALSE; }
	BOOL 			SetFalloffControl(Control *c) { return FALSE; }
	BOOL 			SetColorControl(Control *c) { return FALSE; }
	Control* 		GetHotSpotControl() { return NULL; }
	Control* 		GetFalloffControl() { return NULL; }
	Control* 		GetColorControl() { return NULL; }
	
	void 			SetAffectDiffuse(BOOL onOff) { }
	BOOL 			GetAffectDiffuse() { return FALSE; }
	void 			SetAffectSpecular(BOOL onOff) { }
	BOOL 			GetAffectSpecular() { return FALSE; }

	void 			SetDecayType(BOOL onOff) { }
	BOOL 			GetDecayType() { return FALSE; }
	void 			SetDecayRadius(TimeValue time, float f) {}
	float 			GetDecayRadius(TimeValue t, Interval& valid = Interval(0,0)) { return 0.0f;}
	void 			SetDiffuseSoft(TimeValue time, float f) {}
	float 			GetDiffuseSoft(TimeValue t, Interval& valid = Interval(0,0)) { return 0.0f; }

	void 			SetShadColor(TimeValue t, Point3& rgb) {}
	Point3 			GetShadColor(TimeValue t, Interval &valid = Interval(0,0)) { return Point3(0,0,0); }
	BOOL 			GetLightAffectsShadow() { return FALSE; }
	void 			SetLightAffectsShadow(BOOL b) {  }
	void			SetShadMult(TimeValue t, float m) {  }
	float			GetShadMult(TimeValue t, Interval &valid = Interval(0,0)) { return 1.0f; }

	Texmap* 		GetShadowProjMap() { return NULL;  }
	void 			SetShadowProjMap(Texmap* pmap) {}

	void 			SetAmbientOnly(BOOL onOff) {  }
	BOOL 			GetAmbientOnly() { return FALSE; }

	void			SetAtmosShadows(TimeValue t, int onOff) { }
	int				GetAtmosShadows(TimeValue t) { return 0; }
	void			SetAtmosOpacity(TimeValue t, float f) { }
	float			GetAtmosOpacity(TimeValue t, Interval& valid=FOREVER) { return 0.0f; }
	void			SetAtmosColAmt(TimeValue t, float f) { }
	float			GetAtmosColAmt(TimeValue t, Interval& valid=FOREVER) { return 0.0f; }

	void			SetUseShadowColorMap(TimeValue t, int onOff) { GenLight::SetUseShadowColorMap(t, onOff); }
	int				GetUseShadowColorMap(TimeValue t) { return GenLight::GetUseShadowColorMap(t); }

	void			SetShadowGenerator(ShadowType *s) { GenLight::SetShadowGenerator(s); };
	ShadowType*		GetShadowGenerator() { return GenLight::GetShadowGenerator(); } 

	void			SetEmitterEnable(TimeValue t, BOOL onOff) { GenLight::SetEmitterEnable(t, onOff); }
	BOOL			GetEmitterEnable(TimeValue t, Interval& valid = Interval(0,0)) { return GenLight::GetEmitterEnable(t, valid); }
	void			SetEmitterEnergy(TimeValue t, float energy) { GenLight::SetEmitterEnergy(t, energy); }
	float			GetEmitterEnergy(TimeValue t, Interval& valid = Interval(0,0)) { return GenLight::GetEmitterEnergy(t, valid); }
	void			SetEmitterDecayType(TimeValue t, int decay) { GenLight::SetEmitterDecayType(t, decay); }
	int				GetEmitterDecayType(TimeValue t, Interval& valid = Interval(0,0)) { return GenLight::GetEmitterDecayType(t, valid); }
	void			SetEmitterCausticPhotons(TimeValue t, int photons) { GenLight::SetEmitterCausticPhotons(t, photons); }
	int				GetEmitterCausticPhotons(TimeValue t, Interval& valid = Interval(0,0)) { return GenLight::GetEmitterCausticPhotons(t, valid); }
	void			SetEmitterGlobalIllumPhotons(TimeValue t, int photons) { GenLight::SetEmitterGlobalIllumPhotons(t, photons); }
	int				GetEmitterGlobalIllumPhotons(TimeValue t, Interval& valid = Interval(0,0)) { return GenLight::GetEmitterGlobalIllumPhotons(t, valid); }
};

class MSLightXtnd : public MSObjectXtnd<GenLight, MSPluginLight>
{
public:
					MSLightXtnd(MSPluginClass* pc, BOOL loading);
				   ~MSLightXtnd() { DeleteAllRefsFromMe(); }
	RefTargetHandle Clone(RemapDir& remap = NoRemap());

// ^\(\:b+\:a+\:b*\**\:b+\)\(.*\)\( {.*->\)
// \1\2\3\2

	// From LightObject

	RefResult		EvalLightState(TimeValue time, Interval& valid, LightState *ls) { return delegate->EvalLightState(time, valid, ls); }
	ObjLightDesc *	CreateLightDesc(INode *n) { return delegate->CreateLightDesc(n); }
	void			SetUseLight(int onOff) { delegate->SetUseLight(onOff); }
	BOOL			GetUseLight(void) { return delegate->GetUseLight(); }
	void			SetHotspot(TimeValue time, float f) { delegate->SetHotspot(time, f); } 
	float			GetHotspot(TimeValue t, Interval& valid = Interval(0,0)) { return delegate->GetHotspot(t, valid); }
	void			SetFallsize(TimeValue time, float f) { delegate->SetFallsize(time, f); }
	float			GetFallsize(TimeValue t, Interval& valid = Interval(0,0)) { return delegate->GetFallsize(t, valid); }
	void			SetAtten(TimeValue time, int which, float f) { delegate->SetAtten(time, which, f); }
	float			GetAtten(TimeValue t, int which, Interval& valid = Interval(0,0)) { return delegate->GetAtten(t, which, valid); }
	void			SetTDist(TimeValue time, float f) { delegate->SetTDist(time, f); }
	float			GetTDist(TimeValue t, Interval& valid = Interval(0,0)) { return delegate->GetTDist(t, valid); }
	void			SetConeDisplay(int s, int notify=TRUE) { delegate->SetConeDisplay(s, notify); }
	BOOL			GetConeDisplay(void) { return delegate->GetConeDisplay(); }
	int 			GetShadowMethod() {return delegate->GetShadowMethod();}
	void 			SetRGBColor(TimeValue t, Point3& rgb) { delegate->SetRGBColor(t, rgb); }
	Point3 			GetRGBColor(TimeValue t, Interval &valid = Interval(0,0)) {return delegate->GetRGBColor(t, valid);}        
	void 			SetIntensity(TimeValue time, float f) { delegate->SetIntensity(time, f); }
	float 			GetIntensity(TimeValue t, Interval& valid = Interval(0,0)) { return delegate->GetIntensity(t, valid); }
	void 			SetAspect(TimeValue t, float f) { delegate->SetAspect(t, f); }
	float			GetAspect(TimeValue t, Interval& valid = Interval(0,0)) { return delegate->GetAspect(t, valid); }    
	void 			SetUseAtten(int s) { delegate->SetUseAtten(s); }
	BOOL 			GetUseAtten(void) { return delegate->GetUseAtten(); }
	void 			SetAttenDisplay(int s) { delegate->SetAttenDisplay(s); }
	BOOL 			GetAttenDisplay(void) { return delegate->GetAttenDisplay(); }      
	void 			Enable(int enab) { delegate->Enable(enab); }
	void 			SetMapBias(TimeValue t, float f) { delegate->SetMapBias(t, f); }
	float 			GetMapBias(TimeValue t, Interval& valid = Interval(0,0)) { return delegate->GetMapBias(t, valid); }
	void 			SetMapRange(TimeValue t, float f) { delegate->SetMapRange(t, f); }
	float 			GetMapRange(TimeValue t, Interval& valid = Interval(0,0)) { return delegate->GetMapRange(t, valid); }
	void 			SetMapSize(TimeValue t, int f) { delegate->SetMapSize(t, f); }
	int 			GetMapSize(TimeValue t, Interval& valid = Interval(0,0)) { return delegate->GetMapSize(t, valid); }
	void 			SetRayBias(TimeValue t, float f) { delegate->SetRayBias(t, f); }
	float 			GetRayBias(TimeValue t, Interval& valid = Interval(0,0)) { return delegate->GetRayBias(t, valid); }
	int 			GetAbsMapBias() { return delegate->GetAbsMapBias(); }
	void 			SetAbsMapBias(int a) { delegate->SetAbsMapBias(a); }
	int 			GetOvershoot() { return delegate->GetOvershoot(); }
	void 			SetOvershoot(int a) { delegate->SetOvershoot(a); }
	int 			GetProjector() { return delegate->GetProjector(); }
	void 			SetProjector(int a) { delegate->SetProjector(a); }
	NameTab* 		GetExclList() { return delegate->GetExclList(); }
	BOOL 			Include() { return delegate->Include(); }
	Texmap* 		GetProjMap() { return delegate->GetProjMap(); }
	void 			SetProjMap(Texmap* pmap) { delegate->SetProjMap(pmap); }
	void 			UpdateTargDistance(TimeValue t, INode* inode) { delegate->UpdateTargDistance(t, inode); }

	// From GenLight

	GenLight *		NewLight(int type) { return delegate->NewLight(type); }
	int				Type() { return delegate->Type(); }  // OMNI_LIGHT, TSPOT_LIGHT, DIR_LIGHT, FSPOT_LIGHT, TDIR_LIGHT
	void			SetType(int tp) { delegate->SetType(tp); } // OMNI_LIGHT, TSPOT_LIGHT, DIR_LIGHT, FSPOT_LIGHT, TDIR_LIGHT      
	BOOL			IsSpot() { return delegate->IsSpot(); }
	BOOL			IsDir() { return delegate->IsDir(); }
	void			SetSpotShape(int s) { delegate->SetSpotShape(s); }
	int				GetSpotShape(void) { return delegate->GetSpotShape(); }
	void 			SetHSVColor(TimeValue t, Point3& hsv) { delegate->SetHSVColor(t, hsv); }
	Point3 			GetHSVColor(TimeValue t, Interval &valid = Interval(0,0)) { return delegate->GetHSVColor(t, valid); }
	void 			SetContrast(TimeValue time, float f) { delegate->SetContrast(time, f); }
	float 			GetContrast(TimeValue t, Interval& valid = Interval(0,0)) { return delegate->GetContrast(t, valid); }
	void 			SetUseAttenNear(int s) { delegate->SetUseAttenNear(s); }
	BOOL 			GetUseAttenNear(void) { return delegate->GetUseAttenNear(); }
	void 			SetAttenNearDisplay(int s) { delegate->SetAttenNearDisplay(s); }
	BOOL 			GetAttenNearDisplay(void) { return delegate->GetAttenNearDisplay(); }

	NameTab&		GetExclusionList() { return delegate->GetExclusionList(); }
	void 			SetExclusionList(NameTab &list) { delegate->SetExclusionList(list); }

	BOOL 			SetHotSpotControl(Control *c) { return delegate->SetHotSpotControl(c); }
	BOOL 			SetFalloffControl(Control *c) { return delegate->SetFalloffControl(c); }
	BOOL 			SetColorControl(Control *c) { return delegate->SetColorControl(c); }
	Control* 		GetHotSpotControl() { return delegate->GetHotSpotControl(); }
	Control* 		GetFalloffControl() { return delegate->GetFalloffControl(); }
	Control* 		GetColorControl() { return delegate->GetColorControl(); }
	
	void 			SetAffectDiffuse(BOOL onOff) { delegate->SetAffectDiffuse(onOff); }
	BOOL 			GetAffectDiffuse() { return delegate->GetAffectDiffuse(); }
	void 			SetAffectSpecular(BOOL onOff) { delegate->SetAffectSpecular(onOff); }
	BOOL 			GetAffectSpecular() { return delegate->GetAffectSpecular(); }

	void 			SetDecayType(BOOL onOff) { delegate->SetDecayType(onOff); }
	BOOL 			GetDecayType() { return delegate->GetDecayType(); }
	void 			SetDecayRadius(TimeValue time, float f) { delegate->SetDecayRadius(time, f); }
	float 			GetDecayRadius(TimeValue t, Interval& valid = Interval(0,0)) { return delegate->GetDecayRadius(t, valid);}
	void 			SetDiffuseSoft(TimeValue time, float f) { delegate->SetDiffuseSoft(time, f); }
	float 			GetDiffuseSoft(TimeValue t, Interval& valid = Interval(0,0)) { return delegate->GetDiffuseSoft(t, valid); }

	int 			GetUseGlobal() { return delegate->GetUseGlobal(); }
	void 			SetUseGlobal(int a) { delegate->SetUseGlobal(a); }
	int 			GetShadow() { return delegate->GetShadow(); }
	void 			SetShadow(int a) { delegate->SetShadow(a); }
	int 			GetShadowType() { return delegate->GetShadowType(); }
	void 			SetShadowType(int a) { delegate->SetShadowType(a); }

	void 			SetShadColor(TimeValue t, Point3& rgb) { delegate->SetShadColor(t, rgb); }
	Point3 			GetShadColor(TimeValue t, Interval &valid = Interval(0,0)) { return delegate->GetShadColor(t, valid); }
	BOOL 			GetLightAffectsShadow() { return delegate->GetLightAffectsShadow(); }
	void 			SetLightAffectsShadow(BOOL b) { delegate->SetLightAffectsShadow(b); }
	void			SetShadMult(TimeValue t, float m) { delegate->SetShadMult(t, m); }
	float			GetShadMult(TimeValue t, Interval &valid = Interval(0,0)) { return delegate->GetShadMult(t, valid); }

	Texmap* 		GetShadowProjMap() { return delegate->GetShadowProjMap();  }
	void 			SetShadowProjMap(Texmap* pmap) { delegate->SetShadowProjMap(pmap); }

	void 			SetAmbientOnly(BOOL onOff) { delegate->SetAmbientOnly(onOff); }
	BOOL 			GetAmbientOnly() { return delegate->GetAmbientOnly(); }

	void			SetAtmosShadows(TimeValue t, int onOff) { delegate->SetAtmosShadows(t, onOff);}
	int				GetAtmosShadows(TimeValue t) { return delegate->GetAtmosShadows(t); }
	void			SetAtmosOpacity(TimeValue t, float f) { delegate->SetAtmosOpacity(t, f);}
	float			GetAtmosOpacity(TimeValue t, Interval& valid=FOREVER) { return delegate->GetAtmosOpacity(t); }
	void			SetAtmosColAmt(TimeValue t, float f) { delegate->SetAtmosColAmt(t, f);}
	float			GetAtmosColAmt(TimeValue t, Interval& valid=FOREVER) { return delegate->GetAtmosColAmt(t); }
	
	void			SetUseShadowColorMap(TimeValue t, int onOff) { delegate->SetUseShadowColorMap(t, onOff); }
	int				GetUseShadowColorMap(TimeValue t) { return delegate->GetUseShadowColorMap(t); }

	void			SetShadowGenerator(ShadowType *s) { delegate->SetShadowGenerator(s); }
	ShadowType*		GetShadowGenerator() { return delegate->GetShadowGenerator(); } 

	void			SetEmitterEnable(TimeValue t, BOOL onOff) { delegate->SetEmitterEnable(t, onOff); }
	BOOL			GetEmitterEnable(TimeValue t, Interval& valid = Interval(0,0)) { return delegate->GetEmitterEnable(t, valid); }
	void			SetEmitterEnergy(TimeValue t, float energy) { delegate->SetEmitterEnergy(t, energy); }
	float			GetEmitterEnergy(TimeValue t, Interval& valid = Interval(0,0)) { return delegate->GetEmitterEnergy(t, valid); }
	void			SetEmitterDecayType(TimeValue t, int decay) { delegate->SetEmitterDecayType(t, decay); }
	int				GetEmitterDecayType(TimeValue t, Interval& valid = Interval(0,0)) { return delegate->GetEmitterDecayType(t, valid); }
	void			SetEmitterCausticPhotons(TimeValue t, int photons) { delegate->SetEmitterCausticPhotons(t, photons); }
	int				GetEmitterCausticPhotons(TimeValue t, Interval& valid = Interval(0,0)) { return delegate->GetEmitterCausticPhotons(t, valid); }
	void			SetEmitterGlobalIllumPhotons(TimeValue t, int photons) { delegate->SetEmitterGlobalIllumPhotons(t, photons); }
	int				GetEmitterGlobalIllumPhotons(TimeValue t, Interval& valid = Interval(0,0)) { return delegate->GetEmitterGlobalIllumPhotons(t, valid); }
};

// ----------------------- MSPluginShape ----------------------
// scripted Shape

class MSPluginShape : public MSPluginObject<ShapeObject>
{
	ShapeHierarchy	sh;
public:
					MSPluginShape() { sh.New(); }
					MSPluginShape(MSPluginClass* pc, BOOL loading);
				   ~MSPluginShape() { DeleteAllRefsFromMe(); }

	static RefTargetHandle create(MSPluginClass* pc, BOOL loading);
	RefTargetHandle Clone(RemapDir& remap = NoRemap());

	// From GeomObject
	int				IsRenderable() { return ShapeObject::IsRenderable(); }		
	Mesh*			GetRenderMesh(TimeValue t, INode *inode, View &view, BOOL& needDelete) { return ShapeObject::GetRenderMesh(t, inode, view, needDelete); }

	// from ShapeObject
	void			InitNodeName(TSTR& s) { ShapeObject::InitNodeName(s); }
	SClass_ID		SuperClassID() { return ShapeObject::SuperClassID(); }

	int				IntersectRay(TimeValue t, Ray& ray, float& at, Point3& norm) { return ShapeObject::IntersectRay(t, ray, at, norm); }
	int				NumberOfVertices(TimeValue t, int curve = -1) { return ShapeObject::NumberOfVertices(t, curve); }	// Informational only, curve = -1: total in all curves
	int				NumberOfCurves() { return 0; }                 // Number of curve polygons in the shape
	BOOL			CurveClosed(TimeValue t, int curve) { return FALSE; }     // Returns TRUE if the curve is closed
	Point3			InterpCurve3D(TimeValue t, int curve, float param, int ptype=PARAM_SIMPLE) { return Point3 (0,0,0); }    // Interpolate from 0-1 on a curve
	Point3			TangentCurve3D(TimeValue t, int curve, float param, int ptype=PARAM_SIMPLE) { return Point3 (0,0,0); }    // Get tangent at point on a curve
	float			LengthOfCurve(TimeValue t, int curve) { return 0.0f; }  // Get the length of a curve
	int				NumberOfPieces(TimeValue t, int curve) { return 0; }   // Number of sub-curves in a curve
	Point3			InterpPiece3D(TimeValue t, int curve, int piece, float param, int ptype=PARAM_SIMPLE) { return Point3 (0,0,0); }  // Interpolate from 0-1 on a sub-curve
	Point3			TangentPiece3D(TimeValue t, int curve, int piece, float param, int ptype=PARAM_SIMPLE) { return Point3 (0,0,0); }         // Get tangent on a sub-curve
	BOOL			CanMakeBezier() { return ShapeObject::CanMakeBezier(); }                  // Return TRUE if can turn into a bezier representation
	void			MakeBezier(TimeValue t, BezierShape &shape) { ShapeObject::MakeBezier(t, shape); }     // Create the bezier representation
	ShapeHierarchy& OrganizeCurves(TimeValue t, ShapeHierarchy *hier=NULL) { return sh; }       // Ready for lofting, extrusion, etc.
	void			MakePolyShape(TimeValue t, PolyShape &shape, int steps = PSHAPE_BUILTIN_STEPS, BOOL optimize = FALSE) { } // Create a PolyShape representation with optional fixed steps & optimization
	int				MakeCap(TimeValue t, MeshCapInfo &capInfo, int capType) { return 0; }  // Generate mesh capping info for the shape
	int				MakeCap(TimeValue t, PatchCapInfo &capInfo) { return ShapeObject::MakeCap(t, capInfo); }	// Only implement if CanMakeBezier=TRUE -- Gen patch cap info

	
	MtlID			GetMatID(TimeValue t, int curve, int piece) { return ShapeObject::GetMatID(t, curve, piece); }
	BOOL			AttachShape(TimeValue t, INode *thisNode, INode *attachNode) { return ShapeObject::AttachShape(t, thisNode, attachNode); }	// Return TRUE if attached
	// UVW Mapping switch access
	BOOL			HasUVW() { return ShapeObject::HasUVW(); }
	void			SetGenUVW(BOOL sw) { ShapeObject::SetGenUVW(sw); }

	// These handle loading and saving the data in this class. Should be called
	// by derived class BEFORE it loads or saves any chunks
	IOResult		Save(ISave *isave) { MSPlugin::Save(isave); return ShapeObject::Save(isave); }
    IOResult		Load(ILoad *iload) {  MSPlugin::Load(iload); return ShapeObject::Load(iload); }

	Class_ID		PreferredCollapseType() { return ShapeObject::PreferredCollapseType(); }
	BOOL			GetExtendedProperties(TimeValue t, TSTR &prop1Label, TSTR &prop1Data, TSTR &prop2Label, TSTR &prop2Data)
						{ return ShapeObject::GetExtendedProperties(t, prop1Label, prop1Data, prop2Label, prop2Data); }
	void			RescaleWorldUnits(float f) { ShapeObject::RescaleWorldUnits(f); }
};

class MSShapeXtnd : public MSObjectXtnd<ShapeObject, MSPluginShape>
{
public:
					MSShapeXtnd(MSPluginClass* pc, BOOL loading);
				   ~MSShapeXtnd() { DeleteAllRefsFromMe(); }
	RefTargetHandle Clone(RemapDir& remap = NoRemap());

	// From GeomObject
	int				IsRenderable() { return delegate->IsRenderable(); }		
	Mesh*			GetRenderMesh(TimeValue t, INode *inode, View &view, BOOL& needDelete) { return delegate->GetRenderMesh(t, inode, view, needDelete); }

	// from ShapeObject
	void			InitNodeName(TSTR& s) { delegate->InitNodeName(s); }
	SClass_ID		SuperClassID() { return delegate->SuperClassID(); }

	int				IntersectRay(TimeValue t, Ray& ray, float& at, Point3& norm) { return delegate->IntersectRay(t, ray, at, norm); }
	int				NumberOfVertices(TimeValue t, int curve = -1) { return delegate->NumberOfVertices(t, curve); }	
	int				NumberOfCurves() { return delegate->NumberOfCurves(); }                 
	BOOL			CurveClosed(TimeValue t, int curve) { return delegate->CurveClosed(t, curve); }     
	Point3			InterpCurve3D(TimeValue t, int curve, float param, int ptype=PARAM_SIMPLE) { return delegate->InterpCurve3D(t, curve, param, ptype); }    
	Point3			TangentCurve3D(TimeValue t, int curve, float param, int ptype=PARAM_SIMPLE) { return delegate->TangentCurve3D(t, curve, param, ptype); }    
	float			LengthOfCurve(TimeValue t, int curve) { return delegate->LengthOfCurve(t, curve); }  
	int				NumberOfPieces(TimeValue t, int curve) { return delegate->NumberOfPieces(t, curve); }   
	Point3			InterpPiece3D(TimeValue t, int curve, int piece, float param, int ptype=PARAM_SIMPLE) { return delegate->InterpPiece3D(t, curve, piece, param, ptype); }  
	Point3			TangentPiece3D(TimeValue t, int curve, int piece, float param, int ptype=PARAM_SIMPLE) { return delegate->TangentPiece3D(t, curve, piece, param, ptype); }         
	BOOL			CanMakeBezier() { return delegate->CanMakeBezier(); }                  
	void			MakeBezier(TimeValue t, BezierShape &shape) { delegate->MakeBezier(t, shape); }     
	ShapeHierarchy& OrganizeCurves(TimeValue t, ShapeHierarchy *hier=NULL) { return delegate->OrganizeCurves(t, hier); }       
	void			MakePolyShape(TimeValue t, PolyShape &shape, int steps = PSHAPE_BUILTIN_STEPS, BOOL optimize = FALSE) { delegate->MakePolyShape(t, shape, steps, optimize); } 
	int				MakeCap(TimeValue t, MeshCapInfo &capInfo, int capType) { return delegate->MakeCap(t, capInfo, capType); }  
	int				MakeCap(TimeValue t, PatchCapInfo &capInfo) { return delegate->MakeCap(t, capInfo); }	

	
	MtlID			GetMatID(TimeValue t, int curve, int piece) { return delegate->GetMatID(t, curve, piece); }
	BOOL			AttachShape(TimeValue t, INode *thisNode, INode *attachNode) { return delegate->AttachShape(t, thisNode, attachNode); }	// Return TRUE if attached
	// UVW Mapping switch access
	BOOL			HasUVW() { return delegate->HasUVW(); }
	void			SetGenUVW(BOOL sw) { delegate->SetGenUVW(sw); }

	// These handle loading and saving the data in this class. Should be called
	// by derived class BEFORE it loads or saves any chunks
	IOResult		Save(ISave *isave) { MSPlugin::Save(isave); return ShapeObject::Save(isave); }
    IOResult		Load(ILoad *iload) {  MSPlugin::Load(iload); return ShapeObject::Load(iload); }

	Class_ID		PreferredCollapseType() { return delegate->PreferredCollapseType(); }
	BOOL			GetExtendedProperties(TimeValue t, TSTR &prop1Label, TSTR &prop1Data, TSTR &prop2Label, TSTR &prop2Data)
						{ return delegate->GetExtendedProperties(t, prop1Label, prop1Data, prop2Label, prop2Data); }
	void			RescaleWorldUnits(float f) { delegate->RescaleWorldUnits(f); }

};

// ----------------------- MSPluginSimpleObject ----------------------
//	scriptable SimpleObject, mesh building and all

class MSPluginSimpleObject : public MSPlugin, public SimpleObject
{
public:
	IObjParam*		ip;			// ip for any currently open command panel dialogs

					MSPluginSimpleObject() { }
					MSPluginSimpleObject(MSPluginClass* pc, BOOL loading);
				   ~MSPluginSimpleObject() { DeleteAllRefsFromMe(); }

	static RefTargetHandle create(MSPluginClass* pc, BOOL loading);

	void			DeleteThis();

	// From MSPlugin
	HWND			AddRollupPage(HINSTANCE hInst, TCHAR *dlgTemplate, DLGPROC dlgProc, TCHAR *title, LPARAM param=0,DWORD flags=0);
	void			DeleteRollupPage(HWND hRollup);
	IRollupWindow* GetRollupWindow();
	ReferenceTarget* get_delegate() { return NULL; }  // no delegate 

	// From Animatable
	void			GetClassName(TSTR& s) { s = TSTR(pc->class_name->to_string()); }  
	Class_ID		ClassID() { return pc->class_id; }
	int				NumSubs() { return pblocks.Count(); }  
	Animatable*		SubAnim(int i) { return pblocks[i]; }
	TSTR			SubAnimName(int i) { return pblocks[i]->GetLocalName(); }
	int				NumParamBlocks() { return pblocks.Count(); }
	IParamBlock2*	GetParamBlock(int i) { return pblocks[i]; }
	IParamBlock2*	GetParamBlockByID(BlockID id) { return MSPlugin::GetParamBlockByID(id); }
	void*			GetInterface(ULONG id) { if (id == I_MAXSCRIPTPLUGIN) return (MSPlugin*)this; else return NULL; }

	// From ReferenceMaker
	RefResult		NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, PartID& partID, RefMessage message) 
					{ 
						SimpleObject::NotifyRefChanged(changeInt, hTarget, partID, message); 
						return ((MSPlugin*)this)->NotifyRefChanged(changeInt, hTarget, partID, message); 
					}

	// From ReferenceTarget
	int				NumRefs() { return pblocks.Count(); }
	RefTargetHandle GetReference(int i) { return pblocks[i]; }
	void			SetReference(int i, RefTargetHandle rtarg) 
					{ 
						if (i >= pblocks.Count()) pblocks.SetCount(i+1); pblocks[i] = (IParamBlock2*)rtarg; 
					}
	void			RefDeleted() { MSPlugin::RefDeleted(); }
	RefTargetHandle Clone(RemapDir& remap = NoRemap());
	IOResult		Save(ISave *isave) { return MSPlugin::Save(isave); }
    IOResult		Load(ILoad *iload) { return MSPlugin::Load(iload); }

	// From BaseObject
	TCHAR *			GetObjectName() { return pc->class_name->to_string(); }
	void			BeginEditParams( IObjParam  *ip, ULONG flags,Animatable *prev);
	void			EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);

	// From SimpleObject
	void			BuildMesh(TimeValue t);
	BOOL			OKtoDisplay(TimeValue t);
	void			InvalidateUI();
	CreateMouseCallBack* GetCreateMouseCallBack();
	BOOL			HasUVW();
	void			SetGenUVW(BOOL sw);
};

//	MSSimpleObjectXtnd
class MSSimpleObjectXtnd : public MSPluginSimpleObject
{
public:
	SimpleObject*	delegate;		// my delegate

					MSSimpleObjectXtnd(MSPluginClass* pc, BOOL loading);
				   ~MSSimpleObjectXtnd() { DeleteAllRefsFromMe(); }

	void			DeleteThis();

	// From MSPlugin
	ReferenceTarget* get_delegate() { return delegate; } 

	// From Animatable
	void			GetClassName(TSTR& s) { s = TSTR(pc->class_name->to_string()); }  
	Class_ID		ClassID() { return pc->class_id; }
	void			FreeCaches() { delegate->FreeCaches(); } 		
	int				NumSubs() { return pblocks.Count() + 1; }  
	Animatable*		SubAnim(int i) { if (i == 0) return delegate; else return pblocks[i-1]; }
	TSTR			SubAnimName(int i) { if (i == 0) return delegate->GetObjectName(); else return pblocks[i-1]->GetLocalName(); }
	int				NumParamBlocks() { return pblocks.Count(); }
	IParamBlock2*	GetParamBlock(int i) { return pblocks[i]; }
	IParamBlock2*	GetParamBlockByID(BlockID id) { return MSPlugin::GetParamBlockByID(id); }
	void*			GetInterface(ULONG id) { if (id == I_MAXSCRIPTPLUGIN) return (MSPlugin*)this; else return NULL; }
	
	// From ReferenceMaker
//	RefResult		NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, PartID& partID, RefMessage message) { return REF_SUCCEED; }

	// From ReferenceTarget
	int				NumRefs() { return pblocks.Count() + 1; }
	RefTargetHandle GetReference(int i) { if (i == 0) return delegate; else return pblocks[i-1]; }
	void			SetReference(int i, RefTargetHandle rtarg) 
					{ 
						if (i == 0) 
						{
							if (rtarg == NULL)
								delegate->FreeCaches();
							delegate = (SimpleObject*)rtarg; 
						}
						else { if (i - 1 >= pblocks.Count()) pblocks.SetCount(i); pblocks[i-1] = (IParamBlock2*)rtarg; }
					}
	RefTargetHandle Clone(RemapDir& remap = NoRemap());

	// From BaseObject
	TCHAR *			GetObjectName() { return pc->class_name->to_string(); }
	void			BeginEditParams( IObjParam  *ip, ULONG flags,Animatable *prev);
	void			EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
	int				HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt)
						{ return delegate->HitTest(t, inode, type, crossing, flags, p, vpt); }
	int				Display(TimeValue t, INode* inode, ViewExp *vpt, int flags) 
						{ return delegate->Display(t, inode, vpt, flags); }		
	void			GetWorldBoundBox(TimeValue t,INode* inode, ViewExp *vpt, Box3& box) { delegate->GetWorldBoundBox(t, inode, vpt, box); }
	void			GetLocalBoundBox(TimeValue t, INode *inode,ViewExp* vpt,  Box3& box ) { delegate->GetLocalBoundBox(t, inode, vpt,  box ); }
	void			Snap(TimeValue t, INode* inode, SnapInfo *snap, IPoint2 *p, ViewExp *vpt) { delegate->Snap(t, inode, snap, p, vpt); }
	CreateMouseCallBack* GetCreateMouseCallBack() { return delegate->GetCreateMouseCallBack(); } 
	BOOL			HasUVW() { return delegate->HasUVW(); }
	void			SetGenUVW(BOOL sw) { delegate->SetGenUVW(sw); }
	
	// From Object
	ObjectState		Eval(TimeValue time);
	void			InitNodeName(TSTR& s) {s = GetObjectName();}
	Interval		ObjectValidity(TimeValue t) { return delegate->ObjectValidity(t); }
	int				CanConvertToType(Class_ID obtype) { return delegate->CanConvertToType(obtype); }
	Object*			ConvertToType(TimeValue t, Class_ID obtype) { return delegate->ConvertToType(t, obtype); }
	void			GetCollapseTypes(Tab<Class_ID> &clist, Tab<TSTR*> &nlist) { delegate->GetCollapseTypes(clist, nlist); }
	void			GetDeformBBox(TimeValue t, Box3& box, Matrix3 *tm, BOOL useSel) { delegate->GetDeformBBox(t, box, tm, useSel); }
	int				IntersectRay(TimeValue t, Ray& r, float& at, Point3& norm) { return delegate->IntersectRay(t, r, at, norm); }

	void			BuildMesh(TimeValue t) { delegate->BuildMesh(t); }
	BOOL			OKtoDisplay(TimeValue t) { return delegate->OKtoDisplay(t); }
	void			InvalidateUI() { delegate->InvalidateUI(); }
	ParamDimension* GetParameterDim(int pbIndex) { return delegate->GetParameterDim(pbIndex); }
	TSTR			GetParameterName(int pbIndex) { return delegate->GetParameterName(pbIndex); }

};

// ----------------------- MSPluginModifier ----------------------
// scripted Modifier

class MSPluginModifier : public MSPlugin, public Modifier
{
public:
	IObjParam*		ip;					// ip for any currently open command panel dialogs

					MSPluginModifier() { }
					MSPluginModifier(MSPluginClass* pc, BOOL loading);
				   ~MSPluginModifier() { DeleteAllRefsFromMe(); }

	static RefTargetHandle create(MSPluginClass* pc, BOOL loading);

	void			DeleteThis() { 	DeleteAllRefsFromMe(); MSPlugin::DeleteThis(); }

	// From MSPlugin
	HWND			AddRollupPage(HINSTANCE hInst, TCHAR *dlgTemplate, DLGPROC dlgProc, TCHAR *title, LPARAM param=0,DWORD flags=0);
	void			DeleteRollupPage(HWND hRollup);
	IRollupWindow* GetRollupWindow();
	ReferenceTarget* get_delegate() { return NULL; }  // no delegate 

	// From Animatable
	void			GetClassName(TSTR& s) { s = TSTR(pc->class_name->to_string()); }  
	Class_ID		ClassID() { return pc->class_id; }
	SClass_ID		SuperClassID() { return pc->sclass_id; }
	void			FreeCaches() { } 		
	int				NumSubs() { return pblocks.Count(); }  
	Animatable*		SubAnim(int i) { return pblocks[i]; }
	TSTR			SubAnimName(int i) { return pblocks[i]->GetLocalName(); }
	int				NumParamBlocks() { return pblocks.Count(); }
	IParamBlock2*	GetParamBlock(int i) { return pblocks[i]; }
	IParamBlock2*	GetParamBlockByID(BlockID id) { return MSPlugin::GetParamBlockByID(id); }
	void*			GetInterface(ULONG id) { if (id == I_MAXSCRIPTPLUGIN) return (MSPlugin*)this; else return NULL; }

	// From ReferenceMaker
	RefResult		NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, PartID& partID, RefMessage message) 
					{ 
						return ((MSPlugin*)this)->NotifyRefChanged(changeInt, hTarget, partID, message); 
					}

	// From ReferenceTarget
	int				NumRefs() { return pblocks.Count(); }
	RefTargetHandle GetReference(int i) { return pblocks[i]; }
	void			SetReference(int i, RefTargetHandle rtarg) 
					{ 
						if (i >= pblocks.Count()) pblocks.SetCount(i+1); pblocks[i] = (IParamBlock2*)rtarg; 
					}
	void			RefDeleted() { MSPlugin::RefDeleted(); }
	RefTargetHandle Clone(RemapDir& remap = NoRemap());
	IOResult		Save(ISave *isave) { MSPlugin::Save(isave); return Modifier::Save(isave); }
    IOResult		Load(ILoad *iload) { MSPlugin::Load(iload); return Modifier::Load(iload); }

	// From BaseObject
	TCHAR *			GetObjectName() { return pc->class_name->to_string(); }
	void			BeginEditParams( IObjParam  *ip, ULONG flags,Animatable *prev);
	void			EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
	int				HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt) { return 0; }
	int				Display(TimeValue t, INode* inode, ViewExp *vpt, int flags) { return 0; }		
	void			GetWorldBoundBox(TimeValue t,INode* inode, ViewExp *vpt, Box3& box) { }
	void			GetLocalBoundBox(TimeValue t, INode *inode,ViewExp* vpt,  Box3& box ) { }
	void			Snap(TimeValue t, INode* inode, SnapInfo *snap, IPoint2 *p, ViewExp *vpt) { }
	CreateMouseCallBack* GetCreateMouseCallBack() { return NULL; } 	
	BOOL			HasUVW() { return 1; }
	void			SetGenUVW(BOOL sw) { }

	// from Modifier
	Interval		LocalValidity(TimeValue t);
	ChannelMask		ChannelsUsed() { return GEOM_CHANNEL; }   // pretend this thing mods geometry in order to get parameters eval'd 
	ChannelMask		ChannelsChanged() { return GEOM_CHANNEL; } 
	// this is used to invalidate cache's in Edit Modifiers:
	void			NotifyInputChanged(Interval changeInt, PartID partID, RefMessage message, ModContext *mc) { Modifier::NotifyInputChanged(changeInt, partID, message, mc); }

	// This is the method that is called when the modifier is needed to 
	// apply its effect to the object. Note that the INode* is always NULL
	// for object space modifiers.
	void			ModifyObject(TimeValue t, ModContext &mc, ObjectState* os, INode *node) { os->obj->UpdateValidity(GEOM_CHAN_NUM, LocalValidity(t));	}

	// Modifiers that place a dependency on topology should return TRUE
	// for this method. An example would be a modifier that stores a selection
	// set base on vertex indices.
	BOOL			DependOnTopology(ModContext &mc) { return Modifier::DependOnTopology(mc); }

	// this can return:
	//   DEFORM_OBJ_CLASS_ID -- not really a class, but so what
	//   MAPPABLE_OBJ_CLASS_ID -- ditto
	//   TRIOBJ_CLASS_ID
	//   BEZIER_PATCH_OBJ_CLASS_ID
	Class_ID		InputType() { return Class_ID(DEFORM_OBJ_CLASS_ID,0); }

	IOResult		SaveLocalData(ISave *isave, LocalModData *ld) { return Modifier::SaveLocalData(isave, ld); }  
	IOResult		LoadLocalData(ILoad *iload, LocalModData **pld) { return Modifier::LoadLocalData(iload, pld); }  

};

class MSModifierXtnd : public MSPluginModifier
{
public:
	Modifier*		delegate;		// my delegate

					MSModifierXtnd(MSPluginClass* pc, BOOL loading);
				   ~MSModifierXtnd() { DeleteAllRefsFromMe(); }

					void DeleteThis() { DeleteAllRefsFromMe(); MSPlugin::DeleteThis(); }

	// From MSPlugin
	ReferenceTarget* get_delegate() { return delegate; } 

	// From Animatable
	void			GetClassName(TSTR& s) { s = TSTR(pc->class_name->to_string()); }  
	Class_ID		ClassID() { return pc->class_id; }
	SClass_ID		SuperClassID() { return pc->sclass_id; }
	void			FreeCaches() { delegate->FreeCaches(); } 		
	int				NumSubs() { return pblocks.Count() + 1; }  
	Animatable*		SubAnim(int i) { if (i == 0) return delegate; else return pblocks[i-1]; }
	TSTR			SubAnimName(int i) { if (i == 0) return delegate->GetObjectName(); else return pblocks[i-1]->GetLocalName(); }
	int				NumParamBlocks() { return pblocks.Count(); }
	IParamBlock2*	GetParamBlock(int i) { return pblocks[i]; }
	IParamBlock2*	GetParamBlockByID(BlockID id) { return MSPlugin::GetParamBlockByID(id); }
	void*			GetInterface(ULONG id) { if (id == I_MAXSCRIPTPLUGIN) return (MSPlugin*)this; else return NULL; }
	
	// From ReferenceMaker
//	RefResult		NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, PartID& partID, RefMessage message) { return REF_SUCCEED; }

	// From ReferenceTarget
	int				NumRefs() { return pblocks.Count() + 1; }
	RefTargetHandle GetReference(int i) { if (i == 0) return delegate; else return pblocks[i-1]; }
	void			SetReference(int i, RefTargetHandle rtarg) 
					{ 
						if (i == 0) 
						{
							if (rtarg == NULL)
								delegate->FreeCaches();
							delegate = (Modifier*)rtarg; 
						}
						else { if (i - 1 >= pblocks.Count()) pblocks.SetCount(i); pblocks[i-1] = (IParamBlock2*)rtarg; }
					}
	RefTargetHandle Clone(RemapDir& remap = NoRemap());

	// From BaseObject
	TCHAR *			GetObjectName() { return pc->class_name->to_string(); }
	void			BeginEditParams( IObjParam  *ip, ULONG flags,Animatable *prev);
	void			EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
	int				HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt)
						{ return delegate->HitTest(t, inode, type, crossing, flags, p, vpt); }
	int				Display(TimeValue t, INode* inode, ViewExp *vpt, int flags) 
						{ return delegate->Display(t, inode, vpt, flags); }		
	void			SetExtendedDisplay(int flags) { delegate->SetExtendedDisplay( flags); }      // for setting mode-dependent display attributes
	void			GetWorldBoundBox(TimeValue t,INode* inode, ViewExp *vpt, Box3& box) { delegate->GetWorldBoundBox(t, inode, vpt, box); }
	void			GetLocalBoundBox(TimeValue t, INode *inode,ViewExp* vpt,  Box3& box ) { delegate->GetLocalBoundBox(t, inode, vpt,  box ); }
	void			Snap(TimeValue t, INode* inode, SnapInfo *snap, IPoint2 *p, ViewExp *vpt) { delegate->Snap(t, inode, snap, p, vpt); }
	CreateMouseCallBack* GetCreateMouseCallBack() { return delegate->GetCreateMouseCallBack(); } 
	BOOL			ChangeTopology() {return delegate->ChangeTopology();}

	void			Move( TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin=FALSE ){ delegate->Move( t, partm, tmAxis, val, localOrigin ); }
	void			Rotate( TimeValue t, Matrix3& partm, Matrix3& tmAxis, Quat& val, BOOL localOrigin=FALSE ){ delegate->Rotate( t, partm, tmAxis, val, localOrigin ); }
	void			Scale( TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin=FALSE ){ delegate->Scale( t, partm, tmAxis, val, localOrigin ); }
	void			TransformStart(TimeValue t) { delegate->TransformStart( t); }
	void			TransformHoldingStart(TimeValue t) { delegate->TransformHoldingStart( t); }
	void			TransformHoldingFinish(TimeValue t) { delegate->TransformHoldingFinish( t); }             
	void			TransformFinish(TimeValue t) { delegate->TransformFinish( t); }            
	void			TransformCancel(TimeValue t) { delegate->TransformCancel( t); }            
	int				HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt, ModContext* mc) { return delegate->HitTest( t, inode, type, crossing, flags, p, vpt, mc); }
	int				Display(TimeValue t, INode* inode, ViewExp *vpt, int flags, ModContext* mc) { return delegate->Display( t, inode, vpt, flags, mc); };   // quick render in viewport, using current TM.         
	void			GetWorldBoundBox(TimeValue t,INode* inode, ViewExp *vpt, Box3& box, ModContext *mc) { delegate->GetWorldBoundBox( t, inode, vpt, box, mc); }

	void			CloneSelSubComponents(TimeValue t) { delegate->CloneSelSubComponents( t); }
	void			AcceptCloneSelSubComponents(TimeValue t) { delegate->AcceptCloneSelSubComponents( t); }
	void			 SelectSubComponent(
					HitRecord *hitRec, BOOL selected, BOOL all, BOOL invert=FALSE) { delegate->SelectSubComponent(hitRec, selected, all, invert); }
	void			ClearSelection(int selLevel) { delegate->ClearSelection( selLevel); }
	void			SelectAll(int selLevel) { delegate->SelectAll( selLevel); }
	void			InvertSelection(int selLevel) { delegate->InvertSelection( selLevel); }
	int				SubObjectIndex(HitRecord *hitRec) {return  delegate->SubObjectIndex(hitRec);}               
	void			ActivateSubobjSel(int level, XFormModes& modes ) { delegate->ActivateSubobjSel( level, modes ); }
	BOOL			SupportsNamedSubSels() {return  delegate->SupportsNamedSubSels();}
	void			ActivateSubSelSet(TSTR &setName) { delegate->ActivateSubSelSet(setName); }
	void			NewSetFromCurSel(TSTR &setName) { delegate->NewSetFromCurSel(setName); }
	void			RemoveSubSelSet(TSTR &setName) { delegate->RemoveSubSelSet(setName); }
	void			SetupNamedSelDropDown() { delegate->SetupNamedSelDropDown(); }
	int				NumNamedSelSets() {return  delegate->NumNamedSelSets();}
	TSTR			GetNamedSelSetName(int i) {return  delegate->GetNamedSelSetName( i);}
	void			SetNamedSelSetName(int i,TSTR &newName) { delegate->SetNamedSelSetName( i, newName); }
	void			NewSetByOperator(TSTR &newName,Tab<int> &sets,int op) { delegate->NewSetByOperator(newName, sets, op); }
	void			GetSubObjectCenters(SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc) { delegate->GetSubObjectCenters(cb, t, node, mc); }
	void			GetSubObjectTMs(SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc) { delegate->GetSubObjectTMs( cb, t, node, mc); }                          
	BOOL			HasUVW () { return delegate->HasUVW(); }
	BOOL			HasUVW (int mapChannel) { return delegate->HasUVW (mapChannel); }
	void			SetGenUVW(BOOL sw) { delegate->SetGenUVW( sw);   }	// applies to mapChannel 1
	void			SetGenUVW (int mapChannel, BOOL sw) { delegate->SetGenUVW ( mapChannel, sw); }
	void			ShowEndResultChanged (BOOL showEndResult) { delegate->ShowEndResultChanged ( showEndResult);  }
	
	// from Modifier
	Interval		LocalValidity(TimeValue t);
	ChannelMask		ChannelsUsed() { return delegate->ChannelsUsed(); }
	ChannelMask		ChannelsChanged() { return delegate->ChannelsChanged(); }
	// this is used to invalidate cache's in Edit Modifiers:
	void			NotifyInputChanged(Interval changeInt, PartID partID, RefMessage message, ModContext *mc) { delegate->NotifyInputChanged(changeInt, partID, message, mc); }

	// This is the method that is called when the modifier is needed to 
	// apply its effect to the object. Note that the INode* is always NULL
	// for object space modifiers.
	void			ModifyObject(TimeValue t, ModContext &mc, ObjectState* os, INode *node) { delegate->ModifyObject(t, mc, os, node); }

	// Modifiers that place a dependency on topology should return TRUE
	// for this method. An example would be a modifier that stores a selection
	// set base on vertex indices.
	BOOL			DependOnTopology(ModContext &mc) { return delegate->DependOnTopology(mc); }

	// this can return:
	//   DEFORM_OBJ_CLASS_ID -- not really a class, but so what
	//   MAPPABLE_OBJ_CLASS_ID -- ditto
	//   TRIOBJ_CLASS_ID
	//   BEZIER_PATCH_OBJ_CLASS_ID
	Class_ID		InputType() { return delegate->InputType(); }

	IOResult		SaveLocalData(ISave *isave, LocalModData *ld) { return delegate->SaveLocalData(isave, ld); }  
	IOResult		LoadLocalData(ILoad *iload, LocalModData **pld) { return delegate->LoadLocalData(iload, pld); }  
};

// ----------------------- MSPluginSimpleMod ----------------------
// scripted SimpleMod  (this one has full-implementation handler calls)

class MSPluginSimpleMod : public MSPlugin, public SimpleMod
{
public:
	IObjParam*		ip;					// ip for any currently open command panel dialogs
	Point3Value*	vec;				// cache for the Map parameter & local values
	Point3Value*	extent;
	Point3Value*	min;
	Point3Value*	max;
	Point3Value*	center;
	BOOL			busy;
	TimeValue		last_time;
	Point3			last_in, last_out;

	static CRITICAL_SECTION def_sync;	// thread synch for Map parameter cache
	static BOOL		setup_sync;
	
					MSPluginSimpleMod() { vec = extent = min = max = center = NULL; busy = FALSE; last_time = TIME_NegInfinity; }
					MSPluginSimpleMod(MSPluginClass* pc, BOOL loading);
				   ~MSPluginSimpleMod();

	static RefTargetHandle create(MSPluginClass* pc, BOOL loading);

	void			DeleteThis() {  DeleteAllRefsFromMe(); MSPlugin::DeleteThis(); }

	// From MSPlugin
	HWND			AddRollupPage(HINSTANCE hInst, TCHAR *dlgTemplate, DLGPROC dlgProc, TCHAR *title, LPARAM param=0,DWORD flags=0);
	void			DeleteRollupPage(HWND hRollup);
	IRollupWindow* GetRollupWindow();
	ReferenceTarget* get_delegate() { return NULL; }  // no delegate 

	// From Animatable
	void			GetClassName(TSTR& s) { s = TSTR(pc->class_name->to_string()); }  
	Class_ID		ClassID() { return pc->class_id; }
	SClass_ID		SuperClassID() { return pc->sclass_id; }
	void			FreeCaches() { } 		
	int				NumSubs() { return pblocks.Count() + 2; }  
	Animatable*		SubAnim(int i);
	TSTR			SubAnimName(int i);
	int				NumParamBlocks() { return pblocks.Count(); }
	IParamBlock2*	GetParamBlock(int i) { return pblocks[i]; }
	IParamBlock2*	GetParamBlockByID(BlockID id) { return MSPlugin::GetParamBlockByID(id); }
	void*			GetInterface(ULONG id) { if (id == I_MAXSCRIPTPLUGIN) return (MSPlugin*)this; else return NULL; }

	// From ReferenceMaker
	RefResult		NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, PartID& partID, RefMessage message) 
					{ 
						if (message == REFMSG_CHANGE) 
							last_time = TIME_NegInfinity;
						SimpleMod::NotifyRefChanged(changeInt, hTarget, partID, message);
						return ((MSPlugin*)this)->NotifyRefChanged(changeInt, hTarget, partID, message); 
					}

	// From ReferenceTarget
	int				NumRefs() { return pblocks.Count() + 2; }
	RefTargetHandle GetReference(int i);
	void			SetReference(int i, RefTargetHandle rtarg);
	void			RefDeleted() { MSPlugin::RefDeleted(); }
	RefTargetHandle Clone(RemapDir& remap = NoRemap());
	IOResult		Save(ISave *isave) { MSPlugin::Save(isave); return SimpleMod::Save(isave); }
    IOResult		Load(ILoad *iload) { MSPlugin::Load(iload); return SimpleMod::Load(iload); }

	// From BaseObject
	TCHAR *			GetObjectName() { return pc->class_name->to_string(); }
	void			BeginEditParams( IObjParam  *ip, ULONG flags,Animatable *prev);
	void			EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);

	// Clients of SimpleMod need to implement this method
	Deformer&		GetDeformer(TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat);
	void			InvalidateUI();
	Interval		GetValidity(TimeValue t);
	BOOL			GetModLimits(TimeValue t,float &zmin, float &zmax, int &axis);
};

class MSSimpleModXtnd : public MSPluginSimpleMod
{
public:
	SimpleMod*		delegate;		// my delegate

					MSSimpleModXtnd(MSPluginClass* pc, BOOL loading);
				   ~MSSimpleModXtnd() { DeleteAllRefsFromMe(); }

					void DeleteThis() {  DeleteAllRefsFromMe(); MSPlugin::DeleteThis(); }

	// From MSPlugin
	ReferenceTarget* get_delegate() { return delegate; } 

	// From Animatable
	void			GetClassName(TSTR& s) { s = TSTR(pc->class_name->to_string()); }  
	Class_ID		ClassID() { return pc->class_id; }
	SClass_ID		SuperClassID() { return pc->sclass_id; }
	void			FreeCaches() { delegate->FreeCaches(); } 		
	int				NumSubs() { return pblocks.Count() + 1; }  
	Animatable*		SubAnim(int i) { if (i == 0) return delegate; else return pblocks[i-1]; }
	TSTR			SubAnimName(int i) { if (i == 0) return delegate->GetObjectName(); else return pblocks[i-1]->GetLocalName(); }
	int				NumParamBlocks() { return pblocks.Count(); }
	IParamBlock2*	GetParamBlock(int i) { return pblocks[i]; }
	IParamBlock2*	GetParamBlockByID(BlockID id) { return MSPlugin::GetParamBlockByID(id); }
	void*			GetInterface(ULONG id) { if (id == I_MAXSCRIPTPLUGIN) return (MSPlugin*)this; else return NULL; }
	
	// From ReferenceMaker
//	RefResult		NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, PartID& partID, RefMessage message) { return REF_SUCCEED; }

	// From ReferenceTarget
	int				NumRefs() { return pblocks.Count() + 1; }
	RefTargetHandle GetReference(int i) { if (i == 0) return delegate; else return pblocks[i-1]; }
	void			SetReference(int i, RefTargetHandle rtarg) 
					{ 
						if (i == 0) 
						{
							if (rtarg == NULL)
								delegate->FreeCaches();
							delegate = (SimpleMod*)rtarg; 
						}
						else { if (i - 1 >= pblocks.Count()) pblocks.SetCount(i); pblocks[i-1] = (IParamBlock2*)rtarg; }
					}
	RefTargetHandle Clone(RemapDir& remap = NoRemap());

	// From BaseObject
	TCHAR *			GetObjectName() { return pc->class_name->to_string(); }
	void			BeginEditParams( IObjParam  *ip, ULONG flags,Animatable *prev);
	void			EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
	int				HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt, ModContext* mc)
						{ return delegate->HitTest(t, inode, type, crossing, flags, p, vpt, mc); }
	int				Display(TimeValue t, INode* inode, ViewExp *vpt, int flags, ModContext *mc) 
						{ return delegate->Display(t, inode, vpt, flags, mc); }		
	void			GetWorldBoundBox(TimeValue t,INode* inode, ViewExp *vpt, Box3& box, ModContext *mc) { delegate->GetWorldBoundBox(t, inode, vpt, box, mc); }
	void			GetLocalBoundBox(TimeValue t, INode *inode,ViewExp* vpt,  Box3& box ) { delegate->GetLocalBoundBox(t, inode, vpt,  box ); }
	void			Snap(TimeValue t, INode* inode, SnapInfo *snap, IPoint2 *p, ViewExp *vpt) { delegate->Snap(t, inode, snap, p, vpt); }
	CreateMouseCallBack* GetCreateMouseCallBack() { return delegate->GetCreateMouseCallBack(); } 
	BOOL			HasUVW() { return delegate->HasUVW(); }
	void			SetGenUVW(BOOL sw) { delegate->SetGenUVW(sw); }
		
	void			GetSubObjectCenters(SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc) { delegate->GetSubObjectCenters(cb, t, node, mc); }
	void			GetSubObjectTMs(SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc) { delegate->GetSubObjectTMs(cb, t, node, mc); }
	BOOL			ChangeTopology() { return delegate->ChangeTopology(); }
	
	// from Modifier
	ChannelMask		ChannelsUsed() { return delegate->ChannelsUsed(); }
	ChannelMask		ChannelsChanged() { return delegate->ChannelsChanged(); }
	// this is used to invalidate cache's in Edit Modifiers:
	void			NotifyInputChanged(Interval changeInt, PartID partID, RefMessage message, ModContext *mc) { delegate->NotifyInputChanged(changeInt, partID, message, mc); }

	// This is the method that is called when the modifier is needed to 
	// apply its effect to the object. Note that the INode* is always NULL
	// for object space modifiers.
	void			ModifyObject(TimeValue t, ModContext &mc, ObjectState* os, INode *node) { delegate->ModifyObject(t, mc, os, node); }

	// Modifiers that place a dependency on topology should return TRUE
	// for this method. An example would be a modifier that stores a selection
	// set base on vertex indices.
	BOOL			DependOnTopology(ModContext &mc) { return delegate->DependOnTopology(mc); }

	// this can return:
	//   DEFORM_OBJ_CLASS_ID -- not really a class, but so what
	//   MAPPABLE_OBJ_CLASS_ID -- ditto
	//   TRIOBJ_CLASS_ID
	//   BEZIER_PATCH_OBJ_CLASS_ID
	Class_ID		InputType() { return delegate->InputType(); }

	IOResult		SaveLocalData(ISave *isave, LocalModData *ld) { return delegate->SaveLocalData(isave, ld); }  
	IOResult		LoadLocalData(ILoad *iload, LocalModData **pld) { return delegate->LoadLocalData(iload, pld); } 

	// Clients of SimpleMod need to implement this method
	Deformer&		GetDeformer(TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat) { return delegate->GetDeformer(t, mc, mat, invmat); }
	void			InvalidateUI() { delegate->InvalidateUI(); }
	Interval		GetValidity(TimeValue t);
	BOOL			GetModLimits(TimeValue t,float &zmin, float &zmax, int &axis) { return delegate->GetModLimits(t, zmin,  zmax,  axis); }

};

// ----------------------- MSPluginTexmap ----------------------
// scripted Texmap

class MSPluginTexmap : public MSPlugin, public Texmap
{
public:
	static MSAutoMParamDlg* masterMDlg;						// master dialog containing all scripted rollout
	static IMtlParams*		ip;

					MSPluginTexmap() { }
					MSPluginTexmap(MSPluginClass* pc, BOOL loading);
				   ~MSPluginTexmap() { DeleteAllRefsFromMe(); }

	static RefTargetHandle create(MSPluginClass* pc, BOOL loading);

	// From MSPlugin
	HWND			AddRollupPage(HINSTANCE hInst, TCHAR *dlgTemplate, DLGPROC dlgProc, TCHAR *title, LPARAM param=0,DWORD flags=0);
	void			DeleteRollupPage(HWND hRollup);
	IRollupWindow*  GetRollupWindow();
	ReferenceTarget* get_delegate() { return NULL; } 


	// From Animatable
	void			DeleteThis();
	void			GetClassName(TSTR& s) { s = TSTR(pc->class_name->to_string()); }  
	Class_ID		ClassID() { return pc->class_id; }
	void			FreeCaches() { } 		
	int				NumSubs() { return pblocks.Count(); }  
	Animatable*		SubAnim(int i) { return pblocks[i]; }
	TSTR			SubAnimName(int i) { return pblocks[i]->GetLocalName(); }
	int				NumParamBlocks() { return pblocks.Count(); }
	IParamBlock2*	GetParamBlock(int i) { return pblocks[i]; }
	IParamBlock2*	GetParamBlockByID(BlockID id) { return MSPlugin::GetParamBlockByID(id); }
	void*			GetInterface(ULONG id) { if (id == I_MAXSCRIPTPLUGIN) return (MSPlugin*)this; else return NULL; }

	// From ReferenceMaker
	RefResult		NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, PartID& partID, RefMessage message) 
					{ 
						return ((MSPlugin*)this)->NotifyRefChanged(changeInt, hTarget, partID, message); 
					}

	// From ReferenceTarget
	int				NumRefs() { return pblocks.Count(); }
	RefTargetHandle GetReference(int i) { return pblocks[i]; }
	void			SetReference(int i, RefTargetHandle rtarg) 
					{ 
						if (i >= pblocks.Count()) pblocks.SetCount(i+1); pblocks[i] = (IParamBlock2*)rtarg; 
					}
	void			RefDeleted() { MSPlugin::RefDeleted(); }
	RefTargetHandle Clone(RemapDir& remap = NoRemap());

	// From MtlBase

	TSTR			GetFullName() { return MtlBase::GetFullName(); }
	int				BuildMaps(TimeValue t, RenderMapsContext &rmc) { return MtlBase::BuildMaps(t, rmc); }
	ULONG			Requirements(int subMtlNum) { return MtlBase::Requirements(subMtlNum); }
	ULONG			LocalRequirements(int subMtlNum) { return MtlBase::LocalRequirements(subMtlNum); }
	BOOL			IsMultiMtl() { return MtlBase::IsMultiMtl(); }
	int				NumSubTexmaps();
	Texmap*			GetSubTexmap(int i);
//	int				MapSlotType(int i) { return MtlBase::MapSlotType(i); }
	void			SetSubTexmap(int i, Texmap *m);
//	int				SubTexmapOn(int i) { return MtlBase::SubTexmapOn(i); }
//	void			DeactivateMapsInTree() { MtlBase::DeactivateMapsInTree(); }     
	TSTR			GetSubTexmapSlotName(int i);
	TSTR			GetSubTexmapTVName(int i) { return GetSubTexmapSlotName(i); }
//	void			CopySubTexmap(HWND hwnd, int ifrom, int ito) { MtlBase::CopySubTexmap(hwnd, ifrom, ito); }     
	void			Update(TimeValue t, Interval& valid) { }
	void			Reset() { pc->cd2->Reset(this, TRUE); }
	Interval		Validity(TimeValue t);
	ParamDlg*		CreateParamDlg(HWND hwMtlEdit, IMtlParams* imp);
	IOResult		Save(ISave *isave) { MSPlugin::Save(isave); return MtlBase::Save(isave); }
    IOResult		Load(ILoad *iload) { MSPlugin::Load(iload); return MtlBase::Load(iload); }
	ULONG			GetGBufID() { return MtlBase::GetGBufID(); }
	void			SetGBufID(ULONG id) { MtlBase::SetGBufID(id); }
	void			EnumAuxFiles(NameEnumCallback& nameEnum, DWORD flags) { MtlBase::EnumAuxFiles(nameEnum, flags); }   
	PStamp*			GetPStamp(int sz) { return MtlBase::GetPStamp(sz); }
	PStamp*			CreatePStamp(int sz) { return MtlBase::CreatePStamp(sz); }   		
	void			DiscardPStamp(int sz) { MtlBase::DiscardPStamp(sz); }      		

	// From Texmap

	// Evaluate the color of map for the context.
	AColor			EvalColor(ShadeContext& sc)  { return AColor (0,0,0); }
	
	// Evaluate the map for a "mono" channel.
	// this just permits a bit of optimization 
	float			EvalMono(ShadeContext& sc) { return Texmap::EvalMono(sc); }
	
	// For Bump mapping, need a perturbation to apply to a normal.
	// Leave it up to the Texmap to determine how to do this.
	Point3			EvalNormalPerturb(ShadeContext& sc) { return Point3(0,0,0); }

	// This query is made of maps plugged into the Reflection or 
	// Refraction slots:  Normally the view vector is replaced with
	// a reflected or refracted one before calling the map: if the 
	// plugged in map doesn't need this , it should return TRUE.
	BOOL			HandleOwnViewPerturb() { return Texmap::HandleOwnViewPerturb(); }

	BOOL			SupportTexDisplay() { return Texmap::SupportTexDisplay(); }
	void			ActivateTexDisplay(BOOL onoff) { Texmap::ActivateTexDisplay(onoff); }
	DWORD			GetActiveTexHandle(TimeValue t, TexHandleMaker& thmaker) {return Texmap::GetActiveTexHandle(t, thmaker);}

	void			GetUVTransform(Matrix3 &uvtrans) {Texmap::GetUVTransform(uvtrans); }
	int				GetTextureTiling() { return Texmap::GetTextureTiling(); }
	void			InitSlotType(int sType) { Texmap::InitSlotType(sType); }			   
	int				GetUVWSource() { return Texmap::GetUVWSource(); }
	int				GetMapChannel () { return Texmap::GetMapChannel (); }	// only relevant if above returns UVWSRC_EXPLICIT

	UVGen *			GetTheUVGen() { return Texmap::GetTheUVGen(); }  // maps with a UVGen should implement this
	XYZGen *		GetTheXYZGen() { return Texmap::GetTheXYZGen(); } // maps with a XYZGen should implement this

	// System function to set slot type for all subtexmaps in a tree.
	void			SetOutputLevel(TimeValue t, float v) { Texmap::SetOutputLevel(t, v); }

	// called prior to render: missing map names should be added to NameAccum.
	// return 1: success,   0:failure. 
	int				LoadMapFiles(TimeValue t) { return Texmap::LoadMapFiles(t); } 

	// render a 2-d bitmap version of map.
	void			RenderBitmap(TimeValue t, Bitmap *bm, float scale3D=1.0f, BOOL filter = FALSE) { Texmap::RenderBitmap(t, bm, scale3D, filter); }

	void			RefAdded(RefMakerHandle rm){ Texmap::RefAdded(rm); }

};


class MSTexmapXtnd : public MSPluginTexmap
{
public:
	Texmap*			delegate;		// my delegate

					MSTexmapXtnd(MSPluginClass* pc, BOOL loading);
				   ~MSTexmapXtnd() { DeleteAllRefsFromMe(); }

	void			DeleteThis();

	// From MSPlugin
	ReferenceTarget* get_delegate() { return delegate; } 

	// From Animatable
	void			GetClassName(TSTR& s) { s = TSTR(pc->class_name->to_string()); }  
	Class_ID		ClassID() { return pc->class_id; }
	void			FreeCaches() { delegate->FreeCaches(); } 		
	int				NumSubs() { return pblocks.Count() + 1; }  
	Animatable*		SubAnim(int i) { if (i == 0) return delegate; else return pblocks[i-1]; }
	TSTR			SubAnimName(int i) { if (i == 0) return pc->extend_cd->ClassName(); else return pblocks[i-1]->GetLocalName(); }
	int				NumParamBlocks() { return pblocks.Count(); }
	IParamBlock2*	GetParamBlock(int i) { return pblocks[i]; }
	IParamBlock2*	GetParamBlockByID(BlockID id) { return MSPlugin::GetParamBlockByID(id); }
	void*			GetInterface(ULONG id) { if (id == I_MAXSCRIPTPLUGIN) return (MSPlugin*)this; else return NULL; }
	
	// From ReferenceTarget
	int				NumRefs() { return pblocks.Count() + 1; }
	RefTargetHandle GetReference(int i) { if (i == 0) return delegate; else return pblocks[i-1]; }
	void			SetReference(int i, RefTargetHandle rtarg) 
					{ 
						if (i == 0) 
						{
							if (rtarg == NULL)
								delegate->FreeCaches();
							delegate = (Texmap*)rtarg; 
						}
						else { if (i - 1 >= pblocks.Count()) pblocks.SetCount(i); pblocks[i-1] = (IParamBlock2*)rtarg; }
					}
	RefTargetHandle Clone(RemapDir& remap = NoRemap());

	// From MtlBase

	int				BuildMaps(TimeValue t, RenderMapsContext &rmc) { return delegate->BuildMaps(t, rmc); }
	ULONG			Requirements(int subMtlNum) { return delegate->Requirements(subMtlNum); }
	ULONG			LocalRequirements(int subMtlNum) { return delegate->LocalRequirements(subMtlNum); }
	BOOL			IsMultiMtl() { return delegate->IsMultiMtl(); }
	void			Update(TimeValue t, Interval& valid) { delegate->Update(t, valid); }
	void			Reset() { delegate->Reset(); pc->cd2->Reset(this, TRUE); }
	Interval		Validity(TimeValue t);
	ParamDlg*		CreateParamDlg(HWND hwMtlEdit, IMtlParams* imp);
	IOResult		Save(ISave *isave) { return MSPlugin::Save(isave); } // return delegate->Save(isave); }
    IOResult		Load(ILoad *iload) { return MSPlugin::Load(iload); } // return delegate->Load(iload); }
	ULONG			GetGBufID() { return delegate->GetGBufID(); }
	void			SetGBufID(ULONG id) { delegate->SetGBufID(id); }
	void			EnumAuxFiles(NameEnumCallback& nameEnum, DWORD flags) { delegate->EnumAuxFiles(nameEnum, flags); }   
	PStamp*			GetPStamp(int sz) { return delegate->GetPStamp(sz); }
	PStamp*			CreatePStamp(int sz) { return delegate->CreatePStamp(sz); }   		
	void			DiscardPStamp(int sz) { delegate->DiscardPStamp(sz); }      		

	int				NumSubTexmaps();
	Texmap*			GetSubTexmap(int i);
//	int				MapSlotType(int i) { return MtlBase::MapSlotType(i); }
	void			SetSubTexmap(int i, Texmap *m);
//	int				SubTexmapOn(int i) { return MtlBase::SubTexmapOn(i); }
//	void			DeactivateMapsInTree() { MtlBase::DeactivateMapsInTree(); }     
	TSTR			GetSubTexmapSlotName(int i);

	// From Texmap

	// Evaluate the color of map for the context.
	AColor			EvalColor(ShadeContext& sc)  { return delegate->EvalColor(sc); }
	
	// Evaluate the map for a "mono" channel.
	// this just permits a bit of optimization 
	float			EvalMono(ShadeContext& sc) { return delegate->EvalMono(sc); }
	
	// For Bump mapping, need a perturbation to apply to a normal.
	// Leave it up to the Texmap to determine how to do this.
	Point3			EvalNormalPerturb(ShadeContext& sc) { return Point3(0,0,0); }

	// This query is made of maps plugged into the Reflection or 
	// Refraction slots:  Normally the view vector is replaced with
	// a reflected or refracted one before calling the map: if the 
	// plugged in map doesn't need this , it should return TRUE.
	BOOL			HandleOwnViewPerturb() { return delegate->HandleOwnViewPerturb(); }

	BOOL			SupportTexDisplay() { return delegate->SupportTexDisplay(); }
	void			ActivateTexDisplay(BOOL onoff) { delegate->ActivateTexDisplay(onoff); }
	DWORD			GetActiveTexHandle(TimeValue t, TexHandleMaker& thmaker) {return delegate->GetActiveTexHandle(t, thmaker);}

	void			GetUVTransform(Matrix3 &uvtrans) {delegate->GetUVTransform(uvtrans); }
	int				GetTextureTiling() { return delegate->GetTextureTiling(); }
	void			InitSlotType(int sType) { delegate->InitSlotType(sType); }			   
	int				GetUVWSource() { return delegate->GetUVWSource(); }
	int				GetMapChannel () { return delegate->GetMapChannel (); }	// only relevant if above returns UVWSRC_EXPLICIT

	UVGen *			GetTheUVGen() { return delegate->GetTheUVGen(); }  // maps with a UVGen should implement this
	XYZGen *		GetTheXYZGen() { return delegate->GetTheXYZGen(); } // maps with a XYZGen should implement this

	// System function to set slot type for all subtexmaps in a tree.
	void			SetOutputLevel(TimeValue t, float v) { delegate->SetOutputLevel(t, v); }

	// called prior to render: missing map names should be added to NameAccum.
	// return 1: success,   0:failure. 
	int				LoadMapFiles(TimeValue t) { return delegate->LoadMapFiles(t); } 

	// render a 2-d bitmap version of map.
	void			RenderBitmap(TimeValue t, Bitmap *bm, float scale3D=1.0f, BOOL filter = FALSE) { delegate->RenderBitmap(t, bm, scale3D, filter); }

//	void			RefAdded(RefMakerHandle rm){ delegate->RefAdded(rm); }
};

// ----------------------- MSPluginMtl ----------------------
// scripted Mtl

class MSPluginMtl : public MSPlugin, public Mtl
{
public:
	static MSAutoMParamDlg* masterMDlg; // master dialog containing all scripted rollout
	static IMtlParams*		ip;

					MSPluginMtl() { }
					MSPluginMtl(MSPluginClass* pc, BOOL loading);
				   ~MSPluginMtl() { DeleteAllRefsFromMe(); }

	static RefTargetHandle create(MSPluginClass* pc, BOOL loading);

	// From MSPlugin
	HWND			AddRollupPage(HINSTANCE hInst, TCHAR *dlgTemplate, DLGPROC dlgProc, TCHAR *title, LPARAM param=0,DWORD flags=0);
	void			DeleteRollupPage(HWND hRollup);
	IRollupWindow*  GetRollupWindow();
	ReferenceTarget* get_delegate() { return NULL; } 


	// From Animatable
	void			DeleteThis();
	void			GetClassName(TSTR& s) { s = TSTR(pc->class_name->to_string()); }  
	Class_ID		ClassID() { return pc->class_id; }
	void			FreeCaches() { } 		
	int				NumSubs() { return pblocks.Count(); }  
	Animatable*		SubAnim(int i) { return pblocks[i]; }
	TSTR			SubAnimName(int i) { return pblocks[i]->GetLocalName(); }
	int				NumParamBlocks() { return pblocks.Count(); }
	IParamBlock2*	GetParamBlock(int i) { return pblocks[i]; }
	IParamBlock2*	GetParamBlockByID(BlockID id) { return MSPlugin::GetParamBlockByID(id); }
	void*			GetInterface(ULONG id) { if (id == I_MAXSCRIPTPLUGIN) return (MSPlugin*)this; else return NULL; }

	// From ReferenceMaker
	RefResult		NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, PartID& partID, RefMessage message) 
					{ 
						return ((MSPlugin*)this)->NotifyRefChanged(changeInt, hTarget, partID, message); 
					}

	// From ReferenceTarget
	int				NumRefs() { return pblocks.Count(); }
	RefTargetHandle GetReference(int i) { return pblocks[i]; }
	void			SetReference(int i, RefTargetHandle rtarg) 
					{ 
						if (i >= pblocks.Count()) pblocks.SetCount(i+1); pblocks[i] = (IParamBlock2*)rtarg; 
					}
	RefTargetHandle Clone(RemapDir& remap = NoRemap());

	// From MtlBase

	TSTR			GetFullName() { return MtlBase::GetFullName(); }
	int				BuildMaps(TimeValue t, RenderMapsContext &rmc) { return MtlBase::BuildMaps(t, rmc); }
	ULONG			Requirements(int subMtlNum) { return MtlBase::Requirements(subMtlNum); }
	ULONG			LocalRequirements(int subMtlNum) { return MtlBase::LocalRequirements(subMtlNum); }
	BOOL			IsMultiMtl() { return MtlBase::IsMultiMtl(); }
	int				NumSubTexmaps();
	Texmap*			GetSubTexmap(int i);
//	int				MapSlotType(int i) { return MtlBase::MapSlotType(i); }
	void			SetSubTexmap(int i, Texmap *m);
//	int				SubTexmapOn(int i) { return MtlBase::SubTexmapOn(i); }
//	void			DeactivateMapsInTree() { MtlBase::DeactivateMapsInTree(); }     
	TSTR			GetSubTexmapSlotName(int i);
	TSTR			GetSubTexmapTVName(int i) { return GetSubTexmapSlotName(i); }
//	void			CopySubTexmap(HWND hwnd, int ifrom, int ito) { MtlBase::CopySubTexmap(hwnd, ifrom, ito); }     
	void			Update(TimeValue t, Interval& valid) { }
	void			Reset() { pc->cd2->Reset(this, TRUE); }
	Interval		Validity(TimeValue t);
	ParamDlg*		CreateParamDlg(HWND hwMtlEdit, IMtlParams* imp);
	IOResult		Save(ISave *isave) { MSPlugin::Save(isave); return MtlBase::Save(isave); }
    IOResult		Load(ILoad *iload) { MSPlugin::Load(iload); return MtlBase::Load(iload); }
	ULONG			GetGBufID() { return MtlBase::GetGBufID(); }
	void			SetGBufID(ULONG id) { MtlBase::SetGBufID(id); }
	void			EnumAuxFiles(NameEnumCallback& nameEnum, DWORD flags) { MtlBase::EnumAuxFiles(nameEnum, flags); }   
	PStamp*			GetPStamp(int sz) { return MtlBase::GetPStamp(sz); }
	PStamp*			CreatePStamp(int sz) { return MtlBase::CreatePStamp(sz); }   		
	void			DiscardPStamp(int sz) { MtlBase::DiscardPStamp(sz); }      		

	// From Mtl

	Texmap*			GetActiveTexmap() { return Mtl::GetActiveTexmap(); } 
	void			SetActiveTexmap( Texmap *txm) { Mtl::SetActiveTexmap(txm); } 
	void			RefDeleted() { Mtl::RefDeleted(); MSPlugin::RefDeleted(); } 
	void			RefAdded(RefMakerHandle rm) { Mtl::RefAdded(rm); }  
	Color			GetAmbient(int mtlNum=0, BOOL backFace=FALSE) { return Color(0,0,0); }
	Color			GetDiffuse(int mtlNum=0, BOOL backFace=FALSE) { return Color(0,0,0); }	    
	Color			GetSpecular(int mtlNum=0, BOOL backFace=FALSE) { return Color(0,0,0); }
	float			GetShininess(int mtlNum=0, BOOL backFace=FALSE) { return 0.0f; }
	float			GetShinStr(int mtlNum=0, BOOL backFace=FALSE) { return 0.0f; }		
	float			GetXParency(int mtlNum=0, BOOL backFace=FALSE) { return 0.0f; }
	BOOL			GetSelfIllumColorOn(int mtlNum=0, BOOL backFace=FALSE) { return Mtl::GetSelfIllumColorOn(mtlNum, backFace); } 
	float			GetSelfIllum(int mtlNum=0, BOOL backFace=FALSE) { return Mtl::GetSelfIllum(mtlNum, backFace); } 
	Color			GetSelfIllumColor(int mtlNum=0, BOOL backFace=FALSE) { return Mtl::GetSelfIllumColor(mtlNum, backFace); } 
	float			WireSize(int mtlNum=0, BOOL backFace=FALSE) { return Mtl::WireSize(mtlNum, backFace); } 
	void			SetAmbient(Color c, TimeValue t) { }		
	void			SetDiffuse(Color c, TimeValue t) { }		
	void			SetSpecular(Color c, TimeValue t) { }
	void			SetShininess(float v, TimeValue t) { }	
	void			Shade(ShadeContext& sc) { }
	int				NumSubMtls();
	Mtl*			GetSubMtl(int i);
	void			SetSubMtl(int i, Mtl *m);
	TSTR			GetSubMtlSlotName(int i);
	TSTR			GetSubMtlTVName(int i) { return GetSubMtlSlotName(i); } 					  
//	void			CopySubMtl(HWND hwnd, int ifrom, int ito) { Mtl::CopySubMtl(hwnd, ifrom, ito); }  
	float			GetDynamicsProperty(TimeValue t, int mtlNum, int propID) { return Mtl::GetDynamicsProperty(t, mtlNum, propID); } 
	void			SetDynamicsProperty(TimeValue t, int mtlNum, int propID, float value) { Mtl::SetDynamicsProperty(t, mtlNum, propID, value); } 
	float			EvalDisplacement(ShadeContext& sc) { return Mtl::EvalDisplacement(sc); } 
	Interval		DisplacementValidity(TimeValue t) { return Mtl::DisplacementValidity(t); } 

};


class MSMtlXtnd : public MSPluginMtl
{
public:
	Mtl*			delegate;		// my delegate

					MSMtlXtnd(MSPluginClass* pc, BOOL loading);
				   ~MSMtlXtnd() { DeleteAllRefsFromMe(); }

	void			DeleteThis();

	// From MSPlugin
	ReferenceTarget* get_delegate() { return delegate; } 

	// From Animatable
	void			GetClassName(TSTR& s) { s = TSTR(pc->class_name->to_string()); }  
	Class_ID		ClassID() { return pc->class_id; }
	void			FreeCaches() { delegate->FreeCaches(); } 		
	int				NumSubs() { return pblocks.Count() + 1; }  
	Animatable*		SubAnim(int i) { if (i == 0) return delegate; else return pblocks[i-1]; }
	TSTR			SubAnimName(int i) { if (i == 0) return pc->extend_cd->ClassName(); else return pblocks[i-1]->GetLocalName(); }
	int				NumParamBlocks() { return pblocks.Count(); }
	IParamBlock2*	GetParamBlock(int i) { return pblocks[i]; }
	IParamBlock2*	GetParamBlockByID(BlockID id) { return MSPlugin::GetParamBlockByID(id); }
	void*			GetInterface(ULONG id) { if (id == I_MAXSCRIPTPLUGIN) return (MSPlugin*)this; else return NULL; }
	
	// From ReferenceMaker
//	RefResult		NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, PartID& partID, RefMessage message) { return REF_SUCCEED; }

	// From ReferenceTarget
	int				NumRefs() { return pblocks.Count() + 1; }
	RefTargetHandle GetReference(int i) { if (i == 0) return delegate; else return pblocks[i-1]; }
	void			SetReference(int i, RefTargetHandle rtarg) 
					{ 
						if (i == 0) 
						{
							if (rtarg == NULL)
								delegate->FreeCaches();
							delegate = (Mtl*)rtarg; 
						}
						else { if (i - 1 >= pblocks.Count()) pblocks.SetCount(i); pblocks[i-1] = (IParamBlock2*)rtarg; }
					}
	RefTargetHandle Clone(RemapDir& remap = NoRemap());

	// From MtlBase

	TSTR			GetFullName() { return delegate->GetFullName(); }
	int				BuildMaps(TimeValue t, RenderMapsContext &rmc) { return delegate->BuildMaps(t, rmc); }
	ULONG			Requirements(int subMtlNum) { return delegate->Requirements(subMtlNum); }
	ULONG			LocalRequirements(int subMtlNum) { return delegate->LocalRequirements(subMtlNum); }
	BOOL			IsMultiMtl() { return delegate->IsMultiMtl(); }
	int				NumSubTexmaps();
	Texmap*			GetSubTexmap(int i);
//	int				MapSlotType(int i) { return delegate->MapSlotType(i); }
	void			SetSubTexmap(int i, Texmap *m);
//	int				SubTexmapOn(int i) { return delegate->SubTexmapOn(i); }
//	void			DeactivateMapsInTree() { delegate->DeactivateMapsInTree(); }     
	TSTR			GetSubTexmapSlotName(int i);
//	TSTR			GetSubTexmapTVName(int i) { return delegate->GetSubTexmapTVName(i); }
//	void			CopySubTexmap(HWND hwnd, int ifrom, int ito) { delegate->CopySubTexmap(hwnd, ifrom, ito); }     	
	
	void			Update(TimeValue t, Interval& valid) { delegate->Update(t, valid); }
	void			Reset() { delegate->Reset(); pc->cd2->Reset(this, TRUE); }
	Interval		Validity(TimeValue t);
	ParamDlg*		CreateParamDlg(HWND hwMtlEdit, IMtlParams* imp);
	IOResult		Save(ISave *isave) { return MSPlugin::Save(isave); } // return delegate->Save(isave); }
    IOResult		Load(ILoad *iload) { return MSPlugin::Load(iload); } // return delegate->Load(iload); }
	ULONG			GetGBufID() { return delegate->GetGBufID(); }
	void			SetGBufID(ULONG id) { delegate->SetGBufID(id); }
	void			EnumAuxFiles(NameEnumCallback& nameEnum, DWORD flags) { delegate->EnumAuxFiles(nameEnum, flags); }   
	PStamp*			GetPStamp(int sz) { return delegate->GetPStamp(sz); }
	PStamp*			CreatePStamp(int sz) { return delegate->CreatePStamp(sz); }   		
	void			DiscardPStamp(int sz) { delegate->DiscardPStamp(sz); }      		

	// From Mtl

	BOOL			DontKeepOldMtl() { return TRUE; }
	Texmap*			GetActiveTexmap() { return delegate->GetActiveTexmap(); } 
	void			SetActiveTexmap( Texmap *txm) { delegate->SetActiveTexmap(txm); } 
//	void			RefDeleted() { delegate->RefDeleted(); } 
//	void			RefAdded(RefMakerHandle rm) { delegate->RefAdded(rm); }  
	Color			GetAmbient(int mtlNum=0, BOOL backFace=FALSE) { return delegate->GetAmbient(mtlNum, backFace); }
	Color			GetDiffuse(int mtlNum=0, BOOL backFace=FALSE) { return delegate->GetDiffuse(mtlNum, backFace); }	    
	Color			GetSpecular(int mtlNum=0, BOOL backFace=FALSE) { return delegate->GetSpecular(mtlNum, backFace); }
	float			GetShininess(int mtlNum=0, BOOL backFace=FALSE) { return delegate->GetShininess(mtlNum=0, backFace); }
	float			GetShinStr(int mtlNum=0, BOOL backFace=FALSE) { return delegate->GetShinStr(mtlNum=0, backFace); }		
	float			GetXParency(int mtlNum=0, BOOL backFace=FALSE) { return delegate->GetXParency(mtlNum=0, backFace); }
	BOOL			GetSelfIllumColorOn(int mtlNum=0, BOOL backFace=FALSE) { return delegate->GetSelfIllumColorOn(mtlNum, backFace); } 
	float			GetSelfIllum(int mtlNum=0, BOOL backFace=FALSE) { return delegate->GetSelfIllum(mtlNum, backFace); } 
	Color			GetSelfIllumColor(int mtlNum=0, BOOL backFace=FALSE) { return delegate->GetSelfIllumColor(mtlNum, backFace); } 
	float			WireSize(int mtlNum=0, BOOL backFace=FALSE) { return delegate->WireSize(mtlNum, backFace); } 
	void			SetAmbient(Color c, TimeValue t) { delegate->SetAmbient(c, t); }		
	void			SetDiffuse(Color c, TimeValue t) { delegate->SetDiffuse(c, t); }		
	void			SetSpecular(Color c, TimeValue t) { delegate->SetSpecular(c, t); }
	void			SetShininess(float v, TimeValue t) { delegate->SetShininess(v, t); }	
	void			Shade(ShadeContext& sc) { delegate->Shade(sc); }
	int				NumSubMtls();
	Mtl*			GetSubMtl(int i);
	void			SetSubMtl(int i, Mtl *m);
	TSTR			GetSubMtlSlotName(int i);
	TSTR			GetSubMtlTVName(int i) { return GetSubMtlSlotName(i); } 					  
//	void			CopySubMtl(HWND hwnd, int ifrom, int ito) { delegate->CopySubMtl(hwnd, ifrom, ito); }  
	float			GetDynamicsProperty(TimeValue t, int mtlNum, int propID) { return delegate->GetDynamicsProperty(t, mtlNum, propID); } 
	void			SetDynamicsProperty(TimeValue t, int mtlNum, int propID, float value) { delegate->SetDynamicsProperty(t, mtlNum, propID, value); } 
	float			EvalDisplacement(ShadeContext& sc) { return delegate->EvalDisplacement(sc); } 
	Interval		DisplacementValidity(TimeValue t) { return delegate->DisplacementValidity(t); } 
};

/* ------------- ParamDlg class for scripter material/texmap plug-ins --------------- */

class MSAutoMParamDlg : public IAutoMParamDlg 
{
	public:
		Tab<ParamDlg*>	secondaryDlgs;	// secondary ParamDlgs if this is a master
		ParamDlg*		delegateDlg;	// my delegate's dialog if any
		MSPlugin*		plugin;			// target plugin
		Rollout*		ro;				// rollout controlling dialog
		MtlBase*		mtl;			// material in the dialog
		IMtlParams*		ip;				// mtl interface
		TexDADMgr		texDadMgr;
		MtlDADMgr		mtlDadMgr;
		HWND			hwmedit;		// medit window

					MSAutoMParamDlg(HWND hMedit, IMtlParams *i, MtlBase* mtl, MSPlugin* plugin, Rollout* ro);
				   ~MSAutoMParamDlg();

		// from ParamDlg
		Class_ID	ClassID() { return mtl->ClassID(); }
		ReferenceTarget* GetThing() { return mtl; }
		void		SetThing(ReferenceTarget *m);
		void		DeleteThis();
		void		SetTime(TimeValue t);
		void		ReloadDialog();
		void		ActivateDlg(BOOL onOff);
		int			FindSubTexFromHWND(HWND hw);	
		int			FindSubMtlFromHWND(HWND hw);	

		void		InvalidateUI() { ReloadDialog(); }
		void		MtlChanged() { ip->MtlChanged(); }
		// secondary dialog list management
		int			NumDlgs() { return secondaryDlgs.Count(); }
		void		AddDlg(ParamDlg* dlg);
		ParamDlg*	GetDlg(int i);
		void		SetDlg(int i, ParamDlg* dlg);
		void		DeleteDlg(ParamDlg* dlg);

		// access to this dlg's parammap stuff
		IParamMap2* GetMap() { return NULL; }
};

// RK: Start
// ----------------------- MSPluginSpecialFX ----------------------

//	template for MSPlugin classes derived from SpecialFX
template <class TYPE>
class MSPluginSpecialFX : public TYPE, public MSPlugin
{
public:
	IRendParams		*ip;

	void			DeleteThis();
	
	// From MSPlugin
	HWND			AddRollupPage(HINSTANCE hInst, TCHAR *dlgTemplate, DLGPROC dlgProc, TCHAR *title, LPARAM param=0,DWORD flags=0);
	void			DeleteRollupPage(HWND hRollup);
	IRollupWindow*  GetRollupWindow();
	ReferenceTarget* get_delegate() { return NULL; }  // no delegate

	// From Animatable
	void			GetClassName(TSTR& s) { s = TSTR(pc->class_name->to_string()); }  
	Class_ID		ClassID() { return pc->class_id; }
	void			FreeCaches() { } 		
	int				NumSubs() { return pblocks.Count(); }  
	Animatable*		SubAnim(int i) { return pblocks[i]; }
	TSTR			SubAnimName(int i) { return pblocks[i]->GetLocalName(); }
	int				NumParamBlocks() { return pblocks.Count(); }
	IParamBlock2*	GetParamBlock(int i) { return pblocks[i]; }
	IParamBlock2*	GetParamBlockByID(BlockID id) { return MSPlugin::GetParamBlockByID(id); }
	void*			GetInterface(ULONG id) { if (id == I_MAXSCRIPTPLUGIN) return (MSPlugin*)this; else return NULL; }

	// From ReferenceMaker
	RefResult		NotifyRefChanged( Interval changeInt,RefTargetHandle hTarget, PartID& partID, RefMessage message)
					{ 
						return ((MSPlugin*)this)->NotifyRefChanged(changeInt, hTarget, partID, message); 
					}

	// From ReferenceTarget
	int				NumRefs() { return pblocks.Count(); }
	RefTargetHandle GetReference(int i) { return pblocks[i]; }
	void			SetReference(int i, RefTargetHandle rtarg) 
					{ 
						if (i >= pblocks.Count()) pblocks.SetCount(i+1); pblocks[i] = (IParamBlock2*)rtarg; 
					}
	void			RefDeleted() { MSPlugin::RefDeleted(); }
	IOResult		Save(ISave *isave) { MSPlugin::Save(isave); return SpecialFX::Save(isave); }
    IOResult		Load(ILoad *iload) { MSPlugin::Load(iload); return SpecialFX::Load(iload); }

	// From SpecialFX
	TSTR			GetName() { return pc->class_name->to_string(); }
	BOOL			Active(TimeValue t) { return SpecialFX::Active(t); }
	void			Update(TimeValue t, Interval& valid) { SpecialFX::Update(t, valid); }
	int				NumGizmos() { return SpecialFX::NumGizmos(); }
	INode*			GetGizmo(int i) { return SpecialFX::GetGizmo(i); }
	void			DeleteGizmo(int i) { SpecialFX::DeleteGizmo(i); }
	void			AppendGizmo(INode *node) { SpecialFX::AppendGizmo(node); }
	BOOL			OKGizmo(INode *node) { return SpecialFX::OKGizmo(node); } 
	void			EditGizmo(INode *node) { SpecialFX::EditGizmo(node); } 
};

//	template for MSPlugin Xtnd classes derived from SpecialFX
template <class TYPE, class MS_SUPER>
class MSSpecialFXXtnd : public MS_SUPER
{
public:
	TYPE*			delegate;		// my delegate

	void			DeleteThis();

	// From MSPlugin
	ReferenceTarget* get_delegate() { return delegate; } 

	// From Animatable
	void			GetClassName(TSTR& s) { s = TSTR(pc->class_name->to_string()); }  
	Class_ID		ClassID() { return pc->class_id; }
	void			FreeCaches() { delegate->FreeCaches(); } 		
	int				NumSubs() { return pblocks.Count() + 1; }  
	Animatable*		SubAnim(int i) { if (i == 0) { return delegate; } else return pblocks[i-1]; }
	TSTR			SubAnimName(int i) { if (i == 0) { TSTR n; delegate->GetClassName(n); return n; } else return pblocks[i-1]->GetLocalName(); }
	int				NumParamBlocks() { return pblocks.Count(); }
	IParamBlock2*	GetParamBlock(int i) { return pblocks[i]; }
	IParamBlock2*	GetParamBlockByID(BlockID id) { return MSPlugin::GetParamBlockByID(id); }
	void*			GetInterface(ULONG id) { if (id == I_MAXSCRIPTPLUGIN) return (MSPlugin*)this; else return NULL; }
	
	// From ReferenceMaker
//	RefResult		NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, PartID& partID, RefMessage message) { return REF_SUCCEED; }

	// From ReferenceTarget
	int				NumRefs() { return pblocks.Count() + 1; }
	RefTargetHandle GetReference(int i) { if (i == 0) return delegate; else return pblocks[i-1]; }
	void			SetReference(int i, RefTargetHandle rtarg) 
					{ 
						if (i == 0) 
						{
							if (rtarg == NULL)
								delegate->FreeCaches();
							delegate = (TYPE*)rtarg; 
						}
						else { if (i - 1 >= pblocks.Count()) pblocks.SetCount(i); pblocks[i-1] = (IParamBlock2*)rtarg; }
					}

	// From SpecialFX
	BOOL			Active(TimeValue t) { return delegate->Active(t); }
	void			Update(TimeValue t, Interval& valid) { delegate->Update(t, valid); }
	int				NumGizmos() { return delegate->NumGizmos(); }
	INode*			GetGizmo(int i) { return delegate->GetGizmo(i); }
	void			DeleteGizmo(int i) { delegate->DeleteGizmo(i); }
	void			AppendGizmo(INode *node) { delegate->AppendGizmo(node); }
	BOOL			OKGizmo(INode *node) { return delegate->OKGizmo(node); } 
	void			EditGizmo(INode *node) { delegate->EditGizmo(node); } 
};

// ----------------------- MSPluginEffect ----------------------
// scripted Effect

class MSPluginEffect : public MSPluginSpecialFX<Effect>
{
public:
	MSAutoEParamDlg* masterFXDlg;						// master dialog containing all scripted rollout

					MSPluginEffect() { }
					MSPluginEffect(MSPluginClass* pc, BOOL loading);
				   ~MSPluginEffect() { DeleteAllRefsFromMe(); }

	static RefTargetHandle create(MSPluginClass* pc, BOOL loading);
	RefTargetHandle Clone(RemapDir& remap = NoRemap());

	// from Effect
	EffectParamDlg*	CreateParamDialog(IRendParams* imp);
	DWORD			GBufferChannelsRequired(TimeValue t);
	void			Apply(TimeValue t, Bitmap *bm, RenderGlobalContext *gc, CheckAbortCallback *cb );

	Effect*			to_effect() { return this; }
};

class MSEffectXtnd : public MSSpecialFXXtnd<Effect, MSPluginEffect>
{
public:
					MSEffectXtnd(MSPluginClass* pc, BOOL loading);
	RefTargetHandle Clone(RemapDir& remap = NoRemap());

	// from Effect
	EffectParamDlg*	CreateParamDialog(IRendParams* imp);
	DWORD			GBufferChannelsRequired(TimeValue t);
	void			Apply(TimeValue t, Bitmap *bm, RenderGlobalContext *gc, CheckAbortCallback *cb );

};

/* ------------- ParamDlg class for scripter effect plug-ins --------------- */

class MSAutoEParamDlg : public IAutoEParamDlg 
{
	public:
		Tab<SFXParamDlg*> secondaryDlgs; // secondary ParamDlgs if this is a master
		SFXParamDlg*	delegateDlg;	// my delegate's dialog if any
		MSPlugin*		plugin;			// target plugin
		Rollout*		ro;				// rollout controlling dialog
		SpecialFX*		sfx;			// effect/atmos in the dialog
		IRendParams*	ip;				// render interface

					MSAutoEParamDlg(IRendParams *i, SpecialFX* fx, MSPlugin* plugin, Rollout* ro);
				   ~MSAutoEParamDlg();

		// from ParamDlg
		Class_ID	ClassID() { return sfx->ClassID(); }
		ReferenceTarget* GetThing() { return sfx; }
		void		SetThing(ReferenceTarget *fx);
		void		DeleteThis();
		void		SetTime(TimeValue t);

		void		InvalidateUI(); 
		// secondary dialog list management
		int			NumDlgs() { return secondaryDlgs.Count(); }
		void		AddDlg(SFXParamDlg* dlg);
		SFXParamDlg* GetDlg(int i);
		void		SetDlg(int i, SFXParamDlg* dlg);
		void		DeleteDlg(SFXParamDlg* dlg);

		// access to this dlg's parammap stuff
		IParamMap2* GetMap() { return NULL; }
};

// RK: End 

// ----------------------- MSPluginAtmos ----------------------
// scripted Atmospheric

class MSPluginAtmos : public MSPluginSpecialFX<Atmospheric>
{
public:
	MSAutoEParamDlg* masterFXDlg;						// master dialog containing all scripted rollout

					MSPluginAtmos() { }
					MSPluginAtmos(MSPluginClass* pc, BOOL loading);
				   ~MSPluginAtmos() { DeleteAllRefsFromMe(); }

	static RefTargetHandle create(MSPluginClass* pc, BOOL loading);
	RefTargetHandle Clone(RemapDir& remap = NoRemap());

	// from Atmospheric
	AtmosParamDlg *CreateParamDialog(IRendParams *ip);
	BOOL SetDlgThing(AtmosParamDlg* dlg);
	void Shade(ShadeContext& sc,const Point3& p0,const Point3& p1,Color& color, Color& trans, BOOL isBG=FALSE) { };

	Atmospheric* to_atmospheric() { return this; }
};

class MSAtmosXtnd : public MSSpecialFXXtnd<Atmospheric, MSPluginAtmos>
{
public:
					MSAtmosXtnd(MSPluginClass* pc, BOOL loading);
				   ~MSAtmosXtnd() { DeleteAllRefsFromMe(); }
	RefTargetHandle Clone(RemapDir& remap = NoRemap());

	// from Atmospheric
	AtmosParamDlg *CreateParamDialog(IRendParams *ip);
	BOOL SetDlgThing(AtmosParamDlg* dlg);
	void Shade(ShadeContext& sc,const Point3& p0,const Point3& p1,Color& color, Color& trans, BOOL isBG=FALSE) 
		{ delegate->Shade(sc, p0, p1, color, trans, isBG); }

};

// RK: End 
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\MeshSub.h ===
/*	
 *		MeshSub.h - edit mesh sub-object classes & functions
 *					also includes MeshDelta and MNMesh scripter classes
 *
 *	exposes the new-with-R3 MeshDelta, MapDelta & MeshSel tools for
 *  working with meshes.  Also provides access to MNMesh tools and 
 *  mesh sub-objects as direct properties on nodes.
 *
 *			Copyright  Autodesk, Inc., 1998
 *				John Wainwright
 */

#ifndef _H_MESHSUB
#define _H_MESHSUB

// mesh selection types
#define MSEL_ALL		1		// whole mesh selected 
#define MSEL_CUR		2		// current selection 
#define MSEL_EXP		3		// explicit selection (in vsel) 
#define MSEL_SINGLE		4		// explicit single index  

/* -------------- base class for mesh sub-object selections ------------------- */

class MeshSelection : public Value
{
public:
	MAXWrapper*	owner;			// owner node or modifier if any
	BYTE		sel_type;		// selection type
	BitArray	vsel;			// stand-alone selection if any
	DWORD		index;			// single vert index 			

	void		gc_trace();

	virtual MeshSelection* new_sel(MAXWrapper* own, BYTE stype, DWORD indx = 0) = 0;

	// utility functions to be specialized
	virtual BitArray* get_sel() = 0;	// my element selection
	virtual BitArray* get_owner_sel() = 0;	// owner's element selection
	virtual BitArray get_sel_vertices(Mesh* m) = 0;	// vertexes involved in my element selection
	virtual GenericNamedSelSetList& get_named_sel_set_list() = 0;
	virtual int		num_elements(Mesh* m) = 0;
	virtual BOOL	is_same_selection(Value* s) = 0;
	virtual void	delete_sel(Mesh& m, MeshDelta& md, BitArray &sel) = 0;

	// utility functions
			DWORD	get_sel_index(BitArray* vs, int n);  // index for n'th item vertex in BitArray
			void	update_sel();
			void	sprin1(TCHAR* type, CharStream* s);

	// operations
#include "defimpfn.h"
#	include "arraypro.h"
	def_generic ( move,			"move");
	def_generic ( scale,		"scale");
	def_generic ( rotate,		"rotate");
	def_generic ( delete,		"delete");
	def_generic ( select,		"select");
	def_generic ( deselect,		"deselect");
	def_generic ( selectmore,	"selectMore");

	ScripterExport Value* map(node_map& m);

	// built-in property accessors
	def_property ( count );
	def_property ( index );
	def_property ( selSetNames );
};

/* ---------------- mesh vertex selection --------------------- */

visible_class (VertSelectionValue)

class VertSelectionValue : public MeshSelection
{
public:
	ScripterExport VertSelectionValue(MAXWrapper* own, BYTE stype, DWORD indx = 0);
	
	MeshSelection* new_sel(MAXWrapper* own, BYTE stype, DWORD indx = 0);

				classof_methods (VertSelectionValue, Value);
#	define		is_vertselection(v) ((v)->tag == class_tag(VertSelectionValue))
	void		collect() { delete this; }
	ScripterExport void sprin1(CharStream* s);

	// specialized utility functions
	BitArray*	get_sel();
	BitArray*	get_owner_sel() { return (owner == NULL) ? NULL : owner->get_vertsel(); }
	BitArray	get_sel_vertices(Mesh* m);
	GenericNamedSelSetList& get_named_sel_set_list() { return owner->get_named_vertsel_set(); }
	int			num_elements(Mesh* m) { return m->getNumVerts(); } 
	BOOL		is_same_selection(Value* s) { return is_vertselection(s); }
	void		delete_sel(Mesh& m, MeshDelta& md, BitArray &sel) { md.DeleteVertSet(m, sel); }

	// operations
	def_generic ( put,			"put");

	// built-in property accessors
	def_property ( pos );
};

/* ---------------- mesh face selection --------------------- */

visible_class (FaceSelectionValue)

class FaceSelectionValue : public MeshSelection
{
public:
	ScripterExport FaceSelectionValue(MAXWrapper* own, BYTE stype, DWORD indx = 0);
	
	MeshSelection* new_sel(MAXWrapper* own, BYTE stype, DWORD indx = 0);

				classof_methods (FaceSelectionValue, Value);
#	define		is_faceselection(v) ((v)->tag == class_tag(FaceSelectionValue))
	void		collect() { delete this; }
	ScripterExport void sprin1(CharStream* s);

	// specialized utility functions
	BitArray*	get_sel();
	BitArray*	get_owner_sel() { return (owner == NULL) ? NULL : owner->get_facesel(); }
	BitArray	get_sel_vertices(Mesh* m);
	GenericNamedSelSetList& get_named_sel_set_list() { return owner->get_named_facesel_set(); }
	int			num_elements(Mesh* m) { return m->getNumFaces(); } 
	BOOL		is_same_selection(Value* s) { return is_faceselection(s); }
	void		delete_sel(Mesh& m, MeshDelta& md, BitArray &sel) { md.DeleteFaceSet(m, sel); }

	// operations
	def_generic ( put,			"put");

	// built-in property accessors
};

/* ---------------- edge face selection --------------------- */

visible_class (EdgeSelectionValue)

class EdgeSelectionValue : public MeshSelection
{
public:
	ScripterExport EdgeSelectionValue(MAXWrapper* own, BYTE stype, DWORD indx = 0);
	
	MeshSelection* new_sel(MAXWrapper* own, BYTE stype, DWORD indx = 0);

				classof_methods (EdgeSelectionValue, Value);
#	define		is_edgeselection(v) ((v)->tag == class_tag(EdgeSelectionValue))
	void		collect() { delete this; }
	ScripterExport void sprin1(CharStream* s);

	// specialized utility functions
	BitArray*	get_sel();
	BitArray*	get_owner_sel() { return (owner == NULL) ? NULL : owner->get_edgesel(); }
	BitArray	get_sel_vertices(Mesh* m);
	GenericNamedSelSetList& get_named_sel_set_list() { return owner->get_named_edgesel_set(); }
	int			num_elements(Mesh* m) { return m->getNumFaces() * 3; } 
	BOOL		is_same_selection(Value* s) { return is_edgeselection(s); }
	void		delete_sel(Mesh& m, MeshDelta& md, BitArray &sel) { md.DeleteEdgeSet(m, sel); }

	// operations

	// built-in property accessors
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\MAXObj.h ===
/*	
 *		MAXObject.h - MAX object wrapper classes in MAXScript
 *
 *			Copyright  John Wainwright 1996
 *
 */

#ifndef _H_MAXOBJECT
#define _H_MAXOBJECT

#include "Max.h"
#include "SimpObj.h"
#include "Pathname.h"
#include "istdplug.h"
#include "tvnode.h"

extern ScripterExport Interface* MAXScript_interface;
class MAXControl;

#define MESH_READ_ACCESS	0  // mesh access modes
#define MESH_WRITE_ACCESS	1
#define MESH_BASE_OBJ		2

/* --------------------- base wrapper class ------------------------ */

/* subclasses of MAXWrapper act as MAXScript-side proxies for MAX-side objects,
 * such as nodes, modifiers, materials, etc.  The prime purpose of MAXWrapper is
 * to maintain MAX referenced to the MAX-side objects it wraps & process delete notify messages
 *
 * subclasses should all do a MakeRefByID for each ref on creation & check for 
 * any ref deletion on the MAX side by using the check_for_deletion() macro.
 */

extern ScripterExport TCHAR* get_deleted_obj_err_message();

#define check_for_deletion()  if (ref_deleted) throw RuntimeError (get_deleted_obj_err_message(), class_name());
#define deletion_check(val)  if ((val)->ref_deleted) throw RuntimeError (get_deleted_obj_err_message(), (val)->class_name());

visible_class (MAXWrapper)

class MAXWrapper : public Value, public ReferenceTarget // ReferenceMaker
{
public:
	Tab<RefTargetHandle> refs;		/* reference array		*/
	short		ref_deleted;		 

	ScripterExport			MAXWrapper();
	ScripterExport			~MAXWrapper();
	
	ScripterExport Value*		classOf_vf(Value** arg_list, int count);
	ScripterExport Value*		superClassOf_vf(Value** arg_list, int count);
	ScripterExport Value*		isKindOf_vf(Value** arg_list, int count);
	BOOL		is_kind_of(ValueMetaClass* c) { return (c == class_tag(MAXWrapper)) ? 1 : Value::is_kind_of(c); }
	void		collect() { delete this; }
	virtual	TCHAR* class_name() = 0;
	virtual ReferenceTarget* get_max_object() { return GetReference(0); }
	ScripterExport Value*		copy_no_undo(Value** arg_list, int count);

	ScripterExport void make_ref(int ref_no, ReferenceTarget* ref);
	void		drop_MAX_refs() { DeleteAllRefsFromMe(); }

    // Animatable
	Class_ID ClassID() { return Class_ID(MAXSCRIPT_WRAPPER_CLASS_ID, 0); }
	SClass_ID SuperClassID() { return MAXSCRIPT_WRAPPER_CLASS_ID; }		

	// ReferenceMaker
	int			NumRefs() { return refs.Count(); }
	RefTargetHandle GetReference(int i) { return refs[i]; }
	ScripterExport void		SetReference(int i, RefTargetHandle rtarg);
	ScripterExport RefResult	NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, PartID& partID,  RefMessage message);

	// generic property accessors (operate on ref(0))
	ScripterExport Value*		get_property(Value** arg_list, int count);
	ScripterExport Value*		set_property(Value** arg_list, int count);

	// direct property access, when no wrapper exists, but we have the MAX-side ref
	static ScripterExport Value* get_property(ReferenceTarget* ref, Value* prop, Value* owner);
	static ScripterExport Value* set_property(ReferenceTarget* ref, Value* prop, Value* val);

//#include "defimpfn.h"
// RK: 06/01/99 Redefining these macros with ScripterExport directive so that
//				.dlx plugins can have classes derived from MAXWrapper
// RK: Start
#ifdef def_generic
#	undef def_generic
#	undef def_property
#	undef def_2_prop_path
#	undef def_nested_prop
#endif
#ifdef def_prop_getter
#	undef def_prop_getter
#	undef def_prop_setter
#endif

#define def_generic(fn, name)	\
			ScripterExport Value* fn##_vf(Value** arglist, int arg_count)

#define def_property(p)										\
			ScripterExport Value*	get_##p(Value** arg_list, int count);	\
			ScripterExport Value*	set_##p(Value** arg_list, int count)
#define def_prop_getter(p)									\
			ScripterExport Value*	get_##p(Value** arg_list, int count)
#define def_prop_setter(p)									\
			ScripterExport Value*	set_##p(Value** arg_list, int count)
#define def_2_prop_path(p1, p2)										\
			ScripterExport Value*	get_##p1##_##p2(Value** arg_list, int count);	\
			ScripterExport Value*	set_##p1##_##p2(Value** arg_list, int count)
#define def_nested_prop(p1)											\
			ScripterExport Value*	get_nested_##p1(Value** arg_list, int count);	\
			ScripterExport Value*	set_nested_##p1(Value** arg_list, int count)
// RK: End
			def_generic (numrefs, "numRefs");	// peek & poke for MAXScript...
			def_generic (getref, "getRef");
			def_generic (setref, "getRef");
			def_generic (numsubs, "numSubs");
			def_generic (getsub, "getSub");
			def_generic (setsub, "getSub");

			def_generic (show_props, "showProperties");
			def_generic (get_props,  "getPropNames");
			def_generic (copy,		 "copy");
			def_generic (isDeleted,	 "isDeleted");
			def_generic (exprForMAXObject,	"exprForMAXObject");
//			def_generic (dependsOn,	 "dependsOn");

			// the standard transform subanim properties
			def_property	( pos );
			def_2_prop_path	( pos, controller );
			def_2_prop_path	( pos, isAnimated );
			def_2_prop_path	( pos, keys );
			def_2_prop_path	( pos, track );
			def_2_prop_path	( pos, x );
			def_2_prop_path	( pos, y );
			def_2_prop_path	( pos, z );
			def_property	( rotation );
			def_2_prop_path	( rotation, angle );
			def_2_prop_path	( rotation, x_rotation );
			def_2_prop_path	( rotation, y_rotation );
			def_2_prop_path	( rotation, z_rotation );
			def_2_prop_path	( rotation, axis );
			def_2_prop_path	( rotation, controller );
			def_2_prop_path	( rotation, isAnimated );
			def_2_prop_path	( rotation, keys );
			def_2_prop_path	( rotation, track );
			def_property	( scale );
			def_2_prop_path	( scale, controller );
			def_2_prop_path	( scale, isAnimated );
			def_2_prop_path	( scale, keys );
			def_2_prop_path	( scale, track );
			def_2_prop_path	( scale, x );
			def_2_prop_path	( scale, y );
			def_2_prop_path	( scale, z );
			def_property	( controller );
			def_property	( transform );
			def_property	( isAnimated );
			def_property	( numsubs );

			def_nested_prop	( angle );
			def_nested_prop	( x_rotation );
			def_nested_prop	( y_rotation );
			def_nested_prop	( z_rotation );
			def_nested_prop	( axis );
			def_nested_prop	( controller );
			def_nested_prop	( isAnimated );
			def_nested_prop	( keys );
			def_nested_prop	( x );
			def_nested_prop	( y );
			def_nested_prop	( z );

	// utility methods for the above subanim property accessors, implemented by 
	// those that have standard transform subsanims
	virtual Control* get_max_pos_controller(ParamDimension** pdim) { return NULL; }
	virtual Control* get_max_scale_controller(ParamDimension** pdim) { return NULL; }
	virtual Control* get_max_rotation_controller(ParamDimension** pdim) { return NULL; }
	virtual Control* get_max_tm_controller(ParamDimension** pdim) { return NULL; }
	virtual Control* get_max_controller(ParamDimension** pdim) { return NULL; }
	ScripterExport virtual Control* get_max_prop_controller(Value* prop, ParamDimension** pdim);
	virtual BOOL	 set_max_pos_controller(MAXControl* c) { return FALSE; }
	virtual BOOL	 set_max_scale_controller(MAXControl* c) { return FALSE; }
	virtual BOOL	 set_max_rotation_controller(MAXControl* c) { return FALSE; }
	virtual BOOL	 set_max_tm_controller(MAXControl* c) { return FALSE; }
	virtual BOOL	 set_max_controller(MAXControl* c) { return FALSE; }
	ScripterExport virtual BOOL	 set_max_prop_controller(Value* prop, MAXControl* c);

	static ScripterExport Control* get_max_prop_controller(ReferenceTarget* ref, Value* prop, ParamDimension** pdim);
	static ScripterExport BOOL	   set_max_prop_controller(ReferenceTarget* ref, Value* prop, MAXControl* c);

	ScripterExport Value*		get_container_property(Value* prop, Value* cur_prop);
	ScripterExport Value*		set_container_property(Value* prop, Value* val, Value* cur_prop);

	// coordsystem mappers, default is no mapping
	virtual void	object_to_current_coordsys(Point3& p, int mode=0) { }
	virtual void	object_from_current_coordsys(Point3& p, int mode=0) { }
	virtual void	world_to_current_coordsys(Point3& p, int mode=0) { }
	virtual void	world_from_current_coordsys(Point3& p, int mode=0) { }
	virtual void	world_to_current_coordsys(Quat& q) { }
	virtual void	world_from_current_coordsys(Quat& q) { }

	// map to & from controller value coordsys, eg, parent for nodes, modcontext for modifiers, etc.
	virtual void	ctrl_to_current_coordsys(Point3& p, int mode=0) { }
	virtual void	ctrl_from_current_coordsys(Point3& p, int mode=0) { }
	virtual void	ctrl_to_current_coordsys(Quat& q) { }
	virtual void	ctrl_from_current_coordsys(Quat& q) { }
	virtual void	ctrl_to_current_coordsys(ScaleValue& s) { }
	virtual void	ctrl_from_current_coordsys(ScaleValue& s) { }

	virtual Matrix3& local_tm() { return idTM; }
	virtual Matrix3  local_tm_inv() { return Inverse(local_tm()); }

	// recursive time functions
	#undef def_time_fn
	#define def_time_fn(_fn) ScripterExport Value* _fn##_vf(Value** arglist, int arg_count)
	#include "time_fns.h"			// once for the generics
	#undef def_time_fn
	#define def_time_fn(_fn) ScripterExport Value* _fn(Animatable* anim, Value** arglist, int arg_count)
	#include "time_fns.h"			// and once again for the factored animatable form

	// mesh & mesh-sub-object access setup
	ScripterExport virtual Mesh* set_up_mesh_access(int access, ReferenceTarget** owner = NULL);
	ScripterExport virtual Mesh* set_up_mesh_face_access(int index, int access, ReferenceTarget** owner = NULL);
	ScripterExport virtual Mesh* set_up_mesh_vertex_access(int index, int access, ReferenceTarget** owner = NULL);
	ScripterExport virtual BitArray* get_vertsel();
	ScripterExport virtual BitArray* get_facesel();
	ScripterExport virtual BitArray* get_edgesel();
	ScripterExport virtual GenericNamedSelSetList& get_named_vertsel_set();
	ScripterExport virtual GenericNamedSelSetList& get_named_facesel_set();
	ScripterExport virtual GenericNamedSelSetList& get_named_edgesel_set();
	virtual void update_sel() { NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE); }

	// R2.5 stuff

	def_property   ( category );
	def_prop_getter( classID );

	def_generic ( get,				 "get" );				    // <mw>[i] => subAnim[i]
	def_generic ( getSubAnim,	 	 "getSubAnim" );			// equivalent 
	def_generic ( getSubAnimName,	 "getSubAnimName" );
	def_generic ( getSubAnimNames,	 "getSubAnimNames" );
	def_generic ( getAppData,		 "getAppData");
	def_generic ( setAppData,		 "setAppData");
	def_generic ( deleteAppData,	 "deleteAppData");
	def_generic ( clearAllAppData,	 "clearAllAppData");
	def_generic ( addPluginRollouts, "addPluginRollouts");

	ReferenceTarget* to_reftarg() { return get_max_object(); }

	// scene I/O 
	ScripterExport IOResult Save(ISave* isave);
	static ScripterExport Value* Load(ILoad* iload, USHORT chunkID, ValueLoader* vload);
};

// coordsys mappers defines..
#define NO_TRANSLATE	0x0001
#define NO_SCALE		0x0002

#define ctrl_to_current_coordsys_rotate(p)			ctrl_to_current_coordsys(p, NO_TRANSLATE + NO_SCALE)
#define ctrl_from_current_coordsys_rotate(p)		ctrl_from_current_coordsys(p, NO_TRANSLATE + NO_SCALE)
#define object_to_current_coordsys_rotate(p)		object_to_current_coordsys(p, NO_TRANSLATE + NO_SCALE)
#define object_from_current_coordsys_rotate(p)		object_from_current_coordsys(p, NO_TRANSLATE + NO_SCALE)
#define world_to_current_coordsys_rotate(p)			world_to_current_coordsys(p, NO_TRANSLATE + NO_SCALE)
#define world_from_current_coordsys_rotate(p)		world_from_current_coordsys(p, NO_TRANSLATE + NO_SCALE)
#define object_to_current_coordsys_scaleRotate(p)	object_to_current_coordsys(p, NO_TRANSLATE)
#define object_from_current_coordsys_scaleRotate(p)	object_from_current_coordsys(p, NO_TRANSLATE)

/* ---------------------- MAXClass ----------------------- */
 
/* this is the class that provides a runtime representation for
 * the classes of MAX objects.  It is essentially the MAXScript 
 * equivalent of the ClassDesc instance with extra metadata
 * about creation parameters, ec. */

typedef struct			// parameter descriptor struct
{
	Value*		name;			// parameter name
	TCHAR		desc_type;		// descriptor type... paramblock/fn/etc.
	TCHAR		flags;
	union
	{
		struct					// paramblock entry descriptor
		{
			int		parm_id;	
		};
		struct					// fn entry descriptor
		{
			max_getter_cf getter;
			max_setter_cf setter;
		};
		struct					// subanim entry descriptor
		{
			int		subanim_num;	
		};
		struct					// paramblockn - paramblock at given refno
		{
			int		refno;
			int		pbn_id;
		};
	};
	ParamType	type;			// common type code & initval
	union
	{
		float		fval;
		int			ival;
		BOOL		bval;
		struct		{float x, y, z;};
		struct		{float r, g, b;};
		struct		{float h, s, v;};
		struct		{int btn_min, btn_max, btn_val;};
	} init_val;
} parm_desc;

#define PD_NO_INIT			0x01	// flags this property as reqiring no init
#define PD_LOCAL_DUP		0x02	// this is a duplicate local translation
#define PD_HAS_LOCAL_DUPS	0x04	// this has duplicate local translations
#define PD_SHOWN			0x08	// temp flag to mark already shown props in showProps()

class MAXClass;
class MAXSuperClass;

typedef struct					// entries in the superclass table
{
	SClass_ID		key;
	MAXSuperClass*	mx_superclass;
} superclass_table;

typedef Value* (*maker_fn)(MAXClass* cls, ReferenceTarget* obj, Value** arglist, int count);

visible_class (MAXSuperClass)

class MAXSuperClass : public Value
{
public:
	Value*		name;
	SClass_ID	sclass_id;
	Value*		superclass;
	maker_fn	maker;
	short		n_parms;
	short		flags;
	parm_desc*	parms;

				MAXSuperClass(TCHAR* cname, SClass_ID sid, Value* superClass, maker_fn maker, ...);
			   ~MAXSuperClass();
	void		complete_init();

	static superclass_table* superclasses;		// lookup table of all superclasses by SClass_ID
	static short n_superclasses;
	static BOOL superclass_table_dirty;
	static MAXSuperClass* lookup_superclass(SClass_ID sid);

	Value*		classOf_vf(Value** arg_list, int count);
	Value*		superClassOf_vf(Value** arg_list, int count);
	Value*		isKindOf_vf(Value** arg_list, int count);
	BOOL		is_kind_of(ValueMetaClass* c) { return (c == class_tag(MAXWrapper)) ? 1 : Value::is_kind_of(c); }
	void		collect() { delete this; }
	void		gc_trace();
	ScripterExport void sprin1(CharStream* s);
	void		export_to_scripter();

	void		apply_keyword_parms(ReferenceTarget* obj, Value** key_arg_list, int count);

				def_generic (get_props, "getPropNames");

	def_property( categories );
};

#define SC_SUPERCLASS_INITED	0x0001

typedef struct
{
	Class_ID	cid;
	SClass_ID	scid;
} class_key;

typedef struct				// entries in the class table
{
	class_key	key;
	MAXClass*	mx_class;
} class_table;

enum metadata_flags
{
	md_use_getref  = 0x0001,		/* class flags */
	md_use_getref0 = 0x0002,
	md_use_getref1 = 0x0004,
	md_no_create   = 0x0008,
	md_no_access   = 0x0010,
	md_direct_index = 0x0020,
	md_new_plugin  = 0x0040,
	md_auto_parms  = 0x0080,
	md_name_clash  = 0x0100,
};

enum metadata_flag
{
//	end			= 0,				/* metadata vararg tags */
	getters     = 1,
	setters,
	accessors,
	path_getters,
	path_setters,
	path_accessors,
	fns,
	paramblock,
	subanims,
	paramblockn,
	subanimparamblock
};

enum
{
	TYPE_POINT3_ANGLE	= TYPE_USER + 128,		/* MAXScript special paramblock types... */
	TYPE_POINT3_PCNT,

};


visible_class (MAXClass)

class MAXClass : public Value
{
public:
	Value*			name;
	Class_ID		class_id;
	SClass_ID		sclass_id;
	ClassDesc2*		cd2;				// for now, pointer to ClassDesc2 if this class is PB2-based
	short			md_flags;
	int				n_parms;
	parm_desc*		parms;
	MAXSuperClass*	superclass;
	short			paramblock_ref_no;
	Value*			category;

	static class_table*	classes;		// lookup table of all classes by Class_ID
	static short	n_classes;
	static BOOL		class_table_dirty;
	static MAXClass* lookup_class(Class_ID* cid, SClass_ID scid);

								   MAXClass() { }
					ScripterExport MAXClass(TCHAR* cname, Class_ID cid, SClass_ID sid, MAXSuperClass* sclass, short cflags, ...);
			        ScripterExport ~MAXClass();
	ClassDesc*		complete_init();

	static void		setup();
	Value*			classOf_vf(Value** arg_list, int count);
	Value*			superClassOf_vf(Value** arg_list, int count);
	Value*			isKindOf_vf(Value** arg_list, int count);
	BOOL			is_kind_of(ValueMetaClass* c) { return (c == class_tag(MAXWrapper)) ? 1 : Value::is_kind_of(c); }
	void			collect() { delete this; }
	void			gc_trace();
	ScripterExport void sprin1(CharStream* s);
	void			export_to_scripter();

	ScripterExport Value* apply(Value** arglist, int count);		// object creation by applying class object

	static ScripterExport Value* make_wrapper_for(ReferenceTarget* ref);
	static ScripterExport Value* make_node_for(ReferenceTarget* ref);

	parm_desc*		get_parm_desc(ReferenceTarget* ref, Value* key);
	BOOL			build_parm_descs(ReferenceTarget* ref);
	void			apply_keyword_parms(ReferenceTarget* ref, Value** key_arg_list, int count);
	void			initialize_object(ReferenceTarget* ref);
	Value*			get_max_property(ReferenceTarget* ref, parm_desc* pd, TimeValue t, Interval& valid);
	void			set_max_property(ReferenceTarget* ref, parm_desc* pd, TimeValue t, Value* val);

	// PB2-related
	ParamDef*		get_parm_def(Value* prop, ParamBlockDesc2*& pbd, int& tabIndex, ReferenceTarget* ref = NULL);
	void			set_max_property(ReferenceTarget* ref, ParamDef* pd, int tabIndex, ParamBlockDesc2* pbd, TimeValue t, Value* val);
	Value*			get_max_property(ReferenceTarget* ref, ParamDef* pd, int tabIndex, ParamBlockDesc2* pbd, TimeValue t, Interval& valid);
	static Value*	get_pb2_property(IParamBlock2* pb, ParamDef* pd, int tabIndex, TimeValue t, Interval& valid);
	static void		set_pb2_property(IParamBlock2* pb, ParamDef* pd, int tabIndex, TimeValue t, Value* val);

					def_generic (get_props,		   "getPropNames");
					def_generic (create_instance,  "createInstance");

	Class_ID		get_max_class_id() { return class_id; }

	def_property   ( category );
	def_prop_getter( classID );

	Value*			Category();
};

/* MAX object makers... */

Value* make_max_node(MAXClass* cls, ReferenceTarget* obj, Value** arg_list, int count);
Value* make_max_object(MAXClass* cls, ReferenceTarget* obj, Value** arg_list, int count);
Value* make_max_light(MAXClass* cls, ReferenceTarget* obj, Value** arg_list, int count);
Value* make_max_camera(MAXClass* cls, ReferenceTarget* obj, Value** arg_list, int count);
Value* make_max_modifier(MAXClass* cls, ReferenceTarget* obj, Value** arg_list, int count);
Value* make_max_material(MAXClass* cls, ReferenceTarget* obj, Value** arg_list, int count);
Value* make_max_texturemap(MAXClass* cls, ReferenceTarget* obj, Value** arg_list, int count);
Value* make_max_mtlbase(MAXClass* cls, ReferenceTarget* obj, Value** arg_list, int count);
Value* make_max_system(MAXClass* cls, ReferenceTarget* obj, Value** arg_list, int count);
Value* make_max_helper(MAXClass* cls, ReferenceTarget* obj, Value** arg_list, int count);
Value* make_max_controller(MAXClass* cls, ReferenceTarget* obj, Value** arg_list, int count);
Value* make_max_atmospheric(MAXClass* cls, ReferenceTarget* obj, Value** arg_list, int count);
Value* make_max_effect(MAXClass* cls, ReferenceTarget* obj, Value** arg_list, int count); // RK: Added this
Value* make_max_filter(MAXClass* cls, ReferenceTarget* obj, Value** arg_list, int count); // RK: Added this
Value* make_max_shadow(MAXClass* cls, ReferenceTarget* obj, Value** arg_list, int count); // LE: Added this
Value* make_max_reftarg(MAXClass* cls, ReferenceTarget* obj, Value** arg_list, int count);
Value* no_max_maker(MAXClass* cls, ReferenceTarget* obj, Value** arg_list, int count);

/* ------------------  MAXWrapper instance cache -----------------*/
// MAXWrapper instance cache - it's critical we don't wind up generating a million
// MAXWrappers with References to the same MAX-side object as this KILLS the collector
// during the DeleteAllRefsFromMe() which seems to do a linear search through its refs

#define MAXWRAPPER_CACHE_SIZE 2048			// must be power of 2
extern ScripterExport MAXWrapper* maxwrapper_cache[];

inline BOOL
_maxwrapper_cache_get(long index, MAXWrapper*** pw)
{
    // compute cache index - fold halfwords & fold to cache size, get cache entry
	index = (LOWORD(index) ^ HIWORD(index)) % MAXWRAPPER_CACHE_SIZE - 1;
	*pw = &maxwrapper_cache[abs(index)];
	// we match initially if entry contains a non-deleted MAXWrapper
	MAXWrapper* w = **pw;
	return (w && !w->ref_deleted);
}

// a macro for implementing MAXWrapper interning member functions
#define maxwrapper_cache_get(_mw_class, _mw_ref, _mw_var, _ce_var)									\
	(_maxwrapper_cache_get((long)(_mw_ref) ^ (long)class_tag(_mw_class), (MAXWrapper***)&_ce_var) &&  \
     (_mw_var = *_ce_var)->tag == class_tag(_mw_class))

/* ------------------------ MAXNode class  ------------------------ */

/* this class is the MAXScript wrapper for object hierarchy 
 * INodes. */

visible_class (MAXNode)

class MAXNode : public MAXWrapper
{
public:
	INode	*node;
	
	ScripterExport MAXNode(INode* init_node);
	static ScripterExport Value* intern(INode* init_node);

	Value*		classOf_vf(Value** arg_list, int count);
	Value*		superClassOf_vf(Value** arg_list, int count);
	Value*		isKindOf_vf(Value** arg_list, int count);
	BOOL		is_kind_of(ValueMetaClass* c) { return (c == class_tag(MAXNode)) ? 1 : MAXWrapper::is_kind_of(c); }
#	define is_node(v) ((v)->tag == class_tag(MAXNode))
	void		collect() { delete this; }
	ScripterExport void	sprin1(CharStream* s);
	TCHAR*		class_name();
	ScripterExport ReferenceTarget* get_max_object();

	/* include all the protocol declarations */

#include "defimpfn.h"
#	include "nodepro.h"

	def_generic( distance,  "distance" );  // shortcut distance fn for nodes
	def_generic( eq,		"=");
	def_generic( ne,		"!=");
	def_generic( coerce,	"coerce");
	
	/* declare built-in property accessors */

	def_property	( dir );
	def_property	( target );
	def_property	( mat );
	def_property	( modifiers );
	def_property	( name );
	def_property	( max );
	def_property	( min );
	def_property	( center );
	def_property	( transform );
	def_property	( parent );
	def_property	( children );
	def_property	( pivot );
	def_2_prop_path	( pivot, x );
	def_2_prop_path	( pivot, y );
	def_2_prop_path	( pivot, z );
	def_property	( objectoffsetpos );
	def_property	( objectoffsetrot );
	def_property	( objectoffsetscale );
	def_property	( objecttransform );

	def_nested_prop	( angle );
	def_nested_prop	( axis );

	/* mesh props */

	def_property	( numverts );
	def_property	( numtverts );
	def_property	( numfaces );
	def_property	( numcpvverts );
	def_property	( mesh );
	/* LE added these */
	def_property	( displacementMapping );
	def_property	( subdivisionDisplacement );
	def_property	( splitMesh );
	/* end LE */

	/* mesh sub-objects (implemented in MeshSub.cpp) */

	def_property	( vertices );
	def_property	( selectedVertices );
	def_property	( faces );
	def_property	( selectedFaces );
	def_property	( edges );
	def_property	( selectedEdges );

	/* NURBS sub-objects (implemented in NurbsSub.cpp) */

	def_property		  ( selectedCurveCVs );
	def_property		  ( selectedCurves );
	def_property		  ( selectedImports );
	def_property		  ( selectedPoints );
	def_property		  ( selectedSurfaces );
	def_property		  ( selectedSurfCVs );
	def_property		  ( curveCVs );
	def_property		  ( curves );
	def_property		  ( imports );
	def_property		  ( surfaces );
	def_property		  ( surfCVs );
	def_property		  ( points );

	/* spline shape props */

	def_property	( numsplines );

	/* general property & substructure access */
	
	Value*		get_property(Value** arg_list, int count);
	Value*		set_property(Value** arg_list, int count);
	Value*		find_modifier(Object* obj, Value* prop);
	Value*		get_property_via_metadata(Value* prop);
	Control*	get_max_prop_controller(Value* prop, ParamDimension** pdim);
	BOOL		set_max_prop_controller(Value* prop, MAXControl* c);

	/* children mappers */
	
	ScripterExport Value* map(node_map& m);
	ScripterExport Value* map_path(PathName* path, node_map& m);
	ScripterExport Value* find_first(BOOL (*test_fn)(INode* node, int level, void* arg), void* test_arg);
	ScripterExport Value* get_path(PathName* path);

	INode*		to_node() { check_for_deletion(); return node; }

	//  coordsystem mappers
	void		object_to_current_coordsys(Point3& p, int mode=0);
	void		object_from_current_coordsys(Point3& p, int mode=0);
	void		world_to_current_coordsys(Point3& p, int mode=0);
	void		world_from_current_coordsys(Point3& p, int mode=0);
	void		world_to_current_coordsys(Quat& q);
	void		world_from_current_coordsys(Quat& q);
	void		world_to_current_coordsys(ScaleValue& s);
	void		world_from_current_coordsys(ScaleValue& s);

	// standard transorm controller access
	Control*	get_max_pos_controller(ParamDimension** pdim);
	Control*	get_max_scale_controller(ParamDimension** pdim);
	Control*	get_max_rotation_controller(ParamDimension** pdim);
	Control*	get_max_tm_controller(ParamDimension** pdim);
	Control*	get_max_controller(ParamDimension** pdim);
	BOOL		set_max_pos_controller(MAXControl* c);
	BOOL		set_max_scale_controller(MAXControl* c);
	BOOL		set_max_rotation_controller(MAXControl* c);
	BOOL		set_max_tm_controller(MAXControl* c);
	BOOL		set_max_controller(MAXControl* c);

	void		ctrl_to_current_coordsys(Point3& p, int mode=0);
	void		ctrl_from_current_coordsys(Point3& p, int mode=0);
	void		ctrl_to_current_coordsys(Quat& q);
	void		ctrl_from_current_coordsys(Quat& q);
	void		ctrl_to_current_coordsys(ScaleValue& s);
	void		ctrl_from_current_coordsys(ScaleValue& s);

	// recursive time functions
	#undef def_time_fn
	#define def_time_fn(_fn) Value* _fn##_vf(Value** arglist, int arg_count)
	#include "time_fns.h"

	// mesh access setup
	Mesh*		set_up_mesh_access(int access, ReferenceTarget** owner = NULL);
	Mesh*		set_up_mesh_face_access(int index, int access, ReferenceTarget** owner = NULL);
	Mesh*		set_up_mesh_vertex_access(int index, int access, ReferenceTarget** owner = NULL);
	BitArray*	get_vertsel();
	BitArray*	get_facesel();
	BitArray*	get_edgesel();
	GenericNamedSelSetList& get_named_vertsel_set();
	GenericNamedSelSetList& get_named_facesel_set();
	GenericNamedSelSetList& get_named_edgesel_set();
	void		update_sel();

	// NURBS access setup
	Object*		set_up_nurbs_access(NURBSSubObjectLevel level, BitArray& sel);
	Object*		set_up_nurbs_access(NURBSSubObjectLevel level);

};

#define INODE_CLASS_ID		Class_ID(BASENODE_CLASS_ID, 0)	/* INode class ID for MAXScript metadata table indexing */
#define INODE_SUPERCLASS_ID BASENODE_CLASS_ID

/* ---------------------- MAXNodeChildrenArray ----------------------- */

visible_class (MAXNodeChildrenArray)

class MAXNodeChildrenArray : public MAXWrapper, public Collection
{
public:
	INode*		parent;				/* parent node */

				MAXNodeChildrenArray(INode* parent);
	static ScripterExport Value* intern(INode* parent);

				classof_methods (MAXNodeChildrenArray, MAXWrapper);
	BOOL		_is_collection() { return 1; }
	void		collect() { delete this; }
	ScripterExport void		sprin1(CharStream* s);
	TCHAR*		class_name();

	// operations
	ScripterExport Value* map(node_map& m);

#include "defimpfn.h"
#	include "arraypro.h"

	// built-in property accessors
	def_property ( count );
	def_property ( center );
	def_property ( min );
	def_property ( max );

};

/* ---------------------- MAXObject ----------------------- */

// generic wrapper for MAX reftarg objects (as opposed to nodes); ie, things inside nodes, mod stacks, etc.

visible_class (MAXObject)

class MAXObject : public MAXWrapper
{
public:
	Object* obj;				// the MAX-side object

	ScripterExport MAXObject(Object* o);
	static ScripterExport Value* intern(Object* o);

	void		collect() { delete this; }
	ScripterExport void sprin1(CharStream* s);
	TCHAR*		class_name();

	BOOL CanTransferReference(int i) { return FALSE; }  // prevent mod applications from making us refer to a derived object
	
	def_property	( mesh );
};

/* ---------------------- MAXPB2ArrayParam ----------------------- */

// a virtual array wrapper for ParamBlock2 Tab<> array parameters
// allows indexed access to Tab<> paramaters held in ParamBlock2's

visible_class (MAXPB2ArrayParam)

class MAXPB2ArrayParam : public MAXWrapper, public Collection
{
public:
	IParamBlock2*		pblock;				// owning paramblock
	ParamDef*			pdef;				// Tab<> parameter def

				MAXPB2ArrayParam(IParamBlock2* pb, ParamDef* pd);
	static ScripterExport Value* intern(IParamBlock2* pb, ParamDef* pd);

				classof_methods (MAXPB2ArrayParam, MAXWrapper);
//	BOOL		_is_collection() { return 1; }
#	define		is_tab_param(v) ((v)->tag == class_tag(MAXPB2ArrayParam))
	void		collect() { delete this; }
	ScripterExport void		sprin1(CharStream* s);
	TCHAR*		class_name() { return _T("Array Parameter"); }

	// operations
	ScripterExport Value* map(node_map& m);

#include "defimpfn.h"
#	include "arraypro.h"

	// built-in property accessors
	def_property ( count );

	// nested props on indexed elements (notably <param>[i].controller)
	ScripterExport Value*		get_container_property(Value* prop, Value* cur_prop);
	ScripterExport Value*		set_container_property(Value* prop, Value* val, Value* cur_prop);

	// NULL get/showprops
	Value* show_props_vf(Value** arg_list, int count) { return &undefined; }
	Value* get_props_vf(Value** arg_list, int count) { return &undefined; }
};

/* ---------------------- MAXModifier ----------------------- */

/* generic wrapper for MAX modifiers. */

visible_class (MAXModifier)

class MAXModifier : public MAXWrapper
{
public:
	Modifier*	mod;			// the MAX-side modifier

	ScripterExport MAXModifier(Modifier* imod);
	static ScripterExport Value* intern(Modifier* imod);

#	define is_modifier(v) ((v)->tag == class_tag(MAXModifier))
	BOOL		is_kind_of(ValueMetaClass* c) { return (c == class_tag(MAXModifier)) ? 1 : MAXWrapper::is_kind_of(c); }
	void		collect() { delete this; }
	ScripterExport void		sprin1(CharStream* s);
	TCHAR*		class_name();

	def_property	( name );
	Value*		get_property(Value** arg_list, int count);
	Value*		set_property(Value** arg_list, int count);

	Modifier*	to_modifier() { check_for_deletion(); return mod; }
};

visible_class (MAXModifierArray)

class MAXModifierArray : public MAXWrapper
{
public:
	INode*		node;			/* the noed containing the modifiers */

				MAXModifierArray(INode* node);
	static ScripterExport Value* intern(INode* node);

				classof_methods (MAXModifierArray, MAXWrapper);
	void		collect() { delete this; }
	BOOL		_is_collection() { return 1; }
	ScripterExport void		sprin1(CharStream* s);
	Modifier*	get_modifier(int index);
	Modifier*	find_modifier(TCHAR* name);
	TCHAR*		class_name();

	// operations
	ScripterExport Value* map(node_map& m);

#include "defimpfn.h"
#	include "arraypro.h"

	// built-in property accessors 
	def_property ( count );

};

/* ---------------------- MAXControl ----------------------- */

/* generic wrapper for MAX controls. */

visible_class (MAXControl)

class MAXControl : public MAXWrapper
{
public:
	Control*		 controller;			/* the MAX-side controller					*/
	ParamDimension*  dim;					/* dimension from originating animatable	*/
	short			 flags;

	ScripterExport MAXControl(Control* icont, ParamDimension* idim);
	ScripterExport MAXControl(Control* icont, int flags = 0);
	static ScripterExport Value* intern(Control* icont, ParamDimension* idim);
	static ScripterExport Value* intern(Control* icont, int flags = 0);

	BOOL		is_kind_of(ValueMetaClass* c) { return (c == class_tag(MAXControl)) ? 1 : MAXWrapper::is_kind_of(c); }
	void		collect() { delete this; }
	ScripterExport void		sprin1(CharStream* s);
	TCHAR*		class_name();
#	define is_controller(v) ((v)->tag == class_tag(MAXControl))

	// the non-recursive controller ops... (recursive's are implemented as MAXWrapper methods)
	#include "defimpfn.h"
	use_generic			 ( copy,	"copy");
	def_visible_generic  ( supportsTimeOperations,	"supportsTimeOperations");
	def_visible_generic  ( getTimeRange,			"getTimeRange");
	def_visible_generic  ( deleteKey,				"deleteKey");
	def_visible_generic  ( selectKey,				"selectKey");
	def_visible_generic  ( deselectKey,				"deselectKey");
	def_visible_generic  ( isKeySelected,			"isKeySelected");
	def_visible_generic  ( moveKey,					"moveKey");
	def_visible_generic  ( numKeys,					"numKeys");
	def_visible_generic  ( getKey,					"getKey");
	def_visible_generic  ( getKeyTime,				"getKeyTime");
	def_visible_generic  ( getKeyIndex,				"getKeyIndex");
	def_visible_generic  ( numSelKeys,				"numSelKeys");
	def_visible_generic  ( numEaseCurves,			"numEaseCurves");
	def_visible_generic  ( applyEaseCurve,			"applyEaseCurve");
	def_visible_generic  ( addMultiplierCurve,		"addMultiplierCurve");
	def_visible_generic  ( deleteMultiplierCurve,	"deleteMultiplierCurve");
	def_visible_generic  ( numMultiplierCurves,		"numMultiplierCurves");
	def_visible_generic  ( getMultiplierValue,		"getMultiplierValue");
	def_visible_generic  ( getBeforeORT,			"getBeforeORT");
	def_visible_generic  ( getAfterORT,				"getAfterORT");

	// built-in property accessors 
	def_property ( value );
	def_property ( keys );

	Control*	to_controller() { check_for_deletion(); return controller; }

	// trap reduceKeys() here to supply controllers dim
	def_visible_generic  ( reduceKeys,				"reduceKeys");

};

#define MAX_CTRL_NO_DIM		0x01		// indicates no explicit dimension yet assigned
#define MAX_CTRL_NEW		0x02		// new controller, copy(old) when first assigned

/* ---------------------- MAXSubAnim ----------------------- */

/* generic wrapper for MAX subanims. */

visible_class (MAXSubAnim)

class MAXSubAnim : public MAXWrapper
{
public:
	ReferenceTarget* ref;					/* parent object */
	int				 subanim_num;			/* the subanim index */

	ScripterExport MAXSubAnim(ReferenceTarget* ref, int index);
	static ScripterExport Value* intern(ReferenceTarget* ref, int index);

				classof_methods(MAXSubAnim, MAXWrapper);
	void		collect() { delete this; }
	ScripterExport void		sprin1(CharStream* s);
	TCHAR*		class_name() { return _T("SubAnim"); }
	ScripterExport ReferenceTarget* get_max_object();

	// standard transform controller access
	Control*	get_max_pos_controller(ParamDimension** pdim);
	Control*	get_max_scale_controller(ParamDimension** pdim);
	Control*	get_max_rotation_controller(ParamDimension** pdim);
	Control*	get_max_tm_controller(ParamDimension** pdim);
	Control*	get_max_controller(ParamDimension** pdim);
	BOOL		set_max_pos_controller(MAXControl* c);
	BOOL		set_max_scale_controller(MAXControl* c);
	BOOL		set_max_rotation_controller(MAXControl* c);
	BOOL		set_max_tm_controller(MAXControl* c);
	BOOL		set_max_controller(MAXControl* c);

	def_property( controller );
	def_property( isAnimated );
	def_property( keys );
	def_property( value );
	def_property( object );

	// these converters all attempt to bounce off the subanim object
	Value*		subanim_obj();

	INode*		to_node()		{ return subanim_obj() != this ? subanim_obj()->to_node() : Value::to_node(); }
	Mtl*		to_mtl()		{ return subanim_obj() != this ? subanim_obj()->to_mtl() : Value::to_mtl(); }
	Texmap*		to_texmap()		{ return subanim_obj() != this ? subanim_obj()->to_texmap() : Value::to_texmap(); }
	Modifier*	to_modifier()	{ return subanim_obj() != this ? subanim_obj()->to_modifier() : Value::to_modifier(); }
	Control*	to_controller() { return subanim_obj() != this ? subanim_obj()->to_controller() : Value::to_controller() ; }
	Atmospheric* to_atmospheric() { return subanim_obj() != this ? subanim_obj()->to_atmospheric() : Value::to_atmospheric(); }
	Effect*		to_effect() { return subanim_obj() != this ? subanim_obj()->to_effect() : Value::to_effect(); }
	ITrackViewNode* to_trackviewnode() { return subanim_obj() != this ? subanim_obj()->to_trackviewnode() : Value::to_trackviewnode(); }
};

/* ---------------------- MAXRefTarg ----------------------- */
// generic wrapper for MAX ReferenceTargets.

visible_class (MAXRefTarg)

class MAXRefTarg : public MAXWrapper
{
public:
	ReferenceTarget* ref;					/* the object */

	ScripterExport MAXRefTarg(ReferenceTarget* ref);
	static ScripterExport Value* intern(ReferenceTarget* ref);

				classof_methods(MAXRefTarg, MAXWrapper);
	void		collect() { delete this; }
	ScripterExport void		sprin1(CharStream* s);
	TCHAR*		class_name() { return _T("MAXRefTarg"); }

};

/* ---------------------- MAXTVNode ----------------------- */

// generic wrapper for MAX TrackView Nodes. 

visible_class (MAXTVNode)

class MAXTVNode : public MAXWrapper
{
public:
	ITrackViewNode*	 parent;		// parent node
	int				 index;			// the TVNode index

	ScripterExport MAXTVNode(ITrackViewNode* parent, int index);
	static ScripterExport Value* intern(ITrackViewNode* parent, int index);

				classof_methods (MAXTVNode, MAXWrapper);
	void		collect() { delete this; }
	ScripterExport void		sprin1(CharStream* s);
	TCHAR*		class_name() { return _T("TrackViewNode"); }
	ReferenceTarget* get_max_object();

	Value*		get_property(Value** arg_list, int count);
	Value*		set_property(Value** arg_list, int count);

	Control* get_max_prop_controller(Value* prop, ParamDimension** pdim);
	BOOL	 set_max_prop_controller(Value* prop, MAXControl* c);
	Control* get_max_pos_controller(ParamDimension** pdim) { return get_max_prop_controller(n_position, pdim); }
	Control* get_max_scale_controller(ParamDimension** pdim) { return get_max_prop_controller(n_scale, pdim); }
	Control* get_max_rotation_controller(ParamDimension** pdim) { return get_max_prop_controller(n_rotation, pdim); }

	def_generic  ( get_props,  "getPropNames" );
	def_property ( name );

	RefResult	NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, PartID& partID,  RefMessage message);

	ITrackViewNode* to_trackviewnode() { check_for_deletion(); return (parent == NULL) ? MAXScript_interface->GetTrackViewRootNode() : parent->GetNode(index); }
};

/* ---------------------- MAXMeshClass ----------------------- */
// the sole instance of the MAXMeshClass represents the Nodes made from the core tri-mesh object class TriObject.
// reflecting its special status in MAX, it is defined by a separate class in MAXScript,
// allowing access to all the things you want to get at when procedurally working 
// with meshes.
 
visible_class (MAXMeshClass)

class MAXMeshClass : public Value
{
public:
				MAXMeshClass();

				classof_methods (MAXMeshClass, Value);
	void		collect() { delete this; }
	ScripterExport void		sprin1(CharStream* s);
	void		export_to_scripter();

	ScripterExport Value* apply(Value** arglist, int count);		// object creation by applying class object
	Class_ID	get_max_class_id() { return triObjectClassID; } 
};

/* ---------------------- MeshValue ----------------------- */
// A wrapper for the MAX SDK Mesh objects, typically used in Object plugins for creating scene
// object meshes

applyable_class (MeshValue)

class MeshValue : public MAXWrapper
{
public:
	Object*		obj;		// MAX object if indirect ref to mesh (ref 0)
	Mesh*		mesh;		// direct mesh ref
	BOOL		owned;		// if direct ref owned by this value (& so s/b deleted on collect)

	ScripterExport MeshValue(Mesh* imesh, BOOL owned = FALSE);
	ScripterExport MeshValue(Object* obj);
	static ScripterExport Value* intern(Object* obj);
			   ~MeshValue();

				classof_methods (MeshValue, MAXWrapper);
	void		collect() { delete this; }
	void		sprin1(CharStream* s);
	TCHAR*		class_name() { return _T("TriMesh"); }
	ReferenceTarget* get_max_object() { return obj; }
	void		SetReference(int i, RefTargetHandle rtarg);
	RefResult	NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, PartID& partID,  RefMessage message);

	void		setup_mesh(int access = MESH_READ_ACCESS);

	// mesh protocol (same as for MAXNode)
	def_generic( setvert,			"setvert");
	def_generic( getvert,			"getvert");
	def_generic( settvert,			"settvert");
	def_generic( gettvert,			"gettvert");
	def_generic( setvertcolor,		"setvertcolor");
	def_generic( getvertcolor,		"getvertcolor");
	def_generic( setnumverts,		"setnumverts");
	def_generic( getnumverts,		"getnumverts");
	def_generic( setnumtverts,		"setnumtverts");
	def_generic( getnumtverts,		"getnumtverts");
	def_generic( setnumcpvverts,	"setnumcpvverts");
	def_generic( getnumcpvverts,	"getnumcpvverts");
	def_generic( setnumfaces,		"setnumfaces");
	def_generic( getnumfaces,		"getnumfaces");
	def_generic( buildtvfaces,		"buildTVFaces");
	def_generic( buildvcfaces,		"buildVCFaces");
	def_generic( defaultvcfaces,	"defaultVCFaces");
	def_generic( getnormal,			"getnormal");
	def_generic( setnormal,			"setnormal");
	def_generic( setface,			"setface");
	def_generic( getface,			"getface");
	def_generic( settvface,			"setTVFace");
	def_generic( gettvface,			"getTVFace");
	def_generic( setvcface,			"setVCFace");
	def_generic( getvcface,			"getVCFace");
	def_generic( getfacenormal,		"getfacenormal");
	def_generic( setfacenormal,		"setfacenormal");
	def_generic( setfacematid,		"setfaceMatID");
	def_generic( getfacematid,		"getfaceMatID");
	def_generic( setfacesmoothgroup, "setfaceSmoothGroup");
	def_generic( getfacesmoothgroup, "getfaceSmoothGroup");
	def_generic( setedgevis,		"setedgevis");
	def_generic( getedgevis,		"getedgevis");
	def_generic( detachVerts,		"detachVerts");
	def_generic( detachFaces,		"detachFaces");
	def_generic( extrudeface,		"extrudeface");
	def_generic( deletevert,		"deletevert");
	def_generic( deleteface,		"deleteface");
	def_generic( collapseface,		"collapseface");
	def_generic( setMesh,			"setMesh");
	def_generic( update,			"update");
	def_generic( getVertSelection,	"getVertSelection");
	def_generic( setVertSelection,	"setVertSelection"); 
	def_generic( getFaceSelection,  "getFaceSelection");  
	def_generic( setFaceSelection,	"setFaceSelection");  
	def_generic( getEdgeSelection,	"getEdgeSelection");  
	def_generic( setEdgeSelection,	"setEdgeSelection"); 

	def_generic( copy,				"copy");  
	def_generic( delete,			"delete");  
	use_generic( plus,				"+" );		// mesh boolean ops
	use_generic( minus,				"-" );
	use_generic( times,				"*" );

	def_property( numverts );
	def_property( numtverts );
	def_property( numfaces );
	def_property( numcpvverts );
	def_property( mesh );

	Mesh*		to_mesh() { setup_mesh(); return mesh; }
};

/* ---------------------- MAXAtmospheric ----------------------- */

visible_class (MAXAtmospheric)

class MAXAtmospheric : public MAXWrapper
{
public:
	Atmospheric*	atmos;			// the MAX-side Atmospheric

	ScripterExport MAXAtmospheric(Atmospheric* iatmos);
	static ScripterExport Value* intern(Atmospheric* iatmos);

	BOOL		is_kind_of(ValueMetaClass* c) { return (c == class_tag(MAXAtmospheric)) ? 1 : MAXWrapper::is_kind_of(c); }
	void		collect() { delete this; }
	ScripterExport void		sprin1(CharStream* s);
	TCHAR*		class_name() { return _T("Atmospheric"); }

#include "defimpfn.h"
	#include "atmspro.h"

	def_property	( name );
	def_prop_getter	( numGizmos );

	Atmospheric*	to_atmospheric() { check_for_deletion(); return atmos; }
};

// RK: Start
/* ---------------------- MAXEffect ----------------------- */

visible_class (MAXEffect)

class MAXEffect : public MAXWrapper
{
public:
	Effect*	effect;			// the MAX-side Effect

	ScripterExport MAXEffect(Effect* ieffect);
	static ScripterExport Value* intern(Effect* ieffect);

	BOOL		is_kind_of(ValueMetaClass* c) { return (c == class_tag(MAXEffect)) ? 1 : MAXWrapper::is_kind_of(c); }
	void		collect() { delete this; }
	ScripterExport void		sprin1(CharStream* s);
	TCHAR*		class_name() { return _T("Effect"); }

#include "defimpfn.h"
	#include "atmspro.h"

	def_property	( name );
	def_prop_getter	( numGizmos );

	Effect*	to_effect() { check_for_deletion(); return effect; }
};

// RK: End
/* ---------------------- ChangeHandler ----------------------- */

/* maintains notification references to a bunch of objects & a scitped function
 * to execute if one changes - runtime object for the 'on object changed ....' construct */
class ChangeHandler;

visible_class (ChangeHandler)

class CHTimeChangeCallback : public TimeChangeCallback
{
public:
	static BOOL registered;					// if active
	static Tab<ChangeHandler*> handlers;	// active handlers
	static BOOL notified;					// set if any delayed-handle events have been notified
	public:
		void TimeChanged(TimeValue t);
};

class CHRedrawViewsCallback : public RedrawViewsCallback
{
public:
	static BOOL registered;					// if active
	static Tab<ChangeHandler*> handlers;	// active handlers
	static BOOL notified;					// set if any delayed-handle events have been notified
	public:
		void proc(Interface *ip);
};

class ChangeHandler : public MAXWrapper
{
public:
	Value*		fn;					// function to run
	Value*		attribute;			// controlling change atribute
	Value*		id;					// optional handler ID for group deleting
	Value*		handle_at;			// delayed handling event code (#redraw, #timeChange)
	short		parameter_count;	// # formal params for fn
	short		flags;
	Tab<ReferenceTarget*> targets;	// table of targets who've notified delayed-handling handler

	static CHRedrawViewsCallback	chrvcb;		// redrawviews callback
	static CHTimeChangeCallback		chtccb;		// timechange callback
	static Tab<ChangeHandler*>		handlers;	// immediate-mode active handlers
	static BOOL						delete_flagged; // signals a delayed delete was flagged

				ChangeHandler(Value* ifn, Value* attrib, Value* id, Value* handle_at);

				classof_methods (ChangeHandler, Value);
	void		collect() { delete this; }
	void		gc_trace();
	TCHAR*		class_name() { return _T("<ChangeHandler>"); }
	void		handle_event(ReferenceTarget* target);
	void		call_handler(ReferenceTarget* target);

	RefResult	NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
								 PartID& partID,  RefMessage message);		
};

#define CH_BROKEN		0x0001		// fn had a runtime error, disabled
#define CH_BUSY			0x0002		// fn is running, ignore recursive events
#define CH_NOTIFIED		0x0004		// change notified, handle at next specied handleAt: event
#define CH_DELETE		0x0008		// attempted delete within the change handler, mark for delayed delete

/* ---------------------- Node mapping stuff  ----------------------- */

/* node mapping argument structures */

struct node_map
{
	value_vf	vfn_ptr;							// virtual fn to map
	value_cf	cfn_ptr;							// or, c fn to map (one or the other must be null)
	Value**		arg_list;							// args to pass on...
	int			count;
	BOOL		(*selector)(INode*, int, void*);	// set selector fn
	void*		sel_arg;							// arg for the selector
	int			get_index;							// index if we are doing an indexed get
	int			get_count;							// local running traverse count during get
	Value**		get_result_p;						// ptr to result holder for indexed get
	Array*		collection;							// append map results here if non-null (used in for ... collect)
	short		flags;								// control flags
};

#define NM_INVERT	0x0001							// invert map order, map parents last on the way out of the recursion
#define NM_SELECT	0x0002							// applying a select, adjust clear flag 
#define NM_GET	    0x0004							// doing a get, return get_index'th item 

typedef struct
{
	BOOL		(*tester)(INode*, int, void*);		// node test fn
	void*		test_arg;							// tester arg
	BOOL		(*selector)(INode*, int, void*);	// set selector fn
	void*		sel_arg;							// arg for the selector
} node_find;

typedef struct
{
	PathName*	path;								// path to the node
	BOOL		(*selector)(INode*, int, void*);	// set selector fn
	void*		sel_arg;							// arg for the selector
} node_get;

class ConvertToRestore : public RestoreObj 
{
	BOOL onlyForRedo;
public:		   
	ConvertToRestore(BOOL onlyForRedo = FALSE) { this->onlyForRedo = onlyForRedo; }			
	void Restore(int isUndo);
	void Redo();
	TSTR Description() {return TSTR(_T("convertTo()"));}
};

// G-bufer channel names & IDs
typedef struct { TCHAR* name; int code; } gbuff_chan_code;
extern gbuff_chan_code gbuff_chan_codes[];

// various externs
extern void for_all_nodes(INode* root, node_map* m);
extern Value* find_first_node(INode* root, node_find* f);
extern Value* get_node(INode* root, node_get* g);
extern void for_all_path_nodes(INode* root, PathName* path, node_map* m);
extern BOOL all_objects_selector(INode* node, int level, void* selector_arg);
extern int max_name_compare(TCHAR* max_name, TCHAR* other);
extern int max_name_match(TCHAR* max_name, TCHAR* pattern);
extern Value* get_subanim_property(Animatable* anim, Value* prop);
extern Value* get_subanim_property(Animatable* anim, int i);
extern Value* set_subanim_property(Animatable* anim, Value* prop, Value* val);
extern Value* set_subanim_property(Animatable* anim, int i, Value* val);
extern BOOL set_subanim_controller(Animatable* anim, Value* prop, Control* newc, MAXControl* newcv);
extern Control* find_subanim_controller(Animatable* anim, Value* prop, ParamDimension** dim);
extern void deselect_if_motion_panel_open();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\MSSceneAPI.h ===
//***************************************************************************
//* SceneAPI - Implementation of Scene Extension API for 3D Studio MAX 1.2
//* 
//* By Christer Janson
//* Kinetix Development
//*
//* November 2, 1996	CCJ Initial coding
//* January  8, 1997	CCJ Added material editor slot access
//* March   15, 1997	CCJ Added scene materials access
//*
//* This class implements a couple of missing API calls.
//* 
//* WARNING:
//* These functions depend on the internal structure of 3D Studio MAX 1.2.
//* Do not attempt to use it with other versions.
//*

// If you encounter this error, you are using this file with an unsupported
// version of the 3D Studio Max SDK.
//#if	VERSION_3DSMAX != 120
//#error "STOP!!! This file is only for use with 3D Studio MAX Version 1.2"
//#endif

class SceneAPI {
public:
	SceneAPI(Interface* i);

	int GetNumAtmos();
	Atmospheric* GetAtmospheric(int i);
	Control* GetAmbientLightController();
	Color GetAmbientLight(TimeValue t);
	Texmap* GetBackgroundEnvironment();
	Control* GetBackgroundColorController();
	Color GetBackgroundColor(TimeValue t);
	MtlBase* GetMtlSlot(int i);
	void SetMtlSlot(int i, MtlBase* m);
	int NumMtlSlots();
	MtlBaseLib* GetSceneMtls();

private:
	void FindScene();
	void FindRenderEnvironment();

	Interface* ip;
	ReferenceMaker* scene;
	ReferenceMaker* rendEnv;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\MSTime.h ===
/*		MSTime.h - the time family of classes for MAXScript
 *
 *		Copyright (c) John Wainwright, 1996
 *		
 *
 */

#ifndef _H_MSTIME
#define _H_MSTIME

#include "Max.h"

/* ------------------------ Time ------------------------------ */

visible_class (MSTime)

class MSTime : public Value
{
public:
	TimeValue	time;

				MSTime (TimeValue t);
	static ScripterExport Value* intern(TimeValue t);

#	define		is_time(o) ((o)->tag == class_tag(MSTime))
				classof_methods (MSTime, Value);
	void		collect() { delete this; }
	ScripterExport void sprin1(CharStream* s);

#include "defimpfn.h"
#	include "timepro.h"
	def_generic  ( coerce,	"coerce");

	def_property ( ticks );
	def_property ( frame );
	def_property ( normalized );

	TimeValue	to_timevalue() { return time; }
	float	    to_float() { return (float)time / GetTicksPerFrame(); }
	int			to_int() { return (int)time / GetTicksPerFrame(); }

	Value*	widen_to(Value* arg, Value** arg_list);
	BOOL	comparable(Value* arg);

	// scene I/O 
	IOResult Save(ISave* isave);
	static Value* Load(ILoad* iload, USHORT chunkID, ValueLoader* vload);
};

/* ------------------------ Interval ------------------------------ */

applyable_class (MSInterval)

class MSInterval : public Value
{
public:
	Interval	interval;

				MSInterval () {};
 ScripterExport MSInterval (Interval i);
 ScripterExport MSInterval (TimeValue s, TimeValue e);

#	define		is_interval(o) ((o)->tag == class_tag(MSInterval))
				classof_methods (MSInterval, Value);
	void		collect() { delete this; }
	ScripterExport void sprin1(CharStream* s);

#include "defimpfn.h"
	def_property ( start );
	def_property ( end );

	Interval	to_interval() { return interval; }

	// scene I/O 
	IOResult Save(ISave* isave);
	static Value* Load(ILoad* iload, USHORT chunkID, ValueLoader* vload);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\notespro.h ===
/*	
 *		noteTrack_protocol.h - protocol for MAX note tracks
 *
 *
 */


	def_visible_generic	( sortNoteKeys,			"sortNoteKeys" );
	def_visible_generic	( addNewNoteKey,		"addNewNoteKey" );
	def_visible_generic	( deleteNoteKeys,		"deleteNoteKeys" );
	def_visible_generic	( deleteNoteKey,		"deleteNoteKey" );
	def_visible_generic	( getNoteKeyTime,		"getNoteKeyTime" );
	def_visible_generic	( getNoteKeyIndex,		"getNoteKeyIndex" );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\MXSCtrlr.h ===
/*	
 *		MSController.h - MAXScript scriptable controllers for MAX
 *
 *			Copyright  John Wainwright 1996
 *
 */

#ifndef _H_MSCONTROLLER
#define _H_MSCONTROLLER

#define SCRIPT_POS_CONTROL_CLASS_ID		Class_ID(0x236c6aa5, 0x27590853)
#define SCRIPT_P3_CONTROL_CLASS_ID		Class_ID(0x3d7b231d, 0x2b986df3)
#define SCRIPT_FLOAT_CONTROL_CLASS_ID	Class_ID(0x151d5ead, 0x55626f88)
#define SCRIPT_SCALE_CONTROL_CLASS_ID	Class_ID(0x5f346d25, 0x2c67ff7)
#define SCRIPT_ROT_CONTROL_CLASS_ID		Class_ID(0xc6625, 0xb003c2a)

class ScriptControl : public StdControl 
{
public:
	int			type;
	Interval	ivalid;
	Interval	range;
	HWND		hParams;
	IObjParam *	ip;
	TSTR		desc;
	HWND		hDlg;

	ScriptControl(int type, ScriptControl &ctrl);
	ScriptControl(int type, BOOL loading);
	~ScriptControl();

	// Animatable methods
	int TrackParamsType() { return TRACKPARAMS_WHOLE; }
	
	void DeleteThis() { delete this; }
	int IsKeyable() { return 0; }		
	BOOL IsAnimated() {return TRUE;}
	Interval GetTimeRange(DWORD flags) { return range; }
	void EditTimeRange(Interval range,DWORD flags);
	void Hold();
	void MapKeys( TimeMap *map, DWORD flags );

	void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev );
	void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next );

	void EditTrackParams(
			TimeValue t,	// The horizontal position of where the user right clicked.
			ParamDimensionBase *dim,
			TCHAR *pname,
			HWND hParent,
			IObjParam *ip,
			DWORD flags);

	// Reference methods
	int NumRefs() { return StdControl::NumRefs() + refTab.Count(); }
	ReferenceTarget* GetReference(int i);
	void SetReference(int i, RefTargetHandle rtarg);
	RefResult NotifyRefChanged(Interval, RefTargetHandle, PartID&, RefMessage);
	void RefDeleted();

	IOResult Save(ISave *isave);
	IOResult Load(ILoad *iload);

	// Control methods
	void Copy(Control *from);
	RefTargetHandle Clone(RemapDir& remap=NoRemap()) { return(new ScriptControl(this->type, *this)); }		
	BOOL IsLeaf() { return TRUE; }
	void GetValueLocalTime(TimeValue t, void *val, Interval &valid, GetSetMethod method=CTRL_ABSOLUTE);	
	void SetValueLocalTime(TimeValue t, void *val, int commit, GetSetMethod method) {}
	void Extrapolate(Interval range,TimeValue t,void *val,Interval &valid,int type);
	void *CreateTempValue();
	void DeleteTempValue(void *val);
	void ApplyValue(void *val, void *delta);
	void MultiplyValue(void *val, float m);
};

class ScriptPosControl : public ScriptControl 
{
public:
	ScriptPosControl(ScriptPosControl &ctrl) : ScriptControl(CTRL_POSITION_CLASS_ID, ctrl) {}
	ScriptPosControl(BOOL loading=FALSE) : ScriptControl(CTRL_POSITION_CLASS_ID, loading) {}
	~ScriptPosControl() {}

	RefTargetHandle Clone(RemapDir& remap=NoRemap()) { return(new ScriptPosControl(*this)); }		
	void GetClassName(TSTR& s) { s = _T("Position_script"); }
	Class_ID ClassID() { return Class_ID(SCRIPT_POS_CONTROL_CLASS_ID,0); }  
	SClass_ID SuperClassID() { return CTRL_POSITION_CLASS_ID; }  		
};

class ScriptP3Control : public ScriptControl 
{
public:
	ScriptP3Control(ScriptP3Control &ctrl) : ScriptControl(CTRL_POINT3_CLASS_ID, ctrl) {}
	ScriptP3Control(BOOL loading=FALSE) : ScriptControl(CTRL_POINT3_CLASS_ID, loading) {}
	~ScriptP3Control() {}

	RefTargetHandle Clone(RemapDir& remap=NoRemap()) { return(new ScriptP3Control(*this)); }		
	void GetClassName(TSTR& s) { s = _T("Point_script"); }
	Class_ID ClassID() { return Class_ID(SCRIPT_P3_CONTROL_CLASS_ID,0); }  
	SClass_ID SuperClassID() { return CTRL_POINT3_CLASS_ID; }  		
};

class ScriptFloatControl : public ScriptControl 
{
public:
	ScriptFloatControl(ScriptFloatControl &ctrl) : ScriptControl(CTRL_FLOAT_CLASS_ID, ctrl) {}
	ScriptFloatControl(BOOL loading=FALSE) : ScriptControl(CTRL_FLOAT_CLASS_ID, loading) {}
	~ScriptFloatControl() {}

	RefTargetHandle Clone(RemapDir& remap=NoRemap()) { return(new ScriptFloatControl(*this)); }		
	void GetClassName(TSTR& s) { s = _T("Float_script"); }
	Class_ID ClassID() { return Class_ID(SCRIPT_FLOAT_CONTROL_CLASS_ID,0); }  
	SClass_ID SuperClassID() { return CTRL_FLOAT_CLASS_ID; }  		
};

class ScriptScaleControl : public ScriptControl 
{
public:
	ScriptScaleControl(ScriptScaleControl &ctrl) : ScriptControl(CTRL_SCALE_CLASS_ID, ctrl) {}
	ScriptScaleControl(BOOL loading=FALSE) : ScriptControl(CTRL_SCALE_CLASS_ID, loading) {}
	~ScriptScaleControl() {}

	RefTargetHandle Clone(RemapDir& remap=NoRemap()) { return(new ScriptScaleControl(*this)); }		
	void GetClassName(TSTR& s) { s = _T("Scale_script"); }
	Class_ID ClassID() { return Class_ID(SCRIPT_SCALE_CONTROL_CLASS_ID,0); }  
	SClass_ID SuperClassID() { return CTRL_SCALE_CLASS_ID; }  		
};

class ScriptRotControl : public ScriptControl 
{
public:
	ScriptRotControl(ScriptRotControl &ctrl) : ScriptControl(CTRL_ROTATION_CLASS_ID, ctrl) {}
	ScriptRotControl(BOOL loading=FALSE) : ScriptControl(CTRL_ROTATION_CLASS_ID, loading) {}
	~ScriptRotControl() {}

	RefTargetHandle Clone(RemapDir& remap=NoRemap()) { return(new ScriptRotControl(*this)); }		
	void GetClassName(TSTR& s) { s = _T("Rotation_script"); }
	Class_ID ClassID() { return Class_ID(SCRIPT_ROT_CONTROL_CLASS_ID,0); }  
	SClass_ID SuperClassID() { return CTRL_ROTATION_CLASS_ID; }  		
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\NamedSet.h ===
/*	
 *		NamedSet.h - scripter access to named node selection sets 
 *
 *			John Wainwright
 *			Copyright  Autodesk, Inc. 1997
 *
 */

#ifndef _H_NAMEDSET
#define _H_NAMEDSET

/* ---------------------- MAXNamedSetArray ----------------------- */

// provides array-like access to the table of named selection sets

visible_class (MAXNamedSetArray)

class MAXNamedSetArray : public Value, public Collection
{
public:
				MAXNamedSetArray();

				classof_methods (MAXNamedSetArray, Value);
	void		collect() { delete this; }
	ScripterExport void sprin1(CharStream* s);

	// operations
	ScripterExport Value* map(node_map& m);

#include "defimpfn.h"
#	include "arraypro.h"

	// built-in property accessors
	def_property ( count );

};

/* ---------------------- MAXNamedSet ----------------------- */

visible_class (MAXNamedSet)

class MAXNamedSet : public Value, public Collection
{
public:
	TSTR		name;

				MAXNamedSet(TCHAR* iname);

				classof_methods (MAXNamedSet, Value);
	BOOL		_is_collection() { return 1; }
	void		collect() { delete this; }
	ScripterExport void sprin1(CharStream* s);

	// operations
	ScripterExport Value* map(node_map& m);

#include "defimpfn.h"
#	include "arraypro.h"

	// built-in property accessors
	def_property ( count );
	def_property ( center );
	def_property ( min );
	def_property ( max );
};

extern MAXNamedSetArray theNamedSetArray;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\Numbers.h ===
/*		Numbers.h - the number family of classes - numbers for MAXScript
 *
 *		Copyright (c) John Wainwright, 1996
 *		
 *
 */

#ifndef _H_NUMBER
#define _H_NUMBER

#include "MSTime.h"

#define FLOAT_CACHE_SIZE	1024	// must be power of 2
#define INT_CACHE_SIZE		512		//   "       "       "
#define LOW_INT_RANGE		100

class Float;
class Integer;

extern Float* float_cache[];
extern Integer* int_cache[];

visible_class (Number)

class Number : public Value
{
public:
#	define  is_number(o) ((o)->tag == class_tag(Float) || (o)->tag == class_tag(Integer))
			classof_methods (Number, Value);

	static	Value* read(TCHAR* str);
	static	void setup();
	
#include "defimpfn.h"
	def_generic( coerce,	"coerce");
	def_generic( copy,		"copy");
};

visible_class (Float)
visible_class (Integer)		// forward decls for float class 
#define  is_integer(o) ((o)->tag == class_tag(Integer))

class Float : public Number
{
public:
	float value;

			Float() { }
			Float(float init_val);

	static ScripterExport Value* intern(float init_val);

			classof_methods (Float, Number);
#	define  is_float(o) ((o)->tag == class_tag(Float))
	void	collect() { delete this; }
	ScripterExport void	sprin1(CharStream* s);

	/* include all the protocol declarations */

#include "defimpfn.h"
#	include "mathpro.h"

	float	to_float() { return value; }
	int		to_int() { return (int)value; }
	TimeValue to_timevalue() { return (TimeValue)(value * GetTicksPerFrame()); }  // numbers used as times are in frames

	Value*	widen_to(Value* arg, Value** arg_list);
	BOOL	comparable(Value* arg) { return (is_integer(arg) || is_float(arg) || is_time(arg)); }

	// scene I/O 
	IOResult Save(ISave* isave);
	static Value* Load(ILoad* iload, USHORT chunkID, ValueLoader* vload);
};

class Integer : public Number
{
public:
	int value;

			Integer() { };
			Integer(int init_val);

	static  ScripterExport Value* intern(int init_val);

			classof_methods (Integer, Number);
	void	collect() { delete this; }
	ScripterExport void	sprin1(CharStream* s);

	/* include all the protocol declarations */

#include "defimpfn.h"
#	include "mathpro.h"

	float	to_float() { return (float)value; }
	int		to_int() { return value; }
	TimeValue to_timevalue() { return (TimeValue)(value * GetTicksPerFrame()); }  // numbers used as times are in frames

	Value*	widen_to(Value* arg, Value** arg_list);
	BOOL	comparable(Value* arg) { return (is_integer(arg) || is_float(arg) || is_time(arg)); }

	// scene I/O 
	IOResult Save(ISave* isave);
	static Value* Load(ILoad* iload, USHORT chunkID, ValueLoader* vload);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\Name.h ===
/*	
 *		Name.h - Name class for MAXScript
 *
 *			Copyright  John Wainwright 1996
 *
 */

#ifndef _H_NAME
#define _H_NAME

#include "HashTab.h"

visible_class (Name)

class Name : public Value
{
public:
	TCHAR*		string;
	static		HashTable* intern_table;
				Name(TCHAR *init_string);
			   ~Name() { if (string) free(string); }

#	define		is_name(o) ((o)->tag == class_tag(Name))
	static void	setup();
	static ScripterExport Value* intern(TCHAR* str);
	static ScripterExport Value* find_intern(TCHAR* str);
				classof_methods (Name, Value);
	
	ScripterExport void sprin1(CharStream* s);
	void		collect() { delete this; }
	TCHAR*		to_string() { return string; }

#include "defimpfn.h"
	use_generic( coerce,	"coerce");
	use_generic( gt,		">");
	use_generic( lt,		"<");
	use_generic( ge,		">=");
	use_generic( le,		"<=");

	// scene I/O 
	IOResult Save(ISave* isave);
	static Value* Load(ILoad* iload, USHORT chunkID, ValueLoader* vload);

};

/* core interned names */

#include "defextfn.h"
#	include "corename.h"


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\NurbsSub.h ===
/*	
 *		NurbsSub.h - Nurbs sub-object classes & functions
 *
 *	mirrors the mesh sub-object selection classes for NURBS sub-objects.
 *
 *			Copyright  Autodesk, Inc., 1998
 *				John Wainwright
 */

#ifndef _H_NURBSSUB
#define _H_NURBSSUB

// Nurbs selection types
#define NSEL_ALL		1		// whole Nurbs selected 
#define NSEL_CUR		2		// current selection 
#define NSEL_EXP		3		// explicit selection (in vsel) 
#define NSEL_SINGLE		4		// explicit single index  

/* -------------- base class for Nurbs sub-object selections ------------------- */

visible_class (NURBSSelection)

class NURBSSelection : public Value
{
public:
	MAXNode*	owner;			// owner node if any
	Object*		obj;			// NURBS base obj if any
	NURBSSubObjectLevel level;	// subobject level of this selection
	BYTE		sel_type;		// selection type
	BitArray	vsel;			// stand-alone selection if any or copy of current owner level selection
	DWORD		index;			// single vert index 			

	ScripterExport NURBSSelection(MAXNode* own, NURBSSubObjectLevel lvl, BYTE stype, DWORD indx = 0);

				classof_methods (NURBSSelection, Value);
#	define		is_NURBSSelection(v) ((v)->tag == class_tag(NURBSSelection))
	void		collect() { delete this; }
	void		gc_trace();
	ScripterExport void sprin1(CharStream* s);

	// utility functions
	BitArray*	get_sel();							// my element selection
	void		get_owner_sel(BitArray& osel);		// owner's element selection
	int			num_elements();
	BOOL		is_same_selection(Value* s) { return is_NURBSSelection(s) && ((NURBSSelection*)s)->level == level; }
	void		setup_xform(BitArray& os, BOOL& local_org, Matrix3& axis);

	DWORD		get_sel_index(BitArray* vs, int n);  // index for n'th item vertex in BitArray
	void		update_sel();
	void		sprin1(TCHAR* type, CharStream* s);

	// operations
#include "defimpfn.h"
#	include "arraypro.h"
	def_generic ( move,			"move");
	def_generic ( scale,		"scale");
	def_generic ( rotate,		"rotate");
	def_generic ( delete,		"delete");
	def_generic ( select,		"select");
	def_generic ( deselect,		"deselect");
	def_generic ( selectmore,	"selectMore");

	ScripterExport Value* map(node_map& m);

	// built-in property accessors
	def_property ( count );
	def_property ( index );
	def_property ( selSetNames );
	def_property ( pos );
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\objpro.h ===
/*	
 *		MAX_node_protocol.h - def_generics for the operations on MAX node objects
 *
 *		see def_abstract_generics.h for more info.
 *
 *	
 *			Copyright  John Wainwright 1996
 *
 */

	def_visible_generic(create,	"create");

	def_visible_generic(move,	"move");
	def_visible_generic(scale,	"scale");
	def_visible_generic(rotate,	"rotate");
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\nurbspro.h ===
/*	
 *		nurbspro.h - MAX NURBS protocols
 *
 *			Copyright  Autodesk, Inc. 1997
 *			Author: John Wainwright
 *
 */

	def_visible_generic ( evalPos,			"evalPos" );
	def_visible_generic ( evalTangent,		"evalTangent" );
//	def_visible_generic ( getTrimPoint,		"getTrimPoint" );
	def_visible_generic ( getKnot,			"getKnot" );
	def_visible_generic ( setKnot,			"setKnot" );
	def_visible_generic ( getCV,			"getCV" );
	def_visible_generic ( setCV,			"setCV" );
	def_visible_generic ( refine,			"refine" );
	def_visible_generic ( getPoint,			"getPoint" );
	def_visible_generic ( setPoint,			"setPoint" );
	def_visible_generic ( evalUTangent,		"evalUTangent" );
	def_visible_generic ( evalVTangent,		"evalVTangent" );
	def_visible_generic ( setTiling,		"setTiling" );
	def_visible_generic ( getTiling,		"getTiling" );
	def_visible_generic ( setTilingOffset,	"setTilingOffset" );
	def_visible_generic ( getTilingOffset,	"getTilingOffset" );
	def_visible_generic ( setTextureUVs,	"setTextureUVs" );
	def_visible_generic ( getTextureUVs,	"getTextureUVs" );
	def_visible_generic ( setGenerateUVs,	"setGenerateUVs" );
	def_visible_generic ( getGenerateUVs,	"getGenerateUVs" );
	def_visible_generic ( closeU,			"closeU" );
	def_visible_generic ( closeV,			"closeV" );
	def_visible_generic ( getUKnot,			"getUKnot" );
	def_visible_generic ( getVKnot,			"getVKnot" );
	def_visible_generic ( setUKnot,			"setUKnot" );
	def_visible_generic ( setVKnot,			"setVKnot" );
	def_visible_generic ( refineU,			"refineU" );
	def_visible_generic ( refineV,			"refineV" );
	def_visible_generic ( appendCurve,		"appendCurve" );
	def_visible_generic ( appendCurveByID,  "appendCurveByID" );
	def_visible_generic ( getCurve,			"getCurve" );
	def_visible_generic ( setCurve,			"setCurve" );
	def_visible_generic ( getCurveID,		"getCurveID" );
	def_visible_generic ( setCurveByID,		"setCurveByID" );
	def_visible_generic ( getFlip,			"getFlip" );
	def_visible_generic ( setFlip,			"setFlip" );
	def_visible_generic ( getObject,		"getObject" );
	def_visible_generic ( setObject,		"setObject" );
	def_visible_generic ( appendObject,		"appendObject" );
	def_visible_generic ( removeObject,		"removeObject" );
	def_visible_generic ( deleteObjects,	"deleteObjects" );
	def_visible_generic ( reparameterize, "reparameterize" );

	def_visible_generic ( getParent,		"getParent" );
	def_visible_generic ( getParentID,		"getParentID" );
	def_visible_generic ( setParent,		"setParent" );
	def_visible_generic ( setParentID,		"setParentID" );
	def_visible_generic ( getEdge,			"getEdge" );
	def_visible_generic ( setEdge,			"setEdge" );
	def_visible_generic ( appendUCurve,		"appendUCurve" );
	def_visible_generic ( appendUCurveByID,	"appendUCurveByID" );
	def_visible_generic ( getUCurve,		"getUCurve" );
	def_visible_generic ( getUCurveID,		"getUCurveID" );
	def_visible_generic ( setUCurve,		"setUCurve" );
	def_visible_generic ( setUCurveByID,	"setUCurveByID" );
	def_visible_generic ( appendVCurve,		"appendVCurve" );
	def_visible_generic ( appendVCurveByID,	"appendVCurveByID" );
	def_visible_generic ( getVCurve,		"getVCurve" );
	def_visible_generic ( getVCurveID,		"getVCurveID" );
	def_visible_generic ( setVCurve,		"setVCurve" );
	def_visible_generic ( setVCurveByID,	"setVCurveByID" );
	def_visible_generic ( disconnect,		"disconnect" );
	def_visible_generic ( setSeed, 	"setSeed" );
	def_visible_generic ( getSeed, 	"getSeed" );
	def_visible_generic ( getRadius, "getRadius" );
	def_visible_generic ( setRadius, "setRadius" );
	def_visible_generic ( getTrimSurface,	"getTrimSurface" );
	def_visible_generic ( setTrimSurface,	"setTrimSurface" );
	def_visible_generic ( getFlipTrim, "getFlipTrim" );
	def_visible_generic ( setFlipTrim, "setFlipTrim" );

	def_visible_generic ( setTextureSurface, "setTextureSurface" );
	def_visible_generic ( getTextureSurface, "getTextureSurface" );

	def_visible_generic ( getProdTess,		"getProdTess" );
	def_visible_generic ( setProdTess,		"setProdTess" );
	def_visible_generic ( getViewTess,		"getViewTess" );
	def_visible_generic ( setViewTess,		"setViewTess" );
	def_visible_generic ( clearViewTess,	"clearViewTess" );
	def_visible_generic ( clearProdTess,	"clearProdTess" );

	def_visible_generic ( setCurveStartPoint,	"setCurveStartPoint" );
	def_visible_generic ( getCurveStartPoint,	"getCurveStartPoint" );

	def_visible_primitive ( NURBSLatheSurface,		"MakeNURBSLatheSurface" );
	def_visible_primitive ( NURBSSphereSurface,		"MakeNURBSSphereSurface" );
	def_visible_primitive ( NURBSCylinderSurface,	"MakeNURBSCylinderSurface" );
	def_visible_primitive ( NURBSConeSurface,		"MakeNURBSConeSurface" );
	def_visible_primitive ( NURBSTorusSurface,		"MakeNURBSTorusSurface" );

	def_visible_primitive ( NURBSNode,				"NURBSNode" );
	def_visible_primitive ( NURBSLatheNode,			"NURBSLatheNode" );
	def_visible_primitive ( NURBSExtrudeNode,		"NURBSExtrudeNode" );

	def_visible_primitive ( updateSurfaceMapper,	"updateSurfaceMapper" );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\OLE_auto.h ===
/*	
 *		OLEAutomation.h - OLE Automation services for MAXScript
 *
 *			Copyright  John Wainwright 1996
 *
 */

#ifndef _H_MAX_OLE_AUTOMATION
#define _H_MAX_OLE_AUTOMATION

#include "Arrays.h"
#include "classIDs.h"
#include "Funcs.h"

/* error scodes */

#define MS_E_EXCEPTION					MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, 0x0200)  
#define MS_E_ILLEGAL_RETURN_VALUE       MS_E_EXCEPTION + 0x001  

/* ------- the MAXScript OLE object class factory ---------- */

class MSClassFactory : public IClassFactory
{
public:
    static IClassFactory* Create();

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(REFIID iid, void** ppv);
    STDMETHOD_(unsigned long, AddRef)(void);
    STDMETHOD_(unsigned long, Release)(void);

    /* IClassFactory methods */
    STDMETHOD(CreateInstance)(IUnknown* pUnkOuter, REFIID iid, void** ppv);
    STDMETHOD(LockServer)(BOOL fLock);

private:
    MSClassFactory();

    unsigned long m_refs;
};

/* ---------- the MAXScript OLE object class -------------- */

class MSOLEObject : public IDispatch
{
public:
    static MSOLEObject* Create();

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(REFIID riid, void** ppvObj);
    STDMETHOD_(unsigned long, AddRef)(void);
    STDMETHOD_(unsigned long, Release)(void);

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(unsigned int* pcTypeInfo);
    STDMETHOD(GetTypeInfo)(unsigned int iTypeInfo, LCID lcid, ITypeInfo** ppTypeInfo);
    STDMETHOD(GetIDsOfNames)(REFIID riid, OLECHAR** rgszNames, unsigned int cNames, LCID lcid, DISPID* rgdispid);
    STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid, LCID lcid, unsigned short wFlags,
					  DISPPARAMS* pdispparams, VARIANT* pvarResult, EXCEPINFO* pexcepinfo, unsigned int* puArgErr);

	/* MSOLEObject stuff */

    unsigned long m_refs;
	static Array* exposed_fns;		// array of exposed MAXScript functions, DISPID is 1-based index in array

    MSOLEObject();

	static void install_fns(Array* fns);
};

/* ---------------- client-side classes -------------------- */

visible_class (OLEObject)

class OLEObject : public Value
{
public:
    Value*		progID;		// user-supplied progID string
	CLSID		clsid;		// CLSID of ActiveX object.
    LPDISPATCH	pdisp;		// IDispatch of ActiveX object.

				OLEObject(Value* progID, CLSID cslid, LPDISPATCH pdisp);
				OLEObject(Value* progID, LPDISPATCH pdisp);
			   ~OLEObject();

				classof_methods (OLEObject, Value);
	void		collect() { delete this; }
	void		gc_trace();
	ScripterExport void		sprin1(CharStream* s);

	Value*		get_property(Value** arg_list, int count);
	Value*		set_property(Value** arg_list, int count);
	Value*		get_fn_property(Value* prop);
};

visible_class (OLEMethod)

class OLEMethod : public Function
{
public:
	OLEObject*	ole_obj;	// my OLE object
    DISPID		dispid;		// method dispatch ID

				OLEMethod() { }
				OLEMethod(TCHAR* name, OLEObject* ole_obj, DISPID mth_id);

				classof_methods (OLEMethod, Function);
	void		collect() { delete this; }
	void		gc_trace();

	Value*		apply(Value** arglist, int count);
};

BOOL init_MAXScript_OLE();
void uninit_OLE();

#define UNUSED(X) (X)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\PathName.h ===
/*	
 *		PathName.h - PathName class for MAXScript
 *
 *			Copyright  John Wainwright 1996
 *
 */

#ifndef _H_PATHNAME
#define _H_PATHNAME

#include "Collect.h"
#include "Thunks.h"
#include "ObjSets.h"

enum path_flags { rooted_path = 1, wild_card_path = 2 };

visible_class (PathName)

class PathName : public Set
{
public:
	int			flags;
	short		n_levels;
	TCHAR**		path_levels;
	Thunk*		root_set_thunk;
	Value*		root_set;

				PathName();
				~PathName();

				classof_methods (PathName, Set);
	void		collect() { delete this; }
	ScripterExport void		sprin1(CharStream* s);

	ScripterExport Value* eval();
	void		append(TCHAR* level_name);
	Value*		find_object(TCHAR* name);
	Value*		get_object();

	ScripterExport Value* map(node_map& m);

#include "defimpfn.h"
	def_generic  (get,		"get");   // indexed get (no put or append)
	def_property ( count );
	def_property ( center );
	def_property ( min );
	def_property ( max );
};

extern TCHAR* ellipsis_level_name;
extern TCHAR* parent_level_name;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\ObjSets.h ===
/*	
 *		ObjectSets.h - ObjectSet classes for MAXScript
 *
 *			Copyright  John Wainwright 1996
 *
 */

#ifndef _H_OBJECTSET
#define _H_OBJECTSET

#include "Collect.h"
visible_class (Set)

class Set : public Value, public Collection
{
public:
			classof_methods (Set, Value);
	BOOL	_is_collection() { return 1; }

#include "defimpfn.h"
	def_generic  (coerce,   "coerce"); 
};

#include "PathName.h"

visible_class_s (ObjectSet, Set)

class ObjectSet : public Set
{
public:
	TCHAR*		set_name;
	BOOL		(*selector)(INode* node, int level, void* arg);	// set selector function
	void*		selector_arg;									// selector fn argument

				ObjectSet(TCHAR* name, SClass_ID class_id);
				ObjectSet(TCHAR* init_name, BOOL (*sel_fn)(INode*, int, void*), void* init_arg = NULL);
	void		init(TCHAR* name);

				classof_methods (ObjectSet, Set);
	static void	setup();
	TCHAR*		name() { return set_name; }
	void		collect() { delete this; }
	void		sprin1(CharStream* s) { s->printf(_T("$%s"), set_name); }
	void		export_to_scripter();

	ScripterExport Value* map(node_map& m);
	ScripterExport Value* map_path(PathName* path, node_map& m);
	ScripterExport Value* find_first(BOOL (*test_fn)(INode* node, int level, void* arg), void* test_arg);
	ScripterExport Value* get_path(PathName* path);

#include "defimpfn.h"
	def_generic  (get,		"get");   // indexed get (no put or append)
	def_property ( count );
	def_property ( center );
	def_property ( min );
	def_property ( max );
};

extern ObjectSet all_objects;
extern ObjectSet all_geometry;
extern ObjectSet all_lights;
extern ObjectSet all_cameras;
extern ObjectSet all_helpers;
extern ObjectSet all_shapes;
extern ObjectSet all_systems;
extern ObjectSet all_spacewarps;
extern ObjectSet current_selection;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\nodepro.h ===
/*	
 *		MAX_node_protocol.h - def_generics for the operations on MAX node objects
 *
 *		see def_abstract_generics.h for more info.
 *
 *	
 *			Copyright  John Wainwright 1996
 *
 */
 
/* node transforms */

	def_node_generic(move,			"move");
	def_node_generic(scale,			"scale");
	def_node_generic(rotate,		"rotate");

/* node ops */

	def_node_generic(copy,			"copy");
	def_node_generic(reference,		"reference");
	def_node_generic(instance,		"instance");
	def_visible_primitive(delete,	"delete");		// a prim so I can control collection traversal
	def_node_generic(isDeleted,		"isDeleted");
	def_node_generic(addModifier,	"addModifier");
	def_node_generic(deleteModifier, "deleteModifier");
	def_node_generic(collapseStack, "collapseStack");
	def_node_generic(bindSpaceWarp, "bindSpaceWarp");
	def_node_generic(intersects,	"intersects");
//	def_node_generic(dependsOn,		"dependsOn");

	def_node_generic       (instanceReplace,		"instanceReplace");
	def_node_generic       (referenceReplace,		"referenceReplace");
	def_node_generic       (snapShot,				"snapShot");

	def_visible_generic    (getModContextTM,		"getModContextTM");
	def_visible_generic    (getModContextBBoxMin,	"getModContextBBoxMin");
	def_visible_generic    (getModContextBBoxMax,	"getModContextBBoxMax");
	def_visible_primitive  (validModifier,			"validModifier");
	def_visible_generic    (canConvertTo,			"canConvertTo");
	def_node_generic       (convertTo,				"convertTo");
	def_node_generic       (flagForeground,			"flagForeground");

/* node state */
	
	def_node_generic(hide,			"hide");
	def_node_generic(unhide,		"unhide");
	def_node_generic(unfreeze,		"unfreeze");
	def_node_generic(freeze,		"freeze");
	def_node_generic(select,		"select");
	def_node_generic(deselect,		"deselect");
	def_visible_primitive(clearSelection, "clearSelection");
	def_node_generic(selectmore,	"selectmore");
	def_visible_primitive(group,	"group");
	def_visible_primitive(ungroup,	"ungroup");
	def_visible_primitive(explodeGroup,	"explodeGroup");

/* object xrefs */
	def_visible_generic	( updateXRef,	"updateXRef");

/* NURBS */

	def_node_generic	( getNURBSSet,		"getNURBSSet");
	def_node_generic	( addNURBSSet,		"addNURBSSet");
	use_generic			( transform,		"transform" );
	def_node_generic	( breakCurve,		"breakCurve" );
	def_node_generic	( breakSurface,		"breakSurface" );
	def_node_generic	( joinCurves,		"joinCurves" );
	def_node_generic	( joinSurfaces,		"joinSurfaces" );
	def_node_generic	( makeIndependent,	"makeIndependent" );
	def_node_generic    ( convertToNURBSCurve,		"convertToNURBSCurve" );
	def_node_generic    ( convertToNURBSSurface,	"convertToNURBSSurface" );
	def_node_generic    ( setViewApproximation,		"setViewApproximation" );
	def_node_generic    ( setRenderApproximation,	"setRenderApproximation" );
	def_node_generic    ( setSurfaceDisplay,		"setSurfaceDisplay" );

/* utilities */
	
	def_node_generic(intersectRay,		"intersectRay");
	def_node_generic(printstack,		"printstack");
	def_visible_primitive(uniqueName,	"uniqueName");

/* user prop access */
	
	def_node_generic( getUserProp,		"getUserProp");
	def_node_generic( setUserProp,		"setUserProp");
	def_node_generic( getUserPropBuffer, "getUserPropBuffer");
	def_node_generic( setUserPropBuffer, "setUserPropBuffer");
	
/* mesh ops -- if baseobject is a mesh */

	use_generic     ( plus,			"+" );		// mesh boolean ops
	use_generic     ( minus,		"-" );
	use_generic     ( times,		"*" );

	def_node_generic( convertToMesh, "convertToMesh");  // this works on those things convertable to meshes

	def_visible_generic( setvert,		 "setvert");
	def_visible_generic( getvert,		 "getvert");
	def_visible_generic( settvert,		 "settvert");
	def_visible_generic( gettvert,		 "gettvert");
	def_visible_generic( setvertcolor,	 "setvertcolor");
	def_visible_generic( getvertcolor,	 "getvertcolor");
	def_visible_generic( setnumverts,	 "setnumverts");
	def_visible_generic( getnumverts,	 "getnumverts");
	def_visible_generic( setnumtverts,	 "setnumtverts");
	def_visible_generic( getnumtverts,	 "getnumtverts");
	def_visible_generic( setnumcpvverts, "setnumcpvverts");
	def_visible_generic( getnumcpvverts, "getnumcpvverts");
	def_visible_generic( setnumfaces,	 "setnumfaces");
	def_visible_generic( getnumfaces,	 "getnumfaces");
	def_visible_generic( buildtvfaces,   "buildTVFaces");
	def_visible_generic( buildvcfaces,   "buildVCFaces");
	def_visible_generic( defaultvcfaces, "defaultVCFaces");
	def_visible_generic( getnormal,		 "getnormal");
	def_visible_generic( setnormal,		 "setnormal");
	def_visible_generic( setface,		 "setface");
	def_visible_generic( getface,		 "getface");
	def_visible_generic( settvface,		 "setTVFace");
	def_visible_generic( gettvface,		 "getTVFace");
	def_visible_generic( setvcface,		 "setVCFace");
	def_visible_generic( getvcface,		 "getVCFace");
	def_visible_generic( getfacenormal,  "getfacenormal");
	def_visible_generic( setfacenormal,  "setfacenormal");
	def_visible_generic( setfacematid,	 "setfaceMatID");
	def_visible_generic( getfacematid,	 "getfaceMatID");
	def_visible_generic( setfacesmoothgroup, "setfaceSmoothGroup");
	def_visible_generic( getfacesmoothgroup, "getfaceSmoothGroup");
	def_visible_generic( setedgevis,	 "setedgevis");
	def_visible_generic( getedgevis,	 "getedgevis");
	def_visible_generic( attach,	     "attach");
	def_visible_generic( detachVerts,	 "detachVerts");
	def_visible_generic( detachFaces,	 "detachFaces");
	def_visible_generic( extrudeface,	 "extrudeface");
	def_visible_generic( deletevert,	 "deletevert");
	def_visible_generic( deleteface,	 "deleteface");
	def_visible_generic( collapseface,	 "collapseface");
	def_visible_generic( setMesh,		 "setMesh");
	def_visible_generic( update,		 "update");
	def_visible_generic( getDisplacementMapping, "getDisplacementMapping");
	def_visible_generic( setDisplacementMapping, "setDisplacementMapping");
	def_visible_generic( getSubdivisionDisplacement, "getSubdivisionDisplacement");
	def_visible_generic( setSubdivisionDisplacement, "setSubdivisionDisplacement");
	def_visible_generic( getSplitMesh,		"getSplitMesh");
	def_visible_generic( setSplitMesh,		"setSplitMesh");
	def_visible_generic( displacementToPreset, "displacementToPreset" );

	def_node_generic( getVertSelection,	 "getVertSelection");  // getVertSelection <node> <nodemodifier>
	def_node_generic( setVertSelection,	 "setVertSelection"); 
	def_node_generic( getFaceSelection,	 "getFaceSelection");  
	def_node_generic( setFaceSelection,	 "setFaceSelection");  
	def_node_generic( getEdgeSelection,	 "getEdgeSelection");  
	def_node_generic( setEdgeSelection,	 "setEdgeSelection");  

	def_struct_primitive( mo_startCreate,		meshOps, "startCreate");
	def_struct_primitive( mo_startAttach,		meshOps, "startAttach");
	def_struct_primitive( mo_startExtrude,		meshOps, "startExtrude");
	def_struct_primitive( mo_startBevel,		meshOps, "startBevel");
	def_struct_primitive( mo_startChamfer,		meshOps, "startChamfer");
	def_struct_primitive( mo_startCut,			meshOps, "startCut");
	def_struct_primitive( mo_startSlicePlane,	meshOps, "startSlicePlane");
	def_struct_primitive( mo_startWeldTarget,	meshOps, "startWeldTarget");
	def_struct_primitive( mo_startFlipNormalMode, meshOps, "startFlipNormalMode");
	def_struct_primitive( mo_startDivide,		meshOps, "startDivide");
	def_struct_primitive( mo_startTurn,			meshOps, "startTurn");
	def_struct_primitive( mo_hideOp,			meshOps, "hide");
	def_struct_primitive( mo_unhideAllOp,		meshOps, "unhideAll");
	def_struct_primitive( mo_deleteOp,			meshOps, "delete");
	def_struct_primitive( mo_detachOp,			meshOps, "detach");
	def_struct_primitive( mo_weldOp,			meshOps, "weld");
	def_struct_primitive( mo_breakOp,			meshOps, "break");
	def_struct_primitive( mo_viewAlignOp,		meshOps, "viewAlign");
	def_struct_primitive( mo_gridAlignOp,		meshOps, "gridAlign");
	def_struct_primitive( mo_makePlanarOp,		meshOps, "makePlanar");
	def_struct_primitive( mo_collapseOp,		meshOps, "collapse");
	def_struct_primitive( mo_tesselateOp,		meshOps, "tessellate");
	def_struct_primitive( mo_explodeOp,			meshOps, "explode");
	def_struct_primitive( mo_sliceOp,			meshOps, "slice");
	def_struct_primitive( mo_removeIsolatedVertsOp,	meshOps, "removeIsolatedVerts");
	def_struct_primitive( mo_selectOpenEdgesOp,	meshOps, "selectOpenEdges");
	def_struct_primitive( mo_createShapeFromEdgesOp,meshOps, "createShapeFromEdges");
	def_struct_primitive( mo_flipNormalOp,		meshOps, "flipNormal");
	def_struct_primitive( mo_unifyNormalOp,		meshOps, "unifyNormal");
	def_struct_primitive( mo_visibleEdgeOp,		meshOps, "visibleEdge");
	def_struct_primitive( mo_invisibleEdgeOp,	meshOps, "invisibleEdge");
	def_struct_primitive( mo_autoEdgeOp,		meshOps, "autoEdge");

/* shape ops -- if baseobject is a shape */

	def_node_generic( pathinterp,			"pathInterp");			// MAX path interpolation (subcurve piecewise)
	def_node_generic( lengthinterp,			"lengthInterp");		// total arclength interpolation
	def_visible_primitive( resetlengthinterp, "resetLengthInterp");  // clear length interp caches
	def_node_generic( curvelength,			"curveLength");			// total arclength interpolation
	def_node_generic( nearestpathparam,		"nearestPathParam");    // path 'u' param at nearest point along curve to obj
	def_node_generic( pathtolengthparam,	"pathToLengthParam");  // give length 'u' param from path 'u' param
	def_node_generic( lengthtopathparam,	"lengthToPathParam");  // give path 'u' param from length 'u' param
	def_node_generic( pathtangent,			"pathTangent");			// MAX path interpolation tangent (subcurve piecewise)
	def_node_generic( lengthtangent,		"lengthTangent");		// total arclength interpolation tangent

/* bezier shape ops -- if baseobject is a bezier shape */

	def_node_generic( convertToSplineShape,	"convertToSplineShape");  // this works on those things convertable to splineshapes
	
	def_node_generic( addNewSpline,		"addNewSpline");		
	def_node_generic( deleteSpline,		"deleteSpline");		
	def_node_generic( numSplines,		"numSplines");
	def_node_generic( setFirstSpline,	"setFirstSpline");
	def_node_generic( resetShape,		"resetShape");
	def_node_generic( updateShape,		"updateShape");
	
	def_node_generic( numKnots,			"numKnots");		
	def_node_generic( numSegments,		"numSegments");		
	def_node_generic( isClosed,			"isClosed");		
	use_generic     ( close,			"close");		
	def_node_generic( open,				"open");		
	def_node_generic( addKnot,			"addKnot");		
	def_node_generic( deleteKnot,		"deleteKnot");		
	def_node_generic( setKnotType,		"setKnotType");		
	def_node_generic( getKnotType,		"getKnotType");		
	def_node_generic( setSegmentType,	"setSegmentType");		
	def_node_generic( getSegmentType,	"getSegmentType");		
	def_node_generic( refineSegment,	"refineSegment");		
	def_node_generic( reverse,			"reverse");		
	def_node_generic( setFirstKnot,		"setFirstKnot");		
	def_node_generic( setKnotPoint,		"setKnotPoint");		
	def_node_generic( getKnotPoint,		"getKnotPoint");		
	def_node_generic( getInVec,			"getInVec");		
	def_node_generic( setInVec,			"setInVec");		
	def_node_generic( getOutVec,		"getOutVec");		
	def_node_generic( setOutVec,		"setOutVec");
	def_node_generic( hideSelectedVerts,"hideSelectedVerts");
	def_node_generic( hideSelectedSplines,	"hideSelectedSplines");
	def_node_generic( hideSelectedSegments,  "hideSelectedSegments");
	def_node_generic( unhideSegments,	"unhideSegments");
	def_node_generic( updateBindList,	"updateBindList");
	def_node_generic( unbindKnot,		"unbindKnot");
	def_node_generic( bindKnot,			"bindKnot");
	def_node_generic( materialID,		"materialID");
	def_node_generic( addAndWeld,		"addAndWeld");


	def_visible_primitive( getKnotSelection,   "getKnotSelection");  // getKnotSelection <node> works only for editable splines
	def_visible_primitive( setKnotSelection,   "setKnotSelection"); 
	def_visible_primitive( getSegSelection,	   "getSegSelection");  
	def_visible_primitive( setSegSelection,	   "setSegSelection");  
	def_visible_primitive( getSplineSelection, "getSplineSelection");  
	def_visible_primitive( setSplineSelection, "setSplineSelection");  

	def_struct_primitive( so_startCreateLine,	splineOps, "startCreateLine");
	def_struct_primitive( so_startAttach,		splineOps, "startAttach");
	def_struct_primitive( so_startInsert,		splineOps, "startInsert");
	def_struct_primitive( so_startConnect,		splineOps, "startConnect");
	def_struct_primitive( so_startRefine,		splineOps, "startRefine");
	def_struct_primitive( so_startFillet,		splineOps, "startFillet");
	def_struct_primitive( so_startChamfer,		splineOps, "startChamfer");
	def_struct_primitive( so_startBind,			splineOps, "startBind");
	def_struct_primitive( so_startRefineConnect,splineOps, "startRefineConnect");
	def_struct_primitive( so_startOutline,		splineOps, "startOutline");
	def_struct_primitive( so_startTrim,			splineOps, "startTrim");
	def_struct_primitive( so_startExtend,		splineOps, "startExtend");
	def_struct_primitive( so_startCrossInsert,	splineOps, "startCrossInsert");
	def_struct_primitive( so_startBreak,		splineOps, "startBreak");
	def_struct_primitive( so_startUnion,		splineOps, "startUnion");
	def_struct_primitive( so_startSubtract,		splineOps, "startSubtract");

	def_struct_primitive( so_opHide,			splineOps, "hide");
	def_struct_primitive( so_opUnhideAll,		splineOps, "unhideAll");
	def_struct_primitive( so_opDelete,			splineOps, "delete");
	def_struct_primitive( so_opDetach,			splineOps, "detach");
	def_struct_primitive( so_opDivide,			splineOps, "divide");
	def_struct_primitive( so_opCycle,			splineOps, "cycle");
	def_struct_primitive( so_opUnbind,			splineOps, "unbind");
	def_struct_primitive( so_opWeld,			splineOps, "weld");
	def_struct_primitive( so_opMakeFirst,		splineOps, "makeFirst");
	def_struct_primitive( so_opAttachMultiple,	splineOps, "attachMultiple");
	def_struct_primitive( so_opExplode,			splineOps, "explode");
	def_struct_primitive( so_opReverse,			splineOps, "reverse");
	def_struct_primitive( so_opClose,			splineOps, "close");
	def_struct_primitive( so_opIntersect,		splineOps, "intersect");
	def_struct_primitive( so_opMirrorHoriz,		splineOps, "mirrorHoriz");
	def_struct_primitive( so_opMirrorVert,		splineOps, "mirrorVert");
	def_struct_primitive( so_opMirrorBoth,		splineOps, "mirrorBoth");
	def_struct_primitive( so_opSelectByID,		splineOps, "selectByID");

/* particle ops -- if baseobject is a particle system */

	def_node_generic( particlecount,	"particleCount");		
	def_node_generic( particlepos,		"particlePos");		
	def_node_generic( particlevelocity,	"particleVelocity");		
	def_node_generic( particleage,		"particleAge");	
	def_node_generic( particlesize,		"particleSize");

/* patch ops */

	def_struct_primitive( po_startAttach,		patchOps, "startAttach");
	def_struct_primitive( po_startExtrude,		patchOps, "startExtrude");
	def_struct_primitive( po_startBevel,		patchOps, "startBevel");
	def_struct_primitive( po_startBind,			patchOps, "startBind");

	def_struct_primitive( po_opUnbind,			patchOps, "unbind");
	def_struct_primitive( po_opHide,			patchOps, "hide");
	def_struct_primitive( po_opUnhideAll,		patchOps, "unhideAll");
	def_struct_primitive( po_opWeld,			patchOps, "weld");
	def_struct_primitive( po_opDelete,			patchOps, "delete");
	def_struct_primitive( po_opSubdivide,		patchOps, "subdivide");
	def_struct_primitive( po_opAddTri,			patchOps, "addTri");
	def_struct_primitive( po_opAddQuad,			patchOps, "addQuad");
	def_struct_primitive( po_opDetach,			patchOps, "detach");
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\Parser.h ===
/*	
 *		Parser.h - a compiler for the 3DS MAX MAXScript scripting language
 *
 *			Copyright  John Wainwright 1996
 *
 */

#ifndef _H_PARSER
#define _H_PARSER

#include "Strings.h"
#include "HashTab.h"
#include "Name.h"
#include "Rollouts.h"
#include "imacroscript.h"

#define MAX_TOKEN_SIZE	256
#define UNDEFINED_MACRO -1

extern ScripterExport HashTable* globals;

class MouseTool;
class RCMenu;

/* tokens ... */

enum lex_token
{
	t_local, t_global, t_fn, t_mapped,
	t_if, t_then, t_else, t_do, t_collect, t_while, t_case, 
	t_open_paren, t_close_paren, t_plus, t_times, t_minus, t_div, t_power, t_end,
	t_pluseq, t_minuseq, t_timeseq, t_diveq,
	t_and, t_or, t_not,
	t_number, t_string, t_assign, t_semicolon, t_bad,
	t_badNum, t_eol, t_comma, t_open_bracket, t_close_bracket, t_colon,
	t_quote, t_doubleQuote, t_ampersand, t_name, t_dot, t_name_literal,
	t_openCurly, t_closeCurly, t_hash, t_eq, t_ne, t_lt, t_gt,
	t_ge, t_le, t_for, t_in, t_from, t_to, t_by, t_of, t_where,
	t_as, t_parameter_keyword, t_path_name,
	t_query, t_slash, t_ellipsis, t_level_name, t_wild_card_name, 
	t_dot_dot, t_end_of_path,
	t_with, t_animate, t_coordsys, t_set, t_undo,
	t_about, t_at, t_on, t_off,
	t_max, t_nullary_call, t_utility, t_rollout,
	t_return, t_exit, t_when, t_continue,
	t_struct, t_try, t_catch, t_throw, t_eos,
	t_plugin, t_tool, t_persistent, t_parameters, t_rcmenu, t_macroScript,
	t_missing
};

typedef RolloutControl* (*create_fn)(Value* name, Value* caption, Value** keyparms, int keyparm_count);
typedef struct
{
	Value*	name;
	create_fn creator;
} rollout_control;

extern ScripterExport void install_rollout_control(Value* name, create_fn creator);
class MSPluginClass;
class CodeBlock;

class Parser : public Value				
{
public:
	ScripterExport		   Parser();
	ScripterExport		   Parser(CharStream* errout);
	ScripterExport		   Parser(HashTable* scope);
	ScripterExport		   Parser(CharStream* errout, HashTable* scope);
					void   init();
	ScripterExport	Value* compile(CharStream* stream);
	ScripterExport	Value* compile_factor(CharStream* stream);
	ScripterExport	Value* compile_all(CharStream* stream);
	static			void   setup();

	static Tab<rollout_control> rollout_controls;

	void		collect() { delete this; }
	void		gc_trace();

	CharStream*	source;			// input stream						
	lex_token	token;			// parser's current lexical token	
	Value*		token_value;	//          and value				
	BOOL		at_EOL;			// positioned at \r					
	BOOL		back_tracked;	// we back-tracked					
	BOOL		EOL_at_back_track; // remember EOL state at back_track 
	BOOL		quoted_level_name; // if path level name was quote	
	BOOL		spaced;			// if space after token				
	BOOL		space_before;	// if '-' had a space before		
	BOOL		space_after;	// if '-' had a space after			
	BOOL		throws_ok;		// indicates if empty throws are OK (only in catches) 
	BOOL		in_rollout;		// compiling rollout, no new locals by default 
	BOOL		in_macroscript;	// compiling macroscript, disallow macroscript nesting 
	HashTable*  current_scope;	// current lexical scope hashtable	
	int			parm_count;		// current function def params		
	int			keyparm_count;	//    "        "     " keyword parms 
	int			local_count;	//    "        "     "  locals		
	int			frame_index;	// running fn frame index for locals,args 
	int			frame_level;	// running frame level				
	int			expr_level;		// running nested expression level	
	CharStream* stdout_stream;  // message & debug output stream (usually listener's window) 
	Value*		lookahead_factor; // store for factor lookahead    
	TCHAR		line_buf[256];	// current line capture for error printing 
	TCHAR*		line_buf_p;		//   "       "    "     pointer	   
	CharStream* source_capture; // non-null, capture source to this stream 
	int			ungetch_count;	
	Tab<CharStream*> src_stack; // include source stack				
	BOOL		no_free_refs;	// if on, disallow free refs		
	int			tok_start;		// store stream seek pos of token start 
	CodeBlock*	code_block;		// top-level code block if any

	Value*		single_expr(Value* stream);
	Value*		single_factor(Value* stream);
	Value*		compound_expr(Value* stream);
	Value*		compile_macro_script(Value* stream, MacroID id);

/* lexical analysis methods */
	int			token_must_be(lex_token wanted_token);
	int			next_token_must_be(lex_token wanted_token);
	int			next_token_must_be_name(Value* wanted_name);
	void		back_track(void);
	void		back_track_factor(Value* fac);
	int			white_space(TCHAR& c);
	void		check_for_EOL(TCHAR c);
	void		flush_EO_expr(void);
	TCHAR		get_char();
	void		unget_char(TCHAR c);
	void		flush_to_eobuf();
	Value*		get_string(TCHAR delim);
	Value*		get_path_name();
	Value*		get_name_thunk(Value* name, BOOL make_new);
	lex_token	get_punct(TCHAR c);
	lex_token	get_token(void);
	lex_token	get_path_token(void);
	int			get_max_command(Value*& code);
	void		add_event_handler(HashTable* handlers, BOOL item_based = TRUE);
	void		add_tool_local(TCHAR* var, MouseTool* tool, int& local_count, Value**& local_inits);
	void		add_plugin_local(TCHAR* var, MSPluginClass* plugin, int& local_count, Value**& local_inits, BOOL constant = FALSE);
	Value**		add_rollout_control(Value** controls, int control_index, Rollout* rollout);
	Value**		add_rcmenu_item(Value** items, int& item_count, RCMenu* menu, BOOL subMenu = FALSE);
	void		open_include_file(TCHAR c);
	void		check_for_const_lvalue(Value*& lval);
 
/* recursive descent parse methods */

	Value*		expr_seq(lex_token delimiter);
	Value*		vector_literal();
	Value*		index_or_vector();
	Value*		hash_literals();
	Value*		array_literal();
	Value*		bit_array_literal();
	Value*		factor();
//	Value*		property_access();
//	Value*		array_index();
	Value*		property_index_array();
	Value*		coercion();
    Value*		function_call();
	Value*		power_expr();
	Value*		uminus_expr();
	Value*		term();
	Value*		plus_expr();
	Value*		compare_expr();
	Value*		not_expr();
	Value*		and_expr();
	Value*		simple_expr();
	Value*		variable_declaration();
	Value*		context_expr();
	Value*		change_handler();
	Value*		function(TCHAR* name, short flags = 0);
	Value*		function_def();
	Value*		mapped_fn_def();
	Value*		max_command();
	Value*		struct_body(Value* name);
	Value*		struct_def();
	Value*		try_catch();
	Value*		tool_body(Value* name);
	Value*		tool_def();
	Value*		rcmenu_body(Value* name);
	Value*		rcmenu_def();
	void		plugin_paramblock(MSPluginClass* plugin, Array* pblock_defs, HashTable* handlers, int base_refno);
	Value*		plugin_def();
	Value*		macro_script(MacroID mid = UNDEFINED_MACRO);
	Value*		rollout_body(Value* name);
	Value*		utility_def();
	Value*		rollout_def();
	Value*		exit_expr();
	Value*		continue_expr();
	Value*		return_expr();
	Value*		for_expr();
	Value*		do_expr();
	Value*		while_expr();
	Value*		case_expr();
	Value*		if_expr();
	Value*		assign_expr();
	Value*		expr();
	Value*		top_level_expr();			
};

typedef struct 
{
	TCHAR*		name;
	getter_vf	getter;
	setter_vf   setter;
} property_accessors;

extern property_accessors* get_property_accessors(Value* prop);
extern TCHAR* command_name_from_code(int com);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\phyrgpro.h ===
// Protocols for Physique Rigid Vertex Interface classes

	def_visible_generic(GetNode,			"GetNode");
	def_visible_generic(GetOffsetVector,	"GetOffsetVector");
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\phymcpro.h ===
// Protocols for Physique Mod Context Vertex Interface classes
	
	def_visible_generic(ConvertToRigid,			"ConvertToRigid");
	def_visible_generic(AllowBlending,			"AllowBlending");
	def_visible_generic(GetVertexInterface,		"GetVertexInterface");
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\phyblpro.h ===
// Protocols for Physique Blended Vertex Interface classes	

	def_visible_generic(GetNode,			"GetNode");
	def_visible_generic(GetOffsetVector,	"GetOffsetVector");
	def_visible_generic(GetWeight,		"GetWeight");
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\quatpro.h ===
/*	
 *		quat_protocol.h - def_generics for quaternion protocol
 *
 *	
 *			Copyright  John Wainwright 1996
 *
 */

	use_generic(coerce,	"coerce");

	use_generic( plus,			"+" );
	use_generic( minus,			"-" );
	use_generic( times,			"*" );
	use_generic( div,			"/" );
	use_generic( uminus,		"u-" );

	use_generic( eq,			"=" );
	use_generic( ne,			"!=" );

	use_generic( random,		"random" );

	def_visible_generic( isIdentity,	"isIdentity" );
	use_generic        ( normalize,		"normalize" );
	def_visible_generic( inverse,		"Inverse" );
	def_visible_generic( conjugate,		"Conjugate" );
	def_visible_generic( logN,			"LogN" );
	use_generic        ( exp,			"Exp" );
	def_visible_generic( slerp,			"Slerp" );
	def_visible_generic( lnDif,			"LnDif" );
	def_visible_generic( qCompA,		"QCompA" );
	def_visible_generic( squad,			"Squad" );
	def_visible_generic( qorthog,		"qorthog" );
	def_visible_generic( transform,		"transform" );

	def_visible_primitive( squadrev, "squadrev" );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\prims.h ===
/*	
 *		primitives.h - primitive function defs for MAXScript
 *
 *			Copyright  John Wainwright 1996
 *
 */

#include "buildver.h"

/* scripter-visible primitives */

	/* user input */

	def_visible_primitive( pick_object,				"pickObject");  
	def_visible_primitive( pick_point,				"pickPoint"); 
	def_visible_primitive( get_kb_value,			"getKBValue"); 
	def_visible_primitive( get_kb_point,			"getKBPoint"); 
	def_visible_primitive( get_kb_line,				"getKBLine"); 
	def_visible_primitive( get_kb_char,				"getKBChar"); 
	def_visible_primitive( redraw_views,			"redrawViews"); 
	def_visible_primitive( pick_offset_distance,	"pickOffsetDistance"); 
	def_visible_primitive( clear_listener,			"clearListener"); 
	def_visible_primitive( get_listener_sel,		"getListenerSel");
	def_visible_primitive( set_listener_sel,		"setListenerSel");
	def_visible_primitive( get_listener_sel_text,	"getListenerSelText");
	def_visible_primitive( set_listener_sel_text,	"setListenerSelText");

	/* command-line debugger */

	def_visible_primitive( dbg_break,		"break");
	def_visible_primitive( show_stack,		"stack");
	def_visible_primitive( show_locals,		"locals");
	def_visible_primitive( dbg_go,			"go");

	/* max file I/O */
	
	def_visible_primitive( load_max_file,	"loadMaxFile");
	def_visible_primitive( merge_max_file,	"mergeMaxFile");
	def_visible_primitive( get_max_file_object_names, "getMAXFileObjectNames");
	def_visible_primitive( save_max_file,	"saveMaxFile");
	def_visible_primitive( save_nodes,		"saveNodes");
	def_visible_primitive( reset_max_file,	"resetMaxFile");
	def_visible_primitive( hold_max_file,	"holdMaxFile");
	def_visible_primitive( fetch_max_file,	"fetchMaxFile");
	def_visible_primitive( import_file,		"importFile");
	def_visible_primitive( export_file,		"exportFile");
#ifdef DESIGN_VER 
	def_visible_primitive( link_file,		"linkFile");
#endif

	def_visible_primitive( load_material_library,	"loadMaterialLibrary");
	def_visible_primitive( save_material_library,	"saveMaterialLibrary");
	def_visible_primitive( get_medit_material,		"getMeditMaterial");
	def_visible_primitive( set_medit_material,		"setMeditMaterial");

	def_visible_primitive( quit_max,		"quitMax");

	/* max animation */
	
	def_visible_primitive( play_animation,	"playAnimation");
	def_visible_primitive( stop_animation,	"stopAnimation");

	/* text file I/O */

	def_visible_primitive( open_file,		"openfile");
	def_visible_primitive( create_file,		"createfile");
	def_visible_primitive( open_encrypted,	"openEncryptedFile");
	def_visible_primitive( file_in,			"filein");
	def_visible_primitive( format,			"format");
	def_visible_primitive( open_log,		"openlog");
	def_visible_primitive( close_log,		"closelog");
	def_visible_primitive( flush_log,		"flushlog");

	def_visible_primitive( get_open_filename, "getOpenFileName");
	def_visible_primitive( get_save_filename, "getSaveFileName");
	def_visible_primitive( get_save_path,     "getSavePath");
	def_visible_primitive( filename_from_path, "filenameFromPath");

	def_visible_primitive( get_files,			"getFiles");
	def_visible_primitive( get_directories,		"getDirectories");
	def_visible_primitive( delete_file,			"deleteFile");
	def_visible_primitive( rename_file,			"renameFile");
	def_visible_primitive( copy_file,			"copyFile");
	def_visible_primitive( make_dir,			"makeDir");
	def_visible_primitive( get_filename_path,	"getFilenamePath");
	def_visible_primitive( get_filename_file,	"getFilenameFile");
	def_visible_primitive( get_filename_type,	"getFilenameType");
	def_visible_primitive( get_file_mod_date,	"getFileModDate");
	def_visible_primitive( get_file_create_date,"getFileCreateDate");
	def_visible_primitive( get_file_attribute,	"getFileAttribute");
	def_visible_primitive( set_file_attribute,	"setFileAttribute");

	def_visible_primitive( edit_script,		"edit");
	def_visible_primitive( new_script,		"newScript");

	/* rendering */

	def_visible_primitive( render,			"render");

	/* noise functions */

	def_visible_primitive( noise3,			"noise3");
	def_visible_primitive( noise4,			"noise4");
	def_visible_primitive( turbulence,		"turbulence");
	def_visible_primitive( fractalNoise,	"fractalNoise");

	/* atmospherics */

	def_visible_primitive( addAtmospheric,		"addAtmospheric");
	def_visible_primitive( setAtmospheric,		"setAtmospheric");
	def_visible_primitive( getAtmospheric,		"getAtmospheric");
	def_visible_primitive( deleteAtmospheric,	"deleteAtmospheric");
	def_visible_primitive( editAtmospheric,		"editAtmospheric"); // RK: Added this

	/* effects */ // RK: Added this

	def_visible_primitive( addEffect,		"addEffect");
	def_visible_primitive( setEffect,		"setEffect");
	def_visible_primitive( getEffect,		"getEffect");
	def_visible_primitive( deleteEffect,	"deleteEffect");
	def_visible_primitive( editEffect,		"editEffect");

	/* trackview nodes */

	def_visible_primitive( newTrackViewNode,		"newTrackViewNode");
	def_visible_primitive( deleteTrackViewNode,		"deleteTrackViewNode");
	def_visible_primitive( addTrackViewController,	"addTrackViewController");
	def_visible_primitive( deleteTrackViewController, "deleteTrackViewController");

	/* CUI */

	def_struct_primitive( cui_getConfigFile,cui,	"getConfigFile");
	def_struct_primitive( cui_setConfigFile,cui,	"setConfigFile");
	def_struct_primitive( cui_getDir,		cui,	"getDir");
	def_struct_primitive( cui_saveConfig,	cui,	"saveConfig");
	def_struct_primitive( cui_saveConfigAs,	cui,	"saveConfigAs");
	def_struct_primitive( cui_loadConfig,	cui,	"loadConfig");

	/* macro scripts */
	
	def_struct_primitive( run_macro,	macros,	"run");
	def_struct_primitive( edit_macro,	macros,	"edit");
	def_struct_primitive( new_macro,	macros,	"new");
	def_struct_primitive( load_macros,	macros,	"load");

	/* track view window access */
	
	def_struct_primitive( tvw_open,				trackView,	"open");
	def_struct_primitive( tvw_zoomSelected,		trackView,	"zoomSelected");
	def_struct_primitive( tvw_close,			trackView,	"close");
	def_struct_primitive( tvw_numTrackViews,	trackView,	"numTrackViews");
	def_struct_primitive( tvw_getTrackViewName,	trackView,	"getTrackViewName");
	def_struct_primitive( tvw_setFilter,		trackView,	"setFilter");
	def_struct_primitive( tvw_clearFilter,		trackView,	"clearFilter");
	def_struct_primitive( tvw_pickTrackDlg,		trackView,	"pickTrackDlg");

	/* schematic view window access */
	
	def_struct_primitive( svw_open,				schematicView,	"open");
	def_struct_primitive( svw_zoomSelected,		schematicView,	"zoomSelected");
	def_struct_primitive( svw_close,			schematicView,	"close");
	def_struct_primitive( svw_numSchematicViews,	schematicView,	"numSchematicViews");

	/* modifier panel control */

	def_struct_primitive( modp_setCurrentObject, modPanel,	"setCurrentObject");
	def_struct_primitive( modp_getCurrentObject, modPanel,	"getCurrentObject");
	def_struct_primitive( modp_getModifierIndex, modPanel,	"getModifierIndex");
	def_struct_primitive( modp_addModToSelection, modPanel,	"addModToSelection");

	/* MAX map & xref path config */

	def_struct_primitive( mapPaths_add,			mapPaths,	"add");
	def_struct_primitive( mapPaths_count,		mapPaths,	"count");
	def_struct_primitive( mapPaths_get,			mapPaths,	"get");
	def_struct_primitive( mapPaths_delete,		mapPaths,	"delete");
	def_struct_primitive( xrefPaths_add,		xrefPaths,	"add");
	def_struct_primitive( xrefPaths_count,		xrefPaths,	"count");
	def_struct_primitive( xrefPaths_get,		xrefPaths,	"get");
	def_struct_primitive( xrefPaths_delete,		xrefPaths,	"delete");

	/* references */

//	def_struct_primitive( refs_dependsOn,		refs,		"dependsOn");
	def_struct_primitive( refs_dependents,		refs,		"dependents");

	/* tool modes */

	def_struct_primitive( toolMode_uniformScale,	toolMode,		"uniformScale");
	def_struct_primitive( toolMode_nonUniformScale,	toolMode,		"nonUniformScale");
	def_struct_primitive( toolMode_squashScale,		toolMode,		"squashScale");
	def_struct_primitive( toolMode_coordsys,		toolMode,		"coordsys");
	def_struct_primitive( toolMode_pivotCenter,		toolMode,		"pivotCenter");
	def_struct_primitive( toolMode_selectionCenter,	toolMode,		"selectionCenter");
	def_struct_primitive( toolMode_transformCenter,	toolMode,		"transformCenter");

	/* utils */

	def_visible_primitive( show_class,			"showClass");
	def_visible_generic  ( show_props,			"showProperties");
	def_visible_generic  ( get_props,			"getPropNames");
	def_visible_generic  ( create_instance,		"createInstance");
	def_visible_primitive( getproperty,			"getProperty");
	def_visible_primitive( setproperty,			"setProperty");
	def_visible_primitive( apropos,				"apropos");
	def_visible_generic  ( exprForMAXObject,	"exprForMAXObject");
	def_visible_generic  ( getSubAnim,			"getSubAnim");
	def_visible_generic  ( getSubAnimName,		"getSubAnimName");
	def_visible_generic  ( getSubAnimNames,		"getSubAnimNames");
	def_visible_primitive( show_source,			"showSource");
	def_visible_generic  ( getAppData,			"getAppData");
	def_visible_generic  ( setAppData,			"setAppData");
	def_visible_generic  ( deleteAppData,		"deleteAppData");
	def_visible_generic  ( clearAllAppData,		"clearAllAppData");
	def_visible_generic  ( addPluginRollouts,	"addPluginRollouts");
	def_visible_primitive( startObjectCreation,	"startObjectCreation");
//	def_visible_primitive( waitForToolStop,		"waitForToolStop");

	def_visible_primitive( progressStart,		"progressStart");
	def_visible_primitive( progressUpdate,		"progressUpdate");
	def_visible_primitive( progressEnd,			"progressEnd");
	def_visible_primitive( getProgressCancel,	"getProgressCancel");
	def_visible_primitive( setProgressCancel,	"setProgressCancel");

	def_visible_primitive( dos_command,		"DOSCommand");
	def_visible_primitive( sleep,			"sleep");
	def_visible_primitive( timeStamp,		"timeStamp");

	def_visible_primitive( open_utility,			"openUtility");
	def_visible_primitive( close_utility,			"closeUtility");
	def_visible_primitive( add_rollout,				"addRollout");
	def_visible_primitive( remove_rollout,			"removeRollout");
	def_visible_primitive( new_rollout_floater,		"newRolloutFloater");
	def_visible_primitive( close_rollout_floater,	"closeRolloutFloater");

	def_visible_primitive( message_box,				"messageBox");
	def_visible_primitive( query_box,				"queryBox");
	def_visible_primitive( yes_no_cancel_box,		"yesNoCancelBox");

	def_visible_primitive( set_open_scene_script,	"setOpenSceneScript");
	def_visible_primitive( set_save_scene_script,	"setSaveSceneScript");

	def_struct_primitive ( callbacks_addScript,			callbacks,	"addScript");
	def_struct_primitive ( callbacks_removeScript,		callbacks,	"removeScripts");
	def_struct_primitive ( callbacks_broadcastCallback,	callbacks,	"broadcastCallback");
	def_struct_primitive ( callbacks_show,				callbacks,	"show");
	def_struct_primitive ( pesistents_remove,			persistents, "remove");
	def_struct_primitive ( pesistents_removeAll,		persistents, "removeAll");
	def_struct_primitive ( pesistents_show,				persistents, "show");

	def_visible_primitive( gc,				 "gc");
	def_visible_primitive( freeSceneBitmaps, "freeSceneBitmaps");
	def_visible_primitive( enumerateFiles,	 "enumerateFiles");
	def_visible_primitive( setSaveRequired,	 "setSaveRequired");
	def_visible_primitive( getSaveRequired,	 "getSaveRequired");
	def_visible_primitive( clearUndoBuffer,	 "clearUndoBuffer");

	def_visible_primitive( getCurrentSelection,	"getCurrentSelection");
	def_visible_primitive( selectByName,		"selectByName");
	def_primitive        ( getDollarSel,		"getDollarSel");

	def_visible_primitive( animateVertex,		"animateVertex");

	def_visible_primitive( showTextureMap,		"showTextureMap");

	def_visible_primitive( setWaitCursor,		"setWaitCursor");
	def_visible_primitive( setArrowCursor,		"setArrowCursor");

	def_visible_primitive( registerTimeCallback, "registerTimeCallback");
	def_visible_primitive( unregisterTimeCallback, "unregisterTimeCallback");

#ifdef DESIGN_VER
	def_struct_primitive ( mtlBrowser_browseFrom,	mtlBrowser, "browseFrom");
#endif

	/* active viewport utils */

	def_visible_primitive( getActiveCamera,			"getActiveCamera");
	def_visible_primitive( getScreenScaleFactor,	"getScreenScaleFactor");
	def_visible_primitive( mapScreenToWorldRay,		"mapScreenToWorldRay");
	def_visible_primitive( mapScreenToView,			"mapScreenToView");
	def_visible_primitive( mapScreenToCP,			"mapScreenToCP");
	def_visible_primitive( getCPTM,					"getCPTM");
	def_visible_primitive( getViewTM,				"getViewTM");
	def_visible_primitive( getViewSize,				"getViewSize");
	def_visible_primitive( getViewFOV,				"getViewFOV");

	def_visible_primitive( encryptScript,			"encryptScript");
	def_visible_primitive( encryptFile,				"encryptFile");

	def_visible_primitive( deleteChangeHandler,		"deleteChangeHandler");
	def_visible_primitive( deleteAllChangeHandlers,	"deleteAllChangeHandlers");

	/* morph objects & keys */

	def_visible_primitive( getMKTime,			"getMKTime");
	def_visible_primitive( setMKTime,			"setMKTime");
	def_visible_primitive( getMKWeight,			"getMKWeight");
	def_visible_primitive( setMKWeight,			"setMKWeight");
	def_visible_primitive( getMKKey,			"getMKKey");
	def_visible_primitive( getMKKeyIndex,		"getMKKeyIndex");
	def_visible_primitive( getMKTargetNames,	"getMKTargetNames");
	def_visible_primitive( getMKTargetWeights,	"getMKTargetWeights");
	def_visible_primitive( createMorphObject,	"createMorphObject");
	def_visible_primitive( addMorphTarget,		"addMorphTarget");
	def_visible_primitive( setMorphTarget,		"setMorphTarget");
	def_visible_primitive( deleteMorphTarget,	"deleteMorphTarget");
	def_visible_primitive( setMorphTargetName,	"setMorphTargetName");

	/* OLE automation */

	def_visible_primitive( register_OLE_interface,	"registerOLEInterface");
	def_visible_primitive( create_OLE_object,		"createOLEObject");
	def_visible_primitive( release_OLE_object,		"releaseOLEObject");
	def_visible_primitive( release_all_OLE_objects,	"releaseAllOLEObjects");

#ifdef DDE_ENABLED			// enable this for R4!!
	/* DDE access */

	def_struct_primitive( dde_connect,		dde,	"connect");
	def_struct_primitive( dde_disconnect,	dde,	"disconnect");
	def_struct_primitive( dde_request,		dde,	"request");
	def_struct_primitive( dde_execute,		dde,	"execute");
	def_struct_primitive( dde_poke,			dde,	"poke");
	def_struct_primitive( dde_adviseStart,	dde,	"adviseStart");
	def_struct_primitive( dde_adviseStop,	dde,	"adviseStop");
	def_struct_primitive( dde_createServer,	dde,	"createServer");
	def_struct_primitive( dde_deleteServer,	dde,	"deleteServer");
	def_struct_primitive( dde_createTopic,	dde,	"createTopic");
#endif

	/* evaluator primitives - emitted by parser */
	
	def_primitive( progn,					"progn");
	def_primitive( max_command,				"max");
	def_primitive( return,					"return");
	def_primitive( exit,					"exit");
	def_primitive( continue,				"continue");

	def_lazy_primitive( quote,				"quote");
	def_lazy_primitive( if,					"if");
	def_lazy_primitive( case,				"case");
	def_lazy_primitive( while,				"while");
	def_lazy_primitive( do,					"do");
	def_lazy_primitive( for,				"for");
	def_lazy_primitive( and,				"and");
	def_lazy_primitive( or,					"or");

	def_lazy_primitive( animate_context,	"animate_context");
	def_lazy_primitive( redraw_context,		"redraw_context");
	def_lazy_primitive( pivot_context,		"pivot_context");
	def_lazy_primitive( level_context,		"level_context");
	def_lazy_primitive( time_context,		"time_context");
	def_lazy_primitive( coordsys_context,	"coordsys_context");
	def_lazy_primitive( center_context,		"center_context");
	def_lazy_primitive( undo_context,		"undo_context");

	def_lazy_primitive( assign,				"=");
	def_lazy_primitive( op_assign,			"+=");

	def_mapped_generic( assign,				"=");
	def_mapped_generic( op_assign,			"+=");
	def_generic       ( not,				"not");

	def_lazy_primitive( try,				"try");
	def_primitive	  ( throw,				"throw");

	def_lazy_primitive( change_handler,		"change_handler");

	def_visible_lazy_primitive( swap,		"swap");
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\Pipe.h ===
/*	
 *		Pipe.h - NT TCHAR Pipe wrapper for MAXScript
 *
 *			Copyright  John Wainwright 1996
 *
 */

#ifndef _H_PIPE
#define _H_PIPE

#include "Strings.h"
class FileStream;

#define PIPE_BUF_SIZE	512

// The undelivered data in the pipe is held in a linked list of
// buffers, pointed into by read and write cursors.  
// A side list is kept if writers supply info about sourcing files.
// This is provided to readers like the compiler to add source
// tags to generated code.  

typedef struct src_info src_info;
struct src_info						
{
	src_info*	next;			// next marker
	TCHAR*		start;			// source start character in buffer chain
	Value*		file;			// sourcing file name if any
	int			offset;			// starting offset into source
};

class Pipe : public CharStream
{
public:
	TCHAR*		write_buffer;		// pipe buffers & cursors
	TCHAR*		write_cursor;
	TCHAR*		read_buffer;
	TCHAR*		read_cursor;
	int			ungetch_count;

	CRITICAL_SECTION pipe_update;	// for syncing pipe updates
	HANDLE		pipe_event;			// for signalling data ready
	HANDLE		restart_event;		// used to restart a stopped pipe
	BOOL		waiting;			// reader is waiting for data
	BOOL		stopped;			// pipe reading is blocked

	FileStream* log;				// log stream if non-NULL

	Value*		read_source_file;	// sourcing file for reading if supplied by writer
	int			read_source_offset;	// running reader offset in source
	src_info*	markers;			// marker list...
	src_info*	marker_tail;		
	TCHAR*		next_source_start;	// upcoming marker starting character
	Value*		write_source_file;	// current write source file, used to determine source change
	int			write_source_offset;// running writer offset

				Pipe();
				~Pipe();
				
#	define		is_pipe(o) ((o)->tag == INTERNAL_PIPE_TAG)
	void		collect() { delete this; }
 	void		gc_trace();

	TCHAR		get_char();
	void		unget_char(TCHAR c);
	TCHAR		peek_char();
	int			at_eos();
	int			pos() { return read_source_offset; }
	void		rewind();
	void		flush_to_eol();
	void		flush_to_eobuf();

	void		put_char(TCHAR c, Value* source_file = NULL, int offset = 0);
	void		put_str(TCHAR* str, Value* source_file = NULL, int offset = 0);
	void		put_buf(TCHAR* str, size_t count, Value* source_file = NULL, int offset = 0);
	void		new_write_buffer();
	void		check_write_source_change(Value* file, int offset, int new_len);
	void		read_source_change();
	void		clear_source();
	void		stop();
	void		go();

	TCHAR*		puts(TCHAR* str);
	int			printf(const TCHAR *format, ...);

	void		log_to(FileStream* log);
	void		close_log();
	CharStream* get_log() { return log; }

	Value*		get_file_name();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\SceneIO.h ===
/*	
 *		SceneIO.h - MAXScript-related scene file I/O (persistent globals, on-open script, etc.)
 *
 *			Copyright  Autodesk, Inc, 1998.  John Wainwright.
 *
 */

#ifndef _H_SCENEIO
#define _H_SCENEIO

class ValueLoader;

/* --------- Scene I/O chunk ID's ---------- */

#define OPENSCRIPT_CHUNK			0x0010    // obsoleted by CALLBACKSCRIPT_CHUNK
#define SAVESCRIPT_CHUNK			0x0020    // obsoleted by CALLBACKSCRIPT_CHUNK
#define PSGLOBALS_CHUNK				0x0030
#define MSPLUGINCLASS_CHUNK			0x0040
#define MSPLUGINCLASSHDR_CHUNK		0x0050
#define LENGTH_CHUNK				0x0060
#define CALLBACKSCRIPT_CHUNK		0x0070

/* ---- persistent global value loading ----- */

typedef Value* (*load_fn)(ILoad* iload, USHORT chunkID, ValueLoader* vl);

enum LoadableClassID 
{
	Undefined_Chunk = 0,	Boolean_Chunk,			Ok_Chunk,
	Integer_Chunk,			Float_Chunk,			String_Chunk, 
	Name_Chunk,				Array_Chunk,			Point3Value_Chunk, 
	QuatValue_Chunk,		RayValue_Chunk,			AngAxisValue_Chunk,
	EulerAnglesValue_Chunk, Matrix3Value_Chunk,		Point2Value_Chunk,
	ColorValue_Chunk,		MSTime_Chunk,			MSInterval_Chunk,
	MAXWrapper_Chunk,		Unsupplied_Chunk,

	// add more here...

	HIGH_CLASS_CHUNK  // must be last
};

extern ScripterExport Value* load_value(ILoad* iload, ValueLoader* vload);
extern void save_persistent_callback_scripts(ISave* isave);
extern IOResult load_persistent_callback_script(ILoad* iload);

// post global load callback scheme, allows different loaders to 
// permit ::Load() fns to register a callback to clean-up a load.  
// Eg, Array loader gets such a callback from MAXWrapper::Load() which
// uses this to build the MAXWrapper at post-load time, after object pointers
// have been back-patched.

// ::Load()'s that need to specialize this to provide a callback
class ValueLoadCallback
{
public:
	virtual Value* post_load() { return &undefined; }  // return the cleaned-up value
};

// each loader specializes this and gives it to the ::Load()
class ValueLoader
{
public:
	virtual void register_callback(ValueLoadCallback* cb) { }
	virtual void call_back() { }
};

// callback script  (see MAXCallbacks.cpp)
class CallbackScript 
{ 
public:
	TSTR	script;		// callback script or script filename
	Value*  code;		// cached compiled code
	Value*  id;			// script ID
	short	flags;		// flags

	CallbackScript(TCHAR* iscript, Value* iid, short iflags)
	{
		script = iscript; code = NULL; id = iid; flags = iflags;
	}
};

#define MCB_SCRIPT_IS_FILE		0x0001
#define MCB_PERSISTENT			0x0002
#define MCB_HAS_ID				0x0004
#define MCB_INVALID				0x0008

extern Tab<CallbackScript*>* callback_scripts[];

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\Rollouts.h ===
/*	
 *		Rollouts.h - Rollout panel classes & functions for MAXScript
 *
 *			Copyright  John Wainwright 1996
 *
 */

#ifndef _H_ROLLOUTS
#define _H_ROLLOUTS

#include "Arrays.h"

typedef struct		// rollout control layout data
{
	int	left;
	int top;
	int	width;
	int height;
} layout_data;

/* some layout constants (in pixels) ... */

#define TOP_MARGIN				2
#define SIDE_MARGIN				4
#define RADIO_DOT_WIDTH			23
#define CHECK_BOX_WIDTH			24
#define LEFT_ALIGN				13
#define RIGHT_ALIGN				13
#define GROUP_BOX_Y_MARGIN		6
#define GROUP_BOX_X_MARGIN		4
#define SPACING_BEFORE			5

/* ---------------------- Rollout class ----------------------- */

/* contains the defintion of  rollout panel.  This includes:
 *     - an 'instance variable' array, these variables can be accessed as locals in rollout handlers
 *     - a control array, containing rolout control instances
 *     - a hashtable of event handler functions
 *   there are associated Thunks for the locals & controls so you can ref them as variables in
 *   handlers
 */

class RolloutControl;
class RolloutFloater;
class MSPlugin;
class RolloutChangeCallback;
class PB2Param;

visible_class (Rollout)

class Rollout : public Value
{
public:
	Value*		name;						// rollout's variable name
	Value*		title;						// title factor			
	HashTable*  local_scope;				// local name space			
	Value**		locals;						// local var array			
	Value**		local_inits;				//   "    "    "  init vals	
	int			local_count;				//   "    "  count			
	RolloutControl** controls;				// control array			
	int			control_count;				//    "    "  count			
	HashTable*	handlers;					// handler tables			
	short		flags;						// rollout flags			
	short		order;						// rollout open order no.	
	Interface*	ip;							// Interface pointer		
	HWND		page;						// my dialog HWND when visible 
	HDC			rollout_dc;					// my dialog dev. context	
	HFONT		font;						// dialog's default font	
	int			text_height;				// metrics....				
	int			default_control_leading;
	int			rollout_width;
	int			rollout_height;
	int			current_width;				// used for across: processing...
	int			current_left;
	int			max_y, last_y;
	int			across_count;
	WORD		close_button_ID;			// id of gen'd close button 
	BOOL		selected;					// selected to be open  
	BOOL		disabled;					// error in handler -> ro disabled 		
	CharStream* source;						// source text if available 
	BOOL		init_values;				// whether to init ctrl/local values on (re)open
	MSPlugin*	plugin;						// plugin I'm open on if non-NULL
	RolloutChangeCallback* tcb;				// timechange callback if rollout has controller-linked spinners
	IMtlParams* imp;						// MtlEditor interface if open in Mtl Editor and other stuff...
	TexDADMgr*	texDadMgr;
	MtlDADMgr*	mtlDadMgr;
	HWND		hwMtlEdit;
	RolloutFloater* rof;					// owning rolloutfloater window if present there
	WORD        next_id;					// dialog item ID allocators
	Tab<RolloutControl*> id_map;			// dialog item ID map for taking item ID's to associated RolloutControl

				Rollout(short iflags);
	void		init(Value* name, Value* title, int local_count, Value** inits, HashTable* local_scope, RolloutControl** controls, int control_count, HashTable* handlers, CharStream* source);
			   ~Rollout();

				classof_methods (Rollout, Value);
	void		collect() { delete this; }
	void		gc_trace();
	ScripterExport void		sprin1(CharStream* s);

	ScripterExport BOOL add_page(Interface *ip, HINSTANCE hInstance, int ro_flags = 0, RolloutFloater* rof = NULL);
	ScripterExport void delete_page(Interface *ip, RolloutFloater* rof = NULL);
	void		open(Interface *ip, BOOL rolled_up = FALSE);
	ScripterExport void close(Interface *ip, RolloutFloater* rof = NULL);
	BOOL		ok_to_close(RolloutFloater* rof = NULL);
	void		run_event_handler(Value* event, Value** arg_list, int count);
	Value*		call_event_handler(Value* event, Value** arg_list, int count);
	void		add_close_button(HINSTANCE hInstance, int& current_y);
	void		edit_script();
	void		TimeChanged(TimeValue t);

	// various open/close for scripted plug-in rollouts
	// command panel
	void		BeginEditParams(IObjParam* ip, MSPlugin* plugin, ULONG flags, Animatable *prev);
	void		EndEditParams(IObjParam* ip, MSPlugin* plugin, ULONG flags, Animatable *next);
	// mtl editor
	void		CreateParamDlg(HWND hwMtlEdit, IMtlParams* imp, MSPlugin* plugin, TexDADMgr* texDadMgr, MtlDADMgr* mtlDadMgr);
	void		SetThing(MSPlugin* plugin);
	void		ReloadDialog();
	void		SetTime(TimeValue t);
	void		DeleteThis();
	// update/reload
	void		InvalidateUI();
	void		InvalidateUI(ParamID id, int tabIndex=-1); // nominated param

	virtual	Value*	get_property(Value** arg_list, int count);
	virtual	Value*	set_property(Value** arg_list, int count);
};

#define RO_NO_CLOSEBUTTON	0x0001
#define RO_HIDDEN			0x0002
#define RO_ROLLED_UP		0x0004
#define RO_IN_FLOATER		0x0008
#define RO_INSTALLED		0x0010
#define RO_UTIL_MASTER		0x0020
#define RO_SILENT_ERRORS	0x0040

/* --------------------- RolloutFloater class ------------------------ */

visible_class (RolloutFloater)

class RolloutFloater : public Value
{
public:
	HWND			window;		// modeless dialog window
	HWND			ru_window;	// host rollup winddow cust control
	IRollupWindow*	irw;
	Tab<Rollout*>	rollouts;   // my rollouts
	int				width, height; // window size...
	int				left, top; 

			    RolloutFloater(TCHAR* title, int left, int top, int width, int height);
			   ~RolloutFloater();

				classof_methods (RolloutFloater, Value);
	void		collect() { delete this; }

	void		add_rollout(Rollout* ro, BOOL rolledUp);
	void		remove_rollout(Rollout* ro);

	Value*		get_property(Value** arg_list, int count);
	Value*		set_property(Value** arg_list, int count);
};

/* -------------------- RolloutControl classes ----------------------- */

/* represent controls such as buttons & spinners on rollout panels, RolloutControl is abstract
 * root of all controls */

visible_class (RolloutControl)

class RolloutControl : public Value, public ReferenceMaker
{
public:
	Value*		name;
	Value*		caption;
	Value*		init_caption;
	BOOL		enabled;
	Value**		keyparms;
	int			keyparm_count;
	Rollout*	parent_rollout;
	WORD	    control_ID;
	Control*	controller;		// optional linked animation controller
	ParamDimension*  dim;		// controllers dimension
	PB2Param*	pid;			// if non-NULL, indicates this control is associated with an MSPlugin parameter &
								//   points at ParamUIRep-like data for it
	short		flags;

	ScripterExport  RolloutControl();
	ScripterExport  RolloutControl(Value* name, Value* caption, Value** keyparms, int keyparm_count);
	ScripterExport ~RolloutControl();

				classof_methods (RolloutControl, Value);
	BOOL		_is_rolloutcontrol() { return 1; }
#	define		is_rolloutcontrol(o) ((o)->_is_rolloutcontrol())
	void		collect() { delete this; }
	ScripterExport void gc_trace();

	virtual ScripterExport void	add_control(Rollout *ro, HWND parent, HINSTANCE hInstance, int& current_y);
	virtual LPCTSTR	get_control_class() = 0;
	virtual DWORD	get_control_style() { return WS_TABSTOP; }
	virtual DWORD	get_control_ex_style() { return 0; }
	virtual void	init_control(HWND control) { }
	virtual void	compute_layout(Rollout *ro, layout_data* pos) = 0;
	virtual ScripterExport void	process_layout_params(Rollout *ro, layout_data* pos, int& current_y);
	virtual ScripterExport void	setup_layout(Rollout *ro, layout_data* pos, int& current_y);
	virtual ScripterExport void	process_common_params();
	virtual ScripterExport void	call_event_handler(Rollout *ro, Value* event, Value** arg_list, int count);
	virtual ScripterExport void	run_event_handler(Rollout *ro, Value* event, Value** arg_list, int count);
	virtual BOOL	handle_message(Rollout *ro, UINT message, WPARAM wParam, LPARAM lParam) { return FALSE; }
			ScripterExport WORD	next_id();

	virtual	ScripterExport Value* get_property(Value** arg_list, int count);
	virtual	ScripterExport Value* set_property(Value** arg_list, int count);
	virtual	ScripterExport void	set_text(TCHAR* text, HWND ctl = NULL, Value* align = NULL);
	virtual	ScripterExport void	set_enable();
	virtual ScripterExport int num_controls() { return 1; }
	        ScripterExport Value* get_event_handler(Value* event);

	// ReferenceMaker
	int			NumRefs() { return (controller != NULL) ? 1 : 0; }
	RefTargetHandle GetReference(int i) { return controller; }
	void		SetReference(int i, RefTargetHandle rtarg) { controller = (Control*)rtarg; }
	ScripterExport RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, PartID& partID,  RefMessage message);
	virtual void controller_changed() { }
	virtual BOOL controller_ok(Control* c) { return FALSE; }

	// PB2 UI update
	IParamBlock2* get_pblock();
	virtual void Reload() { }
	virtual void InvalidateUI() { }
	virtual void set_pb2_value() { }
	virtual void get_pb2_value(BOOL load_UI=TRUE) { }
	virtual void SetTexDADMgr(DADMgr* dad) { }
	virtual int FindSubTexFromHWND(HWND hw) { return -1; }
	virtual void SetMtlDADMgr(DADMgr* dad) { }
	virtual int FindSubMtlFromHWND(HWND hw) { return -1; } 

};

#define ROC_FIXED_WIDTH		0x0001			// a specific width: supplied, don't resize buttons on .text =

extern LPCTSTR cust_button_class;

/* ------------- PB2Param class -------------------- */

// present in a UI control if rollout is part of a scripted plugin
// and this control is associated with a ParamBlock2  param

class PB2Param
{
public:
	ParamID id;			// pblock param ID
	int index;			// pblock direct index of param
	int tabIndex;		// element index if param is Tab<>
	int	block_id;		// owning block's ID
	int	subobjno;		// texmap or mtl param subobjno in the block
	ParamDimension* dim;// parameter's dimension
	ParamType2 type;	// parameter's type

	PB2Param(ParamDef& pd, int index, int block_id, int subobjno, int tabIndex = -1);
}; 

/* -------------------- LabelControl  ------------------- */

visible_class (LabelControl)

class LabelControl : public RolloutControl
{
public:
				LabelControl(Value* name, Value* caption, Value** keyparms, int keyparm_count)
					: RolloutControl(name, caption, keyparms, keyparm_count) { tag = class_tag(LabelControl); }

    static RolloutControl* create(Value* name, Value* caption, Value** keyparms, int keyparm_count)
							{ return new LabelControl (name, caption, keyparms, keyparm_count); }

				classof_methods (LabelControl, RolloutControl);
	void		collect() { delete this; }
	ScripterExport void		sprin1(CharStream* s) { s->printf(_T("LabelControl:%s"), name->to_string()); }

	LPCTSTR		get_control_class() { return _T("STATIC"); }
	DWORD		get_control_style() { return 0; }
	void		compute_layout(Rollout *ro, layout_data* pos);
};

/* -------------------- ButtonControl  ------------------- */

visible_class (ButtonControl)

class ButtonControl : public RolloutControl
{
public:
	HIMAGELIST	images;
	int			image_width, image_height;
	int			iOutEn, iInEn, iOutDis, iInDis;

				ButtonControl(Value* name, Value* caption, Value** keyparms, int keyparm_count)
					: RolloutControl(name, caption, keyparms, keyparm_count)
						{
							tag = class_tag(ButtonControl);
							images = NULL;
						}
			   ~ButtonControl();

    static RolloutControl* create(Value* name, Value* caption, Value** keyparms, int keyparm_count)
							{ return new ButtonControl (name, caption, keyparms, keyparm_count); }

				classof_methods (ButtonControl, RolloutControl);
	void		collect() { delete this; }
	void		sprin1(CharStream* s) { s->printf(_T("ButtonControl:%s"), name->to_string()); }

	LPCTSTR		get_control_class() { return cust_button_class; }
	void		init_control(HWND control);
	void		compute_layout(Rollout *ro, layout_data* pos);
	BOOL		handle_message(Rollout *ro, UINT message, WPARAM wParam, LPARAM lParam);
	Value*		get_property(Value** arg_list, int count);
	Value*		set_property(Value** arg_list, int count);
	void		set_enable();
};	

/* -------------------- CheckButtonControl  ------------------- */

visible_class (CheckButtonControl)

class CheckButtonControl : public RolloutControl
{
public:
	BOOL		checked;
	HIMAGELIST	images;
	int			image_width, image_height;
	int			iOutEn, iInEn, iOutDis, iInDis;

				CheckButtonControl(Value* name, Value* caption, Value** keyparms, int keyparm_count)
					: RolloutControl(name, caption, keyparms, keyparm_count)
						{
							tag = class_tag(CheckButtonControl);
							images = NULL;
						}
			   ~CheckButtonControl();

    static RolloutControl* create(Value* name, Value* caption, Value** keyparms, int keyparm_count)
							{ return new CheckButtonControl (name, caption, keyparms, keyparm_count); }

				classof_methods (CheckButtonControl, RolloutControl);
	void		collect() { delete this; }
	void		sprin1(CharStream* s) { s->printf(_T("CheckButtonControl:%s"), name->to_string()); }

	LPCTSTR		get_control_class() { return cust_button_class; }
	void		init_control(HWND control);
	void		compute_layout(Rollout *ro, layout_data* pos);
	BOOL		handle_message(Rollout *ro, UINT message, WPARAM wParam, LPARAM lParam);
	Value*		get_property(Value** arg_list, int count);
	Value*		set_property(Value** arg_list, int count);
	void		set_enable();

	void		Reload();
	void		InvalidateUI();
	void		set_pb2_value();
	void		get_pb2_value(BOOL load_UI=TRUE);
};	

/* -------------------- EditTextControl  ------------------- */

visible_class (EditTextControl)

class EditTextControl : public RolloutControl
{
public:
	Value*		text;
	Value*		bold;

				EditTextControl(Value* name, Value* caption, Value** keyparms, int keyparm_count);

    static RolloutControl* create(Value* name, Value* caption, Value** keyparms, int keyparm_count)
							{ return new EditTextControl (name, caption, keyparms, keyparm_count); }

				classof_methods (EditTextControl, RolloutControl);
	void		collect() { delete this; }
	void		sprin1(CharStream* s) { s->printf(_T("EditTextControl:%s"), name->to_string()); }
	void		gc_trace();

	void		add_control(Rollout *ro, HWND parent, HINSTANCE hInstance, int& current_y);
	LPCTSTR		get_control_class() { return CUSTEDITWINDOWCLASS; }
	void		compute_layout(Rollout *ro, layout_data* pos) { }
	BOOL		handle_message(Rollout *ro, UINT message, WPARAM wParam, LPARAM lParam);
	Value*		get_property(Value** arg_list, int count);
	Value*		set_property(Value** arg_list, int count);
	void		set_enable();
	int			num_controls() { return 2; }

	void		Reload();
	void		InvalidateUI();
	void		set_pb2_value();
	void		get_pb2_value(BOOL load_UI=TRUE);
};

/* -------------------- ComboBoxControl  ------------------- */

visible_class (ComboBoxControl)

class ComboBoxControl : public RolloutControl
{
public:
	Array*		item_array;
	int			selection;
	short		type;
	short		flags;

				ComboBoxControl(Value* name, Value* caption, Value** keyparms, int keyparm_count, int type = CBS_SIMPLE);

    static RolloutControl* create_cb(Value* name, Value* caption, Value** keyparms, int keyparm_count)
							{ return new ComboBoxControl (name, caption, keyparms, keyparm_count); }
    static RolloutControl* create_dd(Value* name, Value* caption, Value** keyparms, int keyparm_count)
							{ return new ComboBoxControl (name, caption, keyparms, keyparm_count, CBS_DROPDOWNLIST); }

				classof_methods (ComboBoxControl, RolloutControl);
	void		collect() { delete this; }
	void		sprin1(CharStream* s) { s->printf(_T("ComboBoxControl:%s"), name->to_string()); }
	void		gc_trace();

	void		add_control(Rollout *ro, HWND parent, HINSTANCE hInstance, int& current_y);
	LPCTSTR		get_control_class() { return _T("COMBOBOX"); }
	DWORD		get_control_style() { return CBS_DROPDOWNLIST | CBS_NOINTEGRALHEIGHT | WS_TABSTOP; }
	void		compute_layout(Rollout *ro, layout_data* pos) { }
	BOOL		handle_message(Rollout *ro, UINT message, WPARAM wParam, LPARAM lParam);
	Value*		get_property(Value** arg_list, int count);
	Value*		set_property(Value** arg_list, int count);
	void		set_enable();
	int			num_controls() { return 2; }
};

#define CBF_EDIT_FIELD_CHANGING		0x0001

/* -------------------- ListBoxControl  ------------------- */

visible_class (ListBoxControl)

class ListBoxControl : public RolloutControl
{
public:
	Array*		item_array;
	int			selection;

				ListBoxControl(Value* name, Value* caption, Value** keyparms, int keyparm_count);

    static RolloutControl* create(Value* name, Value* caption, Value** keyparms, int keyparm_count)
							{ return new ListBoxControl (name, caption, keyparms, keyparm_count); }

				classof_methods (ListBoxControl, RolloutControl);
	void		collect() { delete this; }
	void		sprin1(CharStream* s) { s->printf(_T("ListBoxControl:%s"), name->to_string()); }
	void		gc_trace();

	void		add_control(Rollout *ro, HWND parent, HINSTANCE hInstance, int& current_y);
	LPCTSTR		get_control_class() { return _T("LISTBOX"); }
	DWORD		get_control_style() { return WS_TABSTOP; }
	void		compute_layout(Rollout *ro, layout_data* pos) { }
	BOOL		handle_message(Rollout *ro, UINT message, WPARAM wParam, LPARAM lParam);
	Value*		get_property(Value** arg_list, int count);
	Value*		set_property(Value** arg_list, int count);
	void		set_enable();
	int			num_controls() { return 2; }
};

/* -------------------- SpinnerControl  ------------------- */

visible_class (SpinnerControl)

class SpinnerControl : public RolloutControl
{
public:
	float		value;
	float		max, min;
	float		scale;
	EditSpinnerType spin_type;

				SpinnerControl(Value* name, Value* caption, Value** keyparms, int keyparm_count)
					: RolloutControl(name, caption, keyparms, keyparm_count)  { tag = class_tag(SpinnerControl); }

    static RolloutControl* create(Value* name, Value* caption, Value** keyparms, int keyparm_count)
							{ return new SpinnerControl (name, caption, keyparms, keyparm_count); }

				classof_methods (SpinnerControl, RolloutControl);
	void		collect() { delete this; }
	void		sprin1(CharStream* s) { s->printf(_T("SpinnerControl:%s"), name->to_string()); }

	void		add_control(Rollout *ro, HWND parent, HINSTANCE hInstance, int& current_y);
	LPCTSTR		get_control_class() { return SPINNERWINDOWCLASS; }
	void		compute_layout(Rollout *ro, layout_data* pos) { }
	BOOL		handle_message(Rollout *ro, UINT message, WPARAM wParam, LPARAM lParam);

	Value*		get_property(Value** arg_list, int count);
	Value*		set_property(Value** arg_list, int count);
	void		set_enable();
	int			num_controls() { return 3; }

	void		controller_changed();
	BOOL		controller_ok(Control* c) { return c->SuperClassID() == CTRL_FLOAT_CLASS_ID; }

	void		Reload();
	void		InvalidateUI();
	void		set_pb2_value();
	void		get_pb2_value(BOOL load_UI=TRUE);
};

/* -------------------- SliderControl  ------------------- */

visible_class (SliderControl)

class SliderControl : public RolloutControl
{
public:
	float		value;
	float		max, min;
	int			ticks;
	int			slider_type;
	BOOL		vertical;

				SliderControl(Value* name, Value* caption, Value** keyparms, int keyparm_count)
					: RolloutControl(name, caption, keyparms, keyparm_count)  { tag = class_tag(SliderControl); }

    static RolloutControl* create(Value* name, Value* caption, Value** keyparms, int keyparm_count)
							{ return new SliderControl (name, caption, keyparms, keyparm_count); }

				classof_methods (SliderControl, RolloutControl);
	void		collect() { delete this; }
	void		sprin1(CharStream* s) { s->printf(_T("SliderControl:%s"), name->to_string()); }

	void		add_control(Rollout *ro, HWND parent, HINSTANCE hInstance, int& current_y);
	LPCTSTR		get_control_class() { return TRACKBAR_CLASS; }
	void		compute_layout(Rollout *ro, layout_data* pos) { }
	BOOL		handle_message(Rollout *ro, UINT message, WPARAM wParam, LPARAM lParam);

	Value*		get_property(Value** arg_list, int count);
	Value*		set_property(Value** arg_list, int count);
	void		set_enable();
	int			num_controls() { return 2; }

	void		Reload();
	void		InvalidateUI();
	void		set_pb2_value();
	void		get_pb2_value(BOOL load_UI=TRUE);
};

/* -------------------- PickerControl  ------------------- */

class PickerControl;

class PickerControlFilter : public PickNodeCallback
{
public:
		Value*	filter_fn;

				PickerControlFilter(Value* ifilter) { filter_fn = ifilter; }
		BOOL	Filter(INode *node);
};

class PickerControlMode : public PickModeCallback
{
public:
		PickerControlFilter* pick_filter;
		TCHAR*			msg;
		PickerControl*  picker;

		PickerControlMode(PickerControlFilter* ifilter, TCHAR* imsg, PickerControl* ipick);

		BOOL	HitTest(IObjParam *ip, HWND hWnd, ViewExp *vpt, IPoint2 m, int flags);
		BOOL	Pick(IObjParam *ip, ViewExp *vpt);
		PickNodeCallback *GetFilter() { return pick_filter; }
		BOOL	RightClick(IObjParam *ip, ViewExp *vpt) { return TRUE; }
		void	EnterMode(IObjParam *ip);
		void	ExitMode(IObjParam *ip);
};

visible_class (PickerControl)

class PickerControl : public RolloutControl
{
public:
	PickerControlFilter* pick_filter;
	PickerControlMode*   pick_mode;
    ICustButton*		 cust_button; 
	Value*				 picked_object;

				PickerControl(Value* name, Value* caption, Value** keyparms, int keyparm_count);
			   ~PickerControl();

    static RolloutControl* create(Value* name, Value* caption, Value** keyparms, int keyparm_count)
							{ return new PickerControl (name, caption, keyparms, keyparm_count); }

				classof_methods (PickerControl, RolloutControl);
	void		collect() { delete this; }
	void		gc_trace();
	void		sprin1(CharStream* s) { s->printf(_T("PickerControl:%s"), name->to_string()); }

	LPCTSTR		get_control_class() { return cust_button_class; }
	void		compute_layout(Rollout *ro, layout_data* pos);
	void		init_control(HWND control);
	BOOL		handle_message(Rollout *ro, UINT message, WPARAM wParam, LPARAM lParam);
	Value*		get_property(Value** arg_list, int count);
	Value*		set_property(Value** arg_list, int count);
	void		set_enable();

	void		Reload();
	void		InvalidateUI();
	void		set_pb2_value();
	void		get_pb2_value(BOOL load_UI=TRUE);
};

/* -------------------- ColorPickerControl  ------------------- */

visible_class (ColorPickerControl)

class ColorPickerControl : public RolloutControl
{
public:
	Value*		  color;
    IColorSwatch* csw;
	Value*		  title;

				ColorPickerControl(Value* name, Value* caption, Value** keyparms, int keyparm_count);
			   ~ColorPickerControl();

    static RolloutControl* create(Value* name, Value* caption, Value** keyparms, int keyparm_count)
							{ return new ColorPickerControl (name, caption, keyparms, keyparm_count); }

				classof_methods (ColorPickerControl, RolloutControl);
	void		collect() { delete this; }
	void		gc_trace();
	void		sprin1(CharStream* s) { s->printf(_T("ColorPickerControl:%s"), name->to_string()); }

	LPCTSTR		get_control_class() { return COLORSWATCHWINDOWCLASS; }
	void		init_control(HWND control);
	void		add_control(Rollout *ro, HWND parent, HINSTANCE hInstance, int& current_y);
	void		compute_layout(Rollout *ro, layout_data* pos) {}
	BOOL		handle_message(Rollout *ro, UINT message, WPARAM wParam, LPARAM lParam);
	Value*		get_property(Value** arg_list, int count);
	Value*		set_property(Value** arg_list, int count);
	void		set_enable();
	int			num_controls() { return 2; }

	void		Reload();
	void		InvalidateUI();
	void		set_pb2_value();
	void		get_pb2_value(BOOL load_UI=TRUE);
};

/* -------------------- RadioControl  ------------------- */

visible_class (RadioControl)

class RadioControl : public RolloutControl
{
public:
	int			state;
	int			btn_count;

				RadioControl(Value* name, Value* caption, Value** keyparms, int keyparm_count)
					: RolloutControl(name, caption, keyparms, keyparm_count)  { tag = class_tag(RadioControl); }

    static RolloutControl* create(Value* name, Value* caption, Value** keyparms, int keyparm_count)
							{ return new RadioControl (name, caption, keyparms, keyparm_count); }

				classof_methods (RadioControl, RolloutControl);
	void		collect() { delete this; }
	void		sprin1(CharStream* s) { s->printf(_T("RadioControl:%s"), name->to_string()); }

	void		add_control(Rollout *ro, HWND parent, HINSTANCE hInstance, int& current_y);
	LPCTSTR		get_control_class() { return _T("BUTTON"); }
	DWORD		get_control_style() {  return BS_AUTORADIOBUTTON; }
	void		compute_layout(Rollout *ro, layout_data* pos) { }
	BOOL		handle_message(Rollout *ro, UINT message, WPARAM wParam, LPARAM lParam);

	Value*		get_property(Value** arg_list, int count);
	Value*		set_property(Value** arg_list, int count);
	void		set_enable();
	int			num_controls() { return btn_count + 1; }

	void		Reload();
	void		InvalidateUI();
	void		set_pb2_value();
	void		get_pb2_value(BOOL load_UI=TRUE);
};

/* -------------------- CheckBoxControl  ------------------- */

visible_class (CheckBoxControl)

class CheckBoxControl : public RolloutControl
{
public:
	BOOL		checked;

				CheckBoxControl(Value* name, Value* caption, Value** keyparms, int keyparm_count)
					: RolloutControl(name, caption, keyparms, keyparm_count)  { tag = class_tag(CheckBoxControl); }

    static RolloutControl* create(Value* name, Value* caption, Value** keyparms, int keyparm_count)
							{ return new CheckBoxControl (name, caption, keyparms, keyparm_count); }

				classof_methods (CheckBoxControl, RolloutControl);
	void		collect() { delete this; }
	void		sprin1(CharStream* s) { s->printf(_T("CheckBoxControl:%s"), name->to_string()); }

	LPCTSTR		get_control_class() { return _T("BUTTON"); }
	DWORD		get_control_style() {  return BS_AUTOCHECKBOX | WS_TABSTOP; }
	void		init_control(HWND control);
	void		compute_layout(Rollout *ro, layout_data* pos);
	BOOL		handle_message(Rollout *ro, UINT message, WPARAM wParam, LPARAM lParam);

	Value*		get_property(Value** arg_list, int count);
	Value*		set_property(Value** arg_list, int count);

	void		Reload();
	void		InvalidateUI();
	void		set_pb2_value();
	void		get_pb2_value(BOOL load_UI=TRUE);
};

/* -------------------- BitmapControl  ------------------- */

visible_class (BitmapControl)

class BitmapControl : public RolloutControl
{
public:
	Value*		file_name;
	Value*		max_bitmap;    // if supplied
	HBITMAP		bitmap;

				BitmapControl(Value* name, Value* caption, Value** keyparms, int keyparm_count);
			   ~BitmapControl();

    static RolloutControl* create(Value* name, Value* caption, Value** keyparms, int keyparm_count)
							{ return new BitmapControl (name, caption, keyparms, keyparm_count); }

				classof_methods (BitmapControl, RolloutControl);
	void		collect() { delete this; }
	void		sprin1(CharStream* s) { s->printf(_T("BitmapControl:%s"), name->to_string()); }
	void		gc_trace();

	LPCTSTR		get_control_class() { return _T("STATIC"); }
	DWORD		get_control_style() { return SS_BITMAP + SS_CENTERIMAGE; }
	DWORD		get_control_ex_style() { return WS_EX_CLIENTEDGE; }
	void		compute_layout(Rollout *ro, layout_data* pos);
	void		process_layout_params(Rollout *ro, layout_data* pos, int& current_y);
	void		init_control(HWND control);
	Value*		get_property(Value** arg_list, int count);
	Value*		set_property(Value** arg_list, int count);
};

/* -------------------- MapButtonControl  ------------------- */

visible_class (MapButtonControl)

class MapButtonControl : public ButtonControl
{
public:
		Value*       map;
		ICustButton* btn;

				MapButtonControl(Value* name, Value* caption, Value** keyparms, int keyparm_count)
					: ButtonControl(name, caption, keyparms, keyparm_count)
						{
							tag = class_tag(MapButtonControl);
							btn = NULL;
							map = NULL;
						}
				~MapButtonControl() { if (btn != NULL) ReleaseICustButton(btn); }

    static RolloutControl* create(Value* name, Value* caption, Value** keyparms, int keyparm_count)
							{ return new MapButtonControl (name, caption, keyparms, keyparm_count); }

				classof_methods (MapButtonControl, RolloutControl);
	void		gc_trace();
	void		collect() { delete this; }
	void		sprin1(CharStream* s) { s->printf(_T("MapButtonControl:%s"), name->to_string()); }

	void		init_control(HWND control);
	BOOL		handle_message(Rollout *ro, UINT message, WPARAM wParam, LPARAM lParam);
	Value*		get_property(Value** arg_list, int count);
	Value*		set_property(Value** arg_list, int count);

	void		Reload();
	void		InvalidateUI();
	void		set_pb2_value();
	void		get_pb2_value(BOOL load_UI=TRUE);

	void		SetTexDADMgr(DADMgr* dad) { if (btn) btn->SetDADMgr(dad); }
	int			FindSubTexFromHWND(HWND hw);
};	

/* -------------------- MtlButtonControl  ------------------- */

visible_class (MtlButtonControl)

class MtlButtonControl : public ButtonControl
{
public:
		Value*		 mtl;
		ICustButton* btn;

				MtlButtonControl(Value* name, Value* caption, Value** keyparms, int keyparm_count)
					: ButtonControl(name, caption, keyparms, keyparm_count)
						{
							tag = class_tag(MtlButtonControl);
							btn = NULL;
							mtl = NULL;
						}
				~MtlButtonControl() { if (btn != NULL) ReleaseICustButton(btn); }

    static RolloutControl* create(Value* name, Value* caption, Value** keyparms, int keyparm_count)
							{ return new MtlButtonControl (name, caption, keyparms, keyparm_count); }

				classof_methods (MtlButtonControl, RolloutControl);
	void		gc_trace();
	void		collect() { delete this; }
	void		sprin1(CharStream* s) { s->printf(_T("MtlButtonControl:%s"), name->to_string()); }

	void		init_control(HWND control);
	BOOL		handle_message(Rollout *ro, UINT message, WPARAM wParam, LPARAM lParam);
	Value*		get_property(Value** arg_list, int count);
	Value*		set_property(Value** arg_list, int count);

	void		Reload();
	void		InvalidateUI();
	void		set_pb2_value();
	void		get_pb2_value(BOOL load_UI=TRUE);

	void		SetMtlDADMgr(DADMgr* dad) { if (btn) btn->SetDADMgr(dad); }
	int			FindSubMtlFromHWND(HWND hw);
};	

/* ----------------------- GroupControls  ---------------------- */

visible_class (GroupStartControl)

class GroupStartControl : public RolloutControl
{
public:
	int		start_y;			/* y coord of top of group */

			GroupStartControl(Value* caption)
				: RolloutControl(NULL, caption, NULL, 0)  { tag = class_tag(GroupStartControl); }

			classof_methods (GroupStartControl, RolloutControl);
	void	collect() { delete this; }
	void	sprin1(CharStream* s) { s->printf(_T("GroupStartControl:%s"), caption->to_string()); }

	void	add_control(Rollout *ro, HWND parent, HINSTANCE hInstance, int& current_y);
	LPCTSTR	get_control_class() { return _T(""); }
	void	compute_layout(Rollout *ro, layout_data* pos) { }
};

visible_class (GroupEndControl)

class GroupEndControl : public RolloutControl
{
	GroupStartControl* my_start;			/* link back to my group start control */
public:
			GroupEndControl(GroupStartControl* starter)
				: RolloutControl(NULL, starter->caption, NULL, 0) { tag = class_tag(GroupEndControl); my_start = starter; }

			classof_methods (GroupEndControl, RolloutControl);
	void	collect() { delete this; }
	void	sprin1(CharStream* s) { s->printf(_T("GroupEndControl:%s"), caption->to_string()); }

	void	add_control(Rollout *ro, HWND parent, HINSTANCE hInstance, int& current_y);
	LPCTSTR	get_control_class() { return _T(""); }
	void	compute_layout(Rollout *ro, layout_data* pos) { }
};

// ---- time change callback for rollouts with controller-linked spinners in them ----

class RolloutChangeCallback : public TimeChangeCallback
{
public:
	Rollout*	ro;
				RolloutChangeCallback(Rollout* iro) { ro = iro; }
	void		TimeChanged(TimeValue t) { ro->TimeChanged(t); }
};

/* control keyword parameter access macros... */

extern ScripterExport Value* _get_control_param(Value** keyparms, int count, Value* key_name);
extern ScripterExport Value* _get_control_param_or_default(Value** keyparms, int count, Value* key_name, Value* def);

#define control_param(key)					_get_control_param(keyparms, keyparm_count, n_##key)
#define control_param_or_default(key, def)	_get_control_param_or_default(keyparms, keyparm_count, n_##key##, def)
#define int_control_param(key, var, def)	((var = _get_control_param(keyparms, keyparm_count, n_##key)) == &unsupplied ? def : var->to_int())
#define float_control_param(key, var, def)	((var = _get_control_param(keyparms, keyparm_count, n_##key)) == &unsupplied ? def : var->to_float())

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\ScrpCtrl.h ===
/*	
 *		ScrpCtrl.h - interface to scripter-based expression controllers
 *
 *			John Wainwright
 *			Copyright  Autodesk, Inc. 1997
 */

#ifndef _H_SCRPTCTRL
#define _H_SCRPTCTRL

#define FLOAT_SCRIPT_CONTROL_CNAME			GetString(IDS_RB_SCRIPTFLOAT)
#define FLOAT_SCRIPT_CONTROL_CLASS_ID		Class_ID(0x498702e6, 0x71f11548)

#define POSITION_SCRIPT_CONTROL_CNAME		GetString(IDS_RB_SCRIPTPOSITION)
#define POSITION_SCRIPT_CONTROL_CLASS_ID	Class_ID(0x5065767b, 0x683a42a5)

#define POINT3_SCRIPT_CONTROL_CNAME			GetString(IDS_RB_SCRIPTPOINT3)
#define POINT3_SCRIPT_CONTROL_CLASS_ID		Class_ID(0x46972869, 0x2f7f05ce)

#define ROTATION_SCRIPT_CONTROL_CNAME		GetString(IDS_RB_SCRIPTROTATION)
#define ROTATION_SCRIPT_CONTROL_CLASS_ID	Class_ID(0x31381912, 0x3a904166)

#define SCALE_SCRIPT_CONTROL_CNAME			GetString(IDS_RB_SCRIPTSCALE)
#define SCALE_SCRIPT_CONTROL_CLASS_ID		Class_ID(0x7c8f3a2a, 0x1e954d91)

class IBaseScriptControl : public StdControl {
	public:
		virtual TCHAR*	get_script_text() = 0;
		virtual void	set_script_text(TCHAR* text) = 0;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\streampr.h ===
/*	
 *		stream_protocol.h - def_generics for Stream protocol
 *
 *			Copyright  John Wainwright 1996
 */

	def_visible_generic(read_value,	"readValue");
	def_visible_generic(read_expr,	"readExpr");
	def_visible_generic(read_line,	"readLine");
	def_visible_generic(read_char,	"readChar");
	def_visible_generic(read_chars,	"readChars");
	def_visible_generic(read_delimited_string,	"readDelimitedString");
	def_visible_generic(skip_to_string,	"skipToString");
	def_visible_generic(skip_to_next_line,	"skipToNextLine");
	def_visible_generic(execute,	"execute");
	
	def_visible_generic(file_pos,	"filepos");
	def_visible_generic(seek,		"seek");
	def_visible_generic(eof,		"eof");

	def_visible_generic(close,		"close");
	def_visible_generic(flush,		"flush");
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\shdtppro.h ===
// Protocol for Shadow Type class

	def_visible_generic (CanDoOmni, "CanDoOmni");
	def_visible_generic (SupportStdMapInterface, "SupportStdMapInterface");
	def_visible_generic (MapSize, "MapSize");
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\strngpro.h ===
/*	
 *		string_protocol.h - def_generics for the string protocol
 *
 *			Copyright  John Wainwright 1996
 *
 */

	use_generic( plus,	"+");
	use_generic( eq,	"=");
	use_generic( ne,	"!=");
	use_generic( gt,	">");
	use_generic( lt,	"<");
	use_generic( ge,	">=");
	use_generic( le,	"<=");
	use_generic( get,	"get");
	use_generic( put,	"put");

	def_visible_generic( findString,	"findString");
	def_visible_generic( findPattern,	"findPattern");
	def_visible_generic( substring,		"substring");
	def_visible_generic( replace,		"replace");

	use_generic( execute, "execute");
	use_generic( coerce,  "coerce");
	use_generic( copy,    "copy");
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\Streams.h ===
/*	
  *		Streams.h - stream family for MAXScript
  *
  *			Copyright  John Wainwright 1996
  *
  */
 
 #ifndef _H_STREAM
 #define _H_STREAM
 
 class Listener;
 class FileStream;
 class Parser;
 
 visible_class (CharStream)
 
 class CharStream : public Value
 {
 public:
 					classof_methods (CharStream, Value);
 			BOOL	_is_charstream() { return 1; }
 #	define			is_charstream(o) ((o)->_is_charstream())
 
 	virtual TCHAR	get_char() = 0;
 	virtual void	unget_char(TCHAR c) = 0;
 	virtual TCHAR	peek_char() = 0;
 	virtual int		at_eos() = 0;
 	virtual void	rewind() = 0;
	virtual int		pos() { return 0; }
	virtual void	seek(int pos) { };
	virtual void	flush_to_eol() = 0;
 	virtual void	flush_to_eobuf() {}
 	virtual void	flush_whitespace();
 
 	virtual TCHAR	putch(TCHAR c) { return c; }
 	virtual TCHAR*	puts(TCHAR* str) { return str; }
 	virtual int		printf(const TCHAR *format, ...) { return 0; }
 	virtual void	close() {}
 	virtual void	flush() {}
 
 	virtual void	log_to(CharStream* log) {}
 	virtual void	close_log() {}
 	virtual Listener* get_listener() { return NULL; }
 	virtual CharStream* get_log() { return NULL; }

	virtual Value*	get_file_name() { return NULL; }
 };
 
 visible_class (FileStream)
 
 class FileStream : public CharStream
 {
 public:
 	Value*	file_name;
 	TCHAR*	mode;
 	FILE*	file;
 	CharStream*	log;
 	int		ungetchar_count;
	TCHAR	ungetchar_buf[8];
 	Parser* reader;
	BOOL	decrypt;
 
 			ScripterExport FileStream ();
 		    ScripterExport ~FileStream ();
 
 			classof_methods (FileStream, CharStream);
 #	define	is_filestream(v) ((v)->tag == class_tag(FileStream))
	void	collect() { delete this; }
 	void	gc_trace();
 	ScripterExport void	sprin1(CharStream* s);
 
 #include "defimpfn.h"
 #	include "streampr.h"
 
 	/* internal char stream protocol */
 	
 	ScripterExport TCHAR	get_char();
 	ScripterExport void		unget_char(TCHAR c);
 	ScripterExport TCHAR	peek_char();
 	ScripterExport int		at_eos();
 	ScripterExport int		pos();
 	ScripterExport void		seek(int pos);
	ScripterExport void		rewind();
 	ScripterExport void		flush_to_eol();
 
 	ScripterExport TCHAR	putch(TCHAR c);
 	ScripterExport TCHAR*	puts(TCHAR* str);
 	ScripterExport int		printf(const TCHAR *format, ...);
 
 	ScripterExport FileStream* open_decrypt(TCHAR* ifile_name, int seed);
 	ScripterExport FileStream* open(TCHAR* ifile_name, TCHAR* imode);
 	ScripterExport void	flush();
 	ScripterExport void	close();
 	void	log_to(CharStream* log);
 	void	close_log();

	Value*	get_file_name() { return file_name; }
	void	undo_lookahead();
 };
 
 visible_class (WindowStream)
 
 class WindowStream : public CharStream
 {
 public:
 	HWND		window;
 	int			cursor;
 	TCHAR*		title;
 	Listener*	listener;
 	CharStream*	log;
	TCHAR		wputs_buf[512];			// edit control output buffer
	TCHAR*		wputs_p;
	HWND		echo;
 
 				WindowStream(HWND iwin);
 				WindowStream(TCHAR* title);		/* for background scripts; window with given title will open if output generated */
 			   ~WindowStream();
 
 				classof_methods (WindowStream, CharStream);
 	void		collect() { delete this; }
 	void		gc_trace();
 	ScripterExport void	sprin1(CharStream* s);
 
 #include "defimpfn.h"
 	def_generic(sprint,	  "sprint");
  	use_generic( coerce,  "coerce");
		
 	/* internal TCHAR stream protocol */
 	
 	TCHAR		get_char() { return 0; }
 	void		unget_char(TCHAR c) {}
 	TCHAR		peek_char() {return 0; }
 	int			at_eos() { return TRUE; }
 	void		rewind() {}
 	void		flush_to_eol() {}
 
 	ScripterExport TCHAR	putch(TCHAR c);
 	ScripterExport TCHAR*	puts(TCHAR* str);
 	ScripterExport int		printf(const TCHAR *format, ...);
 	ScripterExport void		flush();

 	void		ensure_window_open();
 
 	void		log_to(CharStream* log);
 	void		close_log();
 	Listener*	get_listener() { return listener; }
 	CharStream* get_log() { return log; }

	// edit control output primitives
	ScripterExport TCHAR*	wputs(const TCHAR *str);
	ScripterExport void		wflush();
	ScripterExport TCHAR	wputch(const TCHAR c);
	ScripterExport int		wprintf(const TCHAR *format, ...);
				   void		set_echo_window(HWND wnd) { echo = wnd; }
				   void		echo_cur_line();
 				   int		get_cur_line(TSTR& line);
};
 
 #endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\Strings.h ===
/*	
 *		Strings.h - string family for MAXScript
 *
 *			Copyright  John Wainwright 1996
 *
 */

#ifndef _H_STRING
#define _H_STRING

#include "streams.h"

visible_class (String)

class String : public Value
{
	TCHAR*		string;

public:
 ScripterExport String(TCHAR *init_string);
			   ~String() { if (string) free(string); }

				classof_methods (String, Value);
#	define		is_string(o) ((o)->tag == class_tag(String))
	void		collect() { delete this; }
	ScripterExport void		sprin1(CharStream* s);

	Value*		append(TCHAR* str);
	Value*		append(Value* str_val) { return append(str_val->to_string()); }

#include "defimpfn.h"
#	include "strngpro.h"

	def_property( count );

	TCHAR*		to_string() { return string; }

	// scene I/O 
	IOResult Save(ISave* isave);
	static Value* Load(ILoad* iload, USHORT chunkID, ValueLoader* vload);

	friend class StringStream;
};

applyable_class (StringStream)

class StringStream : public CharStream
{
public:
	TCHAR*	content_string;		/* the content string				*/
	TCHAR*	cursor;				/* current read/write cursor		*/
	size_t	buf_len;			/* allocated buffer length			*/
 	int		ungetchar_count;
 	Parser* reader;

	ScripterExport StringStream();
	ScripterExport ~StringStream();
	ScripterExport StringStream(TCHAR* init_string);
	ScripterExport StringStream(int ilen);
	ScripterExport StringStream(Value* init_string_value);
	ScripterExport void init(TCHAR* init_string);

			classof_methods (StringStream, CharStream);
	void	collect() { delete this; }
	ScripterExport void	sprin1(CharStream* s);

 #include "defimpfn.h"
 #	include "streampr.h"
 	use_generic( coerce,  "coerce");
	use_generic( copy,    "copy");

	ScripterExport TCHAR	get_char();
	ScripterExport void		unget_char(TCHAR c);
	ScripterExport TCHAR	peek_char();
 	ScripterExport int		pos();
	ScripterExport int		at_eos();
	ScripterExport void		rewind();
	ScripterExport void		flush_to_eol();
	ScripterExport void		flush_to_eobuf();
			  	   void		undo_lookahead();

	ScripterExport	TCHAR*	puts(TCHAR* str);
	ScripterExport	TCHAR	putch(TCHAR c);
	ScripterExport	int		printf(const TCHAR *format, ...);

	TCHAR*	to_string() { return content_string; }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\Structs.h ===
/*		Structs.h - the MAXSript struct definition classes
 *
 *		Copyright (c) John Wainwright, 1996
 *		
 */

#ifndef _H_STRUCT
#define _H_STRUCT

visible_class (StructDef)

class StructDef : public Value
{
public:
	Value*		name;						/* struct's global var name */
	Value**		member_inits;				/* member init vals			*/
	int			member_count;				/*   "    count				*/
	HashTable*	members;					/* member name to index table */

	ScripterExport StructDef(Value* name, int member_count, Value** inits, HashTable* members);
				~StructDef();
				classof_methods (StructDef, Value);
#	define		is_structdef(o) ((o)->tag == class_tag(StructDef))

	void		collect() { delete this; }
	void		gc_trace();
	ScripterExport void		sprin1(CharStream* s);

	ScripterExport Value* apply(Value** arglist, int count);
	ScripterExport Value* get_property(Value** arg_list, int count);
	ScripterExport Value* set_property(Value** arg_list, int count);
};

class Struct : public Value
{
public:
	StructDef*	definition;					/* pointer to my struct def							*/
	Value**		member_data;				/* data elements, indexed via struct def hashtable	*/

	ScripterExport Struct(StructDef* idef, int mem_count);
				~Struct();

	Value*		classOf_vf(Value** arg_list, int count);
	Value*		superClassOf_vf(Value** arg_list, int count);
	Value*		isKindOf_vf(Value** arg_list, int count);
	BOOL		is_kind_of(ValueMetaClass* c) { return (c == class_tag(StructDef)) ? 1 : Value::is_kind_of(c); }

	void		collect() { delete this; }
	void		gc_trace();
	ScripterExport void		sprin1(CharStream* s);

#include "defimpfn.h"
	use_generic ( copy, "copy" );

	Value*		get_property(Value** arg_list, int count);
	Value*		set_property(Value** arg_list, int count);
};

// StructMethods wrap member functions accessed on a struct instance
// their apply() sets up the appropriate struct instance thread-local
// for member data access thunks
class StructMethod : public Value
{
public:
	Struct* this_struct;
	Value*	fn;

			StructMethod(Struct* t, Value* f);

	void	gc_trace();
	void	collect() { delete this; }
	void	sprin1(CharStream* s) { fn->sprin1(s); }
	BOOL	_is_function() { return fn->_is_function(); }

				   Value* classOf_vf(Value** arg_list, int count) { return fn->classOf_vf(arg_list, count); }
				   Value* superClassOf_vf(Value** arg_list, int count) { return fn->superClassOf_vf(arg_list, count); }
				   Value* isKindOf_vf(Value** arg_list, int count) { return fn->isKindOf_vf(arg_list, count); }
				   BOOL	  is_kind_of(ValueMetaClass* c) { return fn->is_kind_of(c); }
				   Value* eval() { return fn->eval(); }
    Value* apply(Value** arglist, int count);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\toolpro.h ===
/*	
 *		toolpro.h - def_generics for the operations on MouseTool
 *
 *			Copyright  John Wainwright 1996
 */

	def_visible_primitive(start_tool,	"startTool");
	def_visible_primitive(stop_tool,	"stopTool");
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\texmapro.h ===
/*	
 *		texture_map_protocol.h - def_generics for the operations on MAX texture maps
 *
 *			Copyright  John Wainwright 1997
 *
 */
 
/* rendering */

	def_visible_generic  ( render_map,	"renderMap");
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\time_fns.h ===
/*	
 *		MAX_time_functions.h - recursive animatable time functions
 *
 *			Copyright  John Wainwright 1996
 *
 */
 
/* time operations */

	def_time_fn  ( deleteTime );
	def_time_fn  ( reverseTime );
	def_time_fn  ( scaleTime );
	def_time_fn  ( insertTime );
	def_time_fn  ( setTimeRange );

/* key operations */

	def_time_fn  ( addNewKey );
	def_time_fn  ( deleteKeys );
	def_time_fn  ( selectKeys );
	def_time_fn  ( deselectKeys );
	def_time_fn  ( moveKeys );
	def_time_fn  ( sortKeys );
	def_time_fn  ( reduceKeys );

/* ORT, ease/multiplier curves */

	def_time_fn  ( addEaseCurve );
	def_time_fn  ( deleteEaseCurve );
	def_time_fn  ( setBeforeORT );
	def_time_fn  ( setAfterORT );
	def_time_fn  ( enableORTs );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\timepro.h ===
/*	
 *		time_protocol.h - def_generics for the Time protocol
 *
 *		see def_abstract_generics.h for more info.
 *
 *	
 *			Copyright  John Wainwright 1996
 *
 */

	use_generic( plus,		"+");
	use_generic( minus,		"-");
	use_generic( times,		"*");
	use_generic( div,		"/");
	use_generic( uminus,	"u-");

	use_generic( eq,		"=");
	use_generic( ne,		"!=");
	use_generic( gt,		">");
	use_generic( lt,		"<");
	use_generic( ge,		">=");
	use_generic( le,		"<=");

	use_generic( random,	"random");
	use_generic( abs,		"abs");

	def_visible_primitive( normtime, "normtime" );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\thrdlcls.h ===
/*	
 *		thread_locals.h - thread locals for each interpreter thread in MAXScript
 *
 *			Copyright  John Wainwright 1996
 *
 */

/* thread locals and initial values */

	def_thread_local( CharStream*, current_stdout,			new WindowStream(_T("Script Output")));
	def_thread_local( BOOL,		force_listener_open,		TRUE);			// whether to force listener open on output to it

	def_thread_local( Value**,	current_frame,				NULL);			// current interpreter frame (for thunk evals)
	def_thread_local( Value**,	current_scan_frame,			NULL);			// current interpreter frame (for gc scanner) 
	def_thread_local( Value**,	current_locals_frame,		NULL);			// C++ local frame
	def_thread_local( Value*,	current_result,				NULL);			// C++ current Value* function result
	def_thread_local( long,		stack_limit,				1024000);		// max stack size to catch recurse loops, 1Mb to start
	def_thread_local( long,		stack_base,					(long)_alloca(sizeof(int)));	// current stack base
	def_thread_local( MSPlugin*, current_plugin,			NULL);			// current scripted plugin (for plugin thunk evals)
	def_thread_local( Struct*,	current_struct,				NULL);			// current struct (for struct member thunk evals)
	def_thread_local( Value*,	current_container,			NULL);			// current container for nested property access
	def_thread_local( int,		container_index,			0);				// current container index (if any)
	def_thread_local( Value*,	container_prop,				NULL);			// current container prop (if any)
	def_thread_local( Value*,	current_prop,				NULL);			// most recent prop access (if any)

	def_thread_local( Value*,	source_file,				NULL);			// current source file
	def_thread_local( int,		source_pos,					0);				// current pos in source file

	def_thread_local( BOOL,		needs_redraw,				0);
	def_thread_local( BOOL,		redraw_mode,				1);				// redraw on
	def_thread_local( BOOL,		pivot_mode,					0);				// pivot off
	def_thread_local( BOOL,		undo_mode,					1);				// undo on
	def_thread_local( Value*,	current_level,				&all_objects);	// $objects
	def_thread_local( BOOL,		use_time_context,			0);				// use MAX time slider
	def_thread_local( TimeValue, current_time,				0);
	def_thread_local( Value*,	current_coordsys,			n_default);
	def_thread_local( Value*,	center_mode,				n_default);

	def_thread_local( int,		rand_accum,					0);				// for our own rand()
	def_thread_local( HANDLE,	message_event,				NULL);			// listener_message synch event
	def_thread_local( int,		stream_rand_accum,			0);				// for stream_rand()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\UIExtend.h ===
/**********************************************************************
 *<
	FILE: UIExtend.h

	DESCRIPTION: MaxScript user interface extensions

	CREATED BY: Ravi Karra, 1998

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef _H_UIEXTEND
#define _H_UIEXTEND

#define MF_SUBMENU_START	(MF_SEPARATOR+10)
#define MF_SUBMENU_END		(MF_SEPARATOR+11)

class RCMenu;

visible_class (MenuItem)

class MenuItem : public Value
{	
public:
	Value	*name, *caption, *flt_fn;
	Value	**keyparms;
	RCMenu	*menu;

	int		keyparm_count;
	UINT	flags;
	
			MenuItem (RCMenu *m, Value* n, Value* c, Value	**keyparms, int keyparm_count, UINT f=0);
			MenuItem () {menu= NULL; name=caption=NULL; keyparms=NULL; flags=keyparm_count=0;} 
			~MenuItem ();

	void	setup_params();
	void	collect() { delete this; }
	void	gc_trace();
	ScripterExport void sprin1(CharStream* s);

	virtual	Value*	get_property(Value** arg_list, int count);
	virtual	Value*	set_property(Value** arg_list, int count);
};


class MSRightClickMenu : public RightClickMenu
{
public:
	RCMenu	*menu;
	void	Init(RightClickMenuManager* manager, HWND hWnd, IPoint2 m);
	void	Selected(UINT id);
	Value*	call_filt_fn(Value* fn);
};


visible_class (RCMenu)

class RCMenu : public Value
{
public:
	Value*		name;						// menu name
	HashTable*  local_scope;				// local name space	
	MenuItem**	items;						// menu item array
	int			item_count;					//   "	  "  count
	Value**		locals;						// local var array	
	Value**		local_inits;				//   "    "    "  init vals	
	int			local_count;				//   "    "  count	
	HashTable*	handlers;					// handler tables	
	short		flags;						// menu flags
	BOOL		init_values;				// whether to init ctrl/local values on (re)open 
	BOOL		end_rcmenu_mode;			// signals end of rcmenu mode
	MSRightClickMenu msmenu;				// right-click menu
	// command mode locals...
	Value*		result;						// rcmenu result
	MSPlugin*	plugin;						// current plugin under manip if non-NULL

				RCMenu(short iflags);
	void		init(Value* name, int local_count, Value** inits, HashTable* local_scope, MenuItem** iitems, int iitem_count, HashTable* handlers);
			   ~RCMenu();

				classof_methods (RCMenu, Value);
	void		collect() { delete this; }
	void		gc_trace();
	ScripterExport void sprin1(CharStream* s);

	Value*		get_event_handler(Value* name, Value* event);
	BOOL		call_event_handler(Value* name, Value* event, Value** arg_list, int count);
	

	virtual	Value*	get_property(Value** arg_list, int count);
	virtual	Value*	set_property(Value** arg_list, int count);
};


#endif //_H_UIEXTEND
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\Value.h ===
/*		Value.h - metaclass system  MAXScript values
 *
 *	All MAXScript-specific C++ objects are subclasses of a single root class, Value, 
 *  and allocated & automatically freed in a specially maintained heap.  There is also
 *  a metaclass system to provide a runtime type calculus for the scripter.  Value subclasses
 *  are divided into those that are scripter-visible, (ie, may wind up as objects that the
 *  scripter may pass around or store in variables, etc.), and those that are entirely
 *  internal to the scripter operation (such as thunks, etc.).  The scripter-visible
 *  classes (the majority) are represented in the metasystem by instances of separate
 *  metaclasses.  The metaclasses are all subclasses of ValueMetaClass, the metaclass of
 *  a class X is named XClass and its sole instance is X_class. The class instances are
 *  made visible in globals (usually) named X.  
 *
 *  Each Value instance has a tag word that either contains a pointer to the instance's
 *  class instance (in the case of scripter-visible classes) or the reserved value INTERNAL_CLASS_TAG.
 *  This value is used in performing runtimne type tests and for yielding results to classOf 
 *  methods.
 *
 *  The metaclass, its instance and some of the class calculus methods are usually defined via
 *  a bunch of macros defined here (see visible_class, visible_class_instance, etc.)
 *
 *  Some of the classes are can be instanced directly as literals in a script, such as strings, 
 *  Point3s, arrays, etc.  Some others are instantiable directly by applying the class value
 *  to a set of initializing parameters, ie, using the class as a function in a function call,
 *	for example, ray, quat, interval, etc.  These are defined via a variant macro: applyable_class().
 *  A special case of this is provided in the MAXWrapper subsytem for creatable MAX objects, such as
 *  boxes, lights, camera, etc..  These are represnted by instances of the class MAXClass, and again, thses
 *  instances are exposed in globals to be applied to creation paramters.  These instances
 *  contain a lot of property metadata and are defined in MAX_classes.cpp.  See MAXObject.h for more
 *  info.
 *	
 *		Copyright (c) John Wainwright, 1996
 *
 */

#ifndef _H_VALUE
#define _H_VALUE

#include "Colctble.h"
#include "Max.h"
#include "STDMAT.H"
#include "Surf_api.h"
#include "Collect.h"

class Name;
#include "defextfn.h"
#	include "corename.h"

// forward declarations...
class PathName;
class Undefined;
class UserProp;
class UserGeneric;

extern ScripterExport Undefined undefined;
class ValueMetaClass;
typedef struct node_map node_map;

// the root MAXScript class
class Value : public Collectable
{
private:
    ScripterExport static Matrix3  s_error_matrix;
	ScripterExport static Box2  s_error_box2;
public:
	ValueMetaClass* tag;		// runtime type tag; filled in by subclasses

	ScripterExport virtual BOOL	is_kind_of(ValueMetaClass* c);
	ScripterExport virtual ValueMetaClass* local_base_class(); // local base class in this class's plug-in
	virtual Value*	eval() { check_interrupts(); return this; }
	virtual Value*	eval_no_wrapper() { check_interrupts(); return this; }
	virtual Value*  apply(Value** arglist, int count) { throw TypeError (_T("Call needs function or class"), this); return this; }
	virtual void	export_to_scripter() { }

	virtual Value*  map(node_map& m) { unimplemented(_T("map"), this) ; return this; }
	virtual Value*	map_path(PathName* path, node_map& m) { unimplemented(_T("map_path"), this) ; return this; }
	virtual Value*	find_first(BOOL (*test_fn)(INode* node, int level, void* arg), void* test_arg) { unimplemented(_T("find_first"), this) ; return this; }
	virtual Value*	get_path(PathName* path) { unimplemented(_T("get"), this) ; return this; }

	ScripterExport virtual void	sprin1(CharStream* stream);
	ScripterExport virtual void	sprint(CharStream* stream);

	virtual void	prin1() { sprin1(thread_local(current_stdout)); }
	virtual void	print() { sprint(thread_local(current_stdout)); }

	/* include all the protocol declarations */

#include "defabsfn.h"
#	include "mathpro.h"
#	include "vectpro.h"
#	include "matpro.h"
#	include "quatpro.h"
#	include "arraypro.h"
#	include "streampr.h"
#	include "strngpro.h"
#	include "timepro.h"
#	include "colorpro.h"
#	include "nodepro.h"
#	include "ctrlrpro.h"
#	include "prims.h"
#	include "biprops.h"
#	include "bitmapro.h"
#	include "texmapro.h"
#	include "atmspro.h"
#	include "nurbspro.h"
#	include "ctbmapro.h"

// MXSAgni specific -- START --
#	include "bmatpro.h"
#	include	"boxpro.h"
#	include "phyblpro.h"
#	include "phymcpro.h"
#	include	"bipedpro.h"
#	include "notespro.h"
#	include "xrefspro.h"
// MXSAgni specific -- END --

	ScripterExport virtual Class_ID get_max_class_id() { return Class_ID(0, 0); }
	ScripterExport virtual Value* delete_vf(Value** arglist, int arg_count) { ABSTRACT_FUNCTION(_T("delete"), this, Value*); }	  
	ScripterExport virtual Value* clearSelection_vf(Value** arglist, int arg_count) { ABSTRACT_FUNCTION(_T("clearSelection"), this, Value*); }	  

#undef def_generic
#define def_generic(fn, name) ScripterExport virtual Value* fn##_vf(Value** arglist, int arg_count);
#	include "kernlpro.h"
	
	virtual float		to_float() { ABSTRACT_CONVERTER(float, Float); }
	virtual TCHAR*		to_string() { ABSTRACT_CONVERTER(TCHAR*, String); }
	virtual int			to_int() { ABSTRACT_CONVERTER(int, Integer); }
	virtual BOOL		to_bool() { ABSTRACT_CONVERTER(BOOL, Boolean); }
	virtual BitArray&	to_bitarray() { throw ConversionError (this, _T("BitArray")); return *(BitArray*)NULL; }
	virtual Point3		to_point3() { ABSTRACT_CONVERTER(Point3, Point3); }
	virtual Point2		to_point2() { ABSTRACT_CONVERTER(Point2, Point2); }
	virtual AColor		to_acolor() { throw ConversionError (this, _T("Color")); return AColor(0,0,0); }
	virtual COLORREF	to_colorref() { throw ConversionError (this, _T("Color")); return RGB(0,0,0); }
	virtual INode*		to_node() { ABSTRACT_CONVERTER(INode*, <node>); }
	virtual Ray			to_ray() { throw ConversionError (this, _T("Ray")); return Ray(); }
	virtual Interval	to_interval() { throw ConversionError (this, _T("Interval")); return Interval();  }
	virtual Quat		to_quat() { throw ConversionError (this, _T("Quaternion")); return Quat();  }
	virtual AngAxis		to_angaxis() { throw ConversionError (this, _T("AngleAxis")); return AngAxis();  }
	virtual Matrix3&	to_matrix3() { throw ConversionError (this, _T("Matrix")); return s_error_matrix;  }
	virtual float*		to_eulerangles() { ABSTRACT_CONVERTER(float*, Float); }
	virtual Mtl*		to_mtl() { ABSTRACT_CONVERTER(Mtl*, Material); }
	virtual Texmap*		to_texmap() { ABSTRACT_CONVERTER(Texmap*, TextureMap); }
	virtual MtlBase*	to_mtlbase() { ABSTRACT_CONVERTER(MtlBase*, MtlBase); }
	virtual Modifier*	to_modifier() { ABSTRACT_CONVERTER(Modifier*, Modifier); }
	virtual TimeValue	to_timevalue() { ABSTRACT_CONVERTER(TimeValue, Time); }
	virtual Control*	to_controller() { ABSTRACT_CONVERTER(Control*, Controller); }
	virtual Atmospheric* to_atmospheric() { ABSTRACT_CONVERTER(Atmospheric*, Atmospheric); }
	virtual Effect*		to_effect() { ABSTRACT_CONVERTER(Effect*, Effect); }						// RK: Added this
	virtual ShadowType*	to_shadowtype() { ABSTRACT_CONVERTER(ShadowType*, ShadowType); }			// RK: Added this
	virtual FilterKernel*	to_filter() { ABSTRACT_CONVERTER(FilterKernel*, FilterKernel); }		// RK: Added this
	virtual INode*		to_rootnode() { ABSTRACT_CONVERTER(INode*, <root>); }						// RK: Added this
	virtual ITrackViewNode* to_trackviewnode() { ABSTRACT_CONVERTER(ITrackViewNode*, TrackViewNode); }
	virtual NURBSIndependentPoint* to_nurbsindependentpoint() { throw ConversionError (this, _T("NURBSIndependentPoint")); return (NURBSIndependentPoint*)0;  }
	virtual NURBSPoint*	to_nurbspoint() { throw ConversionError (this, _T("NURBSPoint")); return (NURBSPoint*)0;  }
	virtual NURBSObject* to_nurbsobject() { throw ConversionError (this, _T("NURBSObject")); return (NURBSObject*)0;  }
	virtual NURBSControlVertex* to_nurbscontrolvertex() { throw ConversionError (this, _T("NURBSControlVertex")); return (NURBSControlVertex*)0;  }
	virtual NURBSCurve* to_nurbscurve() { throw ConversionError (this, _T("NURBSCurve")); return (NURBSCurve*)0;  }
	virtual NURBSCVCurve* to_nurbscvcurve() { throw ConversionError (this, _T("NURBSCVCurve")); return (NURBSCVCurve*)0;  }
	virtual NURBSSurface* to_nurbssurface() { throw ConversionError (this, _T("NURBSSurface")); return (NURBSSurface*)0;  }
	virtual NURBSTexturePoint* to_nurbstexturepoint() { throw ConversionError (this, _T("NURBSTexturePoint")); return (NURBSTexturePoint*)0;  }
	virtual NURBSSet*	to_nurbsset() { throw ConversionError (this, _T("NURBSSet")); return (NURBSSet*)0;  }
	virtual ReferenceTarget* to_reftarg() { ABSTRACT_CONVERTER(ReferenceTarget*, MaxObject); }
	virtual Mesh*		to_mesh() { ABSTRACT_CONVERTER(Mesh*, Mesh); }

// MXSAgni specific -- START --
	virtual Box2&	to_box2() { throw ConversionError (this, _T("Box2")); return s_error_box2;  }
// MXSAgni specific -- END --
	virtual NURBSTextureSurface* to_nurbstexturesurface() { throw ConversionError (this, _T("NURBSTextureSurface")); return (NURBSTextureSurface*)0;  }
	virtual NURBSDisplay* to_nurbsdisplay() { throw ConversionError (this, _T("NURBSDisplay")); return (NURBSDisplay*)0;  }
	virtual TessApprox*	 to_tessapprox() { throw ConversionError (this, _T("TessApprox")); return (TessApprox*)0;  }

	virtual Value*	widen_to(Value* arg, Value** arg_list) { ABSTRACT_WIDENER(arg); }
	virtual BOOL	comparable(Value* arg) { return (tag == arg->tag); }
	virtual BOOL	is_const() { return FALSE; }

	ScripterExport virtual Value*	get_property(Value** arg_list, int count);
	ScripterExport virtual Value*	set_property(Value** arg_list, int count);
	ScripterExport Value*	_get_property(Value* prop);
	ScripterExport Value*	_set_property(Value* prop, Value* val);
	virtual Value*	get_container_property(Value* prop, Value* cur_prop) { throw AccessorError (cur_prop, prop); }
	virtual Value*	set_container_property(Value* prop, Value* val, Value* cur_prop) { throw AccessorError (cur_prop, prop); }

#ifdef USE_PROPERTY_PATH_THUNKS
	virtual Value*	get_property_path(Value** arg_list, int count);
	virtual Value*	set_property_path(Value** arg_list, int count);
#endif

	// polymorphic default type predicates - abstracted over by is_x(v) macros as needed
	virtual BOOL	_is_collection() { return FALSE; }
	virtual BOOL	_is_charstream() { return FALSE; }
	virtual BOOL	_is_rolloutcontrol() { return FALSE; }
	virtual BOOL	_is_rolloutthunk() { return FALSE; }
	virtual BOOL	_is_function()	 { return FALSE; }
	virtual BOOL	_is_selection()	 { return FALSE; }
	virtual BOOL	_is_thunk()		{ return FALSE; }

	// yield selection set iterator if you can
	virtual SelectionIterator* selection_iterator() { throw RuntimeError (_T("Operation requires a selection (Array or BitArray)")); return NULL; }

	// scene persistence functions
	ScripterExport virtual IOResult Save(ISave* isave);
	// the Load fn is a static method on loadbale classes, see SceneIO.cpp & .h and each loadable class

	// called during MAX exit to have all MAXScript-side refs dropped (main implementation in MAXWrapper)
	virtual void drop_MAX_refs() { }
};

/* ---------- the base class for all metaclasses  ---------- */

class MetaClassClass;
extern MetaClassClass value_metaclass;  // the metaclass class

class ValueMetaClass : public Value
{
public:
	TCHAR*			name;
	UserProp*		user_props;		// additional, user defined property accessors
	short			uprop_count;
	UserGeneric*	user_gens;		//     "        "      "    generic fns
	short			ugen_count;

					ValueMetaClass() { }
	ScripterExport	ValueMetaClass(TCHAR* iname);

	ScripterExport BOOL	is_kind_of(ValueMetaClass* c);
#	define		is_valueclass(o) ((o)->tag == (ValueMetaClass*)&value_metaclass)
	ScripterExport void sprin1(CharStream* s);
	ScripterExport void	export_to_scripter();
	ScripterExport void add_user_prop(TCHAR* prop, value_cf getter, value_cf setter);
	ScripterExport void add_user_generic(TCHAR* name, value_cf fn);
	ScripterExport UserGeneric* find_user_gen(Value* name);
	ScripterExport UserProp* find_user_prop(Value* prop);
};

#define classof_methods(_cls, _super)					\
	Value* classOf_vf(Value** arg_list, int count)		\
	{													\
		check_arg_count(classOf, 1, count + 1);			\
		return &_cls##_class;							\
	}													\
	Value* superClassOf_vf(Value** arg_list, int count)	\
	{													\
		check_arg_count(superClassOf, 1, count + 1);	\
		return &_super##_class;							\
	}													\
	Value* isKindOf_vf(Value** arg_list, int count)		\
	{													\
		check_arg_count(isKindOf, 2, count + 1);		\
		return (arg_list[0] == &_cls##_class) ?			\
			&true_value :								\
			_super##_class.isKindOf_vf(arg_list, count); \
	}													\
	BOOL is_kind_of(ValueMetaClass* c)					\
	{													\
		return (c == &_cls##_class) ? 1					\
					: _super::is_kind_of(c);			\
	}

#define visible_class(_cls)												\
	class _cls##Class : public ValueMetaClass							\
	{																	\
	public:																\
					_cls##Class(TCHAR* name) : ValueMetaClass (name) { }	\
		void		collect() { delete this; }							\
	};																	\
	extern ScripterExport _cls##Class _cls##_class;

#define visible_class_s(_cls, _super)									\
	class _cls##Class : public ValueMetaClass							\
	{																	\
	public:																\
					_cls##Class(TCHAR* name) : ValueMetaClass (name) { }	\
		void		collect() { delete this; }							\
		Value*		classOf_vf(Value** arg_list, int count)				\
		{																\
			check_arg_count(classOf, 1, count + 1);						\
			return &_super##_class;										\
		}																\
		Value*		superClassOf_vf(Value** arg_list, int count)		\
		{																\
			return _super##_class.classOf_vf(NULL, 0);					\
		}																\
	};																	\
	extern ScripterExport _cls##Class _cls##_class;

#define applyable_class(_cls)											\
	class _cls##Class : public ValueMetaClass							\
	{																	\
	public:																\
					_cls##Class(TCHAR* name) : ValueMetaClass (name) { }\
		void		collect() { delete this; }							\
		ScripterExport Value* apply(Value** arglist, int count);		\
	};																	\
	extern ScripterExport _cls##Class _cls##_class;

#define applyable_class_s(_cls, _super)									\
	class _cls##Class : public ValueMetaClass							\
	{																	\
	public:																\
					_cls##Class(TCHAR* name) : ValueMetaClass (name) { }\
		Value*		classOf_vf(Value** arg_list, int count)				\
		{																\
			check_arg_count(classOf, 1, count + 1);						\
			return &_super##_class;										\
		}																\
		Value*		superClassOf_vf(Value** arg_list, int count)		\
		{																\
			return _super##_class.classOf_vf(NULL, 0);					\
		}																\
		void		collect() { delete this; }							\
		ScripterExport Value* apply(Value** arglist, int count);		\
	};																	\
	extern ScripterExport _cls##Class _cls##_class;

#define visible_class_instance(_cls, _name)				\
	ScripterExport _cls##Class _cls##_class (_T(_name));

#define class_tag(_cls)				&_cls##_class

#define INTERNAL_CLASS_TAG				((ValueMetaClass*)0L)
#define INTERNAL_INDEX_THUNK_TAG		((ValueMetaClass*)1L)
#define INTERNAL_PROP_THUNK_TAG			((ValueMetaClass*)2L)
#define INTERNAL_LOCAL_THUNK_TAG		((ValueMetaClass*)3L)
#define INTERNAL_FREE_THUNK_TAG			((ValueMetaClass*)4L)
#define INTERNAL_RO_LOCAL_THUNK_TAG		((ValueMetaClass*)5L)
#define INTERNAL_CODE_TAG				((ValueMetaClass*)6L)
#define INTERNAL_SOURCEWRAPPER_TAG		((ValueMetaClass*)7L)
#define INTERNAL_PIPE_TAG				((ValueMetaClass*)8L)
#define INTERNAL_TOOL_LOCAL_THUNK_TAG	((ValueMetaClass*)9L)
#define INTERNAL_GLOBAL_THUNK_TAG		((ValueMetaClass*)10L)
#define INTERNAL_CONST_GLOBAL_THUNK_TAG ((ValueMetaClass*)11L)
#define INTERNAL_SYS_GLOBAL_THUNK_TAG	((ValueMetaClass*)12L)
#define INTERNAL_PLUGIN_LOCAL_THUNK_TAG	((ValueMetaClass*)13L)
#define INTERNAL_PLUGIN_PARAM_THUNK_TAG	((ValueMetaClass*)14L)
#define INTERNAL_RCMENU_LOCAL_THUNK_TAG	((ValueMetaClass*)15L)
#define INTERNAL_STRUCT_MEM_THUNK_TAG	((ValueMetaClass*)16L)
#define INTERNAL_MSPLUGIN_TAG			((ValueMetaClass*)17L)
#define INTERNAL_STRUCT_TAG				((ValueMetaClass*)18L)
#define INTERNAL_MAKER_TAG				((ValueMetaClass*)19L)
#define INTERNAL_CODEBLOCK_LOCAL_TAG	((ValueMetaClass*)20L)
#define INTERNAL_CODEBLOCK_TAG			((ValueMetaClass*)21L)

#define INTERNAL_TAGS					((ValueMetaClass*)100L)  // must be higher than all internal tags

visible_class (Value)

/* ---------- the distinguished value subclasses ---------- */

visible_class (Boolean)

class Boolean;
class ValueLoader;
extern ScripterExport Boolean true_value;
extern ScripterExport Boolean false_value;

class Boolean : public Value
{
public:
			Boolean() { tag = &Boolean_class; }
			classof_methods (Boolean, Value);
	void	collect() { delete this; }
	void	sprin1(CharStream* s);

#	define	is_bool(o) ((o)->tag == &Boolean_class)
	Value*	not_vf(Value**arg_list, int count);
	BOOL	to_bool() { return this == &true_value; }

	// scene I/O 
	IOResult Save(ISave* isave);
	static Value* Load(ILoad* iload, USHORT chunkID, ValueLoader* vload);
};

/* ----- */

visible_class (Undefined)

class Undefined : public Value
{
public:
			Undefined() { tag = &Undefined_class; }
			classof_methods (Undefined, Value);
	void	collect() { delete this; }
	ScripterExport void	sprin1(CharStream* s);
	Value*  copy_vf(Value** arg_list, int count) { return this; }

	// scene I/O 
	IOResult Save(ISave* isave);
	static Value* Load(ILoad* iload, USHORT chunkID, ValueLoader* vload);
	Mtl*	to_mtl() { return NULL; }		// undefined is a NULL material
};

extern ScripterExport Undefined undefined;
extern ScripterExport Undefined dontCollect;

/* ----- */

visible_class (Ok)

class Ok : public Value
{
public:
			Ok() { tag = &Ok_class; }
			classof_methods (Ok, Value);
	void	collect() { delete this; }
	ScripterExport void	sprin1(CharStream* s);

	// scene I/O 
	IOResult Save(ISave* isave);
	static Value* Load(ILoad* iload, USHORT chunkID, ValueLoader* vload);
};

extern ScripterExport Ok ok;

/* ----- */

visible_class (Empty)

class Empty : public Value
{
public:
			Empty() { tag = &Empty_class; }
			classof_methods (Empty, Value);
	void	collect() { delete this; }
	ScripterExport void	sprin1(CharStream* s);
};

extern ScripterExport Empty empty;

/* ----- */

visible_class (Unsupplied)

class Unsupplied : public Value
{
public:
			Unsupplied() { tag = &Unsupplied_class; }
			classof_methods (Unsupplied, Value);
	void	collect() { delete this; }
	ScripterExport void	sprin1(CharStream* s);

	// scene I/O 
	IOResult Save(ISave* isave);
	static Value* Load(ILoad* iload, USHORT chunkID, ValueLoader* vload);
};

extern ScripterExport Unsupplied unsupplied;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\Thunks.h ===
/*		Numbers.h - the Thunk family of classes - variable accessors for MAXScript
 *
 *		Copyright (c) John Wainwright, 1996
 *		
 *
 */

#ifndef _H_THUNKS
#define _H_THUNKS

#include "Name.h"
#include "Arrays.h"
#include "Rollouts.h"
#include "MouseTool.h"

#include "UIExtend.h"

/* ----------------------- Thunk  ---------------------- */

class Thunk : public Value
{
public:
	Value*	name;
	BOOL	clear_container; // outer-level prop in a prop sequence, clear current_container when done
#	define	is_thunk(o) ((o)->_is_thunk())
	BOOL	_is_thunk() { return TRUE; }
};

/* -------------------- GlobalThunk  ------------------- */

class GlobalThunk : public Thunk
{
public:
	Value*	cell;

			GlobalThunk(Value* init_name) { init(init_name); }
			GlobalThunk(Value* init_name, Value* init_val);
	void	init(Value* init_name);
#	define	is_globalthunk(p) ((p)->tag == INTERNAL_GLOBAL_THUNK_TAG)

	ScripterExport Value* eval();

	void	gc_trace();
	void	collect() { delete this; }
	ScripterExport void	sprin1(CharStream* s);

	Value*	assign_vf(Value**arg_list, int count);

};

class ConstGlobalThunk : public GlobalThunk
{
public:
			ConstGlobalThunk(Value* iname) : GlobalThunk(iname) { tag = INTERNAL_CONST_GLOBAL_THUNK_TAG; }
			ConstGlobalThunk(Value* iname, Value* ival) : GlobalThunk(iname, ival) { tag = INTERNAL_CONST_GLOBAL_THUNK_TAG; }
#	define	is_constglobalthunk(p) ((p)->tag == INTERNAL_CONST_GLOBAL_THUNK_TAG)

	Value*	eval() { return cell->is_const() ? cell->copy_vf(NULL, 0) : cell; }
	void	collect() { delete this; }

	Value*	assign_vf(Value**arg_list, int count) { throw AssignToConstError (this); return &undefined; }
};

/* -------------------- SystemGlobalThunk  ------------------- */

/* system globals are abstractions over some system state accessing functions, such as 
 * animation_range, current_renderer,e tc. */

class SystemGlobalThunk : public Thunk
{
	Value* (*get_fn)();
	Value* (*set_fn)(Value*);
public:
			SystemGlobalThunk(Value* init_name, Value* (*iget)(), Value* (*iset)(Value*));

	ScripterExport Value* eval();

	void	collect() { delete this; }
	ScripterExport void	sprin1(CharStream* s) { s->printf(_T("SystemGlobal:%s"), name->to_string()); }

	Value*	assign_vf(Value**arg_list, int count);
};

/* -------------------- LocalThunk  ------------------- */

class LocalThunk : public Thunk
{
public:
	int		frame_level;	// frame nest level at declaration
	int		index;			// local var's index in local frame

			LocalThunk(Value* init_name, int init_index, int iframe_lvl);
#	define	is_localthunk(p) ((p)->tag == INTERNAL_LOCAL_THUNK_TAG)

	Value*	eval() { return thread_local(current_frame)[index]; }

	void	gc_trace();
	void	collect() { delete this; }
	ScripterExport void	sprin1(CharStream* s);

	Value*	assign_vf(Value**arg_list, int count);
};

/* -------------------- FreeThunk  ------------------- */

class FreeThunk : public Thunk
{
public:
	int		level;		// how many levels to reach back
	int		index;		// index there
			FreeThunk(Value* init_name, int level, int index);
#	define	is_freethunk(p) ((p)->tag == INTERNAL_FREE_THUNK_TAG)

	ScripterExport Value* eval();
	void	gc_trace();
	void	collect() { delete this; }
	ScripterExport void	sprin1(CharStream* s);


	Value*	assign_vf(Value**arg_list, int count);
};

/* -------------------- ClosureFreeThunk  ------------------- */

class ClosureFreeThunk : public Thunk
{
public:
	ScripterExport Value* eval();

	void	gc_trace();
	void	collect() { delete this; }
	ScripterExport void	sprin1(CharStream* s);

			ClosureFreeThunk();
			~ClosureFreeThunk();
};

/* -------------------- PropertyThunk  ------------------- */

class PropertyThunk : public Thunk
{
public:
	Value*		target_code;	// code to eval to get target
	Value*		property_name;	// property name
	getter_vf	getter;			// getter virtual fn for built-in properties
	setter_vf	setter;			// setter    "     "       "        "

				PropertyThunk(Value* target, Value* prop_name);
				PropertyThunk(Value* target, Value* prop_name, getter_vf get_fn, setter_vf set_fn);

	void		gc_trace();
	void		collect() { delete this; }
	ScripterExport void sprin1(CharStream* s);
#	define		is_propertythunk(p) ((p)->tag == INTERNAL_PROP_THUNK_TAG)

	ScripterExport Value* eval();
	Value*		assign_vf(Value**arg_list, int count);
	Value*		op_assign_vf(Value**arg_list, int count);
};

// a PropThunk subclass that is used when a Prop access occurs in a function call
// this is basically a hack to support OLE client method calls, since OLE IDISPATCH
// cannot distinguish methods from props
class FnCallPropertyThunk : public PropertyThunk
{
public:
				FnCallPropertyThunk(Value* target, Value* prop_name, getter_vf get_fn, setter_vf set_fn) 
					: PropertyThunk (target, prop_name, get_fn, set_fn) {}
	void		collect() { delete this; }
	ScripterExport Value* eval();
};

#ifdef USE_PROPERTY_PATH_THUNKS
	/* PropertyPathThunk encodes a multi-level property access, such as $foo.twist.gizmo.pos.x
	 * in a single thunk so that MAXWrapper objects (and others that want) can look-ahead doing the whole path at once and
	 * not need backreferencing leaf-values for some of the funnier pseudo property accesses
	 * allowed in MAXScript */

	class PropertyPathThunk : public Thunk
	{
		Value*		target_code;	// code to eval to get target
		Array*		property_path;	// list of property names

	public:
					PropertyPathThunk(Value* target, Array* prop_path);

		void		gc_trace();
		void		collect() { delete this; }
		ScripterExport void sprin1(CharStream* s);

		Value*		append_property(Value* prop_name);

		ScripterExport Value* eval();
		Value*		assign_vf(Value**arg_list, int count);
	};
#endif

/* -------------------- IndexThunk  ------------------- */

class IndexThunk : public Thunk
{
	Value*		target_code;	// code to eval to get target
	Value*		index_code;		// code to eval to get index

public:
				IndexThunk(Value* index);

#	define		is_indexthunk(o)  ((o)->tag == INTERNAL_INDEX_THUNK_TAG)
	void		gc_trace();
	void		collect() { delete this; }
	ScripterExport void sprin1(CharStream* s);

	Value*		set_target(Value* targ) { target_code = targ; return this; }
	ScripterExport Value* eval();
	Value*		assign_vf(Value**arg_list, int count);
};

/* -------------------- RolloutControlThunk  ------------------- */

class RolloutControlThunk : public Thunk
{
public:
	int		index;
	Rollout* rollout;

			RolloutControlThunk(Value* name, int control_index, Rollout* rollout);
	BOOL	_is_rolloutthunk() { return 1; }
#	define	is_rolloutthunk(o) ((o)->_is_rolloutthunk())

	Value*	eval() { return rollout->controls[index]; }

	void ScripterExport gc_trace();
	void	collect() { delete this; }
	ScripterExport void	sprin1(CharStream* s);

	Value*	assign_vf(Value**arg_list, int count);
};

/* -------------------- RolloutLocalThunk  ------------------- */

class RolloutLocalThunk : public Thunk
{
public:
	int		index;
	Rollout* rollout;

			RolloutLocalThunk(Value* name, int control_index, Rollout* rollout);
	BOOL	_is_rolloutthunk() { return 1; }

	ScripterExport Value* eval();

	void	gc_trace();
	void	collect() { delete this; }
	ScripterExport void	sprin1(CharStream* s);

	Value*	assign_vf(Value**arg_list, int count);
};

class ConstRolloutLocalThunk : public RolloutLocalThunk
{
public:
			ConstRolloutLocalThunk(Value* name, int control_index, Rollout* rollout) 
				: RolloutLocalThunk(name, control_index, rollout) { }

	void	collect() { delete this; }

	Value*	assign_vf(Value**arg_list, int count) { throw AssignToConstError (this); return &undefined; }
};

/* -------------------- ToolLocalThunk  ------------------- */

class ToolLocalThunk : public Thunk
{
public:
	int			index;
	MouseTool*	tool;

			ToolLocalThunk(Value* name, int iindex, MouseTool* tool);

	ScripterExport Value* eval();

	void	gc_trace();
	void	collect() { delete this; }
	ScripterExport void	sprin1(CharStream* s);

	Value*	assign_vf(Value**arg_list, int count);
};

/* -------------------- CodeBlockLocalThunk  ------------------- */

class CodeBlock;

class CodeBlockLocalThunk : public Thunk
{
public:
	int			index;
	CodeBlock*	block;

			CodeBlockLocalThunk(Value* name, int iindex, CodeBlock* block);

	ScripterExport Value* eval();

	void	gc_trace();
	void	collect() { delete this; }
	ScripterExport void	sprin1(CharStream* s);

	Value*	assign_vf(Value**arg_list, int count);
};

/* -------------------- RCMenuItemThunk  ------------------- */

class RCMenuItemThunk : public Thunk
{
public:
	int			index;
	RCMenu*		rcmenu;

			RCMenuItemThunk(Value* name, int item_index, RCMenu* menu);
	BOOL	_is_rolloutthunk() { return 1; }
#	define	is_rcmenuthunk(o) ((o)->_is_rcmenuthunk())

	Value*	eval() { return rcmenu->items[index]; }

	void ScripterExport gc_trace();
	void	collect() { delete this; }
	ScripterExport void	sprin1(CharStream* s);

	Value*	assign_vf(Value**arg_list, int count);
};

/* -------------------- RCMenuLocalThunk  ------------------- */

class RCMenuLocalThunk : public Thunk
{
public:
	int			index;
	RCMenu*		rcmenu;

			RCMenuLocalThunk(Value* name, int iindex, RCMenu* menu);
	BOOL	_is_rcmenuthunk() { return 1; }

	ScripterExport Value* eval();

	void	gc_trace();
	void	collect() { delete this; }
	ScripterExport void	sprin1(CharStream* s);

	Value*	assign_vf(Value**arg_list, int count);
};

/* -------------------- PluginLocalThunk  ------------------- */

class PluginLocalThunk : public Thunk
{
public:
	int		index;    // access via current_plugin thread local
	BOOL	re_init;  // indicate whether this local needs re-initialization on a redefinition (say for local rollouts, fns, etc.)

			PluginLocalThunk(Value* name, int iindex, BOOL re_init = FALSE);
#	define	is_pluginlocalthunk(p) ((p)->tag == INTERNAL_PLUGIN_LOCAL_THUNK_TAG)

	ScripterExport Value* eval();

	void	collect() { delete this; }
	ScripterExport void	sprin1(CharStream* s);

	Value*	assign_vf(Value**arg_list, int count);
};

class ConstPluginLocalThunk : public PluginLocalThunk
{
public:
	ConstPluginLocalThunk(Value* name, int iindex, BOOL re_init = FALSE) : PluginLocalThunk(name, iindex, re_init) { }
	void	collect() { delete this; }
	Value*	assign_vf(Value**arg_list, int count) { throw AssignToConstError (this); return &undefined; }
};

/* -------------------- PluginParamThunk  ------------------- */

class PluginParamThunk : public Thunk
{
public:
			PluginParamThunk(Value* name);

	ScripterExport Value* eval();

	void	collect() { delete this; }
	ScripterExport void	sprin1(CharStream* s);

	Value*	assign_vf(Value**arg_list, int count);

	Value*	get_container_property(Value* prop, Value* cur_prop);
	Value*	set_container_property(Value* prop, Value* val, Value* cur_prop);
};

#define push_plugin(_pi)								\
	MSPlugin* _save_cp = thread_local(current_plugin);	\
	thread_local(current_plugin) = _pi;
	
#define pop_plugin()									\
	thread_local(current_plugin) = _save_cp;				

/* -------------------- StructMemberThunk  ------------------- */

class StructMemberThunk : public Thunk
{
public:
	int		index;    // access via current_plugin thread local

			StructMemberThunk(Value* name, int iindex);

	ScripterExport Value* eval();

	void	collect() { delete this; }
	ScripterExport void	sprin1(CharStream* s);

	Value*	assign_vf(Value**arg_list, int count);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\vectpro.h ===
/*	
 *		vector_protocol.h - def_generics for Vector protocol
 *
 *		see def_abstract_generics.h for more info.
 *
 *	
 *			Copyright  John Wainwright 1996
 *
 */

	use_generic( plus,		"+" );
	use_generic( minus,		"-" );
	use_generic( times,		"*" );
	use_generic( div,		"/" );
	use_generic( uminus,	"u-");

	use_generic( eq,		"=");
	use_generic( ne,		"!=");

	use_generic( random,	"random");

	def_visible_generic( length,	"length");
	def_visible_generic( dot,		"dot");
	def_visible_generic( cross,		"cross");
	def_visible_generic( normalize,	"normalize");
	def_visible_generic( distance,	"distance");
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\AudCont\auctrl.cpp ===
//***************************************************************************
//* Audio Amplitude Controller for 3D Studio MAX.
//* 
//* Code & design by Christer Janson
//* Autodesk European Developer Support - Neuchatel Switzerland
//* December 1995
//*

#include "io.h"
#include "auctrl.h"

HINSTANCE hInstance;
int controlsInit = FALSE;

BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) 
{
	hInstance = hinstDLL;

	if ( !controlsInit ) {
		controlsInit = TRUE;
		InitCustomControls(hInstance);
		InitCommonControls();
	}

	switch(fdwReason) {
		case DLL_PROCESS_ATTACH:
			break;
		case DLL_THREAD_ATTACH:
			break;
		case DLL_THREAD_DETACH:
			break;
		case DLL_PROCESS_DETACH:
			break;
	}

	return(TRUE);
}

__declspec( dllexport ) const TCHAR *LibDescription() 
{
	return GetString(IDS_CJ_LIBDESC);
}

__declspec( dllexport ) int LibNumberClasses()
{
	return 5;
}

__declspec( dllexport ) ClassDesc* LibClassDesc(int i)
{
	switch(i) {
		case 0: return GetAudioFloatDesc(); break;
		case 1: return GetAudioPoint3Desc(); break;
		case 2: return GetAudioPositionDesc(); break;
		case 3: return GetAudioRotationDesc(); break;
		case 4: return GetAudioScaleDesc(); break;
		default: return 0;
	}
}

__declspec( dllexport ) ULONG LibVersion()
{
	return VERSION_3DSMAX;
}

TCHAR *GetString(int id)
{
	static TCHAR buf[256];

	if(hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
}

AudioBaseControl::AudioBaseControl()
{
	wave = new WaveForm;
	rtwave = new RunTimeWave;
}

int AudioBaseControl::GetTrackVSpace(int lineHeight)
{
	int height = 1;

	if (!rtwave->IsRecording()) {
		height = 3;
	}

	return height;
}

AudioBaseControl::~AudioBaseControl()
{
	delete wave;
	delete rtwave;
}

class RangeRestore : public RestoreObj {
	public:
		AudioBaseControl *cont;
		Interval ur, rr;
		RangeRestore(AudioBaseControl *c) 
		{
			cont = c;
			ur   = cont->range;
		}   		
		void Restore(int isUndo) 
		{
			rr = cont->range;
			cont->range = ur;
			cont->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
		}
		void Redo()
		{
			cont->range = rr;
			cont->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
		}		
		void EndHold() 
		{ 
			cont->ClearAFlag(A_HELD);
		}
};

void AudioBaseControl::Hold()
{
	if (theHold.Holding() && !TestAFlag(A_HELD)) {
		SetAFlag(A_HELD);
		theHold.Put(new RangeRestore(this));
	}	
}

void AudioBaseControl::MapKeys( TimeMap *map, DWORD flags ) 
{
	Hold();
	range.Set(map->map(range.Start()), map->map(range.End())); 
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
}

int AudioBaseControl::PaintTrack(ParamDimensionBase *dim,HDC hdc,Rect& rcTrack,Rect& rcPaint,float zoom,int scroll,DWORD flags)
{
	HPEN penIn = CreatePen(PS_SOLID,0,RGB(0,0,200));
	HPEN Redpen = CreatePen(PS_SOLID,0,RGB(200,0,0));
	HPEN oldPen;

	int xl = rcPaint.left;
	int xr = rcPaint.right;
	int bot = rcPaint.bottom;
	int top = rcPaint.top;
	TimeValue tp, t;
	float val;
	float newmax;

	tp = ScreenToTime(xl-1,zoom,scroll) ;

	// Kludge to paint the waveform if min == max
	newmax = max;

	if (min == max) {
		newmax += 1.0f;
	}

	if (!rtwave->IsRecording()) {

		oldPen = (HPEN)SelectObject(hdc,penIn);

		for (; xl<=xr; xl++) {
			t   = ScreenToTime(xl,zoom,scroll) - range.Start();
			val	= SampleAtTime(t, quickdraw, TRUE);
			MoveToEx(hdc, xl, bot, NULL);
			LineTo(hdc, xl, (int)(bot + (val-min)/(newmax - min) * (top-bot)));
		}

		SelectObject(hdc,oldPen);
	}
	else {
		oldPen = (HPEN)SelectObject(hdc,Redpen);

		MoveToEx(hdc, xl, bot + (top - bot)/2, NULL);
		LineTo(hdc, xr, bot + (top - bot)/2);

		SelectObject(hdc,oldPen);
	}

	DeleteObject(penIn);
	DeleteObject(Redpen);
	
	return TRACK_DONE;
}

float AudioBaseControl::SampleAtTime(TimeValue t, int ignore_oversampling, int painting)
{
	double sampleTime;
	long sampleNo;
	int sample = 0;
	float normSample;
	WaveForm::Channel ch;
	int i;
	float divider;
    float minval, maxval;

    minval = min;
    maxval = max;
    if (painting && (min == max)) {
        if (minval == maxval) {
            maxval += 1.0f;
        }
    }
	
	if (rtwave->IsRecording())
		return (float)(abs(rtwave->GetSample(numsamples)))/128.0f * (maxval - minval) + minval;

	if (wave->IsEmpty()) {
		// Is a file assigned?
		if (szFilename.isNull()) {
			return minval;
		}
		else {
			// File not found, try looking.
			if (FixupFilename(szFilename, GetCOREInterface()->GetDir(APP_SOUND_DIR))) {
				// Initialize the WaveForm and load the audio stream
				wave->InitOpen(szFilename);
			}
			else {
				return minval;
			}
		}
	}

	sampleTime = t/4.8; // "Instant" in milliseconds
	sampleNo = (long)(sampleTime * wave->GetSamplesPerSec() / 1000);
	switch (channel) {
		case 0:
			ch = WaveForm::kLeftChannel;
			break;
		case 1:
			ch = WaveForm::kRightChannel;
			break;
		default:
			ch = WaveForm::kMixChannels;
			break;
	}

	if (ignore_oversampling) {
		sample = abs(wave->GetSample(sampleNo, ch));
	}
	else {
		// Smooth out the wave through oversampling
		for (i=0; i < numsamples; i++)
			sample += abs(wave->GetSample(sampleNo + i, ch));

        if (i != 0)
			sample = sample / i;
	}

	if (absolute)
		divider = (float)wave->GetMaxValue();
	else 
		divider = wave->GetBitsPerSample() == 8 ? 128.0f : 32768.0f;

	if (((float)sample)/divider < threshold)
		sample = 0;

	normSample = (float)(sample)/divider * (maxval - minval) + minval;

	return normSample;
}


BOOL AudioBaseControl::FixupFilename(TSTR &name,TCHAR *dir)
{
	TSTR pathName, fileName, newPathFile;

	// Check if file exist
	// Return ok if it does
	if (_access(name, 0) == 0)
		return TRUE;

	// If file does not exist, look for it in the specified directory
	SplitPathFile(name, &pathName, &fileName);
	if (dir[strlen(dir)-1] == '\\' ||  dir[strlen(dir)-1] == ':' || dir[strlen(dir)-1] == '/') {
		newPathFile = TSTR(dir) + TSTR(fileName);
	}
	else {
		newPathFile = TSTR(dir) + TSTR(_T("\\")) + TSTR(fileName);
	}

	if (_access(newPathFile, 0) == 0) {
		name = newPathFile;
		return TRUE;
	}

	return FALSE;
}

void AudioBaseControl::EnumAuxFiles(NameEnumCallback& nameEnum, DWORD flags)
{
	// No external file, do realtime recording.
	if (rtwave->IsRecording())
		return;

	if (szFilename.isNull())
		return;

	TSTR name = szFilename;

	if (FixupFilename(name, GetCOREInterface()->GetDir(APP_SOUND_DIR)))
		return;

	nameEnum.RecordName(szFilename);
}

void AudioBaseControl::Extrapolate(Interval range,TimeValue t,void *val,Interval &valid,int etype)
{
	if(type == AUDIO_FLOAT_CONTROL_CLASS_ID1) {
		float fval0, fval1, fval2, res;
		switch (etype) {
		case ORT_LINEAR:			
			if (t<range.Start()) {
				GetValueLocalTime(range.Start(),&fval0,valid);
				GetValueLocalTime(range.Start()+1,&fval1,valid);
				res = LinearExtrapolate(range.Start(),t,fval0,fval1,fval0);				
			} 
			else {
				GetValueLocalTime(range.End()-1,&fval0,valid);
				GetValueLocalTime(range.End(),&fval1,valid);
				res = LinearExtrapolate(range.End(),t,fval0,fval1,fval1);
			}
			break;

		case ORT_IDENTITY:
			if (t<range.Start()) {
				GetValueLocalTime(range.Start(),&fval0,valid);
				res = IdentityExtrapolate(range.Start(),t,fval0);
			} 
			else {
				GetValueLocalTime(range.End(),&fval0,valid);
				res = IdentityExtrapolate(range.End(),t,fval0);
			}
			break;

		case ORT_RELATIVE_REPEAT:
			GetValueLocalTime(range.Start(),&fval0,valid);
			GetValueLocalTime(range.End(),&fval1,valid);
			GetValueLocalTime(CycleTime(range,t),&fval2,valid);
			res = RepeatExtrapolate(range,t,fval0,fval1,fval2);			
			break;
		}
		valid.Set(t,t);
		*((float*)val) = res;
	}
	else if(type == AUDIO_SCALE_CONTROL_CLASS_ID1) {
		ScaleValue val0, val1, val2, res;
		switch (etype) {
		case ORT_LINEAR:			
			if (t<range.Start()) {
				GetValueLocalTime(range.Start(),&val0,valid);
				GetValueLocalTime(range.Start()+1,&val1,valid);
				res = LinearExtrapolate(range.Start(),t,val0,val1,val0);				
			} 
			else {
				GetValueLocalTime(range.End()-1,&val0,valid);
				GetValueLocalTime(range.End(),&val1,valid);
				res = LinearExtrapolate(range.End(),t,val0,val1,val1);
			}
			break;

		case ORT_IDENTITY:
			if (t<range.Start()) {
				GetValueLocalTime(range.Start(),&val0,valid);
				res = IdentityExtrapolate(range.Start(),t,val0);
			} 
			else {
				GetValueLocalTime(range.End(),&val0,valid);
				res = IdentityExtrapolate(range.End(),t,val0);
			}
			break;

		case ORT_RELATIVE_REPEAT:
			GetValueLocalTime(range.Start(),&val0,valid);
			GetValueLocalTime(range.End(),&val1,valid);
			GetValueLocalTime(CycleTime(range,t),&val2,valid);
			res = RepeatExtrapolate(range,t,val0,val1,val2);			
			break;
		}
		valid.Set(t,t);
		*((ScaleValue *)val) = res;
	}
	else {
		Point3 val0, val1, val2, res;
		switch (etype) {
		case ORT_LINEAR:			
			if (t<range.Start()) {
				GetValueLocalTime(range.Start(),&val0,valid);
				GetValueLocalTime(range.Start()+1,&val1,valid);
				res = LinearExtrapolate(range.Start(),t,val0,val1,val0);				
			} 
			else {
				GetValueLocalTime(range.End()-1,&val0,valid);
				GetValueLocalTime(range.End(),&val1,valid);
				res = LinearExtrapolate(range.End(),t,val0,val1,val1);
			}
			break;

		case ORT_IDENTITY:
			if (t<range.Start()) {
				GetValueLocalTime(range.Start(),&val0,valid);
				res = IdentityExtrapolate(range.Start(),t,val0);
			} 
			else {
				GetValueLocalTime(range.End(),&val0,valid);
				res = IdentityExtrapolate(range.End(),t,val0);
			}
			break;

		case ORT_RELATIVE_REPEAT:
			GetValueLocalTime(range.Start(),&val0,valid);
			GetValueLocalTime(range.End(),&val1,valid);
			GetValueLocalTime(CycleTime(range,t),&val2,valid);
			res = RepeatExtrapolate(range,t,val0,val1,val2);			
			break;
		}
		valid.Set(t,t);
		*((Point3 *)val) = res;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\AudCont\auctrl.h ===
//***************************************************************************
//* Audio Amplitude Float Controller for 3D Studio MAX.
//* 
//* Code & design by Christer Janson
//* Autodesk European Developer Support - Neuchatel Switzerland
//* December 1995
//*

#ifndef __AUCTRL__H
#define __AUCTRL__H

#include "Max.h"
#include "resource.h"
#include "wave.h"
#include "rtwave.h"

#define AUDIO_FLOAT_CONTROL_CNAME		GetString(IDS_CJ_FLOATCONTROL)
#define AUDIO_FLOAT_CONTROL_CLASS_ID1	0x2af81b7c
#define AUDIO_FLOAT_CONTROL_CLASS_ID2	0x5fbb7a86

#define AUDIO_POINT3_CONTROL_CNAME		GetString(IDS_CJ_POINT3CONTROL)
#define AUDIO_POINT3_CONTROL_CLASS_ID1	0x29964a18
#define AUDIO_POINT3_CONTROL_CLASS_ID2	0x3c3e77dc

#define AUDIO_POSITION_CONTROL_CNAME		GetString(IDS_CJ_POSITIONCONTROL)
#define AUDIO_POSITION_CONTROL_CLASS_ID1	0x4eef4cc2
#define AUDIO_POSITION_CONTROL_CLASS_ID2	0x5d975fac

#define AUDIO_ROTATION_CONTROL_CNAME		GetString(IDS_CJ_ROTATIONCONTROL)
#define AUDIO_ROTATION_CONTROL_CLASS_ID1	0x4e436d4b
#define AUDIO_ROTATION_CONTROL_CLASS_ID2	0x2f437701

#define AUDIO_SCALE_CONTROL_CNAME		GetString(IDS_CJ_SCALECONTROL)
#define AUDIO_SCALE_CONTROL_CLASS_ID1	0x38926eba
#define AUDIO_SCALE_CONTROL_CLASS_ID2	0x45c13f80

#define BASE_REFERENCE		0
#define TARGET_REFERENCE	1

extern ClassDesc* GetAudioFloatDesc();
extern ClassDesc* GetAudioPoint3Desc();
extern ClassDesc* GetAudioPositionDesc();
extern ClassDesc* GetAudioRotationDesc();
extern ClassDesc* GetAudioScaleDesc();

TCHAR *GetString(int id);

class AudioBaseControl : public StdControl {
	public:		
		int		type;	// Controller type
		Interval	range;

		// Directly mapped to user interface widgets
		int channel;
		int absolute;
		int numsamples;
		float threshold;
		int enableRuntime;
		TSTR szFilename;
		int quickdraw;

		// The wave objects
		WaveForm* wave;
		RunTimeWave* rtwave;
		
		// Used primary for the float controller, but also for internal use
		float min, max;

		AudioBaseControl();
		~AudioBaseControl();

		// Paint myself in TrackView
		int PaintTrack(ParamDimensionBase *dim,HDC hdc,Rect& rcTrack,Rect& rcPaint,float zoom,int scroll,DWORD flags);
		// Get a little more room in TrackView to paint the curve
		int GetTrackVSpace( int lineHeight );

		// Return the sample value at a specific time
		float SampleAtTime(TimeValue t, int ignore_oversampling, int painting);

		// Animatable methods		
		void DeleteThis() {delete this;}		
		int IsKeyable() {return 0;}		
		
		int TrackParamsType() {return TRACKPARAMS_WHOLE;}

		BOOL IsAnimated() { return TRUE; }
		BOOL IsLeaf() {return TRUE;}
		// Control methods				
		void Copy(Control *from) {}
		
		Interval GetTimeRange(DWORD flags) {return range;}
		void Hold();
		void MapKeys(TimeMap *map,DWORD flags );

		void Extrapolate(Interval range,TimeValue t,void *val,Interval &valid,int etype);

		// Fixup the path to a referenced sound file.
		BOOL FixupFilename(TSTR &name,TCHAR *dir);

		void EnumAuxFiles(NameEnumCallback& nameEnum, DWORD flags);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\Include\Maxscrpt\xrefspro.h ===
// xrefs_protocol.h - def_generics for XRefs protocol

	def_visible_generic	( merge_xref_file,			"merge");
	use_generic			( updateXRef,				"updateXRef");
	def_visible_generic	( flag_xref_changed,		"flagChanged");	
	use_generic			( delete,					"delete");
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\AudCont\aufloat.cpp ===
//***************************************************************************
//* Audio Amplitude Float Controller for 3D Studio MAX.
//* 
//* Code & design by Christer Janson
//* Autodesk European Developer Support - Neuchatel Switzerland
//* December 1995
//*

#include "auctrl.h"

extern HINSTANCE hInstance;
extern BOOL GetSoundFileName(HWND hWnd,TSTR &name,TSTR &dir); // CoreExport
extern BOOL CALLBACK AboutBoxDlgProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam);

class AudioFloatDlg;

class AudioFloatControl : public AudioBaseControl {
public:
	Class_ID ClassID() { return Class_ID(AUDIO_FLOAT_CONTROL_CLASS_ID1, AUDIO_FLOAT_CONTROL_CLASS_ID2); }  
	SClass_ID SuperClassID() { return CTRL_FLOAT_CLASS_ID; } 
	void GetClassName(TSTR& s) {s = AUDIO_FLOAT_CONTROL_CNAME;}

	// Remember the dialog object, we may need to close it
	AudioFloatDlg* pDlg;

	AudioFloatControl();
	~AudioFloatControl();

	IOResult Save(ISave *isave);
	IOResult Load(ILoad *iload);

	// Reference methods
	RefResult NotifyRefChanged(Interval, RefTargetHandle, PartID&, RefMessage) {return REF_SUCCEED;}
	void RefDeleted();
	RefTargetHandle Clone(RemapDir& remap);
	void Copy(Control *from);

	void EditTrackParams(TimeValue t, ParamDimensionBase *dim, TCHAR *pname,
		HWND hParent, IObjParam *ip, DWORD flags);

	void *CreateTempValue() {return new float;}
	void DeleteTempValue(void *val) {delete (float*)val;}
	void ApplyValue(void *val, void *delta) {*((float*)val) += *((float*)delta);}
	void MultiplyValue(void *val, float m) {*((float*)val) *= m;}

	void GetValueLocalTime(TimeValue t, void *val, Interval &valid, GetSetMethod method=CTRL_ABSOLUTE);
	void SetValueLocalTime(TimeValue t, void *val, int commit, GetSetMethod method);
};

class AudioFloatClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { return new AudioFloatControl(); }
	const TCHAR *	ClassName() { return AUDIO_FLOAT_CONTROL_CNAME; }
	SClass_ID		SuperClassID() { return CTRL_FLOAT_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(AUDIO_FLOAT_CONTROL_CLASS_ID1,AUDIO_FLOAT_CONTROL_CLASS_ID2); }
	const TCHAR* 	Category() { return _T("");  }
};

static AudioFloatClassDesc floatAudioCD;

ClassDesc* GetAudioFloatDesc()
{
	return &floatAudioCD;
}

static BOOL CALLBACK AudioFloatDlgProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

class AudioFloatDlg : public ReferenceMaker {
	public:
		AudioFloatControl *cont;
		ParamDimensionBase *dim;
		IObjParam *ip;
		HWND hWnd;
		BOOL valid;

		ISpinnerControl *iMin;
		ISpinnerControl *iMax;
		ISpinnerControl *iSamples;
		ISpinnerControl *iThreshold;

		AudioFloatDlg(AudioFloatControl *cont, ParamDimensionBase *dim, IObjParam *ip, HWND hParent);
		~AudioFloatDlg();

		void Update();
		void SetupUI(HWND hWnd);
		void Change();
		void WMCommand(int id, int notify, HWND hCtrl);
		void SpinnerChange(int id,BOOL drag);
		void SpinnerStart(int id);
		void SpinnerEnd(int id,BOOL cancel);
		void EnableChannelUI(BOOL state);

		RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, PartID& partID, RefMessage message);
		int NumRefs() {return 1;}
		RefTargetHandle GetReference(int i) {return cont;}
		void SetReference(int i, RefTargetHandle rtarg) {cont=(AudioFloatControl*)rtarg;}

		void SetActive();
		void ShowAbout(HWND hWnd);
};

AudioFloatDlg::AudioFloatDlg(AudioFloatControl *cont, ParamDimensionBase *dim,
	IObjParam *ip, HWND hParent)
{
	this->cont = cont;
	this->ip   = ip;
	this->dim  = dim;
	valid = FALSE;
	MakeRefByID(FOREVER,0,cont);
	hWnd = CreateDialogParam(
		hInstance,
		MAKEINTRESOURCE(IDD_AUDIOFLOATPARAMS),
		hParent,
		AudioFloatDlgProc,
		(LPARAM)this);
}

AudioFloatDlg::~AudioFloatDlg()
{
	DeleteAllRefsFromMe();
	ReleaseISpinner(iMin);
	ReleaseISpinner(iMax);
	ReleaseISpinner(iSamples);
	ReleaseISpinner(iThreshold);
}

void AudioFloatDlg::SetActive()
{
	SetActiveWindow(hWnd);
}

void AudioFloatDlg::EnableChannelUI(BOOL state)
{
	EnableWindow(GetDlgItem(hWnd, IDC_AUDAMP_LEFT), state);
	EnableWindow(GetDlgItem(hWnd, IDC_AUDAMP_RIGHT), state);
	EnableWindow(GetDlgItem(hWnd, IDC_AUDAMP_MIX), state);
}

void AudioFloatDlg::Update()
{
	if (!valid && hWnd) {
		iMin->SetValue(dim->Convert(cont->min),FALSE);
		iMax->SetValue(dim->Convert(cont->max),FALSE);
		iSamples->SetValue(cont->numsamples,FALSE);
		iThreshold->SetValue(cont->threshold,FALSE);
		if (!cont->szFilename.isNull())
			SendMessage(GetDlgItem(hWnd, IDC_AUDAMP_FILENAME), WM_SETTEXT, 0, (LPARAM)(char *)cont->szFilename);
		else
			SendMessage(GetDlgItem(hWnd, IDC_AUDAMP_FILENAME), WM_SETTEXT, 0, (LPARAM)GetString(IDS_CJ_NOFILE));
		CheckDlgButton(hWnd, IDC_AUDAMP_ABSOLUTE, cont->absolute == TRUE ? 1 : 0);
		CheckDlgButton(hWnd, IDC_QUICKDRAW, cont->quickdraw == TRUE ? 1 : 0);
		EnableChannelUI(cont->wave->GetNumChannels() == 2);

		switch (cont->channel) {
			case 0:
				CheckRadioButton(hWnd, IDC_AUDAMP_LEFT, IDC_AUDAMP_MIX, IDC_AUDAMP_LEFT);
				break;
			case 1:
				CheckRadioButton(hWnd, IDC_AUDAMP_LEFT, IDC_AUDAMP_MIX, IDC_AUDAMP_RIGHT);
				break;
			case 2:
				CheckRadioButton(hWnd, IDC_AUDAMP_LEFT, IDC_AUDAMP_MIX, IDC_AUDAMP_MIX);
				break;
		}
		valid = TRUE;
	}
}

// Called to initialize the dialog box
void AudioFloatDlg::SetupUI(HWND hWnd)
{
	this->hWnd = hWnd;

	// Get hold of, and setup, any available recording device.
	if (cont->rtwave->m_nNumDevices > 0) {
		for (int i = 0; i< cont->rtwave->m_nNumDevices; i++) {
			SendMessage(GetDlgItem(hWnd, IDC_AUDAMP_RECDEVICE), CB_ADDSTRING, 0, (LPARAM)cont->rtwave->m_pDevCaps[i].szPname);
		}
	}
	else {
		SendMessage(GetDlgItem(hWnd, IDC_AUDAMP_RECDEVICE), CB_ADDSTRING, 0, (LPARAM)GetString(IDS_CJ_NODEVICE));
		EnableWindow(GetDlgItem(hWnd, IDC_AUDAMP_RECDEVICE), 0);
		EnableWindow(GetDlgItem(hWnd, IDC_AUDAMP_RECENABLE), 0);
	}

	// Set recording device to first item (Will be "none" if no device)
	SendMessage(GetDlgItem(hWnd, IDC_AUDAMP_RECDEVICE), CB_SETCURSEL, 0, 0);
	cont->rtwave->SetDevice(0);

	// If we are currently recording we check the box
	if (cont->rtwave->IsRecording()) {
		SendMessage(GetDlgItem(hWnd, IDC_AUDAMP_RECDEVICE), CB_SETCURSEL, cont->rtwave->GetDevice(), 0);
		EnableWindow(GetDlgItem(hWnd, IDC_AUDAMP_RECDEVICE), 0);
		CheckDlgButton(hWnd, IDC_AUDAMP_RECENABLE, 1);
	}

	// Setup limits and type of the spinners.
	iMin = GetISpinner(GetDlgItem(hWnd,IDC_AUDAMP_MINSPIN));
	iMin->SetLimits(-9999999,9999999,FALSE);
	iMin->SetAutoScale();
	iMin->LinkToEdit(GetDlgItem(hWnd,IDC_AUDAMP_MIN),EDITTYPE_FLOAT);		

	iMax = GetISpinner(GetDlgItem(hWnd,IDC_AUDAMP_MAXSPIN));
	iMax->SetLimits(-9999999,9999999,FALSE);
	iMax->SetAutoScale();
	iMax->LinkToEdit(GetDlgItem(hWnd,IDC_AUDAMP_MAX),EDITTYPE_FLOAT);		

	iSamples = GetISpinner(GetDlgItem(hWnd,IDC_AUDAMP_NUMSAMPLESSPIN));
	iSamples->SetLimits(1,1000,FALSE);
	iSamples->SetAutoScale();
	iSamples->LinkToEdit(GetDlgItem(hWnd,IDC_AUDAMP_NUMSAMPLES),EDITTYPE_INT);

	iThreshold = GetISpinner(GetDlgItem(hWnd,IDC_AUDAMP_THRESHOLDSPIN));
	iThreshold->SetLimits(0,1,FALSE);
	iThreshold->SetAutoScale();
	iThreshold->LinkToEdit(GetDlgItem(hWnd,IDC_AUDAMP_THRESHOLD),EDITTYPE_FLOAT);

	valid = FALSE;
	Update();
}

// Handle WM_COMMAND messages separately
void AudioFloatDlg::WMCommand(int id, int notify, HWND hCtrl)
{
	int mmerr;

	switch (id) {
		case IDC_AUDAMP_ABSOLUTE:
			cont->absolute = IsDlgButtonChecked(hWnd,id);
			Change();
			break;
		case IDC_QUICKDRAW:
			cont->quickdraw = IsDlgButtonChecked(hWnd,id);
			Change();
			break;
		case IDC_AUDAMP_RECDEVICE:
			if (notify == CBN_SELCHANGE) {
				int devIdx = SendMessage(GetDlgItem(hWnd, IDC_AUDAMP_RECDEVICE), CB_GETCURSEL, 0, 0);
				cont->rtwave->SetDevice(devIdx);
				Change();
			}
			break;
		case IDC_AUDAMP_RECENABLE:
			cont->enableRuntime = IsDlgButtonChecked(hWnd,id);
			// Startup or terminate runtime recording
			if (cont->enableRuntime) {
				if ((mmerr = cont->rtwave->StartRecording()) == 0) {
					EnableWindow(GetDlgItem(hWnd, IDC_AUDAMP_RECDEVICE), 0);
				}
				else {
					CheckDlgButton(hWnd, id, 0);
					MessageBox(hWnd, GetString(IDS_CJ_DEVICE_BUSY), GetString(IDS_CJ_PROGNAME), MB_OK);
				}
			} 
			else {
				cont->rtwave->StopRecording();
				EnableWindow(GetDlgItem(hWnd, IDC_AUDAMP_RECDEVICE), 1);
			}

			// Here we are just telling trackview to repaint its hierarchy.
			// We haven't actually changed cnything, but the switch from file to record
			// will cause a change in TrackView line height - and we need to tell that
			// to TrackView
			cont->NotifyDependents(FOREVER,PART_ALL,REFMSG_SUBANIM_STRUCTURE_CHANGED);

			Change();
			break;
		case IDC_BTN_BROWSE: {
				// Changed to open in the directory of the file. //CJ
				TSTR dir = cont->szFilename;
				if (dir.Length() == 0) {
					// Use sound dir if no file.
					dir = TSTR(ip->GetDir(APP_SOUND_DIR));
				}
				else {
					int lc = dir.last((int)'\\');
					if (lc == -1) {
						lc = dir.last((int)'/');
					}
					if (lc != -1) {
						dir[lc] = '\0';
					}
				}
				// Brings up file dialog box with sound "preview".
				GetSoundFileName(hCtrl, cont->szFilename, dir);

				if (!cont->szFilename.isNull()) {
					cont->wave->InitOpen(cont->szFilename);
					SendMessage(GetDlgItem(hWnd, IDC_AUDAMP_FILENAME), WM_SETTEXT, 0, (LPARAM)((char *)cont->szFilename));
					EnableChannelUI(cont->wave->GetNumChannels() == 2);
				}
				Change();
			}
			break;
		case IDC_BTN_REMOVESOUND:
			cont->wave->FreeSample();
			cont->szFilename = "";
			SendMessage(GetDlgItem(hWnd, IDC_AUDAMP_FILENAME), WM_SETTEXT, 0, (LPARAM)"");
			EnableChannelUI(FALSE);
			Change();
			break;
		case IDC_AUDAMP_LEFT:
			cont->channel = 0;
			Change();
			break;
		case IDC_AUDAMP_RIGHT:
			cont->channel = 1;
			Change();
			break;
		case IDC_AUDAMP_MIX:
			cont->channel = 2;
			Change();
			break;
		case IDC_ABOUT:
			ShowAbout(hWnd);
			break;
		case IDC_CLOSE:
			DestroyWindow(hWnd);
			break;
	}
}

// Handle spinners in the dialog box
void AudioFloatDlg::SpinnerChange(int id,BOOL drag)
{
	switch (id) {
		case IDC_AUDAMP_MINSPIN:
			cont->min = dim->UnConvert(iMin->GetFVal());
			Change();
			break;
		case IDC_AUDAMP_MAXSPIN:
			cont->max = dim->UnConvert(iMax->GetFVal());
			Change();
			break;
		case IDC_AUDAMP_NUMSAMPLESSPIN:
			cont->numsamples = iSamples->GetIVal();
			Change();
			break;
		case IDC_AUDAMP_THRESHOLDSPIN:
			cont->threshold = iThreshold->GetFVal();
			Change();
			break;
		}
	ip->RedrawViews(ip->GetTime());
	}
 
void AudioFloatDlg::SpinnerStart(int id)
{
}

void AudioFloatDlg::SpinnerEnd(int id,BOOL cancel)
{
	ip->RedrawViews(ip->GetTime());
}

void AudioFloatDlg::Change()
{
	cont->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	UpdateWindow(GetParent(hWnd));	
}

RefResult AudioFloatDlg::NotifyRefChanged(Interval changeInt, 
	RefTargetHandle hTarget, PartID& partID, RefMessage message)
{
	switch (message) {
		case REFMSG_CHANGE:
			break;
	}
	return REF_SUCCEED;
}

// Dialog box procedure for user interface dialog.
static BOOL CALLBACK AudioFloatDlgProc(HWND hWnd, UINT msg, WPARAM wParam,
	LPARAM lParam)
{
	AudioFloatDlg *dlg = (AudioFloatDlg*)GetWindowLong(hWnd,GWL_USERDATA);

	switch (msg) {
		case WM_INITDIALOG:
			dlg = (AudioFloatDlg*)lParam;
			SetWindowLong(hWnd,GWL_USERDATA,lParam);
			// Initialize spinners etc.
			dlg->SetupUI(hWnd);
			break;

		case CC_SPINNER_BUTTONDOWN:
			dlg->SpinnerStart(LOWORD(wParam));
			break;

		case CC_SPINNER_CHANGE:
			dlg->SpinnerChange(LOWORD(wParam),HIWORD(wParam));
			break;

		case CC_SPINNER_BUTTONUP:
			dlg->SpinnerEnd(LOWORD(wParam),!HIWORD(wParam));
			break;

		case WM_COMMAND:
			// Handle these separately
			dlg->WMCommand(LOWORD(wParam),HIWORD(wParam),(HWND)lParam);						
			break;

		case WM_PAINT:
			dlg->Update();
			return 0;			
		
		case WM_CLOSE:
			DestroyWindow(hWnd);			
			break;

		case WM_DESTROY:
			// The controller needs to know when the dialog object is deleted
			dlg->cont->pDlg = NULL;						
			delete dlg;
			break;
		
		default:
			return FALSE;
	}
	return TRUE;
}

void AudioFloatDlg::ShowAbout(HWND hWnd)	{
	DialogBoxParam(
		hInstance,
		MAKEINTRESOURCE(IDD_ABOUTBOX),
		hWnd,
		(DLGPROC)AboutBoxDlgProc,
		(LPARAM)this);
}

void AudioFloatControl::EditTrackParams(TimeValue t, ParamDimensionBase *dim,
	TCHAR *pname, HWND hParent, IObjParam *ip, DWORD flags)
{
	// Create and open the dialog box
	if (!pDlg)
		pDlg = new AudioFloatDlg(this,dim,ip,hParent);
	else 
		pDlg->SetActive();
}

AudioFloatControl::AudioFloatControl() 
{
	pDlg = NULL;
	type = AUDIO_FLOAT_CONTROL_CLASS_ID1;
	range = Interval(GetAnimStart(),GetAnimEnd());
	channel = 2;
	absolute = 0;
	min = 0.0f;
	max = 1.0f;
	numsamples = 1;
	threshold = 0.0f;
	quickdraw = 0;
} 

AudioFloatControl::~AudioFloatControl()
{
}


void AudioFloatControl::Copy(Control* from)
{
	float fval;

	if (from->ClassID() == ClassID()) {
		min = ((AudioFloatControl*)from)->min;
		max = ((AudioFloatControl*)from)->max;
	}
	else {
		from->GetValue(0, &fval, Interval(0,0));
		min = fval;
		max = fval;
	}
}


RefTargetHandle AudioFloatControl::Clone(RemapDir& remap)
{
	// make a new AudioFloat controller and give it our param values.
	// TBD: Param values!?
	AudioFloatControl *cont = new AudioFloatControl;
	// *cont = *this;
	cont->type = type;
	cont->range = range;
	cont->channel = channel;
	cont->absolute = absolute;
	cont->numsamples = numsamples;
	cont->enableRuntime = enableRuntime;
	cont->szFilename = szFilename;
	cont->quickdraw = quickdraw;
	cont->min = min;
	cont->max = max;


	return cont;
}

// When the last reference to a controller is
// deleted we need to close the realtime recording device and 
// its parameter dialog needs to be closed
void AudioFloatControl::RefDeleted()
{
	int c=0;
	RefListItem  *ptr = GetRefList().first;
	while (ptr) {
		if (ptr->maker!=NULL) {
			if (ptr->maker->SuperClassID()) c++;
		}
		ptr = ptr->next;
	}	
	if (!c) {
		// Stop the real-time recording is the object is deleted.
		if (rtwave->IsRecording())
			rtwave->StopRecording();

		if (pDlg != NULL)
			DestroyWindow(pDlg->hWnd);
	}
}


#define MIN_CHUNK			0x0100
#define MAX_CHUNK			0x0101
#define ABSOLUTE_CHUNK		0x0103
#define FILENAME_CHUNK		0x0104
#define NUMSAMPLES_CHUNK	0x0105
#define CHANNEL_CHUNK		0x0106
#define RANGE_CHUNK			0x0107
#define THRESHOLD_CHUNK		0x010A
#define QUICKDRAW_CHUNK		0x010C

// Save the controller data
IOResult AudioFloatControl::Save(ISave *isave)
{
	ULONG nb;

	Control::Save(isave);	// Handle ORT's

	isave->BeginChunk(MIN_CHUNK);
	isave->Write(&min,sizeof(min),&nb);
	isave->EndChunk();

	isave->BeginChunk(MAX_CHUNK);
	isave->Write(&max,sizeof(max),&nb);
	isave->EndChunk();

	isave->BeginChunk(ABSOLUTE_CHUNK);
	isave->Write(&absolute,sizeof(absolute),&nb);
	isave->EndChunk();

	isave->BeginChunk(CHANNEL_CHUNK);
	isave->Write(&channel,sizeof(channel),&nb);
	isave->EndChunk();

	isave->BeginChunk(FILENAME_CHUNK);
	isave->WriteWString((TCHAR*)szFilename);
	isave->EndChunk();

	isave->BeginChunk(NUMSAMPLES_CHUNK);
	isave->Write(&numsamples,sizeof(numsamples),&nb);
	isave->EndChunk();

	isave->BeginChunk(RANGE_CHUNK);
	isave->Write(&range,sizeof(range),&nb);
	isave->EndChunk();

	isave->BeginChunk(THRESHOLD_CHUNK);
	isave->Write(&threshold,sizeof(threshold),&nb);
	isave->EndChunk();

	isave->BeginChunk(QUICKDRAW_CHUNK);
	isave->Write(&quickdraw,sizeof(quickdraw),&nb);
	isave->EndChunk();

	return IO_OK;
}

// Load controller data
IOResult AudioFloatControl::Load(ILoad *iload)
{
	ULONG nb;
	IOResult res = IO_OK;

	Control::Load(iload);	// Handle ORT's

	while (IO_OK==(res=iload->OpenChunk())) {
		switch (iload->CurChunkID()) {
			case MIN_CHUNK:
				res=iload->Read(&min,sizeof(min),&nb);
				break;

			case MAX_CHUNK:
				res=iload->Read(&max,sizeof(max),&nb);
				break;

			case ABSOLUTE_CHUNK:
				res=iload->Read(&absolute,sizeof(absolute),&nb);
				break;

			case CHANNEL_CHUNK:
				res=iload->Read(&channel,sizeof(channel),&nb);
				break;

			case FILENAME_CHUNK: {
				wchar_t *buf = NULL;
				res=iload->ReadWStringChunk(&buf);
				szFilename = buf;
				if (!szFilename.isNull()) {
					if (FixupFilename(szFilename, iload->GetDir(APP_SOUND_DIR))) {
						// Initialize the WaveForm and load the audio stream
						wave->InitOpen(szFilename);
					}
				}
				break;
				}
			case NUMSAMPLES_CHUNK:
				res=iload->Read(&numsamples,sizeof(numsamples),&nb);
				break;

			case RANGE_CHUNK:
				res=iload->Read(&range,sizeof(range),&nb);
				break;
			case THRESHOLD_CHUNK:
				res=iload->Read(&threshold,sizeof(threshold),&nb);
				break;
			case QUICKDRAW_CHUNK:
				res=iload->Read(&quickdraw,sizeof(quickdraw),&nb);
				break;
		}

		iload->CloseChunk();
		if (res!=IO_OK)  return res;
	}
	return IO_OK;
}

// Return the value at a specific instant in time
void AudioFloatControl::GetValueLocalTime(TimeValue t, void *val, Interval &valid,
	GetSetMethod method)
{
	valid.SetInstant(t); // This controller is always changing.

	// Subtract start of range from this time to get the 'local' wave time.
	*((float*)val) = SampleAtTime(t - range.Start(), 0, FALSE);
}

// TBD: Not appropriate for this controller.
void AudioFloatControl::SetValueLocalTime(TimeValue t, void *val, int commit, GetSetMethod method)
{
}

BOOL CALLBACK AboutDlgProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam)	{
	switch (message) {
		case WM_INITDIALOG:
			CenterWindow(hWnd,GetParent(hWnd));
			SetCursor(LoadCursor(NULL,IDC_ARROW));
			return 1;
		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDOK:				  
				case IDCANCEL:
					EndDialog(hWnd,1);
					break;
			}
			return 1;
	}
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\AudCont\aup3base.h ===
//***************************************************************************
//* Audio Amplitude Float Controller for 3D Studio MAX.
//*	Base class for all "3 point" controllers
//* 
//* Code & design by Christer Janson
//* Autodesk European Developer Support - Neuchatel Switzerland
//* December 1995
//*
class AudioP3Dlg;

class AudioP3Control : public AudioBaseControl {
public:
	Point3 basePoint;
	Point3 targetPoint;

	AudioP3Dlg* pDlg;

	AudioP3Control();
	~AudioP3Control();

	IOResult Save(ISave *isave);
	IOResult Load(ILoad *iload);

	// Reference methods
	RefResult NotifyRefChanged(Interval, RefTargetHandle, PartID&, RefMessage) {return REF_SUCCEED;}

	void EditTrackParams(TimeValue t, ParamDimensionBase *dim, TCHAR *pname,
		HWND hParent, IObjParam *ip, DWORD flags);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\AudCont\aup3base.cpp ===
//***************************************************************************
//* Audio Amplitude Controller for 3D Studio MAX.
//*	Base class for all "point 3" based controllers
//* 
//* Code & design by Christer Janson
//* Autodesk European Developer Support - Neuchatel Switzerland
//* December 1995
//*

#include "auctrl.h"
#include "aup3base.h"
#include "aup3dlg.h"


extern HINSTANCE hInstance;
extern BOOL GetSoundFileName(HWND hWnd,TSTR &name,TSTR &dir); // From MAX

AudioP3Control::AudioP3Control() 
{
	pDlg = NULL;
	range = Interval(GetAnimStart(),GetAnimEnd());
	channel = 2;
	absolute = 0;
	min = 0.0f;
	max = 1.0f;
	numsamples = 1;
	threshold = 0.0f;
	enableRuntime = 0;
	quickdraw = 0;
} 

AudioP3Control::~AudioP3Control()
{
}

#define MIN_CHUNK			0x0100
#define MAX_CHUNK			0x0101
#define ABSOLUTE_CHUNK		0x0103
#define FILENAME_CHUNK		0x0104
#define NUMSAMPLES_CHUNK	0x0105
#define CHANNEL_CHUNK		0x0106
#define RANGE_CHUNK			0x0107
#define BASE_CHUNK			0x0108
#define TARGET_CHUNK		0x0109
#define THRESHOLD_CHUNK		0x010A
#define RUNTIME_CHUNK		0x010B
#define QUICKDRAW_CHUNK		0x010C

// Save the controller data
IOResult AudioP3Control::Save(ISave *isave)
{
	ULONG nb;

	Control::Save(isave);	// Handle ORT's

	isave->BeginChunk(BASE_CHUNK);
	isave->Write(&basePoint,sizeof(basePoint),&nb);
	isave->EndChunk();

	isave->BeginChunk(TARGET_CHUNK);
	isave->Write(&targetPoint,sizeof(targetPoint),&nb);
	isave->EndChunk();

	isave->BeginChunk(ABSOLUTE_CHUNK);
	isave->Write(&absolute,sizeof(absolute),&nb);
	isave->EndChunk();

	isave->BeginChunk(CHANNEL_CHUNK);
	isave->Write(&channel,sizeof(channel),&nb);
	isave->EndChunk();

	isave->BeginChunk(FILENAME_CHUNK);
	isave->WriteWString((TCHAR*)szFilename);
	isave->EndChunk();

	isave->BeginChunk(NUMSAMPLES_CHUNK);
	isave->Write(&numsamples,sizeof(numsamples),&nb);
	isave->EndChunk();

	isave->BeginChunk(RANGE_CHUNK);
	isave->Write(&range,sizeof(range),&nb);
	isave->EndChunk();

	isave->BeginChunk(THRESHOLD_CHUNK);
	isave->Write(&threshold,sizeof(threshold),&nb);
	isave->EndChunk();

	isave->BeginChunk(RUNTIME_CHUNK);
	isave->Write(&enableRuntime,sizeof(enableRuntime),&nb);
	isave->EndChunk();

	isave->BeginChunk(QUICKDRAW_CHUNK);
	isave->Write(&quickdraw,sizeof(quickdraw),&nb);
	isave->EndChunk();

	return IO_OK;
}

// Load the controller data
IOResult AudioP3Control::Load(ILoad *iload)
{
	ULONG nb;
	IOResult res = IO_OK;

	Control::Load(iload);	// Handle ORT's

	while (IO_OK==(res=iload->OpenChunk())) {
		switch (iload->CurChunkID()) {
			case BASE_CHUNK:
				res=iload->Read(&basePoint,sizeof(basePoint),&nb);
				break;

			case TARGET_CHUNK:
				res=iload->Read(&targetPoint,sizeof(targetPoint),&nb);
				break;

			case ABSOLUTE_CHUNK:
				res=iload->Read(&absolute,sizeof(absolute),&nb);
				break;

			case CHANNEL_CHUNK:
				res=iload->Read(&channel,sizeof(channel),&nb);
				break;

			case FILENAME_CHUNK: {
				wchar_t *buf = NULL;
				res=iload->ReadWStringChunk(&buf);
				szFilename = buf;
				if (!szFilename.isNull()) {
					if (FixupFilename(szFilename, iload->GetDir(APP_SOUND_DIR))) {
						// Initialize the WaveForm and load the audio stream
						wave->InitOpen(szFilename);
					}
				}
				break;
				}
			case NUMSAMPLES_CHUNK:
				res=iload->Read(&numsamples,sizeof(numsamples),&nb);
				break;

			case RANGE_CHUNK:
				res=iload->Read(&range,sizeof(range),&nb);
				break;

			case THRESHOLD_CHUNK:
				res=iload->Read(&threshold,sizeof(threshold),&nb);
				break;

			case RUNTIME_CHUNK:
				res=iload->Read(&enableRuntime,sizeof(enableRuntime),&nb);
				break;
			case QUICKDRAW_CHUNK:
				res=iload->Read(&quickdraw,sizeof(quickdraw),&nb);
				break;

		}

		iload->CloseChunk();
		if (res!=IO_OK)  return res;
	}
	return IO_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\AudCont\aup3dlg.cpp ===
//***************************************************************************
//* Audio Amplitude Controller for 3D Studio MAX.
//* Dialogue box class for "3 point" controllers
//* 
//* Code & design by Christer Janson
//* Autodesk European Developer Support - Neuchatel Switzerland
//* December 1995
//*
#include "auctrl.h"
#include "aup3base.h"
#include "aup3dlg.h"

extern HINSTANCE hInstance;
extern BOOL GetSoundFileName(HWND hWnd,TSTR &name,TSTR &dir); // CoreExport

AudioP3Dlg::AudioP3Dlg(AudioP3Control *cont, ParamDimensionBase *dim,
	IObjParam *ip, HWND hParent)
{
	this->cont = cont;
	this->ip   = ip;
	this->dim  = dim;

	valid = FALSE;
	// Create a reference to the controller
	MakeRefByID(FOREVER,0,cont);
	// Create the dialog box
	hWnd = CreateDialogParam(
		hInstance,
		MAKEINTRESOURCE(IDD_AUDIOPOINT3PARAMS),
		hParent,
		AudioP3DlgProc,
		(LPARAM)this);
}

AudioP3Dlg::~AudioP3Dlg()
{
	DeleteAllRefsFromMe();
	ReleaseISpinner(iBaseX);
	ReleaseISpinner(iBaseY);
	ReleaseISpinner(iBaseZ);
	ReleaseISpinner(iTargetX);
	ReleaseISpinner(iTargetY);
	ReleaseISpinner(iTargetZ);
	ReleaseISpinner(iSamples);
	ReleaseISpinner(iThreshold);
}

// Helper for user interface. Enable channel for stereo sound
void AudioP3Dlg::EnableChannelUI(BOOL state)
{
	EnableWindow(GetDlgItem(hWnd, IDC_AUDAMP_LEFT), state);
	EnableWindow(GetDlgItem(hWnd, IDC_AUDAMP_RIGHT), state);
	EnableWindow(GetDlgItem(hWnd, IDC_AUDAMP_MIX), state);
}

void AudioP3Dlg::SetActive()
{
	SetActiveWindow(hWnd);
}

void AudioP3Dlg::Update()
{
	if (!valid && hWnd) {
		iBaseX->SetValue(dim->Convert(cont->basePoint.x),FALSE);
		iBaseY->SetValue(dim->Convert(cont->basePoint.y),FALSE);
		iBaseZ->SetValue(dim->Convert(cont->basePoint.z),FALSE);
		iTargetX->SetValue(dim->Convert(cont->targetPoint.x),FALSE);
		iTargetY->SetValue(dim->Convert(cont->targetPoint.y),FALSE);
		iTargetZ->SetValue(dim->Convert(cont->targetPoint.z),FALSE);
		iSamples->SetValue(cont->numsamples,FALSE);
		iThreshold->SetValue(cont->threshold,FALSE);
		if (!cont->szFilename.isNull())
			SendMessage(GetDlgItem(hWnd, IDC_AUDAMP_FILENAME), WM_SETTEXT, 0, (LPARAM)(char *)cont->szFilename);
		else
			SendMessage(GetDlgItem(hWnd, IDC_AUDAMP_FILENAME), WM_SETTEXT, 0, (LPARAM)GetString(IDS_CJ_NOFILE));
		CheckDlgButton(hWnd, IDC_AUDAMP_ABSOLUTE, cont->absolute == TRUE ? 1 : 0);
		CheckDlgButton(hWnd, IDC_QUICKDRAW, cont->quickdraw == TRUE ? 1 : 0);
		// Enable channel UI if we are stereo
		EnableChannelUI(cont->wave->GetNumChannels() == 2);
		switch (cont->channel) {
			case 0:
				CheckRadioButton(hWnd, IDC_AUDAMP_LEFT, IDC_AUDAMP_MIX, IDC_AUDAMP_LEFT);
				break;
			case 1:
				CheckRadioButton(hWnd, IDC_AUDAMP_LEFT, IDC_AUDAMP_MIX, IDC_AUDAMP_RIGHT);
				break;
			case 2:
				CheckRadioButton(hWnd, IDC_AUDAMP_LEFT, IDC_AUDAMP_MIX, IDC_AUDAMP_MIX);
				break;
		}
		valid = TRUE;
	}
}

void AudioP3Dlg::SetupUI(HWND hWnd)
{
	this->hWnd = hWnd;

	// Get hold of, and setup, any available recording device.
	if (cont->rtwave->m_nNumDevices > 0) {
		for (int i = 0; i< cont->rtwave->m_nNumDevices; i++) {
			SendMessage(GetDlgItem(hWnd, IDC_AUDAMP_RECDEVICE), CB_ADDSTRING, 0, (LPARAM)cont->rtwave->m_pDevCaps[i].szPname);
		}
	}
	else {
		SendMessage(GetDlgItem(hWnd, IDC_AUDAMP_RECDEVICE), CB_ADDSTRING, 0, (LPARAM)GetString(IDS_CJ_NODEVICE));
		EnableWindow(GetDlgItem(hWnd, IDC_AUDAMP_RECDEVICE), 0);
		EnableWindow(GetDlgItem(hWnd, IDC_AUDAMP_RECENABLE), 0);
	}

	// Set recording device to first item (Will be "none" if no device)
	SendMessage(GetDlgItem(hWnd, IDC_AUDAMP_RECDEVICE), CB_SETCURSEL, 0, 0);
	cont->rtwave->SetDevice(0);

	// If we are currently recording we check the box
	if (cont->rtwave->IsRecording()) {
		SendMessage(GetDlgItem(hWnd, IDC_AUDAMP_RECDEVICE), CB_SETCURSEL, cont->rtwave->GetDevice(), 0);
		EnableWindow(GetDlgItem(hWnd, IDC_AUDAMP_RECDEVICE), 0);
		CheckDlgButton(hWnd, IDC_AUDAMP_RECENABLE, 1);
	}

	// Change label if we are Scale or Rotation controllers
	if (cont->type == AUDIO_SCALE_CONTROL_CLASS_ID1) {
		SendMessage(GetDlgItem(hWnd, IDC_BASEFRAME), WM_SETTEXT, 0, (LPARAM)GetString(IDS_CJ_BASESCALE));
		SendMessage(GetDlgItem(hWnd, IDC_TARGETFRAME), WM_SETTEXT, 0, (LPARAM)GetString(IDS_CJ_TARGETSCALE));
	}
	else if (cont->type == AUDIO_ROTATION_CONTROL_CLASS_ID1) {
		SendMessage(GetDlgItem(hWnd, IDC_BASEFRAME), WM_SETTEXT, 0, (LPARAM)GetString(IDS_CJ_BASEANGLE));
		SendMessage(GetDlgItem(hWnd, IDC_TARGETFRAME), WM_SETTEXT, 0, (LPARAM)GetString(IDS_CJ_TARGETANGLE));
	}

	// Setup limits and type of the spinners.
	iBaseX = GetISpinner(GetDlgItem(hWnd,IDC_AUDAMP_BASEXSPIN));
	iBaseX->SetLimits(-9999999,9999999,FALSE);
	iBaseX->SetAutoScale();
	iBaseX->LinkToEdit(GetDlgItem(hWnd,IDC_AUDAMP_BASEX),EDITTYPE_FLOAT);		

	iBaseY = GetISpinner(GetDlgItem(hWnd,IDC_AUDAMP_BASEYSPIN));
	iBaseY->SetLimits(-9999999,9999999,FALSE);
	iBaseY->SetAutoScale();
	iBaseY->LinkToEdit(GetDlgItem(hWnd,IDC_AUDAMP_BASEY),EDITTYPE_FLOAT);		

	iBaseZ = GetISpinner(GetDlgItem(hWnd,IDC_AUDAMP_BASEZSPIN));
	iBaseZ->SetLimits(-9999999,9999999,FALSE);
	iBaseZ->SetAutoScale();
	iBaseZ->LinkToEdit(GetDlgItem(hWnd,IDC_AUDAMP_BASEZ),EDITTYPE_FLOAT);		

	iTargetX = GetISpinner(GetDlgItem(hWnd,IDC_AUDAMP_TARGETXSPIN));
	iTargetX->SetLimits(-9999999,9999999,FALSE);
	iTargetX->SetAutoScale();
	iTargetX->LinkToEdit(GetDlgItem(hWnd,IDC_AUDAMP_TARGETX),EDITTYPE_FLOAT);		

	iTargetY = GetISpinner(GetDlgItem(hWnd,IDC_AUDAMP_TARGETYSPIN));
	iTargetY->SetLimits(-9999999,9999999,FALSE);
	iTargetY->SetAutoScale();
	iTargetY->LinkToEdit(GetDlgItem(hWnd,IDC_AUDAMP_TARGETY),EDITTYPE_FLOAT);		

	iTargetZ = GetISpinner(GetDlgItem(hWnd,IDC_AUDAMP_TARGETZSPIN));
	iTargetZ->SetLimits(-9999999,9999999,FALSE);
	iTargetZ->SetAutoScale();
	iTargetZ->LinkToEdit(GetDlgItem(hWnd,IDC_AUDAMP_TARGETZ),EDITTYPE_FLOAT);		

	iSamples = GetISpinner(GetDlgItem(hWnd,IDC_AUDAMP_NUMSAMPLESSPIN));
	iSamples->SetLimits(1,1000,FALSE);
	iSamples->SetAutoScale();
	iSamples->LinkToEdit(GetDlgItem(hWnd,IDC_AUDAMP_NUMSAMPLES),EDITTYPE_INT);

	iThreshold = GetISpinner(GetDlgItem(hWnd,IDC_AUDAMP_THRESHOLDSPIN));
	iThreshold->SetLimits(0,1,FALSE);
	iThreshold->SetAutoScale();
	iThreshold->LinkToEdit(GetDlgItem(hWnd,IDC_AUDAMP_THRESHOLD),EDITTYPE_FLOAT);

	valid = FALSE;
	Update();
}

// Filter for the TrackView picker
class VectorFilter : public TrackViewFilter {
public:
	BOOL proc(Animatable *anim, Animatable *client,int subNum)
	{
		return anim->SuperClassID() == CTRL_POSITION_CLASS_ID ||
				anim->SuperClassID() == CTRL_POINT3_CLASS_ID; 
	}
};

// Handle WM_COMMAND messages separately
void AudioP3Dlg::WMCommand(int id, int notify, HWND hCtrl)
{
	int mmerr;
	AudioP3Control* af = (AudioP3Control *)GetWindowLong(hWnd, DWL_USER);

	switch (id) {
		case IDC_AUDAMP_ABSOLUTE:
			cont->absolute = IsDlgButtonChecked(hWnd,id);
			Change();
			break;
		case IDC_QUICKDRAW:
			cont->quickdraw = IsDlgButtonChecked(hWnd,id);
			Change();
			break;
		case IDC_AUDAMP_RECDEVICE:
			if (notify == CBN_SELCHANGE) {
				int devIdx = SendMessage(GetDlgItem(hWnd, IDC_AUDAMP_RECDEVICE), CB_GETCURSEL, 0, 0);
				cont->rtwave->SetDevice(devIdx);
				Change();
			}
			break;
		case IDC_AUDAMP_RECENABLE:
			cont->enableRuntime = IsDlgButtonChecked(hWnd,id);
			// Startup or terminate runtime recording
			if (cont->enableRuntime) {
				if ((mmerr = cont->rtwave->StartRecording()) == 0) {
					EnableWindow(GetDlgItem(hWnd, IDC_AUDAMP_RECDEVICE), 0);
				}
				else {
					CheckDlgButton(hWnd, id, 0);
					MessageBox(hWnd, GetString(IDS_CJ_DEVICE_BUSY), GetString(IDS_CJ_PROGNAME), MB_OK);
				}
			} 
			else {
				cont->rtwave->StopRecording();
				EnableWindow(GetDlgItem(hWnd, IDC_AUDAMP_RECDEVICE), 1);
			}

			// Here we are just telling trackview to repaint its hierarchy.
			// We haven't actually changed anything, but the switch from file to record
			// will cause a change in TrackView line height - and we need to tell that
			// to TrackView
			cont->NotifyDependents(FOREVER,PART_ALL,REFMSG_SUBANIM_STRUCTURE_CHANGED);

			Change();
			break;
		case IDC_BTN_BROWSE: {
				// Changed to open in the directory of the file. //CJ
				TSTR dir = cont->szFilename;
				if (dir.Length() == 0) {
					// Use sound dir if no file.
					dir = TSTR(ip->GetDir(APP_SOUND_DIR));
				}
				else {
					int lc = dir.last((int)'\\');
					if (lc == -1) {
						lc = dir.last((int)'/');
					}
					if (lc != -1) {
						dir[lc] = '\0';
					}
				}
				// Brings up file dialog box with sound "preview".
				GetSoundFileName(hCtrl, cont->szFilename, dir);

				if (!cont->szFilename.isNull()) {
					cont->wave->InitOpen(cont->szFilename);
					SendMessage(GetDlgItem(hWnd, IDC_AUDAMP_FILENAME), WM_SETTEXT, 0, (LPARAM)((char *)cont->szFilename));
					EnableChannelUI(cont->wave->GetNumChannels() == 2);
				}
				Change();
			}
			break;
		case IDC_BTN_REMOVESOUND:
			cont->wave->FreeSample();
			cont->szFilename = "";
			SendMessage(GetDlgItem(hWnd, IDC_AUDAMP_FILENAME), WM_SETTEXT, 0, (LPARAM)"");
			EnableChannelUI(FALSE);
			Change();
			break;
		case IDC_AUDAMP_LEFT:
			cont->channel = 0;
			Change();
			break;
		case IDC_AUDAMP_RIGHT:
			cont->channel = 1;
			Change();
			break;
		case IDC_AUDAMP_MIX:
			cont->channel = 2;
			Change();
			break;
		case IDC_ABOUT:
			ShowAbout(hWnd);
			break;
		case IDC_CLOSE:
			DestroyWindow(hWnd);
			break;
	}
}

// Handle spinners in the dialog box
void AudioP3Dlg::SpinnerChange(int id,BOOL drag)
{
	switch (id) {
		case IDC_AUDAMP_BASEXSPIN:
			cont->basePoint.x = dim->UnConvert(iBaseX->GetFVal());
			Change();
			break;
		case IDC_AUDAMP_BASEYSPIN:
			cont->basePoint.y = dim->UnConvert(iBaseY->GetFVal());
			Change();
			break;
		case IDC_AUDAMP_BASEZSPIN:
			cont->basePoint.z = dim->UnConvert(iBaseZ->GetFVal());
			Change();
			break;
		case IDC_AUDAMP_TARGETXSPIN:
			cont->targetPoint.x = dim->UnConvert(iTargetX->GetFVal());
			Change();
			break;
		case IDC_AUDAMP_TARGETYSPIN:
			cont->targetPoint.y = dim->UnConvert(iTargetY->GetFVal());
			Change();
			break;
		case IDC_AUDAMP_TARGETZSPIN:
			cont->targetPoint.z = dim->UnConvert(iTargetZ->GetFVal());
			Change();
			break;
		case IDC_AUDAMP_NUMSAMPLESSPIN:
			cont->numsamples = iSamples->GetIVal();
			Change();
			break;
		case IDC_AUDAMP_THRESHOLDSPIN:
			cont->threshold = iThreshold->GetFVal();
			Change();
			break;
		}
	ip->RedrawViews(ip->GetTime());
	}
 
void AudioP3Dlg::SpinnerStart(int id)
{
}

void AudioP3Dlg::SpinnerEnd(int id,BOOL cancel)
{
	ip->RedrawViews(ip->GetTime());
}

// Update viewports after parameters have changed
void AudioP3Dlg::Change()
{
	cont->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	UpdateWindow(GetParent(hWnd));	
}

RefResult AudioP3Dlg::NotifyRefChanged(Interval changeInt, 
	RefTargetHandle hTarget, PartID& partID, RefMessage message)
{
	switch (message) {
		case REFMSG_CHANGE:
			break;
	}
	return REF_SUCCEED;
}

// Dialog box procedure for user interface dialog.
static BOOL CALLBACK AudioP3DlgProc(HWND hWnd, UINT msg, WPARAM wParam,
	LPARAM lParam)
{
	AudioP3Dlg *dlg = (AudioP3Dlg*)GetWindowLong(hWnd,GWL_USERDATA);

	switch (msg) {
		case WM_INITDIALOG:
			dlg = (AudioP3Dlg*)lParam;
			SetWindowLong(hWnd,GWL_USERDATA,lParam);
			// Initialize spinners etc.
			dlg->SetupUI(hWnd);
			break;

		case CC_SPINNER_BUTTONDOWN:
			dlg->SpinnerStart(LOWORD(wParam));
			break;

		case CC_SPINNER_CHANGE:
			dlg->SpinnerChange(LOWORD(wParam),HIWORD(wParam));
			break;

		case CC_SPINNER_BUTTONUP:
			dlg->SpinnerEnd(LOWORD(wParam),!HIWORD(wParam));
			break;

		case WM_COMMAND:
			// Handle these separately
			dlg->WMCommand(LOWORD(wParam),HIWORD(wParam),(HWND)lParam);						
			break;

		case WM_PAINT:
			dlg->Update();
			return 0;			
		
		case WM_CLOSE:
			DestroyWindow(hWnd);			
			break;

		case WM_DESTROY:
			// The controller needs to know when the dialogue is deleted
			dlg->cont->pDlg = NULL;						
			delete dlg;
			break;
		
		default:
			return FALSE;
	}
	return TRUE;
}

void AudioP3Control::EditTrackParams(TimeValue t, ParamDimensionBase *dim,
	TCHAR *pname, HWND hParent, IObjParam *ip, DWORD flags)
{
	// Create and open the dialog box
	if (!pDlg)
		pDlg = new AudioP3Dlg(this,dim,ip,hParent);
	else
		pDlg->SetActive();
}	

BOOL CALLBACK AboutBoxDlgProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam)
{
	switch (message) {
		case WM_INITDIALOG:
			CenterWindow(hWnd,GetParent(hWnd));
			SetCursor(LoadCursor(NULL,IDC_ARROW));
			return 1;
		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDOK:				  
				case IDCANCEL:
					EndDialog(hWnd,1);
					break;
			}
			return 1;
	}
	return 0;
}

void AudioP3Dlg::ShowAbout(HWND hWnd)	{
	DialogBoxParam(
		hInstance,
		MAKEINTRESOURCE(IDD_ABOUTBOX),
		hWnd,
		(DLGPROC)AboutBoxDlgProc,
		(LPARAM)this);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\AudCont\aup3dlg.h ===
//***************************************************************************
//* Audio Amplitude Controller for 3D Studio MAX.
//*	Dialog class for all "3 point" controllers
//* 
//* Code & design by Christer Janson
//* Autodesk European Developer Support - Neuchatel Switzerland
//* December 1995
//*
static BOOL CALLBACK AudioP3DlgProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

class AudioP3Dlg : public ReferenceMaker {
	public:
		AudioP3Control *cont;
		ParamDimensionBase *dim;
		IObjParam *ip;
		HWND hWnd;
		BOOL valid;

		ISpinnerControl *iSamples;
		ISpinnerControl *iBaseX;
		ISpinnerControl *iBaseY;
		ISpinnerControl *iBaseZ;
		ISpinnerControl *iTargetX;
		ISpinnerControl *iTargetY;
		ISpinnerControl *iTargetZ;
		ISpinnerControl *iThreshold;

		AudioP3Dlg(AudioP3Control *cont, ParamDimensionBase *dim, IObjParam *ip, HWND hParent);
		~AudioP3Dlg();

		void Invalidate();
		void Update();
		void SetupUI(HWND hWnd);
		void Change();
		void WMCommand(int id, int notify, HWND hCtrl);
		void SpinnerChange(int id,BOOL drag);
		void SpinnerStart(int id);
		void SpinnerEnd(int id,BOOL cancel);
		void EnableChannelUI(BOOL state);

		RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, PartID& partID, RefMessage message);
		int NumRefs() {return 1;}
		RefTargetHandle GetReference(int i) {return cont;}
		void SetReference(int i, RefTargetHandle rtarg) {cont=(AudioP3Control*)rtarg;}

		void SetActive();
		void ShowAbout(HWND hWnd);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\AudCont\aurot.cpp ===
//***************************************************************************
//* Audio Amplitude Rotation Controller for 3D Studio MAX.
//* 
//* Code & design by Christer Janson
//* Autodesk European Developer Support - Neuchatel Switzerland
//* December 1995
//*

#include "auctrl.h"
#include "aup3base.h"
#include "aup3dlg.h"

class AudioRotationControl : public AudioP3Control {
public:
	Class_ID ClassID() { return Class_ID(AUDIO_ROTATION_CONTROL_CLASS_ID1, AUDIO_ROTATION_CONTROL_CLASS_ID2); }
	SClass_ID SuperClassID() { return CTRL_ROTATION_CLASS_ID; } 
	void GetClassName(TSTR& s) {s = AUDIO_ROTATION_CONTROL_CNAME;}

	AudioRotationControl();

	void Copy(Control *from);
	RefTargetHandle Clone(RemapDir& remap);
	void RefDeleted();

	void *CreateTempValue() {return new Quat;}
	void DeleteTempValue(void *val) {delete (Quat *)val;}
	void ApplyValue(void *val, void *delta) {PreRotateMatrix( *((Matrix3*)val), *((Quat*)delta) );}
	void MultiplyValue(void *val, float m) {*((Quat*)val) *= m;}

	void GetValueLocalTime(TimeValue t, void *val, Interval &valid, GetSetMethod method=CTRL_ABSOLUTE);
	void SetValueLocalTime(TimeValue t, void *val, int commit, GetSetMethod method);
};

// Class description
class AudioRotationClassDesc:public ClassDesc {
public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { return new AudioRotationControl(); }
	const TCHAR *	ClassName() { return AUDIO_ROTATION_CONTROL_CNAME; }
	SClass_ID		SuperClassID() { return CTRL_ROTATION_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(AUDIO_ROTATION_CONTROL_CLASS_ID1,AUDIO_ROTATION_CONTROL_CLASS_ID2); }
	const TCHAR* 	Category() { return _T("");  }
};

static AudioRotationClassDesc rotationAudioCD;

ClassDesc* GetAudioRotationDesc()
{
	return &rotationAudioCD;
}

AudioRotationControl::AudioRotationControl() 
{
	type = AUDIO_ROTATION_CONTROL_CLASS_ID1;
	basePoint.x = 0.0f; basePoint.y = 0.0f; basePoint.z = 0.0f;
	targetPoint.x = 0.0f; targetPoint.y = 0.0f; targetPoint.z = 0.0f;
} 

void AudioRotationControl::Copy(Control* from)
{
	Quat fval;
	float ang[3];


	if (from->ClassID() == ClassID()) {
		basePoint = ((AudioRotationControl*)from)->basePoint;
		targetPoint = ((AudioRotationControl*)from)->targetPoint;
	}
	else {
		from->GetValue(0, &fval, Interval(0,0));
		QuatToEuler(fval, ang);
		basePoint.x = ang[0];
		basePoint.y = ang[1];
		basePoint.z = ang[2];

		targetPoint.x = ang[0];
		targetPoint.y = ang[1];
		targetPoint.z = ang[2];
	}
}

RefTargetHandle AudioRotationControl::Clone(RemapDir& remap)
{
	// make a new controller and give it our param values.
	AudioRotationControl *cont = new AudioRotationControl;
	// *cont = *this;
	cont->type = type;
	cont->range = range;
	cont->channel = channel;
	cont->absolute = absolute;
	cont->numsamples = numsamples;
	cont->enableRuntime = enableRuntime;
	cont->szFilename = szFilename;
	cont->quickdraw = quickdraw;
	cont->basePoint = basePoint;
	cont->targetPoint = targetPoint;
	return cont;
}

// When the last reference to a controller is
// deleted we need to close the realtime recording device and 
// its parameter dialog needs to be closed
void AudioRotationControl::RefDeleted()
{
	int c=0;
	RefListItem  *ptr = GetRefList().first;
	while (ptr) {
		if (ptr->maker!=NULL) {
			if (ptr->maker->SuperClassID()) c++;
		}
		ptr = ptr->next;
	}	
	if (!c) {
		// Stop the real-time recording is the object is deleted.
		if (rtwave->IsRecording())
			rtwave->StopRecording();

		if (pDlg != NULL)
			DestroyWindow(pDlg->hWnd);
	}
}

// Get the value at a specific instance
void AudioRotationControl::GetValueLocalTime(TimeValue t, void *val, Interval &valid,
	GetSetMethod method)
{
	float ang[3];
	float samp;

	valid.SetInstant(t); // This controller is always changing.

	// Calculate the angle based on base, target and sample
	samp = SampleAtTime(t - range.Start(), 0, FALSE);
	ang[0] = basePoint.x + (targetPoint.x - basePoint.x) * samp;
	ang[1] = basePoint.y + (targetPoint.y - basePoint.y) * samp;
	ang[2] = basePoint.z + (targetPoint.z - basePoint.z) * samp;

	EulerToQuat(ang,*((Quat*)val));
}

void AudioRotationControl::SetValueLocalTime(TimeValue t, void *val, int commit, GetSetMethod method)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\AudCont\auscale.cpp ===
//***************************************************************************
//* Audio Amplitude Scale Controller for 3D Studio MAX.
//* 
//* Code & design by Christer Janson
//* Autodesk European Developer Support - Neuchatel Switzerland
//* December 1995
//*

#include "auctrl.h"
#include "aup3base.h"
#include "aup3dlg.h"

class AudioScaleControl : public AudioP3Control {
public:
	Class_ID ClassID() { return Class_ID(AUDIO_SCALE_CONTROL_CLASS_ID1, AUDIO_SCALE_CONTROL_CLASS_ID2); }
	SClass_ID SuperClassID() { return CTRL_SCALE_CLASS_ID; } 
	void GetClassName(TSTR& s) {s = AUDIO_SCALE_CONTROL_CNAME;}

	AudioScaleControl();

	void Copy(Control *from);
	RefTargetHandle Clone(RemapDir& remap);
	void RefDeleted();

	void *CreateTempValue() {return new ScaleValue;}
	void DeleteTempValue(void *val) {delete (ScaleValue*)val;}
	void ApplyValue(void *val, void *delta) {ApplyScaling( *((Matrix3*)val), *((ScaleValue*)delta) );}
	void MultiplyValue(void *val, float m) {*((ScaleValue*)val) *= m;}

	void GetValueLocalTime(TimeValue t, void *val, Interval &valid, GetSetMethod method=CTRL_ABSOLUTE);
	void SetValueLocalTime(TimeValue t, void *val, int commit, GetSetMethod method);
};

// Class description
class AudioScaleClassDesc:public ClassDesc {
public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { return new AudioScaleControl(); }
	const TCHAR *	ClassName() { return AUDIO_SCALE_CONTROL_CNAME; }
	SClass_ID		SuperClassID() { return CTRL_SCALE_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(AUDIO_SCALE_CONTROL_CLASS_ID1,AUDIO_SCALE_CONTROL_CLASS_ID2); }
	const TCHAR* 	Category() { return _T("");  }
};

static AudioScaleClassDesc scaleAudioCD;

ClassDesc* GetAudioScaleDesc()
{
	return &scaleAudioCD;
}


AudioScaleControl::AudioScaleControl() 
{
	type = AUDIO_SCALE_CONTROL_CLASS_ID1;
	basePoint.x = 1.0f; basePoint.y = 1.0f; basePoint.z = 1.0f;
	targetPoint.x = 1.0f; targetPoint.y = 1.0f; targetPoint.z = 1.0f;
} 

void AudioScaleControl::Copy(Control* from)
{
	ScaleValue fval;

	if (from->ClassID() == ClassID()) {
		basePoint = ((AudioScaleControl*)from)->basePoint;
		targetPoint = ((AudioScaleControl*)from)->targetPoint;
	}
	else {
		from->GetValue(0, &fval, Interval(0,0));
		basePoint.x = fval.s.x;
		basePoint.y = fval.s.y;
		basePoint.z = fval.s.z;

		targetPoint.x = fval.s.x;
		targetPoint.y = fval.s.y;
		targetPoint.z = fval.s.z;
	}
}

RefTargetHandle AudioScaleControl::Clone(RemapDir& remap)
{
	// make a new controller and give it our param values.
	AudioScaleControl *cont = new AudioScaleControl;
	// *cont = *this;
	cont->type = type;
	cont->range = range;
	cont->channel = channel;
	cont->absolute = absolute;
	cont->numsamples = numsamples;
	cont->enableRuntime = enableRuntime;
	cont->szFilename = szFilename;
	cont->quickdraw = quickdraw;
	cont->basePoint = basePoint;
	cont->targetPoint = targetPoint;
	return cont;
}

// When the last reference to a controller is
// deleted we need to close the realtime recording device and 
// its parameter dialog needs to be closed
void AudioScaleControl::RefDeleted()
{
	int c=0;
	RefListItem  *ptr = GetRefList().first;
	while (ptr) {
		if (ptr->maker!=NULL) {
			if (ptr->maker->SuperClassID()) c++;
		}
		ptr = ptr->next;
	}	
	if (!c) {
		// Stop the real-time recording is the object is deleted.
		if (rtwave->IsRecording())
			rtwave->StopRecording();

		if (pDlg != NULL)
			DestroyWindow(pDlg->hWnd);
	}
}

// Return a value at at specific instant.
void AudioScaleControl::GetValueLocalTime(TimeValue t, void *val, Interval &valid,
	GetSetMethod method)
{
	float samp;

	valid.SetInstant(t); // This controller is always changing.

	// Get a sample from the wave
	samp = SampleAtTime(t - range.Start(), 0, FALSE);

	// Create a scale value based on the sample and the base/targets
	// for X, Y and Z values
	*((ScaleValue*)val) = ScaleValue(
		Point3(
			basePoint.x + (targetPoint.x - basePoint.x) * samp,
			basePoint.y + (targetPoint.y - basePoint.y) * samp,
			basePoint.z + (targetPoint.z - basePoint.z) * samp),
			Quat(0.0,0.0,0.0,1.0));
}

void AudioScaleControl::SetValueLocalTime(TimeValue t, void *val, int commit, GetSetMethod method)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\AudCont\aupoint3.cpp ===
//***************************************************************************
//* Audio Amplitude Point3 Controller for 3D Studio MAX.
//* 
//* Code & design by Christer Janson
//* Autodesk European Developer Support - Neuchatel Switzerland
//* December 1995
//*

#include "auctrl.h"
#include "aup3base.h"
#include "aup3dlg.h"

class AudioPoint3Control : public AudioP3Control {
public:
	Class_ID ClassID() { return Class_ID(AUDIO_POINT3_CONTROL_CLASS_ID1, AUDIO_POINT3_CONTROL_CLASS_ID2); }  
	SClass_ID SuperClassID() { return CTRL_POINT3_CLASS_ID; } 
	void GetClassName(TSTR& s) {s = AUDIO_POINT3_CONTROL_CNAME;}

	AudioPoint3Control();

	void Copy(Control *from);
	RefTargetHandle Clone(RemapDir& remap);
	void RefDeleted();

	void *CreateTempValue() {return new Point3;}
	void DeleteTempValue(void *val) {delete (Point3*)val;}
	void ApplyValue(void *val, void *delta) {*((Point3*)val) += *((Point3*)delta);}
	void MultiplyValue(void *val, float m) {*((Point3*)val) *= m;}

	void GetValueLocalTime(TimeValue t, void *val, Interval &valid, GetSetMethod method=CTRL_ABSOLUTE);
	void SetValueLocalTime(TimeValue t, void *val, int commit, GetSetMethod method);
};

// Class description
class AudioPoint3ClassDesc:public ClassDesc {
public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { return new AudioPoint3Control(); }
	const TCHAR *	ClassName() { return AUDIO_POINT3_CONTROL_CNAME; }
	SClass_ID		SuperClassID() { return CTRL_POINT3_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(AUDIO_POINT3_CONTROL_CLASS_ID1,AUDIO_POINT3_CONTROL_CLASS_ID2); }
	const TCHAR* 	Category() { return _T("");  }
};

static AudioPoint3ClassDesc point3AudioCD;

ClassDesc* GetAudioPoint3Desc()
{
	return &point3AudioCD;
}

AudioPoint3Control::AudioPoint3Control() 
{
	type = AUDIO_POINT3_CONTROL_CLASS_ID1;
	basePoint.x = 0.0f; basePoint.y = 0.0f; basePoint.z = 0.0f;
	targetPoint.x = 1.0f; targetPoint.y = 1.0f; targetPoint.z = 1.0f;
} 

void AudioPoint3Control::Copy(Control* from)
{
	Point3 fval;

	if (from->ClassID() == ClassID()) {
		basePoint = ((AudioPoint3Control*)from)->basePoint;
		targetPoint = ((AudioPoint3Control*)from)->targetPoint;
	}
	else {
		from->GetValue(0, &fval, Interval(0,0));
		basePoint = fval;
		targetPoint = fval;
	}
}

RefTargetHandle AudioPoint3Control::Clone(RemapDir& remap)
{
	// make a new controller and give it our param values.
	AudioPoint3Control *cont = new AudioPoint3Control;
	// *cont = *this;
	cont->type = type;
	cont->range = range;
	cont->channel = channel;
	cont->absolute = absolute;
	cont->numsamples = numsamples;
	cont->enableRuntime = enableRuntime;
	cont->szFilename = szFilename;
	cont->quickdraw = quickdraw;
	cont->basePoint = basePoint;
	cont->targetPoint = targetPoint;

	return cont;
}

// When the last reference to a controller is
// deleted we need to close the realtime recording device and 
// its parameter dialog needs to be closed
void AudioPoint3Control::RefDeleted()
{
	int c=0;
	RefListItem  *ptr = GetRefList().first;
	while (ptr) {
		if (ptr->maker!=NULL) {
			if (ptr->maker->SuperClassID()) c++;
		}
		ptr = ptr->next;
	}	
	if (!c) {
		// Stop the real-time recording is the object is deleted.
		if (rtwave->IsRecording())
			rtwave->StopRecording();

		if (pDlg != NULL)
			DestroyWindow(pDlg->hWnd);
	}
}

// Return a value at a speficif instance.
void AudioPoint3Control::GetValueLocalTime(TimeValue t, void *val, Interval &valid,
	GetSetMethod method)
{
	valid.SetInstant(t); // This controller is always changing.

	// Multiply the target-base with sample and add base
	*((Point3*)val) = basePoint + (targetPoint - basePoint) * SampleAtTime(t - range.Start(), 0, FALSE);
}

void AudioPoint3Control::SetValueLocalTime(TimeValue t, void *val, int commit, GetSetMethod method)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\AudCont\aupos.cpp ===
//***************************************************************************
//* Audio Amplitude Position Controller for 3D Studio MAX.
//* 
//* Code & design by Christer Janson
//* Autodesk European Developer Support - Neuchatel Switzerland
//* December 1995
//*

#include "auctrl.h"
#include "aup3base.h"
#include "aup3dlg.h"

class AudioPositionControl : public AudioP3Control {
public:
	Class_ID ClassID() { return Class_ID(AUDIO_POSITION_CONTROL_CLASS_ID1, AUDIO_POSITION_CONTROL_CLASS_ID2); }
	SClass_ID SuperClassID() { return CTRL_POSITION_CLASS_ID; } 
	void GetClassName(TSTR& s) {s = AUDIO_POSITION_CONTROL_CNAME;}

	AudioPositionControl();
	AudioPositionControl& operator=(const AudioPositionControl& from);

	void Copy(Control *from);
	RefTargetHandle Clone(RemapDir& remap);
	void RefDeleted();

	void *CreateTempValue() {return new Point3;}
	void DeleteTempValue(void *val) {delete (Point3*)val;}
	void ApplyValue(void *val, void *delta) {((Matrix3*)val)->PreTranslate(*((Point3*)delta));}
	void MultiplyValue(void *val, float m) {*((Point3*)val) *= m;}

	void GetValueLocalTime(TimeValue t, void *val, Interval &valid, GetSetMethod method=CTRL_ABSOLUTE);
	void SetValueLocalTime(TimeValue t, void *val, int commit, GetSetMethod method);
};

// Class description
class AudioPositionClassDesc:public ClassDesc {
public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { return new AudioPositionControl(); }
	const TCHAR *	ClassName() { return AUDIO_POSITION_CONTROL_CNAME; }
	SClass_ID		SuperClassID() { return CTRL_POSITION_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(AUDIO_POSITION_CONTROL_CLASS_ID1,AUDIO_POSITION_CONTROL_CLASS_ID2); }
	const TCHAR* 	Category() { return _T("");  }
};

static AudioPositionClassDesc positionAudioCD;

ClassDesc* GetAudioPositionDesc()
{
	return &positionAudioCD;
}

AudioPositionControl::AudioPositionControl() 
{
	type = AUDIO_POINT3_CONTROL_CLASS_ID1;
	basePoint.x = 0.0f; basePoint.y = 0.0f; basePoint.z = 0.0f;
	targetPoint.x = 0.0f; targetPoint.y = 0.0f; targetPoint.z = 0.0f;
} 

void AudioPositionControl::Copy(Control* from)
{
	Point3 fval;

	if (from->ClassID() == ClassID()) {
		basePoint = ((AudioPositionControl*)from)->basePoint;
		targetPoint = ((AudioPositionControl*)from)->targetPoint;
	}
	else {
		from->GetValue(0, &fval, Interval(0,0));
		basePoint = fval;
		targetPoint = fval;
	}
}

RefTargetHandle AudioPositionControl::Clone(RemapDir& remap)
{
	// Make a new controller and give it our param values.
	AudioPositionControl *cont = new AudioPositionControl;
	// *cont = *this;
	cont->type = type;
	cont->range = range;
	cont->channel = channel;
	cont->absolute = absolute;
	cont->numsamples = numsamples;
	cont->enableRuntime = enableRuntime;
	cont->szFilename = szFilename;
	cont->quickdraw = quickdraw;
	cont->basePoint = basePoint;
	cont->targetPoint = targetPoint;
	return cont;
}

// When the last reference to a controller is
// deleted we need to close the realtime recording device and 
// its parameter dialog needs to be closed
void AudioPositionControl::RefDeleted()
{
	int c=0;
	RefListItem  *ptr = GetRefList().first;
	while (ptr) {
		if (ptr->maker!=NULL) {
			if (ptr->maker->SuperClassID()) c++;
		}
		ptr = ptr->next;
	}	
	if (!c) {
		// Stop the real-time recording is the object is deleted.
		if (rtwave->IsRecording())
			rtwave->StopRecording();

		if (pDlg != NULL)
			DestroyWindow(pDlg->hWnd);
	}
}

void AudioPositionControl::GetValueLocalTime(TimeValue t, void *val, Interval &valid,
	GetSetMethod method)
{
	valid.SetInstant(t); // This controller is always changing.

	// Multiply the target-base with sample and add base
	*((Point3*)val) = basePoint + (targetPoint - basePoint) * SampleAtTime(t - range.Start(), 0, FALSE);
}

void AudioPositionControl::SetValueLocalTime(TimeValue t, void *val, int commit, GetSetMethod method)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\AudCont\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by auctrl.rc
//
#define IDS_CJ_NOFILE                   1
#define IDS_CJ_NODEVICE                 2
#define IDS_CJ_DEVICE_BUSY              3
#define IDS_CJ_PROGNAME                 4
#define IDS_CJ_BASESCALE                5
#define IDS_CJ_TARGETSCALE              6
#define IDS_CJ_BASEANGLE                7
#define IDS_CJ_TARGETANGLE              8
#define IDS_CJ_FLOATCONTROL             9
#define IDS_CJ_POINT3CONTROL            10
#define IDS_CJ_POSITIONCONTROL          11
#define IDS_CJ_ROTATIONCONTROL          12
#define IDS_CJ_SCALECONTROL             13
#define IDS_CJ_LIBDESC                  14
#define IDD_DIALOG1                     101
#define IDD_AUDIOFREQUENCYDLG           103
#define IDD_ABOUTBOX                    104
#define IDD_AUDAMPPARAMS                146
#define IDD_AUDIOFLOATPARAMS            146
#define IDD_AUDIOPOINT3PARAMS           147
#define IDC_AUDAMP_WAVEFILE             1000
#define IDC_TESTLIST                    1001
#define IDC_BTN_BROWSE                  1002
#define IDC_WAVEFRAME                   1003
#define IDC_AUDAMP_LEFT                 1004
#define IDC_AUDAMP_RIGHT                1005
#define IDC_AUDAMP_MIX                  1006
#define IDC_AUDAMP_TEXTMAX              1008
#define IDC_AUDAMP_TEXTMIN              1009
#define IDC_AUDAMP_FILENAME             1010
#define IDC_AUDAMP_BASEREFERENCE        1011
#define IDC_BASEREFTEXT                 1012
#define IDC_AUDAMP_TARGETREFERENCE      1013
#define IDC_TARGETREFTEXT               1014
#define IDC_AUDAMP_BASEX                1015
#define IDC_AUDAMP_BASEXSPIN            1016
#define IDC_BASEFRAME                   1017
#define IDC_TARGETFRAME                 1018
#define IDC_AUDAMP_RECENABLE            1019
#define IDC_AUDAMP_RECDEVICE            1020
#define IDC_BTN_REMOVESOUND             1022
#define IDC_FREQFRAME                   1024
#define IDC_RESPONSE_RADIO1             1025
#define IDC_RESPONSE_RADIO2             1026
#define IDC_FREQUENCY                   1027
#define IDC_CUSTOM2                     1028
#define IDC_ABOUT                       1029
#define IDC_QUICKDRAW                   1030
#define IDC_RESPONSE_RADIO3             1031
#define IDC_CLOSE                       1032
#define IDC_DEBUG                       1034
#define IDC_AUDAMP_THRESHOLD            1155
#define IDC_AUDAMP_THRESHOLDSPIN        1156
#define IDC_AUDAMP_NUMSAMPLES           1157
#define IDC_AUDAMP_NUMSAMPLESSPIN       1158
#define IDC_AUDAMP_MIN                  1159
#define IDC_AUDAMP_MINSPIN              1160
#define IDC_AUDAMP_MAX                  1161
#define IDC_AUDAMP_MAXSPIN              1162
#define IDC_AUDAMP_BASEY                1163
#define IDC_AUDAMP_BASEYSPIN            1164
#define IDC_AUDAMP_BASEZ                1165
#define IDC_AUDAMP_BASEZSPIN            1166
#define IDC_AUDAMP_TARGETX              1167
#define IDC_AUDAMP_TARGETXSPIN          1168
#define IDC_AUDAMP_TARGETY              1169
#define IDC_AUDAMP_TARGETYSPIN          1170
#define IDC_AUDAMP_TARGETZ              1171
#define IDC_AUDAMP_TARGETZSPIN          1172
#define IDC_AUDAMP_ABSOLUTE             1213

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        105
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1035
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\AudCont\rtwave.h ===
//***************************************************************************
//* RunTimeWave class.
//* This class handles real-time (recording) processing of audio stream data
//* Code & design by Christer Janson
//* Autodesk European Developer Support - Neuchatel Switzerland
//* January 1996
//*

#ifndef __RTWAVE__H
#define __RTWAVE__H

class RunTimeWave {
public:
	RunTimeWave();
	~RunTimeWave();

	void SetupRecWindow();
	int  StartRecording();
	void ContinueRecording(WAVEHDR* pHdr);
	void StopRecording();
	void RecordingStopped();
	void SetDevice(int nIndex);
	int GetDevice();
	void SetSample(int sample);
	int GetSample(int oversampling);
	void SetStopFlag(int status);
	int  GetStopFlag();

	BOOL IsRecording();
	WAVEINCAPS* m_pDevCaps;
	WAVEINCAPS *pCurCaps;
	WAVEFORMATEX fmt;

	int m_nNumDevices;
	HWND recWindow;
	HWAVEIN m_hWaveIn;
	int blockSize;

	WAVEHDR* pWaveHdr;
	char *pSampleData;
	DWORD lSampleDataSize;
	int m_nIndex;
	int stopFlag;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\AudCont\rtwave.cpp ===
//***************************************************************************
//* RunTimeWave class.
//* This class handles real-time (recording) processing of audio stream data
//* Code & design by Christer Janson
//* Autodesk European Developer Support - Neuchatel Switzerland
//* January 1996
//*

#include "auctrl.h"
#include "windows.h"
#include "vfw.h"
#include "rtwave.h"

extern HINSTANCE hInstance;
#define AUCTRL_DUMMY_WINDOW "AUCTRLDUMMYWINDOW"

RunTimeWave::RunTimeWave()
{
	m_pDevCaps = NULL;
	pCurCaps = NULL;
	m_hWaveIn = NULL;
	blockSize = 512;
 	pSampleData = new char[blockSize];
    fmt.wFormatTag = WAVE_FORMAT_PCM;
	fmt.wBitsPerSample = 8;
    fmt.nChannels = 1;
    fmt.nSamplesPerSec = 11025;
    fmt.nAvgBytesPerSec = fmt.nSamplesPerSec;
    fmt.nBlockAlign = 1;

	m_nNumDevices = waveInGetNumDevs();
	if (m_nNumDevices > 0) {
		m_pDevCaps = new WAVEINCAPS[m_nNumDevices];
		for (int i = 0; i< m_nNumDevices; i++) {
			waveInGetDevCaps(i, &m_pDevCaps[i], sizeof(WAVEINCAPS));
			m_pDevCaps[i].wMid = i;
		}
	}

	SetupRecWindow();

	recWindow = CreateWindow(
		_T(AUCTRL_DUMMY_WINDOW), NULL,
		//WS_POPUP | WS_VISIBLE,
		WS_POPUP,
		//0,0,320,200, 
		0,0,0,0,
		NULL,
		NULL,
		hInstance,
		NULL );
}

RunTimeWave::~RunTimeWave()
{
	if (IsRecording()) {
		StopRecording();
		RecordingStopped();
	}

	if (recWindow) DestroyWindow(recWindow);	

	delete [] pSampleData;

	if (m_pDevCaps)
		delete [] m_pDevCaps;

}

static LRESULT CALLBACK RecWndProc(HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
{
	WAVEHDR* pWave;
	RunTimeWave* rtw;

	switch (msg) {
		case WIM_DATA:
			pWave = (WAVEHDR*)lParam;
			rtw = (RunTimeWave *)pWave->dwUser;
			if (rtw) {
				memcpy(rtw->pSampleData, pWave->lpData, rtw->blockSize);
				if (!rtw->GetStopFlag()) {
					rtw->ContinueRecording(pWave);
				}
				else {
					rtw->RecordingStopped();
				}
			}
			break;
		default:
			return DefWindowProc(hWnd,msg,wParam,lParam);
	}
	return 0;
}

void RunTimeWave::SetupRecWindow()
{
	WNDCLASS  wc;

	wc.style         = 0;
    wc.hInstance     = hInstance;
    wc.hIcon         = NULL;
    wc.hCursor       = LoadCursor(NULL,IDC_ARROW);
	wc.hbrBackground = (HBRUSH)GetStockObject(LTGRAY_BRUSH);
    wc.lpszMenuName  = NULL;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = 0;
    wc.lpfnWndProc   = RecWndProc;
    wc.lpszClassName = _T(AUCTRL_DUMMY_WINDOW);

	RegisterClass(&wc);	
}

int RunTimeWave::StartRecording()
{
	SetStopFlag(FALSE);

	MMRESULT mmr;
    mmr = waveInOpen(&m_hWaveIn,
                     pCurCaps->wMid,
                     &fmt, 
                     (DWORD)(recWindow), 
                     0, 
                     CALLBACK_WINDOW);
    if (mmr != 0) {
		return mmr;
	}


    WAVEHDR* phdr = (WAVEHDR*)malloc(sizeof(WAVEHDR));
	pWaveHdr = phdr;
    // fill out the wave header
    memset(phdr, 0, sizeof(WAVEHDR));
    phdr->lpData = (char *)malloc(blockSize);
    phdr->dwBufferLength = blockSize;
    phdr->dwUser = (DWORD)(void*)this;  // so we can find the object 

    // Prepare the header
    mmr = waveInPrepareHeader(m_hWaveIn, phdr, sizeof(WAVEHDR));
    if (mmr != 0) {
        return mmr;
    }

    // Send it to the driver
    mmr = waveInAddBuffer(m_hWaveIn, phdr, sizeof(WAVEHDR));
    if (mmr != 0) {
        return mmr;
    }

    // Start the recording
    mmr = waveInStart(m_hWaveIn);
    if (mmr != 0) {
        return mmr;
    }

	return 0;
}

void RunTimeWave::ContinueRecording(WAVEHDR* pHdr)
{
    // Send another block to the driver
    // Allocate a header
    WAVEHDR* phdrNew = (WAVEHDR*)malloc(sizeof(WAVEHDR));
	pWaveHdr = phdrNew;

    // fill out the wave header
    memset(phdrNew, 0, sizeof(WAVEHDR));
    phdrNew->lpData = (char *)malloc(blockSize);
    phdrNew->dwBufferLength = blockSize;
    phdrNew->dwUser = (DWORD)(void*)this;  // so we can find the object 

    // Prepare the header
    MMRESULT mmr = waveInPrepareHeader(m_hWaveIn, phdrNew, sizeof(WAVEHDR));
    if (mmr != 0) return ;

    // Send it to the driver
    mmr = waveInAddBuffer(m_hWaveIn, phdrNew, sizeof(WAVEHDR));
    if (mmr != 0) return ;

    // Now handle the block that was completed
    // Unprepare the header
    mmr = waveInUnprepareHeader(m_hWaveIn, pHdr, sizeof(WAVEHDR));
    if (mmr != 0) return ;

    // free the previous block + header
	free(pHdr->lpData);
    free(pHdr);
}


void RunTimeWave::StopRecording()
{
	SetStopFlag(TRUE);
}

void RunTimeWave::RecordingStopped()
{
	waveInReset(m_hWaveIn);
	waveInClose(m_hWaveIn);
	free(pWaveHdr->lpData);
	free(pWaveHdr);
	m_hWaveIn = NULL;
}

void RunTimeWave::SetDevice(int nIndex)
{
	pCurCaps = &m_pDevCaps[nIndex];
	m_nIndex = nIndex;
}

int RunTimeWave::GetDevice()
{
	return m_nIndex;
}

BOOL RunTimeWave::IsRecording()
{
	return (m_hWaveIn && !GetStopFlag()) ? TRUE : FALSE;
}

void RunTimeWave::SetSample(int sample)
{
	//m_nSample = sample;
}

// Macros to normalize 8 bits sound data around -127 to +128
#define AUDIO_NORM8(x) (x<=0?x+128:x-127)

int RunTimeWave::GetSample(int oversampling)
{
	int sample = 0;
	int i;

	if (oversampling > blockSize)
		oversampling = blockSize;

	for (i=0; i < oversampling; i++)
		sample += abs(AUDIO_NORM8(pSampleData[i]));

	if (i != 0)
		sample = sample / i;

	return sample;
}

void RunTimeWave::SetStopFlag(int status)
{
	stopFlag = status;
}

int RunTimeWave::GetStopFlag()
{
	return stopFlag;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\AudCont\wave.h ===
//***************************************************************************
//* WaveForm class.
//* This class handles loading and processing of audio stream data
//* Code & design by Christer Janson
//* Autodesk European Developer Support - Neuchatel Switzerland
//* December 1995

#ifndef __WAVE__H
#define __WAVE__H

class WaveForm {
public:
	WaveForm();
	~WaveForm();

	enum Channel {	kLeftChannel  = 0,
					kRightChannel = 1,
					kMixChannels = 2 };

	// Initialize, open and read the sample data
	BOOL InitOpen(LPCTSTR lpszPathName);

	// Delete the waveform and free allocated memory
	void FreeSample();

	BOOL IsEmpty();
	int GetSample(long sampleNo, WaveForm::Channel channel);

	long GetNumSamples();	// Number of samples
	long GetBeginTime();	// Start time in milliseconds
	long GetEndTime();		// End time in milliseconds
	long GetBeginSample();	// First sample
	long GetEndSample();	// Last sample
	long GetSamplesPerSec();// Samples per second
	int  GetBitsPerSample();
	int  GetNumChannels();
	int  GetMaxValue();

	void DumpDebug();		// Debug Stuff


private:
	void SetNumSamples(long numSamples);
	void SetBeginTime(long startTime);
	void SetEndTime(long endTime);
	void SetBeginSample(long beginSample);
	void SetEndSample(long endSample);
	void SetMaxValue(int value);

	BOOL AllocSample(long lSize);

private:
	// DWORD pSampleData;
	char *pSampleData;
	DWORD lSampleDataSize;
	DWORD m_lSamplesPerSec;
	long m_lNumSamples;
    long m_lWaveBeginTime;
    long m_lWaveEndTime;
    long m_lWaveBeginSample;
    long m_lWaveEndSample;

	int m_nChannels;
	int m_nBitsPerSample;
	int m_nMaxValue;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\AudCont\wave.cpp ===
//***************************************************************************
//* WaveForm class.
//* This class handles loading and processing of audio stream data
//* Code & design by Christer Janson
//* Autodesk European Developer Support - Neuchatel Switzerland
//* December 1995
//*

#include "windows.h"
#include "vfw.h"
#include "wave.h"

#include <stdio.h>

WaveForm::WaveForm()
{
	pSampleData = 0;
	lSampleDataSize = 0;
}

WaveForm::~WaveForm()
{
	FreeSample();
}

BOOL WaveForm::IsEmpty()
{
	return (lSampleDataSize == 0);
}

BOOL WaveForm::InitOpen(LPCTSTR lpszPathName)
{
	PAVISTREAM stream;
	AVISTREAMINFO streamInfo;
	PCMWAVEFORMAT wf;
	long l;

	AVIFileInit();  // Initialize the AVI library

	if (AVIStreamOpenFromFile(&stream, lpszPathName, streamtypeAUDIO, 0, OF_READ, NULL)) {
		AVIFileExit();
		return FALSE;
	}

	if (AVIStreamInfo(stream, &streamInfo, sizeof(streamInfo))) {
		AVIFileExit();
		return FALSE;
	}

	SetNumSamples(streamInfo.dwLength);
	SetBeginTime(AVIStreamStartTime(stream));
	SetEndTime(AVIStreamEndTime(stream));

    SetBeginSample(AVIStreamTimeToSample(stream, GetBeginTime()));
    SetEndSample(AVIStreamTimeToSample(stream, GetEndTime()));

    l = sizeof(wf);
    AVIStreamReadFormat(stream, GetBeginTime(), &wf, &l);
    if (!l) {
		AVIFileExit();
        return FALSE;
	}

    if (wf.wf.wFormatTag != WAVE_FORMAT_PCM) {
		AVIFileExit();
        return FALSE;
	}

	if (!AllocSample((GetEndSample() - GetBeginSample())
			* wf.wf.nChannels * wf.wBitsPerSample / 8)) {
		AVIFileExit();
		return FALSE;
	}

	m_nChannels = wf.wf.nChannels;
	m_nBitsPerSample = wf.wBitsPerSample;
	m_lSamplesPerSec = wf.wf.nSamplesPerSec;

    AVIStreamRead(stream, GetBeginSample(), GetEndSample() - GetBeginSample(), (void*)pSampleData, lSampleDataSize, NULL, &l);
	AVIFileExit();

	long erv = lSampleDataSize;
	if (m_nChannels == 2)
		erv = erv / 2;
	if (m_nBitsPerSample == 16)
		erv = erv / 2;
	
	if (l != erv)
		return FALSE;

	int tMax = -65535;
	int sample;
	long i;

	for (i = 0; i< (GetEndSample() - GetBeginSample()); i++) {
		sample = abs(GetSample(i, kLeftChannel));
		tMax = sample > tMax ? sample : tMax;
	}

	if (m_nChannels == 2) {
		for (i = 0; i< (GetEndSample() - GetBeginSample()); i++) {
			sample = GetSample(i, kRightChannel);
			tMax = sample > tMax ? sample : tMax;
		}
	}

	SetMaxValue(tMax);

	return TRUE;
}

void WaveForm::DumpDebug()
{
	char tbuf[80];
	int sample;
	long i;


	sprintf(tbuf, "Max value: %d\n", GetMaxValue());
	OutputDebugString(tbuf);

	for (i = 0; i< (GetEndSample() - GetBeginSample()); i++) {
		sample = abs(GetSample(i, kLeftChannel));
		sprintf(tbuf, "Sample[%05ld]: %d\n", i, sample);
		OutputDebugString(tbuf);
	}
}

void WaveForm::SetNumSamples(long numSamples)
{
	m_lNumSamples = numSamples;
}

void WaveForm::SetBeginTime(long beginTime)
{
	m_lWaveBeginTime = beginTime;
}

void WaveForm::SetEndTime(long endTime)
{
	m_lWaveEndTime = endTime;
}

void WaveForm::SetBeginSample(long beginSample)
{
	m_lWaveBeginSample = beginSample;
}

void WaveForm::SetMaxValue(int value)
{
	m_nMaxValue = value;
}

void WaveForm::SetEndSample(long endSample)
{
	m_lWaveEndSample = endSample;
}

long WaveForm::GetNumSamples()
{
	return m_lNumSamples;
}

long WaveForm::GetBeginTime()
{
	return m_lWaveBeginTime;
}

long WaveForm::GetEndTime()
{
	return m_lWaveEndTime;
}

long WaveForm::GetBeginSample()
{
	return m_lWaveBeginSample;
}

long WaveForm::GetEndSample()
{
	return m_lWaveEndSample;
}

long WaveForm::GetSamplesPerSec()
{
	return m_lSamplesPerSec;
}

int  WaveForm::GetBitsPerSample()
{
	return m_nBitsPerSample;
}

int  WaveForm::GetNumChannels()
{
	return m_nChannels;
}

int  WaveForm::GetMaxValue()
{
	return m_nMaxValue;
}

BOOL WaveForm::AllocSample(long lSize)
{
	if (pSampleData)
		FreeSample();

	pSampleData = new char[lSize];

	lSampleDataSize = pSampleData ? lSize : 0;

	return pSampleData ? TRUE : FALSE;
}

void WaveForm::FreeSample()
{
	if (pSampleData) {
		delete [] pSampleData;

		pSampleData = 0;
		lSampleDataSize = 0;
	}
}

// Macros to normalize 8 bits sound data around -127 to +128
// No need to normalize 16 bit sound
#define AUDIO_NORM8(x) (x<=0?x+128:x-127)

int WaveForm::GetSample(long sampleNo, WaveForm::Channel channel)
{
	char *sample8;
	short *sample16;
	int sample;
	long lSize;

	if (IsEmpty()) // Do we have a wave file loaded?
		return 0;

	// Get two pointers of different datasize to point to the audio stream.
	sample8 = (char *)pSampleData;
	sample16 = (short *)pSampleData;

	// Test for out of range samples
	// Adjust for two channels and stereo recording
	lSize = GetNumChannels() > 1 ? 2 : 1;
	lSize = lSize * (GetBitsPerSample() == 8 ? 1 : 2);

	if (sampleNo >= (long)lSampleDataSize/lSize || sampleNo < 0)
		return 0;

	if (GetNumChannels() == 2) {
		if (channel == Channel::kLeftChannel)
			sampleNo = sampleNo * 2;
		else if (channel == Channel::kRightChannel)
			sampleNo = sampleNo * 2 + 1;
		else if (channel == Channel::kMixChannels)
			sampleNo = sampleNo * 2; // Get left channel first
	}

	if (GetBitsPerSample() == 8) {
		sample = AUDIO_NORM8(sample8[sampleNo]); // -127 -> +128
		if (channel == Channel::kMixChannels && GetNumChannels() == 2) {
			sample += AUDIO_NORM8(sample8[sampleNo+1]);
			sample = sample /2;
		}
	}
	else {
		sample = sample16[sampleNo];
		if (channel == Channel::kMixChannels && GetNumChannels() == 2) {
			sample += sample16[sampleNo+1];
			sample = sample /2;
		}
	}

	return sample;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\bezfont\type1.h ===
/**********************************************************************
 *<
	FILE: type1.h

	DESCRIPTION:  Adobe Type 1 bezier font file header

	CREATED BY: Tom Hudson

	HISTORY: created 2 November 1995

 *>	Copyright (c) 1995, All Rights Reserved.
 **********************************************************************/

#ifndef __TYPE1_H__

#define __TYPE1_H__

typedef int Errcode;

#define Success 0

/* general errors */

#define Err_nogood		-1 /* something generally went wrong */
#define Err_no_memory	-2 /* no memory available */
#define Err_bad_input	-3 /* bad input data */
#define Err_format		-4 /* general bad data format */
#define Err_no_vram 	-5 /* out of video display memory */
#define Err_no_stack	-6 /* out of stack space */
#define Err_reported	-7 /* still an error but was reported below */
#define Err_unimpl		-8 /* feature unimplemented */
#define Err_overflow	-9 /* data overflow for size of result */
#define Err_not_found	-10 /* object not found */
#define Err_bad_magic	-11 /* bad magic id number on data or record */
#define Err_abort		-12 /* user abort request */
#define Err_timeout 	-13 /* the call waiting timed out */
#define Err_wrong_res	-14 /* Can't deal with object of this dimension */
#define Err_too_big 	-15 /* object too big to handle */
#define Err_version 	-16 /* correct file type but new version */
#define Err_bad_record	-17 /* record magic number is bad */
#define Err_uninit		-18 /* subsystem not initialized */
#define Err_wrong_type	-19 /* object found but not requested type */
#define Err_spline_points -20 /* too many points in spline */
#define Err_widget		-21 /* hardware lock not found */
#define Err_rgb_convert -22 /* only CONVERT program can load rgb image files */
#define Err_pic_unknown -23 /* picture file format unknown */
#define Err_range		-24 /* value out of range */
#define Err_no_message	-25 /* No message except for "context" part */
#define Err_internal_pointer   -26	  /* internal routine detected bad pointer */
#define Err_internal_parameter -27	  /* internal routine detected bad parm value */

/* system errors */
#define SYSERR -50
#define Err_stdio		(SYSERR -0) /* error occurred in stdio routine */
/* end SYSERR */

/* io and file errors */

#define FERR -100
#define Err_no_file 	(FERR -0) /* file not found */
#define Err_no_path 	(FERR -1) /* path not found */
#define Err_no_device	(FERR -2) /* device not found */
#define Err_write		(FERR -3) /* write error */
#define Err_read		(FERR -4) /* read error */
#define Err_seek		(FERR -5) /* seek error */
#define Err_eof 		(FERR -6) /* end of file */
#define Err_in_use		(FERR -7) /* file in use */
#define Err_extant		(FERR -8) /* file exists */
#define Err_create		(FERR -9) /* file creation error */
#define Err_truncated	(FERR -10) /* file data truncated */
#define Err_corrupted	(FERR -11) /* file data corrupted or invalid */
#define Err_no_space	(FERR -12) /* out of space writing to device */
#define Err_disabled	(FERR -13) /* the device,window,file etc. disabled */
#define Err_invalid_id	(FERR -14) /* invalid id value */
#define Err_file_not_open  (FERR -15) /* file is not open */
#define Err_suffix		(FERR-16) /* unrecognized file suffix */
#define Err_too_many_files (FERR-17) /* can't open file cause too many open */
#define Err_access		(FERR-18)	/* Don't have permission to use this file */
#define Err_sys_mem_bad (FERR-19)	/* MS-DOS memory block corrupted */
#define Err_bad_env 	(FERR-20)	/* MS-DOS environment block bad */
#define Err_bad_address (FERR-21)  /* "Invalid memory-block address", */
#define Err_disk_format (FERR-22)	/* Invalid format */
#define Err_file_access (FERR-23)	/* Bad file access code (internal) */
#define Err_data		(FERR-24)	/* Invalid data */
#define Err_no_more_files (FERR-25)  /* No more files */
#define Err_write_protected (FERR-26)  /* Disk write protected. */
#define Err_disk_not_ready (FERR-27) /* No disk in drive */
#define Err_not_dos_disk (FERR-28)	 /* Not an MS-DOS disk */
#define Err_disk_data	(FERR-29)		/* Disk data error */
#define Err_sector		(FERR-30)		/* Disk sector not found */
#define Err_no_paper	(FERR-31)		/* Printer out of paper */
#define Err_general_failure (FERR-32) /* MS-DOS general failure */
#define Err_critical	(FERR-33)		/* critical error */
#define Err_network 	(FERR-34)		/* General network failure */
#define Err_file_share	(FERR-35)	/* file sharing error */
#define Err_file_lock	(FERR-36)		/* file lock error */
#define Err_disk_change (FERR-37)	/* invalid disk  change */
#define Err_no_remote	(FERR-38)		/* remote computer not listening */
#define Err_network_busy (FERR-39)	/* Network busy */
#define Err_share_pause (FERR-40)	/* Sharing temporarily paused */
#define Err_redirect_pause (FERR-41) /* File/printer redirection paused */
#define Err_directory_entry (FERR-42) /* Can't create directory entry */
#define Err_dir_too_long	(FERR-43) /* Directory name too big for ms-dos */
#define Err_dir_name_err	(FERR-44) /* Directory name malformed */
#define Err_file_name_err	(FERR-45) /* FIle name malformed (extra .?) */
#define Err_no_temp_devs (FERR-46) /* Temp files path doen't have any devs. */
#define Err_macrosync	 (FERR-47) /* Input macro out of sync */
#define Err_no_record	(FERR-48)	 /* Data record not found */
#define Err_end_of_record	(FERR-49)	 /* End of data record */
#define Err_no_temp_space	(FERR-50) /* out of space writing to temp device */

typedef struct type1_box
	{
	int xmin,ymin,xmax,ymax;
	} Type1_box;

#define BYTE_MAX 256

#define NCdefs  300                   /* Number of Charstring definitions */


class Type1_font
/* This is all the info on the font that is the same regardless of the
 * size we render it at. */
	{
	public:
		char fullname[256];
		int minx,miny,maxx,maxy;
		unsigned char **letter_defs;	 	 /* Character definitions */
		char **letter_names;				 /* Character names. */
		int letter_count;					 /* Number of letters. */
		unsigned char *ascii_defs[BYTE_MAX]; /* Character defs in ASCII order */
		int sub_count;                    	 /* Number of subroutines */
		unsigned char **subrs;         		 /* Subroutine definitions */
		char **encoding;              		 /* Active mapping vector. */
		int  encoding_count;				 /* Number of entries in encoding */
		Type1_box letter_bounds[BYTE_MAX];	 /* Bounds of letters (unscaled) */
		Type1_box font_bounds;				 /* Unscaled bounds of font. */
		int letter_width[BYTE_MAX];			 /* Width of letters (unscaled) */
		int font_widest;					 /* Width of widest (unscaled) */
		Type1_font() {
			fullname[0]=0;
			minx=miny=maxx=maxy=0;
			letter_defs = NULL;
			letter_names = NULL;
			letter_count = 0;
			sub_count = 0;
			subrs = NULL;
			encoding = NULL;
			encoding_count = 0;
			font_widest = 0;
			Type1_box empty = {0,0,0,0};
			font_bounds = empty;
			for(int i = 0; i < BYTE_MAX; ++i) {
				ascii_defs[i] = NULL;
				letter_bounds[i] = empty;
				letter_width[i] = 0;
				}
			}
	};

typedef struct type1_output
	{
	/* This guy tells the interpreter where to send drawing commands. */
	Errcode (*letter_open)(struct type1_output *fo);
	Errcode (*letter_close)(struct type1_output *fo);
	Errcode (*shape_open)(struct type1_output *fo, double x, double y);
	Errcode (*shape_close)(struct type1_output *fo);
	Errcode (*shape_point)(struct type1_output *fo, double x, double y);
	void *data;		/* Hang data specific implementations of letter_open, etc.
					 * might want here. */
	} Type1_output;

#endif // __TYPE1_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Cammap\cammap.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by CamMap.rc
//
#define IDS_CAMMAPCLASSNAME             1
#define IDS_CAMERAMAP                   2
#define IDS_CAMERAMAPPING               3
#define IDS_MAXSURFACE                  4
#define IDS_CAMERAMAPBINDING            5
#define IDS_CAMERAMAPMODIFIER           6
#define IDS_CAMMAPTITLE                 7
#define IDS_CAMMAPOBJECT                8
#define IDS_CAMERAMAPPINGMODIFIER       9
#define IDS_NONE                        10
#define IDS_PICKCAMERA                  11
#define IDS_ILLEGALCAM                  12
#define IDS_SOT                         13
#define IDS_SHOULDRESET                 14
#define IDS_SETCHANNEL                  15
#define IDD_WSMOD                       101
#define IDD_OBJ                         102
#define IDD_MOD                         103
#define IDC_PICK                        1000
#define IDC_CAMERA_NAME                 1001
#define IDC_MAP_CHAN1                   1002
#define IDC_MAP_CHAN2                   1003
#define IDC_MAP_CHAN_EDIT               1004
#define IDC_MAP_CHAN_SPIN               1005
#define IDC_MAP_CHAN_1                  1006
#define IDC_MAP_CHAN_0                  1007

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        16
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1008
#define _APS_NEXT_SYMED_VALUE           104
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\bezfont\adobet1.cpp ===
/**********************************************************************
 *<
	FILE: adobet1.cpp

	DESCRIPTION:  Adobe Type 1 bezier font file import module

	CREATED BY: Tom Hudson

	HISTORY: created 2 November 1995

 *>	Copyright (c) 1995, All Rights Reserved.
 **********************************************************************/

#include "Max.h"
#include <stdio.h>
#include <direct.h>
#include <commdlg.h>
#include <setjmp.h>
#include "splshape.h"
#include "bezfont.h"
#include "type1.h"
#include "at1rc.h"

// Uncomment the following for debugging prints
//#define DBGAT1

TCHAR *GetString(int id);

HINSTANCE hInstance;
char gp_buffer[256];

#define ADOBET1_LOADER_CLASS_ID 0x1810

// A table of generic pointers
typedef Tab<void *> PtrList;

// Our open font data storage class
class Type1OpenFont {
	public:
		BEZFONTHANDLE handle;	// The handle theBezFontManager has assigned this font
		PtrList ptrs;			// The allocations used by this font		
		Type1_font data;		// The actual font
		Type1OpenFont() {}
		~Type1OpenFont();
		void AddAlloc(void *ptr);
		void *Alloc(int size, int number=1);
	};

Type1OpenFont::~Type1OpenFont() {
	int count = ptrs.Count();
	for(int i = 0; i < count; ++i)
		free(ptrs[i]);
	ptrs.Delete(0, count);
	}

void Type1OpenFont::AddAlloc(void *ptr) {
	ptrs.Append(1, &ptr);
	}

void *Type1OpenFont::Alloc(int size, int number) {
	int bytes = size * number;
	void *ptr = malloc(bytes);
	if(ptr)
		AddAlloc(ptr);
	// Zero out the memory
	char *z = (char *)ptr;
	for(int i=0; i < bytes; ++i)
		*z++ = 0;
	return ptr;
	}

typedef Tab<Type1OpenFont *> Type1OpenFontTab;

/*

		Read and decrypt an Adobe Type 1 font.
		This code was written originally by John Walker
		using the _Adobe Type 1 Font Format 1.1_ published
		by Addison-Wesley ISBN 0-201-57044-0 as a guide.

		Jim Kent changed it a fair amount,  reformatting the
		indentation and renaming some of the identifiers to
		mix with the local style;  making the output go through
		functions embedded in a structure so the same interpreter 
		could be used for both sizing and drawing the font,  and
		putting in stuff to glue it into Animator Pro's font
		manager.  Also changed from line oriented parsing to token
		oriented parsing to accomodate some PD .PFB files.

		There are four main sections to this file set apart with
		long comment blocks.  One reads the font into memory.
		The second interprets the font language.  The third is concerned
		with directing the output of the interpreter into a form
		useful for PJ.  The final bit is the glue into the PJ
		virtual font system.

*/

#define DBGAT3

char t1_fullname[256];		/* Font name */
int t1_chars;			/* Chars in font */
int t1_width;			/* Current char width */
int t1_minx,t1_miny,t1_maxx,t1_maxy;

#define EOS     '\0'

#define X   0
#define Y   1


/*****************************************************************************
 *****************************************************************************
 ** The Load Section.  A PostScript Type 1 file is composed of a list of
 ** definitions.  Each definition is a keyword followed by data.  
 ** At the start of the file are a bunch of definitions that are about the
 ** font as a whole.  Then we come to the individual letters,   which are
 ** encrypted and in their own little RPN language.
 **
 ** The load section is concerned with verifying that the file is indeed
 ** a PostScript Type 1,  extracting a few things from the 
 ** pre-letter definitions,  and then decrypting
 ** the individual letters and the subroutines they use and sticking them 
 ** in a couple of arrays for later access.
 *****************************************************************************
 ****************************************************************************/

/*****************************************************************************
 * Let's handle errors (not enough memory, bad data in file, etc.) during
 * reading with a setjmp/longjmp.  The longjmp destination will be the
 * highest level read routine (read_font).
 ****************************************************************************/
static jmp_buf type1_load_errhandler; /* Jump buffer for load errors.	*/

/*static*/ void type1_load_error(char *msg)
/*
 * format & output an error message, then longjump to error handler.
 */
{
DebugPrint("AT1:%s\n",msg);
longjmp(type1_load_errhandler, Err_reported);
}


/*  Sections of the font file.  */
typedef enum { Header, FontInfo, OtherSubrs, Subrs, CharStrings } file_section;
static file_section section;

#define MAP_SIZE 256

/*  Map of PostScript character names to IBM code page 850 (multilingual) */
static char *isomap[MAP_SIZE] = {
	NULL,				 /*  00 */
	NULL,				 /*  01 */
	NULL,				 /*  02 */
	NULL,				 /*  03 */
	NULL,				 /*  04 */
	NULL,				 /*  05 */
	NULL,				 /*  06 */
	NULL,				 /*  07 */
	NULL,				 /*  08 */
	NULL,				 /*  09 */
	NULL,				 /*  10 */
	"ordmasculine",		 /*  11 */
	"ordfeminine",		 /*  12 */
	NULL,				 /*  13 */
	NULL,				 /*  14 */
	NULL,				 /*  15 */
	NULL,				 /*  16 */
	NULL,				 /*  17 */
	NULL,				 /*  18 */
	NULL,				 /*  19 */
	"paragraph",         /*  20 */
	"section",			 /*  21 */
	NULL,				 /*  22 */
	NULL,				 /*  23 */
	NULL,				 /*  24 */
	NULL,				 /*  25 */
	NULL,				 /*  26 */
	NULL,				 /*  27 */
	NULL,				 /*  28 */
	NULL,				 /*  29 */
	NULL,				 /*  30 */
	NULL,				 /*  31 */
    "space",             /*  32 */
    "exclam",            /*  33 */
    "quotedbl",          /*  34 */
    "numbersign",        /*  35 */
    "dollar",            /*  36 */
    "percent",           /*  37 */
    "ampersand",         /*  38 */
    "quotesingle",        /*  39 */		/* ?"quoteright"? */
    "parenleft",         /*  40 */
    "parenright",        /*  41 */
    "asterisk",          /*  42 */
    "plus",              /*  43 */
    "comma",             /*  44 */
    "hyphen",            /*  45 */
    "period",            /*  46 */
    "slash",             /*  47 */
    "zero",              /*  48 */
    "one",               /*  49 */
    "two",               /*  50 */
    "three",             /*  51 */
    "four",              /*  52 */
    "five",              /*  53 */
    "six",               /*  54 */
    "seven",             /*  55 */
    "eight",             /*  56 */
    "nine",              /*  57 */
    "colon",             /*  58 */
    "semicolon",         /*  59 */
    "less",              /*  60 */
    "equal",             /*  61 */
	"greater",           /*  62 */
    "question",          /*  63 */
    "at",                /*  64 */
    "A",                 /*  65 */
    "B",                 /*  66 */
    "C",                 /*  67 */
    "D",                 /*  68 */
    "E",                 /*  69 */
    "F",                 /*  70 */
    "G",                 /*  71 */
    "H",                 /*  72 */
    "I",                 /*  73 */
    "J",                 /*  74 */
    "K",                 /*  75 */
    "L",                 /*  76 */
    "M",                 /*  77 */
    "N",                 /*  78 */
    "O",                 /*  79 */
    "P",                 /*  80 */
    "Q",                 /*  81 */
    "R",                 /*  82 */
    "S",                 /*  83 */
    "T",                 /*  84 */
    "U",                 /*  85 */
    "V",                 /*  86 */
    "W",                 /*  87 */
    "X",                 /*  88 */
    "Y",                 /*  89 */
    "Z",                 /*  90 */
    "bracketleft",       /*  91 */
    "backslash",         /*  92 */
    "bracketright",      /*  93 */
    "asciicircum",       /*  94 */
    "underscore",        /*  95 */
    "grave",             /*  96 */
	"a",                 /*  97 */
    "b",                 /*  98 */
    "c",                 /*  99 */
    "d",                 /* 100 */
    "e",                 /* 101 */
    "f",                 /* 102 */
    "g",                 /* 103 */
    "h",                 /* 104 */
    "i",                 /* 105 */
    "j",                 /* 106 */
    "k",                 /* 107 */
    "l",                 /* 108 */
    "m",                 /* 109 */
    "n",                 /* 110 */
    "o",                 /* 111 */
    "p",                 /* 112 */
    "q",                 /* 113 */
    "r",                 /* 114 */
    "s",                 /* 115 */
    "t",                 /* 116 */
    "u",                 /* 117 */
    "v",                 /* 118 */
    "w",                 /* 119 */
    "x",                 /* 120 */
    "y",                 /* 121 */
    "z",                 /* 122 */
    "braceleft",         /* 123 */
    "bar",               /* 124 */
    "braceright",        /* 125 */
    "asciitilde",        /* 126 */
    NULL,            	 /* 127 */
    "Ccedilla",          /* 128 80 */
    "udieresis",         /* 129 */
    "eacute",            /* 130 */
    "acircumflex",       /* 131 */
	"adieresis",         /* 132 */
    "agrave",            /* 133 */
    "aring",             /* 134 */
    "ccedilla",          /* 135 */
    "ecircumflex",       /* 136 */
    "edieresis",         /* 137 */
    "egrave",            /* 138 */
    "idieresis",         /* 139 */
    "icircumflex",       /* 140 */
    "igrave",            /* 141 */
    "Adieresis",         /* 142 */
    "Aring",             /* 143 */
    "Eacute",            /* 144 90 */
    "ae",                /* 145 */
    "AE",                /* 146 */
    "ocircumflex",       /* 147 */
    "odieresis",         /* 148 */
    "ograve",            /* 149 */
    "ucircumflex",       /* 150 */
    "ugrave",            /* 151 */
    "ydieresis",         /* 152 */
    "Odieresis",         /* 153 */
    "Udieresis",         /* 154 */
    "oslash",            /* 155 9B */
    "sterling",          /* 156 */
    "Oslash",            /* 157 9D */
    "multiply",          /* 158 9E */	
    "florin",            /* 159 */  
    "aacute",            /* 160 A0 */
    "iacute",       	 /* 161 */
    "oacute",            /* 162 */
    "uacute",            /* 163 */
    "ntilde",            /* 164 */
    "Ntilde",            /* 165 */
    NULL,                /* 166 A6 ??? */	
	NULL,                /* 167 A7 ??? */
    "questiondown",      /* 168 */
    "registered",        /* 169 */
    "logicalnot",        /* 170 */
    "onehalf",           /* 171 */
    "onequarter",        /* 172 */
    "exclamdown",        /* 173 */
    "guillemotleft",                /* 174 AE */
    "guillemotright",                /* 175 AF */
    NULL,                /* 176 B0 ??? */
    NULL,                /* 177 B1 ??? */
    NULL,                /* 178 B2 ??? */
    NULL,                /* 179 B3 ??? */
    NULL,                /* 180 B4 ??? */
    "Aacute",            /* 181 */				
    "Acircumflex",       /* 182 */			
    "Agrave",            /* 183 */
    "copyright",         /* 184 */
    NULL,                /* 185 */				
    NULL,                /* 186 */			
    NULL,                /* 187 */		
    NULL,                /* 188 */	
    "cent",              /* 189 */
    "yen",               /* 190 */
    NULL,                /* 191 */
    NULL,                /* 192 C0 */
    "grave",             /* 193 C1 */		
    "acute",             /* 194 C2 */	
    "circumflex",        /* 195 C3 */
    "tilde",             /* 196 C4 */
    "macron",            /* 197 C5 */
    "atilde",            /* 198 C6 */				
    "Atilde",            /* 199 C7 */
    "dieresis",          /* 200 C8 */
    NULL,                /* 201 C9 */
	"ring",              /* 202 CA */
    "cedilla",           /* 203 CB */
    NULL,                /* 204 CC */
    "hungarumlaut",      /* 205 CD */
    "ogonek",                /* 206 CE */
    "currency",          /* 207 CF */
    "eth",               /* 208 DO */	
    "Eth",               /* 209 D1 */	
    "Ecircumflex",       /* 210 D2 */
    "Edieresis",         /* 211 D3 */
    "Egrave",            /* 212 D4 */
    NULL,                /* 213 D5 ??? */
    "Iacute",            /* 214 D6 */
    "Icircumflex",       /* 215 */
    "Idieresis",         /* 216 */
    NULL,                /* 217 */
    NULL,                /* 218 */
    NULL,                /* 219 */
    NULL,                /* 220 */
    "brokenbar",         /* 221 */
    "Igrave",            /* 222 */
    NULL,                /* 223 */
    "Oacute",            /* 224 E0 */
    "germandbls",        /* 225 */
    "Ocircumflex",       /* 226 */
    "Ograve",            /* 227 */
    "otilde",            /* 228 */
    "Otilde",            /* 229 */
    "mu",                /* 230 */
    "thorn",             /* 231 E7 */
    "Thorn",             /* 232 E8 */
    "Uacute",            /* 233 */
    "Ucircumflex",       /* 234 */
    "Ugrave",            /* 235 */
    "yacute",            /* 236 */
	"Yacute",            /* 237 */
    "macron",            /* 238 */
    "acute",             /* 239 EF */
    "hyphen",            /* 240 F0 */
    "plusminus",         /* 241 */
    NULL,                /* 242 */
    "threequarters",     /* 243 */
    "paragraph",         /* 244 */
    "dotlessi",          /* 245 F5 */
    "divide",            /* 246 */
    "cedilla",           /* 247 F7 */
    "degree",            /* 248 */
    "dieresis",          /* 249 F9 */
    "bullet",            /* 250 */
    "onesuperior",       /* 251 */
    "threesuperior",     /* 252 */
    "twosuperior",       /* 253 */
    NULL,                /* 254 */
    NULL                 /* 255 */
};

/*static*/ char *loader_strdup(Type1OpenFont *font, char *s)
/*  STRSAVE  --  Allocate a duplicate of a string.  */
{
	char *c = (char *)font->Alloc(strlen(s) + 1);
	if(c)
		strcpy(c, s);
	return c;
}


/*****************************************************************************
 * File input.
 ****************************************************************************/

static int (*byte_in)(FILE *fp);	/* Call indirect to read a byte.
									 * Will be at1_getc() or hex_byte_in() */

/*static*/ int hex_byte_in(FILE *fp)
/* Read a byte from file in hexadecimal format.  This skips white space,
 * and reads in two hex digits. */
{
    int xd = 0, i;
	char c;

    for (i = 0; i < 2; i++) {
		for (;;) {
			if(fread(&c,1,1,fp)!=1)
				return(EOF);
            if (isspace(c))
                continue;
            break;
        }
		if (islower(c))
			c = toupper(c);
        if (c >= '0' && c <= '9') {
            c -= '0';
		} else if (c >= 'A' && c <= 'F') {
            c = (c - 'A') + 10;
		} else {
            type1_load_error("Bad hex digit");
            return EOF;
        }
        xd = (xd << 4) | c;
    }
    return xd;
}

int at1_getc(FILE *fp)
{
unsigned char c;
if(fread(&c,1,1,fp)!=1)
	return(EOF);
return((int)c);
}

/*****************************************************************************
 *  DECRYPT  --  Perform running decryption of file.  
 ****************************************************************************/

static unsigned short int cryptR, cryptC1, cryptC2, cryptCSR;

static void crypt_init( unsigned int key)
{
	cryptR = key;
    cryptC1 = 52845;
    cryptC2 = 22719;
}

/*static*/ unsigned int decrypt(unsigned int cipher)
{
    unsigned int plain = (cipher ^ (cryptR >> 8));

    cryptR = (cipher + cryptR) * cryptC1 + cryptC2;
	return plain;
}

/*static*/ int decrypt_byte_in(FILE *fp)
{
	int ch;

	if ((ch = (*byte_in)(fp)) == EOF)
		return EOF;
	else
		return decrypt(ch);
}

/*static*/ void cstrinit(void)
{
    cryptCSR = 4330;
}

/*static*/ unsigned int decstr(unsigned int cipher)
{
    unsigned int plain = (cipher ^ (cryptCSR >> 8));

    cryptCSR = (cipher + cryptCSR) * cryptC1 + cryptC2;
    return plain;
}

/*****************************************************************************
 *  PARSER  --  Chop up file a line at a time and decide what to put where...
 ****************************************************************************/


typedef enum 
	{
	TTT_EOF,
	TTT_NAME,
	TTT_NUMBER,
	TTT_OTHER,
	TTT_TOO_LONG,
	} T1_token_type;

typedef struct
	{
	T1_token_type type;
	char string[256];
	int pushback;
	FILE *file;
	int (*source)(FILE *f);
	} Type1_token;

/*static*/ void type1_token_init(Type1_token *tok, FILE *file, int (*source)(FILE *f))
{
	memset(tok,0,sizeof(Type1_token));
	tok->file = file;
	tok->source = source;
}


/*static*/ BOOL continue_number(int ch)
/* Return true if character is a digit */
{
	return isdigit(ch);
}

/*static*/ BOOL continue_name(int ch)
/* Return true if character can be the second or further character in 
 * a name. */
{
	return ch == '_' || isalnum(ch);
}

/*static*/ void type1_get_binary(Type1_token *tok, unsigned char *buf, int size)
/* Read in X number of bytes.  Account for any pushed-back characters. 
 * Bails out if not enough bytes left. */
{
	int ch;
	int i = 0;

	if (tok->pushback != 0)
		{
		*buf++ = tok->pushback;
		i = 1;
		tok->pushback = 0;
		}
	for (; i<size; ++i)
		{
		if ((ch = tok->source(tok->file)) == EOF)
			{
			sprintf(gp_buffer,"Could only read %d of %d bytes.", i, size);
			type1_load_error(gp_buffer);
			}
		*buf++ = ch;
		}
}

/*static*/ void type1_get_token(Type1_token *token)
/* Read in a token from file and categorize it. 
 * In this case a token is a run of numbers, a letter followed by 
 * letters and numbers, or a single non-alpha-numeric character.  
 * White space serves to separate tokens but is otherwise skipped. 
 * Pass in a "source" function to get next character from file. 
 */
{
	int ch;
	int size = 0;
	BOOL (*get_next)(int ch);
	int tok_len = sizeof(token->string);
	char *string = token->string;

	/* Get pushed-back character if any. */
	if (token->pushback == 0)
		ch = token->source(token->file);
	else
		{
		ch = token->pushback;
		token->pushback = 0;
		}
	/* Skip leading spaces. */
	for (;;)
		{
		if (ch == EOF)
			{
			token->type = TTT_EOF;
			strcpy(token->string, "<EOF>");	/* For error reporting. */
			return;
			}
		if (!isspace(ch))
			break;
		ch = token->source(token->file);
		}
	if (isdigit(ch))
		{
		get_next = continue_number;
		token->type = TTT_NUMBER;
		}
	else if (ch == '_' || isalpha(ch))
		{
		get_next = continue_name;
		token->type = TTT_NAME;
		}
	else
		{
		*string++ = ch;
		*string = 0;
		token->type = TTT_OTHER;
		return;
		}
	for (;;)
		{
		if (--tok_len <= 0)
			{
			token->type = TTT_TOO_LONG;
			return;
			}
		*string++ = ch;
		ch = token->source(token->file);
		if (!(*get_next)(ch))
			{
			token->pushback = ch;
			*string = EOS;
			return;
			}
		}
}

/*static*/ Errcode type1_check_signature(FILE *fp)
/* This just verifies that the font begins with %!FontType1 or
 * %!PS-AdobeFont-1.0.  We expect this in the first 128 bytes or so. */
{
	int ch;
	int i;
	char buf[80];
	static char magic1[] = "PS-AdobeFont-1.0";
	static char magic2[] = "FontType1";

	for (i=0; i<128; ++i)
		{
		ch = at1_getc(fp);
		if (ch == EOF)
			break;
		if (ch == '%') 
			{
			ch = at1_getc(fp);
            if (ch == EOF)
				break;
            if (ch == '!')
				{
				if (fread(buf,80,1,fp)!=1)
					break;
				if (strncmp(buf, magic1, strlen(magic1)) == 0
				||	strncmp(buf, magic2, strlen(magic2)) == 0)
					return Success;
				}
	        }
		}
	return Err_bad_magic;
}

static void type1_parse_custom_encoding(Type1OpenFont *font, Type1_token *tok, int size)
/* Read in a bunch of custom encoding statements (that are used to 
 * associate letter names with ASCII values basically. */
{
	int char_ix;
	int i;

	font->data.encoding_count = size;
	font->data.encoding = (char**)font->Alloc(size * sizeof(*(font->data.encoding)));

	for (i=0; i<size; ++i)
		{
		type1_get_token(tok);
		if (tok->type == TTT_EOF)
			type1_load_error("Premature end of file in Encoding");
		if (tok->type == TTT_NAME)
			{
			if (strcmp(tok->string, "dup") == 0)
				{
				/* This should be the start of a sequence formmatted:
				 * 		dup NN /name put
				 */
				type1_get_token(tok);			/* get NN into char_ix */
				if (tok->type != TTT_NUMBER)
					goto SYNTAX_ERROR;
				char_ix = atoi(tok->string);
				if (char_ix < 0 || char_ix >= size)
					{
					sprintf(gp_buffer,"Character index %d out of range.",char_ix);
					type1_load_error(gp_buffer);
					}
				type1_get_token(tok);			/* Skip over /  */
				if (tok->type != TTT_OTHER && tok->string[0] != '/')
					goto SYNTAX_ERROR;
				type1_get_token(tok);			/* Get name into encoding. */
				if (tok->type == TTT_NAME)
					{
					font->data.encoding[char_ix] = loader_strdup(font,tok->string);
					}
				type1_get_token(tok);			/* Skip over put */
				}
			else if (strcmp(tok->string, "def") == 0)
				return;
			}
		}
	return;
SYNTAX_ERROR:
	type1_load_error("Syntax error in Encoding");
}

static void type1_parse_encoding(Type1OpenFont *font, Type1_token *tok)
/* Parse the encoding statement - which determines how names of letters
 * match up with ascii values. This will either just be StandardEncoding,
 * or it will be an array of name/number pairs. */
{
	long encode_size;

	type1_get_token(tok);
	if (tok->type == TTT_NAME 
	&& ((strcmp(tok->string, "StandardEncoding") == 0)
	|| (strcmp(tok->string, "ISOLatin1Encoding") == 0)))
		{
		font->data.encoding = isomap;
		font->data.encoding_count = 256;
		return;
		}
	if (tok->type == TTT_NUMBER)
		{
		encode_size = atoi(tok->string);
		type1_get_token(tok);
		if (tok->type == TTT_NAME 
		&& strcmp(tok->string, "array") == 0)
			{
			type1_parse_custom_encoding(font, tok, encode_size);
			return;
			}
		}
	type1_load_error("Strange /Encoding");
}

/*static*/ void type1_parse_fullname(Type1OpenFont *font, Type1_token *tok)
/* Gets the font name out of the file */
{
	char name[256]="";

	type1_get_token(tok);
	if(strcmp(tok->string,"(")==0)
		{
		loop:
		type1_get_token(tok);
		if(strcmp(tok->string,")")!=0)
			{
			if((strlen(name)+strlen(tok->string)+1)<255)
				{
				strcat(name,tok->string);
				strcat(name," ");
				goto loop;
				}
			}
		if(strlen(name))
			name[strlen(name)-1]=0;
		strcpy(font->data.fullname,name);
		return;
		}
	type1_load_error("Strange /FullName");
}

int get_type1_number(Type1_token *tok,int *rval)
{
	int neg=0,val;

	type1_get_token(tok);
	if(strcmp(tok->string,"-")==0)
		{
		type1_get_token(tok);
		neg=1;
		}
	if(tok->type==TTT_NUMBER)
		{
		sscanf(tok->string,"%d",&val);
		if(neg)
			val= -val;
		*rval=val;
		return(1);
		}
	return(0);
}

/*static*/ void type1_parse_fontbbox(Type1OpenFont *font, Type1_token *tok)
/* Gets the font bounding box out of the file */
{
	int b1,b2,b3,b4;

	type1_get_token(tok);
	if(strcmp(tok->string,"{")==0 || strcmp(tok->string,"[")==0)
		{
		if(get_type1_number(tok,&b1)==0)
			goto error;
		if(get_type1_number(tok,&b2)==0)
			goto error;
		if(get_type1_number(tok,&b3)==0)
			goto error;
		if(get_type1_number(tok,&b4)==0)
			goto error;
/*
sprintf(gp_buffer,"BBOX: %d %d %d %d",b1,b2,b3,b4);
DebugPrint(gp_buffer);
*/
		font->data.minx=0;
		font->data.miny=0;
		font->data.maxx=b3-b1;
		font->data.maxy=b4-b2;
		return;
		}
	error:
	type1_load_error("Invalid font bounding box");
}

static void type1_parse_public_definition(Type1OpenFont *font, Type1_token *tok)
/* Cope with /XXXX definitions during the public (unencrypted) part of
 * the font.  Right now we ignore everything except /Encoding. */
{
	type1_get_token(tok);

	if (tok->type != TTT_NAME)
		return;
	if (strcmp(tok->string, "Encoding") == 0)
		type1_parse_encoding(font, tok);
	else
	if (strcmp(tok->string, "FullName") == 0)
		type1_parse_fullname(font, tok);
	else
	if (strcmp(tok->string, "FontBBox") == 0)
		type1_parse_fontbbox(font, tok);
}

static void type1_parse_to_eexec(Type1OpenFont *font, Type1_token *tok)
/* Read through unencrypted part of the file.  Stop at "eexec" 
 * statement. */
{
	/* First, read to the first '/' encountered */
	for(;;)
		{
		int c;
		c=at1_getc(tok->file);
		if(c==EOF)
			return;
		if(c=='/')
			{
			tok->pushback=c;
			break;
			}
		}
	for (;;)
		{
		type1_get_token(tok);
		switch (tok->type)
		  {
		  case TTT_EOF:
		    type1_load_error("No eexec in Type1 font file.");
			break;
		  case TTT_NAME:
		    if (strcmp(tok->string, "eexec") == 0)
				return;
			break;
		  case TTT_OTHER:
			if (tok->string[0] == '/')
			    type1_parse_public_definition(font, tok);
			break;
		  default:
		  	break;
		  }
		}
}

static void type1_find_mode(Type1OpenFont *font, FILE *fp)
/* 
   (John Walker's comment on how to tell hex from binary.)
   "Adobe Type 1 Font Format Version 1.1", ISBN 0-201-57044-0 states
   on page 64 that one distinguishes an ASCII from a Hexadecimal
   font file by two tests:

		* The first ciphertext byte must not be an ASCII white space
			  character (blank, tab, carriage return or line feed).
		* At least one of the first 4 ciphertext bytes must not be one
		  of the ASCII hexadecimal character codes (a code for 0-9,
		  A-F, or a-f).  These restrictions can be satisfied by adjusting
		  the random plaintext bytes as necessary.

   Well, notwithstanding this statement, Adobe's own Helvetica Bold
   Narrow Oblique file furnished with Adobe Type Manager for Windows
   has a carriage return as the first byte after the eexec invocation.
   Consequently, I turned off recognition of a hex file by the
   presence of a carriage return. */
{
	char cs[4];
	long encrypt_start;
	int i;

	encrypt_start = ftell(fp);
	cs[0] = at1_getc(fp);

	if (cs[0] == ' ' || cs[0] == '\t' ||
		/* cs[0] == '\r' || */
		cs[0] == '\r' ||
		cs[0] == '\n') 
		{
		byte_in = hex_byte_in;
        } 
	else 
		{
		for (i = 1; i < 4; i++) 
			{
			cs[i] = at1_getc(fp);
            }
		byte_in = hex_byte_in;
		for (i = 0; i < 4; i++) 
			{
			if (!((cs[i] >= '0' && cs[0] <= '0') ||
				  (cs[i] >= 'A' && cs[0] <= 'F') ||
				  (cs[i] >= 'a' && cs[0] <= 'f'))) 
				{
				byte_in = at1_getc;
				break;
                }
            }
        }

	fseek(fp, encrypt_start, SEEK_SET);	/* Reread encrypted random bytes as
										 * the decrypter depends on everything
										 * from encrypt_start on going through
										 * byte_in(). */
}

static int type1_get_number(Type1_token *tok)
/* Get next token,  make sure it's a number,  and return the
 * atoi'd value of number. */
{
	type1_get_token(tok);
	if (tok->type != TTT_NUMBER)
		{
		sprintf(gp_buffer,"Expecting number got %s", tok->string);
		type1_load_error(gp_buffer);
		}
	return atoi(tok->string);
}

static void type1_force_symbol(Type1_token *tok, char *symbol)
/* Get next token.  Verify that it matches symbol. */
{
	type1_get_token(tok);
	if (tok->type != TTT_NAME || strcmp(tok->string, symbol) != 0)
		{
		sprintf(gp_buffer,"Expecting %s got %s", symbol, tok->string);
		type1_load_error(gp_buffer);
		}
}

static void type1_skip_to(Type1_token *tok, char *symbol)
/* Skip tokens until come to one that matches symbol. */
{
	for (;;)
		{
		type1_get_token(tok);
		if (tok->type == TTT_EOF)
			{
			sprintf(gp_buffer,"End of file looking for %s\n", symbol);
			type1_load_error(gp_buffer);
			}
		if (strcmp(tok->string, symbol) == 0)
			return;
		}
}


static void type1_force_RD(Type1_token *tok)
/* Make sure that the next bit in the input is either "RD" or "-|" 
 * Also skip the following white space.  */
{
	unsigned char buf[4];

	type1_get_token(tok);
	if (strcmp(tok->string, "RD") == 0)
		{
		type1_get_binary(tok, buf, 1);	/* Skip white space. */
		return;
		}
	if (tok->string[0] == '-')
		{
		type1_get_binary(tok, buf, 2);
		if (buf[0] == '|')
			return;
		}
	type1_load_error("Expecting RD or -|");
}

static void type1_read_encoded_buffer(Type1_token *token, unsigned char *str, int size)
/* Read in bytes from file and (doubly) decrypt.  
 * You may wonder what happens to any pushed-back characters.
 * Well, this is only called in contexts where there will be no
 * pushbacks. */
{
	int i;

	cstrinit();	/* Initialize string decryption. */
	/* We'll throw out the first 4 characters,  only using them
	 * to cycle the decryptor.  */
	for (i=0; i<4; ++i)	/* Decrypt next three. */
		decstr(token->source(token->file));
	/* Now read in and decrypt (again) the string. */
	while (--size >= 0)
		*str++ = decstr(token->source(token->file));
}

static unsigned char *alloc_and_read_RD_string(Type1OpenFont *font,	Type1_token *tok, int binary_size)
{
	unsigned char *buf;

	type1_force_RD(tok);
	buf = (unsigned char *)font->Alloc(binary_size);
	type1_read_encoded_buffer(tok, buf, binary_size);
	return buf;
}

static void type1_get_subrs(Type1OpenFont *font, Type1_token *tok)
{
/* The Subrs format should be of the form:
 *	NN array 
 *		dup NN NN RD xxxxxxx NP
 *				...
 *		dup NN NN RD xxxxxxx NP
 */
	int sub_count;
	int sub_ix;
	int binary_size;
	unsigned char **subrs;
	int i;

	font->data.sub_count = sub_count = type1_get_number(tok);
	font->data.subrs = subrs = (unsigned char **)font->Alloc(sub_count * sizeof(*subrs));
	type1_force_symbol(tok, "array");
	for (i=0; i<sub_count; ++i)
		{
		type1_skip_to(tok, "dup");
		sub_ix = type1_get_number(tok);
		if (sub_ix < 0 || sub_ix >= sub_count)
			{
			sprintf(gp_buffer,"Subr %d out of range (0-%d).", sub_ix, sub_count);
			type1_load_error(gp_buffer);
			}
		binary_size = type1_get_number(tok) - 4;
		subrs[sub_ix] = alloc_and_read_RD_string(font, tok, binary_size);
		}
}

static void type1_get_char_strings(Type1OpenFont *font, Type1_token *tok)
{
/* The CharStrings format should be of the form:
 *	NN dict dup begin 
 *		/name NN RD xxxxxxx ND
 *				...
 *		/name NN RD xxxxxxx ND
 */
	int letter_count;
	char **letter_names;
	unsigned char **letter_defs;
	int letter_ix = 0;
	int binary_size;

	font->data.letter_count = letter_count = type1_get_number(tok);
	font->data.letter_names = letter_names 
		= (char **)font->Alloc(letter_count * sizeof(*letter_names));
	font->data.letter_defs = letter_defs
		= (unsigned char **)font->Alloc(letter_count * sizeof(*letter_defs));
	for (;;)
		{
		type1_get_token(tok);
		if (tok->type == TTT_EOF)
			return;		/* Oh heck, probably have most of the font by now. */
		else if (tok->type == TTT_NAME && strcmp(tok->string, "end") == 0)
			return;
		else if (tok->type == TTT_OTHER && tok->string[0] == '/')
			{
			type1_get_token(tok);
			if (tok->string[0] == '.')	
				{
				/* Here hopefully all we are doing is converting
				 * ".notdef" to "notdef" */
				type1_get_token(tok);
				}
			if (tok->type == TTT_NUMBER)
				{	/* bocklin.pfb has a character with a missing name.
					 * Well, I geuss we kludge around it here... */
				letter_names[letter_ix] = loader_strdup(font, "");
				binary_size = atoi(tok->string);
				}
			else
				{
				letter_names[letter_ix] = loader_strdup(font, tok->string);
				binary_size = type1_get_number(tok);
				}
			letter_defs[letter_ix] = alloc_and_read_RD_string(font, tok, binary_size);
			if (++letter_ix >= letter_count)
				return;
			}
		}
}

/*****************************************************************************
 *****************************************************************************
 ** The Interpreter Section.  This section deals with interpreting the
 ** little reverse-polish-notation language that describes the letters in
 ** the font.  
 *****************************************************************************
 ****************************************************************************/

enum cscommand {
/*  Charstring command op-codes.  */
	Unused_0,
	Hstem,
	Unused_2,
	Vstem,
	Vmoveto,
	Rlineto,
	Hlineto,
	Vlineto,
	Rrcurveto,
	Closepath,
    Callsubr,
    Return,
    Esc/*ape*/,		// Need to do this to avoid collision
    Hsbw,
    Endchar,
    Unused_15,
    Unused_16,
    Unused_17,
    Unused_18,
    Unused_19,
    Unused_20,
    Rmoveto,
	Hmoveto,
    Unused_23,
    Unused_24,
    Unused_25,
    Unused_26,
    Unused_27,
    Unused_28,
    Unused_29,
    Vhcurveto,
    Hvcurveto,

    /* 12 x commands */

    Dotsection,
    Vstem3,
    Hstem3,
    Unused_12_3,
    Unused_12_4,
    Unused_12_5,
    Seac,
    Sbw,
    Unused_12_8,
    Unused_12_9,
    Unused_12_10,
    Unused_12_11,
    Div,
    Unused_12_13,
    Unused_12_14,
    Unused_12_15,
    Callothersubr,
    Pop,
    Unused_12_18,
    Unused_12_19,
    Unused_12_20,
    Unused_12_21,
	Unused_12_22,
    Unused_12_23,
    Unused_12_24,
    Unused_12_25,
    Unused_12_26,
    Unused_12_27,
    Unused_12_28,
    Unused_12_29,
    Unused_12_30,
    Unused_12_31,
    Unused_12_32,
    Setcurrentpoint
};

#define StackLimit  25
#define OtherLimit  10                /* Maximum othersubr return values */

#define Sl(n) if (sp < (n)) {fflush(stdout); DebugPrint("Stack underflow.\n"); return(0);}
#define Npop(n) sp -= (n)
#define So(n) if ((sp + (n)) > StackLimit) {fflush(stdout); DebugPrint("Stack overflow.\n"); return 0;}
#define Clear() sp = 0

#define S0  stack[sp - 1]
#define S1  stack[sp - 2]
#define S2  stack[sp - 3]
#define S3  stack[sp - 4]
#define S4  stack[sp - 5]
#define S5  stack[sp - 6]

static long stack[StackLimit];        /* Data stack */
static int sp;                        /* Stack pointer */
static long osres[OtherLimit];        /* Results from othersubrs */
static int orp;                       /* Othersubr result pointer */

#define ReturnStackLimit 10

static unsigned char *rstack[ReturnStackLimit]; /* Return stack */
static int rsp;                       /* Return stack pointer */

static int curx, cury;			      /* The current point */
static int flexing;			          /* If a Flex in progress ? */
static int flexx, flexy;              /* Flex current position */

static int bnum;                  	  /* Line segments per Bezier curve */

static int pcount;

/* 3D Studio bezier spline character from Adobe description code */

/*  BEZIER  --	Evaluate a Bezier curve defined by four control
		points.  */

static Spline3D *curSpline = NULL;
static int a1lastx,a1lasty;
static int nested=0;

/*static*/ void bezier(BezierShape &shape,int x0, int y0, int x1, int y1, int x2, int y2,
	int x3, int y3)
{
if(!curSpline)
	curSpline = shape.NewSpline();
int knots = curSpline->KnotCount();
if(knots == 0) {
	curSpline->AddKnot(SplineKnot(KTYPE_BEZIER, LTYPE_CURVE, Point3(x0,y0,0), Point3(x0,y0,0), Point3(x1,y1,0)));
	curSpline->AddKnot(SplineKnot(KTYPE_BEZIER, LTYPE_CURVE, Point3(x3,y3,0), Point3(x2,y2,0), Point3(x3,y3,0)));
	}
else {
	// First point of this curve must be the same as the last point on the output curve
	assert(curSpline->GetKnotPoint(knots-1) == Point3(x0,y0,0));
	curSpline->SetOutVec(knots-1, Point3(x1,y1,0));
	if(Point3(x3,y3,0) == curSpline->GetKnotPoint(0)) {
		curSpline->SetInVec(0, Point3(x2,y2,0));
		curSpline->SetClosed();
		curSpline = NULL;
		}
	else
		curSpline->AddKnot(SplineKnot(KTYPE_BEZIER, LTYPE_CURVE, Point3(x3,y3,0), Point3(x2,y2,0), Point3(x3,y3,0)));
	}
a1lastx=x3;
a1lasty=y3;
curx=x3;
cury=y3;
#ifdef DBGAT3
printf("%d %d to %d %d\n",x0,y0,x3,y3);
#endif
}

/*----------------------------------------------------------------------*
 * Interpret an "other subroutine".  I'm not 100% sure what all this
 * can be.  There are some predefined ones for all fonts,  but potentially they
 * can reside in the file too?
 *----------------------------------------------------------------------*/

static void othersubr(BezierShape &shape, int procno, int nargs, int argp)
{
    static int flexp;                 /* Flex argument pointer */
    static int flexarg[8][2];

    orp = 0;                          /* Reset othersubr result pointer */

	switch (procno) {
        case 0:                       /* Flex */
#ifdef DBGAT3
printf("Othersubr(0), Doing flex bezier\n");
#endif
			bezier(shape,
					flexarg[0][X], flexarg[0][Y],
					flexarg[2][X], flexarg[2][Y],
					flexarg[3][X], flexarg[3][Y],
					flexarg[4][X], flexarg[4][Y]);
			bezier(shape,
					flexarg[4][X], flexarg[4][Y],
					flexarg[5][X], flexarg[5][Y],
					flexarg[6][X], flexarg[6][Y],
					flexarg[7][X], flexarg[7][Y]);
            osres[orp++] = stack[argp + 3];
            osres[orp++] = stack[argp + 2];
            flexing = FALSE;          /* Terminate flex */
#ifdef DBGAT3
printf("Flexing OFF\n");
#endif
            break;

        case 1:                       /* Flex start */
#ifdef DBGAT3
printf("Othersubr(1), Flexing ON\n");
#endif
            flexing = TRUE;           /* Mark flex underway */
            flexx = curx;
            flexy = cury;
            flexp = 0;
            /* Note fall-through */
        case 2:                       /* Flex argument specification */
#ifdef DBGAT3
printf("Othersubr(2)\n");
#endif
            flexarg[flexp][X] = flexx;
            flexarg[flexp++][Y] = flexy;
            break;

        case 3:                       /* Hint replacement */
#ifdef DBGAT3
printf("Othersubr(3)\n");
#endif
			osres[orp++] = 3;		  /* This eventually results in
									   * subroutine 3 being called.
									   * Since subroutine 3 does nothing
									   * but return, one can only guess
									   * what Adobe had in mind designing
									   * this. */
            break;

        default:
    /*        fprintf(stderr, "\nCall to undefined othersubr %d\n",
                procno); */
			break;
    }
}

/*  EXCHARS  --  Execute charstring.  */

/*static*/ int exchars(Type1OpenFont *font,int *pwidth,unsigned char *cp,BezierShape &shape,int ix,int iy)
{
    int sub;

    sp = rsp = 0;		      /* Reset stack pointer */
	flexing = FALSE;          

    while (TRUE)
		{
		int c = *cp++;

		if (c < 32)
			{
			/* Command */
			if (c == 12)
				{
				/* Two byte command */
				c = *cp++ + 32;
				}

		    switch (c)
				{

				/* Commands for Starting and Finishing */

				case Endchar:	      /* 14: End character */
#ifdef DBGAT3
printf("Endchar\n");
#endif
				if(curSpline)
					assert(0);
				curSpline = NULL;
				a1lastx=a1lasty=0;
				Clear();
				goto exdone;

			case Hsbw:	      /* 13:  Set horizontal sidebearing */
			    Sl(2);
			    curx=a1lastx=S1+ix;
			    cury=a1lasty=0+iy;
				if(nested==0)
				    *pwidth=t1_width=S0;
#ifdef DBGAT3
printf("Hsbw: %d\n",t1_width);
#endif
			    Clear();
			    break;

			case Seac: {	      /* 12-6:	Standard encoding accented char */
				int lwidth;
				unsigned char *base, *accent;
				unsigned base_ix = S1, accent_ix = S0;
				int xoff = S3, yoff = S2, asb = S4; 
				int fx = curx, fy = cury;
			    Sl(5);
#ifdef DBGAT3
printf("Seac\n");
#endif
				nested=1;
				if (base_ix < BYTE_MAX)
					{
					if ((base = font->data.ascii_defs[base_ix]) != NULL)
						{
						if (exchars(font, &lwidth, base, shape, ix, iy)==0)
							{
							nested=0;
							DebugPrint("Error decoding Seac base");
							return(0);
							}
						}
					}
				if (accent_ix < BYTE_MAX)
					{
					if ((accent = font->data.ascii_defs[accent_ix]) != NULL)
						{
						if (exchars(font, &lwidth, accent, shape,
								ix+xoff+fx-asb, iy+fy+yoff)==0)
							{
							nested=0;
							DebugPrint("Error decoding Seac accent");
							return(0);
							}
						}
					}
				nested=0;
				if(curSpline)
					assert(0);
				curSpline = NULL;
				a1lastx=a1lasty=0;
			    Clear();
			    goto exdone;
				}

			case Sbw:	      /* 12-7:	Sidebearing point (x-y) */
			    Sl(4);
			    curx = a1lastx = S3+ix;
			    cury = a1lasty = S2+iy;
				if(nested==0)
				    *pwidth=t1_width=S0;
#ifdef DBGAT3
printf("Sbw: %d\n",t1_width);
#endif
			    Clear();
			    break;

			/* Path Construction Commands */

			case Closepath:       /* 9:  Close path */
#ifdef DBGAT3
printf("Closepath\n");
#endif
				if(curSpline) {
					curSpline->SetClosed();
					curSpline = NULL;
					}
			    Clear();
			    break;

			case Hlineto:	      /* 6: Horizontal line to */
			    Sl(1);
#ifdef DBGAT3
printf("Hlineto ");
#endif
			    bezier(shape,curx,cury,curx,cury,curx+S0,cury,curx+S0,cury);
			    Clear();
			    break;

			case Hmoveto:	      /* 22:  Horizontal move to */
			    Sl(1);
#ifdef DBGAT3
printf("Hmoveto ");
#endif
				if (flexing)
					flexx += S0;
				else
				    curx += S0;
			    Clear();
			    break;

			case Hvcurveto:       /* 31:  Horizontal-vertical curve to */
			    Sl(4);
#ifdef DBGAT3
printf("Hvcurveto ");
#endif
			    bezier(shape,curx, cury, curx + S3, cury,
				   curx + S3 + S2, cury + S1,
				   curx + S3 + S2, cury + S1 + S0);
			    Clear();
			    break;

			case Rlineto:	      /* 5:  Relative line to */
			    Sl(2);
#ifdef DBGAT3
printf("Rlineto ");
#endif
			    bezier(shape,curx,cury,curx,cury,
					curx+S1,cury+S0,curx+S1,cury+S0);
			    Clear();
			    break;

			case Rmoveto:	      /* 21:  Relative move to */
			    Sl(2);
#ifdef DBGAT3
printf("Rmoveto %d %d\n",curx+S1,cury+S0);
#endif
				if (flexing) 
					{
					flexx += S1;
					flexy += S0;
					}
				else
					{
				    curx += S1;
				    cury += S0;
					}
			    Clear();
			    break;

			case Rrcurveto:       /* 8:  Relative curve to */
			    Sl(6);
#ifdef DBGAT3
printf("Rrcurveto ");
#endif
			    bezier(shape, curx, cury, curx + S5, cury + S4,
				   curx + S5 + S3, cury + S4 + S2,
				   curx + S5 + S3 + S1, cury + S4 + S2 + S0);
			    Clear();
			    break;

			case Vhcurveto:       /* 30:  Vertical-horizontal curve to */
			    Sl(4);
#ifdef DBGAT3
printf("Vhcurveto ");
#endif
			    bezier(shape, curx, cury, curx, cury + S3,
				   curx + S2, cury + S3 + S1,
				   curx + S2 + S0, cury + S3 + S1);
			    Clear();
			    break;

			case Vlineto:	      /* 7:  Vertical line to */
			    Sl(1);
#ifdef DBGAT3
printf("Vlineto ");
#endif
			    bezier(shape, curx,cury,curx,cury,curx,cury+S0,curx,cury+S0);
			    Clear();
			    break;

			case Vmoveto:	      /* 4:  Vertical move to */
			    Sl(1);
#ifdef DBGAT3
printf("Vmoveto %d %d\n",curx,cury+S0);
#endif
				if (flexing)
					flexy += S0;
				else
				    cury += S0;
			    Clear();
			    break;

			/*  Hint Commands  */

			case Dotsection:      /* 12-0:	Dot section */
			    Clear();
#ifdef DBGAT3
printf("Dotsection\n");
#endif
			    break;

			case Hstem:	      /* 1:  Horizontal stem zone */
			    Sl(2);
			    Clear();
#ifdef DBGAT3
printf("Hstem\n");
#endif
			    break;

			case Hstem3:	      /* 12-2:	Three horizontal stem zones */
			    Sl(6);
			    Clear();
#ifdef DBGAT3
printf("Hstem3\n");
#endif
			    break;

			case Vstem:	      /* 3:  Vertical stem zone */
			    Sl(2);
			    Clear();
#ifdef DBGAT3
printf("Vstem\n");
#endif
			    break;

			case Vstem3:	      /* 12-1:	Three vertical stem zones */
			    Sl(6);
			    Clear();
#ifdef DBGAT3
printf("Vstem3\n");
#endif
			    break;

			/* Arithmetic command */

			case Div:	      /* 12 12:  Divide */
			    Sl(2);
#ifdef DBGAT3
printf("Div %d=(%d+(%d/2))/%d\n",(S1+(S0/2))/S0,S1,S0,S0);
#endif
			    S1 = (S1 + (S0 / 2)) / S0;
			    Npop(1);
			    break;

			/* Subroutine Commands */

			case Callothersubr:   /* 12 16:  Call other subroutine */
			    Sl(2);
#ifdef DBGAT3
printf("Callothersubr\n");
#endif
			    Sl(2 + S1);
				othersubr(shape, S0, S1, sp - (3 + S1));
			    Npop(2 + S1);
			    break;

			case Callsubr:	      /* 10:  Call subroutine */
			    Sl(1);
#ifdef DBGAT3
printf("Callsubr\n");
#endif
			    if (rsp >= ReturnStackLimit)
					{
					fflush(stdout);
					DebugPrint("ADOBET1: Stack limit err\n");
					return(0);
					}
			    rstack[rsp++] = cp;
			    sub = S0;
			    Npop(1);
			    if (sub < 0 || sub >= font->data.sub_count)
					{
					fflush(stdout);
					DebugPrint("ADOBET1: Bad subr\n");
					return(0);
				    }
			    if (font->data.subrs[sub] == NULL)
					{
					fflush(stdout);
					DebugPrint("ADOBET1: NULL subr\n");
					return(0);
				    }
			    cp = font->data.subrs[sub];  /* Set instruction pointer to subr code */
			    break;

			case Pop:	      /* 12 17:  Return argument from othersubr */
#ifdef DBGAT3
printf("Pop\n");
#endif
			    So(1);
				if (orp <= 0)
					{
					fflush(stdout);
					DebugPrint("Stack error in subr pop");
					return(0);
					}
				stack[sp++] = osres[--orp];
			    break;

			case Return:	      /* 11:  Return from subroutine */
#ifdef DBGAT3
printf("Return\n");
#endif
			    if (rsp < 1)
					{
					fflush(stdout);
					DebugPrint("ADOBET1: Return stack error\n");
					return(0);
				    }
			    cp = rstack[--rsp]; /* Restore pushed call address */
			    break;

			case Setcurrentpoint: /* 12 33:  Set current point */
#ifdef DBGAT3
printf("Setcurrent ");
#endif
			    Sl(2);
			    bezier(shape,a1lastx,a1lasty,a1lastx,a1lasty,curx,cury,curx,cury);
			    Clear();
			    break;
		    }
		}
	else
		{
	    long n;
#ifdef DBGAT3
printf("??? (%d)\n",c);
#endif

	    if (c <= 246)
			n = c - 139;
		else
		if (c <= 250)
			n = ((c - 247) << 8) + *cp++ + 108;
		else
		if (c < 255)
			n = -((c - 251) << 8) - *cp++ - 108;
		else
			{
			char ba[4];

			ba[0] = *cp++;
			ba[1] = *cp++;
			ba[2] = *cp++;
			ba[3] = *cp++;
			n = (((((ba[0] << 8) | ba[1]) << 8) | ba[2]) << 8) | ba[3];
		    }
	    if (sp >= StackLimit)
			{
			fflush(stdout);
			DebugPrint("ADOBET1: Stack limit err\n");
			}
		else
			{
			stack[sp++] = n;
#ifdef DBGAT3
printf("Pushed (%d) onto stack\n",n);
#endif
		    }
		}
    }

exdone:
if(!shape.SplineCount())
	return(0);
return(1);
}

//
// Our bezier font import code
//

// ReadFile flags
#define AT1_OPEN_FULL 0		// Get the whole magilla
#define AT1_OPEN_INFO 1		// Get just the information

class AdobeT1Import : public BezFont {
	private:
		Type1OpenFont *open;
	public:
		// required methods from BezFont class
		void EnumerateFonts(BezFontMgrEnumProc &proc, LPARAM userInfo);
		int OpenFont(TSTR name, DWORD flags, DllData *dllData);
		void CloseFont();
		BOOL BuildCharacter(UINT index, float height, BezierShape &shape, float &width, BOOL useMax1Shapes);
		// Our methods
		AdobeT1Import() { open = NULL; }
		~AdobeT1Import();
		BOOL ReadFile(TSTR fname, DWORD mode, BezFontInfo &info);
		int LoadType1(TSTR fname, int mode, Type1OpenFont *font);
		Errcode ReadFont(FILE *fp, int mode, Type1OpenFont *font);
		void RType1(FILE *fp, int mode, Type1OpenFont *font);
		Errcode FindAsciiValues(Type1OpenFont *font);
		BOOL Compout(int index, BezierShape &shape, int *width);
	};

class AT1DllData : public DllData {
	public:
		TSTR filename;
		AT1DllData(TSTR f) { filename = f; }
	};

void AdobeT1Import::EnumerateFonts(BezFontMgrEnumProc &proc, LPARAM userInfo) {
	FontMgrInterface *iface = theBezFontManager.GetInterface();
	int paths = iface->GetFontDirCount();
	WIN32_FIND_DATA data;
	for(int i = 0; i < paths; ++i) {
		TSTR dir = iface->GetFontDir(i);
		TSTR search = dir + _T("\\*.pfb");
		HANDLE h = FindFirstFile(search.data(), &data);
		if(h != INVALID_HANDLE_VALUE) {
			while(1) {
				TSTR fname = dir + _T("\\") + TSTR(data.cFileName);
				BezFontInfo info;
//DebugPrint("Checking [%s]\n",fname.data());
				if(ReadFile(fname, AT1_OPEN_INFO, info)) {
					AT1DllData *data = new AT1DllData(fname);	// Give manager the filename
					if(!proc.Entry(info, userInfo, data)) {
						FindClose(h);
						return;
						}
					}
				if(!FindNextFile(h, &data))
					break;
				}
			FindClose(h);
			}
		}
	}

int AdobeT1Import::OpenFont(TSTR name, DWORD flags, DllData *dllData) {
	AT1DllData *at1DllData = (AT1DllData *)dllData;
	BezFontInfo info;
	if(ReadFile(at1DllData->filename, AT1_OPEN_FULL, info)) {
		return 1;
		}
#ifdef DBGAT1
DebugPrint("ADOBET1: Something went wrong in open!\n");
#endif
	return 0;
	}

void AdobeT1Import::CloseFont() {
	if(open) {
		delete open;
		open = NULL;
		return;
		}
	assert(0);	// Didn't find it!
	}

BOOL AdobeT1Import::BuildCharacter(UINT index, float height, BezierShape &shape, float &width, int fontShapeVersion) {
	if(!open) {
		assert(0);		// Not a valid handle!
		width = 0.0f;
		return FALSE;
		}

	/* Look up the appropriate character */

	int chWidth;
	if(Compout(index, shape, &chWidth)==0)
		return(FALSE);
	// Update the selection set info -- Just to be safe
	shape.UpdateSels();
	// Scale the character according to the request
	float fontHeight = (float)(open->data.maxy - open->data.miny);
	if(height == 0.0f)
		height = 1.0f;
	float scaleFactor = height / fontHeight;
	Matrix3 tm = ScaleMatrix(Point3(scaleFactor, scaleFactor, 0.0f));
	shape.Transform(tm);
	width = float(chWidth) * scaleFactor;
	return TRUE;
	}

AdobeT1Import::~AdobeT1Import() {
	// Clean up our allocations
	if(open)
		delete open;
	}

BOOL AdobeT1Import::ReadFile(TSTR fname, DWORD mode, BezFontInfo &info) {
	int err;

	Type1OpenFont *theFont = new Type1OpenFont;
	if((err = LoadType1(fname, mode, theFont)) >= 0)
		{
		info = BezFontInfo(TSTR(theFont->data.fullname), TSTR(_T("")), BEZFONT_OTHER, (DWORD)0, BezFontMetrics());
		switch(mode) {
			case AT1_OPEN_INFO:
				delete theFont;
				return TRUE;
			case AT1_OPEN_FULL:
				open = theFont;
				return TRUE;
			} 
		assert(0);
		return(FALSE);
		}
#ifdef DBGAT1
DebugPrint("Type1 font load failed:%d",err);
#endif
	return(FALSE);
	}

int AdobeT1Import::LoadType1(TSTR fname, int mode, Type1OpenFont *font) {
	FILE *file;
	int err;

	if ((file = fopen(fname.data(), "rb")) == NULL)
		return(-1);
	if ((err = ReadFont(file, mode, font)) >= Success)
		{
		if(mode == AT1_OPEN_FULL)
			err = FindAsciiValues(font);
		}
	fclose(file);
	return err;
	}

Errcode AdobeT1Import::ReadFont(FILE *fp, int mode, Type1OpenFont *font) {
	Errcode err = Success;

	if ((err = setjmp(type1_load_errhandler)) != 0)
		{	/* Got here via longjmp. */
		err = Err_nogood;	// _something_ went wrong!
		}
	else
		{
		font->data.minx = font->data.miny=0;
		font->data.maxx = font->data.maxy=1000;
		RType1(fp, mode, font);
		}
	return err;
	}

#define FP(x) { DebugPrint("%s:%d\n",(x), ftell(fp)); }

void AdobeT1Import::RType1(FILE *fp, int mode, Type1OpenFont *font) {
    char token[256], ltoken[256], stoken[256], ptoken[256];
    int i;
	Errcode err;
	Type1_token tok;

	section = Header;
    ptoken[0] = stoken[0] = ltoken[0] = token[0] = EOS;
	if ((err = type1_check_signature(fp)) < Success)
		{
		sprintf(gp_buffer,"Can't find %%!FontType1 in .PFB file.");
		type1_load_error(gp_buffer);
		}
	type1_token_init(&tok, fp, at1_getc);
	type1_parse_to_eexec(font, &tok);
	if (font->data.encoding == NULL)
		{
		sprintf(gp_buffer,"No /Encoding array.");
		type1_load_error(gp_buffer);
		}

	// If just loading info, stop here
	if(mode != AT1_OPEN_FULL)
		return;

    for (i = 0; i < 6; i++) 
		{
        int c=at1_getc(fp);              /* Beats me, but there's 6 trash bytes */
		}
	type1_find_mode(font, fp);
    crypt_init(55665);

    /* Now burn the first four plaintext bytes. */

	for (i = 0; i < 4; i++)
		int burn = decrypt_byte_in(fp);

	type1_token_init(&tok, fp, decrypt_byte_in);
	for (;;)
		{
		type1_get_token(&tok);
		switch (tok.type)
		  {
		  case TTT_EOF:
			goto DONE;
		  case TTT_OTHER:
		    if (tok.string[0] == '/')
				{
				type1_get_token(&tok);
				if (tok.type == TTT_NAME)
					{
					if (strcmp(tok.string, "Subrs") == 0)
						type1_get_subrs(font, &tok);
					else if (strcmp(tok.string, "CharStrings") == 0)
						{
						type1_get_char_strings(font, &tok);
						goto DONE;
						}
					}
				}
			break;
		  default:
		    break;
		  }
	}
DONE:
	if (font->data.letter_defs == NULL)
		type1_load_error("No CharStrings!");
	}

/*****************************************************************************
 * Go through and build up an ascii-ordered array of character definitions.
 ****************************************************************************/
Errcode AdobeT1Import::FindAsciiValues(Type1OpenFont *font) {
	char *name;
	unsigned char *ascii_name;
	unsigned char **map = (unsigned char **)font->data.encoding;
	char **names = font->data.letter_names;
	unsigned char **defs = font->data.letter_defs;
	int i,ascii_val;
	int def_ix;
	int def_count;
	int matches = 0;

	/* Clear out the array to NULLs first */
	for(i=0; i<256; ++i)
		font->data.ascii_defs[i]=NULL;

/* The character defs are stored in the font file in *roughly* ascii order.
 * The logic in this routine takes some advantage of this by starting
 * the search for the next letter where the search for the current letter
 * left off. */
	def_ix = 0;		/* Initialize search starting position. */
	def_count = font->data.letter_count;
	for (ascii_val=0; ascii_val<font->data.encoding_count; ++ascii_val)
		{
		if ((ascii_name = *map++) != NULL)
			{
			i = def_count;
			while (--i >= 0)
				{
				if (++def_ix >= def_count)
					def_ix = 0;
				if ((name = names[def_ix]) != NULL)
					{
					if (strcmp(name, (char *)ascii_name) == 0)
						{
						font->data.ascii_defs[ascii_val] = defs[def_ix];
						++matches;
						break;
						}
					}
				}
			}
		}
	if (matches > 0)
		{
		return Success;
		}
	else
		{
		return Err_not_found;
		}
	}

int AdobeT1Import::Compout(int index, BezierShape &shape, int *width) {
	int j,chWidth;

	/* Make sure it's a valid ID */

	if(index < 0 || index >= open->data.encoding_count)
		{
#ifdef DBGAT1
DebugPrint("Outside encoding table limits\n");
#endif
		return(FALSE);
		}

	if(open->data.encoding[index]==NULL)
		{
#ifdef DBGAT1
DebugPrint("%d (%c) Not in encoding table\n",index,index);
#endif
		return(FALSE);
		}

	/* Look for char by name */

	for (j = 0; j < open->data.letter_count; j++) {
		if(open->data.letter_names[j]!=NULL) {
	  		if (strcmp((char *)open->data.letter_names[j],(char *)open->data.encoding[index]) == 0) {
	//printf("Executing char [%s]",tcd->letter_names[j]);
				if(exchars(open,&chWidth,(unsigned char *)open->data.letter_defs[j],shape,0,0)==0) {
#ifdef DBGAT1
DebugPrint("Error decoding character %d (%c)\n",index,index);
#endif
					return FALSE;
					}
				if(width)
					*width = chWidth;
				return TRUE;
				}
			}
		}
#ifdef DBGAT1
DebugPrint("%d (%c) Not in letter names\n",index,index);
#endif
	return FALSE;
	}

// Jaguar interface code

BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) {
	hInstance = hinstDLL;
	switch(fdwReason) {
		case DLL_PROCESS_ATTACH:
			//MessageBox(NULL,L"ADOBET1.DLL: DllMain",L"BEZFONT",MB_OK);
			break;
		case DLL_THREAD_ATTACH:
			break;
		case DLL_THREAD_DETACH:
			break;
		case DLL_PROCESS_DETACH:
			break;
		}
	return(TRUE);
	}


//------------------------------------------------------

class AT1ClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new AdobeT1Import; }
	const TCHAR *	ClassName() { return GetString(IDS_TH_ADOBET1_CLASSNAME); }
	SClass_ID		SuperClassID() { return BEZFONT_LOADER_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(ADOBET1_LOADER_CLASS_ID,0); }
	const TCHAR* 	Category() { return GetString(IDS_TH_ADOBET1_CATEGORY);  }
	};

static AT1ClassDesc AT1Desc;

//------------------------------------------------------
// This is the interface to Jaguar:
//------------------------------------------------------

__declspec( dllexport ) const TCHAR *
LibDescription() { return GetString(IDS_LIB_DESCRIPTION); }

__declspec( dllexport ) int
LibNumberClasses() { return 1; }

__declspec( dllexport ) ClassDesc *
LibClassDesc(int i) {
	switch(i) {
		case 0: return &AT1Desc; break;
		default: return 0; break;
		}

	}

// Return version so can detect obsolete DLLs
__declspec( dllexport ) ULONG 
LibVersion() { return VERSION_3DSMAX; }

TCHAR *GetString(int id)
	{
	static TCHAR buf[256];

	if (hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\bezfont\truetype.cpp ===
/**********************************************************************
 *<
	FILE: truetype.cpp

	DESCRIPTION:  truetype bezier font file import module

	CREATED BY: Tom Hudson

	HISTORY: created 2 November 1995

 *>	Copyright (c) 1995, All Rights Reserved.
 **********************************************************************/

#include "Max.h"
#include <stdio.h>
#include <direct.h>
#include <commdlg.h>
#include "splshape.h"
#include "bezfont.h"
#include "resource.h"

#define TRUETYPE_LOADER_CLASS_ID 0x1800

HINSTANCE hInstance;

TCHAR *GetString(int id);

class TrueTypeImport : public BezFont {
	private:
		HFONT hFont;
		BezFontMgrEnumProc *eProc;
		LPARAM eInfo;		
	public:
		// required methods from BezFont class
		void EnumerateFonts(BezFontMgrEnumProc &proc, LPARAM userInfo);
		int OpenFont(TSTR name, DWORD flags, DllData *dllData);
		void CloseFont();
		BOOL BuildCharacter(UINT index, float height, BezierShape &shape, float &width, int FontShapeVersion);
		// Our methods
		BOOL DoEnumeration(BezFontInfo &info);
		TrueTypeImport() { hFont = NULL; }
		BOOL CreateCharacterShape(LPTTPOLYGONHEADER lpHeader, int size, BezierShape &shape, int FontShapeVersion);
	};

static BOOL FAR PASCAL EnumCallBack2(ENUMLOGFONT *lplf, NEWTEXTMETRIC *lpntm, DWORD fontType, LPVOID iptr) {
	// If no style specified, toss it!
	if(lplf->elfStyle[0] == 0)
		return TRUE;	// Forget this one but keep enumerating
	TrueTypeImport *imp = (TrueTypeImport *)iptr;
	BezFontInfo info;
	info.name = (char*)lplf->elfFullName;
	info.style = (char*)lplf->elfStyle;
	info.type = BEZFONT_TRUETYPE;
	info.flags = 0;		// No flags defined yet -- Make this zero!
	info.metrics = BezFontMetrics(lpntm);
	return imp->DoEnumeration(info);		
	}

static BOOL FAR PASCAL EnumCallBack(ENUMLOGFONT *lplf, NEWTEXTMETRIC *lpntm, DWORD fontType, LPVOID iptr) {
	// All we're concerned with are TrueType(T.M.Reg.U.S.Pat.Off.) fonts...
	if(fontType & TRUETYPE_FONTTYPE) {
		// Got the basic font name, now let's enumerate its members
		TCHAR work[256];
		_tcscpy(work,lplf->elfLogFont.lfFaceName);
		HDC hdcScreen = GetDC(NULL);
		EnumFontFamilies(hdcScreen, (LPCTSTR)work, (FONTENUMPROC)EnumCallBack2, (LPARAM)iptr);
		}
	return TRUE;
	}

void TrueTypeImport::EnumerateFonts(BezFontMgrEnumProc &proc, LPARAM userInfo) {
	HDC hdcScreen = GetDC(NULL);
	eProc = &proc;
	eInfo = userInfo;
	EnumFontFamilies(hdcScreen, (LPCTSTR)NULL, (FONTENUMPROC)EnumCallBack, (LPARAM)this);
	}

int TrueTypeImport::OpenFont(TSTR name, DWORD flags, DllData *dllData) {
    // build a TrueType font.
    static LOGFONT lf;
//    GetObject(GetStockObject(SYSTEM_FONT), sizeof(lf), &lf);
    lf.lfHeight = 1000;
    lf.lfWidth = 0;
	lf.lfEscapement = 0; 
	lf.lfOrientation = 0; 
	lf.lfWeight = 0; 
	lf.lfItalic = FALSE; 
	lf.lfUnderline = FALSE; 
	lf.lfStrikeOut = FALSE; 
	lf.lfCharSet = DEFAULT_CHARSET; 
//	lf.lfCharSet = SHIFTJIS_CHARSET; 
	lf.lfOutPrecision = OUT_DEFAULT_PRECIS; 
	lf.lfClipPrecision = CLIP_DEFAULT_PRECIS; 
	lf.lfQuality = DEFAULT_QUALITY; 
	lf.lfPitchAndFamily = DEFAULT_PITCH | FF_DONTCARE; 
    _tcsncpy((TCHAR *)&lf.lfFaceName, name.data(), LF_FACESIZE);
    hFont = CreateFontIndirect(&lf);
	return(hFont ? 1 : 0);
	}

void TrueTypeImport::CloseFont() {
	if(hFont) {
		DeleteObject(hFont);
		hFont = NULL;
		}
	}

class FontReady {
	public:
		HDC hdc;
		LPOUTLINETEXTMETRIC otm;
		HGDIOBJ hOld;
		FontReady(HFONT font);
		~FontReady();
	};

FontReady::FontReady(HFONT font) {
	hdc = GetDC(NULL);
	hOld = SelectObject(hdc, (HGDIOBJ)font);
	otm = NULL;
	DWORD otmSize = GetOutlineTextMetrics(hdc, 0, NULL);
	if(otmSize) {
		otm = (LPOUTLINETEXTMETRIC)malloc(otmSize);
		if(otm)
			GetOutlineTextMetrics(hdc, otmSize, otm);
		}
 	}

FontReady::~FontReady() {
	SelectObject(hdc, (HGDIOBJ)hOld); ReleaseDC(NULL, hdc);
 	if(otm) {
		free(otm);
		otm = NULL;
		}
 	}

class GenericAlloc {
	public:
		void *ptr;
		GenericAlloc(int size) { ptr = malloc(size); }
		~GenericAlloc() { if(ptr) { free(ptr); ptr = NULL; } }
	};

//  BEZIER  --	Manage additions to our bezier curve for the font character

static Spline3D *curSpline = NULL;

static void
bezier(BezierShape &shape,float x0, float y0, float x1, float y1, float x2, float y2, float x3, float y3)
{
//DebugPrint("Bezier creating %.2f %.2f-%.2f %.2f-%.2f %.2f-%.2f %.2f\n",x0,y0,x1,y1,x2,y2,x3,y3);
if(!curSpline)
	curSpline = shape.NewSpline();
int knots = curSpline->KnotCount();
if(knots == 0) {
	curSpline->AddKnot(SplineKnot(KTYPE_BEZIER, LTYPE_CURVE, Point3(x0,y0,0.0f), Point3(x0,y0,0.0f), Point3(x1,y1,0.0f)));
	curSpline->AddKnot(SplineKnot(KTYPE_BEZIER, LTYPE_CURVE, Point3(x3,y3,0.0f), Point3(x2,y2,0.0f), Point3(x3,y3,0.0f)));
	}
else {
	// First point of this curve must be the same as the last point on the output curve
	assert(curSpline->GetKnotPoint(knots-1) == Point3(x0,y0,0.0f));
	curSpline->SetOutVec(knots-1, Point3(x1,y1,0.0f));
	if(Point3(x3,y3,0.0f) == curSpline->GetKnotPoint(0)) {
		curSpline->SetInVec(0, Point3(x2,y2,0.0f));
		curSpline->SetClosed();
//DebugPrint("Bezier autoclosed\n");
		curSpline = NULL;
		}
	else
		curSpline->AddKnot(SplineKnot(KTYPE_BEZIER, LTYPE_CURVE, Point3(x3,y3,0.0f), Point3(x2,y2,0.0f), Point3(x3,y3,0.0f)));
	}
}

/****************************************************************************
 *  FUNCTION   : IntFromFixed
 *  RETURNS    : int value approximating the FIXED value.
 ****************************************************************************/
static float FloatFromFixed(FIXED f) {
    return f.value + (float)f.fract / 65536.0f;
	}

/****************************************************************************
 *  FUNCTION   : FixedFromDouble
 *  RETURNS    : FIXED value representing the given double.
 ****************************************************************************/
static FIXED FixedFromDouble(double d)
{
    long l;

    l = (long) (d * 65536L);
    return *(FIXED *)&l;
}

BOOL TrueTypeImport::CreateCharacterShape(LPTTPOLYGONHEADER lpHeader, int size, BezierShape &shape, int fontShapeVersion) {
    LPTTPOLYGONHEADER lpStart;
    LPTTPOLYCURVE lpCurve;
    WORD i;
	POINTFX work;
//DebugPrint("Start of letter\n");
    lpStart = lpHeader;
    while ((DWORD)lpHeader < (DWORD)(((LPSTR)lpStart) + size)) {
		if (lpHeader->dwType == TT_POLYGON_TYPE) {

		    // Get to first curve.
	    	lpCurve = (LPTTPOLYCURVE) (lpHeader + 1);
//		    iFirstCurve = cTotal;
//DebugPrint("Poly start\n");

		    while ((DWORD)lpCurve < (DWORD)(((LPSTR)lpHeader) + lpHeader->cb)) {
				if (lpCurve->wType == TT_PRIM_LINE)	{
				    work = *(LPPOINTFX)((LPSTR)lpCurve - sizeof(POINTFX));
					Point3 p0(FloatFromFixed(work.x), FloatFromFixed(work.y), 0.0f);
				    for (i = 0; i < lpCurve->cpfx; i++) {
						work = lpCurve->apfx[i];
						Point3 p1(FloatFromFixed(work.x), FloatFromFixed(work.y), 0.0f);
						bezier(shape, p0.x, p0.y, p0.x, p0.y, p1.x, p1.y, p1.x, p1.y);
						p0 = p1;
				    	}
					}
				else
				if (lpCurve->wType == TT_PRIM_QSPLINE)	{
				    //**********************************************
				    // Format assumption:
				    //   The bytes immediately preceding a POLYCURVE
				    //   structure contain a valid POINTFX.
				    //
				    //   If this is first curve, this points to the 
				    //      pfxStart of the POLYGONHEADER.
				    //   Otherwise, this points to the last point of
				    //      the previous POLYCURVE.
				    //
				    //	 In either case, this is representative of the
				    //      previous curve's last point.
				    //**********************************************
				    work = *(LPPOINTFX)((LPSTR)lpCurve - sizeof(POINTFX));
					Point3 p0(FloatFromFixed(work.x), FloatFromFixed(work.y), 0.0f);
				    Point3 p1, p2, p3, pa, pb;
				    for (i = 0; i < lpCurve->cpfx;) {
						// This point is off the curve -- Hold onto it
						work = lpCurve->apfx[i++];
						pa = Point3(FloatFromFixed(work.x), FloatFromFixed(work.y), 0.0f);

						// Calculate the C point.
						if (i == (lpCurve->cpfx - 1))  {
							// It's the last point, and therefore on the curve.
							// We need to compute the bezier handles between it and p0...
							work = lpCurve->apfx[i++];
							p3 = Point3(FloatFromFixed(work.x), FloatFromFixed(work.y), 0.0f);
							}     
						else  {
							// It's not the last point -- Need to compute midpoint to get
							// a point on the curve
 							work = lpCurve->apfx[i];	// Don't inc i -- We'll use it next time around!
							Point3 pb(FloatFromFixed(work.x), FloatFromFixed(work.y), 0.0f);
							p3 = (pa + pb) / 2.0f;
							}

						// Also compute the appropriate handles...
						if(fontShapeVersion == 1) {		// Release 1.x-compatible
							p1 = (p0 + pa) / 2.0f;
							p2 = (pa + p3) / 2.0f;
							}
						else{
							p1 = (p0 + 2.0f * pa) / 3.0f;	// Release 2
							p2 = (p3 + 2.0f * pa) / 3.0f;
							}

						// Let's add it to the output bezier!
						bezier(shape, p0.x, p0.y, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);

						// New A point for next slice of spline.
						p0 = p3;
						}
					}
				else
					; // error, error, error

				// Move on to next curve.
				lpCurve = (LPTTPOLYCURVE)&(lpCurve->apfx[i]);
		    	}
//DebugPrint("Poly end\n");

			if(curSpline) {
				curSpline->SetClosed();
				curSpline = NULL;
				}

		    // Move on to next polygon.
	    	lpHeader = (LPTTPOLYGONHEADER)(((LPSTR)lpHeader) + lpHeader->cb);
			}
		else
			; // error, error, error
		}
//DebugPrint("End of letter\n");

	// Make sure any splines are closed and reset
	if(curSpline) {
		curSpline->SetClosed();
		curSpline = NULL;
		}

	// Update the selection set info -- Just to be safe
	shape.UpdateSels();
	
	return TRUE;
	}

/****************************************************************************
 *  FUNCTION   : IdentityMat
 *  PURPOSE    : Fill in matrix to be the identity matrix.
 *  RETURNS    : none.
 ****************************************************************************/
static void IdentityMat(LPMAT2 lpMat)
{
    lpMat->eM11 = FixedFromDouble(1.0);
    lpMat->eM12 = FixedFromDouble(0.0);
    lpMat->eM21 = FixedFromDouble(0.0);
    lpMat->eM22 = FixedFromDouble(1.0);
}

BOOL TrueTypeImport::BuildCharacter(UINT index, float height, BezierShape &shape, float &width, int fontShapeVersion) {
    assert(hFont);
	if(!hFont)
		return 0;

	// Set up for the font and release it when this function returns
	FontReady fontRdy(hFont);
			    
	// allocate space for the bitmap/outline
	GLYPHMETRICS gm;
    // init it to prevent UMR in GetGlyphOutline
    gm.gmBlackBoxX = 
    gm.gmBlackBoxY = 
    gm.gmptGlyphOrigin.x =
    gm.gmptGlyphOrigin.y =
    gm.gmCellIncX = 
    gm.gmCellIncY = 0; 

	// Give it an identity matrix
	MAT2 mat;
	IdentityMat(&mat);

	DWORD size = GetGlyphOutline(fontRdy.hdc, index, GGO_NATIVE, &gm, 0, NULL, &mat);
	if(size != GDI_ERROR && size > 0) {
		GenericAlloc mem(size);
		if(!mem.ptr)
			goto failure;
		if ((GetGlyphOutline(fontRdy.hdc, index, GGO_NATIVE, &gm, size, mem.ptr, &mat)) != size)
			goto failure;
		curSpline = NULL;	// reset the current spline pointer
		if(!CreateCharacterShape((TTPOLYGONHEADER *)mem.ptr, size, shape, fontShapeVersion))
			goto failure;
		// Make sure the height matches the request
		float scaleFactor = height / 1000.0f;
		Matrix3 tm = ScaleMatrix(Point3(scaleFactor, scaleFactor, 0.0f));
		shape.Transform(tm);
		width = float(gm.gmCellIncX) * scaleFactor;
		return TRUE;
		}

	// Character wasn't found!
	failure:
	width = 0.0f;
	return FALSE;
	}

BOOL TrueTypeImport::DoEnumeration(BezFontInfo &info) {
	return eProc->Entry(info, eInfo, NULL);
	} 

// Jaguar interface code

BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) {
	hInstance = hinstDLL;
	switch(fdwReason) {
		case DLL_PROCESS_ATTACH:
			//MessageBox(NULL,L"TRUETYPE.DLL: DllMain",L"TRUETYPE",MB_OK);
			break;
		case DLL_THREAD_ATTACH:
			break;
		case DLL_THREAD_DETACH:
			break;
		case DLL_PROCESS_DETACH:
			break;
		}
	return(TRUE);
	}


//------------------------------------------------------

class TTClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new TrueTypeImport; }
	const TCHAR *	ClassName() { return GetString(IDS_TH_CLASSNAME); }
	SClass_ID		SuperClassID() { return BEZFONT_LOADER_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(TRUETYPE_LOADER_CLASS_ID,0); }
	const TCHAR* 	Category() { return GetString(IDS_TH_CATEGORY);  }
	};

static TTClassDesc TTDesc;

//------------------------------------------------------
// This is the interface to Jaguar:
//------------------------------------------------------

__declspec( dllexport ) const TCHAR *
LibDescription() { return GetString(IDS_LIB_DESCRIPTION); }

__declspec( dllexport ) int
LibNumberClasses() { return 1; }

__declspec( dllexport ) ClassDesc *
LibClassDesc(int i) {
	switch(i) {
		case 0: return &TTDesc; break;
		default: return 0; break;
		}

	}

// Return version so can detect obsolete DLLs
__declspec( dllexport ) ULONG 
LibVersion() { return VERSION_3DSMAX; }

TCHAR *GetString(int id)
	{
	static TCHAR buf[256];

	if (hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\bezfont\at1rc.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by adobet1.rc
//
#define IDS_TH_ADOBET1_CLASSNAME        1
#define IDS_TH_ADOBET1_CATEGORY         2
#define IDS_LIB_DESCRIPTION             3

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\bezfont\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by truetype.rc
//
#define IDS_TH_CLASSNAME                1
#define IDS_TH_CATEGORY                 2
#define IDS_LIB_DESCRIPTION             3

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Cammap\cammap.cpp ===
/*===========================================================================*\
 |    File: CamMap.cpp
 |
 | Purpose: A Modifier and World Space Modifier for camera mapping.
 |
 |          This file contains two plug-ins.  A Object Space Modifier version
 |          and a World Space Modifier (Space Warp) version.
 |          The Modifier code appears after all the Space Warp code.
 |
 | History: Mark Meier, Began 12/15/96.
 |          MM, Modifier added, 12/18/96.
 |          MM, Last Change 12/21/96.
 |          michael malone (mjm) - 2.3.99
 |            made obj & ws mods have similar dlgs
 |            implemented undo/redo in objmod similar to wsmod
 |          michael malone (mjm) - 3.10.99
 |            added multi-channel support
\*===========================================================================*/
/*===========================================================================*\
 | Include Files
\*===========================================================================*/
#include "Max.h"			// Main MAX include file
#include "CamMap.h"			// Resource editor include file

TCHAR *GetString(int id);

/*===========================================================================*\
 | Miscellaneous Defines
\*===========================================================================*/
// The unique ClassIDs
#define OBJ_CLASS_ID		Class_ID(0x1cfc3603, 0x40282400)
#define WSMOD_CLASS_ID		Class_ID(0x16dc4353, 0x2dc047b1)
#define MOD_CLASS_ID		Class_ID(0x21ce6ea4, 0x7ed434db)

// These are the names on the creation buttons
#define OBJ_CLASSNAME		GetString(IDS_CAMMAPCLASSNAME)
#define WSMOD_CLASSNAME		GetString(IDS_CAMERAMAP)
#define CLASSNAME			GetString(IDS_CAMERAMAP)

// These are the categories the buttons go into
#define OBJ_CATEGORY		GetString(IDS_CAMERAMAPPING)
#define WSMOD_CATEGORY		_T("")
#define MOD_CATEGORY		GetString(IDS_MAXSURFACE)

// These are the names that will appear in the Modifier stack
#define OBJ_OBJECT_NAME		GetString(IDS_CAMMAPCLASSNAME)
#define WSMOD_OBJECT_NAME	GetString(IDS_CAMERAMAPBINDING)
#define MOD_OBJECT_NAME		GetString(IDS_CAMERAMAPMODIFIER)

// This is the initial node name for the camera map apparatus object
#define INIT_NODE_NAME		GetString(IDS_CAMMAPCLASSNAME)

// The description that appears in the plug-in summary info dialog box
#define LIBDESCRIPTION		GetString(IDS_CAMMAPTITLE)

// Dialog box message title
#define MESSAGE_TITLE		GetString(IDS_CAMERAMAPPING)

// Load/Save chunk IDs
#define HAVE_CAMERA_DATA_CHUNK		1000
#define VERSION_CHUNK				1005
#define MATRIX3_CHUNK				1010
#define FOV_CHUNK					1020
#define ASPECT_CHUNK				1030
#define CHANNEL_CHUNK				1040 // mjm - 3.10.99

// This is the camera reference index
#define CAM_REF				0

// These are the default colors for the apparatus object in the viewports
#define CAMMAP_R			float(0.7)
#define CAMMAP_G			float(0.0)
#define CAMMAP_B			float(0.0)

// This is the ID of the pick command mode
#define CID_PICK_CAMERA		CID_USER+0x7055

// This is the DLL instance handle
HINSTANCE hInstance;

TCHAR *GetString(int id) {
	static TCHAR buf[256];
	if (hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
	}

/*===========================================================================*\
 | Space Warp Code...
\*===========================================================================*/
/*===========================================================================*\
 | Class definitions
\*===========================================================================*/
class PickWSModCameraMode;
// This is the apparatus object for the space warp
class CamMapObj : public WSMObject {
  public:
	// MAX function interface pointer
	static Interface *ip;

	// Rollup page window handle
	static HWND hObjRollup;

	// This is the apparatus object's mesh that shows up in the viewports...
	Mesh mesh;

	// --- Methods From Animatable ---
	void DeleteThis() { delete this; }
	void GetClassName(TSTR& s) { s=GetString(IDS_CAMMAPOBJECT); }
	virtual Class_ID ClassID() { return OBJ_CLASS_ID;}
	void BeginEditParams(IObjParam *ip, ULONG flags, Animatable *prev);
	void EndEditParams(IObjParam *ip, ULONG flags, Animatable *next);		

	// --- Methods From ReferenceMaker ---
	RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
		PartID& partID, RefMessage message) { return REF_SUCCEED; }

	// --- Methods From ReferenceTarget ---
	RefTargetHandle Clone(RemapDir& remap = NoRemap());

	// --- Methods From BaseObject ---
	TCHAR *GetObjectName() { return OBJ_OBJECT_NAME; }
	CreateMouseCallBack *GetCreateMouseCallBack();
	int HitTest(TimeValue t, INode* inode, int type, int crossing, 
		int flags, IPoint2 *p, ViewExp *vpt);
	void Snap(TimeValue t, INode* inode, SnapInfo *snap, 
		IPoint2 *p, ViewExp *vpt);
	int Display(TimeValue t, INode* inode, ViewExp *vpt, int flags);
	void GetWorldBoundBox(TimeValue t, INode *inode, ViewExp *vpt, Box3& box);
	void GetLocalBoundBox(TimeValue t, INode *inode, ViewExp *vpt, Box3& box);

	// --- Methods From Object ---
	void InitNodeName(TSTR& s) {s = INIT_NODE_NAME;}
	int DoOwnSelectHilite() { return TRUE; }
	int IsRenderable() { return FALSE; }
	Interval ObjectValidity(TimeValue t) { return FOREVER; }
	ObjectState Eval(TimeValue t) { return ObjectState(this); }

	// --- Methods From WSMObject ---
	Modifier *CreateWSMMod(INode *node);

	// --- Methods From CamMapObj ---
	CamMapObj::CamMapObj();
	CamMapObj::~CamMapObj();
	void BuildMesh(TimeValue t, Mesh &mesh);
};

// Init the class variables (these are shared by each instance of the class).
// This is okay since only one object can be edited at a time.
Interface *CamMapObj::ip = NULL;
HWND CamMapObj::hObjRollup = NULL;

// This is the modifier portion of the space warp
class CamMapWSMod : public WSModifier {
  public:
	// MAX function interface pointer
	static Interface *ip;

	// Rollup page window handle
	static HWND hModRollup;

	// ui controls
	static ICustButton *iPick;
	static ISpinnerControl *iMapID; // mjm - 3.10.99

	// This is the command mode put into effect when the user selects
	// the iPick button.
	static PickWSModCameraMode *pickMode;

	// This is the Modifier being edited...
	static CamMapWSMod *editMod;

	// The camera node we reference
	INode *camRef;

	// the coordinate channel
	int channel; // mjm - 3.10.99

	// --- Methods From Animatable ---
	void DeleteThis() { delete this; }
	void GetClassName(TSTR& s) { s=GetString(IDS_CAMERAMAPPINGMODIFIER); }
	virtual Class_ID ClassID() { return WSMOD_CLASS_ID;}
	void BeginEditParams(IObjParam *ip, ULONG flags, Animatable *prev);
	void EndEditParams(IObjParam *ip, ULONG flags, Animatable *next);		

	// --- Methods From ReferenceMaker ---
	RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, PartID& partID, RefMessage message);
	int NumRefs() { return 1; } // camera node
	RefTargetHandle GetReference(int i);
	void SetReference(int i, RefTargetHandle rtarg);
	IOResult Save(ISave *isave);
	IOResult Load(ILoad *iload);

	// --- Methods From ReferenceTarget ---
	RefTargetHandle Clone(RemapDir& remap = NoRemap());

	// --- Methods From BaseObject ---
	TCHAR *GetObjectName() { return WSMOD_OBJECT_NAME; }
	CreateMouseCallBack* GetCreateMouseCallBack() { return NULL; } 

	// --- Methods From Modifier ---
	ChannelMask ChannelsUsed()
		{ return PART_GEOM|PART_TOPO|PART_SELECT|TEXMAP_CHANNEL|PART_VERTCOLOR; } // mjm - 3.10.99
	ChannelMask ChannelsChanged()
		{ return PART_VERTCOLOR|TEXMAP_CHANNEL|PART_GEOM; } // mjm - 3.10.99
	Class_ID InputType() 
		{ return Class_ID(TRIOBJ_CLASS_ID, 0); }
	void ModifyObject(TimeValue t, ModContext &mc, 
		ObjectState *os, INode *node);
	Interval LocalValidity(TimeValue t);

	// --- Methods From CamMapWSMod ---
	CamMapWSMod::CamMapWSMod();
	CamMapWSMod::~CamMapWSMod();
	BOOL SetCameraNode(INode *node);
};

// Init the class variables (these are shared by each instance of the class).
// This is okay since only one modifier can be edited at a time
Interface *CamMapWSMod::ip = NULL;
HWND CamMapWSMod::hModRollup = NULL;
ICustButton *CamMapWSMod::iPick = NULL;
ISpinnerControl *CamMapWSMod::iMapID = NULL; // mjm - 3.10.99
PickWSModCameraMode *CamMapWSMod::pickMode = NULL;
CamMapWSMod *CamMapWSMod::editMod = NULL;

// This class is derived from both PickModeCallback (whose various methods
// are called at times during the picking), and PickNodeCallback (which 
// provides a Filter() method used to screen possible hits).
class PickWSModCameraMode : public PickModeCallback, public PickNodeCallback {
  public:		
	CamMapWSMod *cm;
	
	PickWSModCameraMode(CamMapWSMod *c) {cm = c;}
	// --- Methods from PickModeCallback ---
	BOOL HitTest(IObjParam *ip, HWND hWnd, ViewExp *vpt,
		IPoint2 m, int flags);
	BOOL Pick(IObjParam *ip, ViewExp *vpt);
	void EnterMode(IObjParam *ip)
		{ cm->iPick->SetCheck(TRUE); }
	void ExitMode(IObjParam *ip)
		{ if (cm->iPick) cm->iPick->SetCheck(FALSE); }
	BOOL RightClick(IObjParam *ip, ViewExp *vpt) { return TRUE; }
	// This class is itself derived from PickNodeCallback, so it
	// simply returns itself as the GetFilter() pointer.
	PickNodeCallback *GetFilter() { return this; }

	// --- Methods from PickNodeCallback ---
	// This method is used to screen the various nodes passed. It returns
	// TRUE if the node is valid; otherwise FALSE.
	BOOL Filter(INode *node);
};

// This is the restore object used to allow the user to undo or redo the
// selection of a new camera.
class PickWSModCameraRestore : public RestoreObj {
	public:
		CamMapWSMod *cm;
		// This constructor is called when the user has assigned a camera
		// and we register a restore object with the undo system.
		PickWSModCameraRestore(CamMapWSMod *c) { cm = c; }
// mjm - begin - 2.3.99
		void Restore(int isUndo) {
			if (cm->editMod == cm && cm->hModRollup) {
				if (cm->camRef)
					SetWindowText(GetDlgItem(cm->hModRollup, IDC_CAMERA_NAME), cm->camRef->GetName());
				else
					SetWindowText(GetDlgItem(cm->hModRollup, IDC_CAMERA_NAME), GetString(IDS_NONE));
			}
		}
		void Redo() {
			if (cm->editMod == cm && cm->hModRollup && cm->camRef) {
				if (cm->camRef)
					SetWindowText(GetDlgItem(cm->hModRollup, IDC_CAMERA_NAME), cm->camRef->GetName());
				else
					SetWindowText(GetDlgItem(cm->hModRollup, IDC_CAMERA_NAME), GetString(IDS_NONE));
			}
		}
// mjm - end
		TSTR Description() { 
			return TSTR(GetString(IDS_PICKCAMERA)); 
		}
};

// This is the material for the apparatus -- it draws itself rather than
// letting MAX do it so it can always appear in wireframe mode...
class CamMapMtl : public Material {
  public:
	CamMapMtl();
};
static CamMapMtl swMtl;

// This is the callback used in the creation of the apparatus in the viewports
class CamMapObjCreateCallBack : public CreateMouseCallBack {	
  private:
	CamMapObj *ob;	

  public:
	int proc(ViewExp *vpt, int msg, int point, int flags, IPoint2 m, 
		Matrix3 &mat);
	void SetObj(CamMapObj *obj) { ob = obj; }
};
static CamMapObjCreateCallBack camMapCreateCB;

/*===========================================================================*\
 | Class Descriptors
\*===========================================================================*/
class CamMapObjClassDesc : public ClassDesc {
  public:
	int				IsPublic() {return 0;}
	void			*Create(BOOL loading = FALSE) {return new CamMapObj;}
	const TCHAR		*ClassName() {return OBJ_CLASSNAME;}
	SClass_ID		SuperClassID() {return WSM_OBJECT_CLASS_ID;}
	Class_ID		ClassID() {return OBJ_CLASS_ID;}
	const TCHAR		*Category() {return OBJ_CATEGORY;}
};
static CamMapObjClassDesc camMapObjDesc;

class CamMapWSModClassDesc : public ClassDesc {
  public:
	int 			IsPublic() {return 1;}
	void			*Create(BOOL loading = FALSE) {return new CamMapWSMod;}
	const TCHAR		*ClassName() {return WSMOD_CLASSNAME;}
	SClass_ID		SuperClassID() {return WSM_CLASS_ID;}
	Class_ID		ClassID() {return WSMOD_CLASS_ID;}
	const TCHAR		*Category() {return WSMOD_CATEGORY;}
};
static CamMapWSModClassDesc camMapWSModDesc;

/*===========================================================================*\
 | Dialog Procs
\*===========================================================================*/
// This is the dialog proc for the 'Current Camera Object' rollup
static BOOL CALLBACK CamMapWSModDlgProc(HWND hWnd, UINT msg, 
	WPARAM wParam, LPARAM lParam) {

	CamMapWSMod *cm = (CamMapWSMod *)GetWindowLong(hWnd, GWL_USERDATA);
	if (!cm && msg != WM_INITDIALOG ) return FALSE;

	switch (msg)
	{
		case WM_INITDIALOG:
			cm = (CamMapWSMod *)lParam;
			SetWindowLong(hWnd, GWL_USERDATA, (LONG) cm);
			cm->iPick = GetICustButton(GetDlgItem(hWnd, IDC_PICK));
			cm->iPick->SetText(GetString(IDS_PICKCAMERA));
			cm->iPick->SetType(CBT_CHECK);
			cm->iPick->SetHighlightColor(GREEN_WASH);
			cm->iPick->SetCheckHighlight(TRUE);
			// Display the camera node name or "None"
			if (cm->camRef)
				SetWindowText(GetDlgItem(hWnd, IDC_CAMERA_NAME), cm->camRef->GetName());
			else
				SetWindowText(GetDlgItem(hWnd, IDC_CAMERA_NAME), GetString(IDS_NONE));
// mjm - begin - 3.10.99
			cm->iMapID = GetISpinner(GetDlgItem(hWnd,IDC_MAP_CHAN_SPIN));
			cm->iMapID->LinkToEdit(GetDlgItem(hWnd,IDC_MAP_CHAN_EDIT),EDITTYPE_INT);
			cm->iMapID->SetLimits(1, 99, FALSE);
			cm->iMapID->SetAutoScale();
			cm->iMapID->SetValue(cm->channel, FALSE);
			cm->iMapID->Enable(cm->channel);
			CheckRadioButton(hWnd, IDC_MAP_CHAN_1, IDC_MAP_CHAN_0, (cm->channel) ? IDC_MAP_CHAN_1 : IDC_MAP_CHAN_0);
			return TRUE;

		case WM_CUSTEDIT_ENTER:
		case CC_SPINNER_BUTTONUP:
		{
			int chan = cm->iMapID->GetIVal();
			if (chan != cm->channel)
			{
				cm->channel = chan;
				cm->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
				cm->ip->RedrawViews(cm->ip->GetTime());
			}
			return TRUE;
		}
// mjm - end

		case WM_DESTROY:
			ReleaseICustButton(cm->iPick);
// mjm - begin - 3.10.99
			cm->iPick = NULL;
			ReleaseISpinner(cm->iMapID);
			cm->iMapID = NULL;
// mjm - end
			return TRUE;

		case WM_LBUTTONDOWN: case WM_LBUTTONUP:	case WM_MOUSEMOVE:
			cm->ip->RollupMouseMessage(hWnd, msg, wParam, lParam);
			return TRUE;

		case WM_COMMAND:
			switch (LOWORD(wParam))
			{
// mjm - begin - 3.10.99
				case IDC_PICK:
					if (cm->ip->GetCommandMode()->ID() == CID_PICK_CAMERA)
						cm->ip->SetStdCommandMode(CID_OBJMOVE); // cancel the pick
					else
						cm->ip->SetPickMode(cm->pickMode); // do the pick
					return TRUE;

				case IDC_MAP_CHAN_1:
				case IDC_MAP_CHAN_0:
				{
					int chan = IsDlgButtonChecked(hWnd,IDC_MAP_CHAN_1);
					if (chan != cm->channel)
					{
						cm->channel = chan;
						if (cm->channel == 0)
							cm->iMapID->Enable(FALSE);
						else
						{
							cm->channel = cm->iMapID->GetIVal();
							cm->iMapID->Enable(TRUE);
						}
						cm->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
						cm->ip->RedrawViews(cm->ip->GetTime());
					}
					return TRUE;
				}
// mjm - end
			}
	}
	return FALSE; 
}

// This is the dialog proc for the 'Supports Objects of Type' rollup
BOOL CALLBACK DefaultSOTProc(HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam) {
	IObjParam *ip = (IObjParam*)GetWindowLong(hWnd,GWL_USERDATA);

	switch (msg) {
		case WM_INITDIALOG:
			SetWindowLong(hWnd, GWL_USERDATA, lParam);
			break;

		case WM_LBUTTONDOWN: case WM_LBUTTONUP: case WM_MOUSEMOVE:
			if (ip) ip->RollupMouseMessage(hWnd, msg, wParam, lParam);
			return FALSE;

		default: 
			return FALSE;
	}
	return TRUE;
}

/*===========================================================================*\
 | Static global functions
\*===========================================================================*/
// This is used in building the apparatus mesh
static void MakeTri(Face *f, int a, int b, int c) {
	f[0].setVerts(a,b,c);
	f[0].setSmGroup(0);
	f[0].setEdgeVisFlags(1,1,1);	
}

/*===========================================================================*\
 | CamMapObj MAX Methods
\*===========================================================================*/
// --- Methods From Animatable ---
void CamMapObj::BeginEditParams(IObjParam *ip, ULONG flags, Animatable *prev) {
	this->ip = ip;
	// Add the Main rollup pages to the command panel.
	hObjRollup = ip->AddRollupPage(hInstance, MAKEINTRESOURCE(IDD_OBJ),
		DefaultSOTProc, GetString(IDS_SOT), (LPARAM)ip, 0);		
}

void CamMapObj::EndEditParams(IObjParam *ip, ULONG flags, Animatable *next) {
	// Delete the rollup pages
	ip->DeleteRollupPage(hObjRollup);
	hObjRollup = NULL;
}

// --- Methods From ReferenceTarget ---
RefTargetHandle CamMapObj::Clone(RemapDir& remap) {
	CamMapObj* newob = new CamMapObj();	
	return(newob);
}

// --- Methods From BaseObject ---
int CamMapObj::HitTest(TimeValue t, INode* inode, int type, int crossing, 
	int flags, IPoint2 *p, ViewExp *vpt) {
	
	Point2 pt( (float)p[0].x, (float)p[0].y );
	HitRegion hitRegion;
	GraphicsWindow *gw = vpt->getGW();	
	Material *mtl = &swMtl; 
	Matrix3 mat = inode->GetObjectTM(t);	
	gw->setTransform(mat);

	MakeHitRegion(hitRegion, type, crossing, 4, p);

	return mesh.select(gw, mtl, &hitRegion, flags & HIT_ABORTONHIT);
}

void CamMapObj::Snap(TimeValue t, INode* inode, SnapInfo *snap, IPoint2 *p, 
	ViewExp *vpt) {

	Matrix3 tm = inode->GetObjectTM(t);	
	GraphicsWindow *gw = vpt->getGW();
	gw->setTransform(tm);
	mesh.snap(gw, snap, p, tm);
}

int CamMapObj::Display(TimeValue t, INode* inode, ViewExp *vpt, int flags) {
	GraphicsWindow *gw = vpt->getGW();
	Material *mtl = &swMtl;
	Matrix3 mat = inode->GetObjectTM(t);
 	DWORD rlim = gw->getRndLimits();
	gw->setRndLimits(
		GW_WIREFRAME|/*GW_BACKCULL|*/ (rlim&GW_Z_BUFFER?GW_Z_BUFFER:0));//removed BC 2/16/99 DB
	gw->setTransform(mat);
	if (inode->Selected()) 
		gw->setColor( LINE_COLOR, GetSelColor());
	else if(!inode->IsFrozen())
//		gw->setColor( LINE_COLOR, swMtl.Kd[0], swMtl.Kd[1], swMtl.Kd[2]);
		gw->setColor(LINE_COLOR,GetUIColor(COLOR_SPACE_WARPS));
	mesh.render(gw, mtl, NULL, COMP_ALL);
	gw->setRndLimits(rlim);
	return(0);
}

void CamMapObj::GetWorldBoundBox(TimeValue t, INode* inode, ViewExp* vpt, 
	Box3& box) {

	Box3 meshBox;
	Matrix3 mat = inode->GetObjectTM(t);	
	GetLocalBoundBox(t, inode, vpt, meshBox);
	box.Init();
	for(int i = 0; i < 8; i++)
		box += mat * meshBox[i];
}

void CamMapObj::GetLocalBoundBox(TimeValue t, INode* inode, 
	ViewExp* vpt, Box3& box ) {		

	box = mesh.getBoundingBox();
}

// --- Methods From WSMObject ---
// When the user binds a node to a space warp, a new modifier must be 
// created and added to the node's WSM derived object. This method creates 
// the new modifier.
Modifier *CamMapObj::CreateWSMMod(INode *node) {
	return new CamMapWSMod();
}

/*===========================================================================*\
 | CamMapWSMod MAX Methods
\*===========================================================================*/
// --- Methods From Animatable ---
void CamMapWSMod::BeginEditParams(IObjParam *ip, ULONG flags, Animatable *prev) {
	this->ip = ip;

	// Create a new instance of the command mode to handle the 
	// camera node selection and initialize our pickMode pointer.
	pickMode = new PickWSModCameraMode(this);

	// Indicate this is the current Modifier being edited
	editMod = this;

	// Add the Main rollup pages to the command panel.
	hModRollup = ip->AddRollupPage(hInstance, MAKEINTRESOURCE(IDD_WSMOD),
		CamMapWSModDlgProc, GetString(IDS_CAMERAMAPPING), (LPARAM)this, 0);		
}

void CamMapWSMod::EndEditParams(IObjParam *ip, ULONG flags, Animatable *next) {
	// Delete the rollup pages
	ip->DeleteRollupPage(hModRollup);
	// Clear the pick command mode from the command stack.
	ip->ClearPickMode();
	delete pickMode;
	pickMode = NULL;
	editMod = NULL;
	hModRollup = NULL;
}

// --- Methods From ReferenceMaker ---
RefTargetHandle CamMapWSMod::GetReference(int i) {
	switch(i) {
		case CAM_REF: return (RefTargetHandle)camRef;
		default: return NULL;
	}
}

void CamMapWSMod::SetReference(int i, RefTargetHandle rtarg) { 
	switch(i) {
		case CAM_REF: camRef = (INode *) rtarg; return;
	}
}

// This method is called when one of the items we reference changes.
RefResult CamMapWSMod::NotifyRefChanged(Interval changeInt, 
	RefTargetHandle hTarget, PartID& partID, RefMessage message) {
	switch (message) {
		case REFMSG_TARGET_DELETED:	
			if (hTarget == camRef) {
				// The user has deleted the camera node we reference.
				// Set our reference pointer to NULL.
				camRef = NULL;
				// If the modifier edit rollup is up, make sure the 
				// camera node name reads "None".
				if (hModRollup)
					SetWindowText(GetDlgItem(hModRollup, 
						IDC_CAMERA_NAME), GetString(IDS_NONE));
			}
			break;
	}
	return REF_SUCCEED; 
}

// mjm - begin - 3.10.99
IOResult CamMapWSMod::Save(ISave* isave)
{
	ULONG nb;
	int version(3);

	isave->BeginChunk(VERSION_CHUNK);
	isave->Write(&version, sizeof(int), &nb);
	isave->EndChunk();

	isave->BeginChunk(CHANNEL_CHUNK);
	isave->Write(&channel, sizeof(int), &nb);
	isave->EndChunk();

	return IO_OK;
}

IOResult CamMapWSMod::Load(ILoad* iload) {
	ULONG nb;
	IOResult res;

	while ( IO_OK == (res = iload->OpenChunk()) )
	{
		switch ( iload->CurChunkID() )
		{
			case CHANNEL_CHUNK: // mjm - 3.10.99
				res=iload->Read(&channel, sizeof(int), &nb);
				break;
		}
		iload->CloseChunk();
		if (res != IO_OK)
			return res;
	}
	return IO_OK;
}
// mjm - end

// --- Methods From ReferenceTarget ---
RefTargetHandle CamMapWSMod::Clone(RemapDir& remap) {
	// Create a new modifier and init the copied references and vars...
	CamMapWSMod *newMod = new CamMapWSMod();

	if (camRef)
		newMod->ReplaceReference(CAM_REF, camRef);
	else
		newMod->camRef = NULL;

	newMod->pickMode = NULL;
	newMod->editMod = NULL;
	return newMod;
}

// --- Methods From Modifier ---

// The basic idea in this method is to take the vertex coordinates of the
// object this modifier is applied to, and transform these vertices into
// screen space. The X,Y screen coordinates then become the UV coordinates.
void CamMapWSMod::ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node)
{
	// If we don't have a camera yet, we can't do anything...
	if (!camRef) return;

	// Make sure this is indeed a TriObject so we can cast it as one...
	assert(os->obj->IsSubClassOf(triObjectClassID));
	TriObject *triObj = (TriObject *)os->obj;
// mjm - begin - 3.10.99
	Mesh &mesh = triObj->GetMesh();
	int nVerts( mesh.getNumVerts() );
	int nFaces( mesh.getNumFaces() );

	// Make sure the object's points are in world space. We do this
	// by multiplying by the ObjectState TM. If the points are
	// already in world space this matrix will be NULL so
	// there is no need to do this. Otherwise we will transform
	// the points by this TM thus putting them in world space.
	if (os->GetTM()) {
		Matrix3 tm = *(os->GetTM());
		for (int i=0; i<nVerts; i++)
			mesh.verts[i] = mesh.verts[i]*tm;

		// Set the geometry channel interval to be the same
		// as the ObjectState TM interval since its validity
		// now governs the interval of the modified points
		os->obj->UpdateValidity(GEOM_CHAN_NUM, os->tmValid());

		// Once the points are transformed the matrix needs to set to NULL
		os->SetTM(NULL, FOREVER);
	}

	// ensure there are tverts for the channel
	mesh.setMapSupport(channel);

	if ( nVerts != mesh.getNumMapVerts(channel) )
		mesh.setNumMapVerts(channel, nVerts);

	TVFace *tvFaces = mesh.mapFaces(channel);
	for (int i=0; i<nFaces; i++)
		tvFaces[i].setTVerts(mesh.faces[i].getAllVerts());

	// Get the transformation into camera space
	Matrix3 invCamTM = Inverse(camRef->GetObjectTM(t));

	// Create a copy of the world space vertex coordinates. These will 
	// be transformed into screen space and used as the UVWs 
	// for the TriObject.
	Point3 *UVW = (Point3 *) LocalAlloc(LPTR, nVerts*sizeof(Point3));
	for (i=0; i<nVerts; i++)
		UVW[i] = mesh.verts[i]*invCamTM;

	// Get the Field of View parameter from the camera we reference
	ObjectState camOState = camRef->EvalWorldState(t);
	Interval valid = FOREVER;
	float fov = ((CameraObject *)camOState.obj)->GetFOV(t, valid);

	// Compute the scale factors
	float xScale = -0.5f / ((float) tan(0.5*(double)fov));
	Interface *ip = GetCOREInterface();
	float aspectRatio = ip->GetRendImageAspect();
	float yScale = xScale*aspectRatio;

	// Transform the points into screen space
	float distance, x, y, z;
	for (i=0; i<nVerts; i++) {
		x = UVW[i].x; y = UVW[i].y; z = UVW[i].z;
		distance = (float) sqrt(x*x + y*y + z*z);
		UVW[i].x = UVW[i].x*xScale/z + 0.5f;
		UVW[i].y = UVW[i].y*yScale/z + 0.5f;
		UVW[i].z = distance;
	}

	// We have the UVWs ... set them into the tVerts of the mesh
	UVVert *uvVerts = mesh.mapVerts(channel);
	for (i=0; i<nVerts; i++)
		uvVerts[i] = UVW[i];

	// Free the UVWs we allocated...
	LocalFree(UVW);

	// The texture mapping depends on the geometry and topology so make sure
	// the validity interval reflects this.
	Interval iv = LocalValidity(t);

	iv &= triObj->ChannelValidity(t, GEOM_CHAN_NUM);
	iv &= triObj->ChannelValidity(t, TOPO_CHAN_NUM);
	if (!channel)
	{
		iv &= triObj->ChannelValidity (t, VERT_COLOR_CHAN_NUM);
		os->obj->UpdateValidity(VERT_COLOR_CHAN_NUM, iv);
	}
	else
	{
		iv &= triObj->ChannelValidity (t, TEXMAP_CHAN_NUM);
		os->obj->UpdateValidity(TEXMAP_CHAN_NUM, iv);
	}
}
// mjm - end

// Returns the validity of the modifier. We depend only on the camera
// validity -- its ObjectTM and its FOV parameter. If we don't have a
// camera node assigned, we are valid FOREVER.
Interval CamMapWSMod::LocalValidity(TimeValue t) {
	if (camRef) {
		Interval valid = FOREVER;
		Matrix3 tmCam = camRef->GetObjectTM(t, &valid);
		ObjectState camOState = camRef->EvalWorldState(t);
		((CameraObject *) camOState.obj)->GetFOV(t, valid);
		return valid;
	} 
	else
		return FOREVER;
}

/*===========================================================================*\
 | Camera Picking -- Various Methods
\*===========================================================================*/
BOOL PickWSModCameraMode::Filter(INode *node) {
	if (node) {
		ObjectState os = node->EvalWorldState(0);
		if (os.obj->SuperClassID() == CAMERA_CLASS_ID) {
			SetCursor(cm->ip->GetSysCursor(SYSCUR_SELECT));
			return TRUE;
		}
	}
	return FALSE;
}

BOOL PickWSModCameraMode::HitTest(IObjParam *ip, HWND hWnd, ViewExp *vpt,
	IPoint2 m, int flags) {

	// Here a method of class Interface is called to handle the 
	// actual node pick. If a node was found it is returned, 
	// otherwise NULL is returned.
	INode *node = cm->ip->PickNode(hWnd, m);
	if (node) {
		ObjectState os = node->EvalWorldState(0);
		if (os.obj->SuperClassID() == CAMERA_CLASS_ID) {
			SetCursor(cm->ip->GetSysCursor(SYSCUR_SELECT));
			return TRUE;
		}
	}
	return FALSE;
}

BOOL PickWSModCameraMode::Pick(IObjParam *ip, ViewExp *vpt) {
	INode *node = vpt->GetClosestHit();
	if (node) {
		ObjectState os = node->EvalWorldState(0);
		if (os.obj->SuperClassID() == CAMERA_CLASS_ID) {
			if (cm->SetCameraNode(node)) {
				SetWindowText(GetDlgItem(cm->hModRollup, IDC_CAMERA_NAME), node->GetName());
				cm->ip->SetStdCommandMode(CID_OBJMOVE);
				cm->ip->RedrawViews(cm->ip->GetTime());						
			} 
			else {
				TSTR buf = GetString(IDS_ILLEGALCAM);
				MessageBox(ip->GetMAXHWnd(), buf,
					MESSAGE_TITLE, MB_OK|MB_ICONEXCLAMATION);
			}
		}
	}
	return TRUE;
}

/*===========================================================================*\
 | CamMapObj Methods
\*===========================================================================*/
CamMapObj::CamMapObj() {
	BuildMesh(TimeValue(0), mesh);
	mesh.EnableEdgeList(1);
}

CamMapObj::~CamMapObj() {
	DeleteAllRefsFromMe();
}

void CamMapObj::BuildMesh(TimeValue t,Mesh &mesh) {		
	float s = 12.0f;
	mesh.setNumVerts(4);
	mesh.setNumFaces(4);
	mesh.setVert(0,s*Point3(0.0f,1.0f,0.0f));
	mesh.setVert(1,s*Point3(-float(cos(DegToRad(30.0f))),
		-float(sin(DegToRad(30.0f))),0.0f));
	mesh.setVert(2,s*Point3(float(cos(DegToRad(30.0f))),
		-float(sin(DegToRad(30.0f))),0.0f));
	mesh.setVert(3,s*Point3(0.0f,0.0f,1.0f));
	MakeTri(&(mesh.faces[0]),2,1,0);
	MakeTri(&(mesh.faces[1]),3,0,1);
	MakeTri(&(mesh.faces[2]),3,1,2);
	MakeTri(&(mesh.faces[3]),3,2,0);
	mesh.InvalidateGeomCache();	
}

CreateMouseCallBack* CamMapObj::GetCreateMouseCallBack() {
	camMapCreateCB.SetObj(this);
	return &camMapCreateCB;
}

/*===========================================================================*\
 | CamMapWSMod Methods
\*===========================================================================*/
CamMapWSMod::CamMapWSMod() {
	channel = 1; // mjm - 3.10.99
	camRef = NULL;
}

CamMapWSMod::~CamMapWSMod() {
	DeleteAllRefsFromMe();	
}

// This method is called to save the camera node.
BOOL CamMapWSMod::SetCameraNode(INode *node) {
	if (node->TestForLoop(FOREVER,this)==REF_SUCCEED) {
		theHold.Begin();

		// Set the camera reference to the node.
		ReplaceReference(CAM_REF, (RefTargetHandle)node);

		// Register a restore object with the undo system
		theHold.Put(new PickWSModCameraRestore(this));
		theHold.Accept(GetString(IDS_PICKCAMERA));

		// We have just changed -- notify our dependents
		NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
		return TRUE;
	} 
	else {
		// Cyclic reference... cannot assign this node.
		return FALSE;
	}
}

/*===========================================================================*\
 | CreateMouseCallback Methods
\*===========================================================================*/
// This method handles the user/mouse interaction when the apparatus is 
// being placed and positioned in the viewport by the user
int CamMapObjCreateCallBack::proc(ViewExp *vpt,int msg, int point, 
	int flags, IPoint2 m, Matrix3& mat ) {

	Point3 pt;

	if ((msg == MOUSE_POINT) || (msg == MOUSE_MOVE)) {
		switch(point) {
			case 0:
				pt = vpt->GetPointOnCP(m);
				mat.SetTrans(pt);
				break;
			case 1:								
				pt = vpt->GetPointOnCP(m);
				mat.SetTrans(pt);
				if (msg == MOUSE_POINT) 
					return CREATE_STOP;
				break;
		}
	}
	else {
		if (msg == MOUSE_ABORT)
			return CREATE_ABORT;
	}
	return TRUE;
}

/*===========================================================================*\
 | CamMapMtl Methods
\*===========================================================================*/
// Initialize the apparatus material
CamMapMtl::CamMapMtl() : Material() {
	// Diffuse color
	Kd[0] = CAMMAP_R;
	Kd[1] = CAMMAP_G;
	Kd[2] = CAMMAP_B;

	// Specular color
	Ks[0] = CAMMAP_R;
	Ks[1] = CAMMAP_G;
	Ks[2] = CAMMAP_B;
	shininess = 0.0f;

	// Rendering limit -- keep it wireframe always, and remove 
	// back facing polygons
	shadeLimit = GW_WIREFRAME|GW_BACKCULL;

	// Fully self-illuminated
	selfIllum = 1.0f;
}

/*===========================================================================*\
 | Modifier Code...
\*===========================================================================*/
/*===========================================================================*\
 | Class definitions
\*===========================================================================*/
class PickCameraMode;

class CamMapMod : public Modifier { // mjm - 3.10.99
  public:
	// MAX function interface pointer
	static Interface *ip;

	// Rollup page window handle
	static HWND hModRollup;

	// ui controls
	static ICustButton *iPick;
	static ISpinnerControl *iMapID; // mjm - 3.10.99

	// This is the command mode put into effect when the user selects
	// the iPick button.
	static PickCameraMode *pickMode;

// mjm - begin - 2.3.99
	// This is the Modifier being edited...
	static CamMapMod *editMod;

	// The camera node we reference
	INode *camRef;
// mjm - end

	// the coordinate channel
	int channel; // mjm - 3.10.99

	// This flag indicates the user has choosen a camera and we have
	// retrieved the info we need from it.
	int haveCameraData;

	// The field of view of the camera in radians at the time
	// they did the shapshot
	float fov;
	
	// This is the matrix that represents the relative position of the 
	// object to the camera.
	Matrix3 mat;

	// These two are grabbed once when the camera is assigned and then
	// loaded and saved in the MAX file.
	float aspectRatio;

	// --- Methods From Animatable ---
	void DeleteThis() { delete this; }
	void GetClassName(TSTR& s) { s=GetString(IDS_CAMERAMAPPINGMODIFIER); }
	virtual Class_ID ClassID() { return MOD_CLASS_ID; }
	void BeginEditParams(IObjParam *ip, ULONG flags, Animatable *prev);
	void EndEditParams(IObjParam *ip, ULONG flags, Animatable *next);		

	// --- Methods From ReferenceMaker ---
// mjm - begin - 2.3.99
	RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, PartID& partID, RefMessage message);
	int NumRefs() { return 1; } // camera node
	RefTargetHandle GetReference(int i);
	void SetReference(int i, RefTargetHandle rtarg);
// mjm - end
	IOResult Save(ISave *isave);
	IOResult Load(ILoad *iload);

	// --- Methods From ReferenceTarget ---
	RefTargetHandle Clone(RemapDir& remap = NoRemap());

	// --- Methods From BaseObject ---
	TCHAR *GetObjectName() { return MOD_OBJECT_NAME; }
	CreateMouseCallBack* GetCreateMouseCallBack() { return NULL; } 

	// --- Methods From Modifier ---
	ChannelMask ChannelsUsed()
		{ return PART_GEOM|PART_TOPO|PART_SELECT|TEXMAP_CHANNEL|PART_VERTCOLOR; } // mjm - 3.10.99
	ChannelMask ChannelsChanged()
		{ return PART_VERTCOLOR|TEXMAP_CHANNEL; } // mjm - 3.10.99
	Class_ID InputType() 
		{ return Class_ID(TRIOBJ_CLASS_ID, 0); }
	void ModifyObject(TimeValue t, ModContext &mc, 
		ObjectState *os, INode *node);
	Interval LocalValidity(TimeValue t);

	// --- Methods From CamMapMod ---
	CamMapMod::CamMapMod();
	CamMapMod::~CamMapMod();
	BOOL StoreCameraData(INode *node);
};

// Init the class variables (these are shared by each instance of the class).
// This is okay since only one modifier can be edited at a time
Interface *CamMapMod::ip = NULL;
HWND CamMapMod::hModRollup = NULL;
ICustButton *CamMapMod::iPick = NULL;
ISpinnerControl *CamMapMod::iMapID = NULL; // mjm - 3.10.99
PickCameraMode *CamMapMod::pickMode = NULL;
CamMapMod *CamMapMod::editMod = NULL; // mjm - 2.3.99

// This class is derived from both PickModeCallback (whose various methods
// are called at times during the picking), and PickNodeCallback (which 
// provides a Filter() method used to screen possible hits).
class PickCameraMode : public PickModeCallback, public PickNodeCallback {
  public:		
	CamMapMod *cm;
	
	PickCameraMode(CamMapMod *c) {cm = c;}
	// --- Methods from PickModeCallback ---
	BOOL HitTest(IObjParam *ip, HWND hWnd, ViewExp *vpt,
		IPoint2 m, int flags);
	BOOL Pick(IObjParam *ip, ViewExp *vpt);
	void EnterMode(IObjParam *ip)
		{ cm->iPick->SetCheck(TRUE); }
	void ExitMode(IObjParam *ip)
		{ if (cm->iPick) cm->iPick->SetCheck(FALSE); }
	BOOL RightClick(IObjParam *ip, ViewExp *vpt) { return TRUE; }

	// This class is itself derived from PickNodeCallback, so it
	// simply returns itself as the GetFilter() pointer.
	PickNodeCallback *GetFilter() {return this;}

	// --- Methods from PickNodeCallback ---
	// This method is used to screen the various nodes passed. It returns
	// TRUE if the node is valid; otherwise FALSE.
	BOOL Filter(INode *node);
};

// mjm - begin - 2.3.99
// This is the restore object used to allow the user to undo or redo the
// selection of a new camera.
class PickModCameraRestore : public RestoreObj {
	public:
		CamMapMod *cm;
		// This constructor is called when the user has assigned a camera
		// and we register a restore object with the undo system.
		PickModCameraRestore(CamMapMod *c) { cm = c; }
		void Restore(int isUndo) {
			if (cm->editMod == cm && cm->hModRollup) {
				if (cm->camRef)
					SetWindowText(GetDlgItem(cm->hModRollup, IDC_CAMERA_NAME), cm->camRef->GetName());
				else
					SetWindowText(GetDlgItem(cm->hModRollup, IDC_CAMERA_NAME), GetString(IDS_NONE));
			}									
		}
		void Redo() {
			if (cm->editMod == cm && cm->hModRollup && cm->camRef) {
				if (cm->camRef)
					SetWindowText(GetDlgItem(cm->hModRollup, IDC_CAMERA_NAME), cm->camRef->GetName());
				else
					SetWindowText(GetDlgItem(cm->hModRollup, IDC_CAMERA_NAME), GetString(IDS_NONE));
			}
		}
		TSTR Description() { 
			return TSTR(GetString(IDS_PICKCAMERA)); 
		}
};
// mjm - end

/*===========================================================================*\
 | Class Descriptor
\*===========================================================================*/
class CamMapModClassDesc : public ClassDesc {
  public:
	int 			IsPublic() {return 1;}
	void			*Create(BOOL loading = FALSE) {return new CamMapMod;}
	const TCHAR		*ClassName() {return CLASSNAME;}
	SClass_ID		SuperClassID() {return OSM_CLASS_ID;}
	Class_ID		ClassID() {return MOD_CLASS_ID;}
	const TCHAR		*Category() {return MOD_CATEGORY;}
};
static CamMapModClassDesc camMapModDesc;

/*===========================================================================*\
 | Dialog Procs
\*===========================================================================*/
// This is the dialog proc for the 'Snapshot Camera' rollup
static BOOL CALLBACK CamMapModDlgProc(HWND hWnd, UINT msg, 
	WPARAM wParam, LPARAM lParam) {

	CamMapMod *cm = (CamMapMod *)GetWindowLong(hWnd, GWL_USERDATA);
	if (!cm && msg != WM_INITDIALOG ) return FALSE;

	switch (msg)
	{
		case WM_INITDIALOG:
			cm = (CamMapMod *)lParam;
			SetWindowLong(hWnd, GWL_USERDATA, (LONG) cm);
			cm->iPick = GetICustButton(GetDlgItem(hWnd, IDC_PICK));
			cm->iPick->SetText(GetString(IDS_PICKCAMERA));
			cm->iPick->SetType(CBT_CHECK);
			cm->iPick->SetHighlightColor(GREEN_WASH);
			cm->iPick->SetCheckHighlight(TRUE);
// mjm - begin - 2.3.99
			// Display the camera node name or "None"
			if (cm->camRef)
				SetWindowText(GetDlgItem(hWnd, IDC_CAMERA_NAME), cm->camRef->GetName());
			else
				SetWindowText(GetDlgItem(hWnd, IDC_CAMERA_NAME), GetString(IDS_NONE));
// mjm - end
// mjm - begin - 3.10.99
			cm->iMapID = GetISpinner(GetDlgItem(hWnd,IDC_MAP_CHAN_SPIN));
			cm->iMapID->LinkToEdit(GetDlgItem(hWnd,IDC_MAP_CHAN_EDIT),EDITTYPE_INT);
			cm->iMapID->SetLimits(1, 99, FALSE);
			cm->iMapID->SetAutoScale();	
			cm->iMapID->SetValue(cm->channel, FALSE);
			cm->iMapID->Enable(cm->channel);
			CheckRadioButton(hWnd, IDC_MAP_CHAN_1, IDC_MAP_CHAN_0, (cm->channel) ? IDC_MAP_CHAN_1 : IDC_MAP_CHAN_0);
			return TRUE;

		case WM_CUSTEDIT_ENTER:
		case CC_SPINNER_BUTTONUP:
		{
			int chan = cm->iMapID->GetIVal();
			if (chan != cm->channel)
			{
				cm->channel = chan;
				cm->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
				cm->ip->RedrawViews(cm->ip->GetTime());
			}
			return TRUE;
		}
// mjm - end

		case WM_DESTROY:
			ReleaseICustButton(cm->iPick);
// mjm - begin - 3.10.99
			cm->iPick = NULL;
			ReleaseISpinner(cm->iMapID);
			cm->iMapID = NULL;
// mjm - end
			return TRUE;

		case WM_LBUTTONDOWN: case WM_LBUTTONUP:	case WM_MOUSEMOVE:
			cm->ip->RollupMouseMessage(hWnd, msg, wParam, lParam);
			return TRUE;

		case WM_COMMAND:
			switch (LOWORD(wParam))
			{
// mjm - begin - 3.10.99
				case IDC_PICK:
					if (cm->ip->GetCommandMode()->ID() == CID_PICK_CAMERA)
						// cancel pick
						cm->ip->SetStdCommandMode(CID_OBJMOVE);
					else
						// do the pick
						cm->ip->SetPickMode(cm->pickMode);
					return TRUE;

				case IDC_MAP_CHAN_1:
				case IDC_MAP_CHAN_0:
				{
					int chan = IsDlgButtonChecked(hWnd,IDC_MAP_CHAN_1);
					if (chan != cm->channel)
					{
						cm->channel = chan;
						if (cm->channel == 0)
							cm->iMapID->Enable(FALSE);
						else
						{
							cm->channel = cm->iMapID->GetIVal();
							cm->iMapID->Enable(TRUE);
						}
						cm->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
						cm->ip->RedrawViews(cm->ip->GetTime());
					}
					return TRUE;
				}
// mjm - end
			}	
	}
	return FALSE; 
}

/*===========================================================================*\
 | CamMapMod MAX Methods
\*===========================================================================*/
// --- Methods From Animatable ---
void CamMapMod::BeginEditParams(IObjParam *ip, ULONG flags, Animatable *prev) {
	this->ip = ip;

	// Create a new instance of the command mode to handle the 
	// camera node selection and initialize our pickMode pointer.
	pickMode = new PickCameraMode(this);

// mjm - begin - 2.3.99
	// Indicate this is the current Modifier being edited
	editMod = this;
// mjm - end

	// Add the Main rollup pages to the command panel.
	hModRollup = ip->AddRollupPage(hInstance, MAKEINTRESOURCE(IDD_MOD),
		CamMapModDlgProc, GetString(IDS_CAMERAMAPPING), (LPARAM)this, 0);		
}

void CamMapMod::EndEditParams(IObjParam *ip, ULONG flags, Animatable *next) {
	// Delete the rollup pages
	ip->DeleteRollupPage(hModRollup);
	// Clear the pick command mode from the command stack.
	ip->ClearPickMode();
	delete pickMode;
	pickMode = NULL;
	editMod = NULL; // mjm - 2.3.99
	hModRollup = NULL;
}

// --- Methods From ReferenceMaker ---
// Save the flag indicating we have the camera data, the matrix we need 
// for the transformation, and the field of view.
IOResult CamMapMod::Save(ISave* isave) {
	ULONG nb;
	int version(3); // mjm - 3.10.99

	isave->BeginChunk(VERSION_CHUNK);
	isave->Write(&version, sizeof(int), &nb);
	isave->EndChunk();

	isave->BeginChunk(HAVE_CAMERA_DATA_CHUNK);
	isave->Write(&haveCameraData, sizeof(int), &nb);
	isave->EndChunk();

	isave->BeginChunk(MATRIX3_CHUNK);
	isave->Write(mat.GetAddr(), sizeof(Matrix3), &nb);
	isave->EndChunk();

	isave->BeginChunk(FOV_CHUNK);
	isave->Write(&fov, sizeof(float), &nb);
	isave->EndChunk();

	isave->BeginChunk(ASPECT_CHUNK);
	isave->Write(&aspectRatio, sizeof(float), &nb);
	isave->EndChunk();

	isave->BeginChunk(CHANNEL_CHUNK); // mjm - 3.10.99
	isave->Write(&channel, sizeof(int), &nb);
	isave->EndChunk();

	return IO_OK;
}

IOResult CamMapMod::Load(ILoad* iload) {
	ULONG nb;
	IOResult res;

	// Set some default values in case old files are loaded. The older
	// files didn't save these value so they won't otherwise be loaded.
	Interface *ip = GetCOREInterface();
	aspectRatio = ip->GetRendImageAspect();
	// Load the chunks...
	while (IO_OK == (res = iload->OpenChunk())) {
		switch(iload->CurChunkID()) {
			case HAVE_CAMERA_DATA_CHUNK:
				res=iload->Read(&haveCameraData, sizeof(int), &nb);
				break;
			case MATRIX3_CHUNK:
				res=iload->Read(mat.GetAddr(), sizeof(Matrix3), &nb);
				break;
			case FOV_CHUNK:
				res=iload->Read(&fov, sizeof(float), &nb);
				break;
			case ASPECT_CHUNK:
				res=iload->Read(&aspectRatio, sizeof(float), &nb);
				break;
			case CHANNEL_CHUNK: // mjm - 3.10.99
				res=iload->Read(&channel, sizeof(int), &nb);
				break;
		}
		iload->CloseChunk();
		if (res != IO_OK)
			return res;
	}
	return IO_OK;
}

// --- Methods From Modifier ---

void CamMapMod::ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node)
{
	// If the user hasn't choosen a camera yet, don't do anything.
	if (!camRef) return; // mjm - 2.3.99

	// Make sure this is indeed a TriObject so we can cast it as one...
	assert(os->obj->IsSubClassOf(Class_ID(TRIOBJ_CLASS_ID, 0)));
	TriObject *triObj = (TriObject *)os->obj;
// mjm - begin - 3.10.99
	Mesh &mesh = triObj->GetMesh();
	int nVerts( mesh.getNumVerts() );
	int nFaces( mesh.getNumFaces() );

	// ensure there are tverts for the channel
	mesh.setMapSupport(channel);

	if ( nVerts != mesh.getNumMapVerts(channel) )
		mesh.setNumMapVerts(channel, nVerts);

	TVFace *tvFaces = mesh.mapFaces(channel);
	for (int i=0; i<nFaces; i++)
		tvFaces[i].setTVerts(mesh.faces[i].getAllVerts());

	// Create a copy of the vertex coordinates and transform them.
	// This first part of the transformation puts the coords into 
	// the space of the camera 
	Point3 *UVW = (Point3 *) LocalAlloc(LPTR, nVerts*sizeof(Point3));
	for (i=0; i<nVerts; i++)
		UVW[i] = mesh.verts[i]*mat;

	// Compute the scale factors
	float xScale = -0.5f / ((float) tan(0.5*(double)fov));
	float yScale = xScale*aspectRatio;

	// Transform the points into screen space
	float distance, x, y, z;
	for (i=0; i<nVerts; i++) {
		x = UVW[i].x; y = UVW[i].y; z = UVW[i].z;
		distance = (float) sqrt(x*x + y*y + z*z);
		UVW[i].x = UVW[i].x*xScale/z + 0.5f;
		UVW[i].y = UVW[i].y*yScale/z + 0.5f;
		UVW[i].z = distance;
	}

	// We have the UVWs ... set them into the tVerts of the mesh
	UVVert *uvVerts = mesh.mapVerts(channel);
	for (i=0; i<nVerts; i++)
		uvVerts[i] = UVW[i];

	// Free the UVWs we allocated...
	LocalFree(UVW);

	// The texture mapping depends on the geometry and topology so make sure 
	// the validity interval reflects this.
	Interval iv = LocalValidity(t);

	iv &= triObj->ChannelValidity(t, GEOM_CHAN_NUM);
	iv &= triObj->ChannelValidity(t, TOPO_CHAN_NUM);
	if (!channel)
	{
		iv &= triObj->ChannelValidity (t, VERT_COLOR_CHAN_NUM);
		os->obj->UpdateValidity(VERT_COLOR_CHAN_NUM, iv);
	}
	else
	{
		iv &= triObj->ChannelValidity (t, TEXMAP_CHAN_NUM);
		os->obj->UpdateValidity(TEXMAP_CHAN_NUM, iv);
	}
}
// mjm - end

// Returns the validity of the modifier.
Interval CamMapMod::LocalValidity(TimeValue t) {
	return FOREVER;
}

// --- Methods From ReferenceMaker ---
RefTargetHandle CamMapMod::GetReference(int i) {
	switch(i) {
		case CAM_REF: return (RefTargetHandle)camRef;
		default: return NULL;
	}
}

void CamMapMod::SetReference(int i, RefTargetHandle rtarg) { 
	switch(i) {
		case CAM_REF: camRef = (INode *) rtarg; return;
	}
}

// This method is called when one of the items we reference changes.
RefResult CamMapMod::NotifyRefChanged(Interval changeInt, 
	RefTargetHandle hTarget, PartID& partID, RefMessage message) {
	switch (message) {
		case REFMSG_TARGET_DELETED:	
			if (hTarget == camRef) {
				// The user has deleted the camera node we reference.
				// Set our reference pointer to NULL.
				camRef = NULL;
				// If the modifier edit rollup is up, make sure the 
				// camera node name reads "None".
				if (hModRollup)
					SetWindowText(GetDlgItem(hModRollup, 
						IDC_CAMERA_NAME), GetString(IDS_NONE));
			}
			break;
	}
	return REF_SUCCEED; 
}

// --- Methods From ReferenceTarget ---
RefTargetHandle CamMapMod::Clone(RemapDir& remap) {
	// Create a new modifier and init the copied vars...
	CamMapMod *newMod = new CamMapMod();

	if (camRef)
		newMod->ReplaceReference(CAM_REF, camRef);
	else
		newMod->camRef = NULL;

	newMod->pickMode = NULL;
	newMod->editMod = NULL; // mjm - 2.3.99
	newMod->haveCameraData = haveCameraData;
	newMod->fov = fov;
	newMod->mat = mat;
	return newMod;
}

// --- Methods From CamMapMod ---
CamMapMod::CamMapMod() {
	channel = 1; // mjm - 3.10.99
	camRef = NULL; // mjm - 2.3.99
	haveCameraData = FALSE;
}

CamMapMod::~CamMapMod() {
	DeleteAllRefsFromMe();	
}

BOOL CamMapMod::StoreCameraData(INode *camNode) {
	ModContextList mcList;
	INodeTab nodeTab;
	Interval valid = FOREVER;
	Matrix3 objMat, camMat;
	TimeValue currentTime = ip->GetTime();

// mjm - begin - 2.3.99
	if (camNode->TestForLoop(FOREVER,this)==REF_SUCCEED) {
		theHold.Begin();

		// Set the camera reference to the node.
		ReplaceReference(CAM_REF, (RefTargetHandle)camNode);

		// Register a restore object with the undo system
		theHold.Put(new PickModCameraRestore(this));
		theHold.Accept(GetString(IDS_PICKCAMERA));
// mjm - end

		// Get the INode* of the _first_ object we modify. Anyone in their 
		// right mind will apply this to only one object, but since it's an
		// OSM they can instance the modifier...
		ip->GetModContexts(mcList, nodeTab);
		INode *n0 = nodeTab[0];

		// Get the matrix to transform the objects points to world space
		objMat = n0->GetObjectTM(currentTime, &valid);
		// Get the matrix to transform the camera into world space
		camMat = camNode->GetObjectTM(currentTime, &valid);

		// Create the matrix that represents the relative position of the 
		// object to the camera.
		mat = objMat*Inverse(camMat);

		// Get the field of view from the camera
		ObjectState camOState = camNode->EvalWorldState(currentTime);
		fov = ((CameraObject *) camOState.obj)->GetFOV(currentTime, valid);

		// Set the flag to indicate we got it...
		haveCameraData = TRUE;

		// Grab the aspect and pixel aspect ratios
		aspectRatio = ip->GetRendImageAspect();

		// We have just changed -- notify our dependents
		NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
		return TRUE;
// mjm - begin - 2.3.99
	} 
	else {
		// Cyclic reference... cannot assign this node.
		return FALSE;
	}
// mjm - end
}

/*===========================================================================*\
 | Camera Picking -- Various Methods
\*===========================================================================*/
BOOL PickCameraMode::Filter(INode *node) {
	if (node) {
		ObjectState os = node->EvalWorldState(0);
		if (os.obj->SuperClassID() == CAMERA_CLASS_ID) {
			SetCursor(cm->ip->GetSysCursor(SYSCUR_SELECT));
			return TRUE;
		}
	}
	return FALSE;
}

BOOL PickCameraMode::HitTest(IObjParam *ip, HWND hWnd, ViewExp *vpt,
	IPoint2 m, int flags) {

	// Here a method of class Interface is called to handle the 
	// actual node pick. If a node was found it is returned, 
	// otherwise NULL is returned.
	INode *node = cm->ip->PickNode(hWnd, m);
	if (node) {
		ObjectState os = node->EvalWorldState(0);
		if (os.obj->SuperClassID() == CAMERA_CLASS_ID) {
			SetCursor(cm->ip->GetSysCursor(SYSCUR_SELECT));
			return TRUE;
		}
	}
	return FALSE;
}

BOOL PickCameraMode::Pick(IObjParam *ip, ViewExp *vpt) {
	INode *node = vpt->GetClosestHit();
	if (node) {
		ObjectState os = node->EvalWorldState(0);
		if (os.obj->SuperClassID() == CAMERA_CLASS_ID) {
			if (cm->StoreCameraData(node)) {
				SetWindowText(GetDlgItem(cm->hModRollup, IDC_CAMERA_NAME), node->GetName()); // mjm - 2.3.99
				cm->ip->SetStdCommandMode(CID_OBJMOVE);
				cm->ip->RedrawViews(cm->ip->GetTime());
			} 
			else {
				TSTR buf = GetString(IDS_ILLEGALCAM);
				MessageBox(ip->GetMAXHWnd(), buf,
					MESSAGE_TITLE, MB_OK|MB_ICONEXCLAMATION);
			}
		}
	}
	return TRUE;
}

/*===========================================================================*\
 | Dll/Lib Functions
\*===========================================================================*/
int controlsInit = FALSE;
BOOL WINAPI DllMain(HINSTANCE hinstDLL, ULONG fdwReason, LPVOID lpvReserved) {	
	hInstance = hinstDLL;
	if (! controlsInit) {
		controlsInit = TRUE;
		InitCustomControls(hInstance);
		InitCommonControls();
	}
	return(TRUE);
}

__declspec(dllexport) const TCHAR *LibDescription() {
	return (LIBDESCRIPTION);
}

__declspec(dllexport) int LibNumberClasses() { 
	return 3;
}

__declspec(dllexport) ClassDesc* LibClassDesc(int i) { 
	switch(i) {
		case 0: // Space warp object
			return &camMapObjDesc;
		case 1: // Space warp modifier
			return &camMapWSModDesc;
		case 2: // Modifier
			return &camMapModDesc; 
		default:
			return 0;
	}
}

__declspec(dllexport) ULONG LibVersion() { 
	return VERSION_3DSMAX; 
}

// Let the plug-in register itself for deferred loading
__declspec( dllexport ) ULONG CanAutoDefer()
{
	return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\cjrender\cjrender.cpp ===
//***************************************************************************
// CJRender - [cjrender.cpp] Sample Plugin Renderer for 3D Studio MAX.
// 
// By Christer Janson - Kinetix
//
// Description:
// Implementation of main render class
//
//***************************************************************************

#include "maxincl.h"
#include "cjrender.h"
#include "rendutil.h"
#include "refenum.h"

//===========================================================================
//
// Class CJRenderer
//
//===========================================================================

//***************************************************************************
// This is called on File/Reset and we should 
// reset the class variables here.
//***************************************************************************

CJRenderer::CJRenderer()
{
	rendParams.renderer = this;
}

//***************************************************************************
// This is called on File/Reset and we should 
// reset the class variables here.
//***************************************************************************

void CJRenderer::ResetParams()
{
	DebugPrint("**** Resetting parameters.\n");

	rendParams.	SetDefaults();
}

//***************************************************************************
// Standard Animatable method
//***************************************************************************

void CJRenderer::DeleteThis()
{
	delete this;
}

//***************************************************************************
// Standard Animatable method
//***************************************************************************

Class_ID CJRenderer::ClassID()
{
	return CCJREND_CLASS_ID;
}

//***************************************************************************
// Standard Animatable method
//***************************************************************************

void CJRenderer::GetClassName(TSTR& s)
{
	s = RENDERNAME;
}

//***************************************************************************
// Open the renderer.
// This is called when the rendering is first initiated.
// We should do a couple of things here:
// * Grab the parameters passed in and set our own representation
//   of these parameters
// * Enumerate the scene to create a list of all nodes and lights
// * Get hold of the atmospheric effects used
// * Get hold of all materials used.
// * Call RenderBegin() on all objects
//***************************************************************************

int CJRenderer::Open(INode *scene,INode *vnode,ViewParams* viewPar,RendParams& rpar,HWND hwnd,DefaultLight* defaultLights,int numDefLights)
{
	int idx;

	// Important!! This has to be done here in MAX Release 2!
	// Also enable it again in Renderer::Close()
	GetCOREInterface()->DisableSceneRedraw();

	// Get options from RenderParams
	// These are the options that are common to all renderers
	rendParams.bVideoColorCheck = rpar.colorCheck;
	rendParams.bForce2Sided = rpar.force2Side;
	rendParams.bRenderHidden = rpar.rendHidden;
	rendParams.bSuperBlack = rpar.superBlack;
	rendParams.bRenderFields = rpar.fieldRender;
	rendParams.bNetRender = rpar.isNetRender;
	rendParams.rendType = rpar.rendType;

	// Default lights
	rendParams.nNumDefLights = numDefLights;
	rendParams.pDefaultLights = defaultLights;

	// Flag we use when reporting errors
	bFirstFrame = TRUE;
	bUvMessageDone = FALSE;

	// Initialize node counter
	nCurNodeID = 0;

	// Couldn't hurt to initalize these tables...
	ilist = NULL;
	instTab.ZeroCount();
	instTab.Shrink();
	lightTab.ZeroCount();
	lightTab.Shrink();
	mtls.ZeroCount();
	mtls.Shrink();

	// Get the root of the node hierarchy
	pScene = scene;

	// Viewnode is given if our view is a camera or a light
	pViewNode = vnode;
	theView.pRendParams = &rendParams;

	// Viewpar is there if we render a viewport
	if (viewPar) 
		view = *viewPar;


	// Enumerate the nodes in the scene
	// nodeEnum will fill in the rNodeTab for us.
	// Please note that the scene itself is not a true node, it is a
	// place holder whose children are the top level nodes..
	DebugPrint("**** Scanning for nodes.\n");
	for (idx = 0; idx < scene->NumberOfChildren(); idx++) {
		NodeEnum(scene->GetChildNode(idx));
	}

	DebugPrint("\tFound %d nodes\n", instTab.Count());
	DebugPrint("\tFound %d lights\n", lightTab.Count());

	// If there are no lights in the scene
	// we should use the default lights if we got them.
	if (lightTab.Count() == 0 && defaultLights) {
		for (idx = 0; idx < numDefLights; idx++) {
			RenderLight* rl = new RenderLight(&defaultLights[idx]);
			lightTab.Append(1, &rl);
		}
		DebugPrint("\tUsing %d default lights\n", lightTab.Count());
	}

	// The "top atmospheric" called RenderEnvironment is passed as a member
	// of RendParams.
	// All atmospheric effects are referenced by the RenderEnvironment so we
	// only need to evaluate this "RenderEnvironment" in order to catch all
	// Atmospherics.
	rendParams.atmos = rpar.atmos;

	// The environment Map is a pointer to a Texmap
	rendParams.envMap = rpar.envMap;

	// Add any texture maps in the atmosphere or environment to the mtls list
	GetMaps getmaps(&mtls);

	if (rendParams.atmos)

		EnumRefs(rendParams.atmos,getmaps);

	if (rendParams.envMap)
		EnumRefs(rendParams.envMap,getmaps);

	BeginThings();				// Call RenderBegin() on all objects

	// Indicate that we have been opened.
	// A developer can initialize the renderer from the interface class
	// and we want to make sure that he has called Open() first.
	bOpen = TRUE;

	return 1; 	
}

//***************************************************************************
// Close is the last thing called after rendering all frames.
// Things to do here includes:
// * Deleting anything we have allocated.
// * Call RenderEnd() on all objects
//***************************************************************************

void CJRenderer::Close(HWND hwnd)
{
	int idx;
	DebugPrint("**** Renderer going down.\n");

	EndThings();				// Call RenderEnd() on all objects

	for (idx=0; idx<instTab.Count(); idx++) {
		delete instTab[idx];
	}
	instTab.ZeroCount();
	instTab.Shrink();

	for (idx=0; idx<lightTab.Count(); idx++) {
		delete lightTab[idx];
	}
	lightTab.ZeroCount();
	lightTab.Shrink();

	// Shouldn't delete materials. The Dummy materials are already deleted,
	// and the rest of them aren't allocated/created by us.
	mtls.ZeroCount();
	mtls.Shrink();

	// Important!! Don't forget to enable screen redraws when the renderer closes.
	GetCOREInterface()->EnableSceneRedraw();
	bOpen = FALSE;
}

//***************************************************************************
// Call RenderBegin() on all objects.
// We need to call this on each object in the reference hierarchy.
// This needs to be done in order to let the object prepare itself
// for rendering.
// Particle systems for example will change to the number of
// particles used to rendering (instead of for viewport),
// and the optimize modifier have different options for 
// viewport and rendering as well.
//***************************************************************************

void CJRenderer::BeginThings()
{
	int idx;

	ClearFlags clearFlags;
	BeginEnum beginEnum(rendParams.time);

	// First clear the A_WORK1 flag for each object
	for (idx = 0; idx < instTab.Count(); idx++) {
		ReferenceMaker* rm = instTab[idx]->GetINode();
		EnumRefs(rm, clearFlags);
	}

	// Clear reference hierarchy from Atmospherics
	if (rendParams.atmos)
		EnumRefs(rendParams.atmos, clearFlags);

	// Clear reference hierarchy from Environment map
	if (rendParams.envMap)
		EnumRefs(rendParams.envMap, clearFlags);


	// Call RenderBegin() and set the A_WORK1 flag on each object.
	// We need to set the flag so we don't call RenderBegin on the
	// same object twice.
	for (idx = 0; idx < instTab.Count(); idx++) {
		ReferenceMaker* rm = instTab[idx]->GetINode();
		EnumRefs(rm, beginEnum);
	}

	// reference hierarchy from Atmospherics
	if (rendParams.atmos)
		EnumRefs(rendParams.atmos, beginEnum);

	// reference hierarchy from Environment map
	if (rendParams.envMap)
		EnumRefs(rendParams.envMap, beginEnum);
}

//***************************************************************************
// Call RenderEnd() on all objects. See above how we called
// RenderBegin() for information.
//***************************************************************************

void CJRenderer::EndThings()
{
	int idx;

	ClearFlags clearFlags;
	EndEnum endEnum(rendParams.time);

	for (idx = 0; idx < instTab.Count(); idx++) {
		ReferenceMaker* rm = instTab[idx]->GetINode();
		EnumRefs(rm, clearFlags);
	}

	if (rendParams.atmos)
		EnumRefs(rendParams.atmos, clearFlags);

	if (rendParams.envMap)
		EnumRefs(rendParams.envMap, clearFlags);


	for (idx = 0; idx < instTab.Count(); idx++) {
		ReferenceMaker* rm = instTab[idx]->GetINode();
		EnumRefs(rm, endEnum);
	}

	if (rendParams.atmos)
		EnumRefs(rendParams.atmos, endEnum);

	if (rendParams.envMap)
		EnumRefs(rendParams.envMap, endEnum);
}

//***************************************************************************
// Render() is called by MAX to render each frame.
// We get a time, an output bitmap, some parameters and a progress
// callback passed into us here.
//***************************************************************************

int CJRenderer::Render(TimeValue t, Bitmap* tobm, FrameRendParams &frp, HWND hwnd, RendProgressCallback* prog, ViewParams* viewPar)
{
	int i;
	int nExitStatus = 1;

	if (!tobm || !bOpen) {
		return 0; // No output bitmap, not much we can do.
	}
	
	DebugPrint("**** Rendering frame. TimeValue: %d.\n", t);

	// Update progress window
	if (prog) {
		prog->SetTitle("Preparing to render...");
	}

	// Setup ViewParams:
	rendParams.devWidth = tobm->Width();
	rendParams.devHeight = tobm->Height();
	rendParams.devAspect = tobm->Aspect();

	// These are moved from rendparams to FrameRendParams for R3
	rendParams.nRegxmin = frp.regxmin;
	rendParams.nRegymin = frp.regymin;
	rendParams.nRegxmax = frp.regxmax;
	rendParams.nRegymax = frp.regymax;

	// Get the frame
	rendParams.time = t;
	// Get the FrameRenderParams. These are parameters that can be animated
	// so they are different every frame
	rendParams.pFrp = &frp;

	// Viewpar is there if we render a viewport
	if (viewPar) 
		view = *viewPar;

	// Setup the view parameters
	if (pViewNode)
		GetViewParams(pViewNode, view, t);

	rendParams.ComputeViewParams(view);

	// Setup G-Buffer channels
	// The channels we need to supply are present in the output bitmap
	// so we ask the bitmap for the channels we need to fill in
	// Use a BitArray for the channels
	rendParams.gbufChan.SetSize(6);
	rendParams.gbufChan.ClearAll();

	ULONG chan = tobm->ChannelsPresent();
	ULONG ctype;
	pGbufZ = NULL;
	pGbufMtlID = NULL;
	pGbufNodeID = NULL;
	pGbufUV = NULL;
	pGbufNormal = NULL;
	pGbufRealPix = NULL;


	// Get hold of the specific channel
	if (chan & BMM_CHAN_Z) {
		DebugPrint("G-Buffer requests Z buffer\n");
		rendParams.gbufChan.Set(GBUF_Z);
		pGbufZ = (float*)tobm->GetChannel(BMM_CHAN_Z, ctype);
	}
	if (chan & BMM_CHAN_MTL_ID) {
		DebugPrint("G-Buffer requests Material ID\n");
		rendParams.gbufChan.Set(GBUF_MTLID);
		pGbufMtlID = (UBYTE*)tobm->GetChannel(BMM_CHAN_MTL_ID, ctype);
	}
	if (chan & BMM_CHAN_NODE_ID) {
		DebugPrint("G-Buffer requests Node ID\n");
		rendParams.gbufChan.Set(GBUF_NODEID);
		pGbufNodeID = (UWORD*)tobm->GetChannel(BMM_CHAN_NODE_ID, ctype);
	}
	if (chan & BMM_CHAN_UV) {
		DebugPrint("G-Buffer requests UV Channel\n");
		rendParams.gbufChan.Set(GBUF_UV);
		pGbufUV = (Point2*)tobm->GetChannel(BMM_CHAN_UV, ctype);
	}
	if (chan & BMM_CHAN_NORMAL) {
		DebugPrint("G-Buffer requests Normals\n");
		rendParams.gbufChan.Set(GBUF_NORMAL);
		pGbufNormal = (ULONG*)tobm->GetChannel(BMM_CHAN_NORMAL, ctype);
	}
	if (chan & BMM_CHAN_REALPIX) {
		DebugPrint("G-Buffer requests RealPixel\n");
		rendParams.gbufChan.Set(GBUF_REALPIX);
		pGbufRealPix = (RealPixel*)tobm->GetChannel(BMM_CHAN_REALPIX, ctype);
	}
	if (chan & BMM_CHAN_COVERAGE) {
		DebugPrint("G-Buffer requests Pixel Coverage\n");
		rendParams.gbufChan.Set(GBUF_COVER);
		pGbufCov = (UBYTE*)tobm->GetChannel(BMM_CHAN_COVERAGE, ctype);
	}


	// This renderer supports NORMAL or REGION rendering.
	// You should also support SELECTED, and BLOWUP
	if (rendParams.rendType == RENDTYPE_REGION) {
		if (rendParams.nRegxmin<0) rendParams.nRegxmin = 0;
		if (rendParams.nRegymin<0) rendParams.nRegymin = 0;
		if (rendParams.nRegxmax>rendParams.devWidth)
			rendParams.nRegxmax = rendParams.devWidth;
		if (rendParams.nRegymax>rendParams.devHeight)
			rendParams.nRegymax = rendParams.devHeight;
		rendParams.nMinx = rendParams.nRegxmin;
		rendParams.nMiny = rendParams.nRegymin;
		rendParams.nMaxx = rendParams.nRegxmax;
		rendParams.nMaxy = rendParams.nRegymax;
	}
	else {
		rendParams.nMinx = 0;
		rendParams.nMiny = 0;
		rendParams.nMaxx = rendParams.devWidth;
		rendParams.nMaxy = rendParams.devHeight;
	}

	// We need to scan and manually load each map in the system.
	// We will only report any errors on the first frame so we pass in
	// a flag indicating if this is the first frame
	// If some maps are missing this method will ask the user if
	// rendering should continue or be aborted.
	if (!LoadMapFiles(t, hwnd, bFirstFrame))	{
		return 0;
	}

	// Update the Atmospheric effects
	if (rendParams.atmos)
		rendParams.atmos->Update(t, FOREVER);

	// Update the environment map
	if (rendParams.envMap)
		rendParams.envMap->Update(t, FOREVER);


	// Update the Materials.
	// Only top-level materials need to be updated.
	// Also we get the mesh for all nodes and count the number
	// of faces (to give status information to the user)
	nNumFaces = 0;
	for (i = 0; i < instTab.Count(); i++) {
		instTab[i]->mtl->Update(t, FOREVER);
		instTab[i]->Update(t, theView, this);
	}

	// Update the Lights for every frame
	// The light descriptor updates its internal transformation here so
	// if you transform the light nodes into camera space in your renderer
	// you need to call Update() on the light while it is still in 
	// world space.
	// In this renderer we don't transform lights into camera space so
	// this is not a problem here
	for (i = 0; i < lightTab.Count(); i++) {
		lightTab[i]->Update(t, this);
		lightTab[i]->UpdateViewDepParams(rendParams.worldToCam);
	}

	// Transform geometry from object space to Camera (view) space	
	for (i = 0; i < instTab.Count(); i++) {
		instTab[i]->UpdateViewTM(view.affineTM);
		instTab[i]->mesh->buildRenderNormals();
		instTab[i]->TransformGeometry(instTab[i]->objToCam, instTab[i]->normalObjToCam);
	}


	if (!BuildMapFiles(t))	{
		//return 0;
	}

	// Display something informative in the progress bar
	if (prog) {
		prog->SetTitle("Rendering...");
		prog->SetSceneStats(lightTab.Count(), 0, 0, instTab.Count(), nNumFaces);
	}

	// And now the moment we've all been waiting for (drumroll please)....

	nExitStatus = RenderImage(rendParams, t, tobm, prog);


	// Transform geometry back from camera space	
	for (i = 0; i < instTab.Count(); i++) {
		instTab[i]->TransformGeometry(instTab[i]->camToObj, instTab[i]->normalCamToObj);
	}


	// Update the Virtual Frame Buffer.
	Rect r;
	r.top = 0;
	r.bottom = tobm->Height();
	r.left = 0;
	r.right = tobm->Width();
	tobm->RefreshWindow(&r);

	// Write RendInfo to output bitmap
	RenderInfo* ri = tobm->AllocRenderInfo();
	if (ri) {
		ri->projType = rendParams.projType?ProjParallel:ProjPerspective;
		ri->kx = rendParams.xscale;
		ri->ky = rendParams.yscale;
		ri->xc = (float)rendParams.xc;
		ri->yc = (float)rendParams.xc;
		ri->fieldRender = FALSE;	// We don't support field rendering...
		ri->fieldOdd = FALSE;		// We don't support field rendering...
		ri->renderTime[0] = rendParams.time;
		ri->worldToCam[0] = rendParams.worldToCam;
		ri->camToWorld[0] = rendParams.camToWorld;
	}

	// Now it's not the first frame anymore
	bFirstFrame = FALSE;

	// Display something else in the progress bar
	if (prog) {
		prog->SetTitle("Done.");
	}

	return nExitStatus;
}

//***************************************************************************
// Get the parameters for the view
//***************************************************************************

void CJRenderer::GetViewParams(INode* vnode, ViewParams& vp, TimeValue t)
{
	Interval iv;
	const ObjectState& os = vnode->EvalWorldState(t);
	switch (os.obj->SuperClassID()) {
		case CAMERA_CLASS_ID: {
			// compute camera transform
			CameraState cs;
			CameraObject *cam = (CameraObject *)os.obj;
			iv.SetInfinite();

			// Grab the Camera transform from the node.
			Matrix3 camtm = vnode->GetObjTMAfterWSM(t,&iv);

			RemoveScaling(camtm);
			vp.affineTM = Inverse(camtm);
			cam->EvalCameraState(t,iv,&cs);
			if (cs.manualClip) {
				vp.hither = cs.hither;
				vp.yon = cs.yon;
			}
			else {
			    vp.hither	= 0.1f;
		    	vp.yon	  	= -BIGFLOAT;
			}
			vp.projType = PROJ_PERSPECTIVE;
			vp.fov = cs.fov;
			rendParams.nearRange = cs.nearRange;
			rendParams.farRange = cs.farRange;
			}
			break;
		case LIGHT_CLASS_ID: {

			iv.SetInfinite();
			Matrix3 ltm = vnode->GetObjTMAfterWSM(t,&iv);
			vp.affineTM = Inverse(ltm);
			
			LightState ls;
			LightObject *ltob = (LightObject *)os.obj;
			ltob->EvalLightState(t,iv,&ls);

			float aspect = ls.shape?1.0f:ls.aspect;
			switch(ls.type) {
				case SPOT_LGT:			
					vp.projType = PROJ_PERSPECTIVE;      
					vp.fov = DegToRad(ls.fallsize);  
					vp.fov = 2.0f* (float)atan(tan(vp.fov*0.5f)*sqrt(aspect));
					rendParams.devAspect = (float(rendParams.devHeight)/float(rendParams.devWidth))*aspect;
					break;
				case DIRECT_LGT:
					vp.projType = PROJ_PARALLEL; 
					rendParams.devAspect = (float(rendParams.devHeight)/float(rendParams.devWidth))*aspect;
					break;
			}
		    vp.hither	= 0.1f;
	    	vp.yon	  	= -BIGFLOAT;  // so  it doesn't get used

			rendParams.nearRange = 0.0f;
			rendParams.farRange = 500.0f;
			}
			break;
		default:
			rendParams.nearRange = 0.0f;
			rendParams.farRange = 500.0f;
			break;
	}	
}

//***************************************************************************
// This method enumerates the external maps needed by the objects
// and materials.
// If a map is missing its name is appended to a nameTab and we
// report the problem.
// If a map is found it is appended to a map list and
// when done, we manually load each map into the system.
// See the rendutil module for the enumerators.
//***************************************************************************

#define ENUMMISSING FILE_ENUM_MISSING_ONLY|FILE_ENUM_1STSUB_MISSING

int CJRenderer::LoadMapFiles(TimeValue t, HWND hWnd, BOOL firstFrame)
{
	NameTab mapFiles;
	CheckFileNames checkNames(&mapFiles);

	int i;

	// Check the nodes
	for (i = 0; i < instTab.Count(); i++) {
		instTab[i]->GetINode()->EnumAuxFiles(checkNames, ENUMMISSING);
	}

	// Check the lights
	for (i = 0; i < lightTab.Count(); i++) {
		if (lightTab[i]->pLight != NULL) {
			lightTab[i]->pLight->EnumAuxFiles(checkNames, ENUMMISSING);
		}
	}

	// Check atmospherics and environment.
	if (rendParams.envMap) rendParams.envMap->EnumAuxFiles(checkNames, ENUMMISSING );
	if (rendParams.atmos) rendParams.atmos->EnumAuxFiles(checkNames, ENUMMISSING);

	// If we have any missing maps we report it to the user.
	// We should only report these errors on the first frame.
	// Also, if we are network rendering, we do not prompt the user,
	// instead we are writing the status to the log file.

	if (mapFiles.Count() && firstFrame) {
		// TBD: Use new log system
		// Updated to new logging system - GG: 01/29/99
		if (rendParams.bNetRender) {
			// Write out error report to file.
			Interface *ci = GetCOREInterface();
			for ( i=0; i<mapFiles.Count(); i++ )
				ci->Log()->LogEntry(SYSLOG_ERROR,NO_DIALOG,NULL,"Missing Map: %d",mapFiles[i]);
			return 0;
		}
		else {
			if (MessageBox(hWnd, "There are missing maps.\nDo you want to render anyway?", "Warning!", MB_YESNO) != IDYES) {
				return 0;
			}
		}

	}

	// Load the maps
	MapLoadEnum mapload(t);
	for (i=0; i<mtls.Count(); i++) {
		EnumMaps(mtls[i],-1, mapload);
	}

	return 1;
}

//***************************************************************************
// This method enumerates the external maps needed by the objects
// and materials.
// If a map is missing its name is appended to a nameTab and we
// report the problem.
// If a map is found it is appended to a map list and
// when done, we manually load each map into the system.
// See the rendutil module for the enumerators.
//***************************************************************************

int CJRenderer::BuildMapFiles(TimeValue t)
{
	Instance* inst;

	for (inst = ilist; inst!=NULL; inst = inst->next) {
		// Load the maps
		MapSetupEnum mapsetup(t, this, inst);
		EnumMtlTree(inst->mtl, -1, mapsetup);
	}

	return 1;
}



//***************************************************************************
// Cloning the renderer
// This method is required for 3D Studio MAX 2.0
//***************************************************************************

RefTargetHandle CJRenderer::Clone(RemapDir &remap)
{
	CJRenderer* newRend = new CJRenderer();

	// Clone the local options
	newRend->rendParams.nMaxDepth = rendParams.nMaxDepth;
	newRend->rendParams.nAntiAliasLevel = rendParams.nAntiAliasLevel;

	return newRend;
}

void CJRenderer::AddInstance(INode* node)
{
	nCurNodeID++;
	Instance* pInst = new Instance(node, &mtls, nCurNodeID);

	pInst->next = ilist;
	ilist = pInst;
	// TBD - initialize stuff here

	instTab.Append(1, &pInst, 25);
}

//***************************************************************************
// A node enumerator.
// These classes enumerates the nodes in the scene for access at render time.
// When enumerated, we create an object of class RenderNode for each node.
// This RenderNode contains the node, assigned materials etc.
// We store a list of the RenderNodes in a list CJRenderer::rNodeTab
// We also have another list CJRenderer::lightTab where we store all
// the lights in the scene.
//***************************************************************************

void CJRenderer::NodeEnum(INode* node)
{
	// For each child of this node, we recurse into ourselves 
	// until no more children are found.
	for (int c = 0; c < node->NumberOfChildren(); c++) {
		NodeEnum(node->GetChildNode(c));
	}

	// Is the node hidden?
	BOOL nodeHidden = node->IsNodeHidden(TRUE);
	
	// Get the ObjectState.
	// The ObjectState is the structure that flows up the pipeline.
	// It contains a matrix, a material index, some flags for channels,
	// and a pointer to the object in the pipeline.
	ObjectState ostate = node->EvalWorldState(0);
	if (ostate.obj==NULL) 
		return;

	// Examine the superclass ID in order to figure out what kind
	// of object we are dealing with.
	switch (ostate.obj->SuperClassID()) {

		// It's a light.
		case LIGHT_CLASS_ID: { 

			// Get the light object from the ObjectState
			LightObject *light = (LightObject*)ostate.obj;

			// Is this light turned on?
			if (light->GetUseLight()) {
				switch (light->GetShadowMethod()) {
					case LIGHTSHADOW_MAPPED:
						// Mapped shadows
						break;
					case LIGHTSHADOW_RAYTRACED:
						// Ratraced shadows
						break;
					}
				}
				RenderLight* rl = new RenderLight(node, &mtls);
				// Create a RenderLight and append it to our list of lights
				lightTab.Append(1, &rl);
			}
			break;
		case SHAPE_CLASS_ID:	// To support renderable shapes
		case GEOMOBJECT_CLASS_ID: {
			// This is an object in the scene

			// If we are not rendering hidden objects, return now
			if (nodeHidden && !rendParams.bRenderHidden)
				return;

			// If this object cannot render, skip it
			if (!ostate.obj->IsRenderable()) 
				return;
			if (!node->Renderable()) 
				return;

			// Handle motion blur etc...
			
			// Add the node to our list
			AddInstance(node);
			break;
		}
	}
}

//***************************************************************************
// Loading and Saving render parameters
// Chunk ID's for loading and saving render data
//***************************************************************************

#define RAYDEPTH_CHUNK		0x120
#define ANTIALIAS_CHUNK		0x130

//***************************************************************************
//	Save the render options in the scene
//***************************************************************************

IOResult CJRenderer::Save(ISave *isave)
{
	ULONG nb;

	isave->BeginChunk(RAYDEPTH_CHUNK);
	isave->Write(&rendParams.nMaxDepth,sizeof(int),&nb);
	isave->EndChunk();

	isave->BeginChunk(ANTIALIAS_CHUNK);
	isave->Write(&rendParams.nAntiAliasLevel,sizeof(int),&nb);
	isave->EndChunk();

	return IO_OK; 
}


//***************************************************************************
//	Load the render options from the scene
//***************************************************************************

IOResult CJRenderer::Load(ILoad *iload)
{
	ULONG nb;
	int id;
	IOResult res;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(id = iload->CurChunkID())  {
			case RAYDEPTH_CHUNK:
				res = iload->Read(&rendParams.nMaxDepth,sizeof(int), &nb);
				break;
			case ANTIALIAS_CHUNK:
				res = iload->Read(&rendParams.nAntiAliasLevel,sizeof(int), &nb);
				break;
		}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
	}
	return IO_OK;
}

//===========================================================================
//
// Class CJRenderParams
//
//===========================================================================

//***************************************************************************
// Initialize our custom options.
//***************************************************************************

CJRenderParams::CJRenderParams()
{
	SetDefaults();

	envMap = NULL;
	atmos = NULL;
	rendType = RENDTYPE_NORMAL;
	nMinx = 0;
	nMiny = 0;
	nMaxx = 0;
	nMaxy = 0;
	nNumDefLights = 0;
	nRegxmin = 0;
	nRegxmax = 0;
	nRegymin = 0;
	nRegymax = 0;
	scrDUV = Point2(0.0f, 0.0f);
	pDefaultLights = NULL;
	pFrp = NULL;
	bVideoColorCheck = 0;
	bForce2Sided = FALSE;
	bRenderHidden = FALSE;
	bSuperBlack = FALSE;
	bRenderFields = FALSE;
	bNetRender = FALSE;

	renderer = NULL;
	projType = PROJ_PERSPECTIVE;
	devWidth = 0;
	devHeight = 0;
	xscale = 0;
	yscale = 0;
	xc = 0;
	yc = 0;
	antialias = FALSE;
	nearRange = 0;
	farRange = 0;
	devAspect = 0;
	frameDur = 0;
	time = 0;
	wireMode = FALSE;
	inMtlEdit = FALSE;
	fieldRender = FALSE;
	first_field = FALSE;
	field_order = FALSE;
	objMotBlur = FALSE;
	nBlurFrames = 0;
}

void CJRenderParams::SetDefaults()
{
	nMaxDepth = 0;
	nAntiAliasLevel = AA_NONE;
	bReflectEnv = FALSE;
}

//***************************************************************************
// These values can be assumed to be correct.
// See the SDK help for class ViewParams for an explanation.
//***************************************************************************

#define VIEW_DEFAULT_WIDTH ((float)400.0)

void CJRenderParams::ComputeViewParams(const ViewParams&vp)
{
	worldToCam = vp.affineTM;
	camToWorld = Inverse(worldToCam);

	xc = devWidth / 2.0f;
	yc = devHeight / 2.0f;

	scrDUV.x = 1.0f/(float)devWidth;
	scrDUV.y = 1.0f/(float)devHeight;

	projType = vp.projType;

	if (projType == PROJ_PERSPECTIVE) {
		float fac =  -(float)(1.0 / tan(0.5*(double)vp.fov));
		xscale =  fac*xc;
		yscale = -devAspect*xscale;
	}
	else {
		xscale = (float)devWidth/(VIEW_DEFAULT_WIDTH*vp.zoom);
		yscale = -devAspect*xscale;
	}

	// TBD: Do Blowup calculation here.
}

//***************************************************************************
// Calculate the direction of a ray going through pixels sx, sy
//***************************************************************************

Point3 CJRenderParams::RayDirection(float sx, float sy)
{
	Point3 p;
	p.x = -(sx-xc)/xscale; 
	p.y = -(sy-yc)/yscale; 
	p.z = -1.0f;
	return Normalize(p);
}

//***************************************************************************
// Render Instances (from RenderGlobalContext)
//***************************************************************************

int CJRenderParams::NumRenderInstances()
{
	return ((CJRenderer*)renderer)->instTab.Count();
}

RenderInstance* CJRenderParams::GetRenderInstance(int i)
{
	if (i<NumRenderInstances()) {
		return ((CJRenderer*)renderer)->instTab[i];
	}

	return NULL;
}


//===========================================================================
//
// Class MyView
//
//===========================================================================

//***************************************************************************
// View to screen implementation for the view class
//***************************************************************************

Point2 MyView::ViewToScreen(Point3 p)
{
	return pRendParams->MapToScreen(p);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\cjrender\cjrmain.cpp ===
//***************************************************************************
// CJRender - [cjrmain.cpp] Sample Plugin Renderer for 3D Studio MAX.
// 
// By Christer Janson - Kinetix
//
// Description:
// Plugin initialization functions
//
//***************************************************************************

#include "maxincl.h"
#include "cjrender.h"
#include "resource.h"

HINSTANCE hInstance;
int controlsInit = FALSE;
extern ClassDesc* GetCJRenderDesc();

//***************************************************************************
// DllMain.
// Grab instance handle and initialize controls
//***************************************************************************

BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) {
	hInstance = hinstDLL;

	if (!controlsInit) {
		controlsInit = TRUE;
		InitCustomControls(hInstance);
		InitCommonControls();
	}
			
	return (TRUE);
}


//***************************************************************************
// This is the interface to MAX:
//***************************************************************************

__declspec( dllexport ) const TCHAR *
LibDescription() { return GetString (IDS_LIB_DESCRIPTION); }

/// MUST CHANGE THIS NUMBER WHEN ADD NEW CLASS
__declspec( dllexport ) int LibNumberClasses() {return 1;}


__declspec( dllexport ) ClassDesc*
LibClassDesc(int i) {
	switch(i) {
		case 0: return GetCJRenderDesc();
		default: return 0;
	}

}


//***************************************************************************
// Return version so can detect obsolete DLLs
//***************************************************************************

__declspec( dllexport ) ULONG 
LibVersion() { return VERSION_3DSMAX; }


//***************************************************************************
// Class descriptor
//***************************************************************************

class CJRenderClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) {return new CJRenderer;}
	const TCHAR *	ClassName() {return _T(RENDERNAME);}
	SClass_ID		SuperClassID() {return RENDERER_CLASS_ID;}
	Class_ID		ClassID() {return CCJREND_CLASS_ID;}
	const TCHAR* 	Category() {return _T("");}
};

static CJRenderClassDesc CJRenderDesc;
ClassDesc* GetCJRenderDesc() {return &CJRenderDesc;}


//***************************************************************************
// String resource utility function
//***************************************************************************

TCHAR *GetString(int id)
{
	static TCHAR buf[256];

	if (hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\cjrender\dummtl.cpp ===
//***************************************************************************
// CJRender - [dummtl.cpp] Sample Plugin Renderer for 3D Studio MAX.
// 
// By Christer Janson - Kinetix
//
// Description:
// Implementation of dummy material shader.
// This is the material that will be used if an INode does not have an
// assigned material.
//
//***************************************************************************

#include "maxincl.h"
#include "cjrender.h"

DumMtl::DumMtl(Color c)
{ 
	diff = c; spec = Color(DUMSPEC,DUMSPEC,DUMSPEC); 
	phongexp = (float)pow(2.0, DUMSHINE*10.0);
}

void DumMtl::Update(TimeValue t, Interval& valid)
{
}

void DumMtl::Reset()
{
}

Interval DumMtl::Validity(TimeValue t)
{
	return FOREVER;
}

ParamDlg* DumMtl::CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp)
{
	return NULL;
}

Color DumMtl::GetAmbient(int mtlNum, BOOL backFace)
{
	return diff;
}

Color DumMtl::GetDiffuse(int mtlNum, BOOL backFace)
{
	return diff;
}

Color DumMtl::GetSpecular(int mtlNum, BOOL backFace)
{
	return spec;
}

float DumMtl::GetShininess(int mtlNum, BOOL backFace)
{
	return 0.0f;
}

float DumMtl::GetShinStr(int mtlNum, BOOL backFace)
{
	return 0.0f;
}

float DumMtl::GetXParency(int mtlNum, BOOL backFace)
{
	return 0.0f;
}

void DumMtl::SetAmbient(Color c, TimeValue t)
{
}		

void DumMtl::SetDiffuse(Color c, TimeValue t)
{
}

void DumMtl::SetSpecular(Color c, TimeValue t)
{
}

void DumMtl::SetShininess(float v, TimeValue t)
{
}

Class_ID DumMtl::ClassID()
{
	return DUMMTL_CLASS_ID;
}

void DumMtl::DeleteThis()
{
	delete this;
}

RefResult DumMtl::NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
	    	PartID& partID,  RefMessage message)
{
	return REF_SUCCEED;
}

//***************************************************************************
// Shade method for the dummy material
// If a node does not have a material assigned we create
// a dummy material that inherits the wireframe color of
// the node
//***************************************************************************

void DumMtl::Shade(ShadeContext& sc)
{
	Color lightCol;
	Color diffwk(0.0f,0.0f,0.0f);
	Color specwk(0.0f,0.0f,0.0f);
	Color ambwk(0.0f,0.0f,0.0f);
	Point3 N = sc.Normal();
	Point3	R = sc.ReflectVector();
	LightDesc *l;
	for (int i = 0; i<sc.nLights; i++) {
		l = sc.Light(i);
		register float NL, diffCoef;
		Point3 L;
		if (!l->Illuminate(sc, N, lightCol, L, NL, diffCoef))
			continue;

		if (l->ambientOnly) {
			ambwk += lightCol;
			continue;
			}
		// diffuse
		if (l->affectDiffuse)
			diffwk += diffCoef*lightCol;
		// specular
		if (l->affectSpecular) {
			float c = DotProd(L,R);
			if (c>0.0f) {
				c = (float)pow((double)c, (double)phongexp); 
				specwk += c*lightCol*NL;   // multiply by NL to SOFTEN 
			}
		}
	}
	sc.out.t = Color(0.0f,0.0f,0.0f);
	sc.out.c = (.3f*sc.ambientLight + diffwk)*diff + specwk*spec + ambwk;		
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\cjrender\cjrender.h ===
//***************************************************************************
// CJRender - [cjrender.h] Sample Plugin Renderer for 3D Studio MAX.
// 
// By Christer Janson - Kinetix
//
// May     11, 1996	CCJ Initial coding
// October 28, 1996	CCJ Texture mapping, raycasting etc.
// December    1996	CCJ General cleanup
// May         1997 CCJ Substantial rewrite for Version 2.0
//
// Description:
// Main renderer header.
//
//***************************************************************************

#ifndef __CJRENDER_H__
#define __CJRENDER_H__

// IMPORTANT: If you use this sample, don't forget to change the ClassID!!!
#define CCJREND_CLASS_ID	Class_ID(0x396b66d9, 0x429e6793)
#define DUMMTL_CLASS_ID		Class_ID(0x10707f49, 0x40f5940)

// A Ripoff of the scanline A-buffer render name.
// B-buffer being "Bogus", "Bad" or "Butteriks" (but only a Swede living in
// Gothenburg could possibly understand the last one)

#define RENDERNAME "Sample B-Buffer Renderer"

// By popular demand I'm including an explanation of the
// Butteriks-buffer name here:
// '"Butteriks" is a famous old Gothenburgian 
//  establishment that sells costumes and
//  gadgets to practitioners of the art of
//  comedy and magic. The items are typically
//  characterized as being totally fake,
//  nonsensical, or inherently inferior to
//  the real world thing, while often appearing
//  to be real. As such, one should be wary 
//  of anything carrying the "Butteriks" label.'

// Antialias levels
#define  AA_NONE	0x00
#define  AA_MEDIUM	0x01
#define  AA_HIGH	0x02

#define BIGFLOAT (float(1.0e30))

// G-Buffer flags
// I'm using a BitArray to keep track of the G buffer channels requested.
#define GBUF_Z		 1	// BMM_CHAN_Z      
#define GBUF_MTLID   2	// BMM_CHAN_MTL_ID 
#define GBUF_NODEID  3	// BMM_CHAN_NODE_ID
#define GBUF_UV      4	// BMM_CHAN_UV     
#define GBUF_NORMAL  5	// BMM_CHAN_NORMAL 
#define GBUF_REALPIX 6	// BMM_CHAN_REALPIX
#define GBUF_COVER   7	// BMM_CHAN_COVERAGE	// New for MAX 2.0

class CJRenderer;
class Instance;
class RenderLight;
class SContext;

// Render parameters. Add whatever parameters you need here.
// These are typically parameters that needs to be accessed during the
// setup of the renderer and during the rendering.
class CJRenderParams : public RenderGlobalContext {
public:
	RendType	rendType;				// View, blowup, region etc.
	int			nMinx;
	int			nMiny;
	int			nMaxx;
	int			nMaxy;
	int			nNumDefLights;			// The default lights passed into the renderer
	int			nRegxmin;				// Coords for render blowup etc.
	int			nRegxmax;				// Coords for render blowup etc.
	int			nRegymin;				// Coords for render blowup etc.
	int			nRegymax;				// Coords for render blowup etc.
	Point2		scrDUV;
	BitArray	gbufChan;				// The G buffer channels (bitflags)
	DefaultLight*	pDefaultLights;
	FrameRendParams*	pFrp;			// Frame specific members

	// Custom options
	// These options are specific to the sample renderer
	int			nMaxDepth;
	int			nAntiAliasLevel;
	BOOL		bReflectEnv;

	// Standard options
	// These options are configurable for all plugin renderers
	BOOL		bVideoColorCheck;
	BOOL		bForce2Sided;
	BOOL		bRenderHidden;
	BOOL		bSuperBlack;
	BOOL		bRenderFields;
	BOOL		bNetRender;

	CJRenderParams();
	void		SetDefaults();
	void		ComputeViewParams(const ViewParams&vp);
	Point3		RayDirection(float sx, float sy);

	int				NumRenderInstances();
	RenderInstance*	GetRenderInstance(int i);
};

// For calculation of view to screen coords
class MyView : public View {
public:
	CJRenderParams*	pRendParams;
	Point2		ViewToScreen(Point3 p);
};

// Information about closest hit
struct HitInfo {
	Instance*	instance;
	int			faceNum;
	Point3		baryCoord;
	Point3		normalAtHitPoint;
	Point3		hitPos;
};

class CJRenderMapsContext : public RenderMapsContext {
public:
	CJRenderMapsContext(CJRenderer* r, Instance* i) { cjr = r; inst = i; }
	INode *GetNode();
	int NodeRenderID();
	void GetCurrentViewParams(ViewParams &vp);
	void GetSubRendParams(SubRendParams &srp);
	int SubMtlIndex();
	void SetSubMtlIndex(int mindex);
	void FindMtlPlane(float pl[4]);
	void FindMtlScreenBox(Rect &sbox, Matrix3* viewTM=NULL,int mtlIndex=-1);
	Box3 CameraSpaceBoundingBox();
	Box3 ObjectSpaceBoundingBox();
	Matrix3 ObjectToWorldTM();
	RenderGlobalContext *GetGlobalContext();

	// ClipPlanes is a pointer to an array of Point4's,  each of which
	// represents a clip plane.  nClip Planes is the number of planes (up to 6);
	// The planes are in View space.
	int Render(Bitmap *bm, ViewParams &vp, SubRendParams &srp, Point4 *clipPlanes=NULL, int nClipPlanes=0);

private:
	int subMtl;
	CJRenderer* cjr;
	Instance* inst;
};


// This is the renderer class definition.
class CJRenderer: public Renderer {
public:
	BOOL		bOpen;					// Indicate that Open() has been called
	int			nCurNodeID;				// Node counter
	int			nNumFaces;				// Face counter
	INode*		pScene;					// Root node of scene
	INode*		pViewNode;				// Camera node if available
	ViewParams	view;					// View parameters
	MyView		theView;				// View to screen calculation
	MtlBaseLib	mtls;					// List of all materials

	// These are flags we use so if something is wrong we will report
	// errors once only (and not every frame)
	BOOL		bFirstFrame;			// Indicate that this is the first frame
	BOOL		bUvMessageDone;			// indicate that we have already warned the 
										// user that object requires UV coords
	// G-Buffer channels
	float*		pGbufZ;
	UBYTE*		pGbufMtlID;
	UWORD*		pGbufNodeID;
	Point2*		pGbufUV;
	ULONG*		pGbufNormal;
	RealPixel*	pGbufRealPix;
	UBYTE*		pGbufCov;

	Instance*	ilist;
	Tab<Instance *>		instTab;		// Keep track of instances
	Tab<RenderLight *>	lightTab;		// Keep track of lights

	CJRenderParams	rendParams;			// Render parameters

	CJRenderer();
	void		AddInstance(INode* node);
	void		NodeEnum(INode* node);
	int			RenderImage(CJRenderParams& rp, TimeValue t, Bitmap* tobm, RendProgressCallback *prog);
	BOOL		CastRay(CJRenderParams& rp, Ray* ray, SContext* sc, int depth, Color& col);
	void		GetViewParams(INode* vnode, ViewParams& vp, TimeValue t);
	void		BeginThings();			// Called before rendering has started
	void		EndThings();			// Called after rendering has finished
	int			LoadMapFiles(TimeValue t, HWND hWnd, BOOL firstFrame);
	int			BuildMapFiles(TimeValue t);
	IOResult	Save(ISave *isave);
	IOResult	Load(ILoad *iload);
	RefTargetHandle	Clone(RemapDir &remap);

	int			Open(INode* scene, INode* vnode, ViewParams* viewPar, RendParams& rpar, HWND hwnd, DefaultLight* defaultLights=NULL, int numDefLights=0);
	int			Render(TimeValue t, Bitmap* tobm, FrameRendParams &frp, HWND hwnd, RendProgressCallback* prog, ViewParams* viewPar);
	void		Close(HWND hwnd);

	// Create the use interface dialog
	RendParamDlg*	CreateParamDialog(IRendParams *ir,BOOL prog);
	// Called by Max when Max is reset
	void		ResetParams();
	void		DeleteThis();
	Class_ID	ClassID();
	void		GetClassName(TSTR& s);
};

class BoundingSphere {
public:
	void	Set(Point3 center, float radsq) { bsCenter = center; bsRadSq = radsq; }

	Point3	bsCenter;
	float	bsRadSq;
};

typedef Tab<BoundingSphere*> BoundingSphereTab;

class Instance : public RenderInstance {
public:

	Instance(INode* node, MtlBaseLib* mtls, int nodeID);
	~Instance();

	// Methods inherited from RenderInstance
	RenderInstance*	Next();
	Interval	MeshValidity();
	int			NumLights();
	LightDesc*	Light(int n);
	int			NumShadLights();
	LightDesc*	ShadLight(int n);
	INode*		GetINode();
	Object*		GetEvalObject();
	unsigned long	MtlRequirements(int mtlNum);
	Point3		GetFaceNormal(int faceNum);
	Point3		GetFaceVertNormal(int faceNum, int vertNum);
	void		GetFaceVertNormals(int faceNum, Point3 n[3]);
	Point3		GetCamVert(int vertNum);
	void		GetObjVerts(int fnum, Point3 obp[3]);
	void		GetCamVerts(int fnum, Point3 cp[3]);

	// New for R3
	int			CastsShadowsFrom(const ObjLightDesc& lt);

	// Access methods
	TCHAR*		GetName();

	int			Update(TimeValue t, View& gview, CJRenderer* pRenderer);
	void		UpdateViewTM(Matrix3 affineTM);
	void		TransformGeometry(Matrix3 pointMat, Matrix3 vecMat);
	void		CalcBoundingSphere();
	void		FreeAll();

	Matrix3		normalCamToObj;
	INode*		pNode;
	Object*		pObject;
	Matrix3		objToWorld;
	Box3		camBox;
	Instance*	next;
	BoundingSphereTab	faceBoundSpheres;
};

// The RenderLight is the container for all lights in the scene.
class RenderLight {
public:
        // Constructor for normal lights
        RenderLight(INode* node, MtlBaseLib* mtls);
        // Alternative constructor for default lights
        RenderLight(DefaultLight* light);
        ~RenderLight();

        void Update(TimeValue t, CJRenderer* renderer);
        void UpdateViewDepParams(Matrix3 world2cam);

        INode* pNode;
        ObjLightDesc* pDesc;
        LightObject *pLight;
};


//***************************************************************************
//* Dummy Material : Simple Phong shader using Node color
//* This material is assigned to each node that does not have a material
//* previously assigned. The diffuse color is assigned based on the 
//* wireframe color.
//* This way we can assume that all nodes have a material assigned.
//***************************************************************************

#define DUMSHINE .20f	//.25f
#define DUMSPEC .20f	//.50f

class DumMtl: public Mtl {
	Color diff, spec;
	float phongexp;
	public:
		DumMtl(Color c);
		void Update(TimeValue t, Interval& valid);
		void Reset();
		Interval Validity(TimeValue t);
		ParamDlg* CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp);
		Color GetAmbient(int mtlNum=0, BOOL backFace=FALSE);
		Color GetDiffuse(int mtlNum=0, BOOL backFace=FALSE);
		Color GetSpecular(int mtlNum=0, BOOL backFace=FALSE);
		float GetShininess(int mtlNum=0, BOOL backFace=FALSE);
		float GetShinStr(int mtlNum=0, BOOL backFace=FALSE);
		float GetXParency(int mtlNum=0, BOOL backFace=FALSE);
		void SetAmbient(Color c, TimeValue t);
		void SetDiffuse(Color c, TimeValue t);
		void SetSpecular(Color c, TimeValue t);
		void SetShininess(float v, TimeValue t);
		Class_ID ClassID();
		void DeleteThis();
    	RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
	    	PartID& partID,  RefMessage message);
		void Shade(ShadeContext& sc);
};


//***************************************************************************
//* RendContext is used to evaluate the lights
//***************************************************************************

 class RContext: public RendContext {
	public:
		RContext(CJRenderer *cjr) { renderer = cjr; }
		Matrix3 WorldToCam() const { return renderer->rendParams.worldToCam; }
		Color GlobalLightLevel() const;
		int Progress(int done, int total) {
			return 1;
		}
		CJRenderer *renderer;
};


//***************************************************************************
//* The is the Light descriptor object for default lights
//***************************************************************************
class DefObjLight : public ObjLightDesc 
{
	public:
		Color	intensCol;   // intens*color 
		Point3	lightDir;
		bool	bViewOriented;

		DefObjLight(DefaultLight *l);
		void	DeleteThis() {delete this;}
		int		Update(TimeValue t, const RendContext& rc, RenderGlobalContext* rgc, BOOL shadows, BOOL shadowGeomChanged);
		int		UpdateViewDepParams(const Matrix3& worldToCam);
		BOOL	Illuminate(ShadeContext& sc, Point3& normal, Color& color, Point3 &dir, float &dot_nl, float& diffuseCoef);
};

#endif // __CJRENDER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\cjrender\cjrui.cpp ===
//***************************************************************************
// CJRender - [cjrui.cpp] Sample Plugin Renderer for 3D Studio MAX.
// 
// By Christer Janson - Kinetix
//
// Description:
// Implementation of the user interface dialogs
//
//***************************************************************************

#include "maxincl.h"
#include "resource.h"
#include "cjrender.h"

extern HINSTANCE hInstance;
static BOOL CALLBACK CJRendParamsDlgProc(HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);

//***************************************************************************
// Class definition of the render parameters dialog class
//***************************************************************************

class CJRendParamDlg : public RendParamDlg {
	public:
		CJRenderer *rend;
		IRendParams *ir;
		HWND hPanel;
		BOOL prog;
		HFONT hFont;
		ISpinnerControl* depthSpinner;

		CJRendParamDlg(CJRenderer *r,IRendParams *i,BOOL prog);
		~CJRendParamDlg();
		void AcceptParams();
		void RejectParams();
		void DeleteThis() {delete this;}
		void InitParamDialog(HWND hWnd);
		void InitProgDialog(HWND hWnd);
};


//***************************************************************************
// Constructor
//***************************************************************************

CJRendParamDlg::CJRendParamDlg(
		CJRenderer *r,IRendParams *i,BOOL prog)
{
	hFont      = hFont = CreateFont(14,0,0,0,FW_BOLD,0,0,0,0,0,0,0, VARIABLE_PITCH | FF_SWISS, _T(""));
	rend       = r;
	ir         = i;
	this->prog = prog;

	// Create the rollup pages.
	// If we are doing the progress dialog..
	if (prog) {		
		hPanel = ir->AddRollupPage(
			hInstance, 
			MAKEINTRESOURCE(IDD_CCJRENDERDLG_PROG),
			CJRendParamsDlgProc,
			"Sample B-Buffer Renderer",
			(LPARAM)this);
	} else {
		// ...or the user config dialog
		hPanel = ir->AddRollupPage(
			hInstance, 
			MAKEINTRESOURCE(IDD_CCJRENDERDLG),
			CJRendParamsDlgProc,
			"Sample B-Buffer Renderer",
			(LPARAM)this);
	}
}


//***************************************************************************
// Destructor
//***************************************************************************

CJRendParamDlg::~CJRendParamDlg()
{
	// Delete the font
	DeleteObject(hFont);
	// And the rollup page
	ir->DeleteRollupPage(hPanel);
}


//***************************************************************************
// Initialize the progress dialog
//***************************************************************************
void CJRendParamDlg::InitProgDialog(HWND hWnd)
{
	// Set the bold font to the options in the progress dialog.
	SendDlgItemMessage(hWnd,IDC_PROG_DEPTH,WM_SETFONT,(WPARAM)hFont,TRUE);
	SendDlgItemMessage(hWnd,IDC_PROG_ANTIALIAS,WM_SETFONT,(WPARAM)hFont,TRUE);
	SendDlgItemMessage(hWnd,IDC_PROG_REFLENV,WM_SETFONT,(WPARAM)hFont,TRUE);

	TSTR tbuf;
	tbuf.printf("%d", rend->rendParams.nMaxDepth);
	SetWindowText(GetDlgItem(hWnd,IDC_PROG_DEPTH), tbuf);

	tbuf.printf("%d", rend->rendParams.nAntiAliasLevel);
	SetWindowText(GetDlgItem(hWnd,IDC_PROG_ANTIALIAS), tbuf);

	tbuf.printf("%s", rend->rendParams.bReflectEnv ? GetString(IDS_YES) : GetString(IDS_NO));
	SetWindowText(GetDlgItem(hWnd,IDC_PROG_REFLENV), tbuf);
}


//***************************************************************************
// Initialize the render dialog
//***************************************************************************

void CJRendParamDlg::InitParamDialog(HWND hWnd)
{
	CheckRadioButton(hWnd, IDC_AA_NONE, IDC_AA_HIGH,
		rend->rendParams.nAntiAliasLevel == AA_NONE ? IDC_AA_NONE :
		rend->rendParams.nAntiAliasLevel == AA_MEDIUM ? IDC_AA_MEDIUM :
		IDC_AA_HIGH);

	CheckDlgButton(hWnd, IDC_REFLENV, rend->rendParams.bReflectEnv);

	// Setup the spinner controls for raytrace depth
	depthSpinner = GetISpinner(GetDlgItem(hWnd, IDC_DEPTH_SPIN)); 
	depthSpinner->LinkToEdit(GetDlgItem(hWnd,IDC_DEPTH), EDITTYPE_INT ); 
	depthSpinner->SetLimits(0, 25, TRUE); 
	depthSpinner->SetValue(rend->rendParams.nMaxDepth ,FALSE);
}

//***************************************************************************
// Accept parameters.
// This is called if the user clicks "Ok" or "Close"
//***************************************************************************

void CJRendParamDlg::AcceptParams()
{
	rend->rendParams.nMaxDepth = depthSpinner->GetIVal();

	rend->rendParams.nAntiAliasLevel = IsDlgButtonChecked(hPanel, IDC_AA_NONE) ? AA_NONE :
		IsDlgButtonChecked(hPanel, IDC_AA_MEDIUM) ? AA_MEDIUM : 
		IsDlgButtonChecked(hPanel, IDC_AA_HIGH) ? AA_MEDIUM : 0;
	rend->rendParams.bReflectEnv = IsDlgButtonChecked(hPanel, IDC_REFLENV);
}


//***************************************************************************
// Called if the user cancels the render param dialog.
// Reset any options you have changed here.
// Since we don't update the parameters until AcceptParams() is called,
// we don't need to do anything here.
//***************************************************************************

void CJRendParamDlg::RejectParams()
{
}


//***************************************************************************
// Dialog procedure for the rollup pages.
//***************************************************************************

static BOOL CALLBACK CJRendParamsDlgProc(
		HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	CJRendParamDlg *dlg = (CJRendParamDlg*)GetWindowLong(hWnd,GWL_USERDATA);
	switch (msg) {
		case WM_INITDIALOG:
			dlg = (CJRendParamDlg*)lParam;
			SetWindowLong(hWnd,GWL_USERDATA,lParam);
			if (dlg) {
				if (dlg->prog)
					dlg->InitProgDialog(hWnd);
				else
					dlg->InitParamDialog(hWnd);
			}
			break;
		case WM_DESTROY:
			if (!dlg->prog) {
				ReleaseISpinner(dlg->depthSpinner);
			}
			break;		
		case WM_COMMAND:
			// We don't care about the UI controls.
			// We take the value in AcceptParams() instead.
			break;

		case WM_LBUTTONDOWN:
		case WM_MOUSEMOVE:
		case WM_LBUTTONUP:
			dlg->ir->RollupMouseMessage(hWnd,msg,wParam,lParam);
			break;
		default:
			return FALSE;
		}	
	return TRUE;
}


//***************************************************************************
// Create the user interface object
//***************************************************************************

RendParamDlg *CJRenderer::CreateParamDialog(IRendParams *ir,BOOL prog)
{
	return new CJRendParamDlg(this, ir, prog);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\cjrender\maxincl.h ===
//***************************************************************************
// CJRender - [maxincl.h] Sample Plugin Renderer for 3D Studio MAX.
// 
// By Christer Janson - Kinetix
//
// May     11, 1996	CCJ Initial coding
// October 28, 1996	CCJ Texture mapping, raycasting etc.
// December    1996	CCJ General cleanup
//
// Description:
// Here we include the Max SDK headers for use with precompiled headers
//
//***************************************************************************

#include "Max.h"
#include "bmmlib.h"
#include "meshadj.h"
#include "modstack.h"
#include "stdmat.h"
#include "templt.h"
#include "render.h"
#include <float.h>		// Include these guys, otherwise sqrt() doesn't work!
#include <math.h>


// Prototype for a utility function used for string table resources
TCHAR *GetString(int id);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\cjrender\rendutil.h ===
//***************************************************************************
// CJRender - [rendutil.h] Sample Plugin Renderer for 3D Studio MAX.
// 
// By Christer Janson - Kinetix
//
// May     11, 1996	CCJ Initial coding
// October 28, 1996	CCJ Texture mapping, raycasting etc.
// December    1996	CCJ General cleanup
//
// Description:
// This is the header for some utility functions needed throughout the code
//
//***************************************************************************

int				isFacing(Point3& p0, Point3& p1, Point3& p2, int projType);
void			RemoveScaling(Matrix3 &m);
Point3			CalcBaryCoords(Point3 p0, Point3 p1, Point3 p2, Point3 p);
void			MakeFaceUV(Face *f, Point3 *tv);
BMM_Color_64	colTo64(Color c);
BOOL			TMNegParity(Matrix3 &m);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\cjrender\raytrace.cpp ===
//***************************************************************************
// CJRender - [raytrace.cpp] Sample Plugin Renderer for 3D Studio MAX.
// 
// By Christer Janson - Kinetix
//
// Description:
// Implementation of the raytrace core
//
//***************************************************************************

#include "maxincl.h"
#include "cjrender.h"
#include "scontext.h"
#include "rendutil.h"

typedef float Plane[4];	// A plane definition.

BOOL intersectMesh(Ray* ray, HitInfo& hitInfo);
BOOL intersectTri(Ray* ray, Point3* tri, Point3& baryCoord, Point3& normal, Point3& hitPos);
void CompPlaneEqn(Plane plane, const Point3& p0, const Point3& p1, const Point3& p2);
BOOL rayBoundHit(Ray* ray, Box3 boundingBox);

int CJRenderer::RenderImage(CJRenderParams& rp, TimeValue t, Bitmap* tobm, RendProgressCallback *prog)
{
	Point3 camPos = Point3(0,0,0);
	Point3 targPos = Point3(0,0,-1);

	BGContext bc(&rp);
	SContext sc(this, &bc);

	for (int y = rp.nMiny; y < rp.nMaxy; y++) {
		for (int x = rp.nMinx; x < rp.nMaxx; x++) {

			// Clear the G-Buffer entries
			if (rp.gbufChan[GBUF_Z]) {
				pGbufZ[y*rp.devWidth + x] = BIGFLOAT;
			}
			if (rp.gbufChan[GBUF_MTLID]) {
				pGbufMtlID[y*rp.devWidth + x] = 0;
			}
			if (rp.gbufChan[GBUF_NODEID]) {
				pGbufNodeID[y*rp.devWidth + x] = 0;
			}
			if (rp.gbufChan[GBUF_UV]) {
				pGbufUV[y*rp.devWidth + x] = Point2(0.0f, 0.0f);
			}
			if (rp.gbufChan[GBUF_NORMAL]) {
				pGbufNormal[y*rp.devWidth + x] = 0;
			}
			if (rp.gbufChan[GBUF_REALPIX]) {
				RealPixel rpix;
				rpix.r = rpix.g = rpix.b = rpix.e = 0;
				pGbufRealPix[y*rp.devWidth + x] = rpix;
			}
			if (rp.gbufChan[GBUF_COVER]) {
				pGbufNormal[y*rp.devWidth + x] = 0;
			}

			// Cast multiple rays for a pseudo anti-aliasing.
			// Cast one ray through the center of the pixel,
			// and one ray in each corner of the pixel.
			// Since the corner rays are shared between pixels, we effectively
			// only casts a little more than one ray per pixel extra.
			// Physically this won't give us a hight sample rate than casting two
			// rays only, but it softens the image a little.
			Color colMix;
			Color colCenter;

			Color colUpperLeft;
			Color colUpperRight;
			Color colLowerLeft;
			Color colLowerRight;
			float numCols;

			Ray ray;
			ray.p = camPos;
			sc.SetScreenPos(IPoint2(x, y));
			sc.SetCamPos(ray.p);
			bc.SetCamPos(ray.p);
			bc.SetScreenPos(x, y, rp.devWidth, rp.devHeight);

			// Center of pixel
			ray.dir = rp.RayDirection((float)x+0.5f, (float)y+0.5f);
			sc.SetViewDir(ray.dir);
			bc.SetViewDir(ray.dir);
			CastRay(rp, &ray, &sc, 0, colCenter);
			colMix = colCenter;

			numCols = 1.0f;

			if (rp.nAntiAliasLevel > 0) {

				// Lower right - always render this
				ray.dir = rp.RayDirection((float)x+0.75f, (float)y+0.75f);
				sc.SetViewDir(ray.dir);
				bc.SetViewDir(ray.dir);
				CastRay(rp, &ray, &sc, 0, colLowerRight);

				// Upper right
				ray.dir = rp.RayDirection((float)x+0.75f, (float)y+0.25f);
				sc.SetViewDir(ray.dir);
				bc.SetViewDir(ray.dir);
				CastRay(rp, &ray, &sc, 0, colUpperRight);

				// Lower left
				ray.dir = rp.RayDirection((float)x+0.25f, (float)y+0.75f);
				sc.SetViewDir(ray.dir);
				bc.SetViewDir(ray.dir);
				CastRay(rp, &ray, &sc, 0, colLowerLeft);


				// Upper left
				ray.dir = rp.RayDirection((float)x+0.25f, (float)y+0.25f);
				sc.SetViewDir(ray.dir);
				bc.SetViewDir(ray.dir);
				CastRay(rp, &ray, &sc, 0, colUpperLeft);

				colMix = colCenter + colLowerRight + colLowerLeft + colUpperLeft + colUpperRight;
				numCols = 5.0f;
			}

			if (rp.nAntiAliasLevel > 1) {

				// Lower right
				ray.dir = rp.RayDirection((float)x+1.0f, (float)y+1.0f);
				sc.SetViewDir(ray.dir);
				bc.SetViewDir(ray.dir);
				CastRay(rp, &ray, &sc, 0, colLowerRight);

				// Upper right
				ray.dir = rp.RayDirection((float)x+1.0f, (float)y);
				sc.SetViewDir(ray.dir);
				bc.SetViewDir(ray.dir);
				CastRay(rp, &ray, &sc, 0, colUpperRight);

				// Lower left
				ray.dir = rp.RayDirection((float)x, (float)y+1.0f);
				sc.SetViewDir(ray.dir);
				bc.SetViewDir(ray.dir);
				CastRay(rp, &ray, &sc, 0, colLowerLeft);


				// Upper left
				ray.dir = rp.RayDirection((float)x, (float)y);
				sc.SetViewDir(ray.dir);
				bc.SetViewDir(ray.dir);
				CastRay(rp, &ray, &sc, 0, colUpperLeft);

				colMix = colCenter + colLowerRight + colLowerLeft + colUpperLeft + colUpperRight;
				numCols = 9.0f;
			}

			colMix = colMix / numCols;

			BMM_Color_64 col64; // What we output to the bitmap in the end

			col64 = colTo64(colMix);	// Clamp and convert to col64

			tobm->PutPixels(x, y, 1, &col64);
		}

		// Update the output every 10 scanlines or so
		// Updating the display is slow, so keep the update rate down to a reasonable level.
		if (y%10 == 0 || y == rp.devHeight-1) {
			Rect r;
			r.top = y-10;
			r.bottom = y;
			r.left = 0;
			r.right = tobm->Width();

			tobm->ShowProgressLine(y-1);

			tobm->RefreshWindow(&r);
		}

		// Update progress bar and check for cancel
		if (prog && (prog->Progress(y, rp.devHeight-1) == RENDPROG_ABORT)) {
			tobm->ShowProgressLine(-1);	// Clear progress line
			return 0;
			break;
		}

	}

	tobm->ShowProgressLine(-1);	// Clear progress line

	return 1;
}

#define LSQ(v) (v.x*v.x + v.y*v.y + v.z*v.z)

BOOL CJRenderer::CastRay(CJRenderParams& rp, Ray* ray, SContext* sc, int depth, Color& col)
{
	HitInfo	hitInfo;
	BOOL	foundHit = FALSE;
	float	dist = BIGFLOAT;
	int		nNumNodes = instTab.Count();

	for (int n = 0; n < nNumNodes; n++) {
		HitInfo testHitInfo;

		if (!instTab[n]->mesh) {
			continue;
		}

		// Reject object based on bounding sphere.
		Point3 pc = instTab[n]->center - ray->p;
		float v = DotProd(pc,ray->dir);
		if (instTab[n]->radsq - LSQ(pc) + v*v < 0.0f) {
			continue;
		}

		// Reject objects based on bounding box
		if (!rayBoundHit(ray, instTab[n]->camBox)) {
			continue;
		}

		testHitInfo.instance = instTab[n];

		// Check intersection with ray and object
		if (intersectMesh(ray, testHitInfo)) {

			// Only use this hit if it is closer than the previously recorded hit
			float dl = Length(testHitInfo.hitPos);

			if (dl < dist) {
				hitInfo = testHitInfo;
				dist = dl;
				foundHit = TRUE;
			}
		}
	}

	if (!foundHit) {
		// Render background...
		Color bg;

		if (rp.envMap) {
			AColor abg = rp.envMap->EvalColor(*sc->bc);
			bg.r = abg.r;
			bg.g = abg.g;
			bg.b = abg.b;
		}
		else {
			if (rp.pFrp) {
				bg = rp.pFrp->background;
			}
			else {
				bg = Color(0.0f, 0.0f, 0.0f);
			}
		}

		if (rp.atmos) {
			Color xp;
			rp.atmos->Shade(*sc->bc, ray->p, ray->p * TransMatrix(-FARZ * ray->dir), bg, xp, TRUE);
		}

		col = bg;
		return FALSE;
	}


	// Shade point

	Face* f = &(hitInfo.instance->mesh->faces[hitInfo.faceNum]);
	MtlID mid = 0;
	int nNumSubs = hitInfo.instance->mtl->NumSubMtls();

	if (nNumSubs) {
		// Get sub material ID of the face.
		mid = f->getMatID();
		// the material ID of the face can be larger than the
		// total number of sub materials (because it is user
		// configurable).
		// Here I use a modulus function to bring the number
		// down to a legal value.
		mid = mid % nNumSubs;
	}

	// Shade the face that was closest to the camera
	sc->SetInstance(hitInfo.instance);
	sc->SetMtlNum(mid);
	sc->SetFaceNum(hitInfo.faceNum);
	sc->SetHitPos(hitInfo.hitPos);
	sc->SetBary(hitInfo.baryCoord);
	sc->CalcNormals();

	// Go off and do the actual shading.
	hitInfo.instance->mtl->Shade(*sc);

	// Save these for rendering atmospherics
	Point3 shadeCamPos = ray->p;
	Point3 shadeHitPos = sc->P();

	Ray reflectRay;
	Ray refractRay;

	Color thisColor = sc->out.c;
	Color colReflect(1.0f, 1.0f, 1.0f);
	Color colRefract(1.0f, 1.0f, 1.0f);

	/*
	// Total hack!
	float partRefract = hitInfo.instance->mtl->GetXParency();
	//float partRefract = Length(sc->out.t)/1.73f; // Bring down to range 0 - 1.
	float partReflect = (1.0f - partRefract) * hitInfo.instance->mtl->GetShininess();
	float partCol = 1.0f - (partReflect+partRefract);
	*/

	float partReflect = hitInfo.instance->mtl->GetShininess();
	float partCol = 1.0f - partReflect;

	if ((depth < rp.nMaxDepth) && (partReflect > 0.0f)) { // || partRefract > 0.0f)) {
		// Calculate reflection
		reflectRay.p = hitInfo.hitPos;
		reflectRay.dir = sc->ReflectVector();
		sc->SetCamPos(hitInfo.hitPos);
		sc->bc->SetCamPos(hitInfo.hitPos);
		sc->SetViewDir(reflectRay.dir);
		sc->bc->SetViewDir(reflectRay.dir);
		BOOL reflHit = CastRay(rp, &reflectRay, sc, depth+1, colReflect);
		if (!reflHit && !rp.bReflectEnv) {
			partCol = 1.0f;
			partReflect = 0.0f;
		}

		/*
		// Don't look!
		if (MaxVal(sc->out.t) > 0.0f) {
			// calculate refraction
			refractRay.p = hitInfo.hitPos;
			refractRay.dir = sc->RefractVector(sc->out.ior);
			sc->SetCamPos(hitInfo.hitPos);
			sc->bc->SetCamPos(hitInfo.hitPos);
			sc->SetViewDir(refractRay.dir);
			sc->bc->SetViewDir(refractRay.dir);
			CastRay(rp, &refractRay, sc, depth+1, colRefract);
		}
		*/
	}
	else {
		partCol = 1.0f;
		partReflect = 0.0f;
	}

	Color colorMix;

	// mix colors

	colorMix = partCol * thisColor + partReflect * colReflect; // + partRefract * colRefract;

	if (rp.atmos) {
		rp.atmos->Shade(*sc->bc, shadeCamPos, shadeHitPos, colorMix, colRefract, FALSE);
	}

	col = colorMix;
	return TRUE;
}

//***************************************************************************
// Intersect a ray with a mesh
//***************************************************************************

// BOOL intersectMesh(Ray* ray, RenderNode* rn, int& faceNo, Point3& baryCoord, Point3& normal, Point3& hitPos)
BOOL intersectMesh(Ray* ray, HitInfo& hitInfo)
{
	Point3 tri[3];
	BOOL hit = FALSE;
	float dist = BIGFLOAT;
	Mesh* mesh = hitInfo.instance->mesh;

	// For each face in the mesh...
	for (int nf = 0; nf < mesh->numFaces; nf++) {
		Face* f = &(mesh->faces[nf]);

		// We have a pre-calculated bounding sphere for each face.
		// here we can do a trivial hit rejection to see if we can
		// discard the face.

		BoundingSphere* bs = hitInfo.instance->faceBoundSpheres[nf];
		Point3 pc = bs->bsCenter - ray->p;
		float v = DotProd(pc,ray->dir);
		if (bs->bsRadSq - LSQ(pc) + v*v < 0.0f) {
			// No point proceeding with this face...
			continue;
		}

		// Get the vertices
		if (!hitInfo.instance->TestFlag(INST_TM_NEGPARITY)) {
			tri[0] = mesh->getVert(f->getVert(0));
			tri[1] = mesh->getVert(f->getVert(1));
			tri[2] = mesh->getVert(f->getVert(2));
		}
		else {
			// Scaling is negative, get the vertives
			// counter clockwise.
			tri[0] = mesh->getVert(f->getVert(2));
			tri[1] = mesh->getVert(f->getVert(1));
			tri[2] = mesh->getVert(f->getVert(0));
		}

		/* TBD: This slowed things down in some test scenes, but might work better
		// for real life scenes..
		// Do hit rejection on the triangle bouding box
		// to get a few extra triangles out of the way
		Box3 triBound;
		triBound.Init();

		triBound += tri[0];
		triBound += tri[1];
		triBound += tri[2];

		// If we don't hit the bounding box we don't need to hit test the
		// triangle
		if (!rayBoundHit(ray, triBound)) {
			continue;
		}
		*/

		// Intersect ray with triangle
		Point3 bc;
		Point3 n;
		Point3 hp;
		if (intersectTri(ray, tri, bc, n, hp)) {
			float dl = Length(hp);
			if (dl < dist) {
				hitInfo.faceNum = nf;
				hitInfo.baryCoord = bc;
				hitInfo.normalAtHitPoint = n;
				hitInfo.hitPos = hp;
				dist = dl;
				hit = TRUE;
			}
		}
	}

	return hit;
}


//***************************************************************************
// Intersect a ray with a triangle.
//***************************************************************************

BOOL intersectTri(Ray* ray, Point3* tri, Point3& baryCoord,
				  Point3& normal, Point3& hitPos)
{
	Plane p;

	CompPlaneEqn(p, tri[0], tri[1], tri[2]);

	Point3 Pn = Point3(p[0], p[1], p[2]);
	Point3 Rd = ray->dir;
	Point3 R0 = ray->p;

	float Vd = Pn.x * Rd.x + Pn.y * Rd.y + Pn.z * Rd.z;
	if (Vd >= 0.0f)
		return FALSE;

	float V0 = -(Pn.x * R0.x + Pn.y * R0.y + Pn.z * R0.z + p[3]);
	float t = V0 / Vd;

	if (t < 0.0f)
		return FALSE;

	// Intersection with plane.
	Point3 Pi = Point3(R0.x+Rd.x*t, R0.y+Rd.y*t, R0.z+Rd.z*t);

	// Get the barycentric coordinates of the hitPoint.
	// If any of the components are > 1.0 the hit is outside the triangle
	baryCoord = CalcBaryCoords(tri[0], tri[1], tri[2], Pi);

	if (baryCoord.x >= 0.0f && baryCoord.x <= 1.0f) {
		if (baryCoord.y >= 0.0f && baryCoord.y <= 1.0f) {
			if (baryCoord.z >= 0.0f && baryCoord.z <= 1.0f) {
				normal = Point3(0.0f,0.0f,1.0f); // Not used!
				hitPos = Pi; // Intersection point (the point we render)
				return TRUE;
			}
		}
	}

	return FALSE;
}


//***************************************************************************
// Compute the plane equation for the three points making up the plane.
//***************************************************************************

void CompPlaneEqn(Plane plane, const Point3& p0,
				  const Point3& p1, const Point3& p2)
{
	Point3 e1 = p1-p0;
	Point3 e2 = p2-p0;
	Point3 p = CrossProd(e1,e2);
	p = Normalize(p);
	plane[0] = p.x;
	plane[1] = p.y;
	plane[2] = p.z;
	plane[3] = -DotProd(p0,p);
}


//***************************************************************************
// Determine if the ray hits the bounding box of the node.
// This is done for trivial hit rejection.
//***************************************************************************

BOOL rayBoundHit(Ray* ray, Box3 boundingBox)
{
	float t, tmin, tmax;
	float dir, pos;

	tmax = BIGFLOAT;
	tmin = 0.0f;

	dir = ray->dir.x;
	pos = ray->p.x;

	if (dir < 0.0f) {
		t = (boundingBox.pmin.x - pos) / dir;
		if (t < tmin)
			return FALSE;
		if (t <= tmax)
			tmax = t;
		t = (boundingBox.pmax.x - pos) / dir;
		if (t >= tmin) {
			if (t > tmax)
				return FALSE;
			tmin = t;
		}
	} else if (dir > 0.0f) {
		t = (boundingBox.pmax.x - pos) / dir;
		if (t < tmin)
			return FALSE;
		if (t <= tmax)
			tmax = t;
		t = (boundingBox.pmin.x - pos) / dir;
		if (t >= tmin) {
			if (t > tmax)
				return FALSE;
			tmin = t;
		}
	} else if (pos < boundingBox.pmin.x || pos > boundingBox.pmax.x)
		return FALSE;

	dir = ray->dir.y;
	pos = ray->p.y;

	if (dir < 0.0f) {
		t = (boundingBox.pmin.y - pos) / dir;
		if (t < tmin)
			return FALSE;
		if (t <= tmax)
			tmax = t;
		t = (boundingBox.pmax.y - pos) / dir;
		if (t >= tmin) {
			if (t > tmax)
				return FALSE;
			tmin = t;
		}
	} else if (dir > 0.0f) {
		t = (boundingBox.pmax.y - pos) / dir;
		if (t < tmin)
			return FALSE;
		if (t <= tmax)
			tmax = t;
		t = (boundingBox.pmin.y - pos) / dir;
		if (t >= tmin) {
			if (t > tmax)
				return FALSE;
			tmin = t;
		}
	} else if (pos < boundingBox.pmin.y || pos > boundingBox.pmax.y)
		return FALSE;

	dir = ray->dir.z;
	pos = ray->p.z;

	if (dir < 0.0f) {
		t = (boundingBox.pmin.z - pos) / dir;
		if (t < tmin)
			return FALSE;
		if (t <= tmax)
			tmax = t;
		t = (boundingBox.pmax.z - pos) / dir;
		if (t >= tmin) {
			if (t > tmax)
				return FALSE;
			tmin = t;
		}
	} else if (dir > 0.0f) {
		t = (boundingBox.pmax.z - pos) / dir;
		if (t < tmin)
			return FALSE;
		if (t <= tmax)
			tmax = t;
		t = (boundingBox.pmin.z - pos) / dir;
		if (t >= tmin) {
			if (t > tmax)
				return FALSE;
			tmin = t;
		}
	} else if (pos < boundingBox.pmin.z || pos > boundingBox.pmax.z)
		return FALSE;

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\cjrender\refenum.h ===
//***************************************************************************
// CJRender - [refenum.h] Sample Plugin Renderer for 3D Studio MAX.
// 
// By Christer Janson - Kinetix
//
// Description:
// Definition of enumeration classes
//
//***************************************************************************

class MtlEnum {
	public:
		virtual int proc(MtlBase *m, int subMtlNum) = 0;
};

class GetMaps: public RefEnumProc {
	MtlBaseLib *mlib;
	public:
	void proc(ReferenceMaker *rm);
	GetMaps(MtlBaseLib *mbl);
};

class CheckFileNames: public NameEnumCallback {
	public:
		NameTab* missingMaps;
		BitmapInfo bi;
		CheckFileNames(NameTab* n);
		void RecordName(TCHAR *name);
};

class MapLoadEnum:public MtlEnum {
	public:
		TimeValue t;

	   	MapLoadEnum(TimeValue time);
		virtual int proc(MtlBase *m, int subMtlNum);
};

class MapSetupEnum:public MtlEnum {
		TimeValue t;
		CJRenderer* r;
		CJRenderMapsContext rmc;

	public:

	   	MapSetupEnum(TimeValue time, CJRenderer* renderer, Instance* inst);
		virtual int proc(MtlBase *m, int subMtlNum);
};

//***************************************************************************
// Enumerators to manage the RenderBegin()/RenderEnd() calls
//***************************************************************************

class ClearFlags : public RefEnumProc {
	public:
	void proc(ReferenceMaker *rm);
};

class BeginEnum : public RefEnumProc {
	public:
	TimeValue t;
	BeginEnum(TimeValue startTime);
	void proc(ReferenceMaker *rm);
};

class EndEnum : public RefEnumProc {
	public:
	TimeValue t;
	EndEnum(TimeValue endTime);
	void proc(ReferenceMaker *rm);
};

//***************************************************************************
// Prototypes
//***************************************************************************

void	EnumRefs(ReferenceMaker *rm, RefEnumProc &proc);
int		EnumMaps(MtlBase *mb, int subMtl,  MtlEnum &tenum);
int		EnumMtlTree(MtlBase *mb, int subMtl, MtlEnum &tenum);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\cjrender\lights.cpp ===
//***************************************************************************
// CJRender - [lights.cpp] Sample Plugin Renderer for 3D Studio MAX.
// 
// By Christer Janson - Kinetix
//
// Description:
// Implementation of the RenderLights and Light/Shadow support classes
//
//***************************************************************************


#include "maxincl.h"
#include "cjrender.h"
#include "rendutil.h"
#include "refenum.h"



//***************************************************************************
// This is a class designed purely for convenience.
// We need to keep track of the LightObjects, the light nodes
// and the LightObject descriptors. In order to keep them synched
// I'm collecting them in a class for themselves.
//***************************************************************************

//***************************************************************************
// Constructor of RenderLight
// The constructor will get the light objects and the
// light object descriptor from the light node we pass in.
//***************************************************************************

RenderLight::RenderLight(INode* node, MtlBaseLib* mtls)
{
	pNode = node;

	ObjectState ostate = pNode->EvalWorldState(0);

	pLight = (LightObject*)ostate.obj;
	pDesc = pLight->CreateLightDesc(pNode);

	// Process maps
	GetMaps getmaps(mtls);
	EnumRefs(pLight,getmaps);

	DebugPrint("Created RenderLight for: %s\n", node->GetName());
}


//***************************************************************************
// Alternative constructor used for default lights
//***************************************************************************

RenderLight::RenderLight(DefaultLight* l)
{
	pNode = NULL;
	pLight = NULL;
	pDesc = new DefObjLight(l);
	DebugPrint("Created RenderLight for default light.\n");
}

//***************************************************************************
// Nothing to do in the destructor
//***************************************************************************

RenderLight::~RenderLight()
{
}

//***************************************************************************
// Call update on the Light descriptor
//***************************************************************************

void RenderLight::Update(TimeValue t, CJRenderer* renderer)
{
	RContext rc(renderer);

	// TRUE means use shadows, but we only have a dummy implementation of
	// the ShadowBuffer in this renderer. This dummy implementation always
	// reports that the point is not shadowed.
	// To use an implementation similar to the Max default scanline
	// renderer you need to fully implement the ShadowBuffer class
	// see cjshade.cpp for the dummy implementation.
	pDesc->Update(t, rc, &renderer->rendParams, TRUE, FALSE);
}


//***************************************************************************
// Update view dependent parameters
//***************************************************************************

void RenderLight::UpdateViewDepParams(Matrix3 world2cam)
{
	pDesc->UpdateViewDepParams(world2cam);
}


/****************************************************************************
// RContext
 ***************************************************************************/

Color RContext::GlobalLightLevel() const
{
	return renderer->rendParams.pFrp->globalLightLevel;
}


//***************************************************************************
// Light Descriptor for the default lights
//***************************************************************************

DefObjLight::DefObjLight(DefaultLight *l) : ObjLightDesc(NULL)
{
	inode = NULL;
	bViewOriented = true;
	ls = l->ls;

	// New for R3
	// If the TM is all 0, then the light is view dependent and is always
	// supposed to be located at the camera position, looging at the scene.
	// This happens when the user has the "one light" viewport options turned on btw.
	for (int i=0; i<4; i++) {
		Point3 p = l->tm.GetRow(i);
		if (p.x != 0 || p.y != 0 || p.z != 0)
			bViewOriented = false;
		}

	if (!bViewOriented) {
		lightToWorld = l->tm;
		worldToLight = Inverse(lightToWorld);
		}
	}


//***************************************************************************
// Update
//***************************************************************************

int DefObjLight::Update(TimeValue t, const RendContext& rc, RenderGlobalContext* rgc, BOOL shadows, BOOL shadowGeomChanged)
{
	if (bViewOriented) {
		if (rgc) {
			lightToWorld = rgc->camToWorld;
			worldToLight = Inverse(lightToWorld);
			}
		}

	intensCol  = ls.intens*ls.color*rc.GlobalLightLevel();
	return 1;
}


//***************************************************************************
// Update viewdependent parameters
//***************************************************************************

int DefObjLight::UpdateViewDepParams(const Matrix3& worldToCam)
	{
	lightToCam = lightToWorld * worldToCam;
	camToLight = Inverse(lightToCam);
	lightPos   = lightToCam.GetRow(3);  // light pos in camera space
	lightDir   = Normalize(lightToCam.GetRow(2));
	return 1;
	}


//***************************************************************************
// Illuminate method for default lights
//***************************************************************************

BOOL DefObjLight::Illuminate(ShadeContext& sc, Point3& normal, Color& color, Point3 &dir, float &dot_nl, float& diffuseCoef)
	{
	color = intensCol;

	if (ls.type==DIRECT_LGT) {
		diffuseCoef = dot_nl = DotProd(normal, lightDir);
		dir = lightDir;
		}
	else {
		dir = Normalize(lightPos-sc.P());
		diffuseCoef = dot_nl = DotProd(normal,dir);
		}

	return (dot_nl<=0.0f)?0:1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\cjrender\instance.cpp ===
//***************************************************************************
// CJRender - [instance.cpp] Sample Plugin Renderer for 3D Studio MAX.
// 
// By Christer Janson - Kinetix
//
// Description:
// Implementation of the Instance and RenderLight classes
//
//***************************************************************************


#include "maxincl.h"
#include "cjrender.h"
#include "rendutil.h"
#include "refenum.h"

Instance::Instance(INode* node, MtlBaseLib* mtls, int nodeID)
{
	pNode	= node;
	mesh	= NULL;
	flags	= 0;

	// Get material for node
	mtl = node->GetMtl();
	if (!mtl) {
		// Node has no material, create a dummy material based on wireframe color
		// This is done so the  renderer does not have to worry about nodes
		// without materials. It will, in effect, assure that every node has
		// a valid material.
		mtl = new DumMtl(node->GetWireColor());
		DebugPrint("\tCreated dummy material for: %s.\n", node->GetName());
	}

	// Add material to our list
	mtls->AddMtl(mtl);

	this->nodeID = nodeID;
}

Instance::~Instance()
{
	FreeAll();

	// If this is a dummy material we need to delete it
	if (mtl->ClassID() == DUMMTL_CLASS_ID) {
		delete mtl;
		DebugPrint("\tDeleted dummy material.\n");
	}
}


int Instance::Update(TimeValue t, View& vw, CJRenderer* pRenderer)
{
	FreeAll();

	// Check visibility
	vis = pNode->GetVisibility(t);
	if (vis < 0.0f) {
		vis = 0.0f;
		SetFlag(INST_HIDE, 1);
		return 1;
	}
	if (vis > 1.0f) vis = 1.0f;
	SetFlag(INST_HIDE, 0);

	// TM's
	Interval tmValid(FOREVER);
	objToWorld = pNode->GetObjTMAfterWSM(t,&tmValid);

	// Is this node negatively scaled
	SetFlag(INST_TM_NEGPARITY, TMNegParity(objToWorld));

	// Get Object
	ObjectState os = pNode->EvalWorldState(t);
	pObject = os.obj;

	//******************************************************************
	// Mesh access.
	// In this sample renderer we retrieve the mesh for all nodes,
	// then we transform all the vertices to camera space and finally
	// we render the frame.
	// Problem: When we retrieve the mesh from instanced objects
	// we will get the same mesh for all instances.
	// As we, in this case, transform the vertices we would do multiple
	// (and invalid) transformations of the mesh for instanced objects.
	// To solve this in an easy (but expensive way) we make copies of
	// all meshes. We can get away with that, because we are
	// a sample renderer - however, you are not.
	//******************************************************************

	// Make a complete copy of the mesh...
	BOOL deleteMesh;
	mesh = new Mesh;
	Mesh* nodeMesh = ((GeomObject*)pObject)->GetRenderMesh(t, pNode, vw, deleteMesh);

	/*
	mesh->DeepCopy(nodeMesh, GEOM_CHANNEL | TOPO_CHANNEL | TEXMAP_CHANNEL |
		MTL_CHANNEL | DISP_ATTRIB_CHANNEL | TM_CHANNEL);
	*/

	*mesh = *nodeMesh;

	// If the mesh is not a part of the cache, delete it.
	if (deleteMesh) {
		delete nodeMesh;
	}

	for (int i=0; i<mesh->numFaces; i++) {
		BoundingSphere* bs = new BoundingSphere;
		faceBoundSpheres.Append(1, &bs, 25);
	}
	pRenderer->nNumFaces+=mesh->numFaces;

	return 1;
}

void Instance::UpdateViewTM(Matrix3 affineTM)
{
	objToCam = objToWorld * affineTM;
	camToObj = Inverse(objToCam);
	normalObjToCam.IdentityMatrix();

	// Calculate the inverse-transpose of objToCam for transforming normals.
	for (int it=0; it<3; it++) {
		Point4 p = Inverse(objToCam).GetColumn(it);
		normalObjToCam.SetRow(it,Point3(p[0],p[1],p[2]));
	}

	normalCamToObj = Inverse(normalObjToCam);

	CalcBoundingSphere();
}

void Instance::TransformGeometry(Matrix3 pointMat, Matrix3 vecMat)
{
	if (!mesh)
		return;

	// TBD: Do I need to transform back in reverse order?
	// TBD: Do I need to build normals?

	// Transform the mesh points to camera space
	for (int nv = 0; nv < mesh->numVerts; nv++) {
		Point3 vx = pointMat * mesh->getVert(nv);
		mesh->setVert(nv, vx);
	}

	// transform the face normals to camera space
	for (int nf = 0; nf < mesh->numFaces; nf++) {
		Point3 fn = VectorTransform(vecMat, mesh->getFaceNormal(nf));
		mesh->setFaceNormal(nf, fn);
	}
}

void Instance::CalcBoundingSphere()
{
	// Get the boundingbox first
	obBox.Init();

	Point3 vx[3];

	// Include each vertex in the bounding box
	for (int nf = 0; nf < mesh->numFaces; nf++) {
		Face* f = &(mesh->faces[nf]);
		vx[0] = mesh->getVert(f->getVert(0));
		vx[1] = mesh->getVert(f->getVert(1));
		vx[2] = mesh->getVert(f->getVert(2));

		obBox += vx[0];
		obBox += vx[1];
		obBox += vx[2];

		// Pre-calculate bounding spheres for the faces
		BoundingSphere* bs = (BoundingSphere*)faceBoundSpheres[nf];
		bs->bsCenter = objToCam * ((vx[0] + vx[1] + vx[2]) / 3.0f);
		bs->bsRadSq = 0.0f;
		Point3 d;
		float nr = 0.0f;
		for (int i=0; i<3; i++) {
			d = objToCam * vx[i] - bs->bsCenter;
			nr = DotProd(d,d);
			if (nr>bs->bsRadSq) bs->bsRadSq = nr;
		}
	}

	camBox = obBox * objToCam;

	// Now get the bounding sphere forthe object itself
	center = 0.5f*(objToCam*obBox.pmin+objToCam*obBox.pmax);
	radsq = 0.0f;
	for (int i= 0; i<mesh->numVerts; i++) {
		Point3 d = objToCam*mesh->verts[i] - center;
		float nr = DotProd(d,d);
		if (nr>radsq) radsq = nr;		
	}
}

void Instance::FreeAll()
{
	if (mesh) {
		delete mesh;
		mesh = NULL;
	}

	for (int i=0; i<faceBoundSpheres.Count(); i++) {
		delete faceBoundSpheres[i];
	}
	faceBoundSpheres.ZeroCount();
	faceBoundSpheres.Shrink();
}

RenderInstance* Instance::Next()
{
	return next;
}

Interval Instance::MeshValidity()
{
	return FOREVER;
}

int Instance::NumLights()
{
	return 0;
}

LightDesc* Instance::Light(int n)
{
	return NULL;
}

int Instance::NumShadLights()
{
	return NULL;
}

LightDesc* Instance::ShadLight(int n)
{
	return NULL;
}

INode* Instance::GetINode()
{
	return pNode;
}

Object* Instance::GetEvalObject()
{
	return pObject;
}

unsigned long Instance::MtlRequirements(int mtlNum)
{
	return mtl->Requirements(mtlNum);
}

Point3 Instance::GetFaceNormal(int faceNum)
{
	return Point3(0,0,0);
}

Point3 Instance::GetFaceVertNormal(int faceNum, int vertNum)
{
	return Point3(0,0,0);
}

void Instance::GetFaceVertNormals(int faceNum, Point3 n[3])
{
}

Point3 Instance::GetCamVert(int vertNum)
{
	return Point3(0,0,0);
}


void Instance::GetObjVerts(int fnum, Point3 obp[3])
{
	Face* f = &mesh->faces[fnum];
	obp[0] = mesh->verts[f->v[0]];
	obp[1] = mesh->verts[f->v[1]];
	obp[2] = mesh->verts[f->v[2]];
}

void Instance::GetCamVerts(int fnum, Point3 cp[3])
{
}

TCHAR* Instance::GetName()
{
	return pNode->GetName();
}

int Instance::CastsShadowsFrom(const ObjLightDesc& lt)
	{
	return TRUE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\cjrender\rendutil.cpp ===
//***************************************************************************
// CJRender - [rendutil.cpp] Sample Plugin Renderer for 3D Studio MAX.
// 
// By Christer Janson - Kinetix
//
// Description:
// Utilitiy functions
//
//***************************************************************************

#include "maxincl.h"
#include "cjrender.h"
#include "rendutil.h"

//***************************************************************************
// Since Matrix3::NoScale() was not implemented in Max SDK 1.0,
// here's a manual implementation
//***************************************************************************
void RemoveScaling(Matrix3 &m)
{
	for (int i=0; i<3; i++) 
		m.SetRow(i,Normalize(m.GetRow(i)));
}

//***************************************************************************
// Helper function to see if the face is 'facing' our way.
//***************************************************************************
int isFacing(Point3& p0, Point3& p1, Point3& p2 , int projType) {
	if (projType==PROJ_PERSPECTIVE) {
		FLOAT t0,t1,t2,d;
		t0 = p1.y*p2.z - p1.z*p2.y;
		t1 = p2.y*p0.z - p2.z*p0.y;
		t2 = p0.y*p1.z - p0.z*p1.y;
		d = -(p0.x*t0 + p1.x*t1 + p2.x*t2);
		return((d<0.0)?0:1);
	}
	else {
		float d = (p1.x-p0.x)*(p2.y-p0.y) - (p2.x-p0.x)*(p1.y-p0.y);
		return((d<0.0)?0:1);
	}
}

//***************************************************************************
// Calculate the determinant
// Thanks to Ruediger Hoefert, Absolute Software
//***************************************************************************

static float det2x2( float a, float b, float c, float d )
{
    float ans;
    ans = a * d - b * c;
    return ans;
}

//***************************************************************************
// 
// float = det3x3(  a1, a2, a3, b1, b2, b3, c1, c2, c3 )
//   
// calculate the determinant of a 3x3 matrix
// in the form
//
//     | a1,  b1,  c1 |
//     | a2,  b2,  c2 |
//     | a3,  b3,  c3 |
//
// Thanks to Ruediger Hoefert, Absolute Software
//***************************************************************************

static float det3x3( Point3 a,Point3 b,Point3 c )

{
   float a1, a2, a3, b1, b2, b3, c1, c2, c3;    
   float ans;
   
   a1 = a.x ; a2 = a.y ; a3 = a.z ;   
   b1 = b.x ; b2 = b.y ; b3 = b.z ;   
   c1 = c.x ; c2 = c.y ; c3 = c.z ;   

   ans = a1 * det2x2( b2, b3, c2, c3 )
       - b1 * det2x2( a2, a3, c2, c3 )
       + c1 * det2x2( a2, a3, b2, b3 );
   return ans;
}


//***************************************************************************
// Given three points in space forming a triangle (p0,p1,p2), 
// and a fourth point in the plane of that triangle, returns the
// barycentric coords of that point relative to the triangle.
// Thanks to Ruediger Hoefert, Absolute Software
//***************************************************************************

Point3 CalcBaryCoords(Point3 p0, Point3 p1, Point3 p2, Point3 p)
{ 
	Point3 tpos[3];
	Point3 cpos;
	Point3 bary;

	tpos[0] = p0;
	tpos[1] = p1;
	tpos[2] = p2;
	cpos = p;

 /*
 
 S.304 Curves+Surfaces for Computer aided design:

     u + v + w = 1

         area(p,b,c)    area(a,p,c)   area(a,b,p)
 u = -----------, v = -----------, w = -----------, 
    area(a,b,c)    area(a,b,c)   area(a,b,c)
 
   ax  bx  cx
   
 area(a,b,c) = 0.5 * ay  by  cy
   
   az  bz  cz
    
   
 */

	float area_abc, area_pbc, area_apc, area_abp; 
	
	area_abc= det3x3(tpos[0],tpos[1],tpos[2]);
	area_abc=1.0f/area_abc;
	
	area_pbc =det3x3(cpos   ,tpos[1],tpos[2]); 
	area_apc =det3x3(tpos[0],cpos   ,tpos[2]);
	area_abp =det3x3(tpos[0],tpos[1],cpos   );
	
	bary.x = area_pbc *area_abc ;
	bary.y = area_apc *area_abc ;
	bary.z = area_abp *area_abc ;
	
	return bary;
}


//***************************************************************************
// This is cut directly from the SDK documentation.
// This is how UV coords are generated for face mapped materials
//***************************************************************************

static Point3 basic_tva[3] = { 
	Point3(0.0,0.0,0.0),Point3(1.0,0.0,0.0),Point3(1.0,1.0,0.0)
};
static Point3 basic_tvb[3] = { 
	Point3(1.0,1.0,0.0),Point3(0.0,1.0,0.0),Point3(0.0,0.0,0.0)
};
static int nextpt[3] = {1,2,0};
static int prevpt[3] = {2,0,1};

void MakeFaceUV(Face *f, Point3 *tv)
{
	int na,nhid,i;
	Point3 *basetv;
	/* make the invisible edge be 2->0 */
	nhid = 2;
	if (!(f->flags&EDGE_A))  nhid=0;
	else if (!(f->flags&EDGE_B)) nhid = 1;
	else if (!(f->flags&EDGE_C)) nhid = 2;
	na = 2-nhid;
	basetv = (f->v[prevpt[nhid]]<f->v[nhid]) ? basic_tva : basic_tvb; 
	for (i=0; i<3; i++) {  
		tv[i] = basetv[na];
		na = nextpt[na];
	}
}


//***************************************************************************
// Utility function to convert a Color to a BMM_Color_64 structure
//***************************************************************************

BMM_Color_64 colTo64(Color c)
{
	BMM_Color_64 bc;

	// Clamp the colors
	c.ClampMinMax();

	bc.r = (WORD)(c.r * 65535.0);
	bc.g = (WORD)(c.g * 65535.0);
	bc.b = (WORD)(c.b * 65535.0);

	return bc;
}

//***************************************************************************
// Determine is the node has negative scaling.
// This is used for mirrored objects for example. They have a negative scale
// so when calculating the normal we take the vertices counter clockwise.
// If we don't compensate for this the objects will be 'inverted'
//***************************************************************************

BOOL TMNegParity(Matrix3 &m)
{
	return (DotProd(CrossProd(m.GetRow(0),m.GetRow(1)),m.GetRow(2))<0.0)?1:0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\cjrender\refenum.cpp ===
//***************************************************************************
// CJRender - [refenum.cpp] Sample Plugin Renderer for 3D Studio MAX.
// 
// By Christer Janson - Kinetix
//
// Description:
// Implementation of enumeration classes
//
//***************************************************************************

#include "maxincl.h"
#include "cjrender.h"
#include "refenum.h"


//***************************************************************************
// These are enumeration functions for maps, references etc.
//***************************************************************************


//***************************************************************************
// Base class for enumerating references
//***************************************************************************

void EnumRefs(ReferenceMaker *rm, RefEnumProc &proc)
{
	proc.proc(rm);
	int numRefs = rm->NumRefs();
	for (int i=0; i<numRefs; i++) {
		ReferenceMaker *srm = rm->GetReference(i);
		if (srm) {
			EnumRefs(srm,proc);		
		}
	}
}


//***************************************************************************
// Base class of the map enumerator
//***************************************************************************

int EnumMaps(MtlBase *mb, int subMtl,  MtlEnum &tenum)
{
	if (IsTex(mb)) {
		if (!tenum.proc(mb,subMtl)) {
			return 0;
		}
	}
	for (int i=0; i<mb->NumSubTexmaps(); i++) {
		Texmap *st = mb->GetSubTexmap(i); 
		if (st) {
			int subm = (mb->IsMultiMtl()&&subMtl<0)?i:subMtl;
			if (mb->SubTexmapOn(i)) {
				if (!EnumMaps(st,subm,tenum)) {
					return 0;
				}
			}
		}
	}
	if (IsMtl(mb)) {
		Mtl *m = (Mtl *)mb;
		for (i=0; i<m->NumSubMtls(); i++) {
			Mtl *sm = m->GetSubMtl(i);
			if (sm) {
				int subm = (mb->IsMultiMtl()&&subMtl<0)?i:subMtl;
				if (!EnumMaps(sm,subm,tenum)) {
					return 0;
				}
			}
		}
	}
	return 1;
}


//***************************************************************************
// Enumerate a material tree
//***************************************************************************

int EnumMtlTree(MtlBase *mb, int subMtl, MtlEnum &tenum)
{
	for (int i=0; i<mb->NumSubTexmaps(); i++) {
		Texmap *st = mb->GetSubTexmap(i);
		if (st) {
			if (!EnumMtlTree(st,subMtl, tenum)) {
				return 0;
			}
		}
	}
	if (IsTex(mb)) {
		if (!tenum.proc(mb,subMtl)) {
			return 0;
		}
	}
	if (IsMtl(mb)) {
		Mtl *m = (Mtl *)mb;
		for (i=0; i<m->NumSubMtls(); i++) {
			Mtl *sm = m->GetSubMtl(i);
			int subm = (mb->IsMultiMtl()&&subMtl<0)?i:subMtl;
			if (sm) {
				if (!EnumMtlTree(sm,subm,tenum)) {
					return 0;
				}
			}
		}
		if (!tenum.proc(mb,subMtl)) {
			return 0;
		}
	}
	return 1;
}

//***************************************************************************
// Constructor of map enumerator
//***************************************************************************

GetMaps::GetMaps(MtlBaseLib *mbl)
{
	mlib = mbl;
}

//***************************************************************************
// Implementation of the map enumerator
//***************************************************************************

void GetMaps::proc(ReferenceMaker *rm)
{
	if (IsTex((MtlBase*)rm)) {
		mlib->AddMtl((MtlBase *)rm);
	}
}


//***************************************************************************
// Class to manage names of missing maps
//***************************************************************************

CheckFileNames::CheckFileNames(NameTab* n)
{
	missingMaps = n;
}

//***************************************************************************
// Add a name to the list if it's not already there
//***************************************************************************

void CheckFileNames::RecordName(TCHAR *name)
{ 
	if (name) {
		if (name[0]!=0) {
			if (missingMaps->FindName(name)<0) {
			    missingMaps->AddName(name);
			}
		}
	}
}


//***************************************************************************
// Constructor of map loader
// Map loader enum proc
//***************************************************************************

MapLoadEnum::MapLoadEnum(TimeValue time)
{ 
	t = time; 
}

int MapLoadEnum::proc(MtlBase *m, int subMtlNum)
{
	Texmap *tm = (Texmap *)m;
	tm->LoadMapFiles(t);
	return 1;
}

//***************************************************************************
// Constructor of AutoReflect enumerator
// AutoReflect enum proc
// Note:
//***************************************************************************

MapSetupEnum::MapSetupEnum(TimeValue time, CJRenderer* renderer, Instance* inst)
	: rmc(renderer, inst)
{
	t = time; 
	r = renderer;
}

int MapSetupEnum::proc(MtlBase *m, int subMtlNum)
{
	ULONG reqmask = MTLREQ_AUTOREFLECT | MTLREQ_AUTOMIRROR | MTLREQ_PREPRO;
	if (m->LocalRequirements(subMtlNum) & reqmask) {
		rmc.SetSubMtlIndex(subMtlNum);
		m->BuildMaps(t, rmc);
	}
	return 1;
}


//***************************************************************************
// Enumerator to clear the work flag on all objects
//***************************************************************************

void ClearFlags::proc(ReferenceMaker *rm)
{
	if (rm) {
		rm->ClearAFlag(A_WORK1);
	}
}


//***************************************************************************
// Enumerator to call RenderBegin() on all objects
//***************************************************************************

BeginEnum::BeginEnum(TimeValue startTime)
{
	t = startTime;
}

void BeginEnum::proc(ReferenceMaker *rm)
{
	if (rm) {
		if (!rm->TestAFlag(A_WORK1)) {
			rm->SetAFlag(A_WORK1);
			rm->RenderBegin(t);
		}
	}
}

//***************************************************************************
// Enumerator to call RenderEnd() on all objects
//***************************************************************************

EndEnum::EndEnum(TimeValue endTime)
{
	t = endTime;
}

void EndEnum::proc(ReferenceMaker *rm)
{
	if (rm) {
		if (!rm->TestAFlag(A_WORK1)) {
			rm->SetAFlag(A_WORK1);
			rm->RenderEnd(t);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\combust\inferno.h ===
/**********************************************************************
 *<
	FILE: inferno.h

	DESCRIPTION:

	CREATED BY: Rolf Berteig

	HISTORY:

 *>	Copyright (c) 1996 Rolf Berteig, All Rights Reserved.
 **********************************************************************/

#ifndef __INFERNO__H
#define __INFERNO__H

#include "Max.h"
#include "resource.h"

extern ClassDesc* GetExplodeDesc();

extern HINSTANCE hInstance;

TCHAR *GetString(int id);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\cjrender\scontext.h ===
class BGContext; // Fwd decl of background context

// ShadeContext for evaluating materials
// See cjshade.cpp for details about ShadeContext
class SContext : public ShadeContext {
public:
	SContext(CJRenderer* r, BGContext* bgc);
	void SetBary(Point3 bary);

	TimeValue CurTime();
	int NodeID();
	INode* Node();
	Point3 BarycentricCoords();
	int FaceNumber();
	Point3 Normal();
	float Curve();

	LightDesc *Light(int lightNo);
	Point3 GNormal(void);
	Point3 ReflectVector(void);
	Point3 RefractVector(float ior);
	Point3 CamPos(void);
	Point3 V(void);
	Point3 P(void);
	Point3 DP(void);
	Point3 PObj(void);
	Point3 DPObj(void);
	Box3 ObjectBox(void);
	Point3 PObjRelBox(void);
	Point3 DPObjRelBox(void);
	void ScreenUV(Point2 &uv,Point2 &duv);
	IPoint2 ScreenCoord(void);
	Point3 UVW(int channel);
	Point3 DUVW(int channel);
	void DPdUVW(Point3 [], int channel);
	void GetBGColor(Color &bgCol, Color &transp, int fogBG);
	Point3 PointTo(const Point3 &p, RefFrame ito);
	Point3 PointFrom(const Point3 &p, RefFrame ito);
	Point3 VectorTo(const Point3 &p, RefFrame ito);
	Point3 VectorFrom(const Point3 &p, RefFrame ito);

	int		ProjType();
	void	SetInstance(Instance* instance);
	void	SetFaceNum(int f);
	void	SetScreenPos(IPoint2 pt);
	void	SetMtlNum(int mNo);
	void	SetHitPos(Point3 p);
	void	SetViewDir(Point3 v);
	void	CalcNormals();
	void	SetCamPos(Point3 p) { cameraPos = p; }

	BGContext* bc;
	void	getTVerts(int chan);
	void	calc_size_ratio();

	int InMtlEditor() { return FALSE; /* TBD*/ }
	void SetView(Point3 p) { /* TBD*/ }

private:
	CJRenderer* renderer;
	Instance*	pInst;
	Point3		baryCoord;
	int			faceNum;
	IPoint2		screenPos;
	Point3		hitPos;
	Point3		viewDir;
	Point3		vxNormals[3];
	UVVert		tv[MAX_MESHMAPS][3];
	Point3		bumpv[MAX_MESHMAPS][3];
	Point3		dp;
	Point3		uvw[MAX_MESHMAPS];
	Point3		duvw[MAX_MESHMAPS];
	Point3		cameraPos;
	Point3		obpos[3];
	Point3		dobpos;
	ULONG		matreq;
	float		ratio;
	float		curve;
};

//***************************************************************************
//* This is the ShadeContext implementation for backgrounds
//***************************************************************************

#define FARZ -1.0e10f

 class BGContext: public ShadeContext {
	public:
		Point3 viewDir;
		Point3 cpos;
		IPoint2 iscr;
		Point2 scrPos;

		BGContext(CJRenderParams *rpar);
		
		Point3 BGGetPoint(float z = FARZ);
	   	TimeValue CurTime()  { return globContext->time; }     	// current time value
		int FaceNumber() { return 0; }
		LightDesc* Light(int n) { return NULL; }
		int Antialias() { return 0; }
		int NodeID() { return 0; }
		int ProjType() { return globContext->projType;}  // returns: 0: perspective, 1: parallel
		Point3 Normal() { return -viewDir; }
		Point3 GNormal() { return -viewDir;	}
		void SetNormal(Point3 p) {}
		float Curve() { return (float)fabs(1.0f/globContext->xscale);	}
		Point3 ReflectVector() { return Point3(0,0,0); }	// reflection vector
		Point3 RefractVector(float ior) { return Point3(0,0,0); } // refraction vector
	    Point3 CamPos() { return cpos; }			// camera position
		Point3 P() { return viewDir*100.0f; }
		Point3 V() { return viewDir; }
		Point3 DP() { return Point3(0,0,0); }
		void DP(Point3& dpdx, Point3& dpdy) {}
		Point3 PObj() {
			// this makes procedural textures come out a reasonable scale.
			return 100.0f*VectorTransform(globContext->camToWorld,viewDir); 
			}
		Point3 DPObj() { return Point3(0,0,0); }
		Box3 ObjectBox() {return Box3(); } 
		Point3 PObjRelBox() {
			return 100.0f*VectorTransform(globContext->camToWorld,viewDir); 
			}
		Point3 DPObjRelBox() { return Point3(0,0,0); }

	   	void ScreenUV(Point2& uv, Point2 &duv);  // screen coordinate
		IPoint2 ScreenCoord() { return iscr; }		// integer

		Point3 UVW(int channel) { return 100.0f*viewDir; }
		Point3 DUVW(int channel) {	return Point3(0,0,0); }
		void DPdUVW(Point3 dP[3], int channel) { }
		AColor EvalEnvironMap(Texmap *map, Point3 view) {
			Point3 svView = viewDir; 
			viewDir = view;
			AColor rcol = map->EvalColor(*this);
			viewDir = svView;
			return rcol;
			}
		void GetBGColor(Color &bgcol, Color& transp, BOOL fogBG=TRUE) {;}
		Point3 PointFrom(const Point3& p, RefFrame ifrom); 
		Point3 PointTo(const Point3& p, RefFrame ito); 
		Point3 VectorFrom(const Point3& p, RefFrame ifrom);
		Point3 VectorTo(const Point3& p, RefFrame ito); 
		float CamNearRange() {return globContext->nearRange;}
		float CamFarRange() {return globContext->farRange;}

		void SetScreenPos(int x, int y, int width, int height);
		void SetViewDir(Point3 vd) { viewDir = vd; }
		void SetCamPos(Point3 cp)  { cpos = cp; }


// TBD Athena
		int InMtlEditor() { return FALSE; /* TBD*/ }
		void SetView(Point3 p) { /* TBD*/ }

	private:
		Point2		scrDUV;
};

static inline float size_meas(Point3 a, Point3 b, Point3 c) {
	double d  = fabs(b.x-a.x);
	d += fabs(b.y-a.y);
	d += fabs(b.z-a.z);
	d += fabs(c.x-a.x);
	d += fabs(c.y-a.y);
	d += fabs(c.z-a.z);
	return float(d/6.0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\cjrender\scontext.cpp ===
//***************************************************************************
// CJRender - [scontext.cpp] Sample Plugin Renderer for 3D Studio MAX.
// 
// By Christer Janson - Kinetix
//
// Description:
// Implementation of the ShadeContext for materials and backgrounds.
//
//***************************************************************************

#include "maxincl.h"
#include "cjrender.h"
#include "scontext.h"
#include "rendutil.h"


/****************************************************************************
 ShadeContext
 In order to evaluate a material in MAX, you need first of all to derive
 an object from the ShadeContext class.
 Once the ShadeContext is in place, it will provide the shader (the material)
 with enough information to evaluate itself at a specific point in space.
 The ShadeContext provides, among other things, the following information
 to the shader:
 * The current time
 * A Pointer to the node
 * Surface normal at the rendered point
 * Barycentric coordinates of the face at the rendered point
 * The number of the face currently rendered
 * Information about lights
 * Lots of other things...

 ***************************************************************************/

// Enable this definition if you want debug output from ShadeContext
// Note: The status output will come for every pixel and it will be
// *very* slow - even when not ran through the debugger.

// #define SCONTEXT_DEBUG 1

#ifdef SCONTEXT_DEBUG
void SCDebugPrint(char* msg)
{
    DebugPrint(msg);
}
#else 
#define SCDebugPrint(msg)
#endif

static inline Point3 pabs(Point3 p) { return Point3(fabs(p.x),fabs(p.y),fabs(p.z)); }

SContext::SContext(CJRenderer* r, BGContext* bgc)
{
	SCDebugPrint("SContext::SContext\n");

	renderer = r;
	globContext = &r->rendParams;

	bc = bgc;
	pInst = NULL;
	cameraPos = Point3(0.0f, 0.0f, 0.0f);
	mode = SCMODE_NORMAL;
	doMaps = TRUE;
	filterMaps = FALSE;
	shadow = TRUE;
	ambientLight = renderer->rendParams.pFrp->ambient;
	backFace = FALSE;

	nLights = renderer->lightTab.Count();
}

// When the mesh and face number is specified we need to calculate 
// and store the vertex normals
void SContext::CalcNormals()
{
	SCDebugPrint("SContext::CalcNormals\n");

	RVertex* rv[3];
	Face* f = &pInst->mesh->faces[faceNum];
	DWORD smGroup = f->smGroup;
	int numNormals;
	int vxNum;

	// Get the vertex normals
	for (int i = 0, cc = 2; i < 3; i++, cc--) {

		// We need to get the vertices in counter clockwise order
		// if the object has negative scaling.
		if (!pInst->TestFlag(INST_TM_NEGPARITY)) {
			vxNum = i;
		}
		else {
			vxNum = cc;
		}


		rv[i] = pInst->mesh->getRVertPtr(f->getVert(vxNum));

		// Is normal specified
		// SPCIFIED is not currently used, but may be used in future versions.
		if (rv[i]->rFlags & SPECIFIED_NORMAL) {
			vxNormals[i] = VectorTransform(pInst->normalObjToCam, rv[i]->rn.getNormal());
		}
		// If normal is not specified it's only available if the face belongs
		// to a smoothing group
		else if ((numNormals = rv[i]->rFlags & NORCT_MASK) && smGroup) {
			// If there is only one vertex is found in the rn member.
			if (numNormals == 1) {
				vxNormals[i] = VectorTransform(pInst->normalObjToCam, rv[i]->rn.getNormal());
			}
			else {
				// If two or more vertices are there you need to step through them
				// and find the vertex with the same smoothing group as the current face.
				// You will find multiple normals in the ern member.
				for (int j = 0; j < numNormals; j++) {
					if (rv[i]->ern[j].getSmGroup() & smGroup) {
						vxNormals[i] = VectorTransform(pInst->normalObjToCam, rv[i]->ern[j].getNormal());
					}
				}
			}
		}
		else {
			vxNormals[i] = pInst->mesh->getFaceNormal(faceNum);
		}
	}
	vxNormals[0] = Normalize(vxNormals[0]);
	vxNormals[1] = Normalize(vxNormals[1]);
	vxNormals[2] = Normalize(vxNormals[2]);
}

void SContext::SetBary(Point3 bary)
{
	SCDebugPrint("SContext::SetBary\n");

	baryCoord = bary;
}

int SContext::ProjType()
{
	SCDebugPrint("SContext::ProjType\n");

	return renderer->rendParams.projType;
}

void SContext::SetInstance(Instance* instance)
{
	SCDebugPrint("SContext::SetInstance\n");
	pInst = instance;
	matreq = instance->mtl->Requirements(0);
}

void SContext::SetFaceNum(int f)
{
	SCDebugPrint("SContext::SetFaceNum\n");
	faceNum = f;
}

void SContext::SetScreenPos(IPoint2 pt)
{
	SCDebugPrint("SContext::SetScreenPos\n");
	screenPos = pt;
}

void SContext::SetMtlNum(int mNum)
{
	SCDebugPrint("SContext::SetMtlNum\n");

	mtlNum = mNum;
	matreq = pInst->mtl->Requirements(mNum);
}

void SContext::SetHitPos(Point3 p)
{
	SCDebugPrint("SContext::SetHitPos\n");
	hitPos = p;
}

void SContext::SetViewDir(Point3 v)
{
	SCDebugPrint("SContext::SetViewDir\n");
	viewDir = v;
}


// Return current time
TimeValue SContext::CurTime()
{
	SCDebugPrint("SContext::CurTime\n");
	return renderer->rendParams.time;
}

// Return NodeID.
// This is just a counter with a unique value for each node.
int SContext::NodeID()
{
	SCDebugPrint("SContext::NodeID\n");
	return pInst->nodeID;
}

// The INode we are currently rendering
INode* SContext::Node()
{
	SCDebugPrint("SContext::Node\n");
	return pInst->pNode;
}

// The barycentric coordinates of the point relative to the face
Point3 SContext::BarycentricCoords()
{
	SCDebugPrint("SContext::BarycentricCoords\n");
	return baryCoord;
}

// The face number
int SContext::FaceNumber()
{
	SCDebugPrint("SContext::FaceNumber\n");
	return faceNum;
}


// Interpolated normal
Point3 SContext::Normal()
{
	// The face normals are already in camera space
	SCDebugPrint("SContext::Normal\n");

	return Normalize(baryCoord.x*vxNormals[0] + baryCoord.y*vxNormals[1] + baryCoord.z*vxNormals[2]);
}

// Geometric normal (face normal)
Point3 SContext::GNormal(void)
{
	// The face normals are already in camera space
	SCDebugPrint("SContext::GNormal\n");
	return pInst->mesh->getFaceNormal(faceNum);
}

// Return a Light descriptor
LightDesc *SContext::Light(int lightNum)
{
	RenderLight* rLight = (RenderLight*)renderer->lightTab[lightNum];
	SCDebugPrint("SContext::Light\n");
	return rLight->pDesc;
}

// Return reflection vector at this point
Point3 SContext::ReflectVector(void)
{
	SCDebugPrint("SContext::ReflectVector\n");
	Point3 N = Normal();
	float VN = -DotProd(viewDir,N);
    return Normalize(2.0f*VN*N + viewDir);
}

// Foley & vanDam: Computer Graphics: Principles and Practice, 
//     2nd Ed. pp 756ff.
Point3 SContext::RefractVector(float ior)
{
	SCDebugPrint("SContext::RefractVector\n");
	Point3 N = Normal();
	float VN,nur,k;
	VN = DotProd(-viewDir,N);
	if (backFace) nur = ior;
	else nur = (ior!=0.0f) ? 1.0f/ior: 1.0f;
	k = 1.0f-nur*nur*(1.0f-VN*VN);
	if (k<=0.0f) {
		// Total internal reflection: 
		return ReflectVector();
	}
	else {
		return (nur*VN-(float)sqrt(k))*N + nur*viewDir;
	}
}

// We're in camera space, so this is always 0,0,0
Point3 SContext::CamPos(void)
{
	SCDebugPrint("SContext::CamPos\n");
	return cameraPos;
}

// Screen coordinate beeing rendered
IPoint2 SContext::ScreenCoord(void)
{
	SCDebugPrint("SContext::ScreenPos\n");
	return screenPos;
}

// Background color
void SContext::GetBGColor(class Color &bgCol,class Color &transp,int fogBG)
{
	SCDebugPrint("SContext::GetBGColor\n");

	if (renderer->rendParams.envMap) {
		AColor abg = renderer->rendParams.envMap->EvalColor(*bc);
		bgCol.r = abg.r;
		bgCol.g = abg.g;
		bgCol.b = abg.b;
	}
	else {
		bgCol = renderer->rendParams.pFrp->background;
	}

	transp = Color(0.0f, 0.0f, 0.0f);	// TBD
}

// Transforms the specified point from internal camera space to the specified space.
Point3 SContext::PointTo(const class Point3 &p, RefFrame ito)
{
	Point3 pt;

	SCDebugPrint("SContext::PointTo\n");
	Matrix3 camToObj = Inverse(pInst->objToWorld * renderer->view.affineTM);

	switch (ito) {
		case REF_WORLD:  pt = renderer->rendParams.camToWorld*p; break;
		case REF_OBJECT: pt = camToObj * p; break;
		default: pt = p; break;
	}

	return pt;
}

// Transforms the specified point from the specified coordinate system
// to internal camera space.
Point3 SContext::PointFrom(const class Point3 &p, RefFrame ito)
{
	Point3 pt;
	Matrix3 objToCam = pInst->objToWorld * renderer->view.affineTM;
	SCDebugPrint("SContext::PointFrom\n");

	switch (ito) {
		case REF_WORLD:  pt = renderer->rendParams.worldToCam*p; break;
		case REF_OBJECT: pt = objToCam * p; break;
		default: pt = p; break;
	}

	return pt;
}

// Transform the vector from internal camera space to the specified space.
Point3 SContext::VectorTo(const class Point3 &p, RefFrame ito)
{
	Point3 pt;
	Matrix3 camToObj = Inverse(pInst->objToWorld * renderer->view.affineTM);
	SCDebugPrint("SContext::VectorTo\n");

	switch (ito) {
		case REF_WORLD:  pt = VectorTransform(renderer->rendParams.camToWorld,p); break;
		case REF_OBJECT: pt = VectorTransform(camToObj,p); break;
		default: pt = p; break;
	}

	return pt;
}

// Transform the vector from the specified space to internal camera space.
Point3 SContext::VectorFrom(const class Point3 &p, RefFrame ito)
{
	Point3 pt;
	Matrix3 objToCam = pInst->objToWorld * renderer->view.affineTM;

	SCDebugPrint("SContext::VectorFrom\n");
	switch (ito) {
		case REF_WORLD:  pt = VectorTransform(renderer->rendParams.worldToCam,p); break;
		case REF_OBJECT: pt = VectorTransform(objToCam,p); break;
		default: pt = p;
	}

	return pt;
}

// This method returns the unit view vector, from the camera towards P,
// in camera space.
Point3 SContext::V(void)
{
	SCDebugPrint("SContext::V\n");
	return viewDir;
}

// Returns the point to be shaded in camera space.
Point3 SContext::P(void)
{
	SCDebugPrint("SContext::P\n");
	return hitPos;
}

// This returns the derivative of P, relative to the pixel.
// This gives the renderer or shader information about how fast the position
// is changing relative to the screen.

#define DFACT .1f

Point3 SContext::DP(void)
{
	SCDebugPrint("SContext::DP\n");

	float d = (1.0f+DFACT)* /*RayDiam()*/ 0.1f/(DFACT+(float)fabs(DotProd(Normal(),viewDir)));
	dp = Point3(d,d,d);
	return dp;
}

// Retrieves the point relative to the screen where the lower left
// corner is 0,0 and the upper right corner is 1,1.
void SContext::ScreenUV(class Point2 &uv,class Point2 &duv)
{
	Point2 p;

	SCDebugPrint("SContext::ScreenUV\n");

	p.x = .5f*(((float)screenPos.x-renderer->rendParams.xc+0.5f) / 
			renderer->rendParams.xc+1.0f);
	p.y = .5f*(-((float)screenPos.y)/renderer->rendParams.yc+1.0f);
	uv = p;
	duv = renderer->rendParams.scrDUV;
}

// Bounding box in object coords
Box3 SContext::ObjectBox(void)
{
	SCDebugPrint("SContext::ObjectBox\n");
	return pInst->obBox;
}

// Returns the point to be shaded relative to the object box where each
// component is in the range of -1 to +1.
Point3 SContext::PObjRelBox(void)
{
	SCDebugPrint("SContext::PObjRelBox\n");

	Point3 q;
	Point3 p = PObj();
	Box3 b = ObjectBox(); 
	q.x = 2.0f*(p.x-b.pmin.x)/(b.pmax.x-b.pmin.x) - 1.0f;
	q.y = 2.0f*(p.y-b.pmin.y)/(b.pmax.y-b.pmin.y) - 1.0f;
	q.z = 2.0f*(p.z-b.pmin.z)/(b.pmax.z-b.pmin.z) - 1.0f;
	return q;
}

// Returns the derivative of PObjRelBox().
// This is the derivative of the point relative to the object box where
// each component is in the range of -1 to +1.
Point3 SContext::DPObjRelBox(void)
{
	SCDebugPrint("SContext::DPObjRelBox\n");
	Box3 b = ObjectBox(); 
	Point3 d = DPObj();
	d.x *= 2.0f/(b.pmax.x-b.pmin.x); 
	d.y *= 2.0f/(b.pmax.y-b.pmin.y); 
	d.z *= 2.0f/(b.pmax.z-b.pmin.z); 
	return d;
}

// Returns the point to be shaded in object coordinates.
Point3 SContext::PObj(void)
{
	SCDebugPrint("SContext::PObj\n");
	Matrix3 camToObj = Inverse(pInst->objToWorld * renderer->view.affineTM);
	return camToObj * P();
}

// Returns the derivative of PObj(), relative to the pixel.
// TBD
Point3 SContext::DPObj(void)
{
	SCDebugPrint("SContext::DPObj\n");
	return Point3(0.0f,0.0f,0.0f);
}

void SContext::getTVerts(int chan)
{
	if (chan!=0&&(matreq&MTLREQ_FACEMAP)) {
		MakeFaceUV(&pInst->mesh->faces[faceNum],tv[0]);
		}
	else {
		Mesh* m = pInst->mesh;
		if (!m->mapSupport(chan))
			return;

		UVVert* tverts = m->mapVerts(chan);
		TVFace* tvf = &m->mapFaces(chan)[faceNum];

		tv[chan][0] = tverts[tvf->t[0]];
		tv[chan][1] = tverts[tvf->t[1]];
		tv[chan][2] = tverts[tvf->t[2]];
		}
	}

#define SZFACT 1.5f

// Approximate how big fragment is relative to whole face.
void SContext::calc_size_ratio()
{
	Point3 dp = DP();
	Point3 cv[3];
	pInst->GetCamVerts(faceNum,cv);
	float d = size_meas(cv[0], cv[1], cv[2]);
	ratio = SZFACT*(float)fabs(dp.x)/d;  // SZFACT is just a hack to adjust the blur
}

Point3 SContext::UVW(int chan)
{ 
	SCDebugPrint("SContext::UVW\n");

	getTVerts(chan);
	uvw[chan] = baryCoord.x*tv[chan][0] + baryCoord.y*tv[chan][1] + baryCoord.z*tv[chan][2];
	return uvw[chan];
}	

// Returns the UVW derivatives for the point.
// TBD
Point3 SContext::DUVW(int chan)
{
	SCDebugPrint("SContext::DUVW\n");

	getTVerts(chan);
	calc_size_ratio();
	duvw[chan] = 0.5f*(pabs(tv[chan][1]-tv[chan][0])+pabs(tv[chan][2]-tv[chan][0]))*ratio;
	return duvw[chan];
}

// This returns the bump basis vectors for UVW in camera space.
void SContext::DPdUVW(Point3 dP[3], int chan)
{
	SCDebugPrint("SContext::DPdUVW\n");

	getTVerts(chan);
	calc_size_ratio();
	Point3 bv[3];

	pInst->GetObjVerts(faceNum, obpos);

	ComputeBumpVectors(tv[chan], obpos, bv);
	bumpv[chan][0] = Normalize(bv[0]);
	bumpv[chan][1] = Normalize(bv[1]);
	bumpv[chan][2] = Normalize(bv[2]);
	dP[0] = bumpv[chan][0];
	dP[1] = bumpv[chan][1];
	dP[2] = bumpv[chan][2];
}

//--------------------------------------------------------------------
// Computes the average curvature per unit surface distance in the face
//--------------------------------------------------------------------
float ComputeFaceCurvature(Point3 *n, Point3 *v, Point3 bc)
{
	Point3 nc = (n[0]+n[1]+n[2])/3.0f;
	Point3 dn0 = n[0]-nc;
	Point3 dn1 = n[1]-nc;
	Point3 dn2 = n[2]-nc;
	Point3 c = (v[0] + v[1] + v[2]) /3.0f;
	Point3 v0 = v[0]-c;
	Point3 v1 = v[1]-c;
	Point3 v2 = v[2]-c;
	float d0 = DotProd(dn0,v0)/LengthSquared(v0);
	float d1 = DotProd(dn1,v1)/LengthSquared(v1);
	float d2 = DotProd(dn2,v2)/LengthSquared(v2);
	float ad0 = (float)fabs(d0);
	float ad1 = (float)fabs(d1);
	float ad2 = (float)fabs(d2);
	return (ad0>ad1)? (ad0>ad2?d0:d2): ad1>ad2?d1:d2;
}

// This is an estimate of how fast the normal is varying.
// For example if you are doing enviornment mapping this value may be used to
// determine how big an area of the environment to sample.
// If the normal is changing very fast a large area must be sampled otherwise
// you'll get aliasing.  This is an estimate of dN/dsx, dN/dsy put into a
// single value.
float SContext::Curve()
{
	SCDebugPrint("SContext::Curve\n");

	Point3 tpos[3];
	Face &f = pInst->mesh->faces[faceNum];
	tpos[0] = pInst->mesh->verts[f.v[0]];
	tpos[1] = pInst->mesh->verts[f.v[1]];
	tpos[2] = pInst->mesh->verts[f.v[2]];
	float d = ComputeFaceCurvature(vxNormals,tpos,baryCoord);
	curve = d*RayDiam();
	return backFace?-curve:curve;
}




//***************************************************************************
// Background Context
// The is the ShadeContext we use for rendering environments
//***************************************************************************

BGContext::BGContext(CJRenderParams* rpar) { 
	//rp = rpar; (now in globContext)
	globContext = rpar;
	nLights = 0;
	doMaps = TRUE;
	filterMaps  = TRUE;
	shadow = FALSE; 
	cpos = BGGetPoint();
	viewDir = globContext->projType ?  Point3(0.0f,0.0f,-1.0f) : Normalize(cpos);
	backFace = FALSE;
	mtlNum  =0;
	scrDUV = rpar->scrDUV;
} 

void BGContext::SetScreenPos(int x, int y, int width, int height)
{
	SCDebugPrint("BGContext::SetScreenPos\n");
	iscr = IPoint2(x,y);
	scrPos.x = float(x)-globContext->xc;
	scrPos.y = float(y)-globContext->yc;

	cpos = BGGetPoint();
	viewDir = globContext->projType ?  Point3(0.0f,0.0f,-1.0f) : Normalize(cpos);
}

//-------------------------------------------------------------------
// BGGetPoint: returns a point along the current view ray at
// a very large distance from the camera, for applying fog to background.
Point3 BGContext::BGGetPoint(float z) {
	SCDebugPrint("BGContext::BGGetPoint\n");
	
	Point3 p;
	if (globContext->projType) {
		p.x = scrPos.x/globContext->xscale;
		p.y = scrPos.y/globContext->yscale;
		p.z = z;
	}
	else  {
		p.x = scrPos.x*z/globContext->xscale;
		p.y = scrPos.y*z/globContext->yscale;
		p.z = z;
	}
	return p;
}


void BGContext::ScreenUV(Point2& uv, Point2 &duv) {
	SCDebugPrint("BGContext::ScreenUV\n");
	Point2 p;
	p.x = .5f*(scrPos.x/globContext->xc + 1.0f);
	p.y = .5f*(-scrPos.y/globContext->yc + 1.0f);
	uv = p;
	duv = scrDUV;
}


Point3 BGContext::PointTo(const Point3& p, RefFrame ito) {
	SCDebugPrint("BGContext::PointTo\n");

	switch (ito) {
		case REF_WORLD:  return globContext->camToWorld*p;
		case REF_OBJECT: return p;
		default: return p;
	}		
}

Point3 BGContext::PointFrom(const Point3& p, RefFrame ifrom){ 
	SCDebugPrint("BGContext::PointFrom\n");

	switch (ifrom) {
		case REF_WORLD:  return globContext->worldToCam*p;
		case REF_OBJECT: return p;
		default: return p;
	}		
} 

Point3 BGContext::VectorTo(const Point3& p, RefFrame ito) {
	SCDebugPrint("BGContext::VectorTo\n");
	switch (ito) {
		case REF_WORLD:  return VectorTransform(globContext->camToWorld,p);
		case REF_OBJECT: return p;
		default: return p;
	}		
}

Point3 BGContext::VectorFrom(const Point3& p, RefFrame ifrom){ 
	SCDebugPrint("BGContext::VectorFrom\n");
	switch (ifrom) {
		case REF_WORLD:  return VectorTransform(globContext->worldToCam,p);
		case REF_OBJECT: return p;
		default: return p;
	}		
} 

//***************************************************************************
// RenderMapsContext
// The is the context needed to render AutoReflect, AutoMirror and RayTrace maps
//***************************************************************************

INode *CJRenderMapsContext::GetNode()
{
	return inst->pNode;
}

int CJRenderMapsContext::NodeRenderID()
{
	return inst->nodeID;
}

void CJRenderMapsContext::GetCurrentViewParams(ViewParams &vp)
{
	vp = cjr->view;
}

void CJRenderMapsContext::GetSubRendParams(SubRendParams &srp)
{
	srp.rendType	= cjr->rendParams.rendType;
	srp.fieldRender	= cjr->rendParams.bRenderFields;
	srp.evenLines	= 0;
	srp.doingMirror	= 0;
	srp.doEnvMap	= 0;
	srp.devWidth	= cjr->rendParams.devWidth;
	srp.devHeight	= cjr->rendParams.devHeight;
	srp.devAspect	= cjr->rendParams.devAspect;
	srp.xorg		= 0;
	srp.yorg		= 0;
	srp.xmin		= cjr->rendParams.nMinx;
	srp.xmax		= cjr->rendParams.nMaxx;
	srp.ymin		= cjr->rendParams.nMiny;
	srp.ymax		= cjr->rendParams.nMaxy;
}

int CJRenderMapsContext::SubMtlIndex()
{
	return subMtl;
}

void CJRenderMapsContext::SetSubMtlIndex(int mindex)
{
	subMtl = mindex;
}

void CJRenderMapsContext::FindMtlPlane(float pl[4])
{
}

void CJRenderMapsContext::FindMtlScreenBox(Rect &sbox, Matrix3* viewTM,int mtlIndex)
{
}

Box3 CJRenderMapsContext::CameraSpaceBoundingBox()
{
	return inst->camBox;
}

Box3 CJRenderMapsContext::ObjectSpaceBoundingBox()
{
	return Box3();// TBD
}

Matrix3 CJRenderMapsContext::ObjectToWorldTM()
{
	return inst->objToWorld;
}

RenderGlobalContext *CJRenderMapsContext::GetGlobalContext()
{
	return &cjr->rendParams;
}

int CJRenderMapsContext::Render(Bitmap *bm, ViewParams &vp, SubRendParams &srp, Point4 *clipPlanes, int nClipPlanes)
{
	CJRenderParams cjrp;
	// Setup ViewParams:
	cjrp.devWidth = srp.devWidth;
	cjrp.devHeight = srp.devHeight;
	cjrp.devAspect = srp.devAspect;
	cjrp.projType = cjr->rendParams.projType;

	cjrp.ComputeViewParams(vp);

	cjrp.nMinx = srp.xmin;
	cjrp.nMiny = srp.ymin;
	cjrp.nMaxx = srp.xmax;
	cjrp.nMaxy = srp.ymax;

	cjrp.renderer = cjr;



	return cjr->RenderImage(cjrp, cjr->rendParams.time, bm, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\combust\explode.cpp ===
/**********************************************************************
 *<
	FILE: explode.cpp

	DESCRIPTION: A fire/explosion atmospheric effect

	CREATED BY: Rolf Berteig

	HISTORY: 4-15-96

 *>	Copyright (c) 1996 Rolf Berteig, All Rights Reserved.
 **********************************************************************/

#include "inferno.h"
#include "imtl.h"
#include "render.h"  
#include <bmmlib.h>
#include "iparamm.h"
#include "texutil.h"
#include "gizmo.h"
#include "gizmoimp.h"
#include "istdplug.h"


static Class_ID volumeExplode(0x28b00147, 0x37c19db);

#define EXPLODE_CLASSNAME GetString(IDS_RB_COMBUSTION)

#define PBLOCK_REF	0
#define OBJECT_REF	1


#define SPHERE_GIZMO	0
#define CYL_GIZMO		1
#define BOX_GIZMO		2

class ExplodeDlgProc;

class ExplodeSource {
	public:
		Matrix3 tm;
		int hemi, type;
		Point3 seedPt;
		float radius, radius2, hemiRange, hemiLen;
		float width, length, height, height2;

		ExplodeSource(INode *node,SphereGizmoObject *obj,
			float drift, float rfact,
			TimeValue t, Interval &valid);
		ExplodeSource();
		float ComputeTaper(Point3 p);
	};

class ExplodeAtmos : public Atmospheric {
	public:
		// Parameters
		IParamBlock *pblock;  // Ref #0
		Tab<INode*> nodes;	  // Ref #1-n

		// Caches
		Tab<ExplodeSource> sources;		
		float stretch, regularity, drift, rfact;
		float density, scale, phase, levels;
		Color color1, color2, color3;
		int samples, invert;
		Interval valid;		
		CRITICAL_SECTION csect;

#ifndef DESIGN_VER
		float fury;
		int explode, smoke;
#endif

		static ExplodeDlgProc *dlg;

		ExplodeAtmos();
		~ExplodeAtmos() {DeleteCriticalSection(&csect);}

		void UpdateCaches(TimeValue t);

		// Animatable/Reference
		int NumSubs() {return 1;}
		Animatable* SubAnim(int i) {return pblock;}
		TSTR SubAnimName(int i) {return _T("");}
		int NumRefs();
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);
		Class_ID ClassID() {return volumeExplode;}
		void GetClassName(TSTR& s) {s=EXPLODE_CLASSNAME;}
		void DeleteThis() {delete this;}
		RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
	         PartID& partID,  RefMessage message);
		IOResult Load(ILoad *iload);
		IOResult Save(ISave *isave);

		// Atmospheric
		TSTR GetName() {return EXPLODE_CLASSNAME;}
		AtmosParamDlg *CreateParamDialog(IRendParams *ip);
		int RenderBegin(TimeValue t, ULONG flags);
		int RenderEnd(TimeValue t);
		void Update(TimeValue t, Interval& valid);
		void Shade(ShadeContext& sc,const Point3& p0,const Point3& p1,Color& color, Color& trans, BOOL isBG);

		int NumGizmos() {return nodes.Count();}
		INode *GetGizmo(int i) {return nodes[i];}
		void DeleteGizmo(int i);
		void InsertGizmo(int i, INode *node);
		void AppendGizmo(INode *node);
		BOOL OKGizmo(INode *node); // approve a node for possible use as gizmo
 		void EditGizmo(INode *node); // selects this gizmo & displays params for it if any

		void TraceExplosion(
			ExplodeSource &src, Ray ray, float len,
			Color &c, float &o);
	};

class ExplodeParamDlg : public AtmosParamDlg {
	public:
		ExplodeAtmos *atmos;
		IRendParams *ip;
		IParamMap *pmap;

		ExplodeParamDlg(ExplodeAtmos *a,IRendParams *i);
		Class_ID ClassID() {return volumeExplode;}
		ReferenceTarget* GetThing() {return atmos;}
		void SetThing(ReferenceTarget *m);		
		void DeleteThis();
	};


static Interval explodeIV(0,16000);

class ExplodeClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { return new ExplodeAtmos; }
	const TCHAR *	ClassName() { return EXPLODE_CLASSNAME; }
	SClass_ID		SuperClassID() { return ATMOSPHERIC_CLASS_ID; }
	Class_ID 		ClassID() { return volumeExplode; }
	const TCHAR* 	Category() { return _T("");  }
	void			ResetClassParams(BOOL fileReset) {explodeIV = Interval(0,16000);}
	};

static ExplodeClassDesc explodeCD;
ClassDesc* GetExplodeDesc() {return &explodeCD;}

#define PB_COLOR1			0
#define PB_COLOR2			1
#define PB_COLOR3			2
#define PB_FLAMETYPE		3
#define PB_STRETCH			4
#define PB_REGULARITY		5
#define PB_SCALE			6
#define PB_LEVELS			7
#define PB_DENSITY			8
#define PB_SAMPLES			9
#define PB_PHASE			10
#define PB_DRIFT			11

#ifndef DESIGN_VER
#define PB_EXPLODE			12
#define PB_SMOKE			13
#define PB_FURY				14
#endif

static int typeIDs[] = {IDC_EXPLODE_FIREBALL,IDC_EXPLODE_TENDRIL};

static ParamUIDesc descParam[] = {
	
	// Color 1
	ParamUIDesc(PB_COLOR1,TYPE_COLORSWATCH,IDC_EXPLODE_COLOR1),

	// Color 2
	ParamUIDesc(PB_COLOR2,TYPE_COLORSWATCH,IDC_EXPLODE_COLOR2),

	// Color 3
	ParamUIDesc(PB_COLOR3,TYPE_COLORSWATCH,IDC_EXPLODE_COLOR3),

	// Type
	ParamUIDesc(PB_FLAMETYPE,TYPE_RADIO,typeIDs,2),

	// Stretch
	ParamUIDesc(
		PB_STRETCH,
		EDITTYPE_FLOAT,
		IDC_EXPLODE_STRETCH,IDC_EXPLODE_STRETCHSPIN,
		0.0f,999999999.0f,
		0.1f),	
	
	// Regularity
	ParamUIDesc(
		PB_REGULARITY,
		EDITTYPE_FLOAT,
		IDC_EXPLODE_REG,IDC_EXPLODE_REGSPIN,
		0.0f,1.0f,
		0.01f),
		
	// Scale
	ParamUIDesc(
		PB_SCALE,
		EDITTYPE_FLOAT,
		IDC_EXPLODE_SCALE,IDC_EXPLODE_SCALESPIN,
		0.0f,999999999.0f,
		0.01f),
	
	// Levels
	ParamUIDesc(
		PB_LEVELS,
		EDITTYPE_FLOAT,
		IDC_EXPLODE_LEVELS,IDC_EXPLODE_LEVELSSPIN,
		1.0f,10.0f,
		0.01f),

	// Density
	ParamUIDesc(
		PB_DENSITY,
		EDITTYPE_FLOAT,
		IDC_EXPLODE_DENISITY,IDC_EXPLODE_DENISITYSPIN,
		0.0f,999999999.0f,
		0.1f),	

	// Samples
	ParamUIDesc(
		PB_SAMPLES,
		EDITTYPE_INT,
		IDC_EXPLODE_SAMPLES,IDC_EXPLODE_SAMPLESSPIN,
		1.0f,100.0f,
		0.5f),		

	// Phase
	ParamUIDesc(
		PB_PHASE,
		EDITTYPE_FLOAT,
		IDC_EXPLODE_PHASE,IDC_EXPLODE_PHASESPIN,
		0.0f,999999999.0f,
		0.01f),
	
	// Drift
	ParamUIDesc(
		PB_DRIFT,
		EDITTYPE_FLOAT,
		IDC_EXPLODE_DRIFT,IDC_EXPLODE_DRIFTSPIN,
		0.0f,999999999.0f,
		0.01f),

#ifndef DESIGN_VER
	// Explode
	ParamUIDesc(PB_EXPLODE,TYPE_SINGLECHEKBOX,IDC_EXPLODE_ON),

	// Smoke
	ParamUIDesc(PB_SMOKE,TYPE_SINGLECHEKBOX,IDC_EXPLODE_SMOKE),
	
	// Fury
	ParamUIDesc(
		PB_FURY,
		EDITTYPE_FLOAT,
		IDC_EXPLODE_FURY,IDC_EXPLODE_FURYSPIN,
		0.0f,999999999.0f,
		0.01f),	
#endif // !DESIGN_VER
	};

#ifndef DESIGN_VER
#define PARAMDESC_LENGH 15
#else
#define PARAMDESC_LENGH 12
#endif

static ParamBlockDescID descVer1[] = {
	// RB 2/15/99: These should be color controllers.
	{ TYPE_RGBA/*TYPE_POINT3*/,	NULL,	TRUE,	0 },	// color 1
	{ TYPE_RGBA/*TYPE_POINT3*/,	NULL,	TRUE,	1 },	// color 2
	{ TYPE_RGBA/*TYPE_POINT3*/,	NULL,	TRUE,	2 },	// color 3
	{ TYPE_INT,		NULL,	FALSE,	3 },	// type
	{ TYPE_FLOAT,	NULL,	TRUE,	4 },	// stretch
	{ TYPE_FLOAT,	NULL,	TRUE,	5 },	// regularity
	{ TYPE_FLOAT,	NULL,	TRUE,	6 },	// scale
	{ TYPE_FLOAT,	NULL,	TRUE,	7 },	// levels
	{ TYPE_FLOAT,	NULL,	TRUE,	8 },	// density	
	{ TYPE_INT,		NULL,	TRUE,	9 },	// samples	
	{ TYPE_FLOAT,	NULL,	TRUE,	10 },	// phase
	{ TYPE_FLOAT,	NULL,	TRUE,	11 },	// drift
#ifndef DESIGN_VER
	{ TYPE_INT,		NULL,	FALSE,	12 },	// explode
	{ TYPE_INT,		NULL,	FALSE,	13 },	// smoke
	{ TYPE_FLOAT,	NULL,	FALSE,	14 },	// fury
#endif // !DESIGN_VER
	};

#define CURRENT_DESCRIPTOR descVer1

#ifndef DESIGN_VER
#define PBLOCK_LENGTH	15
#else
#define PBLOCK_LENGTH   12
#endif

#define CURRENT_VERSION	1


//--- ExplodeDlgProc ----------------------------------------------------------

class ExplodeDlgProc : 
			public ParamMapUserDlgProc,
			public RendPickProc {
	public:
		IParamMap *pmap;
		ExplodeAtmos *atmos;
		IRendParams *ip;
		ICustButton *iPick, *iRemove;		
		ISpinnerControl *iFury;
		HWND hWnd;
		HFONT hFont;

		ExplodeDlgProc(IParamMap *pmap,ExplodeAtmos *v,IRendParams *i);
		
		void Init(HWND hWnd);		
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void DeleteThis();
		void UpdateNames();		
		void SetStates(HWND hWnd);
		void Invalidate() {pmap->Invalidate();}
		void SetupExplosion(HWND hWnd);

		// From RendPickProc
		BOOL Pick(INode *node);
		void Remove();
		BOOL Filter(INode *node);
		void EnterMode() {iPick->SetCheck(TRUE);}
		void ExitMode() {iPick->SetCheck(FALSE);}
		BOOL AllowMultiSelect() {return TRUE;}
	};

ExplodeDlgProc::ExplodeDlgProc(IParamMap *pmap,ExplodeAtmos *v,IRendParams *i) 
	{
	this->pmap = pmap;
	atmos   = v;
	ip      = i;
	iPick   = NULL;
	iFury   = NULL;
	iRemove = NULL;	
	atmos->dlg=this;
	}

void ExplodeDlgProc::DeleteThis() 
	{	
	atmos->dlg = NULL;
	ip->EndPickMode();
	ReleaseICustButton(iPick);
	ReleaseICustButton(iRemove);	
	ReleaseISpinner(iFury);
	DeleteObject(hFont);
	delete this;
	}

 // approve a node for possible use as gizmo
BOOL ExplodeAtmos::OKGizmo(INode *node) {	
	for (int i=0; i<nodes.Count(); i++) {
		if (nodes[i]==node) return FALSE;
		}
	ObjectState os = node->EvalWorldState(GetCOREInterface()->GetTime());
	if (os.obj->ClassID()==SPHEREGIZMO_CLASSID) return TRUE;
	if (os.obj->ClassID()==CYLGIZMO_CLASSID) return TRUE;
	if (os.obj->ClassID()==BOXGIZMO_CLASSID) return TRUE;
	return FALSE;
	}

 // selects this gizmo & displays params for it if any
void ExplodeAtmos::EditGizmo(INode *node) {
	for (int i=0; i<nodes.Count(); i++) {
		if ((nodes[i]==node)&&dlg) {
			SendMessage(GetDlgItem(dlg->hWnd,IDC_EXPLODE_OBJECTNAME),CB_SETCURSEL,i,0);
			}
		}
	}

void ExplodeAtmos::DeleteGizmo(int i)
	{
	if (theHold.Holding())
		theHold.Put(new DeleteGizmoRestore(this,nodes[i],i));
	theHold.Suspend();
	DeleteReference(i+OBJECT_REF);
	nodes.Delete(i,1);
	NotifyDependents(FOREVER, PART_ALL, REFMSG_SFX_CHANGE);
	if (dlg) dlg->UpdateNames();
	theHold.Resume();
	}

void ExplodeAtmos::InsertGizmo(int i, INode *node)
	{
	INode *nz = NULL;
	nodes.Insert(i, 1, &nz);
	ReplaceReference(i+OBJECT_REF,node);
	NotifyDependents(FOREVER, PART_ALL, REFMSG_SFX_CHANGE);
	if (dlg) dlg->UpdateNames();
	}

void ExplodeAtmos::AppendGizmo(INode *node)
	{
	theHold.Suspend();
	nodes.SetCount(nodes.Count()+1);
	nodes[nodes.Count()-1] = NULL;
	ReplaceReference(OBJECT_REF+nodes.Count()-1,node);
	if (dlg) dlg->UpdateNames();
	theHold.Resume();
	NotifyDependents(FOREVER, PART_ALL, REFMSG_SFX_CHANGE);
	if (theHold.Holding())
		theHold.Put(new AppendGizmoRestore(this,node));
	}

BOOL ExplodeDlgProc::Pick(INode *node)
	{
	theHold.Begin();
	atmos->AppendGizmo(node);
	theHold.Accept(GetString(IDS_DS_ADDGIZMO));
	return TRUE;
	}

void ExplodeDlgProc::Remove()
	{
	int sel = SendMessage(GetDlgItem(hWnd,IDC_EXPLODE_OBJECTNAME),CB_GETCURSEL,0,0);
	if (sel!=CB_ERR) {
		int c=0;
		for (int i=0; i<atmos->nodes.Count(); i++) {
			if (atmos->nodes[i]) {
				if (sel==c) {
					theHold.Begin();
					atmos->DeleteGizmo(i);
					theHold.Accept(GetString(IDS_DS_DELGIZMO));
//					atmos->DeleteReference(i+OBJECT_REF);
//					atmos->nodes.Delete(i,1);
//					UpdateNames();
					break;
					}
				c++;
				}
			}
		}
	}

BOOL ExplodeDlgProc::Filter(INode *node)
	{
	for (int i=0; i<atmos->nodes.Count(); i++) {
		if (atmos->nodes[i]==node) return FALSE;
		}
	ObjectState os = node->EvalWorldState(ip->GetTime());
	//return os.obj->ClassID()==SPHEREGIZMO_CLASSID;
	if (os.obj->ClassID()==SPHEREGIZMO_CLASSID) return TRUE;
	if (os.obj->ClassID()==CYLGIZMO_CLASSID) return TRUE;
	if (os.obj->ClassID()==BOXGIZMO_CLASSID) return TRUE;
	return FALSE;
	}

void ExplodeDlgProc::UpdateNames()
	{
	int c=0;
	SendMessage(GetDlgItem(hWnd,IDC_EXPLODE_OBJECTNAME),CB_RESETCONTENT,0,0);
	for (int i=0; i<atmos->nodes.Count(); i++) {
		if (atmos->nodes[i]) {
			c++;
			SendMessage(GetDlgItem(hWnd,IDC_EXPLODE_OBJECTNAME),
				CB_ADDSTRING,0,(LPARAM)(const TCHAR*)atmos->nodes[i]->GetName());
			}
		}
	SendMessage(GetDlgItem(hWnd,IDC_EXPLODE_OBJECTNAME),CB_SETCURSEL,0,0);
	if (c) {
		iRemove->Enable();
	} else {
		iRemove->Disable();
		}
	}

void ExplodeDlgProc::SetStates(HWND hWnd)
	{
#ifndef DESIGN_VER
	int explode;
	atmos->pblock->GetValue(PB_EXPLODE,0,explode,FOREVER);
	if (explode) {		
		iFury->Enable();
		EnableWindow(GetDlgItem(hWnd,IDC_EXPLODE_SMOKE),TRUE);
		EnableWindow(GetDlgItem(hWnd,IDC_EXPLODE_SETUPPHASE),TRUE);		
		EnableWindow(GetDlgItem(hWnd,IDC_EXPLODE_FURYLABEL),TRUE);		
	} else {		
		iFury->Disable();
		EnableWindow(GetDlgItem(hWnd,IDC_EXPLODE_SMOKE),FALSE);
		EnableWindow(GetDlgItem(hWnd,IDC_EXPLODE_SETUPPHASE),FALSE);		
		EnableWindow(GetDlgItem(hWnd,IDC_EXPLODE_FURYLABEL),FALSE);
		}
#endif // !DESIGN_VER
	}


void ExplodeDlgProc::Init(HWND hWnd)
	{
	this->hWnd = hWnd;
	iPick = GetICustButton(GetDlgItem(hWnd,IDC_EXPLODE_PICK));
	iPick->SetType(CBT_CHECK);
	iPick->SetHighlightColor(GREEN_WASH);
	iRemove = GetICustButton(GetDlgItem(hWnd,IDC_EXPLODE_REMOVE));	
	iFury   = GetISpinner(GetDlgItem(hWnd,IDC_EXPLODE_FURYSPIN));
	hFont   =  CreateFont(24,0,0,0,FW_BOLD,0,0,0,0,0,0,0, VARIABLE_PITCH | FF_SWISS, _T(""));
	SendDlgItemMessage(hWnd,IDC_INFERNO_TITLE,WM_SETFONT,(WPARAM)hFont,TRUE);
	UpdateNames();
	}


BOOL ExplodeDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,
		UINT msg,WPARAM wParam,LPARAM lParam)
	{
	switch (msg) {
		case WM_INITDIALOG:
			Init(hWnd);
			SetStates(hWnd);
			break;

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_EXPLODE_PICK:
					ip->SetPickMode(this);
					break;

				case IDC_EXPLODE_REMOVE:
					Remove();
					break;

				case IDC_EXPLODE_SETUPPHASE:
					SetupExplosion(hWnd);
					break;

				case IDC_EXPLODE_ON:
					SetStates(hWnd);
					break;
				}
			break;
		}
	
	return FALSE;
	}

static BOOL CALLBACK SetupExplodeDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	static Interval *range = NULL;

	switch (msg) {
		case WM_INITDIALOG: {
			range = (Interval*)lParam;
			ISpinnerControl *spin;
			spin = GetISpinner(GetDlgItem(hWnd,IDC_EXPLODE_STARTSPIN));
			spin->LinkToEdit(GetDlgItem(hWnd,IDC_EXPLODE_START),EDITTYPE_TIME);
			spin->SetLimits(TIME_NegInfinity,TIME_PosInfinity, FALSE);
			spin->SetValue(range->Start(),FALSE);
			spin->SetScale(10.0f);
			ReleaseISpinner(spin);

			spin = GetISpinner(GetDlgItem(hWnd,IDC_EXPLODE_ENDSPIN));
			spin->LinkToEdit(GetDlgItem(hWnd,IDC_EXPLODE_END),EDITTYPE_TIME);
			spin->SetLimits(TIME_NegInfinity,TIME_PosInfinity, FALSE);
			spin->SetValue(range->End(),FALSE);
			spin->SetScale(10.0f);
			ReleaseISpinner(spin);

			CenterWindow(hWnd, GetParent(hWnd));
			break;
			}

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDOK: {
					ISpinnerControl *spin;
					TimeValue start, end;
					spin  = GetISpinner(GetDlgItem(hWnd,IDC_EXPLODE_STARTSPIN));
					start = spin->GetIVal();
					ReleaseISpinner(spin);
					spin  = GetISpinner(GetDlgItem(hWnd,IDC_EXPLODE_ENDSPIN));
					end   = spin->GetIVal();
					ReleaseISpinner(spin);
					range->Set(start,end);
					EndDialog(hWnd,1);
					break;
					}

				case IDCANCEL:
					EndDialog(hWnd,0);
					break;
				}
			break;

		default:
			return FALSE;
		}
	return TRUE;
	}

void ExplodeDlgProc::SetupExplosion(HWND hWnd)
	{	
	if (!DialogBoxParam(
		hInstance,
		MAKEINTRESOURCE(IDD_EXPLODE_SETUP),
		hWnd,
		SetupExplodeDlgProc,
		(LONG)&explodeIV)) return;	
	
	// Create a fresh bezier float controller.
	Control *cont = (Control*)CreateInstance(
		CTRL_FLOAT_CLASS_ID,
		Class_ID(HYBRIDINTERP_FLOAT_CLASS_ID,0));
	if (!cont) return;
	IKeyControl *ikey = GetKeyControlInterface(cont);
	if (!ikey) {
		cont->DeleteThis();
		return;
		}
	
	// Setup a key structure with slow in and fast out tangents
	IBezFloatKey key;
	SetInTanType(key.flags,BEZKEY_SLOW);
	SetOutTanType(key.flags,BEZKEY_FAST);
	key.intan = key.outtan = 0.0f;

	// Make the first key
	key.val  = 0.0f;
	key.time = explodeIV.Start();
	ikey->AppendKey(&key);

	// Make the second key
	key.val  = 300.0f;
	key.time = explodeIV.End();
	ikey->AppendKey(&key);

	// Sort the table
	ikey->SortKeys();

	// Replace the controller in the param block with this controller.
	atmos->pblock->
		SetController(PB_PHASE,cont,FALSE);
	}

//--- ExplodeParamDlg -------------------------------------------------------

ExplodeParamDlg::ExplodeParamDlg(ExplodeAtmos *a,IRendParams *i) 
	{
	atmos = a;
	ip    = i;	
	pmap  = CreateRParamMap(
		descParam,PARAMDESC_LENGH,
		atmos->pblock,
		i,
		hInstance,
#ifndef DESIGN_VER
		MAKEINTRESOURCE(IDD_EXPLODE_PARAMS),
#else
		MAKEINTRESOURCE(IDD_VIZ_EXPLODE_PARAMS),
#endif
		GetString(IDS_RB_COMBUSTPARAMS),
		0);	
	
	pmap->SetUserDlgProc(new ExplodeDlgProc(pmap,atmos,ip));
	}

void ExplodeParamDlg::SetThing(ReferenceTarget *m)
	{
	assert(m->ClassID()==atmos->ClassID());
	atmos = (ExplodeAtmos*)m;
	pmap->SetParamBlock(atmos->pblock);	
	if (atmos->dlg) {
		atmos->dlg->atmos = atmos;
		atmos->dlg->UpdateNames();
		atmos->dlg->SetStates(atmos->dlg->hWnd);
		}
	}

void ExplodeParamDlg::DeleteThis()
	{
	DestroyRParamMap(pmap);
	delete this;
	}



//--- ExplodeAtmos -------------------------------------------------------

ExplodeDlgProc *ExplodeAtmos::dlg = NULL;

#define CF(c) (float(c)/float(255))

ExplodeAtmos::ExplodeAtmos()
	{
	InitializeCriticalSection(&csect);
	MakeRefByID(FOREVER, 0, 
		CreateParameterBlock(
			CURRENT_DESCRIPTOR, 
			PBLOCK_LENGTH, 
			CURRENT_VERSION));
	assert(pblock);		

	pblock->SetValue(PB_COLOR1,0,Point3(CF(252),CF(202),CF(  0)));
	pblock->SetValue(PB_COLOR2,0,Point3(CF(225),CF( 30),CF( 30)));	
	pblock->SetValue(PB_COLOR3,0,Point3(0.1,0.1,0.1));
	pblock->SetValue(PB_FLAMETYPE,0,0);
	pblock->SetValue(PB_STRETCH,0,1.0f);
	pblock->SetValue(PB_REGULARITY,0,0.2f);
	pblock->SetValue(PB_SCALE,0,35.0f);	
	pblock->SetValue(PB_LEVELS,0,3.0f);
	pblock->SetValue(PB_DENSITY,0,15.0f);	
	pblock->SetValue(PB_SAMPLES,0,15);			
	pblock->SetValue(PB_PHASE,0,0.0f);
	pblock->SetValue(PB_DRIFT,0,0.0f);
#ifndef DESIGN_VER
	pblock->SetValue(PB_EXPLODE,0,0);
	pblock->SetValue(PB_SMOKE,0,1);
	pblock->SetValue(PB_FURY,0,1.0f);
#endif // !DESIGN_VER
	valid.SetEmpty();
	}

#define NUMOBJECTS_CHUNK	0x0010

IOResult ExplodeAtmos::Load(ILoad *iload)
	{
	Atmospheric::Load(iload);

	ULONG nb;
	int num;
	IOResult res = IO_OK;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch (iload->CurChunkID()) {
			case NUMOBJECTS_CHUNK: {
				res = iload->Read(&num,sizeof(num),&nb);
				nodes.SetCount(num);
				for (int i=0; i<num; i++) nodes[i] = NULL;
				break;
				}
			}
		iload->CloseChunk();
		if (res!=IO_OK)  return res;
		}	
	
	return IO_OK;
	}

IOResult ExplodeAtmos::Save(ISave *isave)
	{
	Atmospheric::Save(isave);

	ULONG nb;
	int num = nodes.Count();
		
	isave->BeginChunk(NUMOBJECTS_CHUNK);
	isave->Write(&num,sizeof(num),&nb);
	isave->EndChunk();	
	
	return IO_OK;
	}

int ExplodeAtmos::NumRefs() 
	{
	return 1+nodes.Count();
	}

RefTargetHandle ExplodeAtmos::GetReference(int i) 
	{
	switch (i) {
		case PBLOCK_REF:	return pblock;		
		default:
			if (i>=OBJECT_REF) return nodes[i-OBJECT_REF];
			else return NULL;			
		}
	}

void ExplodeAtmos::SetReference(int i, RefTargetHandle rtarg) 
	{	
	switch (i) {
		case PBLOCK_REF:	pblock = (IParamBlock*)rtarg; break;
		default:
			if (i>=OBJECT_REF) 
				nodes[i-OBJECT_REF] = (INode*)rtarg; 
			break;
		}
	}
			
RefResult ExplodeAtmos::NotifyRefChanged(
		Interval changeInt, RefTargetHandle hTarget,
		PartID& partID,  RefMessage message) 
	{
	switch (message) {
		case REFMSG_TARGET_DELETED: {
			for (int i=0; i<nodes.Count(); i++) {
				if (hTarget==nodes[i]) {
					nodes[i] = NULL;					
					}
				}
			if (dlg) dlg->UpdateNames();
			break;
			}

		case REFMSG_CHANGE:
			valid.SetEmpty();
			if (dlg)
				dlg->Invalidate();
			break;

		case REFMSG_SUBANIM_STRUCTURE_CHANGED:
		case REFMSG_NODE_NAMECHANGE:
			if (dlg) dlg->UpdateNames();
			break;

		case REFMSG_GET_PARAM_DIM: {
			GetParamDim *gpd = (GetParamDim*)partID;
			switch (gpd->index) {			
				case PB_COLOR1: 	gpd->dim = stdColor255Dim; break;
				case PB_COLOR2: 	gpd->dim = stdColor255Dim; break;
				case PB_COLOR3: 	gpd->dim = stdColor255Dim; break;
				default: 			gpd->dim = defaultDim;
				}
			return REF_STOP; 
			}

		case REFMSG_GET_PARAM_NAME: {
			GetParamName *gpn = (GetParamName*)partID;
			switch (gpn->index) {				
				case PB_COLOR1:		gpn->name = GetString(IDS_RB_INNERCOLOR); break;
				case PB_COLOR2:		gpn->name = GetString(IDS_RB_OUTERCOLOR); break;
				case PB_COLOR3:		gpn->name = GetString(IDS_RB_SMOKECOLOR); break;
				case PB_STRETCH:	gpn->name = GetString(IDS_RB_STRETCH); break;
				case PB_REGULARITY:	gpn->name = GetString(IDS_RB_REGULARITY); break;
				case PB_SCALE:		gpn->name = GetString(IDS_RB_FLAMESIZE); break;
				case PB_LEVELS:		gpn->name = GetString(IDS_RB_FLAMEDETAIL); break;
				case PB_DENSITY:	gpn->name = GetString(IDS_RB_DENSITY); break;				
				case PB_PHASE:		gpn->name = GetString(IDS_RB_PHASE); break;
				case PB_DRIFT:		gpn->name = GetString(IDS_RB_DRIFT); break;
				case PB_FLAMETYPE:	gpn->name = GetString(IDS_RB_FLAMETYPE); break;
				case PB_SAMPLES:	gpn->name = GetString(IDS_RB_SAMPLES); break;
#ifndef DESIGN_VER
				case PB_EXPLODE:	gpn->name = GetString(IDS_RB_EXPLOSION); break;
				case PB_SMOKE:		gpn->name = GetString(IDS_RB_SMOKE); break;
				case PB_FURY:		gpn->name = GetString(IDS_RB_FURY); break;
#endif // !DESIGN_VER
				default:			gpn->name = _T("?????"); break;
				}
			return REF_STOP; 
			}
		}
	return REF_SUCCEED;
	}

AtmosParamDlg *ExplodeAtmos::CreateParamDialog(IRendParams *ip)
	{
	return new ExplodeParamDlg(this,ip);
	}

void ExplodeAtmos::UpdateCaches(TimeValue t)
	{		
	EnterCriticalSection(&csect);
	if (!valid.InInterval(t)) {
		valid = FOREVER;				
		pblock->GetValue(PB_COLOR1,t,color1,valid);
		pblock->GetValue(PB_COLOR2,t,color2,valid);
		pblock->GetValue(PB_COLOR3,t,color3,valid);
		pblock->GetValue(PB_FLAMETYPE,t,invert,valid);
		pblock->GetValue(PB_STRETCH,t,stretch,valid);
		pblock->GetValue(PB_REGULARITY,t,regularity,valid);
		pblock->GetValue(PB_SCALE,t,scale,valid);
		pblock->GetValue(PB_LEVELS,t,levels,valid);
		pblock->GetValue(PB_DENSITY,t,density,valid);
		pblock->GetValue(PB_SAMPLES,t,samples,valid);		
		pblock->GetValue(PB_PHASE,t,phase,valid);
		pblock->GetValue(PB_DRIFT,t,drift,valid);
#ifndef DESIGN_VER
		pblock->GetValue(PB_EXPLODE,t,explode,valid);
		pblock->GetValue(PB_SMOKE,t,smoke,valid);
		pblock->GetValue(PB_FURY,t,fury,valid);
#endif
		density /= 50.0f;
		if (scale != 0.0f) scale = 1.0f/scale;
		if (stretch !=0.0f) stretch = 1.0f/stretch;

#ifndef DESIGN_VER
		if (explode && (phase<0.0f || phase>300.0f)) {
			// Outside of explosion.
			rfact   = 0.0f;
			density = 0.0f;

		} else if (explode) {
			// In explosion			

			// First compute radius factor			
			rfact = (float)sqrt(phase/100.0f);

			// next density
			if (phase>100.0f) {
				float u = 1.0f - (phase-100.0f)/200.0f;				
				density *= (u*u * (3.0f - 2.0f*u));
				}

			// Interpolate to smoke color
			if (smoke) {
				if (phase>200.0f) {
					// Solid smoke
					color1 = color2 = color3;
				} else if (phase>100.0f) {
					// Interpolate to smoke color
					float u = (phase-100.0f)/100.0f;
					u = (u*u * (3.0f - 2.0f*u));
					color1 += color3*u - color1*u;
					color2 += color3*u - color2*u;
					}
				}

			// Convert phase to a reasonable value and
			// add in fury factor
			phase = float(sqrt(phase/75.0f))/2.0f * 5.0f * fury;
		
		} else 
#endif // !DESIGN_VER
		{			
			// Not doing an explosion
			rfact = 1.0f;
			phase = phase/300.0f * 5.0f;
			}
		
		}
	LeaveCriticalSection(&csect);
	}

int ExplodeAtmos::RenderBegin(TimeValue t,ULONG flags)
	{		
  	return 0;
	}

int ExplodeAtmos::RenderEnd(TimeValue t)
	{	
	sources.Resize(0);
	return 0;
	}


ExplodeSource::ExplodeSource(
		INode *node,SphereGizmoObject *obj, 
		float drift, float rfact,
		TimeValue t, Interval &valid)
	{
	int seed;
	//tm = Inverse(node->GetNodeTM(t,&valid));
	tm = Inverse(node->GetObjTMAfterWSM(t,&valid));

	if (obj->ClassID()==SPHEREGIZMO_CLASSID)
		type = SPHERE_GIZMO;
	else if (obj->ClassID()==CYLGIZMO_CLASSID)
		type = CYL_GIZMO;
	else if (obj->ClassID()==BOXGIZMO_CLASSID)
		type = BOX_GIZMO;
	
	switch (type) {
		case SPHERE_GIZMO:
			obj->pblock->GetValue(PB_GIZMO_RADIUS,t,radius,valid);
			obj->pblock->GetValue(PB_GIZMO_HEMI,t,hemi,valid);
			obj->pblock->GetValue(PB_GIZMO_SEED,t,seed,valid);
			radius   *= rfact;
			radius2   = radius*radius;
			hemiRange = radius/5.0f;
			hemiLen   = 2.0f*hemiRange;
			break;

		case CYL_GIZMO:
			obj->pblock->GetValue(PB_CYLGIZMO_RADIUS,t,radius,valid);
			obj->pblock->GetValue(PB_CYLGIZMO_HEIGHT,t,height,valid);
			obj->pblock->GetValue(PB_CYLGIZMO_SEED,t,seed,valid);
			radius *= rfact;
			radius2 = radius*radius;
			height2 = height*0.5f;
			break;

		case BOX_GIZMO:			
			obj->pblock->GetValue(PB_BOXGIZMO_LENGTH,t,length,valid);
			obj->pblock->GetValue(PB_BOXGIZMO_WIDTH, t,width,valid);
			obj->pblock->GetValue(PB_BOXGIZMO_HEIGHT,t,height,valid);
			obj->pblock->GetValue(PB_BOXGIZMO_SEED,t,seed,valid);			
			length *= 0.5f * rfact;
			width  *= 0.5f * rfact;
			height *= rfact;
			height2 = height*0.5f;
			break;
		}
			
	srand(seed);
	seedPt.x  = float(rand())/float(RAND_MAX) * 1000.0f;
	seedPt.y  = float(rand())/float(RAND_MAX) * 1000.0f;
	seedPt.z  = float(rand())/float(RAND_MAX) * 1000.0f;
	seedPt.z -= drift;
	}

float ExplodeSource::ComputeTaper(Point3 p)
	{
	switch (type) {
		case SPHERE_GIZMO: {
			float u = DotProd(p,p)/radius2;
			if (hemi) {
				//float u2 = 1.0f - p.z/radius;
				float u2 = 1.0f - (p.z + hemiRange)/hemiLen;
				if (u2>u) u = u2;
				}
			return u;
			}
		
		case CYL_GIZMO: {
			Point3 pp = p;			
			pp.z = 0.0f;
			float u  = DotProd(pp,pp)/radius2;
			float u2 = p.z/height2 - 1.0f;
			float u3 = -u2;
			if (u2>u) u = u2;
			if (u3>u) u = u3;
			return u;
			}

		case BOX_GIZMO: {
			float u2;
			float u  = (float)fabs(p.x/width);			
			u2 = (float)fabs(p.y/length);
			if (u2>u) u = u2;			
			u2 = (float)fabs(p.z/height2 - 1.0f);
			if (u2>u) u = u2;			
			return u;
			}
		}
	return 0.0f;
	}

void ExplodeAtmos::Update(TimeValue t, Interval& valid)
	{		
	UpdateCaches(t);
	sources.Resize(0);
	for (int i=0; i<nodes.Count(); i++) {
		if (!nodes[i]) continue;
		ObjectState os = nodes[i]->EvalWorldState(t);
		if (os.obj->ClassID()==SPHEREGIZMO_CLASSID ||
			os.obj->ClassID()==CYLGIZMO_CLASSID ||
			os.obj->ClassID()==BOXGIZMO_CLASSID ) {
			ExplodeSource es(
				nodes[i],
				(SphereGizmoObject*)os.obj,
				drift, rfact,
				t, valid);
			sources.Append(1,&es,10);
			}
		}
	}

// Basically a turbulence function
inline float NoiseFunc(
		Point3 p,float phase,float levels,int invert) {
	float sum = 0.0f;
	float l,f = 1.0f;
	for (l = levels; l>=1.0f; l-=1.0f) {
		sum += (float)fabs(noise4(p*f,phase))/f;
		f *= 2.0f;
		}
	if (l>0.0f)
		sum += l*(float)fabs(noise4(p*f,phase))/f;
	if (invert) {
		sum = 0.5f-sum;
		return sum>0.0f?sum:0.0f;
	} else {
		return sum;
		}
	}


#define Dx (ray.dir.x)
#define Dy (ray.dir.y)
#define Dz (ray.dir.z)
#define Px (ray.p.x)
#define Py (ray.p.y)
#define Pz (ray.p.z)

#define DIR(i) ray.dir[i]
#define POS(i)   ray.p[i]
#define BIGFLOAT 1.0e15f


inline BOOL IntersectSphere(
		Ray &ray,float &t0,float &t1,float r, int hemi, float hemiLen)
	{	
	float a, b, c, ac4, b2;
	float root;	

	a = DotProd(ray.dir,ray.dir);
	b = DotProd(ray.dir,ray.p) * 2.0f;
	c = DotProd(ray.p,ray.p) - r*r;
	
	ac4 = 4.0f * a * c;
	b2 = b*b;

	if (ac4 > b2) return FALSE;
	
	root = float(sqrt(b2-ac4));
	t0 = (-b + root) / (2.0f * a);
	t1 = (-b - root) / (2.0f * a);
	if (t0 > t1) {float temp=t0;t0=t1;t1=temp;}

	if (hemi) {
		int behind  = 0;	
		if (Pz + t0*Dz < -hemiLen) behind = 1;
		if (Pz + t1*Dz < -hemiLen) behind +=2;	
		switch (behind) { 		
			case 1: t0 = -(Pz+hemiLen)/Dz; 	break;  // intersect with plane z==-hemiRange
			case 2: t1 = -(Pz+hemiLen)/Dz; 	break;	// intersect with plane z==-hemiRange
			case 3: return FALSE;
			}
		}

	return TRUE;
	}

inline BOOL IntersectCyl(Ray &ray,float &t0,float &t1, float Rsq, float height) 
{
	// mjm - 1.21.99 - reworked function to handle cylinders with a negative height
	float A,B,C;
	A = (Dx*Dx + Dy*Dy);
	B = 2.0f*(Dx*Px + Dy*Py);
	C = Px*Px + Py*Py - Rsq;
	if (fabs(A)<.0000001) 
		return FALSE;
	float d = B*B-4.0f*A*C;
	if (d<0.0f) 
		return FALSE;
	float s = (float)sqrt(d);
	t0 = (-B + s)/(2.0f*A);
	t1 = (-B - s)/(2.0f*A);
	if (t0 < 0.0f && t1 < 0.0f)		// volume is totally behind camera
		return FALSE;

	if (t0 > t1)
		{ float temp=t0; t0=t1; t1=temp; }

	float cylBotZ(min(0.0f, height)), cylTopZ(max(0.0f, height)), rayNearZ(Pz + t0*Dz), rayFarZ(Pz + t1*Dz);

	if (rayNearZ > cylTopZ)
	{
		if (rayFarZ > cylTopZ)
			return FALSE;			// ray passes over top of cylinder
		else if (rayFarZ < cylBotZ)
			t1 = (cylBotZ-Pz)/Dz;	// far intersection with cylinder bottom
		t0 = (cylTopZ-Pz)/Dz;		// near intersection with cylinder top
	}
	else if (rayNearZ < cylBotZ)
	{
		if (rayFarZ > cylTopZ)
			t1 = (cylTopZ-Pz)/Dz;	// far intersection with cylinder top
		else if (rayFarZ < cylBotZ)
			return FALSE;			// ray passes under bottom of cylinder
		t0 = (cylBotZ-Pz)/Dz;		// near intersection with cylinder bottom
	}
	else							// near intersection with side of cylinder
	{
		if (rayFarZ > cylTopZ)
			t1 = (cylTopZ-Pz)/Dz;	// far intersection with cylinder top
		else if (rayFarZ < cylBotZ)
			t1 = (cylBotZ-Pz)/Dz;	// far intersection with cylinder top
	}

	return TRUE;
}

inline BOOL IntersectBox(Ray &ray,float &t0,float &t1, Box3& b) 
	{
	float q0 = -BIGFLOAT;
	float q1 =  BIGFLOAT;
	for (int i=0; i<3; i++) {
		if (DIR(i)==0.0f) {	// parallel to this pair of planes
			if ( POS(i)<b.pmin[i] || POS(i)>b.pmax[i] ) return FALSE;
			}
		else {
			float r0 = (b.pmin[i]-POS(i))/DIR(i);
			float r1 = (b.pmax[i]-POS(i))/DIR(i);
			if (r0 > r1) {float temp=r0; r0=r1; r1=temp;}
			if (r0 > q0) q0 = r0;					
			if (r1 < q1) q1 = r1;					
			if (q0>q1) return FALSE;   // missed box
			if (q1<0.0f) return FALSE; // Box is behind ray origin.
			}
		}
	t0 = q0;
	t1 = q1;
	return TRUE;
	}



void ExplodeAtmos::TraceExplosion(
		ExplodeSource &src, Ray ray, float len,
		Color &c, float &o)
	{
	float t0, t1, dist, dt, opac, u, n;
	Point3 dpt, pt, npt;

	// If the radius is 0, then there's nothing to do
	if (src.type==SPHERE_GIZMO && src.radius<=0.0f) return;

	// Transform the ray into object space;
	ray.p   = ray.p * src.tm;
	ray.dir = VectorTransform(src.tm,ray.dir);

	// Intersect the ray with the explosion sphere
#ifdef OLDWAY
	if (!IntersectSphere(
		ray, t0, t1, src.radius)) return;
#else
	// Intersect it with the gizmo
	switch (src.type) {
		case CYL_GIZMO:
			if (!IntersectCyl(ray,t0,t1,src.radius2,src.height)) {
				return;
				}
			break;
		
		case BOX_GIZMO: {
			Box3 b;
			b.pmin = Point3(-src.width,-src.length, 0.0f);
			b.pmax = Point3( src.width, src.length, src.height);
			if (!IntersectBox(ray,t0,t1,b)) {
				return;
				}
			break;
			}

		case SPHERE_GIZMO:							
			if (!IntersectSphere(ray,t0,t1,src.radius,src.hemi,src.hemiLen)) {
				return;
				}
			break;
		}
#endif

	// We may be inside the sphere
	if (t0<0.0f) t0 = 0.0f;
	if (t1>len)  t1 = len;

	// The sphere may be in front, out of reach
	if (t0>len)
		return;

	// The sphere may be behind us
	if (t1<0.0f)
		return;
	 
	// Setup everything
	dist = t1-t0;
	dt   = dist/float(samples);
	pt   = ray.p + t0*ray.dir;
	dpt  = ray.dir * dt;

	// March along the ray
	for (int i=0; i<samples; i++,pt += dpt) {
		
#ifdef OLDWAY
		// Below the hemisphere range
		if (src.hemi && pt.z<-src.hemiRange) continue;

		// Distance from the origin
		u = DotProd(pt,pt)/src.radius2;		

		// Check hemisphere
		if (src.hemi && pt.z<src.hemiRange) {			
			// Use the falloff due to the hemisphere if
			// it's larger.
			float u2 = 1.0f-(pt.z + src.hemiRange)/src.hemiLen;
			if (u2>u) u = u2;
			}
#else
		// Compute percentage toward edge of volume		
		u = src.ComputeTaper(pt);		
#endif

		// Noise at this point
		npt = pt + src.seedPt; // offset by seed point
		npt.z *= stretch;      // apply stretch factor
		npt   *= scale;        // apply scaling
		n = NoiseFunc(npt,phase,levels,invert);
		
		// Make the noise more sparse as we reach the outer
		// parts of the explosion.
		if (u>regularity) {
			n -= u-regularity;
			if (n<0.0f) n = 0.0f;
			}

		// Compute opacity of this segment
		opac = (1.0f-u)*n*dt*density;

		// Add to color
		c += (color1*n + (1.0f-n)*color2)*opac;

		// Add to opacity
		o += opac;
		}
	}

void ExplodeAtmos::Shade(
		ShadeContext& sc,const Point3& p0,const Point3& p1,
		Color& color, Color& trans, BOOL isBG)
	{
	if (sc.ProjType()==PROJ_PARALLEL) return;
	if (!sources.Count()) return;
	UpdateCaches(sc.CurTime());	

	if (density<=0.0f) return;

	Point3 wp0, wp1, v;
	float len;
	Ray ray;

	// Setup the ray
	wp0   = sc.PointTo(p0,REF_WORLD);
	wp1   = sc.PointTo(p1,REF_WORLD);
	ray.p = wp0;
	v     = wp1-wp0;
	len   = Length(v);
	if (len==0.0f) return;
	ray.dir = v/len;

	// Start out color is clear and black
	Color c;
	c.Black();
	float o = 0.0f;

	// Trace each explosion sphere
	for (int i=0; i<sources.Count(); i++) {
		TraceExplosion(sources[i],ray,len,c,o);
		}

	// Exponentiate
	c.r = 1.0f - (float)exp(-c.r);
	c.g = 1.0f - (float)exp(-c.g);
	c.b = 1.0f - (float)exp(-c.b);
	o   = 1.0f - (float)exp(-o);
	
	// Combine with incoming color.
	color += c-(color*o);
	trans *= 1.0f-o;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\combust\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by inferno.rc
//
#define IDS_RB_ATMOSAPPARATUS           1
#define IDS_RB_COMBUSTPARAMS            2
#define IDS_RB_CMBRADIUS                3
#define IDS_RB_CMBPARAMETER             4
#define IDS_RB_COMBUSTION               5
#define IDS_RB_INNERCOLOR               6
#define IDS_RB_OUTERCOLOR               7
#define IDS_RB_SMOKECOLOR               8
#define IDS_RB_STRETCH                  9
#define IDS_RB_REGULARITY               10
#define IDS_RB_FLAMESIZE                11
#define IDS_RB_FLAMEDETAIL              12
#define IDS_RB_DENSITY                  13
#define IDS_RB_PHASE                    14
#define IDS_RB_DRIFT                    15
#define IDS_RB_COMBUST_INFO             16
#define IDS_RB_FLAMETYPE                17
#define IDS_RB_SAMPLES                  18
#define IDS_RB_EXPLOSION                19
#define IDS_RB_SMOKE                    20
#define IDS_RB_FURY                     21
#define IDS_DS_ADDGIZMO                 22
#define IDS_DS_DELGIZMO                 23
#define IDD_DIALOG1                     101
#define IDD_EDTRI_OBJECT                101
#define IDD_EDTRI_VERTEX                102
#define IDC_EXTRUDECUR                  102
#define IDD_EXPLODE_GIZMO               102
#define IDD_EDTRI_EDGE                  103
#define IDB_FACESELTYPES                103
#define IDD_EXPLODE_SETUP               103
#define IDD_EDTRI_FACE                  104
#define IDB_MASK_FACESELTYPES           104
#define IDD_EXPLODE_ABOUT               104
#define IDD_EDTRI_SURFACE               105
#define IDD_DETACH                      109
#define IDC_ADDVERTCUR                  119
#define IDD_AFFECTREGION                128
#define IDD_EM_SELECTBYMAT              137
#define IDD_EM_SELECTBYSMOOTH           143
#define IDD_EXPLODE_PARAMS              187
#define IDD_EXPLODE_PARAMS_OLD          188
#define IDD_VIZ_EXPLODE_PARAMS          188
#define IDC_EDTRI_ATTACH                1000
#define IDC_EDTRI_DELETE                1001
#define IDC_EXPLODE_INVERT              1002
#define IDC_EXPLODE_TENDRAL             1003
#define IDC_EXPLODE_TENDRIL             1003
#define IDC_EXPLODE_FIREBALL            1004
#define IDC_EXPLODE_SETUPPHASE          1005
#define IDC_EXPGIZMO_RADIUS             1006
#define IDC_EXPGIZMO_RADIUSSPIN         1007
#define IDC_EXPGIZMO_HEMI               1008
#define IDC_EXPGIZMO_SEED               1009
#define IDC_EXPGIZMO_SEEDSPIN           1010
#define IDC_EXPGIZMO_NEWSEED            1011
#define IDC_EXPLODE_ON                  1012
#define IDC_EXPLODE_SMOKE               1013
#define IDC_EXPLODE_FURYLABEL           1014
#define IDC_EXPLODE_START               1015
#define IDC_EXPLODE_STARTSPIN           1016
#define IDC_EXPLODE_END                 1017
#define IDC_EXPLODE_ABOUT               1017
#define IDC_EXPLODE_ENDSPIN             1018
#define IDC_INFERNO_TITLE               1018
#define IDC_TESSELLATE                  1027
#define IDC_AFFECTREGION                1028
#define IDC_EXPLODE                     1028
#define IDC_BACKFACE_VERTS              1029
#define IDC_WELDTHRESH                  1030
#define IDC_EXTRUDEAMOUNT               1033
#define IDC_EXTRUDESPINNER              1034
#define IDC_PLANARSPINNER               1035
#define IDC_SMOOTH_THRESHSPIN           1035
#define IDC_TES_EDGE                    1036
#define IDC_SMOOTH_THRESH               1036
#define IDC_TES_CENTER                  1037
#define IDC_NORMAL_SCALESPIN            1037
#define IDC_TENSIONSPINNER              1038
#define IDC_NORMAL_SCALE                1038
#define IDC_TENSION                     1039
#define IDC_MAT_IDSPIN                  1039
#define IDC_EXTRUDE                     1040
#define IDC_MAT_ID                      1040
#define IDC_PLANAR                      1041
#define IDC_EDITCURVE                   1042
#define IDC_COLLAPSE                    1042
#define IDC_MAKEPLANAR                  1043
#define IDC_BUILDFACE                   1044
#define IDC_SELTYPE                     1045
#define IDC_ANGLETHRESHSPIN             1046
#define IDC_ANGLETRESH                  1047
#define IDC_DELETEFACE                  1048
#define IDC_FACE_HIDE                   1049
#define IDC_FACE_UNHIDEALL              1050
#define IDC_DETACH_NAME                 1055
#define IDC_SMOOTH_GRP1                 1064
#define IDC_SMOOTH_GRP2                 1065
#define IDC_SMOOTH_GRP3                 1066
#define IDC_SMOOTH_GRP4                 1067
#define IDC_SMOOTH_GRP5                 1068
#define IDC_SMOOTH_GRP6                 1069
#define IDC_SMOOTH_GRP7                 1070
#define IDC_SMOOTH_GRP8                 1071
#define IDC_SMOOTH_GRP9                 1072
#define IDC_SMOOTH_GRP10                1073
#define IDC_SMOOTH_GRP11                1074
#define IDC_VERT_DELETE                 1075
#define IDC_SMOOTH_GRP12                1075
#define IDC_VERT_CREATE                 1076
#define IDC_SMOOTH_GRP13                1076
#define IDC_VERT_COLLAPSE               1077
#define IDC_EXP_OBJECTS                 1077
#define IDC_SMOOTH_GRP14                1077
#define IDC_VERT_DETACH                 1078
#define IDC_EXP_ELEMENTS                1078
#define IDC_SMOOTH_GRP15                1078
#define IDC_OBJ_ATTACH                  1079
#define IDC_SMOOTH_GRP16                1079
#define IDC_EDGE_DIVIDE                 1080
#define IDC_SMOOTH_GRP17                1080
#define IDC_VERT_WELD                   1081
#define IDC_EDGE_TURN                   1081
#define IDC_SMOOTH_GRP18                1081
#define IDC_VERT_WELDTOVERT             1082
#define IDC_EDGE_VIS                    1082
#define IDC_SMOOTH_GRP19                1082
#define IDC_EDGE_INVIS                  1083
#define IDC_SMOOTH_GRP20                1083
#define IDC_WELDTHRESHSPIN              1084
#define IDC_EDGE_AUTO                   1084
#define IDC_SMOOTH_GRP21                1084
#define IDC_FACE_DETACH                 1085
#define IDC_EDGE_DELETE                 1085
#define IDC_SMOOTH_GRP22                1085
#define IDC_EDGE_COLLAPSE               1086
#define IDC_SMOOTH_GRP23                1086
#define IDC_FALLOFF                     1086
#define IDC_SMOOTH_GRP24                1087
#define IDC_FALLOFFSPIN                 1087
#define IDC_SMOOTH_GRP25                1088
#define IDC_PINCHSPIN                   1088
#define IDC_SMOOTH_GRP26                1089
#define IDC_PINCH                       1089
#define IDC_SMOOTH_GRP27                1090
#define IDC_BUBBLESPIN                  1090
#define IDC_SMOOTH_GRP28                1091
#define IDC_BUBBLE                      1091
#define IDC_SMOOTH_GRP29                1092
#define IDC_NEARLABEL                   1092
#define IDC_SMOOTH_GRP30                1093
#define IDC_FARLEFTLABEL                1093
#define IDC_SMOOTH_GRP31                1094
#define IDC_FARRIGHTLABEL               1094
#define IDC_SMOOTH_GRP32                1095
#define IDC_AR_GRAPH                    1095
#define IDC_TENSTEXT                    1096
#define IDC_SMOOTH_AUTO                 1196
#define IDC_NORMAL_FLIP                 1197
#define IDC_NORMAL_UNIFY                1198
#define IDC_NORMAL_SHOW                 1199
#define IDC_SELECT_BYID                 1200
#define IDC_CLEARSELECTION              1200
#define IDC_SELECTBYSMOOTH              1201
#define IDC_VERT_HIDE                   1252
#define IDC_VERT_UNHIDEALL              1253
#define IDC_SEL_BYVERT                  1256
#define IDC_EXPLODE_COLOR1              1456
#define IDC_EXPLODE_DENISITY            1457
#define IDC_EXPLODE_DENISITYSPIN        1458
#define IDC_EXPLODE_PICK                1459
#define IDC_EXPLODE_COLOR2              1460
#define IDC_EXPLODE_COLOR3              1461
#define IDC_EXPLODE_SCALE               1463
#define IDC_EXPLODE_SCALESPIN           1464
#define IDC_EXPLODE_REMOVE              1469
#define IDC_EXPLODE_OBJECTNAME          1476
#define IDC_EXPLODE_SAMPLES             1485
#define IDC_EXPLODE_LEVELS              1486
#define IDC_EXPLODE_PHASE               1487
#define IDC_EXPLODE_REG                 1488
#define IDC_EXPLODE_SIZE                1489
#define IDC_EXPLODE_SHIFT               1489
#define IDC_EXPLODE_STRETCH             1490
#define IDC_EXPLODE_SAMPLESSPIN         1491
#define IDC_EXPLODE_LEVELSSPIN          1492
#define IDC_EXPLODE_PHASESPIN           1493
#define IDC_EXPLODE_REGSPIN             1494
#define IDC_EXPLODE_SIZESPIN            1495
#define IDC_EXPLODE_SHIFTSPIN           1495
#define IDC_EXPLODE_STRETCHSPIN         1496
#define IDC_EXPLODE_FURY                1497
#define IDC_EXPLODE_FURYSPIN            1498
#define IDC_EXPLODE_DRIFT               1499
#define IDC_EXPLODE_DRIFTSPIN           1500
#define IDS_RB_OBJECT                   30004
#define IDS_RB_VERTEX                   30011
#define IDS_RB_FACE                     30012
#define IDS_RB_EDGE                     30013
#define IDS_RB_EDITVERTEX               30016
#define IDS_RB_EDITOBJECT               30017
#define IDS_RB_EDITFACE                 30018
#define IDS_RB_EDITEDGE                 30019
#define IDS_RB_EDITPOLY                 30020
#define IDS_RB_EDITELEMENT              30021
#define IDS_RB_DELETEVERT               30211
#define IDS_RB_DELETEFACE               30212
#define IDS_RB_ADDVERTS                 30213
#define IDS_RB_ATTACHOBJECT             30214
#define IDS_RB_FACECOLLAPSE             30215
#define IDS_RB_MAKEPLANAR               30216
#define IDS_RB_BUILDFACE                30217
#define IDS_RB_HIDEFACE                 30218
#define IDS_RB_UNHIDEALLFACES           30219
#define IDS_RB_EDGEVISIBLE              30220
#define IDS_RB_EDGEINVISIBLE            30221
#define IDS_RB_AUTOEDGE                 30222
#define IDS_RB_EDGEDIVIDE               30223
#define IDS_RB_EDGETURN                 30224
#define IDS_RB_DELETEEDGE               30225
#define IDS_RB_COLLAPSEEDGE             30226
#define IDS_RB_CLONE                    30227
#define IDS_RB_TESSELLATE               30228
#define IDS_RB_DELETEISOLATED           30229
#define IDS_RB_EDITSURFACE              30279
#define IDS_RB_SETSMOOTHGROUP           30280
#define IDS_RB_ASSIGNMATID              30281
#define IDS_RB_FLIPNORMALS              30282
#define IDS_RB_UNIFYNORMALS             30283
#define IDS_RB_AUTOSMOOTH               30284
#define IDS_RB_SELECTBYMATID            30285
#define IDS_RB_SELECTBYSMOOTH           30286
#define IDS_RB_HIDEVERT                 30294
#define IDS_RB_COLLAPSE                 30630
#define IDS_RB_WELDVERTS                30631
#define IDS_RB_NOVERTSTOWELD            30680
#define IDS_RB_EDITABLEOBJECTS          30684
#define IDS_RB_EDITABLEMESH             30685
#define IDS_RB_DUPFACEWARNING           30687

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        105
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1019
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\cjrender\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by cjrender.rc
//
#define IDS_YES                         1
#define IDS_NO                          2
#define IDS_LIB_DESCRIPTION             3
#define IDD_CCJRENDERDLG                101
#define IDD_CCJRENDERDLG_PROG           102
#define IDC_AA_NONE                     1001
#define IDC_AA_MEDIUM                   1002
#define IDC_AA_HIGH                     1003
#define IDC_REFLENV                     1004
#define IDC_ANTIALIAS                   1005
#define IDC_PROG_DEPTH                  1006
#define IDC_PROG_ANTIALIAS              1007
#define IDC_PROG_REFLENV                1008
#define IDC_DEPTH                       1109
#define IDC_DEPTH_SPIN                  1110

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1011
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\combust\inferno.cpp ===
/**********************************************************************
 *<
	FILE: inferno.cpp

	DESCRIPTION: DllMain is in here

	CREATED BY: Rolf Berteig

	HISTORY: created 4/15/96

 *>	Copyright (c) 1996 Rolf Berteig, All Rights Reserved.
 **********************************************************************/

#include "inferno.h"

HINSTANCE hInstance;
static int controlsInit = FALSE;


/** public functions **/
BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) {
	hInstance = hinstDLL;

	if (!controlsInit) {
		controlsInit = TRUE;		
		
		// MAXontrols
		InitCustomControls(hInstance);
		
		// initialize Chicago controls
		InitCommonControls();		
		}	

	return(TRUE);
	}


//------------------------------------------------------
// This is the interface to MAX
//------------------------------------------------------

__declspec( dllexport ) const TCHAR *
LibDescription() { return GetString(IDS_RB_COMBUST_INFO); }

/// MUST CHANGE THIS NUMBER WHEN ADD NEW CLASS
__declspec( dllexport ) int LibNumberClasses() {return 1;}


__declspec( dllexport ) ClassDesc*
LibClassDesc(int i) {
	switch(i) {
		case 0: return GetExplodeDesc();		
		default: return 0;
		}

	}

// Return version so can detect obsolete DLLs
__declspec( dllexport ) ULONG 
LibVersion() { return VERSION_3DSMAX; }


TCHAR *GetString(int id)
	{
	static TCHAR buf[256];

	if (hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Control\attach.cpp ===
/**********************************************************************
 *<
	FILE: attach.cpp

	DESCRIPTION: Attachment controller

	CREATED BY: Rolf Berteig

	HISTORY: 11/18/96

 *>	Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/
#include "ctrl.h"
#include "units.h"
#include "tcbgraph.h"


#define ATTACH_CONTROL_CLASS_ID		Class_ID(0xbb27e611,0xa72f43e7)
#define ATTACH_CONTROL_CNAME		GetString(IDS_RB_ATTACHCONTROL)

static void ComputeHermiteBasis(float u, float *v);
static float Ease(float u, float a, float b);

class AKey {
	public:		
		TimeValue time;
		DWORD flags;
		DWORD face;		
		float u0, u1;
		float tens, cont, bias, easeIn, easeOut;
		
		Point3 pos, norm, din, dout;
		Quat quat, qa, qb;

		AKey() {
			flags=0; face=0; u0=u1=tens=cont=bias=easeIn=easeOut=0.0f;
			pos=din=dout=Point3(0,0,0);
			norm=Point3(1,0,0);
			quat=qa=qb=IdentQuat();
			}		
		AKey &operator=(AKey &k) {
			time    = k.time;
			flags	= k.flags;
			face	= k.face;
			u0		= k.u0;
			u1		= k.u1;
			tens	= k.tens;
			cont	= k.cont;
			bias	= k.bias;
			easeIn	= k.easeIn;
			easeOut	= k.easeOut;

			pos  = k.pos;
			din  = k.din;
			dout = k.dout;
			norm = k.norm;
			quat = k.quat;
			qa   = k.qa;
			qb   = k.qb;
			return *this;
			}

	};

#define KEY_SELECTED	(1<<0)
#define KEY_FLAGGED		(1<<1)

class AttachCtrl;

class PickObjectMode : 
		public PickModeCallback,
		public PickNodeCallback {
	public:		
		AttachCtrl *cont;
		
		PickObjectMode(AttachCtrl *c) {cont=c;}
		BOOL HitTest(IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags);
		BOOL Pick(IObjParam *ip,ViewExp *vpt);
		void EnterMode(IObjParam *ip);
		void ExitMode(IObjParam *ip);
		BOOL RightClick(IObjParam *ip,ViewExp *vpt)	{return TRUE;}
		BOOL Filter(INode *node);		
		PickNodeCallback *GetFilter() {return this;}
	};

#define CID_SETPOS 0x938ff27a

class SetPosMouseProc : public MouseCallBack {
	public:
		AttachCtrl *cont;
		IObjParam *ip;
		SetPosMouseProc(AttachCtrl *c,IObjParam *i) {cont=c;ip=i;}
		int proc(HWND hWnd, int msg, int point, int flags, IPoint2 m);		
		void SetPos(HWND hWnd,IPoint2 m);
	};

class SetPosCMode : public CommandMode {
	public:
		ChangeFGObject fgProc;
		SetPosMouseProc proc;
		IObjParam *ip;
		AttachCtrl *cont;

		SetPosCMode(AttachCtrl *c,IObjParam *i) 
			: fgProc((ReferenceTarget*)c), proc(c,i) {ip=i;cont=c;}

		int Class() {return MOVE_COMMAND;}		
		int ID() {return CID_SETPOS;}
		MouseCallBack *MouseProc(int *numPoints) {*numPoints=2;return &proc;}
		ChangeForegroundCallback *ChangeFGProc() {return &fgProc;}
		BOOL ChangeFG(CommandMode *oldMode) {return oldMode->ChangeFGProc() != &fgProc;}
		void EnterMode();
		void ExitMode();
	};


class AttachCtrl : public StdControl, public TimeChangeCallback {
	public:
		// Controller data
		Tab<AKey> keys;
		INode *node;
		BOOL rangeLinked, align, manUpdate;

		// Current value cache
		Interval range, valid;
		Point3 val;
		Quat qval;
		BOOL trackValid, doManUpdate;

		static HWND hWnd;
		static IObjParam *ip;
		static AttachCtrl *editCont;
		static BOOL uiValid;
		static ISpinnerControl *iTime, *iFace, *iA, *iB, *iTens, *iCont, *iBias, *iEaseTo, *iEaseFrom;
		static ICustButton *iPickOb, *iSetPos, *iPrev, *iNext, *iUpdate;
		static ICustStatus *iStat;
		static int index;
		static PickObjectMode *pickObMode;
		static SetPosCMode *setPosMode;

		AttachCtrl();

		// Animatable methods
		void DeleteThis() {delete this;}		
		int IsKeyable() {return 1;}
		BOOL IsAnimated() {return keys.Count()?TRUE:FALSE;}
		Class_ID ClassID() {return ATTACH_CONTROL_CLASS_ID;}
		SClass_ID SuperClassID() {return CTRL_POSITION_CLASS_ID;}
		void GetClassName(TSTR& s) {s = ATTACH_CONTROL_CNAME;}
		void BeginEditParams(IObjParam *ip, ULONG flags,Animatable *prev); 
		void EndEditParams(IObjParam *ip, ULONG flags,Animatable *next); 

		// Reference methods
		RefResult NotifyRefChanged(Interval, RefTargetHandle, PartID&, RefMessage);
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);
		RefTargetHandle Clone(RemapDir &remap = NoRemap());
		int NumRefs() {return Control::NumRefs()+1;};	
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);

		// Control methods				
		void Copy(Control *from);
		BOOL IsLeaf() {return TRUE;}
		void CommitValue(TimeValue t) {}
		void RestoreValue(TimeValue t) {}
				
		// Animatable methods
		Interval GetTimeRange(DWORD flags);
		void EditTimeRange(Interval range,DWORD flags);
		void MapKeys(TimeMap *map,DWORD flags );		
		int NumKeys() {return keys.Count();}
		TimeValue GetKeyTime(int index) {return keys[index].time;}
		int GetKeyIndex(TimeValue t);		
		void DeleteKeyAtTime(TimeValue t);
		BOOL IsKeyAtTime(TimeValue t,DWORD flags);				
		int GetKeyTimes(Tab<TimeValue> &times,Interval range,DWORD flags);
		int GetKeySelState(BitArray &sel,Interval range,DWORD flags);
		BOOL GetNextKeyTime(TimeValue t,DWORD flags,TimeValue &nt);
		void DeleteTime(Interval iv, DWORD flags);
		void ReverseTime(Interval iv, DWORD flags);
		void ScaleTime(Interval iv, float s);
		void InsertTime(TimeValue ins, TimeValue amount);
		BOOL SupportTimeOperations() {return TRUE;}
		void DeleteKeys(DWORD flags);
		void DeleteKeyByIndex(int index);
		void SelectKeys(TrackHitTab& sel, DWORD flags);
		void SelectKeyByIndex(int i,BOOL sel);
		void FlagKey(TrackHitRecord hit);
		int GetFlagKeyIndex();
		int NumSelKeys();
		void CloneSelectedKeys(BOOL offset=FALSE);
		void AddNewKey(TimeValue t,DWORD flags);		
		BOOL IsKeySelected(int index);
		BOOL CanCopyTrack(Interval iv, DWORD flags) {return TRUE;}
		BOOL CanPasteTrack(TrackClipObject *cobj,Interval iv, DWORD flags) {return cobj->ClassID()==ClassID();}
		TrackClipObject *CopyTrack(Interval iv, DWORD flags);
		void PasteTrack(TrackClipObject *cobj,Interval iv, DWORD flags);
		int HitTestTrack(			
			TrackHitTab& hits,
			Rect& rcHit,
			Rect& rcTrack,			
			float zoom,
			int scroll,
			DWORD flags);
		int PaintTrack(
			ParamDimensionBase *dim,
			HDC hdc,
			Rect& rcTrack,
			Rect& rcPaint,
			float zoom,
			int scroll,
			DWORD flags);
		void EditTrackParams(
			TimeValue t,
			ParamDimensionBase *dim,
			TCHAR *pname,
			HWND hParent,
			IObjParam *ip,
			DWORD flags);
		int TrackParamsType() {return TRACKPARAMS_KEY;}

		// StdControl methods
		void GetValueLocalTime(TimeValue t, void *val, Interval &valid, GetSetMethod method=CTRL_ABSOLUTE) {}
		void GetValue(TimeValue t, void *val, Interval &valid, GetSetMethod method=CTRL_ABSOLUTE);
		void SetValueLocalTime(TimeValue t, void *val, int commit, GetSetMethod method) {}
		void Extrapolate(Interval range,TimeValue t,void *val,Interval &valid,int type) {}
		void *CreateTempValue() {return new Point3;}
		void DeleteTempValue(void *val) {delete (Point3*)val;}
		void ApplyValue(void *val, void *delta) {((Matrix3*)val)->PreTranslate(*((Point3*)delta));}
		void MultiplyValue(void *val, float m) {*((Point3*)val) *= m;}

		// TimeChangedCallback
		void TimeChanged(TimeValue t) {InvalidateUI();}

		// Local methods
		void SortKeys();
		void HoldTrack();
		void Invalidate();
		void PrepareTrack(TimeValue t);
		float GetInterpVal(TimeValue t,int &n0, int &n1);
		Point3 PointOnPath(TimeValue t);
		Quat QuatOnPath(TimeValue t);		

		Interval CompValidity(TimeValue t);
		BOOL SetObject(INode *node);
		void SetKeyPos(TimeValue t, DWORD fi, Point3 bary);

		void CompFirstDeriv();
		void CompLastDeriv();
		void Comp2KeyDeriv();
		void CompMiddleDeriv(int i);
		void CompAB(int i);

		void InvalidateUI();
		void UpdateUI();
		void UpdateTCBGraph();
		void UpdateBaryGraph();
		void SetupWindow(HWND hWnd);
		void DestroyWindow();
		void SpinnerChange(int id);
		void Command(int id, LPARAM lParam);
	};

HWND             AttachCtrl::hWnd       = NULL;
IObjParam       *AttachCtrl::ip         = NULL;
AttachCtrl      *AttachCtrl::editCont   = NULL;
BOOL             AttachCtrl::uiValid    = FALSE;
ISpinnerControl *AttachCtrl::iTime      = NULL;
ISpinnerControl *AttachCtrl::iFace      = NULL;
ISpinnerControl *AttachCtrl::iA         = NULL;
ISpinnerControl *AttachCtrl::iB         = NULL;
ISpinnerControl *AttachCtrl::iTens      = NULL;
ISpinnerControl *AttachCtrl::iCont      = NULL;
ISpinnerControl *AttachCtrl::iBias      = NULL;
ISpinnerControl *AttachCtrl::iEaseTo    = NULL;
ISpinnerControl *AttachCtrl::iEaseFrom  = NULL;
ICustButton     *AttachCtrl::iPickOb    = NULL;
ICustButton     *AttachCtrl::iSetPos    = NULL;
ICustButton     *AttachCtrl::iPrev      = NULL;
ICustButton     *AttachCtrl::iNext      = NULL;
ICustButton     *AttachCtrl::iUpdate    = NULL;
ICustStatus     *AttachCtrl::iStat      = NULL;
int              AttachCtrl::index      = -1;
PickObjectMode  *AttachCtrl::pickObMode = NULL;
SetPosCMode     *AttachCtrl::setPosMode = NULL;

class AttachClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading) {return new AttachCtrl();}
	const TCHAR *	ClassName() {return ATTACH_CONTROL_CNAME;}
	SClass_ID		SuperClassID() {return CTRL_POSITION_CLASS_ID; }
	Class_ID		ClassID() {return ATTACH_CONTROL_CLASS_ID;}
	const TCHAR* 	Category() {return _T("");}
	};
static AttachClassDesc attachCD;
ClassDesc* GetAttachControlDesc() {return &attachCD;}


class AttachCtrlRestore : public RestoreObj {
	public:
		Tab<AKey> undo;
		Tab<AKey> redo;
		Interval urange, rrange;
		AttachCtrl *cont;

		AttachCtrlRestore(AttachCtrl *c) {
			cont   = c;
			undo   = c->keys;			
			urange = c->range;
			}
		
		void Restore(int isUndo) {
			if (isUndo) {
				redo   = cont->keys;
				rrange = cont->range;
				}
			cont->keys  = undo;
			cont->range = urange;
			cont->Invalidate();
			cont->NotifyDependents(FOREVER,0,REFMSG_CHANGE);
			}

		void Redo() {
			cont->keys  = redo;
			cont->range = rrange;
			cont->Invalidate();
			cont->NotifyDependents(FOREVER,0,REFMSG_CHANGE);
			}

		int Size() {return 1;}
		void EndHold() {cont->ClearAFlag(A_HELD);}
	};


class AttachClipObject : public TrackClipObject {
	public:
		Tab<AKey> tab;

		Class_ID ClassID() {return ATTACH_CONTROL_CLASS_ID;}
		SClass_ID SuperClassID() { return CTRL_FLOAT_CLASS_ID; }
		void DeleteThis() {delete this;}

		AttachClipObject(Interval iv) : TrackClipObject(iv) {}
	};



//-----------------------------------------------------------------------------

AttachCtrl::AttachCtrl() 
	{	
	node        = NULL;
	rangeLinked = TRUE;
	align       = TRUE;
	trackValid  = FALSE;
	manUpdate   = FALSE;
	doManUpdate = FALSE;
	val  = Point3(0,0,0);
	qval = IdentQuat();
	}

RefTargetHandle AttachCtrl::Clone(RemapDir &remap)
	{
	AttachCtrl *bc = new AttachCtrl;
	bc->range      = range;
	bc->valid      = valid;
	bc->keys       = keys;
	bc->val        = val;
	bc->node       = NULL;
	bc->manUpdate  = manUpdate;
	CloneControl(bc,remap);
	return bc;
	}

#define KEYTIME_CHUNKID		0x0100
#define KEYFLAGS_CHUNKID	0x0110
#define NUMKEYS_CHUNKID		0x0130
#define KEYFACE_CHUNKID		0x0140
#define KEYU0_CHUNKID		0x0150
#define KEYU1_CHUNKID		0x0160
#define KEYTENS_CHUNKID		0x0170
#define KEYCONT_CHUNKID		0x0180
#define KEYBIAS_CHUNKID		0x0190
#define KEYEASEIN_CHUNKID	0x0200
#define KEYEASEOUT_CHUNKID	0x0210
#define ALIGN_CHUNKID		0x0220
#define MANUPDATE_CHUNKID	0x0230

IOResult AttachCtrl::Save(ISave *isave)
	{
	ULONG nb;
	int ct = keys.Count();
		
	// Save align
	isave->BeginChunk(ALIGN_CHUNKID);
	isave->Write(&align,sizeof(align),&nb);	
	isave->EndChunk();

	// Manual update
	isave->BeginChunk(MANUPDATE_CHUNKID);
	isave->Write(&manUpdate,sizeof(manUpdate),&nb);
	isave->EndChunk();

	// Save the number of keys
	isave->BeginChunk(NUMKEYS_CHUNKID);
	isave->Write(&ct,sizeof(ct),&nb);
	isave->EndChunk();

	// Write each key
	for (int i=0; i<ct; i++) {
		isave->BeginChunk(KEYTIME_CHUNKID);
		isave->Write(&keys[i].time,sizeof(keys[i].time),&nb);
		isave->EndChunk();

		isave->BeginChunk(KEYFLAGS_CHUNKID);
		isave->Write(&keys[i].flags,sizeof(keys[i].flags),&nb);
		isave->EndChunk();		

		isave->BeginChunk(KEYFACE_CHUNKID);
		isave->Write(&keys[i].face,sizeof(keys[i].face),&nb);
		isave->EndChunk();		

		isave->BeginChunk(KEYU0_CHUNKID);
		isave->Write(&keys[i].u0,sizeof(keys[i].u0),&nb);
		isave->EndChunk();		

		isave->BeginChunk(KEYU1_CHUNKID);
		isave->Write(&keys[i].u1,sizeof(keys[i].u1),&nb);
		isave->EndChunk();		

		isave->BeginChunk(KEYTENS_CHUNKID);
		isave->Write(&keys[i].tens,sizeof(keys[i].tens),&nb);
		isave->EndChunk();		

		isave->BeginChunk(KEYCONT_CHUNKID);
		isave->Write(&keys[i].cont,sizeof(keys[i].cont),&nb);
		isave->EndChunk();		

		isave->BeginChunk(KEYBIAS_CHUNKID);
		isave->Write(&keys[i].bias,sizeof(keys[i].bias),&nb);
		isave->EndChunk();

		isave->BeginChunk(KEYEASEIN_CHUNKID);
		isave->Write(&keys[i].easeIn,sizeof(keys[i].easeIn),&nb);
		isave->EndChunk();		

		isave->BeginChunk(KEYEASEOUT_CHUNKID);
		isave->Write(&keys[i].easeOut,sizeof(keys[i].easeOut),&nb);
		isave->EndChunk();
		}
	
	return IO_OK;
	}

IOResult AttachCtrl::Load(ILoad *iload)
	{
	ULONG nb;
	int ct;	
	IOResult res;
		
	while (IO_OK==(res=iload->OpenChunk())) {
		switch (iload->CurChunkID()) {	
			case ALIGN_CHUNKID:
				iload->Read(&align,sizeof(align),&nb);
				break;

			case MANUPDATE_CHUNKID:
				iload->Read(&manUpdate,sizeof(manUpdate),&nb);
				break;

			case NUMKEYS_CHUNKID:	
				iload->Read(&ct,sizeof(ct),&nb);
				iload->CloseChunk();	
				keys.SetCount(ct);

				// Key data always follows
				for (int i=0; i<ct; i++) {
					keys[i] = AKey();

					iload->OpenChunk();
					assert(iload->CurChunkID()==KEYTIME_CHUNKID);
					iload->Read(&keys[i].time,sizeof(keys[i].time),&nb);
					iload->CloseChunk();
					
					iload->OpenChunk();
					assert(iload->CurChunkID()==KEYFLAGS_CHUNKID);
					iload->Read(&keys[i].flags,sizeof(keys[i].flags),&nb);
					iload->CloseChunk();		

					iload->OpenChunk();
					assert(iload->CurChunkID()==KEYFACE_CHUNKID);
					iload->Read(&keys[i].face,sizeof(keys[i].face),&nb);
					iload->CloseChunk();		

					iload->OpenChunk();
					assert(iload->CurChunkID()==KEYU0_CHUNKID);
					iload->Read(&keys[i].u0,sizeof(keys[i].u0),&nb);
					iload->CloseChunk();		

					iload->OpenChunk();
					assert(iload->CurChunkID()==KEYU1_CHUNKID);
					iload->Read(&keys[i].u1,sizeof(keys[i].u1),&nb);
					iload->CloseChunk();		

					iload->OpenChunk();
					assert(iload->CurChunkID()==KEYTENS_CHUNKID);
					iload->Read(&keys[i].tens,sizeof(keys[i].tens),&nb);
					iload->CloseChunk();		

					iload->OpenChunk();
					assert(iload->CurChunkID()==KEYCONT_CHUNKID);
					iload->Read(&keys[i].cont,sizeof(keys[i].cont),&nb);
					iload->CloseChunk();		

					iload->OpenChunk();
					assert(iload->CurChunkID()==KEYBIAS_CHUNKID);
					iload->Read(&keys[i].bias,sizeof(keys[i].bias),&nb);
					iload->CloseChunk();		

					iload->OpenChunk();
					assert(iload->CurChunkID()==KEYEASEIN_CHUNKID);
					iload->Read(&keys[i].easeIn,sizeof(keys[i].easeIn),&nb);
					iload->CloseChunk();		

					iload->OpenChunk();
					assert(iload->CurChunkID()==KEYEASEOUT_CHUNKID);
					iload->Read(&keys[i].easeOut,sizeof(keys[i].easeOut),&nb);
					iload->CloseChunk();		
					}
				continue;
			}
		iload->CloseChunk();
		if (res!=IO_OK)  return res;
		}
				
	return IO_OK;
	}

void AttachCtrl::Copy(Control *from)
	{	
	}

void AttachCtrl::HoldTrack()
	{
	if (theHold.Holding()&&!TestAFlag(A_HELD)) {		
		theHold.Put(new AttachCtrlRestore(this));
		SetAFlag(A_HELD);
		}
	}

void AttachCtrl::EditTimeRange(Interval range,DWORD flags)
	{	
	HoldTrack();
	if (flags&EDITRANGE_LINKTOKEYS && keys.Count()) {
		this->range.Set(keys[0].time,keys[keys.Count()-1].time);
		rangeLinked = TRUE;
	} else {		
		rangeLinked = FALSE;
		this->range = range;		
		}
	Invalidate();
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

Interval AttachCtrl::GetTimeRange(DWORD flags)
	{
	if (rangeLinked && keys.Count()) 
		 return Interval(keys[0].time,keys[keys.Count()-1].time);
	else return range;
	}

void AttachCtrl::MapKeys(TimeMap *map,DWORD flags)
	{
	int n = keys.Count();
	BOOL changed = FALSE;
	if (!n) return;
	HoldTrack();

	if (flags&TRACK_MAPRANGE) {		
		TimeValue t0 = map->map(range.Start());
		TimeValue t1 = map->map(range.End());
		range.Set(t0,t1);
		changed = TRUE;
		}	

	if (flags&TRACK_DOALL) {
		for (int i=0; i<n; i++) {			
			keys[i].time = map->map(keys[i].time);
			changed = TRUE;
			}
	} else 
	if (flags&TRACK_DOSEL) {
		BOOL slide = flags&TRACK_SLIDEUNSEL;
		TimeValue delta = 0, prev;
		int start, end, inc;
		if (flags&TRACK_RIGHTTOLEFT) {
			start = n-1;
			end = -1;
			inc = -1;
		} else {
			start = 0;
			end = n;
			inc = 1;
			} 
		for (int i=start; i!=end; i+=inc) {			
			if (keys[i].flags & KEY_SELECTED) {
				prev = keys[i].time;
				keys[i].time = map->map(keys[i].time);
				delta = keys[i].time - prev;
				changed = TRUE;
			} else if (slide) {
				keys[i].time += delta;
				}
			}
		}
	
	if (changed) {
		Invalidate();
		SortKeys();
		NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
		}
	}


int AttachCtrl::GetKeyIndex(TimeValue t)
	{
	for (int i=0; i<keys.Count(); i++) {
		if (keys[i].time==t) return i;
		if (keys[i].time>t) return -1;
		}
	return -1;
	}

void AttachCtrl::DeleteKeyAtTime(TimeValue t)
	{
	int index = GetKeyIndex(t);
	if (index>=0) {
		HoldTrack();
		keys.Delete(index,1);
		Invalidate();
		NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
		}
	}

BOOL AttachCtrl::IsKeyAtTime(TimeValue t,DWORD flags)
	{
	for (int i=0; i<keys.Count(); i++) {
		if (keys[i].time>t) return FALSE;
		if (keys[i].time==t) return TRUE;		
		}
	return FALSE;
	}

int AttachCtrl::GetKeyTimes(
		Tab<TimeValue> &times,Interval range,DWORD flags)
	{
	int skip = 0;
	for (int i=0; i<keys.Count(); i++) {		
		if (keys[i].time >= range.Start() && keys[i].time <= range.End()) {
			times.Append(1,&keys[i].time,10);
		} else {
			if (keys[i].time > range.End()) break;
			skip++;
			}
		}
	times.Shrink();
	return skip;
	}

int AttachCtrl::GetKeySelState(
		BitArray &sel,Interval range,DWORD flags)
	{
	int c = 0;
	int skip = 0;
	for (int i=0; i<keys.Count(); i++) {		
		if (keys[i].time >= range.Start() && keys[i].time <= range.End()) {
			sel.Set(c++,keys[i].flags&KEY_SELECTED);
		} else {			
			if (keys[i].time > range.End()) break;
			skip++;
			}
		}	
	return skip;
	}

BOOL AttachCtrl::GetNextKeyTime(
		TimeValue t,DWORD flags,TimeValue &nt)
	{
	if (!keys.Count()) return FALSE;
	if (flags&NEXTKEY_RIGHT) {		
		for (int i=0; i<keys.Count(); i++) {
			if (keys[i].time > t ) {
				nt = keys[i].time;
				return TRUE;
				}
			}
		nt = keys[0].time;
		return TRUE;
	} else {
		for (int i=keys.Count()-1; i>=0; i--) {
			if (keys[i].time < t ) {
				nt = keys[i].time;
				return TRUE;
				}
			}
		nt = keys[keys.Count()-1].time;
		return TRUE;
		}
	}


void AttachCtrl::DeleteTime(Interval iv, DWORD flags)
	{
	Interval test = TestInterval(iv,flags);
	int n = keys.Count();	
	int d = iv.Duration()-1;
	if (d<0) d = 0;
	HoldTrack();

	for (int i = n-1; i >= 0; i--) {
		if (test.InInterval(keys[i].time)) {
			keys.Delete(i,1);
		} else 
		if (!(flags&TIME_NOSLIDE)) {			
			if (keys[i].time > test.End()) {
				keys[i].time -= d;
				}
			}
		}		    
	
	Invalidate();
	SortKeys();
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

void AttachCtrl::ReverseTime(Interval iv, DWORD flags)
	{
	Interval test = TestInterval(iv,flags);
	int n = keys.Count();
	HoldTrack();

	for (int i = 0; i < n; i++) {		
		if (test.InInterval(keys[i].time)) {
			TimeValue delta = keys[i].time - iv.Start();
			keys[i].time = iv.End()-delta;			
			}
		}
	Invalidate();
	SortKeys();
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

void AttachCtrl::ScaleTime(Interval iv, float s)
	{
	int n = keys.Count();
	TimeValue delta = int(s*float(iv.End()-iv.Start())) + iv.Start()-iv.End();
	HoldTrack();

	for (int i = 0; i < n; i++) {		
		if (iv.InInterval(keys[i].time)) {
			keys[i].time = 
				int(s*float(keys[i].time - iv.Start())) + iv.Start();
		} else 
		if (keys[i].time > iv.End()) {
			keys[i].time += delta;
			}
		}
	Invalidate();
	SortKeys();
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

void AttachCtrl::InsertTime(TimeValue ins, TimeValue amount)
	{
	int n = keys.Count();		
	HoldTrack();

	for (int i = 0; i < n; i++) {		
		if (keys[i].time >= ins) {
			keys[i].time += amount;
			}		
		}
	Invalidate();
	SortKeys();
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

void AttachCtrl::DeleteKeys(DWORD flags)
	{
	int n = keys.Count();		
	HoldTrack();
	
	for (int i = n-1; i >= 0; i--) {
		if (flags&TRACK_DOALL || keys[i].flags&KEY_SELECTED) {
			keys.Delete(i,1);
			}
		}	
	Invalidate();
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

void AttachCtrl::DeleteKeyByIndex(int index)
	{
	HoldTrack();
	keys.Delete(index,1);
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

void AttachCtrl::SelectKeyByIndex(int i,BOOL sel)
	{
	HoldTrack();
	if (sel) keys[i].flags |=  KEY_SELECTED;
	else     keys[i].flags &= ~KEY_SELECTED;
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

void AttachCtrl::SelectKeys(TrackHitTab& sel, DWORD flags)
	{
	HoldTrack();
	
	if (flags&SELKEYS_CLEARKEYS) {
		int n = keys.Count();
		for (int i = 0; i < n; i++ ) {
			keys[i].flags &= ~KEY_SELECTED;
			}
		}
	
	if (flags&SELKEYS_DESELECT) {
		for (int i = 0; i < sel.Count(); i++ ) {			
			keys[sel[i].hit].flags &= ~KEY_SELECTED;
			}		
		} 	
	if (flags&SELKEYS_SELECT) {			
		for (int i = 0; i < sel.Count(); i++ ) {
			keys[sel[i].hit].flags |= KEY_SELECTED;
			}
		}	
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

void AttachCtrl::FlagKey(TrackHitRecord hit)
	{
	int n = keys.Count();
	for (int i = 0; i < n; i++) {
		keys[i].flags &= ~KEY_FLAGGED;
		}
	assert(hit.hit>=0&&hit.hit<(DWORD)n);
	keys[hit.hit].flags |= KEY_FLAGGED;
	}

int AttachCtrl::GetFlagKeyIndex()
	{
	int n = keys.Count();
	for (int i = 0; i < n; i++) {
		if (keys[i].flags & KEY_FLAGGED) {
			return i;
			}
		}
	return -1;
	}

int AttachCtrl::NumSelKeys()
	{
	int n = keys.Count();
	int c = 0;
	for ( int i = 0; i < n; i++ ) {
		if (keys[i].flags & KEY_SELECTED) {
			c++;
			}
		}
	return c;
	}

void AttachCtrl::CloneSelectedKeys(BOOL offset)
	{
	int n = keys.Count();			
	HoldTrack();
	BOOL changed = FALSE;

	for (int i = 0; i < n; i++) {
		if (keys[i].flags & KEY_SELECTED) {
			AKey key(keys[i]);
			key.flags |= KEY_SELECTED;
			keys.Append(1,&key,5);
			keys[i].flags &= ~KEY_SELECTED;
			changed = TRUE;
			}
		}
	if (changed) {
		keys.Shrink();
		Invalidate();
		SortKeys();
		}
	}

void AttachCtrl::AddNewKey(TimeValue t,DWORD flags)
	{
	HoldTrack();
	AKey key;
	key.time = t;
	key.face = 0;
	key.u0 = key.u1 = 1.0f/3.0f;	
	key.tens = key.cont = key.bias = key.easeIn = key.easeOut = 0.0f;

	// Try to find a nearby key
	if (keys.Count()) {
		int n0, n1;
		GetInterpVal(t,n0,n1);
		key.face = keys[n0].face;
		key.u0   = keys[n0].u0;
		key.u1   = keys[n0].u1;
		}

	if (flags&ADDKEY_SELECT) {
		key.flags |= KEY_SELECTED;
		}
	if (flags&ADDKEY_FLAGGED) {
		int n = keys.Count();
		for (int i = 0; i < n; i++) {
			keys[i].flags &= ~KEY_FLAGGED;
			}		
		key.flags |= KEY_FLAGGED;
		}
	keys.Append(1,&key);
	Invalidate();
	SortKeys();
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);	
	}

BOOL AttachCtrl::IsKeySelected(int index)
	{
	return keys[index].flags & KEY_SELECTED;
	}

TrackClipObject *AttachCtrl::CopyTrack(Interval iv, DWORD flags)
	{	
	AttachClipObject *cobj = new AttachClipObject(iv);	
	Interval test = TestInterval(iv,flags);	
	for (int i = 0; i < keys.Count(); i++) {
		if (test.InInterval(keys[i].time)) {
			AKey nk(keys[i]);
			cobj->tab.Append(1,&nk,10);
			}
		}
	cobj->tab.Shrink();
	return cobj;
	}

void AttachCtrl::PasteTrack(TrackClipObject *cobj,Interval iv, DWORD flags)
	{
	AttachClipObject *cob = (AttachClipObject*)cobj;	
	HoldTrack();		
	DeleteTime(iv,flags);	
	InsertTime(iv.Start(),cob->clip.Duration()-1);	
	for (int i = 0; i < cob->tab.Count(); i++) {
		AKey key(cob->tab[i]);
		key.time -= cob->clip.Start() - iv.Start();
		keys.Append(1,&key);		
		}	
	Invalidate();
	SortKeys();
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

int AttachCtrl::HitTestTrack(			
		TrackHitTab& hits,
		Rect& rcHit,
		Rect& rcTrack,			
		float zoom,
		int scroll,
		DWORD flags)
	{
	int left  = ScreenToTime(rcTrack.left,zoom,scroll) - 4;
	int right = ScreenToTime(rcTrack.right,zoom,scroll) + 4;
	int n = keys.Count();
	int y = (rcTrack.top+rcTrack.bottom)/2;	
		
	for ( int i = 0; i < n; i++ ) {
		if (flags&HITTRACK_SELONLY && 
			!(keys[i].flags & KEY_SELECTED)) continue;
		if (flags&HITTRACK_UNSELONLY && 
			(keys[i].flags & KEY_SELECTED)) continue;

		if (keys[i].time > right) {
			break;
			}
		if (keys[i].time > left) {
			int x = TimeToScreen(keys[i].time,zoom,scroll);
			if (rcHit.Contains(IPoint2(x,y))) {
				TrackHitRecord rec(i,0);
				hits.Append(1,&rec);
				if (flags&HITTRACK_ABORTONHIT) return TRACK_DONE;
				}
			}		
		}
	return TRACK_DONE;
	}

int AttachCtrl::PaintTrack(			
		ParamDimensionBase *dim,
		HDC hdc,
		Rect& rcTrack,
		Rect& rcPaint,
		float zoom,
		int scroll,
		DWORD flags)
	{
	int left  = ScreenToTime(rcPaint.left-8,zoom,scroll);
	int right = ScreenToTime(rcPaint.right+8,zoom,scroll);
	int n = keys.Count();
	int y = (rcTrack.top+rcTrack.bottom)/2, x = rcPaint.left-2;
	HBRUSH selBrush   = CreateSolidBrush(RGB(255,255,255));	
	HBRUSH unselBrush = (HBRUSH)GetStockObject(GRAY_BRUSH);		
	SelectObject(hdc,GetStockObject(BLACK_PEN));	
		
	for (int i = 0; i < n; i++) {
		if (keys[i].time > right) {
			break;
			}
		if (keys[i].time > left) {			
			x  = TimeToScreen(keys[i].time,zoom,scroll);
			if ((flags&PAINTTRACK_SHOWSEL) && (keys[i].flags&KEY_SELECTED)) {
				SelectObject(hdc,selBrush);
			} else {
				SelectObject(hdc,unselBrush);
				}
			Ellipse(hdc,x-4,y-5,x+4,y+5);
			}		
		}

	DeleteObject(selBrush);	  
	return TRACK_DONE;
	}


static int __cdecl CompareAKeys(const AKey *k1, const AKey *k2)
	{
	if (k1->time < k2->time) return -1;
	if (k1->time > k2->time) return 1;
	return 0;
	}

void AttachCtrl::SortKeys()
	{
	keys.Sort((CompareFnc)CompareAKeys);
	}


RefResult AttachCtrl::NotifyRefChanged(
		Interval valid, RefTargetHandle targ, 
		PartID &partID, RefMessage msg) 
	{
	switch (msg) {
		case REFMSG_CHANGE:
			Invalidate();
			break;

		case REFMSG_TARGET_DELETED:
			node = NULL;
			break;
		}
	return REF_SUCCEED;
	}

RefTargetHandle AttachCtrl::GetReference(int i)
	{
	if (i<Control::NumRefs()) {
		return Control::GetReference(i);
	} else {
		return node;
		}
	}

void AttachCtrl::SetReference(int i, RefTargetHandle rtarg)
	{
	if (i<Control::NumRefs()) {
		Control::SetReference(i,rtarg);
	} else {
		node = (INode*)rtarg;
		}
	}

Interval AttachCtrl::CompValidity(TimeValue t)
	{
	Interval v = FOREVER;
	if (keys.Count()) {
		if (t<keys[0].time) {
			v.Set(TIME_NegInfinity,keys[0].time);
		} else 
		if (t>keys[keys.Count()-1].time) {
			v.Set(keys[keys.Count()-1].time,TIME_PosInfinity);
		} else {
			v.SetInstant(t);
			}		
		}	
	return v;
	}

void AttachCtrl::GetValue(
		TimeValue t, void *val, Interval &valid, GetSetMethod method)
	{
	TimeValue oldTime = t;
	t = ApplyEase(t,valid);	
	if (!this->valid.InInterval(t)) {
		this->valid = CompValidity(t);
		PrepareTrack(t);
		this->val = PointOnPath(t);
		if (align) {
			qval = QuatOnPath(t);
			}				
		if (this->valid.Empty()) this->valid.Set(oldTime,oldTime);
		}
	if (method==CTRL_RELATIVE) {
		Matrix3 *tm = (Matrix3*)val;
		if (align) qval.MakeMatrix(*tm);		
		tm->SetTrans(this->val);
	} else {
		*((Point3*)val) = this->val;
		}
	valid &= this->valid;
	}

float AttachCtrl::GetInterpVal(TimeValue t,int &n0, int &n1)
	{
	float u=0.0f;

	for (int i=0; i<keys.Count(); i++) {
		if (keys[i].time>t) {
			if (i) {
				n0 = i-1;
				n1 = i;
				u = float(t-keys[i-1].time)/
					float(keys[i].time-keys[i-1].time);
				u = Ease(u,keys[i-1].easeOut,keys[i].easeIn);
				return u;
			} else {
				n0 = n1 = 0;
				return u;
				}
			}
		}
	n0 = n1 = keys.Count()-1;
	return u;
	}

Point3 AttachCtrl::PointOnPath(TimeValue t)
	{
	Point3 p(0,0,0);
	if (keys.Count()) {		
		int n0, n1;
		float u = GetInterpVal(t,n0,n1);
		float v[4];
		ComputeHermiteBasis(u, v);
		p = keys[n0].pos  * v[0] + keys[n1].pos * v[1] +
			keys[n0].dout * v[2] + keys[n1].din * v[3];		
		}
	return p;
	}

Quat AttachCtrl::QuatOnPath(TimeValue t)
	{
	Quat q = IdentQuat();
	if (keys.Count()) {		
		int n0, n1;
		float u = GetInterpVal(t,n0,n1);
		Quat qd = keys[n1].quat/keys[n0].quat;
		float ang;
		Point3 axis;
		AngAxisFromQ(qd, &ang, axis);
		q = squadrev(
			ang, axis, 
			keys[n0].quat, keys[n0].qa, keys[n1].qb, keys[n1].quat, u);		
		}
	return q;
	}

void AttachCtrl::Invalidate()
	{	
	valid.SetEmpty();
	trackValid = FALSE;
	InvalidateUI();
	}

static void MakeAngPositive(float &ang, Point3 &axis) 
	{
	if (ang < 0.0f) {		
		ang  = -ang;
		axis = -axis;
		}
	}

static void MakeAngLessThan180(float &ang, Point3 &axis) 
	{	
	MakeAngPositive(ang,axis);	
	while (ang > TWOPI) ang -= TWOPI;
	if (fabs(ang) > PI) ang -= TWOPI;	
	MakeAngPositive(ang,axis);
	}

static Quat ConstructOrientation(Point3 norm, Point3 dir)
	{
	Matrix3 tm(1);
	tm.SetRow(2,norm);
	tm.SetRow(1,Normalize(norm^dir));
	tm.SetRow(0,tm.GetRow(1)^tm.GetRow(2));
	Quat q(tm);
	float ang;
	Point3 axis;
	AngAxisFromQ(q, &ang, axis);	
	MakeAngLessThan180(ang, axis);
	return QFromAngAxis(ang,axis);
	}


void AttachCtrl::PrepareTrack(TimeValue t)
	{
	if (trackValid && keys.Count()!=1) return;
	trackValid = TRUE;
	if (!node) return;
	if (manUpdate && !doManUpdate) return;
	doManUpdate = FALSE;

	// First compute key positions and normals
	for (int i=0; i<keys.Count(); i++) {
		AKey &k = keys[i];

		// Evaluate the node
		ObjectState os = node->EvalWorldState(
			keys.Count()==1 ? t : k.time);		
		TriObject *obj = NULL;
		BOOL needsDel = FALSE;
		
		// Convert it to a tri object
		if (os.obj->IsSubClassOf(triObjectClassID)) {
			obj = (TriObject*)os.obj;
			needsDel = FALSE;
		} else {
			if (os.obj->CanConvertToType(triObjectClassID)) {
				Object *oldObj = os.obj;
				obj = (TriObject*)
					os.obj->ConvertToType(
					keys.Count()==1 ? t : k.time,triObjectClassID);
				needsDel = (obj != oldObj);
				}
			}
		
		// Get the position on the face
		if (obj) {						
			Interval iv = FOREVER;
			Matrix3 tm = node->GetObjTMAfterWSM(
				keys.Count()==1 ? t : k.time, &iv);
			if (keys.Count()==1) {
				// Special case for only one key
				valid &= iv;
				valid &= obj->ChannelValidity(t,GEOM_CHAN_NUM);
				valid &= obj->ChannelValidity(t,TOPO_CHAN_NUM);
				}
			Mesh &m = obj->GetMesh();
			if (m.getNumFaces()) {
				DWORD f = k.face % m.getNumFaces();
				k.pos = m.verts[m.faces[f].v[0]] * k.u0 +
						m.verts[m.faces[f].v[1]] * k.u1 +
						m.verts[m.faces[f].v[2]] * (1.0f-k.u0-k.u1);
				k.pos = k.pos * tm;

				k.norm = Normalize(
					(m.verts[m.faces[f].v[1]]-m.verts[m.faces[f].v[0]])^
					(m.verts[m.faces[f].v[2]]-m.verts[m.faces[f].v[1]]));
				k.norm = VectorTransform(tm,k.norm);
			} else {
				k.pos  = Point3(0,0,0) * tm;
				k.norm = Point3(0,0,1); 
				}
			
			if (needsDel) obj->DeleteThis();
			}
		}

	// Next compute position derivatives
	switch (keys.Count()) {
		case 0: break;
		case 1:
			keys[0].din = keys[0].dout = Point3(0,0,0); 
			break;

		case 2:
			Comp2KeyDeriv();
			break;

		default:
			for (i=1; i<keys.Count()-1; i++) CompMiddleDeriv(i);		
			CompFirstDeriv();
			CompLastDeriv();
			break;
		}

	// Compute orientations
	if (align) {
		// Compute orientations at each key
		for (int i=0; i<keys.Count(); i++) {
			Point3 dir;
			if (i<keys.Count()-1) {
				dir = Normalize(
					PointOnPath(keys[i].time+1)-
					PointOnPath(keys[i].time));
			} else {
				dir = Normalize(
					PointOnPath(keys[i].time)-
					PointOnPath(keys[i].time-1));
				}
			keys[i].quat = ConstructOrientation(keys[i].norm, dir);
			}

		// Now compute quat tangents
		if (keys.Count()==1) keys[0].qa = keys[0].qb = IdentQuat();
		else for (i=0; i<keys.Count(); i++) CompAB(i);
		}
	trackValid = TRUE;
	}

void AttachCtrl::CompFirstDeriv()
	{
	float t;
	t = 0.5f * (1.0f - keys[0].tens);		
	keys[0].dout = 
		t * (3.0f * (keys[1].pos - keys[0].pos) - keys[1].din);	
	}

void AttachCtrl::CompLastDeriv()
	{
	float t;
	int n = keys.Count();
	t = 0.5f * (1.0f - keys[n-1].tens);		
	keys[n-1].din = 
		-t * (3.0f * (keys[n-2].pos - keys[n-1].pos) + keys[n-2].dout);	
	}

void AttachCtrl::Comp2KeyDeriv()
	{	
	float t0, t1;
	Point3 dp = keys[1].pos - keys[0].pos;	
	t0 = 1.0f - keys[0].tens;
	t1 = 1.0f - keys[1].tens;				
	keys[0].dout = t0 * dp;
	keys[1].din  = t1 * dp;
	}

void AttachCtrl::CompMiddleDeriv(int i)
	{
	float tm,cm,cp,bm,bp,tmcm,tmcp,ksm,ksp,kdm,kdp,c;
	float dt,fp,fn;
	int n = keys.Count();	

	/* fp,fn apply speed correction when continuity is 0.0 */	
	dt = .5f * (float)(keys[i+1].time - keys[i-1].time);
	fp = ((float)(keys[i].time - keys[i-1].time)) / dt;
	fn = ((float)(keys[i+1].time - keys[i].time)) / dt;
	
	c  = float(fabs(keys[i].cont));
	fp = fp + c - c * fp;
	fn = fn + c - c * fn;
	cm = 1.0f - keys[i].cont; 	
	tm = 0.5f * (1.0f - keys[i].tens);
	cp = 2.0f - cm;
	bm = 1.0f - keys[i].bias;
	bp = 2.0f - bm;      
	tmcm = tm*cm;	tmcp = tm*cp;
	ksm = tmcm*bp*fp;	ksp = tmcp*bm*fp;
	kdm = tmcp*bp*fn; 	kdp = tmcm*bm*fn;
	
	Point3 delm, delp;	
	delm = keys[i].pos   - keys[i-1].pos;
	delp = keys[i+1].pos - keys[i].pos;
	keys[i].din  = ksm*delm + ksp*delp;
	keys[i].dout = kdm*delm + kdp*delp;	
	}


static float Ease(float u, float a, float b) 
	{
	float k;
	float s = a + b;
	
	if (u==0.0f || u==1.0f) return u;
	if (s == 0.0) return u;
	if (s > 1.0f) {
		a = a/s;
		b = b/s;
		}
	k = 1/(2.0f - a - b);
	if (u < a) return ((k/a)*u*u);
	else if (u < 1.0f - b) return (k*(2.0f*u - a));
	else {
		u = 1.0f - u;
		return (1.0f - (k/b) *u*u);
		}
	}

static void ComputeHermiteBasis(float u, float *v) 
	{
	float u2,u3,a;
	
	u2 = u*u;
	u3 = u2*u;
	a  = 2.0f*u3 - 3.0f*u2;
	v[0] = 1.0f + a;
	v[1] = -a;
	v[2] = u - 2.0f*u2 + u3;
	v[3] = -u2 + u3;
	}

static float qdot(Quat p, Quat q) 
	{
	return (q[0]*p[0] + q[1]*p[1] + q[2]*p[2] + q[3]*p[3]);
	}

void AttachCtrl::CompAB(int i)
	{	
	int n = keys.Count();
	Quat qprev, qnext, q;
	Quat  qp, qm, qa, qb, qae, qbe;	
	float tm,cm,cp,bm,bp,tmcm,tmcp,ksm,ksp,kdm,kdp,c;
	float dt,fp,fn;
			
	if (i!=0) {
		if (qdot(keys[i-1].quat, keys[i].quat) < 0.0f) 
			 qprev = -keys[i-1].quat;
		else qprev =  keys[i-1].quat;
		qm = LnDif(qprev,keys[i].quat);			
		}
	if (i<n-1) {
		if (qdot(keys[i+1].quat, keys[i].quat) < 0.0f) 
			qnext  = -keys[i+1].quat;
		else qnext =  keys[i+1].quat;
		qp = LnDif(keys[i].quat, qnext);
		}
	if (i==0) qm = qp;
	if (i==1) qp = qm;
	
	fp = fn = 1.0f;
	cm = 1.0f - keys[i].cont;	
	
	if (i>0 && i<n-1) {
		dt = 0.5f * float(keys[i+1].time - keys[i-1].time);
		fp = float(keys[i].time - keys[i-1].time)/dt;
		fn = float(keys[i+1].time - keys[i].time)/dt;
		c = float(fabs(keys[i].cont));
		fp = fp + c - c * fp;
		fn = fn + c - c * fn;
		}
	
	tm = .5f*(1.0f - keys[i].tens);
	cp = 2.0f - cm;
	bm = 1.0f - keys[i].bias;
	bp = 2.0f - bm;      
	tmcm = tm * cm;	
	tmcp = tm * cp;
	ksm  = 1.0f - tmcm * bp * fp;	
	ksp  = -tmcp * bm * fp;
	kdm  = tmcp * bp * fn; 	
	kdp  = tmcm * bm * fn - 1.0f;
	
	for (int j = 0; j < 4; j++) {
		qa[j] = .5f * (kdm * qm[j] + kdp * qp[j]);
		qb[j] = .5f * (ksm * qm[j] + ksp * qp[j]);
		}

	qae = Exp(qa);
	qbe = Exp(qb);
	
	keys[i].qa = keys[i].quat * qae;
	keys[i].qb = keys[i].quat * qbe;	
	}



BOOL AttachCtrl::SetObject(INode *node)
	{
	if (node->TestForLoop(FOREVER,this)==REF_SUCCEED) {
		ReplaceReference(Control::NumRefs(),(RefTargetHandle)node);
		NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
		Invalidate();
		return TRUE;
	} else {
		return FALSE;
		}
	}

void AttachCtrl::SetKeyPos(TimeValue t, DWORD fi, Point3 bary)
	{
	if (manUpdate) doManUpdate = TRUE;
	int index = GetKeyIndex(t);
	if (index<0) {
		AddNewKey(t,0);
		index = GetKeyIndex(t);
		}
	if (index>=0) {
		keys[index].face = fi;
		keys[index].u0   = bary.x;
		keys[index].u1   = bary.y;
		Invalidate();
		NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
		}
	}


//--- UI -------------------------------------------------------------

#define WM_GETBARY	(WM_USER+0xa38c)
#define WM_SETBARY	(WM_USER+0xa38d)

#define BARYGRAPH_UP	1
#define BARYGRAPH_DOWN	2
#define BARYGRAPH_MOVE	3

static LRESULT CALLBACK BaryGraphWindowProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
static BOOL CALLBACK AttachParamDialogProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

#define ToTCBUI(a) (((a)+1.0f)*25.0f)
#define FromTCBUI(a) (((a)/25.0f)-1.0f)
#define ToEaseUI(a) ((a)*50.0f)
#define FromEaseUI(a) ((a)/50.0f)

void RegisterClasses()
	{
	static BOOL registered=FALSE;
	if (!registered) {
		InitTCBGraph(hInstance);
		
		WNDCLASS  wc;
		wc.style         = 0;
		wc.hInstance     = hInstance;
		wc.hIcon         = NULL;
		wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
		wc.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
		wc.lpszMenuName  = NULL;
		wc.cbClsExtra    = 0;
		wc.cbWndExtra    = 0;
		wc.lpfnWndProc   = BaryGraphWindowProc;
		wc.lpszClassName = _T("FacePosGraph");
		RegisterClass(&wc);
		
		registered = TRUE;
		}
	}

void AttachCtrl::BeginEditParams(
		IObjParam *ip, ULONG flags,Animatable *prev)
	{
	RegisterClasses();
	this->ip = ip;
	editCont = this;
	uiValid  = FALSE;
	hWnd = ip->AddRollupPage( 
		hInstance, 
		MAKEINTRESOURCE(IDD_ATTACH_PARAMS),
		AttachParamDialogProc,
		GetString(IDS_RB_ATTACHPARAMS), 
		(LPARAM)this );
	ip->RegisterTimeChangeCallback(this);
	pickObMode = new PickObjectMode(this);
	setPosMode = new SetPosCMode(this,ip);
	}

void AttachCtrl::EndEditParams(
		IObjParam *ip, ULONG flags,Animatable *next)
	{	
	ip->ClearPickMode();
	ip->DeleteMode(setPosMode);
	ip->UnRegisterTimeChangeCallback(this);	
	if (hWnd) ip->DeleteRollupPage(hWnd);		
	hWnd     = NULL;
	ip       = NULL;
	editCont = NULL;	
	delete pickObMode;
	pickObMode = NULL;
	delete setPosMode;
	setPosMode = NULL;
	}

void AttachCtrl::SpinnerChange(int id)
	{
	HoldTrack();
	assert(index>=0);
	switch (id) {
		case IDC_ATTACH_KEYTIMESPIN:
			keys[index].time = iTime->GetIVal();
			ip->SetTime(keys[index].time);
			break;
		case IDC_ATTACH_KEYFACESPIN:
			keys[index].face = iFace->GetIVal();
			break;
		case IDC_ATTACH_KEYASPIN:
			keys[index].u0 = iA->GetFVal();
			UpdateBaryGraph();
			break;
		case IDC_ATTACH_KEYBSPIN:
			keys[index].u1 = iB->GetFVal();
			UpdateBaryGraph();
			break;
		case IDC_ATTACH_KEYTENSSPIN:
			keys[index].tens = FromTCBUI(iTens->GetFVal());
			UpdateTCBGraph();
			break;
		case IDC_ATTACH_KEYCONTSPIN:
			keys[index].cont = FromTCBUI(iCont->GetFVal());
			UpdateTCBGraph();
			break;
		case IDC_ATTACH_KEYBIASSPIN:
			keys[index].bias = FromTCBUI(iBias->GetFVal());
			UpdateTCBGraph();
			break;
		case IDC_ATTACH_KEYEASETOSPIN:
			keys[index].easeIn = FromEaseUI(iEaseTo->GetFVal());
			UpdateTCBGraph();
			break;
		case IDC_ATTACH_KEYEASEFROMSPIN:
			keys[index].easeOut = FromEaseUI(iEaseFrom->GetFVal());
			UpdateTCBGraph();
			break;
		}
	Invalidate();
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime());
	}

void AttachCtrl::Command(int id, LPARAM lParam)
	{
	switch (id) {
		case IDC_ATTACH_PICKOB:
			ip->SetPickMode(pickObMode);
			break;
		
		case IDC_PREVKEY:
			if (index==0) index = keys.Count()-1;
			else index--;
			ip->SetTime(keys[index].time);
			break;

		case IDC_NEXTKEY:
			if (index==keys.Count()-1) index = 0;
			else index++;
			ip->SetTime(keys[index].time);
			break;
			
		case IDC_ATTACH_SETPOS:
			if (ip->GetCommandMode()==setPosMode) {
				ip->SetStdCommandMode(CID_OBJMOVE);
			} else {
				ip->SetCommandMode(setPosMode);
				}
			break;

		case IDC_ATTACH_ALIGN:
			align = IsDlgButtonChecked(hWnd,id);
			valid.SetEmpty();
			NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
			ip->RedrawViews(ip->GetTime());
			break;

		case IDC_ATTACH_UPDATE:		
			doManUpdate = TRUE;
			Invalidate();
			NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
			ip->RedrawViews(ip->GetTime());
			break;

		case IDC_ATTACH_MANUPDATE:
			manUpdate = IsDlgButtonChecked(hWnd,IDC_ATTACH_MANUPDATE);
			if (manUpdate) iUpdate->Enable();			
			else iUpdate->Disable();		
			break;

		case IDC_ATTACH_FACEPOSGRAPH:
			switch (LOWORD(lParam)) {
				case BARYGRAPH_DOWN:
					theHold.Begin();
					break;

				case BARYGRAPH_UP:
					if (HIWORD(lParam)) theHold.Accept(GetString(IDS_RB_EDITATTACHKEY));
					else theHold.Cancel();
					break;

				case BARYGRAPH_MOVE: {
					HoldTrack();
					Point2 bary;
					SendDlgItemMessage(hWnd,IDC_ATTACH_FACEPOSGRAPH,
						WM_GETBARY, 0, (LPARAM)&bary);
					keys[index].u0 = bary.x;
					keys[index].u1 = bary.y;
					Invalidate();
					NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
					UpdateBaryGraph();
					ip->RedrawViews(ip->GetTime());
					break;
					}
				}
			break;
		}
	}

void AttachCtrl::InvalidateUI()
	{
	if (editCont==this) {
		InvalidateRect(hWnd,NULL,FALSE);
		uiValid = FALSE;
		}
	}


void AttachCtrl::UpdateTCBGraph()
	{
	if (index>=0 && hWnd) {
		TCBGraphParams tp;
		tp.tens     = keys[index].tens;
		tp.cont     = keys[index].cont;
		tp.bias     = keys[index].bias;
		tp.easeTo   = keys[index].easeIn;
		tp.easeFrom = keys[index].easeOut;
		SendDlgItemMessage(hWnd,IDC_TCB_GRAPH,WM_SETTCBGRAPHPARAMS,0,(LPARAM)&tp);
		UpdateWindow(GetDlgItem(hWnd,IDC_TCB_GRAPH));
		}
	}

void AttachCtrl::UpdateBaryGraph()
	{
	if (index>=0 && hWnd) {
		Point2 pt(keys[index].u0,keys[index].u1);
		SendDlgItemMessage(hWnd,IDC_ATTACH_FACEPOSGRAPH,WM_SETBARY,0,(LONG)&pt);
		UpdateWindow(GetDlgItem(hWnd,IDC_ATTACH_FACEPOSGRAPH));
		}
	}

void AttachCtrl::UpdateUI()
	{
	if (!uiValid) {
		uiValid = TRUE;

		index = GetKeyIndex(ip->GetTime());
		if (index<0) {
			iTime->Disable();
			iFace->Disable();
			iA->Disable();
			iB->Disable();
			iTens->Disable();
			iCont->Disable();
			iBias->Disable();
			iEaseFrom->Disable();
			iEaseTo->Disable();
			iStat->SetText(_T(""));
			iPrev->Disable();
			iNext->Disable();
			EnableWindow(GetDlgItem(hWnd,IDC_TCB_GRAPH),FALSE);
			EnableWindow(GetDlgItem(hWnd,IDC_ATTACH_FACEPOSGRAPH),FALSE);			
		} else {
			iTime->Enable();
			iFace->Enable();
			iA->Enable();
			iB->Enable();
			iTens->Enable();
			iCont->Enable();
			iBias->Enable();			
			iEaseFrom->Enable();
			iEaseTo->Enable();
			iTime->SetLimits(GetAnimStart(),GetAnimEnd(),FALSE);
			iPrev->Enable();
			iNext->Enable();
			
			TSTR buf;
			buf.printf(_T("%d"),index+1);
			iStat->SetText(buf);

			iTime->SetValue(keys[index].time,FALSE);
			iFace->SetValue((int)keys[index].face,FALSE);
			iA->SetValue(keys[index].u0,FALSE);
			iB->SetValue(keys[index].u1,FALSE);
			iTens->SetValue(ToTCBUI(keys[index].tens),FALSE);
			iCont->SetValue(ToTCBUI(keys[index].cont),FALSE);
			iBias->SetValue(ToTCBUI(keys[index].bias),FALSE);
			iEaseTo->SetValue(ToEaseUI(keys[index].easeIn),FALSE);
			iEaseFrom->SetValue(ToEaseUI(keys[index].easeOut),FALSE);			

			UpdateTCBGraph();
			EnableWindow(GetDlgItem(hWnd,IDC_TCB_GRAPH),TRUE);			
			
			UpdateBaryGraph();
			EnableWindow(GetDlgItem(hWnd,IDC_ATTACH_FACEPOSGRAPH),TRUE);
			}

		CheckDlgButton(hWnd,IDC_ATTACH_ALIGN,align);
		if (node) {
			SetDlgItemText(hWnd,IDC_ATTACH_OBNAME,node->GetName());
		} else {
			SetDlgItemText(hWnd,IDC_ATTACH_OBNAME,GetString(IDS_RB_NONE));
			}

		CheckDlgButton(hWnd,IDC_ATTACH_MANUPDATE,manUpdate);
		if (manUpdate) iUpdate->Enable();		
		else iUpdate->Disable();
		}
	}

void AttachCtrl::SetupWindow(HWND hWnd)
	{
	this->hWnd = hWnd;
	
	iTime = GetISpinner(GetDlgItem(hWnd,IDC_ATTACH_KEYTIMESPIN));
	iTime->SetLimits(GetAnimStart(),GetAnimEnd(),FALSE);
	iTime->SetScale(10.0f);
	iTime->LinkToEdit(GetDlgItem(hWnd,IDC_ATTACH_KEYTIME),EDITTYPE_TIME);

	iFace = GetISpinner(GetDlgItem(hWnd,IDC_ATTACH_KEYFACESPIN));	
	iFace->SetLimits(0,0xfffffff,FALSE);
	iFace->SetScale(0.1f);
	iFace->LinkToEdit(GetDlgItem(hWnd,IDC_ATTACH_KEYFACE),EDITTYPE_INT);
	
	iA = GetISpinner(GetDlgItem(hWnd,IDC_ATTACH_KEYASPIN));
	iA->SetLimits(-999999999.0f,999999999.0f,FALSE);
	iA->SetScale(0.005f);
	iA->LinkToEdit(GetDlgItem(hWnd,IDC_ATTACH_KEYA),EDITTYPE_FLOAT);
	
	iB = GetISpinner(GetDlgItem(hWnd,IDC_ATTACH_KEYBSPIN));
	iB->SetLimits(-999999999.0f,999999999.0f,FALSE);
	iB->SetScale(0.005f);
	iB->LinkToEdit(GetDlgItem(hWnd,IDC_ATTACH_KEYB),EDITTYPE_FLOAT);	

	iTens = GetISpinner(GetDlgItem(hWnd,IDC_ATTACH_KEYTENSSPIN));
	iTens->SetLimits(0.0f,50.0f,FALSE);
	iTens->SetScale(0.1f);
	iTens->LinkToEdit(GetDlgItem(hWnd,IDC_ATTACH_KEYTENS),EDITTYPE_FLOAT);
	
	iCont = GetISpinner(GetDlgItem(hWnd,IDC_ATTACH_KEYCONTSPIN));
	iCont->SetLimits(0.0f,50.0f,FALSE);
	iCont->SetScale(0.1f);
	iCont->LinkToEdit(GetDlgItem(hWnd,IDC_ATTACH_KEYCONT),EDITTYPE_FLOAT);
	
	iBias = GetISpinner(GetDlgItem(hWnd,IDC_ATTACH_KEYBIASSPIN));
	iBias->SetLimits(0.0f,50.0f,FALSE);
	iBias->SetScale(0.1f);
	iBias->LinkToEdit(GetDlgItem(hWnd,IDC_ATTACH_KEYBIAS),EDITTYPE_FLOAT);	

	iEaseTo = GetISpinner(GetDlgItem(hWnd,IDC_ATTACH_KEYEASETOSPIN));
	iEaseTo->SetLimits(0.0f,50.0f,FALSE);
	iEaseTo->SetScale(0.1f);
	iEaseTo->LinkToEdit(GetDlgItem(hWnd,IDC_ATTACH_KEYEASETO),EDITTYPE_FLOAT);	

	iEaseFrom = GetISpinner(GetDlgItem(hWnd,IDC_ATTACH_KEYEASEFROMSPIN));
	iEaseFrom->SetLimits(0.0f,50.0f,FALSE);
	iEaseFrom->SetScale(0.1f);
	iEaseFrom->LinkToEdit(GetDlgItem(hWnd,IDC_ATTACH_KEYEASEFROM),EDITTYPE_FLOAT);	

	iPickOb	= GetICustButton(GetDlgItem(hWnd,IDC_ATTACH_PICKOB));
	iPickOb->SetType(CBT_CHECK);	
	iPickOb->SetHighlightColor(GREEN_WASH);

	iSetPos	= GetICustButton(GetDlgItem(hWnd,IDC_ATTACH_SETPOS));
	iSetPos->SetType(CBT_CHECK);	
	iSetPos->SetHighlightColor(GREEN_WASH);

	iPrev	= GetICustButton(GetDlgItem(hWnd,IDC_PREVKEY));
	iNext	= GetICustButton(GetDlgItem(hWnd,IDC_NEXTKEY));
	iUpdate	= GetICustButton(GetDlgItem(hWnd,IDC_ATTACH_UPDATE));

	iStat   = GetICustStatus(GetDlgItem(hWnd,IDC_KEYNUM));
	iStat->SetTextFormat(STATUSTEXT_CENTERED);
	}

void AttachCtrl::DestroyWindow()
	{
	ReleaseICustStatus(iStat);
	ReleaseISpinner(iTime);
	ReleaseISpinner(iFace);
	ReleaseISpinner(iA);
	ReleaseISpinner(iB);
	ReleaseISpinner(iTens);
	ReleaseISpinner(iCont);
	ReleaseISpinner(iBias);
	ReleaseICustButton(iPickOb);
	ReleaseICustButton(iSetPos);
	ReleaseICustButton(iPrev);
	ReleaseICustButton(iNext);
	ReleaseICustButton(iUpdate);
	ReleaseISpinner(iEaseTo);
	ReleaseISpinner(iEaseFrom);
	iEaseTo = iEaseFrom = iTime = iFace = iA = 
		iB = iTens = iCont = iBias = NULL;
	iStat = NULL;
	iPickOb = iSetPos = iPrev = iNext = iUpdate = NULL;
	}

static BOOL CALLBACK AttachParamDialogProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	AttachCtrl *ctrl = (AttachCtrl*)GetWindowLong(hWnd,GWL_USERDATA);
	if (!ctrl && msg != WM_INITDIALOG) return FALSE;

	switch (msg) {
		case WM_INITDIALOG:
			ctrl = (AttachCtrl*)lParam;
			SetWindowLong(hWnd, GWL_USERDATA, lParam);
			ctrl->SetupWindow(hWnd);
			break;

		case WM_DESTROY:
			ctrl->DestroyWindow();
			break;

		case WM_PAINT:
			ctrl->UpdateUI();
			return FALSE;

		case WM_LBUTTONDOWN:case WM_LBUTTONUP:	case WM_MOUSEMOVE:
			ctrl->ip->RollupMouseMessage(hWnd,msg,wParam,lParam);
			return FALSE;

		case CC_SPINNER_BUTTONDOWN:			
			theHold.Begin();		
			break;

		case WM_CUSTEDIT_ENTER:
		case CC_SPINNER_BUTTONUP:
			if (HIWORD(wParam)) {
				theHold.Accept(GetString(IDS_RB_EDITATTACHKEY));
			} else {
				theHold.Cancel();
				}
			break;

		case CC_SPINNER_CHANGE:
			ctrl->SpinnerChange(LOWORD(wParam));
			break;

		case WM_COMMAND:
			ctrl->Command(LOWORD(wParam),lParam);
			break;

		default:
			return FALSE;
		}
	return TRUE;
	}


//--- PickObjectMode ------------------------------------------------

BOOL PickObjectMode::Filter(INode *node)
	{
	if (node) {
		ObjectState os = node->EvalWorldState(0);
		if (os.obj->CanConvertToType(triObjectClassID)) {			
			return TRUE;
			}
		}
	return FALSE;
	}

BOOL PickObjectMode::HitTest(
		IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags)
	{
	INode *node = cont->ip->PickNode(hWnd,m);	
	return node?TRUE:FALSE;
	}

BOOL PickObjectMode::Pick(IObjParam *ip,ViewExp *vpt)
	{
	INode *node = vpt->GetClosestHit();
	if (node) {
		ObjectState os = node->EvalWorldState(0);
		if (os.obj->CanConvertToType(triObjectClassID)) {
			if (cont->SetObject(node)) {								
				cont->ip->RedrawViews(cont->ip->GetTime());						
			} else {
				TSTR buf1 = GetString(IDS_RB_ATTACHCONTROLLER);
				TSTR buf2 = GetString(IDS_RB_ILLEGALOBJECT);
				MessageBox(ip->GetMAXHWnd(),buf2,buf1,MB_OK|MB_ICONEXCLAMATION);
				}
			}
		}
	return TRUE;
	}

void PickObjectMode::EnterMode(IObjParam *ip)
	{cont->iPickOb->SetCheck(TRUE);}

void PickObjectMode::ExitMode(IObjParam *ip)
	{cont->iPickOb->SetCheck(FALSE);}


//--- SetPosMode ------------------------------------------------

void SetPosMouseProc::SetPos(HWND hWnd,IPoint2 m)
	{
	if (!cont->node) return;
	ViewExp *vpt = ip->GetViewport(hWnd);
	if (!vpt) return;

	Ray ray, wray;
	float at;
	TimeValue t = ip->GetTime();	
	Point3 norm, pt, bary;
	DWORD fi;
	Interval valid;
	
	// Calculate a ray from the mouse point
	vpt->MapScreenToWorldRay(float(m.x), float(m.y),wray);	

	// Back transform the ray into object space.		
	Matrix3 obtm  = cont->node->GetObjTMAfterWSM(t);
	Matrix3 iobtm = Inverse(obtm);
	ray.p   = iobtm * wray.p;
	ray.dir = VectorTransform(iobtm, wray.dir);	

	// Evaluate the node
	ObjectState os = cont->node->EvalWorldState(t);
	TriObject *obj = NULL;
	BOOL needsDel = FALSE;

	// Convert it to a tri object
	if (os.obj->IsSubClassOf(triObjectClassID)) {
		obj = (TriObject*)os.obj;
		needsDel = FALSE;
	} else {
		if (os.obj->CanConvertToType(triObjectClassID)) {
			Object *oldObj = os.obj;
			obj = (TriObject*)
				os.obj->ConvertToType(t,triObjectClassID);
			needsDel = (obj != oldObj);
			}
		}
	if (!obj) return;

	if (obj->GetMesh().IntersectRay(ray, at, norm, fi, bary)) {
		cont->HoldTrack();
		cont->SetKeyPos(t, fi, bary);
		}
	
	if (needsDel) obj->DeleteThis();
	ip->ReleaseViewport(vpt);
	}

int SetPosMouseProc::proc(
		HWND hWnd, int msg, int point, int flags, IPoint2 m)
	{
	static BOOL animated = FALSE;
	switch (msg) {
		case MOUSE_POINT:
			if (point==0) {
				animated = FALSE;
				if (!Animating() && cont->keys.Count()==1) {
					int index = cont->GetKeyIndex(ip->GetTime());
					if (index<0) {
						animated = TRUE;
						}
					}
				theHold.Begin();
				ip->RedrawViews(ip->GetTime(),REDRAW_BEGIN);
			} else {
				if (animated) {
					int res = MessageBox(hWnd,
						_T("Are you sure you want to animate the position of this object?"),
						_T("Attachment Controller"),
						MB_ICONQUESTION|MB_YESNO);
					if (res!=IDYES) {
						theHold.Cancel();
						ip->RedrawViews(ip->GetTime(),REDRAW_END);
						return FALSE;
						}
					}
				theHold.Accept(GetString(IDS_RB_EDITATTACHKEY));
				ip->RedrawViews(ip->GetTime(),REDRAW_END);
				}
			break;

		case MOUSE_MOVE: {
			theHold.Restore();
			SetPos(hWnd,m);
			ip->RedrawViews(ip->GetTime(),REDRAW_INTERACTIVE);			
			break;
			}

		case MOUSE_ABORT:
			theHold.Cancel();
			ip->RedrawViews(ip->GetTime(),REDRAW_END);
			break;

		case MOUSE_FREEMOVE:			
			SetCursor(ip->GetSysCursor(SYSCUR_SELECT));
			break;
		}
	return TRUE;
	}


void SetPosCMode::EnterMode()
	{
	if (cont->iSetPos) cont->iSetPos->SetCheck(TRUE);
	}

void SetPosCMode::ExitMode()
	{
	if (cont->iSetPos) cont->iSetPos->SetCheck(FALSE);
	}


//--- Barycentric graph ----------------------------------------------

static LRESULT CALLBACK BaryGraphWindowProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	Point2 *bary = (Point2*)GetWindowLong(hWnd,GWL_USERDATA);
	static int mx, my;
	static Point2 oldBary;
	static BOOL mDown = FALSE;

	switch (msg) {
		case WM_CREATE:
			SetWindowLong(hWnd,GWL_USERDATA,(LONG)new Point2(0.33f,0.33f));
			break;

		case WM_SETBARY: {
			Point2 *nb = (Point2*)lParam;
			*bary = *nb;
			InvalidateRect(hWnd,NULL,TRUE);
			break;
			}

		case WM_GETBARY: {
			Point2 *nb = (Point2*)lParam;
			*nb = *bary;
			break;
			}

		case WM_ENABLE:
			InvalidateRect(hWnd,NULL,TRUE);
			break;

		case WM_LBUTTONDOWN:
			mDown = TRUE;
			mx = LOWORD(lParam);
			my = HIWORD(lParam);
			oldBary = *bary;
			SetCapture(hWnd);
			SendMessage(GetParent(hWnd),WM_COMMAND,IDC_ATTACH_FACEPOSGRAPH,
				MAKELPARAM(BARYGRAPH_DOWN,0));
			// Fallthrough

		case WM_MOUSEMOVE:
			if (mDown) {
				Rect rect;
				GetClientRect(hWnd,&rect);
				int x = (short)LOWORD(lParam) - 5;
				int y = (short)HIWORD(lParam) - 5;			
				float u = float(x)/float(rect.w()-11);
				float v = 1.0f-float(y)/float(rect.h()-11);
				
				bary->x = v;				
				bary->y = 1.0f-v-u;
				SendMessage(GetParent(hWnd),WM_COMMAND,IDC_ATTACH_FACEPOSGRAPH,
					MAKELPARAM(BARYGRAPH_MOVE,0));
				}
			break;
		
		case WM_LBUTTONUP:
			mDown = FALSE;
			ReleaseCapture();
			SendMessage(GetParent(hWnd),WM_COMMAND,IDC_ATTACH_FACEPOSGRAPH,
				MAKELPARAM(BARYGRAPH_UP,TRUE));
			break;
		
		case WM_RBUTTONDOWN:
			mDown = FALSE;
			*bary = oldBary;
			ReleaseCapture();
			SendMessage(GetParent(hWnd),WM_COMMAND,IDC_ATTACH_FACEPOSGRAPH,
				MAKELPARAM(BARYGRAPH_UP,FALSE));
			break;

		case WM_PAINT: {
			PAINTSTRUCT ps;
			HDC hdc = BeginPaint(hWnd,&ps);
			Rect rect, orect;
			GetClientRect(hWnd,&rect);
			orect = rect;
			
			if (IsWindowEnabled(hWnd)) {
				rect.left   += 5;
				rect.right  -= 5;
				rect.top    += 5;
				rect.bottom -= 5;
				IPoint2 pt0(rect.left,rect.top);
				IPoint2 pt1(rect.left,rect.bottom);
				IPoint2 pt2(rect.right,rect.bottom);
				SelectObject(hdc,GetStockObject(BLACK_PEN));
				MoveToEx(hdc,pt0.x, pt0.y,NULL);
				LineTo(hdc,pt1.x, pt1.y);
				LineTo(hdc,pt2.x, pt2.y);
				LineTo(hdc,pt0.x, pt0.y);
				
				IPoint2 pt( 
					int(pt0.x*bary->x + pt1.x*bary->y + pt2.x*(1.0f-bary->x-bary->y)),
					int(pt0.y*bary->x + pt1.y*bary->y + pt2.y*(1.0f-bary->x-bary->y)));

				SelectObject(hdc,CreatePen(PS_SOLID,0,RGB(255,0,0)));
				MoveToEx(hdc,pt.x, pt.y-3,NULL);
				LineTo(hdc,pt.x, pt.y+4);
				MoveToEx(hdc,pt.x-3, pt.y,NULL);
				LineTo(hdc,pt.x+4, pt.y);
				DeleteObject(SelectObject(hdc,GetStockObject(BLACK_PEN)));
				}

			WhiteRect3D(hdc,orect,TRUE);
			EndPaint(hWnd,&ps);
			break;
			}

		case WM_DESTROY:
			delete bary;
			break;

		default:
			return DefWindowProc(hWnd,msg,wParam,lParam);
		}

	return 0;
	}

//--- Key Dialog ----------------------------------------------------


static BOOL CALLBACK AttachDlgProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

#define ATTACHDLG_CLASS_ID Class_ID(0x8736fff2,0xaab37f23)

class AttachKeyDlg : public ReferenceMaker {
	public:
		HWND hWnd;
		AttachCtrl *cont;
		IObjParam *ip;
		BOOL valid;
		ISpinnerControl *iTime, *iFace, *iA, *iB, *iTens, *iCont, *iBias, *iEaseTo, *iEaseFrom;
		ICustButton *iPrev, *iNext;
		ICustStatus *iStat;

		AttachKeyDlg(AttachCtrl *c,TCHAR *pname,IObjParam *ip,HWND hParent);
		~AttachKeyDlg();

		Class_ID ClassID() {return ATTACHDLG_CLASS_ID;}
		SClass_ID SuperClassID() {return REF_MAKER_CLASS_ID;}
		RefResult NotifyRefChanged(Interval iv, RefTargetHandle hTarg,PartID& partID,RefMessage msg);
		int NumRefs() {return 1;}
		RefTargetHandle GetReference(int i) {return cont;}
		void SetReference(int i, RefTargetHandle rtarg) {cont=(AttachCtrl*)rtarg;}

		void MaybeCloseWindow();
		void Invalidate();
		void Update();
		void UpdateBaryGraph(float a, float b);
		void UpdateTCBGraph(float t, float c, float b, float easeIn, float easeOut);
		void SetupUI(HWND hWnd);
		void Command(int id, LPARAM lParam);
		void SpinnerChange(int id);		
	};

void AttachCtrl::EditTrackParams(
			TimeValue t,
			ParamDimensionBase *dim,
			TCHAR *pname,
			HWND hParent,
			IObjParam *ip,
			DWORD flags)
	{
	RegisterClasses();
	new	AttachKeyDlg(this,pname,ip,hParent);
	}

AttachKeyDlg::AttachKeyDlg(
		AttachCtrl *c,TCHAR *pname,IObjParam *ip,HWND hParent)
	{
	valid = FALSE;
	cont  = NULL;
	hWnd  = NULL;
	this->ip = ip;
	MakeRefByID(FOREVER,0,c);
	hWnd = CreateDialogParam(
		hInstance,
		MAKEINTRESOURCE(IDD_ATTACH_DIALOG),
		hParent,
		AttachDlgProc,
		(LPARAM)this);	
	TSTR title = TSTR(GetString(IDS_RB_ATTACHTITLE)) + TSTR(pname);
	SetWindowText(hWnd,title);
	}

AttachKeyDlg::~AttachKeyDlg()
	{
	DeleteAllRefsFromMe();
	ReleaseICustStatus(iStat);
	ReleaseISpinner(iTime);
	ReleaseISpinner(iFace);
	ReleaseISpinner(iA);
	ReleaseISpinner(iB);
	ReleaseISpinner(iTens);
	ReleaseISpinner(iCont);
	ReleaseISpinner(iBias);	
	ReleaseICustButton(iPrev);
	ReleaseICustButton(iNext);
	ReleaseISpinner(iEaseTo);
	ReleaseISpinner(iEaseFrom);
	}

class CheckForNonAttachDlg : public DependentEnumProc {
	public:		
		BOOL non;
		ReferenceMaker *me;
		CheckForNonAttachDlg(ReferenceMaker *m) {non = FALSE;me = m;}
		int proc(ReferenceMaker *rmaker) {
			if (rmaker==me) return 0;
			if (rmaker->SuperClassID()!=REF_MAKER_CLASS_ID &&
				rmaker->ClassID()!=ATTACHDLG_CLASS_ID) {
				non = TRUE;
				return 1;
				}
			return 0;
			}
	};
void AttachKeyDlg::MaybeCloseWindow()
	{
	CheckForNonAttachDlg check(cont);
	cont->EnumDependents(&check);
	if (!check.non) {
		PostMessage(hWnd,WM_CLOSE,0,0);
		}
	}


void AttachKeyDlg::SpinnerChange(int id)
	{
	cont->HoldTrack();
	
	for (int index=0; index<cont->keys.Count(); index++) {
		if (!(cont->keys[index].flags&KEY_SELECTED)) continue;
		switch (id) {
			case IDC_ATTACH_KEYTIMESPIN:
				cont->keys[index].time = iTime->GetIVal();				
				break;
			case IDC_ATTACH_KEYFACESPIN:
				cont->keys[index].face = iFace->GetIVal();
				break;
			case IDC_ATTACH_KEYASPIN:
				cont->keys[index].u0 = iA->GetFVal();				
				break;
			case IDC_ATTACH_KEYBSPIN:
				cont->keys[index].u1 = iB->GetFVal();				
				break;
			case IDC_ATTACH_KEYTENSSPIN:
				cont->keys[index].tens = FromTCBUI(iTens->GetFVal());				
				break;
			case IDC_ATTACH_KEYCONTSPIN:
				cont->keys[index].cont = FromTCBUI(iCont->GetFVal());				
				break;
			case IDC_ATTACH_KEYBIASSPIN:
				cont->keys[index].bias = FromTCBUI(iBias->GetFVal());				
				break;
			case IDC_ATTACH_KEYEASETOSPIN:
				cont->keys[index].easeIn = FromEaseUI(iEaseTo->GetFVal());				
				break;
			case IDC_ATTACH_KEYEASEFROMSPIN:
				cont->keys[index].easeOut = FromEaseUI(iEaseFrom->GetFVal());				
				break;
			}
		}

	cont->Invalidate();
	cont->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime());
	UpdateWindow(hWnd);
	}

void AttachKeyDlg::Command(int id, LPARAM lParam)
	{
	switch (id) {		
		case IDC_PREVKEY: {
			int n=0;
			for (int i=0; i<cont->keys.Count(); i++) {
				if (cont->keys[i].flags&KEY_SELECTED) {
					if (i) n = i-1;
					else n = cont->keys.Count()-1;
					}
				}
			for (i=0; i<cont->keys.Count(); i++) {
				if (i==n) cont->keys[i].flags |=  KEY_SELECTED;
				else      cont->keys[i].flags &= ~KEY_SELECTED;
				}
			cont->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
			break;
			}

		case IDC_NEXTKEY: {
			int n=0;
			for (int i=0; i<cont->keys.Count(); i++) {
				if (cont->keys[i].flags&KEY_SELECTED) {
					if (i<cont->keys.Count()-1) n = i+1;
					else n = 0;
					}
				}
			for (i=0; i<cont->keys.Count(); i++) {
				if (i==n) cont->keys[i].flags |=  KEY_SELECTED;
				else      cont->keys[i].flags &= ~KEY_SELECTED;
				}
			cont->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
			break;
			}

		case IDC_ATTACH_FACEPOSGRAPH:
			switch (LOWORD(lParam)) {
				case BARYGRAPH_DOWN:
					theHold.Begin();
					break;

				case BARYGRAPH_UP:
					if (HIWORD(lParam)) theHold.Accept(GetString(IDS_RB_EDITATTACHKEY));
					else theHold.Cancel();
					break;

				case BARYGRAPH_MOVE: {
					cont->HoldTrack();
					Point2 bary;
					SendDlgItemMessage(hWnd,IDC_ATTACH_FACEPOSGRAPH,
						WM_GETBARY, 0, (LPARAM)&bary);
					
					for (int index=0; index<cont->keys.Count(); index++) {
						if (!(cont->keys[index].flags&KEY_SELECTED)) continue;
						cont->keys[index].u0 = bary.x;
						cont->keys[index].u1 = bary.y;
						}
					cont->Invalidate();
					cont->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);					
					ip->RedrawViews(ip->GetTime());
					UpdateWindow(hWnd);
					break;
					}
				}
			break;
		}
	}


void AttachKeyDlg::Invalidate()
	{
	valid = FALSE;
	InvalidateRect(hWnd,NULL,FALSE);
	}

void AttachKeyDlg::UpdateBaryGraph(float a, float b)
	{
	Point2 pt(a,b);
	SendDlgItemMessage(hWnd,IDC_ATTACH_FACEPOSGRAPH,WM_SETBARY,0,(LONG)&pt);
	UpdateWindow(GetDlgItem(hWnd,IDC_ATTACH_FACEPOSGRAPH));
	}

void AttachKeyDlg::UpdateTCBGraph(
		float t, float c, float b, float easeIn, float easeOut)
	{
	TCBGraphParams tp;
	tp.tens     = t;
	tp.cont     = c;
	tp.bias     = b;
	tp.easeTo   = easeIn;
	tp.easeFrom = easeOut;
	SendDlgItemMessage(hWnd,IDC_TCB_GRAPH,WM_SETTCBGRAPHPARAMS,0,(LPARAM)&tp);
	UpdateWindow(GetDlgItem(hWnd,IDC_TCB_GRAPH));
	}

void AttachKeyDlg::Update()
	{
	if (valid || !hWnd) return;
	valid = TRUE;
	BOOL init = FALSE;
	TimeValue time;
	DWORD face;
	float a=0.0f, b=0.0f, tens=0.0f, cnt=0.0f, bias=0.0f, easeTo=0.0f, easeFrom=0.0f;
	BOOL common[9] = {0,0,0,0,0,0,0,0,0};
	int selIndex = -1, selCount=0;

	for (int i=0; i<cont->keys.Count(); i++) {
		if (!(cont->keys[i].flags&KEY_SELECTED)) continue;
		selCount++;

		if (!init) {
			init     = TRUE;
			time     = cont->keys[i].time;
			a        = cont->keys[i].u0;
			b        = cont->keys[i].u1;
			tens     = cont->keys[i].tens;
			cnt      = cont->keys[i].cont;
			bias     = cont->keys[i].bias;
			easeTo   = cont->keys[i].easeIn;
			easeFrom = cont->keys[i].easeOut;
			face     = cont->keys[i].face;
			selIndex = i;
			for (int j=0; j<9; j++) common[j] = TRUE;
		} else {
			if (time    !=cont->keys[i].time)     common[0] = FALSE;
			if (a       !=cont->keys[i].u0)       common[1] = FALSE;
			if (b       !=cont->keys[i].u1)       common[2] = FALSE;
			if (tens    !=cont->keys[i].tens)     common[3] = FALSE;
			if (cnt     !=cont->keys[i].cont)     common[4] = FALSE;
			if (bias    !=cont->keys[i].bias)     common[5] = FALSE;
			if (easeTo  !=cont->keys[i].easeIn)   common[6] = FALSE;
			if (easeFrom!=cont->keys[i].easeOut)  common[7] = FALSE;
			if (face    !=cont->keys[i].face)     common[8] = FALSE;
			selIndex = -1;
			}
		}

	UpdateBaryGraph(a,b);
	if (common[3]&&common[4]&&common[5]&&common[6]&&common[7]) {
		UpdateTCBGraph(tens,cnt,bias,easeTo,easeFrom);
		EnableWindow(GetDlgItem(hWnd,IDC_TCB_GRAPH),TRUE);
	} else {
		EnableWindow(GetDlgItem(hWnd,IDC_TCB_GRAPH),FALSE);
		}

	if (selIndex>=0) {
		TSTR buf;
		buf.printf(_T("%d"),selIndex+1);
		iStat->SetText(buf);
	} else {
		iStat->SetText(_T(""));
		}

	if (selCount==0) {
		iTime->Disable();
		iA->Disable();
		iB->Disable();
		iTens->Disable();
		iCont->Disable();
		iBias->Disable();
		iEaseTo->Disable();
		iEaseFrom->Disable();
		iFace->Disable();
		EnableWindow(GetDlgItem(hWnd,IDC_ATTACH_FACEPOSGRAPH),FALSE);
		return;
	} else {
		iTime->Enable();
		iA->Enable();
		iB->Enable();
		iTens->Enable();
		iCont->Enable();
		iBias->Enable();
		iEaseTo->Enable();
		iEaseFrom->Enable();
		iFace->Enable();
		EnableWindow(GetDlgItem(hWnd,IDC_ATTACH_FACEPOSGRAPH),TRUE);
		}

	if (common[0]) {
		iTime->SetIndeterminate(FALSE);
		iTime->SetValue(time,FALSE);
	} else {
		iTime->SetIndeterminate(TRUE);		
		}
	if (common[1]) {
		iA->SetIndeterminate(FALSE);
		iA->SetValue(a,FALSE);
	} else {
		iA->SetIndeterminate(TRUE);		
		}
	if (common[2]) {
		iB->SetIndeterminate(FALSE);
		iB->SetValue(b,FALSE);
	} else {
		iB->SetIndeterminate(TRUE);		
		}
	if (common[3]) {
		iTens->SetIndeterminate(FALSE);
		iTens->SetValue(ToTCBUI(tens),FALSE);
	} else {
		iTens->SetIndeterminate(TRUE);		
		}
	if (common[4]) {
		iCont->SetIndeterminate(FALSE);
		iCont->SetValue(ToTCBUI(cnt),FALSE);
	} else {
		iCont->SetIndeterminate(TRUE);		
		}
	if (common[5]) {
		iBias->SetIndeterminate(FALSE);
		iBias->SetValue(ToTCBUI(bias),FALSE);
	} else {
		iBias->SetIndeterminate(TRUE);		
		}
	if (common[6]) {
		iEaseTo->SetIndeterminate(FALSE);
		iEaseTo->SetValue(ToEaseUI(easeTo),FALSE);
	} else {
		iEaseTo->SetIndeterminate(TRUE);		
		}
	if (common[7]) {
		iEaseFrom->SetIndeterminate(FALSE);
		iEaseFrom->SetValue(ToEaseUI(easeFrom),FALSE);
	} else {
		iEaseFrom->SetIndeterminate(TRUE);		
		}
	if (common[8]) {
		iFace->SetIndeterminate(FALSE);
		iFace->SetValue((int)face,FALSE);
	} else {
		iFace->SetIndeterminate(TRUE);		
		}	
	}

void AttachKeyDlg::SetupUI(HWND hWnd)
	{
	this->hWnd = hWnd;
	
	iTime = GetISpinner(GetDlgItem(hWnd,IDC_ATTACH_KEYTIMESPIN));
	iTime->SetLimits(GetAnimStart(),GetAnimEnd(),FALSE);
	iTime->SetScale(10.0f);
	iTime->LinkToEdit(GetDlgItem(hWnd,IDC_ATTACH_KEYTIME),EDITTYPE_TIME);

	iFace = GetISpinner(GetDlgItem(hWnd,IDC_ATTACH_KEYFACESPIN));	
	iFace->SetLimits(0,0xfffffff,FALSE);
	iFace->SetScale(0.1f);
	iFace->LinkToEdit(GetDlgItem(hWnd,IDC_ATTACH_KEYFACE),EDITTYPE_INT);
	
	iA = GetISpinner(GetDlgItem(hWnd,IDC_ATTACH_KEYASPIN));
	iA->SetLimits(-999999999.0f,999999999.0f,FALSE);
	iA->SetScale(0.005f);
	iA->LinkToEdit(GetDlgItem(hWnd,IDC_ATTACH_KEYA),EDITTYPE_FLOAT);
	
	iB = GetISpinner(GetDlgItem(hWnd,IDC_ATTACH_KEYBSPIN));
	iB->SetLimits(-999999999.0f,999999999.0f,FALSE);
	iB->SetScale(0.005f);
	iB->LinkToEdit(GetDlgItem(hWnd,IDC_ATTACH_KEYB),EDITTYPE_FLOAT);	

	iTens = GetISpinner(GetDlgItem(hWnd,IDC_ATTACH_KEYTENSSPIN));
	iTens->SetLimits(0.0f,50.0f,FALSE);
	iTens->SetScale(0.1f);
	iTens->LinkToEdit(GetDlgItem(hWnd,IDC_ATTACH_KEYTENS),EDITTYPE_FLOAT);
	
	iCont = GetISpinner(GetDlgItem(hWnd,IDC_ATTACH_KEYCONTSPIN));
	iCont->SetLimits(0.0f,50.0f,FALSE);
	iCont->SetScale(0.1f);
	iCont->LinkToEdit(GetDlgItem(hWnd,IDC_ATTACH_KEYCONT),EDITTYPE_FLOAT);
	
	iBias = GetISpinner(GetDlgItem(hWnd,IDC_ATTACH_KEYBIASSPIN));
	iBias->SetLimits(0.0f,50.0f,FALSE);
	iBias->SetScale(0.1f);
	iBias->LinkToEdit(GetDlgItem(hWnd,IDC_ATTACH_KEYBIAS),EDITTYPE_FLOAT);	

	iEaseTo = GetISpinner(GetDlgItem(hWnd,IDC_ATTACH_KEYEASETOSPIN));
	iEaseTo->SetLimits(0.0f,50.0f,FALSE);
	iEaseTo->SetScale(0.1f);
	iEaseTo->LinkToEdit(GetDlgItem(hWnd,IDC_ATTACH_KEYEASETO),EDITTYPE_FLOAT);	

	iEaseFrom = GetISpinner(GetDlgItem(hWnd,IDC_ATTACH_KEYEASEFROMSPIN));
	iEaseFrom->SetLimits(0.0f,50.0f,FALSE);
	iEaseFrom->SetScale(0.1f);
	iEaseFrom->LinkToEdit(GetDlgItem(hWnd,IDC_ATTACH_KEYEASEFROM),EDITTYPE_FLOAT);	
	
	iPrev	= GetICustButton(GetDlgItem(hWnd,IDC_PREVKEY));
	iNext	= GetICustButton(GetDlgItem(hWnd,IDC_NEXTKEY));

	iStat   = GetICustStatus(GetDlgItem(hWnd,IDC_KEYNUM));
	iStat->SetTextFormat(STATUSTEXT_CENTERED);
	}

RefResult AttachKeyDlg::NotifyRefChanged(
		Interval iv, RefTargetHandle hTarg,
		PartID& partID,RefMessage msg)
	{
	switch (msg) {
		case REFMSG_CHANGE:
			Invalidate();			
			break;
		
		case REFMSG_REF_DELETED:
			MaybeCloseWindow();
			break;
		}
	return REF_SUCCEED;
	}

static BOOL CALLBACK AttachDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	AttachKeyDlg *dlg = (AttachKeyDlg*)GetWindowLong(hWnd,GWL_USERDATA);
	
	switch (msg) {
		case WM_INITDIALOG:
			dlg = (AttachKeyDlg*)lParam;
			SetWindowLong(hWnd,GWL_USERDATA,lParam);
			dlg->SetupUI(hWnd);
			CenterWindow(hWnd,GetParent(hWnd));
			ShowWindow(hWnd,SW_SHOW);
			break;

		case WM_CLOSE:
			DestroyWindow(hWnd);			
			break;

		case WM_DESTROY:						
			delete dlg;
			break;

		case WM_PAINT:
			dlg->Update();
			return FALSE;

		case CC_SPINNER_BUTTONDOWN:			
			theHold.Begin();		
			break;

		case WM_CUSTEDIT_ENTER:
		case CC_SPINNER_BUTTONUP:
			if (HIWORD(wParam)) {
				theHold.Accept(GetString(IDS_RB_EDITATTACHKEY));
			} else {
				theHold.Cancel();
				}
			break;

		case CC_SPINNER_CHANGE:
			dlg->SpinnerChange(LOWORD(wParam));
			break;

		case WM_COMMAND:
			dlg->Command(LOWORD(wParam),lParam);
			break;

		default:
			return FALSE;
		}
	return TRUE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Control\boolctrl.cpp ===
/**********************************************************************
 *<
	FILE: boolctrl.cpp

	DESCRIPTION: A boolean controller

	CREATED BY: Rolf Berteig

	HISTORY: 11/18/96

 *>	Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/
#include "ctrl.h"
#include "units.h"
#include "exprlib.h"

#define BOOL_CONTROL_CLASS_ID	Class_ID(0x984b8d27,0x938f3e43)
#define BOOL_CONTROL_CNAME		GetString(IDS_RB_BOOLCONTROL)

#define KEY_SELECTED	(1<<0)
#define KEY_FLAGGED		(1<<1)

#define MAKEBOOL(fl) ( (fl)<=0.0f ? FALSE : TRUE )

class BKey {
	public:
		TimeValue time;
		DWORD flags;

		BKey() {flags=0;}
		BKey(TimeValue t) {time=t; flags=0;}
	};

class BoolControl : public StdControl {
	public:				
		Tab<BKey> keys;
		Interval range, valid;
		BOOL onOff, startOnOff, rangeLinked;

		BoolControl();
				
		// Animatable methods		
		void DeleteThis() {delete this;}		
		int IsKeyable() {return 1;}
		BOOL IsAnimated() {return keys.Count()?TRUE:FALSE;}
		Class_ID ClassID() {return BOOL_CONTROL_CLASS_ID;} 
		SClass_ID SuperClassID() {return CTRL_FLOAT_CLASS_ID;}
		void GetClassName(TSTR& s) {s = BOOL_CONTROL_CNAME;}

		// Reference methods
		RefResult NotifyRefChanged(Interval, RefTargetHandle, PartID&, RefMessage) {return REF_SUCCEED;}
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);
		RefTargetHandle Clone(RemapDir &remap = NoRemap());

		// Control methods				
		void Copy(Control *from);
		BOOL IsLeaf() {return TRUE;}
		void CommitValue(TimeValue t) {}
		void RestoreValue(TimeValue t) {}
		
		void HoldTrack();
		Interval GetTimeRange(DWORD flags);
		void EditTimeRange(Interval range,DWORD flags);
		void MapKeys(TimeMap *map,DWORD flags );
		
		int NumKeys() {return keys.Count();}
		TimeValue GetKeyTime(int index) {return keys[index].time;}
		int GetKeyIndex(TimeValue t);		
		void DeleteKeyAtTime(TimeValue t);
		BOOL IsKeyAtTime(TimeValue t,DWORD flags);		
		void DeleteTime(Interval iv, DWORD flags);
		void ReverseTime(Interval iv, DWORD flags);
		void ScaleTime(Interval iv, float s);
		void InsertTime(TimeValue ins, TimeValue amount);
		BOOL SupportTimeOperations() {return TRUE;}
		void DeleteKeys(DWORD flags);
		void DeleteKeyByIndex(int index);
		void SelectKeys(TrackHitTab& sel, DWORD flags);
		void SelectKeyByIndex(int i,BOOL sel);
		void FlagKey(TrackHitRecord hit);
		int GetFlagKeyIndex();
		int NumSelKeys();
		void CloneSelectedKeys(BOOL offset=FALSE);
		void AddNewKey(TimeValue t,DWORD flags);		
		BOOL IsKeySelected(int index);
		BOOL CanCopyTrack(Interval iv, DWORD flags) {return TRUE;}
		BOOL CanPasteTrack(TrackClipObject *cobj,Interval iv, DWORD flags) {return cobj->ClassID()==ClassID();}
		TrackClipObject *CopyTrack(Interval iv, DWORD flags);
		void PasteTrack(TrackClipObject *cobj,Interval iv, DWORD flags);
		int GetSelKeyCoords(TimeValue &t, float &val,DWORD flags);
		void SetSelKeyCoords(TimeValue t, float val,DWORD flags);
		int SetSelKeyCoordsExpr(ParamDimension *dim,TCHAR *timeExpr, TCHAR *valExpr, DWORD flags);

		int HitTestTrack(			
			TrackHitTab& hits,
			Rect& rcHit,
			Rect& rcTrack,			
			float zoom,
			int scroll,
			DWORD flags);
		int PaintTrack(
			ParamDimensionBase *dim,
			HDC hdc,
			Rect& rcTrack,
			Rect& rcPaint,
			float zoom,
			int scroll,
			DWORD flags);
		

		// StdControl methods
		void GetValueLocalTime(TimeValue t, void *val, Interval &valid, GetSetMethod method=CTRL_ABSOLUTE) {GetValue(t,val,valid,method);}
		void GetValue(TimeValue t, void *val, Interval &valid, GetSetMethod method=CTRL_ABSOLUTE);
		void SetValueLocalTime(TimeValue t, void *val, int commit, GetSetMethod method);
		void Extrapolate(Interval range,TimeValue t,void *val,Interval &valid,int type);		
		void *CreateTempValue() {return new float;}
		void DeleteTempValue(void *val) {delete (float*)val;}
		void ApplyValue(void *val, void *delta) {*((float*)val) += *((float*)delta);}
		void MultiplyValue(void *val, float m) {*((float*)val) *= m;}

		void SortKeys();
		
	};

class BoolClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading) {return new BoolControl();}
	const TCHAR *	ClassName() {return BOOL_CONTROL_CNAME;}
	SClass_ID		SuperClassID() {return CTRL_FLOAT_CLASS_ID; }
	Class_ID		ClassID() {return BOOL_CONTROL_CLASS_ID;}
	const TCHAR* 	Category() {return _T("");}
	};
static BoolClassDesc boolCD;
ClassDesc* GetBoolControlDesc() {return &boolCD;}



class BoolControlRestore : public RestoreObj {
	public:
		Tab<BKey> undo;
		Tab<BKey> redo;
		Interval urange, rrange;
		BOOL onOffU, startOnOffU, rangeLinkedU;
		BOOL onOffR, startOnOffR, rangeLinkedR;
		BoolControl *cont;

		BoolControlRestore(BoolControl *c) {
			cont   = c;
			undo   = c->keys;			
			urange = c->range;
			onOffU  = c->onOff;
			startOnOffU  = c->startOnOff;
			rangeLinkedU = c->rangeLinked;
			}
		
		void Restore(int isUndo) {
			if (isUndo) {
				redo   = cont->keys;
				rrange = cont->range;
				onOffR  = cont->onOff;
				startOnOffR  = cont->startOnOff;
				rangeLinkedR = cont->rangeLinked;
				}
			cont->keys  = undo;
			cont->range = urange;
			cont->onOff       = onOffU;
			cont->startOnOff  = startOnOffU;
			cont->rangeLinked = rangeLinkedU;
			cont->NotifyDependents(FOREVER,0,REFMSG_CHANGE);
			}

		void Redo() {
			cont->keys  = redo;
			cont->range = rrange;
			cont->onOff       = onOffR;
			cont->startOnOff  = startOnOffR;
			cont->rangeLinked = rangeLinkedR;
			cont->NotifyDependents(FOREVER,0,REFMSG_CHANGE);
			}

		int Size() {return 1;}
		void EndHold() {cont->ClearAFlag(A_HELD);}
	};


class BoolClipObject : public TrackClipObject {
	public:
		Tab<BKey> tab;

		Class_ID ClassID() {return BOOL_CONTROL_CLASS_ID;}
		SClass_ID SuperClassID() { return CTRL_FLOAT_CLASS_ID; }
		void DeleteThis() {delete this;}

		BoolClipObject(Interval iv) : TrackClipObject(iv) {}
	};



//-----------------------------------------------------------------------------

BoolControl::BoolControl() 
	{
	startOnOff  = TRUE; 
	rangeLinked = TRUE;
	}

RefTargetHandle BoolControl::Clone(RemapDir &remap)
	{
	BoolControl *bc = new BoolControl;
	bc->range      = range;
	bc->valid      = valid;
	bc->keys       = keys;
	bc->onOff      = onOff;
	bc->startOnOff = startOnOff;
	CloneControl(bc,remap);
	return bc;
	}

#define KEYTIME_CHUNKID		0x0100
#define KEYFLAGS_CHUNKID	0x0110
#define NUMKEYS_CHUNKID		0x0130
#define INITSTATE_CHUNKID	0x0140

IOResult BoolControl::Save(ISave *isave)
	{
	ULONG nb;
	int ct = keys.Count();
	
	// Save the number of keys
	isave->BeginChunk(NUMKEYS_CHUNKID);
	isave->Write(&ct,sizeof(ct),&nb);
	isave->EndChunk();

	// Write each key
	for (int i=0; i<ct; i++) {
		isave->BeginChunk(KEYTIME_CHUNKID);
		isave->Write(&keys[i].time,sizeof(keys[i].time),&nb);
		isave->EndChunk();

		isave->BeginChunk(KEYFLAGS_CHUNKID);
		isave->Write(&keys[i].flags,sizeof(keys[i].flags),&nb);
		isave->EndChunk();		
		}

	// RB 5/3/99: This wasn't getting saved but it should be...
	isave->BeginChunk(INITSTATE_CHUNKID);
	isave->Write(&startOnOff,sizeof(startOnOff),&nb);
	isave->EndChunk();	
	
	return IO_OK;
	}

IOResult BoolControl::Load(ILoad *iload)
	{
	ULONG nb;
	int ct = 0;	
	IOResult res;

	if (IO_OK!=(res=iload->OpenChunk())) return res;
	assert(iload->CurChunkID()==NUMKEYS_CHUNKID);
	iload->Read(&ct,sizeof(ct),&nb);
	iload->CloseChunk();
	
	keys.SetCount(ct);

	for (int i=0; i<ct; i++) {
		iload->OpenChunk();
		assert(iload->CurChunkID()==KEYTIME_CHUNKID);
		iload->Read(&keys[i].time,sizeof(keys[i].time),&nb);
		iload->CloseChunk();
		
		iload->OpenChunk();
		assert(iload->CurChunkID()==KEYFLAGS_CHUNKID);
		iload->Read(&keys[i].flags,sizeof(keys[i].flags),&nb);
		iload->CloseChunk();		
		}

	// RB 5/3/99: Looks like this was originally setup to assume the chunks would be
	// in a fixed order. Which was OK then, but now that I have to add a chunk this
	// has to be more general. I'm going to leave the above code alone since those
	// chunks should always be present. We'll start looking for more chunks after...

	while (IO_OK==(res=iload->OpenChunk())) {
		switch (iload->CurChunkID()) {	
			case INITSTATE_CHUNKID:
				iload->Read(&startOnOff,sizeof(startOnOff),&nb);
				break;
			}

		iload->CloseChunk();
		if (res!=IO_OK)  return res;
		}

	return IO_OK;
	}

void BoolControl::Copy(Control *from)
	{	
	if (from) {
		if (from->SuperClassID()!=CTRL_FLOAT_CLASS_ID) return;
		TimeValue t;
		float s;
		Interval iv;
		TimeValue tpf = GetTicksPerFrame();
		Interval v = from->GetTimeRange(TIMERANGE_ALL);

		BOOL state = 1;
		TimeValue astart = GetAnimStart();
		if (v.Start()>astart) {
			from->GetValue(astart, &s, iv);
			if (s<=0.0f) {
				state = 0;
				AddNewKey(astart, 0);		
				}
			}

		for (t = v.Start(); t<=v.End(); t+=tpf) {
			from->GetValue(t, &s, iv);
			if (state) {
				if (s<=0.0f) {
					state = 0;
					AddNewKey(t, 0);		
					}
				}
			else {
				if (s>0.0f) {
					state = 1;
					AddNewKey(t, 0);		
					}
				}
			}
		}
	}


void BoolControl::HoldTrack()
	{
	if (theHold.Holding()&&!TestAFlag(A_HELD)) {		
		theHold.Put(new BoolControlRestore(this));
		SetAFlag(A_HELD);
		}
	}

void BoolControl::EditTimeRange(Interval range,DWORD flags)
	{
	HoldTrack();
	if (flags&EDITRANGE_LINKTOKEYS && keys.Count()) {
		this->range.Set(keys[0].time,keys[keys.Count()-1].time);
		rangeLinked = TRUE;
	} else {		
		rangeLinked = FALSE;
		this->range = range;		
		}
	valid.SetEmpty();
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

Interval BoolControl::GetTimeRange(DWORD flags)
	{
	if (rangeLinked && keys.Count()) 
		 return Interval(keys[0].time,keys[keys.Count()-1].time);
	else return range;
	}


int BoolControl::GetSelKeyCoords(TimeValue &t, float &val,DWORD flags) 
	{
	BOOL tfound=FALSE, tuncommon = FALSE;
	int n = keys.Count(), res;
	TimeValue atime;	
	
	for (int i = 0; i < n; i++ ) {		
		if (keys[i].flags & KEY_SELECTED) {
			if (tfound) {
				if (keys[i].time!=atime) {
					return KEYS_MULTISELECTED;
					}
			} else {
				tfound = TRUE;
				atime = keys[i].time;
				}
			}		
		if (tuncommon) return KEYS_MULTISELECTED;
		}
	t   = atime;	
	res = 0;
	if (tfound && !tuncommon) {
		res	|= KEYS_COMMONTIME;
		}	
	if (!tfound) {
		res = KEYS_NONESELECTED;
		}
	return res;
	}

int BoolControl::SetSelKeyCoordsExpr(
		ParamDimension *dim,
		TCHAR *timeExpr, TCHAR *valExpr, DWORD flags)
	{
	Expr texpr;
	float tfin, tfout=0.0f;

	if (timeExpr) {
		texpr.defVar(SCALAR_VAR,KEYCOORDS_TIMEVAR);
		if (texpr.load(timeExpr)!=EXPR_NORMAL) return KEYCOORDS_EXPR_ERROR;		
		}

	int n = keys.Count();
	if (!n) return KEYCOORDS_EXPR_OK;
	HoldTrack();

	for (int i=0; i<n; i++) {
		if (!(flags&KEYCOORDS_VALUEONLY)) {			
			if (keys[i].flags & KEY_SELECTED) {
				tfin = float(keys[i].time)/float(GetTicksPerFrame());
				texpr.eval(&tfout, 1, &tfin);
				keys[i].time = int(tfout*GetTicksPerFrame());
				}
			}
		}
	valid.SetEmpty();
	SortKeys();
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	return KEYCOORDS_EXPR_OK;
	}

void BoolControl::SetSelKeyCoords(TimeValue t, float val,DWORD flags)
	{
	int n = keys.Count();
	if (!n) return;
	HoldTrack();
	for (int i = 0; i < n; i++ ) {		
		if (!(flags&KEYCOORDS_VALUEONLY)) {			
			if (keys[i].flags & KEY_SELECTED) {
				keys[i].time = t;
				}		
			}
		}	
	valid.SetEmpty();
	SortKeys();
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

void BoolControl::MapKeys(TimeMap *map,DWORD flags)
	{
	int n = keys.Count();
	BOOL changed = FALSE;
	if (!n) return;
	HoldTrack();

	if (flags&TRACK_MAPRANGE) {		
		TimeValue t0 = map->map(range.Start());
		TimeValue t1 = map->map(range.End());
		range.Set(t0,t1);
		changed = TRUE;
		}	

	if (flags&TRACK_DOALL) {
		for (int i=0; i<n; i++) {			
			keys[i].time = map->map(keys[i].time);
			changed = TRUE;
			}
	} else 
	if (flags&TRACK_DOSEL) {
		BOOL slide = flags&TRACK_SLIDEUNSEL;
		TimeValue delta = 0, prev;
		int start, end, inc;
		if (flags&TRACK_RIGHTTOLEFT) {
			start = n-1;
			end = -1;
			inc = -1;
		} else {
			start = 0;
			end = n;
			inc = 1;
			} 
		for (int i=start; i!=end; i+=inc) {			
			if (keys[i].flags & KEY_SELECTED) {
				prev = keys[i].time;
				keys[i].time = map->map(keys[i].time);
				delta = keys[i].time - prev;
				changed = TRUE;
			} else if (slide) {
				keys[i].time += delta;
				}
			}
		}
	
	if (changed) {
		valid.SetEmpty();
		SortKeys();
		NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
		}
	}


int BoolControl::GetKeyIndex(TimeValue t)
	{
	for (int i=0; i<keys.Count(); i++) {
		if (keys[i].time==t) return i;
		if (keys[i].time<t) return -1;
		}
	return -1;
	}

void BoolControl::DeleteKeyAtTime(TimeValue t)
	{
	int index = GetKeyIndex(t);
	if (index>=0) {
		HoldTrack();
		keys.Delete(index,1);
		valid.SetEmpty();
		NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
		}
	}

BOOL BoolControl::IsKeyAtTime(TimeValue t,DWORD flags)
	{
	for (int i=0; i<keys.Count(); i++) {
		if (keys[i].time>t) return FALSE;
		if (keys[i].time==t) return TRUE;		
		}
	return FALSE;
	}

void BoolControl::DeleteTime(Interval iv, DWORD flags)
	{
	Interval test = TestInterval(iv,flags);
	int n = keys.Count();	
	int d = iv.Duration()-1;
	if (d<0) d = 0;
	HoldTrack();

	for (int i = n-1; i >= 0; i--) {
		if (test.InInterval(keys[i].time)) {
			keys.Delete(i,1);
		} else 
		if (!(flags&TIME_NOSLIDE)) {			
			if (keys[i].time > test.End()) {
				keys[i].time -= d;
				}
			}
		}		    
	
	valid.SetEmpty();
	SortKeys();
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

void BoolControl::ReverseTime(Interval iv, DWORD flags)
	{
	Interval test = TestInterval(iv,flags);
	int n = keys.Count();
	HoldTrack();

	for (int i = 0; i < n; i++) {		
		if (test.InInterval(keys[i].time)) {
			TimeValue delta = keys[i].time - iv.Start();
			keys[i].time = iv.End()-delta;			
			}
		}
	valid.SetEmpty();
	SortKeys();
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

void BoolControl::ScaleTime(Interval iv, float s)
	{
	int n = keys.Count();
	TimeValue delta = int(s*float(iv.End()-iv.Start())) + iv.Start()-iv.End();
	HoldTrack();

	for (int i = 0; i < n; i++) {		
		if (iv.InInterval(keys[i].time)) {
			keys[i].time = 
				int(s*float(keys[i].time - iv.Start())) + iv.Start();
		} else 
		if (keys[i].time > iv.End()) {
			keys[i].time += delta;
			}
		}
	valid.SetEmpty();
	SortKeys();
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

void BoolControl::InsertTime(TimeValue ins, TimeValue amount)
	{
	int n = keys.Count();		
	HoldTrack();

	for (int i = 0; i < n; i++) {		
		if (keys[i].time >= ins) {
			keys[i].time += amount;
			}		
		}
	valid.SetEmpty();
	SortKeys();
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

void BoolControl::DeleteKeys(DWORD flags)
	{
	int n = keys.Count();		
	HoldTrack();
	
	for (int i = n-1; i >= 0; i--) {
		if (flags&TRACK_DOALL || keys[i].flags&KEY_SELECTED) {
			keys.Delete(i,1);
			}
		}	
	valid.SetEmpty();
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

void BoolControl::DeleteKeyByIndex(int index)
	{
	HoldTrack();
	keys.Delete(index,1);
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

void BoolControl::SelectKeyByIndex(int i,BOOL sel)
	{
	HoldTrack();
	if (sel) keys[i].flags |=  KEY_SELECTED;
	else     keys[i].flags &= ~KEY_SELECTED;
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

void BoolControl::SelectKeys(TrackHitTab& sel, DWORD flags)
	{
	HoldTrack();
	
	if (flags&SELKEYS_CLEARKEYS) {
		int n = keys.Count();
		for (int i = 0; i < n; i++ ) {
			keys[i].flags &= ~KEY_SELECTED;
			}
		}
	
	if (flags&SELKEYS_DESELECT) {
		for (int i = 0; i < sel.Count(); i++ ) {			
			keys[sel[i].hit].flags &= ~KEY_SELECTED;
			}		
		} 	
	if (flags&SELKEYS_SELECT) {			
		for (int i = 0; i < sel.Count(); i++ ) {
			keys[sel[i].hit].flags |= KEY_SELECTED;
			}
		}	
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

void BoolControl::FlagKey(TrackHitRecord hit)
	{
	int n = keys.Count();
	for (int i = 0; i < n; i++) {
		keys[i].flags &= ~KEY_FLAGGED;
		}
	assert(hit.hit>=0&&hit.hit<(DWORD)n);
	keys[hit.hit].flags |= KEY_FLAGGED;
	}

int BoolControl::GetFlagKeyIndex()
	{
	int n = keys.Count();
	for (int i = 0; i < n; i++) {
		if (keys[i].flags & KEY_FLAGGED) {
			return i;
			}
		}
	return -1;
	}

int BoolControl::NumSelKeys()
	{
	int n = keys.Count();
	int c = 0;
	for ( int i = 0; i < n; i++ ) {
		if (keys[i].flags & KEY_SELECTED) {
			c++;
			}
		}
	return c;
	}

void BoolControl::CloneSelectedKeys(BOOL offset)
	{
	int n = keys.Count();			
	HoldTrack();
	BOOL changed = FALSE;

	for (int i = 0; i < n; i++) {
		if (keys[i].flags & KEY_SELECTED) {
			BKey key(keys[i].time);
			key.flags |= KEY_SELECTED;
			keys.Append(1,&key,5);
			keys[i].flags &= ~KEY_SELECTED;
			changed = TRUE;
			}
		}
	if (changed) {
		keys.Shrink();
		valid.SetEmpty();
		SortKeys();
		}
	}

void BoolControl::AddNewKey(TimeValue t,DWORD flags)
	{
	HoldTrack();
	BKey key(t);
	if (flags&ADDKEY_SELECT) {
		key.flags |= KEY_SELECTED;
		}
	if (flags&ADDKEY_FLAGGED) {
		int n = keys.Count();
		for (int i = 0; i < n; i++) {
			keys[i].flags &= ~KEY_FLAGGED;
			}		
		key.flags |= KEY_FLAGGED;
		}
	keys.Append(1,&key);
	valid.SetEmpty();
	SortKeys();
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);	
	}

BOOL BoolControl::IsKeySelected(int index)
	{
	return keys[index].flags & KEY_SELECTED;
	}

TrackClipObject *BoolControl::CopyTrack(Interval iv, DWORD flags)
	{	
	BoolClipObject *cobj = new BoolClipObject(iv);	
	Interval test = TestInterval(iv,flags);	
	for (int i = 0; i < keys.Count(); i++) {
		if (test.InInterval(keys[i].time)) {
			BKey nk(keys[i].time);
			cobj->tab.Append(1,&nk,10);
			}
		}
	cobj->tab.Shrink();
	return cobj;
	}

void BoolControl::PasteTrack(TrackClipObject *cobj,Interval iv, DWORD flags)
	{
	BoolClipObject *cob = (BoolClipObject*)cobj;	
	HoldTrack();		
	DeleteTime(iv,flags);	
	InsertTime(iv.Start(),cob->clip.Duration()-1);	
	for (int i = 0; i < cob->tab.Count(); i++) {
		BKey key(cob->tab[i].time);
		key.time -= cob->clip.Start() - iv.Start();
		keys.Append(1,&key);		
		}	
	valid.SetEmpty();
	SortKeys();
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

int BoolControl::HitTestTrack(			
		TrackHitTab& hits,
		Rect& rcHit,
		Rect& rcTrack,			
		float zoom,
		int scroll,
		DWORD flags)
	{
	int left  = ScreenToTime(rcTrack.left,zoom,scroll) - 4;
	int right = ScreenToTime(rcTrack.right,zoom,scroll) + 4;
	int n = keys.Count();
	int y = (rcTrack.top+rcTrack.bottom)/2;	
		
	for ( int i = 0; i < n; i++ ) {
		if (flags&HITTRACK_SELONLY && 
			!(keys[i].flags & KEY_SELECTED)) continue;
		if (flags&HITTRACK_UNSELONLY && 
			(keys[i].flags & KEY_SELECTED)) continue;

		if (keys[i].time > right) {
			break;
			}
		if (keys[i].time > left) {
			int x = TimeToScreen(keys[i].time,zoom,scroll);
			if (rcHit.Contains(IPoint2(x,y))) {
				TrackHitRecord rec(i,0);
				hits.Append(1,&rec);
				if (flags&HITTRACK_ABORTONHIT) return TRACK_DONE;
				}
			}		
		}
	return TRACK_DONE;
	}

int BoolControl::PaintTrack(			
		ParamDimensionBase *dim,
		HDC hdc,
		Rect& rcTrack,
		Rect& rcPaint,
		float zoom,
		int scroll,
		DWORD flags)
	{
	int left  = ScreenToTime(rcPaint.left-8,zoom,scroll);
	int right = ScreenToTime(rcPaint.right+8,zoom,scroll);
	int n = keys.Count();
	int y = (rcTrack.top+rcTrack.bottom)/2, lx, x = rcPaint.left-2;
	HBRUSH selBrush   = CreateSolidBrush(RGB(255,255,255));
	HBRUSH barBrush   = CreateSolidBrush(RGB(113,160,231)); //RGB(80,100,180)
	HBRUSH unselBrush = (HBRUSH)GetStockObject(GRAY_BRUSH);	
	BOOL state = startOnOff;
	SelectObject(hdc,GetStockObject(BLACK_PEN));
	SelectObject(hdc,barBrush);
	
	for (int i = 0; i < n; i++) {		
		lx = x;
		x  = TimeToScreen(keys[i].time,zoom,scroll);
		if (keys[i].time > left) {			
			if (state) {							
				Rectangle(hdc,lx,y-4,x,y+4);
				}
			}		
		state = !state;
		if (keys[i].time > right) {
			break;
			}
		}
	if (state) {		
		Rectangle(hdc,x,y-4,rcPaint.right,y+4);
		}
	
	for (i = 0; i < n; i++) {
		if (keys[i].time > right) {
			break;
			}
		if (keys[i].time > left) {			
			x  = TimeToScreen(keys[i].time,zoom,scroll);
			if ((flags&PAINTTRACK_SHOWSEL) && (keys[i].flags&KEY_SELECTED)) {
				SelectObject(hdc,selBrush);
			} else {
				SelectObject(hdc,unselBrush);
				}
			Ellipse(hdc,x-4,y-5,x+4,y+5);
			}		
		}

	DeleteObject(selBrush);
	DeleteObject(barBrush);
	return TRACK_DONE;
	}


void BoolControl::GetValue(
		TimeValue t, void *val, Interval &valid, GetSetMethod method)
	{
	Interval wvalid = FOREVER;	
	float *v = (float*)val;
			
	t = ApplyEase(t,wvalid);	
	
 	if (!this->valid.InInterval(t)) {
		onOff = startOnOff;
		for (int i=0; i<keys.Count(); i++) {
			if (keys[i].time>t) break;
			onOff = !onOff;
			}
		if (keys.Count()) {
			if (t < keys[0].time) {
				this->valid.Set(TIME_NegInfinity,keys[0].time-1);
			} else 
			if (t > keys[keys.Count()-1].time) {
				this->valid.Set(keys[keys.Count()-1].time,TIME_PosInfinity);
			} else this->valid.SetInstant(t);
		} else {
			this->valid = FOREVER;
			}
		}
	valid &= this->valid;
	*v = onOff ? 1.0f : -1.0f;
	}

void BoolControl::SetValueLocalTime(
		TimeValue t, void *val, int commit, GetSetMethod method)
	{
	float *v = (float*)val;
	float tv;

	GetValue(t,&tv,FOREVER);
	if (MAKEBOOL(tv) == MAKEBOOL(*v)) {
		return;
		}
	
	HoldTrack();
	if (Animating()) {		
		int index = GetKeyIndex(t);
		if (index>=0) {
			keys.Delete(index,1);
			keys.Shrink();
		} else {
			BKey k(t);
			keys.Append(1,&k);
			SortKeys();
			}
	} else {
		if (keys.Count()) {			
			startOnOff = !startOnOff;
		} else {
			onOff = startOnOff = MAKEBOOL(*v);			
			}
		}
	
	valid.SetEmpty();
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

void BoolControl::Extrapolate(
		Interval range,TimeValue t,void *val,Interval &valid,int type)
	{	
	GetValue(t,val,valid);	
	}

static int __cdecl CompareBKeys(const BKey *k1, const BKey *k2)
	{
	if (k1->time < k2->time) return -1;
	if (k1->time > k2->time) return 1;
	return 0;
	}

void BoolControl::SortKeys()
	{
	keys.Sort((CompareFnc)CompareBKeys);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Control\ctrl.h ===
/**********************************************************************
 *<
	FILE: ctrl.h

	DESCRIPTION:

	CREATED BY: Rolf Berteig

	HISTORY: created 13 June 1995

	         added independent scale controller (ScaleXYZ)
			   mjm - 9.15.98

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef __CTRL__H
#define __CTRL__H

#include "Max.h"
#include "resource.h"


extern ClassDesc* GetPathCtrlDesc();
extern ClassDesc* GetEulerCtrlDesc();
extern ClassDesc* GetLocalEulerCtrlDesc();
extern ClassDesc* GetExprPosCtrlDesc();
extern ClassDesc* GetExprP3CtrlDesc();
extern ClassDesc* GetExprFloatCtrlDesc();
extern ClassDesc* GetExprScaleCtrlDesc();
extern ClassDesc* GetExprRotCtrlDesc();
extern ClassDesc* GetFloatNoiseDesc();
extern ClassDesc* GetPositionNoiseDesc();
extern ClassDesc* GetPoint3NoiseDesc();
extern ClassDesc* GetRotationNoiseDesc();
extern ClassDesc* GetScaleNoiseDesc();
extern ClassDesc* GetBoolControlDesc();
extern ClassDesc* GetIPosCtrlDesc();
extern ClassDesc* GetAttachControlDesc();
extern ClassDesc* GetIPoint3CtrlDesc();
extern ClassDesc* GetIColorCtrlDesc();
extern ClassDesc* GetLinkCtrlDesc();
extern ClassDesc* GetFollowUtilDesc();
extern ClassDesc* GetSurfCtrlDesc();
extern ClassDesc* GetLODControlDesc();
extern ClassDesc* GetLODUtilDesc();
extern ClassDesc* GetIScaleCtrlDesc(); // mjm 9.15.98

TCHAR *GetString(int id);
extern HINSTANCE hInstance;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Control\followu.cpp ===
/**********************************************************************
 *<
	FILE: followu.cpp

	DESCRIPTION: A utility that generates path follow

	CREATED BY: Rolf Berteig

	HISTORY: created 1/27/97

 *>	Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/
#include "ctrl.h"
#include "utilapi.h"


#define FOLLOW_CLASS_ID			Class_ID(0x4557a2c4,0x00186d34)
#define FOLLOW_CNAME			GetString(IDS_RB_FOLLOWUTIL)

class FollowUtil : public UtilityObj {
	public:
		IUtil *iu;
		Interface *ip;
		HWND hPanel;		

		BOOL bank, flip;
		float bankAmount, tracking;
		TimeValue start, end;
		int samples;

		FollowUtil();
		void BeginEditParams(Interface *ip,IUtil *iu);
		void EndEditParams(Interface *ip,IUtil *iu);
		void DeleteThis() {}
		void SelectionSetChanged(Interface *ip,IUtil *iu);

		void Init(HWND hWnd);
		void Destroy(HWND hWnd);
		void SetStates(HWND hWnd);

		Matrix3 CalcRefFrame(TimeValue t,INode *node);
		Point3 GetPosition(INode *node,TimeValue t);
		void DoFollow();		
	};
static FollowUtil theFollowUtil;

//--- Class Descriptor ------------------------------------------

class FollowUtilClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) {return &theFollowUtil;}
	const TCHAR *	ClassName() {return FOLLOW_CNAME;}
	SClass_ID		SuperClassID() {return UTILITY_CLASS_ID;}
	Class_ID		ClassID() {return FOLLOW_CLASS_ID;}
	const TCHAR* 	Category() {return _T("");}
	void			ResetClassParams(BOOL fileReset);
	};

void FollowUtilClassDesc::ResetClassParams(BOOL fileReset) 
	{
	if (fileReset) {
		theFollowUtil = FollowUtil();
		}
	}

static FollowUtilClassDesc followUtilDesc;
ClassDesc* GetFollowUtilDesc() {return &followUtilDesc;}

#define BANKSCALE 100.0f
#define FromBankUI(a) ((a)*BANKSCALE)
#define ToBankUI(a)	  ((a)/BANKSCALE)

#define TRACKSCALE 0.04f
#define FromTrackUI(a) ((a)*TRACKSCALE)
#define ToTrackUI(a)   ((a)/TRACKSCALE)


///--- Panel Proc ------------------------------------------------

static BOOL CALLBACK FollowUtilDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	switch (msg) {
		case WM_INITDIALOG:
			theFollowUtil.Init(hWnd);
			break;

		case WM_DESTROY:
			theFollowUtil.Destroy(hWnd);
			break;

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_PATH_BANK:
					theFollowUtil.bank = IsDlgButtonChecked(hWnd,IDC_PATH_BANK);
					theFollowUtil.SetStates(hWnd);
					break;
				
				case IDC_PATH_ALLOWFLIP:
					theFollowUtil.flip = IsDlgButtonChecked(hWnd,IDC_PATH_ALLOWFLIP);
					break;

				case IDC_FOLLOW_APPLY:
					theFollowUtil.DoFollow();
					break;

				case IDOK:
					theFollowUtil.iu->CloseUtility();
					break;
				}
			break;

		case CC_SPINNER_CHANGE: {
			ISpinnerControl *spin = (ISpinnerControl*)lParam;
			switch (LOWORD(wParam)) {
				case IDC_FOLLOW_BANKSPIN:
					theFollowUtil.bankAmount = FromBankUI(spin->GetFVal());
					break;

				case IDC_FOLLOW_TRACKSPIN:
					theFollowUtil.tracking = FromTrackUI(spin->GetFVal());
					break;

				case IDC_FOLLOW_STARTSPIN:
					theFollowUtil.start = spin->GetIVal();
					break;

				case IDC_FOLLOW_ENDSPIN:
					theFollowUtil.end = spin->GetIVal();
					break;

				case IDC_FOLLOW_SAMPSPIN:
					theFollowUtil.samples = spin->GetIVal();
					break;
				}
			break;
			}

		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_MOUSEMOVE:
			theFollowUtil.ip->RollupMouseMessage(hWnd,msg,wParam,lParam); 
			break;

		default:
			return FALSE;
		}
	return TRUE;
	}	

// --- FollowUtil methods -----------------------------------------

FollowUtil::FollowUtil()
	{
	iu = NULL;
	ip = NULL;
    hPanel = NULL;
	bank = FALSE;
	flip = FALSE;
	bankAmount = FromBankUI(0.5f);
	tracking = FromTrackUI(0.5f);
	start = 0;
	end = 16000;
	samples = 25;
	}

void FollowUtil::BeginEditParams(Interface *ip,IUtil *iu)
	{
	this->iu = iu;
	this->ip = ip;
	hPanel = ip->AddRollupPage(
		hInstance,
		MAKEINTRESOURCE(IDD_FOLLOW_PANEL),
		FollowUtilDlgProc,
		GetString(IDS_RB_FOLLOWUTIL),
		0);
	}

void FollowUtil::EndEditParams(Interface *ip,IUtil *iu)
	{
	this->iu = NULL;
	this->ip = NULL;
	ip->DeleteRollupPage(hPanel);
	hPanel = NULL;
	}


void FollowUtil::SelectionSetChanged(Interface *ip,IUtil *iu)
	{
	SetStates(hPanel);
	if (ip->GetSelNodeCount()==1) {
		SetDlgItemText(hPanel,IDC_SEL_NAME,ip->GetSelNode(0)->GetName());
	} else if (ip->GetSelNodeCount()) {
		SetDlgItemText(hPanel,IDC_SEL_NAME,GetString(IDS_RB_MULTISEL));
	} else {
		SetDlgItemText(hPanel,IDC_SEL_NAME,GetString(IDS_RB_NONESEL));
		}	
	}

void FollowUtil::Init(HWND hWnd)
	{
	hPanel = hWnd;

	CheckDlgButton(hWnd,IDC_PATH_BANK,bank);
	CheckDlgButton(hWnd,IDC_PATH_ALLOWFLIP,flip);

	ISpinnerControl * spin;
	spin = GetISpinner(GetDlgItem(hWnd,IDC_FOLLOW_STARTSPIN));
	spin->SetLimits(TIME_NegInfinity,TIME_PosInfinity,FALSE);
	spin->SetScale(10.0f);
	spin->LinkToEdit(GetDlgItem(hWnd,IDC_FOLLOW_START),EDITTYPE_TIME);
	spin->SetValue(start,FALSE);
	ReleaseISpinner(spin);

	spin = GetISpinner(GetDlgItem(hWnd,IDC_FOLLOW_ENDSPIN));
	spin->SetLimits(TIME_NegInfinity,TIME_PosInfinity,FALSE);
	spin->SetScale(10.0f);
	spin->LinkToEdit(GetDlgItem(hWnd,IDC_FOLLOW_END),EDITTYPE_TIME);
	spin->SetValue(end,FALSE);
	ReleaseISpinner(spin);

	spin = GetISpinner(GetDlgItem(hWnd,IDC_FOLLOW_SAMPSPIN));
	spin->SetLimits(1,999999999,FALSE);
	spin->SetScale(0.1f);
	spin->LinkToEdit(GetDlgItem(hWnd,IDC_FOLLOW_SAMP),EDITTYPE_INT);
	spin->SetValue(samples,FALSE);
	ReleaseISpinner(spin);

	spin = GetISpinner(GetDlgItem(hWnd,IDC_FOLLOW_BANKSPIN));
	spin->SetLimits(-999999999,999999999,FALSE);
	spin->SetScale(0.01f);
	spin->LinkToEdit(GetDlgItem(hWnd,IDC_FOLLOW_BANK),EDITTYPE_FLOAT);
	spin->SetValue(ToBankUI(bankAmount),FALSE);
	ReleaseISpinner(spin);

	spin = GetISpinner(GetDlgItem(hWnd,IDC_FOLLOW_TRACKSPIN));
	spin->SetLimits(0.01f,10.0f,FALSE);
	spin->SetScale(0.01f);
	spin->LinkToEdit(GetDlgItem(hWnd,IDC_FOLLOW_TRACK),EDITTYPE_FLOAT);
	spin->SetValue(ToTrackUI(tracking),FALSE);
	ReleaseISpinner(spin);

	SelectionSetChanged(ip,iu);	
	}

void FollowUtil::Destroy(HWND hWnd)
	{
	hPanel = NULL;
	}

void FollowUtil::SetStates(HWND hWnd)
	{
	if (ip->GetSelNodeCount()) {
		EnableWindow(GetDlgItem(hPanel,IDC_FOLLOW_APPLY),TRUE);
	} else {
		EnableWindow(GetDlgItem(hPanel,IDC_FOLLOW_APPLY),FALSE);
		}

	if (bank) {
		EnableWindow(GetDlgItem(hWnd,IDC_FOLLOW_BANKLABEL),TRUE);
		EnableWindow(GetDlgItem(hWnd,IDC_FOLLOW_BANKSPIN),TRUE);		
		EnableWindow(GetDlgItem(hWnd,IDC_FOLLOW_TRACKLABEL),TRUE);
		EnableWindow(GetDlgItem(hWnd,IDC_FOLLOW_TRACKSPIN),TRUE);
	} else {
		EnableWindow(GetDlgItem(hWnd,IDC_FOLLOW_BANKLABEL),FALSE);
		EnableWindow(GetDlgItem(hWnd,IDC_FOLLOW_BANKSPIN),FALSE);
		EnableWindow(GetDlgItem(hWnd,IDC_FOLLOW_TRACKLABEL),FALSE);
		EnableWindow(GetDlgItem(hWnd,IDC_FOLLOW_TRACKSPIN),FALSE);
		}
	}


Point3 FollowUtil::GetPosition(INode *node,TimeValue t)
	{
	Matrix3 tm = node->GetNodeTM(t);
	return tm.GetTrans();
	}

#define DT			1
#define NUMSTEPS	5

Matrix3 FollowUtil::CalcRefFrame(TimeValue t,INode *node)
	{
	Interval valid;
	Matrix3 tm(1);	
	TimeValue s = start, e = end;
	if (s==e) return tm;
	if (s>e) {
		int temp = e;
		e = s;
		s = temp;
		}
	float u = float(t-s)/float(e);	
	int length = e-s;

	Point3 pt0, pt1;
	pt0 = GetPosition(node,t-DT);
	pt1 = GetPosition(node,t+DT);
	
	Point3 pathNorm(0,0,0);
	if (flip) {
		// Compute the normal to the plane of the path by sampling points on the path
#define NUM_SAMPLES 20
		Point3 v[NUM_SAMPLES], cent(0,0,0);
		for (int i=0; i<NUM_SAMPLES; i++) {
			TimeValue tt = int((float(i)/float(NUM_SAMPLES))*float(length)+s);
			v[i] = GetPosition(node,tt);
			cent += v[i];
			}		
		cent /= float(NUM_SAMPLES);
		for (i=1; i<NUM_SAMPLES; i++) {
			pathNorm += Normalize((v[i]-cent)^(v[i-1]-cent));
			}
		pathNorm = Normalize(pathNorm);
		}

	// X
	tm.SetRow(0,Normalize(pt1-pt0));

	if (flip) {
		// Choose Z in the plane of the path		
		// Z
		tm.SetRow(2,Normalize(tm.GetRow(0)^pathNorm));

		// Y
		tm.SetRow(1,tm.GetRow(2)^tm.GetRow(0));
	} else {
		// Choose Y in the world XY plane
		// Y
		tm.SetRow(1,Normalize(Point3(0,0,1)^tm.GetRow(0)));

		// Z
		tm.SetRow(2,tm.GetRow(0)^tm.GetRow(1));
		}

	
	if (bank) {
		// Average over NUMSTEPS samples
		Point3 pt0, pt1, pt2, v0, v1;
		float cv = 0.0f;
		u -= float(NUMSTEPS/2+1)*tracking;
						
		if (u+(NUMSTEPS+2)*tracking > 1.0f) u = 1.0f - (NUMSTEPS+2)*tracking;
		if (u<0.0f) u=0.0f;			

		pt1 = GetPosition(node,int(u*length)+s);
		u += tracking;		
		pt2 = GetPosition(node,int(u*length)+s);
		u += tracking;		
		for (int i=0; i<NUMSTEPS; i++) {			
			pt0 = pt1;
			pt1 = pt2;
			if (u>1.0f) {				
				break;
			} else {				
				pt2 = GetPosition(node,int(u*length)+s);
				}
			v0 = Normalize(pt2-pt1);
			v1 = Normalize(pt1-pt0);			
			v0.z = v1.z = 0.0f; // remove Z component.
			cv += (v0^v1).z * bankAmount / Length(pt1-pt0);
			u  += tracking;			
			}	
		if (i) tm.PreRotateX(cv/float(i));
		}

	return tm;
	}

void FollowUtil::DoFollow()
	{
	theHold.Begin();
	SuspendAnimate();
	AnimateOn();
	for (int j=0; j<ip->GetSelNodeCount(); j++) {
		INode *node = ip->GetSelNode(j);
		Control *cont=node->GetTMController()->GetRotationController();		
		if (cont && cont->IsKeyable()) {
			cont->DeleteTime(Interval(start,end),TIME_INCLEFT|TIME_INCRIGHT|TIME_NOSLIDE);
			for (int i=0; i<=samples; i++) {
				TimeValue t = int((float(i)/float(samples))*(end-start)) + start;
				Matrix3 tm = CalcRefFrame(t,node);
				Quat q(tm);
				cont->SetValue(t,&q,1,CTRL_ABSOLUTE);
				}
			}
		}
	ResumeAnimate();
	theHold.Accept(GetString(IDS_RB_APPLYFOLLOW));
	ip->RedrawViews(ip->GetTime());
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Control\indepos.cpp ===
/**********************************************************************
 *<
	FILE: indepos.cpp

	DESCRIPTION: An independent X, Y, Z position controller

	CREATED BY: Rolf Berteig

	HISTORY: created 13 June 1995

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#include "ctrl.h"

#define IPOS_CONTROL_CLASS_ID	Class_ID(0x118f7e02,0xffee238a)
#define IPOS_CONTROL_CNAME		GetString(IDS_RB_IPOS)

#define IPOINT3_CONTROL_CLASS_ID	Class_ID(0x118f7e02,0xfeee238b)
#define IPOINT3_CONTROL_CNAME		GetString(IDS_RB_IPOINT3)

#define ICOLOR_CONTROL_CLASS_ID		Class_ID(0x118f7c01,0xfeee238a)
#define ICOLOR_CONTROL_CNAME		GetString(IDS_RB_ICOLOR)

#define IPOS_X_REF		0
#define IPOS_Y_REF		1
#define IPOS_Z_REF		2

class IPosDlg;

static DWORD subColor[] = {PAINTCURVE_XCOLOR, PAINTCURVE_YCOLOR, PAINTCURVE_ZCOLOR};

class IndePosition : public Control {
	public:
		Control *posX;
		Control *posY;
		Control *posZ;
		Point3 curval;
		Interval ivalid;
		BOOL blockUpdate;

		static IPosDlg *dlg;
		static IObjParam *ip;
		static ULONG beginFlags;
		static IndePosition *editControl; // The one being edited.
		
		IndePosition(BOOL loading=FALSE);
		IndePosition(const IndePosition &ctrl);
		~IndePosition();
		void Update(TimeValue t);

		// Animatable methods
		Class_ID ClassID() { return IPOS_CONTROL_CLASS_ID;} 
		SClass_ID SuperClassID() {return CTRL_POSITION_CLASS_ID;} 
		
		void GetClassName(TSTR& s) {s = IPOS_CONTROL_CNAME;}
		void DeleteThis() {delete this;}		
		int IsKeyable() {return 1;}		

		int NumSubs()  {return 3;}
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);
		int SubNumToRefNum(int subNum) {return subNum;}

		DWORD GetSubAnimCurveColor(int subNum) {return subColor[subNum];}

		ParamDimension* GetParamDimension(int i) {return stdWorldDim;}
		BOOL AssignController(Animatable *control,int subAnim);
		void AddNewKey(TimeValue t,DWORD flags);
		int NumKeys();
		TimeValue GetKeyTime(int index);
		void CopyKeysFromTime(TimeValue src,TimeValue dst,DWORD flags);
		BOOL IsKeyAtTime(TimeValue t,DWORD flags);
		BOOL GetNextKeyTime(TimeValue t,DWORD flags,TimeValue &nt);
		void DeleteKeyAtTime(TimeValue t);

		void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev );
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next );
		
		// Reference methods
		int NumRefs() { return 3; };	
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);
		RefResult NotifyRefChanged(Interval, RefTargetHandle, PartID&, RefMessage);
		
		// Control methods
		Control *GetXController() {return posX;}
		Control *GetYController() {return posY;}
		Control *GetZController() {return posZ;}
		void Copy(Control *from);
		RefTargetHandle Clone(RemapDir& remap);
		BOOL IsLeaf() {return FALSE;}
		void GetValue(TimeValue t, void *val, Interval &valid, GetSetMethod method);	
		void SetValue(TimeValue t, void *val, int commit, GetSetMethod method);
		void CommitValue(TimeValue t);
		void RestoreValue(TimeValue t);		
	};

IPosDlg       *IndePosition::dlg         = NULL;
IObjParam     *IndePosition::ip          = NULL;
ULONG          IndePosition::beginFlags  = 0;
IndePosition  *IndePosition::editControl = NULL;

class IndePoint3 : public IndePosition {
	public:
		IndePoint3(BOOL loading=FALSE) : IndePosition(loading) {}
		SClass_ID SuperClassID() {return CTRL_POINT3_CLASS_ID;} 
		Class_ID ClassID() { return IPOINT3_CONTROL_CLASS_ID;} 
		void GetClassName(TSTR& s) {s = IPOINT3_CONTROL_CNAME;}
		void GetValue(TimeValue t, void *val, Interval &valid, GetSetMethod method);
		RefTargetHandle Clone(RemapDir& remap);
	};

class IndeColor : public IndePoint3 {
	public:
		IndeColor(BOOL loading=FALSE) : IndePoint3(loading) {}
		SClass_ID SuperClassID() {return CTRL_POINT3_CLASS_ID;} 
		Class_ID ClassID() { return ICOLOR_CONTROL_CLASS_ID;} 
		void GetClassName(TSTR& s) {s = ICOLOR_CONTROL_CNAME;}		
		ParamDimension* GetParamDimension(int i) {return stdColor255Dim;}
		RefTargetHandle Clone(RemapDir& remap);
	};

class IPosClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading) {return new IndePosition(loading);}
	const TCHAR *	ClassName() {return IPOS_CONTROL_CNAME;}
	SClass_ID		SuperClassID() {return CTRL_POSITION_CLASS_ID;}
	Class_ID		ClassID() {return IPOS_CONTROL_CLASS_ID;}
	const TCHAR* 	Category() {return _T("");}
	};
static IPosClassDesc iposCD;
ClassDesc* GetIPosCtrlDesc() {return &iposCD;}

class IPoint3ClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading) {return new IndePoint3(loading);}
	const TCHAR *	ClassName() {return IPOINT3_CONTROL_CNAME;}
	SClass_ID		SuperClassID() {return CTRL_POINT3_CLASS_ID;}
	Class_ID		ClassID() {return IPOINT3_CONTROL_CLASS_ID;}
	const TCHAR* 	Category() {return _T("");}
	};
static IPoint3ClassDesc ipoint3CD;
ClassDesc* GetIPoint3CtrlDesc() {return &ipoint3CD;}

class IColorClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading) {return new IndeColor(loading);}
	const TCHAR *	ClassName() {return ICOLOR_CONTROL_CNAME;}
	SClass_ID		SuperClassID() {return CTRL_POINT3_CLASS_ID;}
	Class_ID		ClassID() {return ICOLOR_CONTROL_CLASS_ID;}
	const TCHAR* 	Category() {return _T("");}
	};
static IColorClassDesc icolorCD;
ClassDesc* GetIColorCtrlDesc() {return &icolorCD;}


static BOOL CALLBACK IPosParamDialogProc(HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);

static const int editButs[] = {IDC_IPOS_X,IDC_IPOS_Y,IDC_IPOS_Z};

#define EDIT_X	0
#define EDIT_Y	1
#define EDIT_Z	2

#define IPOS_BEGIN		1
#define IPOS_MIDDLE		2
#define IPOS_END		3

class IPosDlg {
	public:
		IndePosition *cont;
		HWND hWnd;
		IObjParam *ip;
		ICustButton *iEdit[3];
		static int cur;
		
		IPosDlg(IndePosition *cont,IObjParam *ip);
		~IPosDlg();

		void Init();
		void EndingEdit(IndePosition *next);
		void BeginingEdit(IndePosition *cont,IObjParam *ip,IndePosition *prev);
		void SetCur(int c,int code=IPOS_MIDDLE);
		void WMCommand(int id, int notify, HWND hCtrl);
	};

int IPosDlg::cur = EDIT_X;

IPosDlg::IPosDlg(IndePosition *cont,IObjParam *ip)
	{
	this->ip   = ip;
	this->cont = cont;
	for (int i=0; i<3; i++) {
		iEdit[i] = NULL;
		}
	
	TCHAR *name;
	if (cont->ClassID()==IPOS_CONTROL_CLASS_ID) 
		 name = GetString(IDS_RB_IPOSPARAMS);
	else 
	if (cont->ClassID()==IPOINT3_CONTROL_CLASS_ID) 
		 name = GetString(IDS_RB_IPOINT3PARAMS);
	else name = GetString(IDS_RB_ICOLORPARAMS);

	hWnd = ip->AddRollupPage( 
		hInstance,
		MAKEINTRESOURCE(IDD_IPOS_PARAMS),
		IPosParamDialogProc,
		name, 
		(LPARAM)this);
	ip->RegisterDlgWnd(hWnd);	
	
	SetCur(cur,IPOS_BEGIN);	
	UpdateWindow(hWnd);
	}

IPosDlg::~IPosDlg()
	{
	SetCur(cur,IPOS_END);
	for (int i=0; i<3; i++) {
		ReleaseICustButton(iEdit[i]);		
		}
	ip->UnRegisterDlgWnd(hWnd);
	ip->DeleteRollupPage(hWnd);
	hWnd = NULL;
	}

void IPosDlg::EndingEdit(IndePosition *next)
	{
	switch (cur) {
		case EDIT_X:
			cont->posX->EndEditParams(ip,0,next->posX);
			break;
		case EDIT_Y:
			cont->posY->EndEditParams(ip,0,next->posY);
			break;
		case EDIT_Z:
			cont->posZ->EndEditParams(ip,0,next->posZ);
			break;
		}
	cont = NULL;
	ip   = NULL;
	}

void IPosDlg::BeginingEdit(IndePosition *cont,IObjParam *ip,IndePosition *prev)
	{
	this->ip   = ip;
	this->cont = cont;
	switch (cur) {
		case EDIT_X:
			cont->posX->BeginEditParams(ip,BEGIN_EDIT_MOTION,prev->posX);
			break;
		case EDIT_Y:
			cont->posY->BeginEditParams(ip,BEGIN_EDIT_MOTION,prev->posY);
			break;
		case EDIT_Z:
			cont->posZ->BeginEditParams(ip,BEGIN_EDIT_MOTION,prev->posZ);
			break;
		}	
	UpdateWindow(hWnd);
	}

void IPosDlg::Init()
	{	
	for (int i=0; i<3; i++) {
		iEdit[i] = GetICustButton(GetDlgItem(hWnd,editButs[i]));		
		iEdit[i]->SetType(CBT_CHECK);
		}
	iEdit[cur]->SetCheck(TRUE);	
	}

void IPosDlg::SetCur(int c,int code)
	{
	if (c==cur && code==IPOS_MIDDLE) return;
	Control *prev = NULL, *next = NULL;

	if (code!=IPOS_END) {
		switch (c) {
			case EDIT_X:
				next = cont->posX;
				break;
			case EDIT_Y:
				next = cont->posY;
				break;
			case EDIT_Z:
				next = cont->posZ;
				break;
			}
		}

	if (code!=IPOS_BEGIN) {
		switch (cur) {
			case EDIT_X:
				cont->posX->EndEditParams(ip,END_EDIT_REMOVEUI,next);
				prev = cont->posX;
				break;
			case EDIT_Y:
				cont->posY->EndEditParams(ip,END_EDIT_REMOVEUI,next);
				prev = cont->posY;
				break;
			case EDIT_Z:
				cont->posZ->EndEditParams(ip,END_EDIT_REMOVEUI,next);
				prev = cont->posZ;
				break;
			}
		}

	cur = c;

	if (code!=IPOS_END) {
		switch (cur) {
			case EDIT_X:
				cont->posX->BeginEditParams(ip,BEGIN_EDIT_MOTION,prev);
				break;
			case EDIT_Y:
				cont->posY->BeginEditParams(ip,BEGIN_EDIT_MOTION,prev);
				break;
			case EDIT_Z:
				cont->posZ->BeginEditParams(ip,BEGIN_EDIT_MOTION,prev);
				break;
			}
		}
	}

void IPosDlg::WMCommand(int id, int notify, HWND hCtrl)
	{
	switch (id) {
		case IDC_IPOS_X:
			SetCur(0);
			iEdit[0]->SetCheck(TRUE);
			iEdit[1]->SetCheck(FALSE);
			iEdit[2]->SetCheck(FALSE);
			break;
		case IDC_IPOS_Y:
			SetCur(1);
			iEdit[0]->SetCheck(FALSE);
			iEdit[1]->SetCheck(TRUE);
			iEdit[2]->SetCheck(FALSE);
			break;
		case IDC_IPOS_Z:
			SetCur(2);
			iEdit[0]->SetCheck(FALSE);
			iEdit[1]->SetCheck(FALSE);
			iEdit[2]->SetCheck(TRUE);
			break;
		}
	}

static BOOL CALLBACK IPosParamDialogProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam )
	{
	IPosDlg *dlg = (IPosDlg*)GetWindowLong(hDlg,GWL_USERDATA);

	switch (message) {
		case WM_INITDIALOG:
			dlg = (IPosDlg*)lParam;			
			SetWindowLong(hDlg,GWL_USERDATA,lParam);
			dlg->hWnd = hDlg;
			dlg->Init();
			break;
		
		case WM_COMMAND:
			dlg->WMCommand(LOWORD(wParam),HIWORD(wParam),(HWND)lParam);
			break;

		case WM_LBUTTONDOWN:case WM_LBUTTONUP:	case WM_MOUSEMOVE:
			dlg->ip->RollupMouseMessage(hDlg,message,wParam,lParam);
			break;
				
		default:
			return FALSE;
		}
	return TRUE;
	}



IndePosition::IndePosition(const IndePosition &ctrl)
	{
	blockUpdate = FALSE;

	posX = NULL;
	posY = NULL;
	posZ = NULL;

	if (ctrl.posX) {
		ReplaceReference(IPOS_X_REF,ctrl.posX);
	} else {
		ReplaceReference(IPOS_X_REF,NewDefaultFloatController());
		}
	if (ctrl.posY) {
		ReplaceReference(IPOS_Y_REF,ctrl.posY);
	} else {
		ReplaceReference(IPOS_Y_REF,NewDefaultFloatController());
		}
	if (ctrl.posZ) {
		ReplaceReference(IPOS_Z_REF,ctrl.posZ);
	} else {
		ReplaceReference(IPOS_Z_REF,NewDefaultFloatController());
		}
	
	curval = ctrl.curval;
	ivalid = ctrl.ivalid;
	}

IndePosition::IndePosition(BOOL loading) 
	{
	blockUpdate = FALSE;

	posX = NULL;
	posY = NULL;
	posZ = NULL;
	if (!loading) {
		ReplaceReference(IPOS_X_REF,NewDefaultFloatController());
		ReplaceReference(IPOS_Y_REF,NewDefaultFloatController());
		ReplaceReference(IPOS_Z_REF,NewDefaultFloatController());
		ivalid = FOREVER;
		curval = Point3(0,0,0);
	} else {
		ivalid.SetEmpty();
		}	
	}

RefTargetHandle IndePoint3::Clone(RemapDir& remap) 
	{
	IndePoint3 *pos = new IndePoint3(TRUE);	
	pos->ReplaceReference(IPOS_X_REF, remap.CloneRef(posX));
	pos->ReplaceReference(IPOS_Y_REF, remap.CloneRef(posY));
	pos->ReplaceReference(IPOS_Z_REF, remap.CloneRef(posZ));
	return pos;
	}

RefTargetHandle IndeColor::Clone(RemapDir& remap) 
	{
	IndeColor *pos = new IndeColor(TRUE);	
	pos->ReplaceReference(IPOS_X_REF, remap.CloneRef(posX));
	pos->ReplaceReference(IPOS_Y_REF, remap.CloneRef(posY));
	pos->ReplaceReference(IPOS_Z_REF, remap.CloneRef(posZ));
	return pos;
	}

RefTargetHandle IndePosition::Clone(RemapDir& remap) 
	{
	IndePosition *pos = new IndePosition(TRUE);	
	pos->ReplaceReference(IPOS_X_REF, remap.CloneRef(posX));
	pos->ReplaceReference(IPOS_Y_REF, remap.CloneRef(posY));
	pos->ReplaceReference(IPOS_Z_REF, remap.CloneRef(posZ));
	return pos;
	}


IndePosition::~IndePosition()
	{
	DeleteAllRefsFromMe();
	}

void IndePosition::Copy(Control *from)
	{
	if (from->ClassID()==ClassID()) {
		IndePosition *ctrl = (IndePosition*)from;
		ReplaceReference(IPOS_X_REF,ctrl->posX);
		ReplaceReference(IPOS_Y_REF,ctrl->posY);
		ReplaceReference(IPOS_Z_REF,ctrl->posZ);
		curval = ctrl->curval;
		ivalid = ctrl->ivalid;
	} else {		
		Point3 v;
		Interval iv;
		int num;		
		if ((num=from->NumKeys())!=NOT_KEYFRAMEABLE && num>0) {
			SuspendAnimate();
			AnimateOn();
			for (int i=0; i<num; i++) {
				TimeValue t = from->GetKeyTime(i);
				from->GetValue(t,&v,iv);
				SetValue(t,&v,TRUE,CTRL_ABSOLUTE);	
				}
			ResumeAnimate();
			// RB 2/10/99: A key at frame 0 may have been created
			if (num>0 && from->GetKeyTime(0)!=0) {
				posX->DeleteKeyAtTime(0);
				posY->DeleteKeyAtTime(0);
				posZ->DeleteKeyAtTime(0);
				}
		} else {
			from->GetValue(0,&v,ivalid);
			SetValue(0,&v,TRUE,CTRL_ABSOLUTE);
			}
		}
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	}

void IndePosition::Update(TimeValue t)
	{
	if (!ivalid.InInterval(t)) {
		ivalid = FOREVER;		
		if (posX) posX->GetValue(t,&curval.x,ivalid);
		if (posY) posY->GetValue(t,&curval.y,ivalid);
		if (posZ) posZ->GetValue(t,&curval.z,ivalid);		
		}
	}

void IndePosition::SetValue(TimeValue t, void *val, int commit, GetSetMethod method)
	{
	Point3 *v = (Point3*)val;
	
	// RB 5/5/99: SetValue() calls NotifyDependents() which ultimately calls GetValue().
	// This isn't supposed to happen since reference makers are supposed to only invalidate
	// on a call to NotifyRefChanged(), not re-evaluate. However this is what happens
	// on around line 644 of stdShaders.cpp. 
	curval = *v;
	blockUpdate = TRUE;
	if (posX) posX->SetValue(t,&v->x,commit,method);
	if (posY) posY->SetValue(t,&v->y,commit,method);
	if (posZ) posZ->SetValue(t,&v->z,commit,method);
	blockUpdate = FALSE;

	ivalid.SetEmpty();
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	}

void IndePosition::GetValue(TimeValue t, void *val, Interval &valid, GetSetMethod method)
	{		
	Update(t);
	valid &= ivalid;			 
	if (method==CTRL_RELATIVE) {
  		Matrix3 *mat = (Matrix3*)val;		
		mat->PreTranslate(curval);
	} else {
		*((Point3*)val) = curval;
		}
	}

void IndePoint3::GetValue(TimeValue t, void *val, Interval &valid, GetSetMethod method)
	{		
	if (!blockUpdate) Update(t);
	valid &= ivalid;			 
	if (method==CTRL_RELATIVE) {
  		*((Point3*)val) += curval;
	} else {			    
		*((Point3*)val)  = curval;
		}
	}

void IndePosition::CommitValue(TimeValue t)
	{
	if (posX) posX->CommitValue(t);
	if (posY) posY->CommitValue(t);
	if (posZ) posZ->CommitValue(t);
	}

void IndePosition::RestoreValue(TimeValue t)
	{
	if (posX) posX->RestoreValue(t);
	if (posY) posY->RestoreValue(t);
	if (posZ) posZ->RestoreValue(t);
	}

RefTargetHandle IndePosition::GetReference(int i)
	{
	switch (i) {
		case IPOS_X_REF: return posX;
		case IPOS_Y_REF: return posY;
		case IPOS_Z_REF: return posZ;
		default: return NULL;
		}
	}

void IndePosition::SetReference(int i, RefTargetHandle rtarg)
	{
	switch (i) {
		case IPOS_X_REF: posX = (Control*)rtarg; break;
		case IPOS_Y_REF: posY = (Control*)rtarg; break;
		case IPOS_Z_REF: posZ = (Control*)rtarg; break;
		}
	}

Animatable* IndePosition::SubAnim(int i)
	{
	return GetReference(i);
	}

TSTR IndePosition::SubAnimName(int i)
	{
	if (ClassID()==IPOS_CONTROL_CLASS_ID) {
		switch (i) {
			case IPOS_X_REF: return GetString(IDS_RB_XPOSITION);
			case IPOS_Y_REF: return GetString(IDS_RB_YPOSITION);
			case IPOS_Z_REF: return GetString(IDS_RB_ZPOSITION);
			default: return _T("");
			}
	} else
	if (ClassID()==IPOINT3_CONTROL_CLASS_ID) {
		switch (i) {
			case IPOS_X_REF: return _T("X");
			case IPOS_Y_REF: return _T("Y");
			case IPOS_Z_REF: return _T("Z");
			default: return _T("");
			}
	} else {
		switch (i) {
			case IPOS_X_REF: return _T("R");
			case IPOS_Y_REF: return _T("G");
			case IPOS_Z_REF: return _T("B");
			default: return _T("");
			}
		}
	}

RefResult IndePosition::NotifyRefChanged(
		Interval iv, 
		RefTargetHandle hTarg, 
		PartID& partID, 
		RefMessage msg) 
	{
	switch (msg) {
		case REFMSG_CHANGE:
			ivalid.SetEmpty();
			break;
		case REFMSG_TARGET_DELETED:
			if (posX == hTarg) posX = NULL;
			if (posY == hTarg) posY = NULL;
			if (posZ == hTarg) posZ = NULL; 
			break;
		case REFMSG_GET_CONTROL_DIM: {
			ParamDimension **dim = (ParamDimension **)partID;
			assert(dim);
			*dim = stdWorldDim;
			}
		}
	return REF_SUCCEED;
	}

BOOL IndePosition::AssignController(Animatable *control,int subAnim)
	{	
	switch (subAnim) {
		case IPOS_X_REF:
			ReplaceReference(IPOS_X_REF,(RefTargetHandle)control);
			break;
		case IPOS_Y_REF:
			ReplaceReference(IPOS_Y_REF,(RefTargetHandle)control);
			break;
		case IPOS_Z_REF:
			ReplaceReference(IPOS_Z_REF,(RefTargetHandle)control);
			break;
		}

	// mjm 9.28.98
	// bugfix -- validity interval needs to be invalidated so curval
	// can be properly updated in next call to IndePosition::Update()
	ivalid.SetEmpty();

	NotifyDependents(FOREVER,0,REFMSG_CONTROLREF_CHANGE,TREE_VIEW_CLASS_ID,FALSE);
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);	
	return TRUE;
	}

void IndePosition::AddNewKey(TimeValue t,DWORD flags)
	{
	if (posX) posX->AddNewKey(t,flags);
	if (posY) posY->AddNewKey(t,flags);
	if (posZ) posZ->AddNewKey(t,flags);
	}

int IndePosition::NumKeys()
	{
	int num = 0;
	if (posX) num += posX->NumKeys(); 
	if (posY) num += posY->NumKeys();
	if (posZ) num += posZ->NumKeys();
	return num;
	}

TimeValue IndePosition::GetKeyTime(int index)
	{
	int onum,num = 0;
	if (posX) num += posX->NumKeys(); 
	if (index < num) return posX->GetKeyTime(index);
	onum = num;
	if (posY) num += posY->NumKeys(); 
	if (index < num) return posY->GetKeyTime(index-onum);
	onum = num;
	if (posZ) num += posZ->NumKeys(); 
	if (index < num) return posZ->GetKeyTime(index-onum);
	return 0;
	}

void IndePosition::CopyKeysFromTime(TimeValue src,TimeValue dst,DWORD flags)
	{
	if (posX) posX->CopyKeysFromTime(src,dst,flags);
	if (posY) posY->CopyKeysFromTime(src,dst,flags);
	if (posZ) posZ->CopyKeysFromTime(src,dst,flags);
	}

BOOL IndePosition::IsKeyAtTime(TimeValue t,DWORD flags)
	{
	if (posX && posX->IsKeyAtTime(t,flags)) return TRUE;
	if (posY && posY->IsKeyAtTime(t,flags)) return TRUE;
	if (posZ && posZ->IsKeyAtTime(t,flags)) return TRUE;
	return FALSE;
	}

void IndePosition::DeleteKeyAtTime(TimeValue t)
	{
	if (posX) posX->DeleteKeyAtTime(t);
	if (posY) posY->DeleteKeyAtTime(t);
	if (posZ) posZ->DeleteKeyAtTime(t);
	}

BOOL IndePosition::GetNextKeyTime(TimeValue t,DWORD flags,TimeValue &nt)
	{
	TimeValue at,tnear = 0;
	BOOL tnearInit = FALSE;
	
	if (posX && posX->GetNextKeyTime(t,flags,at)) {
		if (!tnearInit) {
			tnear = at;
			tnearInit = TRUE;
		} else 
		if (ABS(at-t) < ABS(tnear-t)) tnear = at;
		}

	if (posY && posY->GetNextKeyTime(t,flags,at)) {
		if (!tnearInit) {
			tnear = at;
			tnearInit = TRUE;
		} else 
		if (ABS(at-t) < ABS(tnear-t)) tnear = at;
		}

	if (posZ && posZ->GetNextKeyTime(t,flags,at)) {
		if (!tnearInit) {
			tnear = at;
			tnearInit = TRUE;
		} else 
		if (ABS(at-t) < ABS(tnear-t)) tnear = at;
		}
	
	if (tnearInit) {
		nt = tnear;
		return TRUE;
	} else {
		return FALSE;
		}
	}
		

void IndePosition::BeginEditParams(
		IObjParam *ip, ULONG flags,Animatable *prev)
	{	
	this->ip = ip;

	if (dlg) {
		dlg->BeginingEdit(this,ip,(IndePosition*)prev);
	} else {
		dlg = new IPosDlg(this,ip);
		}
	}

void IndePosition::EndEditParams(
		IObjParam *ip, ULONG flags,Animatable *next)
	{	
	IndePosition *cont=NULL;
	if (next && next->ClassID()==ClassID()) {
		cont = (IndePosition*)next;
		}

	if (dlg) {
		if (cont) {
			dlg->EndingEdit(cont);
		} else {
			delete dlg;
			dlg = NULL;
			}
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Control\eulrctrl.cpp ===
/**********************************************************************
 *<
	FILE: eulrctrl.cpp

	DESCRIPTION: An Euler angle rotation controller

	CREATED BY: Rolf Berteig

	HISTORY: created 13 June 1995

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#include "ctrl.h"
#include "interpik.h"
#include "euler.h"

#define EULER_CONTROL_CNAME		GetString(IDS_RB_EULERXYZ)

#define EULER_X_REF		0
#define EULER_Y_REF		1
#define EULER_Z_REF		2

#define THRESHHOLD		1.0f

class EulerDlg;

static DWORD subColor[] = {PAINTCURVE_XCOLOR, PAINTCURVE_YCOLOR, PAINTCURVE_ZCOLOR};

class EulerRotation : public Control {
	public:
		Control *rotX;
		Control *rotY;
		Control *rotZ;
		int order;
		Quat curval;
		Interval ivalid;

		static EulerDlg *dlg;
		static IObjParam *ip;
		static ULONG beginFlags;
		static EulerRotation *editControl; // The one being edited.

		EulerRotation(const EulerRotation &ctrl);
		EulerRotation(BOOL loading=FALSE);
		~EulerRotation();
		void Update(TimeValue t);

		// Animatable methods
		Class_ID ClassID() { return Class_ID(EULER_CONTROL_CLASS_ID,0); }  
		SClass_ID SuperClassID() { return CTRL_ROTATION_CLASS_ID; }  		
		
		void GetClassName(TSTR& s);
		void DeleteThis() {delete this;}		
		int IsKeyable() {return 1;}		

		int NumSubs()  {return 3;}
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);
		int SubNumToRefNum(int subNum) {return subNum;}

		DWORD GetSubAnimCurveColor(int subNum) {return subColor[subNum];}

		ParamDimension* GetParamDimension(int i) {return stdAngleDim;}
		BOOL AssignController(Animatable *control,int subAnim);
		void AddNewKey(TimeValue t,DWORD flags);
		int NumKeys();
		TimeValue GetKeyTime(int index);
		void CopyKeysFromTime(TimeValue src,TimeValue dst,DWORD flags);
		BOOL IsKeyAtTime(TimeValue t,DWORD flags);
		BOOL GetNextKeyTime(TimeValue t,DWORD flags,TimeValue &nt);
		void DeleteKeyAtTime(TimeValue t);

		void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev );
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next );

		int SetProperty(ULONG id, void *data);
		void *GetProperty(ULONG id);

		// Reference methods
		int NumRefs() { return 3; };	
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);
		RefResult NotifyRefChanged(Interval, RefTargetHandle, PartID&, RefMessage);
		void RescaleWorldUnits(float f) {}

		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);

		// Control methods
		Control *GetXController() {return rotX;}
		Control *GetYController() {return rotY;}
		Control *GetZController() {return rotZ;}
		void Copy(Control *from);
		RefTargetHandle Clone(RemapDir& remap);
		BOOL IsLeaf() {return FALSE;}
		void GetValue(TimeValue t, void *val, Interval &valid, GetSetMethod method);	
		void SetValue(TimeValue t, void *val, int commit, GetSetMethod method);
		void CommitValue(TimeValue t);
		void RestoreValue(TimeValue t);
		void EnumIKParams(IKEnumCallback &callback);
		BOOL CompDeriv(TimeValue t,Matrix3& ptm,IKDeriv& derivs,DWORD flags);
		float IncIKParam(TimeValue t,int index,float delta);
		void ClearIKParam(Interval iv,int index);
		void EnableORTs(BOOL enable);
		void MirrorIKConstraints(int axis,int which);		
		BOOL CanCopyIKParams(int which);
		IKClipObject *CopyIKParams(int which);
		BOOL CanPasteIKParams(IKClipObject *co,int which);
		void PasteIKParams(IKClipObject *co,int which);

		void ChangeOrdering(int newOrder);
	};

EulerDlg *EulerRotation::dlg = NULL;
IObjParam *EulerRotation::ip = NULL;
ULONG EulerRotation::beginFlags = 0;
EulerRotation *EulerRotation::editControl = NULL;

class JointParamsEuler : public JointParams {
	public:			 	
		JointParamsEuler() : JointParams((DWORD)JNT_ROT,3) {flags |= JNT_LIMITEXACT;}
		void SpinnerChange(InterpCtrlUI *ui,WORD id,ISpinnerControl *spin,BOOL interactive);
	};

static BOOL CALLBACK EulerParamDialogProc(HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);

static const int editButs[] = {IDC_EULER_X,IDC_EULER_Y,IDC_EULER_Z};

static int eulerIDs[] = {
	IDS_RB_EULERTYPE0,IDS_RB_EULERTYPE1,IDS_RB_EULERTYPE2,
	IDS_RB_EULERTYPE3,IDS_RB_EULERTYPE4,IDS_RB_EULERTYPE5,
	IDS_RB_EULERTYPE6,IDS_RB_EULERTYPE7,IDS_RB_EULERTYPE8};

typedef int EAOrdering[3];
static EAOrdering orderings[] = {
	{0,1,2},
	{0,2,1},
	{1,2,0},
	{1,0,2},
	{2,0,1},
	{2,1,0},
	{0,1,0},
	{1,2,1},
	{2,0,2},
	};

static int xyzIDs[] = {IDS_RB_X,IDS_RB_Y,IDS_RB_Z};
static int xyzRotIDs[] = {IDS_RB_XROTATION,IDS_RB_YROTATION,IDS_RB_ZROTATION};
static int xyzAxisIDs[] = {IDS_RB_XAXIS,IDS_RB_YAXIS,IDS_RB_ZAXIS};

#define EDIT_X	0
#define EDIT_Y	1
#define EDIT_Z	2

#define EULER_BEGIN		1
#define EULER_MIDDLE	2
#define EULER_END		3

class EulerDlg {
	public:
		EulerRotation *cont;
		HWND hWnd;
		IObjParam *ip;
		ICustButton *iEdit[3];
		static int cur;
		
		EulerDlg(EulerRotation *cont,IObjParam *ip);
		~EulerDlg();

		void Init();
		void SetButtonText();
		void EndingEdit(EulerRotation *next);
		void BeginingEdit(EulerRotation *cont,IObjParam *ip,EulerRotation *prev);
		void SetCur(int c,int code=EULER_MIDDLE);
		void WMCommand(int id, int notify, HWND hCtrl);
	};

int EulerDlg::cur = EDIT_X;

EulerDlg::EulerDlg(EulerRotation *cont,IObjParam *ip)
	{
	this->ip   = ip;
	this->cont = cont;
	for (int i=0; i<3; i++) {
		iEdit[i] = NULL;
		}
	
	hWnd = ip->AddRollupPage( 
		hInstance,
		MAKEINTRESOURCE(IDD_EULER_PARAMS),
		EulerParamDialogProc,
		GetString(IDS_RB_EULERPARAMS), 
		(LPARAM)this);
	ip->RegisterDlgWnd(hWnd);	
	
	SetCur(cur,EULER_BEGIN);	
	UpdateWindow(hWnd);
	}

EulerDlg::~EulerDlg()
	{
	SetCur(cur,EULER_END);
	for (int i=0; i<3; i++) {
		ReleaseICustButton(iEdit[i]);		
		}
	ip->UnRegisterDlgWnd(hWnd);
	ip->DeleteRollupPage(hWnd);
	hWnd = NULL;
	}

void EulerDlg::EndingEdit(EulerRotation *next)
	{
	switch (cur) {
		case EDIT_X:
			cont->rotX->EndEditParams(ip,0,next->rotX);
			break;
		case EDIT_Y:
			cont->rotY->EndEditParams(ip,0,next->rotY);
			break;
		case EDIT_Z:
			cont->rotZ->EndEditParams(ip,0,next->rotZ);
			break;
		}
	cont = NULL;
	ip   = NULL;
	}

void EulerDlg::BeginingEdit(EulerRotation *cont,IObjParam *ip,EulerRotation *prev)
	{
	this->ip   = ip;
	this->cont = cont;
	switch (cur) {
		case EDIT_X:
			cont->rotX->BeginEditParams(ip,BEGIN_EDIT_MOTION,prev->rotX);
			break;
		case EDIT_Y:
			cont->rotY->BeginEditParams(ip,BEGIN_EDIT_MOTION,prev->rotY);
			break;
		case EDIT_Z:
			cont->rotZ->BeginEditParams(ip,BEGIN_EDIT_MOTION,prev->rotZ);
			break;
		}	
	UpdateWindow(hWnd);
	}

void EulerDlg::SetButtonText()
	{
	for (int i=0; i<3; i++) {
		iEdit[i]->SetText(GetString(
			xyzIDs[orderings[cont->order][i]]));
		}
	}

void EulerDlg::Init()
	{	
	for (int i=0; i<3; i++) {
		iEdit[i] = GetICustButton(GetDlgItem(hWnd,editButs[i]));		
		iEdit[i]->SetType(CBT_CHECK);		
		}
	iEdit[cur]->SetCheck(TRUE);	
	SetButtonText();

	SendDlgItemMessage(hWnd,IDC_EULER_ORDER,CB_RESETCONTENT,0,0);
	for (i=0; i<9; i++) {
		SendDlgItemMessage(hWnd,IDC_EULER_ORDER,CB_ADDSTRING,0,
			(LPARAM)GetString(eulerIDs[i]));
		}
	SendDlgItemMessage(hWnd,IDC_EULER_ORDER,CB_SETCURSEL,cont->order,0);
	}

void EulerDlg::SetCur(int c,int code)
	{
	if (c==cur && code==EULER_MIDDLE) return;
	Control *prev = NULL, *next = NULL;

	if (code!=EULER_END) {
		switch (c) {
			case EDIT_X:
				next = cont->rotX;
				break;
			case EDIT_Y:
				next = cont->rotY;
				break;
			case EDIT_Z:
				next = cont->rotZ;
				break;
			}
		}

	if (code!=EULER_BEGIN) {
		switch (cur) {
			case EDIT_X:
				cont->rotX->EndEditParams(ip,END_EDIT_REMOVEUI,next);
				prev = cont->rotX;
				break;
			case EDIT_Y:
				cont->rotY->EndEditParams(ip,END_EDIT_REMOVEUI,next);
				prev = cont->rotY;
				break;
			case EDIT_Z:
				cont->rotZ->EndEditParams(ip,END_EDIT_REMOVEUI,next);
				prev = cont->rotZ;
				break;
			}
		}

	cur = c;

	if (code!=EULER_END) {
		switch (cur) {
			case EDIT_X:
				cont->rotX->BeginEditParams(ip,BEGIN_EDIT_MOTION,prev);
				break;
			case EDIT_Y:
				cont->rotY->BeginEditParams(ip,BEGIN_EDIT_MOTION,prev);
				break;
			case EDIT_Z:
				cont->rotZ->BeginEditParams(ip,BEGIN_EDIT_MOTION,prev);
				break;
			}
		}
	}

void EulerDlg::WMCommand(int id, int notify, HWND hCtrl)
	{
	switch (id) {
		case IDC_EULER_X:
			SetCur(0);
			iEdit[0]->SetCheck(TRUE);
			iEdit[1]->SetCheck(FALSE);
			iEdit[2]->SetCheck(FALSE);
			break;
		case IDC_EULER_Y:
			SetCur(1);
			iEdit[0]->SetCheck(FALSE);
			iEdit[1]->SetCheck(TRUE);
			iEdit[2]->SetCheck(FALSE);
			break;
		case IDC_EULER_Z:
			SetCur(2);
			iEdit[0]->SetCheck(FALSE);
			iEdit[1]->SetCheck(FALSE);
			iEdit[2]->SetCheck(TRUE);
			break;

		case IDC_EULER_ORDER:
			if (notify==CBN_SELCHANGE) {
				int res = SendDlgItemMessage(hWnd,IDC_EULER_ORDER,CB_GETCURSEL,0,0);
				if (res!=CB_ERR) {
					cont->ChangeOrdering(res);
					SetButtonText();
					}
				}
			break;			
		}
	}

static BOOL CALLBACK EulerParamDialogProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam )
	{
	EulerDlg *dlg = (EulerDlg*)GetWindowLong(hDlg,GWL_USERDATA);

	switch (message) {
		case WM_INITDIALOG:
			dlg = (EulerDlg*)lParam;			
			SetWindowLong(hDlg,GWL_USERDATA,lParam);
			dlg->hWnd = hDlg;
			dlg->Init();
			break;
		
		case WM_COMMAND:
			dlg->WMCommand(LOWORD(wParam),HIWORD(wParam),(HWND)lParam);
			break;

		case WM_LBUTTONDOWN:case WM_LBUTTONUP:	case WM_MOUSEMOVE:
			dlg->ip->RollupMouseMessage(hDlg,message,wParam,lParam);
			break;
				
		default:
			return FALSE;
		}
	return TRUE;
	}


//********************************************************
// EULER CONTROL
//********************************************************
static Class_ID eulerControlClassID(EULER_CONTROL_CLASS_ID,0); 
class EulerClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { return new EulerRotation(loading); }
	const TCHAR *	ClassName() { return EULER_CONTROL_CNAME; }
	SClass_ID		SuperClassID() { return CTRL_ROTATION_CLASS_ID; }
	Class_ID		ClassID() { return eulerControlClassID; }
	const TCHAR* 	Category() { return _T("");  }
	};
static EulerClassDesc eulerCD;
ClassDesc* GetEulerCtrlDesc() {return &eulerCD;}

EulerRotation::EulerRotation(const EulerRotation &ctrl)
	{
	order = EULERTYPE_XYZ;
	rotX = NULL;
	rotY = NULL;
	rotZ = NULL;

	if (ctrl.rotX) {
		ReplaceReference(EULER_X_REF,ctrl.rotX);
	} else {
		ReplaceReference(EULER_X_REF,NewDefaultFloatController());
		}
	if (ctrl.rotY) {
		ReplaceReference(EULER_Y_REF,ctrl.rotY);
	} else {
		ReplaceReference(EULER_Y_REF,NewDefaultFloatController());
		}
	if (ctrl.rotZ) {
		ReplaceReference(EULER_Z_REF,ctrl.rotZ);
	} else {
		ReplaceReference(EULER_Z_REF,NewDefaultFloatController());
		}
	curval = ctrl.curval;
	ivalid = ctrl.ivalid;
	}

EulerRotation::EulerRotation(BOOL loading) 
	{
	order = EULERTYPE_XYZ;
	rotX = NULL;
	rotY = NULL;
	rotZ = NULL;
	if (!loading) {
		ReplaceReference(EULER_X_REF,NewDefaultFloatController());
		ReplaceReference(EULER_Y_REF,NewDefaultFloatController());
		ReplaceReference(EULER_Z_REF,NewDefaultFloatController());
		ivalid = FOREVER;
		curval.Identity();
	} else {
		ivalid.SetEmpty();
		}	
	}

RefTargetHandle EulerRotation::Clone(RemapDir& remap) 
	{
	EulerRotation *euler = new EulerRotation(TRUE);	
	euler->ReplaceReference(EULER_X_REF, remap.CloneRef(rotX));
	euler->ReplaceReference(EULER_Y_REF, remap.CloneRef(rotY));
	euler->ReplaceReference(EULER_Z_REF, remap.CloneRef(rotZ));
	euler->order = order;

	JointParams *jp = (JointParams*)GetProperty(PROPID_JOINTPARAMS);
    if (jp) {
		JointParams *jp2 = new JointParams(*jp);
		euler->SetProperty(PROPID_JOINTPARAMS,jp2);
		}
	return euler;
	}



EulerRotation::~EulerRotation()
	{
	DeleteAllRefsFromMe();
	}

void EulerRotation::GetClassName(TSTR& s)
	{		
	TSTR format(GetString(IDS_RB_EULERNAME));
	s.printf(format,GetString(eulerIDs[order]));
	}

// This copy method will sample the from controller and smooth out all flips
// Nikolai 1-15-99
void EulerRotation::Copy(Control *from)
	{
	if (from->ClassID()==ClassID()) {
		EulerRotation *ctrl = (EulerRotation*)from;
		ReplaceReference(EULER_X_REF,ctrl->rotX);
		ReplaceReference(EULER_Y_REF,ctrl->rotY);
		ReplaceReference(EULER_Z_REF,ctrl->rotZ);
		curval = ctrl->curval;
		ivalid = ctrl->ivalid;
		order  = ctrl->order;
	} else {		
		Quat qPrev;
		Quat qCurr;
		Interval iv;
		int num;		
		if ((num=from->NumKeys())!=NOT_KEYFRAMEABLE && num>0) {
			SuspendAnimate();
			AnimateOn();
			Interval anim;

			anim.SetStart(from->GetKeyTime(0));

			float eaCurr[3];
			float eaPrev[3];
			float EulerAng[3] = {0,0,0};

			from->GetValue(anim.Start(),&qPrev,iv);

			Matrix3 tm;
			qPrev.MakeMatrix(tm);
			MatrixToEuler(tm,EulerAng, order);
				
			rotX->SetValue(anim.Start(),&EulerAng[0],TRUE, CTRL_ABSOLUTE);
			rotY->SetValue(anim.Start(),&EulerAng[1],TRUE, CTRL_ABSOLUTE);
			rotZ->SetValue(anim.Start(),&EulerAng[2],TRUE, CTRL_ABSOLUTE);
			
			if(num>1)
			{
				float dEuler[3],f;	
				Matrix3 tmPrev, tmCurr;

				anim.SetEnd(from->GetKeyTime(num-1));
				
				// Here we sample over the time range, to detect flips
				for(TimeValue time = anim.Start()+1; time <= anim.End() ; time++  )
				{
					from->GetValue(time,&qCurr,iv);
					
					qPrev.MakeMatrix(tmPrev);
					qCurr.MakeMatrix(tmCurr);

					// The Euler/Quat ratio is the relation of the angle difference in Euler space to 
					// the angle difference in Quat space. If this ration is bigger than PI the rotation 
					// between the two time steps contains a flip

					f = GetEulerMatAngleRatio(tmPrev,tmCurr,eaPrev,eaCurr,order);	
										
					if(  f > PI)
					{
						// We found a flip here
						for(int j=0 ; j < 3 ; j++)
						{				
							// find the sign flip :
							if(fabs((eaCurr[j]-eaPrev[j])) < 2*PI-THRESHHOLD )
								dEuler[j] = eaCurr[j]-eaPrev[j];
							else
								// unflip the flip
								dEuler[j] = (2*PI - (float) (fabs(eaCurr[j]) + fabs(eaPrev[j]))) * (eaPrev[j] > 0 ? 1 : -1);
							
							EulerAng[j] += dEuler[j];
						}
					}
					else
					{
						// Add up the angle difference
						for(int j=0 ; j < 3 ; j++)
						{
							dEuler[j] = eaCurr[j]-eaPrev[j];
							EulerAng[j] += dEuler[j];
						}
					}
					if(from->IsKeyAtTime(time,KEYAT_ROTATION))
					{
						// Create the keys
						rotX->SetValue(time,&EulerAng[0],TRUE, CTRL_ABSOLUTE);
						rotY->SetValue(time,&EulerAng[1],TRUE, CTRL_ABSOLUTE);
						rotZ->SetValue(time,&EulerAng[2],TRUE, CTRL_ABSOLUTE);
					}
					qPrev = qCurr;
				}
			}
			// RB 2/10/99: A key at frame 0 may have been created
			if (num>0 && from->GetKeyTime(0)!=0) {
				rotX->DeleteKeyAtTime(0);
				rotY->DeleteKeyAtTime(0);
				rotZ->DeleteKeyAtTime(0);
			}
			ResumeAnimate();
		} else {
			from->GetValue(0,&qCurr,ivalid);
			SetValue(0,&qCurr,TRUE,CTRL_ABSOLUTE);
			}
		}
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	}

  /*
void EulerRotation::Copy(Control *from)
	{
	if (from->ClassID()==ClassID()) {
		EulerRotation *ctrl = (EulerRotation*)from;
		ReplaceReference(EULER_X_REF,ctrl->rotX);
		ReplaceReference(EULER_Y_REF,ctrl->rotY);
		ReplaceReference(EULER_Z_REF,ctrl->rotZ);
		curval = ctrl->curval;
		ivalid = ctrl->ivalid;
		order  = ctrl->order;
	} else {		
		Quat v;
		Interval iv;
		int num;		
		if (num=from->NumKeys()) {
			SuspendAnimate();
			AnimateOn();
			for (int i=0; i<num; i++) {
				TimeValue t = from->GetKeyTime(i);
				from->GetValue(t,&v,iv);
				SetValue(t,&v,TRUE,CTRL_ABSOLUTE);	
				}
			ResumeAnimate();
		} else {
			from->GetValue(0,&v,ivalid);
			SetValue(0,&v,TRUE,CTRL_ABSOLUTE);
			}
		}
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	}
*/

void EulerRotation::Update(TimeValue t)
	{
	if (!ivalid.InInterval(t)) {
		ivalid = FOREVER;
		Point3 ang(0,0,0);
		if (rotX) rotX->GetValue(t,&ang.x,ivalid);
		if (rotY) rotY->GetValue(t,&ang.y,ivalid);
		if (rotZ) rotZ->GetValue(t,&ang.z,ivalid);
		
		// This could be optimized.
		//Matrix3 tm(1);
		//tm.RotateX(x);
		//tm.RotateY(y);
		//tm.RotateZ(z);
		//curval = Quat(tm);		
		Matrix3 tm(1);
		for (int i=0; i<3; i++) {
			switch (orderings[order][i]) {
				case 0: tm.RotateX(ang[i]); break;
				case 1: tm.RotateY(ang[i]); break;
				case 2: tm.RotateZ(ang[i]); break;
				}
			}
		curval = Quat(tm);
		//EulerToQuat(ang, curval, order);
		}
	}

void EulerRotation::ChangeOrdering(int newOrder)
	{
	order = newOrder;
	ivalid.SetEmpty();
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	NotifyDependents(FOREVER,PART_ALL,REFMSG_SUBANIM_STRUCTURE_CHANGED);
	ip->RedrawViews(ip->GetTime());
	}

void EulerRotation::SetValue(TimeValue t, void *val, int commit, GetSetMethod method)
	{
	Quat v;
	Update(t);
	if (method==CTRL_RELATIVE) {
		v = curval * Quat(*((AngAxis*)val));
	} else {
		v = *((Quat*)val);
		}
		
	float ang[3];
	//QuatToEuler(v,ang);
	Matrix3 tm;
	v.MakeMatrix(tm);
	MatrixToEuler(tm,ang, order);
	
	// RB: this gives the incorrect sign sometimes...
	//QuatToEuler(v, ang, order);		

	if (rotX) rotX->SetValue(t,&ang[0]);
	if (rotY) rotY->SetValue(t,&ang[1]);
	if (rotZ) rotZ->SetValue(t,&ang[2]);
	ivalid.SetEmpty();
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	}

void EulerRotation::GetValue(TimeValue t, void *val, Interval &valid, GetSetMethod method)
	{		
	Update(t);
	valid &= ivalid;			 
	if (method==CTRL_RELATIVE) {
  		Matrix3 *mat = (Matrix3*)val;		
		PreRotateMatrix(*mat,curval);		
	} else {
		*((Quat*)val) = curval;
		}
	}

void EulerRotation::CommitValue(TimeValue t)
	{
	if (rotX) rotX->CommitValue(t);
	if (rotY) rotY->CommitValue(t);
	if (rotZ) rotZ->CommitValue(t);
	}

void EulerRotation::RestoreValue(TimeValue t)
	{
	if (rotX) rotX->RestoreValue(t);
	if (rotY) rotY->RestoreValue(t);
	if (rotZ) rotZ->RestoreValue(t);
	}

RefTargetHandle EulerRotation::GetReference(int i)
	{
	switch (i) {
		case EULER_X_REF: return rotX;
		case EULER_Y_REF: return rotY;
		case EULER_Z_REF: return rotZ;
		default: return NULL;
		}
	}

void EulerRotation::SetReference(int i, RefTargetHandle rtarg)
	{
	switch (i) {
		case EULER_X_REF: rotX = (Control*)rtarg; break;
		case EULER_Y_REF: rotY = (Control*)rtarg; break;
		case EULER_Z_REF: rotZ = (Control*)rtarg; break;
		}
	}

Animatable* EulerRotation::SubAnim(int i)
	{
	return GetReference(i);
	}

TSTR EulerRotation::SubAnimName(int i)
	{	
	switch (i) {
		case EULER_X_REF: return GetString(xyzRotIDs[orderings[order][0]]);
		case EULER_Y_REF: return GetString(xyzRotIDs[orderings[order][1]]);
		case EULER_Z_REF: return GetString(xyzRotIDs[orderings[order][2]]);
		default: return _T("");
		}
	}

RefResult EulerRotation::NotifyRefChanged(
		Interval iv, 
		RefTargetHandle hTarg, 
		PartID& partID, 
		RefMessage msg) 
	{
	switch (msg) {
		case REFMSG_CHANGE:
			ivalid.SetEmpty();
			break;
		case REFMSG_TARGET_DELETED:
			if (rotX == hTarg) rotX = NULL;
			if (rotY == hTarg) rotY = NULL;
			if (rotZ == hTarg) rotZ = NULL; 
			break;
		case REFMSG_GET_CONTROL_DIM: {
			ParamDimension **dim = (ParamDimension **)partID;
			assert(dim);
			*dim = stdAngleDim;
			}
		}
	return REF_SUCCEED;
	}

BOOL EulerRotation::AssignController(Animatable *control,int subAnim)
	{	
	switch (subAnim) {
		case EULER_X_REF:
			ReplaceReference(EULER_X_REF,(RefTargetHandle)control);
			break;
		case EULER_Y_REF:
			ReplaceReference(EULER_Y_REF,(RefTargetHandle)control);
			break;
		case EULER_Z_REF:
			ReplaceReference(EULER_Z_REF,(RefTargetHandle)control);
			break;
		}
	NotifyDependents(FOREVER,0,REFMSG_CONTROLREF_CHANGE,TREE_VIEW_CLASS_ID,FALSE);
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);	
	return TRUE;
	}

void EulerRotation::AddNewKey(TimeValue t,DWORD flags)
	{
	if (rotX) rotX->AddNewKey(t,flags);
	if (rotY) rotY->AddNewKey(t,flags);
	if (rotZ) rotZ->AddNewKey(t,flags);
	}

int EulerRotation::NumKeys()
	{
	int num = 0;
	if (rotX) num += rotX->NumKeys(); 
	if (rotY) num += rotY->NumKeys();
	if (rotZ) num += rotZ->NumKeys();
	return num;
	}

TimeValue EulerRotation::GetKeyTime(int index)
	{
	int onum,num = 0;
	if (rotX) num += rotX->NumKeys(); 
	if (index < num) return rotX->GetKeyTime(index);
	onum = num;
	if (rotY) num += rotY->NumKeys(); 
	if (index < num) return rotY->GetKeyTime(index-onum);
	onum = num;
	if (rotZ) num += rotZ->NumKeys(); 
	if (index < num) return rotZ->GetKeyTime(index-onum);
	return 0;
	}

void EulerRotation::CopyKeysFromTime(TimeValue src,TimeValue dst,DWORD flags)
	{
	if (rotX) rotX->CopyKeysFromTime(src,dst,flags);
	if (rotY) rotY->CopyKeysFromTime(src,dst,flags);
	if (rotZ) rotZ->CopyKeysFromTime(src,dst,flags);
	}

BOOL EulerRotation::IsKeyAtTime(TimeValue t,DWORD flags)
	{
	if (rotX && rotX->IsKeyAtTime(t,flags)) return TRUE;
	if (rotY && rotY->IsKeyAtTime(t,flags)) return TRUE;
	if (rotZ && rotZ->IsKeyAtTime(t,flags)) return TRUE;
	return FALSE;
	}

void EulerRotation::DeleteKeyAtTime(TimeValue t)
	{
	if (rotX) rotX->DeleteKeyAtTime(t);
	if (rotY) rotY->DeleteKeyAtTime(t);
	if (rotZ) rotZ->DeleteKeyAtTime(t);
	}

BOOL EulerRotation::GetNextKeyTime(TimeValue t,DWORD flags,TimeValue &nt)
	{
	TimeValue at,tnear = 0;
	BOOL tnearInit = FALSE;
	
	if (rotX && rotX->GetNextKeyTime(t,flags,at)) {
		if (!tnearInit) {
			tnear = at;
			tnearInit = TRUE;
		} else 
		if (ABS(at-t) < ABS(tnear-t)) tnear = at;
		}

	if (rotY && rotY->GetNextKeyTime(t,flags,at)) {
		if (!tnearInit) {
			tnear = at;
			tnearInit = TRUE;
		} else 
		if (ABS(at-t) < ABS(tnear-t)) tnear = at;
		}

	if (rotZ && rotZ->GetNextKeyTime(t,flags,at)) {
		if (!tnearInit) {
			tnear = at;
			tnearInit = TRUE;
		} else 
		if (ABS(at-t) < ABS(tnear-t)) tnear = at;
		}
	
	if (tnearInit) {
		nt = tnear;
		return TRUE;
	} else {
		return FALSE;
		}
	}
		

void EulerRotation::BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev )
	{
	if (flags&BEGIN_EDIT_HIERARCHY) {
		JointParamsEuler *jp = (JointParamsEuler*)GetProperty(PROPID_JOINTPARAMS);
		InterpCtrlUI *ui;	

		if (!jp) {
			jp = new JointParamsEuler();
			SetProperty(PROPID_JOINTPARAMS,jp);
			}

		if (prev &&
			prev->ClassID()==ClassID() && 
		    (ui = (InterpCtrlUI*)prev->GetProperty(PROPID_INTERPUI))) {
			JointParams *prevjp = (JointParams*)prev->GetProperty(PROPID_JOINTPARAMS);
			prevjp->EndDialog(ui);
			ui->cont = this;
			ui->ip   = ip;
			prev->SetProperty(PROPID_INTERPUI,NULL);
			JointDlgData *jd = (JointDlgData*)GetWindowLong(ui->hParams,GWL_USERDATA);
			jd->jp = jp;
			jp->InitDialog(ui);
		} else {
			ui = new InterpCtrlUI(NULL,ip,this);
			DWORD f=0;
			if (jp && !jp->RollupOpen()) f = APPENDROLL_CLOSED;	

			ui->hParams = ip->AddRollupPage( 
				hInstance, 
				MAKEINTRESOURCE(IDD_STDJOINTPARAMS),
				JointParamDlgProc,
				GetString(IDS_RB_ROTJOINTPARAMS), 
				(LPARAM)new JointDlgData(ui,jp),f);	
			}
	
		SetDlgItemText(ui->hParams,IDC_XAXIS_LABEL,
			GetString(xyzAxisIDs[orderings[order][0]]));
		SetDlgItemText(ui->hParams,IDC_YAXIS_LABEL,
			GetString(xyzAxisIDs[orderings[order][1]]));
		SetDlgItemText(ui->hParams,IDC_ZAXIS_LABEL,
			GetString(xyzAxisIDs[orderings[order][2]]));

		SetProperty(PROPID_INTERPUI,ui);
		editControl = this;
		beginFlags = flags;
	} else 
	if (flags&BEGIN_EDIT_MOTION) {
		this->ip = ip;

		if (dlg) {
			dlg->BeginingEdit(this,ip,(EulerRotation*)prev);
			dlg->Init();
		} else {
			dlg = new EulerDlg(this,ip);	
			}
		}
	}

void EulerRotation::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next )
	{	
	EulerRotation *cont=NULL;
	if (next && next->ClassID()==ClassID()) {
		cont = (EulerRotation*)next;
		}

	if (dlg) {
		if (cont) {
			dlg->EndingEdit(cont);
		} else {
			delete dlg;
			dlg = NULL;
			}
	} else {
		if (cont) return;
		
		editControl = NULL;
		beginFlags = 0;

		int index = aprops.FindProperty(PROPID_INTERPUI);
		if (index>=0) {
			InterpCtrlUI *ui = (InterpCtrlUI*)aprops[index];
			if (ui->hParams) {
				ip->UnRegisterDlgWnd(ui->hParams);
				ip->DeleteRollupPage(ui->hParams);			
				}
			index = aprops.FindProperty(PROPID_INTERPUI);
			if (index>=0) {
				delete aprops[index];
				aprops.Delete(index,1);
				}
			}
		}
	}

int EulerRotation::SetProperty(ULONG id, void *data)
	{
	if (id==PROPID_JOINTPARAMS) {		
		if (!data) {
			int index = aprops.FindProperty(id);
			if (index>=0) {
				aprops.Delete(index,1);
				}
		} else {
			JointParamsEuler *jp = (JointParamsEuler*)GetProperty(id);
			if (jp) {
				*jp = *((JointParamsEuler*)data);
				delete (JointParamsEuler*)data;
			} else {
				aprops.Append(1,(AnimProperty**)&data);
				}					
			}
		return 1;
	} else
	if (id==PROPID_INTERPUI) {		
		if (!data) {
			int index = aprops.FindProperty(id);
			if (index>=0) {				
				aprops.Delete(index,1);
				}
		} else {
			InterpCtrlUI *ui = (InterpCtrlUI*)GetProperty(id);
			if (ui) {
				*ui = *((InterpCtrlUI*)data);
			} else {
				aprops.Append(1,(AnimProperty**)&data);
				}					
			}
		return 1;
	} else {
		return Animatable::SetProperty(id,data);
		}
	}

void* EulerRotation::GetProperty(ULONG id)
	{
	if (id==PROPID_INTERPUI || id==PROPID_JOINTPARAMS) {
		int index = aprops.FindProperty(id);
		if (index>=0) {
			return aprops[index];
		} else {
			return NULL;
			}
	} else {
		return Animatable::GetProperty(id);
		}
	}


#define JOINTPARAMEULER_CHUNK	0x1002
#define ORDER_CHUNK				0x1003

IOResult EulerRotation::Save(ISave *isave)
	{	
	ULONG nb;
	JointParamsEuler *jp = (JointParamsEuler*)GetProperty(PROPID_JOINTPARAMS);
	if (jp) {
		isave->BeginChunk(JOINTPARAMEULER_CHUNK);
		jp->Save(isave);
		isave->EndChunk();
		}

	isave->BeginChunk(ORDER_CHUNK);
	isave->Write(&order,sizeof(order),&nb);
	isave->EndChunk();

	return IO_OK;
	}

IOResult EulerRotation::Load(ILoad *iload)
	{
	ULONG nb;
	IOResult res = IO_OK;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch (iload->CurChunkID()) {
			case ORDER_CHUNK:
				res=iload->Read(&order,sizeof(order),&nb);
				break;

			case JOINTPARAMEULER_CHUNK: {
				JointParamsEuler *jp = new JointParamsEuler;
				jp->Load(iload);
				jp->flags |= JNT_LIMITEXACT;
				SetProperty(PROPID_JOINTPARAMS,jp);
				break;
				}
			}		
		iload->CloseChunk();
		if (res!=IO_OK)  return res;
		}
	return IO_OK;
	}


void EulerRotation::EnumIKParams(IKEnumCallback &callback)
	{
	JointParamsEuler *jp = (JointParamsEuler*)GetProperty(PROPID_JOINTPARAMS);
	for (int i=2; i>=0; i--) {
		if (!jp || jp->Active(i)) {
			callback.proc(this,i);
			}
		}
	}

BOOL EulerRotation::CompDeriv(TimeValue t,Matrix3& ptm,IKDeriv& derivs,DWORD flags)
	{
	JointParamsEuler *jp = (JointParamsEuler*)GetProperty(PROPID_JOINTPARAMS);
	Quat q;
	Interval valid;
	Point3 a(0,0,0);

	if (rotX) rotX->GetValue(t,&a[0],valid);
	if (rotY) rotY->GetValue(t,&a[1],valid);
	if (rotZ) rotZ->GetValue(t,&a[2],valid);

	for (int i=2; i>=0; i--) {
		if (!jp || jp->Active(i)) {
			for (int j=0; j<derivs.NumEndEffectors(); j++) {
				Point3 r = derivs.EndEffectorPos(j) - ptm.GetTrans();	
		
				Point3 axis = ptm.GetRow(orderings[order][i]);
				if (!(ptm.GetIdentFlags()&SCL_IDENT)) {
					axis = Normalize(axis);
					if (ptm.Parity()) axis = -axis;
					}

				if (flags&POSITION_DERIV) {
					derivs.DP(CrossProd(axis,r),j);
					}
				if (flags&ROTATION_DERIV) {
					derivs.DR(axis,j);
					}
				}
			derivs.NextDOF();			
			}
		switch (orderings[order][i]) {
			case 0: ptm.PreRotateX(a[i]); break;
			case 1: ptm.PreRotateY(a[i]); break;
			case 2: ptm.PreRotateZ(a[i]); break;
			}
		}	
	return TRUE;
	}

#define MAX_IKROT	DegToRad(4.0f)
#define SGN(a)	(a<0?-1:1)

float EulerRotation::IncIKParam(TimeValue t,int index,float delta)
	{
	JointParamsEuler *jp = (JointParamsEuler*)GetProperty(PROPID_JOINTPARAMS);
	if ((float)fabs(delta)>MAX_IKROT) delta = MAX_IKROT * SGN(delta);
	
	if (jp) {
		float v=0.0f;		
		if (jp->Limited(index) || jp->Spring(index)) {
			Interval valid;
			switch (index) {
				case 0: if (rotX) rotX->GetValue(t,&v,valid); break;
				case 1: if (rotY) rotY->GetValue(t,&v,valid); break;
				case 2: if (rotZ) rotZ->GetValue(t,&v,valid); break;
				}
			}
		delta = jp->ConstrainInc(index,v,delta);
		}
	switch (index) {
		case 0: if (rotX) rotX->SetValue(t,&delta,FALSE,CTRL_RELATIVE); break;
		case 1: if (rotY) rotY->SetValue(t,&delta,FALSE,CTRL_RELATIVE); break;
		case 2: if (rotZ) rotZ->SetValue(t,&delta,FALSE,CTRL_RELATIVE); break;
		}	
	return delta;	
	}

void EulerRotation::ClearIKParam(Interval iv,int index) 
	{
	switch (index) {
		case 0: if (rotX) rotX->DeleteTime(iv,TIME_INCRIGHT|TIME_NOSLIDE); break;
		case 1: if (rotY) rotY->DeleteTime(iv,TIME_INCRIGHT|TIME_NOSLIDE); break;
		case 2: if (rotZ) rotZ->DeleteTime(iv,TIME_INCRIGHT|TIME_NOSLIDE); break;
		}
	}

void EulerRotation::MirrorIKConstraints(int axis,int which)
	{
	JointParamsEuler *jp = (JointParamsEuler*)GetProperty(PROPID_JOINTPARAMS);
	if (jp) jp->MirrorConstraints(axis);
	}

void EulerRotation::EnableORTs(BOOL enable)
	{
	if (rotX) rotX->EnableORTs(enable);
	if (rotY) rotY->EnableORTs(enable);
	if (rotZ) rotZ->EnableORTs(enable);
	}

BOOL EulerRotation::CanCopyIKParams(int which)
	{
	return ::CanCopyIKParams(this,which);
	}

IKClipObject *EulerRotation::CopyIKParams(int which)
	{
	return ::CopyIKParams(this,which);
	}

BOOL EulerRotation::CanPasteIKParams(IKClipObject *co,int which)
	{
	return ::CanPasteIKParams(this,co,which);
	}

void EulerRotation::PasteIKParams(IKClipObject *co,int which)
	{
	::PasteIKParams(this,co,which);
	}

void JointParamsEuler::SpinnerChange(
		InterpCtrlUI *ui,WORD id,ISpinnerControl *spin,BOOL interactive)
	{
	EulerRotation *c = (EulerRotation*)ui->cont;
	Point3 a(0,0,0);
	BOOL set = FALSE;
	Interval valid;

	if (c->rotX) c->rotX->GetValue(ui->ip->GetTime(),&a[0],valid);
	if (c->rotY) c->rotY->GetValue(ui->ip->GetTime(),&a[1],valid);
	if (c->rotZ) c->rotZ->GetValue(ui->ip->GetTime(),&a[2],valid);

	switch (id) {
		case IDC_XFROMSPIN:
			a[0] = min[0] = DegToRad(spin->GetFVal()); 
			set = TRUE;
			break;
		case IDC_XTOSPIN:
			a[0] = max[0] = DegToRad(spin->GetFVal());
			set = TRUE;
			break;
		case IDC_XSPRINGSPIN:
			a[0] = spring[0] = DegToRad(spin->GetFVal());
			set = TRUE;
			break;
		
		case IDC_YFROMSPIN:
			a[1] = min[1] = DegToRad(spin->GetFVal()); 
			set = TRUE;
			break;
		case IDC_YTOSPIN:
			a[1] = max[1] = DegToRad(spin->GetFVal());
			set = TRUE;
			break;
		case IDC_YSPRINGSPIN:
			a[0] = spring[1] = DegToRad(spin->GetFVal());
			set = TRUE;
			break;
		
		case IDC_ZFROMSPIN:
			a[2] = min[2] = DegToRad(spin->GetFVal()); 
			set = TRUE;
			break;
		case IDC_ZTOSPIN:
			a[2] = max[2] = DegToRad(spin->GetFVal());
			set = TRUE;
			break;
		case IDC_ZSPRINGSPIN:
			a[2] = spring[0] = DegToRad(spin->GetFVal());
			set = TRUE;
			break;
		
		case IDC_XDAMPINGSPIN:
			damping[0] = spin->GetFVal(); break;		
		case IDC_YDAMPINGSPIN:
			damping[1] = spin->GetFVal(); break;		
		case IDC_ZDAMPINGSPIN:
			damping[2] = spin->GetFVal(); break;

		case IDC_XSPRINGTENSSPIN:
			stens[0] = spin->GetFVal()/SPRINGTENS_UI; break;
		case IDC_YSPRINGTENSSPIN:
			stens[1] = spin->GetFVal()/SPRINGTENS_UI; break;
		case IDC_ZSPRINGTENSSPIN:
			stens[2] = spin->GetFVal()/SPRINGTENS_UI; break;
		}
	
	if (set && interactive) {		 		
 		if (c->rotX) c->rotX->SetValue(ui->ip->GetTime(),&a[0],TRUE,CTRL_ABSOLUTE);
		if (c->rotY) c->rotY->SetValue(ui->ip->GetTime(),&a[1],TRUE,CTRL_ABSOLUTE);
		if (c->rotZ) c->rotZ->SetValue(ui->ip->GetTime(),&a[2],TRUE,CTRL_ABSOLUTE);
		ui->ip->RedrawViews(ui->ip->GetTime(),REDRAW_INTERACTIVE);
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Control\exprctrl.cpp ===
/**********************************************************************
 *<
	FILE: exprctrl.cpp

	DESCRIPTION: An expression-based controller

	CREATED BY: Don Brittain

	HISTORY: created 24 August 1995 (Windows 95 debut!)

 *>	Copyright (c) 1995, All Rights Reserved.
 **********************************************************************/

#include "ctrl.h"
#include "units.h"
#include "exprlib.h"
#include <stdio.h>

extern HINSTANCE hInstance;

#define EXPR_POS_CONTROL_CNAME		GetString(IDS_DB_POSITION_EXPR)
#define EXPR_P3_CONTROL_CNAME		GetString(IDS_DB_POINT3_EXPR)
#define EXPR_FLOAT_CONTROL_CNAME	GetString(IDS_DB_FLOAT_EXPR)
#define EXPR_SCALE_CONTROL_CNAME	GetString(IDS_DB_SCALE_EXPR)
#define EXPR_ROT_CONTROL_CNAME		GetString(IDS_DB_ROTATION_EXPR)

#define EXPR_TICKS		0
#define EXPR_SECS		1
#define EXPR_FRAMES		2
#define EXPR_NTIME		3

class ExprControl;

// for the debug floater window
class ExprDebug : public TimeChangeCallback {
public:
	HWND hWnd;
	ExprControl *ec;
	TimeValue t;
	static int winX, winY;

	ExprDebug(HWND hParent, ExprControl *exprControl);
	~ExprDebug();

	void Invalidate();
	void SetTime(TimeValue tm)	{ t = tm; }
	void Update();
	void Init(HWND hWnd);

	void TimeChanged(TimeValue t)	{ SetTime(t); Update(); }
};

// scalar variables
class SVar {
public:
	TSTR	name;
	int		regNum;	// register number variable is assigned to
	int		refID;	// < 0 means constant
	float	val;	// value, if constant
	int		subNum;
	int		offset;	// tick offset
};

class VVar {
public:
	TSTR	name;
	int		regNum;	// reg num this var is assigned to
	int		refID;	// < 0 means constant
	Point3	val;	// value, if const
	int 	subNum;
	int		offset;	// tick offset
};

MakeTab(SVar);
MakeTab(VVar);

class VarRef {
public:
	VarRef()	{ client = NULL; refCt = 0; }
	VarRef(ReferenceTarget *c)	{ client = c; refCt = 1; }
	ReferenceTarget *client;
	int				refCt;
};

MakeTab(VarRef);

class ExprControl : public StdControl 
{
public:
	int			type;
	Expr		expr;
	int			timeSlots[4];
	int			sRegCt;
	int			vRegCt;
	int			curIndex;
	Point3		curPosVal;
	float		curFloatVal;
	Interval	ivalid;
	Interval	range;
	HWND		hParams;
	IObjParam *	ip;
	SVarTab		sVars;
	VVarTab		vVars;
	VarRefTab	refTab;
	TSTR		desc;
	HFONT		hFixedFont;
	HWND		hDlg;
	ExprDebug	*edbg;
	static int	winX, winY;
	BOOL blockGetNodeName; // RB 3/23/99: See imp of getNodeName()

	void	updRegCt(int val, int type);
	BOOL	dfnVar(int type, TCHAR *buf, int slot, int offset);
	int		getVarCount(int type) { return type == SCALAR_VAR ? sVars.Count() : vVars.Count(); }
	TCHAR * getVarName(int type, int i);
	int		getVarOffset(int type, int i);
	int		getRegNum(int type, int i);
	float	getScalarValue(int i);
	Point3	getVectorValue(int i);
	BOOL	assignScalarValue(int i, float val);
	BOOL	assignVectorValue(int i, Point3 &val);
	BOOL	assignController(int type, int i, ReferenceTarget *client, int subNum);
	void	deleteAllVars();
	void    getNodeName(ReferenceTarget *client,TSTR &name);

	ExprControl(int type, ExprControl &ctrl);
	ExprControl(int type, BOOL loading);
	~ExprControl();

	// Animatable methods
	int TrackParamsType() { return TRACKPARAMS_WHOLE; }
	
	void DeleteThis() { delete this; }
	int IsKeyable() { return 0; }		
	BOOL IsAnimated() {return TRUE;}
	Interval GetTimeRange(DWORD flags) { return range; }
	void EditTimeRange(Interval range,DWORD flags);
	void Hold();
	void MapKeys( TimeMap *map, DWORD flags );

	void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev );
	void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next );

	void EditTrackParams(
			TimeValue t,	// The horizontal position of where the user right clicked.
			ParamDimensionBase *dim,
			TCHAR *pname,
			HWND hParent,
			IObjParam *ip,
			DWORD flags);

	// Reference methods
	int NumRefs() { return StdControl::NumRefs() + refTab.Count(); }
	ReferenceTarget* GetReference(int i);
	void SetReference(int i, RefTargetHandle rtarg);
	RefResult NotifyRefChanged(Interval, RefTargetHandle, PartID&, RefMessage);
	void RefDeleted();

	IOResult Save(ISave *isave);
	IOResult Load(ILoad *iload);

	// Control methods
	void Copy(Control *from);
	RefTargetHandle Clone(RemapDir& remap=NoRemap()) { 
		ExprControl *ctrl = new ExprControl(this->type, *this);
		CloneControl(ctrl,remap);
		return ctrl; 
		}		
	BOOL IsLeaf() { return TRUE; }
	void GetValueLocalTime(TimeValue t, void *val, Interval &valid, GetSetMethod method=CTRL_ABSOLUTE);	
	void SetValueLocalTime(TimeValue t, void *val, int commit, GetSetMethod method) {}
	void Extrapolate(Interval range,TimeValue t,void *val,Interval &valid,int type);
	void *CreateTempValue();
	void DeleteTempValue(void *val);
	void ApplyValue(void *val, void *delta);
	void MultiplyValue(void *val, float m);

	void GetAbsoluteControlValue(INode *node,TimeValue t,Point3 *pt,Interval &iv);
};

int ExprControl::winX = -1;
int ExprControl::winY = -1;

class ExprPosControl : public ExprControl 
{
public:
	ExprPosControl(ExprPosControl &ctrl) : ExprControl(EXPR_POS_CONTROL_CLASS_ID, ctrl) {}
	ExprPosControl(BOOL loading=FALSE) : ExprControl(EXPR_POS_CONTROL_CLASS_ID, loading) {}
	~ExprPosControl() {}

	RefTargetHandle Clone(RemapDir& remap=NoRemap()) { return(new ExprPosControl(*this)); }		
	void GetClassName(TSTR& s) { s = EXPR_POS_CONTROL_CNAME; }
	Class_ID ClassID() { return Class_ID(EXPR_POS_CONTROL_CLASS_ID,0); }  
	SClass_ID SuperClassID() { return CTRL_POSITION_CLASS_ID; }  		
};

class ExprP3Control : public ExprControl 
{
public:
	ExprP3Control(ExprP3Control &ctrl) : ExprControl(EXPR_P3_CONTROL_CLASS_ID, ctrl) {}
	ExprP3Control(BOOL loading=FALSE) : ExprControl(EXPR_P3_CONTROL_CLASS_ID, loading) {}
	~ExprP3Control() {}

	RefTargetHandle Clone(RemapDir& remap=NoRemap()) { return(new ExprP3Control(*this)); }		
	void GetClassName(TSTR& s) { s = EXPR_P3_CONTROL_CNAME; }
	Class_ID ClassID() { return Class_ID(EXPR_P3_CONTROL_CLASS_ID,0); }  
	SClass_ID SuperClassID() { return CTRL_POINT3_CLASS_ID; }  		
};

class ExprFloatControl : public ExprControl 
{
public:
	ExprFloatControl(ExprFloatControl &ctrl) : ExprControl(EXPR_FLOAT_CONTROL_CLASS_ID, ctrl) {}
	ExprFloatControl(BOOL loading=FALSE) : ExprControl(EXPR_FLOAT_CONTROL_CLASS_ID, loading) {}
	~ExprFloatControl() {}

	RefTargetHandle Clone(RemapDir& remap=NoRemap()) { return(new ExprFloatControl(*this)); }		
	void GetClassName(TSTR& s) { s = EXPR_FLOAT_CONTROL_CNAME; }
	Class_ID ClassID() { return Class_ID(EXPR_FLOAT_CONTROL_CLASS_ID,0); }  
	SClass_ID SuperClassID() { return CTRL_FLOAT_CLASS_ID; }  		
};

class ExprScaleControl : public ExprControl 
{
public:
	ExprScaleControl(ExprScaleControl &ctrl) : ExprControl(EXPR_SCALE_CONTROL_CLASS_ID, ctrl) {}
	ExprScaleControl(BOOL loading=FALSE) : ExprControl(EXPR_SCALE_CONTROL_CLASS_ID, loading) {}
	~ExprScaleControl() {}

	RefTargetHandle Clone(RemapDir& remap=NoRemap()) { return(new ExprScaleControl(*this)); }		
	void GetClassName(TSTR& s) { s = EXPR_SCALE_CONTROL_CNAME; }
	Class_ID ClassID() { return Class_ID(EXPR_SCALE_CONTROL_CLASS_ID,0); }  
	SClass_ID SuperClassID() { return CTRL_SCALE_CLASS_ID; }  		
};

class ExprRotControl : public ExprControl 
{
public:
	ExprRotControl(ExprRotControl &ctrl) : ExprControl(EXPR_ROT_CONTROL_CLASS_ID, ctrl) {}
	ExprRotControl(BOOL loading=FALSE) : ExprControl(EXPR_ROT_CONTROL_CLASS_ID, loading) {}
	~ExprRotControl() {}

	RefTargetHandle Clone(RemapDir& remap=NoRemap()) { return(new ExprRotControl(*this)); }		
	void GetClassName(TSTR& s) { s = EXPR_ROT_CONTROL_CNAME; }
	Class_ID ClassID() { return Class_ID(EXPR_ROT_CONTROL_CLASS_ID,0); }  
	SClass_ID SuperClassID() { return CTRL_ROTATION_CLASS_ID; }  		
};

//********************************************************
// EXPRESSION CONTROL
//********************************************************
static Class_ID exprPosControlClassID(EXPR_POS_CONTROL_CLASS_ID,0); 
class ExprPosClassDesc:public ClassDesc 
{
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { return new ExprPosControl(loading); }
	const TCHAR *	ClassName() { return EXPR_POS_CONTROL_CNAME; }
	SClass_ID		SuperClassID() { return CTRL_POSITION_CLASS_ID; }
	Class_ID		ClassID() { return exprPosControlClassID; }
	const TCHAR* 	Category() { return _T("");  }
};
static ExprPosClassDesc exprPosCD;
ClassDesc* GetExprPosCtrlDesc() {return &exprPosCD;}

static Class_ID exprP3ControlClassID(EXPR_P3_CONTROL_CLASS_ID,0); 
class ExprP3ClassDesc:public ClassDesc 
{
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { return new ExprP3Control(loading); }
	const TCHAR *	ClassName() { return EXPR_P3_CONTROL_CNAME; }
	SClass_ID		SuperClassID() { return CTRL_POINT3_CLASS_ID; }
	Class_ID		ClassID() { return exprP3ControlClassID; }
	const TCHAR* 	Category() { return _T("");  }
};
static ExprP3ClassDesc exprP3CD;
ClassDesc* GetExprP3CtrlDesc() {return &exprP3CD;}

static Class_ID exprFloatControlClassID(EXPR_FLOAT_CONTROL_CLASS_ID,0); 
class ExprFloatClassDesc:public ClassDesc 
{
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { return new ExprFloatControl(loading); }
	const TCHAR *	ClassName() { return EXPR_FLOAT_CONTROL_CNAME; }
	SClass_ID		SuperClassID() { return CTRL_FLOAT_CLASS_ID; }
	Class_ID		ClassID() { return exprFloatControlClassID; }
	const TCHAR* 	Category() { return _T("");  }
};
static ExprFloatClassDesc exprFloatCD;
ClassDesc* GetExprFloatCtrlDesc() {return &exprFloatCD;}

static Class_ID exprScaleControlClassID(EXPR_SCALE_CONTROL_CLASS_ID,0); 
class ExprScaleClassDesc:public ClassDesc 
{
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { return new ExprScaleControl(loading); }
	const TCHAR *	ClassName() { return EXPR_SCALE_CONTROL_CNAME; }
	SClass_ID		SuperClassID() { return CTRL_SCALE_CLASS_ID; }
	Class_ID		ClassID() { return exprScaleControlClassID; }
	const TCHAR* 	Category() { return _T("");  }
};
static ExprScaleClassDesc exprScaleCD;
ClassDesc* GetExprScaleCtrlDesc() {return &exprScaleCD;}

static Class_ID exprRotControlClassID(EXPR_ROT_CONTROL_CLASS_ID,0); 
class ExprRotClassDesc:public ClassDesc 
{
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { return new ExprRotControl(loading); }
	const TCHAR *	ClassName() { return EXPR_ROT_CONTROL_CNAME; }
	SClass_ID		SuperClassID() { return CTRL_ROTATION_CLASS_ID; }
	Class_ID		ClassID() { return exprRotControlClassID; }
	const TCHAR* 	Category() { return _T("");  }
};
static ExprFloatClassDesc exprRotCD;
ClassDesc* GetExprRotCtrlDesc() {return &exprRotCD;}

ExprControl::ExprControl(int t, ExprControl &ctrl)
{
	int i, j, ct, slot;
	TCHAR *cp;

	blockGetNodeName = FALSE;

	type = t;
	hParams = NULL;
	hFixedFont = CreateFont(14,0,0,0,0,0,0,0,0,0,0,0, FIXED_PITCH | FF_MODERN, _T(""));
	edbg = NULL;

	range = ctrl.range;
	curPosVal = ctrl.curPosVal;
	curFloatVal = ctrl.curFloatVal;
	ivalid = ctrl.ivalid;
	sRegCt = vRegCt = 0;
	desc = ctrl.desc;
	ct = ctrl.expr.getVarCount(SCALAR_VAR);
	for(i = 0; i < ct; i++) {
		cp = ctrl.expr.getVarName(SCALAR_VAR, i);
		updRegCt(slot = expr.defVar(SCALAR_VAR, cp), SCALAR_VAR);
		if(slot == -1)	// variable already defined
			continue;
		if(_tcscmp(cp, _T("T")) == 0)
			timeSlots[EXPR_TICKS] = slot;
		else if(_tcscmp(cp, _T("S")) == 0)
			timeSlots[EXPR_SECS] = slot;
		else if(_tcscmp(cp, _T("F")) == 0)
			timeSlots[EXPR_FRAMES] = slot;
		else if(_tcscmp(cp, _T("NT")) == 0)
			timeSlots[EXPR_NTIME] = slot;
		else {
			dfnVar(SCALAR_VAR, cp, slot, ctrl.getVarOffset(SCALAR_VAR, j=i-4));

			if(ctrl.sVars[j].refID < 0)
				assignScalarValue(slot, ctrl.sVars[j].val);
			else
				assignController(SCALAR_VAR, slot-4, ctrl.refTab[ctrl.sVars[j].refID].client, ctrl.sVars[j].subNum);
		}
	}
	ct = ctrl.expr.getVarCount(VECTOR_VAR);
	for(i = 0; i < ct; i++) {
		cp = ctrl.expr.getVarName(VECTOR_VAR, i);
		updRegCt(slot = expr.defVar(VECTOR_VAR, cp), VECTOR_VAR);
		dfnVar(VECTOR_VAR, cp, slot, ctrl.getVarOffset(VECTOR_VAR, i));

		if(ctrl.vVars[i].refID < 0)
			assignVectorValue(slot, ctrl.vVars[i].val);
		else
			assignController(VECTOR_VAR, slot, ctrl.refTab[ctrl.vVars[i].refID].client, ctrl.vVars[i].subNum);
	}
	cp = ctrl.expr.getExprStr();
	expr.load(cp);
}

ExprControl::ExprControl(int t, BOOL loading) 
{
	blockGetNodeName = FALSE;
	type = t;
	range.Set(GetAnimStart(), GetAnimEnd());
	curPosVal = Point3(0,0,0);
	curFloatVal = 0.0f;
	ivalid.SetEmpty();
	sRegCt = vRegCt = 0;
	updRegCt(timeSlots[EXPR_TICKS] = expr.defVar(SCALAR_VAR, _T("T")), SCALAR_VAR);
	updRegCt(timeSlots[EXPR_SECS] = expr.defVar(SCALAR_VAR, _T("S")), SCALAR_VAR);
	updRegCt(timeSlots[EXPR_FRAMES] = expr.defVar(SCALAR_VAR, _T("F")), SCALAR_VAR);
	updRegCt(timeSlots[EXPR_NTIME] = expr.defVar(SCALAR_VAR, _T("NT")), SCALAR_VAR);
	switch(type = t) {
	case EXPR_POS_CONTROL_CLASS_ID:
	case EXPR_P3_CONTROL_CLASS_ID:
		expr.load(_T("[ 0, 0, 0 ]"));
		break;
	case EXPR_SCALE_CONTROL_CLASS_ID:
		expr.load(_T("[ 1, 1, 1 ]"));
		break;
	case EXPR_FLOAT_CONTROL_CLASS_ID:
		expr.load(_T("0"));
		break;
	case EXPR_ROT_CONTROL_CLASS_ID:
		expr.load(_T("{ [ 0, 0, 0 ], 0 }"));
		break;
	}
	hParams = NULL;
	hFixedFont = CreateFont(14,0,0,0,0,0,0,0,0,0,0,0, FIXED_PITCH | FF_MODERN, _T(""));
	edbg = NULL;
}

ExprControl::~ExprControl()
{
	deleteAllVars();
	DeleteObject(hFixedFont);
	if (hParams)
		DestroyWindow(hParams);
	DeleteAllRefsFromMe();
}

void ExprControl::updRegCt(int val, int type)
{
	if(type == SCALAR_VAR) {
		if(val+1 > sRegCt)
			sRegCt = val+1;
	}
	else {
		if(val+1 > vRegCt)
			vRegCt = val+1;
	}
}

BOOL ExprControl::dfnVar(int type, TCHAR *buf, int slot, int offset)
{
	int i;
	if(type == SCALAR_VAR) {
		SVar sv;
		sv.regNum = slot;
		sv.offset = offset;
		sv.refID = -1;
		sv.val = 0.0f;
		i = sVars.Append(1, &sv, 4);
		sVars[i].name = buf;
	}
	else {
		VVar vv;
//		vv.name = buf;
		vv.regNum = slot;
		vv.offset = offset;
		vv.refID = -1;
		vv.val.x =
		vv.val.y =
		vv.val.z = 0.0f;
		i = vVars.Append(1, &vv, 4);
		vVars[i].name = buf;
	}
	return TRUE;
}

void ExprControl::deleteAllVars()
{
	int i, ct;

	ct = sVars.Count();
	for(i = 0; i < ct; i++)
		delete sVars[i].name;
	sVars.SetCount(0);
	ct = vVars.Count();
	for(i = 0; i < ct; i++)
		delete vVars[i].name;
	vVars.SetCount(0);
}

TCHAR *ExprControl::getVarName(int type, int i)
{
	if(type == SCALAR_VAR) {
		if(i < sVars.Count())
			return sVars[i].name;
	}
	else {
		if(i < vVars.Count())
			return vVars[i].name;
	}
	return NULL;
}

int ExprControl::getVarOffset(int type, int i)
{
	if(type == SCALAR_VAR) {
		if(i < sVars.Count())
			return sVars[i].offset;
	}
	else {
		if(i < vVars.Count())
			return vVars[i].offset;
	}
	return 0;
}

int	ExprControl::getRegNum(int type, int i)
{
	if(type == SCALAR_VAR) {
		if(i < sVars.Count())
			return sVars[i].regNum;
	}
	else {
		if(i < vVars.Count())
			return vVars[i].regNum;
	}
	return -1;
}

float ExprControl::getScalarValue(int i)
{
	if((i < sVars.Count()) && (sVars[i].refID < 0))
		return sVars[i].val;
	return 0.0f;
}

Point3 ExprControl::getVectorValue(int i)
{
	if((i < vVars.Count()) && (vVars[i].refID < 0))
		return vVars[i].val;
	return Point3(0.0f, 0.0f, 0.0f);
}

BOOL ExprControl::assignScalarValue(int i, float val)
{
	if(i < sVars.Count()) {
		sVars[i].refID = -1;
		sVars[i].val = val;
		return TRUE;
	}
	return FALSE;
}

BOOL ExprControl::assignVectorValue(int i, Point3 &val)
{
	if(i < vVars.Count()) {
		vVars[i].refID = -1;
		vVars[i].val = val;
		return TRUE;
	}
	return FALSE;
}

class FloatFilter : public TrackViewFilter {
public:
	BOOL proc(Animatable *anim, Animatable *client,int subNum)
			{ return anim->SuperClassID() == CTRL_FLOAT_CLASS_ID; }
};

class VectorFilter : public TrackViewFilter {
public:
	BOOL proc(Animatable *anim, Animatable *client,int subNum)
			{ 
			if (anim->SuperClassID() == BASENODE_CLASS_ID) {
				INode *node = (INode*)anim;
				return !node->IsRootNode();
				}
			return anim->SuperClassID() == CTRL_POSITION_CLASS_ID ||
					 anim->SuperClassID() == CTRL_POINT3_CLASS_ID; 
			}
};

BOOL ExprControl::assignController(int type, int varIndex, ReferenceTarget *client, int subNum)
{
	if (!client) return FALSE;

	int i, ct;

	ct = refTab.Count();
	for(i = 0; i < ct; i++) {
		if(refTab[i].client == client) {
			refTab[i].refCt++;
			break;
		}
	}
	if(i >= ct) {
		VarRef vr(client);
		i = refTab.Append(1, &vr, 4);
		if(MakeRefByID(FOREVER, StdControl::NumRefs()+i, client) != REF_SUCCEED) {
			refTab.Delete(i, 1);
			TSTR s = GetString(IDS_DB_CIRCULAR_DEPENDENCY);
			MessageBox(hDlg, s, GetString(IDS_DB_CANT_ASSIGN), 
					MB_ICONEXCLAMATION | MB_SYSTEMMODAL | MB_OK);
			return FALSE;
		}
	}
	if(type == SCALAR_VAR) {
		if(varIndex >= sVars.Count()) {
			// should delete reference
			return FALSE;
		}
		sVars[varIndex].refID = i;
		sVars[varIndex].subNum = subNum;
		return TRUE;
	}
	else if(type == VECTOR_VAR) {
		if(varIndex >= vVars.Count()) {
			// should delete reference
			return FALSE;
		}
		vVars[varIndex].refID = i;
		vVars[varIndex].subNum = subNum;
		return TRUE;
	}
	return FALSE;
}

// This patch is here to convert number strings where the decimal point
// is a comma into numbers with a '.' for a decimal point.
// This is needed because the expression object only parses the '.' notation

TCHAR *UglyPatch(TCHAR *buf)
{
	TCHAR *cp = buf;
	while(*cp) {
		if( *cp == _T(','))
			*cp = _T('.');
		else if (*cp == _T(';'))
			*cp = _T(',');
		cp++;
	}
	return buf;
}

void ExprControl::Copy(Control *from)
{
	int i, j, ct, slot;
	TCHAR *cp;
	TCHAR buf[256];

	if (from->ClassID()==ClassID()) {
		ExprControl *ctrl = (ExprControl*)from;
		if(type != ctrl->type)
			goto dropOut;
		curPosVal = ctrl->curPosVal;
		curFloatVal = ctrl->curFloatVal;
		ivalid = ctrl->ivalid;
		range = ctrl->range;
		type = ctrl->type;
		desc = ctrl->desc;
//		sRegCt = vRegCt = 0;
		ct = ctrl->expr.getVarCount(SCALAR_VAR);
		for(i = 0; i < ct; i++) {
			cp = ctrl->expr.getVarName(SCALAR_VAR, i);
			updRegCt(slot = expr.defVar(SCALAR_VAR, cp), SCALAR_VAR);
			if(slot == -1)	// variable already defined
				continue;
			if(_tcscmp(cp, _T("T")) == 0)
				timeSlots[EXPR_TICKS] = slot;
			else if(_tcscmp(cp, _T("S")) == 0)
				timeSlots[EXPR_SECS] = slot;
			else if(_tcscmp(cp, _T("F")) == 0)
				timeSlots[EXPR_FRAMES] = slot;
			else if(_tcscmp(cp, _T("NT")) == 0)
				timeSlots[EXPR_NTIME] = slot;
			else {
				dfnVar(SCALAR_VAR, cp, slot, ctrl->getVarOffset(SCALAR_VAR, j=i-4));

				if(ctrl->sVars[j].refID < 0)
					assignScalarValue(slot, ctrl->sVars[j].val);
				else
					assignController(SCALAR_VAR, slot-4, ctrl->refTab[ctrl->sVars[j].refID].client, ctrl->sVars[j].subNum);
			}
		}
		ct = ctrl->expr.getVarCount(VECTOR_VAR);
		for(i = 0; i < ct; i++) {
			cp = ctrl->expr.getVarName(VECTOR_VAR, i);
			updRegCt(slot = expr.defVar(VECTOR_VAR, cp), VECTOR_VAR);
			dfnVar(VECTOR_VAR, cp, slot, ctrl->getVarOffset(VECTOR_VAR, i));

			if(ctrl->vVars[i].refID < 0)
				assignVectorValue(slot, ctrl->vVars[i].val);
			else
				assignController(VECTOR_VAR, slot, ctrl->refTab[ctrl->vVars[i].refID].client, ctrl->vVars[i].subNum);
		}
		expr.load(ctrl->expr.getExprStr());
	} 
	else {
dropOut:
		switch(type) {
		case EXPR_POS_CONTROL_CLASS_ID:
		case EXPR_P3_CONTROL_CLASS_ID:
			from->GetValue(0,&curPosVal,ivalid);
			_stprintf(buf, _T("[ %g; %g; %g ]"), curPosVal.x, curPosVal.y, curPosVal.z);
			expr.load(UglyPatch(buf));
			break;
		case EXPR_FLOAT_CONTROL_CLASS_ID:
			from->GetValue(0,&curFloatVal,ivalid);
			_stprintf(buf, _T("%g"), curFloatVal);
			expr.load(UglyPatch(buf));
			break;
		// should deal with SCALE and ROT types, but punt for now...
		}
	}
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
}


/*
class FindNodeDEP : public DependentEnumProc {
	public:		
		INode *node;		
		FindNodeDEP() {node=NULL;}
		int proc(ReferenceMaker *rmaker) {
			if (rmaker->SuperClassID()==BASENODE_CLASS_ID) {
				node = (INode*)rmaker;
				return 1;
			} else {
				return 0;
				}			
			}
	};
class FindPRSDEP : public DependentEnumProc {
	public:		
		Control *cont;
		FindPRSDEP() {cont=NULL;}
		int proc(ReferenceMaker *rmaker) {
			if (rmaker->SuperClassID()==CTRL_MATRIX3_CLASS_ID) {
				cont = (Control*)rmaker;
				return 1;
			} else {
				return 0;
				}			
			}
	};

void ExprControl::GetAbsoluteControlValue(
		Control *c,TimeValue t,Point3 *pt,Interval &iv)
	{
	FindPRSDEP dep1;
	FindNodeDEP dep2;
	c->EnumDependents(&dep1);
	if (dep1.cont) dep1.cont->EnumDependents(&dep2);
	if (dep2.node) {
		Matrix3 tm = dep2.node->GetNodeTM(t,&iv);
		*pt = tm.GetTrans();
	} else {
		c->GetValue(t, pt, iv);
		}
	}
*/

void ExprControl::GetAbsoluteControlValue(
		INode *node,TimeValue t,Point3 *pt,Interval &iv)
	{
	Matrix3 tm = node->GetNodeTM(t,&iv);
	*pt = tm.GetTrans();
	}


static BOOL OKPControl(SClass_ID cid) {
	if (cid==CTRL_POINT3_CLASS_ID || cid==CTRL_POS_CLASS_ID || CTRL_POSITION_CLASS_ID )
		return 1;
	return 0;
	}

void ExprControl::GetValueLocalTime(TimeValue t, void *val, Interval &valid, GetSetMethod method)
{
	int i;
	float *sregs = new float[sRegCt];
	Point3 *vregs = new Point3[vRegCt];
	ivalid.SetInstant(t);
	valid &= ivalid;

	// Limit to in range
	if (t<range.Start()) t = range.Start();
	if (t>range.End()) t = range.End();	
	
	switch(type) {
	case EXPR_POS_CONTROL_CLASS_ID:
	case EXPR_P3_CONTROL_CLASS_ID:
	case EXPR_SCALE_CONTROL_CLASS_ID:
		if(expr.getExprType() == VECTOR_EXPR) {
			sregs[timeSlots[EXPR_TICKS]] = (float)t;
			sregs[timeSlots[EXPR_SECS]] = (float)t/4800.0f;
			sregs[timeSlots[EXPR_FRAMES]] = (float)t/GetTicksPerFrame();
			sregs[timeSlots[EXPR_NTIME]] = (float)(t-range.Start()) / (float)(range.End()-range.Start());
			for(i = 0; i < sVars.Count(); i++) {
				if(sVars[i].refID < 0)
					sregs[sVars[i].regNum] = sVars[i].val;
				else {
					Control *c;
					Interval iv;
					c = (Control *)refTab[sVars[i].refID].client->SubAnim(sVars[i].subNum);
					if (c&&(c->SuperClassID()==CTRL_FLOAT_CLASS_ID))
						c->GetValue(t+sVars[i].offset, &sregs[sVars[i].regNum], iv);
				}
			}
			for(i = 0; i < vVars.Count(); i++) {
				if(vVars[i].refID < 0 || !refTab[vVars[i].refID].client)
					vregs[vVars[i].regNum] = vVars[i].val;
				else {
					Control *c;
					Interval iv;
/*
<<<<<<< SourceSafe version
					c = (Control *)refTab[vVars[i].refID].client->SubAnim(vVars[i].subNum);
					c->GetValue(t+vVars[i].offset, &vregs[vVars[i].regNum], iv);
======= 
*/
					// Rolf: check vVars[i].absPos						
					if (vVars[i].subNum<0) {
						GetAbsoluteControlValue(
							(INode*)refTab[vVars[i].refID].client,t+vVars[i].offset,&vregs[vVars[i].regNum], iv);
					} else {
						c = (Control *)refTab[vVars[i].refID].client->SubAnim(vVars[i].subNum);										 
						if (c&&OKPControl(c->SuperClassID()))
							c->GetValue(t+vVars[i].offset, &vregs[vVars[i].regNum], iv);
					}
//>>>>>>> Local version
				}
			}
			if(expr.eval((float *)&curPosVal, sRegCt, sregs, vRegCt, vregs))
				curPosVal = type == EXPR_SCALE_CONTROL_CLASS_ID ? Point3(1,1,1) : Point3(0,0,0);
		}
		else
			curPosVal = type == EXPR_SCALE_CONTROL_CLASS_ID ? Point3(1,1,1) : Point3(0,0,0);
		if (method==CTRL_RELATIVE) {
			if(type == EXPR_POS_CONTROL_CLASS_ID) {
		  		Matrix3 *mat = (Matrix3*)val;
//				mat->SetTrans(mat->GetTrans()+curPosVal);
				mat->PreTranslate(curPosVal);  // DS 9/23/96
			}
			else if(type == EXPR_SCALE_CONTROL_CLASS_ID) {
		  		Matrix3 *mat = (Matrix3*)val;
				mat->Scale(curPosVal);
			}
			else {
		  		Point3 *p = (Point3 *)val;
				*p += curPosVal;
			}
		} 
		else {
			if(type == EXPR_SCALE_CONTROL_CLASS_ID)
				*((ScaleValue *)val) = ScaleValue(curPosVal);
			else
				*((Point3*)val) = curPosVal;
		}
		break;
	case EXPR_FLOAT_CONTROL_CLASS_ID:
		if(expr.getExprType() == SCALAR_EXPR) {
			sregs[timeSlots[EXPR_TICKS]] = (float)t;
			sregs[timeSlots[EXPR_SECS]] = (float)t/4800.0f;
			sregs[timeSlots[EXPR_FRAMES]] = (float)t/GetTicksPerFrame();
			sregs[timeSlots[EXPR_NTIME]] = (float)(t-range.Start()) / (float)(range.End()-range.Start());
			for(i = 0; i < sVars.Count(); i++) {
				if(sVars[i].refID < 0)
					sregs[sVars[i].regNum] = sVars[i].val;
				else {
					Control *c;
					Interval iv;
					c = (Control *)refTab[sVars[i].refID].client->SubAnim(sVars[i].subNum);
					// DS 2/8/99 Added type checking to avoid crashes due to sub anim's moving around
					// when param block 2 code is added.
					if(c&&(c->SuperClassID()==CTRL_FLOAT_CLASS_ID)) {
						c->GetValue(t+sVars[i].offset, &sregs[sVars[i].regNum], iv);
						}
					else
						sregs[sVars[i].regNum] = sVars[i].val;
				}
			}
			for(i = 0; i < vVars.Count(); i++) {
				if(vVars[i].refID < 0 || !refTab[vVars[i].refID].client)
					vregs[vVars[i].regNum] = vVars[i].val;
				else {
					Control *c;
					Interval iv;
/*
<<<<<<< SourceSafe version
					c = (Control *)refTab[vVars[i].refID].client->SubAnim(vVars[i].subNum);
					c->GetValue(t+vVars[i].offset, &vregs[vVars[i].regNum], iv);
======= 
*/
					if (vVars[i].subNum<0) {
						GetAbsoluteControlValue(
							(INode*)refTab[vVars[i].refID].client,t+vVars[i].offset,&vregs[vVars[i].regNum], iv);
					} else {
						c = (Control *)refTab[vVars[i].refID].client->SubAnim(vVars[i].subNum);										 
						// DS 2/8/99 Added type checking to avoid crashes due to sub anim's moving around
						// when param block 2 code is added.
						if(c&&OKPControl(c->SuperClassID()))
							c->GetValue(t+vVars[i].offset, &vregs[vVars[i].regNum], iv);
					}
//>>>>>>> Local version
				}
			}
			if(expr.eval((float *)&curFloatVal, sRegCt, sregs, vRegCt, vregs))
				curFloatVal = 0.0f;
		}
		else
			curFloatVal = 0.0f;
		if (method==CTRL_RELATIVE) {
			*((float *)val) += curFloatVal;
		} 
		else {
			*((float *)val) = curFloatVal;
		}
	    break;
	}
	delete [] sregs;
	delete [] vregs;
}

void *ExprControl::CreateTempValue()
{
	switch(type) {
	case EXPR_POS_CONTROL_CLASS_ID:
	case EXPR_P3_CONTROL_CLASS_ID:
		return new Point3;
	case EXPR_SCALE_CONTROL_CLASS_ID:
		return new ScaleValue;
	case EXPR_FLOAT_CONTROL_CLASS_ID:
		return new float;
	}
	return NULL;
}

void ExprControl::DeleteTempValue(void *val)
{
	switch(type) {
	case EXPR_POS_CONTROL_CLASS_ID:
	case EXPR_P3_CONTROL_CLASS_ID:
		delete (Point3 *)val;
		break;
	case EXPR_SCALE_CONTROL_CLASS_ID:
		delete (ScaleValue *)val;
		break;
	case EXPR_FLOAT_CONTROL_CLASS_ID:
		delete (float *)val;
		break;
	}
}

void ExprControl::ApplyValue(void *val, void *delta)
{
	Matrix3 *mat;
	switch(type) {
	case EXPR_POS_CONTROL_CLASS_ID:
  		mat = (Matrix3*)val;
//		mat->SetTrans(mat->GetTrans()+*((Point3 *)delta));		
		mat->PreTranslate(*((Point3 *)delta));  //DS 9/23/96
		break;
	case EXPR_P3_CONTROL_CLASS_ID:
		*((Point3 *)val) += *((Point3 *)delta);
		break;
	case EXPR_FLOAT_CONTROL_CLASS_ID:
		*((float *)val) += *((float *)delta);
		break;
	case EXPR_SCALE_CONTROL_CLASS_ID:
		Matrix3 *mat = (Matrix3*)val;
		ScaleValue *s = (ScaleValue*)delta;
		ApplyScaling(*mat,*s);
		break;
	}
}

void ExprControl::MultiplyValue(void *val, float m)
{
	switch(type) {
	case EXPR_POS_CONTROL_CLASS_ID:
	case EXPR_P3_CONTROL_CLASS_ID:
		*((Point3 *)val) *= m;
		break;
	case EXPR_SCALE_CONTROL_CLASS_ID:
		*((ScaleValue *)val) *= m;
		break;
	case EXPR_FLOAT_CONTROL_CLASS_ID:
		*((float *)val) *= m;
		break;
	}
}

void ExprControl::Extrapolate(Interval range,TimeValue t,void *val,Interval &valid,int etype)
{
	if(type == EXPR_FLOAT_CONTROL_CLASS_ID) {
		float fval0, fval1, fval2, res;
		switch (etype) {
		case ORT_LINEAR:			
			if (t<range.Start()) {
				GetValueLocalTime(range.Start(),&fval0,valid);
				GetValueLocalTime(range.Start()+1,&fval1,valid);
				res = LinearExtrapolate(range.Start(),t,fval0,fval1,fval0);				
			} 
			else {
				GetValueLocalTime(range.End()-1,&fval0,valid);
				GetValueLocalTime(range.End(),&fval1,valid);
				res = LinearExtrapolate(range.End(),t,fval0,fval1,fval1);
			}
			break;

		case ORT_IDENTITY:
			if (t<range.Start()) {
				GetValueLocalTime(range.Start(),&fval0,valid);
				res = IdentityExtrapolate(range.Start(),t,fval0);
			} 
			else {
				GetValueLocalTime(range.End(),&fval0,valid);
				res = IdentityExtrapolate(range.End(),t,fval0);
			}
			break;

		case ORT_RELATIVE_REPEAT:
			GetValueLocalTime(range.Start(),&fval0,valid);
			GetValueLocalTime(range.End(),&fval1,valid);
			GetValueLocalTime(CycleTime(range,t),&fval2,valid);
			res = RepeatExtrapolate(range,t,fval0,fval1,fval2);			
			break;
		}
		valid.Set(t,t);
		*((float*)val) = res;
	}
	else if(type == EXPR_SCALE_CONTROL_CLASS_ID) {
		ScaleValue val0, val1, val2, res;
		switch (etype) {
		case ORT_LINEAR:			
			if (t<range.Start()) {
				GetValueLocalTime(range.Start(),&val0,valid);
				GetValueLocalTime(range.Start()+1,&val1,valid);
				res = LinearExtrapolate(range.Start(),t,val0,val1,val0);				
			} 
			else {
				GetValueLocalTime(range.End()-1,&val0,valid);
				GetValueLocalTime(range.End(),&val1,valid);
				res = LinearExtrapolate(range.End(),t,val0,val1,val1);
			}
			break;

		case ORT_IDENTITY:
			if (t<range.Start()) {
				GetValueLocalTime(range.Start(),&val0,valid);
				res = IdentityExtrapolate(range.Start(),t,val0);
			} 
			else {
				GetValueLocalTime(range.End(),&val0,valid);
				res = IdentityExtrapolate(range.End(),t,val0);
			}
			break;

		case ORT_RELATIVE_REPEAT:
			GetValueLocalTime(range.Start(),&val0,valid);
			GetValueLocalTime(range.End(),&val1,valid);
			GetValueLocalTime(CycleTime(range,t),&val2,valid);
			res = RepeatExtrapolate(range,t,val0,val1,val2);			
			break;
		}
		valid.Set(t,t);
		*((ScaleValue *)val) = res;
	}
	else {
		Point3 val0, val1, val2, res;
		switch (etype) {
		case ORT_LINEAR:			
			if (t<range.Start()) {
				GetValueLocalTime(range.Start(),&val0,valid);
				GetValueLocalTime(range.Start()+1,&val1,valid);
				res = LinearExtrapolate(range.Start(),t,val0,val1,val0);				
			} 
			else {
				GetValueLocalTime(range.End()-1,&val0,valid);
				GetValueLocalTime(range.End(),&val1,valid);
				res = LinearExtrapolate(range.End(),t,val0,val1,val1);
			}
			break;

		case ORT_IDENTITY:
			if (t<range.Start()) {
				GetValueLocalTime(range.Start(),&val0,valid);
				res = IdentityExtrapolate(range.Start(),t,val0);
			} 
			else {
				GetValueLocalTime(range.End(),&val0,valid);
				res = IdentityExtrapolate(range.End(),t,val0);
			}
			break;

		case ORT_RELATIVE_REPEAT:
			GetValueLocalTime(range.Start(),&val0,valid);
			GetValueLocalTime(range.End(),&val1,valid);
			GetValueLocalTime(CycleTime(range,t),&val2,valid);
			res = RepeatExtrapolate(range,t,val0,val1,val2);			
			break;
		}
		valid.Set(t,t);
		*((Point3 *)val) = res;
	}
}

ReferenceTarget* ExprControl::GetReference(int i) 
{
	int num;

	if(i < (num = StdControl::NumRefs()))
		return StdControl::GetReference(i);
	return (ReferenceTarget*)refTab[i-num].client;
}

void ExprControl::SetReference(int i, RefTargetHandle rtarg)
{
	int num;

	if(i < (num = StdControl::NumRefs()))
		StdControl::SetReference(i, rtarg);
	else
		refTab[i-num].client = rtarg;
}


// RB: When the last reference to an expression controller is
// deleted its parameter dialog needs to be closed.
void ExprControl::RefDeleted()
	{
	if (hParams) {
		int c=0;
		RefListItem  *ptr = GetRefList().first;
		while (ptr) {
			if (ptr->maker!=NULL) {
				if (ptr->maker->SuperClassID()) c++;
				}
			ptr = ptr->next;
			}	
		if (!c) DestroyWindow(hParams);	
		}
	}


class ExprDelTargetRestore : public RestoreObj {	
public:
	ExprControl *ec;
	SVarTab		sVarsUndo;
	VVarTab		vVarsUndo;
	VarRefTab	refTabUndo;
	SVarTab		sVarsRedo;
	VVarTab		vVarsRedo;
	VarRefTab	refTabRedo;
	ExprDelTargetRestore(ExprControl *ec) 
	{ 
		this->ec=ec;

		sVarsUndo.SetCount(ec->sVars.Count());
		for(int i = 0; i < ec->sVars.Count(); i++) {
			sVarsUndo[i].refID = ec->sVars[i].refID;
			sVarsUndo[i].subNum = ec->sVars[i].subNum;
		}

		vVarsUndo.SetCount(ec->vVars.Count());
		for(i = 0; i < ec->vVars.Count(); i++) {
			vVarsUndo[i].refID = ec->vVars[i].refID;
			vVarsUndo[i].subNum = ec->vVars[i].subNum;
		}

		refTabUndo.SetCount(ec->refTab.Count());
		for (i = 0; i < ec->refTab.Count(); i++)
			refTabUndo[i] = ec->refTab[i]; 
	}
	void Restore(int isUndo) 
	{
		// save the undo data in the redo tables
		sVarsRedo.SetCount(sVarsUndo.Count());
		for(int i = 0; i < sVarsUndo.Count(); i++) {
			sVarsRedo[i].refID = sVarsUndo[i].refID;
			sVarsRedo[i].subNum = sVarsUndo[i].subNum;
		}

		vVarsRedo.SetCount(vVarsUndo.Count());
		for(i = 0; i < vVarsUndo.Count(); i++) {
			vVarsRedo[i].refID = vVarsUndo[i].refID;
			vVarsRedo[i].subNum = vVarsUndo[i].subNum;
		}

		refTabRedo.SetCount(refTabUndo.Count());
		for (i = 0; i < refTabUndo.Count(); i++)
			refTabRedo[i] = refTabUndo[i]; 

		// put the undo data back into the controller
		for(i = 0; i < ec->sVars.Count(); i++) {
			ec->sVars[i].refID = sVarsUndo[i].refID;
			ec->sVars[i].subNum = sVarsUndo[i].subNum;
		}

		for(i = 0; i < ec->vVars.Count(); i++) {
			ec->vVars[i].refID = vVarsUndo[i].refID;
			ec->vVars[i].subNum = vVarsUndo[i].subNum;
		}

		for (i = 0; i < ec->refTab.Count(); i++)
			ec->refTab[i] = refTabUndo[i]; 

		ec->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	}
	void Redo()
	{
		// put the redo data back into the controller
		for(int i = 0; i < ec->sVars.Count(); i++) {
			ec->sVars[i].refID = sVarsRedo[i].refID;
			ec->sVars[i].subNum = sVarsRedo[i].subNum;
		}

		for(i = 0; i < ec->vVars.Count(); i++) {
			ec->vVars[i].refID = vVarsRedo[i].refID;
			ec->vVars[i].subNum = vVarsRedo[i].subNum;
		}

		for (i = 0; i < ec->refTab.Count(); i++)
			ec->refTab[i] = refTabRedo[i]; 

		ec->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	}
	void EndHold() { }
};

RefResult ExprControl::NotifyRefChanged(
		Interval iv, 
		RefTargetHandle hTarg, 
		PartID& partID, 
		RefMessage msg) 
{
	int i;

	switch (msg) {
	case REFMSG_GET_NODE_NAME:
		// RB 3/23/99: See comment at imp of getNodeName().
		if (blockGetNodeName) return REF_STOP;
		break;

	case REFMSG_CHANGE:
		ivalid.SetEmpty();
		if(edbg)
			InvalidateRect(edbg->hWnd, NULL, FALSE);	// this is to update the debug window, since
														// calling Update directly in a NotifyRefChanged
														// is a no-no    DB 2/23/99
			//edbg->Update();
		break;

// DS: 5-21-97 -- removed the REFMSG_REF_DELETED. This would cause problems
// when multiple Expr controls referenced the same thing.  When one of the expr
// controls got deleted this message was sent to all the others, setting their
// refs to NULL even though the target still had backptr to them. This would cause
// crashes later.
//	case REFMSG_REF_DELETED:		// this is for when visibility tracks are deleted

	case REFMSG_TARGET_DELETED: {	// this is for when referenced nodes are deleted
		if (theHold.Holding())
			theHold.Put(new ExprDelTargetRestore(this));
		// get rid of any scalar or vector variable references
		for(i = 0; i < sVars.Count(); i++)
			if(sVars[i].refID >= 0 && refTab[sVars[i].refID].client == hTarg)
				sVars[i].refID = -1;
		for(i = 0; i < vVars.Count(); i++)
			if(vVars[i].refID >= 0 && refTab[vVars[i].refID].client == hTarg)
				vVars[i].refID = -1;
		// then get rid of the reference itself
		for (i = 0; i < refTab.Count(); i++)
			if (refTab[i].client == hTarg) 
				refTab[i].client = NULL;
		break;	
		}
	}
	return REF_SUCCEED;
}


class ExprControlRestore : public RestoreObj {	
public:
	ExprControl *ec;
	Interval undo, redo;
	ExprControlRestore(ExprControl *ec) { this->ec=ec; undo=ec->range; }
	void Restore(int isUndo) 
	{
		redo = ec->range;
		ec->range = undo;
		ec->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	}
	void Redo() 
	{
		ec->range = redo;
		ec->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	}
	void EndHold() { ec->ClearAFlag(A_HELD); }
};

void ExprControl::Hold()
{
	if (theHold.Holding() && !TestAFlag(A_HELD)) {
		theHold.Put(new ExprControlRestore(this));
		SetAFlag(A_HELD);
	}
}

void ExprControl::MapKeys( TimeMap *map, DWORD flags ) 
{
	Hold();
	range.Set(map->map(range.Start()), map->map(range.End())); 
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
}

void ExprControl::EditTimeRange(Interval range,DWORD flags)
{
	if(flags == EDITRANGE_LINKTOKEYS)
		return;
	this->range = range;
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
}

void ExprControl::BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev )
{	
}

void ExprControl::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next )
{
}

// RB 3/23/99: To solve 75139 (the problem where a node name is found for variables that 
// are not associated with nodes such as globabl tracks) we need to block the propogation
// of this message through our reference to the client of the variable we're referencing.
// In the expression controller's imp of NotifyRefChanged() we're going to block the get
// node name message if the blockGetNodeName variable is TRUE.
void ExprControl::getNodeName(ReferenceTarget *client, TSTR &name)
	{
	blockGetNodeName = TRUE;
	if (client) client->NotifyDependents(FOREVER,(PartID)&name,REFMSG_GET_NODE_NAME);
	blockGetNodeName = FALSE;
	}

static void setupSpin(HWND hDlg, int spinID, int editID, float val)
{
	ISpinnerControl *spin;

	spin = GetISpinner(GetDlgItem(hDlg, spinID));
	spin->SetLimits( (float)-9e30, (float)9e30, FALSE );
	spin->SetScale( 1.0f );
	spin->LinkToEdit( GetDlgItem(hDlg, editID), EDITTYPE_FLOAT );
	spin->SetValue( val, FALSE );
	ReleaseISpinner( spin );
}

static float getSpinVal(HWND hDlg, int spinID)
{
	ISpinnerControl *spin = GetISpinner(GetDlgItem(hDlg, spinID));
	float res = spin->GetFVal();
	ReleaseISpinner(spin);
	return res;
}

static BOOL CALLBACK ScalarAsgnDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
	ExprControl *ec = (ExprControl *)GetWindowLong(hDlg, GWL_USERDATA);

	switch (msg) {
	case WM_INITDIALOG:
		SetWindowLong(hDlg, GWL_USERDATA, lParam);
		ec = (ExprControl *)lParam;
		SetWindowText(hDlg, ec->getVarName(SCALAR_VAR, ec->curIndex));
		setupSpin(hDlg, IDC_EXPR_CONST_SPIN, IDC_EXPR_CONST, ec->getScalarValue(ec->curIndex));
		break;

	case WM_COMMAND:
		switch (LOWORD(wParam)) {
		case IDOK:
            goto done;
		case IDCANCEL:
			EndDialog(hDlg, FALSE);
			return FALSE;
		}
		break;

	case WM_CLOSE:
done:
		ec->assignScalarValue(ec->curIndex, getSpinVal(hDlg, IDC_EXPR_CONST_SPIN));
		EndDialog(hDlg, TRUE);
		return FALSE;
	}
	return FALSE;
}

static BOOL CALLBACK VectorAsgnDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
	Point3 pt;
	ExprControl *ec = (ExprControl *)GetWindowLong(hDlg, GWL_USERDATA);

	switch (msg) {
	case WM_INITDIALOG:
		SetWindowLong(hDlg, GWL_USERDATA, lParam);
		ec = (ExprControl *)lParam;
		SetWindowText(hDlg, ec->getVarName(VECTOR_VAR, ec->curIndex));
		pt = ec->getVectorValue(ec->curIndex);
		setupSpin(hDlg, IDC_VEC_X_SPIN, IDC_VEC_X, pt.x);
		setupSpin(hDlg, IDC_VEC_Y_SPIN, IDC_VEC_Y, pt.y);
		setupSpin(hDlg, IDC_VEC_Z_SPIN, IDC_VEC_Z, pt.z);
		break;

	case WM_COMMAND:
		switch (LOWORD(wParam)) {
		case IDOK:
            goto done;
		case IDCANCEL:
			EndDialog(hDlg, FALSE);
			return FALSE;
		}
		break;

	case WM_CLOSE:
done:
		pt.x = getSpinVal(hDlg, IDC_VEC_X_SPIN);
		pt.y = getSpinVal(hDlg, IDC_VEC_Y_SPIN);
		pt.z = getSpinVal(hDlg, IDC_VEC_Z_SPIN);
		ec->assignVectorValue(ec->curIndex, pt);
		EndDialog(hDlg, TRUE);
		return FALSE;
	}
	return FALSE;
}

static int isEmpty(TCHAR *s)
{
	int c;
	while(c = *s) {
		if(c != ' ' && c != '\t' && c != '\n' && c != '\r')
			return FALSE;
		s++;
	}
	return TRUE;
}

static int updateExpr(HWND hDlg, ExprControl *ec)
{
	TCHAR buf[4096];
	int exprType;
	GetDlgItemText(hDlg, IDC_EXPR_EDIT, buf, 4096);
	if(ec->expr.load(buf)) {
		if(isEmpty(buf)) {
			switch(ec->type) {
			case EXPR_POS_CONTROL_CLASS_ID:
			case EXPR_P3_CONTROL_CLASS_ID:
				_tcscpy(buf,_T("[ 0, 0, 0 ]"));
				break;
			case EXPR_SCALE_CONTROL_CLASS_ID:
				_tcscpy(buf, _T("[ 1, 1, 1 ]"));
				break;
			case EXPR_FLOAT_CONTROL_CLASS_ID:
				_tcscpy(buf, _T("0"));
				break;
			case EXPR_ROT_CONTROL_CLASS_ID:
				_tcscpy(buf, _T("{ [ 0, 0, 0 ], 0 }"));
				break;
			}
			SetDlgItemText(hDlg, IDC_EXPR_EDIT, buf);
			ec->expr.load(buf);
		}
		else {
			MessageBox(hDlg, ec->expr.getProgressStr(), GetString(IDS_DB_EXPR_PARSE_ERROR), 
					MB_ICONEXCLAMATION | MB_APPLMODAL | MB_OK);
			return FALSE;
		}
	}
	exprType = ec->expr.getExprType();

	switch(ec->type) {
	case EXPR_SCALE_CONTROL_CLASS_ID:
	case EXPR_POS_CONTROL_CLASS_ID:
	case EXPR_P3_CONTROL_CLASS_ID:
		if(exprType != VECTOR_EXPR) {
			TSTR s = GetString(IDS_DB_NEED_VECTOR);
			MessageBox(hDlg, s, GetString(IDS_DB_EXPR_PARSE_ERROR), 
					MB_ICONEXCLAMATION | MB_APPLMODAL | MB_OK);
			return FALSE;
		}
		break;
	case EXPR_FLOAT_CONTROL_CLASS_ID:
		if(exprType != SCALAR_EXPR) {
			TSTR s = GetString(IDS_DB_NEED_SCALAR);
			MessageBox(hDlg, s, GetString(IDS_DB_EXPR_PARSE_ERROR), 
					MB_ICONEXCLAMATION | MB_APPLMODAL | MB_OK);
			return FALSE;
		}
		break;
	}

	ec->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	ec->ip->RedrawViews(ec->ip->GetTime());
	return TRUE;
}

static void updateVarList(HWND hDlg, ExprControl *ec)
{
	int i, ct;

	ct = ec->getVarCount(SCALAR_VAR);
	SendDlgItemMessage(hDlg, IDC_SCALAR_LIST, LB_RESETCONTENT, 0, 0);
	for(i = 0; i < ct; i++)
		SendDlgItemMessage(hDlg, IDC_SCALAR_LIST, LB_ADDSTRING, 0, (LPARAM)ec->getVarName(SCALAR_VAR, i));
	
	ct = ec->getVarCount(VECTOR_VAR);
	SendDlgItemMessage(hDlg, IDC_VECTOR_LIST, LB_RESETCONTENT, 0, 0);
	for(i = 0; i < ct; i++)
		SendDlgItemMessage(hDlg, IDC_VECTOR_LIST, LB_ADDSTRING, 0, (LPARAM)ec->getVarName(VECTOR_VAR, i));
}

#define XPR	_T(".xpr")

static void FixExprFileExt(OPENFILENAME &ofn) 
{
	int l = _tcslen(ofn.lpstrFile);
	int e = _tcslen(XPR);
	if (e>l || _tcsicmp(ofn.lpstrFile+l-e, XPR))
		_tcscat(ofn.lpstrFile,XPR);	
}

static BOOL BrowseForExprFilename(TCHAR *name, TCHAR *dir, int save) 
{
	int tried = 0;
	FilterList filterList;
	HWND hWnd = GetActiveWindow();
	static int filterIndex = 1;
    OPENFILENAME	ofn;
    TCHAR			fname[256];

	_tcscpy(fname, name);

	filterList.Append( GetString(IDS_DB_XPR_FILES) );
	filterList.Append( _T("*.xpr"));

    memset(&ofn, 0, sizeof(OPENFILENAME));

    ofn.lStructSize      = sizeof(OPENFILENAME);
    ofn.hwndOwner        = hWnd;
	ofn.hInstance        = (HINSTANCE)GetWindowLong(hWnd, GWL_HINSTANCE);

	ofn.nFilterIndex = filterIndex;
    ofn.lpstrFilter  = filterList;

    ofn.lpstrTitle   = GetString(save ? IDS_DB_SAVE_EXPR : IDS_DB_LOAD_EXPR);
    ofn.lpstrFile    = fname;
    ofn.nMaxFile     = sizeof(fname) / sizeof(TCHAR);      
	
	if(dir && dir[0])
	   	ofn.lpstrInitialDir = dir;
	else
	   	ofn.lpstrInitialDir = _T("");

	ofn.Flags = OFN_HIDEREADONLY | (save ? OFN_OVERWRITEPROMPT : (OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST));

	if(save) {
		if(!GetSaveFileName(&ofn))
			return FALSE;
	}
	else {
		if(!GetOpenFileName(&ofn))
			return FALSE;
	}
	FixExprFileExt(ofn); // add ".xpr" if absent
	if(dir) {
		_tcsncpy(dir, ofn.lpstrFile, ofn.nFileOffset-1);
		dir[ofn.nFileOffset-1] = _T('\0');
	}
	_tcscpy(name, ofn.lpstrFile);
	return TRUE;
}

static TCHAR exprDir[512];

static void SaveExpression(HWND hDlg, ExprControl *ec)
{
	TCHAR buf[4096];
	int i, ct;
	FILE *fp;

	if(!exprDir[0])
		_tcscpy(exprDir, ec->ip->GetDir(APP_EXPRESSION_DIR));
	buf[0] = _T('\0');
	if(BrowseForExprFilename(buf, exprDir, TRUE))	{
		if((fp = _tfopen(buf, _T("w"))) == NULL)
			return;
		GetDlgItemText(hDlg, IDC_EXPR_EDIT, buf, 4096);
		_ftprintf(fp, _T("%s\n"), buf);
		GetDlgItemText(hDlg, IDC_DESCRIPTION, buf, 4096);
		if(buf[0]) {
			TCHAR line[1024];
			TCHAR *cp = buf;
			int i;
			for(i = 0; *cp; i++, cp++) {
				line[i] = *cp;
				if(*cp == _T('\r')) {
					line[i] = 0;
					_ftprintf(fp, _T("d: %s\n"), line);
					line[0] = 0;
					cp++;	// skip over linefeed
					i = -1;	// reset i
				}
			}
			if(line[0]) {
				line[i] = 0;
				_ftprintf(fp, _T("d: %s\n"), line);
			}
		}
		ct = ec->getVarCount(SCALAR_VAR);
		for(i = 0; i < ct; i++)
			_ftprintf(fp, _T("s: %s:%d\n"), ec->getVarName(SCALAR_VAR, i), ec->sVars[i].offset);
		ct = ec->getVarCount(VECTOR_VAR);
		for(i = 0; i < ct; i++)
			_ftprintf(fp, _T("v: %s:%d %d\n"), ec->getVarName(VECTOR_VAR, i), ec->vVars[i].offset);
		fclose(fp);
	}
}

static void LoadExpression(HWND hDlg, ExprControl *ec)
{
	TCHAR buf[4096];
	TCHAR line[1024];
	TCHAR desc[4096];
	int slot, i, ct;
	int type;
	int offset;
	TCHAR *cp;
	FILE *fp;

	if(!exprDir[0])
		_tcscpy(exprDir, ec->ip->GetDir(APP_EXPRESSION_DIR));
	buf[0] = _T('\0');
	if(BrowseForExprFilename(buf, exprDir, FALSE))	{
		if((fp = _tfopen(buf, _T("r"))) == NULL)
			return;
		desc[0] = _T('\0');
		SetDlgItemText(hDlg, IDC_DESCRIPTION, _T(""));		// empty-out description
		ct = ec->sVars.Count();								// empty-out vars
		for(i = 0; i < ct; i++) {	// leave pre-defined scalars
			ec->expr.deleteVar(ec->sVars[0].name);
			delete ec->sVars[0].name;
			ec->sVars.Delete(0, 1);
		}
		ct = ec->vVars.Count();
		for(i = 0; i < ct; i++) {
			ec->expr.deleteVar(ec->vVars[0].name);
			delete ec->vVars[0].name;
			ec->vVars.Delete(0, 1);
		}
		buf[0] = _T('\0');
		while(_fgetts(line, 1024, fp) && (line[1] != _T(':')))
			_tcscat(buf, line);
		if(buf[_tcslen(buf) - 1] == _T('\n'))
			buf[_tcslen(buf) - 1] = _T('\0');
		SetDlgItemText(hDlg, IDC_EXPR_EDIT, buf);
		if(line[1] == _T(':')) {
			do {
				if(line[_tcslen(line) - 1] == _T('\n'))
					line[_tcslen(line) - 1] = _T('\0');
				switch(line[0]) {
				case _T('d'):
					if(desc[0])
						_tcscat(desc, _T("\r\n"));
					_tcscat(desc, line+3);
					break;
				case _T('s'):
				case _T('v'):
					type = line[0] == _T('s') ? SCALAR_VAR : VECTOR_VAR;
					offset = 0;
					cp = line+3;
					while(cp[offset] != _T('\n') && cp[offset] != ':')
						offset++;
					cp[offset++] = _T('\0');
					ec->updRegCt(slot = ec->expr.defVar(type, cp), type);
					if(slot >= 0)
						ec->dfnVar(type, cp, slot, _ttoi(cp+offset));
					break;
				}
			} while(_fgetts(line, 1024, fp));
		}
		SetDlgItemText(hDlg, IDC_DESCRIPTION, desc);
		updateVarList(hDlg, ec);
		fclose(fp);
	}
}


BOOL invalidName(TCHAR *buf)
{
	if(buf[0] >= '0' && buf[0] <= '9')
		return TRUE;
	TCHAR *cp = buf;
	while(*cp) {
		if(!_istalnum(*cp))
			return TRUE;
		cp++;
	}
	return FALSE;
}

static int fnListIDs[] = {
	IDS_DB_FN_SIN,
	IDS_DB_FN_NOISE,
	IDS_DB_FN_IF,
	IDS_DB_FN_VIF,
	IDS_DB_FN_MIN,
	IDS_DB_FN_MAX,
	IDS_DB_FN_POW,
	IDS_DB_FN_MOD,
	IDS_DB_FN_DEGTORAD,
	IDS_DB_FN_RADTODEG,
	IDS_DB_FN_COS,
	IDS_DB_FN_TAN,
	IDS_DB_FN_ASIN,
	IDS_DB_FN_ACOS,
	IDS_DB_FN_ATAN,
	IDS_DB_FN_SINH,
	IDS_DB_FN_COSH,
	IDS_DB_FN_TANH,
	IDS_DB_FN_LN,
	IDS_DB_FN_LOG,
	IDS_DB_FN_EXP,
	IDS_DB_FN_SQRT,
	IDS_DB_FN_ABS,
	IDS_DB_FN_CEIL,
	IDS_DB_FN_FLOOR,
	IDS_DB_FN_COMP,
	IDS_DB_FN_UNIT,
	IDS_DB_FN_LENGTH,
	IDS_DB_FN_PI,
	IDS_DB_FN_E,
	IDS_DB_FN_TPS
};

BOOL CALLBACK functionListProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	int i = 57;
    switch (message)  {
    case WM_INITDIALOG:
		CenterWindow(hDlg, GetWindow(hDlg, GW_OWNER));
		SendDlgItemMessage(hDlg, IDC_FUNC_LIST, LB_RESETCONTENT, 0, 0L);
		SendDlgItemMessage(hDlg, IDC_FUNC_LIST, LB_SETTABSTOPS, 1, (LPARAM)&i);
		for(i = 0; i < sizeof(fnListIDs) / sizeof(int); i++)
			SendDlgItemMessage(hDlg, IDC_FUNC_LIST, LB_ADDSTRING, 0, (LPARAM)GetString(fnListIDs[i]));
		break;

	case WM_COMMAND:
		switch(LOWORD(wParam)) {
		case IDOK:
			goto done;
		case IDCANCEL:
			EndDialog(hDlg, FALSE);
		default:
			return FALSE;
		}
		break;
		
	case WM_CLOSE:
done:
		EndDialog(hDlg, TRUE);
		break;
    }
    return FALSE;
}


static BOOL CALLBACK ExprParamsWndProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
	int type, slot, i, ct;
	Point3 pt;
	TCHAR buf[4096], buf2[100];
	TrackViewPick res;
	ExprControl *ec = (ExprControl *)GetWindowLong(hDlg, GWL_USERDATA);
	ISpinnerControl *spin;

	switch (msg) {
	case WM_INITDIALOG:
		SetWindowLong(hDlg, GWL_USERDATA, lParam);
		ec = (ExprControl *)lParam;
		if (ec->winX!=-1 && ec->winY!=-1)
			SetWindowPos(hDlg,NULL,ec->winX, ec->winY, 0, 0, SWP_NOSIZE|SWP_NOZORDER);
		ec->hDlg = hDlg;
		spin = GetISpinner(GetDlgItem(hDlg, IDC_OFFSET_SPIN));
		spin->SetLimits( -1000000, 1000000, FALSE );
		spin->SetScale( 1.0f );
		spin->LinkToEdit( GetDlgItem(hDlg, IDC_OFFSET), EDITTYPE_INT );
		spin->SetValue( 0, FALSE );
		ReleaseISpinner( spin );
		SendDlgItemMessage(hDlg, IDC_EXPR_EDIT, WM_SETFONT, (WPARAM)ec->hFixedFont, TRUE);
		CheckRadioButton(hDlg, IDC_SCALAR_RB, IDC_VECTOR_RB, IDC_SCALAR_RB);
		updateVarList(hDlg, ec);
		EnableWindow(GetDlgItem(hDlg, IDC_ASGN_CONST), 0);
		EnableWindow(GetDlgItem(hDlg, IDC_ASGN_CNTRL), 0);
		SetDlgItemText(hDlg, IDC_EXPR_EDIT, ec->expr.getExprStr());
		SetDlgItemText(hDlg, IDC_DESCRIPTION, ec->desc);
		SetFocus(GetDlgItem(hDlg, IDC_EXPR_EDIT));
		GetDlgItemText(hDlg, IDC_EXPLAIN_NOTATION, buf, sizeof(buf));
		if(buf[0]) {
			WINDOWPLACEMENT wp;
			wp.length = sizeof(WINDOWPLACEMENT);
			GetWindowPlacement(GetDlgItem(hDlg, IDC_EXPR_EDIT), &wp);
			wp.rcNormalPosition.bottom -= 12;
			SetWindowPlacement(GetDlgItem(hDlg, IDC_EXPR_EDIT), &wp);
			ShowWindow(GetDlgItem(hDlg, IDC_EXPLAIN_NOTATION), SW_SHOW);
		}
			
		return FALSE;

	case CC_SPINNER_CHANGE:
		switch ( LOWORD(wParam) ) {
		case IDC_OFFSET_SPIN:
			GetDlgItemText(hDlg, IDC_VAR_NAME, buf, 256);
			if(buf[0]) {
				ct = ec->sVars.Count();
				for(i = 0; i < ct; i++) {
					if(_tcscmp(buf, ec->sVars[i].name) == 0) {
						spin = GetISpinner(GetDlgItem(hDlg, IDC_OFFSET_SPIN));
						ec->sVars[i].offset = spin->GetIVal();
						ReleaseISpinner(spin);
						break;
					}
				}
				if(i < ct)
					break;
				ct = ec->vVars.Count();
				for(i = 0; i < ct; i++) {
					if(_tcscmp(buf, ec->vVars[i].name) == 0) {
						spin = GetISpinner(GetDlgItem(hDlg, IDC_OFFSET_SPIN));
						ec->vVars[i].offset = spin->GetIVal();
						ReleaseISpinner(spin);
						break;
					}
				}
			}
			break;
		}
		break;

	case WM_COMMAND:
		switch (LOWORD(wParam)) {
		case IDC_EXPR_DEBUG:
			if(ec->edbg)
				ShowWindow(ec->edbg->hWnd, SW_SHOWNORMAL);
			else
				ec->edbg = new ExprDebug(hDlg, ec);
			updateExpr(hDlg, ec);
			ec->edbg->Update();
			break;
		case IDC_FUNCTIONS:
			DialogBox(hInstance, MAKEINTRESOURCE(IDD_FUNC_LIST), hDlg, functionListProc);
			break;
		case IDC_CREATE_VAR:
			GetDlgItemText(hDlg, IDC_VAR_NAME, buf, 256);
			if(buf[0]) {
				if(invalidName(buf)) {
					_tcscpy(buf2, GetString(IDS_DB_BAD_NAME));
					MessageBox(hDlg, buf2, GetString(IDS_DB_CANT_CREATE_VAR), 
							MB_ICONEXCLAMATION | MB_APPLMODAL | MB_OK);
					break;
				}
				type = IsDlgButtonChecked(hDlg, IDC_SCALAR_RB) ? SCALAR_VAR : VECTOR_VAR;
				ec->updRegCt(slot = ec->expr.defVar(type, buf), type);
				spin = GetISpinner(GetDlgItem(hDlg, IDC_OFFSET_SPIN));
				i = spin->GetIVal();
				ReleaseISpinner(spin);
				if(slot >= 0)
					ec->dfnVar(type, buf, slot, i);
				else {
					_tcscpy(buf2, GetString(IDS_DB_DUPNAME));
					MessageBox(hDlg, buf2, GetString(IDS_DB_CANT_CREATE_VAR), 
							MB_ICONEXCLAMATION | MB_APPLMODAL | MB_OK);
				}
			}
			updateVarList(hDlg, ec);
			slot = type == SCALAR_VAR ? IDC_SCALAR_LIST : IDC_VECTOR_LIST;
			ct = SendDlgItemMessage(hDlg, slot, LB_GETCOUNT, 0, 0);
			for(i = 0; i < ct; i++) {
				SendDlgItemMessage(hDlg, slot, LB_GETTEXT, i, (LPARAM)buf2);
				if(_tcscmp(buf, buf2) == 0) {
					SendDlgItemMessage(hDlg, slot, LB_SETCURSEL, i, 0);
					break;
				}
			}
			SendMessage(hDlg, WM_COMMAND, slot | (LBN_SELCHANGE << 16), 0); 
			break;
		case IDC_DELETE_VAR:
			GetDlgItemText(hDlg, IDC_VAR_NAME, buf, 256);
			if(buf[0]) {
				ct = ec->sVars.Count();
				for(i = 0; i < ct; i++) {
					if(_tcscmp(buf, ec->sVars[i].name) == 0) {
						ec->expr.deleteVar(buf);
						delete ec->sVars[i].name;
						ec->sVars.Delete(i, 1);
						SetDlgItemText(hDlg, IDC_VAR_NAME, _T(""));
						break;
					}
				}
				if(i < ct) {
					updateVarList(hDlg, ec);
					break;
				}

				ct = ec->vVars.Count();
				for(i = 0; i < ct; i++) {
					if(_tcscmp(buf, ec->vVars[i].name) == 0) {
						ec->expr.deleteVar(buf);
						delete ec->vVars[i].name;
						ec->vVars.Delete(i, 1);
						SetDlgItemText(hDlg, IDC_VAR_NAME, _T(""));
						break;
					}
				}
				if(i < ct) {
					updateVarList(hDlg, ec);
					break;
				}
				_stprintf(buf2, GetString(IDS_DB_CANTDELETE), buf);
				MessageBox(hDlg, buf2, GetString(IDS_DB_EXPRCNTL), 
						MB_ICONEXCLAMATION | MB_APPLMODAL | MB_OK);
			}
			else {
				_tcscpy(buf2, GetString(IDS_DB_NOTHINGDEL));
				MessageBox(hDlg, buf2, GetString(IDS_DB_EXPRCNTL), 
						MB_ICONEXCLAMATION | MB_APPLMODAL | MB_OK);
			}
			break;
		case IDC_EXPR_EVAL:
			updateExpr(hDlg, ec);
			if(ec->edbg)
				ec->edbg->Update();
			break;
		case IDC_VAR_NAME:
		case IDC_EXPR_EDIT:
		case IDC_DESCRIPTION:
			if(HIWORD(wParam) == EN_SETFOCUS)
				DisableAccelerators();
			else if(HIWORD(wParam) == EN_KILLFOCUS) {
				EnableAccelerators();
				if (LOWORD(wParam) == IDC_DESCRIPTION) {
					GetDlgItemText(hDlg, IDC_DESCRIPTION, buf, 4096);
					ec->desc = buf;
				}					
			}
			break;
		case IDC_ASGN_CNTRL:
			ct = SendDlgItemMessage(hDlg, IDC_SCALAR_LIST, LB_GETCOUNT, 0, 0);
			for(i = 0; i < ct; i++)
				if(SendDlgItemMessage(hDlg, IDC_SCALAR_LIST, LB_GETSEL, i, 0))
					break;
			if(i < ct) {
				SendDlgItemMessage(hDlg, IDC_SCALAR_LIST, LB_GETTEXT, i, (LPARAM)buf);
				ct = ec->getVarCount(SCALAR_VAR);
				for(i = 0; i < ct; i++) {
					if(_tcscmp(buf, ec->getVarName(SCALAR_VAR, i)) == 0)
						break;
				}
				FloatFilter ff;
				if(ec->ip->TrackViewPickDlg(hDlg, &res, &ff)) {
					assert(res.anim->SuperClassID() == CTRL_FLOAT_CLASS_ID);
					ec->assignController(SCALAR_VAR, i, res.client, res.subNum);
					SendMessage(hDlg, WM_COMMAND, IDC_SCALAR_LIST | (LBN_SELCHANGE << 16), 0); 
				}
				break;
			}
			ct = SendDlgItemMessage(hDlg, IDC_VECTOR_LIST, LB_GETCOUNT, 0, 0);
			for(i = 0; i < ct; i++)
				if(SendDlgItemMessage(hDlg, IDC_VECTOR_LIST, LB_GETSEL, i, 0))
					break;
			if(i < ct) {
				slot = IDC_VECTOR_LIST;
				SendDlgItemMessage(hDlg, IDC_VECTOR_LIST, LB_GETTEXT, i, (LPARAM)buf);
				ct = ec->getVarCount(VECTOR_VAR);
				for(i = 0; i < ct; i++) {
					if(_tcscmp(buf, ec->getVarName(VECTOR_VAR, i)) == 0)
						break;
				}
				VectorFilter vf;
				if(ec->ip->TrackViewPickDlg(hDlg, &res, &vf)) {
					assert(res.anim->SuperClassID() == CTRL_POSITION_CLASS_ID ||
						   res.anim->SuperClassID() == CTRL_POINT3_CLASS_ID ||
						   res.anim->SuperClassID() == BASENODE_CLASS_ID);
					
					if (res.anim->SuperClassID()==BASENODE_CLASS_ID) {
						ec->assignController(VECTOR_VAR, i, res.anim, -1);
					} else {
						ec->assignController(VECTOR_VAR, i, res.client, res.subNum);
						}
					SendMessage(hDlg, WM_COMMAND, IDC_VECTOR_LIST | (LBN_SELCHANGE << 16), 0); 
				}
				break;
			}
			break;
		case IDC_ASGN_CONST:
			ct = SendDlgItemMessage(hDlg, IDC_SCALAR_LIST, LB_GETCOUNT, 0, 0);
			for(i = 0; i < ct; i++)
				if(SendDlgItemMessage(hDlg, IDC_SCALAR_LIST, LB_GETSEL, i, 0))
					break;
			if(i < ct) {
				SendDlgItemMessage(hDlg, IDC_SCALAR_LIST, LB_GETTEXT, i, (LPARAM)buf);
				ct = ec->getVarCount(SCALAR_VAR);
				for(i = 0; i < ct; i++) {
					if(_tcscmp(buf, ec->getVarName(SCALAR_VAR, i)) == 0)
						break;
				}
				ec->curIndex = i;
				DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_SCALAR_ASGN),
							hDlg, ScalarAsgnDlgProc, (LPARAM)ec);
				SendMessage(hDlg, WM_COMMAND, IDC_SCALAR_LIST | (LBN_SELCHANGE << 16), 0); 
				break;
			}
			ct = SendDlgItemMessage(hDlg, IDC_VECTOR_LIST, LB_GETCOUNT, 0, 0);
			for(i = 0; i < ct; i++)
				if(SendDlgItemMessage(hDlg, IDC_VECTOR_LIST, LB_GETSEL, i, 0))
					break;
			if(i < ct) {
				slot = IDC_VECTOR_LIST;
				SendDlgItemMessage(hDlg, IDC_VECTOR_LIST, LB_GETTEXT, i, (LPARAM)buf);
				ct = ec->getVarCount(VECTOR_VAR);
				for(i = 0; i < ct; i++) {
					if(_tcscmp(buf, ec->getVarName(VECTOR_VAR, i)) == 0)
						break;
				}
				ec->curIndex = i;
				DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_VECTOR_ASGN),
							hDlg, VectorAsgnDlgProc, (LPARAM)ec);
				SendMessage(hDlg, WM_COMMAND, IDC_VECTOR_LIST | (LBN_SELCHANGE << 16), 0); 
				break;
			}
			break;
		case IDC_SCALAR_LIST:
			if(HIWORD(wParam) == LBN_SELCHANGE) {
				SendDlgItemMessage(hDlg, IDC_VECTOR_LIST, LB_SETCURSEL, (WPARAM)-1, (LPARAM)0);
				ct = SendDlgItemMessage(hDlg, IDC_SCALAR_LIST, LB_GETCOUNT, 0, 0);
				for(i = 0; i < ct; i++)
					if(SendDlgItemMessage(hDlg, IDC_SCALAR_LIST, LB_GETSEL, i, 0))
						break;
				if(i < ct) {
					SendDlgItemMessage(hDlg, IDC_SCALAR_LIST, LB_GETTEXT, i, (LPARAM)buf);
					ct = ec->getVarCount(SCALAR_VAR);
					for(i = 0; i < ct; i++) 
						if(_tcscmp(buf, ec->getVarName(SCALAR_VAR, i)) == 0)
							break;
					SetDlgItemText(hDlg, IDC_VAR_NAME, buf);
					CheckRadioButton(hDlg, IDC_SCALAR_RB, IDC_VECTOR_RB, IDC_SCALAR_RB);
					spin = GetISpinner(GetDlgItem(hDlg, IDC_OFFSET_SPIN));
					spin->SetValue(ec->sVars[i].offset, FALSE);
					ReleaseISpinner(spin);
					if(ec->sVars[i].refID < 0) {
						_stprintf(buf, "Constant: %g", ec->getScalarValue(i));
						UglyPatch(buf);
					}
					else {
						slot = ec->sVars[i].refID;
#if 0	// displays unique controller id
						_stprintf(buf, "Controller: %s {%08x}:%d", 
									ec->refTab[slot].client->SubAnimName(ec->sVars[i].subNum), 
									ec->refTab[slot].client, ec->sVars[i].subNum);
#else	// displays more user-friendly (but possibly wrong) text
						TSTR nname;
						// RB 3/23/99: See comment at imp of getNodeName().
						//ec->refTab[slot].client->NotifyDependents(FOREVER,(PartID)&nname,REFMSG_GET_NODE_NAME);
						ec->getNodeName(ec->refTab[slot].client,nname);
						TSTR pname;
						if (nname.Length())
							pname = nname + TSTR(_T("\\")) + ec->refTab[slot].client->SubAnimName(ec->sVars[i].subNum);
						else 
							pname = ec->refTab[slot].client->SubAnimName(ec->sVars[i].subNum);
						_tcscpy(buf, pname);
#endif
					}
					SetDlgItemText(hDlg, IDC_CUR_ASGN, buf);
				}
				EnableWindow(GetDlgItem(hDlg, IDC_ASGN_CONST), 1);
				EnableWindow(GetDlgItem(hDlg, IDC_ASGN_CNTRL), 1);
			}
			break;
		case IDC_VECTOR_LIST:
			if(HIWORD(wParam) == LBN_SELCHANGE) {
				SendDlgItemMessage(hDlg, IDC_SCALAR_LIST, LB_SETCURSEL, (WPARAM)-1, (LPARAM)0);
				ct = SendDlgItemMessage(hDlg, IDC_VECTOR_LIST, LB_GETCOUNT, 0, 0);
				for(i = 0; i < ct; i++)
					if(SendDlgItemMessage(hDlg, IDC_VECTOR_LIST, LB_GETSEL, i, 0))
						break;
				if(i < ct) {
					SendDlgItemMessage(hDlg, IDC_VECTOR_LIST, LB_GETTEXT, i, (LPARAM)buf);
					ct = ec->getVarCount(VECTOR_VAR);
					for(i = 0; i < ct; i++) 
						if(_tcscmp(buf, ec->getVarName(VECTOR_VAR, i)) == 0)
							break;
					SetDlgItemText(hDlg, IDC_VAR_NAME, buf);
					CheckRadioButton(hDlg, IDC_SCALAR_RB, IDC_VECTOR_RB, IDC_VECTOR_RB);
					spin = GetISpinner(GetDlgItem(hDlg, IDC_OFFSET_SPIN));
					spin->SetValue(ec->vVars[i].offset, FALSE);
					ReleaseISpinner(spin);
					if(ec->vVars[i].refID < 0 || !ec->refTab[ec->vVars[i].refID].client) {
						pt = ec->getVectorValue(i);
						_stprintf(buf, "Constant: [%g; %g; %g]", pt.x, pt.y, pt.z);
						UglyPatch(buf);
					}
					else {
						slot = ec->vVars[i].refID;
#if 0	// displays unique controller id
						_stprintf(buf, "Controller: %s {%08x}:%d", 
									ec->refTab[slot].client->SubAnimName(ec->vVars[i].subNum), 
									ec->refTab[slot].client, ec->vVars[i].subNum);
#else	// displays more user-friendly (but possibly wrong) text
						TSTR pname;
						if(ec->vVars[i].subNum == -1)	// special case: we're referencing a node
							pname = ((INode *)ec->refTab[slot].client)->GetName();
						else {
							TSTR nname;
							// RB 3/23/99: See comment at imp of getNodeName().
							//ec->refTab[slot].client->NotifyDependents(FOREVER,(PartID)&nname,REFMSG_GET_NODE_NAME);
							ec->getNodeName(ec->refTab[slot].client,nname);
							if (nname.Length())
								pname = nname + TSTR(_T("\\")) + ec->refTab[slot].client->SubAnimName(ec->vVars[i].subNum);
							else 
								pname = ec->refTab[slot].client->SubAnimName(ec->vVars[i].subNum);
						}
						_tcscpy(buf, pname);
#endif
					}
					SetDlgItemText(hDlg, IDC_CUR_ASGN, buf);
				}
				EnableWindow(GetDlgItem(hDlg, IDC_ASGN_CONST), 1);
				EnableWindow(GetDlgItem(hDlg, IDC_ASGN_CNTRL), 1);
			}
			break;
		case IDOK:
		case IDCANCEL:
			if(updateExpr(hDlg, ec))
				DestroyWindow(hDlg);
			break;

		case IDC_SAVE:
			SaveExpression(hDlg, ec);
			break;

		case IDC_LOAD:
			LoadExpression(hDlg, ec);
//			updateExpr(hDlg, ec);
			break;
		}
		break;

	case WM_DESTROY: {
			Rect rect;
			GetWindowRect(hDlg,&rect);
			ec->winX = rect.left;
			ec->winY = rect.top;
		}
		ec->hParams = NULL;
		break;

	default:
		return 0;			
	}
	return 1;
}


void ExprControl::EditTrackParams(
			TimeValue t,	// The horizontal position of where the user right clicked.
			ParamDimensionBase *dim,
			TCHAR *pname,
			HWND hParent,
			IObjParam *ip,
			DWORD flags)
{
	if (!hParams) {
		this->ip = ip;
		hParams = CreateDialogParam(
			hInstance,
			MAKEINTRESOURCE(IDD_EXPRPARAMS),
			hParent,
			ExprParamsWndProc,
			(LPARAM)this);
		TSTR title = TSTR(GetString(IDS_RB_EXPRESSIONCONTROLTITLE)) + TSTR(pname);
		SetWindowText(hParams,title);
	} 
	else {
		SetActiveWindow(hParams);
	}
}

#define EXPR_STR_CHUNK		0x5000
#define EXPR_RANGE_CHUNK	0x5001
#define EXPR_REFTAB_SIZE	0x5002
#define EXPR_SVAR_TABSIZE	0x5003
#define EXPR_VVAR_TABSIZE	0x5005
#define EXPR_VAR_NAME		0x5006
#define EXPR_VAR_REFID		0x5007
#define EXPR_VAR_FLOAT		0x5008
#define EXPR_VAR_POINT3		0x5009
#define EXPR_VAR_SUBNUM		0x500a
#define EXPR_DESCRIPTION	0x500b
#define EXPR_REFTAB_REFCT	0x500c
#define EXPR_VAR_OFFSET		0x500d
#define EXPR_SVAR_ENTRY0	0x6000
#define EXPR_SVAR_ENTRYN	0x6fff
#define EXPR_VVAR_ENTRY0	0x7000
#define EXPR_VVAR_ENTRYN	0x7fff

IOResult ExprControl::Save(ISave *isave)
{
	ULONG 	nb;
	int		i, ct, intVar;

	Control::Save(isave); // RB: this will handle saving ORTs

	if(desc.Length()) {
	 	isave->BeginChunk(EXPR_DESCRIPTION);
		isave->WriteCString(desc);
	 	isave->EndChunk();
	}

 	isave->BeginChunk(EXPR_RANGE_CHUNK);
	isave->Write(&range, sizeof(range), &nb);
 	isave->EndChunk();

 	isave->BeginChunk(EXPR_REFTAB_SIZE);
	intVar = refTab.Count();
	isave->Write(&intVar, sizeof(intVar), &nb);
 	isave->EndChunk();

	ct = refTab.Count();
	for(i = 0; i < ct; i++) {
	 	isave->BeginChunk(EXPR_REFTAB_REFCT);
		isave->Write(&i, sizeof(int), &nb);
		isave->Write(&refTab[i].refCt, sizeof(int), &nb);
		isave->EndChunk();
	}


 	isave->BeginChunk(EXPR_SVAR_TABSIZE);
	intVar = sVars.Count();
	isave->Write(&intVar, sizeof(intVar), &nb);
 	isave->EndChunk();

	ct = sVars.Count();
	for(i = 0; i < ct; i++) {
	 	isave->BeginChunk(EXPR_SVAR_ENTRY0+i);
	 	 isave->BeginChunk(EXPR_VAR_NAME);
		 isave->WriteCString(sVars[i].name);
 		 isave->EndChunk();
	 	 isave->BeginChunk(EXPR_VAR_REFID);
		 isave->Write(&sVars[i].refID, sizeof(int), &nb);
 		 isave->EndChunk();
	 	 isave->BeginChunk(EXPR_VAR_FLOAT);
		 isave->Write(&sVars[i].val, sizeof(float), &nb);
 		 isave->EndChunk();
	 	 isave->BeginChunk(EXPR_VAR_SUBNUM);
		 isave->Write(&sVars[i].subNum, sizeof(int), &nb);
 		 isave->EndChunk();
	 	 isave->BeginChunk(EXPR_VAR_OFFSET);
		 isave->Write(&sVars[i].offset, sizeof(int), &nb);
 		 isave->EndChunk();
	 	isave->EndChunk();
	}

 	isave->BeginChunk(EXPR_VVAR_TABSIZE);
	intVar = vVars.Count();
	isave->Write(&intVar, sizeof(intVar), &nb);
 	isave->EndChunk();

	ct = vVars.Count();
	for(i = 0; i < ct; i++) {
	 	isave->BeginChunk(EXPR_VVAR_ENTRY0+i);
	 	 isave->BeginChunk(EXPR_VAR_NAME);
		 isave->WriteCString(vVars[i].name);
 		 isave->EndChunk();
	 	 isave->BeginChunk(EXPR_VAR_REFID);
		 isave->Write(&vVars[i].refID, sizeof(int), &nb);
 		 isave->EndChunk();
	 	 isave->BeginChunk(EXPR_VAR_POINT3);
		 isave->Write(&vVars[i].val, sizeof(Point3), &nb);
 		 isave->EndChunk();
	 	 isave->BeginChunk(EXPR_VAR_SUBNUM);
		 isave->Write(&vVars[i].subNum, sizeof(int), &nb);
 		 isave->EndChunk();
	 	 isave->BeginChunk(EXPR_VAR_OFFSET);
		 isave->Write(&vVars[i].offset, sizeof(int), &nb);
 		 isave->EndChunk();
	 	isave->EndChunk();
	}

 	isave->BeginChunk(EXPR_STR_CHUNK);
	isave->WriteCString(expr.getExprStr());
 	isave->EndChunk();
	
	return IO_OK;
}

// RB 3/19/99: Check for refs to path controller. These must be refs to the percent track made from
// MAX2.5 or earlier. Convert to paramblock 2 refs.
class CheckForPathContRefsPLCB : public PostLoadCallback {
	public:
		ExprControl *cont;
		CheckForPathContRefsPLCB(ExprControl *c) {cont = c;}
		void proc(ILoad *iload) {
			for (int i=0; i<cont->refTab.Count(); i++) {
				if (!cont->refTab[i].client) continue;
				if (cont->refTab[i].client->SuperClassID()==CTRL_POSITION_CLASS_ID &&
					cont->refTab[i].client->ClassID()==Class_ID(PATH_CONTROL_CLASS_ID,0)) {
										
					cont->ReplaceReference(i+cont->StdControl::NumRefs(),
						cont->refTab[i].client->GetReference(PATHPOS_PBLOCK_REF));					
					}
				}
			delete this;
			}
	};

IOResult ExprControl::Load(ILoad *iload)
{
	ULONG 	nb;
	TCHAR	*cp;
	int		id, i, varIndex, intVar;
	IOResult res;
	VarRef	dummyVarRef;

	Control::Load(iload); // RB: this will handle loading ORTs

	while (IO_OK==(res=iload->OpenChunk())) {
		switch (id = iload->CurChunkID()) {
		case EXPR_STR_CHUNK:
			iload->ReadCStringChunk(&cp);
			expr.load(cp);
			break;
		case EXPR_DESCRIPTION:
			iload->ReadCStringChunk(&cp);
			desc = cp;
			break;
		case EXPR_RANGE_CHUNK:
			iload->Read(&range, sizeof(range), &nb);
			break;
		case EXPR_REFTAB_SIZE:
			iload->Read(&intVar, sizeof(intVar), &nb);
			refTab.SetCount(intVar);
			for(i = 0; i < intVar; i++) {
				refTab[i].refCt = 0;
				refTab[i].client = NULL;
			}
			break;
		case EXPR_REFTAB_REFCT:
			iload->Read(&intVar, sizeof(int), &nb);
			if(intVar < refTab.Count())		// this should always be true!!!!
				iload->Read(&refTab[intVar].refCt, sizeof(int), &nb);
			break;
		case EXPR_SVAR_TABSIZE:
			iload->Read(&intVar, sizeof(intVar), &nb);
			sVars.SetCount(intVar);
			for(i = 0; i < intVar; i++)
				memset(&sVars[i], 0, sizeof(SVar));
			break;
		case EXPR_VVAR_TABSIZE:
			iload->Read(&intVar, sizeof(intVar), &nb);
			vVars.SetCount(intVar);
			for(i = 0; i < intVar; i++)
				memset(&vVars[i], 0, sizeof(VVar));
			break;
		}	
		if(id >= EXPR_SVAR_ENTRY0 && id <= EXPR_SVAR_ENTRYN) {
			varIndex = id - EXPR_SVAR_ENTRY0;
			assert(varIndex < sVars.Count());
			while (IO_OK == iload->OpenChunk()) {
				switch (iload->CurChunkID()) {
				case EXPR_VAR_NAME:
					iload->ReadCStringChunk(&cp);
					sVars[varIndex].name = cp;
					break;
				case EXPR_VAR_REFID:
					iload->Read(&sVars[varIndex].refID, sizeof(int), &nb);
					break;
				case EXPR_VAR_SUBNUM:
					iload->Read(&sVars[varIndex].subNum, sizeof(int), &nb);
					break;
				case EXPR_VAR_OFFSET:
					iload->Read(&sVars[varIndex].offset, sizeof(int), &nb);
					break;
				case EXPR_VAR_FLOAT:
					iload->Read(&sVars[varIndex].val, sizeof(float), &nb);
					break;
				}	
				iload->CloseChunk();
			}
			updRegCt(intVar = expr.defVar(SCALAR_VAR, sVars[varIndex].name), SCALAR_VAR);
			sVars[varIndex].regNum = intVar;
		}
		else if(id >= EXPR_VVAR_ENTRY0 && id <= EXPR_VVAR_ENTRYN) {
			varIndex = id - EXPR_VVAR_ENTRY0;
			assert(varIndex < vVars.Count());
			while (IO_OK == iload->OpenChunk()) {
				switch (iload->CurChunkID()) {
				case EXPR_VAR_NAME:
					iload->ReadCStringChunk(&cp);
					vVars[varIndex].name = cp;
					break;
				case EXPR_VAR_REFID:
					iload->Read(&vVars[varIndex].refID, sizeof(int), &nb);
					break;
				case EXPR_VAR_SUBNUM:
					iload->Read(&vVars[varIndex].subNum, sizeof(int), &nb);
					break;
				case EXPR_VAR_OFFSET:
					iload->Read(&vVars[varIndex].offset, sizeof(int), &nb);
					break;
				case EXPR_VAR_POINT3:
					iload->Read(&vVars[varIndex].val, sizeof(Point3), &nb);
					break;
				}	
				iload->CloseChunk();
			}
			updRegCt(intVar = expr.defVar(VECTOR_VAR, vVars[varIndex].name), VECTOR_VAR);
			vVars[varIndex].regNum = intVar;
		}
		iload->CloseChunk();
	}
	
	// RB 3/19/99: Refs to pathController\percent need to be changed to refer to the parameter block.
	iload->RegisterPostLoadCallback(new CheckForPathContRefsPLCB(this));

	return IO_OK;
}


static BOOL CALLBACK ExprDbgWndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

int ExprDebug::winX = -1;
int ExprDebug::winY = -1;


ExprDebug::ExprDebug(HWND hParent, ExprControl *exprControl)
{
	ec = exprControl;
	CreateDialogParam(
		hInstance,
		MAKEINTRESOURCE(IDD_EXPR_DEBUG),
		hParent,
		ExprDbgWndProc,
		(LPARAM)this);	
}

ExprDebug::~ExprDebug()
{
	Rect rect;
	GetWindowRect(hWnd,&rect);
	winX = rect.left;
	winY = rect.top;
	GetCOREInterface()->UnRegisterTimeChangeCallback(this);
	if(ec)
		ec->edbg = NULL;
}

void ExprDebug::Invalidate()
{
	Rect rect;
	rect.left = 0;
	rect.right = 10;
	rect.top = 0;
	rect.bottom = 10;
	InvalidateRect(hWnd,&rect,FALSE);
}

void ExprDebug::Update()
{
	int i, ct;
	float fval;
	Point3 vval;
	TCHAR buf[1024];
	HWND hList = GetDlgItem(hWnd, IDC_DEBUG_LIST);

	SendMessage(hList, LB_RESETCONTENT, 0, 0);

	_stprintf(buf, _T("%s\t%g"), _T("T"), (float)t);
	SendMessage(hList, LB_ADDSTRING, 0, (LPARAM)buf);
	_stprintf(buf, _T("%s\t%g"), _T("S"), (float)t/4800.0f);
	SendMessage(hList, LB_ADDSTRING, 0, (LPARAM)buf);
	_stprintf(buf, _T("%s\t%g"), _T("F"), (float)t/GetTicksPerFrame());
	SendMessage(hList, LB_ADDSTRING, 0, (LPARAM)buf);
	_stprintf(buf, _T("%s\t%g"), _T("NT"), (float)(t-ec->range.Start()) / 
						(float)(ec->range.End()-ec->range.Start()));
	SendMessage(hList, LB_ADDSTRING, 0, (LPARAM)buf);
 
	ct = ec->getVarCount(SCALAR_VAR);
	for(i = 0; i < ct; i++) {
		if(ec->sVars[i].refID < 0)
			fval = ec->sVars[i].val;
		else {
			Control *c;
			Interval iv;
			c = (Control *)ec->refTab[ec->sVars[i].refID].client->SubAnim(ec->sVars[i].subNum);
			c->GetValue(t+ec->sVars[i].offset, &fval, iv);
		}
		_stprintf(buf, _T("%s\t%.4f"), ec->getVarName(SCALAR_VAR, i), fval);
		SendMessage(hList, LB_ADDSTRING, 0, (LPARAM)buf);
	}
	ct = ec->getVarCount(VECTOR_VAR);
	for(i = 0; i < ct; i++) {
		if(ec->vVars[i].refID < 0 || !ec->refTab[ec->vVars[i].refID].client)
			vval = ec->vVars[i].val;
		else {
			Control *c;
			Interval iv;
			if (ec->vVars[i].subNum < 0) {	// this is referencing a node, not a controller! DB 1/98
				ec->GetAbsoluteControlValue(
					(INode*)ec->refTab[ec->vVars[i].refID].client,t+ec->vVars[i].offset,&vval, iv);
			} 
			else {	// controller reference...
				c = (Control *)ec->refTab[ec->vVars[i].refID].client->SubAnim(ec->vVars[i].subNum);
				c->GetValue(t+ec->vVars[i].offset, &vval, iv);
			}
		}
		_stprintf(buf, _T("%s\t[%.4f, %.4f, %.4f]"), ec->getVarName(VECTOR_VAR, i), vval.x, vval.y, vval.z);
		SendMessage(hList, LB_ADDSTRING, 0, (LPARAM)buf);
	}
	if(ec->expr.getExprType() == SCALAR_EXPR) {
		Interval iv;
		ec->GetValue(t, &ec->curFloatVal, iv);
		_stprintf(buf, _T("%g"), ec->curFloatVal);
	}
	else if(ec->type == EXPR_SCALE_CONTROL_CLASS_ID) {
		Interval iv;
		Quat q;
		ec->GetValue(t, &q, iv);
		_stprintf(buf, _T("[%g, %g, %g]"), q.x, q.y, q.z);
	}
	else {
		Interval iv;
		ec->GetValue(t, &ec->curPosVal, iv);
		_stprintf(buf, _T("[%g, %g, %g]"), ec->curPosVal.x, ec->curPosVal.y, ec->curPosVal.z);
	}
	SetDlgItemText(hWnd, IDC_DEBUG_VALUE, buf);
}

static int tabs[] = { 75 };

void ExprDebug::Init(HWND hWnd)
{
	this->hWnd = hWnd;
	
	if (winX==-1 || winY==-1)
		CenterWindow(hWnd,GetParent(hWnd));
	else 
		SetWindowPos(hWnd,NULL,winX, winY, 0, 0, SWP_NOSIZE|SWP_NOZORDER);

	t = GetCOREInterface()->GetTime();

	SendMessage(GetDlgItem(hWnd, IDC_DEBUG_LIST), LB_SETTABSTOPS, 1, (LPARAM)tabs);
	GetCOREInterface()->RegisterTimeChangeCallback(this);
}


static BOOL CALLBACK ExprDbgWndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	ExprDebug *ed = (ExprDebug*)GetWindowLong(hWnd,GWL_USERDATA);

	switch (msg) {
	case WM_INITDIALOG:
//		SetWindowContextHelpId(hWnd,idh_dialog_xform_typein);
		ed = (ExprDebug*)lParam;
		SetWindowLong(hWnd,GWL_USERDATA,lParam);
		ed->Init(hWnd);
		return FALSE;

	case WM_SYSCOMMAND:
//		if ((wParam & 0xfff0)==SC_CONTEXTHELP) 
//			Help(HELP_CONTEXT,idh_dialog_xform_typein);				
		return 0;

	case WM_PAINT:
//		if (!ed->valid)
			ed->Update();
		return 0;
		
	case WM_COMMAND:
		if(LOWORD(wParam) == IDCANCEL)
			goto weAreDone;
		SendMessage(GetParent(hWnd), msg, wParam, lParam);						
		break;
	
	case WM_CLOSE:
weAreDone:
		DestroyWindow(hWnd);
		break;

	case WM_DESTROY:
		delete ed;
		break;

	default:
		return 0;
	}
	return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Control\ctrl.cpp ===
/**********************************************************************
 *<
    FILE: ctrl.cpp

    DESCRIPTION:   DLL implementation of some controllers

    CREATED BY: Rolf Berteig

    HISTORY: created 13 June 1995

	         added independent scale controller (ScaleXYZ)
			 see file "./indescale.cpp"
			   mjm 9.15.98

 *> Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#include "ctrl.h"
#include "buildver.h"

HINSTANCE hInstance;
int controlsInit = FALSE;

/** public functions **/
BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) {
    hInstance = hinstDLL;

    if ( !controlsInit ) {
        controlsInit = TRUE;
        
        // jaguar controls
        InitCustomControls(hInstance);

#ifdef OLD3DCONTROLS
        // initialize 3D controls
        Ctl3dRegister(hinstDLL);
        Ctl3dAutoSubclass(hinstDLL);
#endif
        
        // initialize Chicago controls
        InitCommonControls();

        SetDefaultBoolController(GetBoolControlDesc());
        }

    switch(fdwReason) {
        case DLL_PROCESS_ATTACH:
            break;
        case DLL_THREAD_ATTACH:
            break;
        case DLL_THREAD_DETACH:
            break;
        case DLL_PROCESS_DETACH:
            break;
        }
    return(TRUE);
    }


//------------------------------------------------------
// This is the interface to Jaguar:
//------------------------------------------------------

__declspec( dllexport ) const TCHAR *
LibDescription() { return
 GetString(IDS_RB_DEFCONTROLLERS); }


#ifndef DESIGN_VER

/// MUST CHANGE THIS NUMBER WHEN ADD NEW CLASS
__declspec( dllexport ) int LibNumberClasses() {return 23;} // mjm 9.15.98

__declspec( dllexport ) ClassDesc*
LibClassDesc(int i) {
    switch(i) {
        case 0: return GetPathCtrlDesc();
        case 1: return GetEulerCtrlDesc();
        case 2: return GetLocalEulerCtrlDesc();
        case 3: return GetFloatNoiseDesc();
        case 4: return GetExprPosCtrlDesc();
        case 5: return GetExprP3CtrlDesc();
        case 6: return GetExprFloatCtrlDesc();
        case 7: return GetExprScaleCtrlDesc();
        case 8: return GetPositionNoiseDesc();
        case 9: return GetPoint3NoiseDesc();
        case 10: return GetRotationNoiseDesc();
        case 11: return GetScaleNoiseDesc();
        case 12: return GetBoolControlDesc();
        case 13: return GetIPosCtrlDesc();
        case 14: return GetAttachControlDesc();
        case 15: return GetIPoint3CtrlDesc();
        case 16: return GetIColorCtrlDesc();
        case 17: return GetLinkCtrlDesc();
        case 18: return GetFollowUtilDesc();
        case 19: return GetSurfCtrlDesc();
        case 20: return GetLODControlDesc();
        case 21: return GetLODUtilDesc();
		case 22: return GetIScaleCtrlDesc(); // mjm 9.15.98

//      case 7: return GetExprRotCtrlDesc();
        default: return 0;
        }
    }

#else

/// MUST CHANGE THIS NUMBER WHEN ADD NEW CLASS
__declspec( dllexport ) int LibNumberClasses() { return 19; } // mjm 9.15.98

__declspec( dllexport ) ClassDesc*
LibClassDesc(int i) {
    switch(i) {
        case 0: return GetPathCtrlDesc();
        case 1: return GetEulerCtrlDesc();
        case 2: return GetLocalEulerCtrlDesc();
        case 3: return GetFloatNoiseDesc();
//      case 4: return GetExprPosCtrlDesc();
//      case 5: return GetExprP3CtrlDesc();
//      case 6: return GetExprFloatCtrlDesc();
//      case 7: return GetExprScaleCtrlDesc();
        case 4: return GetPositionNoiseDesc();
        case 5: return GetPoint3NoiseDesc();
        case 6: return GetRotationNoiseDesc();
        case 7: return GetScaleNoiseDesc();
        case 8: return GetBoolControlDesc();
        case 9: return GetIPosCtrlDesc();
        case 10: return GetAttachControlDesc();
        case 11: return GetIPoint3CtrlDesc();
        case 12: return GetIColorCtrlDesc();
        case 13: return GetLinkCtrlDesc();
        case 14: return GetFollowUtilDesc();
        case 15: return GetSurfCtrlDesc();
        case 16: return GetLODControlDesc();
        case 17: return GetLODUtilDesc();
		case 18: return GetIScaleCtrlDesc(); // mjm 9.15.98

        default: return 0;
        }
    }

#endif


// Return version so can detect obsolete DLLs
__declspec( dllexport ) ULONG 
LibVersion() { return VERSION_3DSMAX; }

TCHAR *GetString(int id)
{
    static TCHAR buf[256];

    if(hInstance)
        return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Control\indescale.cpp ===
/* -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

   FILE: indescale.cpp

	 DESCRIPTION: An independent X, Y, Z scale controller
	              Based upon: class IndePosition

	 CREATED BY: Michael Malone (mjm)

	 HISTORY: created September 15, 1998

   	 Copyright (c) 1998, All Rights Reserved

// -----------------------------------------------------------------------------
// -------------------------------------------------------------------------- */

#include "ctrl.h"

#define ISCALE_CONTROL_CLASS_ID		Class_ID(0x118f7c01,0xfeee238b)
#define ISCALE_CONTROL_CNAME		GetString(IDS_MM_ISCALE)

#define ISCALE_X_REF 0
#define ISCALE_Y_REF 1
#define ISCALE_Z_REF 2

class IScaleDlg;

static DWORD subColor[] = { PAINTCURVE_XCOLOR, PAINTCURVE_YCOLOR, PAINTCURVE_ZCOLOR };

class IndeScale : public Control
{
	public:
		Control *scaleX;
		Control *scaleY;
		Control *scaleZ;
		ScaleValue curval;
		Interval ivalid;

		static IScaleDlg *dlg;
		static IObjParam *ip;
		static ULONG beginFlags;
		static IndeScale *editControl; // The one being edited.
		
		IndeScale(BOOL loading=FALSE);
		IndeScale(const IndeScale &ctrl);
		~IndeScale();
		void Update(TimeValue t);

		// from class Animatable:
		Class_ID ClassID()
			{ return ISCALE_CONTROL_CLASS_ID; } 
		SClass_ID SuperClassID()
			{ return CTRL_SCALE_CLASS_ID; } 
		void GetClassName(TSTR& s)
			{ s = ISCALE_CONTROL_CNAME; }
		void DeleteThis()
			{ delete this; }		
		int IsKeyable()
			{ return 1;	}		
		int NumSubs()
			{ return 3; }
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);
		int SubNumToRefNum(int subNum)
			{ return subNum; }
		DWORD GetSubAnimCurveColor(int subNum)
			{ return subColor[subNum]; }
		ParamDimension* GetParamDimension(int i)
			{ return stdPercentDim; }
		BOOL AssignController(Animatable *control,int subAnim);
		void AddNewKey(TimeValue t,DWORD flags);
		int NumKeys();
		TimeValue GetKeyTime(int index);
		void CopyKeysFromTime(TimeValue src,TimeValue dst,DWORD flags);
		BOOL IsKeyAtTime(TimeValue t,DWORD flags);
		BOOL GetNextKeyTime(TimeValue t,DWORD flags,TimeValue &nt);
		void DeleteKeyAtTime(TimeValue t);

		void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev );
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next );
		
		// from class ReferenceMaker:
		int NumRefs()
			{ return 3; };	
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);
		RefResult NotifyRefChanged(Interval, RefTargetHandle, PartID&, RefMessage);
		
		// from class Control:
		Control *GetXController()
			{ return scaleX; }
		Control *GetYController()
			{ return scaleY; }
		Control *GetZController()
			{ return scaleZ; }
		void Copy(Control *from);
		RefTargetHandle Clone(RemapDir& remap);
		BOOL IsLeaf()
			{ return FALSE; }
		void GetValue(TimeValue t, void *val, Interval &valid, GetSetMethod method);	
		void SetValue(TimeValue t, void *val, int commit, GetSetMethod method);
		void CommitValue(TimeValue t);
		void RestoreValue(TimeValue t);
};

IScaleDlg *IndeScale::dlg		  = NULL;
IObjParam *IndeScale::ip		  = NULL;
ULONG	   IndeScale::beginFlags  = 0;
IndeScale *IndeScale::editControl = NULL;

class IScaleClassDesc:public ClassDesc
{
	public:
		int IsPublic()
			{ return 1; }
		void* Create(BOOL loading)
			{ return new IndeScale(loading); }
		const TCHAR* ClassName()
			{ return ISCALE_CONTROL_CNAME; }
		SClass_ID SuperClassID()
			{ return CTRL_SCALE_CLASS_ID; }
		Class_ID ClassID()
			{ return ISCALE_CONTROL_CLASS_ID; }
		const TCHAR* Category()
			{ return _T(""); }
};

static IScaleClassDesc iscaleCD;
ClassDesc* GetIScaleCtrlDesc()
	{ return &iscaleCD; }

static BOOL CALLBACK IScaleParamDialogProc(HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);

static const int editButs[] = { IDC_ISCALE_X, IDC_ISCALE_Y, IDC_ISCALE_Z };

#define EDIT_X 0
#define EDIT_Y 1
#define EDIT_Z 2

#define ISCALE_BEGIN 1
#define ISCALE_MIDDLE 2
#define ISCALE_END 3

class IScaleDlg
{
	public:
		IndeScale *cont;
		HWND hWnd;
		IObjParam *ip;
		ICustButton *iEdit[3];
		static int cur;
		
		IScaleDlg(IndeScale *cont,IObjParam *ip);
		~IScaleDlg();

		void Init();
		void EndingEdit(IndeScale *next);
		void BeginingEdit(IndeScale *cont,IObjParam *ip,IndeScale *prev);
		void SetCur(int c,int code=ISCALE_MIDDLE);
		void WMCommand(int id, int notify, HWND hCtrl);
};

int IScaleDlg::cur = EDIT_X;

IScaleDlg::IScaleDlg(IndeScale *cont,IObjParam *ip)
{
	this->ip = ip;
	this->cont = cont;
	for (int i=0; i<3; i++)
		iEdit[i] = NULL;
	
	TCHAR *name = GetString(IDS_MM_ISCALEPARAMS);

	hWnd = ip->AddRollupPage(hInstance, MAKEINTRESOURCE(IDD_ISCALE_PARAMS),
							 IScaleParamDialogProc, name, (LPARAM)this);

	ip->RegisterDlgWnd(hWnd);	
	
	SetCur(cur,ISCALE_BEGIN);	
	UpdateWindow(hWnd);
}

IScaleDlg::~IScaleDlg()
{
	SetCur(cur,ISCALE_END);
	for (int i=0; i<3; i++)
		ReleaseICustButton(iEdit[i]);
	ip->UnRegisterDlgWnd(hWnd);
	ip->DeleteRollupPage(hWnd);
	hWnd = NULL;
}

void IScaleDlg::EndingEdit(IndeScale *next)
{
	switch (cur)
	{
	case EDIT_X:
		cont->scaleX->EndEditParams(ip,0,next->scaleX);
		break;
	case EDIT_Y:
		cont->scaleY->EndEditParams(ip,0,next->scaleY);
		break;
	case EDIT_Z:
		cont->scaleZ->EndEditParams(ip,0,next->scaleZ);
		break;
	}
	cont = NULL;
	ip   = NULL;
}

void IScaleDlg::BeginingEdit(IndeScale *cont,IObjParam *ip,IndeScale *prev)
{
	this->ip   = ip;
	this->cont = cont;
	switch (cur)
	{
	case EDIT_X:
		cont->scaleX->BeginEditParams(ip,BEGIN_EDIT_MOTION,prev->scaleX);
		break;
	case EDIT_Y:
		cont->scaleY->BeginEditParams(ip,BEGIN_EDIT_MOTION,prev->scaleY);
		break;
	case EDIT_Z:
		cont->scaleZ->BeginEditParams(ip,BEGIN_EDIT_MOTION,prev->scaleZ);
		break;
	}	
	UpdateWindow(hWnd);
}

void IScaleDlg::Init()
{	
	for (int i=0; i<3; i++)
	{
		iEdit[i] = GetICustButton(GetDlgItem(hWnd,editButs[i]));		
		iEdit[i]->SetType(CBT_CHECK);
	}
	iEdit[cur]->SetCheck(TRUE);
}

void IScaleDlg::SetCur(int c,int code)
{
	if (c==cur && code==ISCALE_MIDDLE) return;
	Control *prev = NULL, *next = NULL;

	if (code!=ISCALE_END)
	{
		switch (c)
		{
		case EDIT_X:
			next = cont->scaleX;
			break;
		case EDIT_Y:
			next = cont->scaleY;
			break;
		case EDIT_Z:
			next = cont->scaleZ;
			break;
		}
	}

	if (code != ISCALE_BEGIN)
	{
		switch (cur)
		{
		case EDIT_X:
			cont->scaleX->EndEditParams(ip, END_EDIT_REMOVEUI, next);
			prev = cont->scaleX;
			break;
		case EDIT_Y:
			cont->scaleY->EndEditParams(ip, END_EDIT_REMOVEUI, next);
			prev = cont->scaleY;
			break;
		case EDIT_Z:
			cont->scaleZ->EndEditParams(ip, END_EDIT_REMOVEUI, next);
			prev = cont->scaleZ;
			break;
		}
	}

	cur = c;

	if (code != ISCALE_END)
	{
		switch (cur)
		{
		case EDIT_X:
			cont->scaleX->BeginEditParams(ip, BEGIN_EDIT_MOTION, prev);
			break;
		case EDIT_Y:
			cont->scaleY->BeginEditParams(ip, BEGIN_EDIT_MOTION, prev);
			break;
		case EDIT_Z:
			cont->scaleZ->BeginEditParams(ip, BEGIN_EDIT_MOTION, prev);
			break;
		}
	}
}

void IScaleDlg::WMCommand(int id, int notify, HWND hCtrl)
{
	switch (id)
	{
	case IDC_ISCALE_X:
		SetCur(0);
		iEdit[0]->SetCheck(TRUE);
		iEdit[1]->SetCheck(FALSE);
		iEdit[2]->SetCheck(FALSE);
		break;
	case IDC_ISCALE_Y:
		SetCur(1);
		iEdit[0]->SetCheck(FALSE);
		iEdit[1]->SetCheck(TRUE);
		iEdit[2]->SetCheck(FALSE);
		break;
	case IDC_ISCALE_Z:
		SetCur(2);
		iEdit[0]->SetCheck(FALSE);
		iEdit[1]->SetCheck(FALSE);
		iEdit[2]->SetCheck(TRUE);
		break;
	}
}

static BOOL CALLBACK IScaleParamDialogProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam )
{
	IScaleDlg *dlg = (IScaleDlg*)GetWindowLong(hDlg,GWL_USERDATA);

	switch (message)
	{
	case WM_INITDIALOG:
		dlg = (IScaleDlg*)lParam;			
		SetWindowLong(hDlg,GWL_USERDATA,lParam);
		dlg->hWnd = hDlg;
		dlg->Init();
		break;
	
	case WM_COMMAND:
		dlg->WMCommand(LOWORD(wParam),HIWORD(wParam),(HWND)lParam);
		break;

	case WM_LBUTTONDOWN:case WM_LBUTTONUP:	case WM_MOUSEMOVE:
		dlg->ip->RollupMouseMessage(hDlg,message,wParam,lParam);
		break;
			
	default:
		return FALSE;
	}
	return TRUE;
}



IndeScale::IndeScale(const IndeScale &ctrl)
{
	scaleX = NULL;
	scaleY = NULL;
	scaleZ = NULL;

	if (ctrl.scaleX)
		ReplaceReference(ISCALE_X_REF, ctrl.scaleX);
	else
		ReplaceReference(ISCALE_X_REF, NewDefaultFloatController());

	if (ctrl.scaleY)
		ReplaceReference(ISCALE_Y_REF, ctrl.scaleY);
	else
		ReplaceReference(ISCALE_Y_REF, NewDefaultFloatController());

	if (ctrl.scaleZ)
		ReplaceReference(ISCALE_Z_REF, ctrl.scaleZ);
	else
		ReplaceReference(ISCALE_Z_REF, NewDefaultFloatController());
	
	curval = ctrl.curval;
	ivalid = ctrl.ivalid;
}

IndeScale::IndeScale(BOOL loading) 
{
	scaleX = NULL;
	scaleY = NULL;
	scaleZ = NULL;
	if (!loading)
	{
		ReplaceReference(ISCALE_X_REF, NewDefaultFloatController());
		ReplaceReference(ISCALE_Y_REF, NewDefaultFloatController());
		ReplaceReference(ISCALE_Z_REF, NewDefaultFloatController());
		ivalid = FOREVER;
		curval = ScaleValue(Point3(1,1,1));
	} else {
		ivalid.SetEmpty();
	}	
}

RefTargetHandle IndeScale::Clone(RemapDir& remap) 
{
	IndeScale *scale = new IndeScale(TRUE);	
	scale->ReplaceReference(ISCALE_X_REF, remap.CloneRef(scaleX));
	scale->ReplaceReference(ISCALE_Y_REF, remap.CloneRef(scaleY));
	scale->ReplaceReference(ISCALE_Z_REF, remap.CloneRef(scaleZ));
	return scale;
}

IndeScale::~IndeScale()
{
	DeleteAllRefsFromMe();
}

void IndeScale::Copy(Control *from)
{
	if (from->ClassID()==ClassID())
	{
		IndeScale *ctrl = (IndeScale*)from;
		ReplaceReference(ISCALE_X_REF, ctrl->scaleX);
		ReplaceReference(ISCALE_Y_REF, ctrl->scaleY);
		ReplaceReference(ISCALE_Z_REF, ctrl->scaleZ);
		curval = ctrl->curval;
		ivalid = ctrl->ivalid;
	} else {		
		ScaleValue v;
		Interval iv;
		int num;		
		if ((num=from->NumKeys())!=NOT_KEYFRAMEABLE && num>0)
		{
			SuspendAnimate();
			AnimateOn();
			for (int i=0; i<num; i++)
			{
				TimeValue t = from->GetKeyTime(i);
				from->GetValue(t,&v,iv);
				SetValue(t,&v,TRUE,CTRL_ABSOLUTE);
			}
			// RB 2/10/99: A key at frame 0 may have been created
			if (num>0 && from->GetKeyTime(0)!=0) {
				scaleX->DeleteKeyAtTime(0);
				scaleY->DeleteKeyAtTime(0);
				scaleZ->DeleteKeyAtTime(0);
			}
			ResumeAnimate();
		} else {
			from->GetValue(0,&v,ivalid);
			SetValue(0,&v,TRUE,CTRL_ABSOLUTE);
		}
	}
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
}

void IndeScale::Update(TimeValue t)
{
	if (!ivalid.InInterval(t))
	{
		ivalid = FOREVER;		
		if (scaleX)
			scaleX->GetValue(t,&curval.s.x,ivalid);
		if (scaleY)
			scaleY->GetValue(t,&curval.s.y,ivalid);
		if (scaleZ)
			scaleZ->GetValue(t,&curval.s.z,ivalid);
		// ------------------------------------------------------------------------
		// ignoring the quaternion here... can't find anyplace in MAX that uses it,
		// could later add a rotation leaf controller for off-axis scaling
		//   -- mjm
		// ------------------------------------------------------------------------
	}
}

void IndeScale::SetValue(TimeValue t, void *val, int commit, GetSetMethod method)
{
	ScaleValue *v = (ScaleValue*)val;

	if (method==CTRL_RELATIVE)
	{
		// ------------------------------------------------------------------------
		// By default, a relative setValue() on an interp float controller does a
		// += instead of *=. Therefore, we have to first get their existing value,
		// manually update (*=), then do an absolute setValue() with the result.
		//   -- mjm
		// ------------------------------------------------------------------------
		float childScale;
		if (scaleX)
		{
			scaleX->GetValue(t,&childScale,FOREVER);
			v->s.x *= childScale;
		}
		if (scaleY)
		{
			scaleY->GetValue(t,&childScale,FOREVER);
			v->s.y *= childScale;
		}
		if (scaleZ)
		{
			scaleZ->GetValue(t,&childScale,FOREVER);
			v->s.z *= childScale;
		}
		method = CTRL_ABSOLUTE;
	}

	if (scaleX)
		scaleX->SetValue(t,&v->s.x,commit,method);
	if (scaleY)
		scaleY->SetValue(t,&v->s.y,commit,method);
	if (scaleZ)
		scaleZ->SetValue(t,&v->s.z,commit,method);
	// ------------------------------------------------------------------------
	// ignoring the quaternion here... can't find anyplace in MAX that uses it,
	// could later add a rotation leaf controller for off-axis scaling
	//   -- mjm
	// ------------------------------------------------------------------------

	ivalid.SetEmpty();
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
}

void IndeScale::GetValue(TimeValue t, void *val, Interval &valid, GetSetMethod method)
{		
	Update(t);
	valid &= ivalid;			 
	if (method==CTRL_RELATIVE)
	{
  		Matrix3 *mat = (Matrix3*)val;
		ApplyScaling(*mat,curval);
	} else {
		*((ScaleValue*)val) = curval;
	}
}

void IndeScale::CommitValue(TimeValue t)
{
	if (scaleX)
		scaleX->CommitValue(t);
	if (scaleY)
		scaleY->CommitValue(t);
	if (scaleZ)
		scaleZ->CommitValue(t);
}

void IndeScale::RestoreValue(TimeValue t)
{
	if (scaleX)
		scaleX->RestoreValue(t);
	if (scaleY)
		scaleY->RestoreValue(t);
	if (scaleZ)
		scaleZ->RestoreValue(t);
}

RefTargetHandle IndeScale::GetReference(int i)
{
	switch (i)
	{
	case ISCALE_X_REF:
		return scaleX;
	case ISCALE_Y_REF:
		return scaleY;
	case ISCALE_Z_REF:
		return scaleZ;
	default:
		return NULL;
	}
}

void IndeScale::SetReference(int i, RefTargetHandle rtarg)
{
	switch (i)
	{
	case ISCALE_X_REF:
		scaleX = (Control*)rtarg;
		break;
	case ISCALE_Y_REF:
		scaleY = (Control*)rtarg;
		break;
	case ISCALE_Z_REF:
		scaleZ = (Control*)rtarg;
		break;
	}
}

Animatable* IndeScale::SubAnim(int i)
{
	return GetReference(i);
}

TSTR IndeScale::SubAnimName(int i)
{
	switch (i)
	{
	case ISCALE_X_REF:
		return GetString(IDS_MM_XSCALE);
	case ISCALE_Y_REF:
		return GetString(IDS_MM_YSCALE);
	case ISCALE_Z_REF:
		return GetString(IDS_MM_ZSCALE);
	default:
		return _T("");
	}
}

RefResult IndeScale::NotifyRefChanged( Interval iv, RefTargetHandle hTarg, PartID& partID, RefMessage msg)
{
	switch (msg)
	{
	case REFMSG_CHANGE:
		ivalid.SetEmpty();
		break;
	case REFMSG_TARGET_DELETED:
		if (scaleX == hTarg)
			scaleX = NULL;
		if (scaleY == hTarg)
			scaleY = NULL;
		if (scaleZ == hTarg)
			scaleZ = NULL; 
		break;
	case REFMSG_GET_CONTROL_DIM:
		ParamDimension **dim = (ParamDimension **)partID;
		assert(dim);
		*dim = stdPercentDim;
		break;
	}
	return REF_SUCCEED;
}

BOOL IndeScale::AssignController(Animatable *control,int subAnim)
{
	// ------------------------------------------------------------------------
	// Interp float controllers initialize to 0.
	// For scaling, we must initialize them to 1.
	//   -- mjm
	// ------------------------------------------------------------------------
	if ( control && !((Control *)control)->NumKeys() )
	{
		float ctrlScale;
		((Control *)control)->GetValue(0,&ctrlScale,FOREVER);
		if (ctrlScale == 0.0f)
		{
			ctrlScale = 1.0f;
			((Control *)control)->SetValue(0,&ctrlScale);
		}
	}
	
	switch (subAnim)
	{
	case ISCALE_X_REF:
		ReplaceReference(ISCALE_X_REF,(RefTargetHandle)control);
		break;
	case ISCALE_Y_REF:
		ReplaceReference(ISCALE_Y_REF,(RefTargetHandle)control);
		break;
	case ISCALE_Z_REF:
		ReplaceReference(ISCALE_Z_REF,(RefTargetHandle)control);
		break;
	}

	ivalid.SetEmpty();

	NotifyDependents(FOREVER,0,REFMSG_CONTROLREF_CHANGE,TREE_VIEW_CLASS_ID,FALSE);
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);	
	return TRUE;
}

void IndeScale::AddNewKey(TimeValue t,DWORD flags)
{
	if (scaleX)
		scaleX->AddNewKey(t,flags);
	if (scaleY)
		scaleY->AddNewKey(t,flags);
	if (scaleZ)
		scaleZ->AddNewKey(t,flags);
}

int IndeScale::NumKeys()
{
	int num = 0;
	if (scaleX)
		num += scaleX->NumKeys(); 
	if (scaleY)
		num += scaleY->NumKeys();
	if (scaleZ)
		num += scaleZ->NumKeys();
	return num;
}

TimeValue IndeScale::GetKeyTime(int index)
{
	int onum,num = 0;
	if (scaleX)
		num += scaleX->NumKeys(); 
	if (index < num)
		return scaleX->GetKeyTime(index);

	onum = num;
	if (scaleY)
		num += scaleY->NumKeys(); 
	if (index < num)
		return scaleY->GetKeyTime(index-onum);

	onum = num;
	if (scaleZ)
		num += scaleZ->NumKeys(); 
	if (index < num)
		return scaleZ->GetKeyTime(index-onum);

	return 0;
}

void IndeScale::CopyKeysFromTime(TimeValue src,TimeValue dst,DWORD flags)
{
	if (scaleX)
		scaleX->CopyKeysFromTime(src,dst,flags);
	if (scaleY)
		scaleY->CopyKeysFromTime(src,dst,flags);
	if (scaleZ)
		scaleZ->CopyKeysFromTime(src,dst,flags);
}

BOOL IndeScale::IsKeyAtTime(TimeValue t,DWORD flags)
{
	if (scaleX && scaleX->IsKeyAtTime(t,flags))
		return TRUE;
	if (scaleY && scaleY->IsKeyAtTime(t,flags))
		return TRUE;
	if (scaleZ && scaleZ->IsKeyAtTime(t,flags))
		return TRUE;
	return FALSE;
}

void IndeScale::DeleteKeyAtTime(TimeValue t)
{
	if (scaleX)
		scaleX->DeleteKeyAtTime(t);
	if (scaleY)
		scaleY->DeleteKeyAtTime(t);
	if (scaleZ)
		scaleZ->DeleteKeyAtTime(t);
}

BOOL IndeScale::GetNextKeyTime(TimeValue t,DWORD flags,TimeValue &nt)
{
	TimeValue at,tnear = 0;
	BOOL tnearInit = FALSE;
	
	if (scaleX && scaleX->GetNextKeyTime(t,flags,at))
	{
		if (!tnearInit)
		{
			tnear = at;
			tnearInit = TRUE;
		} else if ( ABS(at-t) < ABS(tnear-t) ) {
			tnear = at;
		}
	}

	if (scaleY && scaleY->GetNextKeyTime(t,flags,at))
	{
		if (!tnearInit)
		{
			tnear = at;
			tnearInit = TRUE;
		} else if ( ABS(at-t) < ABS(tnear-t) ) {
			tnear = at;
		}
	}

	if (scaleZ && scaleZ->GetNextKeyTime(t,flags,at))
	{
		if (!tnearInit)
		{
			tnear = at;
			tnearInit = TRUE;
		} else if ( ABS(at-t) < ABS(tnear-t) ) {
			tnear = at;
		}
	}
	
	if (tnearInit)
	{
		nt = tnear;
		return TRUE;
	} else {
		return FALSE;
	}
}
		

void IndeScale::BeginEditParams(IObjParam *ip, ULONG flags,Animatable *prev)
{	
	this->ip = ip;

	if (dlg)
		dlg->BeginingEdit(this,ip,(IndeScale*)prev);
	else
		dlg = new IScaleDlg(this,ip);
}

void IndeScale::EndEditParams(IObjParam *ip, ULONG flags,Animatable *next)
{	
	IndeScale *cont=NULL;
	if ( next && next->ClassID()==ClassID() )
		cont = (IndeScale*)next;

	if (dlg)
	{
		if (cont)
		{
			dlg->EndingEdit(cont);
		} else {
			delete dlg;
			dlg = NULL;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Control\lodctrl.cpp ===
/**********************************************************************
 *<
	FILE: lodctrl.cpp

	DESCRIPTION: A level of detail controller

	CREATED BY: Rolf Berteig

	HISTORY: 4/12/97

 *>	Copyright (c) 1997, All Rights Reserved.
 **********************************************************************/
#include "ctrl.h"
#include "units.h"
#include "utilapi.h"

#define LOD_CONTROL_CLASS_ID	Class_ID(0xbbe961a8,0xa0ee7b7f)
#define LOD_CONTROL_CNAME		GetString(IDS_RB_LODCONTROL)

#define LOD_UTILITY_CLASS_ID	Class_ID(0x100d37ef,0x1aa0ab84)
#define LOD_UTILITY_CNAME		GetString(IDS_RB_LODUTILITU)

class LODCtrl : public StdControl {
	public:
		float min, max, bmin, bmax;
		WORD grpID;
		int order;
		BOOL viewport, highest;

		LODCtrl();

		// Animatable methods		
		void DeleteThis() {delete this;}		
		int IsKeyable() {return 0;}		
		Class_ID ClassID() {return LOD_CONTROL_CLASS_ID;} 
		SClass_ID SuperClassID() {return CTRL_FLOAT_CLASS_ID;}
		void GetClassName(TSTR& s) {s = LOD_CONTROL_CNAME;}
		BOOL CanCopyAnim() {return FALSE;}
		BOOL CanMakeUnique() {return FALSE;}		

		// Reference methods
		RefResult NotifyRefChanged(Interval, RefTargetHandle, PartID&, RefMessage) {return REF_SUCCEED;}
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);
		RefTargetHandle Clone(RemapDir &remap = NoRemap());

		// Control methods				
		void Copy(Control *from) {}
		BOOL IsLeaf() {return TRUE;}
		void CommitValue(TimeValue t) {}
		void RestoreValue(TimeValue t) {}
		BOOL IsReplaceable() {return FALSE;}
		BOOL CanInstanceController() {return FALSE;}

		// StdControl methods
		void GetValueLocalTime(TimeValue t, void *val, Interval &valid, GetSetMethod method=CTRL_ABSOLUTE)
			{*((float*)val) = 1.0f;}
		void SetValueLocalTime(TimeValue t, void *val, int commit, GetSetMethod method) {}
		void Extrapolate(Interval range,TimeValue t,void *val,Interval &valid,int type)
			{*((float*)val) = 1.0f;}
		void *CreateTempValue() {return new float;}
		void DeleteTempValue(void *val) {delete (float*)val;}
		void ApplyValue(void *val, void *delta) {*((float*)val) += *((float*)delta);}
		void MultiplyValue(void *val, float m) {*((float*)val) *= m;}

		float EvalVisibility(TimeValue t,View &view,Box3 pbox,Interval &valid);
		BOOL VisibleInViewports();
	};

class LODUtil : 
			public UtilityObj, 
			public PickModeCallback, 
			public PickNodeCallback {
	public:
		IUtil *iu;
		Interface *ip;		
		HWND hWnd;
		INodeTab nodes;
		int disp;

		// From UtilityObj		
		void BeginEditParams(Interface *ip,IUtil *iu);
		void EndEditParams(Interface *ip,IUtil *iu);
		void DeleteThis() {}
		void SelectionSetChanged(Interface *ip,IUtil *iu);		

		// From PickModeCallback
		BOOL HitTest(IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags);
		BOOL Pick(IObjParam *ip,ViewExp *vpt);
		BOOL RightClick(IObjParam *ip,ViewExp *vpt) {return TRUE;}
		void EnterMode(IObjParam *ip);
		void ExitMode(IObjParam *ip);
		PickNodeCallback *GetFilter() {return this;}
		BOOL AllowMultiSelect() {return TRUE;}
		BOOL Filter(INode *node);

		// Local methods
		LODUtil();
		void FindGroupMembers(INode *root,WORD id,INodeTab &nodes);
		WORD FindUniqueGroupID();
		INode *FindSelGroupHead();
		int GetSelID();
		void SetStates();
		void SetupList();
		void ListSelChanged();
		void CreateNewSet();
		void ResetSet();
		void ResetOutput();
		void SetViewportObj(BOOL onOff);
		void DeleteFromSet();
		void SetMin(float m);
		void SetMax(float m);
		void SetBlendRegions();
		float ConvertToPercent(float size);
		float ConvertFromPercent(float perc);
		void SetDisplayMode(int mode);
		void InitDlg();
	};
static LODUtil theLODUtil;

class LODClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 0;}
	void *			Create(BOOL loading) {return new LODCtrl();}
	const TCHAR *	ClassName() {return LOD_CONTROL_CNAME;}
	SClass_ID		SuperClassID() {return CTRL_FLOAT_CLASS_ID; }
	Class_ID		ClassID() {return LOD_CONTROL_CLASS_ID;}
	const TCHAR* 	Category() {return _T("");}
	};
static LODClassDesc lodCD;
ClassDesc* GetLODControlDesc() {return &lodCD;}

class LODUtilClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) {return &theLODUtil;}
	const TCHAR *	ClassName() {return LOD_UTILITY_CNAME;}
	SClass_ID		SuperClassID() {return UTILITY_CLASS_ID;}
	Class_ID		ClassID() {return LOD_UTILITY_CLASS_ID;}
	const TCHAR* 	Category() {return _T("");}
	};

static LODUtilClassDesc lodUtilDesc;
ClassDesc* GetLODUtilDesc() {return &lodUtilDesc;}


//--- LODCtrl --------------------------------------------------------

LODCtrl::LODCtrl()
	{
	bmin = min = 0.0f;
	bmax = max = 0.0f;
	grpID = 0;
	order = 0;
	viewport = FALSE;
	highest  = FALSE;
	}

#define MIN_CHUNK		0x0100
#define MAX_CHUNK		0x0110
#define BMIN_CHUNK		0x0112
#define BMAX_CHUNK		0x0115
#define GROUPID_CHUNK	0x0120
#define ORDER_CHUNK		0x0130
#define VIEWPORT_CHUNK	0x0140
#define HIGHEST_CHUNK	0x0150

IOResult LODCtrl::Save(ISave *isave)
	{
	ULONG nb;

	isave->BeginChunk(MIN_CHUNK);
	isave->Write(&min,sizeof(min),&nb);
	isave->EndChunk();

	isave->BeginChunk(MAX_CHUNK);
	isave->Write(&max,sizeof(max),&nb);
	isave->EndChunk();

	isave->BeginChunk(BMIN_CHUNK);
	isave->Write(&bmin,sizeof(bmin),&nb);
	isave->EndChunk();

	isave->BeginChunk(BMAX_CHUNK);
	isave->Write(&bmax,sizeof(bmax),&nb);
	isave->EndChunk();

	isave->BeginChunk(GROUPID_CHUNK);
	isave->Write(&grpID,sizeof(grpID),&nb);
	isave->EndChunk();

	isave->BeginChunk(ORDER_CHUNK);
	isave->Write(&order,sizeof(order),&nb);
	isave->EndChunk();

	isave->BeginChunk(VIEWPORT_CHUNK);
	isave->Write(&viewport,sizeof(viewport),&nb);
	isave->EndChunk();

	isave->BeginChunk(HIGHEST_CHUNK);
	isave->Write(&highest,sizeof(highest),&nb);
	isave->EndChunk();

	return IO_OK;
	}

IOResult LODCtrl::Load(ILoad *iload)
	{
	ULONG nb;
	IOResult res;
	
	while (IO_OK==(res=iload->OpenChunk())) {
		switch (iload->CurChunkID()) {	
			case MIN_CHUNK:
				iload->Read(&min,sizeof(min),&nb);
				break;

			case MAX_CHUNK:
				iload->Read(&max,sizeof(max),&nb);
				break;

			case BMIN_CHUNK:
				iload->Read(&bmin,sizeof(bmin),&nb);
				break;

			case BMAX_CHUNK:
				iload->Read(&bmax,sizeof(bmax),&nb);
				break;

			case GROUPID_CHUNK:
				iload->Read(&grpID,sizeof(grpID),&nb);
				break;

			case ORDER_CHUNK:
				iload->Read(&order,sizeof(order),&nb);
				break;

			case VIEWPORT_CHUNK:
				iload->Read(&viewport,sizeof(viewport),&nb);
				break;

			case HIGHEST_CHUNK:
				iload->Read(&highest,sizeof(highest),&nb);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK)  return res;
		}
	return IO_OK;
	}

RefTargetHandle LODCtrl::Clone(RemapDir &remap)
	{
	Control *cont = NewDefaultFloatController();
	float val = 1.0f;
	cont->SetValue(0,&val);
	return cont;
	}

float LODCtrl::EvalVisibility(
		TimeValue t,View &view,Box3 pbox,Interval &valid)
	{	
	float xmin, xmax, ymin, ymax;	
	for (int i=0; i<8; i++) {
		Point2 pt = view.ViewToScreen(pbox[i]*view.worldToView);
		if (!i) {
			xmin = xmax = pt.x;
			ymin = ymax = pt.y;
		} else {
			if (pt.x<xmin) xmin = pt.x;
			if (pt.x>xmax) xmax = pt.x;
			if (pt.y<ymin) ymin = pt.y;
			if (pt.y>ymax) ymax = pt.y;
			}
		}
	float w = xmax-xmin;
	float h = ymax-ymin;
	float size = (float)sqrt((w*w) + (h*h));
	if (highest && size>=min) return 1.0f;
	if (size>=min && size<=max) return 1.0f;	
	if (size<min && size>bmin) {
		return 1.0f - (min-size)/(min-bmin);
		}
	if (size>max && size<bmax) {
		return 1.0f - (size-max)/(bmax-max);
		}
	return 0.0f;
	}

BOOL LODCtrl::VisibleInViewports()
	{
	return viewport;
	}

//--- LODUtil --------------------------------------------------------

static BOOL CALLBACK LODUtilDlgProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

#define NODESEL_LODANDNONLOD	-4
#define NODESEL_LODMIX			-3
#define NODESEL_NONLOD			-2
#define NODESEL_NONE			-1


LODUtil::LODUtil()
	{
	iu   = NULL;
	ip   = NULL;
	hWnd = NULL;
	disp = IDC_LOD_DISPPERCENT;
	}

void LODUtil::BeginEditParams(Interface *ip,IUtil *iu)
	{
	this->iu = iu;
	this->ip = ip;
	hWnd = ip->AddRollupPage(
		hInstance,
		MAKEINTRESOURCE(IDD_LOD_UTILPARAMS),
		LODUtilDlgProc,
		GetString(IDS_RB_LODUTILITU),
		0);
	}

void LODUtil::EndEditParams(Interface *ip,IUtil *iu)
	{
	ip->ClearPickMode();
	ip->DeleteRollupPage(hWnd);	
	this->iu = NULL;
	this->ip = NULL;	
	}

void LODUtil::SelectionSetChanged(Interface *ip,IUtil *iu)
	{
	SetStates();
	}


static int __cdecl CompareNodes(const void *elem1, const void *elem2)
	{
	INode *node1 = *((INode**)elem1);
	INode *node2 = *((INode**)elem2);
	LODCtrl *cont1 = (LODCtrl*)node1->GetVisController();
	LODCtrl *cont2 = (LODCtrl*)node2->GetVisController();
	if (!cont1 || !cont2) return 0;
	return cont1->order-cont2->order;
	}

#define BLEND_PERCENT	0.2f

void LODUtil::InitDlg()
	{
	ISpinnerControl *iW = GetISpinner(GetDlgItem(hWnd,IDC_LOD_VIEWWIDTHSPIN));
	ISpinnerControl *iH = GetISpinner(GetDlgItem(hWnd,IDC_LOD_VIEWHEIGHTSPIN));

	iW->SetLimits(1.0f,99999999.0f,FALSE);
	iW->SetScale(0.1f);
	iW->LinkToEdit(GetDlgItem(hWnd,IDC_LOD_VIEWWIDTH),EDITTYPE_INT);	
	iW->SetValue(ip->GetRendWidth(),FALSE);
	iH->SetLimits(1.0f,99999999.0f,FALSE);
	iH->SetScale(0.1f);
	iH->LinkToEdit(GetDlgItem(hWnd,IDC_LOD_VIEWHEIGHT),EDITTYPE_INT);	
	iH->SetValue(ip->GetRendHeight(),FALSE);

	ReleaseISpinner(iW);
	ReleaseISpinner(iH);
	}

void LODUtil::ResetOutput()
	{
	ISpinnerControl *iW = GetISpinner(GetDlgItem(hWnd,IDC_LOD_VIEWWIDTHSPIN));
	ISpinnerControl *iH = GetISpinner(GetDlgItem(hWnd,IDC_LOD_VIEWHEIGHTSPIN));
	iW->SetValue(ip->GetRendWidth(),FALSE);
	iH->SetValue(ip->GetRendHeight(),FALSE);
	ReleaseISpinner(iW);
	ReleaseISpinner(iH);
	SetupList();
	ListSelChanged();
	}

void LODUtil::SetStates()
	{	
	int id = GetSelID();

	ISpinnerControl *iMin = GetISpinner(GetDlgItem(hWnd,IDC_LOD_MINSPIN));
	ISpinnerControl *iMax = GetISpinner(GetDlgItem(hWnd,IDC_LOD_MAXSPIN));	

	iMin->SetLimits(0.0f,99999999.0f,FALSE);
	iMin->SetScale(0.1f);
	iMin->LinkToEdit(GetDlgItem(hWnd,IDC_LOD_MIN),EDITTYPE_FLOAT);	
	iMax->SetLimits(0.0f,99999999.0f,FALSE);
	iMax->SetScale(0.1f);
	iMax->LinkToEdit(GetDlgItem(hWnd,IDC_LOD_MAX),EDITTYPE_FLOAT);	
	
	ReleaseISpinner(iMin);
	ReleaseISpinner(iMax);	

	SendDlgItemMessage(hWnd,IDC_LOD_LIST,LB_RESETCONTENT,0,0);

	nodes.SetCount(0);
	if (id>=0) {		
		LODCtrl *cont;
		LODCtrl *cprev=NULL;		
		FindGroupMembers(ip->GetRootNode(),(WORD)id,nodes);
		nodes.Sort(CompareNodes);
		for (int i=0; i<nodes.Count(); i++) {
			cont = (LODCtrl*)nodes[i]->GetVisController();
			if (!cont) {
				return;
				}
			
			if (cprev) {
				cont->min   = cprev->max;
				cont->order = cprev->order+1;
				if (cont->max<cont->min) cont->max = cont->min;
				cont->bmin = cont->min - (cprev->max-cprev->min)*BLEND_PERCENT;
			} else {
				cont->min   = 0;
				cont->bmin  = 0;
				cont->order	= 0;
				}
			if (i<nodes.Count()-1) {
				LODCtrl*cnext = (LODCtrl*)nodes[i+1]->GetVisController();
				if (!cnext) return;
				cont->bmax = cont->max + (cnext->max-cnext->min)*BLEND_PERCENT;
				cont->highest = FALSE;
			} else {
				cont->bmax = cont->max + (cont->max-cont->min)*BLEND_PERCENT;
				cont->highest = TRUE;
				}
			cprev = cont;
			}
		SetupList();
		ICustButton *but;
		but = GetICustButton(GetDlgItem(hWnd,IDC_LOD_ADDTOSET));
		but->SetType(CBT_CHECK);
		but->SetHighlightColor(GREEN_WASH);
		but->Enable();
		ReleaseICustButton(but);		
		EnableWindow(GetDlgItem(hWnd,IDC_LOD_RESET),TRUE);
		EnableWindow(GetDlgItem(hWnd,IDC_LOD_DISPPIXELS),TRUE);
		EnableWindow(GetDlgItem(hWnd,IDC_LOD_DISPPERCENT),TRUE);
		CheckDlgButton(hWnd,disp,TRUE);
		but = GetICustButton(GetDlgItem(hWnd,IDC_LOD_CREATENEWSET));
		but->Disable();
		ReleaseICustButton(but);
	} else {
		EnableWindow(GetDlgItem(hWnd,IDC_LOD_DISPPIXELS),FALSE);
		EnableWindow(GetDlgItem(hWnd,IDC_LOD_DISPPERCENT),FALSE);
		EnableWindow(GetDlgItem(hWnd,IDC_LOD_RESET),FALSE);
		ICustButton *but;
		but = GetICustButton(GetDlgItem(hWnd,IDC_LOD_ADDTOSET));
		but->Disable();
		but->SetCheck(FALSE);
		ip->ClearPickMode();
		ReleaseICustButton(but);		
		but = GetICustButton(GetDlgItem(hWnd,IDC_LOD_CREATENEWSET));
		if (id==NODESEL_NONLOD) {
			but->Enable();
		} else {
			but->Disable();
			}
		ReleaseICustButton(but);
		}
	ListSelChanged();
	}

float LODUtil::ConvertToPercent(float size)
	{
	ISpinnerControl *iW = GetISpinner(GetDlgItem(hWnd,IDC_LOD_VIEWWIDTHSPIN));
	ISpinnerControl *iH = GetISpinner(GetDlgItem(hWnd,IDC_LOD_VIEWHEIGHTSPIN));
	int w = iW->GetIVal();
	int h = iH->GetIVal();
	ReleaseISpinner(iW);
	ReleaseISpinner(iH);
	float screen = (float)sqrt(float(w*w)+float(h*h));
	return size/screen * 100.0f;
	}

float LODUtil::ConvertFromPercent(float perc)
	{
	ISpinnerControl *iW = GetISpinner(GetDlgItem(hWnd,IDC_LOD_VIEWWIDTHSPIN));
	ISpinnerControl *iH = GetISpinner(GetDlgItem(hWnd,IDC_LOD_VIEWHEIGHTSPIN));
	int w = iW->GetIVal();
	int h = iH->GetIVal();
	ReleaseISpinner(iW);
	ReleaseISpinner(iH);
	float screen = (float)sqrt(float(w*w)+float(h*h));
	return screen*perc/100.0f;
	}

void LODUtil::SetupList()
	{
	LODCtrl *cont;	
	int sel = SendDlgItemMessage(hWnd,IDC_LOD_LIST,LB_GETCURSEL,0,0);
	SendDlgItemMessage(hWnd,IDC_LOD_LIST,LB_RESETCONTENT,0,0);
	for (int i=0; i<nodes.Count(); i++) {
		cont = (LODCtrl*)nodes[i]->GetVisController();
		if (!cont) continue;
		TSTR buf;
		float val = cont->max;
		if (disp==IDC_LOD_DISPPERCENT) {
			val = ConvertToPercent(val);
			}
		buf.printf(_T("%.1f\t%s"),val,nodes[i]->GetName());
		SendDlgItemMessage(hWnd,IDC_LOD_LIST,LB_ADDSTRING,0,
			(LPARAM)(TCHAR*)buf);		
		}
	if (sel!=LB_ERR) {
		SendDlgItemMessage(hWnd,IDC_LOD_LIST,LB_SETCURSEL,sel,0);
		}
	}

void LODUtil::SetDisplayMode(int mode)
	{
	disp = mode;
	SetupList();
	ListSelChanged();
	}

void LODUtil::ListSelChanged()
	{
	ICustButton *but;

	int sel = SendDlgItemMessage(hWnd,IDC_LOD_LIST,LB_GETCURSEL,0,0);
	ISpinnerControl *iMin = GetISpinner(GetDlgItem(hWnd,IDC_LOD_MINSPIN));
	ISpinnerControl *iMax = GetISpinner(GetDlgItem(hWnd,IDC_LOD_MAXSPIN));	
	
	if (sel==LB_ERR) {
		iMin->Disable();
		iMin->SetValue(0.0f,FALSE);
		iMax->Disable();
		iMax->SetValue(0.0f,FALSE);
		EnableWindow(GetDlgItem(hWnd,IDC_LOD_MINLABEL),FALSE);
		EnableWindow(GetDlgItem(hWnd,IDC_LOD_MAXLABEL),FALSE);		
		EnableWindow(GetDlgItem(hWnd,IDC_LOD_VIEWPORTOBJ),FALSE);
		but = GetICustButton(GetDlgItem(hWnd,IDC_LOD_DELETEFROMSET));
		but->Disable();
		ReleaseICustButton(but);
	} else {
		iMin->Enable();		
		iMax->Enable();		
		EnableWindow(GetDlgItem(hWnd,IDC_LOD_MINLABEL),TRUE);
		EnableWindow(GetDlgItem(hWnd,IDC_LOD_MAXLABEL),TRUE);		
		EnableWindow(GetDlgItem(hWnd,IDC_LOD_VIEWPORTOBJ),TRUE);
		but = GetICustButton(GetDlgItem(hWnd,IDC_LOD_DELETEFROMSET));
		but->Enable();
		ReleaseICustButton(but);

		LODCtrl *cont = (LODCtrl*)nodes[sel]->GetVisController();
		if (cont) {
		
			if (disp==IDC_LOD_DISPPERCENT) {
				iMin->SetValue(ConvertToPercent(cont->min),FALSE);
				iMax->SetValue(ConvertToPercent(cont->max),FALSE);
			} else {
				iMin->SetValue(cont->min,FALSE);
				iMax->SetValue(cont->max,FALSE);
				}
			CheckDlgButton(hWnd,IDC_LOD_VIEWPORTOBJ,cont->viewport);
			}
		}

	ReleaseISpinner(iMin);
	ReleaseISpinner(iMax);
	}

void LODUtil::FindGroupMembers(INode *root,WORD id,INodeTab &nodes)
	{
	for (int i=0; i<root->NumberOfChildren(); i++) {
		INode *node = root->GetChildNode(i);		
		Control *cont = node->GetVisController();
		if (cont && cont->ClassID()==LOD_CONTROL_CLASS_ID) {
			LODCtrl *lcont = (LODCtrl*)cont;
			if (lcont->grpID==id) {
				nodes.Append(1,&node,10);
				}
			}			
		FindGroupMembers(node,id,nodes);
		}	
	}

static BOOL IsAncestorSelected(INode *node)
	{
	if (node->GetParentNode()) {		
		if (node->GetParentNode()->Selected()) return TRUE;
		return IsAncestorSelected(node->GetParentNode());
	} else {
		return FALSE;
		}
	}

int LODUtil::GetSelID()
	{
	int id = -1;
	BOOL gotLOD=FALSE, gotNonLOD=FALSE; 

	if (!ip->GetSelNodeCount()) return NODESEL_NONE;

	INode *grpHead = FindSelGroupHead();

	for (int i=0; i<ip->GetSelNodeCount(); i++) {
		if (ip->GetSelNode(i)==grpHead) continue;
		if (IsAncestorSelected(ip->GetSelNode(i)->GetParentNode())) continue;

		Control *cont = ip->GetSelNode(i)->GetVisController();
		if (cont && cont->ClassID()==LOD_CONTROL_CLASS_ID) {
			LODCtrl *lcont = (LODCtrl*)cont;
			gotLOD = TRUE;
			if (id==-1) id = lcont->grpID;
			else if (id!=lcont->grpID) id = -2;				
		} else {
			gotNonLOD = TRUE;
			}
		}

	//if (gotNonLOD && gotLOD)  return NODESEL_LODANDNONLOD;
	if (gotLOD && id<0)       return NODESEL_LODMIX;
	if (gotNonLOD && !gotLOD) return NODESEL_NONLOD;

	return id;
	}

class NodeSize {
	public:
	INode *node; int faces;
	NodeSize() {node=NULL;faces=0;}
	NodeSize(INode *n,TimeValue t);
	void CountFaces(INode *node,TimeValue t);
	};

class NullView: public View {
	public:
		Point2 ViewToScreen(Point3 p) { return Point2(p.x,p.y); }
		NullView() { worldToView.IdentityMatrix(); screenW=640.0f; screenH = 480.0f; }
	};

NodeSize::NodeSize(INode *n,TimeValue t)
	{
	node  = n;
	faces = 0;
	CountFaces(node,t);
	}

void NodeSize::CountFaces(INode *node,TimeValue t)
	{
	ObjectState os = node->EvalWorldState(t,TRUE);
	BOOL needDelete = FALSE;
	NullView view;
	if (os.obj->SuperClassID()==GEOMOBJECT_CLASS_ID) {
		GeomObject *obj = (GeomObject*)os.obj;
		Mesh *mesh = obj->GetRenderMesh(t, node, view, needDelete);
		if (mesh) faces += mesh->getNumFaces();
		if (needDelete) delete mesh;		
		}
	for (int i=0; i<node->NumberOfChildren(); i++) {
		CountFaces(node->GetChildNode(i),t);
		}
	}

static int __cdecl CompareNodeSize(const void *elem1, const void *elem2)
	{
	NodeSize *ns1 = (NodeSize*)elem1;
	NodeSize *ns2 = (NodeSize*)elem2;
	return ns1->faces - ns2->faces;	
	}

static void CheckIDs(INode *root,BitArray &used)
	{	
	Control *cont = (Control*)root->GetVisController();	
	if (cont && cont->ClassID()==LOD_CONTROL_CLASS_ID) {
		LODCtrl *lcont = (LODCtrl*)cont;
		used.Set(lcont->grpID);
		}
	for (int i=0; i<root->NumberOfChildren(); i++) {
		CheckIDs(root->GetChildNode(i),used);		
		}
	}

WORD LODUtil::FindUniqueGroupID()
	{
	BitArray used;
	used.SetSize(65536);
	CheckIDs(ip->GetRootNode(),used);
	for (int i=0; i<used.GetSize(); i++) {
		if (!used[i]) return (WORD)i;
		}	
	return 65535;
	}

INode *LODUtil::FindSelGroupHead()
	{
	INode *grpHead = NULL;
	for (int i=0; i<ip->GetSelNodeCount(); i++) {
		if (IsAncestorSelected(ip->GetSelNode(i)->GetParentNode())) continue;
		INode *node = ip->GetSelNode(i);
		if (node->IsGroupHead()) {
			BOOL res = TRUE;
			for (int j=0; j<ip->GetSelNodeCount(); j++) {
				if (i==j) continue;
				if (IsAncestorSelected(ip->GetSelNode(j)->GetParentNode())) continue;
				INode *cnode = ip->GetSelNode(j);
				if (cnode->GetParentNode()!=node) {
					res = FALSE;
					break;
					}
				}
			if (res) {
				grpHead = node;
				break;
				}
			}
		}
	return grpHead;
	}

static void SetInheritVis(INode *node)
	{
	node->SetInheritVisibility(TRUE);
	for (int i=0; i<node->NumberOfChildren(); i++) {	
		SetInheritVis(node->GetChildNode(i));
		}
	}

void LODUtil::CreateNewSet()
	{
	// See if one of the selected objects is the group head of the
	// rest of the selected objects
	INode *grpHead = FindSelGroupHead();	

	if (!grpHead) {
		TSTR buf2(GetString(IDS_RB_LODUTILITU));
		TSTR buf1(GetString(IDS_RB_LODSAMEPARENT));
		MessageBox(hWnd,buf1,buf2,MB_ICONSTOP);
		return;
		}	

	// Turn on visibility inheritance
	SetInheritVis(grpHead);

	// Build a sorted list of nodes along with their sizes
	Tab<NodeSize> nodesizes;
	for (int i=0; i<ip->GetSelNodeCount(); i++) {
		if (ip->GetSelNode(i)==grpHead) continue;
		if (IsAncestorSelected(ip->GetSelNode(i)->GetParentNode())) continue;

		NodeSize ns(ip->GetSelNode(i),ip->GetTime());
		nodesizes.Append(1,&ns,10);
		}	
	nodesizes.Sort(CompareNodeSize);
	
	// Assign LOD controllers	
	WORD grpID = FindUniqueGroupID();
	if (grpID==65535) return;

	int ct = nodesizes.Count();
	for (i=0; i<ct; i++) {
		LODCtrl *cont = new LODCtrl;		
		cont->grpID    = grpID;
		cont->order    = i;
		cont->viewport = i==0;
		nodesizes[i].node->SetVisController(cont);
		}

	SetStates();
	ResetSet();
	ip->RedrawViews(ip->GetTime());
	}

void LODUtil::ResetSet()
	{
	// Compute the target screen size
	ISpinnerControl *iW = GetISpinner(GetDlgItem(hWnd,IDC_LOD_VIEWWIDTHSPIN));
	ISpinnerControl *iH = GetISpinner(GetDlgItem(hWnd,IDC_LOD_VIEWHEIGHTSPIN));
	int w = iW->GetIVal();
	int h = iH->GetIVal();
	ReleaseISpinner(iW);
	ReleaseISpinner(iH);
	float size = (float)sqrt(float(w*w)+float(h*h));

	Tab<NodeSize> nodesizes;
	for (int i=0; i<nodes.Count(); i++) {		
		NodeSize ns(nodes[i],ip->GetTime());
		nodesizes.Append(1,&ns,10);
		}
	nodesizes.Sort(CompareNodeSize);
	for (i=0; i<nodesizes.Count(); i++) {
		nodes[i] = nodesizes[i].node;
		}

	float maxFaces = float(nodesizes[nodesizes.Count()-1].faces);	
	maxFaces = float(sqrt(maxFaces));

	// Reset LOD controllers		
	int ct = nodes.Count();	
	float prev = 0.0f;
	for (i=0; i<ct; i++) {		
		LODCtrl *cont  = (LODCtrl*)nodes[i]->GetVisController();
		if (!cont) continue;		
		cont->order = i;
		cont->min   = prev;
		cont->max   = (float)sqrt(float(nodesizes[i].faces))/maxFaces * size;
		prev = cont->max;		
		}
	SetBlendRegions();
	SetStates();
	}

void LODUtil::SetBlendRegions()
	{
	int ct = nodes.Count();	
	for (int i=0; i<ct; i++) {		
		LODCtrl *cont  = (LODCtrl*)nodes[i]->GetVisController();
		LODCtrl *cprev  = NULL;
		LODCtrl *cnext = NULL;
		if (!cont) continue;
		
		if (i) cprev = (LODCtrl*)nodes[i-1]->GetVisController();
		if (i<ct-1) cnext = (LODCtrl*)nodes[i+1]->GetVisController();

		if (cprev) {
			cont->bmin = cont->min - (cprev->max-cprev->min)*BLEND_PERCENT;
		} else {
			cont->bmin = 0.0f;
			}
		if (cnext) {
			cont->bmax = cont->max + (cnext->max-cnext->min)*BLEND_PERCENT;
		} else {
			cont->bmax = cont->max + (cont->max-cont->min)*BLEND_PERCENT;
			}		
		}
	}

void LODUtil::SetViewportObj(BOOL onOff)
	{
	int sel = SendDlgItemMessage(hWnd,IDC_LOD_LIST,LB_GETCURSEL,0,0);
	if (sel==LB_ERR) return;
	LODCtrl *cont = (LODCtrl*)nodes[sel]->GetVisController();
	if (!cont) return;

	for (int i=0; i<nodes.Count(); i++) {		
		LODCtrl *cnt = (LODCtrl*)nodes[i]->GetVisController();
		if (!cnt) continue;
		cnt->viewport = FALSE;
		cnt->NotifyDependents(FOREVER,PART_HIDESTATE,REFMSG_CHANGE);
		cnt->NotifyDependents(FOREVER,0,REFMSG_SUBANIM_STRUCTURE_CHANGED);
		}
	cont->viewport = TRUE;
	cont->NotifyDependents(FOREVER,PART_HIDESTATE,REFMSG_CHANGE);

	ListSelChanged();
	ip->RedrawViews(ip->GetTime());
	}

void LODUtil::DeleteFromSet()
	{
	int sel = SendDlgItemMessage(hWnd,IDC_LOD_LIST,LB_GETCURSEL,0,0);
	if (sel==LB_ERR) return;
	
	// If this was the viewport object, pick another viewport object
	LODCtrl *cont = (LODCtrl*)nodes[sel]->GetVisController();
	if (cont && cont->viewport) {
		int next = sel+1;
		if (next>=nodes.Count()) next = 0;		
		LODCtrl *cnt = (LODCtrl*)nodes[next]->GetVisController();
		if (cnt) {
			cnt->viewport = TRUE;
			cnt->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
			cnt->NotifyDependents(FOREVER,PART_ALL,REFMSG_SUBANIM_STRUCTURE_CHANGED);		
			}
		}
	nodes[sel]->SetVisController(NULL);	
	SetStates();
	ip->RedrawViews(ip->GetTime());
	}

void LODUtil::SetMin(float m)
	{
	int sel = SendDlgItemMessage(hWnd,IDC_LOD_LIST,LB_GETCURSEL,0,0);
	if (sel==LB_ERR) return;
	LODCtrl *cont = (LODCtrl*)nodes[sel]->GetVisController();
	if (!cont) return;
	
	if (disp==IDC_LOD_DISPPERCENT) 
		m = ConvertFromPercent(m);
	cont->min = m;

	// Propogate down
	float min = m;
	for (int i=sel-1; i>=0; i--) {
		LODCtrl *cnt = (LODCtrl*)nodes[i]->GetVisController();
		if (!cnt) continue;
		cnt->max = min;
		if (cnt->min > cnt->max) cnt->min = cnt->max;
		min = cnt->min;
		}

	// Propogate up
	if (cont->max < cont->min) {
		cont->max = cont->min;
		float max = cont->min;
		for (int i=sel+1; i<nodes.Count(); i++) {
			LODCtrl *cnt = (LODCtrl*)nodes[i]->GetVisController();
			if (!cnt) continue;
			cnt->min = max;
			if (cnt->max < cnt->min) cnt->max = cnt->min;
			max = cnt->max;
			}
		}

	SetBlendRegions();
	SetupList();
	ListSelChanged();
	}

void LODUtil::SetMax(float m)
	{
	int sel = SendDlgItemMessage(hWnd,IDC_LOD_LIST,LB_GETCURSEL,0,0);
	if (sel==LB_ERR) return;
	LODCtrl *cont = (LODCtrl*)nodes[sel]->GetVisController();
	if (!cont) return;
	
	if (disp==IDC_LOD_DISPPERCENT) 
		m = ConvertFromPercent(m);
	cont->max = m;

	// Propogate up		
	float max = m;
	for (int i=sel+1; i<nodes.Count(); i++) {
		LODCtrl *cnt = (LODCtrl*)nodes[i]->GetVisController();
		if (!cnt) continue;
		cnt->min = max;
		if (cnt->max < cnt->min) cnt->max = cnt->min;
		max = cnt->max;
		}

	// Propogate down
	if (cont->min > cont->max) {
		cont->min = cont->max;
		float min = cont->min;
		for (int i=sel-1; i>=0; i--) {
			LODCtrl *cnt = (LODCtrl*)nodes[i]->GetVisController();
			if (!cnt) continue;
			cnt->max = min;
			if (cnt->min > cnt->max) cnt->min = cnt->max;
			min = cnt->min;
			}
		}	
	
	SetBlendRegions();
	SetupList();
	ListSelChanged();
	}

BOOL LODUtil::HitTest(
		IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags)
	{
	return ip->PickNode(hWnd,m,this) ? TRUE : FALSE;
	}

BOOL LODUtil::Pick(IObjParam *ip,ViewExp *vpt)
	{
	INode *node = vpt->GetClosestHit();
	if (node) {
		// Compute all the sizes for existing set members
		Tab<NodeSize> nodesizes;
		for (int i=0; i<nodes.Count(); i++) {		
			NodeSize ns(nodes[i],ip->GetTime());
			nodesizes.Append(1,&ns,10);
			}

		// Compute the size for this node
		NodeSize ns(node,ip->GetTime());

		// Make a new LOD controller
		LODCtrl *cnt   = (LODCtrl*)nodes[0]->GetVisController();
		if (!cnt) return FALSE;
		LODCtrl *cont  = new LODCtrl;		
		cont->grpID    = cnt->grpID;		
		cont->viewport = FALSE;		

		// Find its location in the list
		BOOL found = FALSE;
		for (i=0; i<nodesizes.Count(); i++) {
			if (ns.faces<nodesizes[i].faces) {
				cont->order = i;
				found = TRUE;
				}
			if (found) {
				LODCtrl *cnt = (LODCtrl*)nodes[i]->GetVisController();
				if (!cnt) return FALSE;
				cnt->order++;
				}
			}
		if (!found) {
			cont->order = i;
			}
		
		// Assign the new controller
		node->SetVisController(cont);
		
		// Redraw
		ip->RedrawViews(ip->GetTime());
		SetStates();
		}
	return FALSE;
	}

void LODUtil::EnterMode(IObjParam *ip)
	{
	ICustButton *but = GetICustButton(GetDlgItem(hWnd,IDC_LOD_ADDTOSET));
	but->SetCheck(TRUE);
	ReleaseICustButton(but);
	}

void LODUtil::ExitMode(IObjParam *ip)
	{
	ICustButton *but = GetICustButton(GetDlgItem(hWnd,IDC_LOD_ADDTOSET));
	but->SetCheck(FALSE);
	ReleaseICustButton(but);
	}

BOOL LODUtil::Filter(INode *node)
	{
	for (int i=0; i<nodes.Count(); i++) {
		if (nodes[i]==node) return FALSE;		
		}
	INode *head = FindSelGroupHead();
	if (node->GetParentNode()!=head) return FALSE;
	return TRUE;
	}

static BOOL CALLBACK LODUtilDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	switch (msg) {
		case WM_INITDIALOG:			
			theLODUtil.hWnd = hWnd;
			theLODUtil.InitDlg();
			theLODUtil.SetStates();
			break;

		case WM_DESTROY:			
			break;
		
		case CC_SPINNER_CHANGE: {
			ISpinnerControl *spin = (ISpinnerControl*)lParam;
			switch (LOWORD(wParam)) {
				case IDC_LOD_VIEWWIDTHSPIN:
				case IDC_LOD_VIEWHEIGHTSPIN:
					theLODUtil.SetDisplayMode(theLODUtil.disp);
					break;

				case IDC_LOD_MINSPIN:
					theLODUtil.SetMin(spin->GetFVal());
					break;
				case IDC_LOD_MAXSPIN:
					theLODUtil.SetMax(spin->GetFVal());
					break;
				}
			break;
			}

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_LOD_DISPPERCENT:
				case IDC_LOD_DISPPIXELS:
					theLODUtil.SetDisplayMode(LOWORD(wParam));
					break;

				case IDC_LOD_LIST:
					if (HIWORD(wParam)==LBN_SELCHANGE) {
						theLODUtil.ListSelChanged();
					} else 
					if (HIWORD(wParam)==LBN_DBLCLK) {
						theLODUtil.SetViewportObj(IsDlgButtonChecked(hWnd,IDC_LOD_VIEWPORTOBJ));
						}
					break;

				case IDC_LOD_CREATENEWSET:
					theLODUtil.CreateNewSet();
					break;

				case IDC_LOD_DELETEFROMSET:
					theLODUtil.DeleteFromSet();
					break;

				case IDC_LOD_ADDTOSET:
					theLODUtil.ip->SetPickMode(&theLODUtil);
					break;

				case IDC_LOD_VIEWPORTOBJ:
					theLODUtil.SetViewportObj(IsDlgButtonChecked(hWnd,IDC_LOD_VIEWPORTOBJ));
					break;

				case IDC_LOD_RESET:
					theLODUtil.ResetSet();
					break;

				case IDC_LOD_RESETOUTPUT:
					theLODUtil.ResetOutput();
					break;

				case IDOK:
					theLODUtil.iu->CloseUtility();
					break;							
				}
			break;

		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_MOUSEMOVE:
			theLODUtil.ip->RollupMouseMessage(hWnd,msg,wParam,lParam); 
			break;

		default:
			return FALSE;
		}
	return TRUE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Control\loceulrc.cpp ===
/**********************************************************************
 *<
    FILE: loceulrc.cpp

    DESCRIPTION: A Local Euler angle rotation controller

    CREATED BY: Pete Samson

    HISTORY: modified from eulrctrl.cpp

 *> Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#include "ctrl.h"
#include "interpik.h"
#include "euler.h"

#define HYBRID_LINEAR   1

#define LOCAL_EULER_CONTROL_CNAME     GetString(IDS_PRS_LOCALEULERXYZ)

#define EULER_X_REF     0
#define EULER_Y_REF     1
#define EULER_Z_REF     2

#define THRESHHOLD		1.0f

class LocalEulerDlg;

static DWORD subColor[] = {PAINTCURVE_XCOLOR, PAINTCURVE_YCOLOR, PAINTCURVE_ZCOLOR};

class LocalEulerRotation : public Control {
    public:
        Control *rotX;
        Control *rotY;
        Control *rotZ;
        int order;
        Quat curval;
        Interval ivalid;

        static LocalEulerDlg *dlg;
        static IObjParam *ip;
        static ULONG beginFlags;
        static LocalEulerRotation *editControl; // The one being edited.

        LocalEulerRotation(const LocalEulerRotation &ctrl);
        LocalEulerRotation(BOOL loading=FALSE);
        ~LocalEulerRotation();
        void Update(TimeValue t);
        DWORD GetDefaultInTan() {return HYBRID_LINEAR;}
        DWORD GetDefaultOutTan() {return HYBRID_LINEAR;}

        // Animatable methods
        Class_ID ClassID() { return Class_ID(LOCAL_EULER_CONTROL_CLASS_ID,0); }  
        SClass_ID SuperClassID() { return CTRL_ROTATION_CLASS_ID; }         
        
        void GetClassName(TSTR& s);
        void DeleteThis() { delete this; }        
        int IsKeyable() { return 1; }     

        int NumSubs()  { return 3; }
        Animatable* SubAnim(int i);
        TSTR SubAnimName(int i);
        int SubNumToRefNum(int subNum) { return subNum; }

        DWORD GetSubAnimCurveColor(int subNum) { return subColor[subNum]; }

        ParamDimension* GetParamDimension(int i) { return stdAngleDim; }
        BOOL AssignController(Animatable *control,int subAnim);
        void AddNewKey(TimeValue t,DWORD flags);
        int NumKeys();
        TimeValue GetKeyTime(int index);
        void CopyKeysFromTime(TimeValue src, TimeValue dst, DWORD flags);
        BOOL IsKeyAtTime(TimeValue t, DWORD flags);
        BOOL GetNextKeyTime(TimeValue t, DWORD flags, TimeValue &nt);
        void DeleteKeyAtTime(TimeValue t);

        void BeginEditParams(IObjParam *ip, ULONG flags,Animatable *prev);
        void EndEditParams(IObjParam *ip, ULONG flags,Animatable *next);

        int SetProperty(ULONG id, void *data);
        void *GetProperty(ULONG id);

        // Reference methods
        int NumRefs() { return 3; };    
        RefTargetHandle GetReference(int i);
        void SetReference(int i, RefTargetHandle rtarg);
        RefResult NotifyRefChanged(Interval, RefTargetHandle, PartID&, RefMessage);
        void RescaleWorldUnits(float f) {}

        IOResult Save(ISave *isave);
        IOResult Load(ILoad *iload);

        // Control methods
        Control *GetXController() { return rotX; }
        Control *GetYController() { return rotY; }
        Control *GetZController() { return rotZ; }
        void Copy(Control *from);
        RefTargetHandle Clone(RemapDir& remap);
        BOOL IsLeaf() { return FALSE; }
        void GetValue(TimeValue t, void *val, Interval &valid, GetSetMethod method);    
        void SetValue(TimeValue t, void *val, int commit, GetSetMethod method);
        void CommitValue(TimeValue t);
        void RestoreValue(TimeValue t);
        void EnumIKParams(IKEnumCallback &callback);
        BOOL CompDeriv(TimeValue t, Matrix3& ptm, IKDeriv& derivs, DWORD flags);
        float IncIKParam(TimeValue t, int index, float delta);
        void ClearIKParam(Interval iv, int index);
        void EnableORTs(BOOL enable);
        void MirrorIKConstraints(int axis, int which);       
        BOOL CanCopyIKParams(int which);
        IKClipObject *CopyIKParams(int which);
        BOOL CanPasteIKParams(IKClipObject *co, int which);
        void PasteIKParams(IKClipObject *co, int which);
        void ChangeOrdering(int newOrder);
    };

LocalEulerDlg *LocalEulerRotation::dlg = NULL;
IObjParam *LocalEulerRotation::ip = NULL;
ULONG LocalEulerRotation::beginFlags = 0;
LocalEulerRotation *LocalEulerRotation::editControl = NULL;

class JointParamsLocalEuler : public JointParams {
    public:             
        JointParamsLocalEuler() : JointParams((DWORD)JNT_ROT,3) {flags |= JNT_LIMITEXACT;}
        void SpinnerChange(InterpCtrlUI *ui,WORD id,ISpinnerControl *spin,BOOL interactive);
    };

static BOOL CALLBACK LocalEulerParamDialogProc(HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);

static const int editButs[] = {IDC_EULER_X,IDC_EULER_Y,IDC_EULER_Z};

static int eulerIDs[] = {
    IDS_RB_EULERTYPE0,IDS_RB_EULERTYPE1,IDS_RB_EULERTYPE2,
    IDS_RB_EULERTYPE3,IDS_RB_EULERTYPE4,IDS_RB_EULERTYPE5,
    IDS_RB_EULERTYPE6,IDS_RB_EULERTYPE7,IDS_RB_EULERTYPE8};

typedef int EAOrdering[3];
static EAOrdering orderings[] = {
    {0,1,2},
    {0,2,1},
    {1,2,0},
    {1,0,2},
    {2,0,1},
    {2,1,0},
    {0,1,0},
    {1,2,1},
    {2,0,2},
    };

static int xyzIDs[] = {IDS_RB_X,IDS_RB_Y,IDS_RB_Z};
static int xyzRotIDs[] =
    {IDS_PRS_LOCALXROTATION,IDS_PRS_LOCALYROTATION,IDS_PRS_LOCALZROTATION};
static int xyzAxisIDs[] = {IDS_RB_XAXIS,IDS_RB_YAXIS,IDS_RB_ZAXIS};

#define EDIT_X  0
#define EDIT_Y  1
#define EDIT_Z  2

#define EULER_BEGIN     1
#define EULER_MIDDLE    2
#define EULER_END       3

class LocalEulerDlg {
    public:
        LocalEulerRotation *cont;
        HWND hWnd;
        IObjParam *ip;
        ICustButton *iEdit[3];
        static int cur;
        
        LocalEulerDlg(LocalEulerRotation *cont,IObjParam *ip);
        ~LocalEulerDlg();

        void Init();
        void SetButtonText();
        void EndingEdit(LocalEulerRotation *next);
        void BeginingEdit(LocalEulerRotation *cont, IObjParam *ip,
                          LocalEulerRotation *prev);
        void SetCur(int c,int code=EULER_MIDDLE);
        void WMCommand(int id, int notify, HWND hCtrl);
    };

int LocalEulerDlg::cur = EDIT_X;

LocalEulerDlg::LocalEulerDlg(LocalEulerRotation *cont,IObjParam *ip)
    {
    this->ip   = ip;
    this->cont = cont;
    for (int i=0; i<3; i++) {
        iEdit[i] = NULL;
        }
    
    hWnd = ip->AddRollupPage( 
        hInstance,
        MAKEINTRESOURCE(IDD_EULER_PARAMS),
        LocalEulerParamDialogProc,
        GetString(IDS_RB_EULERPARAMS), 
        (LPARAM)this);
    ip->RegisterDlgWnd(hWnd);   
    
    SetCur(cur,EULER_BEGIN);    
    UpdateWindow(hWnd);
    }

LocalEulerDlg::~LocalEulerDlg()
    {
    SetCur(cur,EULER_END);
    for (int i=0; i<3; i++) {
        ReleaseICustButton(iEdit[i]);       
        }
    ip->UnRegisterDlgWnd(hWnd);
    ip->DeleteRollupPage(hWnd);
    hWnd = NULL;
    }

void LocalEulerDlg::EndingEdit(LocalEulerRotation *next)
    {
    switch (cur) {
        case EDIT_X:
            cont->rotX->EndEditParams(ip,0,next->rotX);
            break;
        case EDIT_Y:
            cont->rotY->EndEditParams(ip,0,next->rotY);
            break;
        case EDIT_Z:
            cont->rotZ->EndEditParams(ip,0,next->rotZ);
            break;
        }
    cont = NULL;
    ip   = NULL;
    }

void LocalEulerDlg::BeginingEdit(LocalEulerRotation *cont, IObjParam *ip,
                                 LocalEulerRotation *prev)
    {
    this->ip   = ip;
    this->cont = cont;
    switch (cur) {
        case EDIT_X:
            cont->rotX->BeginEditParams(ip, BEGIN_EDIT_MOTION, prev->rotX);
            break;
        case EDIT_Y:
            cont->rotY->BeginEditParams(ip, BEGIN_EDIT_MOTION, prev->rotY);
            break;
        case EDIT_Z:
            cont->rotZ->BeginEditParams(ip, BEGIN_EDIT_MOTION, prev->rotZ);
            break;
        }   
    UpdateWindow(hWnd);
    }

void LocalEulerDlg::SetButtonText()
    {
    for (int i=0; i<3; i++) {
        iEdit[i]->SetText(GetString(
            xyzIDs[orderings[cont->order][i]]));
        }
    }

void LocalEulerDlg::Init()
    {   
    for (int i=0; i<3; i++) {
        iEdit[i] = GetICustButton(GetDlgItem(hWnd,editButs[i]));        
        iEdit[i]->SetType(CBT_CHECK);       
        }
    iEdit[cur]->SetCheck(TRUE); 
    SetButtonText();

    SendDlgItemMessage(hWnd, IDC_EULER_ORDER, CB_RESETCONTENT, 0, 0);
    for (i=0; i<9; i++) {
        SendDlgItemMessage(hWnd,IDC_EULER_ORDER, CB_ADDSTRING, 0,
            (LPARAM)GetString(eulerIDs[i]));
        }
    SendDlgItemMessage(hWnd, IDC_EULER_ORDER, CB_SETCURSEL, cont->order, 0);
    }

void LocalEulerDlg::SetCur(int c,int code)
    {
    if (c==cur && code==EULER_MIDDLE) return;
    Control *prev = NULL, *next = NULL;

    if (code!=EULER_END) {
        switch (c) {
            case EDIT_X:
                next = cont->rotX;
                break;
            case EDIT_Y:
                next = cont->rotY;
                break;
            case EDIT_Z:
                next = cont->rotZ;
                break;
            }
        }

    if (code!=EULER_BEGIN) {
        switch (cur) {
            case EDIT_X:
                cont->rotX->EndEditParams(ip,END_EDIT_REMOVEUI,next);
                prev = cont->rotX;
                break;
            case EDIT_Y:
                cont->rotY->EndEditParams(ip,END_EDIT_REMOVEUI,next);
                prev = cont->rotY;
                break;
            case EDIT_Z:
                cont->rotZ->EndEditParams(ip,END_EDIT_REMOVEUI,next);
                prev = cont->rotZ;
                break;
            }
        }

    cur = c;

    if (code!=EULER_END) {
        switch (cur) {
            case EDIT_X:
                cont->rotX->BeginEditParams(ip,BEGIN_EDIT_MOTION,prev);
                break;
            case EDIT_Y:
                cont->rotY->BeginEditParams(ip,BEGIN_EDIT_MOTION,prev);
                break;
            case EDIT_Z:
                cont->rotZ->BeginEditParams(ip,BEGIN_EDIT_MOTION,prev);
                break;
            }
        }
    }

void LocalEulerDlg::WMCommand(int id, int notify, HWND hCtrl)
    {
    switch (id) {
        case IDC_EULER_X:
            SetCur(0);
            iEdit[0]->SetCheck(TRUE);
            iEdit[1]->SetCheck(FALSE);
            iEdit[2]->SetCheck(FALSE);
            break;
        case IDC_EULER_Y:
            SetCur(1);
            iEdit[0]->SetCheck(FALSE);
            iEdit[1]->SetCheck(TRUE);
            iEdit[2]->SetCheck(FALSE);
            break;
        case IDC_EULER_Z:
            SetCur(2);
            iEdit[0]->SetCheck(FALSE);
            iEdit[1]->SetCheck(FALSE);
            iEdit[2]->SetCheck(TRUE);
            break;

        case IDC_EULER_ORDER:
            if (notify==CBN_SELCHANGE) {
                int res = SendDlgItemMessage(hWnd, IDC_EULER_ORDER,
                                             CB_GETCURSEL, 0, 0);
                if (res!=CB_ERR) {
                    cont->ChangeOrdering(res);
                    SetButtonText();
                    }
                }
            break;          
        }
    }

static BOOL CALLBACK LocalEulerParamDialogProc(HWND hDlg, UINT message,
                                               WPARAM wParam, LPARAM lParam)
    {
    LocalEulerDlg *dlg = (LocalEulerDlg*)GetWindowLong(hDlg,GWL_USERDATA);

    switch (message) {
        case WM_INITDIALOG:
            dlg = (LocalEulerDlg*)lParam;            
            SetWindowLong(hDlg, GWL_USERDATA, lParam);
            dlg->hWnd = hDlg;
            dlg->Init();
            break;
        
        case WM_COMMAND:
            dlg->WMCommand(LOWORD(wParam), HIWORD(wParam), (HWND)lParam);
            break;

        case WM_LBUTTONDOWN:
        case WM_LBUTTONUP:
        case WM_MOUSEMOVE:
            dlg->ip->RollupMouseMessage(hDlg, message, wParam, lParam);
            break;
                
        default:
            return FALSE;
        }
    return TRUE;
    }


//********************************************************
// LOCAL EULER CONTROL
//********************************************************
static Class_ID localEulerControlClassID(LOCAL_EULER_CONTROL_CLASS_ID,0);
 
class LocalEulerClassDesc : public ClassDesc {
    public:
    int             IsPublic() { return 1; }
    void *          Create(BOOL loading) { return new LocalEulerRotation(loading); }
    const TCHAR *   ClassName() { return LOCAL_EULER_CONTROL_CNAME; }
    SClass_ID       SuperClassID() { return CTRL_ROTATION_CLASS_ID; }
    Class_ID        ClassID() { return localEulerControlClassID; }
    const TCHAR*    Category() { return _T("");  }
    };
static LocalEulerClassDesc eulerCD;
ClassDesc* GetLocalEulerCtrlDesc() {return &eulerCD;}

LocalEulerRotation::LocalEulerRotation(const LocalEulerRotation &ctrl)
    {
    order = EULERTYPE_XYZ;
    rotX = NULL;
    rotY = NULL;
    rotZ = NULL;

    if (ctrl.rotX) {
        ReplaceReference(EULER_X_REF, ctrl.rotX);
    } else {
        ReplaceReference(EULER_X_REF, NewDefaultFloatController());
        }
    if (ctrl.rotY) {
        ReplaceReference(EULER_Y_REF, ctrl.rotY);
    } else {
        ReplaceReference(EULER_Y_REF, NewDefaultFloatController());
        }
    if (ctrl.rotZ) {
        ReplaceReference(EULER_Z_REF, ctrl.rotZ);
    } else {
        ReplaceReference(EULER_Z_REF, NewDefaultFloatController());
        }
    curval = ctrl.curval;
    ivalid = ctrl.ivalid;
    }

LocalEulerRotation::LocalEulerRotation(BOOL loading) 
    {
    order = EULERTYPE_XYZ;
    rotX = NULL;
    rotY = NULL;
    rotZ = NULL;
    if (!loading) {
        ReplaceReference(EULER_X_REF, NewDefaultFloatController());
        ReplaceReference(EULER_Y_REF, NewDefaultFloatController());
        ReplaceReference(EULER_Z_REF, NewDefaultFloatController());
        ivalid = FOREVER;
        curval.Identity();
    } else {
        ivalid.SetEmpty();
        }   
    }

RefTargetHandle LocalEulerRotation::Clone(RemapDir& remap) 
    {
    LocalEulerRotation *euler = new LocalEulerRotation(TRUE); 
    euler->ReplaceReference(EULER_X_REF, remap.CloneRef(rotX));
    euler->ReplaceReference(EULER_Y_REF, remap.CloneRef(rotY));
    euler->ReplaceReference(EULER_Z_REF, remap.CloneRef(rotZ));
    euler->order = order;

    JointParams *jp = (JointParams*)GetProperty(PROPID_JOINTPARAMS);
    if (jp) {
        JointParams *jp2 = new JointParams(*jp);
        euler->SetProperty(PROPID_JOINTPARAMS, jp2);
        }
    return euler;
    }



LocalEulerRotation::~LocalEulerRotation()
    {
    DeleteAllRefsFromMe();
    }

void LocalEulerRotation::GetClassName(TSTR& s)
    {       
    TSTR format(GetString(IDS_PRS_LOCALEULERNAME));
    s.printf(format, GetString(eulerIDs[order]));
    }
// This copy method will sample the from controller and smooth out all flips
// Nikolai 1-15-99
void LocalEulerRotation::Copy(Control *from)
	{
	if (from->ClassID()==ClassID()) {
		LocalEulerRotation *ctrl = (LocalEulerRotation*)from;
		ReplaceReference(EULER_X_REF,ctrl->rotX);
		ReplaceReference(EULER_Y_REF,ctrl->rotY);
		ReplaceReference(EULER_Z_REF,ctrl->rotZ);
		curval = ctrl->curval;
		ivalid = ctrl->ivalid;
		order  = ctrl->order;
	} else {		
		Quat qPrev;
		Quat qCurr;
		Interval iv;
		int num;		
		if ((num=from->NumKeys())!=NOT_KEYFRAMEABLE && num>0) {		
			SuspendAnimate();
			AnimateOn();
			Interval anim;

			anim.SetStart(from->GetKeyTime(0));

			float eaCurr[3];
			float eaPrev[3];
			float EulerAng[3] = {0,0,0};

			from->GetValue(anim.Start(),&qPrev,iv);

			Matrix3 tm;
			qPrev.MakeMatrix(tm);
			MatrixToEuler(tm,EulerAng, order);
				
			rotX->SetValue(anim.Start(),&EulerAng[0],TRUE, CTRL_ABSOLUTE);
			rotY->SetValue(anim.Start(),&EulerAng[1],TRUE, CTRL_ABSOLUTE);
			rotZ->SetValue(anim.Start(),&EulerAng[2],TRUE, CTRL_ABSOLUTE);
			
			if(num>1)
			{
				float dEuler[3],f;	
				Matrix3 tmPrev, tmCurr;

				anim.SetEnd(from->GetKeyTime(num-1));
				
				// Here we sample over the time range, to detect flips
				for(TimeValue time = anim.Start()+1; time <= anim.End() ; time++  )
				{
					from->GetValue(time,&qCurr,iv);
					
					qPrev.MakeMatrix(tmPrev);
					qCurr.MakeMatrix(tmCurr);

					// The Euler/Quat ratio is the relation of the angle difference in Euler space to 
					// the angle difference in Quat space. If this ration is bigger than PI the rotation 
					// between the two time steps contains a flip

					f = GetEulerMatAngleRatio(tmPrev,tmCurr,eaPrev,eaCurr,order);	
										
					if(  f > PI)
					{
						// We found a flip here
						for(int j=0 ; j < 3 ; j++)
						{				
							// find the sign flip :
							if(fabs((eaCurr[j]-eaPrev[j])) < 2*PI-THRESHHOLD )
								dEuler[j] = eaCurr[j]-eaPrev[j];
							else
								// unflip the flip
								dEuler[j] = (2*PI - (float) (fabs(eaCurr[j]) + fabs(eaPrev[j]))) * (eaPrev[j] > 0 ? 1 : -1);
							
							EulerAng[j] += dEuler[j];
						}
					}
					else
					{
						// Add up the angle difference
						for(int j=0 ; j < 3 ; j++)
						{
							dEuler[j] = eaCurr[j]-eaPrev[j];
							EulerAng[j] += dEuler[j];
						}
					}
					if(from->IsKeyAtTime(time,KEYAT_ROTATION))
					{
						// Create the keys
						rotX->SetValue(time,&EulerAng[0],TRUE, CTRL_ABSOLUTE);
						rotY->SetValue(time,&EulerAng[1],TRUE, CTRL_ABSOLUTE);
						rotZ->SetValue(time,&EulerAng[2],TRUE, CTRL_ABSOLUTE);
					}
					qPrev = qCurr;
				}
			}
			// RB 2/10/99: A key at frame 0 may have been created
			if (num>0 && from->GetKeyTime(0)!=0) {
				rotX->DeleteKeyAtTime(0);
				rotY->DeleteKeyAtTime(0);
				rotZ->DeleteKeyAtTime(0);
			}
			ResumeAnimate();
		} else {
			from->GetValue(0,&qCurr,ivalid);
			SetValue(0,&qCurr,TRUE,CTRL_ABSOLUTE);
			}
		}
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	}
  
/*
// This is the old way
void LocalEulerRotation::Copy(Control *from)
    {
    if (from->ClassID() == ClassID()) {
        LocalEulerRotation *ctrl = (LocalEulerRotation*)from;
        ReplaceReference(EULER_X_REF, ctrl->rotX);
        ReplaceReference(EULER_Y_REF, ctrl->rotY);
        ReplaceReference(EULER_Z_REF, ctrl->rotZ);
        curval = ctrl->curval;
        ivalid = ctrl->ivalid;
        order  = ctrl->order;
    } else {        
        Quat v;
        Interval iv;
        int num;        
        if (num=from->NumKeys()) {
            SuspendAnimate();
            AnimateOn();
            for (int i=0; i<num; i++) {
                TimeValue t = from->GetKeyTime(i);
                from->GetValue(t,&v,iv);
                SetValue(t,&v,TRUE,CTRL_ABSOLUTE);  
                }
            ResumeAnimate();
        } else {
            from->GetValue(0,&v,ivalid);
            SetValue(0,&v,TRUE,CTRL_ABSOLUTE);
            }
        }
    NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
    }
*/
void LocalEulerRotation::Update(TimeValue t)
    {
    if (!ivalid.InInterval(t)) {
        ivalid = FOREVER;
        Point3 ang(0,0,0);
        if (rotX) rotX->GetValue(t,&ang.x,ivalid);
        if (rotY) rotY->GetValue(t,&ang.y,ivalid);
        if (rotZ) rotZ->GetValue(t,&ang.z,ivalid);
        
        // This could be optimized.
        //Matrix3 tm(1);
        //tm.RotateX(x);
        //tm.RotateY(y);
        //tm.RotateZ(z);
        //curval = Quat(tm);        
        Matrix3 tm(1);
        for (int i = 2; i >= 0; i--) {
            switch (orderings[order][i]) {
                case 0: tm.RotateX(ang[i]); break;
                case 1: tm.RotateY(ang[i]); break;
                case 2: tm.RotateZ(ang[i]); break;
                }
            }
        curval = Quat(tm);
        //EulerToQuat(ang, curval, order);
        }
    }

void LocalEulerRotation::ChangeOrdering(int newOrder)
    {
    order = newOrder;
    ivalid.SetEmpty();
    NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
    NotifyDependents(FOREVER, PART_ALL, REFMSG_SUBANIM_STRUCTURE_CHANGED);
    ip->RedrawViews(ip->GetTime());
    }

void LocalEulerRotation::SetValue(TimeValue t, void *val, int commit,
                                  GetSetMethod method)
    {
    Quat v;
    Update(t);
    if (method==CTRL_RELATIVE) {
        v = curval * Quat(*((AngAxis*)val));
    } else {
        v = *((Quat*)val);
        }
        
    float ang[3];
    //QuatToEuler(v,ang);
    Matrix3 tm;
    v.MakeMatrix(tm);
    MatrixToEuler(tm,ang, order | EULERTYPE_RF); // rotate the coordinate frame
    
    // RB: this gives the incorrect sign sometimes...
    //QuatToEuler(v, ang, order);       

    if (rotX) rotX->SetValue(t,&ang[0]);
    if (rotY) rotY->SetValue(t,&ang[1]);
    if (rotZ) rotZ->SetValue(t,&ang[2]);
    ivalid.SetEmpty();
    NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
    }

void LocalEulerRotation::GetValue(TimeValue t, void *val, Interval &valid,
                                  GetSetMethod method)
    {       
    Update(t);
    valid &= ivalid;             
    if (method==CTRL_RELATIVE) {
        Matrix3 *mat = (Matrix3*)val;       
        PreRotateMatrix(*mat,curval);       
    } else {
        *((Quat*)val) = curval;
        }
    }

void LocalEulerRotation::CommitValue(TimeValue t)
    {
    if (rotX) rotX->CommitValue(t);
    if (rotY) rotY->CommitValue(t);
    if (rotZ) rotZ->CommitValue(t);
    }

void LocalEulerRotation::RestoreValue(TimeValue t)
    {
    if (rotX) rotX->RestoreValue(t);
    if (rotY) rotY->RestoreValue(t);
    if (rotZ) rotZ->RestoreValue(t);
    }

RefTargetHandle LocalEulerRotation::GetReference(int i)
    {
    switch (i) {
        case EULER_X_REF: return rotX;
        case EULER_Y_REF: return rotY;
        case EULER_Z_REF: return rotZ;
        default: return NULL;
        }
    }

void LocalEulerRotation::SetReference(int i, RefTargetHandle rtarg)
    {
    switch (i) {
        case EULER_X_REF: rotX = (Control*)rtarg; break;
        case EULER_Y_REF: rotY = (Control*)rtarg; break;
        case EULER_Z_REF: rotZ = (Control*)rtarg; break;
        }
    }

Animatable* LocalEulerRotation::SubAnim(int i)
    {
    return GetReference(i);
    }

TSTR LocalEulerRotation::SubAnimName(int i)
    {   
    switch (i) {
        case EULER_X_REF: return GetString(xyzRotIDs[orderings[order][0]]);
        case EULER_Y_REF: return GetString(xyzRotIDs[orderings[order][1]]);
        case EULER_Z_REF: return GetString(xyzRotIDs[orderings[order][2]]);
        default: return _T("");
        }
    }

RefResult LocalEulerRotation::NotifyRefChanged(
        Interval iv, 
        RefTargetHandle hTarg, 
        PartID& partID, 
        RefMessage msg) 
    {
    switch (msg) {
        case REFMSG_CHANGE:
            ivalid.SetEmpty();
            break;
        case REFMSG_TARGET_DELETED:
            if (rotX == hTarg) rotX = NULL;
            if (rotY == hTarg) rotY = NULL;
            if (rotZ == hTarg) rotZ = NULL; 
            break;
        case REFMSG_GET_CONTROL_DIM: {
            ParamDimension **dim = (ParamDimension **)partID;
            assert(dim);
            *dim = stdAngleDim;
            }
        }
    return REF_SUCCEED;
    }

BOOL LocalEulerRotation::AssignController(Animatable *control,int subAnim)
    {   
    switch (subAnim) {
        case EULER_X_REF:
            ReplaceReference(EULER_X_REF,(RefTargetHandle)control);
            break;
        case EULER_Y_REF:
            ReplaceReference(EULER_Y_REF,(RefTargetHandle)control);
            break;
        case EULER_Z_REF:
            ReplaceReference(EULER_Z_REF,(RefTargetHandle)control);
            break;
        }
    NotifyDependents(FOREVER,0,REFMSG_CONTROLREF_CHANGE,TREE_VIEW_CLASS_ID,FALSE);
    NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);   
    return TRUE;
    }

void LocalEulerRotation::AddNewKey(TimeValue t, DWORD flags)
    {
    if (rotX) rotX->AddNewKey(t,flags);
    if (rotY) rotY->AddNewKey(t,flags);
    if (rotZ) rotZ->AddNewKey(t,flags);
    }

int LocalEulerRotation::NumKeys()
    {
    int num = 0;
    if (rotX) num += rotX->NumKeys(); 
    if (rotY) num += rotY->NumKeys();
    if (rotZ) num += rotZ->NumKeys();
    return num;
    }

TimeValue LocalEulerRotation::GetKeyTime(int index)
    {
    int onum, num = 0;
    if (rotX) num += rotX->NumKeys(); 
    if (index < num) return rotX->GetKeyTime(index);
    onum = num;
    if (rotY) num += rotY->NumKeys(); 
    if (index < num) return rotY->GetKeyTime(index-onum);
    onum = num;
    if (rotZ) num += rotZ->NumKeys(); 
    if (index < num) return rotZ->GetKeyTime(index-onum);
    return 0;
    }

void LocalEulerRotation::CopyKeysFromTime(TimeValue src,TimeValue dst,DWORD flags)
    {
    if (rotX) rotX->CopyKeysFromTime(src,dst,flags);
    if (rotY) rotY->CopyKeysFromTime(src,dst,flags);
    if (rotZ) rotZ->CopyKeysFromTime(src,dst,flags);
    }

BOOL LocalEulerRotation::IsKeyAtTime(TimeValue t, DWORD flags)
    {
    if (rotX && rotX->IsKeyAtTime(t,flags)) return TRUE;
    if (rotY && rotY->IsKeyAtTime(t,flags)) return TRUE;
    if (rotZ && rotZ->IsKeyAtTime(t,flags)) return TRUE;
    return FALSE;
    }

void LocalEulerRotation::DeleteKeyAtTime(TimeValue t)
    {
    if (rotX) rotX->DeleteKeyAtTime(t);
    if (rotY) rotY->DeleteKeyAtTime(t);
    if (rotZ) rotZ->DeleteKeyAtTime(t);
    }

BOOL LocalEulerRotation::GetNextKeyTime(TimeValue t, DWORD flags, TimeValue &nt)
    {
    TimeValue at,tnear = 0;
    BOOL tnearInit = FALSE;
    
    if (rotX && rotX->GetNextKeyTime(t,flags,at)) {
        if (!tnearInit) {
            tnear = at;
            tnearInit = TRUE;
        } else 
        if (ABS(at-t) < ABS(tnear-t)) tnear = at;
        }

    if (rotY && rotY->GetNextKeyTime(t,flags,at)) {
        if (!tnearInit) {
            tnear = at;
            tnearInit = TRUE;
        } else 
        if (ABS(at-t) < ABS(tnear-t)) tnear = at;
        }

    if (rotZ && rotZ->GetNextKeyTime(t,flags,at)) {
        if (!tnearInit) {
            tnear = at;
            tnearInit = TRUE;
        } else 
        if (ABS(at-t) < ABS(tnear-t)) tnear = at;
        }
    
    if (tnearInit) {
        nt = tnear;
        return TRUE;
    } else {
        return FALSE;
        }
    }
        

void LocalEulerRotation::BeginEditParams(IObjParam *ip, ULONG flags,
                                         Animatable *prev )
    {
    if (flags & BEGIN_EDIT_HIERARCHY) {
        JointParamsLocalEuler *jp = (JointParamsLocalEuler*)GetProperty(PROPID_JOINTPARAMS);
        InterpCtrlUI *ui;   

        if (!jp) {
            jp = new JointParamsLocalEuler();
            SetProperty(PROPID_JOINTPARAMS,jp);
            }

        if (prev &&
            prev->ClassID()==ClassID() && 
            (ui = (InterpCtrlUI*)prev->GetProperty(PROPID_INTERPUI))) {
            JointParams *prevjp = (JointParams*)prev->GetProperty(PROPID_JOINTPARAMS);
            prevjp->EndDialog(ui);
            ui->cont = this;
            ui->ip   = ip;
            prev->SetProperty(PROPID_INTERPUI,NULL);
            JointDlgData *jd = (JointDlgData*)GetWindowLong(ui->hParams,
                                                            GWL_USERDATA);
            jd->jp = jp;
            jp->InitDialog(ui);
        } else {
            ui = new InterpCtrlUI(NULL, ip, this);
            DWORD f=0;
            if (jp && !jp->RollupOpen()) f = APPENDROLL_CLOSED; 

            ui->hParams = ip->AddRollupPage(hInstance, 
                                            MAKEINTRESOURCE(IDD_STDJOINTPARAMS),
                                            JointParamDlgProc,
                                            GetString(IDS_RB_ROTJOINTPARAMS), 
                                            (LPARAM)new JointDlgData(ui,jp),f); 
            }
    
        SetDlgItemText(ui->hParams,IDC_XAXIS_LABEL,
            GetString(xyzAxisIDs[orderings[order][0]]));
        SetDlgItemText(ui->hParams,IDC_YAXIS_LABEL,
            GetString(xyzAxisIDs[orderings[order][1]]));
        SetDlgItemText(ui->hParams,IDC_ZAXIS_LABEL,
            GetString(xyzAxisIDs[orderings[order][2]]));

        SetProperty(PROPID_INTERPUI, ui);
        editControl = this;
        beginFlags = flags;
    } else 
    if (flags & BEGIN_EDIT_MOTION) {
        this->ip = ip;

        if (dlg) {
            dlg->BeginingEdit(this,ip,(LocalEulerRotation*)prev);
            dlg->Init();
        } else {
            dlg = new LocalEulerDlg(this,ip);    
            }
        }
    }

void LocalEulerRotation::EndEditParams(IObjParam *ip, ULONG flags,Animatable *next)
    {   
    LocalEulerRotation *cont=NULL;
    if (next && next->ClassID()==ClassID()) {
        cont = (LocalEulerRotation*)next;
        }

    if (dlg) {
        if (cont) {
            dlg->EndingEdit(cont);
        } else {
            delete dlg;
            dlg = NULL;
            }
    } else {
        if (cont) return;
        
        editControl = NULL;
        beginFlags = 0;

        int index = aprops.FindProperty(PROPID_INTERPUI);
        if (index>=0) {
            InterpCtrlUI *ui = (InterpCtrlUI*)aprops[index];
            if (ui->hParams) {
                ip->UnRegisterDlgWnd(ui->hParams);
                ip->DeleteRollupPage(ui->hParams);          
                }
            index = aprops.FindProperty(PROPID_INTERPUI);
            if (index>=0) {
                delete aprops[index];
                aprops.Delete(index,1);
                }
            }
        }
    }

int LocalEulerRotation::SetProperty(ULONG id, void *data)
    {
    if (id==PROPID_JOINTPARAMS) {       
        if (!data) {
            int index = aprops.FindProperty(id);
            if (index>=0) {
                aprops.Delete(index,1);
                }
        } else {
            JointParamsLocalEuler *jp = (JointParamsLocalEuler*)GetProperty(id);
            if (jp) {
                *jp = *((JointParamsLocalEuler*)data);
                delete (JointParamsLocalEuler*)data;
            } else {
                aprops.Append(1,(AnimProperty**)&data);
                }                   
            }
        return 1;
    } else
    if (id==PROPID_INTERPUI) {      
        if (!data) {
            int index = aprops.FindProperty(id);
            if (index>=0) {             
                aprops.Delete(index,1);
                }
        } else {
            InterpCtrlUI *ui = (InterpCtrlUI*)GetProperty(id);
            if (ui) {
                *ui = *((InterpCtrlUI*)data);
            } else {
                aprops.Append(1,(AnimProperty**)&data);
                }                   
            }
        return 1;
    } else {
        return Animatable::SetProperty(id,data);
        }
    }

void* LocalEulerRotation::GetProperty(ULONG id)
    {
    if (id==PROPID_INTERPUI || id==PROPID_JOINTPARAMS) {
        int index = aprops.FindProperty(id);
        if (index>=0) {
            return aprops[index];
        } else {
            return NULL;
            }
    } else {
        return Animatable::GetProperty(id);
        }
    }


#define JOINTPARAMEULER_CHUNK   0x1002
#define ORDER_CHUNK             0x1003

IOResult LocalEulerRotation::Save(ISave *isave)
    {   
    ULONG nb;
    JointParamsLocalEuler *jp = (JointParamsLocalEuler*)GetProperty(PROPID_JOINTPARAMS);
    if (jp) {
        isave->BeginChunk(JOINTPARAMEULER_CHUNK);
        jp->Save(isave);
        isave->EndChunk();
        }

    isave->BeginChunk(ORDER_CHUNK);
    isave->Write(&order,sizeof(order),&nb);
    isave->EndChunk();

    return IO_OK;
    }

IOResult LocalEulerRotation::Load(ILoad *iload)
    {
    ULONG nb;
    IOResult res = IO_OK;
    while (IO_OK==(res=iload->OpenChunk())) {
        switch (iload->CurChunkID()) {
            case ORDER_CHUNK:
                res=iload->Read(&order,sizeof(order),&nb);
                break;

            case JOINTPARAMEULER_CHUNK: {
                JointParamsLocalEuler *jp = new JointParamsLocalEuler;
                jp->Load(iload);
                jp->flags |= JNT_LIMITEXACT;
                SetProperty(PROPID_JOINTPARAMS,jp);
                break;
                }
            }       
        iload->CloseChunk();
        if (res!=IO_OK)  return res;
        }
    return IO_OK;
    }


void LocalEulerRotation::EnumIKParams(IKEnumCallback &callback)
    {
    JointParamsLocalEuler *jp = (JointParamsLocalEuler*)GetProperty(PROPID_JOINTPARAMS);
    for (int i=2; i>=0; i--) {
        if (!jp || jp->Active(i)) {
            callback.proc(this,i);
            }
        }
    }

BOOL LocalEulerRotation::CompDeriv(TimeValue t, Matrix3& ptm, IKDeriv& derivs,
                                   DWORD flags)
    {
    JointParamsLocalEuler *jp = (JointParamsLocalEuler*)GetProperty(PROPID_JOINTPARAMS);
    Quat q;
    Interval valid;
    Point3 a(0,0,0);

    if (rotX) rotX->GetValue(t,&a[0],valid);
    if (rotY) rotY->GetValue(t,&a[1],valid);
    if (rotZ) rotZ->GetValue(t,&a[2],valid);

    for (int i=2; i>=0; i--) {
        if (!jp || jp->Active(i)) {
            for (int j=0; j<derivs.NumEndEffectors(); j++) {
                Point3 r = derivs.EndEffectorPos(j) - ptm.GetTrans();   
        
                Point3 axis = ptm.GetRow(orderings[order][i]);
                if (!(ptm.GetIdentFlags()&SCL_IDENT)) {
                    axis = Normalize(axis);
                    if (ptm.Parity()) axis = -axis;
                    }

                if (flags&POSITION_DERIV) {
                    derivs.DP(CrossProd(axis,r),j);
                    }
                if (flags&ROTATION_DERIV) {
                    derivs.DR(axis,j);
                    }
                }
            derivs.NextDOF();           
            }
        switch (orderings[order][i]) {
            case 0: ptm.PreRotateX(a[i]); break;
            case 1: ptm.PreRotateY(a[i]); break;
            case 2: ptm.PreRotateZ(a[i]); break;
            }
        }   
    return TRUE;
    }

#define MAX_IKROT   DegToRad(4.0f)
#define SGN(a)  (a<0?-1:1)

float LocalEulerRotation::IncIKParam(TimeValue t, int index, float delta)
    {
    JointParamsLocalEuler *jp = (JointParamsLocalEuler*)GetProperty(PROPID_JOINTPARAMS);
    if ((float)fabs(delta)>MAX_IKROT) delta = MAX_IKROT * SGN(delta);
    
    if (jp) {
        float v=0.0f;       
        if (jp->Limited(index) || jp->Spring(index)) {
            Interval valid;
            switch (index) {
                case 0: if (rotX) rotX->GetValue(t,&v,valid); break;
                case 1: if (rotY) rotY->GetValue(t,&v,valid); break;
                case 2: if (rotZ) rotZ->GetValue(t,&v,valid); break;
                }
            }
        delta = jp->ConstrainInc(index,v,delta);
        }
    switch (index) {
        case 0: if (rotX) rotX->SetValue(t,&delta,FALSE,CTRL_RELATIVE); break;
        case 1: if (rotY) rotY->SetValue(t,&delta,FALSE,CTRL_RELATIVE); break;
        case 2: if (rotZ) rotZ->SetValue(t,&delta,FALSE,CTRL_RELATIVE); break;
        }   
    return delta;   
    }

void LocalEulerRotation::ClearIKParam(Interval iv,int index) 
    {
    switch (index) {
        case 0: if (rotX) rotX->DeleteTime(iv,TIME_INCRIGHT|TIME_NOSLIDE); break;
        case 1: if (rotY) rotY->DeleteTime(iv,TIME_INCRIGHT|TIME_NOSLIDE); break;
        case 2: if (rotZ) rotZ->DeleteTime(iv,TIME_INCRIGHT|TIME_NOSLIDE); break;
        }
    }

void LocalEulerRotation::MirrorIKConstraints(int axis,int which)
    {
    JointParamsLocalEuler *jp = (JointParamsLocalEuler*)GetProperty(PROPID_JOINTPARAMS);
    if (jp) jp->MirrorConstraints(axis);
    }

void LocalEulerRotation::EnableORTs(BOOL enable)
    {
    if (rotX) rotX->EnableORTs(enable);
    if (rotY) rotY->EnableORTs(enable);
    if (rotZ) rotZ->EnableORTs(enable);
    }

BOOL LocalEulerRotation::CanCopyIKParams(int which)
    {
    return ::CanCopyIKParams(this,which);
    }

IKClipObject *LocalEulerRotation::CopyIKParams(int which)
    {
    return ::CopyIKParams(this,which);
    }

BOOL LocalEulerRotation::CanPasteIKParams(IKClipObject *co,int which)
    {
    return ::CanPasteIKParams(this,co,which);
    }

void LocalEulerRotation::PasteIKParams(IKClipObject *co,int which)
    {
    ::PasteIKParams(this,co,which);
    }

void JointParamsLocalEuler::SpinnerChange(
        InterpCtrlUI *ui,WORD id,ISpinnerControl *spin,BOOL interactive)
    {
    LocalEulerRotation *c = (LocalEulerRotation*)ui->cont;
    Point3 a(0,0,0);
    BOOL set = FALSE;
    Interval valid;

    if (c->rotX) c->rotX->GetValue(ui->ip->GetTime(),&a[0],valid);
    if (c->rotY) c->rotY->GetValue(ui->ip->GetTime(),&a[1],valid);
    if (c->rotZ) c->rotZ->GetValue(ui->ip->GetTime(),&a[2],valid);

    switch (id) {
        case IDC_XFROMSPIN:
            a[0] = min[0] = DegToRad(spin->GetFVal()); 
            set = TRUE;
            break;
        case IDC_XTOSPIN:
            a[0] = max[0] = DegToRad(spin->GetFVal());
            set = TRUE;
            break;
        case IDC_XSPRINGSPIN:
            a[0] = spring[0] = DegToRad(spin->GetFVal());
            set = TRUE;
            break;
        
        case IDC_YFROMSPIN:
            a[1] = min[1] = DegToRad(spin->GetFVal()); 
            set = TRUE;
            break;
        case IDC_YTOSPIN:
            a[1] = max[1] = DegToRad(spin->GetFVal());
            set = TRUE;
            break;
        case IDC_YSPRINGSPIN:
            a[0] = spring[1] = DegToRad(spin->GetFVal());
            set = TRUE;
            break;
        
        case IDC_ZFROMSPIN:
            a[2] = min[2] = DegToRad(spin->GetFVal()); 
            set = TRUE;
            break;
        case IDC_ZTOSPIN:
            a[2] = max[2] = DegToRad(spin->GetFVal());
            set = TRUE;
            break;
        case IDC_ZSPRINGSPIN:
            a[2] = spring[0] = DegToRad(spin->GetFVal());
            set = TRUE;
            break;
        
        case IDC_XDAMPINGSPIN:
            damping[0] = spin->GetFVal(); break;        
        case IDC_YDAMPINGSPIN:
            damping[1] = spin->GetFVal(); break;        
        case IDC_ZDAMPINGSPIN:
            damping[2] = spin->GetFVal(); break;

        case IDC_XSPRINGTENSSPIN:
            stens[0] = spin->GetFVal()/SPRINGTENS_UI; break;
        case IDC_YSPRINGTENSSPIN:
            stens[1] = spin->GetFVal()/SPRINGTENS_UI; break;
        case IDC_ZSPRINGTENSSPIN:
            stens[2] = spin->GetFVal()/SPRINGTENS_UI; break;
        }
    
    if (set && interactive) {               
        if (c->rotX) c->rotX->SetValue(ui->ip->GetTime(),&a[0],TRUE,CTRL_ABSOLUTE);
        if (c->rotY) c->rotY->SetValue(ui->ip->GetTime(),&a[1],TRUE,CTRL_ABSOLUTE);
        if (c->rotZ) c->rotZ->SetValue(ui->ip->GetTime(),&a[2],TRUE,CTRL_ABSOLUTE);
        ui->ip->RedrawViews(ui->ip->GetTime(),REDRAW_INTERACTIVE);
        }
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Control\noizctrl.cpp ===
/**********************************************************************
 *<
	FILE: noizctrl.cpp

	DESCRIPTION: A simple noise controller

	CREATED BY: Rolf Berteig

	HISTORY: created 26 August 1995

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/
#include "ctrl.h"
#include "units.h"
#include "noise.h"
#include "istdplug.h"

#define FLOATNOISE_CONTROL_CNAME	GetString(IDS_RB_NOISEFLOAT)
#define POSITIONNOISE_CONTROL_CNAME	GetString(IDS_RB_NOISEPOSITION)
#define POINT3NOISE_CONTROL_CNAME	GetString(IDS_RB_NOISEPOINT3)
#define ROTATIONNOISE_CONTROL_CNAME	GetString(IDS_RB_NOISEROTATION)
#define SCALENOISE_CONTROL_CNAME	GetString(IDS_RB_NOISESCALE)



#define MAX_ELEMS	3
										   
class BaseNoiseControl : public INoiseControl {
	public:		
		//float strength[MAX_ELEMS];
		Control *cont; // make strength animatable.
		float frequency;
		float roughness;
		int seed;
		BOOL fractal;
		BOOL lim[MAX_ELEMS];
		Interval range;
		TimeValue rampin, rampout;

		BaseNoiseControl();
		BaseNoiseControl& operator=(const BaseNoiseControl& from);
		float NoiseAtTime(TimeValue t,int s,int index);
		
		virtual int Elems()=0;

		// Animatable methods		
		void DeleteThis() {delete this;}		
		int IsKeyable() {return 0;}		
		BOOL IsAnimated() {return TRUE;}

		int NumSubs();
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);
		BOOL AssignController(Animatable *control,int subAnim);
		int SubNumToRefNum(int subNum);

		int NumRefs();
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);

		void EditTrackParams(
			TimeValue t,
			ParamDimensionBase *dim,
			TCHAR *pname,
			HWND hParent,
			IObjParam *ip,
			DWORD flags);
		
		int TrackParamsType() {return TRACKPARAMS_WHOLE;}

		// Reference methods
		RefResult NotifyRefChanged(Interval, RefTargetHandle, PartID&, RefMessage) {return REF_SUCCEED;}

		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);

		// Control methods				
		void Copy(Control *from) {}
		BOOL IsLeaf() {return TRUE;}
		void CommitValue(TimeValue t) {}
		void RestoreValue(TimeValue t) {}		
		
		// From INoiseControl
		void SetSeed(int seed);		
		void SetFrequency(float f);		
		void SetFractal(BOOL f);		
		void SetRoughness(float f);		
		void SetRampIn(TimeValue in);
		void SetRampOut(TimeValue out);		
		void SetPositiveOnly(int which,BOOL onOff);		
		void SetStrengthController(Control *c);

		float GetRoughness() {return roughness;}
		int GetSeed() {return seed;}
		float GetFrequency() {return frequency;}
		BOOL GetFractal() {return fractal;}
		TimeValue GetRampIn() {return rampin;}
		TimeValue GetRampOut() {return rampout;}
		BOOL GetPositiveOnly(int which) {return lim[which];}
		Control *GetStrengthController() {return cont;}

		void HoldRange();
		Interval GetTimeRange(DWORD flags) {return range;}
		void EditTimeRange(Interval range,DWORD flags);
		void MapKeys(TimeMap *map,DWORD flags );

		void GetStrength(TimeValue t,float *strength) {
			cont->GetValue(t,strength,FOREVER);
			}
	};

//---------------------------------------------------------------------------

class FloatNoiseControl : public BaseNoiseControl {
	public:
		int Elems() {return 1;}

		FloatNoiseControl() {
			cont=NULL;
			ReplaceReference(Control::NumRefs(),NewDefaultFloatController());
			float v = 50.0f;
			cont->SetValue(0,&v);
			}

		Class_ID ClassID() { return Class_ID(FLOATNOISE_CONTROL_CLASS_ID,0); }  
		SClass_ID SuperClassID() { return CTRL_FLOAT_CLASS_ID; } 
		void GetClassName(TSTR& s) {s = FLOATNOISE_CONTROL_CNAME;}

		// Control methods
		RefTargetHandle Clone(RemapDir& remap);

		// StdControl methods
		void GetValueLocalTime(TimeValue t, void *val, Interval &valid, GetSetMethod method=CTRL_ABSOLUTE);
		void SetValueLocalTime(TimeValue t, void *val, int commit, GetSetMethod method) {}		
		void Extrapolate(Interval range,TimeValue t,void *val,Interval &valid,int type);		
		void *CreateTempValue() {return new float;}
		void DeleteTempValue(void *val) {delete (float*)val;}
		void ApplyValue(void *val, void *delta) {*((float*)val) += *((float*)delta);}
		void MultiplyValue(void *val, float m) {*((float*)val) *= m;}
	};


class FloatNoiseClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { return new FloatNoiseControl(); }
	const TCHAR *	ClassName() { return FLOATNOISE_CONTROL_CNAME; }
	SClass_ID		SuperClassID() { return CTRL_FLOAT_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(FLOATNOISE_CONTROL_CLASS_ID,0); }
	const TCHAR* 	Category() { return _T("");  }
	};
static FloatNoiseClassDesc floatNoiseCD;
ClassDesc* GetFloatNoiseDesc() {return &floatNoiseCD;}

//-----------------------------------------------------------------------------

class PositionNoiseControl : public BaseNoiseControl {
	public:
		int Elems() {return 3;}

		PositionNoiseControl() {
			cont=NULL;
			ReplaceReference(Control::NumRefs(),NewDefaultPoint3Controller());
			Point3 v(50.0f,50.0f,50.0f);			
			cont->SetValue(0,&v);
			}

		Class_ID ClassID() { return Class_ID(POSITIONNOISE_CONTROL_CLASS_ID,0); }  
		SClass_ID SuperClassID() { return CTRL_POSITION_CLASS_ID; } 
		void GetClassName(TSTR& s) {s = POSITIONNOISE_CONTROL_CNAME;}

		// Control methods
		RefTargetHandle Clone(RemapDir& remap);

		// StdControl methods
		void GetValueLocalTime(TimeValue t, void *val, Interval &valid, GetSetMethod method=CTRL_ABSOLUTE);
		void SetValueLocalTime(TimeValue t, void *val, int commit, GetSetMethod method) {}		
		void Extrapolate(Interval range,TimeValue t,void *val,Interval &valid,int type);
		void *CreateTempValue() {return new Point3;}
		void DeleteTempValue(void *val) {delete (Point3*)val;}
		void ApplyValue(void *val, void *delta) {((Matrix3*)val)->PreTranslate(*((Point3*)delta));}
		void MultiplyValue(void *val, float m) {*((Point3*)val) *= m;}
	};


class PositionNoiseClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { return new PositionNoiseControl(); }
	const TCHAR *	ClassName() { return POSITIONNOISE_CONTROL_CNAME; }
	SClass_ID		SuperClassID() { return CTRL_POSITION_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(POSITIONNOISE_CONTROL_CLASS_ID,0); }
	const TCHAR* 	Category() { return _T("");  }
	};
static PositionNoiseClassDesc positionNoiseCD;
ClassDesc* GetPositionNoiseDesc() {return &positionNoiseCD;}

//-----------------------------------------------------------------------------

class Point3NoiseControl : public BaseNoiseControl {
	public:
		int Elems() {return 3;}

		Point3NoiseControl() {
			cont=NULL;
			ReplaceReference(Control::NumRefs(),NewDefaultPoint3Controller());
			Point3 v(50.0f,50.0f,50.0f);			
			cont->SetValue(0,&v);
			}

		Class_ID ClassID() { return Class_ID(POINT3NOISE_CONTROL_CLASS_ID,0); }  
		SClass_ID SuperClassID() { return CTRL_POINT3_CLASS_ID; } 
		void GetClassName(TSTR& s) {s = POINT3NOISE_CONTROL_CNAME;}

		// Control methods
		RefTargetHandle Clone(RemapDir& remap);

		// StdControl methods
		void GetValueLocalTime(TimeValue t, void *val, Interval &valid, GetSetMethod method=CTRL_ABSOLUTE);
		void SetValueLocalTime(TimeValue t, void *val, int commit, GetSetMethod method) {}		
		void Extrapolate(Interval range,TimeValue t,void *val,Interval &valid,int type);
		void *CreateTempValue() {return new Point3;}
		void DeleteTempValue(void *val) {delete (Point3*)val;}
		void ApplyValue(void *val, void *delta) {*((Point3*)val) += *((Point3*)delta);}
		void MultiplyValue(void *val, float m) {*((Point3*)val) *= m;}
	};


class Point3NoiseClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { return new Point3NoiseControl(); }
	const TCHAR *	ClassName() { return POINT3NOISE_CONTROL_CNAME; }
	SClass_ID		SuperClassID() { return CTRL_POINT3_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(POINT3NOISE_CONTROL_CLASS_ID,0); }
	const TCHAR* 	Category() { return _T("");  }
	};
static Point3NoiseClassDesc point3NoiseCD;
ClassDesc* GetPoint3NoiseDesc() {return &point3NoiseCD;}

//-----------------------------------------------------------------------------


class RotationNoiseControl : public BaseNoiseControl {
	public:
		int Elems() {return 3;}
		
		RotationNoiseControl() {
			Point3 strength;
			strength[0] = strength[1] = strength[2] = DegToRad(45);
			cont=NULL;
			ReplaceReference(Control::NumRefs(),NewDefaultPoint3Controller());
			cont->SetValue(0,&strength); 
			}

		Class_ID ClassID() { return Class_ID(ROTATIONNOISE_CONTROL_CLASS_ID,0); }  
		SClass_ID SuperClassID() { return CTRL_ROTATION_CLASS_ID; } 
		void GetClassName(TSTR& s) {s = ROTATIONNOISE_CONTROL_CNAME;}

		// Control methods
		RefTargetHandle Clone(RemapDir& remap);

		// StdControl methods
		void GetValueLocalTime(TimeValue t, void *val, Interval &valid, GetSetMethod method=CTRL_ABSOLUTE);
		void SetValueLocalTime(TimeValue t, void *val, int commit, GetSetMethod method) {}		
		void Extrapolate(Interval range,TimeValue t,void *val,Interval &valid,int type);
		void *CreateTempValue() {return new Quat;}
		void DeleteTempValue(void *val) {delete (Quat*)val;}
		void ApplyValue(void *val, void *delta) {PreRotateMatrix( *((Matrix3*)val), *((Quat*)delta) );}
		void MultiplyValue(void *val, float m) {*((Quat*)val) *= m;}
	};


class RotationNoiseClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { return new RotationNoiseControl(); }
	const TCHAR *	ClassName() { return ROTATIONNOISE_CONTROL_CNAME; }
	SClass_ID		SuperClassID() { return CTRL_ROTATION_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(ROTATIONNOISE_CONTROL_CLASS_ID,0); }
	const TCHAR* 	Category() { return _T("");  }
	};
static RotationNoiseClassDesc rotationNoiseCD;
ClassDesc* GetRotationNoiseDesc() {return &rotationNoiseCD;}

//-----------------------------------------------------------------------------

class ScaleNoiseControl : public BaseNoiseControl {
	public:
		int Elems() {return 3;}

		ScaleNoiseControl() {
			Point3 strength;
			strength[0] = strength[1] = strength[2] = 0.5f;
			cont=NULL;
			ReplaceReference(Control::NumRefs(),NewDefaultPoint3Controller());
			cont->SetValue(0,&strength); 
			}

		Class_ID ClassID() { return Class_ID(SCALENOISE_CONTROL_CLASS_ID,0); }  
		SClass_ID SuperClassID() { return CTRL_SCALE_CLASS_ID; } 
		void GetClassName(TSTR& s) {s = SCALENOISE_CONTROL_CNAME;}

		// Control methods
		RefTargetHandle Clone(RemapDir& remap);

		// StdControl methods
		void GetValueLocalTime(TimeValue t, void *val, Interval &valid, GetSetMethod method=CTRL_ABSOLUTE);
		void SetValueLocalTime(TimeValue t, void *val, int commit, GetSetMethod method) {}		
		void Extrapolate(Interval range,TimeValue t,void *val,Interval &valid,int type);
		void *CreateTempValue() {return new ScaleValue;}
		void DeleteTempValue(void *val) {delete (ScaleValue*)val;}
		void ApplyValue(void *val, void *delta) {ApplyScaling( *((Matrix3*)val), *((ScaleValue*)delta) );}
		void MultiplyValue(void *val, float m) {*((ScaleValue*)val) *= m;}
	};


class ScaleNoiseClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { return new ScaleNoiseControl(); }
	const TCHAR *	ClassName() { return SCALENOISE_CONTROL_CNAME; }
	SClass_ID		SuperClassID() { return CTRL_SCALE_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(SCALENOISE_CONTROL_CLASS_ID,0);}
	const TCHAR* 	Category() { return _T("");  }
	};
static ScaleNoiseClassDesc scaleNoiseCD;
ClassDesc* GetScaleNoiseDesc() {return &scaleNoiseCD;}


//-----------------------------------------------------------------------------


class RangeRestore : public RestoreObj {
	public:
		BaseNoiseControl *cont;
		Interval ur, rr;
		RangeRestore(BaseNoiseControl *c) 
			{
			cont = c;
			ur   = cont->range;
			}   		
		void Restore(int isUndo) 
			{
			rr = cont->range;
			cont->range = ur;
			cont->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
			}
		void Redo()
			{
			cont->range = rr;
			cont->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
			}		
		void EndHold() 
			{ 
			cont->ClearAFlag(A_HELD);
			}
		TSTR Description() { return TSTR(_T("Noise control range")); }
	};


//-----------------------------------------------------------------
//
// UI

static LRESULT CALLBACK NoiseGraphWinProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

static void InitNoiseGraph(HINSTANCE hInst)
	{
	static BOOL init = FALSE;
	if (init) return;
	else init = TRUE;

	WNDCLASS wc;
	wc.style         = 0;
    wc.hInstance     = hInst;
    wc.hIcon         = NULL;
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
	wc.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wc.lpszMenuName  = NULL;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = 0;
    wc.lpfnWndProc   = NoiseGraphWinProc;
    wc.lpszClassName = _T("NoiseGraph");
		
	RegisterClass(&wc);	
	}


#define STEPSIZE			4
#define GRAPH_TIMESCALE		20

static void DrawNoiseGraph(BaseNoiseControl *cont,HWND hWnd,HDC hdc)
	{
	Rect rect, orect;
	GetClientRect(hWnd,&rect);
	orect = rect;
	float v, fy;
	int mid = rect.h()/2;
	rect.top    += 5;
	rect.bottom -= 5;
	TimeValue end = rect.right * GRAPH_TIMESCALE;

	SelectObject(hdc,CreatePen(PS_DOT,0,GetSysColor(COLOR_BTNFACE)));
	
	MoveToEx(hdc,0,mid,NULL);
	LineTo(hdc,rect.right,mid);
	MoveToEx(hdc,cont->rampin / GRAPH_TIMESCALE,0,NULL);
	LineTo(hdc,cont->rampin / GRAPH_TIMESCALE,rect.bottom);
	MoveToEx(hdc,rect.right - cont->rampout / GRAPH_TIMESCALE,0,NULL);
	LineTo(hdc,rect.right - cont->rampout / GRAPH_TIMESCALE,rect.bottom);

	DeleteObject(SelectObject(hdc,GetStockObject(BLACK_PEN)));

	for (int x = 0; x < rect.right + STEPSIZE; x += STEPSIZE) {
		int t = x*GRAPH_TIMESCALE;
		float ramp = 1.0f;
		
		// mjm 9.28.98
		// add a check for div by zero on cont->rampin
		// since x>=0, then t>=0, so t should never be < cont->rampin when cont->rampin is 0
		// but fix is added for symmetry with fix below
		if ( (cont->rampin != 0) && (t<cont->rampin) )
		{
			float u = float(t)/float(cont->rampin);
			ramp *= u*u * (3.0f-2.0f*u);
		}
		// mjm 9.28.98
		// bugfix -- add a check for div by zero on cont->rampout
		// because of STEPSIZE and GRAPH_TIMESCALE, t jumps from being < end to being > end.
		// when cont->rampout equals 0, (its default setting), then (t>end-cont->rampout) is TRUE,
		// leading to the div by zero
		if ( (cont->rampout != 0) && (t>end-cont->rampout) )
		{
			float u = float(end-t)/float(cont->rampout);
			ramp *= u*u * (3.0f-2.0f*u);
		}

		v = float(t) * float(0.005) * cont->frequency + Perm(cont->seed);
		if (cont->fractal) {
			fy = (float)fBm1(v, 1.0f-cont->roughness, 2.0f, 6 /*octaves*/);
		} else {
			fy = noise1(v);
			}
		fy *= ramp;

		if (!x) {
			MoveToEx(hdc,0,mid + int((rect.h()) * fy),NULL);
		} else {
			LineTo(hdc,x,mid + int((rect.h()) * fy));
			}
		}

	WhiteRect3D(hdc,orect,TRUE);
	}

static LRESULT CALLBACK NoiseGraphWinProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	BaseNoiseControl *cont = (BaseNoiseControl*)GetWindowLong(hWnd,GWL_USERDATA);
	if (!cont) return DefWindowProc(hWnd,msg,wParam,lParam);

	switch (msg) {		
		case WM_PAINT: {
			PAINTSTRUCT ps;
			HDC hdc = BeginPaint(hWnd,&ps);
			DrawNoiseGraph(cont,hWnd,hdc);
			EndPaint(hWnd,&ps);
			break;
			}

		default:
			return DefWindowProc(hWnd,msg,wParam,lParam);
		}
	
	return 0;
	}

//--------------------------------------------------------------

static BOOL CALLBACK NoiseDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

static int strengthSpinID[] = {IDC_NOISE_XSTRENGTHSPIN,IDC_NOISE_YSTRENGTHSPIN,IDC_NOISE_ZSTRENGTHSPIN};
static int strengthEditID[] = {IDC_NOISE_XSTRENGTH,IDC_NOISE_YSTRENGTH,IDC_NOISE_ZSTRENGTH};
static int strengthLabelID[] = {IDC_NOISE_XSTRENGTHLABEL,IDC_NOISE_YSTRENGTHLABEL,IDC_NOISE_ZSTRENGTHLABEL};
static int limID[] = {IDC_NOISE_XLIM0,IDC_NOISE_YLIM0,IDC_NOISE_ZLIM0};

#define NOISEDLG_CLASS_ID	0xaab659c4


class NoiseCtrlWindow {
	public:
		HWND hWnd;
		HWND hParent;
		Control *cont;
		NoiseCtrlWindow() {assert(0);}
		NoiseCtrlWindow(HWND hWnd,HWND hParent,Control *cont)
			{this->hWnd=hWnd; this->hParent=hParent; this->cont=cont;}
	};
static Tab<NoiseCtrlWindow> noiseCtrlWindows;

static void RegisterNoiseCtrlWindow(HWND hWnd, HWND hParent, Control *cont)
	{
	NoiseCtrlWindow rec(hWnd,hParent,cont);
	noiseCtrlWindows.Append(1,&rec);
	}

static void UnRegisterNoiseCtrlWindow(HWND hWnd)
	{	
	for (int i=0; i<noiseCtrlWindows.Count(); i++) {
		if (hWnd==noiseCtrlWindows[i].hWnd) {
			noiseCtrlWindows.Delete(i,1);
			return;
			}
		}	
	}

static HWND FindOpenNoiseCtrlWindow(HWND hParent,Control *cont)
	{	
	for (int i=0; i<noiseCtrlWindows.Count(); i++) {
		if (hParent == noiseCtrlWindows[i].hParent &&
			cont    == noiseCtrlWindows[i].cont) {
			return noiseCtrlWindows[i].hWnd;
			}
		}
	return NULL;
	}

class NoiseDlg : public ReferenceMaker, public TimeChangeCallback {
	public:
		BaseNoiseControl *cont;	
		ParamDimensionBase *dim;
		IObjParam *ip;
		HWND hWnd;
		BOOL valid;
		int elems;
		ISpinnerControl *iStrength[MAX_ELEMS];
		ISpinnerControl *iSeed, *iFreq, *iRough, *iRampIn, *iRampOut;

		NoiseDlg(
			BaseNoiseControl *cont,
			ParamDimensionBase *dim,
			TCHAR *pname,
			IObjParam *ip,
			HWND hParent);
		~NoiseDlg();

		Class_ID ClassID() {return Class_ID(NOISEDLG_CLASS_ID,0);}
		SClass_ID SuperClassID() {return REF_MAKER_CLASS_ID;}

		void MaybeCloseWindow();

		void TimeChanged(TimeValue t) {Invalidate();}

		void Invalidate();
		void Update();
		void SetupUI(HWND hWnd);
		void Change(BOOL redraw=FALSE);
		void WMCommand(int id, int notify, HWND hCtrl);
		void SpinnerChange(int id,BOOL drag);
		void SpinnerStart(int id);
		void SpinnerEnd(int id,BOOL cancel);

		RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
	         PartID& partID,  RefMessage message);
		int NumRefs() {return 1;}
		RefTargetHandle GetReference(int i) {return cont;}
		void SetReference(int i, RefTargetHandle rtarg) {cont=(BaseNoiseControl*)rtarg;}
	};


NoiseDlg::NoiseDlg(
		BaseNoiseControl *cont,
		ParamDimensionBase *dim,
		TCHAR *pname,
		IObjParam *ip,
		HWND hParent)
	{
	InitNoiseGraph(hInstance);
	this->cont = cont;
	this->ip   = ip;
	this->dim  = dim;
	valid = FALSE;
	elems = cont->Elems();

	theHold.Suspend();
	MakeRefByID(FOREVER,0,cont);
	theHold.Resume();

	hWnd = CreateDialogParam(
		hInstance,
		MAKEINTRESOURCE(IDD_NOISEPARAMS),
		hParent,
		NoiseDlgProc,
		(LPARAM)this);	
	TSTR title = TSTR(GetString(IDS_RB_NOISECONTROLTITLE)) + TSTR(pname);
	SetWindowText(hWnd,title);
	ip->RegisterTimeChangeCallback(this);
	}

NoiseDlg::~NoiseDlg()
	{
	UnRegisterNoiseCtrlWindow(hWnd);
	ip->UnRegisterTimeChangeCallback(this);

	theHold.Suspend();
	DeleteAllRefsFromMe();
	theHold.Resume();

	ReleaseISpinner(iSeed);
	ReleaseISpinner(iFreq);
	ReleaseISpinner(iRough);
	ReleaseISpinner(iRampIn);
	ReleaseISpinner(iRampOut);
	for (int i=0; i<elems; i++) {
		ReleaseISpinner(iStrength[i]);
		}
	}

void NoiseDlg::Invalidate()
	{
	valid = FALSE;
	InvalidateRect(hWnd,NULL,FALSE);	
	InvalidateRect(GetDlgItem(hWnd,IDC_NOISE_GRAPH),NULL,FALSE);
	}

void NoiseDlg::Update()
	{
	if (!valid && hWnd) {
		float strength[MAX_ELEMS];
		cont->GetStrength(ip->GetTime(),strength);

		for (int i=0; i<elems; i++) {			
			iStrength[i]->SetValue(dim->Convert(strength[i]),FALSE);
			iStrength[i]->SetKeyBrackets( cont->cont->IsKeyAtTime(ip->GetTime(), 0) ); // mjm - 3.1.99
			CheckDlgButton(hWnd,limID[i],cont->lim[i]);
			}
		iSeed->SetValue(cont->seed,FALSE);
		iFreq->SetValue(cont->frequency,FALSE);
		iRough->SetValue(cont->roughness,FALSE);
		iRampIn->SetValue(cont->rampin,FALSE);
		iRampOut->SetValue(cont->rampout,FALSE);
		if (cont->fractal) {
			CheckDlgButton(hWnd,IDC_NOISE_FRACTAL,TRUE);
			EnableWindow(GetDlgItem(hWnd,IDC_NOISE_ROUGHLABEL),TRUE);
			EnableWindow(GetDlgItem(hWnd,IDC_NOISE_ROUGHSPIN),TRUE);
		} else {
			CheckDlgButton(hWnd,IDC_NOISE_FRACTAL,FALSE);
			EnableWindow(GetDlgItem(hWnd,IDC_NOISE_ROUGHLABEL),FALSE);
			EnableWindow(GetDlgItem(hWnd,IDC_NOISE_ROUGHSPIN),FALSE);
			}
		valid = TRUE;
		}
	}

void NoiseDlg::SetupUI(HWND hWnd)
	{
	this->hWnd = hWnd;

	for (int i=0; i<elems; i++) {
		iStrength[i] = GetISpinner(GetDlgItem(hWnd,strengthSpinID[i]));
		iStrength[i]->SetLimits(-9999999,9999999,FALSE);
		iStrength[i]->SetAutoScale();
		iStrength[i]->LinkToEdit(GetDlgItem(hWnd,strengthEditID[i]),EDITTYPE_FLOAT);		
		}
	for ( ; i< MAX_ELEMS; i++) {
		ShowWindow(GetDlgItem(hWnd,strengthSpinID[i]),SW_HIDE);
		ShowWindow(GetDlgItem(hWnd,strengthEditID[i]),SW_HIDE);
		ShowWindow(GetDlgItem(hWnd,strengthLabelID[i]),SW_HIDE);
		ShowWindow(GetDlgItem(hWnd,limID[i]),SW_HIDE);
		}

	iSeed = GetISpinner(GetDlgItem(hWnd,IDC_NOISE_SEEDSPIN));
	iSeed->SetLimits(0,9999999,FALSE);
	iSeed->SetScale(0.1f);
	iSeed->LinkToEdit(GetDlgItem(hWnd,IDC_NOISE_SEED),EDITTYPE_INT);	

	iFreq = GetISpinner(GetDlgItem(hWnd,IDC_NOISE_FREQSPIN));
	iFreq->SetLimits(0.001f,10.0f,FALSE);
	iFreq->SetScale(0.005f);
	iFreq->LinkToEdit(GetDlgItem(hWnd,IDC_NOISE_FREQ),EDITTYPE_FLOAT);	

	iRough = GetISpinner(GetDlgItem(hWnd,IDC_NOISE_ROUGHSPIN));
	iRough->SetLimits(0.0f,1.0f,FALSE);
	iRough->SetScale(0.005f);
	iRough->LinkToEdit(GetDlgItem(hWnd,IDC_NOISE_ROUGH),EDITTYPE_FLOAT);	
	
	iRampIn = GetISpinner(GetDlgItem(hWnd,IDC_NOISE_RAMPINSPIN));
	iRampIn->SetLimits(0,TIME_PosInfinity,FALSE);
	iRampIn->SetScale(10.0f);
	iRampIn->LinkToEdit(GetDlgItem(hWnd,IDC_NOISE_RAMPIN),EDITTYPE_TIME);	
	
	iRampOut = GetISpinner(GetDlgItem(hWnd,IDC_NOISE_RAMPOUTSPIN));
	iRampOut->SetLimits(0,TIME_PosInfinity,FALSE);
	iRampOut->SetScale(10.0f);
	iRampOut->LinkToEdit(GetDlgItem(hWnd,IDC_NOISE_RAMPOUT),EDITTYPE_TIME);	
	
	if (elems==1) {		
		SetWindowText(GetDlgItem(hWnd,IDC_NOISE_XSTRENGTHLABEL),
			GetString(IDS_RB_STRENGTH));
		}
	
	SetWindowLong(GetDlgItem(hWnd,IDC_NOISE_GRAPH),GWL_USERDATA,(LONG)cont);
	valid = FALSE;
	Update();
	}

void NoiseDlg::WMCommand(int id, int notify, HWND hCtrl)
	{
	switch (id) {
		case IDC_NOISE_FRACTAL:
			cont->fractal = IsDlgButtonChecked(hWnd,id);
			Change(TRUE);
			break;

		case IDC_NOISE_XLIM0:
			cont->lim[0] = IsDlgButtonChecked(hWnd,id);
			Change(TRUE);
			break;
		case IDC_NOISE_YLIM0:
			cont->lim[1] = IsDlgButtonChecked(hWnd,id);
			Change(TRUE);
			break;
		case IDC_NOISE_ZLIM0:
			cont->lim[2] = IsDlgButtonChecked(hWnd,id);
			Change(TRUE);
			break;
		}
	}

void NoiseDlg::SpinnerChange(int id,BOOL drag)
	{
	float strength[MAX_ELEMS];
	BOOL strengthChange = FALSE;
	
	// RB 2/5/99: Added test to see if theHold is already holding. A right click on the
	// spinner causes both a mouse down and up (but drag is FALSE) so there is no need to
	// turn the hold on again.
	if (!drag && !theHold.Holding()) {
		SpinnerStart(id);
		}

	if (id==IDC_NOISE_XSTRENGTHSPIN ||
		id==IDC_NOISE_YSTRENGTHSPIN ||
		id==IDC_NOISE_ZSTRENGTHSPIN) {
		cont->GetStrength(ip->GetTime(),strength);
		}

	switch (id) {
		case IDC_NOISE_XSTRENGTHSPIN:
			strength[0] = dim->UnConvert(iStrength[0]->GetFVal());
			strengthChange = TRUE;
			Change(1);
			break;

		case IDC_NOISE_YSTRENGTHSPIN:
			strength[1] = dim->UnConvert(iStrength[1]->GetFVal());
			strengthChange = TRUE;
			Change(1);
			break;

		case IDC_NOISE_ZSTRENGTHSPIN:
			strength[2] = dim->UnConvert(iStrength[2]->GetFVal());
			strengthChange = TRUE;
			Change(1);
			break;

		case IDC_NOISE_SEEDSPIN:
			cont->seed = iSeed->GetIVal();
			Change(1);
			break;

		case IDC_NOISE_FREQSPIN:
			cont->frequency = iFreq->GetFVal();
			Change(1);
			break;	
		
		case IDC_NOISE_ROUGHSPIN:
			cont->roughness = iRough->GetFVal();
			Change(1);
			break;			

		case IDC_NOISE_RAMPINSPIN:
			cont->rampin = iRampIn->GetIVal();
			Change(1);
			break;

		case IDC_NOISE_RAMPOUTSPIN:
			cont->rampout = iRampOut->GetIVal();
			Change(1);
			break;
		}
	
	if (strengthChange) {
		cont->cont->SetValue(ip->GetTime(),strength);
		}
	}

void NoiseDlg::SpinnerStart(int id)
	{
	switch (id) {
		case IDC_NOISE_XSTRENGTHSPIN:
		case IDC_NOISE_YSTRENGTHSPIN:
		case IDC_NOISE_ZSTRENGTHSPIN:
			theHold.Begin();
			break;
		}
	}

void NoiseDlg::SpinnerEnd(int id,BOOL cancel)
	{
	switch (id) {
		case IDC_NOISE_XSTRENGTH:
		case IDC_NOISE_YSTRENGTH:
		case IDC_NOISE_ZSTRENGTH:
		case IDC_NOISE_XSTRENGTHSPIN:
		case IDC_NOISE_YSTRENGTHSPIN:
		case IDC_NOISE_ZSTRENGTHSPIN:
			if (cancel) {
				theHold.Cancel();
			} else {
				theHold.Accept(GetString(IDS_RB_CHANGESTRENGTH));
				}
			break;
		}
	ip->RedrawViews(ip->GetTime());
	}

void NoiseDlg::Change(BOOL redraw)
	{
	InvalidateRect(GetDlgItem(hWnd,IDC_NOISE_GRAPH),NULL,TRUE);
	cont->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	UpdateWindow(GetDlgItem(hWnd,IDC_NOISE_GRAPH));
	UpdateWindow(GetParent(hWnd));	
	if (redraw) ip->RedrawViews(ip->GetTime());
	}


class CheckForNonNoiseDlg : public DependentEnumProc {
	public:		
		BOOL non;
		ReferenceMaker *me;
		CheckForNonNoiseDlg(ReferenceMaker *m) {non = FALSE;me = m;}
		int proc(ReferenceMaker *rmaker) {
			if (rmaker==me) return 0;
			if (rmaker->SuperClassID()!=REF_MAKER_CLASS_ID &&
				rmaker->ClassID()!=Class_ID(NOISEDLG_CLASS_ID,0)) {
				non = TRUE;
				return 1;
				}
			return 0;
			}
	};
void NoiseDlg::MaybeCloseWindow()
	{
	CheckForNonNoiseDlg check(cont);
	cont->EnumDependents(&check);
	if (!check.non) {
		PostMessage(hWnd,WM_CLOSE,0,0);
		}
	}



RefResult NoiseDlg::NotifyRefChanged(
		Interval changeInt, 
		RefTargetHandle hTarget, 
     	PartID& partID,  
     	RefMessage message)
	{
	switch (message) {
		case REFMSG_CHANGE:
			Invalidate();			
			break;
		
		case REFMSG_REF_DELETED:
			MaybeCloseWindow();
			break;
		}
	return REF_SUCCEED;
	}


static BOOL CALLBACK NoiseDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	NoiseDlg *dlg = (NoiseDlg*)GetWindowLong(hWnd,GWL_USERDATA);

	switch (msg) {
		case WM_INITDIALOG:
			dlg = (NoiseDlg*)lParam;
			SetWindowLong(hWnd,GWL_USERDATA,lParam);
			dlg->SetupUI(hWnd);
			break;

		case CC_SPINNER_BUTTONDOWN:
			dlg->SpinnerStart(LOWORD(wParam));
			break;

		case CC_SPINNER_CHANGE:
			dlg->SpinnerChange(LOWORD(wParam),HIWORD(wParam));
			break;

		case WM_CUSTEDIT_ENTER:
			dlg->SpinnerEnd(LOWORD(wParam),FALSE);
			break;

		case CC_SPINNER_BUTTONUP:
			dlg->SpinnerEnd(LOWORD(wParam),!HIWORD(wParam));
			break;

		case WM_COMMAND:
			dlg->WMCommand(LOWORD(wParam),HIWORD(wParam),(HWND)lParam);						
			break;

		case WM_PAINT:
			dlg->Update();
			return 0;			
		
		case WM_CLOSE:
			DestroyWindow(hWnd);			
			break;

		case WM_DESTROY:						
			delete dlg;
			break;
		
		default:
			return FALSE;
		}
	return TRUE;
	}

void BaseNoiseControl::EditTrackParams(
		TimeValue t,
		ParamDimensionBase *dim,
		TCHAR *pname,
		HWND hParent,
		IObjParam *ip,
		DWORD flags)
	{
	HWND hCur = FindOpenNoiseCtrlWindow(hParent,this);
	if (hCur) {
		SetForegroundWindow(hCur);
		return;
		}

	NoiseDlg *dlg = new NoiseDlg(this,dim,pname,ip,hParent);
	RegisterNoiseCtrlWindow(dlg->hWnd,hParent,this);
	}

//------------------------------------------------------------

BaseNoiseControl::BaseNoiseControl() 
	{	
	for (int i=0; i<MAX_ELEMS; i++) {
		//strength[i] = 50.0f;
		lim[i] = FALSE;
		}
	fractal   = TRUE;
	roughness = 0.0f;
	frequency = 0.5f;	
	seed      = 0;	
	rampin = rampout = 0;
	range     = Interval(GetAnimStart(),GetAnimEnd());
	} 

BaseNoiseControl& BaseNoiseControl::operator=(const BaseNoiseControl& from)
	{
	ReplaceReference(Control::NumRefs(),from.cont);
	for (int i=0; i<MAX_ELEMS; i++) {
		//strength[i]  = from.strength[i];
		lim[i] = from.lim[i];
		}
	fractal   = from.fractal;
	roughness = from.roughness;
	frequency = from.frequency;
	seed      = from.seed;
	range     = from.range;
	rampin    = from.rampin;
	rampout   = from.rampout;
	return *this;
	}

int BaseNoiseControl::NumSubs() 
	{
	return Control::NumSubs()+1;
	}

Animatable* BaseNoiseControl::SubAnim(int i) 
	{
	if (i<Control::NumSubs()) return Control::SubAnim(i);
	return cont;
	}

TSTR BaseNoiseControl::SubAnimName(int i) 
	{
	if (i<Control::NumSubs()) 
		return Control::SubAnimName(i);
	return GetString(IDS_RB_NOISESTRENGTH);
	}

BOOL BaseNoiseControl::AssignController(Animatable *control,int subAnim) 
	{
	ReplaceReference(Control::NumRefs(),(Control*)control);
	return TRUE;
	}

int BaseNoiseControl::SubNumToRefNum(int subNum) 
	{	
	return Control::NumRefs();
	}

int BaseNoiseControl::NumRefs() 
	{
	return Control::NumRefs()+1;
	}

RefTargetHandle BaseNoiseControl::GetReference(int i) 
	{
	if (i<Control::NumRefs()) return Control::GetReference(i);
	return cont;
	}

void BaseNoiseControl::SetReference(int i, RefTargetHandle rtarg) 
	{
	if (i<Control::NumRefs()) Control::SetReference(i,rtarg);
	else cont = (Control*)rtarg;
	}

extern float noise1(float arg);

float BaseNoiseControl::NoiseAtTime(TimeValue t,int s,int index)
	{
	float ramp = 1.0f, res;
	
	// Limit to in range
	if (t<range.Start()) t = range.Start();
	if (t>range.End()) t = range.End();	
	
	// Compute ramping
	if (t<range.Start()+rampin) {
		float u = float(t-range.Start())/float(rampin);
		ramp *= u*u * (3.0f-2.0f*u);
		}
	if (t>range.End()-rampout) {
		float u = float(range.End()-t)/float(rampout);
		ramp *= u*u * (3.0f-2.0f*u);
		}

	// Compute noise
	float v = float(t) * float(0.005) * frequency + Perm(s);	
	if (fractal) {
		res = (float)fBm1(v, 1.0f-roughness, 2.0f, 6 /*octaves*/);
	} else {
		res = noise1(v);
		}
	if (lim[index]) {
		res = res+0.5f;
		}
	return res * ramp;
	}

void BaseNoiseControl::HoldRange()
	{
	if (theHold.Holding() && !TestAFlag(A_HELD)) {
		SetAFlag(A_HELD);
		theHold.Put(new RangeRestore(this));
		}
	}

void BaseNoiseControl::EditTimeRange(Interval range,DWORD flags)
	{
	if (!(flags&EDITRANGE_LINKTOKEYS)) {
		HoldRange();
		this->range = range;
		NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
		}
	}

void BaseNoiseControl::MapKeys(TimeMap *map,DWORD flags)
	{
	if (flags&TRACK_MAPRANGE) {
		HoldRange();
		TimeValue t0 = map->map(range.Start());
		TimeValue t1 = map->map(range.End());
		range.Set(t0,t1);
		NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
		}
	}


#define XSTRENGTH_CHUNK		0x0100
#define YSTRENGTH_CHUNK		0x0101
#define ZSTRENGTH_CHUNK		0x0102
#define FREQUENCY_CHUNK		0x0103
#define ROUGHNESS_CHUNK		0x0104
#define SEED_CHUNK			0x0105
#define FRACTAL_CHUNK		0x0106
#define RANGE_CHUNK			0x0107
#define RAMPIN_CHUNK		0x0108
#define RAMPOUT_CHUNK		0x0109
#define XLIM_CHUNK			0x0110
#define YLIM_CHUNK			0x0111
#define ZLIM_CHUNK			0x0112

IOResult BaseNoiseControl::Save(ISave *isave)
	{		
	ULONG nb;	

	for (int i=0; i<MAX_ELEMS; i++) {
		//isave->BeginChunk(XSTRENGTH_CHUNK+i);
		//isave->Write(&strength[i],sizeof(strength[i]),&nb);
		//isave->EndChunk();

		isave->BeginChunk(XLIM_CHUNK+i);
		isave->Write(&lim[i],sizeof(lim[i]),&nb);
		isave->EndChunk();
		}

	isave->BeginChunk(FREQUENCY_CHUNK);
	isave->Write(&frequency,sizeof(frequency),&nb);
	isave->EndChunk();
	
	isave->BeginChunk(ROUGHNESS_CHUNK);
	isave->Write(&roughness,sizeof(roughness),&nb);
	isave->EndChunk();
	
	isave->BeginChunk(SEED_CHUNK);
	isave->Write(&seed,sizeof(seed),&nb);
	isave->EndChunk();
	
	isave->BeginChunk(FRACTAL_CHUNK);
	isave->Write(&fractal,sizeof(fractal),&nb);
	isave->EndChunk();
	
	isave->BeginChunk(RANGE_CHUNK);
	isave->Write(&range,sizeof(range),&nb);
	isave->EndChunk();
	
	isave->BeginChunk(RAMPIN_CHUNK);
	isave->Write(&rampin,sizeof(rampin),&nb);
	isave->EndChunk();
	
	isave->BeginChunk(RAMPOUT_CHUNK);
	isave->Write(&rampout,sizeof(rampout),&nb);
	isave->EndChunk();
	
	return IO_OK;
	}

IOResult BaseNoiseControl::Load(ILoad *iload)
	{
	float strength[MAX_ELEMS];
	BOOL strengthRead=FALSE;
	ULONG nb;
	IOResult res = IO_OK;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch (iload->CurChunkID()) {
			case XSTRENGTH_CHUNK:
				res=iload->Read(&strength[0],sizeof(strength[0]),&nb);
				strengthRead = TRUE;
				break;

			case YSTRENGTH_CHUNK:
				res=iload->Read(&strength[1],sizeof(strength[1]),&nb);
				strengthRead = TRUE;
				break;

			case ZSTRENGTH_CHUNK:
				res=iload->Read(&strength[2],sizeof(strength[2]),&nb);
				strengthRead = TRUE;
				break;

			case XLIM_CHUNK:
				res=iload->Read(&lim[0],sizeof(lim[0]),&nb);
				break;
			case YLIM_CHUNK:
				res=iload->Read(&lim[1],sizeof(lim[1]),&nb);
				break;
			case ZLIM_CHUNK:
				res=iload->Read(&lim[2],sizeof(lim[2]),&nb);
				break;

			case FREQUENCY_CHUNK:
				res=iload->Read(&frequency,sizeof(frequency),&nb);
				break;

			case ROUGHNESS_CHUNK:
				res=iload->Read(&roughness,sizeof(roughness),&nb);
				break;

			case SEED_CHUNK:
				res=iload->Read(&seed,sizeof(seed),&nb);
				break;

			case FRACTAL_CHUNK:
				res=iload->Read(&fractal,sizeof(fractal),&nb);
				break;

			case RANGE_CHUNK:
				res=iload->Read(&range,sizeof(range),&nb);
				break;

			case RAMPIN_CHUNK:
				res=iload->Read(&rampin,sizeof(rampin),&nb);
				break;

			case RAMPOUT_CHUNK:
				res=iload->Read(&rampout,sizeof(rampout),&nb);
				break;
			}

		iload->CloseChunk();
		if (res!=IO_OK)  return res;
		}
	
	if (strengthRead) {
		cont->SetValue(0,strength);
		}
	return IO_OK;
	}


void BaseNoiseControl::SetSeed(int seed)
	{
	this->seed = seed;
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

void BaseNoiseControl::SetFrequency(float f)
	{
	frequency = f;
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

void BaseNoiseControl::SetFractal(BOOL f)
	{
	fractal = f;
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

void BaseNoiseControl::SetRoughness(float f)
	{
	roughness = f;
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

void BaseNoiseControl::SetRampIn(TimeValue in)
	{
	rampin = in;
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

void BaseNoiseControl::SetRampOut(TimeValue out)
	{
	rampout = out;
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

void BaseNoiseControl::SetPositiveOnly(int which,BOOL onOff)
	{
	lim[which] = onOff;
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}

void BaseNoiseControl::SetStrengthController(Control *c)
	{
	ReplaceReference(Control::NumRefs(),c);
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}



//--------------------------------------------------------------------

RefTargetHandle FloatNoiseControl::Clone(RemapDir& remap)
	{
	// make a new noise controller and give it our param values.
	FloatNoiseControl *cont = new FloatNoiseControl;
	*cont = *this;
	// Clone the strength controller
	cont->ReplaceReference(Control::NumRefs(),remap.CloneRef(cont->cont));
	CloneControl(cont,remap);
	return cont;
	}

void FloatNoiseControl::GetValueLocalTime(
		TimeValue t, void *val, Interval &valid, GetSetMethod method)
	{
	float strength;
	GetStrength(t,&strength);

	// This controller is always changing.
	valid.SetInstant(t);
	
	*((float*)val) = NoiseAtTime(t,seed,0) * strength;
	}

void FloatNoiseControl::Extrapolate(
		Interval range,TimeValue t,void *val,Interval &valid,int type)
	{
	float val0, val1, val2, res;
	switch (type) {
		case ORT_LINEAR:			
			if (t<range.Start()) {
				GetValueLocalTime(range.Start(),&val0,valid);
				GetValueLocalTime(range.Start()+1,&val1,valid);
				res = LinearExtrapolate(range.Start(),t,val0,val1,val0);				
			} else {
				GetValueLocalTime(range.End()-1,&val0,valid);
				GetValueLocalTime(range.End(),&val1,valid);
				res = LinearExtrapolate(range.End(),t,val0,val1,val1);
				}
			break;

		case ORT_IDENTITY:
			if (t<range.Start()) {
				GetValueLocalTime(range.Start(),&val0,valid);
				res = IdentityExtrapolate(range.Start(),t,val0);
			} else {
				GetValueLocalTime(range.End(),&val0,valid);
				res = IdentityExtrapolate(range.End(),t,val0);
				}
			break;

		case ORT_RELATIVE_REPEAT:
			GetValueLocalTime(range.Start(),&val0,valid);
			GetValueLocalTime(range.End(),&val1,valid);
			GetValueLocalTime(CycleTime(range,t),&val2,valid);
			res = RepeatExtrapolate(range,t,val0,val1,val2);			
			break;
		}
	valid.Set(t,t);
	*((float*)val) = res;
	}

//--------------------------------------------------------------------------

RefTargetHandle PositionNoiseControl::Clone(RemapDir& remap)
	{
	// make a new noise controller and give it our param values.
	PositionNoiseControl *cont = new PositionNoiseControl;
	*cont = *this;
	// Clone the strength controller
	cont->ReplaceReference(Control::NumRefs(),remap.CloneRef(cont->cont));
	CloneControl(cont,remap);
	return cont;
	}

void PositionNoiseControl::GetValueLocalTime(
		TimeValue t, void *val, Interval &valid, GetSetMethod method)
	{
	float strength[3];
	GetStrength(t,strength);

	// This controller is always changing.
	valid.SetInstant(t);
	
	*((Point3*)val) = Point3(
		NoiseAtTime(t,seed,0) * strength[0],
		NoiseAtTime(t,seed+1,1) * strength[1],
		NoiseAtTime(t,seed+2,2) * strength[2] );
	}

void PositionNoiseControl::Extrapolate(
		Interval range,TimeValue t,void *val,Interval &valid,int type)
	{
	Point3 val0, val1, val2, res;
	switch (type) {
		case ORT_LINEAR:			
			if (t<range.Start()) {
				GetValueLocalTime(range.Start(),&val0,valid);
				GetValueLocalTime(range.Start()+1,&val1,valid);
				res = LinearExtrapolate(range.Start(),t,val0,val1,val0);				
			} else {
				GetValueLocalTime(range.End()-1,&val0,valid);
				GetValueLocalTime(range.End(),&val1,valid);
				res = LinearExtrapolate(range.End(),t,val0,val1,val1);
				}
			break;

		case ORT_IDENTITY:
			if (t<range.Start()) {
				GetValueLocalTime(range.Start(),&val0,valid);
				res = IdentityExtrapolate(range.Start(),t,val0);
			} else {
				GetValueLocalTime(range.End(),&val0,valid);
				res = IdentityExtrapolate(range.End(),t,val0);
				}
			break;

		case ORT_RELATIVE_REPEAT:
			GetValueLocalTime(range.Start(),&val0,valid);
			GetValueLocalTime(range.End(),&val1,valid);
			GetValueLocalTime(CycleTime(range,t),&val2,valid);
			res = RepeatExtrapolate(range,t,val0,val1,val2);			
			break;
		}
	valid.Set(t,t);
	*((Point3*)val) = res;
	}

//--------------------------------------------------------------------------


RefTargetHandle Point3NoiseControl::Clone(RemapDir& remap)
	{
	// make a new noise controller and give it our param values.
	Point3NoiseControl *cont = new Point3NoiseControl;
	*cont = *this;	
	// Clone the strength controller
	cont->ReplaceReference(Control::NumRefs(),remap.CloneRef(cont->cont));
	CloneControl(cont,remap);
	return cont;
	}

void Point3NoiseControl::GetValueLocalTime(
		TimeValue t, void *val, Interval &valid, GetSetMethod method)
	{
	float strength[3];
	GetStrength(t,strength);

	// This controller is always changing.
	valid.SetInstant(t);
	
	*((Point3*)val) = Point3(
		NoiseAtTime(t,seed,0) * strength[0],
		NoiseAtTime(t,seed+1,1) * strength[1],
		NoiseAtTime(t,seed+2,2) * strength[2] );
	}

void Point3NoiseControl::Extrapolate(
		Interval range,TimeValue t,void *val,Interval &valid,int type)
	{
	Point3 val0, val1, val2, res;
	switch (type) {
		case ORT_LINEAR:			
			if (t<range.Start()) {
				GetValueLocalTime(range.Start(),&val0,valid);
				GetValueLocalTime(range.Start()+1,&val1,valid);
				res = LinearExtrapolate(range.Start(),t,val0,val1,val0);				
			} else {
				GetValueLocalTime(range.End()-1,&val0,valid);
				GetValueLocalTime(range.End(),&val1,valid);
				res = LinearExtrapolate(range.End(),t,val0,val1,val1);
				}
			break;

		case ORT_IDENTITY:
			if (t<range.Start()) {
				GetValueLocalTime(range.Start(),&val0,valid);
				res = IdentityExtrapolate(range.Start(),t,val0);
			} else {
				GetValueLocalTime(range.End(),&val0,valid);
				res = IdentityExtrapolate(range.End(),t,val0);
				}
			break;

		case ORT_RELATIVE_REPEAT:
			GetValueLocalTime(range.Start(),&val0,valid);
			GetValueLocalTime(range.End(),&val1,valid);
			GetValueLocalTime(CycleTime(range,t),&val2,valid);
			res = RepeatExtrapolate(range,t,val0,val1,val2);			
			break;
		}
	valid.Set(t,t);
	*((Point3*)val) = res;
	}

//--------------------------------------------------------------------------



RefTargetHandle RotationNoiseControl::Clone(RemapDir& remap)
	{
	// make a new noise controller and give it our param values.
	RotationNoiseControl *cont = new RotationNoiseControl;
	*cont = *this;	
	// Clone the strength controller
	cont->ReplaceReference(Control::NumRefs(),remap.CloneRef(cont->cont));
	CloneControl(cont,remap);
	return cont;
	}

void RotationNoiseControl::GetValueLocalTime(
		TimeValue t, void *val, Interval &valid, GetSetMethod method)
	{
	float strength[3];
	GetStrength(t,strength);

	// This controller is always changing.
	valid.SetInstant(t);
	float ang[3];

	ang[0] = NoiseAtTime(t,seed,0) * strength[0];
	ang[1] = NoiseAtTime(t,seed+1,1) * strength[1];
	ang[2] = NoiseAtTime(t,seed+2,2) * strength[2];
	
	EulerToQuat(ang,*((Quat*)val));		
	}

void RotationNoiseControl::Extrapolate(
		Interval range,TimeValue t,void *val,Interval &valid,int type)
	{
	Quat val0, val1, val2, res;
	switch (type) {
		case ORT_LINEAR:			
			if (t<range.Start()) {
				GetValueLocalTime(range.Start(),&val0,valid);
				GetValueLocalTime(range.Start()+1,&val1,valid);
				res = LinearExtrapolate(range.Start(),t,val0,val1,val0);				
			} else {
				GetValueLocalTime(range.End()-1,&val0,valid);
				GetValueLocalTime(range.End(),&val1,valid);
				res = LinearExtrapolate(range.End(),t,val0,val1,val1);
				}
			break;

		case ORT_IDENTITY:
			if (t<range.Start()) {
				GetValueLocalTime(range.Start(),&val0,valid);
				res = IdentityExtrapolate(range.Start(),t,val0);
			} else {
				GetValueLocalTime(range.End(),&val0,valid);
				res = IdentityExtrapolate(range.End(),t,val0);
				}
			break;

		case ORT_RELATIVE_REPEAT:
			GetValueLocalTime(range.Start(),&val0,valid);
			GetValueLocalTime(range.End(),&val1,valid);
			GetValueLocalTime(CycleTime(range,t),&val2,valid);
			res = RepeatExtrapolate(range,t,val0,val1,val2);			
			break;
		}
	valid.Set(t,t);
	*((Quat*)val) = res;
	}

//--------------------------------------------------------------------------



RefTargetHandle ScaleNoiseControl::Clone(RemapDir& remap)
	{
	// make a new noise controller and give it our param values.
	ScaleNoiseControl *cont = new ScaleNoiseControl;
	*cont = *this;
	// Clone the strength controller
	cont->ReplaceReference(Control::NumRefs(),remap.CloneRef(cont->cont));
	CloneControl(cont,remap);
	return cont;
	}

void ScaleNoiseControl::GetValueLocalTime(
		TimeValue t, void *val, Interval &valid, GetSetMethod method)
	{
	float strength[3];
	GetStrength(t,strength);

	// This controller is always changing.
	valid.SetInstant(t);
	
	*((ScaleValue*)val) = ScaleValue(
		Point3(
			1.0f + NoiseAtTime(t,seed,0) * strength[0],
			1.0f + NoiseAtTime(t,seed+1,1) * strength[1],
			1.0f + NoiseAtTime(t,seed+2,2) * strength[2] ),
		Quat(0.0,0.0,0.0,1.0));
	}

void ScaleNoiseControl::Extrapolate(
		Interval range,TimeValue t,void *val,Interval &valid,int type)
	{
	ScaleValue val0, val1, val2, res;
	switch (type) {
		case ORT_LINEAR:			
			if (t<range.Start()) {
				GetValueLocalTime(range.Start(),&val0,valid);
				GetValueLocalTime(range.Start()+1,&val1,valid);
				res = LinearExtrapolate(range.Start(),t,val0,val1,val0);				
			} else {
				GetValueLocalTime(range.End()-1,&val0,valid);
				GetValueLocalTime(range.End(),&val1,valid);
				res = LinearExtrapolate(range.End(),t,val0,val1,val1);
				}
			break;

		case ORT_IDENTITY:
			if (t<range.Start()) {
				GetValueLocalTime(range.Start(),&val0,valid);
				res = IdentityExtrapolate(range.Start(),t,val0);
			} else {
				GetValueLocalTime(range.End(),&val0,valid);
				res = IdentityExtrapolate(range.End(),t,val0);
				}
			break;

		case ORT_RELATIVE_REPEAT:
			GetValueLocalTime(range.Start(),&val0,valid);
			GetValueLocalTime(range.End(),&val1,valid);
			GetValueLocalTime(CycleTime(range,t),&val2,valid);
			res = RepeatExtrapolate(range,t,val0,val1,val2);			
			break;
		}
	valid.Set(t,t);
	*((ScaleValue*)val) = res;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Control\noise.h ===
//
//	Misc. noise functions from Texturing and Modeling A Procedural Approach
//  Perlin, Musgrave...
//

float bias(float a, float b);
float gain(float a, float b);

float noise1(float arg);
float noise2(float vec[]);
float noise3(float vec[]);

float turbulence(float *v, float freq);
int Perm(int v);

#define MAX_OCTAVES	50

double fBm1(double point, double H, double lacunarity, double octaves);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Control\linkctrl.cpp ===
/**********************************************************************
 *<
	FILE: linkctrl.cpp

	DESCRIPTION: An animated link controller

	CREATED BY: Rolf Berteig

	HISTORY: 1/25/97

 *>	Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/
#include "ctrl.h"
#include "units.h"
#include "istdplug.h"

#define LINKCTRL_NAME		GetString(IDS_RB_LINKCTRL)

class LinkCtrl;

class PickLinkMode : 
		public PickModeCallback,
		public PickNodeCallback {
	public:		
		LinkCtrl *cont;
		
		PickLinkMode(LinkCtrl *c) {cont=c;}
		BOOL HitTest(IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags);
		BOOL Pick(IObjParam *ip,ViewExp *vpt);
		void EnterMode(IObjParam *ip);
		void ExitMode(IObjParam *ip);
		BOOL RightClick(IObjParam *ip,ViewExp *vpt)	{return TRUE;}
		BOOL Filter(INode *node);		
		PickNodeCallback *GetFilter() {return this;}
	};

class LinkCtrl : public ILinkCtrl {
	public:
		Control *tmControl;		// ref 0
		Tab<INode*> nodes;		// ref 1-n
		Tab<TimeValue> times;

		static HWND hWnd;
		static IObjParam *ip;
		static LinkCtrl *editCont;
		static ISpinnerControl *iTime;
		static ICustButton *iPickOb, *iDelOb;
		static PickLinkMode *pickLinkMode;
		static BOOL valid;

		LinkCtrl(BOOL loading=FALSE);

		// Animatable methods
		void DeleteThis() {delete this;}		
		Class_ID ClassID() {return LINKCTRL_CLASSID;}
		SClass_ID SuperClassID() {return CTRL_MATRIX3_CLASS_ID;}
		void GetClassName(TSTR& s) {s = LINKCTRL_NAME;}
		void BeginEditParams(IObjParam *ip, ULONG flags,Animatable *prev); 
		void EndEditParams(IObjParam *ip, ULONG flags,Animatable *next); 
		int NumSubs()  {return 1;}
		Animatable* SubAnim(int i) {return tmControl;}
		TSTR SubAnimName(int i) {return GetString(IDS_RB_TRANSFORM);}		

		// Reference methods
		RefResult NotifyRefChanged(Interval, RefTargetHandle, PartID&, RefMessage);
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);
		RefTargetHandle Clone(RemapDir &remap = NoRemap());
		int NumRefs() {return 1+nodes.Count();}
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);
		BOOL AssignController(Animatable *control,int subAnim);

		// Control methods				
		void Copy(Control *from);
		BOOL IsLeaf() {return FALSE;}
		void CommitValue(TimeValue t) {}
		void RestoreValue(TimeValue t) {}
		void GetValue(TimeValue t, void *val, Interval &valid, GetSetMethod method=CTRL_ABSOLUTE);
		void SetValue(TimeValue t, void *val, int commit=1, GetSetMethod method=CTRL_ABSOLUTE);
		BOOL InheritsParentTransform() {return FALSE;}
		BOOL CanInstanceController() {return FALSE;}

		// Animatable methods		
		void CopyKeysFromTime(TimeValue src,TimeValue dst,DWORD flags) {tmControl->CopyKeysFromTime(src,dst,flags);}
		BOOL IsKeyAtTime(TimeValue t,DWORD flags) {return tmControl->IsKeyAtTime(t,flags);}
		BOOL GetNextKeyTime(TimeValue t,DWORD flags,TimeValue &nt) {return tmControl->GetNextKeyTime(t,flags,nt);}
		int GetKeyTimes(Tab<TimeValue> &times,Interval range,DWORD flags) {return tmControl->GetKeyTimes(times,range,flags);}
		int GetKeySelState(BitArray &sel,Interval range,DWORD flags) {return tmControl->GetKeySelState(sel,range,flags);}
		Control *GetPositionController() {return tmControl->GetPositionController();}
		Control *GetRotationController() {return tmControl->GetRotationController();}
		Control *GetScaleController() {return tmControl->GetScaleController();}
		BOOL SetPositionController(Control *c) {return tmControl->SetPositionController(c);}
		BOOL SetRotationController(Control *c) {return tmControl->SetRotationController(c);}
		BOOL SetScaleController(Control *c) {return tmControl->SetScaleController(c);}
		void MapKeys(TimeMap *map,DWORD flags);

		// From ILinkCtrl
		int GetParentCount() {return nodes.Count();}
		TimeValue GetLinkTime(int i) {return times[i];}
		void SetLinkTime(int i,TimeValue t) {SetTime(t,i);}
		void LinkTimeChanged() {SortNodes(-1);}

		// Local methods
		Matrix3 GetParentTM(TimeValue t,Interval *valid=NULL);
		Matrix3 CompTM(TimeValue t, int i);
		void AddNewLink(INode *node,TimeValue t);
		void DeleteLink(int i);
		void SetTime(TimeValue t,int i);
		void SortNodes(int sel);

		void SetupDialog(HWND hWnd);
		void DestroyDialog();
		void SetupList(int sel=-1);
		void ListSelChanged();
		void Invalidate();
		void Update();
	};


class LinksRestore : public RestoreObj {
	public:
		LinkCtrl *cont;
		Tab<INode*> unodes;
		Tab<INode*> rnodes;
		Tab<TimeValue> utimes;
		Tab<TimeValue> rtimes;

		LinksRestore(LinkCtrl *c) {
			cont = c;
			unodes = cont->nodes;
			utimes = cont->times;
			}
		void Restore(int isUndo) {
			if (isUndo) {
				rnodes = cont->nodes;
				rtimes = cont->times;
				}
			cont->nodes = unodes;
			cont->times = utimes;
			cont->NotifyDependents(FOREVER,0,REFMSG_CHANGE);
			cont->NotifyDependents(FOREVER,0,REFMSG_SUBANIM_STRUCTURE_CHANGED);
			cont->Invalidate();
			}
		void Redo() {
			cont->nodes = rnodes;
			cont->times = rtimes;
			cont->NotifyDependents(FOREVER,0,REFMSG_CHANGE);
			cont->NotifyDependents(FOREVER,0,REFMSG_SUBANIM_STRUCTURE_CHANGED);
			cont->Invalidate();
			}	
		void EndHold() {cont->ClearAFlag(A_HELD);}
	};



//--- Class Descriptor ----------------------------------------------

HWND			 LinkCtrl::hWnd = NULL;
IObjParam		*LinkCtrl::ip = NULL;
LinkCtrl		*LinkCtrl::editCont = NULL;
ISpinnerControl *LinkCtrl::iTime = NULL;
ICustButton		*LinkCtrl::iPickOb = NULL;
ICustButton		*LinkCtrl::iDelOb = NULL;
PickLinkMode    *LinkCtrl::pickLinkMode = NULL;
BOOL             LinkCtrl::valid = FALSE;
  
class LinkCtrlClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading) {return new LinkCtrl(loading);}
	const TCHAR *	ClassName() {return LINKCTRL_NAME;}
	SClass_ID		SuperClassID() {return CTRL_MATRIX3_CLASS_ID; }
	Class_ID		ClassID() {return LINKCTRL_CLASSID;}
	const TCHAR* 	Category() {return _T("");}
	};
static LinkCtrlClassDesc linkCtrlCD;
ClassDesc* GetLinkCtrlDesc() {return &linkCtrlCD;}

BOOL CALLBACK LinkParamDialogProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);


//--- LinkCtrl methods -----------------------------------------------

LinkCtrl::LinkCtrl(BOOL loading)
	{
	tmControl = NULL;
	if (!loading) {
		Control *cont;
		ClassDesc *desc = GetDefaultController(CTRL_MATRIX3_CLASS_ID);
		if (desc && desc->ClassID()==ClassID()) {
			cont = (Control*)CreateInstance(CTRL_MATRIX3_CLASS_ID, Class_ID(PRS_CONTROL_CLASS_ID,0));			
		} else {
			cont = NewDefaultMatrix3Controller();
			}
		ReplaceReference(0,cont);
		}
	}

void LinkCtrl::BeginEditParams(
		IObjParam *ip, ULONG flags,Animatable *prev)
	{
	if (flags&BEGIN_EDIT_MOTION) {
		this->ip = ip;
		editCont = this;	
		hWnd = ip->AddRollupPage( 
			hInstance, 
			MAKEINTRESOURCE(IDD_LINK_PARAMS),
			LinkParamDialogProc,
			GetString(IDS_RB_LINKPARAMS), 
			(LPARAM)this);	
		pickLinkMode = new PickLinkMode(this);
		tmControl->BeginEditParams(ip,flags,NULL);
		}
	}

void LinkCtrl::EndEditParams(
		IObjParam *ip, ULONG flags,Animatable *next)
	{
	if (editCont) {
		ip->ClearPickMode();
		tmControl->EndEditParams(ip,flags,NULL);
		ip->DeleteRollupPage(hWnd);	
		hWnd     = NULL;
		ip       = NULL;
		editCont = NULL;	
		delete pickLinkMode;
		pickLinkMode = NULL;
		}
	}


RefResult LinkCtrl::NotifyRefChanged(
		Interval iv, RefTargetHandle hTarg, 
		PartID& partID, RefMessage msg)
	{
	switch (msg) {
		case REFMSG_TARGET_DELETED: {
			for (int i=nodes.Count()-1; i>=0; i--) {
				if (nodes[i]==hTarg) DeleteLink(i);
				}
			break;
			}
		}
	return REF_SUCCEED;
	}

#define LINKCOUNT_CHUNK	0x0100
#define TIMES_CHUNK		0x0110

IOResult LinkCtrl::Save(ISave *isave)
	{
	ULONG nb;
	int ct = nodes.Count();
	
	isave->BeginChunk(LINKCOUNT_CHUNK);
	isave->Write(&ct,sizeof(ct),&nb);
	isave->EndChunk();

	if (ct) {
		isave->BeginChunk(TIMES_CHUNK);
		isave->Write(times.Addr(0),sizeof(TimeValue)*ct,&nb);
		isave->EndChunk();
		}

	return IO_OK;
	}

IOResult LinkCtrl::Load(ILoad *iload)
	{
	ULONG nb;
	int ct;	
	IOResult res;
		
	while (IO_OK==(res=iload->OpenChunk())) {
		switch (iload->CurChunkID()) {
			case LINKCOUNT_CHUNK: {
				iload->Read(&ct,sizeof(ct),&nb);
				nodes.SetCount(ct);
				times.SetCount(ct);
				for (int i=0; i<ct; i++) nodes[i] = NULL;
				break;
				}

			case TIMES_CHUNK:
				iload->Read(times.Addr(0),sizeof(TimeValue)*ct,&nb);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK)  return res;
		}

	return IO_OK;
	}


RefTargetHandle LinkCtrl::Clone(RemapDir &remap)
	{
	LinkCtrl *ctrl = new LinkCtrl();
	ctrl->ReplaceReference(0,remap.CloneRef(tmControl));
	ctrl->nodes.SetCount(nodes.Count());
	ctrl->times.SetCount(times.Count());
	for (int i=0; i<nodes.Count(); i++) {
		ctrl->nodes[i] = NULL;
		ctrl->ReplaceReference(i+1,nodes[i]);
		ctrl->times[i] = times[i];
		}
	return ctrl;
	}

RefTargetHandle LinkCtrl::GetReference(int i)
	{
	if (i==0) return tmControl;
	return nodes[i-1];
	}

void LinkCtrl::SetReference(int i, RefTargetHandle rtarg)
	{
	if (i==0) tmControl = (Control*)rtarg;
	else nodes[i-1] = (INode*)rtarg;
	}

BOOL LinkCtrl::AssignController(Animatable *control,int subAnim)
	{
	if (control->ClassID()==ClassID()) return FALSE;
	ReplaceReference(0,(ReferenceTarget*)control);
	NotifyDependents(FOREVER,0,REFMSG_CHANGE);
	NotifyDependents(FOREVER,0,REFMSG_SUBANIM_STRUCTURE_CHANGED);
	return TRUE;
	}

void LinkCtrl::Copy(Control *from)
	{
	if (from->ClassID()==ClassID()) {
		LinkCtrl *lc = (LinkCtrl*)from;
		ReplaceReference(0,(ReferenceTarget*)lc->tmControl->Clone());
	} else {
		ReplaceReference(0,(ReferenceTarget*)from->Clone());
		}
	NotifyDependents(FOREVER,0,REFMSG_CHANGE);
	NotifyDependents(FOREVER,0,REFMSG_SUBANIM_STRUCTURE_CHANGED);
	}

void LinkCtrl::GetValue(
		TimeValue t, void *val, Interval &valid, 
		GetSetMethod method)
	{
	Matrix3 *ptm = (Matrix3*)val;
	*ptm = GetParentTM(t,&valid);
	tmControl->GetValue(t,val,valid,method);
	}

void LinkCtrl::SetValue(
		TimeValue t, void *val, int commit, 
		GetSetMethod method)
	{
	SetXFormPacket *pckt = (SetXFormPacket*)val;
	pckt->tmParent = GetParentTM(t);
	tmControl->SetValue(t,val,commit,method);
	}


Matrix3 LinkCtrl::CompTM(TimeValue t, int i)
	{
	Matrix3 rtm(1);
	if (i) {
		// Evaluate the tm of the previous node the instant of the switch
		Matrix3 pptm = CompTM(times[i],i-1);
		 
		// Evaluate the tm of this node the instant of the switch
		Matrix3 ptm = nodes[i]->GetNodeTM(times[i]);
		
		rtm = pptm*Inverse(ptm);
		}
	return rtm*nodes[i]->GetNodeTM(t);
	}

Matrix3 LinkCtrl::GetParentTM(TimeValue t,Interval *valid)
	{
	if (!nodes.Count()) return Matrix3(1);	
	for (int i=0; i<nodes.Count(); i++) {
		if (times[i]>t) {
			if (i) i--;
			break;
			}
		}
	if (i>nodes.Count()-1) i = nodes.Count()-1;

	// Compute a matrix that adjusts the transitions between links so
	// as to maintain continuity
	Matrix3 rtm(1);
	if (i) {
		// Evaluate (recursively) the tm of the previous node the instant of the switch
		//Matrix3 pptm = nodes[i-1]->GetNodeTM(times[i]);
		Matrix3 pptm = CompTM(times[i],i-1);
			
		// Evaluate the tm of this node the instant of the switch
		Matrix3 ptm = nodes[i]->GetNodeTM(times[i]);
		
		rtm = pptm*Inverse(ptm);
		}
	
	// Validity is limited to the duration of this link
	if (valid) {
		Interval iv = FOREVER;
		if (i) iv.SetStart(times[i]);
		if (i<times.Count()-1) iv.SetEnd(times[i+1]);
		*valid &= iv;
		}

	return rtm*nodes[i]->GetNodeTM(t,valid);
	}


void LinkCtrl::AddNewLink(INode *node,TimeValue t)
	{
	if (theHold.Holding() && !TestAFlag(A_HELD)) 
		theHold.Put(new LinksRestore(this));	
	
	if (!nodes.Count()) {		
		Matrix3 tm(1), ntm = node->GetNodeTM(t), itm(1);
		tmControl->GetValue(t,&tm,FOREVER,CTRL_RELATIVE);
		tmControl->ChangeParents(t,itm,ntm,tm);
		}
	
	for (int i=0; i<nodes.Count(); i++) {
		if (times[i]>t) break;
		}
	nodes.Insert(i,1,&node);
	times.Insert(i,1,&t);
	MakeRefByID(FOREVER,i+1,node);
	NotifyDependents(FOREVER,0,REFMSG_CHANGE);
	SetupList(i);
	}

void LinkCtrl::DeleteLink(int i)
	{
	if (nodes.Count()==1) {
		TimeValue t = GetCOREInterface()->GetTime();
		Matrix3 ptm = GetParentTM(t);
		Matrix3 itm(1), tm = ptm;
		tmControl->GetValue(t,&tm,FOREVER,CTRL_RELATIVE);
		tmControl->ChangeParents(t,ptm,itm,tm);
		}

	DeleteReference(i+1);
	if (theHold.Holding() && !TestAFlag(A_HELD)) 
		theHold.Put(new LinksRestore(this));
	nodes.Delete(i,1);
	times.Delete(i,1);
	NotifyDependents(FOREVER,0,REFMSG_CHANGE);
	if (hWnd && editCont==this) SetupList();
	}

void LinkCtrl::SetTime(TimeValue t,int i)
	{
	if (theHold.Holding() && !TestAFlag(A_HELD)) {
		theHold.Put(new LinksRestore(this));
		SetAFlag(A_HELD);
		}
	times[i] = t;
	SortNodes(i);
	NotifyDependents(FOREVER,0,REFMSG_CHANGE);
	}

void LinkCtrl::MapKeys(TimeMap *map,DWORD flags)
	{	
	if (theHold.Holding() && !TestAFlag(A_HELD)) {
		theHold.Put(new LinksRestore(this));
		SetAFlag(A_HELD);
		}

	for (int i=0; i<times.Count(); i++) {
		times[i] = map->map(times[i]);
		}
	
	if (hWnd && editCont==this) SetupList();
	NotifyDependents(FOREVER,0,REFMSG_CHANGE);
	}

static LinkCtrl *theSortCtrl = NULL;
static int __cdecl CompareNodes(const void *a, const void *b)
	{
	int *aa = (int*)a;
	int *bb = (int*)b;
	assert(theSortCtrl);
	return theSortCtrl->times[*aa] - theSortCtrl->times[*bb];
	}

void LinkCtrl::SortNodes(int sel)
	{
	// Setup a map for a shell sort
	Tab<int> map;
	map.SetCount(nodes.Count());	
	for (int i=0; i<map.Count(); i++) map[i] = i;

	// Sort
	theSortCtrl = this;
	map.Sort(CompareNodes);

	// Put everything in the right place
	Tab<INode*> onodes = nodes;
	Tab<TimeValue> otimes = times;
	for (i=0; i<nodes.Count(); i++) {
		nodes[i] = onodes[map[i]];
		times[i] = otimes[map[i]];
		}

	// Redo the list selecting the node in its new place
	if (sel>=0) {
		for (i=0; i<map.Count(); i++) {
			if (map[i]==sel) {
				SetupList(i);
				break;
				}
			}
		}
	}


//--- UI ------------------------------------------------------------


static BOOL CALLBACK LinkParamDialogProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	LinkCtrl *cont = (LinkCtrl*)GetWindowLong(hWnd,GWL_USERDATA);

	switch (msg) {
		case WM_INITDIALOG:
			cont = (LinkCtrl*)lParam;
			SetWindowLong(hWnd,GWL_USERDATA,lParam);
			cont->SetupDialog(hWnd);
			break;

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_LINK_PICK:
					cont->ip->SetPickMode(cont->pickLinkMode);
					break;

				case IDC_LINK_DELETE: {
					int sel = SendDlgItemMessage(hWnd,IDC_LINK_LIST,LB_GETCURSEL,0,0);
					if (sel!=LB_ERR) {
						theHold.Begin();
						cont->DeleteLink(sel);
						theHold.Accept(GetString(IDS_RB_DELETELINK));
						cont->ip->RedrawViews(cont->ip->GetTime());
						}
					break;
					}

				case IDC_LINK_LIST:
					if (HIWORD(wParam)==LBN_SELCHANGE) {
						cont->ListSelChanged();
						}
					break;
				}
			break;

		case CC_SPINNER_BUTTONDOWN:
			theHold.Begin();
			break;

		case CC_SPINNER_CHANGE: {			
			ISpinnerControl *spin = (ISpinnerControl*)lParam;
			int sel = SendDlgItemMessage(hWnd,IDC_LINK_LIST,LB_GETCURSEL,0,0);
			if (sel!=LB_ERR) cont->SetTime(spin->GetIVal(),sel);
			cont->ip->RedrawViews(cont->ip->GetTime());
			break;
			}

		case CC_SPINNER_BUTTONUP:
			if (HIWORD(wParam)) {
				theHold.Accept(GetString(IDS_RB_SETLINKTIME));
			} else {
				theHold.Cancel();
				}
			cont->ip->RedrawViews(cont->ip->GetTime());
			break;

		case WM_PAINT:
			cont->Update();
			return FALSE;

		case WM_DESTROY:
			cont->DestroyDialog();
			break;

		default:
			return FALSE;
		}
	return TRUE;
	}

void LinkCtrl::SetupDialog(HWND hWnd)
	{
	this->hWnd = hWnd;

	iTime = GetISpinner(GetDlgItem(hWnd,IDC_LINK_TIMESPIN));
	iTime->SetLimits(TIME_NegInfinity,TIME_PosInfinity,FALSE);
	iTime->SetScale(10.0f);
	iTime->LinkToEdit(GetDlgItem(hWnd,IDC_LINK_TIME),EDITTYPE_TIME);

	iPickOb = GetICustButton(GetDlgItem(hWnd,IDC_LINK_PICK));
	iDelOb  = GetICustButton(GetDlgItem(hWnd,IDC_LINK_DELETE));

	iPickOb->SetType(CBT_CHECK);
	iPickOb->SetHighlightColor(GREEN_WASH);

	SetupList();	
	}

void LinkCtrl::DestroyDialog()
	{
	ReleaseISpinner(iTime);
	ReleaseICustButton(iPickOb);
	ReleaseICustButton(iDelOb);
	iTime = NULL;
	iPickOb = NULL;
	iDelOb = NULL;
	}

void LinkCtrl::SetupList(int sel)
	{
	if (!hWnd || editCont!=this) return;
	int csel = SendDlgItemMessage(hWnd,IDC_LINK_LIST,LB_GETCURSEL,0,0);
	if (sel>=0) csel = sel;
	SendDlgItemMessage(hWnd,IDC_LINK_LIST,LB_RESETCONTENT,0,0);
	for (int i=0; i<nodes.Count(); i++) {
		SendDlgItemMessage(hWnd,IDC_LINK_LIST,LB_ADDSTRING,0,
			(LPARAM)nodes[i]->GetName());
		}
	if (csel!=LB_ERR && csel<nodes.Count()) {
		SendDlgItemMessage(hWnd,IDC_LINK_LIST,LB_SETCURSEL,csel,0);
		}
	ListSelChanged();
	}

void LinkCtrl::ListSelChanged()
	{
	int sel = SendDlgItemMessage(hWnd,IDC_LINK_LIST,LB_GETCURSEL,0,0);
	if (sel!=LB_ERR) {
		iDelOb->Enable();
		iTime->Enable();
		iTime->SetValue(times[sel],FALSE);
		EnableWindow(GetDlgItem(hWnd,IDC_LINK_TIMELABEL),TRUE);
	} else {
		iDelOb->Disable();
		iTime->Disable();		
		EnableWindow(GetDlgItem(hWnd,IDC_LINK_TIMELABEL),FALSE);
		}
	}

void LinkCtrl::Invalidate()
	{	
	if (hWnd && editCont==this) {
		valid = FALSE;
		InvalidateRect(hWnd,NULL,FALSE);		
		}
	}

void LinkCtrl::Update()
	{
	if (!valid) {
		valid = TRUE;
		SetupList();
		}
	}


//--- PickLinkMode ------------------------------------------------

BOOL PickLinkMode::Filter(INode *node)
	{
	if (node) {
		return (node->TestForLoop(FOREVER,cont)==REF_SUCCEED);
		}
	return FALSE;
	}

BOOL PickLinkMode::HitTest(
		IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags)
	{
	INode *node = cont->ip->PickNode(hWnd,m);	
	return node?TRUE:FALSE;
	}

BOOL PickLinkMode::Pick(IObjParam *ip,ViewExp *vpt)
	{
	INode *node = vpt->GetClosestHit();
	if (node) {
		if (node->TestForLoop(FOREVER,cont)==REF_SUCCEED) {
			theHold.Begin();
			cont->AddNewLink(node,ip->GetTime());			
			theHold.Accept(GetString(IDS_RB_ADDLINK));
			cont->ip->RedrawViews(cont->ip->GetTime());
			}		
		}
	return FALSE;
	}

void PickLinkMode::EnterMode(IObjParam *ip)
	{cont->iPickOb->SetCheck(TRUE);}

void PickLinkMode::ExitMode(IObjParam *ip)
	{cont->iPickOb->SetCheck(FALSE);}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Control\pathctrl.cpp ===
/**********************************************************************
 *<
	FILE: pathctrl.cpp

	DESCRIPTION: A controller that moves an object along a spline path
				 Ed. 2 re-coded using ParamBlock2/ParamMap2

	CREATED BY: Rolf Berteig
	            Ed. 2 John Wainwright

	HISTORY: created 13 June 1995
	         Ed. 2 re-coded 9/22/98

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#include "ctrl.h"
#include "units.h"
#include "interpik.h"
#include "spline3d.h"
#include "istdplug.h"
#include "iparamm2.h"

#define PATH_CONTROL_CNAME		GetString(IDS_RB_PATH)

#define InterpType() ((ConstVel())?SPLINE_INTERP_NORMALIZED:SPLINE_INTERP_SIMPLE)

// flag values
#define PATHFLAG_FOLLOW		(1<<0)
#define PATHFLAG_BANK		(1<<1)
#define PATHFLAG_CLOSED		(1<<2)
#define PATHFLAG_ALLOWFLIP	(1<<3)
#define PATHFLAG_CONSTVEL	(1<<4)
#define PATHFLAG_FLIP		(1<<5)
#define PATHFLAG_YAXIS		(1<<6)
#define PATHFLAG_ZAXIS		(1<<7)

class PathPosition : public	IPathPosition {
	public:
		IParamBlock2* pblock;
		INode *path;
		DWORD flags;
		float bankAmount, tracking;
		Point3 curval;
		Quat curRot;
		Control* old_percent;  // holds pre-PB2 percent controller during loading
		Interval ivalid;
		
		static PathPosition *editCont;
		static IObjParam *ip;

		PathPosition(const PathPosition &ctrl);
		PathPosition(BOOL loading=FALSE);
		~PathPosition();

		BOOL SetPathNode(INode *node);
		void SetBankAmount(float a);
		void SetTracking(float t);
		void SetFollow(BOOL f);
		void SetBank(BOOL b);
		void SetAllowFlip(BOOL f);
		void SetConstVel(BOOL cv);
		void SetFlip(BOOL onOff);
		void SetAxis(int axis);
		
		BOOL GetFollow() {return Follow();}
		float GetBankAmount();
		BOOL GetBank() {return Bank();}
		float GetTracking();
		BOOL GetAllowFlip() {return AllowFlip();}
		BOOL GetConstVel() {return ConstVel();}		

		BOOL Follow() {return flags&PATHFLAG_FOLLOW?TRUE:FALSE;}
		BOOL Bank() {return flags&PATHFLAG_BANK?TRUE:FALSE;}
		BOOL AllowFlip() {return flags&PATHFLAG_ALLOWFLIP?TRUE:FALSE;}
		BOOL ConstVel() {return flags&PATHFLAG_CONSTVEL?TRUE:FALSE;}
		BOOL GetFlip() {return flags&PATHFLAG_FLIP?TRUE:FALSE;}
		int GetAxis();		
		
		void Update(TimeValue t);
		float GetPercent(TimeValue t,Interval &valid,BOOL noClip=FALSE);
		Point3 PointOnPath(TimeValue t, ShapeObject *pathOb, Interval &valid);
		Matrix3 CalcRefFrame(TimeValue t,ShapeObject *pathOb);

		// Animatable methods
		Class_ID ClassID() { return Class_ID(PATH_CONTROL_CLASS_ID,0); }  
		SClass_ID SuperClassID() { return CTRL_POSITION_CLASS_ID; }  		
		
		void GetClassName(TSTR& s) {s = PATH_CONTROL_CNAME;}
		void DeleteThis() {delete this;}		
		int IsKeyable() {return 0;}		

		int NumSubs()  {return 1;}
		Animatable* SubAnim(int i) {return pblock;}
		TSTR SubAnimName(int i) { return GetString(IDS_RB_PATHPARAMS); }
		int SubNumToRefNum(int subNum) {if (subNum==0) return PATHPOS_PBLOCK_REF; else return -1;}

		void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev ); 
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next ); 

		int SetProperty(ULONG id, void *data);
		void *GetProperty(ULONG id);

// JBW: direct ParamBlock access is added
		int	NumParamBlocks() { return 1; }					// return number of ParamBlocks in this instance
		IParamBlock2* GetParamBlock(int i) { return pblock; } // return i'th ParamBlock
		IParamBlock2* GetParamBlockByID(BlockID id) { return (pblock->ID() == id) ? pblock : NULL; } // return id'd ParamBlock

		// Reference methods
		int NumRefs() { return 3; };	
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);
		RefResult NotifyRefChanged(Interval, RefTargetHandle, PartID&, RefMessage);

		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);

		void RescaleWorldUnits(float f) {}

		// Control methods
		void Copy(Control *from);
		RefTargetHandle Clone(RemapDir& remap);
		BOOL IsLeaf() {return FALSE;}
		void GetValue(TimeValue t, void *val, Interval &valid, GetSetMethod method);	
		void SetValue(TimeValue t, void *val, int commit, GetSetMethod method) {}
		void CommitValue(TimeValue t) { }
		void RestoreValue(TimeValue t) { }
		void EnumIKParams(IKEnumCallback &callback);
		BOOL CompDeriv(TimeValue t,Matrix3& ptm,IKDeriv& derivs,DWORD flags);
		float IncIKParam(TimeValue t,int index,float delta);
		void ClearIKParam(Interval iv,int index);
	};

class JointParamsPath : public JointParams {
	public:			 	
		JointParamsPath() : JointParams((DWORD)JNT_POS,1,100.0f) {}
		void SpinnerChange(InterpCtrlUI *ui,WORD id,ISpinnerControl *spin,BOOL interactive);
	};

IObjParam *PathPosition::ip             = NULL;
PathPosition *PathPosition::editCont    = NULL;

//********************************************************
// PATH CONTROL
//********************************************************
static Class_ID pathControlClassID(PATH_CONTROL_CLASS_ID,0); 
class PathClassDesc:public ClassDesc2 {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { return new PathPosition(loading); }
	const TCHAR *	ClassName() { return PATH_CONTROL_CNAME; }
	SClass_ID		SuperClassID() { return CTRL_POSITION_CLASS_ID; }
	Class_ID		ClassID() { return pathControlClassID; }
	const TCHAR* 	Category() { return _T("");  }
// JBW: new descriptor data accessors added.
	const TCHAR*	InternalName() { return _T("Path"); }			// returns fixed parsable name (scripter-visible name)
	HINSTANCE		HInstance() { return hInstance; }				// returns owning module handle
	};

static PathClassDesc pathCD;
ClassDesc* GetPathCtrlDesc() {return &pathCD;}

// ParamBlock IDs
// main block
enum { path_params, path_joint_params };
// path_params param IDs
enum { path_percent, path_path, path_follow, path_bank, path_bank_amount, path_smoothness, 
       path_allow_upsidedown, path_constant_vel, path_axis, path_axis_flip, };

// parameter setter callback, reflect any ParamBlock-mediated param setting in instance data members.
// JBW: since the old path controller kept all parameters as instance data members, this setter callback
// is implemented to to reduce changes to existing code 
class PathPBAccessor : public PBAccessor
{ 
public:
	void Set(PB2Value& v, ReferenceMaker* owner, ParamID id, int tabIndex, TimeValue t)    // set from v
	{
		PathPosition* p = (PathPosition*)owner;
		switch (id)
		{
			case path_path:
			{
				IParamMap2* pmap = p->pblock->GetMap();
				if (pmap)
					if (v.r == NULL)
						SetWindowText(GetDlgItem(pmap->GetHWnd(), IDC_PATHNAME), GetString(IDS_RB_NONE)); 
					else
						SetWindowText(GetDlgItem(pmap->GetHWnd(), IDC_PATHNAME), ((INode*)(v.r))->GetName()); 
				break;
			}
			case path_follow:
				if (v.i) p->flags |= PATHFLAG_FOLLOW; else p->flags &= ~PATHFLAG_FOLLOW; break;
			case path_bank:
				if (v.i) p->flags |= PATHFLAG_BANK; else p->flags &= ~PATHFLAG_BANK; break;
			case path_bank_amount:
				p->bankAmount = FromBankUI(v.f); break;
			case path_smoothness:
				p->tracking = FromTrackUI(v.f); break;
			case path_allow_upsidedown:
				if (v.i) p->flags |= PATHFLAG_ALLOWFLIP; else p->flags &= ~PATHFLAG_ALLOWFLIP; break;
			case path_constant_vel:
				if (v.i) p->flags |= PATHFLAG_CONSTVEL; else p->flags &= ~PATHFLAG_CONSTVEL; break;
			case path_axis:
				switch (v.i)
				{
					case 0: p->flags &= ~(PATHFLAG_YAXIS | PATHFLAG_ZAXIS); break;			// X
					case 1: p->flags |= PATHFLAG_YAXIS; p->flags &= ~PATHFLAG_ZAXIS; break;	// Y
					case 2: p->flags |= PATHFLAG_ZAXIS; p->flags &= ~PATHFLAG_YAXIS; break;	// Y
				}
				break;
			case path_axis_flip:
				if (v.i) p->flags |= PATHFLAG_FLIP; else p->flags &= ~PATHFLAG_FLIP; break;
		}
	}
};

static PathPBAccessor path_accessor;

class PathDlgProc : public ParamMap2UserDlgProc 
{
	public:
		void UpdatePathName(PathPosition* p)
		{
			IParamMap2* pmap = p->pblock->GetMap();
			if (pmap)
			{
				HWND hWnd = pmap->GetHWnd();
				if (p->path == NULL)
					SetWindowText(GetDlgItem(hWnd, IDC_PATHNAME), GetString(IDS_RB_NONE)); 
				else
					SetWindowText(GetDlgItem(hWnd, IDC_PATHNAME), p->path->GetName()); 
			}
		}

		BOOL DlgProc(TimeValue t, IParamMap2 *map, HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
		{
			switch (msg) 
			{
				case WM_INITDIALOG:
					PathPosition* p = (PathPosition*)map->GetParamBlock()->GetOwner();
					UpdatePathName(p);
					return TRUE;
			}
			return FALSE;
		}

		void SetParamBlock(IParamBlock2* pb) 
		{ 
			UpdatePathName((PathPosition*)pb->GetOwner());
		}

		void DeleteThis() { }
};

static PathDlgProc pathDlgProc;

// per instance path controller block
static ParamBlockDesc2 path_paramblk (path_params, _T("PathParameters"),  0, &pathCD, P_AUTO_CONSTRUCT + P_AUTO_UI, PATHPOS_PBLOCK_REF, 
	//rollout
	IDD_PATHPARAMS, IDS_RB_PATHPARAMS, BEGIN_EDIT_MOTION, 0, &pathDlgProc,
	// params
	path_percent,	_T("percent"),		TYPE_PCNT_FRAC, P_ANIMATABLE + P_RESET_DEFAULT, 	IDS_RB_PERCENT, 
		p_default, 		0.0,	
		p_range, 		float(-999999999), float(999999999), 
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_PATHPERCENT, IDC_PATHPERCENTSPIN, 0.1f, 
		end, 
	path_path, 		_T("path"), 		TYPE_INODE, 	P_OWNERS_REF + P_NO_AUTO_LABELS,	IDS_RB_PATH,
		p_ui, 			TYPE_PICKNODEBUTTON, IDC_PICKPATH, 
		p_sclassID,		SHAPE_CLASS_ID, 
		p_refno,		PATHPOS_PATH_REF,
		p_accessor,		&path_accessor,
		end, 
	path_follow,	_T("follow"),		TYPE_BOOL, 		0,									IDS_JW_FOLLOW,
		p_default, 		FALSE, 
		p_ui, 			TYPE_SINGLECHEKBOX, IDC_PATH_FOLLOW, 
		p_enable_ctrls,	4, path_bank, path_allow_upsidedown, path_axis, path_axis_flip,
		p_accessor,		&path_accessor,
		end, 
	path_bank,		_T("bank"),			TYPE_BOOL, 		0,									IDS_JW_BANK,
		p_default, 		FALSE, 
		p_ui, 			TYPE_SINGLECHEKBOX, IDC_PATH_BANK, 
		p_enabled,		FALSE,
		p_enable_ctrls,	2, path_bank_amount, path_smoothness,
		p_accessor,		&path_accessor,
		end, 
	path_bank_amount, _T("bankAmount"), TYPE_FLOAT, 	P_ANIMATABLE, 						IDS_JW_BANKAMOUNT, 
		p_default, 		0.5, 
		p_range, 		-999999.0, 999999.0, 
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_FOLLOW_BANK, IDC_FOLLOW_BANKSPIN, 0.01f,
		p_accessor,		&path_accessor,
		p_enabled,		FALSE,
		end, 
	path_smoothness,  _T("smoothness"), TYPE_FLOAT, 	P_ANIMATABLE, 						IDS_JW_SMOOTHNESS, 
		p_default, 		0.5, 
		p_range, 		0.01f, 10.0f, 
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_FOLLOW_TRACK, IDC_FOLLOW_TRACKSPIN, 0.01f,
		p_enabled,		FALSE,
		p_accessor,		&path_accessor,
		end, 
	path_allow_upsidedown, _T("allowUpsideDown"), TYPE_BOOL, 0,								IDS_JW_ALLOWUPSIDEDOWN,
		p_default, 		FALSE, 
		p_ui, 			TYPE_SINGLECHEKBOX, IDC_PATH_ALLOWFLIP, 
		p_enabled,		FALSE,
		p_accessor,		&path_accessor,
		end, 
	path_constant_vel, _T("constantVel"), TYPE_BOOL,	0,									IDS_JW_CONSTANTVEL,
		p_default, 		FALSE, 
		p_ui, 			TYPE_SINGLECHEKBOX, IDC_PATH_CONSTVEL, 
		p_accessor,		&path_accessor,
		end, 
	path_axis, 		_T("axis"),			TYPE_INT, 		0,									IDS_JW_AXIS,
		p_default, 		0, 
		p_range, 		0, 2, 
		p_ui, 			TYPE_RADIO, 	3, IDC_PATH_X, IDC_PATH_Y, IDC_PATH_Z, 
		p_enabled,		FALSE,
		p_accessor,		&path_accessor,
		end, 
	path_axis_flip, _T("axisFlip"),		TYPE_BOOL,		0,									IDS_JW_AXISFLIP,
		p_default, 		FALSE, 
		p_ui, 			TYPE_SINGLECHEKBOX, IDC_PATH_FLIP, 
		p_enabled,		FALSE,
		p_accessor,		&path_accessor,
		end, 
	end
	);

PathPosition::PathPosition(BOOL loading) 
	{
	path     = NULL;
	old_percent = NULL;
	curval   = Point3(0,0,0);
	curRot.Identity();
	flags      = 0;
	bankAmount = FromBankUI(0.5f);
	tracking   = FromTrackUI(0.5f);

	// make the paramblock
	pathCD.MakeAutoParamBlocks(this);
	// pre-animate percent param
	SuspendAnimate();
	AnimateOn();
	float val =  1.0f;
	pblock->SetValue(path_percent, GetAnimEnd(), val); 
	ResumeAnimate();
	pblock->CallSets();
	ivalid.SetEmpty();
}

PathPosition::~PathPosition()
	{
	DeleteAllRefsFromMe();
	}

RefTargetHandle PathPosition::Clone(RemapDir& remap)
	{
	PathPosition *p = new PathPosition(TRUE);

	if (path) {
		p->ReplaceReference(PATHPOS_PATH_REF,path);
	} else {
		p->path = NULL;
		}

    p->ReplaceReference(PATHPOS_PBLOCK_REF, pblock->Clone(remap));

	p->flags      = flags;
	p->bankAmount = bankAmount;
	p->tracking   = tracking;
	p->curval     = curval;
	p->curRot     = curRot;
	p->ivalid.SetEmpty();
	return p;
	}


void PathPosition::Copy(Control *from)
	{
	if (from->ClassID()==ClassID()) {
		PathPosition *ctrl = (PathPosition*)from;
		ReplaceReference(PATHPOS_PATH_REF,ctrl->path);
		// a copy will construct its own pblock to keep the pblock-to-owner 1-to-1.
		RemapDir *remap = NewRemapDir(); 
		ReplaceReference(PATHPOS_PBLOCK_REF, ctrl->pblock->Clone(*remap));
		remap->DeleteThis();
		curval   = ctrl->curval;
		curRot   = ctrl->curRot;
		flags    = ctrl->flags;
		bankAmount = ctrl->bankAmount;
		tracking = ctrl->tracking;
//		IParamMap2* pmap = ctrl->pblock->GetMap();
//		if (pmap != NULL)
//			pmap->SetParamBlock(pblock);
	} else {
		from->GetValue(0,&curval,ivalid);
		}
	ivalid.SetEmpty();
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	}

float PathPosition::GetPercent(TimeValue t,Interval &valid,BOOL noClip)
	{	
	float per;
	pblock->GetValue(path_percent, t, per, valid);	
	if (noClip) return per;
	if (per < 0.0f || per > 1.0f || (flags & PATHFLAG_CLOSED)) {
		per = (float)fmod(per,1.0f);
		}
	if (per<0.0f) per = 1.0f + per;	
	return per;
	}

Point3 PathPosition::PointOnPath(TimeValue t, ShapeObject *pathOb, Interval &valid)
	{	
	return pathOb->InterpCurve3D(t, 0, GetPercent(t,valid), InterpType()) * 
		path->GetObjTMAfterWSM(t,&valid);	
	}

// Reference frame is calculated as the following:
//
// X axis = tangent(t)
// Y axis = WorldZ cross X
// Z axis = X cross Y
//
// or if the 'Allow Upside Down' option us selected:
//
// X axis = tangent(t)
// Z axis = path normal cross X
// Y axis = Z cross X
//
// If roll is on then the reference frame is rotated about
// the tangent by rollamount * curviture.

#define DU			0.001f
#define BDU			0.01f
#define NUMSTEPS	5

Matrix3 PathPosition::CalcRefFrame(TimeValue t,ShapeObject *pathOb)
	{
	Interval valid;
	Matrix3 tm(1), otm = path->GetObjTMAfterWSM(t);
	float u = GetPercent(t,valid);
	bankAmount = FromBankUI(pblock->GetFloat(path_bank_amount, t));
	tracking = FromTrackUI(pblock->GetFloat(path_smoothness, t));
	
	Point3 pt0, pt1;
	pt0 = pathOb->InterpCurve3D(t, 0, u-DU, InterpType()) * otm;
	pt1 = pathOb->InterpCurve3D(t, 0, u+DU, InterpType()) * otm;
	
	Point3 pathNorm(0,0,0);
	if (AllowFlip()) {
		// Compute the normal to the plane of the path by sampling points on the path
#define NUM_SAMPLES 20
		Point3 v[NUM_SAMPLES], cent(0,0,0);
		for (int i=0; i<NUM_SAMPLES; i++) {
			v[i] = pathOb->InterpCurve3D(t, 0, float(i)/float(NUM_SAMPLES), InterpType()) * otm;
			cent += v[i];
			}		
		cent /= float(NUM_SAMPLES);
		for (i=1; i<NUM_SAMPLES; i++) {
			pathNorm += Normalize((v[i]-cent)^(v[i-1]-cent));
			}
		pathNorm = Normalize(pathNorm);
		}

	// X
	tm.SetRow(0,Normalize(pt1-pt0));

	if (GetFlip()) tm.SetRow(0,-tm.GetRow(0));

	if (AllowFlip()) {
		// Choose Z in the plane of the path		
		// Z
		tm.SetRow(2,Normalize(tm.GetRow(0)^pathNorm));

		// Y
		tm.SetRow(1,tm.GetRow(2)^tm.GetRow(0));
	} else {
		// Choose Y in the world XY plane
		// Y
		tm.SetRow(1,Normalize(Point3(0,0,1)^tm.GetRow(0)));

		// Z
		tm.SetRow(2,tm.GetRow(0)^tm.GetRow(1));
		}

	// swap axis around	
	Point3 tmp;
	switch (GetAxis()) {
		case 1: 
			tmp = tm.GetRow(0);
			tm.SetRow(0,-tm.GetRow(1));
			tm.SetRow(1,tmp);
			break;
		case 2: 
			tmp = tm.GetRow(0);
			tm.SetRow(0,-tm.GetRow(2));
			tm.SetRow(2,tmp);
			break;
		}
		
	
	if (Bank()) {
		// Average over NUMSTEPS samples
		Point3 pt0, pt1, pt2, v0, v1;
		float cv = 0.0f;
		u -= float(NUMSTEPS/2+1)*tracking;
				
		if (!pathOb->CurveClosed(t,0)) {
			if (u+(NUMSTEPS+2)*tracking > 1.0f) u = 1.0f - (NUMSTEPS+2)*tracking;
			if (u<0.0f) u=0.0f;
			}

		pt1 = pathOb->InterpCurve3D(t, 0, u, InterpType()) * otm;
		u += tracking;		
		pt2 = pathOb->InterpCurve3D(t, 0, u, InterpType()) * otm;
		u += tracking;		
		for (int i=0; i<NUMSTEPS; i++) {			
			pt0 = pt1;
			pt1 = pt2;
			if (!pathOb->CurveClosed(t,0) && u>1.0f) {
				//pt2 += pt2 - pt1;
				break;
			} else {
				u   = (float)fmod(u,1.0f);
				pt2 = pathOb->InterpCurve3D(t, 0, u, InterpType()) * otm;
				}
			v0 = Normalize(pt2-pt1);
			v1 = Normalize(pt1-pt0);			
			v0.z = v1.z = 0.0f; // remove Z component.
			cv += (v0^v1).z * bankAmount / Length(pt1-pt0);
			u  += tracking;			
			}	
		if (i) {
			if (GetFlip()) cv = -cv;
			switch (GetAxis()) {
				case 0: tm.PreRotateX(cv/float(i)); break;
				case 1: tm.PreRotateY(cv/float(i)); break;
				case 2: tm.PreRotateZ(cv/float(i)); break;
				}
			}
		}

	return tm;
	}

void PathPosition::Update(TimeValue t)
	{
	ShapeObject *pathOb = NULL;
	ivalid = FOREVER;
	
	if (path) {
		ObjectState os = path->EvalWorldState(t);
		if (os.obj->IsShapeObject()) {
			pathOb = (ShapeObject*)os.obj;
			if (!pathOb->NumberOfCurves()) {
				pathOb = NULL;
				}
			
			}
		ivalid &= os.Validity(t);
		}
	if (!pathOb) return;
	curval = PointOnPath(t,pathOb,ivalid);

	if (Follow()) {
		curRot = Quat(CalcRefFrame(t,pathOb));
	} else {
		curRot.Identity();
		}

	if (pathOb->CurveClosed(t,0)) {
		flags |= PATHFLAG_CLOSED;
	} else {
		flags &= ~PATHFLAG_CLOSED;
		}

	if (ivalid.Empty()) ivalid.SetInstant(t);
	}

void PathPosition::GetValue(TimeValue t, void *val, Interval &valid, GetSetMethod method)
	{
	if (!ivalid.InInterval(t)) {
		Update(t);
		}
	valid &= ivalid;
			 
	if (method==CTRL_RELATIVE) {
  		Matrix3 *mat = (Matrix3*)val;
		if (Follow()) {
			curRot.MakeMatrix(*mat);
			}
		mat->SetTrans(curval);		
	} else {
		*((Point3*)val) = curval;
		}
	}

RefTargetHandle PathPosition::GetReference(int i)
	{
		switch (i)
		{
			case 0:
				return old_percent;   // ref 0 is now obsolete, percent stored in ParamBlock.
			case PATHPOS_PATH_REF:
				return path;
			case PATHPOS_PBLOCK_REF:
				return pblock;
		}
		return NULL;
	}

void PathPosition::SetReference(int i, RefTargetHandle rtarg)
	{
		switch (i)
		{
			case 0:
				old_percent = (Control*)rtarg;  // reference set by pre-PB2 versions loading, fix up in PLCB
				break;
			case PATHPOS_PATH_REF:
				path = (INode*)rtarg; break;
			case PATHPOS_PBLOCK_REF:
				pblock = (IParamBlock2*)rtarg; break;
		}
	}

RefResult PathPosition::NotifyRefChanged(
		Interval iv, 
		RefTargetHandle hTarg, 
		PartID& partID, 
		RefMessage msg) 
	{
	switch (msg) {
		case REFMSG_CHANGE:
			ivalid.SetEmpty();
			path_paramblk.InvalidateUI();
			break;
		case REFMSG_TARGET_DELETED:
			if (hTarg == path) 
			{
				path = NULL;
				pblock->RefDeleted(path_path);
			}
			break;
		}
	return REF_SUCCEED;
	}

class PickPathRestore : public RestoreObj {
	public:
		PathPosition *cont;
		PickPathRestore(PathPosition *c) {cont=c;}
		void Restore(int isUndo) {
			if (cont->editCont == cont) {
				path_paramblk.InvalidateUI();
				}									
			}
		void Redo() {
			if (cont->editCont == cont && cont->path) {
				path_paramblk.InvalidateUI();
				}
			}
		TSTR Description() { return TSTR(_T("Pick Path")); }
	};

BOOL PathPosition::SetPathNode(INode *node)
	{
	if (node->TestForLoop(FOREVER,this)==REF_SUCCEED) {
		theHold.Begin();
		ReplaceReference(PATHPOS_PATH_REF,(RefTargetHandle)node);
		theHold.Put(new PickPathRestore(this));
		theHold.Accept(GetString(IDS_RB_PICKPATH));
		ivalid.SetEmpty();
		NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
		return TRUE;
	} else {
		return FALSE;
		}
	}


void PathPosition::SetTracking(float t)
	{
	float ut = ToTrackUI(t);
	pblock->SetValue(path_smoothness, GetCOREInterface()->GetTime(), ut);
	ivalid.SetEmpty();
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	}

float PathPosition::GetTracking()
	{
	return FromTrackUI(pblock->GetFloat(path_smoothness, GetCOREInterface()->GetTime()));
	}

void PathPosition::SetBankAmount(float a)
	{
	float ua = ToBankUI(a);
	pblock->SetValue(path_bank_amount, GetCOREInterface()->GetTime(), ua);
	ivalid.SetEmpty();
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);		
	}

float PathPosition::GetBankAmount()
	{
	return FromBankUI(pblock->GetFloat(path_bank_amount, GetCOREInterface()->GetTime()));
	}

void PathPosition::SetFollow(BOOL f)
	{
	pblock->SetValue(path_follow, GetCOREInterface()->GetTime(), f);
	ivalid.SetEmpty();
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	}

void PathPosition::SetAllowFlip(BOOL f)
	{
	pblock->SetValue(path_allow_upsidedown, GetCOREInterface()->GetTime(), f);
	ivalid.SetEmpty();
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	}

void PathPosition::SetConstVel(BOOL cv)
	{
	pblock->SetValue(path_constant_vel, GetCOREInterface()->GetTime(), cv);
	ivalid.SetEmpty();
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	}

void PathPosition::SetBank(BOOL b)
	{
	pblock->SetValue(path_bank, GetCOREInterface()->GetTime(), b);
	ivalid.SetEmpty();
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);	
	}

void PathPosition::SetFlip(BOOL onOff)
	{
	pblock->SetValue(path_axis_flip, GetCOREInterface()->GetTime(), onOff);
	ivalid.SetEmpty();
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);	
	}

void PathPosition::SetAxis(int axis)
	{
	pblock->SetValue(path_axis, GetCOREInterface()->GetTime(), axis);
	ivalid.SetEmpty();
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	}

int PathPosition::GetAxis()
	{
	if (flags&PATHFLAG_YAXIS) return 1;
	if (flags&PATHFLAG_ZAXIS) return 2;
	return 0;
	}

/*--------------------------------------------------------------------*/
// PathPosition UI

void PathPosition::BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev )
	{	
	this->ip = ip;
	editCont = this;
	if (flags & BEGIN_EDIT_HIERARCHY) {
// JBW: JointParam stuff not handled by ParamBlock2 yet		
		// No IK if follow is on
		if (Follow()) return;

		JointParamsPath *jp = (JointParamsPath*)GetProperty(PROPID_JOINTPARAMS);
		InterpCtrlUI *ui;	

		if (!jp) {
			jp = new JointParamsPath();
			SetProperty(PROPID_JOINTPARAMS,jp);
			}

		if (prev &&
			prev->ClassID()==ClassID() && 
		    (ui = (InterpCtrlUI*)prev->GetProperty(PROPID_INTERPUI))) {
			JointParams *prevjp = (JointParams*)prev->GetProperty(PROPID_JOINTPARAMS);
			prevjp->EndDialog(ui);
			ui->cont = this;
			ui->ip   = ip;
			prev->SetProperty(PROPID_INTERPUI,NULL);
			JointDlgData *jd = (JointDlgData*)GetWindowLong(ui->hParams,GWL_USERDATA);
			jd->jp = jp;
			jp->InitDialog(ui);
		} else {
			ui = new InterpCtrlUI(NULL,ip,this);
			DWORD f=0;
			if (!jp || !jp->RollupOpen()) f = APPENDROLL_CLOSED;	

			ui->hParams = ip->AddRollupPage( 
				hInstance, 
				MAKEINTRESOURCE(IDD_PATHJOINTPARAMS),
				JointParamDlgProc,
				GetString(IDS_RB_PATHJOINTPARAMS), 
				(LPARAM)new JointDlgData(ui,jp),f);	
			}
	
		SetProperty(PROPID_INTERPUI,ui);		
	} else {
		pathCD.BeginEditParams(ip, this, flags, prev);
		}
	}

void PathPosition::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next )
{
	editCont = NULL;
	IParamMap2* pmap = pblock->GetMap();
	if (pmap != NULL)
	{
		if (next && next->ClassID() == ClassID() && ((PathPosition*)next)->pblock)
		{
			pmap->SetParamBlock(((PathPosition*)next)->pblock);
			ip->ClearPickMode();
		}
		else
			pathCD.EndEditParams(ip, this, flags | END_EDIT_REMOVEUI, next);
	}
	else
	{
		int index = aprops.FindProperty(PROPID_INTERPUI);
		if (index>=0) {
			InterpCtrlUI *ui = (InterpCtrlUI*)aprops[index];
			if (ui->hParams) {
				ip->UnRegisterDlgWnd(ui->hParams);
				ip->DeleteRollupPage(ui->hParams);			
				}
			index = aprops.FindProperty(PROPID_INTERPUI);
			if (index>=0) {
				delete aprops[index];
				aprops.Delete(index,1);
				}
			}	
	}
}

int PathPosition::SetProperty(ULONG id, void *data)
	{
	if (id==PROPID_JOINTPARAMS) {		
		if (!data) {
			int index = aprops.FindProperty(id);
			if (index>=0) {
				aprops.Delete(index,1);
				}
		} else {
			JointParamsPath *jp = (JointParamsPath*)GetProperty(id);
			if (jp) {
				*jp = *((JointParamsPath*)data);
				delete (JointParamsPath*)data;
			} else {
				aprops.Append(1,(AnimProperty**)&data);
				}					
			}
		return 1;
	} else
	if (id==PROPID_INTERPUI) {		
		if (!data) {
			int index = aprops.FindProperty(id);
			if (index>=0) {
				aprops.Delete(index,1);
				}
		} else {
			InterpCtrlUI *ui = (InterpCtrlUI*)GetProperty(id);
			if (ui) {
				*ui = *((InterpCtrlUI*)data);
			} else {
				aprops.Append(1,(AnimProperty**)&data);
				}					
			}
		return 1;
	} else {
		return Animatable::SetProperty(id,data);
		}
	}

void* PathPosition::GetProperty(ULONG id)
	{
	if (id==PROPID_INTERPUI || id==PROPID_JOINTPARAMS) {
		int index = aprops.FindProperty(id);
		if (index>=0) {
			return aprops[index];
		} else {
			return NULL;
			}
	} else {
		return Animatable::GetProperty(id);
		}
	}


#define JOINTPARAMPATH_CHUNK	0x1001
#define FOLLOW_CHUNK			0x1002
#define BANK_CHUNK				0x1003
#define BANKAMOUNT_CHUNK		0x1004
#define	TRACKING_CHUNK			0x1005
#define ALLOWFLIP_CHUNK			0x1006
#define CONSTVEL_CHUNK			0x1007
#define AXIS_CHUNK				0x1008
#define FLIP_CHUNK				0x1009

IOResult PathPosition::Save(ISave *isave)
	{	
	JointParamsPath *jp = (JointParamsPath*)GetProperty(PROPID_JOINTPARAMS);

	if (jp) {
		isave->BeginChunk(JOINTPARAMPATH_CHUNK);
		jp->Save(isave);
		isave->EndChunk();
		}
	
	return IO_OK;
	}


// provide a post-load callback so old-version path controller data can be loaded into the ParamBlock2
class PathPLCB : public PostLoadCallback 
{
public:
	PathPosition*	p;
	BOOL			old_version;
	BOOL			flip;
	int				axis;
	BOOL			constvel;
	BOOL			follow;	
	BOOL			bank;	
	BOOL			allowFlip;
	float			bankAmt;	
	float			tracking;

	PathPLCB(PathPosition* pth)
	{ 
		p = pth;
		old_version = FALSE; flip = FALSE; axis = 0; constvel = FALSE;
	    follow = FALSE; bank = FALSE; allowFlip = FALSE; bankAmt = 0.5; tracking = 0.5;
	}
	void proc(ILoad *iload)
	{
		if (old_version)
		{
			// loading an old version, set the param values
			p->pblock->SetValue(path_axis_flip, 0, flip);
			p->pblock->SetValue(path_axis, 0, axis);
			p->pblock->SetValue(path_constant_vel, 0, constvel);
			p->pblock->SetValue(path_follow, 0, follow);
			p->pblock->SetValue(path_bank, 0, bank);
			p->pblock->SetValue(path_allow_upsidedown, 0, allowFlip);
			bankAmt = ToBankUI(bankAmt);
			p->pblock->SetValue(path_bank_amount, 0, bankAmt);
			tracking = ToTrackUI(tracking);
			p->pblock->SetValue(path_smoothness, 0, tracking);
			// copy across old percent controller
			if (p->old_percent != NULL)
				p->pblock->SetController(path_percent, 0, p->old_percent, FALSE);
		}
		else
			// make all params call their PBAccessor::Set() fns to set up flags from just-loaded pblock values
			p->pblock->CallSets();
	}
};

IOResult PathPosition::Load(ILoad *iload)
	{
	ULONG nb;
	IOResult res = IO_OK;
	PathPLCB* plcb = new PathPLCB(this);
	iload->RegisterPostLoadCallback(plcb);

	while (IO_OK==(res=iload->OpenChunk())) {
		switch (iload->CurChunkID()) {
			case FLIP_CHUNK:
				plcb->old_version = TRUE;
				plcb->flip = TRUE;
				break;

			case AXIS_CHUNK:
				plcb->old_version = TRUE;
				res=iload->Read(&plcb->axis,sizeof(int),&nb);
				break;

			case CONSTVEL_CHUNK:
				plcb->old_version = TRUE;
				plcb->constvel = TRUE;
				break;

			case FOLLOW_CHUNK:
				plcb->old_version = TRUE;
				plcb->follow = TRUE;
				break;

			case BANK_CHUNK:
				plcb->old_version = TRUE;
				plcb->bank = TRUE;
				break;

			case ALLOWFLIP_CHUNK:
				plcb->old_version = TRUE;
				plcb->allowFlip = TRUE;
				break;

			case BANKAMOUNT_CHUNK:
				plcb->old_version = TRUE;
				res=iload->Read(&plcb->bankAmt,sizeof(bankAmount),&nb);
				break;

			case TRACKING_CHUNK:
				plcb->old_version = TRUE;
				res=iload->Read(&plcb->tracking,sizeof(tracking),&nb);
				break;

			case JOINTPARAMPATH_CHUNK: {
				JointParamsPath *jp = new JointParamsPath;
				jp->Load(iload);
				SetProperty(PROPID_JOINTPARAMS,jp);
				break;
				}
			}		
		iload->CloseChunk();
		if (res!=IO_OK)  return res;
		}
	return IO_OK;
	}

//-------------------------------------------------------------
//
// IK
//


void PathPosition::EnumIKParams(IKEnumCallback &callback)
	{
	JointParamsPath *jp = (JointParamsPath*)GetProperty(PROPID_JOINTPARAMS);
	if (jp && jp->Active(0) && !Follow()) {
		callback.proc(this,0);
		}
	}

BOOL PathPosition::CompDeriv(TimeValue t,Matrix3& ptm,IKDeriv& derivs,DWORD flags)
	{
	JointParamsPath *jp = (JointParamsPath*)GetProperty(PROPID_JOINTPARAMS);
	if (!jp || !jp->Active(0) || Follow()) return FALSE;
	Point3 zero(0,0,0);
	if (path) {
		ObjectState os = path->EvalWorldState(t);
		if (os.obj->IsShapeObject()) {
			ShapeObject *pathOb = (ShapeObject*)os.obj;
			if (pathOb->NumberOfCurves()) {
				Point3 p0,p1,d;
				float per,dt=0.01f;
				pblock->GetValue(path_percent, t, per, ivalid);
				per = (float)fmod(per,1.0f);
				if (per<0.0f) per = 1.0f + per;
				if (dt+per>1.0f) dt = -dt;
				p0 = pathOb->InterpCurve3D(t,0,per, InterpType());
				p1 = pathOb->InterpCurve3D(t,0,per+dt, InterpType());
				if (os.GetTM()) {
					p0 = p0 * (*os.GetTM());
					p1 = p1 * (*os.GetTM());
					}
				d = (p1-p0)/dt;
				for (int j=0; j<derivs.NumEndEffectors(); j++) {
					if (flags&POSITION_DERIV) {
						derivs.DP(d,j);
						}
					if (flags&ROTATION_DERIV) {
						derivs.DR(zero,j);
						}
					}
				
				derivs.NextDOF();
				ptm.SetTrans(p0);
				return TRUE;
				}
			}	
		}
	
	for (int j=0; j<derivs.NumEndEffectors(); j++) {
		if (flags&POSITION_DERIV) {
			derivs.DP(zero,j);
			}
		if (flags&ROTATION_DERIV) {
			derivs.DR(zero,j);
			}
		}
	derivs.NextDOF();
	return FALSE;
	}

float PathPosition::IncIKParam(TimeValue t,int index,float delta)
	{
	JointParamsPath *jp = (JointParamsPath*)GetProperty(PROPID_JOINTPARAMS);
	float v=0.0f;
	BOOL gotV=FALSE;
	if (fabs(delta) > 0.01f) {
		if (delta<0) delta = -0.01f;
		else delta = 0.01f;
		}
	if (jp) {		
		if (jp->Limited(0)) {			
			Interval valid;
			pblock->GetValue(path_percent, t, v, valid);
			gotV = TRUE;
			}
		delta = jp->ConstrainInc(0,v,delta);
		}	
	// If the path is not closed, do not let it go off the end.
	if (!(flags&PATHFLAG_CLOSED)) {
		if (!gotV) {
			Interval valid;
			pblock->GetValue(path_percent, t, v, valid);
			}
		if (v + delta < 0.0f) delta = -v;
		if (v + delta > 1.0f) delta = 1.0f-v;
		}
	pblock->GetController(path_percent)->SetValue(t,&delta,FALSE,CTRL_RELATIVE);
	return delta;
	}

void PathPosition::ClearIKParam(Interval iv,int index) 
	{
	pblock->GetController(path_percent)->DeleteTime(iv,TIME_INCRIGHT|TIME_NOSLIDE);	
	}

void JointParamsPath::SpinnerChange(
		InterpCtrlUI *ui,WORD id,ISpinnerControl *spin,BOOL interactive)
	{
	float val;
	BOOL set = FALSE;

	switch (id) {
		case IDC_XFROMSPIN:
			val = min[0] = spin->GetFVal()/scale; 
			set = TRUE;
			break;
		case IDC_XTOSPIN:
			val = max[0] = spin->GetFVal()/scale;
			set = TRUE;
			break;
		
		case IDC_XDAMPINGSPIN:
			damping[0] = spin->GetFVal(); break;
		}
	
	if (set && interactive) {
		PathPosition *c = (PathPosition*)ui->cont;
 		c->pblock->GetController(path_percent)->SetValue(ui->ip->GetTime(),&val,TRUE,CTRL_ABSOLUTE);
		ui->ip->RedrawViews(ui->ip->GetTime(),REDRAW_INTERACTIVE);
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Control\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by control.rc
//
#define IDD_EXPRPARAMS                  103
#define IDD_FUNC_LIST                   104
#define IDD_SCALAR_ASGN                 105
#define IDD_VECTOR_ASGN                 106
#define IDD_ATTACH_DIALOG               107
#define IDD_FOLLOW_PANEL                110
#define IDD_PATHPARAMS                  123
#define IDD_STDJOINTPARAMS              129
#define IDD_PATHJOINTPARAMS             130
#define IDD_EULER_PARAMS                145
#define IDD_NOISEPARAMS                 146
#define IDD_IPOS_PARAMS                 147
#define IDD_ATTACH_PARAMS               148
#define IDD_EXPR_DEBUG                  149
#define IDD_LINK_PARAMS                 150
#define IDD_SURFPARAMS                  151
#define IDD_SURFJOINTPARAMS             152
#define IDD_LOD_UTILPARAMS              153
#define IDD_ISCALE_PARAMS               154
#define IDC_EXPLAIN_NOTATION            1002
#define IDC_PATH_ALLOWFLIP              1003
#define IDC_IPOS_X                      1004
#define IDC_PATH_CONSTVEL               1004
#define IDC_IPOS_Y                      1005
#define IDC_IPOS_Z                      1006
#define IDC_ATTACH_OBNAME               1007
#define IDC_ATTACH_PICKOB               1008
#define IDC_DEBUG_LIST                  1008
#define IDC_DEBUG_VALUE                 1009
#define IDC_ATTACH_UPDATE               1009
#define IDC_ATTACH_SETPOS               1010
#define IDC_ATTACH_KEYTIME              1011
#define IDC_ATTACH_KEYTIMESPIN          1012
#define IDC_ATTACH_KEYFACE              1013
#define IDC_ATTACH_KEYFACESPIN          1014
#define IDC_ATTACH_KEYA                 1015
#define IDC_ATTACH_KEYASPIN             1016
#define IDC_ATTACH_KEYB                 1017
#define IDC_ATTACH_KEYBSPIN             1018
#define IDC_ATTACH_FACEPOSGRAPH         1019
#define IDC_ATTACH_KEYTENS              1020
#define IDC_ATTACH_KEYTENSSPIN          1021
#define IDC_ATTACH_KEYCONT              1022
#define IDC_ATTACH_KEYCONTSPIN          1023
#define IDC_ATTACH_KEYBIAS              1024
#define IDC_ATTACH_KEYBIASSPIN          1025
#define IDC_ATTACH_KEYEASETO            1026
#define IDC_ATTACH_KEYEASETOSPIN        1027
#define IDC_ATTACH_KEYEASEFROM          1028
#define IDC_ATTACH_KEYEASEFROMSPIN      1029
#define IDC_SEL_NAME                    1029
#define IDC_ATTACH_ALIGN                1030
#define IDC_EXPR_DEBUG                  1031
#define IDC_ATTACH_MANUPDATE            1033
#define IDC_LINK_PICK                   1035
#define IDC_LINK_LIST                   1036
#define IDC_LINK_TIME                   1037
#define IDC_LINK_TIMESPIN               1038
#define IDC_LINK_TIMELABEL              1039
#define IDC_LINK_DELETE                 1040
#define IDC_SURFNAME                    1040
#define IDC_PICKSURF                    1041
#define IDC_SURF_U                      1042
#define IDC_SURF_USPIN                  1043
#define IDC_ALIGN_U                     1044
#define IDC_ALIGN_NONE                  1045
#define IDC_ALIGN_V                     1046
#define IDC_ALIGN_FLIP                  1047
#define IDC_EXPR_EDIT                   1048
#define IDC_EULER_ORDER                 1048
#define IDC_EXPR_EVAL                   1049
#define IDC_XAXIS_LABEL                 1049
#define IDC_VAR_NAME                    1050
#define IDC_YAXIS_LABEL                 1050
#define IDC_SCALAR_RB                   1051
#define IDC_ZAXIS_LABEL                 1051
#define IDC_VECTOR_RB                   1052
#define IDC_CREATE_VAR                  1053
#define IDC_SCALAR_LIST                 1054
#define IDC_VECTOR_LIST                 1055
#define IDC_ASGN_CONST                  1056
#define IDC_ASGN_CNTRL                  1057
#define IDC_FOLLOW_APPLY                1058
#define IDC_ABS_POS                     1058
#define IDC_LOD_LIST                    1059
#define IDC_FUNCTIONS                   1060
#define IDC_LOD_MINLABEL                1060
#define IDC_SAVE                        1061
#define IDC_LOD_MIN                     1061
#define IDC_LOAD                        1062
#define IDC_LOD_MINSPIN                 1062
#define IDC_CUR_ASGN                    1063
#define IDC_LOD_MAX                     1063
#define IDC_FUNC_LIST                   1064
#define IDC_LOD_MAXSPIN                 1064
#define IDC_DELETE_VAR                  1065
#define IDC_LOD_MAXLABEL                1065
#define IDC_DESCRIPTION                 1066
#define IDC_LOD_RESET                   1066
#define IDC_XTO                         1067
#define IDC_LOD_VIEWPORTOBJ             1067
#define IDC_VEC_X                       1068
#define IDC_XTOSPIN                     1068
#define IDC_LOD_VIEWWIDTH               1068
#define IDC_VEC_Y                       1069
#define IDC_XDAMPING                    1069
#define IDC_LOD_ADDTOSET                1069
#define IDC_VEC_Z                       1070
#define IDC_XDAMPINGSPIN                1070
#define IDC_LOD_DELETEFROMSET           1070
#define IDC_OFFSET                      1071
#define IDC_YTO                         1071
#define IDC_LOD_CREATENEWSET            1071
#define IDC_CHANGE_OFFSET               1072
#define IDC_YDAMPING                    1072
#define IDC_LOD_VIEWWIDTHSPIN           1072
#define IDC_YTOSPIN                     1073
#define IDC_LOD_DISPPIXELS              1073
#define IDC_YDAMPINGSPIN                1074
#define IDC_LOD_VIEWHEIGHT              1074
#define IDC_OFFSET_SPIN                 1074
#define IDC_ZTO                         1075
#define IDC_LOD_VIEWHEIGHTSPIN          1075
#define IDC_ISCALE_X                    1075
#define IDC_ZDAMPING                    1076
#define IDC_LOD_DISPPERCENT             1076
#define IDC_ISCALE_Y                    1076
#define IDC_ZTOSPIN                     1077
#define IDC_LOD_RESETOUTPUT             1077
#define IDC_ISCALE_Z                    1077
#define IDC_ZDAMPINGSPIN                1078
#define IDC_XSPRING                     1079
#define IDC_XSPRINGSPIN                 1080
#define IDC_YSPRING                     1081
#define IDC_YSPRINGSPIN                 1082
#define IDC_ZSPRING                     1083
#define IDC_ZSPRINGSPIN                 1084
#define IDC_XSPRINGTENS                 1085
#define IDC_XSPRINGTENSSPIN             1086
#define IDC_PICKPATH                    1087
#define IDC_YSPRINGTENS                 1087
#define IDC_PATHNAME                    1088
#define IDC_YSPRINGTENSSPIN             1088
#define IDC_ZSPRINGTENS                 1089
#define IDC_PREVKEY                     1090
#define IDC_ZSPRINGTENSSPIN             1090
#define IDC_NEXTKEY                     1091
#define IDC_KEYNUM                      1092
#define IDC_XACTIVE                     1099
#define IDC_XLIMITED                    1100
#define IDC_XEASE                       1101
#define IDC_XFROM                       1102
#define IDC_XFROMSPIN                   1103
#define IDC_YACTIVE                     1104
#define IDC_YLIMITED                    1105
#define IDC_YFROM                       1106
#define IDC_YEASE                       1107
#define IDC_YFROMSPIN                   1108
#define IDC_ZACTIVE                     1109
#define IDC_ZLIMITED                    1110
#define IDC_ZFROM                       1111
#define IDC_ZEASE                       1112
#define IDC_ZFROMSPIN                   1113
#define IDC_EULER_X                     1149
#define IDC_EULER_Y                     1150
#define IDC_EULER_Z                     1151
#define IDC_NOISE_XSTRENGTH             1151
#define IDC_NOISE_XSTRENGTHSPIN         1152
#define IDC_NOISE_FREQ                  1153
#define IDC_NOISE_FREQSPIN              1154
#define IDC_NOISE_YSTRENGTH             1155
#define IDC_EXPR_CONST                  1156
#define IDC_NOISE_YSTRENGTHSPIN         1156
#define IDC_EXPR_CONST_SPIN             1157
#define IDC_NOISE_SEED                  1157
#define IDC_VEC_Z_SPIN                  1158
#define IDC_NOISE_SEEDSPIN              1158
#define IDC_VEC_Y_SPIN                  1159
#define IDC_NOISE_ZSTRENGTH             1159
#define IDC_NOISE_ZSTRENGTHSPIN         1160
#define IDC_VEC_X_SPIN                  1161
#define IDC_NOISE_ROUGH                 1161
#define IDC_NOISE_ROUGHSPIN             1162
#define IDC_NOISE_RAMPIN                1163
#define IDC_NOISE_RAMPINSPIN            1164
#define IDC_NOISE_RAMPOUT               1165
#define IDC_NOISE_RAMPOUTSPIN           1166
#define IDC_TCB_GRAPH                   1182
#define IDC_PATH_FOLLOW                 1200
#define IDC_PATH_BANK                   1201
#define IDC_FOLLOW_BANKSPIN             1202
#define IDC_FOLLOW_BANK                 1203
#define IDC_FOLLOW_BANKLABEL            1204
#define IDC_FOLLOW_TRACK                1205
#define IDC_FOLLOW_TRACKSPIN            1206
#define IDC_FOLLOW_TRACKLABEL           1207
#define IDC_PATHPERCENT                 1208
#define IDC_FOLLOW_START                1208
#define IDC_PATHPERCENTSPIN             1209
#define IDC_FOLLOW_STARTSPIN            1209
#define IDC_NOISE_XSTRENGTHLABEL        1210
#define IDC_FOLLOW_BANKLABEL2           1210
#define IDC_NOISE_YSTRENGTHLABEL        1211
#define IDC_FOLLOW_END                  1211
#define IDC_SURF_V                      1211
#define IDC_NOISE_ZSTRENGTHLABEL        1212
#define IDC_FOLLOW_ENDSPIN              1212
#define IDC_SURF_VSPIN                  1212
#define IDC_NOISE_FRACTAL               1213
#define IDC_FOLLOW_SAMP                 1213
#define IDC_NOISE_ROUGHLABEL            1214
#define IDC_FOLLOW_SAMPSPIN             1214
#define IDC_NOISE_GRAPH                 1215
#define IDC_NOISE_ZSTRENGTHLABEL2       1216
#define IDC_NOISE_ZSTRENGTHLABEL3       1217
#define IDC_NOISE_XLIM0                 1506
#define IDC_NOISE_YLIM0                 1507
#define IDC_NOISE_ZLIM0                 1508
#define IDC_JP_XFROMLABEL               1534
#define IDC_JP_XTOLABEL                 1535
#define IDC_JP_YFROMLABEL               1536
#define IDC_JP_ZFROMLABEL               1537
#define IDC_JP_YTOLABEL                 1538
#define IDC_JP_ZTOLABEL                 1539
#define IDC_JP_XDAMPINGLABEL            1549
#define IDC_JP_YDAMPINGLABEL            1550
#define IDC_JP_ZDAMPINGLABEL            1551
#define IDC_PATH_X                      1607
#define IDC_PATH_Y                      1608
#define IDC_PATH_Z                      1609
#define IDC_PATH_FLIP                   1610
#define IDC_XSPINGBACK                  1638
#define IDC_YSPINGBACK                  1639
#define IDC_ZSPINGBACK                  1640
#define IDS_DB_EXPR_PARSE_ERROR         20280
#define IDS_DB_DUPNAME                  20281
#define IDS_DB_CANT_CREATE_VAR          20282
#define IDS_DB_NOSUCH                   20283
#define IDS_DB_CANT_CHANGE_OFFSET       20284
#define IDS_DB_NOCURVAR                 20285
#define IDS_DB_CANTDELETE               20286
#define IDS_DB_EXPRCNTL                 20287
#define IDS_DB_NOTHINGDEL               20288
#define IDS_DB_XPR_FILES                20289
#define IDS_JW_BANK                     20290
#define IDS_JW_AXIS                     20291
#define IDS_JW_AXISFLIP                 20292
#define IDS_DB_BAD_NAME                 20552
#define IDS_DB_POSITION_EXPR            20553
#define IDS_DB_POINT3_EXPR              20554
#define IDS_DB_FLOAT_EXPR               20555
#define IDS_DB_SCALE_EXPR               20556
#define IDS_DB_ROTATION_EXPR            20557
#define IDS_DB_CIRCULAR_DEPENDENCY      20558
#define IDS_DB_CANT_ASSIGN              20559
#define IDS_DB_NEED_VECTOR              20560
#define IDS_DB_NEED_SCALAR              20561
#define IDS_DB_SAVE_EXPR                20562
#define IDS_DB_LOAD_EXPR                20563
#define IDS_JW_BANKAMOUNT               20564
#define IDS_JW_SMOOTHNESS               20565
#define IDS_JW_ALLOWUPSIDEDOWN          20566
#define IDS_JW_CONSTANTVEL              20567
#define IDS_JW_FOLLOW                   20568
#define IDS_RB_PERCENT                  30135
#define IDS_RB_PATHPARAMS               30136
#define IDS_RB_NONE                     30137
#define IDS_RB_ROTJOINTPARAMS           30148
#define IDS_RB_PATHJOINTPARAMS          30151
#define IDS_RB_STRENGTH                 30247
#define IDS_RB_PATH                     30532
#define IDS_RB_EULERXYZ                 30533
#define IDS_RB_EULERPARAMS              30534
#define IDS_RB_XROTATION                30535
#define IDS_RB_YROTATION                30536
#define IDS_RB_ZROTATION                30537
#define IDS_RB_NOISEFLOAT               30538
#define IDS_RB_NOISEPOSITION            30539
#define IDS_RB_NOISEPOINT3              30540
#define IDS_RB_NOISEROTATION            30541
#define IDS_RB_NOISESCALE               30542
#define IDS_PRS_LOCALEULERXYZ           30543
#define IDS_PRS_LOCALXROTATION          30544
#define IDS_PRS_LOCALYROTATION          30545
#define IDS_PRS_LOCALZROTATION          30546
#define IDS_RB_PATHCONTROLLER           30625
#define IDS_RB_ILLEGALPATH              30626
#define IDS_RB_NOISECONTROLTITLE        30655
#define IDS_RB_EXPRESSIONCONTROLTITLE   30656
#define IDS_RB_PICKPATH                 30663
#define IDS_DB_FN_SIN                   30664
#define IDS_DB_FN_NOISE                 30665
#define IDS_DB_FN_IF                    30666
#define IDS_DB_FN_MIN                   30667
#define IDS_DB_FN_MAX                   30668
#define IDS_DB_FN_POW                   30669
#define IDS_DB_FN_MOD                   30670
#define IDS_DB_FN_DEGTORAD              30671
#define IDS_DB_FN_RADTODEG              30672
#define IDS_DB_FN_COS                   30673
#define IDS_DB_FN_TAN                   30674
#define IDS_DB_FN_ASIN                  30675
#define IDS_DB_FN_ACOS                  30676
#define IDS_DB_FN_ATAN                  30677
#define IDS_DB_FN_SINH                  30678
#define IDS_DB_FN_COSH                  30679
#define IDS_DB_FN_TANH                  30680
#define IDS_DB_FN_LN                    30681
#define IDS_DB_FN_LOG                   30682
#define IDS_DB_FN_EXP                   30683
#define IDS_DB_FN_SQRT                  30684
#define IDS_DB_FN_ABS                   30685
#define IDS_DB_FN_CEIL                  30686
#define IDS_DB_FN_FLOOR                 30687
#define IDS_DB_FN_COMP                  30688
#define IDS_DB_FN_UNIT                  30689
#define IDS_DB_FN_LENGTH                30690
#define IDS_DB_FN_PI                    30691
#define IDS_DB_FN_E                     30692
#define IDS_DB_FN_TPS                   30693
#define IDS_DB_FN_VIF                   30694
#define IDS_RB_NOISESTRENGTH            30695
#define IDS_RB_SETPERCENT               30696
#define IDS_RB_BOOLCONTROL              30697
#define IDS_RB_IPOSPARAMS               30698
#define IDS_RB_IPOS                     30699
#define IDS_RB_XPOSITION                30700
#define IDS_RB_YPOSITION                30701
#define IDS_RB_ZPOSITION                30702
#define IDS_RB_ATTACHCONTROL            30703
#define IDS_RB_ATTACHPARAMS             30704
#define IDS_RB_EDITATTACHKEY            30705
#define IDS_RB_ATTACHCONTROLLER         30706
#define IDS_RB_ILLEGALOBJECT            30707
#define IDS_RB_ATTACHTITLE              30708
#define IDS_RB_IPOINT3                  30709
#define IDS_RB_IPOINT3PARAMS            30710
#define IDS_RB_ICOLOR                   30711
#define IDS_RB_ICOLORPARAMS             30712
#define IDS_RB_LINKCTRL                 30713
#define IDS_RB_TRANSFORM                30714
#define IDS_RB_LINKPARAMS               30715
#define IDS_RB_SETLINKTIME              30716
#define IDS_RB_DELETELINK               30717
#define IDS_RB_ADDLINK                  30718
#define IDS_RB_FOLLOWUTIL               30719
#define IDS_RB_MULTISEL                 30720
#define IDS_RB_NONESEL                  30721
#define IDS_RB_APPLYFOLLOW              30722
#define IDS_MM_ISCALEPARAMS             30723
#define IDS_RB_SURF                     30724
#define IDS_RB_U                        30725
#define IDS_RB_V                        30726
#define IDS_RB_CHANGEUV                 30727
#define IDS_RB_SURFPARAMS               30728
#define IDS_RB_SURFJOINTPARAMS          30729
#define IDS_RB_EULERTYPE0               30730
#define IDS_RB_EULERTYPE1               30731
#define IDS_RB_EULERTYPE2               30732
#define IDS_RB_EULERTYPE3               30733
#define IDS_RB_EULERTYPE4               30734
#define IDS_RB_EULERTYPE5               30735
#define IDS_RB_EULERTYPE6               30736
#define IDS_RB_EULERTYPE7               30737
#define IDS_RB_EULERTYPE8               30738
#define IDS_RB_X                        30739
#define IDS_RB_Y                        30740
#define IDS_RB_Z                        30741
#define IDS_RB_XAXIS                    30742
#define IDS_RB_YAXIS                    30743
#define IDS_RB_ZAXIS                    30744
#define IDS_RB_EULERNAME                30745
#define IDS_RB_LODCONTROL               30746
#define IDS_RB_LODUTILITU               30747
#define IDS_RB_LODSAMEPARENT            30748
#define IDS_RB_DEFCONTROLLERS           30749
#define IDS_RB_CHANGESTRENGTH           30750
#define IDS_PRS_LOCALEULERNAME          30751
#define IDS_MM_ISCALE                   30752
#define IDS_MM_XSCALE                   30753
#define IDS_MM_YSCALE                   30754
#define IDS_MM_ZSCALE                   30755

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        109
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1075
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Control\perlin.cpp ===
//
// From "Texturing and Modeling A Procedural Approach"
//
// Chapter 6 by Ken Perlin
//

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include "noise.h"

#define random()	rand()


float bias(float a, float b)
{
	return pow((double)a, log((double)b) / log(0.5));
}

float gain(float a, float b)
{
	float p = log(1. - b) / log(0.5);

	if (a < .001)
		return 0.;
	else if (a > .999)
		return 1.;
	if (a < 0.5)
		return pow(2 * a, p) / 2;
	else
		return 1. - pow(2.0 * (1. - a), (double)p) / 2;
}

float noise1(float arg);
float noise2(float vec[]);
float noise3(float vec[]);

float noise(float vec[], int len)
{
	switch (len) {
	case 0:
		return 0.;
	case 1:
		return noise1(vec[0]);
	case 2:
		return noise2(vec);
	default:
		return noise3(vec);
	}
}

float turbulence(float *v, float freq)
{
	float t, vec[3];

	for (t = 0. ; freq >= 1. ; freq /= 2) {
		vec[0] = freq * v[0];
		vec[1] = freq * v[1];
		vec[2] = freq * v[2];
		t += fabs(noise3(vec)) / freq;
	}
	return t;
}

/* noise functions over 1, 2, and 3 dimensions */

#define B 0x100
#define BM 0xff

#define N 0x1000
#define NP 12   /* 2^N */
#define NM 0xfff

static p[B + B + 2];
static float g3[B + B + 2][3];
static float g2[B + B + 2][2];
static float g1[B + B + 2];
static start = 1;

static void init(void);

int Perm(int v)
	{
	return p[v&BM];
	}

#define s_curve(t) ( t * t * (3. - 2. * t) )

#define lerp(t, a, b) ( a + t * (b - a) )

#define setup(i,b0,b1,r0,r1)\
	t = vec[i] + N;\
	b0 = ((int)t) & BM;\
	b1 = (b0+1) & BM;\
	r0 = t - (int)t;\
	r1 = r0 - 1.;

float noise1(float arg)
{
	int bx0, bx1;
	float rx0, rx1, sx, t, u, v, vec[1];

	vec[0] = arg;
	if (start) {
		start = 0;
		init();
	}

	setup(0, bx0,bx1, rx0,rx1);

	sx = s_curve(rx0);

	u = rx0 * g1[ p[ bx0 ] ];
	v = rx1 * g1[ p[ bx1 ] ];

	return lerp(sx, u, v);
}

float noise2(float vec[2])
{
	int bx0, bx1, by0, by1, b00, b10, b01, b11;
	float rx0, rx1, ry0, ry1, *q, sx, sy, a, b, t, u, v;
	register i, j;

	if (start) {
		start = 0;
		init();
	}

	setup(0, bx0,bx1, rx0,rx1);
	setup(1, by0,by1, ry0,ry1);

	i = p[ bx0 ];
	j = p[ bx1 ];

	b00 = p[ i + by0 ];
	b10 = p[ j + by0 ];
	b01 = p[ i + by1 ];
	b11 = p[ j + by1 ];

	sx = s_curve(rx0);
	sy = s_curve(ry0);

#define at2(rx,ry) ( rx * q[0] + ry * q[1] )

	q = g2[ b00 ] ; u = at2(rx0,ry0);
	q = g2[ b10 ] ; v = at2(rx1,ry0);
	a = lerp(sx, u, v);

	q = g2[ b01 ] ; u = at2(rx0,ry1);
	q = g2[ b11 ] ; v = at2(rx1,ry1);
	b = lerp(sx, u, v);

	return lerp(sy, a, b);
}

float noise3(float vec[3])
{
	int bx0, bx1, by0, by1, bz0, bz1, b00, b10, b01, b11;
	float rx0, rx1, ry0, ry1, rz0, rz1, *q, sy, sz, a, b, c, d, t, u, v;
	register i, j;

	if (start) {
		start = 0;
		init();
	}

	setup(0, bx0,bx1, rx0,rx1);
	setup(1, by0,by1, ry0,ry1);
	setup(2, bz0,bz1, rz0,rz1);

	i = p[ bx0 ];
	j = p[ bx1 ];

	b00 = p[ i + by0 ];
	b10 = p[ j + by0 ];
	b01 = p[ i + by1 ];
	b11 = p[ j + by1 ];

	t  = s_curve(rx0);
	sy = s_curve(ry0);
	sz = s_curve(rz0);

#define at3(rx,ry,rz) ( rx * q[0] + ry * q[1] + rz * q[2] )

	q = g3[ b00 + bz0 ] ; u = at3(rx0,ry0,rz0);
	q = g3[ b10 + bz0 ] ; v = at3(rx1,ry0,rz0);
	a = lerp(t, u, v);

	q = g3[ b01 + bz0 ] ; u = at3(rx0,ry1,rz0);
	q = g3[ b11 + bz0 ] ; v = at3(rx1,ry1,rz0);
	b = lerp(t, u, v);

	c = lerp(sy, a, b);

	q = g3[ b00 + bz1 ] ; u = at3(rx0,ry0,rz1);
	q = g3[ b10 + bz1 ] ; v = at3(rx1,ry0,rz1);
	a = lerp(t, u, v);

	q = g3[ b01 + bz1 ] ; u = at3(rx0,ry1,rz1);
	q = g3[ b11 + bz1 ] ; v = at3(rx1,ry1,rz1);
	b = lerp(t, u, v);

	d = lerp(sy, a, b);

	return lerp(sz, c, d);
}

static void normalize2(float v[2])
{
	float s;

	s = sqrt(v[0] * v[0] + v[1] * v[1]);
	v[0] = v[0] / s;
	v[1] = v[1] / s;
}

static void normalize3(float v[3])
{
	float s;

	s = sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
	v[0] = v[0] / s;
	v[1] = v[1] / s;
	v[2] = v[2] / s;
}

static void init(void)
{
	int i, j, k;
	srand(0);

	for (i = 0 ; i < B ; i++) {
		p[i] = i;

		g1[i] = (float)((random() % (B + B)) - B) / B;

		for (j = 0 ; j < 2 ; j++)
			g2[i][j] = (float)((random() % (B + B)) - B) / B;
		normalize2(g2[i]);

		for (j = 0 ; j < 3 ; j++)
			g3[i][j] = (float)((random() % (B + B)) - B) / B;
		normalize3(g3[i]);
	}

	while (--i) {
		k = p[i];
		p[i] = p[j = random() % B];
		p[j] = k;
	}

	for (i = 0 ; i < B + 2 ; i++) {
		p[B + i] = p[i];
		g1[B + i] = g1[i];
		for (j = 0 ; j < 2 ; j++)
			g2[B + i][j] = g2[i][j];
		for (j = 0 ; j < 3 ; j++)
			g3[B + i][j] = g3[i][j];
	}
}



/*
 * Procedural fBm evaluated at "point"; returns value stored in "value".
 *
 * Copyright 1994 F. Kenton Musgrave 
 * 
 * Parameters:
 *    ``H''  is the fractal increment parameter
 *    ``lacunarity''  is the gap between successive frequencies
 *    ``octaves''  is the number of frequencies in the fBm
 */

// RB:
// Modified to be evaluated with a scalar.

#define TRUE    1
#define FALSE   0

double
fBm1( double point, double H, double lacunarity, double octaves )
{
	  static double     exponent_array[MAX_OCTAVES+1];
      static double		lastH;
      double            value, frequency, remainder, Noise3();
      int               i;
      static int        first = TRUE;
      

      /* precompute and store spectral weights */
      if (first || H!= lastH) {
	  		lastH = H;
            frequency = 1.0;
            for (i=0; i<=octaves; i++) {
                  /* compute weight for each frequency */
                  exponent_array[i] = pow( frequency, -H );
                  frequency *= lacunarity;
            }
            first = FALSE;
      }

      value = 0.0;            /* initialize vars to proper values */
      frequency = 1.0;

      /* inner loop of spectral construction */
      for (i=0; i<octaves; i++) {
            value += noise1( point ) * exponent_array[i];
            point *= lacunarity;            
      } /* for */

      remainder = octaves - (int)octaves;
      if ( remainder )      /* add in ``octaves''  remainder */
            /* ``i''  and spatial freq. are preset in loop above */
            value += remainder * noise1( point ) * exponent_array[i];

      return( value );

} /* fBm() */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Control\block\blockcontrol.cpp ===
#include "block.h"
#include "units.h"
#include "masterblock.h"
#include "istdplug.h"


#include "iparamm2.h"

#define FLOATLIST_CONTROL_CLASS_ID		0x4b4b1000
#define POINT3LIST_CONTROL_CLASS_ID		0x4b4b1001
#define POSLIST_CONTROL_CLASS_ID		0x4b4b1002
#define ROTLIST_CONTROL_CLASS_ID		0x4b4b1003
#define SCALELIST_CONTROL_CLASS_ID		0x4b4b1004
#define DUMMY_CONTROL_CLASS_ID			0xeeefffff


										   
static BlockControlClassDesc blockControlCD;
ClassDesc* GetBlockControlDesc() {return &blockControlCD;}

/*


enum { block_params };
// path_params param IDs
enum { block_slaves };

// per instance path controller block
static ParamBlockDesc2 block_paramblk (block_params, _T("MasterParameters"),  0, &blockCD, P_AUTO_CONSTRUCT + P_AUTO_UI, BLOCK_PBLOCK_REF, 
	//rollout
	0, 0, 0, 0, NULL,
	// params
		block_slaves,	_T("Slaves"),		TYPE_REFTARG_TAB,10, P_ANIMATABLE, 	IDS_PW_SLAVE, 
		end, 
	end
	);

*/

BOOL CALLBACK BlockPropDlgProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK TrackPropDlgProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

//------------------------------------------------------------

BlockControl::BlockControl() 
	{	
	range     = Interval(GetAnimStart(),GetAnimEnd());
//	blockCD.MakeAutoParamBlocks(this);
//watje 4-30-99
	suspendNotifies = FALSE;

	} 
BlockControl::~BlockControl() 
	{	
	for (int i = 0; i < tempControls.Count(); i++)
		delete tempControls[i];
	} 


int BlockControl::NumSubs() 
	{
	return controls.Count();
	}

Animatable* BlockControl::SubAnim(int i) 
	{
	if (i < controls.Count()) return controls[i];
	return NULL;
	}

TSTR BlockControl::SubAnimName(int i) 
	{
	TSTR name;
	if (i < names.Count())
		{
		if (names[i] && names[i]->length()) 
			{
			name = *names[i];
			}
		} 
	else if (controls[i]) 
			{
			controls[i]->GetClassName(name);
			} 

	return name;
	}


BOOL BlockControl::AssignController(Animatable *control,int subAnim) 
	{
	
	MessageBox(  GetCOREInterface()->GetMAXHWnd(),          // handle of owner window
					 (LPCTSTR) GetString(IDS_PW_ERROR_MSG),     // address of text in message box
					(LPCTSTR) NULL,  // address of title of message box
						MB_OK | MB_ICONWARNING | MB_APPLMODAL );         // style of message box);
//	ReplaceReference(Control::NumRefs(),(Control*)control);
	return FALSE;
	}
//MessageBox(A, B, "Error !", MB_OK | MB_ICONWARNING | MB_APPLMODAL)
/*
int BlockControl::SubNumToRefNum(int subNum) 
	{	
	return Control::NumRefs();
	}
*/
int BlockControl::NumRefs() 
	{
//DebugPrint("Block Num ref %d\n",controls.Count());

	return controls.Count();
	}

RefTargetHandle BlockControl::GetReference(int i) 
	{

	if (i < controls.Count()) 
		{
//		DebugPrint("Getting block control ref %d\n",i);
		return controls[i];
		}
	return NULL;
//	return cont;
	}

void BlockControl::SetReference(int i, RefTargetHandle rtarg) 
	{
//	DebugPrint("Setting block control ref %d\n",i);

	if (i==controls.Count() && rtarg) {
		controls.Resize(controls.Count()+1);
		}
	if (i==controls.Count() && !rtarg) {
		return;
		}

	controls[i] = (Control*)rtarg;

	}

void BlockControl::NotifySlaves()

{
//watje 4-30-99
if (!suspendNotifies)
	{

	int i, count;
	count = backPointers.Count();

	for (i=0; i<count; i++) 
		{
		if ( (backPointers[i]) && (backPointers[i]->master))
			{
			backPointers[i]->UpdateSlave();
			backPointers[i]->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
			}
		}
	count = externalBackPointers.Count();
	for (i=0; i<count; i++) 
		{
		if (externalBackPointers[i])
			{
			externalBackPointers[i]->UpdateSlave();
			externalBackPointers[i]->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
			}
		}
	}

			
}

RefResult BlockControl::NotifyRefChanged(
		Interval changeInt, 
		RefTargetHandle hTarget, 
     	PartID& partID,  
     	RefMessage message)
	{
	switch (message) {
		case REFMSG_CHANGE:
//			Invalidate();	
			NotifySlaves();
			break;
		
		}
	return REF_SUCCEED;
	}




//extern float noise1(float arg);



RefTargetHandle BlockControl::Clone(RemapDir& remap)
	{
	// make a new noise controller and give it our param values.
//	BlockControl *cont = new BlockControl;
//	*cont = *this;
	// Clone the strength controller
//	cont->ReplaceReference(Control::NumRefs(),remap.CloneRef(cont->cont));
//	CloneControl(cont,remap);
	return NULL;
	}
/*
void BlockControl::GetValueLocalTime(
		TimeValue t, void *val, Interval &valid, GetSetMethod method)
	{
	}

void BlockControl::Extrapolate(
		Interval range,TimeValue t,void *val,Interval &valid,int type)
	{
	}

*/

void BlockControl::GetValue(
		TimeValue t, void *val, Interval &valid, GetSetMethod method)
	{
//DebugPrint("Error occured this getValue should never be called on a block control\n");
//	float *v = (float*)val;

//	if (method==CTRL_ABSOLUTE) {
//		*v = 0.0f;
//		}

//	sub->GetValue(t,val,valid,CTRL_RELATIVE);
	}

void BlockControl::GetValue(
		TimeValue t, void *val, Interval &valid, int whichSub, GetSetMethod method)
	{
//DebugPrint("Error occured this getValue should never be called on a block control\n");
	float *v = (float*)val;

//	if (method==CTRL_ABSOLUTE) {
//		*v = 0.0f;
//		}

	controls[whichSub]->GetValue(t,val,valid,method);
	}

void BlockControl::SetValue(
		TimeValue t, void *val, int commit, GetSetMethod method)
	{

//this should never get called
//DebugPrint("Error occured SetValue should never be called on a block control\n");
/*
	if (method==CTRL_ABSOLUTE) {
		float v = *((float*)val);
		float before = 0.0f, after = 0.0f;
		Interval valid;
		sub->GetValue(t,&before,valid,CTRL_RELATIVE);
		sub->GetValue(t,&after,valid,CTRL_RELATIVE);
		v = -before + v + -after;
		sub->SetValue(t,&v,commit,method);
	} else {
		sub->SetValue(t,val,commit,method);
		}
*/
	}


void BlockControl::RebuildTempControl()
{


for (int i =0; i < controls.Count();i++)
//Nuke all keys
	{
	if (tempControls[i] == NULL)
		tempControls[i] = (Control *) controls[i]->Clone();
/*
		Blocks[whichBlock]->tempControls[whichSub]->DeleteKeys(TRACK_DOALL);

		if (Blocks[whichBlock]->tempControls[whichSub]->SuperClassID() == CTRL_FLOAT_CLASS_ID)
			{
			float f = 0.0f;
			Blocks[whichBlock]->tempControls[whichSub]->SetValue(0,&f);
			}
		else if (Blocks[whichBlock]->tempControls[whichSub]->SuperClassID() == CTRL_POSITION_CLASS_ID)
			{
			Point3 f(0.0f,0.0f,0.0f);
			Blocks[whichBlock]->tempControls[whichSub]->SetValue(0,&f);
			}
*/
	tempControls[i]->DeleteKeys(TRACK_DOALL);
	float f = 0.0f;
	Point3 p(0.0f,0.0f,0.0f);
	if (tempControls[i]->SuperClassID() == CTRL_FLOAT_CLASS_ID)
		tempControls[i]->SetValue(0,&f);
	else if ( (tempControls[i]->SuperClassID() == CTRL_POSITION_CLASS_ID) || (tempControls[i]->SuperClassID() == CTRL_POINT3_CLASS_ID))
		tempControls[i]->SetValue(0,&p);

	}
}
void BlockControl::AddKeyToTempControl(TimeValue t,  TimeValue scale, BOOL isRelative)
{
//DebugPrint("key data\n");
for (int i =0; i < controls.Count();i++)
//Nuke all keys
	{
	
//copy track in 
//need to add relative controls
	Interval iv(start,end);
	TrackClipObject *cpy = controls[i]->CopyTrack(iv, TIME_INCLEFT|TIME_INCRIGHT);
//	int sz = sizeof(&cpy);
	iv.Set(t,t + (end-start));
	DWORD flags = TIME_INCLEFT|TIME_INCRIGHT;
	if (isRelative)
		{
		flags |= PASTE_RELATIVE;
//look at last key	and get offset
		}

	tempControls[i]->PasteTrack(cpy, iv, flags);
//now loop through and add relative value

//now need to scale those keys
	float s = 1.0f;
	if ((end-start) != 0)
		 s =  (float)scale/(float)(end-start);

	tempControls[i]->ScaleTime(iv, s);

//	int numKeys = tempControls[i]->NumKeys();
	cpy->DeleteThis();
//			}
//		tempControls[i]->DeleteKeys(TRACK_DOALL);
	}

}


void BlockControl::AddKeyToSub(Control *sub, int whichSub, TimeValue t,  TimeValue scale, Interval mrange,BOOL isRelative)
{
//DebugPrint("key data\n");
int i = whichSub;
//for (int i =0; i < controls.Count();i++)
//Nuke all keys
	{
	
//copy track in 
//need to add relative controls
	Interval iv(start,end);
	TrackClipObject *cpy = controls[i]->CopyTrack(iv, TIME_INCLEFT|TIME_INCRIGHT);
//	int sz = sizeof(&cpy);
//now need to scale those keys
	float s = 1.0f;
	if ((end-start) != 0)
		 s =  (float)scale/(float)(end-start);
   	iv.Set(t,t + (end-start));
	DWORD flags = TIME_INCLEFT|TIME_INCRIGHT;
	if (isRelative)
		{
		flags |= PASTE_RELATIVE;
//look at last key	and get offset
		}

	Interval scaleIV = iv;
	iv = iv & mrange;
	sub->PasteTrack(cpy, iv, flags);
//now loop through and add relative value


	sub->ScaleTime(scaleIV, s);

//	int numKeys = tempControls[i]->NumKeys();
	cpy->DeleteThis();
//			}
//		tempControls[i]->DeleteKeys(TRACK_DOALL);
	}

}

/*
void BlockControl::AddKeyToSub(Control *sub,int whichSub, BOOL isRelative)
{
DebugPrint("key data\n");
int i = whichSub;
//for (int i =0; i < controls.Count();i++)
//Nuke all keys
//	{
	
//copy track in 
//need to add relative controls
	Interval iv= tempControls[i]->GetTimeRange(TIMERANGE_ALL);



	TrackClipObject *cpy = tempControls[i]->CopyTrack(iv, TIME_INCLEFT|TIME_INCRIGHT);
//	int sz = sizeof(&cpy);
//	iv.Set(t,t + (end-start));
	DWORD flags = TIME_INCLEFT|TIME_INCRIGHT;
	if (isRelative)
		{
		flags |= PASTE_RELATIVE;
//look at last key	and get offset
		}

	sub->PasteTrack(cpy, iv, flags);
//now loop through and add relative value

//now need to scale those keys
//	float s = 1.0f;
//	if ((end-start) != 0)
//		 s =  (float)scale/(float)(end-start);

//	sub->ScaleTime(iv, s);

	cpy->DeleteThis();
//	}

}
*/
#define BLOCKCOUNT_CHUNK		0x01010
#define NAME_CHUNK				0x01020
#define NONAME_CHUNK			0x01030
#define COLOR_CHUNK				0x01040
#define START_CHUNK				0x01050
#define END_CHUNK				0x01060
#define BACKPOINTERS_CHUNK		0x01070
#define EXBACKPOINTERS_COUNT_CHUNK	0x01080
#define EXBACKPOINTERS_CHUNK	0x01090



IOResult BlockControl::Save(ISave *isave)
	{		
	ULONG nb;	
//count
	int count = controls.Count();
	isave->BeginChunk(BLOCKCOUNT_CHUNK);
	isave->Write(&count,sizeof(int),&nb);			
	isave->EndChunk();
//names

	for (int i=0; i<count; i++) {
		if (names[i]) {
			isave->BeginChunk(NAME_CHUNK);
			isave->WriteWString(*names[i]);
			isave->EndChunk();
		} else {
			isave->BeginChunk(NONAME_CHUNK);
			isave->EndChunk();
			}
		}
//color
	Color c = color;
	isave->BeginChunk(COLOR_CHUNK);
	isave->Write(&c,sizeof(c),&nb);			
	isave->EndChunk();

//start
	TimeValue s = start;
	isave->BeginChunk(START_CHUNK);
	isave->Write(&s,sizeof(s),&nb);			
	isave->EndChunk();

//end
	TimeValue e = end;
	isave->BeginChunk(END_CHUNK);
	isave->Write(&e,sizeof(e),&nb);			
	isave->EndChunk();

//back pointers
	isave->BeginChunk(BACKPOINTERS_CHUNK);
	for (i=0; i<count; i++) 
		{
		ULONG id = isave->GetRefID(backPointers[i]);
		isave->Write(&id,sizeof(ULONG), &nb);
		}
	isave->EndChunk();

//external back pointers
	count = externalBackPointers.Count();
	isave->BeginChunk(EXBACKPOINTERS_COUNT_CHUNK);
	isave->Write(&count,sizeof(int),&nb);			
	isave->EndChunk();

//external back pointers
	isave->BeginChunk(EXBACKPOINTERS_CHUNK);
	for (i=0; i<count; i++) 
		{
		ULONG id = isave->GetRefID(externalBackPointers[i]);
		isave->Write(&id,sizeof(ULONG), &nb);
		}
	isave->EndChunk();
	
	return IO_OK;
	}

IOResult BlockControl::Load(ILoad *iload)
	{
	int ID =  0;
	ULONG nb;
	IOResult res = IO_OK;
	int ix = 0;

	while (IO_OK==(res=iload->OpenChunk())) 
		{
		ID = iload->CurChunkID();
		if (ID ==BLOCKCOUNT_CHUNK)
			{
			int ct;
			iload->Read(&ct, sizeof(ct), &nb);
			controls.SetCount(ct);
			tempControls.SetCount(ct);
			names.SetCount(ct);
			backPointers.SetCount(ct);
			for (int i=0; i<ct; i++) 
				{
				names[i] = NULL;
				controls[i] = NULL;
				tempControls[i] = NULL;
				backPointers[i] = NULL;
				}

			}
		else if (ID == NAME_CHUNK)
			{
			TCHAR *buf;
			iload->ReadWStringChunk(&buf);
			names[ix++] = new TSTR(buf);
			}
		else if (ID == NONAME_CHUNK)
			{
			ix++;
			}
		else if (ID ==COLOR_CHUNK)
			{
			Color c;
			iload->Read(&c, sizeof(Color), &nb);
			color = c;
			}
		else if (ID ==START_CHUNK)
			{
			TimeValue s;
			iload->Read(&s, sizeof(s), &nb);
			start = s;
			}
		else if (ID ==END_CHUNK)
			{
			TimeValue e;
			iload->Read(&e, sizeof(e), &nb);
			end = e;
			}
		else if (ID ==BACKPOINTERS_CHUNK)
			{
			for (int i=0; i<backPointers.Count(); i++) 
				{
				ULONG id;
				iload->Read(&id,sizeof(ULONG), &nb);
				if (id!=0xffffffff)
					iload->RecordBackpatch(id,(void**)&backPointers[i]);
				}
			}
		else if (ID ==EXBACKPOINTERS_COUNT_CHUNK)
			{
			int ct;
			iload->Read(&ct, sizeof(ct), &nb);
			externalBackPointers.SetCount(ct);
			for (int i=0; i<ct; i++) 
				{
				externalBackPointers[i] = NULL;
				}

			}
		else if (ID ==EXBACKPOINTERS_CHUNK)
			{
			for (int i=0; i<externalBackPointers.Count(); i++) 
				{
				ULONG id;
				iload->Read(&id,sizeof(ULONG), &nb);
				if (id!=0xffffffff)
					iload->RecordBackpatch(id,(void**)&externalBackPointers[i]);
				}
			}


		iload->CloseChunk();
		if (res!=IO_OK)  return res;
		}

//rebuild all tempcontrols	
	return IO_OK;
	}



void BlockControl::EditTrackParams(
			TimeValue t,
			ParamDimensionBase *dim,
			TCHAR *pname,
			HWND hParent,
			IObjParam *ip,
			DWORD flags)
{
trackHWND = hParent;

int OK = DialogBoxParam  (hInstance, MAKEINTRESOURCE(IDD_ADDNEWTRACK),
				hParent, BlockPropDlgProc, (LPARAM)this);

}

BlockControl::AddBlockName(ReferenceTarget *anim,ReferenceTarget *client, int subNum, NameList &names)

{

MyEnumProc dep;              
anim->EnumDependents(&dep);
TSTR nodeName = TSTR( dep.Nodes[0]->GetName());
TSTR np = TSTR(client->SubAnimName(subNum));
TSTR Slash("/");
nodeName += Slash;
nodeName += np;
		
TSTR *st = new TSTR(nodeName);
names.Append(1,&st,1);
return 1;
}

Control* BlockControl::BuildListControl(TrackViewPick res, BOOL &createdList)
{
Control *list=NULL;
createdList = FALSE;
if ((res.anim->SuperClassID() == CTRL_FLOAT_CLASS_ID) && (res.client->ClassID() != Class_ID(FLOATLIST_CONTROL_CLASS_ID,0)))
	{
	list = (Control*)GetCOREInterface()->CreateInstance(
	CTRL_FLOAT_CLASS_ID,
	Class_ID(FLOATLIST_CONTROL_CLASS_ID,0));
	createdList = TRUE;
	}
else if ((res.anim->SuperClassID() == CTRL_FLOAT_CLASS_ID) && (res.client->ClassID() == Class_ID(FLOATLIST_CONTROL_CLASS_ID,0)))
	{
	list = (Control *)res.client;
	}
else if ((res.anim->SuperClassID() == CTRL_POSITION_CLASS_ID) && (res.client->ClassID() != Class_ID(POSLIST_CONTROL_CLASS_ID,0)))
	{
	list = (Control*)GetCOREInterface()->CreateInstance(
	CTRL_POSITION_CLASS_ID,
	Class_ID(POSLIST_CONTROL_CLASS_ID,0));
	createdList = TRUE;
	}
else if ((res.anim->SuperClassID() == CTRL_POSITION_CLASS_ID) && (res.client->ClassID() == Class_ID(POSLIST_CONTROL_CLASS_ID,0)))
	{
	list =  (Control *)res.client;
	}
else if ((res.anim->SuperClassID() == CTRL_ROTATION_CLASS_ID) && (res.client->ClassID() != Class_ID(ROTLIST_CONTROL_CLASS_ID,0)))
	{
	list = (Control*)GetCOREInterface()->CreateInstance(
	CTRL_ROTATION_CLASS_ID,
	Class_ID(ROTLIST_CONTROL_CLASS_ID,0));
	createdList = TRUE;
	}
else if ((res.anim->SuperClassID() == CTRL_ROTATION_CLASS_ID) && (res.client->ClassID() == Class_ID(ROTLIST_CONTROL_CLASS_ID,0)))
	{
	list =  (Control *)res.client;
	}
else if ((res.anim->SuperClassID() == CTRL_SCALE_CLASS_ID) && (res.client->ClassID() != Class_ID(SCALELIST_CONTROL_CLASS_ID,0)))
	{
	list = (Control*)GetCOREInterface()->CreateInstance(
	CTRL_SCALE_CLASS_ID,
	Class_ID(SCALELIST_CONTROL_CLASS_ID,0));
	createdList = TRUE;
	}
else if ((res.anim->SuperClassID() == CTRL_SCALE_CLASS_ID) && (res.client->ClassID() == Class_ID(SCALELIST_CONTROL_CLASS_ID,0)))
	{
	list =  (Control *)res.client;
	}
return list;
}

Control* BlockControl::BuildSlave(TrackViewPick res,Control* list, BOOL createdList)
{
int count = list->NumSubs()-1;
Control *slave = NULL;
for (int i = 0; i < count; i++)
	{
	if (res.anim->SuperClassID() == CTRL_FLOAT_CLASS_ID) 
		{
		slave = (Control*)list->SubAnim(i);
		if (slave->ClassID() == SLAVEFLOAT_CONTROL_CLASS_ID)
			{
//			list->AssignController(res.anim,count);
			return slave;
			}
		}
	else if (res.anim->SuperClassID() == CTRL_POSITION_CLASS_ID) 
		{
		slave = (Control*)list->SubAnim(i);
		if (slave->ClassID() == SLAVEPOS_CONTROL_CLASS_ID)
			{
//			list->AssignController(res.anim,count);
			return slave;
			}
		}
	else if (res.anim->SuperClassID() == CTRL_ROTATION_CLASS_ID) 
		{
		slave = (Control*)list->SubAnim(i);
		if (slave->ClassID() == SLAVEROTATION_CONTROL_CLASS_ID)
			{
//			list->AssignController(res.anim,count);
			return slave;
			}
		}
	else if (res.anim->SuperClassID() == CTRL_SCALE_CLASS_ID) 
		{
		slave = (Control*)list->SubAnim(i);
		if (slave->ClassID() == SLAVESCALE_CONTROL_CLASS_ID)
			{
//			list->AssignController(res.anim,count);
			return slave;
			}
		}
	}
BOOL isRotation = FALSE;
if (res.anim->SuperClassID() == CTRL_FLOAT_CLASS_ID) 
	slave = (Control*)new SlaveFloatControl;
else if (res.anim->SuperClassID() == CTRL_POSITION_CLASS_ID) 
	slave = (Control*)new SlavePosControl;
else if (res.anim->SuperClassID() == CTRL_ROTATION_CLASS_ID) 
	{
	slave = (Control*)new SlaveRotationControl;
	isRotation = TRUE;
	}
else if (res.anim->SuperClassID() == CTRL_SCALE_CLASS_ID) 
	slave = (Control*)new SlaveScaleControl;
if (createdList)
	{
//	if (isRotation)
//		{
//		list->AssignController(slave,count);
//		list->AssignController(res.anim->Clone(),count+1);
//		}	
//	else
		{
		list->AssignController(res.anim->Clone(),count);
		list->AssignController(slave,count+1);
		}	
	}
else
	{
	list->AssignController(slave,count);
	}
return slave;
}


BlockControl::AddControl(HWND hWnd)
{
//pop up track view selector
Interface *ip = GetCOREInterface();


TrackViewPick res;
MasterBlockTrackViewFilter filter;
if (ip->TrackViewPickDlg(hWnd, &res,&filter ))
	{
//pop frame selector
	if (res.anim != NULL)
		{
		int OK = DialogBoxParam  (hInstance, MAKEINTRESOURCE(IDD_TRACKPROP),
			hWnd, TrackPropDlgProc, (LPARAM)this);
		if (OK)
			{
			Control *list;
			BOOL createdList = FALSE;
//check for list control if not add
			list = BuildListControl(res,createdList);
//check if list has a slave control
			Control *slaveControl;
			slaveControl = BuildSlave(res,list,createdList);


			int i = controls.Count();
			Control *ctemp = NULL;
			controls.Append(1,&ctemp,1);
			tempControls.Append(1,&ctemp,1);
//			backPointers.Append(1,&ctemp,1);
			ReplaceReference(i,res.anim->Clone());

//copy relvant keys
			propStart = propStart * GetTicksPerFrame();
			Interval iv(propStart,propStart + (end-start));
			TrackClipObject *cpy = controls[i]->CopyTrack(iv, TIME_INCLEFT|TIME_INCRIGHT);
//nuke all keys 
			controls[i]->DeleteKeys(TRACK_DOALL);
//paste back relevant keys
			iv.Set(0,end-start);
			controls[i]->PasteTrack(cpy, iv, TIME_INCLEFT|TIME_INCRIGHT);


			tempControls[i] = (Control *) res.anim->Clone();
			SlaveControl *sl = (SlaveControl *) slaveControl;
			backPointers.Append(1,&sl,1);

			AddBlockName(res.anim,res.client,res.subNum,names);
//add slaves controls to the selected tracks and put the original as a sub anim of the slaves
//set slave	to have reference to master
			slaveControl->ReplaceReference(1,this);
//copy selected track into slave sub
			slaveControl->ReplaceReference(0,(Control*)res.anim->Clone());
			int bc;

			#define ID_TV_GETFIRSTSELECTED	680
			Tab<TrackViewPick> r;
			SendMessage(trackHWND,WM_COMMAND,ID_TV_GETFIRSTSELECTED,(LPARAM)&r);
			bc = r[0].subNum-1;

			if (res.anim->SuperClassID() == CTRL_FLOAT_CLASS_ID)
				{
				float f = 0.0f;
				tempControls[i]->DeleteKeys(TRACK_DOALL);
				tempControls[i]->SetValue(0,&f);
				SlaveFloatControl *slave = (SlaveFloatControl *) slaveControl;

				slave->scratchControl = (Control *) res.anim->Clone();
//now replace track with slave
//	int bc = Blocks.Count()-1;
				slave->blockID.Append(1,&bc,1);
				slave->subID.Append(1,&i,1);
				}
			else if (res.anim->SuperClassID() == CTRL_POSITION_CLASS_ID)
				{
				Point3 f(0.0f,0.0f,0.0f);
				tempControls[i]->DeleteKeys(TRACK_DOALL);
				tempControls[i]->SetValue(0,&f);
				SlavePosControl *slave = (SlavePosControl *) slaveControl;

				slave->scratchControl = (Control *) res.anim->Clone();
//now replace track with slave
//	int bc = Blocks.Count()-1;
				slave->blockID.Append(1,&bc,1);
				slave->subID.Append(1,&i,1);
				}
			else if (res.anim->SuperClassID() == CTRL_ROTATION_CLASS_ID)
				{
				Quat f;
				f.Identity();
				tempControls[i]->DeleteKeys(TRACK_DOALL);
				tempControls[i]->SetValue(0,&f);
				SlaveRotationControl *slave = (SlaveRotationControl *) slaveControl;

				slave->scratchControl = (Control *) res.anim->Clone();
//now replace track with slave
				slave->blockID.Append(1,&bc,1);
				slave->subID.Append(1,&i,1);

				}
			else if (res.anim->SuperClassID() == CTRL_SCALE_CLASS_ID)
				{
				Matrix3 f(1);
//		f.Identity();
				tempControls[i]->DeleteKeys(TRACK_DOALL);
				tempControls[i]->SetValue(0,&f);
				SlaveScaleControl *slave = (SlaveScaleControl *) slaveControl;

				slave->scratchControl = (Control *) res.anim->Clone();
//now replace track with slave
//	int bc = Blocks.Count()-1;
				slave->blockID.Append(1,&bc,1);
				slave->subID.Append(1,&i,1);
				}
			if (createdList)
				res.client->AssignController(list,res.subNum);
//res.client->AssignController(slave,res.subNum);

			return 1;
			
				
			}
		}

	}
return 1;

}

BlockControl::DeleteControl(int Index)

{
//names.Delete(1,whichBlock);
if ((Index < 0) || (Index >= controls.Count())) return 0;
//notify all back pointer that there block is about to be deleted

DeleteReference(Index);
controls.Delete(Index,1);
tempControls.Delete(Index,1);
names.Delete(Index,1);

for (int i = 0;i <backPointers.Count();i++)
	{
//lock at the bockid table
//	int subCount = Blocks[whichBlock]->backPointers[i]->blockID.Count();
	for (int j=0; j< backPointers[i]->blockID.Count(); j++)
		{
		if (backPointers[i]->subID[j] == Index)
			{
			backPointers[i]->blockID.Delete(j,1);
			backPointers[i]->subID.Delete(j,1);
			j--;
			}
		else if (backPointers[i]->subID[j] > Index)
			{
			backPointers[i]->subID[j] -= 1;
			}
		}

	}

backPointers.Delete(Index,1);

for (i = 0;i < externalBackPointers.Count();i++)
	{
	for (int j=0; j< externalBackPointers[i]->blockID.Count(); j++)
		{
		if (externalBackPointers[i]->subID[j] == Index)
			{
			externalBackPointers[i]->blockID.Delete(j,1);
			externalBackPointers[i]->subID.Delete(j,1);
			j--;
			}
		else if (externalBackPointers[i]->subID[j] > Index)
			{
			externalBackPointers[i]->subID[j] -= 1;
			}
		}

	}
NotifyDependents(FOREVER,0,REFMSG_CHANGE);
NotifyDependents(FOREVER,0,REFMSG_SUBANIM_STRUCTURE_CHANGED);

return 1;
}



BOOL CALLBACK BlockPropDlgProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
	BlockControl *blk = (BlockControl*)GetWindowLong(hWnd,GWL_USERDATA);


	switch (msg) {
	case WM_INITDIALOG:
		{
		blk = (BlockControl*)lParam;
		SetWindowLong(hWnd,GWL_USERDATA,lParam);


//load up list box with sub anims names
		for (int i = 0; i < blk->NumSubs(); i++)
			{
			TSTR finalName = blk->SubAnimName(i);
			SendMessage(GetDlgItem(hWnd,IDC_LIST1),
				LB_ADDSTRING,0,(LPARAM)(TCHAR*)finalName);
			}
		SendMessage(GetDlgItem(hWnd,IDC_LIST1),
			LB_SETCURSEL,0,0);
		CenterWindow(hWnd,GetParent(hWnd));
		break;
		}
		


	case WM_COMMAND:
		switch (LOWORD(wParam)) {
		case IDC_ADD:
			{
			blk->AddControl( hWnd);
			SendMessage(GetDlgItem(hWnd,IDC_LIST1),
				LB_SETCOUNT,0,0);
			for (int i = 0; i < blk->NumSubs(); i++)
				{
				TSTR finalName = blk->SubAnimName(i);
				SendMessage(GetDlgItem(hWnd,IDC_LIST1),
					LB_ADDSTRING,0,(LPARAM)(TCHAR*)finalName);
				}
			SendMessage(GetDlgItem(hWnd,IDC_LIST1),
			LB_SETCURSEL,0,0);
			break;
			}
		case IDC_REMOVE:
			{
			int sel = SendMessage(GetDlgItem(hWnd,IDC_LIST1),
						LB_GETCURSEL,0,0);
			if (sel >=0)
				{
				blk->DeleteControl(sel);
				SendMessage(GetDlgItem(hWnd,IDC_LIST1),
					LB_DELETESTRING,sel,0);

				}
			break;
			}
		case IDOK:
			{
			EndDialog(hWnd,1);
			break;
			}
		}
		break;

	default:
		return FALSE;
	}
	return TRUE;
}




BOOL CALLBACK TrackPropDlgProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
	BlockControl *blk = (BlockControl*)GetWindowLong(hWnd,GWL_USERDATA);

	ISpinnerControl *spin;
	static TSTR zero = FormatUniverseValue(0.0f);
	Rect rect;

	switch (msg) {
	case WM_INITDIALOG:
		{
		blk = (BlockControl*)lParam;
		SetWindowLong(hWnd,GWL_USERDATA,lParam);

		Interval range = GetCOREInterface()->GetAnimRange();

		
		spin = GetISpinner(GetDlgItem(hWnd,IDC_STARTSPIN));
		spin->SetLimits(-999999.0f,9999999.0f, FALSE);
		spin->SetAutoScale();
		spin->LinkToEdit(GetDlgItem(hWnd,IDC_START), EDITTYPE_INT);
		spin->SetValue(range.Start()/GetTicksPerFrame(),FALSE);
		ReleaseISpinner(spin);

		blk->propStart = range.Start()/GetTicksPerFrame();
		CenterWindow(hWnd,GetParent(hWnd));
		break;
		}
		
	case CC_SPINNER_CHANGE:
		spin = (ISpinnerControl*)lParam;
		switch (LOWORD(wParam)) {
		case IDC_STARTSPIN: blk->propStart = spin->GetIVal(); break;
		}
		break;



	case WM_COMMAND:
		switch (LOWORD(wParam)) {
		case IDOK:
			{
			EndDialog(hWnd,1);
			blk->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);

			break;
			}
		case IDCANCEL:
			EndDialog(hWnd,0);
			break;
		}
		break;

	default:
		return FALSE;
	}
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Control\block\block.cpp ===
/**********************************************************************
 *<
    FILE: ctrl.cpp

    DESCRIPTION:   DLL implementation of some controllers

    CREATED BY: Rolf Berteig

    HISTORY: created 13 June 1995

	         added independent scale controller (ScaleXYZ)
			 see file "./indescale.cpp"
			   mjm 9.15.98

 *> Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#include "block.h"
#include "buildver.h"

HINSTANCE hInstance;
int controlsInit = FALSE;

/** public functions **/
BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) {
    hInstance = hinstDLL;

    if ( !controlsInit ) {
        controlsInit = TRUE;
        
        // jaguar controls
        InitCustomControls(hInstance);

#ifdef OLD3DCONTROLS
        // initialize 3D controls
        Ctl3dRegister(hinstDLL);
        Ctl3dAutoSubclass(hinstDLL);
#endif
        
        // initialize Chicago controls
        InitCommonControls();

        }

    switch(fdwReason) {
        case DLL_PROCESS_ATTACH:
            break;
        case DLL_THREAD_ATTACH:
            break;
        case DLL_THREAD_DETACH:
            break;
        case DLL_PROCESS_DETACH:
            break;
        }
    return(TRUE);
    }


//------------------------------------------------------
// This is the interface to Jaguar:
//------------------------------------------------------

__declspec( dllexport ) const TCHAR *
LibDescription() { return _T("Block controller (Kinetix)"); }


#ifndef DESIGN_VER

/// MUST CHANGE THIS NUMBER WHEN ADD NEW CLASS
__declspec( dllexport ) int LibNumberClasses() {return 8;} // mjm 9.15.98

__declspec( dllexport ) ClassDesc*
LibClassDesc(int i) {
    switch(i) {
        case 0: return GetMasterBlockDesc();
        case 1: return GetBlockControlDesc();
        case 2: return GetSlaveFloatDesc();
        case 3: return GetSlavePosDesc();
		case 4: return GetControlContainerDesc();
        case 5: return GetSlaveRotationDesc();
        case 6: return GetSlaveScaleDesc();
        case 7: return GetSlavePoint3Desc();
        default: return 0;
        }
    }

#else

/// MUST CHANGE THIS NUMBER WHEN ADD NEW CLASS
__declspec( dllexport ) int LibNumberClasses() { return 8; } // mjm 9.15.98

__declspec( dllexport ) ClassDesc*
LibClassDesc(int i) {
    switch(i) {
        case 0: return GetMasterBlockDesc();
        case 1: return GetBlockControlDesc();
        case 2: return GetSlaveFloatDesc();
        case 3: return GetSlavePosDesc();
		case 4: return GetControlContainerDesc();
        case 5: return GetSlaveRotationDesc();
        case 6: return GetSlaveScaleDesc();
        case 7: return GetSlavePoint3Desc();
        default: return 0;
        }
    }

#endif


// Return version so can detect obsolete DLLs
__declspec( dllexport ) ULONG 
LibVersion() { return VERSION_3DSMAX; }

TCHAR *GetString(int id)
{
    static TCHAR buf[256];

    if(hInstance)
        return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Control\block\ControlContainer.cpp ===
/**********************************************************************
 *<
	FILE: controlContainer.cpp

	DESCRIPTION:  a simple object that just holds a list of sub animas 
				  so I can save and load them
				  

	CREATED BY: Peter Watje
				

	HISTORY: 11/27/1998

 *>	Copyright (c) 1998, All Rights Reserved.
 **********************************************************************/
#include "block.h"
#include "masterblock.h"
#include "Simpobj.h"
#include "iparamm2.h"

//--- ClassDescriptor and class vars ---------------------------------
ClassDesc* GetControlContainerDesc();
static ControlContainerClassDesc controlContainerDesc;
ClassDesc* GetControlContainerDesc() { return &controlContainerDesc; }

IObjParam* ControlContainerObject::ip = NULL;




// JBW: Here follows the new parameter block descriptors.  There are now 3, 
//      two new STATIC ones to hold the old class var parameters, one for the main
//		per-instance parameters.  Apart from all the extra 
//      metadata you see in the definitions, one important new idea is the
//      folding of ParamMap description info into the parameter descriptor and
//      providing a semi-automatic rollout desipaly mechanism.
//      

// Parameter Block definitions

// JBW: First come the position and version independent IDs for each
//      of the blocks and the parameters in each block.  These IDs are used
//	    in subsequent Get/SetValue() parameter access, etc. and for version-independent
//      load and save


// JBW: here are the two static block descriptors.  This form of 
//      descriptor declaration uses a static NParamBlockDesc instance whose constructor
//      uses a varargs technique to walk through all the param definitions.
//      It has the advantage of supporting optional and variable type definitions, 
//      but may generate a tad more code than a simple struct template.  I'd
//      be interested in opinions about this.

//      I'll briefly describe the first definition so you can figure the others.  Note
//      that in certain places where strings are expected, you supply a string resource ID rather than
//      a string at it does the lookup for you as needed.
//
//		line 1: block ID, internal name, local (subanim) name, flags
//																 AUTO_UI here means the rollout will
//																 be automatically created (see BeginEditParams for details)
//      line 2: since AUTO_UI was set, this line gives: 
//				dialog resource ID, rollout title, flag test, appendRollout flags
//		line 3: required info for a parameter:
//				ID, internal name, type, flags, local (subanim) name
//		lines 4-6: optional parameter declaration info.  each line starts with a tag saying what
//              kind of spec it is, in this case default value, value range, and UI info as would
//              normally be in a ParamUIDesc less range & dimension
//	    the param lines are repeated as needed for the number of parameters defined.

// JBW: this descriptor defines the main per-instance parameter block.  It is flagged as AUTO_CONSTRUCT which
//      means that the CreateInstance() will automatically create one of these blocks and set it to the reference
//      number given (0 in this case, as seen at the end of the line).

// per instance geosphere block
static ParamBlockDesc2 container_param_blk ( container_params, _T("ContainerParameters"),  0, &controlContainerDesc, P_AUTO_CONSTRUCT, 0, 
	//rollout
//	0, 0, 0, 0, NULL,
	// params
	container_refs,  _T("refs"), TYPE_REFTARG_TAB,0 , 0, 	IDS_PW_REFS, 
		end, 
	container_names,  _T("names"), TYPE_STRING_TAB,0, 0, 	IDS_PW_REFS_NAMES, 
		end, 
	container_color,  _T("color"), TYPE_POINT3, 0, 	IDS_PW_COLOR, 
		end, 
	container_start,  _T("start"), TYPE_TIMEVALUE , 0, 	IDS_PW_START, 
		end, 
	container_end,  _T("end"), TYPE_TIMEVALUE , 0, 	IDS_PW_END, 
		end, 
	container_blockname,  _T("name"), TYPE_STRING, 0, 	IDS_PW_REFS_NAMES, 
		end, 

	end
	);




//--- GSphere methods -------------------------------
// JBW: the GeoSphere constructor has gone.  The paramblock creation and wiring and
//		the intial value setting is automatic now.
// JBW: BeginEditParams() becomes much simpler with automatic UI param blocks.
//      you redirect the BeginEditParams() to the ClassDesc instance and it
//      throws up the appropriate rollouts.

ControlContainerObject::ControlContainerObject() 
	{ 
	GetControlContainerDesc()->MakeAutoParamBlocks(this); 
	assert(pblock2);
	}



void ControlContainerObject::BeginEditParams(IObjParam *ip, ULONG flags, Animatable *prev)
{
	GeomObject::BeginEditParams(ip, flags, prev);
	this->ip = ip;
	// throw up all the appropriate auto-rollouts
	controlContainerDesc.BeginEditParams(ip, this, flags, prev);
}
		
// JBW: similarly for EndEditParams and you also don't have to snapshot
//		current parameter values as initial values for next object as
//		this is automatic for the new ParamBlock params unless disabled.

void ControlContainerObject::EndEditParams(IObjParam *ip, ULONG flags, Animatable *next)
{		
	GeomObject::EndEditParams(ip, flags, next);
	this->ip = NULL;
	// tear down the appropriate auto-rollouts
	controlContainerDesc.EndEditParams(ip, this, flags, next);
}

// CONSTRUCTING THE MESH:

// To construct a geodesic sphere, we take a tetrahedron, subdivide each face into
// segs^2 faces, and project the vertices onto the sphere of the correct radius.

// This subdivision produces 3 kinds of vertices: 4 "corner" vertices, which are the
// original tetrahedral vertices; "edge" vertices, those that lie on the tetrahedron's
// edges, and "face" vertices.  There are 6 edges with (segs-1) verts on each, and
// 4 faces with (segs-1)*(segs-2)/2 verts.

// We construct these vertices in this order: the first four are the corner vertices.
// Then we use spherical interpolation to place edge vertices along each edge.
// Finally, we use the same interpolation to produce face vertices between the edge
// vertices.


// Assumed in the following function: the vertices have the same radius, or
// distance from the origin, and they have nontrivial cross product.



BOOL ControlContainerObject::HasUVW() { 
	return 0; 
	}

void ControlContainerObject::SetGenUVW(BOOL sw) {  
	}


// Now put it all together sensibly
#define EPSILON 1e-5f
void ControlContainerObject::BuildMesh(TimeValue t)
	{
	
	mesh.setNumVerts(0);
	mesh.setNumFaces(0);
	mesh.setNumTVerts (0);
	mesh.setNumTVFaces (0);


	mesh.InvalidateGeomCache();
	mesh.BuildStripsAndEdges();
}

class GSphereObjCreateCallBack : public CreateMouseCallBack {
	IPoint2 sp0;
	ControlContainerObject *ob;
	Point3 p0;
public:
	int proc( ViewExp *vpt, int msg, int point, int flags, IPoint2 m, Matrix3& mat);
	void SetObj(ControlContainerObject *obj) {ob = obj;}
};

int GSphereObjCreateCallBack::proc(ViewExp *vpt, int msg, int point, int flags, IPoint2 m, Matrix3& mat ) {
	float r;
	Point3 p1, center;

	if (msg == MOUSE_FREEMOVE)
	{
		vpt->SnapPreview(m, m, NULL, SNAP_IN_3D);
	}


	if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		switch(point) {
		case 0:  // only happens with MOUSE_POINT msg
			ob->suspendSnap = TRUE;				
			sp0 = m;
			p0 = vpt->SnapPoint(m, m, NULL, SNAP_IN_3D);
			mat.SetTrans(p0);
			break;
		case 1:
			mat.IdentityMatrix();
			p1 = vpt->SnapPoint(m, m, NULL, SNAP_IN_3D);
			center = (p0+p1)/float(2);
			mat.SetTrans(center);
			r = Length(center-p0);
			mat.SetTrans(center);
			container_param_blk.InvalidateUI();

			if (flags&MOUSE_CTRL) {
				float ang = (float)atan2(p1.y-p0.y, p1.x-p0.x);					
				mat.PreRotateZ(ob->ip->SnapAngle(ang));
			}

			if (msg==MOUSE_POINT) {
				ob->suspendSnap = FALSE;
				return (Length(m-sp0)<3)?CREATE_ABORT:CREATE_STOP;
			}
			break;					   
		}
	} else {
		if (msg == MOUSE_ABORT) return CREATE_ABORT;
	}

	return TRUE;
}

static GSphereObjCreateCallBack gsphereCreateCB;

CreateMouseCallBack* ControlContainerObject::GetCreateMouseCallBack() 
	{
	gsphereCreateCB.SetObj(this);
	return(&gsphereCreateCB);
	}


BOOL ControlContainerObject::OKtoDisplay(TimeValue t) 
	{
	return FALSE;
	}


void ControlContainerObject::InvalidateUI() 
{
	container_param_blk.InvalidateUI();
}

RefTargetHandle ControlContainerObject::Clone(RemapDir& remap) 
{
	ControlContainerObject* newob = new ControlContainerObject();	
	newob->ReplaceReference(0, pblock2->Clone(remap));
	newob->ivalid.SetEmpty();	
	return(newob);
}


int ControlContainerObject::CanConvertToType(Class_ID obtype)
	{
	return GeomObject::CanConvertToType(obtype);
	}

Object* ControlContainerObject::ConvertToType(TimeValue t, Class_ID obtype)
	{
	return SimpleObject::ConvertToType(t, obtype);
	}


void ControlContainerObject::GetCollapseTypes(Tab<Class_ID> &clist, Tab<TSTR*> &nlist)
{
    Object::GetCollapseTypes(clist, nlist);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Control\block\block.h ===
/**********************************************************************
 *<
	FILE: ctrl.h

	DESCRIPTION:

	CREATED BY: Rolf Berteig

	HISTORY: created 13 June 1995

	         added independent scale controller (ScaleXYZ)
			   mjm - 9.15.98

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef __CTRL__H
#define __CTRL__H

#include "Max.h"
#include "resource.h"


extern ClassDesc* GetMasterBlockDesc();
extern ClassDesc* GetBlockControlDesc();
extern ClassDesc* GetSlaveFloatDesc();
extern ClassDesc* GetSlavePosDesc();
extern ClassDesc* GetSlavePoint3Desc();
extern ClassDesc* GetSlaveRotationDesc();
extern ClassDesc* GetSlaveScaleDesc();
extern ClassDesc* GetControlContainerDesc();
TCHAR *GetString(int id);
extern HINSTANCE hInstance;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Control\block\masterblock.cpp ===
/**********************************************************************
 *<
	FILE: noizctrl.cpp

	DESCRIPTION: A simple noise controller

	CREATED BY: Rolf Berteig

	HISTORY: created 26 August 1995

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/
#include "block.h"
#include "units.h"
#include "masterblock.h"
#include "istdplug.h"
//#include "treevw.h"


//#include "iparamm2.h"

#define FLOATLIST_CONTROL_CLASS_ID		0x4b4b1000
#define POINT3LIST_CONTROL_CLASS_ID		0x4b4b1001
#define POSLIST_CONTROL_CLASS_ID		0x4b4b1002
#define ROTLIST_CONTROL_CLASS_ID		0x4b4b1003
#define SCALELIST_CONTROL_CLASS_ID		0x4b4b1004
#define DUMMY_CONTROL_CLASS_ID			0xeeefffff



										   
static MasterBlockClassDesc masterBlockCD;
ClassDesc* GetMasterBlockDesc() {return &masterBlockCD;}
//static Tab<NoiseCtrlWindow> noiseCtrlWindows;

static BOOL CALLBACK MasterBlockDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK AddBlockDlgProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK AttachBlockDlgProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK MasterBlockPropDlgProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK KeyPropDlgProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

/*

enum { masterblock_params };
// path_params param IDs
enum { masterblock_slaves };

// per instance path controller block
static ParamBlockDesc2 masterblock_paramblk (masterblock_params, _T("MasterParameters"),  0, &masterBlockCD, P_AUTO_CONSTRUCT + P_AUTO_UI, MASTER_PBLOCK_REF, 
	//rollout
	0, 0, 0, 0, NULL,
	// params
	masterblock_slaves,	_T("Slaves"),TYPE_FLOAT_TAB,10, P_SUBANIM, 	IDS_PW_SLAVE, 
		end, 
	end
	);

*/
//-----------------------------------------------------------------------------

/*
static void RegisterNoiseCtrlWindow(HWND hWnd, HWND hParent, Control *cont)
	{
	NoiseCtrlWindow rec(hWnd,hParent,cont);
	noiseCtrlWindows.Append(1,&rec);
	}

static void UnRegisterNoiseCtrlWindow(HWND hWnd)
	{	
	for (int i=0; i<noiseCtrlWindows.Count(); i++) {
		if (hWnd==noiseCtrlWindows[i].hWnd) {
			noiseCtrlWindows.Delete(i,1);
			return;
			}
		}	
	}

static HWND FindOpenNoiseCtrlWindow(HWND hParent,Control *cont)
	{	
	for (int i=0; i<noiseCtrlWindows.Count(); i++) {
		if (hParent == noiseCtrlWindows[i].hParent &&
			cont    == noiseCtrlWindows[i].cont) {
			return noiseCtrlWindows[i].hWnd;
			}
		}
	return NULL;
	}

*/

MasterBlockDlg::MasterBlockDlg(
		MasterBlockControl *cont,
		ParamDimensionBase *dim,
		TCHAR *pname,
		IObjParam *ip,
		HWND hParent)
	{
//	InitNoiseGraph(hInstance);
	this->cont = cont;
	this->ip   = ip;
	this->dim  = dim;
	valid = FALSE;
	cont->iop=ip;
//	elems = cont->Elems();

//	theHold.Suspend();
//	MakeRefByID(FOREVER,0,cont);
//	theHold.Resume();

//	hWnd = CreateDialogParam(
	int iret = DialogBoxParam(hInstance,MAKEINTRESOURCE(IDD_MASTERPARAMS),
		        hParent,MasterBlockDlgProc,(LPARAM)this);	
	cont->iop=NULL;

//	TSTR title = TSTR(GetString(IDS_RB_NOISECONTROLTITLE)) + TSTR(pname);
//	SetWindowText(hWnd,title);
//	ip->RegisterTimeChangeCallback(this);
	}

MasterBlockDlg::~MasterBlockDlg()
	{
//	UnRegisterNoiseCtrlWindow(hWnd);
//	ip->UnRegisterTimeChangeCallback(this);

//	theHold.Suspend();
//	DeleteAllRefsFromMe();
//	theHold.Resume();

	}

void MasterBlockDlg::Invalidate()
	{
//	valid = FALSE;
//	InvalidateRect(hWnd,NULL,FALSE);	
//	InvalidateRect(GetDlgItem(hWnd,IDC_NOISE_GRAPH),NULL,FALSE);
	}

void MasterBlockDlg::Update()
	{
	if (!valid && hWnd) {
/*
		float strength[MAX_ELEMS];
		cont->GetStrength(ip->GetTime(),strength);

		for (int i=0; i<elems; i++) {			
//			iStrength[i]->SetValue(dim->Convert(strength[i]),FALSE);
//			CheckDlgButton(hWnd,limID[i],cont->lim[i]);
			}
		if (cont->fractal) {
		} else {
			}
*/
		valid = TRUE;
		}
	}

void MasterBlockDlg::SetupUI(HWND hWnd)
	{
	this->hWnd = hWnd;

/*	iRampOut = GetISpinner(GetDlgItem(hWnd,IDC_NOISE_RAMPOUTSPIN));
	iRampOut->SetLimits(0,TIME_PosInfinity,FALSE);
	iRampOut->SetScale(10.0f);
	iRampOut->LinkToEdit(GetDlgItem(hWnd,IDC_NOISE_RAMPOUT),EDITTYPE_TIME);	
*/
	
//	SetWindowLong(GetDlgItem(hWnd,IDC_NOISE_GRAPH),GWL_USERDATA,(LONG)cont);
	SetupList();


	valid = FALSE;
	Update();
	}

void MasterBlockDlg::SetupList()
	{
	SendMessage(GetDlgItem(hWnd,IDC_LIST1),
				LB_RESETCONTENT,0,0);
	for (int i=0; i<cont->Blocks.Count(); i++) {
		TSTR name = cont->SubAnimName(i+1);
		SendMessage(GetDlgItem(hWnd,IDC_LIST1),
			LB_ADDSTRING,0,(LPARAM)(TCHAR*)name);
		}

	int sel = SendMessage(GetDlgItem(hWnd,IDC_LIST1),
				LB_GETCURSEL,0,0);

	if (sel!=LB_ERR) {
		SendMessage(GetDlgItem(hWnd,IDC_LIST1),
			LB_SETCURSEL,(WPARAM)sel,0);
		SetButtonStates();
	} else {
		if (cont->Blocks.Count() > 0)
			{
			SendMessage(GetDlgItem(hWnd,IDC_LIST1),
				LB_SETCURSEL,(WPARAM)cont->Blocks.Count()-1,0);
			SetButtonStates();
			}
		else SendMessage(GetDlgItem(hWnd,IDC_LIST1),
				LB_SETCURSEL,(WPARAM)-1,0);
		}


	}

void MasterBlockDlg::SetButtonStates()
	{
	int sel = SendMessage(GetDlgItem(hWnd,IDC_LIST1),
		LB_GETCURSEL,0,0);
	ICustEdit *iName = GetICustEdit(GetDlgItem(hWnd,IDC_LIST_NAME));

	if (sel!=LB_ERR) {
		iName->Enable();
		if (cont->names[sel]) iName->SetText(*cont->names[sel]);
		else iName->SetText(_T(""));
	} else {
		iName->Disable();
		}
	ReleaseICustEdit(iName);


	if (sel!=LB_ERR) {
		COLORREF c = cont->Blocks[sel]->color;
		IColorSwatch *cs = GetIColorSwatch(GetDlgItem(hWnd,IDC_COLOR),
				c, _T("Block Color"));
		cs->SetColor(c);
		ReleaseIColorSwatch(cs);
		}


	}

void MasterBlockDlg::EnableButtons()
{
int sel = SendMessage(GetDlgItem(hWnd,IDC_LIST1),
		LB_GETCURSEL,0,0);
if (sel>=0) {
	EnableWindow(GetDlgItem(hWnd,IDC_SAVE),TRUE);
	EnableWindow(GetDlgItem(hWnd,IDC_REPLACE),TRUE);
	EnableWindow(GetDlgItem(hWnd,IDC_DELETE),TRUE);
	}
else {
	EnableWindow(GetDlgItem(hWnd,IDC_SAVE),FALSE);
	EnableWindow(GetDlgItem(hWnd,IDC_REPLACE),FALSE);
	EnableWindow(GetDlgItem(hWnd,IDC_DELETE),FALSE);
	}
}

void MasterBlockDlg::WMCommand(int id, int notify, HWND hCtrl)
	{
	switch (id) {
		case IDC_LIST_NAME: {
			int sel = SendMessage(GetDlgItem(hWnd,IDC_LIST1),
				LB_GETCURSEL,0,0);
			if (sel>=0) {
				TCHAR buf[256];
				ICustEdit *iName = GetICustEdit(GetDlgItem(hWnd,IDC_LIST_NAME));
				iName->GetText(buf,256);
				if (!cont->names[sel]) cont->names[sel] = new TSTR;
				*cont->names[sel] = buf;

				cont->NotifyDependents(FOREVER,0,REFMSG_NODE_NAMECHANGE);

				SendMessage(GetDlgItem(hWnd,IDC_LIST1),
					LB_RESETCONTENT,0,0);
				for (int i=0; i<cont->Blocks.Count(); i++) {
					TSTR name = cont->SubAnimName(i+1);
					SendMessage(GetDlgItem(hWnd,IDC_LIST1),
						LB_ADDSTRING,0,(LPARAM)(TCHAR*)name);
					}
				SendMessage(GetDlgItem(hWnd,IDC_LIST1),
					LB_SETCURSEL,(WPARAM)sel,0);



//				SetupList();
				ReleaseICustEdit(iName);
//				EnableWindow(GetDlgItem(hWnd,IDC_SAVE),TRUE);
//				EnableWindow(GetDlgItem(hWnd,IDC_REPLACE),TRUE);
//				EnableWindow(GetDlgItem(hWnd,IDC_DELETE),TRUE);

				}
			break;
			}
		case IDC_LIST1:
			if (notify==LBN_SELCHANGE) {
				SetButtonStates();				
				}

			break;
		case IDC_ADD:
			theHold.Begin();
			theHold.Put(new MasterBlockAdd(cont));
			theHold.Suspend();
			cont->AddBlock(hCtrl);
			SetupList();
			EnableButtons();
			theHold.Resume();
			theHold.Accept(GetString(IDS_PW_ADDBLOCK));
			GetSystemSetting(SYSSET_CLEAR_UNDO);
			SetSaveRequiredFlag(TRUE);
			break;
		case IDC_ADD_SELECTED:
			theHold.Begin();
			theHold.Suspend();
			cont->AddSelected(hCtrl);
			SetupList();
			EnableButtons();
			theHold.Resume();
			theHold.Accept(GetString(IDS_PW_ADDBLOCK));
			GetSystemSetting(SYSSET_CLEAR_UNDO);
			SetSaveRequiredFlag(TRUE);
			break;

		case IDC_REPLACE:
			{
			int sel = SendMessage(GetDlgItem(hWnd,IDC_LIST1),
				LB_GETCURSEL,0,0);
			cont->ReplaceBlock(hCtrl,sel);
			SetupList();
			EnableButtons();
			GetSystemSetting(SYSSET_CLEAR_UNDO);
			SetSaveRequiredFlag(TRUE);
			break;
			}
		case IDC_DELETE:
			{
//			theHold.Begin();
			int sel = SendMessage(GetDlgItem(hWnd,IDC_LIST1),
				LB_GETCURSEL,0,0);
			cont->DeleteBlock(sel);
			SetupList();
			EnableButtons();
			GetSystemSetting(SYSSET_CLEAR_UNDO);
			break;
			}
		case IDC_SAVE:
			{
			int sel = SendMessage(GetDlgItem(hWnd,IDC_LIST1),
				LB_GETCURSEL,0,0);
			cont->SaveBlock(sel);
			SetupList();
			break;
			}
		case IDC_LOAD:
			{
			cont->LoadBlock();
			SetupList();
			break;
			}
		case IDOK:
//			DestroyWindow(hWnd);
			GetCOREInterface()->RedrawViews(GetCOREInterface()->GetTime());
			cont->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
			EndDialog(hWnd,1);
			break;
		case IDCANCEL:
			EndDialog(hWnd,0);

//			DestroyWindow(hWnd);
			break;


		}

	}


void MasterBlockDlg::Change(BOOL redraw)
	{
//	InvalidateRect(GetDlgItem(hWnd,IDC_NOISE_GRAPH),NULL,TRUE);
//	cont->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
//	UpdateWindow(GetDlgItem(hWnd,IDC_NOISE_GRAPH));
//	UpdateWindow(GetParent(hWnd));	
//	if (redraw) ip->RedrawViews(ip->GetTime());
	}


class CheckForNonMasterBlockDlg : public DependentEnumProc {
	public:		
		BOOL non;
		ReferenceMaker *me;
		CheckForNonMasterBlockDlg(ReferenceMaker *m) {non = FALSE;me = m;}
		int proc(ReferenceMaker *rmaker) {
			if (rmaker==me) return 0;
			if (rmaker->SuperClassID()!=REF_MAKER_CLASS_ID &&
				rmaker->ClassID()!=Class_ID(MASTERBLOCKDLG_CLASS_ID,0)) {
				non = TRUE;
				return 1;
				}
			return 0;
			}
	};
void MasterBlockDlg::MaybeCloseWindow()
	{
	CheckForNonMasterBlockDlg check(cont);
	cont->EnumDependents(&check);
	if (!check.non) {
		PostMessage(hWnd,WM_CLOSE,0,0);
		}
	}


/*
RefResult MasterBlockDlg::NotifyRefChanged(
		Interval changeInt, 
		RefTargetHandle hTarget, 
     	PartID& partID,  
     	RefMessage message)
	{
	switch (message) {
		case REFMSG_CHANGE:
			Invalidate();			
			break;
		
		case REFMSG_REF_DELETED:
			MaybeCloseWindow();
			break;
		}
	return REF_SUCCEED;
	}


*/





static BOOL CALLBACK MasterBlockDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	MasterBlockDlg *dlg = (MasterBlockDlg*)GetWindowLong(hWnd,GWL_USERDATA);

	switch (msg) {
		case WM_INITDIALOG:
			{
			dlg = (MasterBlockDlg*)lParam;
			SetWindowLong(hWnd,GWL_USERDATA,lParam);
			dlg->SetupUI(hWnd);
			SendMessage(GetDlgItem(hWnd,IDC_LIST1),
				LB_SETCURSEL,0,0);
			int sel = SendMessage(GetDlgItem(hWnd,IDC_LIST1),
				LB_GETCURSEL,0,0);
			if (sel==-1) 
				{
				EnableWindow(GetDlgItem(hWnd,IDC_SAVE),FALSE);
				EnableWindow(GetDlgItem(hWnd,IDC_REPLACE),FALSE);
				EnableWindow(GetDlgItem(hWnd,IDC_DELETE),FALSE);
				}

			if (dlg->cont->Blocks.Count()>0)
				{
				COLORREF c = dlg->cont->Blocks[0]->color;
				IColorSwatch *cs = GetIColorSwatch(GetDlgItem(hWnd,IDC_COLOR),
					c, _T("Block Color"));
				cs->SetColor(c);
				ReleaseIColorSwatch(cs);

				ICustEdit *iName = GetICustEdit(GetDlgItem(hWnd,IDC_LIST_NAME));

				if (dlg->cont->names[0]) iName->SetText(*dlg->cont->names[0]);
				else iName->SetText(_T(""));
				ReleaseICustEdit(iName);

	
				}


			break;

			}
		case WM_COMMAND:
			dlg->WMCommand(LOWORD(wParam),HIWORD(wParam),(HWND)lParam);						
			break;

		case WM_PAINT:
			dlg->Update();
			return 0;			
		
		case WM_CLOSE:
			DestroyWindow(hWnd);			
			break;

		case WM_DESTROY:						
			delete dlg;
			break;
	
		case CC_COLOR_BUTTONDOWN:
			theHold.Begin();
			break;
		case CC_COLOR_BUTTONUP:
			if (HIWORD(wParam)) theHold.Accept(GetString(IDS_DS_PARAMCHG));
			else theHold.Cancel();
			break;
		case CC_COLOR_CHANGE: {
			int i = LOWORD(wParam);
			IColorSwatch *cs = (IColorSwatch*)lParam;
			int sel = SendMessage(GetDlgItem(hWnd,IDC_LIST1),
				LB_GETCURSEL,0,0);
			if (sel != -1)
				{
				if (HIWORD(wParam)) theHold.Begin();
				dlg->cont->Blocks[sel]->color = cs->GetColor();
				if (HIWORD(wParam)) {
					theHold.Accept(GetString(IDS_DS_PARAMCHG));
					}
				}
			break;
		}

		
		default:
			return FALSE;
		}
	return TRUE;
	}




void MasterBlockControl::EditTrackParams(
		TimeValue t,
		ParamDimensionBase *dim,
		TCHAR *pname,
		HWND hParent,
		IObjParam *ip,
		DWORD flags)
	{
	
	BOOL found = FALSE;
	trackHWND = hParent;
	int where;
	for (int i = 0; i < BlockKeys.Count(); i++)
		{
		if (BlockKeys[i].start < BlockKeys[i].end)
			{
			if ( ((t >= BlockKeys[i].start) && (t <= BlockKeys[i].end)) &&
				 ((BlockKeys[i].startSelected) || ( BlockKeys[i].endSelected))
				)
				{
				found = TRUE;
				where = i;
				}
			}
		else
			{
			if ( ( (t >= BlockKeys[i].end) && (t <= BlockKeys[i].start) ) &&
				 ((BlockKeys[i].startSelected) || ( BlockKeys[i].endSelected)) )
				{
				found = TRUE;
				where = i;
				}
			}

		}
	if (found)
		{
		propStart = BlockKeys[where].start;
		propEnd = BlockKeys[where].end;
		propRelative = BlockKeys[where].relative;

		int OK = DialogBoxParam  (hInstance, MAKEINTRESOURCE(IDD_KEYPROP),
				hParent, KeyPropDlgProc, (LPARAM)this);
		if (OK)
			{
//change block type			
			BlockKeys[where].start = propStart * GetTicksPerFrame() ;
			BlockKeys[where].end = propEnd * GetTicksPerFrame() ;
			BlockKeys[where].relative = propRelative;
			UpdateControl(BlockKeys[where].block_id);
			GetCOREInterface()->RedrawViews(GetCOREInterface()->GetTime());

			}
		}
	else{ 
//add right click menu here
//add only if valid time range
		if (EDITTRACK_MOUSE&flags)
			{
			HMENU hMenu = CreatePopupMenu();
			for (int i = 0; i < Blocks.Count();i++)
				AppendMenu(  hMenu,      // handle to menu to be changed
						 MF_ENABLED | MF_STRING,      // menu-item flags
						i+2,  // menu-item identifier or handle to drop-down menu or submenu
						*names[i] // menu-item content
						);
			if (Blocks.Count() > 0)
				AppendMenu(  hMenu,      // handle to menu to be changed
						 MF_SEPARATOR,      // menu-item flags
						0,  // menu-item identifier or handle to drop-down menu or submenu
						NULL // menu-item content
						);
			AppendMenu(  hMenu,      // handle to menu to be changed
					 MF_ENABLED | MF_STRING,      // menu-item flags
					1,  // menu-item identifier or handle to drop-down menu or submenu
					GetString(IDS_PW_PROPERTIES) // menu-item content
					);
			POINT lpPoint;   
			GetCursorPos( &lpPoint );  // address of structure for cursor position); 

			int id = TrackPopupMenuEx(hMenu, 
				TPM_TOPALIGN | TPM_VCENTERALIGN | TPM_RIGHTBUTTON  | TPM_RETURNCMD , 
				lpPoint.x, lpPoint.y,  hParent, NULL);
			DestroyMenu(hMenu);		

			if (id == 1) 
				{
				MasterBlockDlg *dlg = new MasterBlockDlg(this,dim,pname,ip,hParent);
//				delete dlg;
				}
				else
				{
				if ((id >=2) && (id < (Blocks.Count()+2)) )
					AddKey(t, id-2);
				}
			}
		else
			{
			MasterBlockDlg *dlg = new MasterBlockDlg(this,dim,pname,ip,hParent);
			}



//add new key block

		}
	}


//------------------------------------------------------------

MasterBlockControl::MasterBlockControl() 
	{	
//	for (int i=0; i<MAX_ELEMS; i++) {
		//strength[i] = 50.0f;
//		lim[i] = FALSE;
//		}
//	fractal   = TRUE;
//	roughness = 0.0f;
//	frequency = 0.5f;	
//	seed      = 0;	
//	rampin = rampout = 0;
//	`SetStart(0);
	range.SetEmpty();
//	range    = Interval(GetAnimStart(),GetAnimEnd());

//	cont=NULL;
//	ReplaceReference(Control::NumRefs(),NewDefaultFloatController());
//	float v = 50.0f;
//	cont->SetValue(0,&v);
	blendControl = NULL;
	ReplaceReference(0,NewDefaultFloatController());
	float v = 1.0f;
	blendControl->SetValue(0,&v);
	isCurveSelected = FALSE;
	rangeUnlocked = FALSE;

//	masterBlockCD.MakeAutoParamBlocks(this);


	} 

int MasterBlockControl::NumSubs() 
	{
	return Blocks.Count()+1;
	}

Animatable* MasterBlockControl::SubAnim(int i) 
	{
	if (i==0)
		return blendControl;
	else if ((i-1) < Blocks.Count())
		return Blocks[i-1];
	else
		{
//		DebugPrint("Subanims out of range call\n");
		return NULL;
		}
	}

TSTR MasterBlockControl::SubAnimName(int i) 
	{
		TSTR name;
		if (i==0)
			return GetString(IDS_PW_BLEND); 
		else if ((i-1) < names.Count())
			{
			if (names[i-1] && names[i-1]->length()) 
				{
				name = *names[i-1];
				}
			} 
		else if (Blocks[i-1]) 
			{
			Blocks[i-1]->GetClassName(name);
			} 
/*
	if (i<Control::NumSubs()) 
		return Control::SubAnimName(i);*/
	return name;
	}


BOOL MasterBlockControl::AssignController(Animatable *control,int subAnim) 
	{
	if (subAnim == 0)
		{
		ReplaceReference(0,(Control*)control);
		return TRUE;
		}
	else return FALSE;
	}


int MasterBlockControl::NumRefs() 
	{
	return Blocks.Count() + 1;
	}

RefTargetHandle MasterBlockControl::GetReference(int i) 
	{
	if (i == 0)
		return blendControl;
	else if ((i-1) < Blocks.Count())
		return Blocks[i-1];
	else 
		{
//		DebugPrint("get reference error occurred\n");
		return NULL;
		}
	}

void MasterBlockControl::SetReference(int i, RefTargetHandle rtarg) 
	{
	if (i==0) blendControl = (Control *) rtarg;
	else if ((i-1) < Blocks.Count())
		Blocks[i-1] = (BlockControl *) rtarg;
	else DebugPrint("set reference error occurred\n");

//	pblock2 = (IParamBlock2*)rtarg;
	}


RefResult MasterBlockControl::NotifyRefChanged(
		Interval changeInt, 
		RefTargetHandle hTarget, 
     	PartID& partID,  
     	RefMessage message)
	{
	switch (message) {
		case REFMSG_CHANGE:
//			Invalidate();			
//			DebugPrint("Ref changed should have slave get updated\n");
			break;
		
		}
	return REF_SUCCEED;
	}


void MasterBlockControl::UpdateControl(int index)
{


Blocks[index]->RebuildTempControl();
for (int i = 0; i < BlockKeys.Count();i++)
	{
	if (BlockKeys[i].block_id == index)
		Blocks[index]->AddKeyToTempControl(BlockKeys[i].start,  BlockKeys[i].end-BlockKeys[i].start,BlockKeys[i].relative);
	}
Blocks[index]->NotifySlaves();


}


void MasterBlockControl::HoldRange()
	{
	if (theHold.Holding() && !TestAFlag(A_HELD)) {
		SetAFlag(A_HELD);
		theHold.Put(new RangeRestore(this));
		}
	}
void MasterBlockControl::HoldTrack()
	{
	if (theHold.Holding() && !TestAFlag(A_HELD)) {
		SetAFlag(A_HELD);
		theHold.Put(new MasterBlockRest(this));
		}
	}



void MasterBlockControl::EditTimeRange(Interval range,DWORD flags)
	{
//DebugPrint("EditTimeRaneg\n");
	if ((flags&EDITRANGE_LINKTOKEYS)) {
		rangeUnlocked = FALSE; 
		}
	else 
		{
		HoldRange();
		this->range = range;
		rangeUnlocked = TRUE; 
		}

	for (int i = 0; i < Blocks.Count();i++)
		{
		UpdateControl(i);
		}

	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
/*	
	if (!(flags&EDITRANGE_LINKTOKEYS)) {
		HoldRange();
		this->range = range;
		NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);

		}
*/
	}

void MasterBlockControl::SelectCurve(BOOL sel)
{
isCurveSelected = sel;
if (!sel)
	{
//	DebugPrint("Not Selected Curve\n");

	for (int i=0; i < BlockKeys.Count(); i++)
		{
		BlockKeys[i].startSelected = FALSE;
		BlockKeys[i].endSelected = FALSE;
		}
	}
//else DebugPrint("Selected Curve\n");
}
BOOL MasterBlockControl::IsCurveSelected()
{
return isCurveSelected;
}


void MasterBlockControl::UpdateRange()
{

if (!rangeUnlocked)
	{
		range.SetEmpty();
		if (BlockKeys.Count() > 0)
			{
			if (BlockKeys[0].start < BlockKeys[0].end)
				{
				range.SetStart(BlockKeys[0].start);
				range.SetEnd(BlockKeys[0].end);
				}
			else
				{
				range.SetEnd(BlockKeys[0].start);
				range.SetStart(BlockKeys[0].end);
				}
			}
		for (int i=1; i < BlockKeys.Count(); i++)
			{
			if (BlockKeys[i].start < range.Start()) range.SetStart(BlockKeys[i].start);
			if (BlockKeys[i].end < range.Start()) range.SetStart(BlockKeys[i].end);
			if (BlockKeys[i].start > range.End()) range.SetEnd(BlockKeys[i].start);
			if (BlockKeys[i].end > range.End()) range.SetEnd(BlockKeys[i].end);
			}
	}
}

void MasterBlockControl::MapKeys(TimeMap *map,DWORD flags)
	{

	HoldTrack();
//	DebugPrint("MapKEys\n");
	if (flags&TRACK_MAPRANGE) {
		HoldRange();
		TimeValue t0 = map->map(range.Start());
		TimeValue t1 = map->map(range.End());

		range.Set(t0,t1);
//	DebugPrint("Range %d %d new range %d %d\n",t0,t1,range.Start(),range.End());
		NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
		}

	int n = BlockKeys.Count();
	BOOL changed = FALSE;
	if (!n) return;
	BitArray changedBlock;

	changedBlock.SetSize(Blocks.Count());
	changedBlock.ClearAll();

	if (flags&TRACK_DOALL) {
		for (int i=0; i<n; i++) {
			BlockKeys[i].start = map->map(BlockKeys[i].start);
			BlockKeys[i].end = map->map(BlockKeys[i].end);
			changedBlock.Set(BlockKeys[i].block_id);
			changed = TRUE;
			}
	} else 
	if (flags&TRACK_DOSEL) {
		BOOL slide = flags&TRACK_SLIDEUNSEL;
		TimeValue delta = 0, prev;
		int start, end, inc;
		if (flags&TRACK_RIGHTTOLEFT) {
			start = n-1;
			end = -1;
			inc = -1;
		} else {
			start = 0;
			end = n;
			inc = 1;
			} 
		for (int i = start; i!=end; i+=inc) {
			if (BlockKeys[i].startSelected) {                   
				prev = BlockKeys[i].start;
				BlockKeys[i].start = map->map(BlockKeys[i].start);
				delta = BlockKeys[i].start - prev;
				changedBlock.Set(BlockKeys[i].block_id);

				changed = TRUE;
			} else if (slide) {
				BlockKeys[i].start += delta;
				changedBlock.Set(BlockKeys[i].block_id);

				}
			if (BlockKeys[i].endSelected) {                   
				prev = BlockKeys[i].end;
				BlockKeys[i].end = map->map(BlockKeys[i].end);
				delta = BlockKeys[i].end - prev;
				changedBlock.Set(BlockKeys[i].block_id);

				changed = TRUE;
			} else if (slide) {
				BlockKeys[i].end += delta;
				changedBlock.Set(BlockKeys[i].block_id);

				}
			}
		}


/*	if (flags&TRACK_MAPRANGE && keys.TestFlag(RANGE_UNLOCKED)) {
		TimeValue t0 = map->map(keys.range.Start());
		TimeValue t1 = map->map(keys.range.End());
		keys.range.Set(t0,t1);
		}
*/
	UpdateRange();

	if (changed) {
//		keys.Invalidate();
//		Invalidate();
		for (int i = 0; i < changedBlock.GetSize();i++)
			{
			if (changedBlock[i])
				UpdateControl(i);
			}

		NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
		}


	}

void MasterBlockControl::FlagKey(TrackHitRecord hit)
	{
	int n = BlockKeys.Count();
	for ( int i = 0; i < n; i++ ) {
		BlockKeys[i].startFlag  = 0;
		BlockKeys[i].endFlag  = 0;
		}
	int index  = hit.hit;

	int whichBlock = index/2;
	int whichEnd = index%2;
//	assert(hit.hit>=0&&hit.hit<(DWORD)n);
	if (whichEnd ==0)
		BlockKeys[whichBlock].startFlag = KEY_FLAGGED;
	else if (whichEnd ==1)
		BlockKeys[whichBlock].endFlag = KEY_FLAGGED;

//DebugPrint("Flag key %d %d \n",whichBlock,whichEnd);

	}

int MasterBlockControl::GetFlagKeyIndex()
	{
	int n = BlockKeys.Count()/2;
//DebugPrint("Get Flag key \n");
	for ( int i = 0; i < n; i++ ) {
		if (BlockKeys[i].startFlag == KEY_FLAGGED)
			{
			return i*2;
			}
		if (BlockKeys[i].endFlag == KEY_FLAGGED)
			{
			return i*2+1;
			}
		}

	return -1;
	}


int MasterBlockControl::NumSelKeys()
{
int ct = 0;
for (int i = 0; i < BlockKeys.Count(); i++)
	{
	if (BlockKeys[i].startSelected)  ct++;
	if (BlockKeys[i].endSelected)  ct++;
	}
//DebugPrint("Num sel keys %d\n",ct);
return ct;
}
int MasterBlockControl::NumKeys()
{
//DebugPrint("Num keys %d\n",BlockKeys.Count());
return BlockKeys.Count()*2;
}

TimeValue MasterBlockControl::GetKeyTime(int index) 
{
//DebugPrint("Get key time  %d\n",index);
	int whichBlock = index/2;
	int whichEnd = index%2;
	if (whichEnd == 0)
		return BlockKeys[whichBlock].start;
	else return BlockKeys[whichBlock].end;
}

void MasterBlockControl::CloneSelectedKeys(BOOL offset)
	{
//DebugPrint("Clone Me Offset %d\n",offset);
//loop through block keys
	int ct = BlockKeys.Count();
	for (int i = 0; i < ct; i++)
		{
		if ( ( BlockKeys[i].startSelected) && (BlockKeys[i].endSelected))
			{
			BlockKeysClass b;
			b = BlockKeys[i];
			BlockKeys.Append(1,&b,1);

			}
		BlockKeys[i].startSelected = FALSE;
		BlockKeys[i].endSelected = FALSE;

		}

//	if (!conts.Count()) return;
//	assert(active>=0);
//	conts[active]->CloneSelectedKeys(offset);
	}

void MasterBlockControl::DeleteKeys(DWORD flags)
	{
//DebugPrint("Delete Me \n");

	if (theHold.Holding()&&!TestAFlag(A_HELD)) {		
		theHold.Put(new MasterBlockDeleteKey(this));
		SetAFlag(A_HELD);
		}
	theHold.Accept(GetString(IDS_PW_MB_DELETEKEY));
	//HoldRange();

	BitArray UpdateList;
	UpdateList.SetSize(Blocks.Count());
	UpdateList.ClearAll();
	for (int i = 0; i < BlockKeys.Count(); i++)
		{
//loop through blocks
		if ( ( BlockKeys[i].startSelected) || (BlockKeys[i].endSelected))
			{
//find blocks that are selected and delete them
			UpdateList.Set(BlockKeys[i].block_id);
			BlockKeys.Delete(i,1);
			i--;
			}	
		}
	UpdateRange();
	for (i = 0; i < UpdateList.GetSize(); i++)
		{
		if (UpdateList[i])
			{
			UpdateControl(i);
			}
		}

	}


BOOL MasterBlockControl::IsKeySelected(int index)
	{
//	if (!conts.Count()) return FALSE;
//	assert(active>=0);
//	return conts[active]->IsKeySelected(index);
//DebugPrint("Is key selected \n");
	int whichBlock = index /2;
	int whichEnd = index %2;
	
	if (index<BlockKeys.Count())
		{
		if (whichEnd == 0)
			return BlockKeys[index].startSelected;
		else return BlockKeys[index].endSelected;
		}
	return FALSE;
	}

void MasterBlockControl::CopyKeysFromTime(TimeValue src,TimeValue dst,DWORD flags)
	{
//DebugPrint("Copy Me %d to %d\n",src,dst);

//	if (!conts.Count()) return;
//	assert(active>=0);
//	conts[active]->CopyKeysFromTime(src,dst,flags);
	}
/*
void ListControl::DeleteKeyAtTime(TimeValue t)
	{
	if (!conts.Count()) return;
	assert(active>=0);
	conts[active]->DeleteKeyAtTime(t);
	}
*/

BOOL MasterBlockControl::IsKeyAtTime(TimeValue t,DWORD flags)
	{
//DebugPrint("Is Key at time %d \n",t);
//	if (!conts.Count()) return FALSE;
//	assert(active>=0);
//	return conts[active]->IsKeyAtTime(t,flags);
	for (int i = 0; i < BlockKeys.Count();i++)
		{
		if (BlockKeys[i].start = t) return TRUE;
		}
	return FALSE;
	}
/*
BOOL MasterBlockControl::GetNextKeyTime(TimeValue t,DWORD flags,TimeValue &nt)
	{
	if (!conts.Count()) return FALSE;
	assert(active>=0);
	return conts[active]->GetNextKeyTime(t,flags,nt);
	}
*/
int MasterBlockControl::GetKeyTimes(Tab<TimeValue> &times,Interval range,DWORD flags)
	{
//DebugPrint("Get Key times \n");
//	if (!conts.Count()) return 0;
//	assert(active>=0);
//	return conts[active]->GetKeyTimes(times,range,flags);
	int ct =  0;
	for (int i = 0; i < BlockKeys.Count();i++)
		{
		if (range.InInterval(BlockKeys[i].start))
			{
			times.Append(1,&BlockKeys[i].start,1);
			}
		else if (BlockKeys[i].start<range.Start()) 
			ct++;
		}
	return ct;
	}

int MasterBlockControl::GetKeySelState(BitArray &sel,Interval range,DWORD flags)
	{
//DebugPrint("Is Key Sel state  \n");

//	if (!conts.Count()) return 0;
//	assert(active>=0);
//	return conts[active]->GetKeySelState(sel,range,flags);
	int ct =  0;
	for (int i = 0; i < BlockKeys.Count();i++)
		{
		if (range.InInterval(BlockKeys[i].start))
			{
			if (BlockKeys[i*2].startSelected)
				sel.Set(i*2);
			else sel.Clear(i*2);
			}
		else if (BlockKeys[i].start<range.Start()) 
			ct++;
		if (range.InInterval(BlockKeys[i].end))
			{
			if (BlockKeys[i*2+1].endSelected)
				sel.Set(i*2+1);
			else sel.Clear(i*2+1);
			}
		else if (BlockKeys[i].end<range.Start()) 
			ct++;

		
		}
	return ct;
	}


void MasterBlockControl::AddKey(TimeValue t, int whichBlock)
	{
//DebugPrint("Add key here\n");
//pop up a menu listing all types

	
	if (theHold.Holding()&&!TestAFlag(A_HELD)) {		
		theHold.Put(new MasterBlockAddKey(this));
		SetAFlag(A_HELD);
		}
	else
		{
		theHold.Begin();
		theHold.Put(new MasterBlockAddKey(this));
		SetAFlag(A_HELD);

		}
	theHold.Accept(	GetString(IDS_PW_MB_ADDKEY));

//	theHold.Cancel();
//	PopCommandMode();
	AddDialogSelect = whichBlock;

	if (AddDialogSelect != -1)
		{
		//HoldTrack();
//add a new block track here at this time
		BlockKeysClass block;
		block.startSelected = FALSE;
		block.endSelected = FALSE;
		block.relative = TRUE;
		block.start = t;
		TimeValue l = Blocks[AddDialogSelect]->end - Blocks[AddDialogSelect]->start +1;
//		block.end = t+ Blocks[AddDialogSelect]->l-1;
		block.end = t+ l-1;
		block.block_id = AddDialogSelect;
		BlockKeys.Append(1,&block,1);

		UpdateRange();

		UpdateControl(AddDialogSelect);
//		UpdateControl(AddDialogSelect);
		GetCOREInterface()->RedrawViews(GetCOREInterface()->GetTime());
//		NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
		
//		Blocks[AddDialogSelect]->NotifySlaves();
		}

		
	}


void MasterBlockControl::AddNewKey(TimeValue t,DWORD flags)
	{
	}
void MasterBlockControl::SelectKeys(TrackHitTab& sel, DWORD flags)
{
if (theHold.Holding()&&!TestAFlag(A_HELD)) {		
	theHold.Put(new MasterBlockRest(this));
	SetAFlag(A_HELD);
	}
else
	{
	theHold.Begin();
	theHold.Put(new MasterBlockRest(this));
	SetAFlag(A_HELD);
	}



theHold.Accept(	GetString(IDS_PW_MB_SELECTKEY));




if (flags&SELKEYS_CLEARCURVE) isCurveSelected = FALSE;
if ((flags&SELKEYS_CLEARKEYS) || (flags&SELKEYS_CLEARCURVE))
	{
	
	for (int i = 0; i < BlockKeys.Count(); i++)
		{
		if (sel.Count() == 0)
			{
			BlockKeys[i].startSelected = FALSE;
			BlockKeys[i].endSelected = FALSE;
			}
		else
			{
			if (sel[0].flags !=2)
				{
				BlockKeys[i].startSelected = FALSE;
				BlockKeys[i].endSelected = FALSE;

				}	
			}
		}
	}

BOOL fcurve = flags&SELKEYS_FCURVE;
if (flags&SELKEYS_SELECT) 
	{	
	if (fcurve) 
		{
		// If the curve isn't yet selected, eat the input and just
		// select the curve.
		if (!isCurveSelected)
			{				
			isCurveSelected = TRUE;
			return;
			}
		}
	}


for ( int i = 0; i < sel.Count(); i++)
	{
	int whichBlock = sel[i].hit /2;
	int whichEnd = sel[i].hit %2;
	if (sel[i].flags ==2)
		{
		BlockKeys[whichBlock].relative = !BlockKeys[whichBlock].relative;
		UpdateControl(BlockKeys[whichBlock].block_id);
		BlockKeys[whichBlock].endSelected = endRestoreState;
		BlockKeys[whichBlock].startSelected = startRestoreState;

		}
	else if (sel[i].flags ==1)
		{
		if (flags&SELKEYS_DESELECT)
			BlockKeys[whichBlock].startSelected = FALSE;
		if (flags&SELKEYS_SELECT)                      
			BlockKeys[whichBlock].startSelected = TRUE;
		if (flags&SELKEYS_DESELECT)
			BlockKeys[whichBlock].endSelected = FALSE;
		if (flags&SELKEYS_SELECT)                      
			BlockKeys[whichBlock].endSelected = TRUE;
		}
	else if (whichEnd ==0)
		{
		if (flags&SELKEYS_DESELECT)
			BlockKeys[whichBlock].startSelected = FALSE;
		if (flags&SELKEYS_SELECT)                      
			BlockKeys[whichBlock].startSelected = TRUE;

		}
	else if (whichEnd ==1)
		{
		if (flags&SELKEYS_DESELECT)
			BlockKeys[whichBlock].endSelected = FALSE;
		if (flags&SELKEYS_SELECT)                      
			BlockKeys[whichBlock].endSelected = TRUE;
		}

	}

NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);

}
void MasterBlockControl::SelectKeyByIndex(int i,BOOL sel)
{
	HoldTrack();
	int whichBlock = i /2;
	int whichEnd = i %2;

	if (sel) 
		{
		if (whichEnd == 0)
			BlockKeys[whichBlock].startSelected = TRUE;
		else BlockKeys[whichBlock].endSelected = TRUE;
		}
	else
		{
		if (whichEnd == 0)
			BlockKeys[whichBlock].startSelected = FALSE;
		else BlockKeys[whichBlock].endSelected = FALSE;
		}
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);

}

void MasterBlockControl::MoveKeys(ParamDimensionBase *dim,float delta,DWORD flags)
{
}

void MasterBlockControl::SetSelKeyCoords(TimeValue t, float val,DWORD flags)
{
//DebugPrint("Move key %d\n",t);
for (int i = 0; i < BlockKeys.Count(); i++)
	{
	if (BlockKeys[i].startSelected)
		{
//		TimeValue l = BlockKeys[i].end - BlockKeys[i].start;
		BlockKeys[i].start = t;
//		BlockKeys[i].end = t+l;

		}
	if (BlockKeys[i].endSelected)
		{
//		TimeValue l = BlockKeys[i].end - BlockKeys[i].start;
		BlockKeys[i].end = t;
//		BlockKeys[i].end = t+l;

		}
	}

NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);

}


int MasterBlockControl::GetSelKeyCoords(TimeValue &t, float &val,	DWORD flags)
{
int ct = 0;
TimeValue at;
BOOL tfound = FALSE;

//DebugPrint("Get Sel key Coord\n");

if (relativeHit)
	return KEYS_MULTISELECTED;

for (int i = 0; i < BlockKeys.Count(); i++)
	{
	if (flags&KEYCOORDS_TIMEONLY)
		{
		if (BlockKeys[i].startSelected)
			{
			if (tfound)
				{
				if (BlockKeys[i].start!=at) 
					{
//DebugPrint("Get Sel key multi\n");
					return KEYS_MULTISELECTED;
					}

		
				}
			else 
				{			
				tfound = TRUE;
				at = BlockKeys[i].start;
				}
			}
		if (BlockKeys[i].endSelected)
			{
			if (tfound)
				{
				if (BlockKeys[i].end!=at) 
					{
//DebugPrint("Get Sel key multi\n");
					return KEYS_MULTISELECTED;
					}
				}
			else
				{			
				tfound = TRUE;
				at = BlockKeys[i].end;
				}
			}


		}
	else
		{
//DebugPrint("Get Sel key none\n");
		return KEYS_NONESELECTED;
		}



	}
if (tfound) 
	{
	t = at;
//DebugPrint("Get Sel key %d\n",t);
	return KEYS_COMMONTIME;
	} 
else {
//DebugPrint("Get Sel key none\n");

	return KEYS_NONESELECTED;
	}

}

int MasterBlockControl::HitTestTrack(TrackHitTab& hits,Rect& rcHit,Rect& rcTrack,float zoom,int scroll,DWORD flags)

{

	int left  = ScreenToTime(rcTrack.left,zoom,scroll) - 4;
	int right = ScreenToTime(rcTrack.right,zoom,scroll) + 4;
	int n = BlockKeys.Count();
	int y = (rcTrack.top+rcTrack.bottom)/2;	
	int y2 = (y + rcTrack.bottom)/2;


	int hitCount = 0;
	int setRelative = -1;
	relativeHit = FALSE;


//check individual keys first
	for (int i = (n-1); i >= 0; i-- ) 
//	for (int i = 0; i < n; i++ ) 
		{


if  ((BlockKeys[i].startSelected) || (BlockKeys[i].endSelected))
{

			
		int sx = 0;
		int ex = 0;
		BOOL flip = FALSE;
		if (BlockKeys[i].start <= BlockKeys[i].end)
			{
			sx = TimeToScreen(BlockKeys[i].start,zoom,scroll);
			ex = TimeToScreen(BlockKeys[i].end,zoom,scroll);
			}
		else
			{
			ex = TimeToScreen(BlockKeys[i].start,zoom,scroll);
			sx = TimeToScreen(BlockKeys[i].end,zoom,scroll);
			flip = TRUE;
			}
		int mid = (sx+ex)/2;
		IPoint2 ml(mid-8,y),mr(mid+8,rcTrack.bottom);
		IPoint2 rl(rcHit.left,rcHit.top),rr(rcHit.right,rcHit.bottom);

		Box2 box(ml,mr);
		if ((sx>=rcHit.left)&&  (sx<=rcHit.right))
			   
			{
			if (!flip)
				{
				if ( (flags&HITTRACK_SELONLY) && 
					 ((!BlockKeys[i].startSelected) )) continue;
				if ( (flags&HITTRACK_UNSELONLY) && 
					 ((BlockKeys[i].startSelected) )) continue;

				TrackHitRecord rec(i*2,0);
				hits.Append(1,&rec);
				hitCount++;
				if (flags&HITTRACK_ABORTONHIT) 
					return TRACK_DONE;
				}
			else
				{
				if ( (flags&HITTRACK_SELONLY) && 
					 ((!BlockKeys[i].endSelected) )) continue;
				if ( (flags&HITTRACK_UNSELONLY) && 
					 ((BlockKeys[i].endSelected) )) continue;

				TrackHitRecord rec(i*2+1,0);
				hits.Append(1,&rec);
				hitCount++;
				if (flags&HITTRACK_ABORTONHIT) 
					return TRACK_DONE;
				}

			}
		if ((ex>=rcHit.left)&&  (ex<=rcHit.right))
			   
			{
			if (!flip)
				{
				if ( (flags&HITTRACK_SELONLY) && 
					 ((!BlockKeys[i].endSelected) )) continue;
				if ( (flags&HITTRACK_UNSELONLY) && 
					 ((BlockKeys[i].endSelected) )) continue;



				TrackHitRecord rec(i*2+1,0);
				hits.Append(1,&rec);
				hitCount++;
				if (flags&HITTRACK_ABORTONHIT) 
					return TRACK_DONE;
				}
			else
				{
				if ( (flags&HITTRACK_SELONLY) && 
					 ((!BlockKeys[i].startSelected) )) continue;
				if ( (flags&HITTRACK_UNSELONLY) && 
					 ((BlockKeys[i].startSelected) )) continue;

				TrackHitRecord rec(i*2,0);
				hits.Append(1,&rec);
				hitCount++;
				if (flags&HITTRACK_ABORTONHIT) 
					return TRACK_DONE;
				}
			}
//check if relative/absolute hit

		if (box.Contains(rl) && box.Contains(rr))
			{

				setRelative = i;
				TrackHitRecord rec(setRelative*2,2);
				hits.Append(1,&rec);
				relativeHit = TRUE;
				startRestoreState = BlockKeys[i].startSelected;
				endRestoreState = BlockKeys[i].endSelected;
				return TRACK_DONE;


			}

		else if ((rcHit.left>sx)&&  (rcHit.right<ex))
			{
			if ( (flags&HITTRACK_SELONLY) && 
				 ((!BlockKeys[i].endSelected) && (!BlockKeys[i].startSelected))) continue;
			if ( (flags&HITTRACK_UNSELONLY) && 
				 ((BlockKeys[i].endSelected) && (BlockKeys[i].startSelected))) continue;

			TrackHitRecord rec(i*2,1);
			hits.Append(1,&rec);
			hitCount++;
			if (flags&HITTRACK_ABORTONHIT) 
				return TRACK_DONE;
			}
}					
		}

//check individual keys first
	for (i = (n-1); i >= 0; i-- ) 
//	for (int i = 0; i < n; i++ ) 
		{



			
		int sx = 0;
		int ex = 0;
		BOOL flip = FALSE;
		if (BlockKeys[i].start <= BlockKeys[i].end)
			{
			sx = TimeToScreen(BlockKeys[i].start,zoom,scroll);
			ex = TimeToScreen(BlockKeys[i].end,zoom,scroll);
			}
		else
			{
			ex = TimeToScreen(BlockKeys[i].start,zoom,scroll);
			sx = TimeToScreen(BlockKeys[i].end,zoom,scroll);
			flip = TRUE;
			}
		int mid = (sx+ex)/2;
		IPoint2 ml(mid-8,y),mr(mid+8,rcTrack.bottom);
		IPoint2 rl(rcHit.left,rcHit.top),rr(rcHit.right,rcHit.bottom);

		Box2 box(ml,mr);
		if ((sx>=rcHit.left)&&  (sx<=rcHit.right))
			   
			{
			if (!flip)
				{
				if ( (flags&HITTRACK_SELONLY) && 
					 ((!BlockKeys[i].startSelected) )) continue;
				if ( (flags&HITTRACK_UNSELONLY) && 
					 ((BlockKeys[i].startSelected) )) continue;

				TrackHitRecord rec(i*2,0);
				hits.Append(1,&rec);
				hitCount++;
				if (flags&HITTRACK_ABORTONHIT) 
					return TRACK_DONE;
				}
			else
				{
				if ( (flags&HITTRACK_SELONLY) && 
					 ((!BlockKeys[i].endSelected) )) continue;
				if ( (flags&HITTRACK_UNSELONLY) && 
					 ((BlockKeys[i].endSelected) )) continue;

				TrackHitRecord rec(i*2+1,0);
				hits.Append(1,&rec);
				hitCount++;
				if (flags&HITTRACK_ABORTONHIT) 
					return TRACK_DONE;
				}

			}
		if ((ex>=rcHit.left)&&  (ex<=rcHit.right))
			   
			{
			if (!flip)
				{
				if ( (flags&HITTRACK_SELONLY) && 
					 ((!BlockKeys[i].endSelected) )) continue;
				if ( (flags&HITTRACK_UNSELONLY) && 
					 ((BlockKeys[i].endSelected) )) continue;



				TrackHitRecord rec(i*2+1,0);
				hits.Append(1,&rec);
				hitCount++;
				if (flags&HITTRACK_ABORTONHIT) 
					return TRACK_DONE;
				}
			else
				{
				if ( (flags&HITTRACK_SELONLY) && 
					 ((!BlockKeys[i].startSelected) )) continue;
				if ( (flags&HITTRACK_UNSELONLY) && 
					 ((BlockKeys[i].startSelected) )) continue;

				TrackHitRecord rec(i*2,0);
				hits.Append(1,&rec);
				hitCount++;
				if (flags&HITTRACK_ABORTONHIT) 
					return TRACK_DONE;
				}
			}
//check if relative/absolute hit

		if (box.Contains(rl) && box.Contains(rr))
			{

				setRelative = i;
				TrackHitRecord rec(setRelative*2,2);
				hits.Append(1,&rec);
				relativeHit = TRUE;
				startRestoreState = BlockKeys[i].startSelected;
				endRestoreState = BlockKeys[i].endSelected;
				return TRACK_DONE;


			}

		else if ((rcHit.left>sx)&&  (rcHit.right<ex))
			{
			if ( (flags&HITTRACK_SELONLY) && 
				 ((!BlockKeys[i].endSelected) && (!BlockKeys[i].startSelected))) continue;
			if ( (flags&HITTRACK_UNSELONLY) && 
				 ((BlockKeys[i].endSelected) && (BlockKeys[i].startSelected))) continue;

			TrackHitRecord rec(i*2,1);
			hits.Append(1,&rec);
			hitCount++;
			if (flags&HITTRACK_ABORTONHIT) 
				return TRACK_DONE;
			}
					
		}

//now check blocks
/*
	for (i = (n-1); i >= 0; i-- ) 
		{



			
		int sx = 0;
		int ex = 0;
		BOOL flip = FALSE;
		if (BlockKeys[i].start <= BlockKeys[i].end)
			{
			sx = TimeToScreen(BlockKeys[i].start,zoom,scroll);
			ex = TimeToScreen(BlockKeys[i].end,zoom,scroll);
			}
		else
			{
			ex = TimeToScreen(BlockKeys[i].start,zoom,scroll);
			sx = TimeToScreen(BlockKeys[i].end,zoom,scroll);
			flip = TRUE;
			}
		int mid = (sx+ex)/2;
		IPoint2 ml(mid-8,y),mr(mid+8,rcTrack.bottom);
		IPoint2 rl(rcHit.left,rcHit.top),rr(rcHit.right,rcHit.bottom);

		Box2 box(ml,mr);

		if ((sx>=rcHit.left)&&  (sx<=rcHit.right))
			   
			{
			if (!flip)
				{
				if ( (flags&HITTRACK_SELONLY) && 
					 ((!BlockKeys[i].startSelected) )) continue;
				if ( (flags&HITTRACK_UNSELONLY) && 
					 ((BlockKeys[i].startSelected) )) continue;

				TrackHitRecord rec(i*2,0);
				hits.Append(1,&rec);
				hitCount++;
				if (flags&HITTRACK_ABORTONHIT) 
					return TRACK_DONE;
				}
			else
				{
				if ( (flags&HITTRACK_SELONLY) && 
					 ((!BlockKeys[i].endSelected) )) continue;
				if ( (flags&HITTRACK_UNSELONLY) && 
					 ((BlockKeys[i].endSelected) )) continue;

				TrackHitRecord rec(i*2+1,0);
				hits.Append(1,&rec);
				hitCount++;
				if (flags&HITTRACK_ABORTONHIT) 
					return TRACK_DONE;
				}

			}
		if ((ex>=rcHit.left)&&  (ex<=rcHit.right))
			   
			{
			if (!flip)
				{
				if ( (flags&HITTRACK_SELONLY) && 
					 ((!BlockKeys[i].endSelected) )) continue;
				if ( (flags&HITTRACK_UNSELONLY) && 
					 ((BlockKeys[i].endSelected) )) continue;



				TrackHitRecord rec(i*2+1,0);
				hits.Append(1,&rec);
				hitCount++;
				if (flags&HITTRACK_ABORTONHIT) 
					return TRACK_DONE;
				}
			else
				{
				if ( (flags&HITTRACK_SELONLY) && 
					 ((!BlockKeys[i].startSelected) )) continue;
				if ( (flags&HITTRACK_UNSELONLY) && 
					 ((BlockKeys[i].startSelected) )) continue;

				TrackHitRecord rec(i*2,0);
				hits.Append(1,&rec);
				hitCount++;
				if (flags&HITTRACK_ABORTONHIT) 
					return TRACK_DONE;
				}
			}

//check if relative/absolute hit

		if (box.Contains(rl) && box.Contains(rr))
			{

				setRelative = i;
				TrackHitRecord rec(setRelative*2,2);
				hits.Append(1,&rec);
				relativeHit = TRUE;
				startRestoreState = BlockKeys[i].startSelected;
				endRestoreState = BlockKeys[i].endSelected;
				return TRACK_DONE;


			}

		else if ((rcHit.left>sx)&&  (rcHit.right<ex))
			{
			if ( (flags&HITTRACK_SELONLY) && 
				 ((!BlockKeys[i].endSelected) && (!BlockKeys[i].startSelected))) continue;
			if ( (flags&HITTRACK_UNSELONLY) && 
				 ((BlockKeys[i].endSelected) && (BlockKeys[i].startSelected))) continue;

			TrackHitRecord rec(i*2,1);
			hits.Append(1,&rec);
			hitCount++;
			if (flags&HITTRACK_ABORTONHIT) 
				return TRACK_DONE;
			}
					
		}
*/
	return TRACK_DONE;

}

#define HSIZE 4
#define VSIZE 5
inline void PaintKey(HDC hdc, int x, int y) {
	Ellipse(hdc,x-HSIZE,y-VSIZE,x+HSIZE,y+VSIZE);
	}


int MasterBlockControl::PaintTrack(ParamDimensionBase *dim,HDC hdc,Rect& rcTrack,Rect& rcPaint,float zoom,int scroll,DWORD flags)
{

	HPEN penIn = CreatePen(PS_SOLID,0,RGB(0,0,200));
	HPEN Redpen = CreatePen(PS_SOLID,0,RGB(200,0,0));
	HPEN RedLightpen = CreatePen(PS_SOLID,0,RGB(210,187,187));
	HPEN oldPen;

	int xl = rcPaint.left;
	int xr = rcPaint.right;
	int bot = rcPaint.bottom;
	int top = rcPaint.top;
	HGDIOBJ oldFt;  
	int		oldBkMode;


	// Kludge to paint the waveform if min == max

	oldPen = (HPEN)SelectObject(hdc,Redpen);
	oldFt = SelectObject( hdc, GetCOREInterface()->GetAppHFont());
	oldBkMode = GetBkMode( hdc); 
	SetBkMode( hdc, TRANSPARENT); 
	HBRUSH selBrush = CreateSolidBrush(RGB(255,255,255));
	HBRUSH unselBrush = (HBRUSH)GetStockObject(GRAY_BRUSH); 

	for (int i = 0; i < BlockKeys.Count();i++)
		{
		if (((!BlockKeys[i].startSelected) && (!BlockKeys[i].endSelected)))
			{
			int sx,ex;
			sx = BlockKeys[i].start;
			ex = BlockKeys[i].end;
			sx = TimeToScreen(sx,zoom,scroll);
			ex = TimeToScreen(ex,zoom,scroll);
			RECT r;
			r.left = sx-HSIZE-2;
			r.top = top;
			r.right = ex+HSIZE+2;
			r.bottom = bot;

			COLORREF c;
		

			if ((BlockKeys[i].startSelected) || (BlockKeys[i].endSelected))
				{	
				Color cc = Blocks[BlockKeys[i].block_id]->color;
				cc.r += (1.0f-cc.r) *.75f;
				cc.g += (1.0f-cc.g) *.75f;
				cc.b += (1.0f-cc.b) *.75f;
				c = (DWORD) cc;
				}
			else
				{
				c = (DWORD) Blocks[BlockKeys[i].block_id]->color;
				}

			HBRUSH sBrush = CreateSolidBrush(c);
			SelectObject(hdc,sBrush);
			Rectangle(hdc,sx-HSIZE-2,top,ex+HSIZE+2,bot-1);	
			DeleteObject(sBrush);

			int subid = BlockKeys[i].block_id;

			TSTR name = SubAnimName(subid+1);
			WhiteRect3D(hdc,r,FALSE);
			RECT tr;
			tr.left = sx-HSIZE-2;
			tr.top = top+1;
			tr.right = ex+HSIZE+2;
			tr.bottom = bot-4;

			DrawText( hdc, (TCHAR*)name, names[subid]->length(),&tr, DT_CENTER | DT_VCENTER | DT_SINGLELINE );
			TSTR abs ="A\n";
			TSTR rel ="R\n";
			if (BlockKeys[i].relative)
				DrawText( hdc, (TCHAR*)rel, 1,&tr, DT_CENTER  | DT_BOTTOM | DT_SINGLELINE );
			else DrawText( hdc, (TCHAR*)abs, 1,&tr, DT_CENTER  |  DT_BOTTOM | DT_SINGLELINE );

			if  (BlockKeys[i].startSelected) {
				SelectObject(hdc,selBrush);
			} else {
				SelectObject(hdc,unselBrush);
				}

			PaintKey(hdc,sx,bot-VSIZE-2);

			if  (BlockKeys[i].endSelected) {
				SelectObject(hdc,selBrush);
			} else {
				SelectObject(hdc,unselBrush);
				}

			PaintKey(hdc,ex,bot-VSIZE-2);

			}
		}

	for (i = 0; i < BlockKeys.Count();i++)
		{
		if (((BlockKeys[i].startSelected) || (BlockKeys[i].endSelected)))
			{
			int sx,ex;
			sx = BlockKeys[i].start;
			ex = BlockKeys[i].end;
			sx = TimeToScreen(sx,zoom,scroll);
			ex = TimeToScreen(ex,zoom,scroll);
			RECT r;
			r.left = sx-HSIZE-2;
			r.top = top;
			r.right = ex+HSIZE+2;
			r.bottom = bot;

			COLORREF c;
		

			if ((BlockKeys[i].startSelected) || (BlockKeys[i].endSelected))
				{	
				Color cc = Blocks[BlockKeys[i].block_id]->color;
				cc.r += (1.0f-cc.r) *.75f;
				cc.g += (1.0f-cc.g) *.75f;
				cc.b += (1.0f-cc.b) *.75f;
				c = (DWORD) cc;
				}
			else
				{
				c = (DWORD) Blocks[BlockKeys[i].block_id]->color;
				}

			HBRUSH sBrush = CreateSolidBrush(c);
			SelectObject(hdc,sBrush);
			Rectangle(hdc,sx-HSIZE-2,top,ex+HSIZE+2,bot-1);	
			DeleteObject(sBrush);

			int subid = BlockKeys[i].block_id;

			TSTR name = SubAnimName(subid+1);
			WhiteRect3D(hdc,r,FALSE);
			RECT tr;
			tr.left = sx-HSIZE-2;
			tr.top = top+1;
			tr.right = ex+HSIZE+2;
			tr.bottom = bot-4;

			DrawText( hdc, (TCHAR*)name, names[subid]->length(),&tr, DT_CENTER | DT_VCENTER | DT_SINGLELINE );
			TSTR abs ="A\n";
			TSTR rel ="R\n";
			if (BlockKeys[i].relative)
				DrawText( hdc, (TCHAR*)rel, 1,&tr, DT_CENTER  | DT_BOTTOM | DT_SINGLELINE );
			else DrawText( hdc, (TCHAR*)abs, 1,&tr, DT_CENTER  |  DT_BOTTOM | DT_SINGLELINE );

			if  (BlockKeys[i].startSelected) {
				SelectObject(hdc,selBrush);
			} else {
				SelectObject(hdc,unselBrush);
				}

			PaintKey(hdc,sx,bot-VSIZE-2);

			if  (BlockKeys[i].endSelected) {
				SelectObject(hdc,selBrush);
			} else {
				SelectObject(hdc,unselBrush);
				}

			PaintKey(hdc,ex,bot-VSIZE-2);

			}
		}

	for (i = 0; i < BlockKeys.Count();i++)
		{
		if (((BlockKeys[i].startSelected) && (BlockKeys[i].endSelected)))
			{
			int sx,ex;
			sx = BlockKeys[i].start;
			ex = BlockKeys[i].end;
			sx = TimeToScreen(sx,zoom,scroll);
			ex = TimeToScreen(ex,zoom,scroll);
			RECT r;
			r.left = sx-HSIZE-2;
			r.top = top;
			r.right = ex+HSIZE+2;
			r.bottom = bot;

			COLORREF c;
		

			if ((BlockKeys[i].startSelected) || (BlockKeys[i].endSelected))
				{	
				Color cc = Blocks[BlockKeys[i].block_id]->color;
				cc.r += (1.0f-cc.r) *.75f;
				cc.g += (1.0f-cc.g) *.75f;
				cc.b += (1.0f-cc.b) *.75f;
				c = (DWORD) cc;
				}
			else
				{
				c = (DWORD) Blocks[BlockKeys[i].block_id]->color;
				}

			HBRUSH sBrush = CreateSolidBrush(c);
			SelectObject(hdc,sBrush);
			Rectangle(hdc,sx-HSIZE-2,top,ex+HSIZE+2,bot-1);	
			DeleteObject(sBrush);

			int subid = BlockKeys[i].block_id;

			TSTR name = SubAnimName(subid+1);
			WhiteRect3D(hdc,r,FALSE);
			RECT tr;
			tr.left = sx-HSIZE-2;
			tr.top = top+1;
			tr.right = ex+HSIZE+2;
			tr.bottom = bot-4;

			DrawText( hdc, (TCHAR*)name, names[subid]->length(),&tr, DT_CENTER | DT_VCENTER | DT_SINGLELINE );
			TSTR abs ="A\n";
			TSTR rel ="R\n";
			if (BlockKeys[i].relative)
				DrawText( hdc, (TCHAR*)rel, 1,&tr, DT_CENTER  | DT_BOTTOM | DT_SINGLELINE );
			else DrawText( hdc, (TCHAR*)abs, 1,&tr, DT_CENTER  |  DT_BOTTOM | DT_SINGLELINE );

			if  (BlockKeys[i].startSelected) {
				SelectObject(hdc,selBrush);
			} else {
				SelectObject(hdc,unselBrush);
				}

			PaintKey(hdc,sx,bot-VSIZE-2);

			if  (BlockKeys[i].endSelected) {
				SelectObject(hdc,selBrush);
			} else {
				SelectObject(hdc,unselBrush);
				}

			PaintKey(hdc,ex,bot-VSIZE-2);

			}
		}



	SelectObject(hdc,oldPen);
	SelectObject( hdc, oldFt); 		  
	SetBkMode(hdc,oldBkMode);

	DeleteObject(penIn);
	DeleteObject(Redpen);
	DeleteObject(RedLightpen);
	DeleteObject(selBrush);
	DeleteObject(unselBrush);
	
	return TRACK_DONE;

}





int MasterBlockControl::PaintFCurves(			
			ParamDimensionBase *dim,
			HDC hdc,
			Rect& rcGraph,
			Rect& rcPaint,
			float tzoom,
			int tscroll,
			float vzoom,
			int vscroll,
			DWORD flags )
	{


	HPEN penIn = CreatePen(PS_SOLID,0,RGB(0,0,200));
	HPEN Redpen = CreatePen(PS_SOLID,0,RGB(200,0,0));
	HPEN RedLightpen = CreatePen(PS_SOLID,0,RGB(210,187,187));
	HPEN oldPen;

	int mid = (rcPaint.bottom-30);

	int xl = rcPaint.left;
	int xr = rcPaint.right;
//	int bot = rcPaint.bottom;
//	int top = rcPaint.top;
	int bot = mid+20;
	int top = mid-20;
	HGDIOBJ oldFt;  
	int		oldBkMode;


	// Kludge to paint the waveform if min == max

	oldPen = (HPEN)SelectObject(hdc,Redpen);
	oldFt = SelectObject( hdc, GetCOREInterface()->GetAppHFont());
	oldBkMode = GetBkMode( hdc); 
	SetBkMode( hdc, TRANSPARENT); 
	HBRUSH selBrush = CreateSolidBrush(RGB(255,255,255));
	HBRUSH unselBrush = (HBRUSH)GetStockObject(GRAY_BRUSH); 

	for (int i = 0; i < BlockKeys.Count();i++)
		{
		int sx,ex;
		sx = BlockKeys[i].start;
		ex = BlockKeys[i].end;
		sx = TimeToScreen(sx,tzoom,tscroll);
		ex = TimeToScreen(ex,tzoom,tscroll);
		RECT r;
		r.left = sx-HSIZE-2;
		r.top = top;
		r.right = ex+HSIZE+2;
		r.bottom = bot;

		COLORREF c;
		

		if (((BlockKeys[i].startSelected) || (BlockKeys[i].endSelected)) && (isCurveSelected))
			{	
//			SelectObject(hdc,GetStockObject(LTGRAY_BRUSH  ));
			Color cc = Blocks[BlockKeys[i].block_id]->color;
			cc.r += (1.0f-cc.r) *.75f;
			cc.g += (1.0f-cc.g) *.75f;
			cc.b += (1.0f-cc.b) *.75f;
			c = (DWORD) cc;
			}
		else
			{
			c = (DWORD) Blocks[BlockKeys[i].block_id]->color;
			}
			//SelectObject(hdc,GetStockObject(DKGRAY_BRUSH ));

		HBRUSH sBrush = CreateSolidBrush(c);
//		HPEN Colorpen = CreatePen(PS_SOLID,0,c);
		SelectObject(hdc,sBrush);
		Rectangle(hdc,sx-HSIZE-2,top,ex+HSIZE+2,bot-1);	
		DeleteObject(sBrush);

		int subid = BlockKeys[i].block_id;

		TSTR name = SubAnimName(subid+1);
		WhiteRect3D(hdc,r,FALSE);
		RECT tr;
		tr.left = sx-HSIZE-2;
		tr.top = top+1;
		tr.right = ex+HSIZE+2;
		tr.bottom = bot-4;

		DrawText( hdc, (TCHAR*)name, names[subid]->length(),&tr, DT_CENTER | DT_VCENTER | DT_SINGLELINE );
		TSTR abs ="A\n";
		TSTR rel ="R\n";
		if (BlockKeys[i].relative)
			DrawText( hdc, (TCHAR*)rel, 1,&tr, DT_CENTER  | DT_BOTTOM | DT_SINGLELINE );
		else DrawText( hdc, (TCHAR*)abs, 1,&tr, DT_CENTER  |  DT_BOTTOM | DT_SINGLELINE );

		if  (BlockKeys[i].startSelected) {
			SelectObject(hdc,selBrush);
		} else {
			SelectObject(hdc,unselBrush);
			}

		if (isCurveSelected)
			PaintKey(hdc,sx,bot-VSIZE-2);

		if  (BlockKeys[i].endSelected) {
			SelectObject(hdc,selBrush);
		} else {
			SelectObject(hdc,unselBrush);
			}

		if (isCurveSelected)
			PaintKey(hdc,ex,bot-VSIZE-2);

		}


	SelectObject(hdc,oldPen);
	SelectObject( hdc, oldFt); 		  
	SetBkMode(hdc,oldBkMode);

	DeleteObject(penIn);
	DeleteObject(Redpen);
	DeleteObject(RedLightpen);
	DeleteObject(selBrush);
	DeleteObject(unselBrush);
	
	return TRACK_DONE;

	return 0;
	}

int MasterBlockControl::HitTestFCurves(ParamDimensionBase *dim,TrackHitTab& hits, 
									   Rect& rcHit, Rect& rcTrack,
									   float zoom, int scroll,
									   float vzoom,int vscroll, DWORD flags)
{

	int left  = ScreenToTime(rcTrack.left,zoom,scroll) - 4;
	int right = ScreenToTime(rcTrack.right,zoom,scroll) + 4;
	int n = BlockKeys.Count();


	if (flags&HITTRACK_SELONLY && (!isCurveSelected)) {
		return HITCURVE_NONE;
		}		

//	int y = (rcTrack.top+rcTrack.bottom)/2;	
//	int y2 = (y + rcTrack.bottom)/2;
	int y = rcTrack.bottom-30;	
	int y2 = (y + rcTrack.bottom)/2;

//DebugPrint("Flags selonly %d\n",flags&HITTRACK_SELONLY);
//DebugPrint("Flags unselonly %d\n",flags&HITTRACK_UNSELONLY);
//DebugPrint("Flags abort on hit %d\n",flags&HITTRACK_ABORTONHIT);


	int hitCount = 0;
	int setRelative = -1;

	for (int i = 0; i < n; i++ ) 
		{

		if ( (flags&HITTRACK_SELONLY) && 
			 ((!BlockKeys[i].startSelected) && (!BlockKeys[i].endSelected))) continue;
		if ( (flags&HITTRACK_UNSELONLY) && 
			 ((BlockKeys[i].startSelected) && (BlockKeys[i].endSelected))) continue;

			
	
		int sx = TimeToScreen(BlockKeys[i].start,zoom,scroll);
		int ex = TimeToScreen(BlockKeys[i].end,zoom,scroll);
		int mid = (sx+ex)/2;
		if ((sx>=rcHit.left) &&  (sx<=rcHit.right) && (rcHit.top > (y-30)))
			   
			{

//			if ( ((flags&HITTRACK_SELONLY) && (BlockKeys[i].startSelected)) ||
//			     ((flags&HITTRACK_UNSELONLY) && (!BlockKeys[i].startSelected)) )
				{
				TrackHitRecord rec(i*2,0);
				hits.Append(1,&rec);
				hitCount++;
				}

//			if (flags&HITTRACK_ABORTONHIT) 
//				return TRACK_DONE;
			}
		if ((ex>=rcHit.left)&&  (ex<=rcHit.right) && (rcHit.top > (y-30)))
			   
			{
//			if ( ((flags&HITTRACK_SELONLY) && (BlockKeys[i].endSelected)) ||
//			     ((flags&HITTRACK_UNSELONLY) && (!BlockKeys[i].endSelected)) )
				{
				TrackHitRecord rec(i*2+1,0);
				hits.Append(1,&rec);
				hitCount++;
				}

//			if (flags&HITTRACK_ABORTONHIT) return TRACK_DONE;
			}

//check if relative/absolute hit
		if (rcHit.Contains(IPoint2(mid,y2)))
			{
			setRelative = i;
			}

		else if ((rcHit.left>sx)&&  (rcHit.right<ex) && (rcHit.top > (y-30)))
			{
//			if ( ((flags&HITTRACK_SELONLY) && ((BlockKeys[i].endSelected) ||(BlockKeys[i].startSelected))) ||
//			     ((flags&HITTRACK_UNSELONLY) && ((!BlockKeys[i].endSelected) || (!BlockKeys[i].startSelected))) )
				{
				TrackHitRecord rec(i*2,1);
				hits.Append(1,&rec);
				hitCount++;
				}
//			if (flags&HITTRACK_ABORTONHIT) 
//				return TRACK_DONE;
			}

					
		}

	if ((hitCount ==0) && (setRelative != -1))
		{
		TrackHitRecord rec(setRelative*2,2);
		hits.Append(1,&rec);
		hitCount++;
		}

	int result = HITCURVE_NONE;
	if (hitCount >0)
		result = HITCURVE_KEY;
	if (((!isCurveSelected) && result==HITCURVE_KEY)  || ((!isCurveSelected) && (rcHit.top > (y-20))) )
		{
		result = HITCURVE_WHOLE;
		}

if (result != HITCURVE_NONE)
{
/*DebugPrint("Flags HITTRACK_SELONLY %d HITTRACK_UNSELONLY %d HITTRACK_ABORT %d \n",
			 flags&HITTRACK_SELONLY,
			 flags&HITTRACK_UNSELONLY,
			 flags&HITTRACK_ABORTONHIT
			 );
DebugPrint("Result HITCURVE_WHOLE %d HITCURVE_KEY %d\n",
			 result&HITCURVE_WHOLE,
			 result&HITCURVE_KEY
			 );
*/

}
//DebugPrint("Result %d\n",result);
	return result;

/*
	if (hitCount >0)
		{
		DebugPrint("Hit keys\n");
		if (isCurveSelected)
			return HITCURVE_KEY;
		else
			{ 
			if (flags&HITTRACK_SELONLY)
				return HITCURVE_NONE;
			else return HITCURVE_WHOLE;
			}
		}
	else if (rcHit.top > (y-20))
		{
		DebugPrint("Hit whole\n");
		if (flags&HITTRACK_SELONLY)
			return HITCURVE_NONE;
		else return HITCURVE_WHOLE;
		}
	else
		{
		DebugPrint("Hit none\n");
		return HITCURVE_NONE;
		}
*/
}


#define BLOCKKEYSCOUNT_CHUNK	0x01010
#define BLOCKKEYS_CHUNK			0x01020
#define NAMECOUNT_CHUNK			0x01030
#define NAME_CHUNK				0x01040
#define NONAME_CHUNK			0x01050
#define LOCK_CHUNK				0x01060
#define RANGE_CHUNK				0x01070



IOResult MasterBlockControl::Save(ISave *isave)
	{		
	ULONG nb;	
//names
//block keys
	int count = BlockKeys.Count();
	isave->BeginChunk(BLOCKKEYSCOUNT_CHUNK);
	isave->Write(&count,sizeof(int),&nb);			
	isave->EndChunk();

	isave->BeginChunk(BLOCKKEYS_CHUNK);
	for (int i=0; i<count; i++) 
		{
		isave->Write(&BlockKeys[i],sizeof(BlockKeysClass),&nb);
		}
	isave->EndChunk();

	count = Blocks.Count();
	isave->BeginChunk(NAMECOUNT_CHUNK);
	isave->Write(&count,sizeof(int),&nb);			
	isave->EndChunk();

	for (i=0; i<count; i++) {
		if (names[i]) {
			isave->BeginChunk(NAME_CHUNK);
			isave->WriteWString(*names[i]);
			isave->EndChunk();
		} else {
			isave->BeginChunk(NONAME_CHUNK);
			isave->EndChunk();
			}
		}
	isave->BeginChunk(LOCK_CHUNK);
	isave->Write(&rangeUnlocked,sizeof(BOOL),&nb);			
	isave->EndChunk();

	isave->BeginChunk(RANGE_CHUNK);
	isave->Write(&range,sizeof(range),&nb);			
	isave->EndChunk();

	return IO_OK;
	}

class MasterBlockPostLoadCallback:public  PostLoadCallback
{
public:
	MasterBlockControl      *s;
	MasterBlockPostLoadCallback(MasterBlockControl *r) {s=r;}
	void proc(ILoad *iload);
};

void MasterBlockPostLoadCallback::proc(ILoad *iload)
{

	if (s)
		{
		for (int i = 0; i < s->Blocks.Count();i++)
			{
			s->UpdateControl(i);
			}

		}

	delete this;

}
 


IOResult MasterBlockControl::Load(ILoad *iload)
	{
	int ID =  0;
	ULONG nb;
	IOResult res = IO_OK;
	int ix = 0;
	while (IO_OK==(res=iload->OpenChunk())) 
		{
		ID = iload->CurChunkID();
		if (ID ==BLOCKKEYSCOUNT_CHUNK)
			{
			int ct;
			iload->Read(&ct, sizeof(ct), &nb);
			BlockKeys.SetCount(ct);
			}
		else if (ID ==LOCK_CHUNK)
			{
			iload->Read(&rangeUnlocked, sizeof(BOOL), &nb);
			}

		else if (ID == BLOCKKEYS_CHUNK)
			{
			for (int i = 0; i < BlockKeys.Count(); i++)
				{
				BlockKeysClass b;
				iload->Read(&b, sizeof(BlockKeysClass), &nb);
				BlockKeys[i] = b;
				}
			}
		else if (ID == NAMECOUNT_CHUNK)
			{
			int ct;
			iload->Read(&ct, sizeof(ct), &nb);
			names.SetCount(ct);
			Blocks.SetCount(ct);
			for (int i=0; i<ct; i++) 
				{
				names[i] = NULL;
				Blocks[i] = NULL;
				}

			}
		else if (ID == NAME_CHUNK)
			{
			TCHAR *buf;
			iload->ReadWStringChunk(&buf);
			names[ix++] = new TSTR(buf);
			}
		else if (ID == NONAME_CHUNK)
			{
			ix++;
			}
		else if (ID == RANGE_CHUNK)
			{
			res=iload->Read(&range,sizeof(range),&nb);
			}


		iload->CloseChunk();
		if (res!=IO_OK)  return res;
		}
//rebuild all tempcontrols	
	MasterBlockPostLoadCallback* mplcb = new MasterBlockPostLoadCallback(this);
	iload->RegisterPostLoadCallback(mplcb);

	return IO_OK;
	}


//--------------------------------------------------------------------

MasterBlockControl::LoadBlock()

{
//need to pop up a standard load dialog
Interface *ip = GetCOREInterface();
HWND hWnd = ip->GetMAXHWnd();

static TCHAR fname[256] = {'\0'};
OPENFILENAME ofn;
memset(&ofn,0,sizeof(ofn));
FilterList fl;
fl.Append( GetString(IDS_PW_BLKFILES));
fl.Append( _T("*.blk"));		
TSTR title = GetString(IDS_PW_LOADBLOCK);

ofn.lStructSize     = sizeof(OPENFILENAME);
ofn.hwndOwner       = hWnd;
ofn.lpstrFilter     = fl;
ofn.lpstrFile       = fname;
ofn.nMaxFile        = 256;    
//ofn.lpstrInitialDir = ip->GetDir(APP_EXPORT_DIR);
ofn.Flags           = OFN_HIDEREADONLY|OFN_FILEMUSTEXIST|OFN_PATHMUSTEXIST;
ofn.lpstrDefExt     = _T("blk");
ofn.lpstrTitle      = title;


if (GetOpenFileName(&ofn)) {
//load stuff here  stuff here
//merge file
//	theHold.Begin();
	theHold.Suspend();

	ip->MergeFromFile(fname, TRUE,TRUE, FALSE,MERGE_DUPS_DELOLD);

//get selected block
	INode *node = ip->GetSelNode(0);
	if (node != NULL)
		{
		ObjectState os = node->EvalWorldState(0);

		ControlContainerObject *cobj;// = new ControlContainerObject();
		ControlContainerObject *tcobj;

		tcobj = (ControlContainerObject *) os.obj;
		cobj = (ControlContainerObject *) tcobj->Clone();
		
		propContainer = cobj;

		ip->DeleteNode(node);
		theHold.Resume();

//		Color c;
//		TimeValue s,e;
		propContainer->pblock2->GetValue(container_color,0,propColor,FOREVER);
		propContainer->pblock2->GetValue(container_start,0,propStart,FOREVER);
		propContainer->pblock2->GetValue(container_end,0,propEnd,FOREVER);
		TCHAR *c;

		propContainer->pblock2->GetValue(container_blockname,0,c,FOREVER);
		propBlockName = c;

//create a new block
//copy over the subs
//copy over the names
//pop up a attach dialog so we can associate it with correct controller
		DialogBoxParam  (hInstance, MAKEINTRESOURCE(IDD_ATTACH_CONTROLS_DIALOG),
				hWnd, AttachBlockDlgProc, (LPARAM)this);
		cobj->DeleteThis();
//		theHold.Suspend();
		}
	else
		theHold.Resume();


//	theHold.Cancel();
	return 1;
	}
return 0;

}
//--------------------------------------------------------------------
MasterBlockControl::DeleteBlock(int whichBlock)

{
//names.Delete(1,whichBlock);
if ((whichBlock < 0) || (whichBlock >= Blocks.Count())) return 0;
//notify all back pointer that there block is about to be deleted
for (int i = 0;i <Blocks[whichBlock]->backPointers.Count();i++)
	{
//lock at the bockid table
//	int subCount = Blocks[whichBlock]->backPointers[i]->blockID.Count();
	if (Blocks[whichBlock]->backPointers[i])
		{
		for (int j=0; j< Blocks[whichBlock]->backPointers[i]->blockID.Count(); j++)
			{
			if (Blocks[whichBlock]->backPointers[i]->blockID[j] == whichBlock)
				{
				Blocks[whichBlock]->backPointers[i]->blockID.Delete(j,1);
				Blocks[whichBlock]->backPointers[i]->subID.Delete(j,1);
				j--;
				}
			else if (Blocks[whichBlock]->backPointers[i]->blockID[j] > whichBlock)
				{
				Blocks[whichBlock]->backPointers[i]->blockID[j] -= 1;
				}
			}
		}

	}

for (i = 0;i <Blocks[whichBlock]->externalBackPointers.Count();i++)
	{
//lock at the bockid table
//	int subCount = Blocks[whichBlock]->backPointers[i]->blockID.Count();
	if (Blocks[whichBlock]->externalBackPointers[i])
		{
		for (int j=0; j< Blocks[whichBlock]->externalBackPointers[i]->blockID.Count(); j++)
			{
			if (Blocks[whichBlock]->externalBackPointers[i]->blockID[j] == whichBlock)
				{
				Blocks[whichBlock]->externalBackPointers[i]->blockID.Delete(j,1);
				Blocks[whichBlock]->externalBackPointers[i]->subID.Delete(j,1);
				j--;
				}
			else if (Blocks[whichBlock]->externalBackPointers[i]->blockID[j] > whichBlock)
				{
				Blocks[whichBlock]->externalBackPointers[i]->blockID[j] -= 1;
				}
			}
		}

	}


//loop through all block keys and reduce the indices by one
DeleteReference(whichBlock+1);
//Blocks[whichBlock]->DeleteThis();
//Blocks[whichBlock]= NULL;
Blocks.Delete(whichBlock,1);
names.Delete(whichBlock,1);

for (i = 0; i < BlockKeys.Count(); i++)
	{
	if (BlockKeys[i].block_id == whichBlock)
		{
		BlockKeys.Delete(i,1);
		i--;
		}
	else if (BlockKeys[i].block_id > whichBlock)
		BlockKeys[i].block_id -=1;

	}
NotifyDependents(FOREVER,0,REFMSG_CHANGE);
NotifyDependents(FOREVER,0,REFMSG_SUBANIM_STRUCTURE_CHANGED);
return 1;
}

MasterBlockControl::SaveBlock(int whichBlock)

{
//build a container node
ControlContainerObject *cobj = new ControlContainerObject();

	// Create a new object through the CreateInstance() API

Interface *ip = GetCOREInterface();
/*Object *obj = (Object*)ip->CreateInstance(
	GEOMOBJECT_CLASS_ID,
	Class_ID(CYLINDER_CLASS_ID,0));
assert(obj);
*/

//ntrolContainerObject *cobj = (ControlContainerObject*) obj;

//copy data in color start end time
cobj->pblock2->SetValue(container_color,0,Blocks[whichBlock]->color);
cobj->pblock2->SetValue(container_start,0,Blocks[whichBlock]->start);
cobj->pblock2->SetValue(container_end,0,Blocks[whichBlock]->end);

TCHAR *n = *names[whichBlock];
cobj->pblock2->SetValue(container_blockname,0,n);

// Get a hold of the parameter block
//copy names selection in
//cobj->pblock2->SetValue(container_name,0,names[i]);
for (int i = 0; i < Blocks[whichBlock]->controls.Count(); i++)
	{
//copy the sub anims in
//	cobj->pblock2->SetValue(container_refs,0,Blocks[whichBlock]->controls[i]->Clone(),1);
	ReferenceTarget *c = (ReferenceTarget *) Blocks[whichBlock]->controls[i]->Clone();
	cobj->pblock2->Append(container_refs,1,&c);
	TCHAR *s = *Blocks[whichBlock]->names[i];
	cobj->pblock2->Append(container_names,1,&s);
//	cobj->pblock2->SetValue(container_names,0,s);
	}
for (i = 0; i < Blocks[whichBlock]->controls.Count(); i++)
	{
	TCHAR *c;
	cobj->pblock2->GetValue(container_names,0,c,FOREVER,i);
//	DebugPrint("save str %s\n",c);
	}
// Create a node in the scene that references the derived object

INode *node = ip->CreateObjectNode(cobj);
	
// Name the node and make the name unique.
TSTR name(_T("47df4589"));
//ip->MakeNameUnique(name);
node->SetName(name);

//save selection unselect all select it
theHold.Suspend();
//call save selected
ip->SelectNode(node,1);
//ip->FileSaveSelected();

HWND hWnd = ip->GetMAXHWnd();
static TCHAR fname[256] = {'\0'};
OPENFILENAME ofn;
memset(&ofn,0,sizeof(ofn));
FilterList fl;
fl.Append( GetString(IDS_PW_BLKFILES));
fl.Append( _T("*.blk"));		
TSTR title = GetString(IDS_PW_SAVEBLOCK);

ofn.lStructSize     = sizeof(OPENFILENAME);
ofn.hwndOwner       = hWnd;
ofn.lpstrFilter     = fl;
ofn.lpstrFile       = fname;
ofn.nMaxFile        = 256;    
//ofn.lpstrInitialDir = ip->GetDir(APP_EXPORT_DIR);
ofn.Flags           = OFN_HIDEREADONLY|OFN_FILEMUSTEXIST|OFN_PATHMUSTEXIST;
ofn.lpstrDefExt     = _T("blk");
ofn.lpstrTitle      = title;

tryAgain:
if (GetSaveFileName(&ofn)) {
	if (DoesFileExist(fname)) {
		TSTR buf1;
		TSTR buf2 = GetString(IDS_PW_SAVEBLOCK);
		buf1.printf(GetString(IDS_PW_FILEEXISTS),fname);
		if (IDYES!=MessageBox(
			hWnd,
			buf1,buf2,MB_YESNO|MB_ICONQUESTION)) {
			goto tryAgain;
			}
		}
	ip->FileSaveSelected(fname);
//reapply old selection
//delete container node
	ip->DeleteNode(node,FALSE);
	theHold.Resume();
//	theHold.Cancel();
	return 1;

	}




//reapply old selection
//delete container node
ip->DeleteNode(node,FALSE);
theHold.Resume();
//theHold.Cancel();
return 0;

}


int MyEnumProc::proc(ReferenceMaker *rmaker) 
	{ 
	if (rmaker->SuperClassID()==BASENODE_CLASS_ID)    
			{
            Nodes.Append(1, (INode **)&rmaker);                 
			name = Nodes[0]->GetName();
			return 1;
			}
	TSTR s;
	rmaker->GetClassName(s);
	TSTR b("blank");
	if (name == b)
		{
		if ( (rmaker->SuperClassID() == MATERIAL_CLASS_ID) || 
			 (rmaker->SuperClassID() == TEXMAP_CLASS_ID) || 
			 (rmaker->SuperClassID() == ATMOSPHERIC_CLASS_ID) )
			{
			 rmaker->GetClassName(name);
			 return 1;
			}

		}
//	DebugPrint("dep %s %d\n",s,rmaker->SuperClassID());
//MATERIAL_CLASS_ID
//TEXMAP_CLASS_ID
//ATMOSPHERIC_CLASS_ID
     return 0;              
	}

MasterBlockControl::AddBlockName(ReferenceTarget *anim,ReferenceTarget *client, int subNum, NameList &names)

{
MyEnumProc dep;             
TSTR b("");
dep.name =  b;
anim->EnumDependents(&dep);
//TSTR nodeName = TSTR( dep.Nodes[0]->GetName());
TSTR nodeName = dep.name;
TSTR np = TSTR(client->SubAnimName(subNum));
TSTR Slash("/");
nodeName += Slash;
nodeName += np;
TSTR *st = new TSTR(nodeName);
names.Append(1,&st,1);
return 1;
}

TSTR* MasterBlockControl::GetBlockName(ReferenceTarget *anim,ReferenceTarget *client, int subNum)

{

MyEnumProc dep;              
TSTR b("");
dep.name =  b;
anim->EnumDependents(&dep);
//TSTR nodeName = TSTR( dep.Nodes[0]->GetName());
TSTR nodeName = dep.name;
TSTR np = TSTR(client->SubAnimName(subNum));
TSTR Slash("/");
nodeName += Slash;
nodeName += np;
TSTR *st = new TSTR(nodeName);
return st;
}



Control* MasterBlockControl::BuildListControl(TrackViewPick res, BOOL &createdList)
{
Control *list=NULL;
createdList = FALSE;
if ((res.anim->SuperClassID() == CTRL_FLOAT_CLASS_ID) && (res.client->ClassID() != Class_ID(FLOATLIST_CONTROL_CLASS_ID,0)))
	{
	list = (Control*)GetCOREInterface()->CreateInstance(
	CTRL_FLOAT_CLASS_ID,
	Class_ID(FLOATLIST_CONTROL_CLASS_ID,0));
	createdList = TRUE;
	}
else if ((res.anim->SuperClassID() == CTRL_FLOAT_CLASS_ID) && (res.client->ClassID() == Class_ID(FLOATLIST_CONTROL_CLASS_ID,0)))
	{
	list = (Control *)res.client;
	}
else if ((res.anim->SuperClassID() == CTRL_POSITION_CLASS_ID) && (res.client->ClassID() != Class_ID(POSLIST_CONTROL_CLASS_ID,0)))
	{
	list = (Control*)GetCOREInterface()->CreateInstance(
	CTRL_POSITION_CLASS_ID,
	Class_ID(POSLIST_CONTROL_CLASS_ID,0));
	createdList = TRUE;
	}
else if ((res.anim->SuperClassID() == CTRL_POSITION_CLASS_ID) && (res.client->ClassID() == Class_ID(POSLIST_CONTROL_CLASS_ID,0)))
	{
	list =  (Control *)res.client;
	}
else if ((res.anim->SuperClassID() == CTRL_POINT3_CLASS_ID) && (res.client->ClassID() != Class_ID(POINT3LIST_CONTROL_CLASS_ID,0)))
	{
	list = (Control*)GetCOREInterface()->CreateInstance(
	CTRL_POINT3_CLASS_ID,
	Class_ID(POINT3LIST_CONTROL_CLASS_ID,0));
	createdList = TRUE;
	}
else if ((res.anim->SuperClassID() == CTRL_POINT3_CLASS_ID) && (res.client->ClassID() == Class_ID(POINT3LIST_CONTROL_CLASS_ID,0)))
	{
	list =  (Control *)res.client;
	}

else if ((res.anim->SuperClassID() == CTRL_ROTATION_CLASS_ID) && (res.client->ClassID() != Class_ID(ROTLIST_CONTROL_CLASS_ID,0)))
	{
	list = (Control*)GetCOREInterface()->CreateInstance(
	CTRL_ROTATION_CLASS_ID,
	Class_ID(ROTLIST_CONTROL_CLASS_ID,0));
	createdList = TRUE;
	}
else if ((res.anim->SuperClassID() == CTRL_ROTATION_CLASS_ID) && (res.client->ClassID() == Class_ID(ROTLIST_CONTROL_CLASS_ID,0)))
	{
	list =  (Control *)res.client;
	}
else if ((res.anim->SuperClassID() == CTRL_SCALE_CLASS_ID) && (res.client->ClassID() != Class_ID(SCALELIST_CONTROL_CLASS_ID,0)))
	{
	list = (Control*)GetCOREInterface()->CreateInstance(
	CTRL_SCALE_CLASS_ID,
	Class_ID(SCALELIST_CONTROL_CLASS_ID,0));
	createdList = TRUE;
	}
else if ((res.anim->SuperClassID() == CTRL_SCALE_CLASS_ID) && (res.client->ClassID() == Class_ID(SCALELIST_CONTROL_CLASS_ID,0)))
	{
	list =  (Control *)res.client;
	}
return list;
}

Control* MasterBlockControl::BuildSlave(TrackViewPick res,Control* list, BOOL createdList)
{
int count = list->NumSubs()-1;
Control *slave = NULL;
for (int i = 0; i < count; i++)
	{
	if (res.anim->SuperClassID() == CTRL_FLOAT_CLASS_ID) 
		{
		slave = (Control*)list->SubAnim(i);
		if (slave->ClassID() == SLAVEFLOAT_CONTROL_CLASS_ID)
			{
//			list->AssignController(res.anim,count);
			return slave;
			}
		}
	else if (res.anim->SuperClassID() == CTRL_POSITION_CLASS_ID) 
		{
		slave = (Control*)list->SubAnim(i);
		if (slave->ClassID() == SLAVEPOS_CONTROL_CLASS_ID)
			{
//			list->AssignController(res.anim,count);
			return slave;
			}
		}
	else if (res.anim->SuperClassID() == CTRL_POINT3_CLASS_ID) 
		{
		slave = (Control*)list->SubAnim(i);
		if (slave->ClassID() == SLAVEPOINT3_CONTROL_CLASS_ID)
			{
//			list->AssignController(res.anim,count);
			return slave;
			}
		}
	else if (res.anim->SuperClassID() == CTRL_ROTATION_CLASS_ID) 
		{
		slave = (Control*)list->SubAnim(i);
		if (slave->ClassID() == SLAVEROTATION_CONTROL_CLASS_ID)
			{
//			list->AssignController(res.anim,count);
			return slave;
			}
		}
	else if (res.anim->SuperClassID() == CTRL_SCALE_CLASS_ID) 
		{
		slave = (Control*)list->SubAnim(i);
		if (slave->ClassID() == SLAVESCALE_CONTROL_CLASS_ID)
			{
//			list->AssignController(res.anim,count);
			return slave;
			}
		}
	}
BOOL isRotation = FALSE;
BOOL isFloat = FALSE;
if (res.anim->SuperClassID() == CTRL_FLOAT_CLASS_ID) 
	{
	slave = (Control*)new SlaveFloatControl;
	isFloat = TRUE;
	}
else if (res.anim->SuperClassID() == CTRL_POSITION_CLASS_ID) 
	slave = (Control*)new SlavePosControl;
else if (res.anim->SuperClassID() == CTRL_POINT3_CLASS_ID) 
	slave = (Control*)new SlavePoint3Control;
else if (res.anim->SuperClassID() == CTRL_ROTATION_CLASS_ID) 
	{
	slave = (Control*)new SlaveRotationControl;
	isRotation = TRUE;
	}
else if (res.anim->SuperClassID() == CTRL_SCALE_CLASS_ID) 
	slave = (Control*)new SlaveScaleControl;
if (createdList)
	{
//	if (isFloat)
	if (0)
		{
		list->AssignController(slave,count);
		list->AssignController(res.anim->Clone(),count+1);
		}	
	else
		{
		if (GetCOREInterface()->GetCommandPanelTaskMode() == TASK_MODE_MOTION)
			res.anim->EndEditParams(iop,END_EDIT_REMOVEUI,NULL);

		list->AssignController(res.anim->Clone(),count);
		list->AssignController(slave,count+1);
		}	
	}
else
	{
	list->AssignController(slave,count);
	}
return slave;
}




//watje 4-24-99
int MasterBlockControl::AppendBlockNoSlave(BlockControl *b,int i, TSTR *name, Control *bdata)
{

int where = -1;

b->ReplaceReference(i,(Control *) bdata->Clone());

int bc;
if (where == -1)
	bc = Blocks.Count()-1;
else bc = where;





b->tempControls[i] = (Control *) bdata->Clone();

b->backPointers[i] = NULL;


b->names.Append(1,&name,1);


//copy relvant keys
Interval iv(b->start,b->end);
TrackClipObject *cpy = b->controls[i]->CopyTrack(iv, TIME_INCLEFT|TIME_INCRIGHT);
b->controls[i]->DeleteKeys(TRACK_DOALL);
iv.Set(0,b->end-b->start);
b->controls[i]->PasteTrack(cpy, iv, TIME_INCLEFT|TIME_INCRIGHT);


if (b->SuperClassID() == CTRL_FLOAT_CLASS_ID)
	{
	float f = 0.0f;
	b->tempControls[i]->DeleteKeys(TRACK_DOALL);
	b->tempControls[i]->SetValue(0,&f);
	}
else if (b->SuperClassID() == CTRL_POSITION_CLASS_ID)
	{
	Point3 f(0.0f,0.0f,0.0f);
	b->tempControls[i]->DeleteKeys(TRACK_DOALL);
	b->tempControls[i]->SetValue(0,&f);
	}
else if (b->SuperClassID() == CTRL_POINT3_CLASS_ID)
	{
	Point3 f(0.0f,0.0f,0.0f);
	b->tempControls[i]->DeleteKeys(TRACK_DOALL);
	b->tempControls[i]->SetValue(0,&f);
	}
else if (b->SuperClassID() == CTRL_ROTATION_CLASS_ID)
	{
	Quat f;
	f.Identity();
	b->tempControls[i]->DeleteKeys(TRACK_DOALL);
	b->tempControls[i]->SetValue(0,&f);

	}
else if (b->SuperClassID() == CTRL_SCALE_CLASS_ID)
	{
//	Matrix3 f(1);
//		f.Identity();
	b->tempControls[i]->DeleteKeys(TRACK_DOALL);

	Quat f;
	f.Identity();
	Point3 p(1.0f,1.0f,1.0f);
	ScaleValue s(p,f); 
	b->tempControls[i]->SetValue(0,&s);

	}




return 1;
}

void NukeEaseAndMult(Control *c)
{
	int ct = c->NumEaseCurves();
	for (int i=0; i<ct;i++)		
		 c->DeleteEaseCurve(0);
	ct = c->NumMultCurves();
	for (i=0; i<ct;i++)		
		 c->DeleteMultCurve(0);
}


MasterBlockControl::AppendBlock(BlockControl *b,int i, TrackViewPick res, int where)
{
Control *list;
BOOL createdList = FALSE;
//check for list control if not add
list = BuildListControl(res,createdList);
//check if list has a slave control
Control *slaveControl;
slaveControl = BuildSlave(res,list,createdList);

int bc;
if (where == -1)
	bc = Blocks.Count()-1;
else bc = where;

b->ReplaceReference(i,res.anim->Clone());



b->tempControls[i] = (Control *) res.anim->Clone();
b->backPointers[i] = (SlaveControl *) slaveControl;



AddBlockName(res.anim,res.client,res.subNum,b->names);
//add slaves controls to the selected tracks and put the original as a sub anim of the slaves
//set slave	to have reference to master
slaveControl->ReplaceReference(1,this);
//copy selected track into slave sub
slaveControl->ReplaceReference(0,(Control*)res.anim->Clone());

//copy relvant keys
Interval iv(b->start,b->end);
TrackClipObject *cpy = b->controls[i]->CopyTrack(iv, TIME_INCLEFT|TIME_INCRIGHT);
//nuke all keys 
b->controls[i]->DeleteKeys(TRACK_DOALL);
//paste back relevant keys
iv.Set(0,b->end-b->start);
b->controls[i]->PasteTrack(cpy, iv, TIME_INCLEFT|TIME_INCRIGHT);


if (res.anim->SuperClassID() == CTRL_FLOAT_CLASS_ID)
	{
	float f = 0.0f;
	b->tempControls[i]->DeleteKeys(TRACK_DOALL);
	b->tempControls[i]->SetValue(0,&f);
	SlaveFloatControl *slave = (SlaveFloatControl *) slaveControl;

	slave->scratchControl = (Control *) res.anim->Clone();
	NukeEaseAndMult((Control *) slave->scratchControl);
	slave->scratchControl->DeleteKeys(TRACK_DOALL) ;
	slave->scratchControl->SetValue(0,&f);
//now replace track with slave
//	int bc = Blocks.Count()-1;
	slave->blockID.Append(1,&bc,1);
	slave->subID.Append(1,&i,1);
	}
else if (res.anim->SuperClassID() == CTRL_POSITION_CLASS_ID)
	{
	Point3 f(0.0f,0.0f,0.0f);
	b->tempControls[i]->DeleteKeys(TRACK_DOALL);
	b->tempControls[i]->SetValue(0,&f);
	SlavePosControl *slave = (SlavePosControl *) slaveControl;

	slave->scratchControl = (Control *) res.anim->Clone();
	NukeEaseAndMult((Control *) slave->scratchControl);
	slave->scratchControl->DeleteKeys(TRACK_DOALL) ;
	slave->scratchControl->SetValue(0,&f);

//now replace track with slave
//	int bc = Blocks.Count()-1;
	slave->blockID.Append(1,&bc,1);
	slave->subID.Append(1,&i,1);
	}
else if (res.anim->SuperClassID() == CTRL_POINT3_CLASS_ID)
	{
	Point3 f(0.0f,0.0f,0.0f);
	b->tempControls[i]->DeleteKeys(TRACK_DOALL);
	b->tempControls[i]->SetValue(0,&f);
	SlavePoint3Control *slave = (SlavePoint3Control *) slaveControl;

	slave->scratchControl = (Control *) res.anim->Clone();
	NukeEaseAndMult((Control *) slave->scratchControl);
	slave->scratchControl->DeleteKeys(TRACK_DOALL) ;
	slave->scratchControl->SetValue(0,&f);
//now replace track with slave
//	int bc = Blocks.Count()-1;
	slave->blockID.Append(1,&bc,1);
	slave->subID.Append(1,&i,1);
	}
else if (res.anim->SuperClassID() == CTRL_ROTATION_CLASS_ID)
	{
	Quat f;
	f.Identity();
	b->tempControls[i]->DeleteKeys(TRACK_DOALL);
	b->tempControls[i]->SetValue(0,&f);
	SlaveRotationControl *slave = (SlaveRotationControl *) slaveControl;

	slave->scratchControl = (Control *) res.anim->Clone();
	NukeEaseAndMult((Control *) slave->scratchControl);
	slave->scratchControl->DeleteKeys(TRACK_DOALL) ;
	slave->scratchControl->SetValue(0,&f);
//now replace track with slave
	slave->blockID.Append(1,&bc,1);
	slave->subID.Append(1,&i,1);

	}
else if (res.anim->SuperClassID() == CTRL_SCALE_CLASS_ID)
	{
//	Matrix3 f(1);
//		f.Identity();
	b->tempControls[i]->DeleteKeys(TRACK_DOALL);

	Quat f;
	f.Identity();
	Point3 p(1.0f,1.0f,1.0f);
	ScaleValue s(p,f); 
	b->tempControls[i]->SetValue(0,&s);

	SlaveScaleControl *slave = (SlaveScaleControl *) slaveControl;

	slave->scratchControl = (Control *) res.anim->Clone();
	NukeEaseAndMult((Control *) slave->scratchControl);
	slave->scratchControl->DeleteKeys(TRACK_DOALL) ;
	slave->scratchControl->SetValue(0,&f);
//now replace track with slave
//	int bc = Blocks.Count()-1;
	slave->blockID.Append(1,&bc,1);
	slave->subID.Append(1,&i,1);
	}
if (createdList)
	res.client->AssignController(list,res.subNum);
//res.client->AssignController(slave,res.subNum);

return 1;
}


MasterBlockControl::AppendBlock(BlockControl *b,int i, TrackViewPick res, Control *bdata,int where)
{
Control *list;
BOOL createdList = FALSE;
//check for list control if not add
list = BuildListControl(res,createdList);
//check if list has a slave control
Control *slaveControl;
slaveControl = BuildSlave(res,list,createdList);

//b->ReplaceReference(i,res.anim->Clone());
//b->tempControls[i] = (Control *) res.anim->Clone();
b->ReplaceReference(i,(Control *) bdata->Clone());

int bc;
if (where == -1)
	bc = Blocks.Count()-1;
else bc = where;





b->tempControls[i] = (Control *) bdata->Clone();

b->backPointers[i] = (SlaveControl *) slaveControl;



AddBlockName(res.anim,res.client,res.subNum,b->names);
//add slaves controls to the selected tracks and put the original as a sub anim of the slaves
//set slave	to have reference to master
slaveControl->ReplaceReference(1,this);
//copy selected track into slave sub
slaveControl->ReplaceReference(0,(Control*)res.anim->Clone());


//copy relvant keys
Interval iv(b->start,b->end);
TrackClipObject *cpy = b->controls[i]->CopyTrack(iv, TIME_INCLEFT|TIME_INCRIGHT);
b->controls[i]->DeleteKeys(TRACK_DOALL);
iv.Set(0,b->end-b->start);
b->controls[i]->PasteTrack(cpy, iv, TIME_INCLEFT|TIME_INCRIGHT);


if (res.anim->SuperClassID() == CTRL_FLOAT_CLASS_ID)
	{
	float f = 0.0f;
	b->tempControls[i]->DeleteKeys(TRACK_DOALL);
	b->tempControls[i]->SetValue(0,&f);
	SlaveFloatControl *slave = (SlaveFloatControl *) slaveControl;

	slave->scratchControl = (Control *) res.anim->Clone();
	NukeEaseAndMult((Control *) slave->scratchControl);
	slave->scratchControl->DeleteKeys(TRACK_DOALL) ;
	slave->scratchControl->SetValue(0,&f);
//now replace track with slave
//	int bc = Blocks.Count()-1;
	slave->blockID.Append(1,&bc,1);
	slave->subID.Append(1,&i,1);
	}
else if (res.anim->SuperClassID() == CTRL_POSITION_CLASS_ID)
	{
	Point3 f(0.0f,0.0f,0.0f);
	b->tempControls[i]->DeleteKeys(TRACK_DOALL);
	b->tempControls[i]->SetValue(0,&f);
	SlavePosControl *slave = (SlavePosControl *) slaveControl;

	slave->scratchControl = (Control *) res.anim->Clone();
	NukeEaseAndMult((Control *) slave->scratchControl);
	slave->scratchControl->DeleteKeys(TRACK_DOALL) ;
	slave->scratchControl->SetValue(0,&f);
//now replace track with slave
//	int bc = Blocks.Count()-1;
	slave->blockID.Append(1,&bc,1);
	slave->subID.Append(1,&i,1);
	}
else if (res.anim->SuperClassID() == CTRL_POINT3_CLASS_ID)
	{
	Point3 f(0.0f,0.0f,0.0f);
	b->tempControls[i]->DeleteKeys(TRACK_DOALL);
	b->tempControls[i]->SetValue(0,&f);
	SlavePoint3Control *slave = (SlavePoint3Control *) slaveControl;

	slave->scratchControl = (Control *) res.anim->Clone();
	NukeEaseAndMult((Control *) slave->scratchControl);
	slave->scratchControl->DeleteKeys(TRACK_DOALL) ;
	slave->scratchControl->SetValue(0,&f);
//now replace track with slave
//	int bc = Blocks.Count()-1;
	slave->blockID.Append(1,&bc,1);
	slave->subID.Append(1,&i,1);
	}
else if (res.anim->SuperClassID() == CTRL_ROTATION_CLASS_ID)
	{
	Quat f;
	f.Identity();
	b->tempControls[i]->DeleteKeys(TRACK_DOALL);
	b->tempControls[i]->SetValue(0,&f);
	SlaveRotationControl *slave = (SlaveRotationControl *) slaveControl;

	slave->scratchControl = (Control *) res.anim->Clone();
	NukeEaseAndMult((Control *) slave->scratchControl);
	slave->scratchControl->DeleteKeys(TRACK_DOALL) ;
	slave->scratchControl->SetValue(0,&f);
//now replace track with slave
//	int bc = Blocks.Count()-1;
	slave->blockID.Append(1,&bc,1);
	slave->subID.Append(1,&i,1);

	}
else if (res.anim->SuperClassID() == CTRL_SCALE_CLASS_ID)
	{
//	Matrix3 f(1);
//		f.Identity();
	b->tempControls[i]->DeleteKeys(TRACK_DOALL);

	Quat f;
	f.Identity();
	Point3 p(1.0f,1.0f,1.0f);
	ScaleValue s(p,f); 

	b->tempControls[i]->SetValue(0,&s);

	SlaveScaleControl *slave = (SlaveScaleControl *) slaveControl;

	slave->scratchControl = (Control *) res.anim->Clone();
	NukeEaseAndMult((Control *) slave->scratchControl);
	slave->scratchControl->DeleteKeys(TRACK_DOALL) ;
	slave->scratchControl->SetValue(0,&f);
//now replace track with slave
//	int bc = Blocks.Count()-1;
	slave->blockID.Append(1,&bc,1);
	slave->subID.Append(1,&i,1);
	}

if (createdList)
	res.client->AssignController(list,res.subNum);
return 1;
}


MasterBlockControl::AddBlock(HWND hWnd)
{


Tab<TrackViewPick> res;
MasterBlockTrackViewFilter filter;


if (GetCOREInterface()->TrackViewPickMultiDlg(hWnd, &res,&filter,PICKMULTI_FLAG_ANIMATED | PICKMULTI_FLAG_VISTRACKS  ))
	{
//pop up time space and name dialog
//	DebugPrint("Got track conunt %d\n",res.Count());
//	TSTR nameClip;
	TSTR *ptr = new TSTR(GetString(IDS_PW_BLOCK));
	names.Append(1,&ptr,1);

//add new block name
	propNamePos = names.Count()-1;
	if (DialogBoxParam  (hInstance, MAKEINTRESOURCE(IDD_BLOCKPROP),
			hWnd, MasterBlockPropDlgProc, (LPARAM)this))
		{

		BlockControl *b = new BlockControl;
		Blocks.Append(1,&b,1);
		propStart *= GetTicksPerFrame();
		propEnd *= GetTicksPerFrame();
		b->start = propStart;
		b->end = propEnd;
		b->color = propColor;
		b->l = b->end-b->start+1;

//copy sub controls into blocks
		b->controls.SetCount(res.Count());
		b->tempControls.SetCount(res.Count());
		b->backPointers.SetCount(res.Count());
//	b->controls.SetCount(1);
//	b->tempControls.SetCount(1);
		for (int i = 0; i < res.Count(); i++)
			{
			b->backPointers[i] = NULL;
			b->tempControls[i] = NULL;
			}
		b->suspendNotifies = TRUE;
		for (i = 0; i < res.Count(); i++)
//	for (int i = 0; i < 1; i++)
			{
			b->controls[i] = NULL;
//need to make copy
//need to check is controller really attched or is there no keys and just constant
			if (res[i].anim != NULL)
				{
//check if this controler already has a slave attached don't create another one just update its blockid and subid table
//need check what type of control it is 
				AppendBlock(b,i,res[i]);
				}
			}
		b->suspendNotifies = FALSE;
		b->end = b->end-b->start;
		b->l = b->end-b->start+1;
		b->start = 0;

		ReplaceReference(Blocks.Count()-1+1,b);
		b->NotifySlaves();

		NotifyDependents(FOREVER,0,REFMSG_CHANGE);
		NotifyDependents(FOREVER,0,REFMSG_SUBANIM_STRUCTURE_CHANGED);
		}
	else
		{
		names.Delete(names.Count()-1,1);
		}

	
	}
return 0;

}


MasterBlockControl::AddSelected(HWND hWnd)
{

Tab<TrackViewPick> res;
//MasterBlockTrackViewFilter filter;

res.ZeroCount();
#define ID_TV_GETSELECTED	680

SendMessage(trackHWND,WM_COMMAND,ID_TV_GETSELECTED,(LPARAM)&res);

//nuke invalid types
for (int rc = 0; rc < res.Count(); rc++)
	{
	if (!(res[rc].anim->CanCopyTrack(FOREVER,0)  && res[rc].anim->IsAnimated() && res[rc].anim->CanCopyAnim()))
		{
		res.Delete(rc,1);
		rc--;
		}
	}
//if (GetCOREInterface()->TrackViewPickMultiDlg(hWnd, &res,&filter,3 ))
if (res.Count()>0)
	{
//pop up time space and name dialog
//	DebugPrint("Got track conunt %d\n",res.Count());
//	TSTR nameClip;
	TSTR *ptr = new TSTR(GetString(IDS_PW_BLOCK));
	names.Append(1,&ptr,1);

//add new block name
	propNamePos = names.Count()-1;
	if (DialogBoxParam  (hInstance, MAKEINTRESOURCE(IDD_BLOCKPROP),
			hWnd, MasterBlockPropDlgProc, (LPARAM)this))
		{

		BlockControl *b = new BlockControl;
		Blocks.Append(1,&b,1);
		propStart *= GetTicksPerFrame();
		propEnd *= GetTicksPerFrame();
		b->start = propStart;
		b->end = propEnd;
		b->color = propColor;
		b->l = b->end-b->start+1;

//copy sub controls into blocks
		b->controls.SetCount(res.Count());
		b->tempControls.SetCount(res.Count());
		b->backPointers.SetCount(res.Count());
//	b->controls.SetCount(1);
//	b->tempControls.SetCount(1);
//DebugPrint("Resized control to  %d \n",b->controls.Count());
		for (int i = 0; i < res.Count(); i++)
			{
			b->backPointers[i] = NULL;
			b->tempControls[i] = NULL;
			}

		b->suspendNotifies = TRUE;
		for (i = 0; i < res.Count(); i++)
//	for (int i = 0; i < 1; i++)
			{
//DebugPrint("Addingf ref %d controls\n",i);
			b->controls[i] = NULL;

//need to make copy
//need to check is controller really attched or is there no keys and just constant
			if (res[i].anim != NULL)
				{
//check if this controler already has a slave attached don't create another one just update its blockid and subid table
//need check what type of control it is 
				AppendBlock(b,i,res[i]);
				}
			}
		b->suspendNotifies = FALSE;
		b->end = b->end-b->start;
		b->l = b->end-b->start+1;
		b->start = 0;

		ReplaceReference(Blocks.Count()-1+1,b);
		b->NotifySlaves();

		NotifyDependents(FOREVER,0,REFMSG_CHANGE);
		NotifyDependents(FOREVER,0,REFMSG_SUBANIM_STRUCTURE_CHANGED);
		}
	else
		{
		names.Delete(names.Count()-1,1);
		}

	
	}
return 0;

}


MasterBlockControl::ReplaceBlock(HWND hWnd, int whichBlock)
{


Tab<TrackViewPick> res;
MasterBlockTrackViewFilter filter;

if (GetCOREInterface()->TrackViewPickMultiDlg(hWnd, &res,&filter,PICKMULTI_FLAG_ANIMATED | PICKMULTI_FLAG_VISTRACKS  ))
	{
//pop up time space and name dialog
//	DebugPrint("Got track conunt %d\n",res.Count());

//add new block name
	propNamePos = whichBlock;

	if (DialogBoxParam  (hInstance, MAKEINTRESOURCE(IDD_BLOCKPROP),
			hWnd, MasterBlockPropDlgProc, (LPARAM)this))
		{


//loop through back pointers removing all references to this current block
		for (int i = 0;i <Blocks[whichBlock]->backPointers.Count();i++)
			{
//lock at the bockid table
//	int subCount = Blocks[whichBlock]->backPointers[i]->blockID.Count();
			for (int j=0; j< Blocks[whichBlock]->backPointers[i]->blockID.Count(); j++)
				{
				if (Blocks[whichBlock]->backPointers[i]->blockID[j] == whichBlock)
					{
					Blocks[whichBlock]->backPointers[i]->blockID.Delete(j,1);
					Blocks[whichBlock]->backPointers[i]->subID.Delete(j,1);
					j--;
					}
				}
			Blocks[whichBlock]->backPointers[i]->DeleteReference(1);

			}


		for (i = 0;i <Blocks[whichBlock]->externalBackPointers.Count();i++)
			{
//lock at the bockid table
//	int subCount = Blocks[whichBlock]->backPointers[i]->blockID.Count();
			for (int j=0; j< Blocks[whichBlock]->externalBackPointers[i]->blockID.Count(); j++)			{
				if (Blocks[whichBlock]->backPointers[i]->blockID[j] == whichBlock)
					{
					Blocks[whichBlock]->externalBackPointers[i]->blockID.Delete(j,1);
					Blocks[whichBlock]->externalBackPointers[i]->subID.Delete(j,1);
					j--;
					}
				}
			Blocks[whichBlock]->externalBackPointers[i]->DeleteReference(1);

			}


		BlockControl *b = new BlockControl;
//	DeleteReference(whichBlock+1);
		



		propStart *= GetTicksPerFrame();
		propEnd *= GetTicksPerFrame();
		b->start = propStart;
		b->end = propEnd;
		b->color = propColor;
		b->l = b->end-b->start+1;

//copy sub controls into blocks
		b->controls.SetCount(res.Count());
		b->tempControls.SetCount(res.Count());
		b->backPointers.SetCount(res.Count());
//	b->controls.SetCount(1);
//	b->tempControls.SetCount(1);
//DebugPrint("Resized control to  %d \n",b->controls.Count());

		for (i = 0; i < res.Count(); i++)
			{
			b->backPointers[i] = NULL;
			b->tempControls[i] = NULL;
			}
		b->suspendNotifies = TRUE;
		for (i = 0; i < res.Count(); i++)
//	for (int i = 0; i < 1; i++)
			{
//DebugPrint("Addingf ref %d controls\n",i);
			b->controls[i] = NULL;

//need to make copy
//need to check is controller really attched or is there no keys and just constant
			if (res[i].anim != NULL)
				{
//check if this controler already has a slave attached don't create another one just update its blockid and subid table
//need check what type of control it is 
				AppendBlock(b,i,res[i],whichBlock);
				}
			}
		b->end = b->end-b->start;
		b->l = b->end-b->start+1;
		b->start = 0;

		b->suspendNotifies = FALSE;

		ReplaceReference(whichBlock+1,b);
		b->NotifySlaves();

		NotifyDependents(FOREVER,0,REFMSG_CHANGE);
		NotifyDependents(FOREVER,0,REFMSG_SUBANIM_STRUCTURE_CHANGED);

		}
	}
return 0;

}

MasterBlockControl::AttachAddToList(int where,  TrackViewPick res)
{

if (res.anim)
	{
	if (where < (propTargetList.Count()-1))
		{
		propTargetList[where] = res;
		propNames[where] = GetBlockName(res.anim,res.client, res.subNum);
		}
	else
		{
		int st = propTargetList.Count()-1;
		for (int i = st; i <= where; i++)
			{
			TrackViewPick c;
			c.anim = NULL;
			propTargetList.Append(1,&c,1);
			TSTR *nullName = new TSTR("NULL");
			propNames.Append(1,&nullName,1);
			}
		propTargetList[where] = res;
		int k = res.subNum;
//		DebugPrint("SubName %d %s\n",k,res.client->SubAnimName(k));
		TSTR str;
		TSTR str2;
		res.client->GetClassName(str);
		res.anim->GetClassName(str2);
//		DebugPrint("animClass %s %s\n",str);
		Animatable *r = res.client->SubAnim(k);


		propNames[where] = GetBlockName(res.anim,res.client, res.subNum);
		}

//	AddBlockName(res[i].anim,res[i].client,res[i].subNum,propNames);
//	SendMessage(hListWnd,
//			LB_ADDSTRING,0,(LPARAM)(TCHAR*)*propNames[propNames.Count()-1]);
	}

}

int IsSubString(TSTR sub, TSTR main)
{
int l = sub.Length();
int l2 = main.Length();
for (int i = 0; i < (l2-1+1); i++)
	{
	TSTR match = main.Substr(i,l);
	if (match == sub)
		return 1;
	}
return 0;

}
MasterBlockControl::RecurseSubs(TSTR matchString, Class_ID pid, Animatable* anim, TrackViewPick& r)
{
if (anim)
	{
	for (int j = 0; j < anim->NumSubs();j++)
		{
//wwatje 4-30-99
		Animatable *sub = anim->SubAnim(j);
		if (sub)
			{
			TSTR subAnim(anim->SubAnimName(j));
//			if ((matchString == subAnim) && (pid == sub->ClassID()))
			if ( IsSubString(matchString, subAnim) && (pid == sub->ClassID()))
				{
				r.client = (ReferenceTarget *)anim;
				if (r.client && r.client->SuperClassID()==PARAMETER_BLOCK_CLASS_ID) 
					{
					IParamBlock *iparam = (IParamBlock*)r.client;
					r.anim = (ReferenceTarget *) iparam->GetController(iparam->AnimNumToParamNum(j));
					r.subNum = j;//;
					if (!r.anim)
						{
						r.anim = (ReferenceTarget*)GetDefaultController(iparam->GetAnimParamControlType(j))->Create();
						iparam->SetController(iparam->AnimNumToParamNum(j), (Control *) r.anim, TRUE);					
	
						}
					return 1;
					}
				else
					{
					r.anim = (ReferenceTarget *) anim->SubAnim(j);
					r.subNum = j;
					return 1;
					}
				}
			}
		

		}
	
	for ( j = 0; j < anim->NumSubs();j++)
		{
		if (RecurseSubs(matchString, pid, anim->SubAnim(j), r)) return 1;
		}
	}
return 0;


}

MasterBlockControl::MatchNode(Tab<BOOL> selSet, HWND hParent)
{
//popup node selection box
Interface *ip = GetCOREInterface();
MasterMatchNodeViewFilter filter;
TrackViewPick res;
if (ip->TrackViewPickDlg(hParent, &res, NULL))
	{
//	TSTR nodeName = res.client->SubAnimName(res.subNum);	
//	int l = nodeName.Length();
//loop through sel set removing any that don't match the first
	for (int i=0; i < selSet.Count(); i++)
		{
		if (selSet[i])
			{
			//find 
			
			char *name;
			propContainer->pblock2->GetValue(container_names,0,name,FOREVER,i);
			TSTR pName(name);
			int ct = pName.first('/');
			TSTR propSubAnim;
			int l = pName.Length();
			if (ct == -1)
				propSubAnim = pName.Substr(0,l);
			else 
				{
				ct++;
				propSubAnim = pName.Substr(ct,l-ct);
				}
			TrackViewPick r;
			r.anim = NULL;
			r.client = NULL;

			ReferenceTarget *c;
			propContainer->pblock2->GetValue(container_refs,0,c,FOREVER,i);
			Class_ID propID = c->ClassID();

//			for (int j = 0; j < res.anim->NumSubs();j++)
//				{
				if (RecurseSubs(propSubAnim, propID, res.anim,r))
					{
					if (r.anim)
						AttachAddToList(i,  r);
//					j = res.anim->NumSubs();
					}
/*
				TSTR subAnim = res.anim->SubAnimName(j);
				if (propSubAnim == subAnim)
					{
					TrackViewPick r;
					r.client = res.anim;
					r.anim = (ReferenceTarget *) res.anim->SubAnim(j);
					r.subNum = j;
					AttachAddToList(i, r);
					j = res.anim->NumSubs();
					}
*/
//				}
			}
		}
	int ct = 0;
	ct = propContainer->pblock2->Count(container_refs);
	for (i=ct; i < propTargetList.Count(); i++)
		{
		if (propTargetList[i].anim == NULL)
			{
			propTargetList.Delete(i,1);
			propNames.Delete(i,1);
			i--;
			}
		}
	}

}
MasterBlockControl::AttachAddMoveUp(int i)
{
if (i <= 0) return 0;
TSTR *Name;
TrackViewPick ref;
Name = propNames[i-1];
ref = propTargetList[i-1];
propNames[i-1] = propNames[i];
propTargetList[i-1] = propTargetList[i];
propNames[i] = Name;
propTargetList[i] = ref;
return 1;

}

MasterBlockControl::AttachAddMoveDown(int i)
{
if (i >= (propTargetList.Count()-1)) return 0;
TSTR *Name;
TrackViewPick ref;
Name = propNames[i+1];
ref = propTargetList[i+1];
propNames[i+1] = propNames[i];
propTargetList[i+1] = propTargetList[i];
propNames[i] = Name;
propTargetList[i] = ref;
return 1;

}

MasterBlockControl::AttachAdd(HWND hListWnd)

{
Tab<TrackViewPick> res;
HWND hWnd = GetCOREInterface()->GetMAXHWnd();
MasterBlockTrackViewFilterAdd filter;

if (GetCOREInterface()->TrackViewPickMultiDlg(hWnd, &res,&filter, PICKMULTI_FLAG_VISTRACKS  ))
	{
	for (int i = 0; i < res.Count();i++)
		{
		BOOL found = FALSE;
		for (int j = 0; j < propTargetList.Count();j++)
			{
			if (res[i].anim == propTargetList[j].anim)
				{
				found = TRUE;
				j = propTargetList.Count();
				}
			}
//add to list make sure they are not dulicates
		if (!found)
			{
//add names list
//			Control *c = (Control*)res[i].anim; 
			propTargetList.Append(1,&res[i],1);
			AddBlockName(res[i].anim,res[i].client,res[i].subNum,propNames);
			SendMessage(hListWnd,
				LB_ADDSTRING,0,(LPARAM)(TCHAR*)*propNames[propNames.Count()-1]);
			
			}
		}
	}
return 1;
}


MasterBlockControl::AttachAddNullAt(HWND hListWnd, int where)

{
//add names list
//Control *c = NULL; 
TrackViewPick c;
c.anim = NULL;
propTargetList.Insert(where,1,&c);
TSTR *nullName = new TSTR("NULL");
propNames.Insert(where,1,&nullName);
SendMessage(hListWnd,
			LB_ADDSTRING,0,(LPARAM)(TCHAR*)*propNames[where]);
			
return 1;
}


MasterBlockControl::BuildNewBlock()

{
//add names list
//TrackViewPick res;
BlockControl *b = new BlockControl;
Blocks.Append(1,&b,1);

TSTR *ptr = new TSTR(propBlockName);
names.Append(1,&ptr,1);

//add new block name
b->start = propStart;
b->end = propEnd;
b->color = propColor;
b->l = b->end-b->start+1;
b->suspendNotifies = TRUE;

//copy sub controls into blocks
int selCount = 0;
for (int i = 0; i < propTargetList.Count(); i++)
	{
//	if (propTargetList[i].anim != NULL)
		selCount++;
	}

int ccount = propContainer->pblock2->Count(container_refs);
//if (selCount> ccount) selCount = ccount;
selCount = ccount;
b->controls.SetCount(selCount);
b->tempControls.SetCount(selCount);
b->backPointers.SetCount(selCount);
int ct = 0;
//for (i = 0; i < propTargetList.Count(); i++)
for (i = 0; i < ccount; i++)
	{
	ReferenceTarget *c;
	propContainer->pblock2->GetValue(container_refs,0,c,FOREVER,i);
//need to make copy
//need to check is controller really attched or is there no keys and just constant
	if ((i<propTargetList.Count()) && (propTargetList[i].anim != NULL)&&
		(propTargetList[i].anim->SuperClassID() == c->SuperClassID())
		)		{
		b->controls[ct] = NULL;
//check if this controler already has a slave attached don't create another one just update its blockid and subid table
//need check what type of control it is 
		AppendBlock(b,ct,propTargetList[i],(Control *)c);
		ct++;
		}
	else 
		{
		b->controls[ct] = NULL;
//check if this controler already has a slave attached don't create another one just update its blockid and subid table
//need check what type of control it is 
		ReferenceTarget *c;
		propContainer->pblock2->GetValue(container_refs,0,c,FOREVER,i);
		char *name;
		propContainer->pblock2->GetValue(container_names,0,name,FOREVER,i);
		TSTR *pName = new TSTR(name);
		AppendBlockNoSlave(b,ct,pName,(Control *)c);
		ct++;
		}

	}
b->end = b->end-b->start;
b->l = b->end-b->start+1;
b->start = 0;

ReplaceReference(Blocks.Count()-1+1,b);
b->suspendNotifies = FALSE;
b->NotifySlaves();
propTargetList.ZeroCount();
NotifyDependents(FOREVER,0,REFMSG_SUBANIM_STRUCTURE_CHANGED);

return 1;
}

MasterBlockControl::AttachDeleteAt(HWND hListWnd, int where)

{
//add names list
propTargetList.Delete(where,1);
propNames.Delete(where,1);
SendMessage(hListWnd,
			LB_DELETESTRING,(WPARAM) where,0);
if (propTargetList.Count() !=0)
	{
	if (where >= propTargetList.Count())
		where = propTargetList.Count()-1;
	SendMessage(hListWnd,
			LB_SETCURSEL,where,0);

	}
			
return 1;
}



RefTargetHandle MasterBlockControl::Clone(RemapDir& remap)
	{
	// make a new noise controller and give it our param values.
//	MasterBlockControl *cont = new MasterBlockControl;
//	*cont = *this;
	// Clone the strength controller
//	cont->ReplaceReference(Control::NumRefs(),remap.CloneRef(cont->cont));
//	CloneControl(cont,remap);
	return NULL;
	}


void MasterBlockControl::GetValue(
		TimeValue t, void *val, Interval &valid, GetSetMethod method)
	{
//DebugPrint("Error occured this getValue should never be called on a block control\n");
	}

void MasterBlockControl::GetValue2(
		TimeValue t, void *val, Interval &valid, int whichBlock, int whichSub, GetSetMethod method)
	{

	if (Blocks[whichBlock]->tempControls[whichSub] == NULL)
		{
		UpdateControl(whichBlock);
		}	
	else Blocks[whichBlock]->tempControls[whichSub]->GetValue(t,val,valid, method);
	}


void MasterBlockControl::GetValue3(Control *sub,
		TimeValue t, void *val, Interval &valid, Tab<int> whichBlock, Tab<int> whichSub, Interval localIV, GetSetMethod method)
	{

/*		if ((whichBlock.Count() == 0) || (whichSub.Count() == 0)) return;
	
		for (int j = 0; j < whichBlock.Count(); j++)
			{
			for (int i = 0; i < BlockKeys.Count();i++)
				{
				if (BlockKeys[i].block_id == whichBlock[j])
					Blocks[whichBlock[j]]->AddKeyToSub(sub, whichSub[j], BlockKeys[i].start,  BlockKeys[i].end-BlockKeys[i].start,BlockKeys[i].relative);
				}
			}

//add multiplier curve
		if (sub->CanApplyEaseMultCurves())
			{
			for (int ct = 0; ct < sub->NumMultCurves(); ct++)
				sub->DeleteMultCurve(ct);
			if (sub->NumMultCurves() == 0)
				sub->AppendMultCurve(blendControl);
			}
*/
		if (sub) sub->GetValue(t,val,valid, method);
	}


void MasterBlockControl::Update(Control *sub,
		Tab<int> whichBlock, Tab<int> whichSub)
	{

		if ((whichBlock.Count() == 0) || (whichSub.Count() == 0)) return;
	
		for (int j = 0; j < whichBlock.Count(); j++)
			{
			for (int i = 0; i < BlockKeys.Count();i++)
				{
				if (BlockKeys[i].block_id == whichBlock[j])
					{
					Blocks[whichBlock[j]]->AddKeyToSub(sub, whichSub[j], BlockKeys[i].start,  BlockKeys[i].end-BlockKeys[i].start,range,BlockKeys[i].relative);
					}
//					Blocks[whichBlock[j]]->AddKeyToSub(sub, whichSub[j], BlockKeys[i].start,  BlockKeys[i].end-BlockKeys[i].start,BlockKeys[i].relative);
				}
			}

//add multiplier curve
		if (sub->CanApplyEaseMultCurves())
			{
//			for (int ct = 0; ct < sub->NumMultCurves(); ct++)
//				sub->DeleteMultCurve(ct);
			if (sub->NumMultCurves() == 0)
				sub->AppendMultCurve(blendControl);
			}



//		sub->GetValue(t,val,valid, method);
	}

void MasterBlockControl::SetValue(
		TimeValue t, void *val, int commit, GetSetMethod method)
	{

//this should never get called
//DebugPrint("Error occured SetValue should never be called on a block control\n");
/*
	if (method==CTRL_ABSOLUTE) {
		float v = *((float*)val);
		float before = 0.0f, after = 0.0f;
		Interval valid;
		sub->GetValue(t,&before,valid,CTRL_RELATIVE);
		sub->GetValue(t,&after,valid,CTRL_RELATIVE);
		v = -before + v + -after;
		sub->SetValue(t,&v,commit,method);
	} else {
		sub->SetValue(t,val,commit,method);
		}
*/
	}

/*
void MasterBlockControl::GetValueLocalTime(
		TimeValue t, void *val, Interval &valid, GetSetMethod method)
	{
	float strength;
	GetStrength(t,&strength);

	// This controller is always changing.
	valid.SetInstant(t);
	
//	*((float*)val) = NoiseAtTime(t,seed,0) * strength;
	}

void MasterBlockControl::Extrapolate(
		Interval range,TimeValue t,void *val,Interval &valid,int type)
	{
	float val0, val1, val2, res;
	switch (type) {
		case ORT_LINEAR:			
			if (t<range.Start()) {
				GetValueLocalTime(range.Start(),&val0,valid);
				GetValueLocalTime(range.Start()+1,&val1,valid);
				res = LinearExtrapolate(range.Start(),t,val0,val1,val0);				
			} else {
				GetValueLocalTime(range.End()-1,&val0,valid);
				GetValueLocalTime(range.End(),&val1,valid);
				res = LinearExtrapolate(range.End(),t,val0,val1,val1);
				}
			break;

		case ORT_IDENTITY:
			if (t<range.Start()) {
				GetValueLocalTime(range.Start(),&val0,valid);
				res = IdentityExtrapolate(range.Start(),t,val0);
			} else {
				GetValueLocalTime(range.End(),&val0,valid);
				res = IdentityExtrapolate(range.End(),t,val0);
				}
			break;

		case ORT_RELATIVE_REPEAT:
			GetValueLocalTime(range.Start(),&val0,valid);
			GetValueLocalTime(range.End(),&val1,valid);
			GetValueLocalTime(CycleTime(range,t),&val2,valid);
			res = RepeatExtrapolate(range,t,val0,val1,val2);			
			break;
		}
	valid.Set(t,t);
	*((float*)val) = res;
	}
*/


BOOL CALLBACK AddBlockDlgProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
	MasterBlockControl *mb = (MasterBlockControl*)GetWindowLong(hWnd,GWL_USERDATA);

	switch (msg) {
	case WM_INITDIALOG:
		{
		mb = (MasterBlockControl*)lParam;

		SetWindowLong(hWnd,GWL_USERDATA,lParam);

//load up list box 
		for (int i=0; i<mb->Blocks.Count(); i++) 
			{
			TSTR name = mb->SubAnimName(i+1);
			SendMessage(GetDlgItem(hWnd,IDC_LIST1),
				LB_ADDSTRING,0,(LPARAM)(TCHAR*)name);
			}


		break;
		}
	case WM_COMMAND:
		switch (LOWORD(wParam)) {
		case IDOK:
			{
			int sel = SendMessage(GetDlgItem(hWnd,IDC_LIST1),
				LB_GETCURSEL,0,0);
			mb->AddDialogSelect = sel;
			EndDialog(hWnd,1);
			break;
			}
		case IDCANCEL:
			mb->AddDialogSelect = -1;
			EndDialog(hWnd,0);
			break;
		}
		break;

	default:
		return FALSE;
	}
	return TRUE;
}




BOOL CALLBACK MasterBlockPropDlgProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
	MasterBlockControl *mb = (MasterBlockControl*)GetWindowLong(hWnd,GWL_USERDATA);

	ISpinnerControl *spin;
	static TSTR zero = FormatUniverseValue(0.0f);
	Rect rect;

	switch (msg) {
	case WM_INITDIALOG:
		{
		mb = (MasterBlockControl*)lParam;
		SetWindowLong(hWnd,GWL_USERDATA,lParam);
		Interval range = GetCOREInterface()->GetAnimRange();
		
		spin = GetISpinner(GetDlgItem(hWnd,IDC_STARTSPIN));
		spin->SetLimits(-999999.0f,9999999.0f, FALSE);
		spin->SetAutoScale();
		spin->LinkToEdit(GetDlgItem(hWnd,IDC_START), EDITTYPE_INT);
		spin->SetValue(range.Start()/GetTicksPerFrame(),FALSE);
		ReleaseISpinner(spin);

		spin = GetISpinner(GetDlgItem(hWnd,IDC_ENDSPIN));
		spin->SetLimits(-999999.0f,9999999.0f, FALSE);
		spin->SetAutoScale();
		spin->LinkToEdit(GetDlgItem(hWnd,IDC_END), EDITTYPE_INT);
		spin->SetValue(range.End()/GetTicksPerFrame(),FALSE);
		ReleaseISpinner(spin);

		mb->propStart =  range.Start()/GetTicksPerFrame();
		mb->propEnd = range.End()/GetTicksPerFrame();

	//copy name into field
		ICustEdit *iName = GetICustEdit(GetDlgItem(hWnd,IDC_LIST_NAME));
		iName->SetText(*mb->names[mb->names.Count()-1]);
//		iName->GetText(buf,256);
		ReleaseICustEdit(iName);

		IColorSwatch *cs = GetIColorSwatch(GetDlgItem(hWnd,IDC_COLOR),
				RGB(88,88,188), _T("Block Color"));
		cs->SetColor(RGB(88,88,188));
		mb->propColor = cs->GetColor();
		ReleaseIColorSwatch(cs);


		CenterWindow(hWnd,GetParent(hWnd));
		break;
		}
		
	case CC_SPINNER_CHANGE:
		spin = (ISpinnerControl*)lParam;
		switch (LOWORD(wParam)) {
		case IDC_STARTSPIN: mb->propStart = spin->GetIVal(); break;
		case IDC_ENDSPIN: mb->propEnd = spin->GetIVal(); break;
		}
		break;

	case CC_COLOR_BUTTONDOWN:
		theHold.Begin();
		break;
	case CC_COLOR_BUTTONUP:
		if (HIWORD(wParam)) theHold.Accept(GetString(IDS_DS_PARAMCHG));
		else theHold.Cancel();
		break;
	case CC_COLOR_CHANGE: {
		if (HIWORD(wParam)) theHold.Begin();
		int i = LOWORD(wParam);
		IColorSwatch *cs = (IColorSwatch*)lParam;
		mb->propColor = cs->GetColor();
		if (HIWORD(wParam)) {
			theHold.Accept(GetString(IDS_DS_PARAMCHG));
			}
		break;
		}


	case WM_COMMAND:
		switch (LOWORD(wParam)) {
		case IDOK:
			{
			TCHAR buf[256];
			ICustEdit *iName = GetICustEdit(GetDlgItem(hWnd,IDC_LIST_NAME));
			iName->GetText(buf,256);
//			*mb->names[mb->names.Count()-1] = buf;
			*mb->names[mb->propNamePos] = buf;
			ReleaseICustEdit(iName);
			EndDialog(hWnd,1);
			break;
			}
		case IDCANCEL:
			EndDialog(hWnd,0);
			break;
		}
		break;

	default:
		return FALSE;
	}
	return TRUE;
}


BOOL CALLBACK KeyPropDlgProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
	MasterBlockControl *mb = (MasterBlockControl*)GetWindowLong(hWnd,GWL_USERDATA);

	ISpinnerControl *spin;
	static TSTR zero = FormatUniverseValue(0.0f);
	Rect rect;

	switch (msg) {
	case WM_INITDIALOG:
		{
		mb = (MasterBlockControl*)lParam;
		SetWindowLong(hWnd,GWL_USERDATA,lParam);

		if (mb->propRelative)
			CheckDlgButton(  hWnd,IDC_RELATIVE,TRUE);
		else CheckDlgButton(  hWnd,IDC_RELATIVE,FALSE);
 




		Interval range = GetCOREInterface()->GetAnimRange();

		
		spin = GetISpinner(GetDlgItem(hWnd,IDC_STARTSPIN));
		spin->SetLimits(-999999.0f,9999999.0f, FALSE);
		spin->SetAutoScale();
		spin->LinkToEdit(GetDlgItem(hWnd,IDC_START), EDITTYPE_INT);
		spin->SetValue(mb->propStart/GetTicksPerFrame(),FALSE);
		ReleaseISpinner(spin);

		spin = GetISpinner(GetDlgItem(hWnd,IDC_ENDSPIN));
		spin->SetLimits(-999999.0f,9999999.0f, FALSE);
		spin->SetAutoScale();
		spin->LinkToEdit(GetDlgItem(hWnd,IDC_END), EDITTYPE_INT);
		spin->SetValue(mb->propEnd/GetTicksPerFrame(),FALSE);
		ReleaseISpinner(spin);

		mb->propStart =  mb->propStart/GetTicksPerFrame();
		mb->propEnd = mb->propEnd/GetTicksPerFrame();

/*
	//copy name into field
		ICustEdit *iName = GetICustEdit(GetDlgItem(hWnd,IDC_LIST_NAME));
		iName->SetText(*mb->names[mb->names.Count()-1]);
//		iName->GetText(buf,256);
		ReleaseICustEdit(iName);

		IColorSwatch *cs = GetIColorSwatch(GetDlgItem(hWnd,IDC_COLOR),
				RGB(128,128,128), _T("Block Color"));
		cs->SetColor(RGB(128,128,128));
		mb->propColor = cs->GetColor();
		ReleaseIColorSwatch(cs);
*/

		CenterWindow(hWnd,GetParent(hWnd));
		break;
		}
		
	case CC_SPINNER_CHANGE:
		spin = (ISpinnerControl*)lParam;
		switch (LOWORD(wParam)) {
		case IDC_STARTSPIN: mb->propStart = spin->GetIVal(); break;
		case IDC_ENDSPIN: mb->propEnd = spin->GetIVal(); break;
		}
		break;



	case WM_COMMAND:
		switch (LOWORD(wParam)) {
		case IDOK:
			{
			mb->propRelative = IsDlgButtonChecked(hWnd,IDC_RELATIVE);
			EndDialog(hWnd,1);
			mb->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);

			break;
			}
		case IDCANCEL:
			EndDialog(hWnd,0);
			break;
		}
		break;

	default:
		return FALSE;
	}
	return TRUE;
}

BOOL CALLBACK AttachBlockDlgProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
	MasterBlockControl *mb = (MasterBlockControl*)GetWindowLong(hWnd,GWL_USERDATA);

	switch (msg) {
	case WM_INITDIALOG:
		{
		mb = (MasterBlockControl*)lParam;

		SetWindowLong(hWnd,GWL_USERDATA,lParam);

//load up list box 
		int scount = mb->propContainer->pblock2->Count(container_names);
		for (int i=0; i<mb->propContainer->pblock2->Count(container_refs);i++)
			{
			char *name;
			mb->propContainer->pblock2->GetValue(container_names,0,name,FOREVER,i);
			SendMessage(GetDlgItem(hWnd,IDC_LIST1),
				LB_ADDSTRING,0,(LPARAM)(TCHAR*)name);
			}


/*		for (i=0; i<mb->propTargetList.Count();i++)
			{
			char *name;
			name = *mb->propNames[i];
//			mb->propContainer->pblock2->GetValue(container_names,0,name,FOREVER,i);
			SendMessage(GetDlgItem(hWnd,IDC_LIST2),
				LB_ADDSTRING,0,(LPARAM)(TCHAR*)name);
			}
*/

		mb->propTargetList.ZeroCount();
		mb->propNames.ZeroCount();
		break;
		}
	case WM_COMMAND:
		switch (LOWORD(wParam)) {
		case IDC_ADD_CONTROL:
			{
			//bring up muti selector track picker
			mb->AttachAdd(GetDlgItem(hWnd,IDC_LIST2));
			//update list 
			//save off list of controls and names to current
			break;
			}
		case IDC_MATCH_CONTROL:
			{
			Tab<BOOL> selSet;
			selSet.SetCount(mb->propContainer->pblock2->Count(container_names));
			for (int i = 0;i<mb->propContainer->pblock2->Count(container_names);i++)
				{
				selSet[i] = SendMessage(GetDlgItem(hWnd,IDC_LIST1),
					LB_GETSEL,i,0);
				}
			mb->MatchNode(selSet, hWnd);

			int ct = SendMessage(GetDlgItem(hWnd,IDC_LIST2),
					LB_GETCOUNT,0,0);
			for (i=0; i<ct;i++)
				{
				SendMessage(GetDlgItem(hWnd,IDC_LIST2),
							LB_DELETESTRING,0,0);
				}

			for (i=0; i<mb->propTargetList.Count();i++)
				{
				char *name;
				name = *mb->propNames[i];
				SendMessage(GetDlgItem(hWnd,IDC_LIST2),
					LB_ADDSTRING,0,(LPARAM)(TCHAR*)name);
				}

			break;
			}
		case IDC_UP:
			{
			int sel = SendMessage(GetDlgItem(hWnd,IDC_LIST2),
					LB_GETCURSEL,0,0);
			if (sel >=0)
				if (mb->AttachAddMoveUp(sel))
					{
					for (int i=0; i<mb->propNames.Count();i++)
						SendMessage(GetDlgItem(hWnd,IDC_LIST2),
							LB_DELETESTRING,0,0);
					for (i=0; i<mb->propNames.Count();i++)
						{
						char *name;
						name = *mb->propNames[i];
						SendMessage(GetDlgItem(hWnd,IDC_LIST2),
							LB_ADDSTRING,0,(LPARAM)(TCHAR*)name);
						}
					sel--;
					SendMessage(GetDlgItem(hWnd,IDC_LIST2),
						LB_SETCURSEL,sel,0);
					}

			break;
			}
		case IDC_DOWN:
			{
			int sel = SendMessage(GetDlgItem(hWnd,IDC_LIST2),
					LB_GETCURSEL,0,0);
			if (sel >=0)
				if (mb->AttachAddMoveDown(sel))
					{
					for (int i=0; i<mb->propNames.Count();i++)
						SendMessage(GetDlgItem(hWnd,IDC_LIST2),
							LB_DELETESTRING,0,0);
					for (i=0; i<mb->propNames.Count();i++)
						{
						char *name;
						name = *mb->propNames[i];
						SendMessage(GetDlgItem(hWnd,IDC_LIST2),
							LB_ADDSTRING,0,(LPARAM)(TCHAR*)name);
						}
					sel++;
					SendMessage(GetDlgItem(hWnd,IDC_LIST2),
						LB_SETCURSEL,sel,0);
					}

			break;
			}
		case IDC_ADDNULL_CONTROL:
			{
			//bring up muti selector track picker
			int sel = SendMessage(GetDlgItem(hWnd,IDC_LIST2),
					LB_GETCURSEL,0,0);
			if (sel < 0)
			sel = 0;

			mb->AttachAddNullAt(GetDlgItem(hWnd,IDC_LIST2),sel);
			//update list 
			//save off list of controls and names to current
			break;
			}

		case IDC_DELETE_CONTROL:
			{
			int sel = SendMessage(GetDlgItem(hWnd,IDC_LIST2),
					LB_GETCURSEL,0,0);
			if (sel >=0)
				mb->AttachDeleteAt(GetDlgItem(hWnd,IDC_LIST2),sel);
			//get selecetd list
			//delete selected tracks
			break;
			}
		case IDOK:
			{
			mb->BuildNewBlock();
			EndDialog(hWnd,1);
			break;
			}
		case IDCANCEL:
			EndDialog(hWnd,0);
			break;
		}
		break;

	default:
		return FALSE;
	}
	return TRUE;
}

#define CUBICMORPHCONT_CLASS_ID 0x09923023


BOOL MasterBlockTrackViewFilter :: proc(Animatable *anim, Animatable *client,int subNum)

{
//make sure the parent is not a slave or 
if ( anim->CanCopyTrack(FOREVER,0) /*&& ((Control*)anim)->IsKeyable()*/ && anim->IsAnimated() && anim->CanCopyAnim()
	 && (client->ClassID() !=BLOCK_CONTROL_CLASS_ID)
	&& (anim->ClassID() != Class_ID(CUBICMORPHCONT_CLASS_ID,0))
	&& (anim->ClassID() !=Class_ID(MASTERPOINTCONT_CLASS_ID,0))

//	|| ( (anim->ClassID() == SLAVEFLOAT_CONTROL_CLASS_ID) || 
//		 (anim->ClassID() == SLAVEPOS_CONTROL_CLASS_ID) ||
//		 (anim->ClassID() == SLAVEROTATION_CONTROL_CLASS_ID) 
//	   )
	)
	return TRUE;
return FALSE;
}

BOOL MasterBlockTrackViewFilterAdd :: proc(Animatable *anim, Animatable *client,int subNum)

{
//make sure the parent is not a slave or 
if ( anim->CanCopyTrack(FOREVER,0) && anim->CanCopyAnim() &&
	 (client->ClassID() !=BLOCK_CONTROL_CLASS_ID)
	&& (anim->ClassID() != Class_ID(CUBICMORPHCONT_CLASS_ID,0))
	&& (anim->ClassID() !=Class_ID(MASTERPOINTCONT_CLASS_ID,0))
	 
//	|| ( (anim->ClassID() == SLAVEFLOAT_CONTROL_CLASS_ID) || 
//		 (anim->ClassID() == SLAVEPOS_CONTROL_CLASS_ID) ||
//		 (anim->ClassID() == SLAVEROTATION_CONTROL_CLASS_ID) 
//	   )
	)
	return TRUE;
return FALSE;
}


BOOL MasterMatchNodeViewFilter :: proc(Animatable *anim, Animatable *client,int subNum)

{
//make sure the parent is not a slave or 
if ( ( anim->SuperClassID()==BASENODE_CLASS_ID) &&
	 (client->ClassID() !=BLOCK_CONTROL_CLASS_ID)
	&& (anim->ClassID() != Class_ID(CUBICMORPHCONT_CLASS_ID,0))
	&& (anim->ClassID() !=Class_ID(MASTERPOINTCONT_CLASS_ID,0))

//	|| ( (anim->ClassID() == SLAVEFLOAT_CONTROL_CLASS_ID) || 
//		 (anim->ClassID() == SLAVEPOS_CONTROL_CLASS_ID) ||
//		 (anim->ClassID() == SLAVEROTATION_CONTROL_CLASS_ID) 
//	   )
	)
	return TRUE;
return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Control\surfctrl.cpp ===
/**********************************************************************
 *<
	FILE: surfctrl.cpp

	DESCRIPTION: A controller that moves an object along a surface

	CREATED BY: Rolf Berteig

	HISTORY: created 2/13/97

 *>	Copyright (c) 1997, All Rights Reserved.
 **********************************************************************/

#include "ctrl.h"
#include "units.h"
#include "interpik.h"
#include "istdplug.h"

#define SURF_CONTROL_CNAME		GetString(IDS_RB_SURF)

#define U_REF		0
#define V_REF		1
#define SURF_REF	2

class SurfPosition;

class PickSurfMode : 
		public PickModeCallback,
		public PickNodeCallback {
	public:		
		SurfPosition *cont;
		
		PickSurfMode(SurfPosition *c) {cont=c;}
		BOOL HitTest(IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags);
		BOOL Pick(IObjParam *ip,ViewExp *vpt);
		void EnterMode(IObjParam *ip);
		void ExitMode(IObjParam *ip);
		BOOL RightClick(IObjParam *ip,ViewExp *vpt)	{return TRUE;}
		BOOL Filter(INode *node);		
		PickNodeCallback *GetFilter() {return this;}
	};

class SurfPosition : public ISurfPosition, public TimeChangeCallback {
	public:
		Control *uCont, *vCont;
		INode *surf;
		int align;
		BOOL flip;

		Point3 curval;
		Quat curRot;
		Interval ivalid;

		static HWND hWnd;
		static IObjParam *ip;
		static ICustButton *iPick;		
		static PickSurfMode *pickMode;
		static ISpinnerControl *iU, *iV;
		static SurfPosition *editCont;

		SurfPosition();
		~SurfPosition();

		// Animatable methods
		Class_ID ClassID() {return SURF_CONTROL_CLASSID;}  
		SClass_ID SuperClassID() { return CTRL_POSITION_CLASS_ID; } 
		void GetClassName(TSTR& s) {s = SURF_CONTROL_CNAME;}
		void DeleteThis() {delete this;}
		int IsKeyable() {return 0;}
		int NumSubs()  {return 2;}
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);
		int SubNumToRefNum(int subNum);
		ParamDimension* GetParamDimension(int i) {return stdPercentDim;}
		BOOL AssignController(Animatable *control,int subAnim);
		void BeginEditParams(IObjParam *ip, ULONG flags,Animatable *prev);
		void EndEditParams(IObjParam *ip, ULONG flags,Animatable *next); 
		int SetProperty(ULONG id, void *data);
		void *GetProperty(ULONG id);

		// Reference methods
		int NumRefs() {return 3;};
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);
		RefResult NotifyRefChanged(Interval, RefTargetHandle, PartID&, RefMessage);
		RefTargetHandle Clone(RemapDir& remap);
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);

		// Control methods
		void Copy(Control *from);		
		BOOL IsLeaf() {return FALSE;}
		void GetValue(TimeValue t, void *val, Interval &valid, GetSetMethod method);	
		void SetValue(TimeValue t, void *val, int commit, GetSetMethod method) {}
		void CommitValue(TimeValue t);
		void RestoreValue(TimeValue t);
		void EnumIKParams(IKEnumCallback &callback);
		BOOL CompDeriv(TimeValue t,Matrix3& ptm,IKDeriv& derivs,DWORD flags);
		float IncIKParam(TimeValue t,int index,float delta);
		void ClearIKParam(Interval iv,int index);

		// TimeChangeCallback methods
		void TimeChanged(TimeValue t);

		// Local methods
		void SetSurface(INode *node);
		void SetupDialog(HWND hWnd);
		void DestroyDialog();
		void UpdateDialog();
		void GetUV(TimeValue t,float &u, float &v,Interval *iv=NULL);
		Point3 DU(TimeValue t,float u, float v);
		Point3 DV(TimeValue t,float u, float v);
		Point3 Norm(TimeValue t,float u, float v);
		Point3 Pos(TimeValue t,float u, float v,Interval *iv=NULL);

		int GetAlign() {return align;}
		void SetAlign(int a);
		BOOL GetFlip() {return flip;}
		void SetFlip(BOOL f);
	};

class JointParamsSurf : public JointParams {
	public:			 	
		JointParamsSurf() : JointParams((DWORD)JNT_POS,2,1.0f) {}
		void SpinnerChange(InterpCtrlUI *ui,WORD id,ISpinnerControl *spin,BOOL interactive);
	};

//--- ClassDesc and class vars -------------------------------------

class SurfClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading) { return new SurfPosition();}
	const TCHAR *	ClassName() {return SURF_CONTROL_CNAME;}
	SClass_ID		SuperClassID() {return CTRL_POSITION_CLASS_ID;}
	Class_ID		ClassID() {return SURF_CONTROL_CLASSID;}
	const TCHAR* 	Category() {return _T("");}
	};
static SurfClassDesc surfCD;
ClassDesc* GetSurfCtrlDesc() {return &surfCD;}


HWND             SurfPosition::hWnd     = NULL;
IObjParam       *SurfPosition::ip       = NULL;
ICustButton     *SurfPosition::iPick    = NULL;
ISpinnerControl *SurfPosition::iU       = NULL;
ISpinnerControl *SurfPosition::iV       = NULL;
PickSurfMode    *SurfPosition::pickMode = NULL;
SurfPosition    *SurfPosition::editCont = NULL;

static BOOL CALLBACK SurfParamDlgProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

//--- SurfPosition methods ------------------------------------------

SurfPosition::SurfPosition()
	{
	uCont = vCont = NULL;
	surf = NULL;
	ReplaceReference(U_REF,NewDefaultFloatController());
	ReplaceReference(V_REF,NewDefaultFloatController());
	align = IDC_ALIGN_NONE;
	flip  = FALSE;
	ivalid.SetEmpty();	
	}

SurfPosition::~SurfPosition()
	{
	DeleteAllRefsFromMe();
	}

Animatable* SurfPosition::SubAnim(int i)
	{
	switch (i) {
		case 0: return uCont; break;
		case 1: return vCont; break;
		};
	return NULL;
	}

TSTR SurfPosition::SubAnimName(int i)
	{
	switch (i) {
		case 0: return GetString(IDS_RB_U); break;
		case 1: return GetString(IDS_RB_V); break;
		}
	return _T("");
	}

int SurfPosition::SubNumToRefNum(int subNum)
	{
	switch (subNum) {
		case 0: return 0;
		case 1: return 1;
		default: return -1;
		}
	}

BOOL SurfPosition::AssignController(
		Animatable *control,int subAnim)
	{
	ReplaceReference(subAnim,(ReferenceTarget*)control);
	ivalid.SetEmpty();
	NotifyDependents(FOREVER,0,REFMSG_SUBANIM_STRUCTURE_CHANGED);
	NotifyDependents(FOREVER,0,REFMSG_CHANGE);
	return TRUE;
	}

void SurfPosition::BeginEditParams(
		IObjParam *ip, ULONG flags,Animatable *prev)
	{
	this->ip = ip;
	editCont = this;
	if (flags&BEGIN_EDIT_HIERARCHY) {		
		if (align!=IDC_ALIGN_NONE) return;

		JointParamsSurf *jp = (JointParamsSurf*)GetProperty(PROPID_JOINTPARAMS);
		InterpCtrlUI *ui;	

		if (!jp) {
			jp = new JointParamsSurf();
			SetProperty(PROPID_JOINTPARAMS,jp);
			}

		if (prev &&
			prev->ClassID()==ClassID() && 
		    (ui = (InterpCtrlUI*)prev->GetProperty(PROPID_INTERPUI))) {
			JointParams *prevjp = (JointParams*)prev->GetProperty(PROPID_JOINTPARAMS);
			prevjp->EndDialog(ui);
			ui->cont = this;
			ui->ip   = ip;
			prev->SetProperty(PROPID_INTERPUI,NULL);
			JointDlgData *jd = (JointDlgData*)GetWindowLong(ui->hParams,GWL_USERDATA);
			jd->jp = jp;
			jp->InitDialog(ui);
		} else {
			ui = new InterpCtrlUI(NULL,ip,this);
			DWORD f=0;
			if (!jp || !jp->RollupOpen()) f = APPENDROLL_CLOSED;	

			ui->hParams = ip->AddRollupPage( 
				hInstance, 
				MAKEINTRESOURCE(IDD_SURFJOINTPARAMS),
				JointParamDlgProc,
				GetString(IDS_RB_SURFJOINTPARAMS), 
				(LPARAM)new JointDlgData(ui,jp),f);	
			}
	
		SetProperty(PROPID_INTERPUI,ui);
	} else {
		pickMode = new PickSurfMode(this);
		hWnd     = ip->AddRollupPage( 
			hInstance, 
			MAKEINTRESOURCE(IDD_SURFPARAMS),
			SurfParamDlgProc,
			GetString(IDS_RB_SURFPARAMS), 
			(LPARAM)this );				
		ip->RegisterTimeChangeCallback(this);
		}
	}

void SurfPosition::EndEditParams(
		IObjParam *ip, ULONG flags,Animatable *next)
	{
	editCont = NULL;
	this->ip = NULL;
	if (next && next->ClassID()==ClassID() && !hWnd) return;

	if (hWnd) {
		ip->UnRegisterTimeChangeCallback(this);
		ip->ClearPickMode();
		delete pickMode;
		pickMode = NULL;		
		ip->DeleteRollupPage(hWnd);
		hWnd = NULL;
	} else {
		int index = aprops.FindProperty(PROPID_INTERPUI);
		if (index>=0) {
			InterpCtrlUI *ui = (InterpCtrlUI*)aprops[index];
			if (ui->hParams) {
				ip->UnRegisterDlgWnd(ui->hParams);
				ip->DeleteRollupPage(ui->hParams);			
				}
			index = aprops.FindProperty(PROPID_INTERPUI);
			if (index>=0) {
				delete aprops[index];
				aprops.Delete(index,1);
				}
			}	
		}
	}

RefTargetHandle SurfPosition::GetReference(int i)
	{
	switch (i) {
		case U_REF: return uCont;
		case V_REF: return vCont;
		case SURF_REF: return surf;
		}
	return NULL;
	}

void SurfPosition::SetReference(int i, RefTargetHandle rtarg)
	{
	switch (i) {
		case U_REF: uCont = (Control*)rtarg; break;
		case V_REF: vCont = (Control*)rtarg; break;
		case SURF_REF: surf = (INode*)rtarg; break;
		}
	}

RefResult SurfPosition::NotifyRefChanged(
		Interval iv, RefTargetHandle hTarg, 
		PartID &partID, RefMessage msg)
	{
	switch (msg) {
		case REFMSG_CHANGE:
			ivalid.SetEmpty();
			UpdateDialog();
			break;

		case REFMSG_TARGET_DELETED:
			if (hTarg == surf) {
				surf = NULL;
				if (hWnd && editCont == this) {
					SetWindowText(GetDlgItem(hWnd,IDC_SURFNAME),
						GetString(IDS_RB_NONE));
					}
				}			
			break;
		}
	return REF_SUCCEED;
	}

void SurfPosition::SetAlign(int a)
	{
	align = a;
	ivalid.SetEmpty();
	NotifyDependents(FOREVER,0,REFMSG_CHANGE);
	if (ip) UpdateDialog();
	}

void SurfPosition::SetFlip(BOOL f)
	{
	flip = f;
	ivalid.SetEmpty();
	NotifyDependents(FOREVER,0,REFMSG_CHANGE);
	if (ip) UpdateDialog();
	}

RefTargetHandle SurfPosition::Clone(RemapDir& remap)
	{
	SurfPosition *cont = new SurfPosition;
	cont->ReplaceReference(U_REF,remap.CloneRef(uCont));
	cont->ReplaceReference(V_REF,remap.CloneRef(vCont));
	cont->ReplaceReference(SURF_REF,surf);
	cont->align = align;
	cont->flip  = flip;
	return cont;
	}

#define ALIGN_CHUNK				0x0100
#define FLIP_CHUNK				0x0110
#define JOINTPARAMSURF_CHUNK	0x0200

IOResult SurfPosition::Save(ISave *isave)
	{
	JointParamsSurf *jp = (JointParamsSurf*)GetProperty(PROPID_JOINTPARAMS);
	ULONG nb;

	if (jp) {
		isave->BeginChunk(JOINTPARAMSURF_CHUNK);
		jp->Save(isave);
		isave->EndChunk();
		}

	isave->BeginChunk(ALIGN_CHUNK);
	isave->Write(&align,sizeof(align),&nb);
	isave->EndChunk();

	if (flip) {
		isave->BeginChunk(FLIP_CHUNK);	
		isave->EndChunk();
		}
	return IO_OK;
	}

IOResult SurfPosition::Load(ILoad *iload)
	{
	ULONG nb;
	IOResult res = IO_OK;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch (iload->CurChunkID()) {
			case ALIGN_CHUNK:
				res=iload->Read(&align,sizeof(align),&nb);
				break;

			case JOINTPARAMSURF_CHUNK: {
				JointParamsSurf *jp = new JointParamsSurf;
				jp->Load(iload);
				SetProperty(PROPID_JOINTPARAMS,jp);
				break;
				}

			case FLIP_CHUNK:
				flip = TRUE;
				break;
			}		
		iload->CloseChunk();
		if (res!=IO_OK)  return res;
		}
	return IO_OK;
	}

void SurfPosition::Copy(Control *from)
	{
	if (from->ClassID()==ClassID()) {
		SurfPosition *cont = (SurfPosition*)from;
		ReplaceReference(U_REF,cont->uCont->Clone());
		ReplaceReference(V_REF,cont->vCont->Clone());
		ReplaceReference(SURF_REF,cont->surf);
		align = cont->align;
		flip  = cont->flip;
		}
	}

void SurfPosition::GetUV(
		TimeValue t,float &u, float &v,Interval *iv)
	{	
	Interval valid;
	if (!iv) iv = &valid;	
	uCont->GetValue(t,&u,*iv);
	vCont->GetValue(t,&v,*iv);
	}

Point3 SurfPosition::DU(TimeValue t,float u, float v)
	{
	return (Pos(t,u+0.01f,v)-Pos(t,u,v))/0.01f;
	}

Point3 SurfPosition::DV(TimeValue t,float u, float v)
	{
	return (Pos(t,u,v+0.01f)-Pos(t,u,v))/0.01f;
	}

Point3 SurfPosition::Norm(TimeValue t,float u, float v)
	{
	Point3 du = DU(t,u,v);
	Point3 dv = DV(t,u,v);
	return Normalize(du^dv);
	}

Point3 SurfPosition::Pos(
		TimeValue t,float u, float v,Interval *iv)
	{	
	Interval valid;
	if (!iv) iv = &valid;
	if (surf) {
		ObjectState os = surf->EvalWorldState(0);		
		return os.obj->GetSurfacePoint(t,u,v,*iv) *
			surf->GetObjTMBeforeWSM(t,iv);
	} else {
		return Point3(0,0,0);
		}
	}

void SurfPosition::GetValue(
		TimeValue t, void *val, Interval &valid, 
		GetSetMethod method)
	{
	if (!ivalid.InInterval(t)) {
		float u, v;
		ivalid = FOREVER;
		GetUV(t,u,v,&ivalid);
		curval = Pos(t,u,v,&ivalid);
		if (align!=IDC_ALIGN_NONE) {
			Matrix3 tm(1);
			Point3 norm = Norm(t,u,v);
			tm.SetRow(2,flip?-norm:norm);
			if (align==IDC_ALIGN_U) 
				 tm.SetRow(0,Normalize(DU(t,u,v)));
			else tm.SetRow(0,Normalize(DV(t,u,v)));
			tm.SetRow(1,Normalize(tm.GetRow(2)^tm.GetRow(0)));
			curRot = Quat(tm);
			}
		}

	if (method==CTRL_RELATIVE) {
		Matrix3 *mat = (Matrix3*)val;
		if (align!=IDC_ALIGN_NONE) {
			curRot.MakeMatrix(*mat);
			}
		mat->SetTrans(curval);		
	} else {
		*((Point3*)val) = curval;
		}
	valid &= ivalid;
	}

void SurfPosition::CommitValue(TimeValue t)
	{
	uCont->CommitValue(t);
	vCont->CommitValue(t);
	}

void SurfPosition::RestoreValue(TimeValue t)
	{
	uCont->RestoreValue(t);
	vCont->RestoreValue(t);
	}

void SurfPosition::TimeChanged(TimeValue t)
	{
	UpdateDialog();
	}

void SurfPosition::SetSurface(INode *node)
	{
	ivalid.SetEmpty();
	ReplaceReference(SURF_REF,node);
	NotifyDependents(FOREVER,0,REFMSG_CHANGE);
	if (ip) UpdateDialog();
	}


//--- PickSurfMode methods -----------------------------------------

BOOL PickSurfMode::HitTest(
		IObjParam *ip,HWND hWnd,ViewExp *vpt,
		IPoint2 m,int flags)
	{
	INode *node = cont->ip->PickNode(hWnd,m);
	return node?TRUE:FALSE;
	}

BOOL PickSurfMode::Pick(IObjParam *ip,ViewExp *vpt)
	{
	INode *node = vpt->GetClosestHit();
	if (node) {
		cont->SetSurface(node);
		ip->RedrawViews(ip->GetTime());
		}
	return TRUE;
	}

void PickSurfMode::EnterMode(IObjParam *ip)
	{
	cont->iPick->SetCheck(TRUE);
	}

void PickSurfMode::ExitMode(IObjParam *ip)
	{
	cont->iPick->SetCheck(FALSE);
	}

BOOL PickSurfMode::Filter(INode *node)
	{
	if (node) {
		ObjectState os = node->EvalWorldState(0);
		if (os.obj->IsParamSurface()) return TRUE;
		}
	return FALSE;
	}


//--- UI -------------------------------------------------------------

static BOOL CALLBACK SurfParamDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	SurfPosition *co = (SurfPosition*)GetWindowLong(hWnd,GWL_USERDATA);
	switch (msg) {
		case WM_INITDIALOG:
			co = (SurfPosition*)lParam;
			SetWindowLong(hWnd, GWL_USERDATA, (LONG)co);
			co->SetupDialog(hWnd);
			break;

		case CC_SPINNER_BUTTONDOWN:
			theHold.Begin();
			break;

		case WM_CUSTEDIT_ENTER:
		case CC_SPINNER_BUTTONUP:
			if (HIWORD(wParam)) {
				theHold.Accept(GetString(IDS_RB_CHANGEUV));
			} else {
				theHold.Cancel();
				}
			co->ip->RedrawViews(co->ip->GetTime());
			break;

		case CC_SPINNER_CHANGE: {
			float f;
			TimeValue t = co->ip->GetTime(); // mjm - 3.1.99
			switch (LOWORD(wParam)) {
				case IDC_SURF_USPIN:
					f = co->iU->GetFVal() / 100.0f; // RB 4/19/99: Display as percent
					co->uCont->SetValue(t, &f);
					co->iU->SetKeyBrackets( co->uCont->IsKeyAtTime(t, 0) ); // mjm - 3.1.99
					break;
				case IDC_SURF_VSPIN:
					f = co->iV->GetFVal()/ 100.0f; // RB 4/19/99: Display as percent
					co->vCont->SetValue(t, &f);
					co->iV->SetKeyBrackets( co->vCont->IsKeyAtTime(t, 0) ); // mjm - 3.1.99
					break;
				}
			co->ip->RedrawViews(co->ip->GetTime());
			break;
			}

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_ALIGN_FLIP:
					co->flip = IsDlgButtonChecked(hWnd,IDC_ALIGN_FLIP);
					co->ivalid.SetEmpty();
					co->NotifyDependents(FOREVER,0,REFMSG_CHANGE);
					co->ip->RedrawViews(co->ip->GetTime());
					break;

				case IDC_ALIGN_NONE:
				case IDC_ALIGN_U:
				case IDC_ALIGN_V:
					co->align = LOWORD(wParam);
					co->ivalid.SetEmpty();
					co->NotifyDependents(FOREVER,0,REFMSG_CHANGE);
					co->ip->RedrawViews(co->ip->GetTime());
					co->UpdateDialog();
					break;

				case IDC_PICKSURF:
					co->ip->SetPickMode(co->pickMode);
					break;
				}
			break;

		case WM_LBUTTONDOWN:case WM_LBUTTONUP:	case WM_MOUSEMOVE:
			co->ip->RollupMouseMessage(hWnd,msg,wParam,lParam);
			return FALSE;

		case WM_DESTROY:
			co->DestroyDialog();
			break;

		default:
			return FALSE;
		}
	return TRUE;
	}

void SurfPosition::SetupDialog(HWND hWnd)
	{
	this->hWnd = hWnd;

	iPick = GetICustButton(GetDlgItem(hWnd,IDC_PICKSURF));
	iPick->SetType(CBT_CHECK);
	iPick->SetHighlightColor(GREEN_WASH);

	iU = GetISpinner(GetDlgItem(hWnd,IDC_SURF_USPIN));			
	iU->SetLimits(-999999999.0f,999999999.0f,FALSE);			
	iU->SetAutoScale();
	iU->LinkToEdit(GetDlgItem(hWnd,IDC_SURF_U),EDITTYPE_FLOAT);
	
	iV = GetISpinner(GetDlgItem(hWnd,IDC_SURF_VSPIN));
	iV->SetLimits(-999999999.0f,999999999.0f,FALSE);			
	iV->SetAutoScale();
	iV->LinkToEdit(GetDlgItem(hWnd,IDC_SURF_V),EDITTYPE_FLOAT);
	
	UpdateDialog();
	}

void SurfPosition::UpdateDialog()
	{	
	if (!hWnd) return;

	TimeValue t = ip->GetTime();
	float f;
	uCont->GetValue(t,&f,FOREVER);
	iU->SetValue(f * 100.0f,FALSE); // RB 4/19/99: Display as percent
	iU->SetKeyBrackets( uCont->IsKeyAtTime(t, 0) ); // mjm - 3.1.99
	vCont->GetValue(t,&f,FOREVER);
	iV->SetValue(f * 100.0f,FALSE);
	iV->SetKeyBrackets( vCont->IsKeyAtTime(t, 0) ); // mjm - 3.1.99

	// RB 3/7/99: Auto radio buttons were supposed to uncheck other buttons... I thought.
	//CheckDlgButton(hWnd,align,TRUE);
	CheckDlgButton(hWnd, IDC_ALIGN_NONE, align==IDC_ALIGN_NONE);	
	CheckDlgButton(hWnd, IDC_ALIGN_U, align==IDC_ALIGN_U);
	CheckDlgButton(hWnd, IDC_ALIGN_V, align==IDC_ALIGN_V);

	CheckDlgButton(hWnd,IDC_ALIGN_FLIP,flip);
	if (align!=IDC_ALIGN_NONE)
		 EnableWindow(GetDlgItem(hWnd,IDC_ALIGN_FLIP),TRUE);
	else EnableWindow(GetDlgItem(hWnd,IDC_ALIGN_FLIP),FALSE);

	if (surf) {
		SetWindowText(GetDlgItem(hWnd,IDC_SURFNAME),
			surf->GetName());
	} else {
		SetWindowText(GetDlgItem(hWnd,IDC_SURFNAME),
			GetString(IDS_RB_NONE));
		}
	}

void SurfPosition::DestroyDialog()
	{
	ReleaseISpinner(iU); iU = NULL;
	ReleaseISpinner(iV); iV = NULL;
	ReleaseICustButton(iPick); iPick = NULL;
	hWnd = NULL;
	}


//--- IK -----------------------------------------------------------

int SurfPosition::SetProperty(ULONG id, void *data)
	{
	if (id==PROPID_JOINTPARAMS) {		
		if (!data) {
			int index = aprops.FindProperty(id);
			if (index>=0) {
				aprops.Delete(index,1);
				}
		} else {
			JointParamsSurf *jp = (JointParamsSurf*)GetProperty(id);
			if (jp) {
				*jp = *((JointParamsSurf*)data);
				delete (JointParamsSurf*)data;
			} else {
				aprops.Append(1,(AnimProperty**)&data);
				}					
			}
		return 1;
	} else
	if (id==PROPID_INTERPUI) {		
		if (!data) {
			int index = aprops.FindProperty(id);
			if (index>=0) {
				aprops.Delete(index,1);
				}
		} else {
			InterpCtrlUI *ui = (InterpCtrlUI*)GetProperty(id);
			if (ui) {
				*ui = *((InterpCtrlUI*)data);
			} else {
				aprops.Append(1,(AnimProperty**)&data);
				}					
			}
		return 1;
	} else {
		return Animatable::SetProperty(id,data);
		}
	}

void* SurfPosition::GetProperty(ULONG id)
	{
	if (id==PROPID_INTERPUI || id==PROPID_JOINTPARAMS) {
		int index = aprops.FindProperty(id);
		if (index>=0) {
			return aprops[index];
		} else {
			return NULL;
			}
	} else {
		return Animatable::GetProperty(id);
		}
	}

void JointParamsSurf::SpinnerChange(
		InterpCtrlUI *ui,WORD id,ISpinnerControl *spin,
		BOOL interactive)
	{
	float val;
	int set = 0;

	switch (id) {
		case IDC_XFROMSPIN:
			val = min[0] = spin->GetFVal()/scale; 
			set = 1;
			break;
		case IDC_XTOSPIN:
			val = max[0] = spin->GetFVal()/scale;
			set = 1;
			break;
		
		case IDC_XDAMPINGSPIN:
			damping[0] = spin->GetFVal(); break;

		case IDC_YFROMSPIN:
			val = min[1] = spin->GetFVal()/scale; 
			set = 2;
			break;
		case IDC_YTOSPIN:
			val = max[1] = spin->GetFVal()/scale;
			set = 2;
			break;
		
		case IDC_YDAMPINGSPIN:
			damping[1] = spin->GetFVal(); break;
		}
	
	if (set && interactive) {
		SurfPosition *c = (SurfPosition*)ui->cont;
 		if (set==1) 
			 c->uCont->SetValue(
				ui->ip->GetTime(),&val,TRUE,CTRL_ABSOLUTE);
		else c->vCont->SetValue(
				ui->ip->GetTime(),&val,TRUE,CTRL_ABSOLUTE);
		ui->ip->RedrawViews(ui->ip->GetTime(),REDRAW_INTERACTIVE);
		}
	}

void SurfPosition::EnumIKParams(IKEnumCallback &callback)
	{
	JointParamsSurf *jp = (JointParamsSurf*)GetProperty(PROPID_JOINTPARAMS);
	if (jp && align==IDC_ALIGN_NONE) {
		if (jp->Active(0)) callback.proc(this,0);
		if (jp->Active(1)) callback.proc(this,1);
		}
	}

BOOL SurfPosition::CompDeriv(
		TimeValue t,Matrix3& ptm,IKDeriv& derivs,DWORD flags)
	{
	JointParamsSurf *jp = (JointParamsSurf*)GetProperty(PROPID_JOINTPARAMS);
	if (!jp || align!=IDC_ALIGN_NONE) return FALSE;

	float u, v;		
	GetUV(t,u,v);
	Point3 zero(0,0,0);

	if (jp->Active(0)) {
		Point3 d = DU(t,u,v);
		for (int j=0; j<derivs.NumEndEffectors(); j++) {
			if (flags&POSITION_DERIV) {
				derivs.DP(d,j);
				}
			if (flags&ROTATION_DERIV) {
				derivs.DR(zero,j);
				}
			}
		derivs.NextDOF();
		}
	if (jp->Active(1)) {
		Point3 d = DV(t,u,v);
		for (int j=0; j<derivs.NumEndEffectors(); j++) {
			if (flags&POSITION_DERIV) {
				derivs.DP(d,j);
				}
			if (flags&ROTATION_DERIV) {
				derivs.DR(zero,j);
				}
			}
		derivs.NextDOF();
		}
	
	ptm.SetTrans(Pos(t,u,v));
	return TRUE;
	}

float SurfPosition::IncIKParam(TimeValue t,int index,float delta)
	{
	JointParamsSurf *jp = (JointParamsSurf*)GetProperty(PROPID_JOINTPARAMS);
	if (fabs(delta) > 0.01f) {
		if (delta<0) delta = -0.01f;
		else delta = 0.01f;
		}
	if (jp) {
		float u, v;
		if (index==0) {
			if (jp->Limited(0)) {			
				uCont->GetValue(t,&u,FOREVER);			
				}
			delta = jp->ConstrainInc(0,u,delta);
			uCont->SetValue(t,&delta,FALSE,CTRL_RELATIVE);
		} else {
			if (jp->Limited(1)) {			
				vCont->GetValue(t,&v,FOREVER);			
				}
			delta = jp->ConstrainInc(0,v,delta);
			vCont->SetValue(t,&delta,FALSE,CTRL_RELATIVE);
			}
		}	
	return delta;
	}

void SurfPosition::ClearIKParam(Interval iv,int index)
	{
	uCont->DeleteTime(iv,TIME_INCRIGHT|TIME_NOSLIDE);
	vCont->DeleteTime(iv,TIME_INCRIGHT|TIME_NOSLIDE);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Control\block\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by control.rc
//
#define IDD_EXPRPARAMS                  103
#define IDD_FUNC_LIST                   104
#define IDD_SCALAR_ASGN                 105
#define IDD_VECTOR_ASGN                 106
#define IDD_ATTACH_DIALOG               107
#define IDD_ATTACH_CONTROLS_DIALOG      109
#define IDD_FOLLOW_PANEL                110
#define IDD_KEYPROP                     111
#define IDD_PATHPARAMS                  123
#define IDD_STDJOINTPARAMS              129
#define IDD_PATHJOINTPARAMS             130
#define IDD_EULER_PARAMS                145
#define IDD_NOISEPARAMS                 146
#define IDD_MASTERPARAMS                146
#define IDD_IPOS_PARAMS                 147
#define IDD_ADDKEY                      147
#define IDD_ATTACH_PARAMS               148
#define IDD_BLOCKPROP                   148
#define IDD_EXPR_DEBUG                  149
#define IDD_SLAVEPARAMS                 149
#define IDD_LINK_PARAMS                 150
#define IDD_ADDNEWLINK                  150
#define IDD_SURFPARAMS                  151
#define IDD_ADDNEWMASTER                151
#define IDD_SURFJOINTPARAMS             152
#define IDD_ADDNEWTRACK                 152
#define IDD_LOD_UTILPARAMS              153
#define IDD_TRACKPROP                   153
#define IDD_ISCALE_PARAMS               154
#define IDS_PW_BLKFILES                 329
#define IDS_PW_SAVEBLOCK                330
#define IDS_PW_FILEEXISTS               331
#define IDS_PW_LOADBLOCK                332
#define IDC_LIST1                       1000
#define IDC_ADD                         1001
#define IDC_LIST2                       1001
#define IDC_EXPLAIN_NOTATION            1002
#define IDC_BUTTON2                     1002
#define IDC_DELETE                      1002
#define IDC_PATH_ALLOWFLIP              1003
#define IDC_BUTTON3                     1003
#define IDC_REPLACE                     1003
#define IDC_IPOS_X                      1004
#define IDC_PATH_CONSTVEL               1004
#define IDC_BUTTON4                     1004
#define IDC_ADD_SELECTED                1004
#define IDC_IPOS_Y                      1005
#define IDC_BUTTON5                     1005
#define IDC_IPOS_Z                      1006
#define IDC_ATTACH_OBNAME               1007
#define IDC_ATTACH_PICKOB               1008
#define IDC_DEBUG_LIST                  1008
#define IDC_DEBUG_VALUE                 1009
#define IDC_ATTACH_UPDATE               1009
#define IDC_ATTACH_SETPOS               1010
#define IDC_ATTACH_KEYTIME              1011
#define IDC_ATTACH_KEYTIMESPIN          1012
#define IDC_ATTACH_KEYFACE              1013
#define IDC_ATTACH_KEYFACESPIN          1014
#define IDC_ATTACH_KEYA                 1015
#define IDC_ATTACH_KEYASPIN             1016
#define IDC_ATTACH_KEYB                 1017
#define IDC_ATTACH_KEYBSPIN             1018
#define IDC_ATTACH_FACEPOSGRAPH         1019
#define IDC_ATTACH_KEYTENS              1020
#define IDC_ATTACH_KEYTENSSPIN          1021
#define IDC_ATTACH_KEYCONT              1022
#define IDC_ATTACH_KEYCONTSPIN          1023
#define IDC_ATTACH_KEYBIAS              1024
#define IDC_ATTACH_KEYBIASSPIN          1025
#define IDC_ATTACH_KEYEASETO            1026
#define IDC_ATTACH_KEYEASETOSPIN        1027
#define IDC_ATTACH_KEYEASEFROM          1028
#define IDC_ATTACH_KEYEASEFROMSPIN      1029
#define IDC_SEL_NAME                    1029
#define IDC_ATTACH_ALIGN                1030
#define IDC_EXPR_DEBUG                  1031
#define IDC_ATTACH_MANUPDATE            1033
#define IDC_LINK_PICK                   1035
#define IDC_LINK_LIST                   1036
#define IDC_LINK_TIME                   1037
#define IDC_LINK_TIMESPIN               1038
#define IDC_LINK_TIMELABEL              1039
#define IDC_LINK_DELETE                 1040
#define IDC_SURFNAME                    1040
#define IDC_PICKSURF                    1041
#define IDC_SURF_U                      1042
#define IDC_SURF_USPIN                  1043
#define IDC_ALIGN_U                     1044
#define IDC_ALIGN_NONE                  1045
#define IDC_ALIGN_V                     1046
#define IDC_ALIGN_FLIP                  1047
#define IDC_EXPR_EDIT                   1048
#define IDC_EULER_ORDER                 1048
#define IDC_EXPR_EVAL                   1049
#define IDC_XAXIS_LABEL                 1049
#define IDC_VAR_NAME                    1050
#define IDC_YAXIS_LABEL                 1050
#define IDC_SCALAR_RB                   1051
#define IDC_ZAXIS_LABEL                 1051
#define IDC_VECTOR_RB                   1052
#define IDC_CREATE_VAR                  1053
#define IDC_SCALAR_LIST                 1054
#define IDC_VECTOR_LIST                 1055
#define IDC_ASGN_CONST                  1056
#define IDC_ASGN_CNTRL                  1057
#define IDC_FOLLOW_APPLY                1058
#define IDC_ABS_POS                     1058
#define IDC_LOD_LIST                    1059
#define IDC_FUNCTIONS                   1060
#define IDC_LOD_MINLABEL                1060
#define IDC_SAVE                        1061
#define IDC_LOD_MIN                     1061
#define IDC_LOAD                        1062
#define IDC_LOD_MINSPIN                 1062
#define IDC_CUR_ASGN                    1063
#define IDC_LOD_MAX                     1063
#define IDC_FUNC_LIST                   1064
#define IDC_LOD_MAXSPIN                 1064
#define IDC_DELETE_VAR                  1065
#define IDC_LOD_MAXLABEL                1065
#define IDC_DESCRIPTION                 1066
#define IDC_LOD_RESET                   1066
#define IDC_XTO                         1067
#define IDC_LOD_VIEWPORTOBJ             1067
#define IDC_VEC_X                       1068
#define IDC_XTOSPIN                     1068
#define IDC_LOD_VIEWWIDTH               1068
#define IDC_VEC_Y                       1069
#define IDC_XDAMPING                    1069
#define IDC_LOD_ADDTOSET                1069
#define IDC_VEC_Z                       1070
#define IDC_XDAMPINGSPIN                1070
#define IDC_LOD_DELETEFROMSET           1070
#define IDC_OFFSET                      1071
#define IDC_YTO                         1071
#define IDC_LOD_CREATENEWSET            1071
#define IDC_CHANGE_OFFSET               1072
#define IDC_YDAMPING                    1072
#define IDC_LOD_VIEWWIDTHSPIN           1072
#define IDC_YTOSPIN                     1073
#define IDC_LOD_DISPPIXELS              1073
#define IDC_YDAMPINGSPIN                1074
#define IDC_LOD_VIEWHEIGHT              1074
#define IDC_OFFSET_SPIN                 1074
#define IDC_ZTO                         1075
#define IDC_LOD_VIEWHEIGHTSPIN          1075
#define IDC_ISCALE_X                    1075
#define IDC_ZDAMPING                    1076
#define IDC_LOD_DISPPERCENT             1076
#define IDC_ISCALE_Y                    1076
#define IDC_ADD_CONTROL                 1076
#define IDC_ZTOSPIN                     1077
#define IDC_LOD_RESETOUTPUT             1077
#define IDC_ISCALE_Z                    1077
#define IDC_DELETE_CONTROL              1077
#define IDC_RELATIVE                    1077
#define IDC_ZDAMPINGSPIN                1078
#define IDC_UP                          1078
#define IDC_XSPRING                     1079
#define IDC_DOWN                        1079
#define IDC_XSPRINGSPIN                 1080
#define IDC_ADDNULL_CONTROL             1080
#define IDC_LINK                        1080
#define IDC_YSPRING                     1081
#define IDC_REMOVE                      1081
#define IDC_MATCH_CONTROL               1081
#define IDC_YSPRINGSPIN                 1082
#define IDC_COLLAPSE                    1082
#define IDC_ZSPRING                     1083
#define IDC_ZSPRINGSPIN                 1084
#define IDC_XSPRINGTENS                 1085
#define IDC_XSPRINGTENSSPIN             1086
#define IDC_PICKPATH                    1087
#define IDC_YSPRINGTENS                 1087
#define IDC_PATHNAME                    1088
#define IDC_YSPRINGTENSSPIN             1088
#define IDC_STARTSPIN                   1088
#define IDC_ZSPRINGTENS                 1089
#define IDC_START                       1089
#define IDC_PREVKEY                     1090
#define IDC_ZSPRINGTENSSPIN             1090
#define IDC_ENDSPIN                     1090
#define IDC_NEXTKEY                     1091
#define IDC_END                         1091
#define IDC_KEYNUM                      1092
#define IDC_XACTIVE                     1099
#define IDC_XLIMITED                    1100
#define IDC_XEASE                       1101
#define IDC_XFROM                       1102
#define IDC_XFROMSPIN                   1103
#define IDC_YACTIVE                     1104
#define IDC_YLIMITED                    1105
#define IDC_YFROM                       1106
#define IDC_YEASE                       1107
#define IDC_YFROMSPIN                   1108
#define IDC_ZACTIVE                     1109
#define IDC_ZLIMITED                    1110
#define IDC_ZFROM                       1111
#define IDC_ZEASE                       1112
#define IDC_ZFROMSPIN                   1113
#define IDC_EULER_X                     1149
#define IDC_EULER_Y                     1150
#define IDC_EULER_Z                     1151
#define IDC_NOISE_XSTRENGTH             1151
#define IDC_NOISE_XSTRENGTHSPIN         1152
#define IDC_NOISE_FREQ                  1153
#define IDC_NOISE_FREQSPIN              1154
#define IDC_NOISE_YSTRENGTH             1155
#define IDC_EXPR_CONST                  1156
#define IDC_NOISE_YSTRENGTHSPIN         1156
#define IDC_EXPR_CONST_SPIN             1157
#define IDC_NOISE_SEED                  1157
#define IDC_VEC_Z_SPIN                  1158
#define IDC_NOISE_SEEDSPIN              1158
#define IDC_VEC_Y_SPIN                  1159
#define IDC_NOISE_ZSTRENGTH             1159
#define IDC_NOISE_ZSTRENGTHSPIN         1160
#define IDC_VEC_X_SPIN                  1161
#define IDC_NOISE_ROUGH                 1161
#define IDC_NOISE_ROUGHSPIN             1162
#define IDC_NOISE_RAMPIN                1163
#define IDC_NOISE_RAMPINSPIN            1164
#define IDC_NOISE_RAMPOUT               1165
#define IDC_NOISE_RAMPOUTSPIN           1166
#define IDC_TCB_GRAPH                   1182
#define IDC_PATH_FOLLOW                 1200
#define IDC_PATH_BANK                   1201
#define IDC_FOLLOW_BANKSPIN             1202
#define IDC_FOLLOW_BANK                 1203
#define IDC_FOLLOW_BANKLABEL            1204
#define IDC_FOLLOW_TRACK                1205
#define IDC_FOLLOW_TRACKSPIN            1206
#define IDC_FOLLOW_TRACKLABEL           1207
#define IDC_PATHPERCENT                 1208
#define IDC_FOLLOW_START                1208
#define IDC_PATHPERCENTSPIN             1209
#define IDC_FOLLOW_STARTSPIN            1209
#define IDC_NOISE_XSTRENGTHLABEL        1210
#define IDC_FOLLOW_BANKLABEL2           1210
#define IDC_NOISE_YSTRENGTHLABEL        1211
#define IDC_FOLLOW_END                  1211
#define IDC_SURF_V                      1211
#define IDC_NOISE_ZSTRENGTHLABEL        1212
#define IDC_FOLLOW_ENDSPIN              1212
#define IDC_SURF_VSPIN                  1212
#define IDC_NOISE_FRACTAL               1213
#define IDC_FOLLOW_SAMP                 1213
#define IDC_NOISE_ROUGHLABEL            1214
#define IDC_FOLLOW_SAMPSPIN             1214
#define IDC_NOISE_GRAPH                 1215
#define IDC_NOISE_ZSTRENGTHLABEL2       1216
#define IDC_NOISE_ZSTRENGTHLABEL3       1217
#define IDC_NOISE_XLIM0                 1506
#define IDC_NOISE_YLIM0                 1507
#define IDC_NOISE_ZLIM0                 1508
#define IDC_JP_XFROMLABEL               1534
#define IDC_JP_XTOLABEL                 1535
#define IDC_JP_YFROMLABEL               1536
#define IDC_JP_ZFROMLABEL               1537
#define IDC_JP_YTOLABEL                 1538
#define IDC_JP_ZTOLABEL                 1539
#define IDC_COLOR                       1540
#define IDC_JP_XDAMPINGLABEL            1549
#define IDC_JP_YDAMPINGLABEL            1550
#define IDC_JP_ZDAMPINGLABEL            1551
#define IDC_PATH_X                      1607
#define IDC_PATH_Y                      1608
#define IDC_PATH_Z                      1609
#define IDC_PATH_FLIP                   1610
#define IDC_XSPINGBACK                  1638
#define IDC_YSPINGBACK                  1639
#define IDC_ZSPINGBACK                  1640
#define IDC_LIST_NAME                   1664
#define IDS_DB_EXPR_PARSE_ERROR         20280
#define IDS_DB_DUPNAME                  20281
#define IDS_DB_CANT_CREATE_VAR          20282
#define IDS_DB_NOSUCH                   20283
#define IDS_DB_CANT_CHANGE_OFFSET       20284
#define IDS_DB_NOCURVAR                 20285
#define IDS_DB_CANTDELETE               20286
#define IDS_DB_EXPRCNTL                 20287
#define IDS_DB_NOTHINGDEL               20288
#define IDS_DB_XPR_FILES                20289
#define IDS_JW_BANK                     20290
#define IDS_JW_AXIS                     20291
#define IDS_JW_AXISFLIP                 20292
#define IDS_DB_BAD_NAME                 20552
#define IDS_DB_POSITION_EXPR            20553
#define IDS_DB_POINT3_EXPR              20554
#define IDS_DB_FLOAT_EXPR               20555
#define IDS_DB_SCALE_EXPR               20556
#define IDS_DB_ROTATION_EXPR            20557
#define IDS_DB_CIRCULAR_DEPENDENCY      20558
#define IDS_DB_CANT_ASSIGN              20559
#define IDS_DB_NEED_VECTOR              20560
#define IDS_DB_NEED_SCALAR              20561
#define IDS_DB_SAVE_EXPR                20562
#define IDS_DB_LOAD_EXPR                20563
#define IDS_JW_BANKAMOUNT               20564
#define IDS_JW_SMOOTHNESS               20565
#define IDS_JW_ALLOWUPSIDEDOWN          20566
#define IDS_JW_CONSTANTVEL              20567
#define IDS_JW_FOLLOW                   20568
#define IDS_RB_PERCENT                  30135
#define IDS_RB_PATHPARAMS               30136
#define IDS_RB_NONE                     30137
#define IDS_RB_ROTJOINTPARAMS           30148
#define IDS_RB_PATHJOINTPARAMS          30151
#define IDS_RB_STRENGTH                 30247
#define IDS_RB_PATH                     30532
#define IDS_RB_EULERXYZ                 30533
#define IDS_RB_EULERPARAMS              30534
#define IDS_RB_XROTATION                30535
#define IDS_RB_YROTATION                30536
#define IDS_RB_ZROTATION                30537
#define IDS_RB_NOISEFLOAT               30538
#define IDS_RB_NOISEPOSITION            30539
#define IDS_RB_NOISEPOINT3              30540
#define IDS_RB_NOISEROTATION            30541
#define IDS_RB_NOISESCALE               30542
#define IDS_PRS_LOCALEULERXYZ           30543
#define IDS_PRS_LOCALXROTATION          30544
#define IDS_PRS_LOCALYROTATION          30545
#define IDS_PRS_LOCALZROTATION          30546
#define IDS_PW_MASTERBLOCK              30548
#define IDS_PW_SLAVE                    30549
#define IDS_PW_BLOCK                    30550
#define IDS_PW_SLAVEFLOAT               30551
#define IDS_PW_SUB                      30552
#define IDS_PW_SLAVEPOS                 30553
#define IDS_DS_PARAMCHG                 30554
#define IDS_PW_CONTROLCONTAINER         30555
#define IDS_PW_REFS                     30556
#define IDS_PW_REFS_NAMES               30557
#define IDS_PW_HOLDER                   30558
#define IDS_PW_START                    30559
#define IDS_PW_END                      30560
#define IDS_PW_COLOR                    30561
#define IDS_PW_SLAVEROTATION            30562
#define IDS_PW_BLEND                    30563
#define IDS_PW_SLAVESCALE               30564
#define IDS_PW_PROPERTIES               30565
#define IDS_PW_MB_ADDKEY                30566
#define IDS_PW_MB_DELETEKEY             30567
#define IDS_PW_MB_SELECTKEY             30568
#define IDS_PW_SLAVEPOINT3              30569
#define IDS_PW_RANGE                    30570
#define IDS_PW_RESTORE                  30571
#define IDS_PW_ADDKEY                   30572
#define IDS_PW_DELETEKEY                30573
#define IDS_PW_ERROR                    30574
#define IDS_PW_ERROR_MSG                30575
#define IDS_PW_ADDBLOCK                 30576
#define IDS_PW_REMOVEBLOCK              30577
#define IDS_RB_PATHCONTROLLER           30625
#define IDS_RB_ILLEGALPATH              30626
#define IDS_RB_NOISECONTROLTITLE        30655
#define IDS_RB_EXPRESSIONCONTROLTITLE   30656
#define IDS_RB_PICKPATH                 30663
#define IDS_DB_FN_SIN                   30664
#define IDS_DB_FN_NOISE                 30665
#define IDS_DB_FN_IF                    30666
#define IDS_DB_FN_MIN                   30667
#define IDS_DB_FN_MAX                   30668
#define IDS_DB_FN_POW                   30669
#define IDS_DB_FN_MOD                   30670
#define IDS_DB_FN_DEGTORAD              30671
#define IDS_DB_FN_RADTODEG              30672
#define IDS_DB_FN_COS                   30673
#define IDS_DB_FN_TAN                   30674
#define IDS_DB_FN_ASIN                  30675
#define IDS_DB_FN_ACOS                  30676
#define IDS_DB_FN_ATAN                  30677
#define IDS_DB_FN_SINH                  30678
#define IDS_DB_FN_COSH                  30679
#define IDS_DB_FN_TANH                  30680
#define IDS_DB_FN_LN                    30681
#define IDS_DB_FN_LOG                   30682
#define IDS_DB_FN_EXP                   30683
#define IDS_DB_FN_SQRT                  30684
#define IDS_DB_FN_ABS                   30685
#define IDS_DB_FN_CEIL                  30686
#define IDS_DB_FN_FLOOR                 30687
#define IDS_DB_FN_COMP                  30688
#define IDS_DB_FN_UNIT                  30689
#define IDS_DB_FN_LENGTH                30690
#define IDS_DB_FN_PI                    30691
#define IDS_DB_FN_E                     30692
#define IDS_DB_FN_TPS                   30693
#define IDS_DB_FN_VIF                   30694
#define IDS_RB_NOISESTRENGTH            30695
#define IDS_RB_SETPERCENT               30696
#define IDS_RB_BOOLCONTROL              30697
#define IDS_RB_IPOSPARAMS               30698
#define IDS_RB_IPOS                     30699
#define IDS_RB_XPOSITION                30700
#define IDS_RB_YPOSITION                30701
#define IDS_RB_ZPOSITION                30702
#define IDS_RB_ATTACHCONTROL            30703
#define IDS_RB_ATTACHPARAMS             30704
#define IDS_RB_EDITATTACHKEY            30705
#define IDS_RB_ATTACHCONTROLLER         30706
#define IDS_RB_ILLEGALOBJECT            30707
#define IDS_RB_ATTACHTITLE              30708
#define IDS_RB_IPOINT3                  30709
#define IDS_RB_IPOINT3PARAMS            30710
#define IDS_RB_ICOLOR                   30711
#define IDS_RB_ICOLORPARAMS             30712
#define IDS_RB_LINKCTRL                 30713
#define IDS_RB_TRANSFORM                30714
#define IDS_RB_LINKPARAMS               30715
#define IDS_RB_SETLINKTIME              30716
#define IDS_RB_DELETELINK               30717
#define IDS_RB_ADDLINK                  30718
#define IDS_RB_FOLLOWUTIL               30719
#define IDS_RB_MULTISEL                 30720
#define IDS_RB_NONESEL                  30721
#define IDS_RB_APPLYFOLLOW              30722
#define IDS_MM_ISCALEPARAMS             30723
#define IDS_RB_SURF                     30724
#define IDS_RB_U                        30725
#define IDS_RB_V                        30726
#define IDS_RB_CHANGEUV                 30727
#define IDS_RB_SURFPARAMS               30728
#define IDS_RB_SURFJOINTPARAMS          30729
#define IDS_RB_EULERTYPE0               30730
#define IDS_RB_EULERTYPE1               30731
#define IDS_RB_EULERTYPE2               30732
#define IDS_RB_EULERTYPE3               30733
#define IDS_RB_EULERTYPE4               30734
#define IDS_RB_EULERTYPE5               30735
#define IDS_RB_EULERTYPE6               30736
#define IDS_RB_EULERTYPE7               30737
#define IDS_RB_EULERTYPE8               30738
#define IDS_RB_X                        30739
#define IDS_RB_Y                        30740
#define IDS_RB_Z                        30741
#define IDS_RB_XAXIS                    30742
#define IDS_RB_YAXIS                    30743
#define IDS_RB_ZAXIS                    30744
#define IDS_RB_EULERNAME                30745
#define IDS_RB_LODCONTROL               30746
#define IDS_RB_LODUTILITU               30747
#define IDS_RB_LODSAMEPARENT            30748
#define IDS_RB_DEFCONTROLLERS           30749
#define IDS_RB_CHANGESTRENGTH           30750
#define IDS_PRS_LOCALEULERNAME          30751
#define IDS_MM_ISCALE                   30752
#define IDS_MM_XSCALE                   30753
#define IDS_MM_YSCALE                   30754
#define IDS_MM_ZSCALE                   30755

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        113
#define _APS_NEXT_COMMAND_VALUE         40006
#define _APS_NEXT_CONTROL_VALUE         1082
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Control\block\masterblock.h ===
//
//	app/scene.cpp
//  app/tvpickmulti.cpp -  done
//  app/jagapi.cpp - done
//  app/jagimp.cpp - done
//  app/treevw.h - done
//  core/listctrl.cpp - done
//  core/coremain.h - done
//  maxsdk/include/maxapi.h - done
//  maxsdk/include/plugapi.h - done
//  resmgr/ktx.rc - done

#ifndef __MB__H
#define __MB__H

#include "iparamm2.h"
#include "Simpobj.h"

//#define MASTERBLOCK_SUPER_CLASS_ID	0x64c95999

#define PICKMULTI_FLAG_ANIMATED	 1
#define PICKMULTI_FLAG_VISTRACKS 2

#define BLOCK_CONTROL_CNAME	GetString(IDS_PW_BLOCK)
#define BLOCK_CONTROL_CLASS_ID	Class_ID(0x64c959cf, 0x47df4589)

#define SLAVE_CONTROL_CNAME	GetString(IDS_PW_SLAVE)
#define SLAVE_CONTROL_CLASS_ID	Class_ID(0x64c959cf, 0x47df4590)

#define SLAVEFLOAT_CONTROL_CNAME	GetString(IDS_PW_SLAVEFLOAT)
#define SLAVEFLOAT_CONTROL_CLASS_ID	Class_ID(0x64c959cf, 0x47df4501)

#define SLAVEPOS_CONTROL_CNAME	GetString(IDS_PW_SLAVEPOS)
#define SLAVEPOS_CONTROL_CLASS_ID	Class_ID(0x64c959cf, 0x47df4512)

#define SLAVEROTATION_CONTROL_CNAME	GetString(IDS_PW_SLAVEROTATION)
#define SLAVEROTATION_CONTROL_CLASS_ID	Class_ID(0x64c959cf, 0x47df4523)

#define SLAVESCALE_CONTROL_CNAME	GetString(IDS_PW_SLAVESCALE)
#define SLAVESCALE_CONTROL_CLASS_ID	Class_ID(0x64c959cf, 0x47df4534)


#define SLAVEPOINT3_CONTROL_CNAME	GetString(IDS_PW_SLAVEPOINT3)
#define SLAVEPOINT3_CONTROL_CLASS_ID	Class_ID(0x64c959cf, 0x47df4535)



#define MASTERBLOCK_CONTROL_CNAME	GetString(IDS_PW_MASTERBLOCK)
#define MASTERBLOCK_CONTROL_CLASS_ID	Class_ID(0x64c959cf, 0x47df4578)
#define MASTERBLOCKDLG_CLASS_ID	0xaab659c4
#define SLAVEDLG_CLASS_ID	0xaab659c5

#define CONTROLCONTAINER_CNAME	GetString(IDS_PW_CONTROLCONTAINER)
#define CONTROLCONTAINER_CLASS_ID	Class_ID(0x64c959cf, 0x47df423)


#define BLOCK_PBLOCK_REF 0


#define MASTER_PBLOCK_REF 0


class NameList : public Tab<TSTR*> {
	public:
		void Free() {
			for (int i=0; i<Count(); i++) {
				delete (*this)[i];
				(*this)[i] = NULL;
				}
			}
		void Duplicate() {
			for (int i=0; i<Count(); i++) {
				if ((*this)[i]) (*this)[i] = new TSTR(*(*this)[i]);
				}
			}
	};


class BlockDataClass
{
Tab<Control> c;
//name
//Control *c;
};

class ControlContainerObject ;
class SlaveControl;
//need a container controller

class BlockControl : public Control {
	public:		
//		IParamBlock2* pblock2;
		Interval range;
		BlockControl();
		~BlockControl();

		Color color;
		HWND trackHWND;
//watje 4-30-99
		BOOL suspendNotifies;

		Tab<Control*> controls;
		Tab<Control*> tempControls;
		Tab<SlaveControl*> backPointers;

		Tab<SlaveControl*> externalBackPointers;

		void NotifySlaves();

		
		void RebuildTempControl();
		void AddKeyToTempControl(TimeValue t,  TimeValue scale, BOOL isRelative = TRUE);
//		void AddKeyToSub(Control *sub,int whichSub, TimeValue t,  TimeValue scale, BOOL isRelative = TRUE);
		void AddKeyToSub(Control *sub,int whichSub, TimeValue t,  TimeValue scale, Interval mrange, BOOL isRelative = TRUE);
		
		NameList names;
		TimeValue start,end;
		TimeValue l;
		int propStart;
//		int index;

		// Animatable methods		
		void DeleteThis() {delete this;}		
		int IsKeyable() {return 0;}		
		BOOL IsAnimated() {return TRUE;}

// JBW: direct ParamBlock access is added
//		int	NumParamBlocks() { return 1; }					// return number of ParamBlocks in this instance
//		IParamBlock2* GetParamBlock(int i) { return pblock2; } // return i'th ParamBlock
//		IParamBlock2* GetParamBlockByID(BlockID id) { return (pblock2->ID() == id) ? pblock2 : NULL; } // return id'd ParamBlock


		int NumSubs();  //number of sub tracks in pblock2
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);
		BOOL AssignController(Animatable *control,int subAnim);
//		int SubNumToRefNum(int subNum);

		int NumRefs();
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);

		BOOL CanCopyAnim() {return FALSE;}
		BOOL CanMakeUnique(){return FALSE;}
		BOOL IsReplaceable() { return FALSE;}


		BOOL CanApplyEaseMultCurves() { return FALSE;}

		// Reference methods
//		RefResult NotifyRefChanged(Interval, RefTargetHandle, PartID&, RefMessage) {return REF_SUCCEED;}
		RefResult NotifyRefChanged(
				Interval changeInt, 
				RefTargetHandle hTarget, 
     			PartID& partID,  
     			RefMessage message);


		// Control methods				
		void Copy(Control *from) {}
		BOOL IsLeaf() {return FALSE;}
		void CommitValue(TimeValue t) {}
		void RestoreValue(TimeValue t) {}		

		void EditTrackParams(
			TimeValue t,
			ParamDimensionBase *dim,
			TCHAR *pname,
			HWND hParent,
			IObjParam *ip,
			DWORD flags);

		int TrackParamsType() {return TRACKPARAMS_NONE;}

		
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);

		Class_ID ClassID() { return BLOCK_CONTROL_CLASS_ID; }  
		SClass_ID SuperClassID() { return CTRL_FLOAT_CLASS_ID; } 
		void GetClassName(TSTR& s) {s = BLOCK_CONTROL_CNAME;}

		// Control methods
		RefTargetHandle Clone(RemapDir& remap);

		void GetValue(TimeValue t, void *val, Interval &valid, GetSetMethod method=CTRL_ABSOLUTE);
		void SetValue(TimeValue t, void *val, int commit, GetSetMethod method);

		void GetValue(TimeValue t, void *val, Interval &valid, int whichSub, GetSetMethod method=CTRL_ABSOLUTE);


		DeleteControl(int i);
		AddControl( HWND hWnd);
		Control* BuildSlave(TrackViewPick res,Control* list, BOOL createdList);
		Control* BuildListControl(TrackViewPick res, BOOL &createdList);
		AddBlockName(ReferenceTarget *anim,ReferenceTarget *client, int subNum, NameList &names);


	};


class BlockControlClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 0; }
	void *			Create(BOOL loading) { return new BlockControl(); }
	const TCHAR *	ClassName() { return BLOCK_CONTROL_CNAME; }
	SClass_ID		SuperClassID() { return CTRL_FLOAT_CLASS_ID; }
	Class_ID		ClassID() { return BLOCK_CONTROL_CLASS_ID; }
	const TCHAR* 	Category() { return _T("");  }

	};


#define KEY_FLAGGED     (1<<1)

class BlockKeysClass
{
public:
TimeValue start,end;
int block_id;
BOOL startSelected;
BOOL endSelected;
BOOL relative;
int startFlag,endFlag;
float blend;

};


class MasterBlockControl : public Control {
	public:		
		//float strength[MAX_ELEMS];

//list of all block controls 
//		IParamBlock2* pblock2;
//		Control *cont; // make strength animatable.
		IObjParam *iop;

		void UpdateRange();

		HWND trackHWND;
		Tab<BlockControl*> Blocks;
		Control *blendControl;
		Tab<BlockKeysClass> BlockKeys;
		BOOL relativeHit;
		BOOL startRestoreState, endRestoreState;

		Interval range;
		NameList names;
		BOOL isCurveSelected;
		BOOL rangeUnlocked;

		int CurrentSelectedTrack;
		int AddDialogSelect;
		TimeValue propStart, propEnd;
		BOOL propRelative;
		Color propColor;
		Tab<TrackViewPick> propTargetList;
		TSTR propBlockName;
		NameList propNames;
		int propNamePos;

		ControlContainerObject *propContainer;

		Control* BuildSlave(TrackViewPick res,Control* list, BOOL createdList);
		Control* BuildListControl(TrackViewPick res, BOOL &createdList);
		ReplaceBlock(HWND hWnd,int whichBlock);
		AddBlock(HWND hWnd);
		AddSelected(HWND hWnd);
		AppendBlock(BlockControl *b, int i, TrackViewPick res,int where=-1);
		AppendBlock(BlockControl *b,int i, TrackViewPick res, Control *bdata,int where=-1);

//watje 4-24-99
		int AppendBlockNoSlave(BlockControl *b,int i, TSTR *name, Control *bdata);

		AddBlockName(ReferenceTarget *anim,ReferenceTarget *client, int subNum, NameList &names);
		AttachAdd(HWND hWnd);
		AttachAddNullAt(HWND hListWnd, int where);
		AttachDeleteAt(HWND hListWnd, int where);
		BuildNewBlock();

		SaveBlock(int whichBlock);
		DeleteBlock(int whichBlock);
		LoadBlock();

		MasterBlockControl();
		

		// Animatable methods		
		void DeleteThis() {delete this;}		
		int IsKeyable() {return 1;}		
		BOOL IsAnimated() {return TRUE;}

		// Paint myself in TrackView
		int PaintTrack(ParamDimensionBase *dim,HDC hdc,Rect& rcTrack,Rect& rcPaint,float zoom,int scroll,DWORD flags);
		// Get a little more room in TrackView to paint the curve
		int GetTrackVSpace( int i ) {return 3;}
		int PaintFCurves(ParamDimensionBase *dim,HDC hdc,Rect& rcGraph,	Rect& rcPaint,float tzoom,int tscroll,float vzoom,int vscroll,DWORD flags );



// JBW: direct ParamBlock access is added
//		int	NumParamBlocks() { return 1; }					// return number of ParamBlocks in this instance
//		IParamBlock2* GetParamBlock(int i) { return pblock2; } // return i'th ParamBlock
//		IParamBlock2* GetParamBlockByID(BlockID id) { return (pblock2->ID() == id) ? pblock2 : NULL; } // return id'd ParamBlock
		int SubNumToRefNum(int subNum) { if (subNum == 0)
											return 0;
											else return -1;
										}
		BOOL CanCopyAnim() {return FALSE;}
		BOOL AssignController(Animatable *control,int subAnim);
		BOOL CanApplyEaseMultCurves() { return FALSE;}



		int NumSubs();  //nmumber of blocks
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);
//		BOOL AssignController(Animatable *control,int subAnim);
//		int SubNumToRefNum(int subNum);
//int SubNumToRefNum(int subNum) {if (subNum==0) return PATHPOS_PBLOCK_REF; else return -1;}
		int NumRefs();
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);

		RefResult NotifyRefChanged(
				Interval changeInt, 
				RefTargetHandle hTarget, 
     			PartID& partID,  
     			RefMessage message);


		BOOL CanMakeUnique() {return FALSE;}

		void EditTrackParams(
			TimeValue t,
			ParamDimensionBase *dim,
			TCHAR *pname,
			HWND hParent,
			IObjParam *ip,
			DWORD flags);
	
		int HitTestTrack(TrackHitTab& hits,
				Rect& rcHit,Rect& rcTrack,
				float zoom,int scroll,DWORD flags);

		int HitTestFCurves(ParamDimensionBase *dim,TrackHitTab& hits,
				Rect& rcHit, Rect& rcGraph,
				float tzoom, int tscroll,
				float vzoom,int vscroll, DWORD flags);

		
		int TrackParamsType() {return TRACKPARAMS_WHOLE;}

		void SelectCurve(BOOL sel);
		BOOL IsCurveSelected();

		// Reference methods
//		RefResult NotifyRefChanged(Interval, RefTargetHandle, PartID&, RefMessage) {return REF_SUCCEED;}

		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);

		// Control methods				
		void Copy(Control *from) {}
		BOOL IsLeaf() {return TRUE;}
		void CommitValue(TimeValue t) {}
		void RestoreValue(TimeValue t) {}		
		void HoldTrack();
		
		void UpdateControl(int i);
		// From INoiseControl

		void HoldRange();
		Interval GetTimeRange(DWORD flags) {
				UpdateRange(); 
				return range;}
		void EditTimeRange(Interval range,DWORD flags);
		void MapKeys(TimeMap *map,DWORD flags );

		void GetStrength(TimeValue t,float *strength) {
//			cont->GetValue(t,strength,FOREVER);
			}


		Class_ID ClassID() { return MASTERBLOCK_CONTROL_CLASS_ID; }  
		SClass_ID SuperClassID() { return MASTERBLOCK_SUPER_CLASS_ID; } 
		void GetClassName(TSTR& s) {s = MASTERBLOCK_CONTROL_CNAME;}

		// Control methods
		RefTargetHandle Clone(RemapDir& remap);

		void GetValue(TimeValue t, void *val, Interval &valid, GetSetMethod method=CTRL_ABSOLUTE);
		void SetValue(TimeValue t, void *val, int commit, GetSetMethod method);

		void GetValue2(TimeValue t, void *val, Interval &valid, int whichBlock, int whichSub, GetSetMethod method=CTRL_ABSOLUTE);
		void GetValue3(Control *sub, TimeValue t, void *val, Interval &valid, Tab<int> whichBlock, Tab<int> whichSub, Interval localIV, GetSetMethod method=CTRL_ABSOLUTE);

		int NumKeys();
		void CloneSelectedKeys(BOOL offset);
		void DeleteKeys(DWORD flags);
		BOOL IsKeySelected(int index);
		void CopyKeysFromTime(TimeValue src,TimeValue dst,DWORD flags);
		int GetKeyTimes(Tab<TimeValue> &times,Interval range,DWORD flags);
		int GetKeySelState(BitArray &sel,Interval range,DWORD flags);
		BOOL IsKeyAtTime(TimeValue t,DWORD flags);


		void AddKey(TimeValue t, int whichBlock);
		void AddNewKey(TimeValue t,DWORD flags);

		void MoveKeys(ParamDimensionBase *dim,float delta,DWORD flags);
		void SelectKeys(TrackHitTab& sel, DWORD flags);
		void SetSelKeyCoords(TimeValue t, float val,DWORD flags);
		int GetSelKeyCoords(TimeValue &t, float &val,	DWORD flags);
		int NumSelKeys();
		void FlagKey(TrackHitRecord hit);
		int GetFlagKeyIndex();
		TimeValue GetKeyTime(int index) ;
		void SelectKeyByIndex(int i,BOOL sel);


		MatchNode(Tab<BOOL> selSet, HWND hParent);
		AttachAddMoveUp(int i);
		AttachAddMoveDown(int i);
		AttachAddToList(int where, TrackViewPick res);
		TSTR* GetBlockName(ReferenceTarget *anim,ReferenceTarget *client, int subNum);
//		RecurseSubs(TSTR matchString, Animatable* anim, TrackViewPick& r);
		RecurseSubs(TSTR matchString, Class_ID pid, Animatable* anim, TrackViewPick& r);
		BOOL IsReplaceable() { return FALSE;}

		void Update(Control *sub, Tab<int> whichBlock, Tab<int> whichSub);


 //		void AddKey();

		// StdControl methods
  };


class MasterBlockClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { return new MasterBlockControl(); }
	const TCHAR *	ClassName() { return MASTERBLOCK_CONTROL_CNAME; }
	SClass_ID		SuperClassID() { return MASTERBLOCK_SUPER_CLASS_ID; }
	Class_ID		ClassID() { return MASTERBLOCK_CONTROL_CLASS_ID; }
	const TCHAR* 	Category() { return _T("");  }
// JBW: new descriptor data accessors added.
	const TCHAR*	InternalName() { return _T("MasterBlock"); }			// returns fixed parsable name (scripter-visible name)
	HINSTANCE		HInstance() { return hInstance; }				// returns owning module handle

	};





class SlaveControl : public Control {
	public:		

		HWND trackHWND;

		SClass_ID superID;
		int propBlockID,propSubID;
		MasterBlockControl *master;
		BOOL masterPresent;
		Control *sub;
		Control *scratchControl;

		Tab<int> blockID;
		Tab<int> subID;


		Interval range;

		SlaveControl();
		~SlaveControl();
		

		// Animatable methods		
//		int IsKeyable() {return sub->IsKeyable();}	
		int IsKeyable() {return FALSE;}	
		
		void GetValue(TimeValue t, void *val, Interval &valid, GetSetMethod method=CTRL_ABSOLUTE);
		void SetValue(TimeValue t, void *val, int commit=1, GetSetMethod method=CTRL_ABSOLUTE);
		void EnumIKParams(IKEnumCallback &callback);
		BOOL CompDeriv(TimeValue t,Matrix3& ptm,IKDeriv& derivs,DWORD flags);
		void MouseCycleCompleted(TimeValue t);

		BOOL CanApplyEaseMultCurves() { return FALSE;}

		void EditTrackParams(
			TimeValue t,
			ParamDimensionBase *dim,
			TCHAR *pname,
			HWND hParent,
			IObjParam *ip,
			DWORD flags);
	
		int TrackParamsType() {return TRACKPARAMS_WHOLE;}


		BOOL IsAnimated() {return TRUE;}

// JBW: direct ParamBlock access is added
//		int	NumParamBlocks() { return 1; }					// return number of ParamBlocks in this instance
//		IParamBlock2* GetParamBlock(int i) { return pblock2; } // return i'th ParamBlock
//		IParamBlock2* GetParamBlockByID(BlockID id) { return (pblock2->ID() == id) ? pblock2 : NULL; } // return id'd ParamBlock


		int NumSubs();  //nmumber of blocks
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);
		void DeleteThis() {delete this;}		

		void AddNewKey(TimeValue t,DWORD flags);
		void CloneSelectedKeys(BOOL offset);
		void DeleteKeys(DWORD flags);
		void SelectKeys(TrackHitTab& sel, DWORD flags);
		BOOL IsKeySelected(int index);

//		int TrackParamsType() {return TRACKPARAMS_NONE;}


		void HoldRange();
		BOOL AssignController(Animatable *control,int subAnim);

	
		void CopyKeysFromTime(TimeValue src,TimeValue dst,DWORD flags);
		void DeleteKeyAtTime(TimeValue t);
		BOOL IsKeyAtTime(TimeValue t,DWORD flags);
		BOOL GetNextKeyTime(TimeValue t,DWORD flags,TimeValue &nt);
		int GetKeyTimes(Tab<TimeValue> &times,Interval range,DWORD flags);
		int GetKeySelState(BitArray &sel,Interval range,DWORD flags);

//		int SubNumToRefNum(int subNum);
//int SubNumToRefNum(int subNum) {if (subNum==0) return PATHPOS_PBLOCK_REF; else return -1;}
		int NumRefs();
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);


		// Reference methods
//		RefResult NotifyRefChanged(Interval, RefTargetHandle, PartID&, RefMessage) {return REF_SUCCEED;}
		RefResult NotifyRefChanged(
				Interval changeInt, 
				RefTargetHandle hTarget, 
     			PartID& partID,  
     			RefMessage message);

		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);

		// Control methods				
		void Copy(Control *from);// {}
		BOOL IsLeaf() {return TRUE;}
		void CommitValue(TimeValue t) {sub->CommitValue(t);}
		void RestoreValue(TimeValue t) {sub->RestoreValue(t);}		
		BOOL IsReplaceable() {return TRUE;}
		
		// From INoiseControl

//		void HoldRange();
		Interval GetTimeRange(DWORD flags) {
//			if (masterPresent)
//				return master->range;
//			else
//				{
				Interval iv;
				iv.SetEmpty();
				return iv;
//				}
			}
		void EditTimeRange(Interval range,DWORD flags);
		void MapKeys(TimeMap *map,DWORD flags );



		Class_ID ClassID() { return SLAVE_CONTROL_CLASS_ID; }  
		SClass_ID SuperClassID() { return CTRL_FLOAT_CLASS_ID; } 
		void GetClassName(TSTR& s) {s = SLAVE_CONTROL_CNAME;}

		// Control methods
		RefTargetHandle Clone(RemapDir& remap);


		void RemoveControl(int sel);
		void AddControl(int blockid,int subid );
		void CollapseControl();

		virtual void UpdateSlave() {}

		// StdControl methods
/*
		void GetValueLocalTime(TimeValue t, void *val, Interval &valid, GetSetMethod method=CTRL_ABSOLUTE);
		void SetValueLocalTime(TimeValue t, void *val, int commit, GetSetMethod method) {}		
		void Extrapolate(Interval range,TimeValue t,void *val,Interval &valid,int type);		
		void *CreateTempValue() {return new float;}
		void DeleteTempValue(void *val) {delete (float*)val;}
		void ApplyValue(void *val, void *delta) {*((float*)val) += *((float*)delta);}
		void MultiplyValue(void *val, float m) {*((float*)val) *= m;}
*/
	};

/*
class SlaveClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { return new SlaveControl(); }
	const TCHAR *	ClassName() { return SLAVE_CONTROL_CNAME; }
	SClass_ID		SuperClassID() { return CTRL_FLOAT_CLASS_ID; }
	Class_ID		ClassID() { return SLAVE_CONTROL_CLASS_ID; }
	const TCHAR* 	Category() { return _T("");  }
// JBW: new descriptor data accessors added.
	const TCHAR*	InternalName() { return _T("SlaveBlock"); }			// returns fixed parsable name (scripter-visible name)
	HINSTANCE		HInstance() { return hInstance; }				// returns owning module handle

	};
*/

class SlaveFloatControl : public SlaveControl {
	public:		
	
		SlaveFloatControl();
		

		// Animatable methods		
//void DeleteThis() {delete this;}		

//		void SetValue(TimeValue t, void *val, int commit, GetSetMethod method);
		void GetValue(TimeValue t, void *val, Interval &valid, GetSetMethod method);
		Class_ID ClassID() { return SLAVEFLOAT_CONTROL_CLASS_ID; }  
//		SClass_ID SuperClassID() { return CTRL_FLOAT_CLASS_ID; } 
		void GetClassName(TSTR& s) {s = SLAVEFLOAT_CONTROL_CNAME;}
		void UpdateSlave();
		// Control methods
		RefTargetHandle Clone(RemapDir& remap);


// Reference methods
//RefResult NotifyRefChanged(Interval, RefTargetHandle, PartID&, RefMessage) {return REF_SUCCEED;}
	};

class SlaveFloatClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { return new SlaveFloatControl(); }
	const TCHAR *	ClassName() { return SLAVEFLOAT_CONTROL_CNAME; }
	SClass_ID		SuperClassID() { return CTRL_FLOAT_CLASS_ID; }
	Class_ID		ClassID() { return SLAVEFLOAT_CONTROL_CLASS_ID; }
	const TCHAR* 	Category() { return _T("");  }
// JBW: new descriptor data accessors added.
	const TCHAR*	InternalName() { return _T("SlaveFloat"); }			// returns fixed parsable name (scripter-visible name)
	HINSTANCE		HInstance() { return hInstance; }				// returns owning module handle

	};


class SlavePosControl : public SlaveControl {
	public:		

		SlavePosControl();
		void GetValue(TimeValue t, void *val, Interval &valid, GetSetMethod method);
		Class_ID ClassID() { return SLAVEPOS_CONTROL_CLASS_ID; }  
		SClass_ID SuperClassID() { return CTRL_POSITION_CLASS_ID; } 
		void GetClassName(TSTR& s) {s = SLAVEPOS_CONTROL_CNAME;}
		void UpdateSlave(); 
		// Control methods
		RefTargetHandle Clone(RemapDir& remap);
	};


class SlavePosClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { return new SlavePosControl(); }
	const TCHAR *	ClassName() { return SLAVEPOS_CONTROL_CNAME; }
	SClass_ID		SuperClassID() { return CTRL_POSITION_CLASS_ID; }
	Class_ID		ClassID() { return SLAVEPOS_CONTROL_CLASS_ID; }
	const TCHAR* 	Category() { return _T("");  }
// JBW: new descriptor data accessors added.
	const TCHAR*	InternalName() { return _T("SlavePos"); }			// returns fixed parsable name (scripter-visible name)
	HINSTANCE		HInstance() { return hInstance; }				// returns owning module handle

	};


class SlavePoint3Control : public SlaveControl {
	public:		

		SlavePoint3Control();
		void GetValue(TimeValue t, void *val, Interval &valid, GetSetMethod method);
		Class_ID ClassID() { return SLAVEPOINT3_CONTROL_CLASS_ID; }  
		SClass_ID SuperClassID() { return CTRL_POINT3_CLASS_ID; } 
		void GetClassName(TSTR& s) {s = SLAVEPOINT3_CONTROL_CNAME;}
		void UpdateSlave();
		// Control methods
		RefTargetHandle Clone(RemapDir& remap);
	};


class SlavePoint3ClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { return new SlavePoint3Control(); }
	const TCHAR *	ClassName() { return SLAVEPOINT3_CONTROL_CNAME; }
	SClass_ID		SuperClassID() { return CTRL_POINT3_CLASS_ID; }
	Class_ID		ClassID() { return SLAVEPOINT3_CONTROL_CLASS_ID; }
	const TCHAR* 	Category() { return _T("");  }
// JBW: new descriptor data accessors added.
	const TCHAR*	InternalName() { return _T("SlavePoint3"); }			// returns fixed parsable name (scripter-visible name)
	HINSTANCE		HInstance() { return hInstance; }				// returns owning module handle

	};



class SlaveRotationControl : public SlaveControl {
	public:		

		SlaveRotationControl();
		void GetValue(TimeValue t, void *val, Interval &valid, GetSetMethod method);

		Class_ID ClassID() { return SLAVEROTATION_CONTROL_CLASS_ID; }  
		SClass_ID SuperClassID() { return CTRL_ROTATION_CLASS_ID; } 
		void GetClassName(TSTR& s) {s = SLAVEROTATION_CONTROL_CNAME;}
		void UpdateSlave();

		// Control methods
		RefTargetHandle Clone(RemapDir& remap);

	};




class SlaveRotationClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { return new SlaveRotationControl(); }
	const TCHAR *	ClassName() { return SLAVEROTATION_CONTROL_CNAME; }
	SClass_ID		SuperClassID() { return CTRL_ROTATION_CLASS_ID; }
	Class_ID		ClassID() { return SLAVEROTATION_CONTROL_CLASS_ID; }
	const TCHAR* 	Category() { return _T("");  }
// JBW: new descriptor data accessors added.
	const TCHAR*	InternalName() { return _T("SlaveRotation"); }			// returns fixed parsable name (scripter-visible name)
	HINSTANCE		HInstance() { return hInstance; }				// returns owning module handle

	};



class SlaveScaleControl : public SlaveControl {
	public:		

		SlaveScaleControl();
		void GetValue(TimeValue t, void *val, Interval &valid, GetSetMethod method);

		Class_ID ClassID() { return SLAVESCALE_CONTROL_CLASS_ID; }  
		SClass_ID SuperClassID() { return CTRL_SCALE_CLASS_ID; } 
		void GetClassName(TSTR& s) {s = SLAVESCALE_CONTROL_CNAME;}
		void UpdateSlave();
		// Control methods
		RefTargetHandle Clone(RemapDir& remap);


	};

class SlaveScaleClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { return new SlaveScaleControl(); }
	const TCHAR *	ClassName() { return SLAVESCALE_CONTROL_CNAME; }
	SClass_ID		SuperClassID() { return CTRL_SCALE_CLASS_ID; }
	Class_ID		ClassID() { return SLAVESCALE_CONTROL_CLASS_ID; }
	const TCHAR* 	Category() { return _T("");  }
// JBW: new descriptor data accessors added.
	const TCHAR*	InternalName() { return _T("SlaveScale"); }			// returns fixed parsable name (scripter-visible name)
	HINSTANCE		HInstance() { return hInstance; }				// returns owning module handle

	};


class RangeRestore : public RestoreObj {
	public:
		MasterBlockControl *cont;
		Interval ur, rr;
		RangeRestore(MasterBlockControl *c) 
			{
			cont = c;
			ur   = cont->range;
			}   		
		void Restore(int isUndo) 
			{
			rr = cont->range;
			cont->range = ur;

			cont->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
			}
		void Redo()
			{
			cont->range = rr;
			cont->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
			}		
		void EndHold() 
			{ 
			cont->ClearAFlag(A_HELD);
			}
		TSTR Description() { return TSTR(_T(GetString(IDS_PW_RANGE))); }
	};


class MasterBlockRest : public RestoreObj {
	public:
		Tab<BlockKeysClass> undo, redo;
		Interval ur, rr;
		
		MasterBlockControl *cont;

		MasterBlockRest(MasterBlockControl *c) { 
			cont = c;
			undo = c->BlockKeys;
			ur   = cont->range;

			}
		~MasterBlockRest() {}
		void Restore(int isUndo) {
			if (isUndo) {
				if (redo.Count()!=cont->BlockKeys.Count()) {
					redo = cont->BlockKeys;
					rr = cont->range;
					}
				}
			cont->BlockKeys = undo;
			cont->range = ur;
			cont->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
			}
		void Redo() {
			cont->BlockKeys = redo;
			cont->range  = rr;
			cont->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
			}               
		void EndHold() { 
			cont->ClearAFlag(A_HELD);
			}
		TSTR Description() { return TSTR(_T(GetString(IDS_PW_RESTORE))); }
	};


class MasterBlockAddKey : public RestoreObj {
	public:
		Tab<BlockKeysClass> undo, redo;
		MasterBlockControl *cont;
		Interval ur, rr;

		MasterBlockAddKey(MasterBlockControl *c) { 
			cont = c;
			undo = c->BlockKeys;
			ur = c->range;
			}
		~MasterBlockAddKey() {}
		void Restore(int isUndo) {
			if (isUndo) {
				if (redo.Count()!=cont->BlockKeys.Count()) {
					redo = cont->BlockKeys;
					}
				rr = cont->range;
				}
			cont->BlockKeys = undo;
			cont->range = ur;
			cont->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
			for (int i = 0; i < cont->Blocks.Count();i++)
				{
				cont->Blocks[i]->NotifySlaves();
				}

			}
		void Redo() {
			cont->BlockKeys = redo;
			cont->range = rr;

			cont->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
			for (int i = 0; i < cont->Blocks.Count();i++)
				{
				cont->Blocks[i]->NotifySlaves();
				}

			}               
		void EndHold() { 
			cont->ClearAFlag(A_HELD);
			}
		TSTR Description() { return TSTR(_T(GetString(IDS_PW_ADDKEY))); }
	};

class MasterBlockDeleteKey : public RestoreObj {
	public:
		Tab<BlockKeysClass> undo, redo;
		MasterBlockControl *cont;
		Interval ur, rr;

		MasterBlockDeleteKey(MasterBlockControl *c) { 
			cont = c;
			undo = c->BlockKeys;
			ur = c->range;
			}
		~MasterBlockDeleteKey() {}
		void Restore(int isUndo) {
			if (isUndo) {
				if (redo.Count()!=cont->BlockKeys.Count()) {
					redo = cont->BlockKeys;
					}
				rr = cont->range;
				}
			cont->BlockKeys = undo;
			cont->range = ur;
			cont->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
			for (int i = 0; i < cont->Blocks.Count();i++)
				{
				cont->Blocks[i]->NotifySlaves();
				}

			}
		void Redo() {
			cont->BlockKeys = redo;
			cont->range = rr;
			cont->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
			for (int i = 0; i < cont->Blocks.Count();i++)
				{
				cont->Blocks[i]->NotifySlaves();
				}

			}               
		void EndHold() { 
			cont->ClearAFlag(A_HELD);
			}
		TSTR Description() { return TSTR(_T(GetString(IDS_PW_DELETEKEY))); }
	};



class MasterBlockAdd : public RestoreObj {
	public:
		Tab<BlockControl*> undo, redo;
		MasterBlockControl *cont;

		MasterBlockAdd(MasterBlockControl *c) { 
			cont = c;
			undo = c->Blocks;
			}
		~MasterBlockAdd() {}
		void Restore(int isUndo) {
			if (isUndo) {
					redo = cont->Blocks;
					}
			cont->Blocks = undo;
			cont->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
			}
		void Redo() {
			cont->Blocks = redo;

			cont->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
			}               
		void EndHold() { 
			cont->ClearAFlag(A_HELD);
			}
		TSTR Description() { return TSTR(_T(GetString(IDS_PW_ADDBLOCK))); }
	};


class MasterBlockDlg 
{

//: public ReferenceMaker, public TimeChangeCallback {
	public:
		MasterBlockControl *cont;	
		ParamDimensionBase *dim;
		IObjParam *ip;
		HWND hWnd;
		BOOL valid;
		int elems;

		MasterBlockDlg(
			MasterBlockControl *cont,
			ParamDimensionBase *dim,
			TCHAR *pname,
			IObjParam *ip,
			HWND hParent);
		~MasterBlockDlg();

//		Class_ID ClassID() {return Class_ID(MASTERBLOCKDLG_CLASS_ID,0);}
//		SClass_ID SuperClassID() {return REF_MAKER_CLASS_ID;}

		void MaybeCloseWindow();

//		void TimeChanged(TimeValue t) {Invalidate();}

		void Invalidate();
		void SetupList();
		void SetButtonStates();
		void EnableButtons();

		void Update();
		void SetupUI(HWND hWnd);
		void Change(BOOL redraw=FALSE);
		void WMCommand(int id, int notify, HWND hCtrl);

//		RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
//	         PartID& partID,  RefMessage message);
//		int NumRefs() {return 1;}
//		RefTargetHandle GetReference(int i) {return cont;}
//		void SetReference(int i, RefTargetHandle rtarg) {cont=(MasterBlockControl*)rtarg;}
	};

class SlaveDlg : public ReferenceMaker{//, public TimeChangeCallback {
	public:
		SlaveControl *cont;	
		ParamDimensionBase *dim;
		IObjParam *ip;
		HWND hWnd;
		BOOL valid;
		int elems;

		SlaveDlg(
			SlaveControl *cont,
			ParamDimensionBase *dim,
			TCHAR *pname,
			IObjParam *ip,
			HWND hParent);
		~SlaveDlg();

		Class_ID ClassID() {return Class_ID(MASTERBLOCKDLG_CLASS_ID,0);}
		SClass_ID SuperClassID() {return REF_MAKER_CLASS_ID;}

		void MaybeCloseWindow();

//		void TimeChanged(TimeValue t) {Invalidate();}

		void Invalidate();
		void SetupList();
		void SetButtonStates();

		void Update();
		void SetupUI(HWND hWnd);
		void Change(BOOL redraw=FALSE);
		void WMCommand(int id, int notify, HWND hCtrl);

		RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
	         PartID& partID,  RefMessage message);
		int NumRefs() {return 1;}
		RefTargetHandle GetReference(int i) {return cont;}
		void SetReference(int i, RefTargetHandle rtarg) {cont=(SlaveControl*)rtarg;}
	};




class MasterBlockTrackViewFilter :public TrackViewFilter

{
BOOL proc(Animatable *anim, Animatable *client,int subNum);
};

class MasterBlockTrackViewFilterAdd :public TrackViewFilter

{
BOOL proc(Animatable *anim, Animatable *client,int subNum);
};


class MasterTrackViewFilter :public TrackViewFilter

{
BOOL proc(Animatable *anim, Animatable *client,int subNum);
};

class MasterMatchNodeViewFilter :public TrackViewFilter

{
BOOL proc(Animatable *anim, Animatable *client,int subNum);
};


//dummy object to save the data



// JBW: IParamArray has gone since the class variable UI paramters are stored in static ParamBlocks
//      all corresponding class vars have gone, including the ParamMaps since they are replaced 
//      by the new descriptors

// block IDs

enum { container_params };
// geo_param param IDs
enum { container_refs, container_color, container_start, container_end,container_names,container_blockname};

class ControlContainerObject : public SimpleObject2
{
	public:	
		// Class vars
		static IObjParam *ip;

//		IParamBlock2 *pblock2;


// JBW: minimal constructor, call MakeAutoParamBlocks() on my ClassDesc to
//      have all the declared per-instance P_AUTO_CONSTRUCT blocks made, initialized and
//      wired in.
		ControlContainerObject();
//		{ 
//				GetGSphereDesc()->MakeAutoParamBlocks(this); 
//				}
		
		CreateMouseCallBack* GetCreateMouseCallBack();
		void BeginEditParams( IObjParam  *ip, ULONG flags, Animatable *prev);
		void EndEditParams( IObjParam *ip, ULONG flags, Animatable *next);
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() { return CONTROLCONTAINER_CNAME; }
		BOOL HasUVW();
		void SetGenUVW(BOOL sw);
		
		// From Object
		int CanConvertToType(Class_ID obtype);
		Object* ConvertToType(TimeValue t, Class_ID obtype);
		void GetCollapseTypes(Tab<Class_ID> &clist, Tab<TSTR*> &nlist);

		
		// Animatable methods		
		void DeleteThis() {delete this;}
		Class_ID ClassID() { return CONTROLCONTAINER_CLASS_ID; } 
// JBW: direct ParamBlock access is added
		int	NumParamBlocks() { return 1; }					// return number of ParamBlocks in this instance
		IParamBlock2* GetParamBlock(int i) { return pblock2; } // return i'th ParamBlock
		IParamBlock2* GetParamBlockByID(BlockID id) { 
			return (pblock2->ID() == id) ? pblock2 : NULL; 
			} // return id'd ParamBlock

// JBW: the Load() post-load callback insertion has gone since versioning is 
//		handled automatically by virtue of permanent parameter IDs.  These IDs
//		are defined in enums and are never retired so that old versions can be
//		automatically re-mapped to new ones
//
//      Note that this is only true in new plug-ins; old plug-ins need to 
//		continue to support version re-mapping as before for version up until
//		converting to the new descriptors
//IOResult Load(ILoad *iload);
		
// JBW: all the IParamArray methods are gone since we don't need them for the class variables

		// From SimpleObject
		void BuildMesh(TimeValue t);
		BOOL OKtoDisplay(TimeValue t);
		void InvalidateUI();
// JBW: the GetParamName() and GetParamDim() function have gone	as this all 
//      is available in the descriptors. REFMSG_GET_PARAM_NAME, etc. become unnecessary as well
};

// in prim.cpp  - The dll instance handle
extern HINSTANCE hInstance;


// The class descriptor for gsphere
class ControlContainerClassDesc: public ClassDesc2 
{
	public:
	int 			IsPublic() { return 0; }
	void *			Create(BOOL loading = FALSE) { return new ControlContainerObject; }
	const TCHAR *	ClassName() { return CONTROLCONTAINER_CNAME; }
	SClass_ID		SuperClassID() { return GEOMOBJECT_CLASS_ID; }
	Class_ID		ClassID() { return CONTROLCONTAINER_CLASS_ID; }
	const TCHAR* 	Category() { return GetString(IDS_PW_HOLDER); }
// JBW:  the ResetClassParams() has gone since this is automatic now
//       using the default values in the descriptors

// JBW: new descriptor data accessors added.  Note that the 
//      internal name is hardwired since it must not be localized.
	const TCHAR*	InternalName() { return _T("controlContainer"); }	// returns fixed parsable name (scripter-visible name)
	HINSTANCE		HInstance() { return hInstance; }			// returns owning module handle
};

class MyEnumProc : public DependentEnumProc 
	{
      public :
      virtual int proc(ReferenceMaker *rmaker); 
      INodeTab Nodes;              
	  TSTR name;
	};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Control\Reactor\reactor.h ===
/**********************************************************************
 *<
	FILE: reactor.h

	DESCRIPTION: Header file for Reactor Controller

	CREATED BY: Adam Felt

	HISTORY:

 *>	Copyright (c) 1998-1999 Adam Felt, All Rights Reserved.
 **********************************************************************/

#ifndef __REACTOR__H
#define __REACTOR__H


#include "Max.h"
#include "resource.h"
#include "KbdShortcut.h"
#include "Maxscrpt.h"
#include "definsfn.h"

extern ClassDesc* GetFloatReactorDesc();
extern ClassDesc* GetPositionReactorDesc();
extern ClassDesc* GetPoint3ReactorDesc();
extern ClassDesc* GetRotationReactorDesc();
extern ClassDesc* GetScaleReactorDesc();

extern HINSTANCE hInstance;

TCHAR *GetString(int id);

//-----------------------------------------------



//--------------------------------------------------------------------------

// Keyboard Shortcuts stuff
const ShortcutTableId kReactorShortcuts = 0x6bd55e20;

#define NumElements(array) (sizeof(array) / sizeof(array[0]))

ShortcutTable* GetShortcuts();

template <class T>
class ReactorShortcutCB : public ShortcutCallback
{
	public:
		T*		reactor;
				ReactorShortcutCB(T *reactor) { this->reactor = reactor; }
		BOOL	KeyboardShortcut(int id); 
};


template <class T>
BOOL ReactorShortcutCB<T>::KeyboardShortcut(int id)
{
	switch (id)
	{
	case ID_MIN_INFLUENCE:
		reactor->setMinInfluence();
		break;
	case ID_MAX_INFLUENCE:
		reactor->setMaxInfluence();
		break;
	case ID_CREATE_REACTION:
		reactor->CreateReaction();
		break;
	case ID_DELETE_REACTION:
		reactor->DeleteReaction();
		break;
	case ID_SET_VALUE:
		reactor->setReactionValue();
		break;
	case ID_EDIT_STATE:
		reactor->editing = (reactor->editing == FALSE ? TRUE : FALSE);  //toggle the editing state
		reactor->dlg->iEditBut->SetCheck(reactor->editing);
		reactor->setEditing(reactor->editing);
		break;
	}
	return TRUE;
}

#endif // __REACTOR__H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Control\block\slave.cpp ===
/**********************************************************************
 *<
	FILE: slave.cpp

	DESCRIPTION: A slave controller that is driven by the master and the sub control

	CREATED BY: Peter Watje

	HISTORY: Oct 15, 1998

 *>	Copyright (c) 1998, All Rights Reserved.
 **********************************************************************/
#include "block.h"
#include "units.h"
#include "masterblock.h"
#include "istdplug.h"


//#include "iparamm2.h"


										   

static SlaveFloatClassDesc slaveFloatCD;
ClassDesc* GetSlaveFloatDesc() {return &slaveFloatCD;}


static SlavePosClassDesc slavePosCD;
ClassDesc* GetSlavePosDesc() {return &slavePosCD;}

static SlavePoint3ClassDesc slavePoint3CD;
ClassDesc* GetSlavePoint3Desc() {return &slavePoint3CD;}


static SlaveRotationClassDesc slaveRotationCD;
ClassDesc* GetSlaveRotationDesc() {return &slaveRotationCD;}

static SlaveScaleClassDesc slaveScaleCD;
ClassDesc* GetSlaveScaleDesc() {return &slaveScaleCD;}



BOOL CALLBACK NewLinkDlgProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK NewMasterDlgProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

//------------------------------------------------------------

SlaveControl::SlaveControl() 
	{	
	range     = Interval(GetAnimStart(),GetAnimEnd());
	master = NULL;
	scratchControl = NULL;
	sub = NULL;
	float v = 50.0f;
	masterPresent = FALSE;

	} 

SlaveControl::~SlaveControl() 
	{	
	int ct = blockID.Count();
	for (int i = 0; i < ct; i++)
		RemoveControl(0);

	if (scratchControl)
		{
		scratchControl->DeleteThis();
		}
	scratchControl = NULL;
	} 

int SlaveControl::NumSubs() 
	{
//	return 1;
	return 0;
	}


void SlaveControl::SetValue(TimeValue t, void *val, int commit, GetSetMethod method)
	{
//	sub->SetValue(t,val,commit,method);
	}

void SlaveControl::EnumIKParams(IKEnumCallback &callback)
	{
	if (scratchControl)
		scratchControl->EnumIKParams(callback);
	}

BOOL SlaveControl::CompDeriv(TimeValue t,Matrix3& ptm,IKDeriv& derivs,DWORD flags)
	{
	if (scratchControl)
		return scratchControl->CompDeriv(t,ptm,derivs,flags);
	else return FALSE;
	}

void SlaveControl::MouseCycleCompleted(TimeValue t)
	{
	if (scratchControl)
		scratchControl->MouseCycleCompleted(t);
	}

void SlaveControl::AddNewKey(TimeValue t,DWORD flags)
	{
	if (scratchControl)
		scratchControl->AddNewKey(t,flags);
	}

void SlaveControl::CloneSelectedKeys(BOOL offset)
	{
	if (scratchControl)
		scratchControl->CloneSelectedKeys(offset);
	}

void SlaveControl::DeleteKeys(DWORD flags)
	{
	if (scratchControl)
		scratchControl->DeleteKeys(flags);
	}

void SlaveControl::SelectKeys(TrackHitTab& sel, DWORD flags)
	{
	if (scratchControl)
		scratchControl->SelectKeys(sel,flags);
	}

BOOL SlaveControl::IsKeySelected(int index)
	{
	if (scratchControl)
		return scratchControl->IsKeySelected(index);
	return FALSE;
	}

void SlaveControl::CopyKeysFromTime(TimeValue src,TimeValue dst,DWORD flags)
	{
	if (scratchControl)
		scratchControl->CopyKeysFromTime(src,dst,flags);

	}

void SlaveControl::DeleteKeyAtTime(TimeValue t)
	{
	if (scratchControl)
		scratchControl->DeleteKeyAtTime(t);
	}

BOOL SlaveControl::IsKeyAtTime(TimeValue t,DWORD flags)
	{
	if (scratchControl)
		return scratchControl->IsKeyAtTime(t,flags);
	return FALSE;
	}

BOOL SlaveControl::GetNextKeyTime(TimeValue t,DWORD flags,TimeValue &nt)
	{
	if (scratchControl)
		return scratchControl->GetNextKeyTime(t,flags,nt);
	return FALSE;
	}

int SlaveControl::GetKeyTimes(Tab<TimeValue> &times,Interval range,DWORD flags)
	{
	if (scratchControl)
		return scratchControl->GetKeyTimes(times,range,flags);
	return 0;
	}

int SlaveControl::GetKeySelState(BitArray &sel,Interval range,DWORD flags)
	{
	if (scratchControl)
		return scratchControl->GetKeySelState(sel,range,flags);
	return 0;
	}




Animatable* SlaveControl::SubAnim(int i) 
	{
//	if (i==0)
//		return sub;
//	else 
//		{
//		DebugPrint("Subanims out of range call\n");
		return NULL;
//		}
	}


TSTR SlaveControl::SubAnimName(int i) 
	{
	return GetString(IDS_PW_SUB);
	}




BOOL SlaveControl::AssignController(Animatable *control,int subAnim) 
	{
	return FALSE;
	}


int SlaveControl::NumRefs() 
	{
	return 2;
	}

RefTargetHandle SlaveControl::GetReference(int i) 
	{
	if (i==0) return (RefTargetHandle) sub;
	else if (i==1) return (RefTargetHandle) master;
	else
		{
//		DebugPrint("get reference error occurred\n");
		return NULL;
		}
	}

void SlaveControl::SetReference(int i, RefTargetHandle rtarg) 
	{
	if (i==0) sub = (Control*) rtarg;
	else if (i==1) 
		{
		if ((rtarg == NULL) && (master))
			{
//tell the master that I am being removed
			int ct = blockID.Count();
			for (int i = 0; i < ct; i++)
				RemoveControl(0);

			}

		master = (MasterBlockControl*) rtarg;
		if (master == NULL) masterPresent = FALSE;
			else masterPresent = TRUE;
		}
	else DebugPrint("set reference error occurred\n");

	}


void SlaveControl::Copy(Control *from)
	{
	if ( from->CanCopyTrack(FOREVER,0) )
		ReplaceReference(0,from);
	superID = from->SuperClassID();
//	scratchControl->Copy(from);
//	MakeRefByID(FOREVER,0,from);
	}

/*
void SlaveControl::HoldRange()
	{
	if (theHold.Holding() && !TestAFlag(A_HELD)) {
		SetAFlag(A_HELD);
		theHold.Put(new RangeRestore(this));
		}
	}

*/

RefResult SlaveControl::NotifyRefChanged(
		Interval changeInt, 
		RefTargetHandle hTarget, 
     	PartID& partID,  
     	RefMessage message)
	{
	switch (message) {

		case REFMSG_TARGET_DELETED:
			if (hTarget == master) {
				masterPresent = FALSE;
				}

			break;
		case REFMSG_CHANGE:
//			UpdateSlave();			
			break;


		}
	return REF_SUCCEED;
	}



class SlaveRangeRestore : public RestoreObj {
	public:
		SlaveControl *cont;
		Interval ur, rr;
		SlaveRangeRestore(SlaveControl *c) 
			{
			cont = c;
			ur   = cont->range;
			}   		
		void Restore(int isUndo) 
			{
			rr = cont->range;
			cont->range = ur;
			cont->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
			}
		void Redo()
			{
			cont->range = rr;
			cont->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
			}		
		void EndHold() 
			{ 
			cont->ClearAFlag(A_HELD);
			}
		TSTR Description() { return TSTR(_T("Slave control range")); }
	};


void SlaveControl::HoldRange()
	{
	if (theHold.Holding() && !TestAFlag(A_HELD)) {
		SetAFlag(A_HELD);
		theHold.Put(new SlaveRangeRestore(this));
		}
	}

void SlaveControl::EditTimeRange(Interval range,DWORD flags)
	{
/*
	if (!(flags&EDITRANGE_LINKTOKEYS)) {
		HoldRange();
		this->range = range;
		NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
		}
*/
	}

void SlaveControl::MapKeys(TimeMap *map,DWORD flags)
	{
/*
	if (flags&TRACK_MAPRANGE) {
		HoldRange();
		TimeValue t0 = map->map(range.Start());
		TimeValue t1 = map->map(range.End());

		range.Set(t0,t1);
		NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
		}
*/
	}
void SlaveControl::RemoveControl(int sel)

{
if (master)
	{
	if (blockID[sel] < master->Blocks.Count() )
		{
		for (int i = 0; i <master->Blocks[blockID[sel]]->externalBackPointers.Count(); i++)
			{ 
			if ( this == master->Blocks[blockID[sel]]->externalBackPointers[i])
				{
				master->Blocks[blockID[sel]]->externalBackPointers.Delete(i,1);
				i--;
				}
			}
		for (i = 0; i <master->Blocks[blockID[sel]]->backPointers.Count(); i++)
			{ 
			if ( this == master->Blocks[blockID[sel]]->backPointers[i])
				{
				master->Blocks[blockID[sel]]->backPointers[i]= NULL;
				}
			}
		}
	}
blockID.Delete(sel,1);
subID.Delete(sel,1);

}

void SlaveControl::AddControl(int blockid,int subid )
{
blockID.Append(1,&blockid,1);
subID.Append(1,&subid,1);
SlaveControl *sl = this;
master->Blocks[blockid]->externalBackPointers.Append(1,&sl,1);
if (sub == NULL)
	{
	ReplaceReference(0,master->Blocks[blockid]->controls[subid]->Clone());
	}
}

void SlaveControl::CollapseControl()
{
#define ID_TV_GETSELECTED	680

Tab<TrackViewPick> res;
res.ZeroCount();
SendMessage(trackHWND,WM_COMMAND,ID_TV_GETSELECTED,(LPARAM)&res);
if (res.Count() == 1)
	{
	if (masterPresent)
		{
		Control *mc = (Control *) master->blendControl->Clone();

		for (int ct = 0; ct < scratchControl->NumMultCurves(); ct++)
			scratchControl->DeleteMultCurve(ct);
		scratchControl->AppendMultCurve(mc);
		}
	int ct = blockID.Count();
	for (int i = 0; i < ct; i++)
		RemoveControl(0);

	res[0].client->AssignController(scratchControl->Clone(),res[0].subNum);


//	Control *mc = (Control *) res[0].client;
//	mc->AppendMultCurve(master->blendControl);



	NotifyDependents(FOREVER,0,REFMSG_CHANGE);
	NotifyDependents(FOREVER,0,REFMSG_SUBANIM_STRUCTURE_CHANGED);
//	DeleteReference(0);
//	DeleteReference(1);
//	this->DeleteThis();
	}

		// Get Interfaces
//Interface *iu = GetCOREInterface();
//Animatable *anim   = iu->GetAnim(i);
//Animatable *client = iu->GetClient(i);
//int subNum         = iu->GetSubNum(i);

//scratchControl
//list->

}


#define COUNT_CHUNK		0x01010
#define DATA_CHUNK		0x01020


IOResult SlaveControl::Save(ISave *isave)
	{		
	ULONG nb;	
//count
	int count = blockID.Count();
	isave->BeginChunk(COUNT_CHUNK);
	isave->Write(&count,sizeof(count),&nb);			
	isave->EndChunk();
//id data 
	for (int i =0; i < count; i++)
		{
		isave->BeginChunk(DATA_CHUNK);
		isave->Write(&blockID[i],sizeof(int),&nb);			
		isave->Write(&subID[i],sizeof(int),&nb);			
		isave->EndChunk();
		}
	return IO_OK;
	}

IOResult SlaveControl::Load(ILoad *iload)
	{
	int ID =  0;
	ULONG nb;
	IOResult res = IO_OK;
	int ix = 0;
	while (IO_OK==(res=iload->OpenChunk())) 
		{
		ID = iload->CurChunkID();
		if (ID ==COUNT_CHUNK)
			{
			int ct;
			iload->Read(&ct, sizeof(ct), &nb);
			blockID.SetCount(ct);
			subID.SetCount(ct);
/*
			for (int i=0; i<ct; i++) 
				{
				names[i] = NULL;
				controls[i] = NULL;
				tempControls[i] = NULL;
				}
*/

			}
		else if (ID == DATA_CHUNK)
			{
			int bID,sID;
			iload->Read(&bID, sizeof(int), &nb);
			iload->Read(&sID, sizeof(int), &nb);
			blockID[ix] = bID;
			subID[ix++] = sID;
			}
		iload->CloseChunk();
		if (res!=IO_OK)  return res;
		}

//rebuild all tempcontrols	
	return IO_OK;
	}


//--------------------------------------------------------------------


RefTargetHandle SlaveControl::Clone(RemapDir& remap)
	{
	SlaveControl *cont = new SlaveControl;
//	*cont = *this;
	cont->sub = NULL;
	cont->master = NULL;
	cont->scratchControl = NULL;

	cont->ReplaceReference(0,sub);
	cont->ReplaceReference(1,master);
	cont->blockID = blockID;
	cont->subID = subID;
	cont->masterPresent = masterPresent;
//	if (master)
//		master->Blocks[blockID]->externalBackPointers.Append(1,&cont,1);

	CloneControl(cont,remap);
	cont->UpdateSlave();
	return cont;
	}


void SlaveControl::GetValue(TimeValue t, void *val, Interval &valid, GetSetMethod method)
{
}

//------------------------------------------------------------
//Slave Float Controller
//------------------------------------------------------------

RefTargetHandle SlaveFloatControl::Clone(RemapDir& remap)
	{
	SlaveFloatControl *cont = new SlaveFloatControl;
//	*cont = *this;
	cont->sub = NULL;
	cont->master = NULL;
	cont->scratchControl = NULL;

	cont->ReplaceReference(0,sub);
	cont->ReplaceReference(1,master);
	cont->blockID = blockID;
	cont->subID = subID;
	cont->masterPresent = masterPresent;
	if (master)
		{
		for (int i = 0; i < blockID.Count(); i++)
			{
			SlaveControl *c = (SlaveControl *)cont;
			master->Blocks[blockID[i]]->externalBackPointers.Append(1,&c,1);
			}
		}
	CloneControl(cont,remap);
	cont->UpdateSlave();
	return cont;
	}

SlaveFloatControl::SlaveFloatControl() 
	{	

	} 

void SlaveFloatControl::UpdateSlave()
{
	if (scratchControl == NULL)
		scratchControl = (Control *) sub->Clone();
	scratchControl->DeleteKeys(TRACK_DOALL);
	float f = 0.0f;
	scratchControl->SetValue(0,&f);
	if (master)
		master->Update(scratchControl,blockID,subID);

}

void SlaveFloatControl::GetValue(
		TimeValue t, void *val, Interval &valid, GetSetMethod method)
	{
	if ( (sub == NULL) || (!masterPresent) || (blockID.Count()==0))
		{
		if (method == CTRL_ABSOLUTE)
			{
			float *v = ((float*)val);
			*v = 0.0f;
			}
		return;
		}
//copy keys into scratch control


	if (scratchControl == NULL)
		{
		UpdateSlave();
		}
	float *tv = ((float*)val);

	if (master)
		master->GetValue3(scratchControl,t,val,valid,blockID,subID,range,method);
//	cpy->DeleteThis();

	}



//------------------------------------------------------------
//Slave Pos Controller
//------------------------------------------------------------

RefTargetHandle SlavePosControl::Clone(RemapDir& remap)
	{
	SlavePosControl *cont = new SlavePosControl;
//	*cont = *this;
	cont->sub = NULL;
	cont->master = NULL;
	cont->scratchControl = NULL;
	cont->ReplaceReference(0,sub);
	cont->ReplaceReference(1,master);
	cont->blockID = blockID;
	cont->subID = subID;
	cont->masterPresent = masterPresent;
	if (master)
		{
		for (int i = 0; i < blockID.Count(); i++)
			{
			SlaveControl *c = (SlaveControl *)cont;
			master->Blocks[blockID[i]]->externalBackPointers.Append(1,&c,1);
			}
		}
	CloneControl(cont,remap);
	cont->UpdateSlave();
	return cont;
	}

SlavePosControl::SlavePosControl() 
	{	

	} 


void SlavePosControl::UpdateSlave()
{
	if (scratchControl == NULL)
		scratchControl = (Control *) sub->Clone();
	scratchControl->DeleteKeys(TRACK_DOALL);
	Point3 f(0.0f,0.f,0.0f);
	scratchControl->SetValue(0,&f);

	if (master)
		master->Update(scratchControl,blockID,subID);


}



void SlavePosControl::GetValue(
		TimeValue t, void *val, Interval &valid, GetSetMethod method)
	{
	if ( (sub == NULL) || (!masterPresent) || (blockID.Count()==0))
		{
		if (method == CTRL_ABSOLUTE)
			{
			Point3 *v = ((Point3*)val);
			*v = Point3(0.0f,0.0f,0.0f);
			}
		else
			{
			Point3 f(0.0f,0.0f,0.0f);
			Matrix3 *v = ((Matrix3*)val);
			v->PreTranslate(f);
			
			}

		return;
		}
//copy keys into scratch control



	if (scratchControl == NULL)
		{
		UpdateSlave();
		}

	if (master)
		master->GetValue3(scratchControl,t,val,valid,blockID,subID,range,method);

	}


//------------------------------------------------------------
//Slave Pos Controller
//------------------------------------------------------------

RefTargetHandle SlavePoint3Control::Clone(RemapDir& remap)
	{
	SlavePoint3Control *cont = new SlavePoint3Control;
//	*cont = *this;
	cont->sub = NULL;
	cont->master = NULL;
	cont->scratchControl = NULL;

	cont->ReplaceReference(0,sub);
	cont->ReplaceReference(1,master);
	cont->blockID = blockID;
	cont->subID = subID;
	cont->masterPresent = masterPresent;
	if (master)
		{
		for (int i = 0; i < blockID.Count(); i++)
			{
			SlaveControl *c = (SlaveControl *)cont;
			master->Blocks[blockID[i]]->externalBackPointers.Append(1,&c,1);
			}
		}
	CloneControl(cont,remap);
	cont->UpdateSlave();
	return cont;
	}

SlavePoint3Control::SlavePoint3Control() 
	{	

	} 


void SlavePoint3Control::UpdateSlave()
{
	if (scratchControl == NULL)
		scratchControl = (Control *) sub->Clone();
	scratchControl->DeleteKeys(TRACK_DOALL);
	Point3 f(0.0f,0.f,0.0f);
	scratchControl->SetValue(0,&f);

	if (master)
		master->Update(scratchControl,blockID,subID);

}

void SlavePoint3Control::GetValue(
		TimeValue t, void *val, Interval &valid, GetSetMethod method)
	{
	if ( (sub == NULL) || (!masterPresent) || (blockID.Count()==0))
		{
		Point3 *v = ((Point3*)val);
		*v = Point3(0.0f,0.0f,0.0f);
		return;
		}
//copy keys into scratch control

	if (scratchControl == NULL)
		{
		UpdateSlave();
		}

	if (master)
		master->GetValue3(scratchControl,t,val,valid,blockID,subID,range,method);
//	cpy->DeleteThis();

	}




//------------------------------------------------------------
//Slave rotation Controller
//------------------------------------------------------------

RefTargetHandle SlaveRotationControl::Clone(RemapDir& remap)
	{
	SlaveRotationControl *cont = new SlaveRotationControl;
//	*cont = *this;
	cont->sub = NULL;
	cont->master = NULL;
	cont->scratchControl = NULL;

	cont->ReplaceReference(0,sub);
	cont->ReplaceReference(1,master);
	cont->blockID = blockID;
	cont->subID = subID;
	cont->masterPresent = masterPresent;
	if (master)
		{
		for (int i = 0; i < blockID.Count(); i++)
			{
			SlaveControl *c = (SlaveControl *)cont;
			master->Blocks[blockID[i]]->externalBackPointers.Append(1,&c,1);
			}
		}
	CloneControl(cont,remap);
	cont->UpdateSlave();
	return cont;
	}


SlaveRotationControl::SlaveRotationControl() 
	{	

	} 


void SlaveRotationControl::UpdateSlave()
{
	if (scratchControl == NULL)
		scratchControl = (Control *) sub->Clone();
	scratchControl->DeleteKeys(TRACK_DOALL);
	Quat f;
	f.Identity();
	scratchControl->SetValue(0,&f);
	if (master)
		master->Update(scratchControl,blockID,subID);

}

void SlaveRotationControl::GetValue(TimeValue t, void *val, Interval &valid, GetSetMethod method)
	{
	if ( (sub == NULL) || (!masterPresent) || (blockID.Count()==0))
		{
		Quat f;
		f.Identity();
		if (method == CTRL_ABSOLUTE)
			{
			Quat *v = ((Quat*)val);
			*v = f;
			return;
			}
		else
			{
			Matrix3 *v = ((Matrix3*)val);
			PreRotateMatrix(*v,f);
			return;				
			}

		}

//copy keys into scratch control
	if (scratchControl == NULL)
		{
		UpdateSlave();
		}

	if (master)
		master->GetValue3(scratchControl,t,val,valid,blockID,subID,range,method);
//	cpy->DeleteThis();

	}



//------------------------------------------------------------
//Slave Scale Controller
//------------------------------------------------------------

RefTargetHandle SlaveScaleControl::Clone(RemapDir& remap)
	{
	SlaveScaleControl *cont = new SlaveScaleControl;
//	*cont = *this;
	cont->sub = NULL;
	cont->master = NULL;
	cont->scratchControl = NULL;

	cont->ReplaceReference(0,sub);
	cont->ReplaceReference(1,master);
	cont->blockID = blockID;
	cont->subID = subID;
	cont->masterPresent = masterPresent;
	if (master)
		{
		for (int i = 0; i < blockID.Count(); i++)
			{
			SlaveControl *c = (SlaveControl *)cont;
			master->Blocks[blockID[i]]->externalBackPointers.Append(1,&c,1);
			}
		}
	CloneControl(cont,remap);
	cont->UpdateSlave();
	return cont;
	}

SlaveScaleControl::SlaveScaleControl() 
	{	

	} 

void SlaveScaleControl::UpdateSlave()
{
	if (scratchControl == NULL)
		scratchControl = (Control *) sub->Clone();
	scratchControl->DeleteKeys(TRACK_DOALL);
//	Matrix3 f(1);

	Quat f;
	f.Identity();
	Point3 p(1.0f,1.0f,1.0f);
	ScaleValue s(p,f); 

	scratchControl->SetValue(0,&s);


	if (master)
		master->Update(scratchControl,blockID,subID);

}

void SlaveScaleControl::GetValue(TimeValue t, void *val, Interval &valid, GetSetMethod method)
	{
	if ( (sub == NULL) || (!masterPresent) || (blockID.Count()==0))
		{
		Quat f;
		f.Identity();
		Point3 p(1.0f,1.0f,1.0f);
		if (method == CTRL_ABSOLUTE)
			{
			ScaleValue s(p,f); 
			ScaleValue *v = ((ScaleValue*)val);
			*v = s;
			return;
			}
		else
			{
			Matrix3 *mat = (Matrix3*)val;
			ScaleValue s(p,f); 
			ApplyScaling(*mat,s);
			return;				

			
			}

		}

	if (scratchControl == NULL)
		UpdateSlave();


	if (master)
		master->GetValue3(scratchControl,t,val,valid,blockID,subID,range,method);

	}



static BOOL CALLBACK SlaveDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

void SlaveControl::EditTrackParams(
		TimeValue t,
		ParamDimensionBase *dim,
		TCHAR *pname,
		HWND hParent,
		IObjParam *ip,
		DWORD flags)
	{

	if (flags & EDITTRACK_BUTTON)
		{
		trackHWND = hParent;
		SlaveDlg *dlg = new SlaveDlg(this,dim,pname,ip,hParent);
		}
	}

SlaveDlg::SlaveDlg(
		SlaveControl *cont,
		ParamDimensionBase *dim,
		TCHAR *pname,
		IObjParam *ip,
		HWND hParent)
	{
	this->cont = cont;
	this->ip   = ip;
	this->dim  = dim;
	valid = FALSE;

//	elems = cont->Elems();

	theHold.Suspend();
	MakeRefByID(FOREVER,0,cont);
	theHold.Resume();

//	hWnd = CreateDialogParam(
	int iret = DialogBoxParam(hInstance,MAKEINTRESOURCE(IDD_SLAVEPARAMS),
		        hParent,SlaveDlgProc,(LPARAM)this);	

//	TSTR title = TSTR(GetString(IDS_RB_NOISECONTROLTITLE)) + TSTR(pname);
//	SetWindowText(hWnd,title);
//	ip->RegisterTimeChangeCallback(this);
	}

SlaveDlg::~SlaveDlg()
	{
//	UnRegisterNoiseCtrlWindow(hWnd);
//	ip->UnRegisterTimeChangeCallback(this);


	theHold.Suspend();
	DeleteAllRefsFromMe();
	theHold.Resume();

	}

void SlaveDlg::Invalidate()
	{
	valid = FALSE;
//	InvalidateRect(hWnd,NULL,FALSE);	
//	InvalidateRect(GetDlgItem(hWnd,IDC_NOISE_GRAPH),NULL,FALSE);
	}

void SlaveDlg::Update()
	{
	if (!valid && hWnd) {
/*
		float strength[MAX_ELEMS];
		cont->GetStrength(ip->GetTime(),strength);

		for (int i=0; i<elems; i++) {			
//			iStrength[i]->SetValue(dim->Convert(strength[i]),FALSE);
//			CheckDlgButton(hWnd,limID[i],cont->lim[i]);
			}
		if (cont->fractal) {
		} else {
			}
*/
		valid = TRUE;
		}
	}

void SlaveDlg::SetupUI(HWND hWnd)
	{
	this->hWnd = hWnd;

/*	iRampOut = GetISpinner(GetDlgItem(hWnd,IDC_NOISE_RAMPOUTSPIN));
	iRampOut->SetLimits(0,TIME_PosInfinity,FALSE);
	iRampOut->SetScale(10.0f);
	iRampOut->LinkToEdit(GetDlgItem(hWnd,IDC_NOISE_RAMPOUT),EDITTYPE_TIME);	
*/
	
//	SetWindowLong(GetDlgItem(hWnd,IDC_NOISE_GRAPH),GWL_USERDATA,(LONG)cont);
	SetupList();


	valid = FALSE;
	Update();
	}

void SlaveDlg::SetupList()
	{
//loop through list getting names
//nuke old lis
	SendMessage(GetDlgItem(hWnd,IDC_LIST1),
				LB_RESETCONTENT,0,0);
	SendMessage(GetDlgItem(hWnd,IDC_LIST1),
				LB_SETCOUNT,0,0);
	if (cont->masterPresent)
		{
		for (int i=0; i<cont->blockID.Count(); i++) 
			{
			int id = cont->blockID[i];
			int subid = cont->subID[i];
			if (id < cont->master->Blocks.Count())
				{
				TSTR name = cont->master->Blocks[id]->SubAnimName(subid);
				SendMessage(GetDlgItem(hWnd,IDC_LIST1),
					LB_ADDSTRING,0,(LPARAM)(TCHAR*)name);
				}

			}
		}

/*
	int sel = SendMessage(GetDlgItem(hWnd,IDC_LIST1),
				LB_GETCURSEL,0,0);
	SendMessage(GetDlgItem(hWnd,IDC_LIST1),
				LB_RESETCONTENT,0,0);
	for (int i=0; i<cont->Blocks.Count(); i++) {
		TSTR name = cont->SubAnimName(i+1);
		SendMessage(GetDlgItem(hWnd,IDC_LIST1),
			LB_ADDSTRING,0,(LPARAM)(TCHAR*)name);
		}
	if (sel!=LB_ERR) {
		SendMessage(GetDlgItem(hWnd,IDC_LIST1),
			LB_SETCURSEL,(WPARAM)sel,0);
	} else {
		SendMessage(GetDlgItem(hWnd,IDC_LIST1),
				LB_SETCURSEL,(WPARAM)-1,0);
		}
*/
	}

void SlaveDlg::SetButtonStates()
	{
	int sel = SendMessage(GetDlgItem(hWnd,IDC_LIST1),
			LB_GETCURSEL,0,0);
	if (sel!=LB_ERR) {
		if ((cont->blockID.Count() == 0) || (cont->subID.Count()==0))
			{
			EnableWindow(GetDlgItem(hWnd,IDC_REMOVE),FALSE);
			EnableWindow(GetDlgItem(hWnd,IDC_COLLAPSE),FALSE);
			}
		else {
			EnableWindow(GetDlgItem(hWnd,IDC_REMOVE),TRUE);
			EnableWindow(GetDlgItem(hWnd,IDC_COLLAPSE),TRUE);
			}
		}
	else
		{
		EnableWindow(GetDlgItem(hWnd,IDC_REMOVE),FALSE);
		EnableWindow(GetDlgItem(hWnd,IDC_COLLAPSE),FALSE);
		}


	}

BOOL MasterTrackViewFilter :: proc(Animatable *anim, Animatable *client,int subNum)

{
//make sure the parent is not a slave or 
if ( anim->ClassID() ==MASTERBLOCK_CONTROL_CLASS_ID)
	return TRUE;
return FALSE;
}


void SlaveDlg::WMCommand(int id, int notify, HWND hCtrl)
	{
	switch (id) {
		case IDC_LIST_NAME: {

			int sel = SendMessage(GetDlgItem(hWnd,IDC_LIST1),
				LB_GETCURSEL,0,0);
			if (sel!=LB_ERR) {
/*
				TCHAR buf[256];
				ICustEdit *iName = GetICustEdit(GetDlgItem(hWnd,IDC_LIST_NAME));
				iName->GetText(buf,256);
				if (!cont->names[sel]) cont->names[sel] = new TSTR;
				*cont->names[sel] = buf;
				cont->NotifyDependents(FOREVER,0,REFMSG_NODE_NAMECHANGE);
				SetupList();
				ReleaseICustEdit(iName);
				EnableWindow(GetDlgItem(hWnd,IDC_SAVE),TRUE);
				EnableWindow(GetDlgItem(hWnd,IDC_REPLACE),TRUE);
				EnableWindow(GetDlgItem(hWnd,IDC_DELETE),TRUE);
*/

				if ((cont->blockID.Count() == 0) || (cont->subID.Count()==0))
					{
					EnableWindow(GetDlgItem(hWnd,IDC_REMOVE),FALSE);
					EnableWindow(GetDlgItem(hWnd,IDC_COLLAPSE),FALSE);
					}
				else {
					EnableWindow(GetDlgItem(hWnd,IDC_REMOVE),TRUE);
					EnableWindow(GetDlgItem(hWnd,IDC_COLLAPSE),TRUE);
					}

				}

			break;
			}
		case IDC_LIST1:
			if (notify==LBN_SELCHANGE) {
				SetButtonStates();				
				}

			break;
		case IDC_LINK:
			{
			if (!cont->masterPresent)
				{
				MasterTrackViewFilter filter;
				TrackViewPick res;
				BOOL MasterOK = GetCOREInterface()->TrackViewPickDlg(hWnd,&res,&filter);
				if (MasterOK && (res.anim != NULL))
					{
					cont->ReplaceReference(1,res.anim,FALSE);
					cont->propBlockID = -1;
					cont->propSubID = -1;

					int OK = DialogBoxParam  (hInstance, MAKEINTRESOURCE(IDD_ADDNEWLINK),
						hWnd, NewLinkDlgProc, (LPARAM)cont);
			
					if ((OK) && (cont->propSubID != -1) && (cont->propSubID != -1))
						{
						cont->AddControl(cont->propBlockID,cont->propSubID);
						SetupList();
						}

					}
				int sel = SendMessage(GetDlgItem(hWnd,IDC_LIST1),
					LB_GETCURSEL,0,0);

				if ((cont->blockID.Count() == 0) || (cont->subID.Count()==0))
					{
					EnableWindow(GetDlgItem(hWnd,IDC_REMOVE),FALSE);
					EnableWindow(GetDlgItem(hWnd,IDC_COLLAPSE),FALSE);
						
					}
				else {
					if (sel!=LB_ERR)
						{
						EnableWindow(GetDlgItem(hWnd,IDC_REMOVE),TRUE);
						EnableWindow(GetDlgItem(hWnd,IDC_COLLAPSE),TRUE);
						}
					}

				}
			else
				{
				int OK = DialogBoxParam  (hInstance, MAKEINTRESOURCE(IDD_ADDNEWLINK),
					hWnd, NewLinkDlgProc, (LPARAM)cont);
			
				if (OK)
					{
					cont->AddControl(cont->propBlockID,cont->propSubID);
					SetupList();
					}
				}
			Change(TRUE);
			break;
			}
		case IDC_REMOVE:
			{
			int sel = SendMessage(GetDlgItem(hWnd,IDC_LIST1),
				LB_GETCURSEL,0,0);
			cont->RemoveControl(sel);
			SendMessage(GetDlgItem(hWnd,IDC_LIST1),
				LB_DELETESTRING,sel,0);
			SetupList();
			sel = SendMessage(GetDlgItem(hWnd,IDC_LIST1),
				LB_GETCURSEL,0,0);

			if ((cont->blockID.Count() == 0) || (cont->subID.Count()==0))
				{
				EnableWindow(GetDlgItem(hWnd,IDC_REMOVE),FALSE);
				EnableWindow(GetDlgItem(hWnd,IDC_COLLAPSE),FALSE);
				}
			else {
				if (sel!=LB_ERR)
					{
					EnableWindow(GetDlgItem(hWnd,IDC_REMOVE),TRUE);
					EnableWindow(GetDlgItem(hWnd,IDC_COLLAPSE),TRUE);
					}
				}

			Change(TRUE);

			break;
			}
		case IDC_COLLAPSE:
			{
			int sel = SendMessage(GetDlgItem(hWnd,IDC_LIST1),
				LB_GETCURSEL,0,0);
			cont->CollapseControl();
			EndDialog(hWnd,1);
//			SetupList();
			break;
			}
		case IDOK:
//			DestroyWindow(hWnd);
			EndDialog(hWnd,1);
			break;
		case IDCANCEL:
			EndDialog(hWnd,0);

//			DestroyWindow(hWnd);
			break;


		}

	}


void SlaveDlg::Change(BOOL redraw)
	{
//	InvalidateRect(GetDlgItem(hWnd,IDC_NOISE_GRAPH),NULL,TRUE);
	cont->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
//	UpdateWindow(GetDlgItem(hWnd,IDC_NOISE_GRAPH));
	UpdateWindow(GetParent(hWnd));	
	if (redraw) ip->RedrawViews(ip->GetTime());
	}


class CheckForNonSlaveDlg : public DependentEnumProc {
	public:		
		BOOL non;
		ReferenceMaker *me;
		CheckForNonSlaveDlg(ReferenceMaker *m) {non = FALSE;me = m;}
		int proc(ReferenceMaker *rmaker) {
			if (rmaker==me) return 0;
			if (rmaker->SuperClassID()!=REF_MAKER_CLASS_ID &&
				rmaker->ClassID()!=Class_ID(SLAVEDLG_CLASS_ID,0)) {
				non = TRUE;
				return 1;
				}
			return 0;
			}
	};
void SlaveDlg::MaybeCloseWindow()
	{
	CheckForNonSlaveDlg check(cont);
	cont->EnumDependents(&check);
	if (!check.non) {
		PostMessage(hWnd,WM_CLOSE,0,0);
		}
	}



RefResult SlaveDlg::NotifyRefChanged(
		Interval changeInt, 
		RefTargetHandle hTarget, 
     	PartID& partID,  
     	RefMessage message)
	{
	switch (message) {
		case REFMSG_CHANGE:
			Invalidate();			
			break;
		
		case REFMSG_REF_DELETED:
			MaybeCloseWindow();
			break;
		}
	return REF_SUCCEED;
	}








static BOOL CALLBACK SlaveDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	SlaveDlg *dlg = (SlaveDlg*)GetWindowLong(hWnd,GWL_USERDATA);

	switch (msg) {
		case WM_INITDIALOG:
			{
			dlg = (SlaveDlg*)lParam;
			SetWindowLong(hWnd,GWL_USERDATA,lParam);
			dlg->SetupUI(hWnd);
			SendMessage(GetDlgItem(hWnd,IDC_LIST1),
				LB_SETCURSEL,0,0);
			int sel = SendMessage(GetDlgItem(hWnd,IDC_LIST1),
				LB_GETCURSEL,0,0);
			if (sel==-1) 
				{
				EnableWindow(GetDlgItem(hWnd,IDC_REMOVE),FALSE);
				EnableWindow(GetDlgItem(hWnd,IDC_COLLAPSE),FALSE);
				}

			break;

			}
		case WM_COMMAND:
			dlg->WMCommand(LOWORD(wParam),HIWORD(wParam),(HWND)lParam);						
			break;

		case WM_PAINT:
			dlg->Update();
			return 0;			
		
		case WM_CLOSE:
			DestroyWindow(hWnd);			
			break;

		case WM_DESTROY:						
			delete dlg;
			break;
	
		case CC_COLOR_BUTTONDOWN:
			theHold.Begin();
			break;
		case CC_COLOR_BUTTONUP:
			if (HIWORD(wParam)) theHold.Accept(GetString(IDS_DS_PARAMCHG));
			else theHold.Cancel();
			break;
		case CC_COLOR_CHANGE: {
			int i = LOWORD(wParam);
			IColorSwatch *cs = (IColorSwatch*)lParam;
			int sel = SendMessage(GetDlgItem(hWnd,IDC_LIST1),
				LB_GETCURSEL,0,0);
			if (sel != -1)
				{
				if (HIWORD(wParam)) theHold.Begin();
//				dlg->cont->Blocks[sel]->color = cs->GetColor();
				if (HIWORD(wParam)) {
					theHold.Accept(GetString(IDS_DS_PARAMCHG));
					}
				}
			break;
		}

		
		default:
			return FALSE;
		}
	return TRUE;
	}





BOOL CALLBACK NewLinkDlgProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
	SlaveControl *slv = (SlaveControl*)GetWindowLong(hWnd,GWL_USERDATA);

	static Tab<int> sid,bid;

	switch (msg) {
	case WM_INITDIALOG:
		{
		sid.ZeroCount();
		bid.ZeroCount();
		slv = (SlaveControl*)lParam;
		SetWindowLong(hWnd,GWL_USERDATA,lParam);

//goto master look at all sub block
		int count = slv->master->Blocks.Count();
		for (int i = 0;i < slv->master->Blocks.Count();i++)
			{
			TSTR blockName = slv->master->SubAnimName(i+1);
			for (int j = 0;j < slv->master->Blocks[i]->controls.Count();j++)
				{
				TSTR subName = slv->master->Blocks[i]->SubAnimName(j);
				TSTR finalName = blockName +" "+ subName;
//check if control is the same as ours
				if (slv->sub == NULL)
//if (((slv->sub == NULL) && (slv->superID ==slv->master->Blocks[i]->controls[j]->SuperClassID()) ) ||

					{
//					SClass_ID sID=slv->master->Blocks[i]->controls[j]->SuperClassID();
//					SClass_ID thisID=slv->SuperClassID();

					if (slv->master->Blocks[i]->controls[j]->SuperClassID() == slv->SuperClassID())  
						{
//add to list box
						sid.Append(1,&j,1);
						bid.Append(1,&i,1);
						SendMessage(GetDlgItem(hWnd,IDC_LIST1),
							LB_ADDSTRING,0,(LPARAM)(TCHAR*)finalName);

						}
					}
				else if (slv->master->Blocks[i]->controls[j]->ClassID() == slv->sub->ClassID() )  
					
					{

//add to list box
					sid.Append(1,&j,1);
					bid.Append(1,&i,1);
					SendMessage(GetDlgItem(hWnd,IDC_LIST1),
						LB_ADDSTRING,0,(LPARAM)(TCHAR*)finalName);
					}
				}
			}	

		SendMessage(GetDlgItem(hWnd,IDC_LIST1),
			LB_SETCURSEL,0,0);
		CenterWindow(hWnd,GetParent(hWnd));
		break;
		}
		


	case WM_COMMAND:
		switch (LOWORD(wParam)) {
		case IDOK:
			{
			int sel = SendMessage(GetDlgItem(hWnd,IDC_LIST1),
						LB_GETCURSEL,0,0);
			if (sel >=0)
				{
				slv->propBlockID = bid[sel];
				slv->propSubID = sid[sel];
				slv->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
				}

			EndDialog(hWnd,1);
			break;
			}
		case IDCANCEL:
			EndDialog(hWnd,0);
			break;
		}
		break;

	default:
		return FALSE;
	}
	return TRUE;
}


/*
BOOL CALLBACK NewLinkDlgProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
	SlaveControl *slv = (SlaveControl*)GetWindowLong(hWnd,GWL_USERDATA);

	static Tab<int> sid,bid;

	switch (msg) {
	case WM_INITDIALOG:
		{
		sid.ZeroCount();
		bid.ZeroCount();
		slv = (SlaveControl*)lParam;
		SetWindowLong(hWnd,GWL_USERDATA,lParam);

//goto master look at all sub block
		for (int i = 0;i < slv->master->Blocks.Count();i++)
			{
			TSTR blockName = slv->master->SubAnimName(i+1);
			for (int j = 0;j < slv->master->Blocks[i]->controls.Count();j++)
				{
				TSTR subName = slv->master->Blocks[i]->SubAnimName(j);
				TSTR finalName = blockName +" "+ subName;
//check if control is the same as ours
				if (slv->master->Blocks[i]->controls[j]->ClassID() == slv->sub->ClassID())
					{

//add to list box
					sid.Append(1,&j,1);
					bid.Append(1,&i,1);
					SendMessage(GetDlgItem(hWnd,IDC_LIST1),
						LB_ADDSTRING,0,(LPARAM)(TCHAR*)finalName);
					}
				}
			}	

		SendMessage(GetDlgItem(hWnd,IDC_LIST1),
			LB_SETCURSEL,0,0);
		CenterWindow(hWnd,GetParent(hWnd));
		break;
		}
		


	case WM_COMMAND:
		switch (LOWORD(wParam)) {
		case IDOK:
			{
			int sel = SendMessage(GetDlgItem(hWnd,IDC_LIST1),
						LB_GETCURSEL,0,0);
			slv->propBlockID = bid[sel];
			slv->propSubID = sid[sel];
			EndDialog(hWnd,1);
			slv->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);

			break;
			}
		case IDCANCEL:
			EndDialog(hWnd,0);
			break;
		}
		break;

	default:
		return FALSE;
	}
	return TRUE;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Control\Reactor\reactor.cpp ===
/**********************************************************************
 *<
	FILE: reactor.cpp

	DESCRIPTION: A Controller plugin that reacts to changes in other controllers

	CREATED BY: Adam Felt

	HISTORY: 

 *>	Copyright (c) 1998, All Rights Reserved.
***********************************************************************/
//-----------------------------------------------------------------------------
#include "reactor.h"
#include "iparamm.h"
#include "ReactAPI.h"


//-----------------------------------------------------------------------
float Distance(Point3 p1, Point3 p2)
{
	p1 = p2-p1;
	return (float)sqrt((p1.x*p1.x)+(p1.y*p1.y)+(p1.z*p1.z));
}

//-----------------------------------------------------------------------


class ReactorDlg;

// scalar variables
class SVar {
public:
	TSTR	name;
	int		subNum;
	int		regNum;	// register number variable is assigned to
	int		refID;	// < 0 means constant
	float	influence, multiplier; 
	float strength;
	float falloff;

	//The type used here is the same as the controller type
	float	fstate;		//reaction state if it's a float
	Quat	qstate;		//reaction state if it's a quat
	Point3	pstate;		//reaction state if it's a point3
	
	//The type used here is the same as the client track
	Point3	pvalue;		//current value if it is a point3
	float	fvalue;		//current value if it's a float
	Quat	qvalue;		//current value if it's a quat

	SVar& operator=(const SVar& from){
		name = ((SVar)from).name;
		influence = ((SVar)from).influence;
		strength = ((SVar)from).strength;
		falloff = ((SVar)from).falloff;
		fstate = ((SVar)from).fstate;
		qstate = ((SVar)from).qstate;
		pstate = ((SVar)from).pstate;
		pvalue = ((SVar)from).pvalue;
		fvalue = ((SVar)from).fvalue;
		qvalue = ((SVar)from).qvalue;
		return *this;
	}



};
	
MakeTab(SVar);


class VarRef {
public:
	INode* client;
	int	refCt;
	int subnum;

	VarRef()	{ client = NULL; refCt = 0; }
	VarRef(INode* c)	{ client = c; refCt = 1; }
	
	VarRef& operator=(const VarRef& from){
		client = ((VarRef)from).client;
		refCt = ((VarRef)from).refCt;
		subnum = ((VarRef)from).subnum;
		return *this;
	}

};

class MyEnumProc : public DependentEnumProc 
	{
      public :
      virtual int proc(ReferenceMaker *rmaker); 
	  INodeTab nodes;
	};


int MyEnumProc::proc(ReferenceMaker *rmaker) 
{ 
		nodes.Append(1, (INode**)&rmaker);
		return 0;
}

class Reactor : public IReactor {
	public:

		int			type, selected, count, rtype;
		BOOL		editing;  // editing the reaction state
		BOOL		isBiped;
		SVarTab		reaction;
		Interval	ivalid;
		Interval	range;
		HWND		hParams;
		NameMaker*	nmaker;
	
		VarRef vrefs;
		Point3 curpval;
		float curfval;
		Quat curqval;
		BOOL blockGetNodeName; // RB 3/23/99: See imp of getNodeName()

		ReactorShortcutCB<Reactor >	*reactorShortcutCB;		// Shortcuts handler 		

		virtual int Elems()=0;
		static IObjParam *ip;
		static ReactorDlg *dlg;	
		
		Reactor(int t, Reactor &ctrl);
		Reactor(int t, BOOL loading);
		Reactor& operator=(const Reactor& from);
		~Reactor();

		BOOL	assignReactObj(INode* client, int subnum);
//		void	assignTo(TrackViewPick res);
		void	reactTo(Animatable* anim, TimeValue t = GetCOREInterface()->GetTime());
		void	updReactionCt(int val);
		BOOL	CreateReaction(TCHAR *buf=NULL, TimeValue t = GetCOREInterface()->GetTime());
		BOOL	DeleteReaction(int i=-1);
		int		getVarCount() { return reaction.Count(); }
		void	deleteAllVars();
		int		getSelected() {return selected;}
		void	setSelected(int i) {selected = i; NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE); return;}
		void	setrType(int i){ rtype = i; }
		int 	getrType(){ return rtype; }
		int 	getType(){ return type; }
		TCHAR*	getVarName(int i);
		void	setVarName(int i, TSTR name);
		void*	getReactionValue(int i);
		BOOL	setReactionValue(int i=-1, void *val=NULL, TimeValue t=NULL);
		float	getCurFloatValue(TimeValue t);
		Point3	getCurPoint3Value(TimeValue t);
		ScaleValue	getCurScaleValue(TimeValue t);
		Quat	getCurQuatValue(TimeValue t);
		BOOL	setInfluence(int num, float inf);
		float	getInfluence(int num);
		void	setMinInfluence(int x=-1);
		void	setMaxInfluence(int x=-1);
		BOOL	setStrength(int num, float inf);
		float	getStrength(int num);
		BOOL	setFalloff(int num, float inf);
		float	getFalloff(int num);
		BOOL	setEditing(BOOL edit);
		void*	getState(int num);
		BOOL	setState(int num, void *val=NULL, TimeValue t=NULL);
		void	getNodeName(ReferenceTarget *client, TSTR &name);

		void	Update(TimeValue t);
		void	ComputeMultiplier(TimeValue t);
		void	GetAbsoluteControlValue(INode *node,TimeValue t,void *pt,Interval &iv);
		BOOL	ChangeParents(TimeValue t,const Matrix3& oldP,const Matrix3& newP,const Matrix3& tm);
		void	isABiped(BOOL bip) { isBiped = bip; }

		// Animatable methods		
		void DeleteThis() {delete this;}		
		int IsKeyable() {return 0;}		
		BOOL IsAnimated() {if (reaction.Count() > 1) return true; else return false;}
		Interval GetTimeRange(DWORD flags) { return range; } 
		void EditTimeRange(Interval range,DWORD flags);
		void MapKeys(TimeMap *map,DWORD flags);

		void HoldTrack();
		void HoldAll();
		void HoldParams();
		void HoldRange();

		int NumSubs();
		BOOL AssignController(Animatable *control,int subAnim) {return false;}
		Animatable* SubAnim(int i){return NULL;}
		TSTR SubAnimName(int i){ return "";}

		int NumRefs();
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);
		
		void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev );
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next );

		void EditTrackParams(
			TimeValue t,
			ParamDimensionBase *dim,
			TCHAR *pname,
			HWND hParent,
			IObjParam *ip,
			DWORD flags);
		int TrackParamsType() {return TRACKPARAMS_WHOLE;}

		// Reference methods
		RefResult NotifyRefChanged(Interval, RefTargetHandle, PartID&, RefMessage);
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);

		// Control methods				
		void Copy(Control *from);
		BOOL IsLeaf() {return TRUE;}

		//These three default implementation are shared by Position, Point3 and Scale controllers
		void SetValue(TimeValue t, void *val, int commit, GetSetMethod method);
		void CommitValue(TimeValue t);
		void RestoreValue(TimeValue t);		
};

//---------------------------------------------------------------------------


class Point3Reactor : public Reactor {
	public:
		int Elems() {return 3;}

		Point3Reactor(Point3Reactor &ctrl) : Reactor(REACTORP3, ctrl) {}
		Point3Reactor(BOOL loading) : Reactor(REACTORP3, loading) {}
		~Point3Reactor() {}

		Class_ID ClassID() { return REACTORP3_CLASS_ID; }  
		SClass_ID SuperClassID() { return CTRL_POINT3_CLASS_ID; } 
		void GetClassName(TSTR& s) {s = GetString(IDS_AF_REACTORP3);}

		// Control methods
		RefTargetHandle Clone(RemapDir& remap);
		void GetValue(TimeValue t, void *val, Interval &valid, GetSetMethod method);
	};


class Point3ReactorClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { return new Point3Reactor(loading); }
	const TCHAR *	ClassName() { return GetString(IDS_AF_REACTORP3); }
	SClass_ID		SuperClassID() { return CTRL_POINT3_CLASS_ID; }
	Class_ID		ClassID() { return REACTORP3_CLASS_ID; }
	const TCHAR* 	Category() { return _T("");  }
};
static Point3ReactorClassDesc point3ReactorCD;
ClassDesc* GetPoint3ReactorDesc() {return &point3ReactorCD;}

//-----------------------------------------------------------------------------

class PositionReactor : public Reactor {
	public:
		int Elems() {return 3;}

		PositionReactor(PositionReactor &ctrl) : Reactor(REACTORPOS, ctrl) {}
		PositionReactor(BOOL loading) : Reactor(REACTORPOS, loading) {}
		~PositionReactor() {}

		Class_ID ClassID() { return REACTORPOS_CLASS_ID; }  
		SClass_ID SuperClassID() { return CTRL_POSITION_CLASS_ID; } 
		void GetClassName(TSTR& s) {s = GetString(IDS_AF_REACTORPOS);}

		// Control methods
		RefTargetHandle Clone(RemapDir& remap);
		void GetValue(TimeValue t, void *val, Interval &valid, GetSetMethod method); 
	};


class PositionReactorClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { return new PositionReactor(loading); }
	const TCHAR *	ClassName() { return GetString(IDS_AF_REACTORPOS); }
	SClass_ID		SuperClassID() { return CTRL_POSITION_CLASS_ID; }
	Class_ID		ClassID() { return REACTORPOS_CLASS_ID; }
	const TCHAR* 	Category() { return _T("");  }

	};
static PositionReactorClassDesc positionReactorCD;
ClassDesc* GetPositionReactorDesc() {return &positionReactorCD;}

//-----------------------------------------------------------------------------


class ScaleReactor : public Reactor {
	public:
		int Elems() {return 3;}

		ScaleReactor(ScaleReactor &ctrl) : Reactor(REACTORSCALE, ctrl) {}
		ScaleReactor(BOOL loading) : Reactor(REACTORSCALE, loading) {}
		~ScaleReactor() {}

		Class_ID ClassID() { return REACTORSCALE_CLASS_ID; }  
		SClass_ID SuperClassID() { return CTRL_SCALE_CLASS_ID; } 
		void GetClassName(TSTR& s) {s = GetString(IDS_AF_REACTORSCALE);}

		// Control methods
		RefTargetHandle Clone(RemapDir& remap);
		void GetValue(TimeValue t, void *val, Interval &valid, GetSetMethod method);
		void SetValue(TimeValue t, void *val, int commit, GetSetMethod method);		
	};


class ScaleReactorClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { return new ScaleReactor(loading); }
	const TCHAR *	ClassName() { return GetString(IDS_AF_REACTORSCALE); }
	SClass_ID		SuperClassID() { return CTRL_SCALE_CLASS_ID; }
	Class_ID		ClassID() { return REACTORSCALE_CLASS_ID;}
	const TCHAR* 	Category() { return _T("");  }
	};

static ScaleReactorClassDesc scaleReactorCD;
ClassDesc* GetScaleReactorDesc() {return &scaleReactorCD;}

//-------------------------------------------------------------------

class RotationReactor : public Reactor {
	public:
		int Elems() {return 3;}

		RotationReactor(RotationReactor &ctrl) : Reactor(REACTORROT, ctrl) {}
		RotationReactor(BOOL loading) : Reactor(REACTORROT, loading) {}
		~RotationReactor() {}

		Class_ID ClassID() { return REACTORROT_CLASS_ID; }  
		SClass_ID SuperClassID() { return CTRL_ROTATION_CLASS_ID; } 
		void GetClassName(TSTR& s) {s = GetString(IDS_AF_REACTORROT);}

		// Control methods
		RefTargetHandle Clone(RemapDir& remap);
		void GetValue(TimeValue t, void *val, Interval &valid, GetSetMethod method);
		void SetValue(TimeValue t, void *val, int commit, GetSetMethod method);		
		void CommitValue(TimeValue t);
		void RestoreValue(TimeValue t);
	};


class RotationReactorClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { return new RotationReactor(loading); }
	const TCHAR *	ClassName() { return GetString(IDS_AF_REACTORROT); }
	SClass_ID		SuperClassID() { return CTRL_ROTATION_CLASS_ID; }
	Class_ID		ClassID() { return REACTORROT_CLASS_ID; }
	const TCHAR* 	Category() { return _T("");  }
	};
static RotationReactorClassDesc rotationReactorCD;
ClassDesc* GetRotationReactorDesc() {return &rotationReactorCD;}

//-----------------------------------------------------------------------------


class FloatReactor : public Reactor {
	public:
		int Elems() {return 1;}
		
		FloatReactor(FloatReactor &ctrl) : Reactor(REACTORFLOAT, ctrl) {}
		FloatReactor(BOOL loading) : Reactor(REACTORFLOAT, loading) {}
		~FloatReactor() {}

		Class_ID ClassID() { return REACTORFLOAT_CLASS_ID; }  
		SClass_ID SuperClassID() { return CTRL_FLOAT_CLASS_ID; } 
		void GetClassName(TSTR& s) {s = GetString(IDS_AF_REACTORFLOAT);}

		// Control methods
		RefTargetHandle Clone(RemapDir& remap);
		void GetValue(TimeValue t, void *val, Interval &valid, GetSetMethod method);
		void SetValue(TimeValue t, void *val, int commit, GetSetMethod method){}		
		void CommitValue(TimeValue t){}
		void RestoreValue(TimeValue t){}		
	};


class FloatReactorClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { return new FloatReactor(loading); }
	const TCHAR *	ClassName() { return GetString(IDS_AF_REACTORFLOAT); }
	SClass_ID		SuperClassID() { return CTRL_FLOAT_CLASS_ID; }
	Class_ID		ClassID() { return REACTORFLOAT_CLASS_ID; }
	const TCHAR* 	Category() { return _T("");  }
	//You only need to add the shortcut stuff to one Class Desc
	int             NumShortcutTables() { return 1; }
	ShortcutTable*  GetShortcutTable(int i) { return GetShortcuts(); }

	};
static FloatReactorClassDesc floatReactorCD;
ClassDesc* GetFloatReactorDesc() {return &floatReactorCD;}

//-----------------------------------------------------------------------------


//////////////////////////////////////////////////////////////
//************************************************************

class ReactorDlg : public ReferenceMaker, public TimeChangeCallback {
	public:
		Reactor *cont;	
		ParamDimensionBase *dim;
		IObjParam *ip;
		HWND hWnd;
		BOOL valid;
		int elems;  //This is reserved in case I have a variable # of spinners
		ISpinnerControl *iFloatState;		
		ISpinnerControl *iInfluence;
		ISpinnerControl *iStrength;
		ISpinnerControl *iFalloff[1];  //Variable number of spinners (reserved)
		ICustButton *iCreateBut;
		ICustButton *iDeleteBut;
		ICustButton *iSetBut;
		ICustButton *iEditBut;
		ICustEdit	*iNameEdit;
		ICustEdit	*iValueStatus;

		ReactorShortcutCB<Reactor >	*reactorShortcutCB;		// Shortcuts handler 		
		
		ReactorDlg(
			Reactor *cont,
			ParamDimensionBase *dim,
			TCHAR *pname,
			IObjParam *ip,
			HWND hParent);
		~ReactorDlg();

		Class_ID ClassID() {return Class_ID(REACTORDLG_CLASS_ID,0x67053d10);}
		SClass_ID SuperClassID() {return REF_MAKER_CLASS_ID;}

		void MaybeCloseWindow();
		void TimeChanged(TimeValue t) {Invalidate();}
		void Invalidate();
		void Update();
		void UpdateNodeName();
		void UpdateVarList();
		void UpdateReactionValue();
		void SetupUI(HWND hWnd);
		void Change(BOOL redraw=FALSE);
		void WMCommand(int id, int notify, HWND hCtrl);
		void SpinnerChange(int id,BOOL drag);
		void SpinnerStart(int id);
		void SpinnerEnd(int id,BOOL cancel);

		RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
	         PartID& partID,  RefMessage message);
		int NumRefs() {return 1;}
		RefTargetHandle GetReference(int i) {return cont;}
		void SetReference(int i, RefTargetHandle rtarg) {cont=(Reactor*)rtarg;}
	};



//-----------------------------------------------------------------------

class FullRestore: public RestoreObj {
	public:		
		Control *sav;
		Control *cur;
		Control *redo; 
		FullRestore() { sav = cur = redo =  NULL; }
		FullRestore(Control *cont) {
			cur = cont;
			theHold.Suspend();
			sav = (Control*)cont->Clone();
			theHold.Resume();
			redo = NULL;
			}
		~FullRestore() {
			}		
		
		void Restore(int isUndo) {
			assert(cur); assert(sav);
			if (isUndo) {
				theHold.Suspend();
				redo = (Control *)cur->Clone();
				theHold.Resume();
				}
			cur->Copy(sav);
			}
		void Redo() {
			assert(cur); 
			if (redo) 
				cur->Copy(redo);
			}
		void EndHold() {}
		TSTR Description() { return TSTR(_T("FullReactorRestore")); }
	};


void Reactor::HoldAll()
	{
	if (theHold.Holding()) { 	
		theHold.Put(new FullRestore(this));
		}
	}


// A restore object to save the influence, strength, and falloff.
class SpinnerRestore : public RestoreObj {
	public:		
		Reactor *cont;
		Tab<SVar> ureaction, rreaction;
		float uselected, rselected;
		SpinnerRestore(Reactor *c) {
			cont=c;
			ureaction = cont->reaction;
			uselected = cont->selected;
		}
		void Restore(int isUndo) {
			// if we're undoing, save a redo state
			if (isUndo) {
				rreaction = cont->reaction;
				rselected = cont->selected;
			}
			cont->reaction = ureaction;
			cont->selected = uselected;
			cont->count = cont->reaction.Count();
			cont->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);

		}
		void Redo() {
			cont->reaction = rreaction;
			cont->selected = rselected;
			cont->count = cont->reaction.Count();
			cont->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
		}
		void EndHold()
		{
		}
		int Size()
		{
			return sizeof(cont->reaction) + sizeof(float);
		}

};


void Reactor::HoldParams()
{
	if (theHold.Holding()) {
		theHold.Put(new SpinnerRestore(this));
	}
}


class StateRestore : public RestoreObj {
	public:
		Reactor *cont;
		Point3 ucurpval, rcurpval;
		float ucurfval, rcurfval;
		Quat ucurqval, rcurqval;
		Tab<SVar> ureaction, rreaction;

		StateRestore(Reactor *c) 
			{
			cont = c;
			ucurpval = cont->curpval;
			ucurqval = cont->curqval;
			ucurfval = cont->curfval;
			ureaction = cont->reaction;
			}   		
		void Restore(int isUndo) 
			{
			rcurpval = cont->curpval;
			rcurqval = cont->curqval;
			rcurfval = cont->curfval;
			rreaction = cont->reaction;
			cont->curpval = ucurpval;
			cont->curqval = ucurqval;
			cont->curfval = ucurfval;
			cont->reaction = ureaction;
			cont->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
			}
		void Redo()
			{
			cont->curpval = rcurpval;
			cont->curqval = rcurqval;
			cont->curfval = rcurfval;
			cont->reaction = rreaction;
			cont->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
			}		
		void EndHold() 
			{ 
			cont->ClearAFlag(A_HELD);
			}
		TSTR Description() { return TSTR(_T("Reactor State")); }
};

void Reactor::HoldTrack()
	{
	if (theHold.Holding()&&!TestAFlag(A_HELD)) {		
		theHold.Put(new StateRestore(this));
		SetAFlag(A_HELD);
		}
	}

class RangeRestore : public RestoreObj {
	public:
		Reactor *cont;
		Interval ur, rr;
		RangeRestore(Reactor *c) 
			{
			cont = c;
			ur   = cont->range;
			}   		
		void Restore(int isUndo) 
			{
			rr = cont->range;
			cont->range = ur;
			cont->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
			}
		void Redo()
			{
			cont->range = rr;
			cont->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
			}		
		void EndHold() 
			{ 
			cont->ClearAFlag(A_HELD);
			}
		TSTR Description() { return TSTR(_T("Reactor control range")); }
	};


void Reactor::HoldRange()
{
	if (theHold.Holding() && !TestAFlag(A_HELD)) {
		SetAFlag(A_HELD);
		theHold.Put(new RangeRestore(this));
		}
}
		

IObjParam		*Reactor::ip = NULL;
ReactorDlg		*Reactor::dlg = NULL;

Reactor::Reactor(int t, Reactor &ctrl)
{
	type = t;
	DeleteAllRefsFromMe();
	MakeRefByID(FOREVER,0,vrefs.client);

	ip = ctrl.ip;
	hParams = ctrl.hParams;
	range = ctrl.range;
	ivalid = ctrl.ivalid;
	selected = ctrl.selected;
	count = ctrl.count;
	editing = ctrl.editing;
	isBiped = ctrl.isBiped;
	nmaker = ctrl.nmaker;
	curpval = ctrl.curpval;
	curfval = ctrl.curfval;
	curqval = ctrl.curqval;
	rtype = ctrl.rtype;
	type = ctrl.type;
	blockGetNodeName = FALSE;

}

Reactor::Reactor(int t, BOOL loading) 
{
	type = t;
	range.Set(GetAnimStart(), GetAnimEnd());
	count = 0;
	selected = 0;
	editing = FALSE;
	isBiped = FALSE;
	hParams = NULL;
	nmaker = NULL;
	curpval = Point3(1.0f,1.0f,1.0f);
	curfval = 0.0f;
	curqval.Identity();
	ivalid.SetEmpty();
	blockGetNodeName = FALSE;

}

Reactor::~Reactor()
{
	deleteAllVars();
	if(nmaker) delete nmaker;
	if (hParams)
	{
		DestroyWindow(hParams);
	}
	DeleteAllRefsFromMe();
}

void Reactor::deleteAllVars()
{
	reaction.SetCount(0);
	count = 0;
	selected = 0;
}

Reactor& Reactor::operator=(const Reactor& from)
	{
		
		type = from.type;
		rtype = from.rtype;		
		assignReactObj(from.vrefs.client, from.vrefs.subnum);
		reaction = from.reaction;

		count = from.count;	
		selected = from.selected;
		editing = from.editing;
		isBiped = from.isBiped;
		
		curfval = from.curfval;
		curpval = from.curpval;
		curqval = from.curqval;

		ivalid = from.ivalid;
		range = from.range;

		nmaker = from.nmaker;
		NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);

	return *this;
	}

int Reactor::NumSubs() 
	{
	return 0;
	}

void Reactor::EditTimeRange(Interval range,DWORD flags)
{
	if(!(flags&EDITRANGE_LINKTOKEYS)){
		HoldRange();
		this->range = range;
		NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}
}

void Reactor::MapKeys(TimeMap *map,DWORD flags)
	{
	if (flags&TRACK_MAPRANGE) {
		HoldRange();
		TimeValue t0 = map->map(range.Start());
		TimeValue t1 = map->map(range.End());
		range.Set(t0,t1);
		NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
		}
	}

int Reactor::NumRefs() 
{
		return 1;
}

RefTargetHandle Reactor::GetReference(int i) 
{
	return vrefs.client;

}

void Reactor::SetReference(int i, RefTargetHandle rtarg) 
{
	vrefs.client = (INode*)rtarg;
}


RefResult Reactor::NotifyRefChanged(
		Interval iv, 
		RefTargetHandle hTarg, 
		PartID& partID, 
		RefMessage msg) 
{
	switch (msg) {
		case REFMSG_CHANGE:
			ivalid.SetEmpty();

			break;
	case REFMSG_GET_NODE_NAME:
		// RB 3/23/99: See comment at imp of getNodeName().
		if (blockGetNodeName) return REF_STOP;
		break;
		case REFMSG_TARGET_DELETED:
			if (hTarg==vrefs.client && vrefs.subnum < 0 )  //If it's a special case reference delete everything
			{
				vrefs.client = NULL;
				HoldParams();
				count = 0;
				reaction.ZeroCount();
				selected = -1;
			}
			break;
		case REFMSG_GET_CONTROL_DIM: {
//			ParamDimension **dim = (ParamDimension **)partID;
//			assert(dim);
//			*dim = stdWorldDim;
			}
		}
	return REF_SUCCEED;
}
 
void Reactor::Copy(Control *from)
{
	Point3 pointval;
	float floatval, f;
	Quat quatval;
	ScaleValue sv;
	
	if (from->ClassID() == ClassID()) (*this) = *((Reactor*)from);
	else {
		switch (type)
		{
			case REACTORPOS:
			case REACTORP3:
				from->GetValue(GetCOREInterface()->GetTime(), &pointval, ivalid);
				curpval = pointval;
				break;
			case REACTORROT:
				from->GetValue(GetCOREInterface()->GetTime(), &quatval, ivalid);
				curqval = quatval;
				break;
			case REACTORFLOAT:
				from->GetValue(GetCOREInterface()->GetTime(), &floatval, ivalid);
				f = floatval;
				curfval = f;
				break;
			case REACTORSCALE:
				from->GetValue(GetCOREInterface()->GetTime(), &sv, ivalid);
				curpval = sv.s;
				break;
			default: break;
		}
	}
}



#define REACTOR_VAR_RQUAT		0x5000
#define REACTOR_VAR_RVECTOR		0x5001
#define REACTOR_RTYPE_CHUNK		0x5002
#define REACTOR_VAR_STRENGTH	0x5003
#define REACTOR_VAR_FALLOFF		0x5004
#define REACTOR_ISBIPED_CHUNK	0x5005
#define REACTOR_RANGE_CHUNK		0x6001
#define REACTOR_VREFS_REFCT		0x6002
#define REACTOR_VREFS_SUBNUM	0x6003
#define REACTOR_SVAR_TABSIZE	0x6004
#define REACTOR_VVAR_TABSIZE	0x6005
#define REACTOR_VAR_NAME		0x6006
#define REACTOR_VAR_VAL			0x6007
#define REACTOR_VAR_INF			0x6008
#define REACTOR_VAR_MULT		0x6009
#define REACTOR_VAR_FNUM		0x7000
#define REACTOR_VAR_POS			0x7300
#define REACTOR_VAR_QVAL		0x7600
#define REACTOR_SVAR_ENTRY0		0x8000
#define REACTOR_SVAR_ENTRYN		0x8fff
#define REACTOR_VVAR_ENTRY0		0x9000
#define REACTOR_VVAR_ENTRYN		0x9fff


IOResult Reactor::Save(ISave *isave)
{		
	ULONG 	nb;
	int		i, ct, intVar;
 
	isave->BeginChunk(REACTOR_RTYPE_CHUNK);
	isave->Write(&rtype, sizeof(int), &nb);
 	isave->EndChunk();

	isave->BeginChunk(REACTOR_RANGE_CHUNK);
	isave->Write(&range, sizeof(range), &nb);
 	isave->EndChunk();

	isave->BeginChunk(REACTOR_ISBIPED_CHUNK);
	isave->Write(&isBiped, sizeof(BOOL), &nb);
 	isave->EndChunk();

	isave->BeginChunk(REACTOR_VREFS_REFCT);
	isave->Write(&vrefs.refCt, sizeof(int), &nb);
	isave->EndChunk();

	isave->BeginChunk(REACTOR_VREFS_SUBNUM);
	isave->Write(&vrefs.subnum, sizeof(int), &nb);
	isave->EndChunk();

	isave->BeginChunk(REACTOR_SVAR_TABSIZE);
	intVar = count;
	isave->Write(&intVar, sizeof(intVar), &nb);
 	isave->EndChunk();

	ct = count;
	for(i = 0; i < ct; i++) {
	 	isave->BeginChunk(REACTOR_SVAR_ENTRY0+i);
	 	 isave->BeginChunk(REACTOR_VAR_POS);
		 isave->Write(&reaction[i].pvalue, sizeof(Point3), &nb);
 		 isave->EndChunk();
	 	 isave->BeginChunk(REACTOR_VAR_NAME);
		 isave->WriteCString(reaction[i].name);
 		 isave->EndChunk();
	 	 isave->BeginChunk(REACTOR_VAR_VAL);
		 isave->Write(&reaction[i].fstate, sizeof(float), &nb);
 		 isave->EndChunk();
	 	 isave->BeginChunk(REACTOR_VAR_RQUAT);
		 isave->Write(&reaction[i].qstate, sizeof(Quat), &nb);
 		 isave->EndChunk();
	 	 isave->BeginChunk(REACTOR_VAR_RVECTOR);
		 isave->Write(&reaction[i].pstate, sizeof(Point3), &nb);
 		 isave->EndChunk();
	 	 isave->BeginChunk(REACTOR_VAR_INF);
		 isave->Write(&reaction[i].influence, sizeof(float), &nb);
 		 isave->EndChunk();
	 	 isave->BeginChunk(REACTOR_VAR_STRENGTH);
		 isave->Write(&reaction[i].strength, sizeof(float), &nb);
 		 isave->EndChunk();
	 	 isave->BeginChunk(REACTOR_VAR_FALLOFF);
		 isave->Write(&reaction[i].falloff, sizeof(float), &nb);
 		 isave->EndChunk();
	 	 isave->BeginChunk(REACTOR_VAR_MULT);
		 isave->Write(&reaction[i].multiplier, sizeof(float), &nb);
 		 isave->EndChunk();
	 	 isave->BeginChunk(REACTOR_VAR_FNUM);
		 isave->Write(&reaction[i].fvalue, sizeof(float), &nb);
 		 isave->EndChunk();
	 	 isave->BeginChunk(REACTOR_VAR_QVAL);
		 isave->Write(&reaction[i].qvalue, sizeof(Quat), &nb);
 		 isave->EndChunk();
	 	isave->EndChunk();
	}
	return IO_OK;
}

IOResult Reactor::Load(ILoad *iload)
	{
	ULONG 	nb;
	TCHAR	*cp;
	int		id, i, varIndex, intVar;
	IOResult res;
	VarRef	dummyVarRef;

	while (IO_OK==(res=iload->OpenChunk())) {
		switch (id = iload->CurChunkID()) {
	
		case REACTOR_RTYPE_CHUNK:
			iload->Read(&rtype, sizeof(int), &nb);
			break;
		case REACTOR_RANGE_CHUNK:
			iload->Read(&range, sizeof(range), &nb);
			break;
		case REACTOR_ISBIPED_CHUNK:
			iload->Read(&isBiped, sizeof(BOOL), &nb);
			break;
		case REACTOR_VREFS_REFCT:
			iload->Read(&vrefs.refCt, sizeof(int), &nb);
			break;
		case REACTOR_VREFS_SUBNUM:
			iload->Read(&vrefs.subnum, sizeof(int), &nb);
			break;
		case REACTOR_SVAR_TABSIZE:
			iload->Read(&intVar, sizeof(intVar), &nb);
			reaction.SetCount(intVar);
			updReactionCt(intVar);
			for(i = 0; i < intVar; i++)
				memset(&reaction[i], 0, sizeof(SVar));
			break;
		}	
		if(id >= REACTOR_SVAR_ENTRY0 && id <= REACTOR_SVAR_ENTRYN) {
			varIndex = id - REACTOR_SVAR_ENTRY0;
			assert(varIndex < count);
			while (IO_OK == iload->OpenChunk()) {
				switch (iload->CurChunkID()) {
				case REACTOR_VAR_NAME:
					iload->ReadCStringChunk(&cp);
					reaction[varIndex].name = cp;
					break;
				case REACTOR_VAR_VAL:
					iload->Read(&reaction[varIndex].fstate, sizeof(float), &nb);
					break;
				case REACTOR_VAR_RQUAT:
					iload->Read(&reaction[varIndex].qstate, sizeof(Quat), &nb);
					break;
				case REACTOR_VAR_RVECTOR:
					iload->Read(&reaction[varIndex].pstate, sizeof(Point3), &nb);
					break;
				case REACTOR_VAR_INF:
					iload->Read(&reaction[varIndex].influence, sizeof(float), &nb);
					break;
				case REACTOR_VAR_STRENGTH:
					iload->Read(&reaction[varIndex].strength, sizeof(float), &nb);
					break;
				case REACTOR_VAR_FALLOFF:
					iload->Read(&reaction[varIndex].falloff, sizeof(float), &nb);
					break;
				case REACTOR_VAR_MULT:
					iload->Read(&reaction[varIndex].multiplier, sizeof(float), &nb);
					break;
				case REACTOR_VAR_FNUM:
					iload->Read(&reaction[varIndex].fvalue, sizeof(float), &nb);
					break;
				case REACTOR_VAR_POS:
					iload->Read(&reaction[varIndex].pvalue, sizeof(Point3), &nb);
					break;
				case REACTOR_VAR_QVAL:
					iload->Read(&reaction[varIndex].qvalue, sizeof(Quat), &nb);
					break;
				}	
				iload->CloseChunk();
			}
		}
		iload->CloseChunk();
	}
	return IO_OK;
}

// RB 3/23/99: To solve 75139 (the problem where a node name is found for variables that 
// are not associated with nodes such as globabl tracks) we need to block the propogation
// of this message through our reference to the client of the variable we're referencing.
// In the expression controller's imp of NotifyRefChanged() we're going to block the get
// node name message if the blockGetNodeName variable is TRUE.
void Reactor::getNodeName(ReferenceTarget *client, TSTR &name)
{
	blockGetNodeName = TRUE;
	if (client) client->NotifyDependents(FOREVER,(PartID)&name,REFMSG_GET_NODE_NAME);
	blockGetNodeName = FALSE;
}


void Reactor::ComputeMultiplier(TimeValue t)
{

	float m, mtemp, normval, total;
	int i, j;
	Tab<float> ftab, inftab;
	Point3 axis;

	ftab.ZeroCount();
	inftab.ZeroCount();
	total = 0.0f;
	if (!editing)
	{
		float mult;

		// Limit to in range
		if (t<range.Start()) t = range.Start();
		if (t>range.End()) t = range.End();	

		//Make sure there is always an influentual reaction
		//If not create a temp influence value that is large enough
		//First sum up all multiplier values
		for(i=0;i<count;i++){
			inftab.Append(1, &(reaction[i].influence)); 
			switch (rtype)
			{
				case FLOAT_VAR:
					mult = 1.0f-((float)fabs(getCurFloatValue(t)-reaction[i].fvalue)/(reaction[i].influence));
					break;
				case VECTOR_VAR: 
					mult = 1.0f-(Distance(reaction[i].pvalue, getCurPoint3Value(t))/(reaction[i].influence));
					break;
				case SCALE_VAR:
					mult = 1.0f-(Distance(reaction[i].pvalue, (getCurScaleValue(t)).s)/(reaction[i].influence));
					break;
				case QUAT_VAR: 
					mult = 1.0f-(QangAxis(reaction[i].qvalue, getCurQuatValue(t), axis)/reaction[i].influence);
					break;

				default: assert(0);
			}
			if (mult<0) mult = 0.0f;
			total += mult;
		}
		//Check to see if any are influencial, total > 0 if any influence
		if(total <= 0.0f) {
			//find the closest reaction
			int which;  
			float closest, closesttemp;
			closest = 10000000.0f;
			which = 0;
			for(i=0;i<count;i++)
			{
				switch (rtype)
				{
					case FLOAT_VAR:
						closesttemp = ((float)fabs(getCurFloatValue(t)-reaction[i].fvalue)<closest ? (float)fabs(getCurFloatValue(t)-reaction[i].fvalue) : closest);
						break;
					case VECTOR_VAR: 
						closesttemp = (Distance(reaction[i].pvalue, getCurPoint3Value(t))<closest ? Distance(reaction[i].pvalue, getCurPoint3Value(t)) : closest);
						break;
					case SCALE_VAR: 
						closesttemp = (Distance(reaction[i].pvalue, (getCurScaleValue(t)).s)<closest ? Distance(reaction[i].pvalue, (getCurScaleValue(t)).s) : closest);
						break;
					case QUAT_VAR: 
						closesttemp = (QangAxis(reaction[i].qvalue, getCurQuatValue(t), axis)<closest ? QangAxis(reaction[i].qvalue, getCurQuatValue(t), axis) : closest);
						break;
					default: closesttemp = 10000000.0f;
				}
				if (closesttemp < closest) 
				{
					which = i;	
					closest = closesttemp;
				}
			}
			if(count&&closest) 
			{
				inftab[which] = closest + 1.0f;  //make the influence a little more than the closest reaction
			}
		}


		//Get the initial multiplier by determining it's influence
		for(i=0;i<count;i++)
		{
			switch (rtype)
			{
				case FLOAT_VAR:
					m = 1.0f-((float)fabs(getCurFloatValue(t)-reaction[i].fvalue)/inftab[i]);
					break;
				case VECTOR_VAR: 
					m = 1.0f-(Distance(reaction[i].pvalue, getCurPoint3Value(t))/inftab[i]);
					break;
				case SCALE_VAR: 
					m = 1.0f-(Distance(reaction[i].pvalue, (getCurScaleValue(t)).s)/inftab[i]);
					break;
				case QUAT_VAR: 
					m = 1.0f-(QangAxis(reaction[i].qvalue, getCurQuatValue(t), axis)/inftab[i]);
					break;

				default: assert(0);
			}
			if(m<0) m=0;
			reaction[i].multiplier = m;
		}
		
		for(i=0;i<count;i++)
		{
			//add the strength
			reaction[i].multiplier  *= reaction[i].strength;
		}

		//Make an adjustment so that when a value is reached 
		//the state is also reached reguardless of the other influentual reactions 
		for(i=0;i<count;i++)
		{
			mtemp = 1.0f;
			for(j=0;j<count;j++)
			{
				BOOL is_same = false;
				switch (rtype)
				{
					case SCALE_VAR:
					case VECTOR_VAR:
						if((*((Point3*)getReactionValue(j))) == (*((Point3*)getReactionValue(i)))) 
							is_same = true;
						break;
					case QUAT_VAR:
						if((*((Quat*)getReactionValue(j))) == (*((Quat*)getReactionValue(i)))) 
							is_same = true;
						break;
					case FLOAT_VAR:
						if((*((float*)getReactionValue(j))) == (*((float*)getReactionValue(i)))) 
							is_same = true;
						break;
					default : is_same = false;
				}
				if (is_same ) mtemp *= reaction[j].multiplier; 
					else mtemp *= (1.0f - reaction[j].multiplier);
			}
			if(mtemp<0) mtemp = 0.0f;
			ftab.Append(1, &mtemp);
		}

		//update the Reaction multipliers
		for(i=0;i<count;i++)
		{
			reaction[i].multiplier = ftab[i];
			//compute the falloff
			reaction[i].multiplier = (float)pow(reaction[i].multiplier, (1/reaction[i].falloff));
		}
		//make sure they always add up to 1.0
		int valcount = 0;
		total = 0.0f;
		for(i=0;i<count;i++)
			total +=reaction[i].multiplier;
		if (!total) total = 1.0f; 
		normval = 1.0f/total;
		for(i=0;i<count;i++)
		reaction[i].multiplier *= normval;
		
	}

}


void Reactor::reactTo(Animatable *anim, TimeValue t)
{
	Animatable* nd;

	theHold.Begin();
	HoldAll();

	switch ( anim->SuperClassID() )
	{
		case CTRL_FLOAT_CLASS_ID:
			setrType(FLOAT_VAR); break;
		case CTRL_POINT3_CLASS_ID:
		case CTRL_POSITION_CLASS_ID:
			setrType(VECTOR_VAR); break;
		case CTRL_SCALE_CLASS_ID:
			setrType(SCALE_VAR); break;
		case CTRL_ROTATION_CLASS_ID:
			setrType(QUAT_VAR); break;
		default: setrType(VECTOR_VAR); 
	}

	if (anim->SuperClassID()==BASENODE_CLASS_ID)
	{
		nd = (INode*)anim;

		Control *c = ((INode*)nd)->GetTMController();
		if (c->ClassID() == BIPSLAVE_CONTROL_CLASS_ID || c->ClassID() == IKSLAVE_CLASSID)
		{
			isABiped(TRUE);
			setrType(QUAT_VAR);
			if (!(assignReactObj((INode*)nd, -2))) return;
		}else {
			setrType(VECTOR_VAR);
			if (!(assignReactObj((INode*)nd, -1))) return;
		}
	} 
	else {
		MyEnumProc dep;             
		((ReferenceTarget*)anim)->EnumDependents(&dep);

		for(int x=0; x<dep.nodes.Count(); x++)
		{
			for(int i=0; i<dep.nodes[x]->NumSubs(); i++)
			{
				Animatable* n = dep.nodes[x]->SubAnim(i);
				if ((Control*)n == (Control*)anim)
				{
					if (!(assignReactObj((INode*)dep.nodes[x], i))) return;
				}
			}
		}
	}
	CreateReaction();
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);

	theHold.Accept(GetString(IDS_ASSIGN_TO));
}


/*
void Reactor::assignTo(TrackViewPick res)
{
	theHold.Begin();
	HoldAll();

	switch (res.anim->SuperClassID())
	{
		case CTRL_FLOAT_CLASS_ID:
			setrType(FLOAT_VAR); break;
		case CTRL_POINT3_CLASS_ID:
		case CTRL_POSITION_CLASS_ID:
			setrType(VECTOR_VAR); break;
		case CTRL_SCALE_CLASS_ID:
			setrType(SCALE_VAR); break;
		case CTRL_ROTATION_CLASS_ID:
			setrType(QUAT_VAR); break;
		default: setrType(VECTOR_VAR); //assert(0);
	}

	
	if (res.anim->SuperClassID()==BASENODE_CLASS_ID) {

		Control *c = ((INode*)res.anim)->GetTMController();
		if (c->ClassID() == BIPSLAVE_CONTROL_CLASS_ID || c->ClassID() == IKSLAVE_CLASSID)
		{
			isBiped = TRUE;
			setrType(QUAT_VAR);
			assignReactObj((INode*)res.anim, -2);
		}else {
			setrType(VECTOR_VAR);
			assignReactObj((INode*)res.anim, -1);
		}
	} 
	else {
		assignReactObj((INode*)res.client, res.subNum);
		}

	CreateReaction();
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);

	theHold.Accept(GetString(IDS_ASSIGN_TO));

}

*/ 

BOOL Reactor::assignReactObj(INode* client, int subNum)
{
	if (!client) return FALSE;

	reaction.ZeroCount();
	count = 0;
	selected = 0;

	VarRef vr(client);
	vrefs = vr;
	vrefs.subnum = subNum;
	if(MakeRefByID(FOREVER, 0, client) != REF_SUCCEED) {
		vrefs = NULL;
		count = 0;
		TSTR s = GetString(IDS_AF_CIRCULAR_DEPENDENCY);
		MessageBox(hParams, s, GetString(IDS_AF_CANT_ASSIGN), 
		MB_ICONEXCLAMATION | MB_SYSTEMMODAL | MB_OK);
		theHold.Cancel();
		return FALSE;
	}

	return TRUE;
}

void Reactor::updReactionCt(int val)
{
	count += val;
}


BOOL Reactor::CreateReaction(TCHAR *buf, TimeValue t)
{
	TSTR mname(GetString(IDS_AF_VARNAME));

	theHold.Begin();
	HoldParams();  

	if (buf == NULL)
	{
		if (!nmaker) nmaker = GetCOREInterface()->NewNameMaker(FALSE);
		nmaker->MakeUniqueName(mname);
	}else mname = buf;

	int i;
	SVar sv;
	sv.refID = -1;

	sv.strength = 1.0f;
	sv.falloff = 2.0f;
	sv.influence = 100.0f;

	i = reaction.Append(1, &sv);
	reaction[i].name = mname;
	setState(i, NULL, t);
	setReactionValue(i, NULL, t);
	updReactionCt(1);
	selected = i;

	//Scheme to set influence to nearest reaction automatically (better defaults)
	if (i!=0)		//if its not the first reaction
	{
		if(i == 1)   //and if it is the second one update the first while your at it
			setMinInfluence(0);
		setMinInfluence(i);
	}

	theHold.Accept(GetString(IDS_CREATE_REACTION));
	return TRUE;
}

BOOL Reactor::DeleteReaction(int i)
{
	if(vrefs.client != NULL)
	{		
		if (i == -1) i = selected;
		if (count>1)  //can't delete the last sVar
		{
			theHold.Begin();
			HoldParams(); 

			reaction.Delete(i, 1);
			updReactionCt(-1); 
			if (selected >= getVarCount() ) selected -=1;

			ivalid.SetEmpty();
			NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
			GetCOREInterface()->RedrawViews(GetCOREInterface()->GetTime());
			theHold.Accept(GetString(IDS_DELETE_REACTION));
			return TRUE;
		}

	}return FALSE;
}



TCHAR *Reactor::getVarName(int i)
{
	if(i>=0&&i<count&&count>0)
		return reaction[i].name;
	return "error";
}

void Reactor::setVarName(int i, TSTR name)
{
	if (i>=0&&i<count&&count>0)
		reaction[i].name = name;
}

void* Reactor::getReactionValue(int i)
{
	if(getVarCount() > 0 && i >= 0 && i < getVarCount())
	{
		switch (rtype)
		{
			case FLOAT_VAR:
				return &reaction[i].fvalue;
			case QUAT_VAR:
				return &reaction[i].qvalue;
			case VECTOR_VAR:
			case SCALE_VAR:
				return &reaction[i].pvalue;
			default: assert(0);
		}
	}
	return NULL;
}


BOOL Reactor::setReactionValue(int i, void *val, TimeValue t)
{
	float f;
	Quat q;
	Point3 p;
	ScaleValue s;
	Control *c;
	
	if (t == NULL) t = GetCOREInterface()->GetTime();

	if (i == -1) i = selected;

	if (vrefs.client != NULL) {

		theHold.Begin();
		HoldParams();
		
		reaction[i].fvalue = 0.0f;
		reaction[i].pvalue = Point3(0,0,0);
		reaction[i].qvalue.Identity();

		if ( val == NULL )
		{
			if (vrefs.subnum < 0 )
			{
				if (isBiped)	
				{
					GetAbsoluteControlValue(vrefs.client, t, &(reaction[i].qvalue), FOREVER);
				}
				else {
					GetAbsoluteControlValue(vrefs.client, t, &(reaction[i].pvalue), FOREVER);
				}
			}
			else {
				c = (Control *)vrefs.client->SubAnim(vrefs.subnum);
				switch (rtype)
				{
					case FLOAT_VAR:
						c->GetValue(t, &f, FOREVER);
						reaction[i].fvalue = f;
						break;
					case VECTOR_VAR:
						c->GetValue(t, &p, FOREVER);
						reaction[i].pvalue = p;
						break;
					case SCALE_VAR:
						c->GetValue(t, &s, FOREVER);
						reaction[i].pvalue = s.s;
						break;
					case QUAT_VAR:
						c->GetValue(t, &q, FOREVER);
						reaction[i].qvalue = q;
						break;
				}
			}
		} else {
			switch (rtype)
			{
				case FLOAT_VAR:
					reaction[i].fvalue = (*(float*)val);
					break;
				case SCALE_VAR:
				case VECTOR_VAR:
					reaction[i].pvalue = (*(Point3*)val);
					break;
				case QUAT_VAR:
					reaction[i].qvalue = (*(Quat*)val);
					break;
			}
		}
		if( ip ) dlg->UpdateReactionValue();   //Updates the value field
		ivalid.SetEmpty();
		NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
		GetCOREInterface()->RedrawViews(GetCOREInterface()->GetTime());
		theHold.Accept(GetString(IDS_UNSET_VALUE));
		return TRUE;
	}
	return FALSE;
}

float Reactor::getCurFloatValue(TimeValue t)
{
	float f;
	Control *c;

	if (vrefs.client != NULL) {
		c = GetControlInterface(vrefs.client->SubAnim(vrefs.subnum));
		c->GetValue(t, &f, FOREVER);
		return f;
	}
	return 0.0f;
}

Point3 Reactor::getCurPoint3Value(TimeValue t)
{
	Point3 p = Point3(0,0,0);
	Control *c;

	if (vrefs.client != NULL) {
		if (vrefs.subnum < 0 )
		{
			GetAbsoluteControlValue(vrefs.client, t, &p, FOREVER);
		}else {
			c = GetControlInterface(vrefs.client->SubAnim(vrefs.subnum));
			c->GetValue(t, &p, FOREVER);
		}
	}
	return p;
}

ScaleValue Reactor::getCurScaleValue(TimeValue t)
{
	ScaleValue ss;
	Control *c;

	if (vrefs.client != NULL) {
		c = GetControlInterface(vrefs.client->SubAnim(vrefs.subnum));
		c->GetValue(t, &ss, FOREVER);
	}
	return ss;
}

Quat Reactor::getCurQuatValue(TimeValue t)
{
	Quat q;
	q.Identity();
	Control *c;

	if (vrefs.client != NULL) {
		if (vrefs.subnum < 0 )
		{
			GetAbsoluteControlValue(vrefs.client, t, &q, FOREVER);
		}else {
			c = GetControlInterface(vrefs.client->SubAnim(vrefs.subnum));
			c->GetValue(t, &q, FOREVER);
		}
	}
	return q;
}



float Reactor::getInfluence(int num)
{
	return reaction[num].influence;
}

BOOL Reactor::setInfluence(int num, float inf)
{
	BOOL hold_here = false;

	if (!theHold.Holding()) { hold_here=true; theHold.Begin(); HoldParams();}

	reaction[num].influence = inf;

	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	GetCOREInterface()->RedrawViews(GetCOREInterface()->GetTime());
	if (hold_here) theHold.Accept(GetString(IDS_AF_CHANGEINFLUENCE));
	return TRUE;
}

void Reactor::setMinInfluence(int x)
{
	BOOL hold_here = false;
	if (!theHold.Holding()) 
	{ 
		hold_here=true; theHold.Begin(); HoldParams();
	}
	
	if ( x == -1 ) x = selected;
	float dist = 1000000.0f;
	float disttemp = 100.0f;
	Point3 axis;

	if ( count && x >= 0 )
	{
		for(int i=0;i<count;i++)
		{
			if (i != x)
			{
				switch (rtype)
				{
					case FLOAT_VAR:
						disttemp = (float)fabs(reaction[x].fvalue - reaction[i].fvalue);
						break;
					case VECTOR_VAR: 
					case SCALE_VAR: 
						disttemp = Distance(reaction[i].pvalue, reaction[x].pvalue);
						break;
					case QUAT_VAR: 
						disttemp = QangAxis(reaction[i].qvalue, reaction[x].qvalue, axis);
						break;
					default: disttemp = 100.0f; break;
				} 
			}
			if (disttemp != 0.0f) 
			{
				dist = (dist <= disttemp && dist != 100 ? dist : disttemp);
			} else if (dist == 1000000.0f && i == count-1) dist = 100.0f;
		}
		reaction[x].influence = dist;
		NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
		if (hold_here) theHold.Accept(GetString(IDS_AF_CHANGEINFLUENCE));
	}
}

void Reactor::setMaxInfluence(int x)
{
	BOOL hold_here = false;
	if (!theHold.Holding()) { hold_here=true; theHold.Begin(); HoldParams();}
	
	if ( x == -1 ) x = selected;

	float dist;
	float disttemp;
	Point3 axis;

	if ( count && x >= 0 )
	{
		for(int i=0;i<count;i++)
		{
			switch (rtype)
			{
				case FLOAT_VAR:
					disttemp = (float)fabs(reaction[x].fvalue - reaction[i].fvalue);
					break;
				case VECTOR_VAR: 
				case SCALE_VAR: 
					disttemp = Distance(reaction[i].pvalue, reaction[x].pvalue);
					break;
				case QUAT_VAR: 
					disttemp = QangAxis(reaction[i].qvalue, reaction[x].qvalue, axis);
					break;
				default: disttemp = 100.0f; break;
			}
			if (i == 0) dist = disttemp;
			else dist = (dist >= disttemp ? dist : disttemp);
		}
		reaction[x].influence = dist;
		NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
		if (hold_here) theHold.Accept(GetString(IDS_AF_CHANGEINFLUENCE));
	}
}



float Reactor::getStrength(int num)
{
	return reaction[num].strength;
}

BOOL Reactor::setStrength(int num, float inf)
{
	BOOL hold_here = false;

	if (!theHold.Holding()) { hold_here=true; theHold.Begin(); HoldParams();}

	reaction[num].strength = inf;

	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	GetCOREInterface()->RedrawViews(GetCOREInterface()->GetTime());
	if(hold_here) theHold.Accept(GetString(IDS_AF_CHANGESTRENGTH));
	return TRUE;
}

float Reactor::getFalloff(int num)
{
	return reaction[num].falloff;
}

BOOL Reactor::setFalloff(int num, float inf)
{
	BOOL hold_here = false;

	if (!theHold.Holding()) { hold_here=true; theHold.Begin(); HoldParams();}

	reaction[num].falloff = inf;

	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	GetCOREInterface()->RedrawViews(GetCOREInterface()->GetTime());
	if (hold_here) theHold.Accept(GetString(IDS_AF_CHANGEFALLOFF));
	return TRUE;
}

BOOL Reactor::setEditing(BOOL ed)
{
	editing = ed;
	ivalid.SetEmpty();
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime());
	return editing;
}

BOOL Reactor::setState(int num, void *val, TimeValue t)
{
	if (t == NULL) t = GetCOREInterface()->GetTime();
	switch (type)
	{
		case REACTORFLOAT: 
			if (val==NULL) 
				this->GetValue(t, &(reaction[num].fstate), FOREVER, CTRL_ABSOLUTE);
				else reaction[num].fstate = *((float*)val);
			break; 
		case REACTORROT: 
			 if (val==NULL) 
				 this->GetValue(t, &(reaction[num].qstate), FOREVER, CTRL_ABSOLUTE);
				else reaction[num].qstate = *((Quat*)val);
			break; 
		case REACTORP3: 
		case REACTORSCALE: 
		case REACTORPOS: 
			if (val==NULL) 
				this->GetValue(t, &(reaction[num].pstate), FOREVER, CTRL_ABSOLUTE);
				else reaction[num].pstate = *((Point3*)val);
			break; 
		default: return false;
	}
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	GetCOREInterface()->RedrawViews(GetCOREInterface()->GetTime());
	return true; 
}


void* Reactor::getState(int num)
{
	if(getVarCount() > 0 && num >= 0 && num < getVarCount())
		switch (type)
		{
			case REACTORFLOAT: 
				return &reaction[num].fstate; 
			case REACTORROT: 
				return &reaction[num].qstate;
			case REACTORP3: 
			case REACTORSCALE: 
			case REACTORPOS: 
				return &reaction[num].pstate;

		}
	return NULL;
}


void Reactor::BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev )
{
}

void Reactor::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next )
{
}


void Reactor::GetAbsoluteControlValue(
		INode *node,TimeValue t,void *pt,Interval &iv)
{
	if (node != NULL)
	{
		if (isBiped)
		{
			Matrix3 cur_mat = node->GetNodeTM(t,&iv);
			Matrix3 par_mat =  node->GetParentTM(t);
			Matrix3 relative_matrix = cur_mat * Inverse( par_mat);
			Quat q = Quat(relative_matrix);
			*(Quat*)pt = q;
		}else {	
			Matrix3 tm = node->GetNodeTM(t,&iv);
			*(Point3*)pt = tm.GetTrans();
		}
	}
}


//--------------------------------------------------------------------

BOOL Reactor::ChangeParents(TimeValue t,const Matrix3& oldP,const Matrix3& newP,const Matrix3& tm)
	{
		HoldAll();
		// Position and rotation controllers need their path counter rotated to
		// account for the new parent.
		Matrix3 rel = oldP * Inverse(newP);
		// Modify the controllers current value (the controllers cache)
		*((Point3*)(&curpval)) = *((Point3*)(&curpval)) * rel;
		*((Quat*)(&curqval)) = *((Quat*)(&curqval)) * rel;

		//Modify each reaction state 
		for (int i=0;i<count;i++)
		{
			*((Point3*)(&reaction[i].pstate)) = *((Point3*)(&reaction[i].pstate)) * rel;
			*((Quat*)(&reaction[i].qstate)) = *((Quat*)(&reaction[i].qstate)) * rel;
		}
		ivalid.SetEmpty();
		return TRUE;
	}

void Reactor::Update(TimeValue t)
{
	if (!ivalid.InInterval(t))
	{
		ivalid = FOREVER;		
		if (vrefs.client!=NULL)
		{
			float f;
			Quat q;
			Point3 p;
			ScaleValue s;
			//update the validity interval
			if (vrefs.subnum < 0 )
			{
				if (isBiped) GetAbsoluteControlValue(vrefs.client, t, &q, ivalid);
					else GetAbsoluteControlValue(vrefs.client, t, &p, ivalid);
			}else {
				switch (rtype)
				{
				case FLOAT_VAR:
					GetControlInterface(vrefs.client->SubAnim(vrefs.subnum))->GetValue(t, &f, ivalid);
					break;
				case VECTOR_VAR:
					GetControlInterface(vrefs.client->SubAnim(vrefs.subnum))->GetValue(t, &p, ivalid);
					break;
				case SCALE_VAR:
					GetControlInterface(vrefs.client->SubAnim(vrefs.subnum))->GetValue(t, &s, ivalid);
					break;
				case QUAT_VAR:
					GetControlInterface(vrefs.client->SubAnim(vrefs.subnum))->GetValue(t, &q, ivalid);
					break;
				}
			}
			curfval = reaction[selected].fstate;
			curpval = reaction[selected].pstate;
			curqval = reaction[selected].qstate;
		}
	}
}


void Reactor::SetValue(TimeValue t, void *val, int commit, GetSetMethod method)
{
	if (editing && count) {
		if (!TestAFlag(A_SET)) {				
			HoldTrack();
			tmpStore.PutBytes(sizeof(Point3),&curpval,this);
			SetAFlag(A_SET);
			}
		if (method == CTRL_RELATIVE) curpval += *((Point3*)val);
		else curpval = *((Point3*)val);

		ivalid.SetInstant(t);	
		if (commit) CommitValue(t);
		if (!commit) NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}
}


void Reactor::CommitValue(TimeValue t) {
	if (TestAFlag(A_SET)) {		
		if (ivalid.InInterval(t)) {

			Point3 old;
			tmpStore.GetBytes(sizeof(Point3),&old,this);					
			reaction[selected].pstate = curpval;

			tmpStore.Clear(this);
			ivalid.SetEmpty();
			NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
		}
		ClearAFlag(A_SET);
	}
}

void Reactor::RestoreValue(TimeValue t) 
	{
	if (TestAFlag(A_SET)) {
		if (count) {
			tmpStore.GetBytes(sizeof(Point3),&curpval,this);
			reaction[selected].pstate = curpval;
			tmpStore.Clear(this);
			ivalid.SetInstant(t);
			}
		ClearAFlag(A_SET);
		}
	}



//------------------------------------------------------------

RefTargetHandle FloatReactor::Clone(RemapDir& remap)
	{
	// make a new reactor controller and give it our param values.
	FloatReactor *cont = new FloatReactor(TRUE);
	*cont = *this;
	CloneControl(cont,remap);
	return cont;
	}

void FloatReactor::GetValue(
		TimeValue t, void *val, Interval &valid, GetSetMethod method)
{
	Update(t);
	valid &= ivalid;  
	if (!editing)
	{
		ComputeMultiplier(t);
		//sum up all the weighted states
		float ray = 0.0f;
		for(int i=0;i<count;i++)
			ray +=((reaction[i].fstate)*reaction[i].multiplier);
		if (count) curfval = ray;  
	}

	if (method==CTRL_RELATIVE) {
		*((float*)val) += curfval;
	} else {
		*((float*)val) = curfval;
	}
		
}


//--------------------------------------------------------------------------

RefTargetHandle PositionReactor::Clone(RemapDir& remap)
{
	// make a new reactor controller and give it our param values.
	PositionReactor *cont = new PositionReactor(TRUE);
	*cont = *this;
	CloneControl(cont,remap);
	return cont;
}

void PositionReactor::GetValue(
		TimeValue t, void *val, Interval &valid, GetSetMethod method)
{
	Point3 ray = Point3(0,0,0);

	Update(t);
	valid &= ivalid;  
	if (!editing && count)
	{
		ComputeMultiplier(t);
		//sum up all the weighted states
		for(int i=0;i<count;i++)
			ray +=((reaction[i].pstate)*reaction[i].multiplier);
		curpval = ray;  
	}

	if (method==CTRL_RELATIVE) {
  		Matrix3 *mat = (Matrix3*)val;	
		mat->PreTranslate(curpval);
	} else {
		*((Point3*)val) = curpval;
	}
}
//---------------------------------------------------------

RefTargetHandle Point3Reactor::Clone(RemapDir& remap)
	{
	// make a new reactor controller and give it our param values.
	Point3Reactor *cont = new Point3Reactor(TRUE);
	*cont = *this;	
	CloneControl(cont,remap);
	return cont;
	}

void Point3Reactor::GetValue(
		TimeValue t, void *val, Interval &valid, GetSetMethod method)
	{
	Update(t);
	valid &= ivalid;  
	if (!editing && count)
	{
		ComputeMultiplier(t);
		//sum up all the weighted states
		Point3 ray = Point3(0,0,0);
		for(int i=0;i<count;i++)
			ray +=((reaction[i].pstate)*reaction[i].multiplier);
		curpval = ray;  
	}

	if (method==CTRL_RELATIVE) {
		*((Point3*)val) += curpval;
	} else {
		*((Point3*)val) = curpval;
	}
}



//--------------------------------------------------------------------------

RefTargetHandle ScaleReactor::Clone(RemapDir& remap)
	{
	// make a new reactor controller and give it our param values.
	ScaleReactor *cont = new ScaleReactor(TRUE);
	*cont = *this;
	CloneControl(cont,remap);
	return cont;
	}

void ScaleReactor::GetValue(
		TimeValue t, void *val, Interval &valid, GetSetMethod method)
{
	Update(t);
	valid &= ivalid;  
	if (!editing && count)
	{
		ComputeMultiplier(t);
		//sum up all the weighted states
		Point3 ray = Point3(0,0,0);
		for(int i=0;i<count;i++)
			ray +=((reaction[i].pstate)*reaction[i].multiplier);
		curpval = ray;  
	}

	if (method==CTRL_RELATIVE) {
  		Matrix3 *mat = (Matrix3*)val;
		ApplyScaling(*mat, curpval);
	} else {
		*((Point3*)val) = curpval;
	}
}


void ScaleReactor::SetValue(TimeValue t, void *val, int commit, GetSetMethod method)
{
	if (editing && count) {
		if (!TestAFlag(A_SET)) {				
			HoldTrack();
			tmpStore.PutBytes(sizeof(Point3),&curpval,this);
			SetAFlag(A_SET);
			}
		if (method == CTRL_RELATIVE) curpval *= *((Point3*)val);
		else curpval = *((Point3*)val);

		ivalid.SetInstant(t);	
		if (commit) CommitValue(t);
		if (!commit) NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}
}


//------------------------------------------------------------------

RefTargetHandle RotationReactor::Clone(RemapDir& remap)
	{
	// make a new reactor controller and give it our param values.
	RotationReactor *cont = new RotationReactor(TRUE);
	*cont = *this;	
	CloneControl(cont,remap);
	return cont;
	}

void RotationReactor::GetValue(
		TimeValue t, void *val, Interval &valid, GetSetMethod method)
{
	float eulr[3];

	Update(t);
	valid &= ivalid;  
	if (!editing)
	{
		ComputeMultiplier(t);
		//sum up all the weighted states
		curqval.Identity();
		Quat ray;
		
		for(int i=0;i<count;i++)
		{
			ray = reaction[i].qstate;
			QuatToEuler(ray, eulr);
			eulr[0] *= reaction[i].multiplier;
			eulr[1] *= reaction[i].multiplier;
			eulr[2] *= reaction[i].multiplier;
			EulerToQuat(eulr, ray);

			curqval += ray;
		}
	}

	if (method==CTRL_RELATIVE) {
  	Matrix3 *mat = (Matrix3*)val;		//Why is mat always (0,0,0)???
	PreRotateMatrix(*mat, curqval);
	} else {
		*((Quat*)val) = curqval;
	}
		
}

void RotationReactor::SetValue(TimeValue t, void *val, int commit, GetSetMethod method)
{
	if (editing && count) {
		if (!TestAFlag(A_SET)) {				
			HoldTrack();
			tmpStore.PutBytes(sizeof(Point3),&curpval,this);
			SetAFlag(A_SET);
			}

		if (method == CTRL_RELATIVE) curqval *= Quat(*((AngAxis*)val));
		else curqval = Quat(*((AngAxis*)val));

		ivalid.SetInstant(t);	
		if (commit) CommitValue(t);
		if (!commit) NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	}
}


void RotationReactor::CommitValue(TimeValue t) {
	if (TestAFlag(A_SET)) {		
		if (ivalid.InInterval(t)) {

			Quat old;
			tmpStore.GetBytes(sizeof(Quat),&old,this);					
			reaction[selected].qstate = curqval;

			tmpStore.Clear(this);
			ivalid.SetEmpty();
			NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
		}
		ClearAFlag(A_SET);
	}
}

void RotationReactor::RestoreValue(TimeValue t) 
	{
	if (TestAFlag(A_SET)) {
		if (count) {
			tmpStore.GetBytes(sizeof(Quat),&curqval,this);
			reaction[selected].qstate = curqval;
			tmpStore.Clear(this);
			ivalid.SetInstant(t);
			}
		ClearAFlag(A_SET);
		}
	}


//--------------------------------------------------------------------------

class ReactionFilter : public TrackViewFilter {
public:
	BOOL proc(Animatable *anim, Animatable *client, int subNum)
	{ 
		
		if (anim->SuperClassID() == BASENODE_CLASS_ID) {
			INode *node = (INode*)anim;
			return !node->IsRootNode();
			}

		return anim->SuperClassID() == CTRL_FLOAT_CLASS_ID ||
			anim->SuperClassID() == CTRL_POSITION_CLASS_ID ||
			anim->SuperClassID() == CTRL_POINT3_CLASS_ID ||
			anim->SuperClassID() == CTRL_SCALE_CLASS_ID ||
			anim->SuperClassID() == CTRL_ROTATION_CLASS_ID || 
			anim->SuperClassID() == BASENODE_CLASS_ID; 
	}

};


//--------------------------------------------------------------
// UI Stuff
//--------------------------------------------------------------

void ReactorDlg::UpdateVarList()
{
	int i, ct;

	SendDlgItemMessage(hWnd, IDC_REACTION_LIST, LB_SETCURSEL, cont->selected, 0);
	if (cont->selected >= cont->getVarCount() ) cont->selected -=1;
	ct = cont->getVarCount();
	SendDlgItemMessage(hWnd, IDC_REACTION_LIST, LB_RESETCONTENT, 0, 0);
	for(i = 0; i < ct; i++)
	{
		SendDlgItemMessage(hWnd, IDC_REACTION_LIST, LB_ADDSTRING, 0, (LPARAM)cont->getVarName(i));
	}
	SendDlgItemMessage(hWnd, IDC_REACTION_LIST, LB_SETCURSEL, cont->selected, 0);

	i = cont->selected;
	if(i >=0 ) {
			
		iNameEdit->SetText(cont->reaction[i].name);
		UpdateReactionValue();
		iInfluence->SetValue(cont->reaction[i].influence, FALSE);
		iFalloff[0]->SetValue(cont->reaction[i].falloff, FALSE);
		iStrength->SetValue(cont->reaction[i].strength, FALSE);
	}
	cont->ivalid.SetEmpty();
	cont->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	if (ip) ip->RedrawViews(ip->GetTime());
}

void ReactorDlg::UpdateReactionValue()
{
	AngAxis aa;
	float f;
	TCHAR buf[256];
	_stprintf(buf, _T(""));
	int i = cont->selected;

	if (cont->vrefs.client)
	{
		switch (cont->rtype)
		{
			case FLOAT_VAR:
				assert(SetDlgItemFloat(hWnd, IDC_VALUE_STATUS, cont->reaction[i].fvalue));
				break;
			case VECTOR_VAR:
			case SCALE_VAR:
				_stprintf(buf, _T("( %g; %g; %g )"), cont->reaction[i].pvalue[0], cont->reaction[i].pvalue[1], cont->reaction[i].pvalue[2]);
				SetDlgItemText(hWnd, IDC_VALUE_STATUS, buf);	
				break;
			case QUAT_VAR:
				aa = cont->reaction[i].qvalue;
				f = RadToDeg(aa.angle);
				_stprintf(buf, _T("%g ( %g; %g; %g )"), f, aa.axis.x, aa.axis.y, aa.axis.z);
				SetDlgItemText(hWnd, IDC_VALUE_STATUS, buf);	
				break;
		}
	}
	else SetDlgItemText(hWnd, IDC_VALUE_STATUS, buf);	
}

//------------------------------------------------------------


static BOOL CALLBACK ReactorDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

class ReactorCtrlWindow {
	public:
		HWND hWnd;
		HWND hParent;
		Control *cont;
		ReactorCtrlWindow() {assert(0);}
		ReactorCtrlWindow(HWND hWnd,HWND hParent,Control *cont)
			{this->hWnd=hWnd; this->hParent=hParent; this->cont=cont;}
	};
static Tab<ReactorCtrlWindow> reactorCtrlWindows;

static void RegisterReactorCtrlWindow(HWND hWnd, HWND hParent, Control *cont)
	{
	ReactorCtrlWindow rec(hWnd,hParent,cont);
	reactorCtrlWindows.Append(1,&rec);
	}

static void UnRegisterReactorCtrlWindow(HWND hWnd)
	{	
	for (int i=0; i<reactorCtrlWindows.Count(); i++) {
		if (hWnd==reactorCtrlWindows[i].hWnd) {
			reactorCtrlWindows.Delete(i,1);
			return;
			}
		}	
	}

static HWND FindOpenReactorCtrlWindow(HWND hParent,Control *cont)
	{	
	for (int i=0; i<reactorCtrlWindows.Count(); i++) {
		if (hParent == reactorCtrlWindows[i].hParent &&
			cont    == reactorCtrlWindows[i].cont) {
			return reactorCtrlWindows[i].hWnd;
			}
		}
	return NULL;
	}



ReactorDlg::ReactorDlg(
		Reactor *cont,
		ParamDimensionBase *dim,
		TCHAR *pname,
		IObjParam *ip,
		HWND hParent)
	{
	this->cont = cont;
	this->ip   = ip;
	this->dim  = dim;
	valid = FALSE;
	elems = cont->Elems();
	MakeRefByID(FOREVER,0,cont);
	cont->hParams = hWnd = CreateDialogParam(
		hInstance,
		MAKEINTRESOURCE(IDD_REACTOR_PARAMS),
		hParent,
		ReactorDlgProc,
		(LPARAM)this);	
	TSTR title = TSTR(GetString(IDS_AF_REACTORTITLE)) + TSTR(pname);
	SetWindowText(hWnd,title);
	ip->RegisterTimeChangeCallback(this);
	reactorShortcutCB = new ReactorShortcutCB<Reactor>(cont);
	ip->ActivateShortcutTable(reactorShortcutCB, kReactorShortcuts);
	}

ReactorDlg::~ReactorDlg()
	{
	ip->DeactivateShortcutTable(reactorShortcutCB, kReactorShortcuts);
	delete reactorShortcutCB;

	UnRegisterReactorCtrlWindow(hWnd);
	ip->UnRegisterTimeChangeCallback(this);
	cont->hParams = NULL;
	cont->ip = NULL;
	cont->dlg = NULL;
	DeleteAllRefsFromMe();

	ReleaseISpinner(iFloatState);
	ReleaseISpinner(iInfluence);
	ReleaseISpinner(iStrength);
	ReleaseISpinner(iFalloff[0]);
	ReleaseICustEdit(iNameEdit);
	ReleaseICustEdit(iValueStatus);
	ReleaseICustButton(iCreateBut);
	ReleaseICustButton(iDeleteBut);
	ReleaseICustButton(iSetBut);
	ReleaseICustButton(iEditBut);

	}

void ReactorDlg::Invalidate()
	{
	valid = FALSE;
	InvalidateRect(hWnd,NULL,FALSE);
	}

void ReactorDlg::UpdateNodeName()
	{
		TSTR nname, pname;
		pname = "";
		
		if (cont->vrefs.client)
		{

			if(cont->vrefs.subnum < 0)	// special case: we're referencing a node
				pname = ((INode *)cont->vrefs.client)->GetName();
			else {
				cont->getNodeName(cont->vrefs.client,nname);
				if (nname.Length())
					pname = nname + TSTR(_T("\\")) + cont->vrefs.client->SubAnimName(cont->vrefs.subnum);
				else 
					pname = cont->vrefs.client->SubAnimName(cont->vrefs.subnum);
			}
			assert(SetDlgItemText(hWnd, IDC_TRACK_NAME, pname));
		} else{
			assert(SetDlgItemText(hWnd, IDC_TRACK_NAME, pname));
		}
	}

void ReactorDlg::Update()
{
	TCHAR buf[256];

	if (cont->count) {
		valid = FALSE;
		float fval, f;
		Point3 pval;
		Quat qval;
		AngAxis aa;
		ScaleValue sval;
		Control *c;

		iFloatState->Enable(TRUE);
		iInfluence->Enable(TRUE);
		iFalloff[0]->Enable(TRUE);
		iStrength->Enable(TRUE);
		iCreateBut->Enable(TRUE);
		iDeleteBut->Enable(TRUE);
		iSetBut->Enable(TRUE);
		iEditBut->Enable(TRUE);

		iFloatState->SetValue(cont->reaction[cont->selected].fstate, FALSE);
		iStrength->SetValue(cont->reaction[cont->selected].strength, FALSE);
		iFalloff[0]->SetValue(cont->reaction[cont->selected].falloff, FALSE);
		iInfluence->SetValue(cont->reaction[cont->selected].influence, FALSE);

		UpdateVarList();
		UpdateNodeName();
		iEditBut->SetCheck(cont->editing);

		if (cont->vrefs.subnum < 0 )
		{
			if (cont->isBiped)	
			{
				cont->GetAbsoluteControlValue(cont->vrefs.client, ip->GetTime(), &qval, FOREVER);
					aa = qval;
					f = RadToDeg(aa.angle);
					_stprintf(buf, _T("%g ( %g; %g; %g )"), f, aa.axis.x, aa.axis.y, aa.axis.z);
			}
			else {
				cont->GetAbsoluteControlValue(cont->vrefs.client, ip->GetTime(), &pval, FOREVER);
				_stprintf(buf, _T("( %g; %g; %g )"), pval.x, pval.y, pval.z);
			}
			SetDlgItemText(hWnd, IDC_TRACK_VALUE, buf);	
		}
		else {
			c = (Control *)cont->vrefs.client->SubAnim(cont->vrefs.subnum);
			switch (cont->rtype)
			{
				case FLOAT_VAR:
					c->GetValue(ip->GetTime(), &fval, FOREVER);
					assert(SetDlgItemFloat(hWnd, IDC_TRACK_VALUE, fval));
					break;
				case VECTOR_VAR:
					c->GetValue(ip->GetTime(), &pval, FOREVER);
					_stprintf(buf, _T("( %g; %g; %g )"), pval.x, pval.y, pval.z);
					SetDlgItemText(hWnd, IDC_TRACK_VALUE, buf);	
					break;
				case SCALE_VAR:
					c->GetValue(ip->GetTime(), &sval, FOREVER);
					_stprintf(buf, _T("( %g; %g; %g )"), sval.s.x, sval.s.y, sval.s.z);
					SetDlgItemText(hWnd, IDC_TRACK_VALUE, buf);	
					break;
				case QUAT_VAR:
					c->GetValue(ip->GetTime(), &qval, FOREVER);
					aa = qval;
					f = RadToDeg(aa.angle);
					_stprintf(buf, _T("%g ( %g; %g; %g )"), f, aa.axis.x, aa.axis.y, aa.axis.z);
					SetDlgItemText(hWnd, IDC_TRACK_VALUE, buf);	
					break;
			}
		}
		switch (cont->type)
		{
			case REACTORFLOAT:
				assert(SetDlgItemFloat(hWnd, IDC_OUTPUT_STATUS, cont->curfval));
				break;
			case REACTORPOS:
			case REACTORP3:
			case REACTORSCALE:
				_stprintf(buf, _T("( %g; %g; %g )"), cont->curpval.x, cont->curpval.y, cont->curpval.z);
				SetDlgItemText(hWnd, IDC_OUTPUT_STATUS, buf);	
				break;
			case REACTORROT:
				aa = cont->curqval;
				f = RadToDeg(aa.angle);
				_stprintf(buf, _T("%g ( %g; %g; %g )"), f, aa.axis.x, aa.axis.y, aa.axis.z);
				SetDlgItemText(hWnd, IDC_OUTPUT_STATUS, buf);	
				break;
		}		
	} else{
		_stprintf(buf, _T(""));
		iFloatState->Enable(FALSE);
		iInfluence->Enable(FALSE);
		iFalloff[0]->Enable(FALSE);
		iStrength->Enable(FALSE);
		iCreateBut->Enable(FALSE);
		iDeleteBut->Enable(FALSE);
		iSetBut->Enable(FALSE);
		iEditBut->Enable(FALSE);
		UpdateNodeName();
		UpdateVarList();
		UpdateReactionValue();
		SetDlgItemText(hWnd, IDC_TRACK_VALUE, buf);	
		SetDlgItemText(hWnd, IDC_OUTPUT_STATUS, buf);
		iNameEdit->SetText("");
	}
}


void ReactorDlg::SetupUI(HWND hWnd)
{
	this->hWnd = hWnd;

	iFloatState = GetISpinner(GetDlgItem(hWnd,IDC_FLOATSTATE_SPIN));
	iFloatState ->SetLimits(-99999,99999,FALSE);
	iFloatState ->SetAutoScale();
	iFloatState ->LinkToEdit(GetDlgItem(hWnd,IDC_FLOATSTATE_EDIT),EDITTYPE_FLOAT);	

	iStrength = GetISpinner(GetDlgItem(hWnd,IDC_STRENGTH_SPIN));
	iStrength ->SetLimits(0,99999,FALSE);
	iStrength ->SetAutoScale();
	iStrength ->LinkToEdit(GetDlgItem(hWnd,IDC_STRENGTH_EDIT),EDITTYPE_FLOAT);	

	iFalloff[0] = GetISpinner(GetDlgItem(hWnd,IDC_FALLOFF_SPIN));
	iFalloff[0] ->SetLimits(0.001f,10.0f,FALSE);
	iFalloff[0] ->SetAutoScale();
	iFalloff[0] ->LinkToEdit(GetDlgItem(hWnd,IDC_FALLOFF_EDIT),EDITTYPE_FLOAT);	

	iInfluence = GetISpinner(GetDlgItem(hWnd,IDC_INFLUENCE_SPIN));
	iInfluence ->SetLimits(0.0f,99999.0f,FALSE);
	iInfluence ->SetAutoScale();
	iInfluence ->LinkToEdit(GetDlgItem(hWnd,IDC_INFLUENCE_EDIT),EDITTYPE_FLOAT);	

	iNameEdit = GetICustEdit(GetDlgItem(hWnd,IDC_NAME_EDIT));
	iValueStatus = GetICustEdit(GetDlgItem(hWnd,IDC_VALUE_STATUS));
	
	iCreateBut = GetICustButton(GetDlgItem(hWnd,IDC_CREATE_BUTTON));
	iDeleteBut = GetICustButton(GetDlgItem(hWnd,IDC_DELETE_BUTTON));
	iSetBut    = GetICustButton(GetDlgItem(hWnd,IDC_SET_BUTTON));
	iEditBut   = GetICustButton(GetDlgItem(hWnd,IDC_EDIT_BUTTON));
	iCreateBut->SetType(CBT_PUSH);
	iDeleteBut->SetType(CBT_PUSH);
	iSetBut->SetType(CBT_PUSH);
	iEditBut->SetType(CBT_CHECK);
	iEditBut->SetHighlightColor(GREEN_WASH);

	if (cont->ClassID() == REACTORFLOAT_CLASS_ID){
		ShowWindow(GetDlgItem(hWnd, IDC_EDIT_BUTTON), SW_HIDE);
	}
	else{
		ShowWindow(GetDlgItem(hWnd, IDC_FLOATSTATE_SPIN), SW_HIDE);
		ShowWindow(GetDlgItem(hWnd, IDC_FLOATSTATE_EDIT), SW_HIDE);
		ShowWindow(GetDlgItem(hWnd, IDC_EDITSTATE_STATIC), SW_HIDE);
	}

	if (!cont->reaction.Count())
	{
		iFloatState->Enable(FALSE);
		iInfluence->Enable(FALSE);
		iFalloff[0]->Enable(FALSE);
		iStrength->Enable(FALSE);
		iCreateBut->Enable(FALSE);
		iDeleteBut->Enable(FALSE);
		iSetBut->Enable(FALSE);
		iEditBut->Enable(FALSE);
	}
}


void ReactorDlg::WMCommand(int id, int notify, HWND hCtrl)
	{
		Point3 pt;
		TrackViewPick res;
		ReactionFilter rf;

		switch (id) {
			case IDC_PICK_BUTTON:
				if(cont->ip->TrackViewPickDlg(hWnd, &res, &rf)) {
//				cont->assignTo(res);
				cont->reactTo(res.anim);
				}break;
			case IDC_CREATE_BUTTON:
					if(cont->vrefs.client != NULL)
						cont->CreateReaction();
				break;
			case IDC_REACTION_LIST:
				if(notify == LBN_SELCHANGE) {
					cont->selected = SendDlgItemMessage(hWnd, IDC_REACTION_LIST, LB_GETCURSEL, 0, 0);
					UpdateVarList();
				}break;
			case IDC_DELETE_BUTTON:
				cont->DeleteReaction();
				break;
			case IDC_SET_BUTTON:
				if(cont->vrefs.client != NULL)
					cont->setReactionValue(cont->selected);
				break;
			case IDC_EDIT_BUTTON:
				cont->setEditing(iEditBut->IsChecked());
				break;
			default: break;
		}
	}

void ReactorDlg::SpinnerChange(int id,BOOL drag)
	{

	if (!drag)
		if (!theHold.Holding()) {
		SpinnerStart(id);
		}
	
	switch (id) {
		case IDC_FALLOFF_SPIN:
			cont->setFalloff(cont->selected, (float)iFalloff[0]->GetFVal());
			break;
		case IDC_INFLUENCE_SPIN:
			cont->setInfluence(cont->selected, (float)iInfluence->GetFVal());
			break;

		case IDC_STRENGTH_SPIN:
			cont->setStrength(cont->selected, (float)iStrength->GetFVal());
			break;

		case IDC_FLOATSTATE_SPIN:
			cont->HoldParams();
			cont->reaction[cont->selected].fstate = (float)iFloatState->GetFVal();
			break;
		}
		Change(FALSE);
	}

void ReactorDlg::SpinnerStart(int id)
	{
	switch (id) {
		case IDC_FLOATSTATE_SPIN:
		case IDC_STRENGTH_SPIN:
		case IDC_INFLUENCE_SPIN:
		case IDC_FALLOFF_SPIN:
			theHold.Begin();
			cont->HoldParams();
			break;
		}
	}

void ReactorDlg::SpinnerEnd(int id,BOOL cancel)
{
	if (cancel) {
		theHold.Cancel();
	} else {
	switch (id) {
		case IDC_FLOATSTATE_SPIN:
		case IDC_FLOATSTATE_EDIT:
			theHold.Accept(GetString(IDS_AF_CHANGESTATE));
			break;
		case IDC_STRENGTH_SPIN:
		case IDC_STRENGTH_EDIT:
			theHold.Accept(GetString(IDS_AF_CHANGESTRENGTH));
			break;
		case IDC_INFLUENCE_SPIN:
		case IDC_INFLUENCE_EDIT:
			theHold.Accept(GetString(IDS_AF_CHANGEINFLUENCE));
			break;
		case IDC_FALLOFF_SPIN:
		case IDC_FALLOFF_EDIT:
			theHold.Accept(GetString(IDS_AF_CHANGEFALLOFF));
			break;
		}
	}
	ip->RedrawViews(ip->GetTime());
}

void ReactorDlg::Change(BOOL redraw)
	{
	cont->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	UpdateWindow(GetParent(hWnd));	
	if (redraw) ip->RedrawViews(ip->GetTime());
	}


class CheckForNonReactorDlg : public DependentEnumProc {
	public:		
		BOOL non;
		ReferenceMaker *me;
		CheckForNonReactorDlg(ReferenceMaker *m) {non = FALSE;me = m;}
		int proc(ReferenceMaker *rmaker) {
			if (rmaker==me) return 0;
			if (rmaker->SuperClassID()!=REF_MAKER_CLASS_ID &&
				rmaker->ClassID()!=Class_ID(REACTORDLG_CLASS_ID,0x67053d10)) {
				non = TRUE;
				return 1;
				}
			return 0;
			}
	};
void ReactorDlg::MaybeCloseWindow()
	{
	CheckForNonReactorDlg check(cont);
	cont->EnumDependents(&check);
	if (!check.non) {
		PostMessage(hWnd,WM_CLOSE,0,0);
		}
	}



RefResult ReactorDlg::NotifyRefChanged(
		Interval changeInt, 
		RefTargetHandle hTarget, 
     	PartID& partID,  
     	RefMessage message)
	{
	switch (message) {
		case REFMSG_CHANGE:
			Invalidate();			
			break;
		
		case REFMSG_REF_DELETED:
			MaybeCloseWindow();
			break;
		}
	return REF_SUCCEED;
	}


static BOOL CALLBACK ReactorDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	ReactorDlg *dlg = (ReactorDlg*)GetWindowLong(hWnd,GWL_USERDATA);
	int i;
	TCHAR buf[256];

	switch (msg) {
		case WM_INITDIALOG:
			dlg = (ReactorDlg*)lParam;
			SetWindowLong(hWnd,GWL_USERDATA,lParam);
			dlg->SetupUI(hWnd);
			if (dlg->cont->vrefs.client){
				dlg->UpdateNodeName();
				dlg->UpdateVarList();
				dlg->iEditBut->SetCheck(dlg->cont->editing);
			}
			break;

		case CC_SPINNER_BUTTONDOWN:
			dlg->SpinnerStart(LOWORD(wParam));
			break;

		case CC_SPINNER_CHANGE:
			dlg->SpinnerChange(LOWORD(wParam),HIWORD(wParam));
			break;

		case WM_CUSTEDIT_ENTER:
			switch (LOWORD(wParam)) 
			{
				case IDC_NAME_EDIT:
					i = SendDlgItemMessage(hWnd, IDC_REACTION_LIST, LB_GETCURSEL, 0, 0);
					if (i>=0)
					{
						dlg->iNameEdit->GetText(buf, 256);
						dlg->cont->reaction[dlg->cont->selected].name = buf;
						dlg->UpdateVarList();						
					}
					break;
				default: dlg->SpinnerEnd(LOWORD(wParam),FALSE);
			}

		case CC_SPINNER_BUTTONUP:
			dlg->SpinnerEnd(LOWORD(wParam),!HIWORD(wParam));
			break;

		case WM_COMMAND:
			dlg->WMCommand(LOWORD(wParam),HIWORD(wParam),(HWND)lParam);						
			break;

		case WM_PAINT:
			dlg->Update();
			return 0;			
		
		case WM_CLOSE:
			DestroyWindow(hWnd);			
			break;

		case WM_DESTROY:
			delete dlg;
			break;
		
		default:
			return FALSE;
		}
	return TRUE;
	}


void Reactor::EditTrackParams(
		TimeValue t,
		ParamDimensionBase *dim,
		TCHAR *pname,
		HWND hParent,
		IObjParam *ip,
		DWORD flags)
	{
	this->ip = ip;
	HWND hCur = FindOpenReactorCtrlWindow(hParent,this);
	if (hCur) 
	{
		SetForegroundWindow(hCur);
		return;
	}

	dlg = new ReactorDlg(this,dim,pname,ip,hParent);
	RegisterReactorCtrlWindow(dlg->hWnd,hParent,this);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Control\Reactor\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by reactor.rc
//
#define IDS_LIBDESCRIPTION              1
#define IDS_CATEGORY                    2
#define IDS_CLASS_NAME                  3
#define IDS_AF_REACTORFLOAT             3
#define IDS_PARAMS                      4
#define IDS_AF_REACTORPOS               5
#define IDS_AF_REACTORP3                6
#define IDS_AF_REACTORROT               7
#define IDS_AF_REACTORSCALE             8
#define IDS_AF_REACTORTITLE             9
#define IDS_AF_CHANGEFALLOFF            10
#define IDS_AF_FALLOFF                  11
#define IDS_AF_VARNAME                  12
#define IDS_AF_CIRCULAR_DEPENDENCY      13
#define IDS_AF_CANT_ASSIGN              14
#define IDS_AF_REACTOR                  15
#define IDS_MIN_INFLUENCE               16
#define IDS_MAX_INFLUENCE               17
#define IDS_CREATE_REACTION             18
#define IDS_DELETE_REACTION             19
#define IDS_SET_VALUE                   20
#define IDS_EDIT_STATE                  21
#define IDS_AF_CHANGESTRENGTH           22
#define IDS_AF_CHANGEINFLUENCE          23
#define IDS_AF_CHANGESTATE              24
#define IDS_UNSET_VALUE                 25
#define IDS_ASSIGN_TO                   26
#define IDS_NOT_A_REACTOR               27
#define IDS_NOT_AN_INT                  28
#define IDS_NOT_A_VALID_VALUE           29
#define IDS_NOT_A_NAME                  30
#define IDS_NOT_A_VALID_STATE           31
#define IDS_NOT_A_FLOAT                 32
#define IDD_PANEL                       101
#define IDD_REACTOR_PARAMS              101
#define IDR_REACTOR_SHORTCUTS           101
#define IDC_CLOSEBUTTON                 1000
#define IDC_DOSTUFF                     1000
#define IDC_REACTION_LIST               1004
#define IDC_CREATE_BUTTON               1005
#define IDC_SET_BUTTON                  1006
#define IDC_DELETE_BUTTON               1007
#define IDC_PICK_BUTTON                 1008
#define IDC_EDIT_BUTTON                 1009
#define IDC_EDITSTATE_STATIC            1012
#define IDC_TRACK_NAME                  1063
#define IDC_VALUE_STATUS                1064
#define IDC_STATE_STATUS                1065
#define IDC_OUTPUT_STATUS               1065
#define IDC_TRACK_VALUE                 1066
#define IDC_COLOR                       1456
#define IDC_EDIT                        1490
#define IDC_FALLOFF_EDIT                1490
#define IDC_INFLUENCE_EDIT              1491
#define IDC_NAME_EDIT                   1492
#define IDC_FLOATSTATE_EDIT             1493
#define IDC_STRENGTH_EDIT               1494
#define IDC_SPIN                        1496
#define IDC_FALLOFF_SPIN                1496
#define IDC_INFLUENCE_SPIN              1497
#define IDC_FLOATSTATE_SPIN             1498
#define IDC_STRENGTH_SPIN               1499
#define ID_MIN_INFLUENCE                40001
#define ID_MAX_INFLUENCE                40002
#define ID_CREATE_REACTION              40003
#define ID_DELETE_REACTION              40004
#define ID_SET_VALUE                    40005
#define ID_EDIT_STATE                   40006

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40007
#define _APS_NEXT_CONTROL_VALUE         1013
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Control\Reactor\ReactAPI.h ===
//-------------------------------------------------------------
// Access to the Reactor Controller
//
#include "ikctrl.h"


#define REACTORFLOAT 0x717d7d1f
#define REACTORPOS 0x7ac5cae4
#define REACTORP3 0x19080908
#define REACTORROT 0x2a8734eb
#define REACTORSCALE 0x13c4451c
#define REACTORFLOAT_CLASS_ID	Class_ID(REACTORFLOAT, 0x124c173b)
#define REACTORPOS_CLASS_ID		Class_ID(REACTORPOS, 0x904a56b3)
#define REACTORP3_CLASS_ID		Class_ID(REACTORP3, 0x3b617839)
#define REACTORROT_CLASS_ID		Class_ID(REACTORROT, 0x57f47da6)
#define REACTORSCALE_CLASS_ID	Class_ID(REACTORSCALE, 0x2ccb3388)

#define EDITABLE_SURF_CLASS_ID Class_ID(0x76a11646, 0x12a822fb)

// this is the class for all biped controllers except the root and the footsteps
#define BIPSLAVE_CONTROL_CLASS_ID Class_ID(0x9154,0)
// this is the class for the center of mass, biped root controller ("Bip01")
#define BIPBODY_CONTROL_CLASS_ID  Class_ID(0x9156,0) 



#define REACTORDLG_CLASS_ID	0x75a847f9

#define FLOAT_VAR		1
#define VECTOR_VAR		2
#define QUAT_VAR		3
#define SCALE_VAR		4

class IReactor : public Control {
	public:

		virtual BOOL	CreateReaction(TCHAR *buf=NULL, TimeValue t = GetCOREInterface()->GetTime())=0;
		virtual BOOL	DeleteReaction(int i=-1)=0;
		virtual int		getSelected()=0;
		virtual int		getVarCount()=0;
		virtual TCHAR*	getVarName(int i)=0;
		virtual void	setVarName(int i, TSTR name)=0;
		virtual void	setSelected(int i)=0;
		virtual void	setrType(int i)=0;
		virtual void	reactTo(Animatable* anim, TimeValue t = GetCOREInterface()->GetTime())=0;

		virtual BOOL	assignReactObj(INode* client, int subnum)=0;
		virtual BOOL	setInfluence(int num, float inf)=0;
		virtual	BOOL	setStrength(int num, float inf)=0;
		virtual BOOL	setFalloff(int num, float inf)=0;
		virtual BOOL	setState(int num, void *val, TimeValue t=NULL)=0;
		virtual void	isABiped(BOOL bip)=0;

		virtual float	getInfluence(int num)=0;
		virtual float	getStrength(int num)=0;
		virtual float	getFalloff(int num)=0;
		virtual int 	getrType()=0;
		virtual int 	getType()=0;
		virtual void*	getState(int num)=0;
		virtual BOOL	setReactionValue(int i=-1, void *val=NULL, TimeValue t=NULL)=0;
		virtual void*	getReactionValue(int i)=0;


	};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Control\Reactor\reactorui.cpp ===
/**********************************************************************
 *<
	FILE: reactorui.cpp

	DESCRIPTION: MAXScript support

	CREATED BY: Adam Felt

	HISTORY: created 2/20/99

 *>	Copyright (c) 1999 Adam Felt, All Rights Reserved.
 **********************************************************************/
#include "MAXScrpt.h"
#include "Numbers.h"
#include "3DMath.h"
#include "Name.h"
#include "strings.h"
#include "MAXobj.h"
#include "ReactAPI.h"
#include "reactor.h"


// Maxscript stuff
def_visible_primitive (createReaction,			"createReaction" );
def_visible_primitive (deleteReaction,			"deleteReaction" );
def_visible_primitive (selectReaction,			"selectReaction" );
def_visible_primitive (getSelectedReaction,		"getSelectedReactionNum" );

def_visible_primitive (setReactionState,		"setReactionState" );
def_visible_primitive (setReactionValue,		"setReactionValue" );
def_visible_primitive (setReactionInfluence,	"setReactionInfluence" );
def_visible_primitive (setReactionStrength,		"setReactionStrength" );
def_visible_primitive (setReactionFalloff,		"setReactionFalloff" );
def_visible_primitive (setReactionName,			"setReactionName" );

def_visible_primitive (getReactionCount,		"getReactionCount" );
def_visible_primitive (getReactionInfluence,	"getReactionInfluence" );
def_visible_primitive (getReactionStrength,		"getReactionStrength" );
def_visible_primitive (getReactionFalloff,		"getReactionFalloff" );
def_visible_primitive (getReactionName,			"getReactionName" );
def_visible_primitive (getReactionState,		"getReactionState" );
def_visible_primitive (getReactionValue,		"getReactionValue" );
def_visible_primitive (reactTo,					"reactTo" );


#define get_reactor_cont()															\
	Control *cont = arg_list[0]->to_controller();									\
	Class_ID id = cont->ClassID();													\
	if ( id != REACTORFLOAT_CLASS_ID && id != REACTORPOS_CLASS_ID &&				\
			id != REACTORP3_CLASS_ID && id != REACTORROT_CLASS_ID &&				\
			id !=REACTORSCALE_CLASS_ID )											\
		throw RuntimeError(GetString(IDS_NOT_A_REACTOR), arg_list[0]);				\
	IReactor* react = (IReactor*)cont;			


Value*
setReactionState_cf(Value** arg_list, int count)
{
	check_arg_count(getReactionState, 3, count);
	get_reactor_cont();
	int sel;
	if (is_integer(arg_list[1])) sel = arg_list[1]->to_int();
		else throw RuntimeError(GetString(IDS_NOT_AN_INT), arg_list[1]);
	Point3 p;
	float f;
	Quat q;

	if (sel>0 && sel <= react->getVarCount())
	{
		switch (react->getType())
		{
			case REACTORFLOAT: 
				if (is_float(arg_list[2]))
				{
					f = arg_list[2]->to_float();
					react->setState(sel-1, &f);
					break;
				}else throw RuntimeError(GetString(IDS_NOT_A_VALID_STATE), arg_list[2]);
			case REACTORROT: 
				if (is_quat(arg_list[2]))
				{
					q = arg_list[2]->to_quat();
					react->setState(sel-1, &q);
					break;
				}else throw RuntimeError(GetString(IDS_NOT_A_VALID_STATE), arg_list[2]);
			case REACTORP3: 
			case REACTORSCALE: 
			case REACTORPOS: 
				if (is_point3(arg_list[2]))
				{
					p = arg_list[2]->to_point3();
					react->setState(sel-1, &p);
					break;
				}else throw RuntimeError(GetString(IDS_NOT_A_VALID_STATE), arg_list[2]);
			default: break;
		}
	}
	return &ok;
}


Value*
getReactionState_cf(Value** arg_list, int count)
{
	check_arg_count(getReactionState, 2, count);
	get_reactor_cont();
	int sel;
	if (is_integer(arg_list[1])) sel = arg_list[1]->to_int();
		else throw RuntimeError(GetString(IDS_NOT_AN_INT), arg_list[1]);

	if (sel>0 && sel <= react->getVarCount())
	{
		switch (react->getType())
		{
			case REACTORFLOAT: 
				return Float::intern(*((float*)react->getState(sel-1))); 
			case REACTORROT: 
				return new QuatValue(*((Quat*)react->getState(sel-1))); 
			case REACTORP3: 
			case REACTORSCALE: 
			case REACTORPOS: 
				return new Point3Value(*((Point3*)react->getState(sel-1))); 
			default: 
				return &false_value; 
		}
	}
	return Name::intern(GetString(IDS_NOT_AN_INT));
}

Value*
setReactionValue_cf(Value** arg_list, int count)
{
	check_arg_count(getReactionState, 3, count);
	get_reactor_cont();
	int sel;
	if (is_integer(arg_list[1])) sel = arg_list[1]->to_int();
		else throw RuntimeError(GetString(IDS_NOT_AN_INT), arg_list[1]);

	Point3 p;
	float f;
	Quat q;
	
	if (sel>0 && sel <= react->getVarCount())
	{
		switch (react->getrType())
		{
			case FLOAT_VAR: 
				if (is_float(arg_list[2]))
				{
					f = arg_list[2]->to_float();
					react->setReactionValue(sel-1, &f);
					break;
				}else throw RuntimeError(GetString(IDS_NOT_A_VALID_VALUE), arg_list[2]);
			case QUAT_VAR: 
				if (is_quat(arg_list[2]))
				{
					q = arg_list[2]->to_quat();
					react->setReactionValue(sel-1, &q);
					break;
				}else throw RuntimeError(GetString(IDS_NOT_A_VALID_VALUE), arg_list[2]);
			case VECTOR_VAR: 
			case SCALE_VAR: 
				if (is_point3(arg_list[2]))
				{
					p = arg_list[2]->to_point3();
					react->setReactionValue(sel-1, &p);
					break;
				}else throw RuntimeError(GetString(IDS_NOT_A_VALID_VALUE), arg_list[2]);
			default: 
				break;
		}
	}
	return &ok;
}


Value*
getReactionValue_cf(Value** arg_list, int count)
{
	check_arg_count(getReactionState, 2, count);
	get_reactor_cont();
	int sel;
	if (is_integer(arg_list[1])) sel = arg_list[1]->to_int();
		else throw RuntimeError(GetString(IDS_NOT_AN_INT), arg_list[1]);

	if (sel>0 && sel <= react->getVarCount())
	{
		switch (react->getrType())
		{
			case FLOAT_VAR: 
				return Float::intern(*((float*)react->getReactionValue(sel-1))); 
			case QUAT_VAR: 
				return new QuatValue(*((Quat*)react->getReactionValue(sel-1))); 
			case VECTOR_VAR: 
			case SCALE_VAR: 
				return new Point3Value(*((Point3*)react->getReactionValue(sel-1))); 
			default: 
				return &false_value; 
		}
	}
	return Name::intern(GetString(IDS_NOT_AN_INT));
}


Value*
reactTo_cf(Value** arg_list, int count)
{
	check_arg_count(reactTo, 2, count);
	get_reactor_cont();

//	Animatable* anim = ((MAXWrapper*)arg_list[1])->get_max_object();
	
	if ( is_node(arg_list[1]) )
	{
		INode* c = arg_list[1]->to_node();
		react->reactTo(((Animatable*)c));
		return &ok;
	}
	else if ( is_controller(arg_list[1]) )
	{
		Control* c = arg_list[1]->to_controller();
		react->reactTo(((Animatable*)c));
		return &ok;
	}
		else throw RuntimeError("Not a Controller or a Node: ", arg_list[1]);
}


Value*
createReaction_cf(Value** arg_list, int count)
{
	check_arg_count(createReaction, 1, count);
	get_reactor_cont();
	react->CreateReaction(NULL, MAXScript_time());
	MAXScript_interface->RedrawViews(MAXScript_interface->GetTime());
	return &ok;
}

Value*
deleteReaction_cf(Value** arg_list, int count)
{
	check_arg_count(deleteReaction, 2, count);
	get_reactor_cont();
	int sel;
	if (is_integer(arg_list[1])) sel = arg_list[1]->to_int();
		else throw RuntimeError(GetString(IDS_NOT_AN_INT), arg_list[1]);
	if (sel>0 && sel <= react->getVarCount()) react->DeleteReaction(sel-1);
	return &ok;
}

Value*
getSelectedReaction_cf(Value** arg_list, int count)
{
	check_arg_count(getSelectedReaction, 1, count);
	get_reactor_cont();
	return Integer::intern(react->getSelected()+1);
}

Value*
selectReaction_cf(Value** arg_list, int count)
{
	check_arg_count(selectReaction, 2, count);
	get_reactor_cont();
	int sel;
	if (is_integer(arg_list[1])) sel = arg_list[1]->to_int();
		else throw RuntimeError(GetString(IDS_NOT_AN_INT), arg_list[1]);
	if (sel>0 && sel <= react->getVarCount()) react->setSelected(sel-1);
	return &ok;
}


Value*
setReactionInfluence_cf(Value** arg_list, int count)
{
	check_arg_count(setReactionInfluence, 3, count);
	get_reactor_cont();
	int sel;
	if (is_integer(arg_list[1])) sel = arg_list[1]->to_int();
		else throw RuntimeError(GetString(IDS_NOT_AN_INT), arg_list[1]);
	float inf;
	if (is_float(arg_list[2])||is_integer(arg_list[2])) inf = arg_list[2]->to_float();
		else throw RuntimeError(GetString(IDS_NOT_A_FLOAT), arg_list[2]);
	if (sel>0 && sel <= react->getVarCount()) react->setInfluence(sel-1, inf);
	return &ok;
}

Value*
setReactionStrength_cf(Value** arg_list, int count)
{
	check_arg_count(setReactionStrength, 3, count);
	get_reactor_cont();
	int sel;
	if (is_integer(arg_list[1])) sel = arg_list[1]->to_int();
		else throw RuntimeError(GetString(IDS_NOT_AN_INT), arg_list[1]);
	float str;
	if (is_float(arg_list[2])||is_integer(arg_list[2])) str = arg_list[2]->to_float();
		else throw RuntimeError(GetString(IDS_NOT_A_FLOAT), arg_list[2]);
	if (sel>0 && sel <= react->getVarCount()) react->setStrength(sel-1, str);
	return &ok;
}

Value*
setReactionFalloff_cf(Value** arg_list, int count)
{
	check_arg_count(setReactionFalloff, 3, count);
	get_reactor_cont();
	int sel;
	if (is_integer(arg_list[1])) sel = arg_list[1]->to_int();
		else throw RuntimeError(GetString(IDS_NOT_AN_INT), arg_list[1]);
	float fall;
	if (is_float(arg_list[2])||is_integer(arg_list[2])) fall = arg_list[2]->to_float();
		else throw RuntimeError(GetString(IDS_NOT_A_FLOAT), arg_list[2]);
	if (sel>0 && sel <= react->getVarCount()) react->setFalloff(sel-1, fall);
	return &ok;
}

Value*
setReactionName_cf(Value** arg_list, int count)
{
	check_arg_count(setReactionName, 3, count);
	get_reactor_cont();
	int sel;
	if (is_integer(arg_list[1])) sel = arg_list[1]->to_int();
		else throw RuntimeError(GetString(IDS_NOT_AN_INT), arg_list[1]);
	TCHAR *name;
	if (is_string(arg_list[2])) name = arg_list[2]->to_string();
		else throw RuntimeError(GetString(IDS_NOT_A_NAME), arg_list[2]);
	if (sel>0 && sel <= react->getVarCount()) react->setVarName(sel-1, name);
	react->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	return &ok;
}

Value*
getReactionCount_cf(Value** arg_list, int count)
{
	check_arg_count(getReactionCount, 1, count);
	get_reactor_cont();
	return Integer::intern(react->getVarCount());
}

Value*
getReactionInfluence_cf(Value** arg_list, int count)
{
	check_arg_count(getReactionInfluence, 2, count);
	get_reactor_cont();
	int sel;
	if (is_integer(arg_list[1])) sel = arg_list[1]->to_int();
		else throw RuntimeError(GetString(IDS_NOT_AN_INT), arg_list[1]);
	if (sel>0 && sel <= react->getVarCount()) return Float::intern(react->getInfluence(sel-1));
	else return &false_value; 
}

Value*
getReactionStrength_cf(Value** arg_list, int count)
{
	check_arg_count(getReactionStrength, 2, count);
	get_reactor_cont();
	int sel;
	if (is_integer(arg_list[1])) sel = arg_list[1]->to_int();
		else throw RuntimeError(GetString(IDS_NOT_AN_INT), arg_list[1]);
	if (sel>0 && sel <= react->getVarCount()) return Float::intern(react->getStrength(sel-1));
	else return &false_value; 
}

Value*
getReactionFalloff_cf(Value** arg_list, int count)
{
	check_arg_count(getReactionFalloff, 2, count);
	get_reactor_cont();
	int sel;
	if (is_integer(arg_list[1])) sel = arg_list[1]->to_int();
		else throw RuntimeError(GetString(IDS_NOT_AN_INT), arg_list[1]);
	if (sel>0 && sel <= react->getVarCount()) return Float::intern(react->getFalloff(sel-1));
	else return &false_value; 
}

Value*
getReactionName_cf(Value** arg_list, int count)
{
	check_arg_count(getReactionName, 2, count);
	get_reactor_cont();
	int sel;
	if (is_integer(arg_list[1])) sel = arg_list[1]->to_int();
		else throw RuntimeError(GetString(IDS_NOT_AN_INT), arg_list[1]);
	if (sel>0 && sel <= react->getVarCount()) return Name::intern(react->getVarName(sel-1));
	else return &false_value; 
}


// shortcut table
static ShortcutDescription spShortcuts[] = {

	ID_MIN_INFLUENCE,				IDS_MIN_INFLUENCE,
    ID_MAX_INFLUENCE,				IDS_MAX_INFLUENCE,
    ID_CREATE_REACTION,				IDS_CREATE_REACTION,
    ID_DELETE_REACTION,				IDS_DELETE_REACTION,
    ID_SET_VALUE,					IDS_SET_VALUE,
    ID_EDIT_STATE,					IDS_EDIT_STATE,
};

ShortcutTable* GetShortcuts()
{
    TSTR name = GetString(IDS_AF_REACTOR);
    HACCEL hAccel = LoadAccelerators(hInstance,
                                     MAKEINTRESOURCE(IDR_REACTOR_SHORTCUTS));
    int numOps = NumElements(spShortcuts);
    ShortcutTable* pTab;
    pTab = new ShortcutTable(kReactorShortcuts, name, hAccel, numOps,
                             spShortcuts, hInstance);

    return pTab;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\dynwarps\dynw.cpp ===
/*************************************************************************
 *<
	FILE: dynw.cpp

	DESCRIPTION: Dynamic Spacewarps Support Files

	CREATED BY: Eric Peterson (from Audrey's Suprprts.cpp)

	HISTORY: 6/97

 *>	Copyright (c) 1996 for and assigned to Yost Group, All Rights Reserved.
 *************************************************************************/
#include "dynw.h"

HINSTANCE hInstance;
static int controlsInit = FALSE;


//------------------------------------------------------
// This is the interface to Jaguar:
//------------------------------------------------------
TCHAR *GetString(int id)
	{
	static TCHAR buf[256];

	if (hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
	}

__declspec( dllexport ) const TCHAR *
LibDescription() { return GetString(IDS_AP_DYNWARPLIB); }

// This function returns the number of plug-in classes this DLL implements
__declspec( dllexport ) int 
LibNumberClasses() { return 4; }
//LibNumberClasses() { return 6; }

// This function return the ith class descriptor. We have one.
__declspec( dllexport ) ClassDesc* 
LibClassDesc(int i) {
	switch(i){
	case 0:return GetForceObjDesc();
	case 1:return GetForceModDesc();
	case 2:return GetMotorObjDesc();
	case 3:return GetMotorModDesc();
//	case 4:return GetPinObjDesc();
//	case 5:return GetPinModDesc();
    default:return 0;}
 }

BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) 
	{	
	// Hang on to this DLL's instance handle.
	hInstance = hinstDLL;

  	if (!controlsInit) {
		controlsInit = TRUE;		

	// Initialize MAX's custom controls
	InitCustomControls(hInstance);
		
	// Initialize Win95 controls
	InitCommonControls();
	}
	
	return(TRUE);
	}


// This function returns a pre-defined constant indicating the version of 
// the system under which it was compiled.  It is used to allow the system
// to catch obsolete DLLs.
__declspec( dllexport ) ULONG 
LibVersion() { return VERSION_3DSMAX; }

// Let the plug-in register itself for deferred loading
__declspec( dllexport ) ULONG CanAutoDefer()
{
	return 1;
}


/* rand returns a number between 0 and 32767 */
/* number between 0 and 1 */
const float IntMax=32767.0f;
const float IntMax1=32768.0f;
const float HalfIntMax=16383.5f;
typedef float Matrix3By3[3][3];
typedef float Matrix4By3[4][3];
Point3 Zero=Point3(0.0f,0.0f,0.0f); 

int FloatEQ0(float number)
{	return((FLOAT_EPSILON>=number)&&(number>=-FLOAT_EPSILON));}

int SmallerEQ0(float number)
{	return((SMALL_EPSILON>=number)&&(SMALL_EPSILON>=-FLOAT_EPSILON));}

int FGT0(Point3 p1)
{	return((fabs(p1[0])>SMALL_EPSILON)||(fabs(p1[1])>SMALL_EPSILON)||(fabs(p1[2])>SMALL_EPSILON));}

void Mult1X4(float *A,Matrix4By4 B,float *C)
{	C[0]=A[0]*B[0][0]+A[1]*B[1][0]+A[2]*B[2][0]+A[3]*B[3][0];
	C[1]=A[0]*B[0][1]+A[1]*B[1][1]+A[2]*B[2][1]+A[3]*B[3][1];
	C[2]=A[0]*B[0][2]+A[1]*B[1][2]+A[2]*B[2][2]+A[3]*B[3][2];
	C[3]=A[0]*B[0][3]+A[1]*B[1][3]+A[2]*B[2][3]+A[3]*B[3][3];
}

void Mult4X1(float *A,Matrix4By4 B,float *C)
{   C[0]=A[0]*B[0][0]+A[1]*B[0][1]+A[2]*B[0][2]+A[3]*B[0][3];
	C[1]=A[0]*B[1][0]+A[1]*B[1][1]+A[2]*B[1][2]+A[3]*B[1][3];
	C[2]=A[0]*B[2][0]+A[1]*B[2][1]+A[2]*B[2][2]+A[3]*B[2][3];
	C[3]=A[0]*B[3][0]+A[1]*B[3][1]+A[2]*B[3][2]+A[3]*B[3][3];
}

void Mult1X3(float *A,Matrix3By3 B,float *C)
{   C[0]=A[0]*B[0][0]+A[1]*B[1][0]+A[2]*B[2][0];
	C[1]=A[0]*B[0][1]+A[1]*B[1][1]+A[2]*B[2][1];
	C[2]=A[0]*B[0][2]+A[1]*B[1][2]+A[2]*B[2][2];
}

void Mult3X4(Matrix3By4 A,Matrix4By4 B,Matrix3By4 C)
{   C[0][0]=A[0][0]*B[0][0]+A[0][1]*B[1][0]+A[0][2]*B[2][0]+A[0][3]*B[3][0];
	C[0][1]=A[0][0]*B[0][1]+A[0][1]*B[1][1]+A[0][2]*B[2][1]+A[0][3]*B[3][1];
	C[0][2]=A[0][0]*B[0][2]+A[0][1]*B[1][2]+A[0][2]*B[2][2]+A[0][3]*B[3][2];
	C[0][3]=A[0][0]*B[0][3]+A[0][1]*B[1][3]+A[0][2]*B[2][3]+A[0][3]*B[3][3];
	C[1][0]=A[1][0]*B[0][0]+A[1][1]*B[1][0]+A[1][2]*B[2][0]+A[1][3]*B[3][0];
	C[1][1]=A[1][0]*B[0][1]+A[1][1]*B[1][1]+A[1][2]*B[2][1]+A[1][3]*B[3][1];
	C[1][2]=A[1][0]*B[0][2]+A[1][1]*B[1][2]+A[1][2]*B[2][2]+A[1][3]*B[3][2];
	C[1][3]=A[1][0]*B[0][3]+A[1][1]*B[1][3]+A[1][2]*B[2][3]+A[1][3]*B[3][3];
	C[2][0]=A[2][0]*B[0][0]+A[2][1]*B[1][0]+A[2][2]*B[2][0]+A[2][3]*B[3][0];
	C[2][1]=A[2][0]*B[0][1]+A[2][1]*B[1][1]+A[2][2]*B[2][1]+A[2][3]*B[3][1];
	C[2][2]=A[2][0]*B[0][2]+A[2][1]*B[1][2]+A[2][2]*B[2][2]+A[2][3]*B[3][2];
	C[2][3]=A[2][0]*B[0][3]+A[2][1]*B[1][3]+A[2][2]*B[2][3]+A[2][3]*B[3][3];
}

void Mult4X3(Matrix4By3 A,Matrix4By4 B,Matrix4By3 C)
{   C[0][0]=A[0][0]*B[0][0]+A[1][0]*B[0][1]+A[2][0]*B[0][2]+A[3][0]*B[0][3];
	C[1][0]=A[0][0]*B[1][0]+A[1][0]*B[1][1]+A[2][0]*B[1][2]+A[3][0]*B[1][3];
	C[2][0]=A[0][0]*B[2][0]+A[1][0]*B[2][1]+A[2][0]*B[2][2]+A[3][0]*B[2][3];
	C[3][0]=A[0][0]*B[3][0]+A[1][0]*B[3][1]+A[2][0]*B[3][2]+A[3][0]*B[3][3];
	C[0][1]=A[0][1]*B[0][0]+A[1][1]*B[0][1]+A[2][1]*B[0][2]+A[3][1]*B[0][3];
	C[1][1]=A[0][1]*B[1][0]+A[1][1]*B[1][1]+A[2][1]*B[1][2]+A[3][1]*B[1][3];
	C[2][1]=A[0][1]*B[2][0]+A[1][1]*B[2][1]+A[2][1]*B[2][2]+A[3][1]*B[2][3];
	C[3][1]=A[0][1]*B[3][0]+A[1][1]*B[3][1]+A[2][1]*B[3][2]+A[3][1]*B[3][3];
	C[0][2]=A[0][2]*B[0][0]+A[1][2]*B[0][1]+A[2][2]*B[0][2]+A[3][2]*B[0][3];
	C[1][2]=A[0][2]*B[1][0]+A[1][2]*B[1][1]+A[2][2]*B[1][2]+A[3][2]*B[1][3];
	C[2][2]=A[0][2]*B[2][0]+A[1][2]*B[2][1]+A[2][2]*B[2][2]+A[3][2]*B[2][3];
	C[3][2]=A[0][2]*B[3][0]+A[1][2]*B[3][1]+A[2][2]*B[3][2]+A[3][2]*B[3][3];
}

void Mult4X4(Matrix4By4 A,Matrix4By4 B,Matrix4By4 C)
{   C[0][0]=A[0][0]*B[0][0]+A[0][1]*B[1][0]+A[0][2]*B[2][0]+A[0][3]*B[3][0];
	C[0][1]=A[0][0]*B[0][1]+A[0][1]*B[1][1]+A[0][2]*B[2][1]+A[0][3]*B[3][1];
	C[0][2]=A[0][0]*B[0][2]+A[0][1]*B[1][2]+A[0][2]*B[2][2]+A[0][3]*B[3][2];
	C[0][3]=A[0][0]*B[0][3]+A[0][1]*B[1][3]+A[0][2]*B[2][3]+A[0][3]*B[3][3];
	C[1][0]=A[1][0]*B[0][0]+A[1][1]*B[1][0]+A[1][2]*B[2][0]+A[1][3]*B[3][0];
	C[1][1]=A[1][0]*B[0][1]+A[1][1]*B[1][1]+A[1][2]*B[2][1]+A[1][3]*B[3][1];
	C[1][2]=A[1][0]*B[0][2]+A[1][1]*B[1][2]+A[1][2]*B[2][2]+A[1][3]*B[3][2];
	C[1][3]=A[1][0]*B[0][3]+A[1][1]*B[1][3]+A[1][2]*B[2][3]+A[1][3]*B[3][3];
	C[2][0]=A[2][0]*B[0][0]+A[2][1]*B[1][0]+A[2][2]*B[2][0]+A[2][3]*B[3][0];
	C[2][1]=A[2][0]*B[0][1]+A[2][1]*B[1][1]+A[2][2]*B[2][1]+A[2][3]*B[3][1];
	C[2][2]=A[2][0]*B[0][2]+A[2][1]*B[1][2]+A[2][2]*B[2][2]+A[2][3]*B[3][2];
	C[2][3]=A[2][0]*B[0][3]+A[2][1]*B[1][3]+A[2][2]*B[2][3]+A[2][3]*B[3][3];
	C[3][0]=A[3][0]*B[0][0]+A[3][1]*B[1][0]+A[3][2]*B[2][0]+A[3][3]*B[3][0];
	C[3][1]=A[3][0]*B[0][1]+A[3][1]*B[1][1]+A[3][2]*B[2][1]+A[3][3]*B[3][1];
	C[3][2]=A[3][0]*B[0][2]+A[3][1]*B[1][2]+A[3][2]*B[2][2]+A[3][3]*B[3][2];
	C[3][3]=A[3][0]*B[0][3]+A[3][1]*B[1][3]+A[3][2]*B[2][3]+A[3][3]*B[3][3];
}

float det2x2(float a,float b,float c,float d)
{	return(a*d-b*c);}

float det3x3(float a1,float a2,float a3,float b1,float b2,float b3,float c1,float c2,float c3)
{	return(a1*det2x2(b2,b3,c2,c3)-b1*det2x2(a2,a3,c2,c3)+c1*det2x2(a2,a3,b2,b3));}

void Adjoint(Matrix4By4 in, Matrix4By4 out,float det)
{	float a1,a2,a3,a4,b1,b2,b3,b4;
	float c1,c2,c3,c4,d1,d2,d3,d4;
	a1=in[0][0];b1=in[0][1];c1=in[0][2];d1=in[0][3];
	a2=in[1][0];b2=in[1][1];c2=in[1][2];d2=in[1][3];
	a3=in[2][0];b3=in[2][1];c3=in[2][2];d3=in[2][3];
	a4=in[3][0];b4=in[3][1];c4=in[3][2];d4=in[3][3];
	out[0][0]= det3x3(b2,b3,b4,c2,c3,c4,d2,d3,d4)/det;
	out[1][0]=-det3x3(a2,a3,a4,c2,c3,c4,d2,d3,d4)/det;
	out[2][0]= det3x3(a2,a3,a4,b2,b3,b4,d2,d3,d4)/det;
	out[3][0]=-det3x3(a2,a3,a4,b2,b3,b4,c2,c3,c4)/det;
	out[0][1]=-det3x3(b1,b3,b4,c1,c3,c4,d1,d3,d4)/det;
	out[1][1]= det3x3(a1,a3,a4,c1,c3,c4,d1,d3,d4)/det;
	out[2][1]=-det3x3(a1,a3,a4,b1,b3,b4,d1,d3,d4)/det;
	out[3][1]= det3x3(a1,a3,a4,b1,b3,b4,c1,c3,c4)/det;
	out[0][2]= det3x3(b1,b2,b4,c1,c2,c4,d1,d2,d4)/det;
	out[1][2]=-det3x3(a1,a2,a4,c1,c2,c4,d1,d2,d4)/det;
	out[2][2]= det3x3(a1,a2,a4,b1,b2,b4,d1,d2,d4)/det;
	out[3][2]=-det3x3(a1,a2,a4,b1,b2,b4,c1,c2,c4)/det;
	out[0][3]=-det3x3(b1,b2,b3,c1,c2,c3,d1,d2,d3)/det;
	out[1][3]= det3x3(a1,a2,a3,c1,c2,c3,d1,d2,d3)/det;
	out[2][3]=-det3x3(a1,a2,a3,b1,b2,b3,d1,d2,d3)/det;
	out[3][3]= det3x3(a1,a2,a3,b1,b2,b3,c1,c2,c3)/det;
}

float det4x4(Matrix4By4 m)
{	float a1,a2,a3,a4,b1,b2,b3,b4;
	float c1,c2,c3,c4,d1,d2,d3,d4,ans;
	a1=m[0][0];b1=m[0][1];c1=m[0][2];d1=m[0][3];
	a2=m[1][0];b2=m[1][1];c2=m[1][2];d2=m[1][3];
	a3=m[2][0];b3=m[2][1];c3=m[2][2];d3=m[2][3];
	a4=m[3][0];b4=m[3][1];c4=m[3][2];d4=m[3][3];
	ans= a1*det3x3(b2,b3,b4,c2,c3,c4,d2,d3,d4)
		-b1*det3x3(a2,a3,a4,c2,c3,c4,d2,d3,d4)
		+c1*det3x3(a2,a3,a4,b2,b3,b4,d2,d3,d4)
		-d1*det3x3(a2,a3,a4,b2,b3,b4,c2,c3,c4);
	return(ans);
}

int MatrixInvert(Matrix4By4 in,Matrix4By4 out)
{	float det;
	det=det4x4(in);
	if (fabs(det)<PRECISION_LIMIT)  /* NO INVERSE */
    return(0);
	Adjoint(in,out,det);
	return(1);
}

void SetUpRotation(float *Q, float *W,float Theta,Matrix4By4 Rq)
{	float ww1,ww2,ww3,w12,w13,w23,CosTheta,SinTheta,MinCosTheta;
	Point3 temp;
	Matrix3By3 R;
	ww1=W[0]*W[0];ww2=W[1]*W[1];ww3=W[2]*W[2];
	w12=W[0]*W[1];w13=W[0]*W[2];w23=W[1]*W[2];
	CosTheta=(float)cos(Theta);MinCosTheta=1.0f-CosTheta;SinTheta=(float)sin(Theta);
	R[0][0]=ww1+(1.0f-ww1)*CosTheta;
	R[0][1]=w12*MinCosTheta+W[2]*SinTheta;
	R[0][2]=w13*MinCosTheta-W[1]*SinTheta;
	R[1][0]=w12*MinCosTheta-W[2]*SinTheta;
	R[1][1]=ww2+(1.0f-ww2)*CosTheta;
	R[1][2]=w23*MinCosTheta+W[0]*SinTheta;
	R[2][0]=w13*MinCosTheta+W[1]*SinTheta;
	R[2][1]=w23*MinCosTheta-W[0]*SinTheta;
	R[2][2]=ww3+(1.0f-ww3)*CosTheta;
	Mult1X3(Q,R,&temp.x);
	memcpy(Rq[0],R[0],row3size);memcpy(Rq[1],R[1],row3size);memcpy(Rq[2],R[2],row3size);
	Rq[3][0]=Q[0]-temp.x;Rq[3][1]=Q[1]-temp.y;Rq[3][2]=Q[2]-temp.z;
	Rq[0][3]=Rq[1][3]=Rq[2][3]=0.0f;Rq[3][3]=1.0f;
}

void RotatePoint(Matrix3By4 Pin,float *Q, float *W,float Theta)
{	Matrix3By4 Pout;
	Matrix4By4 Rq;
	SetUpRotation(Q,W,Theta,Rq);
	Mult3X4(Pin,Rq,Pout);
	memcpy(Pin, Pout, sizeof(Matrix3By4));
}

void RotateOnePoint(float *Pin,float *Q, float *W,float Theta)
{	Matrix4By4 Rq;
	float Pout[4],Pby4[4];
	SetUpRotation(Q,W,Theta,Rq);
	memcpy(Pby4,Pin,row3size);Pby4[3]=1.0f;
	Mult1X4(Pby4,Rq,Pout);
	memcpy(Pin,Pout,row3size);
}

float RND01()
{	float num;
	num=(float)rand();
	return(num/IntMax);
}

/* number between -1 and 1 */
float RND11()
{	float num;
	num=(float)rand()-HalfIntMax;
	return(num/HalfIntMax);
}

int RNDSign()
{	return((RND11()<0?-1:1));}

float RND55()
{	float num;
	num=RND11();
	return(num/2);
}

int RND0x(int maxnum)
{	float num;
	int newnum;
	num=(float)rand();
	if (maxnum==0) return(0);
	newnum=(int)floor((++maxnum)*num/IntMax1);
	return(newnum>maxnum?maxnum:newnum);
}

BOOL CALLBACK DefaultSOTProc(HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
{	IObjParam *ip = (IObjParam*)GetWindowLong(hWnd,GWL_USERDATA);
	switch (msg)
	{	case WM_INITDIALOG:
			SetWindowLong(hWnd,GWL_USERDATA,lParam);
			break;
		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_MOUSEMOVE:
			if (ip) ip->RollupMouseMessage(hWnd,msg,wParam,lParam);
			return FALSE;
		default:
			return FALSE;
	}
	return TRUE;
}

void TurnButton(HWND hWnd,int SpinNum,BOOL ison)
{	ICustButton *iBut;
	iBut=GetICustButton(GetDlgItem(hWnd,SpinNum));
	if (iBut) 
	{	if (ison) iBut->Enable(); else iBut->Disable();}
	ReleaseICustButton(iBut);
}

void SpinnerOn(HWND hWnd,int SpinNum,int Winnum)
{	ISpinnerControl *spin2 = GetISpinner(GetDlgItem(hWnd,SpinNum));
	spin2->Enable();
	EnableWindow(GetDlgItem(hWnd,Winnum),TRUE);
	ReleaseISpinner(spin2);
}

void SpinnerOff(HWND hWnd,int SpinNum,int Winnum)
{	ISpinnerControl *spin2 = GetISpinner(GetDlgItem(hWnd,SpinNum));
	spin2->Disable();
	EnableWindow(GetDlgItem(hWnd,Winnum),FALSE);
	ReleaseISpinner(spin2);
}

Point3 CalcSpread(float divangle,Point3 oldnorm)
{	float Q[3];
	Point3 r;
	Q[0]=Q[1]=Q[2]=0.0f;
	r=Point3(RND11(),RND11(),RND11());
	r=Normalize(r^oldnorm);
	RotateOnePoint(&oldnorm.x,Q,&r.x,RND01()*divangle);
	return(oldnorm);
}

void VectorVar(Point3 *vel,float R,float MaxAngle)
{ Point3 X=Point3(RND11(),RND11(),RND11());
  Point3 c=Normalize(X^*vel);
  float Theta=MaxAngle*R*RND01();
  RotateOnePoint(&(*vel).x,&Zero.x,&c.x,Theta);
}

float Smallest(Point3 pmin) {return (pmin.x<pmin.y?(pmin.z<pmin.x?pmin.z:pmin.x):(pmin.z<pmin.y?pmin.z:pmin.y));}
float Largest(Point3 pmax) {return (pmax.x>pmax.y?(pmax.z>pmax.x?pmax.z:pmax.x):(pmax.z>pmax.y?pmax.z:pmax.y));}

TriObject *TriIsUseable(Object *pobj,TimeValue t)
{  	if (pobj->IsSubClassOf(triObjectClassID)) return (TriObject*)pobj;
    else 
	{	if (pobj->CanConvertToType(triObjectClassID)) 
	  	return (TriObject*)pobj->ConvertToType(t,triObjectClassID);			
	}
	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Control\Reactor\reactorMain.cpp ===
/**********************************************************************
 *<
	FILE: DllMain.cpp

	DESCRIPTION: DllMain is in here

	CREATED BY: Adam Felt

	HISTORY: 

 *>	Copyright (c) 1998-1999 Adam Felt, All Rights Reserved.
 **********************************************************************/


#include "reactor.h"

HINSTANCE hInstance;
int controlsInit = FALSE;


BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved)
{
	hInstance = hinstDLL;				// Hang on to this DLL's instance handle.

	if (!controlsInit) {
		controlsInit = TRUE;
		InitCustomControls(hInstance);	// Initialize MAX's custom controls
		InitCommonControls();			// Initialize Win95 controls
	}
			
	return (TRUE);
}

__declspec( dllexport ) const TCHAR* LibDescription()
{
	return GetString(IDS_LIBDESCRIPTION);
}

//TODO: Must change this number when adding a new class
__declspec( dllexport ) int LibNumberClasses()
{
	return 5;
}

__declspec( dllexport ) ClassDesc* LibClassDesc(int i)
{
	switch(i) {
		case 0: return GetFloatReactorDesc();
		case 1: return GetPositionReactorDesc();
		case 2: return GetPoint3ReactorDesc();
		case 3: return GetRotationReactorDesc();
		case 4: return GetScaleReactorDesc();
		default: return 0;
	}
}

__declspec( dllexport ) ULONG LibVersion()
{
	return VERSION_3DSMAX;
}

TCHAR *GetString(int id)
{
	static TCHAR buf[256];

	if (hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\ffd\ffd.cpp ===
/**********************************************************************
 *<
	FILE: ffd.cpp

	DESCRIPTION: A FFD Modifier

	CREATED BY: Rolf Berteig, 3.0 additions by Ravi Karra 

	HISTORY: 7/22/96

 *>	Copyright (c) 1996 Rolf Berteig, All Rights Reserved.
 **********************************************************************/

////////////////////////////////////////////////////////////////////
//
// Free Form Deformation Patent #4,821,214 licensed 
// from Viewpoint DataLabs Int'l, Inc., Orem, UT
// www.viewpoint.com
// 
////////////////////////////////////////////////////////////////////

#include "ffdmod.h"
#include "ffdui.h"
#include "istdplug.h"
#include "iparamb2.h"
#include "iparamm2.h"
#include "macrorec.h"

// Compute the linear address of a control point from a
// set of 3D indices. Assumes a 4x4x4 grid.
#define GRIDINDEX44(i,j,k) (((i)<<4) + ((j)<<2) + (k))
#define GRIDINDEX33(i,j,k) (((i)*9) + ((j)*3) + (k))
#define GRIDINDEX22(i,j,k) (((i)<<2) + ((j)<<1) + (k))

Point3 LatticeSize(Box3 box);
void MakeBoxThick(Box3 &box);

//--- FFD Modifier -------------------------------------------------

class FFDMod : public IFFDMod<Modifier> {	
	public:
		MasterPointControl *masterCont;		// Master track controller		
		// An addition transformation from "Mod Space".
		// Let's the user move/rotate/scale the source box
		Control	*tmControl;
		
		// Parameter block to store parameters
		IParamBlock2 *pblock;		
		
		// This BitArray will be set to a length of 64. 1 bit for
		// each point indicating its selection state.
		BitArray sel;
		
		// A cache of the input object's bounding box.
		Box3 lbox;
		int	 selLevel;
		int loadRefVersion;

		FFDRightMenu<FFDMod >	*ffdMenu;			// Right-click menu handler		
		FFDShortcutCB<FFDMod >	*ffdShortcutCB;		// Shortcuts handler 		
		

		// Class variables -- these are only used by one instance
		// of this class at a time while it is being edited in
		// the command panel.
		static IObjParam			*ip;		
		static MoveModBoxCMode		*moveMode;
		static RotateModBoxCMode	*rotMode;
		static UScaleModBoxCMode	*uscaleMode;
		static NUScaleModBoxCMode	*nuscaleMode;
		static SquashModBoxCMode	*squashMode;
		static SelectModBoxCMode	*selectMode;

		FFDMod();
		~FFDMod();
		
		// From Animatable
		void DeleteThis() {delete this;}		
		void BeginEditParams(IObjParam *ip, ULONG flags,Animatable *prev);
		void EndEditParams(IObjParam *ip,ULONG flags,Animatable *next);				
		CreateMouseCallBack* GetCreateMouseCallBack() {return NULL;} 
		BOOL AssignController(Animatable *control,int subAnim);		
		int SubNumToRefNum(int subNum);
		BOOL SelectSubAnim(int subNum);
		int	NumParamBlocks() { return 1; }					// return number of ParamBlocks in this instance
		IParamBlock2* GetParamBlock(int i) { return pblock; } // return i'th ParamBlock
		IParamBlock2* GetParamBlockByID(BlockID id) { return (pblock->ID() == id) ? pblock : NULL; } // return id'd ParamBlock

		// From BaseObject/Object
		int Display(TimeValue t, INode* inode, ViewExp *vpt, int flags, ModContext *mc);
		void GetWorldBoundBox(TimeValue t,INode* inode, ViewExp *vpt, Box3& box, ModContext *mc);
		int HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt, ModContext* mc);
		void SelectSubComponent(HitRecord *hitRec, BOOL selected, BOOL all, BOOL invert=FALSE);
		void ClearSelection(int selLevel);
		void SelectAll(int selLevel);
		void InvertSelection(int selLevel);
		void ActivateSubobjSel(int level, XFormModes& modes);
		void Move(TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin);
		void Rotate(TimeValue t, Matrix3& partm, Matrix3& tmAxis, Quat& val, BOOL localOrigin);
		void Scale(TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin);
		void GetSubObjectCenters(SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc);
		void GetSubObjectTMs(SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc);
		void TransformStart(TimeValue t) {if (ip) ip->LockAxisTripods(TRUE);}
		void TransformFinish(TimeValue t) {if (ip) ip->LockAxisTripods(FALSE);}
		void TransformCancel(TimeValue t) {if (ip) ip->LockAxisTripods(FALSE);}

		// From Modifier
		ChannelMask ChannelsUsed()  {return PART_GEOM|PART_TOPO|PART_SELECT|PART_SUBSEL_TYPE;}
		ChannelMask ChannelsChanged() {return PART_GEOM;}
		Class_ID InputType() {return defObjectClassID;}		
		Interval LocalValidity(TimeValue t);
		void ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node);

		// From ReferenceTarget/Maker
		int NumRefs() {return 67;}
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);
		int NumSubs() {return 3;}
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);

		int		 RemapRefOnLoad(int iref);
		IOResult Load(ILoad *iload);
		IOResult Save(ISave *isave);
						
		RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, PartID& partID, RefMessage message);

		int DrawControlPoints(TimeValue t,ViewExp *vpt,GraphicsWindow *gw,Box3 box,BOOL ht=FALSE,INode *inode=NULL,ModContext *mc=NULL,int flags=0);		
		Matrix3 CompTM(TimeValue t,INode *inode,ModContext *mc);
		void PlugControllers(TimeValue t, BOOL all=FALSE);
		
		
		virtual Point3& getPt(int i)=0;
		virtual Point3& getOffset(int i)=0;
		virtual Point3 *GetPtPtr()=0;
		virtual Point3 *GetOffsetPtr()=0;
		virtual int GridWidth()=0;
		virtual int GridIndex(int i,int j,int k)=0;
		virtual Point3 GetControlPoint(TimeValue t, int i, int src=FALSE, BOOL initVol=FALSE)=0;
		virtual	ClassDesc2* GetClassDesc()=0;

		// From IFFDMod
		Point3 GetPt(int i) { return getPt(i); }
		void SetPt(int i, Point3 p) { getPt(i) = p; }
		void Reset();
		void Conform();
		void AnimateAll();
		void SetGridDim(IPoint3 d) { Reset(); }
		};


class FFDMod44 : public FFDMod {
	public:
		Control *ptCont[64];		
		Point3  pt[64];
		Point3	offsets[64];

		FFDMod44();
		
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		void GetClassName(TSTR& s) {s= GetString(IDS_RB_FFD44);}
		Class_ID ClassID() {return FFD44_CLASS_ID;}
		TCHAR *GetObjectName() {return GetString(IDS_RB_FFD44);}				

		int NumPts() {return 64;}
		int	NumPtConts() { return NumPts(); }
		IPoint3	GetGridDim() { return IPoint3(4,4,4); }
		Control* GetPtCont(int i) {return ptCont[i];}
		void SetPtCont(int i,Control *c);
		Point3& getPt(int i) {return pt[i];}
		Point3& getOffset(int i)  {return offsets[i];}
		Point3 * GetPtPtr() {return pt;}
		Point3 * GetOffsetPtr() {return offsets;}
		int GridWidth() {return 4;}
		int GridIndex(int i,int j,int k) {return GRIDINDEX44(i,j,k);}		
		Point3 GetControlPoint(TimeValue t, int i, int src=FALSE, BOOL initVol=FALSE);
		ClassDesc2* GetClassDesc();
	};

class FFDMod33 : public FFDMod {
	public:
		Control *ptCont[27];		
		Point3  pt[27];
		Point3	offsets[27];

		FFDMod33();

		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		void GetClassName(TSTR& s) {s= GetString(IDS_RB_FFD33);}
		Class_ID ClassID() {return FFD33_CLASS_ID;}
		TCHAR *GetObjectName() {return GetString(IDS_RB_FFD33);}		

		int NumPts() {return 27;}
		int	NumPtConts() { return NumPts(); }
		IPoint3	GetGridDim() { return IPoint3(3,3,3); }
		Control* GetPtCont(int i) {return ptCont[i];}
		void SetPtCont(int i,Control *c);
		Point3& getPt(int i) {return pt[i];}
		Point3& getOffset(int i)  {return offsets[i];}
		Point3 * GetPtPtr() {return pt;}
		Point3 * GetOffsetPtr() {return offsets;}
		int GridWidth() {return 3;}
		int GridIndex(int i,int j,int k) {return GRIDINDEX33(i,j,k);}
		Point3 GetControlPoint(TimeValue t, int i, int src=FALSE, BOOL initVol=FALSE);
		ClassDesc2* GetClassDesc();
	};

class FFDMod22 : public FFDMod {
	public:
		Control *ptCont[8];		
		Point3  pt[8];
		Point3	offsets[8];

		FFDMod22();

		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		void GetClassName(TSTR& s) {s= GetString(IDS_RB_FFD22);}
		Class_ID ClassID() {return FFD22_CLASS_ID;}
		TCHAR *GetObjectName() {return GetString(IDS_RB_FFD22);}

		int NumPts() {return 8;}
		int	NumPtConts() { return NumPts(); }
		IPoint3	GetGridDim() { return IPoint3(2,2,2); }
		Control* GetPtCont(int i) {return ptCont[i];}
		void SetPtCont(int i,Control *c);
		Point3& getPt(int i) {return pt[i];}
		Point3& getOffset(int i)  {return offsets[i];}
		Point3 * GetPtPtr() {return pt;}
		Point3 * GetOffsetPtr() {return offsets;}
		int GridWidth() {return 2;}
		int GridIndex(int i,int j,int k) {return GRIDINDEX22(i,j,k);}
		Point3 GetControlPoint(TimeValue t, int i, int src=FALSE, BOOL initVol=FALSE);
		ClassDesc2* GetClassDesc();
	};

//--- Class Descriptor and Class Vars. ------------------------------------------

IObjParam			*FFDMod::ip = NULL;
MoveModBoxCMode		*FFDMod::moveMode = NULL;
RotateModBoxCMode	*FFDMod::rotMode = NULL;
UScaleModBoxCMode	*FFDMod::uscaleMode = NULL;
NUScaleModBoxCMode	*FFDMod::nuscaleMode = NULL;
SquashModBoxCMode	*FFDMod::squashMode = NULL;
SelectModBoxCMode	*FFDMod::selectMode = NULL;

// The FFD Class Descriptor
class FFDClassDesc44: public ClassDesc2 {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) {return new FFDMod44;}
	const TCHAR *	ClassName() {return GetString(IDS_RB_FFD44);}
	SClass_ID		SuperClassID() {return OSM_CLASS_ID;}
	Class_ID		ClassID() {return FFD44_CLASS_ID;}
	const TCHAR* 	Category() {return GetString(IDS_RB_DEFDEFORMATIONS);}
	const TCHAR*	InternalName() { return _T("FFD4x4x4"); }
	HINSTANCE		HInstance()	{ return hInstance; }
	};
class FFDClassDesc33: public ClassDesc2 {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) {return new FFDMod33;}
	const TCHAR *	ClassName() {return GetString(IDS_RB_FFD33);}
	SClass_ID		SuperClassID() {return OSM_CLASS_ID;}
	Class_ID		ClassID() {return FFD33_CLASS_ID;}
	const TCHAR* 	Category() {return GetString(IDS_RB_DEFDEFORMATIONS);}
	const TCHAR*	InternalName() { return _T("FFD3x3x3"); }
	HINSTANCE		HInstance()	{ return hInstance; }
	};
class FFDClassDesc22: public ClassDesc2 {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) {return new FFDMod22;}
	const TCHAR *	ClassName() {return GetString(IDS_RB_FFD22);}
	SClass_ID		SuperClassID() {return OSM_CLASS_ID;}
	Class_ID		ClassID() {return FFD22_CLASS_ID;}
	const TCHAR* 	Category() {return GetString(IDS_RB_DEFDEFORMATIONS);}
	const TCHAR*	InternalName() { return _T("FFD2x2x2"); }
	HINSTANCE		HInstance()	{ return hInstance; }
	};

// We'll just declare one instace of the descriptor.
static FFDClassDesc44 ffdDesc44;
static FFDClassDesc33 ffdDesc33;
static FFDClassDesc22 ffdDesc22;
ClassDesc* GetFFDDesc44() {return &ffdDesc44;}
ClassDesc* GetFFDDesc33() {return &ffdDesc33;}
ClassDesc* GetFFDDesc22() {return &ffdDesc22;}
ClassDesc2* FFDMod44::GetClassDesc() { return &ffdDesc44; }
ClassDesc2* FFDMod33::GetClassDesc() { return &ffdDesc33; }
ClassDesc2* FFDMod22::GetClassDesc() { return &ffdDesc22; }

//--- RestoreObjects for undo/redo --------------------------------

// A restore object to save the selection state.
class SelRestore : public RestoreObj {
	public:		
		FFDMod *mod;
		BitArray undo,redo;
		SelRestore(FFDMod *m) {mod=m;undo=mod->sel;}
		void Restore(int isUndo) {
			// if we're undoing, save a redo state
			if (isUndo) redo = mod->sel;
			mod->sel = undo;
			mod->NotifyDependents(FOREVER,PART_SELECT,REFMSG_CHANGE);
			}
		void Redo() {
			mod->sel = redo;
			mod->NotifyDependents(FOREVER,PART_SELECT,REFMSG_CHANGE);
			}
	};

// A restore object to save the position of control points.
class MoveRestore : public RestoreObj {
	public:		
		FFDMod *mod;
		Point3 undo[64], redo[64], undoOffs[64], redoOffs[64];
		MoveRestore(FFDMod *m) {
			mod = m;
			for (int i=0; i<mod->NumPts(); i++) {
				undo[i] = mod->getPt(i);
				undoOffs[i] = mod->getOffset(i);
				}
			}
		void Restore(int isUndo) {
			// if we're undoing, save a redo state
			if (isUndo) {
				for (int i=0; i<mod->NumPts(); i++) {
					redo[i] = mod->getPt(i);
					redoOffs[i] = mod->getOffset(i);
					}
				}
			for (int i=0; i<mod->NumPts(); i++) {
				mod->getPt(i) = undo[i];
				mod->getOffset(i) = undoOffs[i];
				}
			mod->NotifyDependents(FOREVER,PART_GEOM,REFMSG_CHANGE);
			}
		void Redo() {
			for (int i=0; i<mod->NumPts(); i++) {
				mod->getPt(i) = redo[i];
				mod->getOffset(i) = redoOffs[i];
				}
			mod->NotifyDependents(FOREVER,PART_GEOM,REFMSG_CHANGE);
			}
		void EndHold() {
			mod->ClearAFlag(A_HELD);
			}
	};

//--- Parameter map/block descriptors -------------------------------
enum { ffd_params };
enum { ffd_disp_lattice, ffd_disp_source, ffd_deform, ffd_inpoints, ffd_outpoints, ffd_offset};


static ParamBlockDesc2 ffd44_param_blk ( ffd_params, _T("ffdparameters"),  0, &ffdDesc44, P_AUTO_CONSTRUCT + P_AUTO_UI, PBLOCK_REF, 
	//rollout
	IDD_FFDPARAMS, IDS_RB_PARAMETERS, 0, 0, NULL,
	// params
	ffd_disp_lattice, 	_T("dispLattice"),		TYPE_BOOL, 		0,				IDS_RK_SHOWLATTICE,
		p_default, 		TRUE, 
		p_ui, 			TYPE_SINGLECHEKBOX, 	IDC_FFD_SHOWLATTICE, 
		end, 
	ffd_disp_source, 	_T("dispSource"),		TYPE_BOOL, 		0,				IDS_RK_SHOWSOURCE,
		p_default, 		FALSE, 
		p_ui, 			TYPE_SINGLECHEKBOX, 	IDC_FFD_SHOWSOURCE, 
		end, 
	ffd_deform, 		_T("deformType"),		TYPE_INT, 		0,				0,
		p_default, 		0, 
		p_range, 		0, 1, 
		p_ui, 			TYPE_RADIO, 	2,		IDC_FFD_INVOLUME,				IDC_FFD_DEFORMALL,  
		end, 
	ffd_inpoints, 		_T("inPoints"),			TYPE_BOOL, 		0,				IDS_RK_INPOINTS,
		p_default, 		TRUE, 
		p_ui, 			TYPE_SINGLECHEKBOX, 	IDC_FFD_INPOINTS, 
		end,
	ffd_outpoints, 		_T("outPoints"),		TYPE_BOOL, 		0,				IDS_RK_OUTPOINTS,
		p_default, 		TRUE, 
		p_ui, 			TYPE_SINGLECHEKBOX, 	IDC_FFD_OUTPOINTS, 
		end,		
	ffd_offset, 		_T("offset"), 			TYPE_FLOAT, 	P_ANIMATABLE, 	IDS_RK_OFFSET, 
		p_default, 		0.05f, 
		p_range, 		-0.2f, 0.2f, 
		p_ui, 			TYPE_SPINNER,			EDITTYPE_FLOAT, IDC_FFD_OFFSET,	IDC_FFD_OFFSETSPIN, 0.01f, 
		end,
	end
	);

static ParamBlockDesc2 ffd33_param_blk ( ffd_params, _T("ffdparameters"),  0, &ffdDesc33, P_AUTO_CONSTRUCT + P_USE_PARAMS, PBLOCK_REF,
	// use params from existing descriptor
	&ffd44_param_blk
	);

static ParamBlockDesc2 ffd22_param_blk ( ffd_params, _T("ffdparameters"),  0, &ffdDesc22, P_AUTO_CONSTRUCT + P_USE_PARAMS, PBLOCK_REF,
	// use params from existing descriptor
	&ffd44_param_blk
	);

// These are the parameters stored in our parameter block
#define ffd_disp_lattice	0	// Is lattice display turned on
#define ffd_disp_source	1 	// Is display source turned on
#define ffd_deform		2	// Is the deform only in volume option selected

//
//
// Parameters

// The parameter block. Note that none of these parameters are animatable.
static ParamBlockDescID descVer0[] = {
	{ TYPE_INT, NULL, FALSE, 0 },
	{ TYPE_INT, NULL, FALSE, 1 },
	{ TYPE_INT, NULL, FALSE, 2 } };

// Arrays of old versions
static ParamVersionDesc versionsMod[] = {
	ParamVersionDesc(descVer0,3,0),
};

#define NUM_OLDVERSIONS	1

//--- FFDDlgProc ---------------------------------------------
//
// A dialog proc for the about box
//


// NOTE:
// The following statement (which appears in the about box of this
// modifier) ABSOLUTELY MUST APPEAR in any modifier based on this
// code or that uses the FFD technology.
//
////////////////////////////////////////////////////////////////////
//
// Free Form Deformation Patent #4,821,214 licensed 
// from Viewpoint DataLabs Int'l, Inc., Orem, UT
// www.viewpoint.com
// 
////////////////////////////////////////////////////////////////////

static BOOL CALLBACK AboutDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	switch (msg) {
		case WM_INITDIALOG:
			CenterWindow(hWnd, GetParent(hWnd));
			break;

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDOK:
					EndDialog(hWnd,1);
					break;
				}
			break;
		
		default:
			return FALSE;
		}
	return TRUE;
	}


// This callback will let us do additional processing
// for our UI. The parameter map will handle the parameters,
// we just need to handle the about box.

class FFDDlgProc : public ParamMap2UserDlgProc {
	public:
		FFDMod	*ffd;
		int		dlgID;
		FFDDlgProc() {dlgID=IDD_FFD_ABOUT44;}
		BOOL DlgProc(TimeValue t,IParamMap2 *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void DeleteThis() {}
	};

// This class doesn't have any state, so we'll just declare one
// static instance.
static FFDDlgProc theFFDProc;


// This will get called everytime the rollup page's window proc
// is called.
// The only message we're interested in is the about button.
BOOL FFDDlgProc::DlgProc(TimeValue t,IParamMap2 *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	switch (msg) {
		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_FFD_RESET:
					macroRecorder->FunctionCall(_T("resetLattice"), 1, 0, mr_reftarg, ffd, mr_funcall);
					theHold.Begin();
					ffd->Reset();
					//ffd->sel=0;
					theHold.Accept(GetString(IDS_RK_RESETLATTICE));						
					break;

				case IDC_FFD_ANIMATEALL:
					macroRecorder->FunctionCall(_T("animateAll"), 1, 0, mr_reftarg, ffd, mr_funcall);
					theHold.Begin();
					ffd->AnimateAll();
					theHold.Accept(GetString(IDS_RK_ANIMATEALL));					
					break;
				
				case IDC_FFD_CONFORM: {
					HCURSOR hCur = SetCursor(LoadCursor(NULL,IDC_WAIT));
					macroRecorder->FunctionCall(_T("conformToShape"), 1, 0, mr_reftarg, ffd, mr_funcall);
					theHold.Begin();
					ffd->Conform();
					theHold.Accept(GetString(IDS_RK_CONFORM));
					SetCursor(hCur);
					}
					break;					
				case IDC_FFD_ABOUT:
					// Put up the about box
					DialogBox(
						hInstance,
						MAKEINTRESOURCE(dlgID),
						hWnd,
						AboutDlgProc);
					break;
				}
			break;

		default:
			return FALSE;
		}
	return TRUE;
	}


//--- FFD Deformer --------------------------------------------------
//
// The deformer will actually modify the points of the input object.
// Note that the Map() function must be thread safe. In this
// case it is not a problem since the only variables modified by
// the Map() function are on the stack.
 
class FFDDeformer : public Deformer {
	public:
		// Lattice points
		Point3 pt[64];
		
		// These transformations will take a point from object
		// space into lattice space and back.
		Matrix3 tm, itm;
		
		// If TRUE, only deform points in the source volume.
		int inVol;

		FFDDeformer(FFDMod *m,TimeValue t,ModContext *mc);		
	};

class FFDDeformer44 : public FFDDeformer {
	public:
		FFDDeformer44(FFDMod *m,TimeValue t,ModContext *mc) :
			FFDDeformer(m,t,mc) {}
		Point3 Map(int ii, Point3 p);
	};
class FFDDeformer33 : public FFDDeformer {
	public:
		FFDDeformer33(FFDMod *m,TimeValue t,ModContext *mc) :
			FFDDeformer(m,t,mc) {}
		Point3 Map(int ii, Point3 p);
	};
class FFDDeformer22 : public FFDDeformer {
	public:
		FFDDeformer22(FFDMod *m,TimeValue t,ModContext *mc) :
			FFDDeformer(m,t,mc) {}
		Point3 Map(int ii, Point3 p);
	};


FFDDeformer::FFDDeformer(FFDMod *mod,TimeValue t,ModContext *mc)
	{	
	// Copy the lattice into our buffer.
	for (int i=0; i<mod->NumPts(); i++) {
		pt[i] = mod->GetControlPoint(t,i) - mod->getOffset(i);
		}

	// Get the state of the deform all option
	inVol = !mod->pblock->GetInt(ffd_deform,t);	

	// Evaluate the TM controller
	Matrix3 ctm(1);
	mod->tmControl->GetValue(t,&ctm,FOREVER,CTRL_RELATIVE);
	
	// Get the ModContext TM (if there is one)
	tm  = mc->tm ? *mc->tm : Matrix3(1);
	
	// Apply our TM to the MC TM
	tm *= Inverse(ctm);
	
	// The origin of the TM is the lower left corner of the
	// box, not the center.
	tm.SetTrans(tm.GetTrans()-mc->box->Min());
	
	// Compute scale factors to normalize lattice space
	// to the extents of the box.
	Point3 s = LatticeSize(*mc->box);	

	for (i=0; i<3; i++) {
		if (s[i]==0.0f) s[i] = 1.0f;
		else s[i] = 1.0f/s[i];
		}
	tm.Scale(s,TRUE);

	// Compute the inverse.
	itm = Inverse(tm);
	}

// Cubic basis function.
// Note that this could be optimized by precomputing u^2, u^3, s^2, s^3
inline float BPoly4(int i, float u)
	{
	float s = 1.0f-u;
	switch (i) {
		case 0: return s*s*s;
		case 1: return 3.0f*u*s*s;
		case 2: return 3.0f*u*u*s;
		case 3: return u*u*u;
		default: return 0.0f;
		}
	}
inline float BPoly3(int i, float u)
	{
	float s = 1.0f-u;
	switch (i) {
		case 0: return s*s;
		case 1: return 2.0f*u*s;
		case 2: return u*u;
		default: return 0.0f;
		}
	}
inline float BPoly2(int i, float u)
	{	
	switch (i) {
		case 0: return 1.0f-u;
		case 1: return u;
		default: return 0.0f;
		}
	}

#define EPSILON	0.001f

// This is the function that computes the deformed points.
Point3 FFDDeformer44::Map(int ii, Point3 p)
	{
	Point3 q(0,0,0), pp;
	
	// Transform into lattice space
	pp = p*tm;

	// maybe skip the point if it is outside the source volume.
	if (inVol) {
		for (int i=0; i<3; i++) {
			if (pp[i]<-EPSILON || pp[i]>1.0f+EPSILON) return p;
			}
		}

	// Compute the deformed point as a weighted average of all
	// 64 control points.
	for (int i=0; i<4; i++) {
		for (int j=0; j<4; j++) {
			for (int k=0; k<4; k++) {
				q += pt[GRIDINDEX44(i,j,k)]*
					BPoly4(i,pp.x)*
					BPoly4(j,pp.y)*
					BPoly4(k,pp.z);
				}
			}
		}
	
	// Transform out of lattice space back into object space.
	return q*itm;
	}

Point3 FFDDeformer33::Map(int ii, Point3 p)
	{
	Point3 q(0,0,0), pp;
	
	// Transform into lattice space
	pp = p*tm;

	// maybe skip the point if it is outside the source volume.
	if (inVol) {
		for (int i=0; i<3; i++) {
			if (pp[i]<-EPSILON || pp[i]>1.0f+EPSILON) return p;
			}
		}

	// Compute the deformed point as a weighted average of all
	// 64 control points.
	for (int i=0; i<3; i++) {
		for (int j=0; j<3; j++) {
			for (int k=0; k<3; k++) {
				q += pt[GRIDINDEX33(i,j,k)]*
					BPoly3(i,pp.x)*
					BPoly3(j,pp.y)*
					BPoly3(k,pp.z);
				}
			}
		}
	
	// Transform out of lattice space back into object space.
	return q*itm;
	}

Point3 FFDDeformer22::Map(int ii, Point3 p)
	{
	Point3 q(0,0,0), pp;
	
	// Transform into lattice space
	pp = p*tm;

	// maybe skip the point if it is outside the source volume.
	if (inVol) {
		for (int i=0; i<3; i++) {
			if (pp[i]<-EPSILON || pp[i]>1.0f+EPSILON) return p;
			}
		}

	// Compute the deformed point as a weighted average of all
	// 64 control points.
	for (int i=0; i<2; i++) {
		for (int j=0; j<2; j++) {
			for (int k=0; k<2; k++) {
				q += pt[GRIDINDEX22(i,j,k)]*
					BPoly2(i,pp.x)*
					BPoly2(j,pp.y)*
					BPoly2(k,pp.z);
				}
			}
		}
	
	// Transform out of lattice space back into object space.
	return q*itm;
	}

//--- FFD Modifier Methods -----------------------------------------

FFDMod::FFDMod()
	{
	// Create a new matrix controller to controller the lattice TM
	tmControl = NULL;
	MakeRefByID(FOREVER,TM_REF,NewDefaultMatrix3Controller()); 
	
	// Create the ffd master control
	masterCont = NULL;		
	MakeRefByID(FOREVER, MASTER_REF, NewDefaultMasterPointController());	
	}

FFDMod44::FFDMod44()
	{
	ffd44_param_blk.dlg_template = IDD_FFDPARAMS;
	ffd44_param_blk.title = IDS_RB_PARAMETERS;
	GetClassDesc()->MakeAutoParamBlocks(this);
	// Init all the control point controllers to NULL;
	for (int i=0; i<64; i++) {
		ptCont[i] = NULL;		
		}

	// Init the lattice grid
	for (i=0; i<4; i++) {
		for (int j=0; j<4; j++) {
			for (int k=0; k<4; k++) {
				pt[GRIDINDEX44(i,j,k)] = Point3(
					float(i)/3.0f,
					float(j)/3.0f,
					float(k)/3.0f);
				offsets[GRIDINDEX44(i,j,k)] = Point3(0.0, 0.0, 0.0);
				}
			}
		}
	
	// Set the selection set size
	sel.SetSize(64);
	}

FFDMod33::FFDMod33()
	{
	ffd33_param_blk.dlg_template = IDD_FFDPARAMS;
	ffd33_param_blk.title = IDS_RB_PARAMETERS;
	GetClassDesc()->MakeAutoParamBlocks(this);
	// Init all the control point controllers to NULL;
	for (int i=0; i<27; i++) {
		ptCont[i] = NULL;		
		}

	// Init the lattice grid
	for (i=0; i<3; i++) {
		for (int j=0; j<3; j++) {
			for (int k=0; k<3; k++) {
				pt[GRIDINDEX33(i,j,k)] = Point3(
					float(i)/2.0f,
					float(j)/2.0f,
					float(k)/2.0f);
				offsets[GRIDINDEX33(i,j,k)] = Point3(0.0, 0.0, 0.0);
				}
			}
		}
	
	// Set the selection set size
	sel.SetSize(27);
	}

FFDMod22::FFDMod22()
	{
	ffd22_param_blk.dlg_template = IDD_FFDPARAMS;
	ffd22_param_blk.title = IDS_RB_PARAMETERS;
	GetClassDesc()->MakeAutoParamBlocks(this);
	// Init all the control point controllers to NULL;
	for (int i=0; i<8; i++) {
		ptCont[i] = NULL;		
		}

	// Init the lattice grid
	for (i=0; i<2; i++) {
		for (int j=0; j<2; j++) {
			for (int k=0; k<2; k++) {
				pt[GRIDINDEX22(i,j,k)] = Point3(
					float(i),
					float(j),
					float(k));
				offsets[GRIDINDEX22(i,j,k)] = Point3(0.0, 0.0, 0.0);
				}
			}
		}
	
	// Set the selection set size
	sel.SetSize(8);
	}

FFDMod::~FFDMod()
	{
	}

RefTargetHandle FFDMod::GetReference(int i)
	{
	if (i==0) 
		return tmControl;
	else if (i==1) {
		return pblock;
	} else if (i==2) {
		return masterCont;
	} else if (i<NumPts()+3) {		
		return GetPtCont(i-3);
	} else 
		return NULL;
	}

void FFDMod::SetReference(int i, RefTargetHandle rtarg)
	{
	if (i==0) 
		tmControl = (Control*)rtarg;
	else if (i==1) {
		pblock = (IParamBlock2*)rtarg;
	} else if (i==2) {
		masterCont = (MasterPointControl*)rtarg;
		if (masterCont)
			masterCont->SetNumSubControllers(64);
	} else if (i<NumPts()+3) {
		SetPtCont(i-3,(Control*)rtarg);
	} else 
		assert(0);
	}

Animatable* FFDMod::SubAnim(int i)
	{
	return GetReference(i);
	}

TSTR FFDMod::SubAnimName(int i)
	{
	if (i==0) {
		return GetString(IDS_RB_LATTICETM);
	} else if (i==1) {
		return GetString(IDS_RB_PARAMETERS);
	} else if (i==2) {
		return GetString(IDS_RK_MASTER);
	} else if (i<NumPts()+3) { 		
		TSTR str;
		str.printf(GetString(IDS_RB_CONTROLPOINTN),i-2);
		return str;
	} else 
		return TSTR();
	}

int FFDMod::SubNumToRefNum(int subNum)
	{
	if (subNum==1) return -1;
	else return subNum;
	}

BOOL FFDMod::AssignController(Animatable *control,int subAnim)
	{	
	ReplaceReference(subAnim,(RefTargetHandle)control);	
	if (subAnim==MASTER_REF) {
		int n = NumPtConts();
		masterCont->SetNumSubControllers(n);
		for (int i=0; i<n; i++)
			if (GetPtCont(i)) masterCont->SetSubController(i,GetPtCont(i));
		}
	NotifyDependents(FOREVER,0,REFMSG_CONTROLREF_CHANGE,TREE_VIEW_CLASS_ID,FALSE);	
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	return TRUE;
	}

void FFDMod::BeginEditParams(
		IObjParam *ip, ULONG flags,Animatable *prev)
	{
	this->ip = ip;

	// Activate the right-click menu callback
	ffdMenu = new FFDRightMenu<FFDMod >(this);
	ip->GetRightClickMenuManager()->Register(ffdMenu);
	
	// Set up keyboard shortcuts    
	ffdShortcutCB = new FFDShortcutCB<FFDMod >(this);
    ip->ActivateShortcutTable(ffdShortcutCB, kFFDShortcuts);
	
	// Creates some modes
	moveMode       = new MoveModBoxCMode(this,ip);
	rotMode        = new RotateModBoxCMode(this,ip);
	uscaleMode     = new UScaleModBoxCMode(this,ip);
	nuscaleMode    = new NUScaleModBoxCMode(this,ip);
	squashMode     = new SquashModBoxCMode(this,ip);
	selectMode     = new SelectModBoxCMode(this,ip);

	// Add our sub object type
	TSTR type1(GetString(IDS_RB_CONTPOINTS));	
	TSTR type2(GetString(IDS_RB_LATTICE));	
	TSTR type3(GetString(IDS_RK_SETVOLUME));
	const TCHAR *ptype[] = {type1,type2, type3};
	ip->RegisterSubObjectTypes(ptype, 3);

	// Notify the system that we have an apparatus to display
	TimeValue t = ip->GetTime();
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_BEGIN_EDIT);
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_MOD_DISPLAY_ON);
	SetAFlag(A_MOD_BEING_EDITED);	

	// Create a parameter map to handle UI
	theFFDProc.ffd = this;
	switch (NumPts()) {		
		case 64: theFFDProc.dlgID = IDD_FFD_ABOUT44; break;
		case 27: theFFDProc.dlgID = IDD_FFD_ABOUT33; break;
		case  8: theFFDProc.dlgID = IDD_FFD_ABOUT22; break;
		}
	ParamBlockDesc2* pbd = GetClassDesc()->GetParamBlockDesc(0);
	pbd->flags |= P_AUTO_UI;
	GetClassDesc()->BeginEditParams(ip, this, flags, prev);
	pbd->SetUserDlgProc(&theFFDProc);

	if ((SuperClassID() != WSM_OBJECT_CLASS_ID)) {
		// Disable "conform" controls if multiple objects or non-triobjects are selected
		sMyEnumProc dep;              
		EnumDependents(&dep);
		
		if ((dep.Nodes.Count() != 1) ||
			!dep.Nodes[0]->EvalWorldState(ip->GetTime()).obj->IsSubClassOf(triObjectClassID)) {
				EnableWindow(GetDlgItem(pblock->GetMap()->GetHWnd(),IDC_FFD_CONFORM), FALSE);
				EnableWindow(GetDlgItem(pblock->GetMap()->GetHWnd(),IDC_FFD_INPOINTS), FALSE);
				EnableWindow(GetDlgItem(pblock->GetMap()->GetHWnd(),IDC_FFD_OUTPOINTS), FALSE);
				EnableWindow(GetDlgItem(pblock->GetMap()->GetHWnd(),IDC_FFD_OFFSETLABEL),FALSE);
				ISpinnerControl *spin = GetISpinner(GetDlgItem(pblock->GetMap()->GetHWnd(),IDC_FFD_OFFSETSPIN));				
				spin->Disable();			
				ReleaseISpinner(spin);
			}
	}

	}

void FFDMod::EndEditParams(
		IObjParam *ip,ULONG flags,Animatable *next)
	{	
	ip->GetRightClickMenuManager()->Unregister(ffdMenu);
	delete ffdMenu;
	ip->DeactivateShortcutTable(ffdShortcutCB, kFFDShortcuts);
	delete ffdShortcutCB;

	GetClassDesc()->EndEditParams(ip, this, flags, next);
	
	// Turn off aparatus display
	TimeValue t = ip->GetTime();
	ClearAFlag(A_MOD_BEING_EDITED);
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_END_EDIT);
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_MOD_DISPLAY_OFF);
	
	ip->DeleteMode(moveMode);
	ip->DeleteMode(rotMode);
	ip->DeleteMode(uscaleMode);
	ip->DeleteMode(nuscaleMode);
	ip->DeleteMode(squashMode);
	ip->DeleteMode(selectMode);
	if (moveMode) delete moveMode;
	moveMode = NULL;
	if (rotMode) delete rotMode;
	rotMode = NULL;
	if (uscaleMode) delete uscaleMode;
	uscaleMode = NULL;
	if (nuscaleMode) delete nuscaleMode;
	nuscaleMode = NULL;
	if (squashMode) delete squashMode;
	squashMode = NULL;
	if (selectMode) delete selectMode;
	selectMode = NULL;
	
	this->ip = NULL;
	}

#define MIN_THICK	0.001f

void MakeBoxThick(Box3 &box)
	{
	if (box.IsEmpty()) box.MakeCube(Point3(0,0,0),1.0f);
	for (int i=0; i<3; i++) {
		if (fabs(box.pmax[i]-box.pmin[i])<MIN_THICK) {
			box.pmax[i] = box.pmin[i] + MIN_THICK;
			}
		}
	}

void FFDMod::ModifyObject(
		TimeValue t, ModContext &mc, ObjectState *os, INode *node)
	{
	// Compute our validity interval
	Interval valid = LocalValidity(t);
	if (valid.Empty()) valid.SetInstant(t);
	
	// Cache the input box
	lbox = *mc.box;
	MakeBoxThick(lbox);

	if (NumPts()==64) {	
		FFDDeformer44 deformer(this,t,&mc);	
		os->obj->Deform(&deformer, TRUE);
	} else if (NumPts()==27) {
		FFDDeformer33 deformer(this,t,&mc);	
		os->obj->Deform(&deformer, TRUE);
	} else {
		FFDDeformer22 deformer(this,t,&mc);	
		os->obj->Deform(&deformer, TRUE);
		}
	
	// This will intersect our validity with the object's
	// validity.
	os->obj->UpdateValidity(GEOM_CHAN_NUM,valid);
	}

Interval FFDMod::LocalValidity(TimeValue t)
	{
	// If we're being edited, then returning NEVER for our
	// validity will ensure that the output of the previous
	// modifier is cached.
	if (TestAFlag(A_MOD_BEING_EDITED))
		 return NEVER;  
	else {
		// Our validity depends on whether any of our controllers
		// are animated.
		Interval valid = FOREVER;
		Matrix3 ctm(1);
		Point3 p;
		tmControl->GetValue(t,&ctm,valid,CTRL_RELATIVE);
		for (int i=0; i<NumPts(); i++) {			
			if (GetPtCont(i)) GetPtCont(i)->GetValue(t,&p,valid,CTRL_ABSOLUTE);
			}
		return valid;
		}
	}

RefTargetHandle FFDMod44::Clone(RemapDir& remap)
	{
	FFDMod44 *mod = new FFDMod44;
	 
	mod->ReplaceReference(TM_REF,remap.CloneRef(tmControl));
	mod->ReplaceReference(PBLOCK_REF,pblock->Clone(remap));
	
	for (int i=0; i<64; i++) {
		if (ptCont[i]) {
			mod->ReplaceReference(i+3,remap.CloneRef(ptCont[i]));
			}
		mod->pt[i] = pt[i];
		}

	mod->sel  = sel;
	mod->lbox = lbox;

	return mod;
	}

RefTargetHandle FFDMod33::Clone(RemapDir& remap)
	{
	FFDMod33 *mod = new FFDMod33;
	 
	mod->ReplaceReference(TM_REF,remap.CloneRef(tmControl));
	mod->ReplaceReference(PBLOCK_REF,pblock->Clone(remap));
	
	for (int i=0; i<27; i++) {
		if (ptCont[i]) {
			mod->ReplaceReference(i+3,remap.CloneRef(ptCont[i]));
			}
		mod->pt[i] = pt[i];
		}

	mod->sel  = sel;
	mod->lbox = lbox;

	return mod;
	}

RefTargetHandle FFDMod22::Clone(RemapDir& remap)
	{
	FFDMod22 *mod = new FFDMod22;
	 
	mod->ReplaceReference(TM_REF,remap.CloneRef(tmControl));
	mod->ReplaceReference(PBLOCK_REF,pblock->Clone(remap));
	
	for (int i=0; i<8; i++) {
		if (ptCont[i]) {
			mod->ReplaceReference(i+3,remap.CloneRef(ptCont[i]));
			}
		mod->pt[i] = pt[i];
		}

	mod->sel  = sel;
	mod->lbox = lbox;

	return mod;
	}


int  FFDMod::RemapRefOnLoad(int iref) {
	if(loadRefVersion == ES_REF_VER_0 && iref > PBLOCK_REF)
		return iref+1;
	return iref;
}
	
#define FFD_SEL_CHUNKID			0x0100
#define FFD_PT_CHUNKID			0x0200
#define FFD_SELLEVEL_CHUNKID	0x0300
#define FFD_OFFSETS_CHUNKID		0x0400

// The following chunk tells which reference version we're dealing with
#define REF_VERSION_CHUNK	0x2000

//deform involume setting has changed from 2.5 to 3.0, this will fix that
class InVolFixPLCB : public PostLoadCallback 
{
public:
	FFDMod *ffd;

	InVolFixPLCB(FFDMod* f) { ffd = f; }
	void proc(ILoad *iload)
	{
		if (ffd->loadRefVersion == ES_REF_VER_0)
			ffd->pblock->SetValue(ffd_deform, 0, !ffd->pblock->GetInt(ffd_deform,0));
		delete this;
	}
};

IOResult FFDMod::Load(ILoad *iload) 
	{
	Modifier::Load(iload);	
	iload->RegisterPostLoadCallback(
		new ParamBlock2PLCB(versionsMod, NUM_OLDVERSIONS, GetClassDesc()->GetParamBlockDesc(0), this, PBLOCK_REF));
	iload->RegisterPostLoadCallback(new InVolFixPLCB(this));
	ULONG nb;
	IOResult res;
	loadRefVersion = ES_REF_VER_0;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case REF_VERSION_CHUNK:
				res = iload->Read(&loadRefVersion,sizeof(int), &nb);
				break;
			case FFD_SEL_CHUNKID:
				sel.Load(iload);
				break;
			case FFD_PT_CHUNKID:
				res = iload->Read(GetPtPtr(),NumPts()*sizeof(Point3), &nb);
				break;
			case FFD_OFFSETS_CHUNKID:
				res = iload->Read(GetOffsetPtr(),NumPts()*sizeof(Point3), &nb);
				break;
			case FFD_SELLEVEL_CHUNKID:
				iload->Read(&selLevel,sizeof(selLevel), &nb);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}	
	return IO_OK;
	}

IOResult FFDMod::Save(ISave *isave) 	
	{
	Modifier::Save(isave);
	ULONG nb;
	int refVer = ES_REF_VER_1;
	
	isave->BeginChunk(REF_VERSION_CHUNK);
	isave->Write(&refVer,sizeof(int), &nb);
	isave->EndChunk();
	
	isave->BeginChunk(FFD_SEL_CHUNKID);
	sel.Save(isave);
	isave->EndChunk();
	
	isave->BeginChunk(FFD_PT_CHUNKID);
	isave->Write(GetPtPtr(),NumPts()*sizeof(Point3), &nb);
	isave->EndChunk();

	isave->BeginChunk(FFD_OFFSETS_CHUNKID);
	isave->Write(GetOffsetPtr(),NumPts()*sizeof(Point3), &nb);
	isave->EndChunk();

	isave->BeginChunk(FFD_SELLEVEL_CHUNKID);
	isave->Write(&selLevel,sizeof(selLevel),&nb);
	isave->EndChunk();
	
	return IO_OK;
	}

RefResult FFDMod::NotifyRefChanged(
		Interval changeInt, 
		RefTargetHandle hTarget, 
		PartID& partID, 
		RefMessage message)
	{
	return REF_SUCCEED;
	}

int FFDMod::Display(
		TimeValue t, 
		INode* inode, 
		ViewExp *vpt, 
		int flags, 
		ModContext *mc)
	{
	GraphicsWindow *gw = vpt->getGW();
	
	// Compute a the transformation out of lattice space into world space
	// Then plug this matrix into the GW.	
	Matrix3 tm = CompTM(t,inode,mc);
	gw->setTransform(tm);
	
	// Draw...
	if (ip->GetSubObjectLevel()==SEL_LATTICE) {
		//gw->setColor(LINE_COLOR, (float)1, (float)1, (float)0.0);
		gw->setColor(LINE_COLOR,GetUIColor(COLOR_SEL_GIZMOS));
	} else {
		//gw->setColor(LINE_COLOR, (float).85, (float).5, (float)0.0);
		gw->setColor(LINE_COLOR,GetUIColor(COLOR_GIZMOS));
		}
	DrawControlPoints(t,vpt,gw,*mc->box);

	return 0;
	}


int FFDMod::HitTest(
		TimeValue t, 
		INode* inode, 
		int type, 
		int crossing, 
		int flags, 
		IPoint2 *p, 
		ViewExp *vpt, 
		ModContext* mc)
	{
	GraphicsWindow *gw = vpt->getGW();
	
	// Set the GW into pick mode.
	int savedLimits;
	gw->setRndLimits(((savedLimits = gw->getRndLimits()) | GW_PICK) & ~GW_ILLUM);
	gw->clearHitCode();
	HitRegion hr;
	MakeHitRegion(hr,type, crossing,4,p);
	gw->setHitRegion(&hr);

	// Compute a the transformation out of lattice space into world space
	// Then plug this matrix into the GW.
	Matrix3 tm = CompTM(t,inode,mc);	
	gw->setTransform(tm);

	int res = DrawControlPoints(t,vpt,gw,*mc->box,TRUE,inode,mc,flags);

	// Restore the GW's render limits
	gw->setRndLimits(savedLimits);

	return res;
	}


void FFDMod::GetWorldBoundBox(
		TimeValue t,
		INode* inode, 
		ViewExp *vpt, 
		Box3& box, 
		ModContext *mc)
	{	
	Box3 mcbox = *mc->box;
	MakeBoxThick(mcbox);
	Point3 s = LatticeSize(mcbox);
	Point3 p;
	GraphicsWindow *gw = vpt->getGW();
	//if (mc && mc->box->IsEmpty()) return;

	// Compute a the transformation out of lattice space into world space	
	Matrix3 tm = CompTM(t,inode,mc);
	
	// Expand the box to include all control points
	for (int i=0; i<NumPts(); i++) {
		p    = GetControlPoint(t,i)*s + mcbox.Min();
		box += p * tm;
		}
	}

int FFDMod::DrawControlPoints(
		TimeValue t,
		ViewExp *vpt,
		GraphicsWindow *gw,
		Box3 box,
		BOOL ht,
		INode *inode,
		ModContext *mc,
		int flags)
	{	
	MakeBoxThick(box);
	Point3 s = LatticeSize(box);
	Point3 p, pp[3];
	int res=0, dispLat, dispSrc;
	int level = ip ? ip->GetSubObjectLevel() : SEL_LATTICE;
	pblock->GetValue(ffd_disp_lattice,0,dispLat,FOREVER);
	pblock->GetValue(ffd_disp_source,0,dispSrc,FOREVER);

	// Draw the control points
	for (int i=0; i<NumPts(); i++) {
		// Maybe skip sel or unsel points
		if (ht && flags&HIT_SELONLY   && !sel[i]) continue;
		if (ht && flags&HIT_UNSELONLY &&  sel[i]) continue;

		if (!ht)
		{
			// Set the line color based on selection
			if (level==SEL_POINTS) {
				if ( sel[i]) //gw->setColor(LINE_COLOR, (float)1, (float)1, (float)0.0);
					gw->setColor(LINE_COLOR,GetUIColor(COLOR_SEL_GIZMOS));
				if (!sel[i]) //gw->setColor(LINE_COLOR, (float).85, (float).5, (float)0.0);
					gw->setColor(LINE_COLOR,GetUIColor(COLOR_GIZMOS));
				}
			else if (level==SEL_SETVOLUME) {
				if ( sel[i]) gw->setColor(LINE_COLOR, (float)1, (float)0, (float)0.0);				
				if (!sel[i]) gw->setColor(LINE_COLOR, (float)0, (float)1, (float)0.0);				
				}
		}

		// Draw the point
		p = GetControlPoint(t,i,dispSrc,level==SEL_SETVOLUME)*s + box.Min();
		gw->marker(&p,HOLLOW_BOX_MRKR);		
		
		// If we're hit testing then check for a hit and log it
		if (ht && gw->checkHitCode()) {			
			gw->clearHitCode();
			vpt->LogHit(inode, mc, gw->getHitDistance(), i, NULL);
			res = 1;
			if (flags&HIT_ABORTONHIT) return res;
			if (level==SEL_LATTICE) return 1;
			}
		}

	// Don't hit test the lattice
	if (ht && level!=SEL_LATTICE) return res;
	if (!dispLat) return res;

	// Set the GW line color
	if (level!=SEL_LATTICE) {
		//gw->setColor( LINE_COLOR, (float).85, (float).5, (float)0.0);
		gw->setColor(LINE_COLOR,GetUIColor(COLOR_GIZMOS));
		}

	// Draw the lattice
	for (i=0; i<GridWidth(); i++) {
		for (int j=0; j<GridWidth(); j++) {
			for (int k=0; k<GridWidth(); k++) {
				pp[0] = GetControlPoint(t,GridIndex(i,j,k),dispSrc,level==SEL_SETVOLUME)*s + box.Min();
				if (i<GridWidth()-1) {
					pp[1] = GetControlPoint(t,GridIndex(i+1,j,k),dispSrc,level==SEL_SETVOLUME)*s + box.Min();
					gw->polyline(2,pp,NULL,NULL,FALSE,NULL);
					}
				if (j<GridWidth()-1) {
					pp[1] = GetControlPoint(t,GridIndex(i,j+1,k),dispSrc,level==SEL_SETVOLUME)*s + box.Min();
					gw->polyline(2,pp,NULL,NULL,FALSE,NULL);
					}
				if (k<GridWidth()-1) {
					pp[1] = GetControlPoint(t,GridIndex(i,j,k+1),dispSrc,level==SEL_SETVOLUME)*s + box.Min();
					gw->polyline(2,pp,NULL,NULL,FALSE,NULL);
					}
				}
			}
		}
	
	if (ht && gw->checkHitCode()) {
		gw->clearHitCode();
		vpt->LogHit(inode, mc, gw->getHitDistance(), i, NULL);
		return 1;
		}
	return 0;
	}

void FFDMod::AnimateAll()
{
	PlugControllers(0, TRUE);	
}

void FFDMod::Conform()
{
	int inPts, outPts, out=FALSE;
	Ray ry;
	Point3 norm, ipt, center, s;
	float at, off;	
	sMyEnumProc dep;              
	EnumDependents(&dep);
	TimeValue t = GetCOREInterface()->GetTime();
	
	if (SuperClassID()==WSM_OBJECT_CLASS_ID || (dep.Nodes.Count() != 1) ||
			!dep.Nodes[0]->EvalWorldState(t).obj->IsSubClassOf(triObjectClassID))
		return;
	
	inPts = pblock->GetInt(ffd_inpoints);
	outPts = pblock->GetInt(ffd_outpoints);
	off = pblock->GetFloat(ffd_offset);

	if (theHold.Holding()) theHold.Put(new MoveRestore(this));	
	if (!inPts && !outPts) return;	

	Box3 box;	
	ObjectState os = dep.Nodes[0]->EvalWorldState(t);
	os.obj->GetDeformBBox(t, box,NULL);
	Mesh *ffdmesh = &((TriObject*)os.obj)->GetMesh();
	if (!ffdmesh) return;		

	// Calculate the center of the mesh
	Point3 sum = Point3(0,0,0);	
	for (int v=0; v < ffdmesh->numVerts; v++)
		sum += ffdmesh->getVert(v);
	center = sum/(float)ffdmesh->numVerts;	
	//center = Point3(0.5,0.5,0.5);
	s = LatticeSize(box);		
	
	// Shrink wrap the lattice to fit the shape of the object
	for (int i=0; i<NumPts(); i++) {				
		
		BOOL hit = FALSE; 	
		Point3 lp = GetPt(i);
		
		// Shoot ray from lattice point to center
		ry.p = box.Min() + lp*s;
		ry.dir =  center - ry.p;
		for (int j=0; j < 3 && !hit; j++, ry.p.z += 0.01f)		
			if (ffdmesh->IntersectRay(ry, at, norm))
				out = hit = TRUE;
		if (!hit || at>1.0f) {			
			// Shoot ray from center to lattice point
			ry.p = center;
			ry.dir =  box.Min() + lp*s - ry.p;
			if (ffdmesh->IntersectRay(ry, at, norm))
				out = !(hit = TRUE);
			}
		if (!hit || (out ? !outPts : !inPts))
			continue;
		
		// Compute the point of intersection 
		ipt = (ry.p + ry.dir * (at-off) - box.Min())/s; 		
		
		// Move the lattice point to the point of intersection
		getPt(i) = ipt;
		getOffset(i) = ipt-GetControlPoint(t,i,TRUE);
		}
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);	
}


void FFDMod::Reset()
	{
	int total = NumPts();
	MoveRestore *rest = NULL;
	if (theHold.Holding()) rest = new MoveRestore(this);
	for (int i=0; i<NumPtConts(); i++) DeleteReference(i+3);	
	masterCont->SetNumSubControllers(total);
	sel.SetSize(total);
	for (i=0; i<total; i++) {
		SetPtCont(i, NULL);
		getPt(i) = GetControlPoint(0,i,TRUE);
		getOffset(i) = Point3(0,0,0);
		}	
	if (rest) theHold.Put(rest);
	NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	NotifyDependents(FOREVER,PART_ALL,REFMSG_NODE_NAMECHANGE);
	NotifyDependents(FOREVER,PART_ALL,REFMSG_BRANCHED_HISTORY_CHANGED);
	}

void FFDMod44::SetPtCont(int i,Control *c)
	{
	assert(i>=0 && i<NumPtConts());	
	ptCont[i]=c;
	if (masterCont) masterCont->SetSubController(i,c);
	}

void FFDMod33::SetPtCont(int i,Control *c)
	{
	assert(i>=0 && i<NumPtConts());
	ptCont[i]=c;
	if (masterCont) masterCont->SetSubController(i,c);
	}

void FFDMod22::SetPtCont(int i,Control *c)
	{
	assert(i>=0 && i<NumPtConts());
	ptCont[i]=c;
	if (masterCont) masterCont->SetSubController(i,c);
	}

Point3 FFDMod44::GetControlPoint(TimeValue t, int i, int src, BOOL initVol)
	{
	if (initVol) return pt[i];
	if (src) {
		// Return the unmodified control point
		int ii, jj, kk;
		ii = (i>>4)&3;
		jj = (i>>2)&3;
		kk = i&3;
		return Point3(
			float(ii)/3.0f,
			float(jj)/3.0f,
			float(kk)/3.0f);
	} else {
		if (ptCont[i]) {
			// The point is animated, get it from the controller
			Point3 p;
			ptCont[i]->GetValue(t,&p,FOREVER,CTRL_ABSOLUTE);
			return p;
		} else {
			// the point is not animated.
			return pt[i];
			}
		}
	}

Point3 FFDMod33::GetControlPoint(TimeValue t, int i, int src, BOOL initVol)
	{
	if (initVol) return pt[i];
	if (src) {
		// Return the unmodified control point
		int ii, jj, kk;
		ii = i/9;
		jj = (i-(ii*9))/3;
		kk = i-(ii*9)-(jj*3);
		return Point3(
			float(ii)/2.0f,
			float(jj)/2.0f,
			float(kk)/2.0f);
	} else {
		if (ptCont[i]) {
			// The point is animated, get it from the controller
			Point3 p;
			ptCont[i]->GetValue(t,&p,FOREVER,CTRL_ABSOLUTE);
			return p;
		} else {
			// the point is not animated.
			return pt[i];
			}
		}
	}

Point3 FFDMod22::GetControlPoint(TimeValue t, int i, int src, BOOL initVol)
	{
	if (initVol) return pt[i];
	if (src) {
		// Return the unmodified control point
		int ii, jj, kk;
		ii = (i>>2)&1;
		jj = (i>>1)&1;
		kk = i&1;
		return Point3(
			float(ii),
			float(jj),
			float(kk));
	} else {
		if (ptCont[i]) {
			// The point is animated, get it from the controller
			Point3 p;
			ptCont[i]->GetValue(t,&p,FOREVER,CTRL_ABSOLUTE);
			return p;
		} else {
			// the point is not animated.
			return pt[i];
			}
		}
	}

BOOL FFDMod::SelectSubAnim(int subNum)
	{
	if (theHold.Holding()) theHold.Put(new SelRestore(this));
	
	BOOL add = GetKeyState(VK_CONTROL)<0;
	BOOL sub = GetKeyState(VK_MENU)<0;

	if (!add && !sub) sel.ClearAll();
	if (sub)
		 sel.Clear(subNum-3);
	else sel.Set(subNum-3);

	NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
	return TRUE;
	}

void FFDMod::SelectSubComponent(
		HitRecord *hitRec, 
		BOOL selected, 
		BOOL all, 
		BOOL invert)
	{
	int level = ip->GetSubObjectLevel();
	if (level==SEL_LATTICE) return;

	if (theHold.Holding()) theHold.Put(new SelRestore(this));
	while (hitRec) {
		BOOL state = selected;
		if (invert) state = !sel[hitRec->hitInfo];
		if (state) sel.Set(hitRec->hitInfo);
		else       sel.Clear(hitRec->hitInfo);
		if (!all) break;
		hitRec = hitRec->Next();
		}	
	NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
	}

void FFDMod::ClearSelection(int selLevel)
	{
	int level = ip->GetSubObjectLevel();
	if (level==SEL_LATTICE) return;

	if (theHold.Holding()) theHold.Put(new SelRestore(this));
	sel.ClearAll();
	NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
	}

void FFDMod::SelectAll(int selLevel)
	{
	if (theHold.Holding()) theHold.Put(new SelRestore(this));
	sel.SetAll();
	NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
	}

void FFDMod::InvertSelection(int selLevel)
	{
	if (theHold.Holding()) theHold.Put(new SelRestore(this));
	sel = ~sel;
	NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
	}

void FFDMod::ActivateSubobjSel(int level, XFormModes& modes)
	{
	selLevel = level;	
	if (level==SEL_OBJECT) {
		// Make sure these modes aren't still on the command stack.
		ip->DeleteMode(moveMode);
		ip->DeleteMode(rotMode);
		ip->DeleteMode(uscaleMode);
		ip->DeleteMode(nuscaleMode);
		ip->DeleteMode(squashMode);
		ip->DeleteMode(selectMode);		
	} else {
		modes = XFormModes(moveMode,rotMode,nuscaleMode,uscaleMode,squashMode,selectMode);
		}		
	NotifyDependents(FOREVER, SELECT_CHANNEL|DISP_ATTRIB_CHANNEL|SUBSEL_TYPE_CHANNEL, REFMSG_CHANGE);
	}

void FFDMod::PlugControllers(TimeValue t,BOOL all)
	{
	BOOL notify=FALSE;
	// Plug-in controllers for selected points without controllers
	// if we're animating
	if (all || (Animating() && t!=0)) { 	// RK: Adding option to animate all
		SuspendAnimate();
		AnimateOff();
		for (int i=0; i<NumPts(); i++) {		
			if ((all || sel[i]) && !GetPtCont(i)) {
				ReplaceReference(3+i,NewDefaultPoint3Controller()); 				
				theHold.Suspend();				
				GetPtCont(i)->SetValue(0,&getPt(i),TRUE,CTRL_ABSOLUTE);
				theHold.Resume();
				masterCont->SetSubController(i,GetPtCont(i));
				notify = TRUE;
				}			
			}
		ResumeAnimate();
		}
	if (notify) NotifyDependents(FOREVER,0,REFMSG_SUBANIM_STRUCTURE_CHANGED);
	}

Point3 LatticeSize(Box3 box)
	{
	Point3 size = box.Max()-box.Min();
	if (size.x==0.0f) size.x = MIN_THICK;
	if (size.y==0.0f) size.y = MIN_THICK;
	if (size.z==0.0f) size.z = MIN_THICK;
	return size;
	}

void FFDMod::Move(
		TimeValue t, 
		Matrix3& partm, 
		Matrix3& tmAxis, 
		Point3& val, 
		BOOL localOrigin)
	{
	int level = ip->GetSubObjectLevel();
	if (level==SEL_LATTICE) {
		SetXFormPacket pckt(val,partm,tmAxis);
		tmControl->SetValue(t,&pckt,TRUE,CTRL_RELATIVE);
	} else {		
		PlugControllers(t);

		// Compute a matrix to move points
		Matrix3 ctm(1);
		tmControl->GetValue(t,&ctm,FOREVER,CTRL_RELATIVE);
		Matrix3 tm  = ctm * partm * Inverse(tmAxis);
		Matrix3 itm = Inverse(tm);
		tm *= TransMatrix(val);
		
		// Compute scale (and inverse scale) to and from lattice space
		// and apply it to the matrices	
		Matrix3 stm = ScaleMatrix(LatticeSize(lbox));
		stm.SetTrans(lbox.Min());
		tm  = stm * tm;
		itm = itm * Inverse(stm);

		// Hold for undo
		if (theHold.Holding() && !TestAFlag(A_HELD)) {
			theHold.Put(new MoveRestore(this));
			SetAFlag(A_HELD);
			}
		
		// Move the control points
		for (int i=0; i<NumPts(); i++) {
			if (sel[i]) {
				if (GetPtCont(i)) {
					GetPtCont(i)->GetValue(t,&getPt(i),FOREVER,CTRL_ABSOLUTE);
					getPt(i) = (tm*getPt(i))*itm;
					GetPtCont(i)->SetValue(t,&getPt(i),TRUE,CTRL_ABSOLUTE);
				} else {
					Point3 p = GetPt(i);
					getPt(i) = (tm*p)*itm;
					// Calculate offsets if setting the initial state of the lattice
					if(level==SEL_SETVOLUME) getOffset(i) += GetPt(i)-p;
					}
				}
			}
		}
	NotifyDependents(FOREVER,PART_GEOM,REFMSG_CHANGE);
	}

void FFDMod::Rotate(
		TimeValue t, 
		Matrix3& partm, 
		Matrix3& tmAxis, 
		Quat& val, 
		BOOL localOrigin)
	{
	int level = ip->GetSubObjectLevel();
	if (level==SEL_LATTICE) {
		SetXFormPacket pckt(val,localOrigin,partm,tmAxis);
		tmControl->SetValue(t,&pckt,TRUE,CTRL_RELATIVE);		
	} else {
		PlugControllers(t);

		Matrix3 ctm(1);
		tmControl->GetValue(t,&ctm,FOREVER,CTRL_RELATIVE);
		Matrix3 tm  = ctm * partm * Inverse(tmAxis);
		Matrix3 itm = Inverse(tm);
		Matrix3 mat;
		val.MakeMatrix(mat);
		tm *= mat;

		// Compute scale (and inverse scale) to and from lattice space
		// and apply it to the matrices	
		Matrix3 stm = ScaleMatrix(LatticeSize(lbox));
		stm.SetTrans(lbox.Min());
		tm  = stm * tm;
		itm = itm * Inverse(stm);

		// Hold for undo
		if (theHold.Holding() && !TestAFlag(A_HELD)) {
			theHold.Put(new MoveRestore(this));
			SetAFlag(A_HELD);
			}
		
		// Move the control points
		for (int i=0; i<NumPts(); i++) {
			if (sel[i]) {
				if (GetPtCont(i)) {
					GetPtCont(i)->GetValue(t,&getPt(i),FOREVER,CTRL_ABSOLUTE);
					getPt(i) = (tm*getPt(i))*itm;
					GetPtCont(i)->SetValue(t,&getPt(i),TRUE,CTRL_ABSOLUTE);
				} else {
					Point3 p = GetPt(i);
					getPt(i) = (tm*p)*itm;
					// Calculate offsets if setting the initial state of the lattice
					if(level==SEL_SETVOLUME) getOffset(i) += GetPt(i)-p;
					}
				}
			}
		}
	NotifyDependents(FOREVER,PART_GEOM,REFMSG_CHANGE);
	}

void FFDMod::Scale(
		TimeValue t, 
		Matrix3& partm, 
		Matrix3& tmAxis, 
		Point3& val, 
		BOOL localOrigin)
	{
	int level = ip->GetSubObjectLevel();
	if (level==SEL_LATTICE) {
		SetXFormPacket pckt(val,localOrigin,partm,tmAxis);
		tmControl->SetValue(t,&pckt,TRUE,CTRL_RELATIVE);		
	} else {
		PlugControllers(t);

		Matrix3 ctm(1);
		tmControl->GetValue(t,&ctm,FOREVER,CTRL_RELATIVE);
		Matrix3 tm  = ctm * partm * Inverse(tmAxis);
		Matrix3 itm = Inverse(tm);
		tm *= ScaleMatrix(val);;
		
		// Compute scale (and inverse scale) to and from lattice space
		// and apply it to the matrices	
		Matrix3 stm = ScaleMatrix(LatticeSize(lbox));
		stm.SetTrans(lbox.Min());
		tm  = stm * tm;
		itm = itm * Inverse(stm);

		// Hold for undo
		if (theHold.Holding() && !TestAFlag(A_HELD)) {
			theHold.Put(new MoveRestore(this));
			SetAFlag(A_HELD);
			}
		
		// Move the control points
		for (int i=0; i<NumPts(); i++) {
			if (sel[i]) {
				if (GetPtCont(i)) {
					GetPtCont(i)->GetValue(t,&getPt(i),FOREVER,CTRL_ABSOLUTE);
					getPt(i) = (tm*getPt(i))*itm;
					GetPtCont(i)->SetValue(t,&getPt(i),TRUE,CTRL_ABSOLUTE);
				} else {
					Point3 p = GetPt(i);
					getPt(i) = (tm*p)*itm;
					// Calculate offsets if setting the initial state of the lattice
					if(level==SEL_SETVOLUME) getOffset(i) += GetPt(i)-p;
					}
				}
			}
		}
	NotifyDependents(FOREVER,PART_GEOM,REFMSG_CHANGE);
	}


void FFDMod::GetSubObjectCenters(
		SubObjAxisCallback *cb,
		TimeValue t,
		INode *node,
		ModContext *mc)
	{
	Box3 box = *mc->box;
	MakeBoxThick(box);
	// Compute a the transformation out of lattice space into world space	
	Point3 s = box.Max() - box.Min();
	Matrix3 tm = CompTM(t,node,mc);	

	int level = ip->GetSubObjectLevel();
	if (level==SEL_LATTICE) {
		cb->Center(tm.GetTrans(),0);
	} else {
		Point3 cent(0,0,0);
		int ct=0;
		for (int i=0; i<NumPts(); i++) {
			if (sel[i]) {
				cent += (GetControlPoint(t,i)*s + box.Min()) * tm;
				ct++;
				}
			}
		if (ct) {
			cent /= float(ct);
			cb->Center(cent,0);
			}
		}
	}

void FFDMod::GetSubObjectTMs(
		SubObjAxisCallback *cb,
		TimeValue t,
		INode *node,
		ModContext *mc)
	{
	// Compute a the transformation out of lattice space into world space
	Matrix3 tm = CompTM(t,node,mc);
	cb->TM(tm,0);
	}

Matrix3 FFDMod::CompTM(TimeValue t,INode *inode,ModContext *mc)
	{
	// Compute a the transformation out of lattice space into world space	
	Matrix3 ntm = inode->GetObjTMBeforeWSM(t);
	Matrix3 ctm(1);
	if (mc && mc->tm) {
		ntm = Inverse(*(mc->tm)) * ntm;
		}
	tmControl->GetValue(t,&ctm,FOREVER,CTRL_RELATIVE);
	return ctm * ntm;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\ffd\ffdmod.h ===
/**********************************************************************
 *<
	FILE: ffdmod.h

	DESCRIPTION:

	CREATED BY: Rolf Berteig

	HISTORY: created 7/22/96

 *>	Copyright (c) 1996 Rolf Berteig, All Rights Reserved.
 **********************************************************************/

#ifndef __INFERNO__H
#define __INFERNO__H

#include "Max.h"
#include "resource.h"

extern ClassDesc* GetFFDDesc44();
extern ClassDesc* GetFFDDesc33();
extern ClassDesc* GetFFDDesc22();
extern ClassDesc* GetFFDNMSquareOSDesc();
extern ClassDesc* GetFFDNMSquareWSDesc();
extern ClassDesc* GetFFDNMSquareWSModDesc();
extern ClassDesc* GetFFDNMCylOSDesc();
extern ClassDesc* GetFFDNMCylWSDesc();
extern ClassDesc* GetFFDSelModDesc();

extern HINSTANCE hInstance;

TCHAR *GetString(int id);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\ffd\ffdmod.cpp ===
/**********************************************************************
	 *<
		FILE: ffdmod.cpp

		DESCRIPTION: DllMain is in here

		CREATED BY: Rolf Berteig

		HISTORY: created 7/22/96

	 *>	Copyright (c) 1996 Rolf Berteig, All Rights Reserved.
	 **********************************************************************/

////////////////////////////////////////////////////////////////////
//
// Free Form Deformation Patent #4,821,214 licensed 
// from Viewpoint DataLabs Int'l, Inc., Orem, UT
// www.viewpoint.com
// 
////////////////////////////////////////////////////////////////////

#include "ffdmod.h"

HINSTANCE hInstance;
static int controlsInit = FALSE;


/** public functions **/
BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) {
	hInstance = hinstDLL;

	if (!controlsInit) {
		controlsInit = TRUE;		
		
		// MAXontrols
		InitCustomControls(hInstance);
		
		// initialize Chicago controls
		InitCommonControls();		
		}	

	return(TRUE);
	}


//------------------------------------------------------
// This is the interface to MAX
//------------------------------------------------------

__declspec( dllexport ) const TCHAR *
LibDescription() { return GetString(IDS_RB_FFDMOD); }

/// MUST CHANGE THIS NUMBER WHEN ADD NEW CLASS
__declspec( dllexport ) int LibNumberClasses() {return 9;}


__declspec( dllexport ) ClassDesc*
LibClassDesc(int i) {
	switch(i) {
		case 0: return GetFFDDesc44();		
		case 1: return GetFFDDesc33();
		case 2: return GetFFDDesc22();
		case 3: return GetFFDNMSquareOSDesc();
		case 4: return GetFFDNMSquareWSDesc();
		case 5: return GetFFDNMSquareWSModDesc();
		case 6: return GetFFDNMCylOSDesc();
		case 7: return GetFFDNMCylWSDesc();
		case 8: return GetFFDSelModDesc();
		default: return 0;
		}

	}

// Return version so can detect obsolete DLLs
__declspec( dllexport ) ULONG 
LibVersion() { return VERSION_3DSMAX; }


// Loads a string from the resource into a static buffer.
TCHAR *GetString(int id)
	{
	static TCHAR buf[256];
	if (hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
	}

BOOL CALLBACK DefaultSOTProc(
		HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	IObjParam *ip = (IObjParam*)GetWindowLong(hWnd,GWL_USERDATA);

	switch (msg) {
		case WM_INITDIALOG:
			SetWindowLong(hWnd,GWL_USERDATA,lParam);
			break;

		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_MOUSEMOVE:
			if (ip) ip->RollupMouseMessage(hWnd,msg,wParam,lParam);
			return FALSE;

		default:
			return FALSE;
		}
	return TRUE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\dynwarps\pin.cpp ===
/*****************************************************************************
 *<
	FILE: pin.cpp

	DESCRIPTION: Pin Constraint for use With Dynamics

	CREATED BY: Eric Peterson

	HISTORY: 10/98

 *>	Copyright (c) 1998, All Rights Reserved, assigned to, and for Yost Group Inc.
 *****************************************************************************/
#include "dynwarps.h"
#include "dynw.h"
#include "iparamm.h"
#include "simpmod.h"
#include "simpobj.h"
#include "texutil.h"

static Class_ID PIN_CLASS_ID(0x41d14a7d, 0x793d56e4);
static Class_ID PINMOD_CLASS_ID(0x1f756c96, 0x26180a50);

class PinObject : public SimpleWSMObject {	
	public:									
		PinObject();		
		static IParamMap *pmapParam;
		static IObjParam *ip;
		static HWND hSot;
		ForceField *GetForceField(INode *node); //ok
		BOOL SupportsDynamics() {return TRUE;}

		// From Animatable		
		void BeginEditParams( IObjParam  *ip, ULONG flags,Animatable *prev );
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
		void MapKeys(TimeMap *map,DWORD flags);
				
		// from object		
		CreateMouseCallBack* GetCreateMouseCallBack();
		
		// From SimpleWSMObject		
		void InvalidateUI();		

		// From Animatable		
		void DeleteThis() {delete this;}		
		Class_ID ClassID() {return PIN_CLASS_ID;}		
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() {return GetString(IDS_AP_PIN);}

		// From BaseObject
		IParamArray *GetParamBlock() {return pblock;}
		int GetParamBlockIndex(int id) {return id;}
						
		// From WSMObject
		Modifier *CreateWSMMod(INode *node);
		
		// From SimpleWSMObject				
		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);
		void BuildMesh(TimeValue t);

		int DialogID() {return IDD_SW_DYNPIN;}
		ParamUIDesc *UIDesc();
		int UIDescLength();
		TSTR UIStrName();
	};

IObjParam *PinObject::ip        = NULL;
IParamMap *PinObject::pmapParam = NULL;
HWND       PinObject::hSot      = NULL;

class PinClassDesc:public ClassDesc
{	public:
		int 			IsPublic() {return 1;}
		void *			Create(BOOL loading = FALSE) { return new PinObject;}
		const TCHAR *	ClassName() {return GetString(IDS_AP_PIN_CLASS);}
		SClass_ID		SuperClassID() {return WSM_OBJECT_CLASS_ID; }
		Class_ID		ClassID() {return PIN_CLASS_ID;}
		const TCHAR* 	Category() {return GetString(SPACEWARPS_FOR_DYNAMICS);}
};

static PinClassDesc PinDesc;
ClassDesc* GetPinObjDesc() {return &PinDesc;}

class PinMod;

class PinField : public ForceField //ok
{	public:
		PinObject *obj;
		TimeValue dtsq,dt;
		INode *node;
		int count;
		Matrix3 tm,invtm;
		Interval tmValid;
		Point3 force;
		Interval fValid;
		Point3 Force(TimeValue t,const Point3 &pos, const Point3 &vel, int index); //ok
};

class PinMod : public SimpleWSMMod
{	public:				
		PinField force; //ok
		PinMod() {}
		PinMod(INode *node,PinObject *obj);		
		// From Animatable
		void GetClassName(TSTR& s) {s= GetString(IDS_AP_PINMOD);}
		SClass_ID SuperClassID() {return WSM_CLASS_ID;}
		void DeleteThis() {delete this;}
		Class_ID ClassID() { return PINMOD_CLASS_ID;}
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() {return GetString(IDS_AP_PINBINDING);}
		void ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node);
		// From SimpleWSMMod		
		Interval GetValidity(TimeValue t);		
		Deformer& GetDeformer(TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat);
};

class PinModClassDesc:public ClassDesc
{	public:
		int 			IsPublic() { return 0; }
		void *			Create(BOOL loading = FALSE) {return new PinMod;}
		const TCHAR *	ClassName() { return GetString(IDS_AP_PINMOD);}
		SClass_ID		SuperClassID() {return WSM_CLASS_ID;}
		Class_ID		ClassID() {return PINMOD_CLASS_ID;}
		const TCHAR* 	Category() {return _T("");}
};

static PinModClassDesc PinModDesc;

ClassDesc* GetPinModDesc() {return &PinModDesc;}

class PinModData : public LocalModData
{	public:
		LocalModData *Clone ();
};

LocalModData *PinModData::Clone ()
{	PinModData *clone;
	clone = new PinModData ();
	return(clone);
}

//--- PinObject Parameter map/block descriptors ------------------
#define PB_ONTIME			0
#define PB_OFFTIME			1
#define PB_PINTYPE 			2
#define PB_ICONSIZE			3

static int ConstraintIDs[] = {IDC_AP_CONSTRAINTSURF,IDC_AP_CONSTRAINTAXLE,IDC_AP_CONSTRAINTPIN};

static ParamUIDesc descParamPin[] = {

	// Pin Time On
	ParamUIDesc(
		PB_ONTIME,
		EDITTYPE_TIME,
		IDC_AP_FONTIME,IDC_AP_FONTIMESPIN,
		-999999999.0f,999999999.0f,
		10.0f),
	
	// Pin Time Off
	ParamUIDesc(
		PB_OFFTIME,
		EDITTYPE_TIME,
		IDC_AP_FOFFTIME,IDC_AP_FOFFTIMESPIN,
		-999999999.0f,999999999.0f,
		10.0f),
	
	// Pin Type
	ParamUIDesc(PB_PINTYPE,TYPE_RADIO,ConstraintIDs,3),

	// Icon Size
	ParamUIDesc(
		PB_ICONSIZE,
		EDITTYPE_UNIVERSE,
		IDC_AP_DYNF_ICONSIZE,IDC_AP_DYNF_ICONSIZESPIN,
		0.0f, 9999999.0f,
		SPIN_AUTOSCALE),
	};

#define PINPARAMDESC_LENGTH	4

ParamBlockDescID descPinVer0[] = {
	{ TYPE_INT, NULL, FALSE, 0 },	// PB_ONTIME
	{ TYPE_INT, NULL, FALSE, 1 },	// PB_OFFTIME
	{ TYPE_INT, NULL, FALSE, 1 },	// PB_PINTYPE
	{ TYPE_FLOAT, NULL, TRUE, 17}  // PB_ICONSIZE
};

#define PBLOCK_LENGTH	4

#define CURRENT_VERSION	0


//--- Deflect object methods -----------------------------------------

PinObject::PinObject()
{	int FToTick=(int)((float)TIME_TICKSPERSEC/(float)GetFrameRate());
	MakeRefByID(FOREVER, 0,CreateParameterBlock(descPinVer0, PBLOCK_LENGTH, CURRENT_VERSION));
	assert(pblock);	
	pblock->SetValue(PB_ONTIME,0,0);
	pblock->SetValue(PB_OFFTIME,0,FToTick*100);
	pblock->SetValue(PB_PINTYPE,0,0);
}

void PinObject::BeginEditParams(IObjParam *ip,ULONG flags,Animatable *prev)
{	SimpleWSMObject::BeginEditParams(ip,flags,prev);
	this->ip = ip;
	if (pmapParam)
	{	// Left over
		pmapParam->SetParamBlock(pblock);
	}
	else
	{	hSot = ip->AddRollupPage(hInstance,MAKEINTRESOURCE(IDD_SW_DESC_DYNONLY),DefaultSOTProc,GetString(IDS_AP_TOP),(LPARAM)ip,APPENDROLL_CLOSED);
		// Gotta make a new one.
		pmapParam = CreateCPParamMap(descParamPin,PINPARAMDESC_LENGTH,pblock,ip,hInstance,MAKEINTRESOURCE(IDD_SW_DYNPIN),GetString(IDS_AP_PARAMETERS),0);
	}
//	if (pmapParam) pmapParam->SetUserDlgProc(new PinDlgProc(this));
}

void PinObject::EndEditParams(IObjParam *ip,ULONG flags,Animatable *next)
{	SimpleWSMObject::EndEditParams(ip,flags,next);
	this->ip = NULL;
	if (flags&END_EDIT_REMOVEUI )
	{	DestroyCPParamMap(pmapParam);
		ip->DeleteRollupPage(hSot);
		pmapParam = NULL;		
	}	
}

ForceField *PinObject::GetForceField(INode *node)
{	PinField *pb = new PinField;	
	pb->obj  = this;
	pb->node = node;
	pb->tmValid.SetEmpty();
	pb->fValid.SetEmpty();
	pb->dt=GetTicksPerFrame();
	pb->dtsq=pb->dt*pb->dt;
	return pb;
}

void PinObject::MapKeys(TimeMap *map,DWORD flags)
{	TimeValue TempTime;
// mapped values
	pblock->GetValue(PB_ONTIME,0,TempTime,FOREVER);
	TempTime=map->map(TempTime);
	pblock->SetValue(PB_ONTIME,0,TempTime);
	pblock->GetValue(PB_OFFTIME,0,TempTime,FOREVER);
	TempTime=map->map(TempTime);
	pblock->SetValue(PB_OFFTIME,0,TempTime);
}

#define NUM_SEGS 16

#define PLANECONSTRAINT 0
#define AXLECONSTRAINT	1
#define PINCONSTRAINT	2

void PinObject::BuildMesh(TimeValue t)
{	ivalid = FOREVER;
	int kindofpin;
	pblock->GetValue(PB_PINTYPE,t,kindofpin,ivalid);
	float iconsize;
	pblock->GetValue(PB_ICONSIZE,t,iconsize,ivalid);

	if (kindofpin == PLANECONSTRAINT)
	{	float rad, u, rcosu, rsinu, halfside;
		int iloop, loopoffset1, loopoffset2, loopoffset3;
		int v1, v2, v3;
		loopoffset1 = NUM_SEGS;
		loopoffset2 = loopoffset1 + NUM_SEGS;
		loopoffset3 = loopoffset2 + NUM_SEGS;
		rad = 0.4f*iconsize;
		halfside = 0.5f * iconsize;
		mesh.setNumVerts(3*NUM_SEGS+1+8);
		mesh.setNumFaces(3*NUM_SEGS+4);
		for (iloop = 0; iloop<NUM_SEGS; iloop++)
		{	u = (float(iloop)/float(NUM_SEGS))*TWOPI;
			rcosu = rad*(float)cos(u);
			rsinu = rad*(float)sin(u);
			mesh.setVert(iloop,              Point3(rcosu,rsinu, 0.0f));
			mesh.setVert(iloop + loopoffset1,Point3(0.0f ,rcosu,rsinu));
			mesh.setVert(iloop + loopoffset2,Point3(rcosu, 0.0f,rsinu));
		}
		mesh.setVert(loopoffset3, Zero);
		mesh.setVert(loopoffset3+1,Point3( halfside, halfside, rad));
		mesh.setVert(loopoffset3+2,Point3(-halfside, halfside, rad));
		mesh.setVert(loopoffset3+3,Point3(-halfside,-halfside, rad));
		mesh.setVert(loopoffset3+4,Point3( halfside,-halfside, rad));
		mesh.setVert(loopoffset3+5,Point3( halfside, halfside,-rad));
		mesh.setVert(loopoffset3+6,Point3(-halfside, halfside,-rad));
		mesh.setVert(loopoffset3+7,Point3(-halfside,-halfside,-rad));
		mesh.setVert(loopoffset3+8,Point3( halfside,-halfside,-rad));

		v3 = loopoffset3;
		for (iloop = 0; iloop<NUM_SEGS; iloop++)
		{	v1 = iloop;
			v2 = (iloop>(NUM_SEGS-2)?iloop-NUM_SEGS+1:iloop+1);
			mesh.faces[iloop].setEdgeVisFlags(1,0,0);
			mesh.faces[iloop].setSmGroup(0);
			mesh.faces[iloop].setVerts(v1,v2,v3);

			mesh.faces[iloop+loopoffset1].setEdgeVisFlags(1,0,0);
			mesh.faces[iloop+loopoffset1].setSmGroup(0);
			mesh.faces[iloop+loopoffset1].setVerts(v1+loopoffset1,v2+loopoffset1,v3);

			mesh.faces[iloop+loopoffset2].setEdgeVisFlags(1,0,0);
			mesh.faces[iloop+loopoffset2].setSmGroup(0);
			mesh.faces[iloop+loopoffset2].setVerts(v1+loopoffset2,v2+loopoffset2,v3);
		}
		mesh.faces[loopoffset3  ].setEdgeVisFlags(1,1,0);
		mesh.faces[loopoffset3  ].setSmGroup(0);
		mesh.faces[loopoffset3  ].setVerts(loopoffset3+1,loopoffset3+2,loopoffset3+3);
		mesh.faces[loopoffset3+1].setEdgeVisFlags(1,1,0);
		mesh.faces[loopoffset3+1].setSmGroup(0);
		mesh.faces[loopoffset3+1].setVerts(loopoffset3+3,loopoffset3+4,loopoffset3+1);

		mesh.faces[loopoffset3+2].setEdgeVisFlags(1,1,0);
		mesh.faces[loopoffset3+2].setSmGroup(0);
		mesh.faces[loopoffset3+2].setVerts(loopoffset3+5,loopoffset3+6,loopoffset3+7);
		mesh.faces[loopoffset3+3].setEdgeVisFlags(1,1,0);
		mesh.faces[loopoffset3+3].setSmGroup(0);
		mesh.faces[loopoffset3+3].setVerts(loopoffset3+7,loopoffset3+8,loopoffset3+5);
	}
	else if (kindofpin == AXLECONSTRAINT)
	{	float rad, u, rcosu, rsinu, halfside;
		int iloop, loopoffset1, loopoffset2, loopoffset3;
		int v1, v2, v3;
		loopoffset1 = NUM_SEGS;
		loopoffset2 = loopoffset1 + NUM_SEGS;
		loopoffset3 = loopoffset2 + NUM_SEGS;
		rad = 0.4f*iconsize;
		halfside = 0.5f * iconsize;
		mesh.setNumVerts(3*NUM_SEGS+1+16);
		mesh.setNumFaces(3*NUM_SEGS+8);
		for (iloop = 0; iloop<NUM_SEGS; iloop++)
		{	u = (float(iloop)/float(NUM_SEGS))*TWOPI;
			rcosu = rad*(float)cos(u);
			rsinu = rad*(float)sin(u);
			mesh.setVert(iloop,              Point3(rcosu,rsinu, 0.0f));
			mesh.setVert(iloop + loopoffset1,Point3(0.0f ,rcosu,rsinu));
			mesh.setVert(iloop + loopoffset2,Point3(rcosu, 0.0f,rsinu));
		}
		mesh.setVert(loopoffset3, Zero);

		mesh.setVert(loopoffset3+1,Point3( halfside, halfside, rad));
		mesh.setVert(loopoffset3+2,Point3(-halfside, halfside, rad));
		mesh.setVert(loopoffset3+3,Point3(-halfside,-halfside, rad));
		mesh.setVert(loopoffset3+4,Point3( halfside,-halfside, rad));
		mesh.setVert(loopoffset3+5,Point3( halfside, halfside,-rad));
		mesh.setVert(loopoffset3+6,Point3(-halfside, halfside,-rad));
		mesh.setVert(loopoffset3+7,Point3(-halfside,-halfside,-rad));
		mesh.setVert(loopoffset3+8,Point3( halfside,-halfside,-rad));

		mesh.setVert(loopoffset3+9 ,Point3( halfside, rad, halfside));
		mesh.setVert(loopoffset3+10,Point3(-halfside, rad, halfside));
		mesh.setVert(loopoffset3+11,Point3(-halfside, rad,-halfside));
		mesh.setVert(loopoffset3+12,Point3( halfside, rad,-halfside));
		mesh.setVert(loopoffset3+13,Point3( halfside,-rad, halfside));
		mesh.setVert(loopoffset3+14,Point3(-halfside,-rad, halfside));
		mesh.setVert(loopoffset3+15,Point3(-halfside,-rad,-halfside));
		mesh.setVert(loopoffset3+16,Point3( halfside,-rad,-halfside));

		v3 = loopoffset3;
		for (iloop = 0; iloop<NUM_SEGS; iloop++)
		{	v1 = iloop;
			v2 = (iloop>(NUM_SEGS-2)?iloop-NUM_SEGS+1:iloop+1);
			mesh.faces[iloop].setEdgeVisFlags(1,0,0);
			mesh.faces[iloop].setSmGroup(0);
			mesh.faces[iloop].setVerts(v1,v2,v3);

			mesh.faces[iloop+loopoffset1].setEdgeVisFlags(1,0,0);
			mesh.faces[iloop+loopoffset1].setSmGroup(0);
			mesh.faces[iloop+loopoffset1].setVerts(v1+loopoffset1,v2+loopoffset1,v3);

			mesh.faces[iloop+loopoffset2].setEdgeVisFlags(1,0,0);
			mesh.faces[iloop+loopoffset2].setSmGroup(0);
			mesh.faces[iloop+loopoffset2].setVerts(v1+loopoffset2,v2+loopoffset2,v3);
		}
		mesh.faces[loopoffset3  ].setEdgeVisFlags(1,1,0);
		mesh.faces[loopoffset3  ].setSmGroup(0);
		mesh.faces[loopoffset3  ].setVerts(loopoffset3+1,loopoffset3+2,loopoffset3+3);
		mesh.faces[loopoffset3+1].setEdgeVisFlags(1,1,0);
		mesh.faces[loopoffset3+1].setSmGroup(0);
		mesh.faces[loopoffset3+1].setVerts(loopoffset3+3,loopoffset3+4,loopoffset3+1);

		mesh.faces[loopoffset3+2].setEdgeVisFlags(1,1,0);
		mesh.faces[loopoffset3+2].setSmGroup(0);
		mesh.faces[loopoffset3+2].setVerts(loopoffset3+5,loopoffset3+6,loopoffset3+7);
		mesh.faces[loopoffset3+3].setEdgeVisFlags(1,1,0);
		mesh.faces[loopoffset3+3].setSmGroup(0);
		mesh.faces[loopoffset3+3].setVerts(loopoffset3+7,loopoffset3+8,loopoffset3+5);

		mesh.faces[loopoffset3+4].setEdgeVisFlags(1,1,0);
		mesh.faces[loopoffset3+4].setSmGroup(0);
		mesh.faces[loopoffset3+4].setVerts(loopoffset3+ 9,loopoffset3+10,loopoffset3+11);
		mesh.faces[loopoffset3+5].setEdgeVisFlags(1,1,0);
		mesh.faces[loopoffset3+5].setSmGroup(0);
		mesh.faces[loopoffset3+5].setVerts(loopoffset3+11,loopoffset3+12,loopoffset3+ 9);

		mesh.faces[loopoffset3+6].setEdgeVisFlags(1,1,0);
		mesh.faces[loopoffset3+6].setSmGroup(0);
		mesh.faces[loopoffset3+6].setVerts(loopoffset3+13,loopoffset3+14,loopoffset3+15);
		mesh.faces[loopoffset3+7].setEdgeVisFlags(1,1,0);
		mesh.faces[loopoffset3+7].setSmGroup(0);
		mesh.faces[loopoffset3+7].setVerts(loopoffset3+15,loopoffset3+16,loopoffset3+13);

	}
	else if (kindofpin == PINCONSTRAINT)
	{	float rad, u, rcosu, rsinu, halfside;
		int iloop, loopoffset1, loopoffset2, loopoffset3;
		int v1, v2, v3;
		loopoffset1 = NUM_SEGS;
		loopoffset2 = loopoffset1 + NUM_SEGS;
		loopoffset3 = loopoffset2 + NUM_SEGS;
		rad = 0.4f*iconsize;
		halfside = 0.5f * iconsize;
		mesh.setNumVerts(3*NUM_SEGS+1+24);
		mesh.setNumFaces(3*NUM_SEGS+12);
		for (iloop = 0; iloop<NUM_SEGS; iloop++)
		{	u = (float(iloop)/float(NUM_SEGS))*TWOPI;
			rcosu = rad*(float)cos(u);
			rsinu = rad*(float)sin(u);
			mesh.setVert(iloop,              Point3(rcosu,rsinu, 0.0f));
			mesh.setVert(iloop + loopoffset1,Point3(0.0f ,rcosu,rsinu));
			mesh.setVert(iloop + loopoffset2,Point3(rcosu, 0.0f,rsinu));
		}
		mesh.setVert(loopoffset3, Zero);

		mesh.setVert(loopoffset3+1,Point3( halfside, halfside, rad));
		mesh.setVert(loopoffset3+2,Point3(-halfside, halfside, rad));
		mesh.setVert(loopoffset3+3,Point3(-halfside,-halfside, rad));
		mesh.setVert(loopoffset3+4,Point3( halfside,-halfside, rad));
		mesh.setVert(loopoffset3+5,Point3( halfside, halfside,-rad));
		mesh.setVert(loopoffset3+6,Point3(-halfside, halfside,-rad));
		mesh.setVert(loopoffset3+7,Point3(-halfside,-halfside,-rad));
		mesh.setVert(loopoffset3+8,Point3( halfside,-halfside,-rad));

		mesh.setVert(loopoffset3+9 ,Point3( halfside, rad, halfside));
		mesh.setVert(loopoffset3+10,Point3(-halfside, rad, halfside));
		mesh.setVert(loopoffset3+11,Point3(-halfside, rad,-halfside));
		mesh.setVert(loopoffset3+12,Point3( halfside, rad,-halfside));
		mesh.setVert(loopoffset3+13,Point3( halfside,-rad, halfside));
		mesh.setVert(loopoffset3+14,Point3(-halfside,-rad, halfside));
		mesh.setVert(loopoffset3+15,Point3(-halfside,-rad,-halfside));
		mesh.setVert(loopoffset3+16,Point3( halfside,-rad,-halfside));

		mesh.setVert(loopoffset3+17,Point3( rad, halfside, halfside));
		mesh.setVert(loopoffset3+18,Point3( rad,-halfside, halfside));
		mesh.setVert(loopoffset3+19,Point3( rad,-halfside,-halfside));
		mesh.setVert(loopoffset3+20,Point3( rad, halfside,-halfside));
		mesh.setVert(loopoffset3+21,Point3(-rad, halfside, halfside));
		mesh.setVert(loopoffset3+22,Point3(-rad,-halfside, halfside));
		mesh.setVert(loopoffset3+23,Point3(-rad,-halfside,-halfside));
		mesh.setVert(loopoffset3+24,Point3(-rad, halfside,-halfside));

		v3 = loopoffset3;
		for (iloop = 0; iloop<NUM_SEGS; iloop++)
		{	v1 = iloop;
			v2 = (iloop>(NUM_SEGS-2)?iloop-NUM_SEGS+1:iloop+1);
			mesh.faces[iloop].setEdgeVisFlags(1,0,0);
			mesh.faces[iloop].setSmGroup(0);
			mesh.faces[iloop].setVerts(v1,v2,v3);

			mesh.faces[iloop+loopoffset1].setEdgeVisFlags(1,0,0);
			mesh.faces[iloop+loopoffset1].setSmGroup(0);
			mesh.faces[iloop+loopoffset1].setVerts(v1+loopoffset1,v2+loopoffset1,v3);

			mesh.faces[iloop+loopoffset2].setEdgeVisFlags(1,0,0);
			mesh.faces[iloop+loopoffset2].setSmGroup(0);
			mesh.faces[iloop+loopoffset2].setVerts(v1+loopoffset2,v2+loopoffset2,v3);
		}
		mesh.faces[loopoffset3  ].setEdgeVisFlags(1,1,0);
		mesh.faces[loopoffset3  ].setSmGroup(0);
		mesh.faces[loopoffset3  ].setVerts(loopoffset3+1,loopoffset3+2,loopoffset3+3);
		mesh.faces[loopoffset3+1].setEdgeVisFlags(1,1,0);
		mesh.faces[loopoffset3+1].setSmGroup(0);
		mesh.faces[loopoffset3+1].setVerts(loopoffset3+3,loopoffset3+4,loopoffset3+1);

		mesh.faces[loopoffset3+2].setEdgeVisFlags(1,1,0);
		mesh.faces[loopoffset3+2].setSmGroup(0);
		mesh.faces[loopoffset3+2].setVerts(loopoffset3+5,loopoffset3+6,loopoffset3+7);
		mesh.faces[loopoffset3+3].setEdgeVisFlags(1,1,0);
		mesh.faces[loopoffset3+3].setSmGroup(0);
		mesh.faces[loopoffset3+3].setVerts(loopoffset3+7,loopoffset3+8,loopoffset3+5);

		mesh.faces[loopoffset3+4].setEdgeVisFlags(1,1,0);
		mesh.faces[loopoffset3+4].setSmGroup(0);
		mesh.faces[loopoffset3+4].setVerts(loopoffset3+ 9,loopoffset3+10,loopoffset3+11);
		mesh.faces[loopoffset3+5].setEdgeVisFlags(1,1,0);
		mesh.faces[loopoffset3+5].setSmGroup(0);
		mesh.faces[loopoffset3+5].setVerts(loopoffset3+11,loopoffset3+12,loopoffset3+ 9);

		mesh.faces[loopoffset3+6].setEdgeVisFlags(1,1,0);
		mesh.faces[loopoffset3+6].setSmGroup(0);
		mesh.faces[loopoffset3+6].setVerts(loopoffset3+13,loopoffset3+14,loopoffset3+15);
		mesh.faces[loopoffset3+7].setEdgeVisFlags(1,1,0);
		mesh.faces[loopoffset3+7].setSmGroup(0);
		mesh.faces[loopoffset3+7].setVerts(loopoffset3+15,loopoffset3+16,loopoffset3+13);

		mesh.faces[loopoffset3+8].setEdgeVisFlags(1,1,0);
		mesh.faces[loopoffset3+8].setSmGroup(0);
		mesh.faces[loopoffset3+8].setVerts(loopoffset3+17,loopoffset3+18,loopoffset3+19);
		mesh.faces[loopoffset3+9].setEdgeVisFlags(1,1,0);
		mesh.faces[loopoffset3+9].setSmGroup(0);
		mesh.faces[loopoffset3+9].setVerts(loopoffset3+19,loopoffset3+20,loopoffset3+17);

		mesh.faces[loopoffset3+10].setEdgeVisFlags(1,1,0);
		mesh.faces[loopoffset3+10].setSmGroup(0);
		mesh.faces[loopoffset3+10].setVerts(loopoffset3+21,loopoffset3+22,loopoffset3+23);
		mesh.faces[loopoffset3+11].setEdgeVisFlags(1,1,0);
		mesh.faces[loopoffset3+11].setSmGroup(0);
		mesh.faces[loopoffset3+11].setVerts(loopoffset3+23,loopoffset3+24,loopoffset3+21);

	}
	else
	{	mesh.setNumVerts(0);
		mesh.setNumFaces(0);
	}
	mesh.InvalidateGeomCache();
}

class PinObjCreateCallback : public CreateMouseCallBack
{	public:
		PinObject *ob;	
		Point3 p0,p1;
		IPoint2 sp0;
		int proc(ViewExp *vpt,int msg,int point,int flags,IPoint2 m,Matrix3& mat);
};

int PinObjCreateCallback::proc(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat)
{
#ifdef _3D_CREATE
	DWORD snapdim = SNAP_IN_3D;
#else
	DWORD snapdim = SNAP_IN_PLANE;
#endif

#ifdef _OSNAP
	if (msg == MOUSE_FREEMOVE)
	{ vpt->SnapPreview(m,m,NULL, snapdim);
	}
#endif
	
	if (msg==MOUSE_POINT||msg==MOUSE_MOVE)
	 {	switch(point)
		{	case 0:								
				// if hidden by category, re-display particles and objects
				GetCOREInterface()->SetHideByCategoryFlags(GetCOREInterface()->GetHideByCategoryFlags() & ~(HIDE_OBJECTS|HIDE_PARTICLES));
				sp0 = m;
				p0  = vpt->SnapPoint(m,m,NULL,snapdim);
				mat.SetTrans(p0);
				break;
			case 1:
				p1  = vpt->SnapPoint(m,m,NULL,snapdim);
				float x=Length(p1-p0);
				ob->pblock->SetValue(PB_ICONSIZE,0,x);
				ob->pmapParam->Invalidate();
				if (msg==MOUSE_POINT)
				{	if (Length(m-sp0)<3) return CREATE_ABORT;
					else return CREATE_STOP;
				}
				break;
		}
	}
	else
	{	if (msg == MOUSE_ABORT)
		return CREATE_ABORT;
	}
	return TRUE;
}

static PinObjCreateCallback PinCreateCB;

CreateMouseCallBack* PinObject::GetCreateMouseCallBack()
{	PinCreateCB.ob = this;
	return &PinCreateCB;
}

void PinObject::InvalidateUI() 
{	if (pmapParam) pmapParam->Invalidate();}

Modifier *PinObject::CreateWSMMod(INode *node)
{	return new PinMod(node,this);}

RefTargetHandle PinObject::Clone(RemapDir& remap) 
{	PinObject* newob = new PinObject();
	newob->ReplaceReference(0,pblock->Clone(remap));
	return newob;
}

ParamDimension *PinObject::GetParameterDim(int pbIndex) 
{	switch (pbIndex)
	{	case PB_ONTIME:		return stdTimeDim;
		case PB_OFFTIME:	return stdTimeDim;
		case PB_ICONSIZE:	return stdWorldDim;
		default: return defaultDim;
	}
}

TSTR PinObject::GetParameterName(int pbIndex) 
{	switch (pbIndex)
	{	case PB_ONTIME:		return GetString(IDS_AP_ONTIME);
		case PB_OFFTIME:	return GetString(IDS_AP_OFFTIME);
		case PB_PINTYPE:	return GetString(IDS_AP_PINTYPE);
		case PB_ICONSIZE:	return GetString(IDS_AP_ICONSIZE);
		default: 			return TSTR(_T(""));
	}
}

ParamUIDesc *PinObject::UIDesc()
{	return descParamPin;}

int PinObject::UIDescLength()
{	return PINPARAMDESC_LENGTH;}

TSTR PinObject::UIStrName()
{   return GetString(IDS_AP_PINPARAM);}


PinMod::PinMod(INode *node,PinObject *obj)
{	//MakeRefByID(FOREVER,SIMPWSMMOD_OBREF,obj);
	MakeRefByID(FOREVER,SIMPWSMMOD_NODEREF,node);
	pblock = NULL;
	obRef = NULL;
	}

Interval PinMod::GetValidity(TimeValue t) 
{	if (nodeRef)
	{	Interval valid=FOREVER;
		Matrix3 tm;
		tm=nodeRef->GetObjectTM(t,&valid);
		return valid;
	}
	else
	{	return FOREVER;
	}
}

class PinDeformer : public Deformer
{	public:		
	Point3 Map(int i, Point3 p) {return p;}
};
static PinDeformer gdeformer;

Deformer& PinMod::GetDeformer(TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat)
{	return gdeformer;}

RefTargetHandle PinMod::Clone(RemapDir& remap) 
{	PinMod *newob = new PinMod(nodeRef,(PinObject*)obRef);	
	newob->SimpleWSMModClone(this);
	return newob;
}

void PinMod::ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node)
{	ParticleObject *obj = GetParticleInterface(os->obj);
	if (obj)
	{	force.obj=(PinObject*)GetWSMObject(t);
		force.node=nodeRef;
		force.tmValid.SetEmpty();
		force.fValid.SetEmpty();
		force.dt=GetTicksPerFrame();
		force.dtsq=force.dt*force.dt;
		obj->ApplyForceField(&force); //ok
	}
}

Point3 PinField::Force(TimeValue t,const Point3 &pos, const Point3 &vel,int index) //ok
{	fValid= FOREVER;		
	if (!tmValid.InInterval(t)) 
	{	tmValid=FOREVER;
		tm=node->GetObjectTM(t,&tmValid);
		invtm=Inverse(tm);
	}
	fValid&=tmValid;
	TimeValue t1,t2;
	obj->pblock->GetValue(PB_ONTIME,t,t1,fValid);
	obj->pblock->GetValue(PB_OFFTIME,t,t2,fValid);
	Point3 OutPin;
	if ((t>=t1)&&(t<=t2))
		OutPin = Zero;
	else 
		OutPin = Zero;
	return OutPin*6.25e-03f;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\dynwarps\dynwarps.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dynwarps.rc
//
#define IDS_AP_FORCE                    1
#define IDS_AP_FORCEMOD                 2
#define IDS_AP_FORCEBINDING             3
#define IDS_AP_TOP                      4
#define IDS_AP_PARAMETERS               5
#define IDS_AP_ONTIME                   6
#define IDS_AP_OFFTIME                  7
#define IDS_AP_STRENGTH                 8
#define IDS_AP_UNITS                    9
#define IDS_AP_FEEDBACKON               10
#define IDS_AP_REVERSIBLE               11
#define IDS_AP_TARGETVEL                12
#define IDS_AP_CONTROLGAIN              13
#define IDS_AP_TIMEPER1                 14
#define IDS_AP_PHASPER1                 15
#define IDS_AP_TIMEPER2                 16
#define IDS_AP_PHASPER2                 17
#define IDS_AP_ICONSIZE                 18
#define IDS_AP_FORCEPARAM               19
#define IDS_AP_MOTOR                    20
#define IDS_AP_MOTORMOD                 21
#define IDS_AP_MOTORBINDING             22
#define IDS_AP_TARGETREVS               23
#define IDS_AP_REVSUNITS                24
#define IDS_AP_MOTORPARAM               25
#define IDS_AP_AMP1                     26
#define IDS_AP_AMP2                     27
#define IDS_AP_RANGEON                  28
#define IDS_AP_RANGEVAL                 29
#define IDS_AP_ENABLESINES              30
#define IDS_AP_STRENGTHT                31
#define IDS_AP_DYNWARPLIB               32
#define IDS_AP_FORCE_CLASS              33
#define IDS_AP_MOTOR_CLASS              34
#define IDS_AP_PIN                      35
#define IDS_AP_PINMOD                   37
#define IDS_AP_PINBINDING               38
#define IDS_AP_PINTYPE                  39
#define IDS_AP_PIN_CLASS                40
#define SPACEWARPS_FOR_DYNAMICS         51
#define IDS_AP_PINPARAM                 52
#define IDD_SW_DESC                     108
#define IDD_SW_DYNMOTOR                 110
#define IDD_SW_DYNFORCE                 111
#define IDD_SW_DYNPIN                   112
#define IDD_SW_DESC_DYNONLY             113
#define IDC_AP_MOTORONT                 1000
#define IDC_AP_MOTORONTSPIN             1001
#define IDC_AP_MOTOROFFTSPIN            1002
#define IDC_AP_MOTOROFFT                1003
#define IDC_AP_FINNEWTONS               1004
#define IDC_AP_FINLBS                   1005
#define IDC_AP_FEEDBACKON               1006
#define IDC_AP_CONSTRAINTPIN            1006
#define IDC_AP_TINLBIN                  1007
#define IDC_AP_REVERSIBLE               1007
#define IDC_AP_FVALUE                   1008
#define IDC_AP_REVERSIBLET              1008
#define IDC_AP_FVALUESPIN               1009
#define IDC_AP_REVSRPS                  1009
#define IDC_AP_DYNF_ICONSIZE            1010
#define IDC_AP_DYNF_ICONSIZESPIN        1011
#define IDC_AP_CONTROLPT                1012
#define IDC_AP_CONTROLPTSPIN            1013
#define IDC_AP_GAIN                     1014
#define IDC_AP_GAINSPIN                 1015
#define IDC_AP_VARIATIONON              1016
#define IDC_AP_AMPVART2TSPIN            1017
#define IDC_AP_RANGEVAL                 1017
#define IDC_AP_AMPPHAS1T                1018
#define IDC_AP_RANGEVALSPIN             1018
#define IDC_AP_AMPVART2T                1019
#define IDC_AP_RANGE                    1019
#define IDC_AP_RANGEM                   1020
#define IDC_AP_CONSTRAINTAXLE           1020
#define IDC_AP_RANGEVALM                1021
#define IDC_AP_CONSTRAINTSURF           1021
#define IDC_AP_RANGEVALMSPIN            1022
#define IDC_AP_AMPAMP1M                 1023
#define IDC_SP_BLASTSTOP                1030
#define IDC_AP_FOFFTIME                 1030
#define IDC_SP_BLASTSTOPSPIN            1031
#define IDC_AP_FOFFTIMESPIN             1031
#define IDC_AP_AMPVART1                 1032
#define IDC_AP_AMPVART1SPIN             1033
#define IDC_SP_BLASTSPHR                1034
#define IDC_AP_AMPVART2                 1034
#define IDC_SP_BLASTCYL                 1035
#define IDC_AP_AMPVART2SPIN             1035
#define IDC_SP_BLASTPLAN                1036
#define IDC_AP_AMPPHAS1                 1036
#define IDC_SP_BLASTDV                  1037
#define IDC_AP_AMPPHAS1SPIN             1037
#define IDC_AP_TVALUE                   1037
#define IDC_SP_BLASTDVSPIN              1038
#define IDC_AP_AMPPHAS2                 1038
#define IDC_AP_TVALUESPIN               1038
#define IDC_SP_BLASTDECAY               1039
#define IDC_AP_AMPPHAS2SPIN             1039
#define IDC_AP_AMPPHAS1SPIN2            1039
#define IDC_AP_AMPPHAS1TSPIN            1039
#define IDC_SP_BLASTDECAYSPIN           1040
#define IDC_AP_AMPPHAS3                 1040
#define IDC_AP_AMPPHAS2T                1040
#define IDC_AP_AMPAMP1                  1040
#define IDC_SP_DECAYOFF                 1041
#define IDC_AP_TINNM                    1041
#define IDC_AP_AMPAMP1SPIN              1041
#define IDC_SP_DECAYLIN                 1042
#define IDC_AP_TINLBFT                  1042
#define IDC_AP_AMPAMP2                  1042
#define IDC_SP_DECAYEXP                 1043
#define IDC_AP_AMPPHAS2SPIN2            1043
#define IDC_AP_AMPPHAS2TSPIN            1043
#define IDC_AP_AMPAMP2SPIN              1043
#define IDC_SP_BLASTCHAOS               1044
#define IDC_AP_REVSRPH                  1044
#define IDC_SP_BLASTCHAOSSPIN           1045
#define IDC_AP_REVSRPM                  1045
#define IDC_SP_BLASTSTRT                1046
#define IDC_AP_FONTIME                  1046
#define IDC_AP_AMPAMP2M                 1046
#define IDC_SP_BLASTSTRTSPIN            1047
#define IDC_AP_FONTIMESPIN              1047
#define IDC_AP_AMPAMP2MSPIN             1047
#define IDC_SP_BLAST_ICONSIZE           1048
#define IDC_AP_DTORK_ICONSIZE           1048
#define IDC_SP_BLAST_ICONSIZESPIN       1049
#define IDC_AP_DTORK_ICONSIZESPIN       1049
#define IDC_AP_AMPAMP1MSPIN             1050

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1022
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\dynwarps\force.cpp ===
/*****************************************************************************
 *<
	FILE: force.cpp

	DESCRIPTION: Point Force icon for Dynamics / Force field for Particles

	CREATED BY: Eric Peterson (from Audrey's PBOMB.CPP)

	HISTORY: 6/97

 *>	Copyright (c) 1997, All Rights Reserved, assigned to, and for Yost Group Inc.
 *****************************************************************************/
#include "dynwarps.h"
#include "dynw.h"
#include "iparamm.h"
#include "simpmod.h"
#include "simpobj.h"
#include "texutil.h"

static Class_ID FORCE_CLASS_ID(0x3d4d3ca5, 0x3b22358f);
static Class_ID FORCEMOD_CLASS_ID(0x44975ae9, 0x65f53e3a);
class ForceObject : public SimpleWSMObject {	
	public:									
		ForceObject();		
		static IParamMap *pmapParam;
		static IObjParam *ip;
		static HWND hSot;
		ForceField *GetForceField(INode *node);
		BOOL SupportsDynamics() {return TRUE;}

		// From Animatable		
		void BeginEditParams( IObjParam  *ip, ULONG flags,Animatable *prev );
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);		
		void MapKeys(TimeMap *map,DWORD flags);
				
		// from object		
		CreateMouseCallBack* GetCreateMouseCallBack();		
		
		// From SimpleWSMObject		
		void InvalidateUI();		

		// From Animatable		
		void DeleteThis() {delete this;}		
		Class_ID ClassID() {return FORCE_CLASS_ID;}		
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() {return GetString(IDS_AP_FORCE);}

		// From BaseObject
		IParamArray *GetParamBlock() {return pblock;}
		int GetParamBlockIndex(int id) {return id;}
						
		// From WSMObject
		Modifier *CreateWSMMod(INode *node);
		
		// From SimpleWSMObject				
		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);
		void BuildMesh(TimeValue t);

		int DialogID() {return IDD_SW_DYNFORCE;}
		ParamUIDesc *UIDesc();
		int UIDescLength();
		TSTR UIStrName();
	};

IObjParam *ForceObject::ip        = NULL;
IParamMap *ForceObject::pmapParam = NULL;
HWND       ForceObject::hSot      = NULL;

class ForceClassDesc:public ClassDesc
{	public:
		int 			IsPublic() {return 1;}
		void *			Create(BOOL loading = FALSE) { return new ForceObject;}
		const TCHAR *	ClassName() {return GetString(IDS_AP_FORCE_CLASS);}
		SClass_ID		SuperClassID() {return WSM_OBJECT_CLASS_ID; }
		Class_ID		ClassID() {return FORCE_CLASS_ID;}
		const TCHAR* 	Category() {return GetSpaceWarpCatString(SPACEWARP_CAT_PARTICLE);}
};

static ForceClassDesc ForceDesc;
ClassDesc* GetForceObjDesc() {return &ForceDesc;}

class ForceMod;

class PtForceField : public ForceField
{	public:
		ForceObject *obj;
		TimeValue dtsq,dt;
		INode *node;
		int count;
		Matrix3 tm,invtm;
		Interval tmValid;
		Point3 force;
		Interval fValid;
		Point3 Force(TimeValue t,const Point3 &pos, const Point3 &vel, int index);
};

class ForceMod : public SimpleWSMMod
{	public:				
		PtForceField force;
		ForceMod() {}
		ForceMod(INode *node,ForceObject *obj);		
		// From Animatable
		void GetClassName(TSTR& s) {s= GetString(IDS_AP_FORCEMOD);}
		SClass_ID SuperClassID() {return WSM_CLASS_ID;}
		void DeleteThis() {delete this;}
		Class_ID ClassID() { return FORCEMOD_CLASS_ID;}
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() {return GetString(IDS_AP_FORCEBINDING);}
		void ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node);
		// From SimpleWSMMod		
		Interval GetValidity(TimeValue t);		
		Deformer& GetDeformer(TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat);
};

class ForceModClassDesc:public ClassDesc
{	public:
		int 			IsPublic() { return 0; }
		void *			Create(BOOL loading = FALSE) {return new ForceMod;}
		const TCHAR *	ClassName() { return GetString(IDS_AP_FORCEMOD);}
		SClass_ID		SuperClassID() {return WSM_CLASS_ID;}
		Class_ID		ClassID() {return FORCEMOD_CLASS_ID;}
		const TCHAR* 	Category() {return _T("");}
};

static ForceModClassDesc ForceModDesc;

ClassDesc* GetForceModDesc() {return &ForceModDesc;}

class ForceModData : public LocalModData
{	public:
		LocalModData *Clone ();
};

LocalModData *ForceModData::Clone ()
{	ForceModData *clone;
	clone = new ForceModData ();
	return(clone);
}

//--- ForceObject Parameter map/block descriptors ------------------
#define PB_ONTIME			0
#define PB_OFFTIME			1
#define PB_STRENGTH			2
#define PB_UNITS			3
#define PB_FEEDBACKON		4 
#define PB_REVERSIBLE		5
#define PB_TARGETVEL		6
#define PB_CONTROLGAIN		7
#define PB_ENABLESINES		8
#define PB_TIMEPER1			9
#define PB_AMP1				10
#define PB_PHASPER1			11
#define PB_TIMEPER2			12
#define PB_AMP2				13
#define PB_PHASPER2			14
#define PB_RANGEON			15
#define PB_RANGEVAL			16
#define PB_ICONSIZE			17

static int UnitsIDs[] = {IDC_AP_FINNEWTONS,IDC_AP_FINLBS};

static ParamUIDesc descParamForce[] = {

	// Force Time On
	ParamUIDesc(
		PB_ONTIME,
		EDITTYPE_TIME,
		IDC_AP_FONTIME,IDC_AP_FONTIMESPIN,
		-999999999.0f,999999999.0f,
		10.0f),
	
	// Force Time Off
	ParamUIDesc(
		PB_OFFTIME,
		EDITTYPE_TIME,
		IDC_AP_FOFFTIME,IDC_AP_FOFFTIMESPIN,
		-999999999.0f,999999999.0f,
		10.0f),
	
	// Strength
	ParamUIDesc(
		PB_STRENGTH,
		EDITTYPE_FLOAT,
		IDC_AP_FVALUE,IDC_AP_FVALUESPIN,
		-999999999.0f,999999999.0f,
		SPIN_AUTOSCALE),

	// Force Units
	ParamUIDesc(PB_UNITS,TYPE_RADIO,UnitsIDs,2),

	// Feedback
	ParamUIDesc(PB_FEEDBACKON,TYPE_SINGLECHEKBOX,IDC_AP_FEEDBACKON),

	// Reversible
	ParamUIDesc(PB_REVERSIBLE,TYPE_SINGLECHEKBOX,IDC_AP_REVERSIBLE),
	
	// Target Speed
	ParamUIDesc(
		PB_TARGETVEL,
		EDITTYPE_UNIVERSE,
		IDC_AP_CONTROLPT,IDC_AP_CONTROLPTSPIN,
		0.0f,999999999.0f,
		SPIN_AUTOSCALE),

	// Gain
	ParamUIDesc(
		PB_CONTROLGAIN,
		EDITTYPE_FLOAT,
		IDC_AP_GAIN,IDC_AP_GAINSPIN,
		0.0f,999999999.0f,
		SPIN_AUTOSCALE),

	// Reversible
	ParamUIDesc(PB_ENABLESINES,TYPE_SINGLECHEKBOX,IDC_AP_VARIATIONON),
	
	// Period 1
	ParamUIDesc(
		PB_TIMEPER1,
		EDITTYPE_TIME,
		IDC_AP_AMPVART1,IDC_AP_AMPVART1SPIN,
		0.0f,999999999.0f,
		10.0f),

	// Amp 1
	ParamUIDesc(
		PB_AMP1,
		EDITTYPE_FLOAT,
		IDC_AP_AMPAMP1,IDC_AP_AMPAMP1SPIN,
		0.0f,999999999.0f,
		SPIN_AUTOSCALE),

	// Phase 1
	ParamUIDesc(
		PB_PHASPER1,
		EDITTYPE_FLOAT,
		IDC_AP_AMPPHAS1,IDC_AP_AMPPHAS1SPIN,
		0.0f,360.0f,
		SPIN_AUTOSCALE),

	// Period 2
	ParamUIDesc(
		PB_TIMEPER2,
		EDITTYPE_TIME,
		IDC_AP_AMPVART2,IDC_AP_AMPVART2SPIN,
		0.0f,999999999.0f,
		10.0f),

	// Amp 2
	ParamUIDesc(
		PB_AMP2,
		EDITTYPE_FLOAT,
		IDC_AP_AMPAMP2,IDC_AP_AMPAMP2SPIN,
		0.0f,999999999.0f,
		SPIN_AUTOSCALE),

	// Phase 2
	ParamUIDesc(
		PB_PHASPER2,
		EDITTYPE_FLOAT,
		IDC_AP_AMPPHAS2,IDC_AP_AMPPHAS2SPIN,
		0.0f,360.0f,
		SPIN_AUTOSCALE),

	// Range on
	ParamUIDesc(PB_RANGEON,TYPE_SINGLECHEKBOX,IDC_AP_RANGE),
	
	// Range limit
	ParamUIDesc(
		PB_RANGEVAL,
		EDITTYPE_UNIVERSE,
		IDC_AP_RANGEVAL,IDC_AP_RANGEVALSPIN,
		0.0f,999999999.0f,
		SPIN_AUTOSCALE),

	// Icon Size
	ParamUIDesc(
		PB_ICONSIZE,
		EDITTYPE_UNIVERSE,
		IDC_AP_DYNF_ICONSIZE,IDC_AP_DYNF_ICONSIZESPIN,
		0.0f, 9999999.0f,
		SPIN_AUTOSCALE),
	};

#define FORCEPARAMDESC_LENGTH	18

ParamBlockDescID descForceVer0[] = {
	{ TYPE_INT, NULL, FALSE, 0 },	// PB_ONTIME
	{ TYPE_INT, NULL, FALSE, 1 },	// PB_OFFTIME
	{ TYPE_FLOAT, NULL, TRUE, 2 },	// PB_STRENGTH
	{ TYPE_INT, NULL, FALSE, 3 },	// PB_UNITS
	{ TYPE_INT, NULL, FALSE, 4 },	// PB_FEEDBACKON
	{ TYPE_INT, NULL, FALSE, 5 },	// PB_REVERSIBLE
	{ TYPE_FLOAT, NULL, TRUE, 6 },	// PB_TARGETVEL
	{ TYPE_FLOAT, NULL, TRUE, 7 },  // PB_CONTROLGAIN
	{ TYPE_INT, NULL, FALSE, 8 },   // PB_ENABLESINES
	{ TYPE_INT, NULL, TRUE, 9 },    // PB_TIMEPER1
	{ TYPE_FLOAT, NULL, TRUE, 10 }, // PB_AMP1
	{ TYPE_FLOAT, NULL, TRUE, 11 }, // PB_PHASPER1
	{ TYPE_INT, NULL, TRUE, 12 },   // PB_TIMEPER2
	{ TYPE_FLOAT, NULL, TRUE, 13 }, // PB_AMP2
	{ TYPE_FLOAT, NULL, TRUE, 14 }, // PB_PHASPER2
	{ TYPE_INT, NULL, FALSE, 15 },  // PB_RangeOn
	{ TYPE_FLOAT, NULL, TRUE, 16 }, // PB_Range
	{ TYPE_FLOAT, NULL, FALSE, 17}  // PB_ICONSIZE
	};

#define PBLOCK_LENGTH	18

#define CURRENT_VERSION	0


//--- Deflect object methods -----------------------------------------

ForceObject::ForceObject()
{	int FToTick=(int)((float)TIME_TICKSPERSEC/(float)GetFrameRate());
	MakeRefByID(FOREVER, 0,CreateParameterBlock(descForceVer0, PBLOCK_LENGTH, CURRENT_VERSION));
	assert(pblock);	
	pblock->SetValue(PB_ONTIME,0,0);
	pblock->SetValue(PB_OFFTIME,0,FToTick*30);
	pblock->SetValue(PB_STRENGTH,0,1.0f);
	pblock->SetValue(PB_UNITS,0,0);
	pblock->SetValue(PB_FEEDBACKON,0,0);
	pblock->SetValue(PB_REVERSIBLE,0,0);
	pblock->SetValue(PB_CONTROLGAIN,0,50.0f);
	pblock->SetValue(PB_TARGETVEL,0,100.0f);
	pblock->SetValue(PB_ENABLESINES,0,0);
	pblock->SetValue(PB_TIMEPER1,0,100);
	pblock->SetValue(PB_AMP1,0,100.0f);
	pblock->SetValue(PB_PHASPER1,0,0.0f);
	pblock->SetValue(PB_TIMEPER2,0,100);
	pblock->SetValue(PB_AMP2,0,100.0f);
	pblock->SetValue(PB_RANGEON,0,0);
	pblock->SetValue(PB_RANGEVAL,0,1000.0f);
	pblock->SetValue(PB_PHASPER2,0,0.0f);
}

class ForceDlgProc : public ParamMapUserDlgProc
{	public:
		ForceObject *po;
		HWND hwnd;
		ForceDlgProc(ForceObject *p) {po=p;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void Update(TimeValue t);
		void DoFeedback();
		void DoEnableVar();
		void DoRange();
		void DeleteThis() {delete this;}
};
void ForceDlgProc::DoFeedback()
{ int feedbackon;
  po->pblock->GetValue(PB_FEEDBACKON,0,feedbackon,FOREVER);
  if (feedbackon)
  {	SpinnerOn(hwnd,IDC_AP_CONTROLPTSPIN,IDC_AP_CONTROLPT);
	SpinnerOn(hwnd,IDC_AP_GAINSPIN,IDC_AP_GAIN);
  }
  else
  {	SpinnerOff(hwnd,IDC_AP_CONTROLPTSPIN,IDC_AP_CONTROLPT);
	SpinnerOff(hwnd,IDC_AP_GAINSPIN,IDC_AP_GAIN);
  }
  EnableWindow(GetDlgItem(hwnd,IDC_AP_REVERSIBLE),feedbackon);
}
void ForceDlgProc::DoEnableVar()
{ int enablevar;
  po->pblock->GetValue(PB_ENABLESINES,0,enablevar,FOREVER);
  if (enablevar)
  {	SpinnerOn(hwnd,IDC_AP_AMPVART1SPIN,IDC_AP_AMPVART1);
 	SpinnerOn(hwnd,IDC_AP_AMPAMP1SPIN,IDC_AP_AMPAMP1);
	SpinnerOn(hwnd,IDC_AP_AMPPHAS1SPIN,IDC_AP_AMPPHAS1);
	SpinnerOn(hwnd,IDC_AP_AMPVART2SPIN,IDC_AP_AMPVART2);
	SpinnerOn(hwnd,IDC_AP_AMPAMP2SPIN,IDC_AP_AMPAMP2);
	SpinnerOn(hwnd,IDC_AP_AMPPHAS2SPIN,IDC_AP_AMPPHAS2);
  }
  else
  {	SpinnerOff(hwnd,IDC_AP_AMPVART1SPIN,IDC_AP_AMPVART1);
 	SpinnerOff(hwnd,IDC_AP_AMPAMP1SPIN,IDC_AP_AMPAMP1);
 	SpinnerOff(hwnd,IDC_AP_AMPPHAS1SPIN,IDC_AP_AMPPHAS1);
 	SpinnerOff(hwnd,IDC_AP_AMPVART2SPIN,IDC_AP_AMPVART2);
	SpinnerOff(hwnd,IDC_AP_AMPAMP2SPIN,IDC_AP_AMPAMP2);
	SpinnerOff(hwnd,IDC_AP_AMPPHAS2SPIN,IDC_AP_AMPPHAS2);
  }
}
void ForceDlgProc::DoRange()
{ int enablerng;
  po->pblock->GetValue(PB_RANGEON,0,enablerng,FOREVER);
  if (enablerng) 
	SpinnerOn(hwnd,IDC_AP_RANGEVALSPIN,IDC_AP_RANGEVAL);
  else
	SpinnerOff(hwnd,IDC_AP_RANGEVALSPIN,IDC_AP_RANGEVAL);
}

void ForceDlgProc::Update(TimeValue t)
{ DoFeedback();
  DoEnableVar();
  DoRange();
}

BOOL ForceDlgProc::DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
{	switch (msg) 
	{	case WM_INITDIALOG: 
		{ hwnd=hWnd;
		  Update(t);
		  break;
		}
		case WM_COMMAND:
			switch (LOWORD(wParam)) 
			{	case IDC_AP_FEEDBACKON:
					DoFeedback();
					return TRUE;
				case IDC_AP_VARIATIONON:
					DoEnableVar();
					return TRUE;
				case IDC_AP_RANGE:
					DoRange();
					return TRUE;
				default: return TRUE;
			}
	}
	return FALSE;
}

void ForceObject::BeginEditParams(IObjParam *ip,ULONG flags,Animatable *prev)
{	SimpleWSMObject::BeginEditParams(ip,flags,prev);
	this->ip = ip;
	if (pmapParam)
	{	// Left over
		pmapParam->SetParamBlock(pblock);
	}
	else
	{	hSot = ip->AddRollupPage(hInstance,MAKEINTRESOURCE(IDD_SW_DESC),DefaultSOTProc,GetString(IDS_AP_TOP),(LPARAM)ip,APPENDROLL_CLOSED);
		// Gotta make a new one.
		pmapParam = CreateCPParamMap(descParamForce,FORCEPARAMDESC_LENGTH,pblock,ip,hInstance,MAKEINTRESOURCE(IDD_SW_DYNFORCE),GetString(IDS_AP_PARAMETERS),0);
	}
	if (pmapParam) pmapParam->SetUserDlgProc(new ForceDlgProc(this));
}

void ForceObject::EndEditParams(IObjParam *ip,ULONG flags,Animatable *next)
{	SimpleWSMObject::EndEditParams(ip,flags,next);
	this->ip = NULL;
	if (flags&END_EDIT_REMOVEUI )
	{	DestroyCPParamMap(pmapParam);
		ip->DeleteRollupPage(hSot);
		pmapParam = NULL;		
	}	
}

ForceField *ForceObject::GetForceField(INode *node)
{	PtForceField *pb = new PtForceField;	
	pb->obj  = this;
	pb->node = node;
	pb->tmValid.SetEmpty();
	pb->fValid.SetEmpty();
	pb->dt=GetTicksPerFrame();
	pb->dtsq=pb->dt*pb->dt;
	return pb;
}

void ForceObject::MapKeys(TimeMap *map,DWORD flags)
{	TimeValue TempTime;
// mapped values
	pblock->GetValue(PB_ONTIME,0,TempTime,FOREVER);
	TempTime=map->map(TempTime);
	pblock->SetValue(PB_ONTIME,0,TempTime);
	pblock->GetValue(PB_OFFTIME,0,TempTime,FOREVER);
	TempTime=map->map(TempTime);
	pblock->SetValue(PB_OFFTIME,0,TempTime);
// scaled values
	pblock->GetValue(PB_TIMEPER1,0,TempTime,FOREVER);
	TempTime=map->map(TempTime);
	pblock->SetValue(PB_TIMEPER1,0,TempTime);
	pblock->GetValue(PB_TIMEPER2,0,TempTime,FOREVER);
	TempTime=map->map(TempTime);
	pblock->SetValue(PB_TIMEPER2,0,TempTime);
}

#define NUM_SEGS 12
#define NUM_SEGS2 24

void ForceObject::BuildMesh(TimeValue t)
{	ivalid = FOREVER;
	float l1,l2,l3,l4,r1,r2,r3,length;
	pblock->GetValue(PB_ICONSIZE,t,length,ivalid);
	int dorange,dofrange=0,norvs,norfs;
	pblock->GetValue(PB_RANGEON,t,dorange,ivalid);
	if (dorange){ dorange=73;dofrange=72;}
	l1=0.0f;
	l2=length/2.0f;
	l3=0.1f*length;
	l4=length;
	r1=length/6.0f;
	r2=r1/2.0f;
	r3=(r1+r2)/2.0f;
	float u,cosu,sinu,r1cosu,r2cosu,r3cosu,r1sinu,r2sinu,r3sinu;
	mesh.setNumVerts((norvs=76)+dorange);
	mesh.setNumFaces((norfs=84)+dofrange);
	int i,i2,i3,i4,i5,i6,i7;
	i2=NUM_SEGS;
	i3=2*NUM_SEGS;
	i4=3*NUM_SEGS;
	i5=4*NUM_SEGS;
	i6=5*NUM_SEGS;
	i7=6*NUM_SEGS;
    for (i=0;i<NUM_SEGS;i++)
    {	u=float(i)/float(NUM_SEGS)*TWOPI;
		cosu=(float)cos(u);sinu=(float)sin(u);
		r1cosu=r1*cosu;r1sinu=r1*sinu;
		r2cosu=r2*cosu;r2sinu=r2*sinu;
		r3cosu=r3*cosu;r3sinu=r3*sinu;
		mesh.setVert(i,   Point3(r1cosu,r1sinu,-l4));
		mesh.setVert(i+i2,Point3(r1cosu,r1sinu,-l2));
		mesh.setVert(i+i3,Point3(r2cosu,r2sinu,-l2));
		mesh.setVert(i+i4,Point3(r2cosu,r2sinu,-l3));
		mesh.setVert(i+i5,Point3(r3cosu,r3sinu,-l3));
		mesh.setVert(i+i6,Point3(r3cosu,r3sinu,-l1));
	}
    mesh.setVert(i7  ,Point3(0.0f,0.0f,-l4));
    mesh.setVert(i7+1,Point3(0.0f,0.0f,-l2));
    mesh.setVert(i7+2,Point3(0.0f,0.0f,-l3));
    mesh.setVert(i7+3,Point3(0.0f,0.0f,-l1));
    for (i=0;i<NUM_SEGS;i++) 
    {	int v,v2,v3,v4,v5,v6;
		if (i>(NUM_SEGS-2))
		{	v=0;
			v2=i2;
			v3=i3;
			v4=i4;
			v5=i5;
			v6=i6;
		}
		else
		{	v=i+1;
			v2=v+i2;
			v3=v+i3;
			v4=v+i4;
			v5=v+i5;
			v6=v+i6;
		}
		mesh.faces[i].setEdgeVisFlags(1,0,0);
	    mesh.faces[i].setSmGroup(0);
	    mesh.faces[i].setVerts(i,v,i7);
		int ii2=i+i2;
		mesh.faces[ii2].setEdgeVisFlags(1,0,0);
	    mesh.faces[ii2].setSmGroup(0);
	    mesh.faces[ii2].setVerts(ii2,v2,i7+1);
		int ii3=i+i3;
		mesh.faces[ii3].setEdgeVisFlags(1,0,0);
	    mesh.faces[ii3].setSmGroup(0);
	    mesh.faces[ii3].setVerts(ii3,v3,i7+1);
		int ii4=i+i4;
		mesh.faces[ii4].setEdgeVisFlags(1,0,0);
	    mesh.faces[ii4].setSmGroup(0);
	    mesh.faces[ii4].setVerts(ii4,v4,i7+2);
		int ii5=i+i5;
		mesh.faces[ii5].setEdgeVisFlags(1,0,0);
	    mesh.faces[ii5].setSmGroup(0);
	    mesh.faces[ii5].setVerts(ii5,v5,i7+2);
		int ii6=i+i6;
		mesh.faces[ii6].setEdgeVisFlags(1,0,0);
	    mesh.faces[ii6].setSmGroup(0);
	    mesh.faces[ii6].setVerts(ii6,v6,i7+3);
    }
	mesh.faces[72].setEdgeVisFlags(1,0,0);
    mesh.faces[72].setSmGroup(2);
    mesh.faces[72].setVerts(0,12,6);
	mesh.faces[73].setEdgeVisFlags(0,0,1);
    mesh.faces[73].setSmGroup(2);
    mesh.faces[73].setVerts(6,12,18);
	mesh.faces[74].setEdgeVisFlags(1,0,0);
    mesh.faces[74].setSmGroup(2);
    mesh.faces[74].setVerts(3,15,9);
	mesh.faces[75].setEdgeVisFlags(0,0,1);
    mesh.faces[75].setSmGroup(2);
    mesh.faces[75].setVerts(9,15,21);
	mesh.faces[76].setEdgeVisFlags(1,0,0);
    mesh.faces[76].setSmGroup(2);
    mesh.faces[76].setVerts(24,36,30);
	mesh.faces[77].setEdgeVisFlags(0,0,1);
    mesh.faces[77].setSmGroup(2);
    mesh.faces[77].setVerts(30,36,42);
	mesh.faces[78].setEdgeVisFlags(1,0,0);
    mesh.faces[78].setSmGroup(2);
    mesh.faces[78].setVerts(27,39,33);
	mesh.faces[79].setEdgeVisFlags(0,0,1);
    mesh.faces[79].setSmGroup(2);
    mesh.faces[79].setVerts(33,39,45);
	mesh.faces[80].setEdgeVisFlags(1,0,0);
    mesh.faces[80].setSmGroup(2);
    mesh.faces[80].setVerts(48,60,54);
	mesh.faces[81].setEdgeVisFlags(0,0,1);
    mesh.faces[81].setSmGroup(2);
    mesh.faces[81].setVerts(54,60,66);
	mesh.faces[82].setEdgeVisFlags(1,0,0);
    mesh.faces[82].setSmGroup(2);
    mesh.faces[82].setVerts(51,63,57);
	mesh.faces[83].setEdgeVisFlags(0,0,1);
    mesh.faces[83].setSmGroup(2);
    mesh.faces[83].setVerts(57,63,69);
	if (dorange)
	{   int newv;
		pblock->GetValue(PB_RANGEVAL,t,length,ivalid);
		for (int i=0; i<NUM_SEGS2; i++)
	    { u = float(i)/float(NUM_SEGS2) * TWOPI;
		  mesh.setVert(i+norvs, Point3((float)cos(u) * length, (float)sin(u) * length, 0.0f));
	    }
		newv=NUM_SEGS2+norvs;
	    for (i=0; i<NUM_SEGS2; i++) 
	    { u = float(i)/float(NUM_SEGS2) * TWOPI;
		  mesh.setVert(i+newv, Point3(0.0f, (float)cos(u) * length, (float)sin(u) * length));
	    } newv+=NUM_SEGS2;
	    for (i=0; i<NUM_SEGS2; i++)
	    { u = float(i)/float(NUM_SEGS2) * TWOPI;
		  mesh.setVert(i+newv, Point3((float)cos(u) * length, 0.0f, (float)sin(u) * length));
	    }	
		newv+=NUM_SEGS2;
	    mesh.setVert(newv, Point3(0.0f, 0.0f, 0.0f));
		int vi=norvs;
	    for (i=norfs; i<norfs+dofrange; i++) 
	    { int i1 = vi+1;
	      if ((i1-norvs)%NUM_SEGS2==0) i1 -= NUM_SEGS2;
	      mesh.faces[i].setEdgeVisFlags(1,0,0);
	      mesh.faces[i].setSmGroup(0);
	      mesh.faces[i].setVerts(vi,i1,newv);
		  vi++;
		}
	}
	mesh.InvalidateGeomCache();
}

class ForceObjCreateCallback : public CreateMouseCallBack
{	public:
		ForceObject *ob;	
		Point3 p0,p1;
		IPoint2 sp0;
		int proc(ViewExp *vpt,int msg,int point,int flags,IPoint2 m,Matrix3& mat);
};

int ForceObjCreateCallback::proc(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat)
{
#ifdef _3D_CREATE
	DWORD snapdim = SNAP_IN_3D;
#else
	DWORD snapdim = SNAP_IN_PLANE;
#endif

#ifdef _OSNAP
	if (msg == MOUSE_FREEMOVE)
	{ vpt->SnapPreview(m,m,NULL, snapdim);
	}
#endif
	
	if (msg==MOUSE_POINT||msg==MOUSE_MOVE)
	 {	switch(point)
		{	case 0:								
				// if hidden by category, re-display particles and objects
				GetCOREInterface()->SetHideByCategoryFlags(GetCOREInterface()->GetHideByCategoryFlags() & ~(HIDE_OBJECTS|HIDE_PARTICLES));
				sp0 = m;
				p0  = vpt->SnapPoint(m,m,NULL,snapdim);
				mat.SetTrans(p0);
				