on. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <XBUtil.h>
#include <XBResource.h>

// The following header file is generated from "Resource.rdf" file using the
// Bundler tool. In addition to the header, the tool outputs a binary file
// (Resource.xpr) which contains compiled (i.e. bundled) resources and is
// loaded at runtime using the CXBPackedResource class.
#include "Resource.h"




//-----------------------------------------------------------------------------
// ASCII names for the resources used by the app
//-----------------------------------------------------------------------------
XBRESOURCE g_ResourceNames[] = 
{
    { "Seafloor.bmp", resource_Seafloor_OFFSET },
    { NULL, 0 },
};


   

//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_LEFTSTICK,    XBHELP_PLACEMENT_2, L"Change fog\nstart/density" },
    { XBHELP_RIGHTSTICK,   XBHELP_PLACEMENT_2, L"Change fog\nend" },
    { XBHELP_X_BUTTON,     XBHELP_PLACEMENT_2, L"Change fog\nmode" },
    { XBHELP_A_BUTTON,     XBHELP_PLACEMENT_2, L"Toggle use of\nvertex shader" },
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_2, L"Display\nhelp" },
    { XBHELP_START_BUTTON, XBHELP_PLACEMENT_1, L"Pause" },
};

#define NUM_HELP_CALLOUTS 6




//-----------------------------------------------------------------------------
// Structures and Macros
//-----------------------------------------------------------------------------
struct FOGVERTEX
{
    D3DXVECTOR3 p;
    D3DXVECTOR3 n;
    FLOAT       tu, tv;
};

#define D3DFVF_FOGVERTEX (D3DFVF_XYZ|D3DFVF_NORMAL|D3DFVF_TEX1)

#define FAR_PLANE  150.0f
#define NEAR_PLANE   1.0f
#define FOG_COLOR  0xff0000ff




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Application class. The base class provides just about all the
//       functionality we want, so we're just supplying stubs to interface with
//       the non-C++ functions of the app.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBPackedResource  m_xprResource;         // Packed resources for the app
    CXBFont            m_Font;                // Font class
    CXBHelp            m_Help;                // Help class
    BOOL               m_bDrawHelp;           // Whether to draw help

    D3DXMATRIX         m_matWorld;            // Transform matrices
    D3DXMATRIX         m_matView;
    D3DXMATRIX         m_matProj;

    DWORD              m_dwFogMode;           // Fog parameters
    FLOAT              m_fFogStartValue;
    FLOAT              m_fFogEndValue;
    FLOAT              m_fFogDensity;

    LPDIRECT3DVERTEXBUFFER8 m_pColumnVB;      // Scene geometry
    DWORD                   m_dwNumColumnVertices;
    LPDIRECT3DVERTEXBUFFER8 m_pTerrainVB;
    DWORD                   m_dwNumTerrainVertices;
    LPDIRECT3DTEXTURE8      m_pFloorTexture;

    DWORD                   m_dwVertexShader; // Fog vertex shader
    BOOL                    m_bUseVertexShader;

    HRESULT GenerateTerrainDisk( DWORD dwNumSegments, FLOAT fScale );
    HRESULT GenerateColumn( DWORD dwNumSegments, FLOAT fRadius, FLOAT fHeight );
    HRESULT SetupFixedPipeline();
    HRESULT SetupVertexShader();

protected:
    HRESULT Initialize();
    HRESULT Render();
    HRESULT FrameMove();

public:
    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Application constructor. Sets attributes for the app.
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    m_bDrawHelp        = FALSE;

    m_dwFogMode        = D3DFOG_LINEAR;
    m_fFogStartValue   = NEAR_PLANE;
    m_fFogEndValue     = FAR_PLANE;
    m_fFogDensity      = 0.0f;

    m_pTerrainVB       = NULL;
    m_pColumnVB        = NULL;
    m_pFloorTexture    = NULL;

    m_dwVertexShader   = TRUE;
    m_bUseVertexShader = FALSE;
}




//----------------------------------------------------------------------------
// Name: GenerateTerrainDisk()
// Desc: Generates a trianglestrip for a disk
//----------------------------------------------------------------------------
HRESULT CXBoxSample::GenerateTerrainDisk( DWORD dwNumSegments, FLOAT fScale )
{
    HRESULT hr;

    m_dwNumTerrainVertices = 2 * dwNumSegments * (dwNumSegments);

    // Create a vertex buffer
    hr = m_pd3dDevice->CreateVertexBuffer( m_dwNumTerrainVertices*sizeof(FOGVERTEX),
                                           D3DUSAGE_WRITEONLY, D3DFVF_FOGVERTEX,
                                           D3DPOOL_DEFAULT, &m_pTerrainVB );
    if( FAILED(hr) )
        return hr;

    FOGVERTEX* pVertices = NULL;
    hr = m_pTerrainVB->Lock( 0, m_dwNumTerrainVertices*sizeof(FOGVERTEX),
                             (BYTE**)&pVertices, 0 );
    if( FAILED(hr) )
        return hr;

    // Generate a spiralized trianglestrip
    for( DWORD ring = 0; ring < dwNumSegments; ring++ )
    {
        for( DWORD seg=0; seg < dwNumSegments; seg++ )
        {
            FLOAT fTheta = (seg*2*D3DX_PI) / dwNumSegments;
            FLOAT r0     = (ring + fTheta/(2*D3DX_PI))*fScale/dwNumSegments;
            FLOAT r1     = r0 + fScale/dwNumSegments;

            FLOAT x   =  sinf( fTheta );
            FLOAT z   =  cosf( fTheta );

            FLOAT y0  =  sinf(r0*z*z+r0*x*x);
            FLOAT nx0 = -cosf(r0*z*z+r0*x*x)*r0*2*x;
            FLOAT ny0 =  1.0f;
            FLOAT nz0 = -cosf(r0*z*z+r0*x*x)*r0*2*z;

            FLOAT y1  =  sinf(r1*z*z+r1*x*x);
            FLOAT nx1 = -cosf(r1*z*z+r1*x*x)*r1*2*x;
            FLOAT ny1 =  1.0f;
            FLOAT nz1 = -cosf(r1*z*z+r1*x*x)*r1*2*z;

            // Add two vertices to the strip at each step
            pVertices->p.x = r0*x;
            pVertices->p.y = y0;
            pVertices->p.z = r0*z;
            pVertices->n.x = nx0;
            pVertices->n.y = ny0;
            pVertices->n.z = nz0;
            pVertices->tu  = (r0*x)/fScale;
            pVertices->tv  = (r0*z)/fScale;
            pVertices++;

            pVertices->p.x = r1*x;
            pVertices->p.y = y1;
            pVertices->p.z = r1*z;
            pVertices->n.x = nx1;
            pVertices->n.y = ny1;
            pVertices->n.z = nz1;
            pVertices->tu  = (r1*x)/fScale;
            pVertices->tv  = (r1*z)/fScale;
            pVertices++;
        }
    }

    m_pTerrainVB->Unlock();

    return S_OK;
}




//----------------------------------------------------------------------------
// Name: GenerateColumn()
// Desc: Generates a trianglestrip for a column
//----------------------------------------------------------------------------
HRESULT CXBoxSample::GenerateColumn( DWORD dwNumSegments, FLOAT fRadius, FLOAT fHeight )
{
    HRESULT hr;

    m_dwNumColumnVertices = 2 * (dwNumSegments+1);

    // Create a vertex buffer
    hr = m_pd3dDevice->CreateVertexBuffer( m_dwNumColumnVertices*sizeof(FOGVERTEX),
                                           D3DUSAGE_WRITEONLY, D3DFVF_FOGVERTEX,
                                           D3DPOOL_DEFAULT, &m_pColumnVB );
    if( FAILED(hr) )
        return hr;

    FOGVERTEX* pVertices = NULL;
    hr = m_pColumnVB->Lock( 0, m_dwNumColumnVertices*sizeof(FOGVERTEX),
                             (BYTE**)(&pVertices), 0 );
    if( FAILED(hr) )
        return hr;

    // Generate a trianglestrip
    for( DWORD seg=0; seg<=dwNumSegments; seg++ )
    {
        FLOAT fTheta = (2*D3DX_PI*seg)/dwNumSegments;
        FLOAT nx     = sinf(fTheta);
        FLOAT nz     = cosf(fTheta);
        FLOAT r      = fRadius;
        FLOAT u      = (1.0f*seg)/dwNumSegments;

        // Add two vertices to the strip at each step
        pVertices->p.x = r*nx;
        pVertices->p.y = fHeight;
        pVertices->p.z = r*nz;
        pVertices->n.x = nx;
        pVertices->n.y = 0;
        pVertices->n.z = nz;
        pVertices->tu  = u;
        pVertices->tv  = 1;
        pVertices++;

        pVertices->p.x = r*nx;
        pVertices->p.y = -1;
        pVertices->p.z = r*nz;
        pVertices->n.x = nx;
        pVertices->n.y = 0;
        pVertices->n.z = nz;
        pVertices->tu  = u;
        pVertices->tv  = 0;
        pVertices++;
    }

    m_pColumnVB->Unlock();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Initialize scene objects.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create the font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the resources
    if( FAILED( m_xprResource.Create( m_pd3dDevice, "Resource.xpr", 
                                      resource_NUM_RESOURCES, g_ResourceNames ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the floor texture
    m_pFloorTexture = m_xprResource.GetTexture( "SeaFloor.bmp" );

    // Generate some geometry for the app
    GenerateTerrainDisk( 80, 100.0f );
    GenerateColumn( 30, 1.0f, 10.0f );

    // Create the vertex shader
    DWORD dwVertexDecl[] =
    {
        D3DVSD_STREAM( 0 ),
        D3DVSD_REG( 0, D3DVSDT_FLOAT3 ), // v0 = Position
        D3DVSD_REG( 2, D3DVSDT_FLOAT3 ), // v2 = Normal
        D3DVSD_REG( 5, D3DVSDT_FLOAT2 ), // v5 = Tex coords
        D3DVSD_END()
    };

    if( FAILED( XBUtil_CreateVertexShader( m_pd3dDevice, "Shaders\\Fog.xvu",
                                           dwVertexDecl, &m_dwVertexShader ) ) )
        return E_FAIL;

    // Set the transform matrices
    D3DXMatrixIdentity( &m_matWorld );
    D3DXMatrixIdentity( &m_matView );
    D3DXMatrixPerspectiveFovLH( &m_matProj, D3DX_PI/4.0f, 4.0f/3.0f, NEAR_PLANE, FAR_PLANE );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK )
        m_bDrawHelp = !m_bDrawHelp;

    // For linear fog, toggle fixed function vs. vertex shader
    if( m_dwFogMode == D3DFOG_LINEAR )
    {
        if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_A] )
            m_bUseVertexShader = !m_bUseVertexShader;
    }

    // Adjust fog parameters
    if( m_dwFogMode == D3DFOG_LINEAR )
    {
        m_fFogStartValue += m_DefaultGamepad.fY1*m_fElapsedTime*100.0f;
        if( m_fFogStartValue < NEAR_PLANE )      m_fFogStartValue = NEAR_PLANE;
        if( m_fFogStartValue > FAR_PLANE )       m_fFogStartValue = FAR_PLANE;
        if( m_fFogStartValue > m_fFogEndValue )  m_fFogStartValue = m_fFogEndValue;

        m_fFogEndValue += m_DefaultGamepad.fY2*m_fElapsedTime*100.0f;
        if( m_fFogEndValue < NEAR_PLANE )        m_fFogEndValue = NEAR_PLANE;
        if( m_fFogEndValue > FAR_PLANE )         m_fFogEndValue = FAR_PLANE;
        if( m_fFogEndValue < m_fFogStartValue )  m_fFogEndValue = m_fFogStartValue;
    }
    else
    {
        m_fFogDensity += m_DefaultGamepad.fY1*m_fElapsedTime*0.1f;
        if( m_fFogDensity < 0.0f ) m_fFogDensity = 0.0f;
        if( m_fFogDensity > 1.0f ) m_fFogDensity = 1.0f;
    }

    if( FALSE == m_bUseVertexShader )
    {
        // Cycle through fog modes
        if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_X] )
        {
            if( m_dwFogMode == D3DFOG_LINEAR )      m_dwFogMode = D3DFOG_EXP;
            else if( m_dwFogMode == D3DFOG_EXP )    m_dwFogMode = D3DFOG_EXP2;
            else if( m_dwFogMode == D3DFOG_EXP2 )   m_dwFogMode = D3DFOG_LINEAR;
        }
    }

    // Move the camera along an ellipse
    D3DXVECTOR3 vFrom( 50*sinf(m_fAppTime/2), 5.0f, 60*cosf(m_fAppTime/2) );
    D3DXVECTOR3 vAt( 50*sinf(m_fAppTime/2+1.5f), 4.0f, 60*cosf(m_fAppTime/2+1.5f) );
    D3DXVECTOR3 vUp( 0.0f, 1.0f, 0.0f );
    D3DXMatrixLookAtLH( &m_matView, &vFrom, &vAt, &vUp );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SetupFixedPipeline()
// Desc: Set fixed pipeline render states for the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::SetupFixedPipeline()
{
    // Set the FVF for the fixed pipeline
    m_pd3dDevice->SetVertexShader( D3DFVF_FOGVERTEX );

    // Set the transform matrices
    m_pd3dDevice->SetTransform( D3DTS_WORLD,      &m_matWorld );
    m_pd3dDevice->SetTransform( D3DTS_VIEW,       &m_matView );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &m_matProj );

    // Set up the light and material
    D3DLIGHT8 light;
    XBUtil_InitLight( light, D3DLIGHT_POINT, 0.0f, 50.0f, 0.0f );
    light.Attenuation0 =  1.0f;
    light.Range        = 200.0f;
    m_pd3dDevice->SetLight( 0, &light );
    m_pd3dDevice->LightEnable( 0, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING,    TRUE );

    D3DMATERIAL8 mtrl;
    XBUtil_InitMaterial( mtrl, 1.0f, 1.0f, 1.0f );
    m_pd3dDevice->SetMaterial( &mtrl );
    m_pd3dDevice->SetRenderState( D3DRS_AMBIENT,  0x44444444 );

    // Set fog parameters.
    m_pd3dDevice->SetRenderState( D3DRS_FOGENABLE,    TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_FOGCOLOR,     FOG_COLOR );
    m_pd3dDevice->SetRenderState( D3DRS_FOGTABLEMODE, m_dwFogMode );
    m_pd3dDevice->SetRenderState( D3DRS_FOGSTART,     FtoDW(m_fFogStartValue) );
    m_pd3dDevice->SetRenderState( D3DRS_FOGEND,       FtoDW(m_fFogEndValue) );
    m_pd3dDevice->SetRenderState( D3DRS_FOGDENSITY,   FtoDW(m_fFogDensity) );
    
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SetupVertexShader()
// Desc: Set vertex shader constants for the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::SetupVertexShader()
{
    // Set the vertex shader
    m_pd3dDevice->SetVertexShader( m_dwVertexShader );

    // Set the transform matrices
    D3DXMATRIX matW, matWV, matWVP;
    D3DXMatrixMultiply( &matWV,  &m_matWorld, &m_matView );
    D3DXMatrixMultiply( &matWVP, &matWV, &m_matProj );
    D3DXMatrixTranspose( &matW,   &m_matWorld ); 
    D3DXMatrixTranspose( &matWV,  &matWV ); 
    D3DXMatrixTranspose( &matWVP, &matWVP );
    m_pd3dDevice->SetVertexShaderConstant( 10, &matW,   4 );
    m_pd3dDevice->SetVertexShaderConstant( 20, &matWV,  4 );
    m_pd3dDevice->SetVertexShaderConstant( 30, &matWVP, 4 );

    // Set constants for the light
    D3DXVECTOR4 vZeroes( 0.0f, 0.0f, 0.0f, 0.0f );
    D3DXVECTOR4 vLight( 0.0f, 50.0f, 0.0f, 0.0f );
    D3DXVECTOR4 vDiffuse( 1.0f, 1.0f, 1.0f, 1.0f );
    D3DXVECTOR4 vAmbient( 0x44/255.0f, 0x44/255.0f, 0x44/255.0f, 1.0f );
    
    // Put the light in object space)
    D3DXMATRIX matInvWorld;
    D3DXMatrixInverse( &matInvWorld, NULL, &m_matWorld );
    D3DXVec3TransformCoord( (D3DXVECTOR3*)&vLight, (D3DXVECTOR3*)&vLight, &matInvWorld );
    
    m_pd3dDevice->SetVertexShaderConstant(  0, &vZeroes,   1 );
    m_pd3dDevice->SetVertexShaderConstant( 40, &vLight,    1 ); // Light position
    m_pd3dDevice->SetVertexShaderConstant( 41, &vDiffuse,  1 ); // Diffuse color
    m_pd3dDevice->SetVertexShaderConstant( 42, &vAmbient,  1 ); // Ambient color

    // Set constants for doing linear fog in the vertex shader
    D3DXVECTOR4 vFog( -1.0f/(m_fFogEndValue-m_fFogStartValue), m_fFogEndValue/(m_fFogEndValue-m_fFogStartValue), 0.0f, 0.0f );
    m_pd3dDevice->SetVertexShaderConstant( 44, &vFog,  1 ); // Fog values

    // Set fog parameters
    m_pd3dDevice->SetRenderState( D3DRS_FOGENABLE,    TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_FOGCOLOR,     FOG_COLOR );
    m_pd3dDevice->SetRenderState( D3DRS_FOGTABLEMODE, D3DFOG_NONE );

    // Note: by setting D3DFOG_NONE above, we are telling the hardware we want
    // complete control over the fog value. In other words, the vertex shader
    // will set oFog.x in a range from 0.0 to 1.0, which will be the final fog
    // value as seen by the pixel shader.
    //
    // We could still set the fog table mode to linear, exp, or exp2, in which
    // case we'd need our vertex shader to set oFog.x in view space coordinates.
    // The hardware will take that value and perform the fog calculations (and
    // table lookup) on it.
    //
    // We chose the D3DFOG_NONE approach for this sample since it shows how 
    // you can have complete custom control with fog via your vertex shader.

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Sets up render states, clears the viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Clear the viewport
    m_pd3dDevice->Clear( 0, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,
                         FOG_COLOR, 1.0f, 0L );

    // Set state
    m_pd3dDevice->SetTexture( 0, NULL );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING,         TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,          TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_DITHERENABLE,     TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SPECULARENABLE,   FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  FALSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_NONE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU,  D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV,  D3DTADDRESS_WRAP );

    // Reset the world matrix
    D3DXMATRIX matWorld;
    D3DXMatrixIdentity( &m_matWorld );

    if( m_bUseVertexShader )
        SetupVertexShader();
    else
        SetupFixedPipeline();

    // Draw the terrain
    m_pd3dDevice->SetTexture( 0, m_pFloorTexture );
    m_pd3dDevice->SetStreamSource( 0, m_pTerrainVB, sizeof(FOGVERTEX) );
    m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP,
                                 0, m_dwNumTerrainVertices-2 );

    // Draw the columns
    for( DWORD i=0; i<20; i++ )
    {
        FLOAT tx = (i%10)*20.0f - 100.0f;
        FLOAT ty =  0.0f;
        FLOAT tz = (i<=10) ? 40.0f : -40.0f;
        D3DXMatrixTranslation( &m_matWorld, tx, ty, tz );

        if( m_bUseVertexShader )
            SetupVertexShader();
        else
            SetupFixedPipeline();

        m_pd3dDevice->SetStreamSource( 0, m_pColumnVB, sizeof(FOGVERTEX) );
        m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP,
                                     0, m_dwNumColumnVertices-2 );
    }

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        m_Font.Begin();
        m_Font.DrawText(  64, 48, 0xffffffff, L"Fog" );
        m_Font.DrawText( 450, 48, 0xffffff00, m_strFrameRate );

        WCHAR strBuffer[80];

        m_Font.DrawText( 64, 75, 0xffffffff, L"Mode:" );
        if( m_bUseVertexShader )
            m_Font.DrawText( 150, 75, 0xffffff00, L"Using vertex shader" );
        else if( m_dwFogMode == D3DFOG_LINEAR )
            m_Font.DrawText( 150, 75, 0xffffff00, L"D3DFOG_LINEAR" );
        else if( m_dwFogMode == D3DFOG_EXP )
            m_Font.DrawText( 150, 75, 0xffffff00, L"D3DFOG_EXP" );
        else if( m_dwFogMode == D3DFOG_EXP2 )
            m_Font.DrawText( 150, 75, 0xffffff00, L"D3DFOG_EXP2" );

        if( TRUE == m_bUseVertexShader || m_dwFogMode == D3DFOG_LINEAR )
        {
            swprintf( strBuffer, L"%0.2f", m_fFogStartValue );
            m_Font.DrawText( 64, 100, 0xffffffff, L"Start:" );
            m_Font.DrawText( 150, 100, 0xffffff00, strBuffer  );

            swprintf( strBuffer, L"%0.2f", m_fFogEndValue );
            m_Font.DrawText( 64, 125, 0xffffffff, L"End:" );
            m_Font.DrawText( 150, 125, 0xffffff00, strBuffer  );
        }
        else
        {
            swprintf( strBuffer, L"%0.3f", m_fFogDensity );
            m_Font.DrawText( 64, 100, 0xffffffff, L"Density:" );
            m_Font.DrawText( 150, 100, 0xffffff00, strBuffer );
        }
        m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\fog\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\fog\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 1UL

#define resource_Seafloor_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\fresnelReflect\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\fresnelReflect\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\fresnelReflect\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\fog\obj\i386\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 1UL

#define resource_Seafloor_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\fresnelReflect\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\fresnelReflect\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\fresnelReflect\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 4UL

#define resource_Scene_OFFSET 0UL
#define resource_Scene1_OFFSET 20UL
#define resource_Earth_OFFSET 40UL
#define resource_Clouds_OFFSET 60UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\fur\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\fresnelReflect\fresnelReflect.cpp ===
//-----------------------------------------------------------------------------
// File: fresnel.cpp
//
// Desc: Demonstrates Fresnel Reflection for more realistic shiny surfaces
//
// Hist: 9.25.01 - Created
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <XGraphics.h>
#include <XObj.h>
#include <XBMesh.h>

#include "Resource.h"
//-----------------------------------------------------------------------------
// ASCII names for the resources used by the app
//-----------------------------------------------------------------------------
XBRESOURCE g_ResourceNames[] = 
{
    { "Scene.bmp",      resource_Scene_OFFSET },
    { "Scene1.bmp",      resource_Scene1_OFFSET },
    { "earthmap2k.bmp", resource_Earth_OFFSET },
    { "cloudcolor.tga", resource_Clouds_OFFSET },
    { NULL, 0 },
};

//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_1, L"Display help" },
    { XBHELP_A_BUTTON,     XBHELP_PLACEMENT_1, L"Switch Object" },
    { XBHELP_LEFTSTICK,    XBHELP_PLACEMENT_1, L"Rotate Object" },
    { XBHELP_RIGHTSTICK,   XBHELP_PLACEMENT_1, L"Zoom/Rotate Light" },
};

#define NUM_HELP_CALLOUTS 4

#define FAR_PLANE  20.0f
#define EARTH_FAR_PLANE 200000.0f
#define NEAR_PLANE 1.0f

#define XBMESH_RENDERSHAPENUM 0xffff0000 // Render ShapeNumber is MSB portion

enum DrawObject
{
	Draw_EnvTeapot,
	Draw_EnvCar,
	Draw_Earth
};




//-----------------------------------------------------------------------------
// Name: class CCarMesh
// Desc: Class to load and render geometry. Most functionality is inherited
//       from the CXBMesh base class.  Override renderMesh so I can change
//       the materials on the pieces of the car.
//-----------------------------------------------------------------------------
class CCarMesh : public CXBMesh
{

public:

    virtual HRESULT RenderMesh( LPDIRECT3DDEVICE8 pd3dDevice, XBMESH_DATA* pMesh, 
                                DWORD dwFlags );

};




//-----------------------------------------------------------------------------
// Name: CCarMesh::RenderMesh()
// Desc: Renders the mesh geometry.
//-----------------------------------------------------------------------------
HRESULT CCarMesh::RenderMesh( LPDIRECT3DDEVICE8 pd3dDevice, XBMESH_DATA* pMesh, 
                             DWORD dwFlags )
{
    D3DVertexBuffer* pVB           = &pMesh->m_VB;
    DWORD            dwNumVertices =  pMesh->m_dwNumVertices;
    D3DIndexBuffer*  pIB           = &pMesh->m_IB;
    DWORD            dwNumIndices  =  pMesh->m_dwNumIndices;
    DWORD            dwFVF         =  pMesh->m_dwFVF;
    DWORD            dwVertexSize  =  pMesh->m_dwVertexSize;
    D3DPRIMITIVETYPE dwPrimType    =  pMesh->m_dwPrimType;
    DWORD            dwNumSubsets  =  pMesh->m_dwNumSubsets;
    XBMESH_SUBSET*   pSubsets      = &pMesh->m_pSubsets[0];

    (VOID)dwNumIndices; // not used

    if( dwNumVertices == 0 )
        return S_OK;

    // Set the vertex stream
    pd3dDevice->SetStreamSource( 0, pVB, dwVertexSize );
    pd3dDevice->SetIndices( pIB, 0 );

    // Set the FVF code, unless the user asked us not to
    if( 0 == ( dwFlags & XBMESH_NOFVF ) )
        pd3dDevice->SetVertexShader( dwFVF );

    // Render the subsets
    DWORD dwStartShape = 0;
    DWORD dwEndShape = 0;

    if (dwFlags & XBMESH_RENDERSHAPENUM)
    {
        dwStartShape = (dwFlags >> 16) - 1;
        dwEndShape = dwStartShape + 1;

        // If they passed us in a bad subset,
        // just start drawing at zero and draw all.
        if (dwStartShape >= dwNumSubsets)
        {
            dwStartShape = 0;
            dwEndShape = dwNumSubsets;
        }
    }

    for( DWORD i = dwStartShape; i < dwEndShape; i++ )
    {
        BOOL bRender = FALSE;

        // Render the opaque subsets, unless the user asked us not to
        if( 0 == ( dwFlags & XBMESH_ALPHAONLY ) )
        {
            if( 0 == ( dwFlags & XBMESH_NOMATERIALS ) )
            {
                if( pSubsets[i].mtrl.Diffuse.a >= 1.0f )
                    bRender = TRUE;
            }
            else
                bRender = TRUE;
        }

        // Render the transparent subsets, unless the user asked us not to
        if( 0 == ( dwFlags & XBMESH_OPAQUEONLY ) )
        {
            if( 0 == ( dwFlags & XBMESH_NOMATERIALS ) )
            {
                if( pSubsets[i].mtrl.Diffuse.a < 1.0f )
                    bRender = TRUE;
            }
        }

        if( bRender )
        {
            // Set the material, unless the user asked us not to
            if( 0 == ( dwFlags & XBMESH_NOMATERIALS ) )
                pd3dDevice->SetMaterial( &pSubsets[i].mtrl );

            // Set the texture, unless the user asked us not to
            if( 0 == ( dwFlags & XBMESH_NOTEXTURES ) )
                pd3dDevice->SetTexture( 0, pSubsets[i].pTexture );

            // Call the callback, so the app can tweak state before rendering
            // each subset
            BOOL bRenderSubset = RenderCallback( pd3dDevice, i, &pSubsets[i], dwFlags );

            // Draw the mesh subset
            if( bRenderSubset )
            {
                DWORD dwNumPrimitives = ( D3DPT_TRIANGLESTRIP == dwPrimType ) ? pSubsets[i].dwIndexCount-2 : pSubsets[i].dwIndexCount/3;
                pd3dDevice->DrawIndexedPrimitive( dwPrimType, 0, pSubsets[i].dwIndexCount,
                                                  pSubsets[i].dwIndexStart, dwNumPrimitives );
            }
        }
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
public:
    CXBoxSample();

    virtual HRESULT Initialize();
    virtual HRESULT Render();
    virtual HRESULT FrameMove();

    // Font and help
    CXBFont     m_Font;
    CXBHelp     m_Help;

    BOOL        m_bDrawHelp;

	CXBPackedResource  m_xprResource;      			// Packed resources for the app

    CXBMesh    		   m_Teapot;					// Test Teapot
    LPDIRECT3DTEXTURE8 m_pSphereMapTexture;			// Texture for Sphere mapping

    CCarMesh           m_Car;						// Test Car

	CXBMesh            m_Earth;						// Test Earth Globe
	LPDIRECT3DTEXTURE8 m_pEarthMapTexture;			// Texture for the earth
	LPDIRECT3DTEXTURE8 m_pEarthCloudTexture;		// Texture for the clouds

    D3DXMATRIX         m_matWorld;					// Transform matrices
    D3DXMATRIX         m_matView;
    D3DXMATRIX         m_matProj;

	D3DXVECTOR3        m_vCameraPosition;			// Camera position and look vector
	D3DXVECTOR3        m_vLookPosition;

	FLOAT              m_fXObjRotate;				// Rotation values for Teapot
	FLOAT              m_fYObjRotate;

	DWORD              m_dwFresnelShader;	            // Handle to the Fresnel Vertex Shader

	DWORD              m_dwEarthShader;					// Handle to the Shader for 
														// the Earth color and cloud layers

	DWORD              m_dwCarShader;					// Handle to the Shader for car's body

	DWORD              m_dwFresnelEarthShader;			// Handle to the Fresnel Shader for 
														// the Earth's atmosphere

	FLOAT              m_fLightRotate;					// Current Rotation of light source

	DrawObject         m_DrawObject;				// Tells me which object to draw.
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample (constructor)
// Desc: Constructor for CXBoxSample class
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample() 
            :CXBApplication()
{
    m_bDrawHelp = FALSE;
}




//-----------------------------------------------------------------------------
// Name: Initialize
// Desc: Peforms initialization
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;    

    // Create the resources
    if( FAILED( m_xprResource.Create( m_pd3dDevice, "Resource.xpr", 
                                      resource_NUM_RESOURCES, g_ResourceNames ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create a mesh (vertex and index buffers) for the teapot
    if( FAILED( m_Teapot.Create( m_pd3dDevice, "Models\\Teapot.xbg" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create a mesh (vertex and index buffers) for the car
    if( FAILED( m_Car.Create( m_pd3dDevice, "Models\\GenericSedan.xbg" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create a mesh (vertex and index buffers) for the earth globe
    if( FAILED( m_Earth.Create( m_pd3dDevice, "Models\\gearth.xbg" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Load the spheremap texture
    m_pSphereMapTexture = m_xprResource.GetTexture( "Scene1.bmp" );

	//Load the Earth's textures
	m_pEarthMapTexture = m_xprResource.GetTexture( "earthmap2k.bmp" );
	m_pEarthCloudTexture = m_xprResource.GetTexture( "cloudcolor.tga" );

    // Set the transform matrices
    D3DXMatrixIdentity( &m_matWorld );
    D3DXMatrixIdentity( &m_matView );
    D3DXMatrixPerspectiveFovLH( &m_matProj, D3DX_PI/4.0f, 4.0f/3.0f, NEAR_PLANE, FAR_PLANE );

	// Setup the camera look and position vectors
	m_vLookPosition.x = 
	m_vLookPosition.y = 
	m_vLookPosition.z = 0.f;

	m_vCameraPosition.x = 5.f;
	m_vCameraPosition.y = m_vCameraPosition.z = 0.f;

	// Set initial rotation of object
	m_fXObjRotate = m_fYObjRotate = m_fLightRotate = 0.f;

	// Set which object to draw
	m_DrawObject = Draw_EnvTeapot;

    // Create vertex shaders
    {
        DWORD dwDecl[] =
        {
            D3DVSD_STREAM( 0 ),
            D3DVSD_REG( 0, D3DVSDT_FLOAT3 ),
            D3DVSD_REG( 1, D3DVSDT_FLOAT3 ),
			D3DVSD_REG( 2, D3DVSDT_FLOAT2 ),
            D3DVSD_END()
        };

        if( FAILED( XBUtil_CreateVertexShader( m_pd3dDevice, "Shaders\\fresnel3.xvu",
                                               dwDecl, &m_dwFresnelShader ) ) )
            return XBAPPERR_MEDIANOTFOUND;

        if( FAILED( XBUtil_CreateVertexShader( m_pd3dDevice, "Shaders\\fresnel4.xvu",
                                               dwDecl, &m_dwFresnelEarthShader ) ) )
            return XBAPPERR_MEDIANOTFOUND;

        if( FAILED( XBUtil_CreateVertexShader( m_pd3dDevice, "Shaders\\planet.xvu",
                                               dwDecl, &m_dwEarthShader ) ) )
            return XBAPPERR_MEDIANOTFOUND;

        if( FAILED( XBUtil_CreateVertexShader( m_pd3dDevice, "Shaders\\car.xvu",
                                               dwDecl, &m_dwCarShader ) ) )
            return XBAPPERR_MEDIANOTFOUND;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove
// Desc: Performs per-frame updates
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK ) 
    {
        m_bDrawHelp = !m_bDrawHelp;
    }

	// Check for buttons pressed 
	if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_A] )
	{
		switch( m_DrawObject )
		{
			case Draw_EnvTeapot:
				m_vCameraPosition.x = m_Car.ComputeRadius() * 3.0f;
				m_DrawObject = Draw_EnvCar;
				break;

			case Draw_EnvCar:
				m_vCameraPosition.x = m_Earth.ComputeRadius() * 3.0f;
				m_DrawObject = Draw_Earth;
				break;

			case Draw_Earth:
				m_vCameraPosition.x = 5.0f;
				m_DrawObject = Draw_EnvTeapot;
				break;
		}
	}

    // Setup the projection matrix
    if (m_DrawObject == Draw_Earth)
        D3DXMatrixPerspectiveFovLH( &m_matProj, D3DX_PI/4.0f, 4.0f/3.0f, NEAR_PLANE, EARTH_FAR_PLANE );
    else
        D3DXMatrixPerspectiveFovLH( &m_matProj, D3DX_PI/4.0f, 4.0f/3.0f, NEAR_PLANE, FAR_PLANE );

	// Setup the view Matrix
	D3DXVECTOR3 vUp( 0.0f, 1.0f, 0.0f );
	D3DXMatrixLookAtLH( &m_matView, &m_vCameraPosition, &m_vLookPosition, &vUp );

	// Check if we should rotate the object
    m_fXObjRotate += m_DefaultGamepad.fX1 * D3DX_PI * m_fElapsedTime;
    m_fYObjRotate += m_DefaultGamepad.fY1 * D3DX_PI * m_fElapsedTime;

	// Check if we should move the camera in or out.
	FLOAT fCameraZoomFactor = ( m_DrawObject == Draw_Earth ) ? 2000.0f : 1.0f;
	m_vCameraPosition.x += m_DefaultGamepad.fY2 * fCameraZoomFactor * m_fElapsedTime;

	// Check if we should rotate the light source.
	m_fLightRotate += m_DefaultGamepad.fX2 * D3DX_PI * m_fElapsedTime;

    // Setup object matrix
    D3DXMATRIX matObjRotate;
    D3DXMatrixRotationYawPitchRoll( &matObjRotate, -m_fXObjRotate, -m_fYObjRotate, 0.0f );
    
    D3DXMatrixIdentity( &m_matWorld );
    D3DXMatrixMultiply( &m_matWorld, &m_matWorld, &matObjRotate );

	// Setup the fresnel rotate matrix
    D3DXMATRIX matFresnelRotate;

	FLOAT fDeterminant = 0.f;
	D3DXMatrixInverse( &matFresnelRotate, &fDeterminant, &matObjRotate );

    // Setup the vertex shader constants
    {
		// Create the World/view/projection matrix concatenation
        D3DXMATRIX mat;
		D3DXMatrixMultiply( &mat, &m_matWorld, &m_matView );
        D3DXMatrixMultiply( &mat, &mat, &m_matProj );
        D3DXMatrixTranspose( &mat, &mat );

		// Rotate the camera normal into the Object's rotational frame.
		// Saves us having to transform all of the vectors on the object in the shader!
		D3DXVECTOR3 vCameraNormal( 1.0f, 0.0f, 0.0f );
		D3DXVECTOR3 vRotatedNormal;
		D3DXVec3TransformNormal( &vRotatedNormal, &vCameraNormal, &matFresnelRotate );

		// Setup constants
		D3DXVECTOR4 vForceColor( 0.45f, 0.45f, 0.45f, 1.0f );
		D3DXVECTOR4 vConstants( 1.0f, 0.5f, 3.0f, 0.15f );
		D3DXVECTOR4 vConstants1( 1.0f, 0.0f, 0.0f, 0.0f );

        m_pd3dDevice->SetVertexShaderConstant( 0, &mat, 4 );
        m_pd3dDevice->SetVertexShaderConstant( 4, &vRotatedNormal, 1 );
        m_pd3dDevice->SetVertexShaderConstant( 5, &vForceColor, 1 );
        m_pd3dDevice->SetVertexShaderConstant( 6, &vConstants, 1 );
        m_pd3dDevice->SetVertexShaderConstant( 7, &vConstants1, 1 );

		// Generate spheremap texture coords from the position
		D3DXMATRIX matTexture;
		D3DXMatrixIdentity( &matTexture );
		matTexture._11 = 0.5f; matTexture._12 = 0.0f;
		matTexture._21 = 0.0f; matTexture._22 =-0.5f;
		matTexture._14 = 0.5f; matTexture._24 = 0.5f;

		D3DXMatrixMultiply( &matTexture, &matTexture, &mat );
		m_pd3dDevice->SetVertexShaderConstant( 15, &matTexture, 4 );
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render
// Desc: Renders the scene
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Clear the zbuffer
    if ( m_DrawObject == Draw_Earth)
        m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL|D3DCLEAR_TARGET,
                             0x00000000, 1.0f, 0L );
    else
        m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL|D3DCLEAR_TARGET,
                             0xff404040, 1.0f, 0L );

    // Setup render state
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_MINFILTER, D3DTEXF_LINEAR );

	m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE );

	m_pd3dDevice->SetRenderState( D3DRS_LIGHTING, FALSE );
	m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
	m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA );
	m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_ONE );

	m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_CCW );
	m_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE, FALSE );
	m_pd3dDevice->SetRenderState( D3DRS_DITHERENABLE, TRUE );

    // Draw a gradient filled background
	if( m_DrawObject == Draw_EnvTeapot )
    {
        m_pd3dDevice->SetVertexShader( NULL );
        RenderGradientBackground( 0xff404040, 0xff4040C0 );
    }

    // Draw the Object desired
	switch( m_DrawObject )
	{
		case Draw_EnvTeapot:
		{
			m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );

			// Set new constants for this object.
			D3DXVECTOR4 vForceColor( 0.55f, 0.55f, 0.55f, 1.0f );

			// Set the vertex Shader
			m_pd3dDevice->SetVertexShader( m_dwFresnelShader );

			// Adds in the teapot's sphere map
			m_pd3dDevice->SetTexture( 0, m_pSphereMapTexture );
			m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
			m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
			m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
	
			m_Teapot.Render( m_pd3dDevice, XBMESH_NOTEXTURES | XBMESH_NOFVF );
		}
		break;

		case Draw_EnvCar:
		{
			// Set render state changes for the car
			m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA );
			m_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE, TRUE );
            m_pd3dDevice->SetRenderState( D3DRS_ZFUNC, D3DCMP_LESSEQUAL );
	
			// Set new constants for the additional work.
			{
				m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
	
				D3DXMATRIX matLightRotate;
				D3DXMatrixRotationY( &matLightRotate, m_fLightRotate );
	
				D3DXVECTOR4 vForceColor( 0.0f, 0.23f, 0.70f, 1.0f );
				D3DXVECTOR3 vLightDirection( 1.0f, 0.0f, 0.0f );
				D3DXVECTOR4 vAmbientLight( 0.0f, 0.23f, 0.70f, 1.0f );
	
				D3DXVec3TransformNormal( &vLightDirection, &vLightDirection, &matLightRotate );
	
				m_pd3dDevice->SetVertexShaderConstant( 5, &vForceColor, 1 );
				m_pd3dDevice->SetVertexShaderConstant( 8, &vLightDirection, 1 );
				m_pd3dDevice->SetVertexShaderConstant( 9, &vAmbientLight, 1 );
			}
	
			// Set the vertex Shader
			m_pd3dDevice->SetVertexShader( m_dwCarShader );
	
			// Adds in the car's color map
			m_pd3dDevice->SetTexture( 0, 0 );

            // Draw the roof and sides of car
            m_Car.RenderMesh( m_pd3dDevice, m_Car.GetMesh(0),
                              XBMESH_NOTEXTURES | XBMESH_NOMATERIALS | XBMESH_NOFVF | (1<<16) );
	
            // Draw the underside of the car - Much darker color
			{
				D3DXVECTOR4 vForceColor( 0.0f, 0.03f, 0.15f, 1.0f );
				D3DXVECTOR4 vAmbientLight( 0.0f, 0.0f, 0.05f, 1.0f );
	
				m_pd3dDevice->SetVertexShaderConstant( 5, &vForceColor, 1 );
				m_pd3dDevice->SetVertexShaderConstant( 9, &vAmbientLight, 1 );
			}

            m_Car.RenderMesh( m_pd3dDevice, m_Car.GetMesh(0),
                              XBMESH_NOTEXTURES | XBMESH_NOMATERIALS | XBMESH_NOFVF | (2<<16) );

            // Draw the Window seals of the car - Black.  No reflection
			{
				D3DXVECTOR4 vForceColor( 0.0f, 0.0f, 0.0f, 0.0f );
				D3DXVECTOR4 vAmbientLight( 0.0f, 0.0f, 0.0f, 1.0f );
	
				m_pd3dDevice->SetVertexShaderConstant( 5, &vForceColor, 1 );
				m_pd3dDevice->SetVertexShaderConstant( 9, &vAmbientLight, 1 );
			}

            m_Car.RenderMesh( m_pd3dDevice, m_Car.GetMesh(0),
                              XBMESH_NOTEXTURES | XBMESH_NOMATERIALS | XBMESH_NOFVF | (5<<16) );

            m_Car.RenderMesh( m_pd3dDevice, m_Car.GetMesh(0),
                              XBMESH_NOTEXTURES | XBMESH_NOMATERIALS | XBMESH_NOFVF | (6<<16) );

			m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
	
			// Set new constants for this object and the "shiny" pass.
			{
				D3DXVECTOR4 vConstants( 1.0f, 0.5f, 1.5f, 0.15f );
				D3DXVECTOR4 vConstants1( 0.75f, 0.0f, 0.0f, 0.0f );
		
				D3DXVECTOR4 vForceColor( 0.55f, 0.55f, 0.55f, 1.0f );
				m_pd3dDevice->SetVertexShaderConstant( 5, &vForceColor, 1 );
				m_pd3dDevice->SetVertexShaderConstant( 6, &vConstants, 1 );
				m_pd3dDevice->SetVertexShaderConstant( 7, &vConstants1, 1 );
			}
	
			// Set the vertex Shader
			m_pd3dDevice->SetVertexShader( m_dwFresnelShader );
	
			// Adds in the car's sphere map
			m_pd3dDevice->SetTexture( 0, m_pSphereMapTexture );
			m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
			m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
			m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
	
            // Draw the roof and sides of car - Quite Shiny
            m_Car.RenderMesh( m_pd3dDevice, m_Car.GetMesh(0),
                              XBMESH_NOTEXTURES | XBMESH_NOMATERIALS | XBMESH_NOFVF | (1<<16) );
	
            // Draw the underside of the car - MUCH less shiny
			{
				D3DXVECTOR4 vConstants( 1.0f, 0.5f, 1.5f, 0.05f );
				D3DXVECTOR4 vConstants1( 0.15f, 0.0f, 0.0f, 0.0f );
		
				D3DXVECTOR4 vForceColor( 0.55f, 0.55f, 0.55f, 1.0f );
				m_pd3dDevice->SetVertexShaderConstant( 5, &vForceColor, 1 );
				m_pd3dDevice->SetVertexShaderConstant( 6, &vConstants, 1 );
				m_pd3dDevice->SetVertexShaderConstant( 7, &vConstants1, 1 );
			}
            m_Car.RenderMesh( m_pd3dDevice, m_Car.GetMesh(0),
                              XBMESH_NOTEXTURES | XBMESH_NOMATERIALS | XBMESH_NOFVF | (2<<16) );

            // Draw the Windows and mirrors of the car - Not drawn above so transparent
			{
				D3DXVECTOR4 vConstants( 1.0f, 0.5f, 1.5f, 0.15f );
				D3DXVECTOR4 vConstants1( 0.75f, 0.0f, 0.0f, 0.0f );
		
				D3DXVECTOR4 vForceColor( 0.75f, 0.75f, 0.75f, 1.0f );
				m_pd3dDevice->SetVertexShaderConstant( 5, &vForceColor, 1 );
				m_pd3dDevice->SetVertexShaderConstant( 6, &vConstants, 1 );
				m_pd3dDevice->SetVertexShaderConstant( 7, &vConstants1, 1 );
			}
            m_Car.RenderMesh( m_pd3dDevice, m_Car.GetMesh(0),
                              XBMESH_NOTEXTURES | XBMESH_NOMATERIALS | XBMESH_NOFVF | (3<<16) );
	
  			m_Car.RenderMesh( m_pd3dDevice, m_Car.GetMesh(0),
                              XBMESH_NOTEXTURES | XBMESH_NOMATERIALS | XBMESH_NOFVF | (4<<16) );
		}
		break;
	
		case Draw_Earth:
		{
			// Set render state changes for earth
			m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA );

			// Set new constants for the additional work.
			{
				D3DXMATRIX matLightRotate;
			    D3DXMatrixRotationY( &matLightRotate, m_fLightRotate );

 				D3DXVECTOR4 vForceColor( 0.6f, 0.6f, 0.6f, 1.0f );
				D3DXVECTOR3 vLightDirection( 1.5f, 0.0f, 0.0f );
				D3DXVECTOR4 vAmbientLight( 0.15f, 0.15f, 0.15f, 1.0f );

				D3DXVec3TransformNormal( &vLightDirection, &vLightDirection, &matLightRotate );

				m_pd3dDevice->SetVertexShaderConstant( 5, &vForceColor, 1 );
				m_pd3dDevice->SetVertexShaderConstant( 8, &vLightDirection, 1 );
				m_pd3dDevice->SetVertexShaderConstant( 9, &vAmbientLight, 1 );
			}

			// Set the vertex Shader
			m_pd3dDevice->SetVertexShader( m_dwEarthShader );

			// Adds in the earth's color map
			m_pd3dDevice->SetTexture( 0, m_pEarthMapTexture );
			m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
			m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
			m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
			m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1 );
			m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
			m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );
		    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU,  D3DTADDRESS_WRAP );
		    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV,  D3DTADDRESS_WRAP );
	
			m_Earth.Render( m_pd3dDevice, XBMESH_NOTEXTURES | XBMESH_NOMATERIALS | XBMESH_NOFVF );

			// Add in the earth's cloud map
			m_pd3dDevice->SetTexture( 0, m_pEarthCloudTexture );
			m_Earth.Render( m_pd3dDevice, XBMESH_NOTEXTURES | XBMESH_NOMATERIALS | XBMESH_NOFVF );

			// Add in the Fresnel Transparency layer
			m_pd3dDevice->SetTexture( 0, 0 );

			// Setup the constants for this shader
			{
				D3DXVECTOR4 vForceColor( 0.15f, 0.45f, 0.75f, 1.0f);
				D3DXVECTOR4 vConstants( 1.0f, 0.5f, 1.2f, 0.15f);
				D3DXVECTOR4 vConstants1( 0.75f, 0.0f, 0.0f, 0.0f);

		        m_pd3dDevice->SetVertexShaderConstant( 5, &vForceColor, 1 );
			    m_pd3dDevice->SetVertexShaderConstant( 6, &vConstants, 1 );
				m_pd3dDevice->SetVertexShaderConstant( 7, &vConstants1, 1 );
			}

			// Set the vertex Shader
			m_pd3dDevice->SetVertexShader( m_dwFresnelEarthShader );
			m_Earth.Render( m_pd3dDevice, XBMESH_NOTEXTURES | XBMESH_NOMATERIALS | XBMESH_NOFVF );
		}
		break;
	}

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        m_Font.Begin();

		if( m_DrawObject != Draw_Earth )
		{
   			m_Font.DrawText( 64, 50, 0xffffffff, L"Fresnel Reflectivity" );
			m_Font.DrawText( 64, 70, 0xffffffff, L"Using Shader Fresnel3" );

			m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );
		}
		else
		{
			m_Font.DrawText( 64, 50, 0xffffffff, L"Fresnel Transparency" );
			m_Font.DrawText( 64, 70, 0xffffffff, L"Using Shader Fresnel4" );
			m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );
		}
        m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\fur\Clip.h ===
//-----------------------------------------------------------------------------
//  Blinn clipping.
//
//  Note that clipping range is assumed to be 0 to 1 in X, Y, and Z,
//  so the standard D3D clipping coords must be scaled and offset in
//  X and Y by 0.5, as done by BlinnClipMatrix().
//
//  See Jim Blinn's "A Trip Down the Graphics Pipeline", pp. 119-134.
//
//  Copyright (C) 2001 Microsoft Corporation
//  All rights reserved.
//-----------------------------------------------------------------------------

//////////////////////////////////////////////////////////////////////
// Convert D3D world.view.projection matrix to Blinn-style clip matrix.
//    D3D's clip volume is [-1,1] in X and Y, and [0,1] in Z.
//    Blinn's clip volume is [0,1] in X, Y, and Z.
//
inline D3DXMATRIX *BlinnClipMatrix(D3DXMATRIX *pmatBlinnClip, const D3DXMATRIX *pmatD3DClip)
{
	D3DXMATRIX matClipScale;
	D3DXMatrixScaling(&matClipScale, 0.5f, 0.5f, 1.f);
	D3DXMATRIX matClipOffset;
	D3DXMatrixTranslation(&matClipOffset, 0.5f, 0.5f, 0.f);
	*pmatBlinnClip = *pmatD3DClip * matClipScale * matClipOffset;
	return pmatBlinnClip;
}

//////////////////////////////////////////////////////////////////////
// Move float sign bit into bit 0 of the returned DWORD
//
inline DWORD FloatSignBit(float f)
{
	return *(DWORD *)&f >> 31;
}

//////////////////////////////////////////////////////////////////////
// Blinn boundary codes packed into a DWORD
//
inline DWORD BlinnBoundaryCode(const float *p)
{
	return FloatSignBit(p[0])				// X == 0
		| (FloatSignBit(p[3] - p[0]) << 1)	// X == 1
		| (FloatSignBit(p[1])        << 2)	// Y == 0
		| (FloatSignBit(p[3] - p[1]) << 3)	// Y == 1
		| (FloatSignBit(p[2])        << 4)	// Z == 0
		| (FloatSignBit(p[3] - p[2]) << 5); // Z == 1
}

//////////////////////////////////////////////////////////////////////
// Checks to see if points in [0,1] clip coordinates touch the clip frustum.
//
inline bool BoundingPointsInFrustum(UINT nPoint,				// number of points to test
									const D3DXVECTOR4 *rvPoint)	// array of bounding points in [0,1] clip coords
{
	DWORD Ocumulate = 0;
	DWORD Acumulate = (DWORD)-1;
	for (UINT i = 0; i < nPoint; i++)	// 8 points on bounding volume
	{
		DWORD BC = BlinnBoundaryCode(rvPoint[i]);
		Ocumulate |= BC;
		Acumulate &= BC;
	}
	if (Acumulate != 0)
		return false;	// all points are outside of frustum
	if (Ocumulate == 0)
		return true;	// all points are inside of frustum
	// TODO: Now a more elaborate test is needed, since the bounding box is
	// straddling a clip plane. Currently, this returns false positives.
	return true;
}

//////////////////////////////////////////////////////////////////////
// Culling helper. Checks to see if bounding box touches the clip frustum.
//    The matClip transformaion takes world coords to [0,1] clip range in X, Y, and Z.
//
inline bool BoundingBoxInFrustum(const D3DXMATRIX &matClip,  // current world/view/proj/clip matrix
								 const D3DXVECTOR3 &vMin, // bounding box
								 const D3DXVECTOR3 &vMax)
{
	float rv[8][3] = {
		vMin.x, vMin.y, vMin.z,
		vMin.x, vMin.y, vMax.z,
		vMin.x, vMax.y, vMin.z,
		vMin.x, vMax.y, vMax.z,
		vMax.x, vMin.y, vMin.z,
		vMax.x, vMin.y, vMax.z,
		vMax.x, vMax.y, vMin.z,
		vMax.x, vMax.y, vMax.z
	};
	D3DXVECTOR4 rvClip[8];
	for (UINT i = 0; i < 8; i++)
		D3DXVec3Transform(&rvClip[i], (D3DXVECTOR3 *)&rv[i], &matClip);
	return BoundingPointsInFrustum(8, rvClip);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\fresnelReflect\obj\i386\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 4UL

#define resource_Scene_OFFSET 0UL
#define resource_Scene1_OFFSET 20UL
#define resource_Earth_OFFSET 40UL
#define resource_Clouds_OFFSET 60UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\fur\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\fur\furfade2.inl ===
// Xbox Shader Assembler 1.00.4355.1
D3DPIXELSHADERDEF psd;
ZeroMemory(&psd, sizeof(psd));
psd.PSCombinerCount=PS_COMBINERCOUNT(
    3,
    PS_COMBINERCOUNT_MUX_MSB | PS_COMBINERCOUNT_UNIQUE_C0 | PS_COMBINERCOUNT_UNIQUE_C1);
psd.PSTextureModes=PS_TEXTUREMODES(
    PS_TEXTUREMODES_PROJECT2D,
    PS_TEXTUREMODES_PROJECT2D,
    PS_TEXTUREMODES_NONE,
    PS_TEXTUREMODES_NONE);
psd.PSInputTexture=PS_INPUTTEXTURE(0,0,0,0);
psd.PSDotMapping=PS_DOTMAPPING(
    0,
    PS_DOTMAPPING_ZERO_TO_ONE,
    PS_DOTMAPPING_ZERO_TO_ONE,
    PS_DOTMAPPING_ZERO_TO_ONE);
psd.PSCompareMode=PS_COMPAREMODE(
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT);

//------------- Stage 0 -------------
psd.PSRGBInputs[0]=PS_COMBINERINPUTS(
    PS_REGISTER_V0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_T1 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
psd.PSAlphaInputs[0]=PS_COMBINERINPUTS(
    PS_REGISTER_V0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_T1 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
psd.PSRGBOutputs[0]=PS_COMBINEROUTPUTS(
    PS_REGISTER_R0,
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_COMBINEROUTPUT_SHIFTLEFT_1 | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[0]=PS_COMBINEROUTPUTS(
    PS_REGISTER_R0,
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[0] = 0x00000000;
psd.PSConstant1[0] = 0x00000000;

//------------- Stage 1 -------------
psd.PSRGBInputs[1]=PS_COMBINERINPUTS(
    PS_REGISTER_C0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_T0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
psd.PSAlphaInputs[1]=PS_COMBINERINPUTS(
    PS_REGISTER_C0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_T0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
psd.PSRGBOutputs[1]=PS_COMBINEROUTPUTS(
    PS_REGISTER_R1,
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[1]=PS_COMBINEROUTPUTS(
    PS_REGISTER_R1,
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[1] = 0x00000000;
psd.PSConstant1[1] = 0x00000000;

//------------- Stage 2 -------------
psd.PSRGBInputs[2]=PS_COMBINERINPUTS(
    PS_REGISTER_R1 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_R0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
psd.PSAlphaInputs[2]=PS_COMBINERINPUTS(
    PS_REGISTER_R1 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_R0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
psd.PSRGBOutputs[2]=PS_COMBINEROUTPUTS(
    PS_REGISTER_R0,
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_COMBINEROUTPUT_SHIFTLEFT_1 | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[2]=PS_COMBINEROUTPUTS(
    PS_REGISTER_R0,
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[2] = 0x00000000;
psd.PSConstant1[2] = 0x00000000;

psd.PSC0Mapping = 0xffffff0f;
psd.PSC1Mapping = 0xffffffff;
psd.PSFinalCombinerConstants = 0x000001ff;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\fur\furfade0.inl ===
// Xbox Shader Assembler 1.00.4355.1
D3DPIXELSHADERDEF psd;
ZeroMemory(&psd, sizeof(psd));
psd.PSCombinerCount=PS_COMBINERCOUNT(
    2,
    PS_COMBINERCOUNT_MUX_MSB | PS_COMBINERCOUNT_UNIQUE_C0 | PS_COMBINERCOUNT_UNIQUE_C1);
psd.PSTextureModes=PS_TEXTUREMODES(
    PS_TEXTUREMODES_PROJECT2D,
    PS_TEXTUREMODES_PROJECT2D,
    PS_TEXTUREMODES_NONE,
    PS_TEXTUREMODES_NONE);
psd.PSInputTexture=PS_INPUTTEXTURE(0,0,0,0);
psd.PSDotMapping=PS_DOTMAPPING(
    0,
    PS_DOTMAPPING_ZERO_TO_ONE,
    PS_DOTMAPPING_ZERO_TO_ONE,
    PS_DOTMAPPING_ZERO_TO_ONE);
psd.PSCompareMode=PS_COMPAREMODE(
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT);

//------------- Stage 0 -------------
psd.PSRGBInputs[0]=PS_COMBINERINPUTS(
    PS_REGISTER_V0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_T1 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
psd.PSAlphaInputs[0]=PS_COMBINERINPUTS(
    PS_REGISTER_V0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_T1 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
psd.PSRGBOutputs[0]=PS_COMBINEROUTPUTS(
    PS_REGISTER_R1,
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_COMBINEROUTPUT_SHIFTLEFT_1 | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[0]=PS_COMBINEROUTPUTS(
    PS_REGISTER_R1,
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[0] = 0x00000000;
psd.PSConstant1[0] = 0x00000000;

//------------- Stage 1 -------------
psd.PSRGBInputs[1]=PS_COMBINERINPUTS(
    PS_REGISTER_R1 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_T0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
psd.PSAlphaInputs[1]=PS_COMBINERINPUTS(
    PS_REGISTER_R1 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_T0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
psd.PSRGBOutputs[1]=PS_COMBINEROUTPUTS(
    PS_REGISTER_R0,
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_COMBINEROUTPUT_SHIFTLEFT_1 | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[1]=PS_COMBINEROUTPUTS(
    PS_REGISTER_R0,
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[1] = 0x00000000;
psd.PSConstant1[1] = 0x00000000;

psd.PSC0Mapping = 0xffffffff;
psd.PSC1Mapping = 0xffffffff;
psd.PSFinalCombinerConstants = 0x000001ff;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\fur\comp2.inl ===
// Xbox Shader Assembler 1.00.4355.1
D3DPIXELSHADERDEF psd;
ZeroMemory(&psd, sizeof(psd));
psd.PSCombinerCount=PS_COMBINERCOUNT(
    1,
    PS_COMBINERCOUNT_MUX_MSB | PS_COMBINERCOUNT_UNIQUE_C0 | PS_COMBINERCOUNT_UNIQUE_C1);
psd.PSTextureModes=PS_TEXTUREMODES(
    PS_TEXTUREMODES_PROJECT2D,
    PS_TEXTUREMODES_PROJECT2D,
    PS_TEXTUREMODES_NONE,
    PS_TEXTUREMODES_NONE);
psd.PSInputTexture=PS_INPUTTEXTURE(0,0,0,0);
psd.PSDotMapping=PS_DOTMAPPING(
    0,
    PS_DOTMAPPING_ZERO_TO_ONE,
    PS_DOTMAPPING_ZERO_TO_ONE,
    PS_DOTMAPPING_ZERO_TO_ONE);
psd.PSCompareMode=PS_COMPAREMODE(
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT);

//------------- Stage 0 -------------
psd.PSRGBInputs[0]=PS_COMBINERINPUTS(
    PS_REGISTER_T1 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_T0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_T1 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSAlphaInputs[0]=PS_COMBINERINPUTS(
    PS_REGISTER_T1 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_T0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_T1 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSRGBOutputs[0]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[0]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[0] = 0x00000000;
psd.PSConstant1[0] = 0x00000000;

psd.PSC0Mapping = 0xffffffff;
psd.PSC1Mapping = 0xffffffff;
psd.PSFinalCombinerConstants = 0x000001ff;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\fur\Fur.cpp ===
//-----------------------------------------------------------------------------
// File: Fur.cpp
//
// Desc: This is the main file for the fur demo, which shows how to draw fur
//       using vertex shaders (for shell expansion, lighting, and wind) and
//       pixel shaders (for combining slice textures with a hair lighting
//       texture and for fading-in level-of-detail layers.)
//
// Copyright (c) 2000-2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBUtil.h>
#include <XBHelp.h>
#include <wchar.h>
#include "Clip.h"
#include "XBFur.h"
#include "XBFurMesh.h"
#include "xobj.h"
#include "xpath.h"
#include "util.h"

// help screen definitions
XBHELP_CALLOUT g_NormalHelpCallouts[] =
{
    { XBHELP_LEFTSTICK,    XBHELP_PLACEMENT_1, L"Rotate/Zoom the model"},
    { XBHELP_RIGHTSTICK,   XBHELP_PLACEMENT_2, L"Rotate the model\nand light source"},
    { XBHELP_DPAD,         XBHELP_PLACEMENT_1, L"Model Count" },
    { XBHELP_MISC_CALLOUT, XBHELP_PLACEMENT_1, L"Right trigger to use blower" },
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_1, L"Toggle help" },
};
#define MAX_NORMAL_HELP_CALLOUTS (sizeof(g_NormalHelpCallouts)/sizeof(XBHELP_CALLOUT))

bool  g_bDrawFins = true;
bool  g_bDrawShells = true;

bool  g_bWind = false;
bool  g_bLocalLighting = false;
bool  g_bSelfShadow = false;

DWORD g_dwNumShellsDrawn;

D3DXVECTOR4 g_vWind1;   // wind origin
D3DXVECTOR4 g_vWind2;   // wind up vector
D3DXVECTOR4 g_vWind3;   // wind left vector
float g_fWindChoose;    // wind smooth start / stop

D3DXVECTOR3 g_LightPos;                 // current light position
D3DXVECTOR3 g_EyePos;                   // current eye position
D3DXVECTOR3 g_vLookAt;

//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBFont m_Font;
    CXBHelp m_Help;
    BOOL m_bDrawHelp;
    D3DVECTOR m_vViewAngle;
    D3DXVECTOR3 m_vCameraPos;       // camera rest position
    D3DXVECTOR3 m_vEyePos;          // eye position
    D3DXMATRIX m_matProjection;     // projection matrix
    D3DXMATRIX m_matView;           // view matrix
    D3DXVECTOR3 m_vLightPos;
    D3DLIGHT8 m_Light0;             // d3d8 light
    FLOAT m_fLightAngle;
    CXObject m_LightObj;            // light icon
#define TEDDYCOUNT 3
    struct Teddy {                  // the teddy model comes in several levels of geometric detail
        D3DXVECTOR3 m_vMin, m_vMax; // bounding box
        CXBMesh m_Mesh;             // skin base mesh, plus eyes and nose
        CXBFurMesh m_FurMesh;       // base mesh for fur + "fins" to get better silhouettes
    } m_rTeddy[TEDDYCOUNT];
    CXBFur m_Fur;                   // fur texture
    DWORD m_dwLoadPhase;            // keeps track of current loading stage
    FLOAT m_fLevelOfDetail;         // scale factor for level of detail calculation
    INT m_iNumInstances;
#define NMAXINSTANCE 1000
    struct Instance {
        D3DXVECTOR3 vPosition;      // position of instance
        FLOAT fLevelOfDetail;       // level-of-detail value for this object
        UINT iModel;                // which model to use for this object
        D3DXMATRIX matWorld;        // world matrix for instance
    } m_rInstance[NMAXINSTANCE];    // model instances, sorted by distance from eye
    INT m_iNumActiveInstances;
    struct ActiveInstance {
        FLOAT fDist2;       // squared distance from eye. This field must be first for qsort to work.
        INT iInstance;      // index of instance
    } m_rActiveInstance[NMAXINSTANCE];
    INT m_iNumSlices;       // number of slices for the fur texture
    UINT m_iTextureIndex;   // most recently compressed texture index
    
#define VERTEXSHADER_CONFIGURATIONS 8    /* three bits: wind local_lighting self_shadowing */
    DWORD m_rdwFurVS[VERTEXSHADER_CONFIGURATIONS];
    DWORD m_rdwFinVS[VERTEXSHADER_CONFIGURATIONS];

#define PIXELSHADER_CONFIGURATIONS 3    /* 0=texture + hairlighting,  1=blend LOD texture + hairlighting, 2=fade texture + lighting */
    DWORD m_rdwFurPS[PIXELSHADER_CONFIGURATIONS];
    
public:
    HRESULT Initialize();
    HRESULT FrameMove();
    HRESULT Render();
    HRESULT Cleanup();

    CXBoxSample();
    HRESULT DrawLightIcon();
    HRESULT LoadModels();			// load geometric models
    HRESULT ExtractFins();			// group mesh edges of original model according to view direction
	HRESULT CreateHairTextures();	// slice particle system hair into textures
    HRESULT UpdateInstances();
} g_xbApp;

//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program. Initializes everything, and goes into a
//       message-processing loop. Idle time is used to render the scene.
//-----------------------------------------------------------------------------
void __cdecl main()
{
    if( FAILED( g_xbApp.Create() ) )
        return;
    g_xbApp.Run();
}

//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
#ifdef _DEBUG
    // Allow unlimited frame rate
    m_d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;
#endif
    m_bDrawHelp = FALSE;
    m_dwLoadPhase = 0;
    m_fLevelOfDetail = 0.045f;
    m_iNumInstances = 25;   // start with a bunch of teddy bears
    m_iNumSlices = 8;   // Increase this number to get finer detail along the length of the fur
    for (UINT iConfig = 0; iConfig < VERTEXSHADER_CONFIGURATIONS; iConfig++)
    {
        m_rdwFurVS[iConfig] = 0;
        m_rdwFinVS[iConfig] = 0;
    }
}

//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Initialize device-dependant objects.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    HRESULT hr;

    // Create a font
    if( FAILED( hr = m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // initialize the help system
    m_Help.Create( m_pd3dDevice, "Gamepad.xpr" );

    // Set projection transform
    float fFOV = D3DX_PI/4;
    D3DXMatrixPerspectiveFovLH(&m_matProjection, fFOV, 640.0f/480.0f, 0.4f, 40.0f);
    m_pd3dDevice->SetTransform(D3DTS_PROJECTION, &m_matProjection);

    // load the fur and fin vertex shaders
    for (UINT iConfig = 0; iConfig < VERTEXSHADER_CONFIGURATIONS; iConfig++)
    {
        int iWind = (iConfig >> 2) & 1;
        int iLocal = (iConfig >> 1) & 1;
        int iSelf = iConfig & 1;
        
        // load the fur vertex shader
        {
            DWORD vsdecl[] = 
            {
                D3DVSD_STREAM(0),
                D3DVSD_REG(0, D3DVSDT_FLOAT3),      // vertex
                D3DVSD_REG(1, D3DVSDT_FLOAT3),      // normal / hair tangent
                D3DVSD_REG(2, D3DVSDT_FLOAT2),      // texture 0
                D3DVSD_END()
            };
            CHAR name[_MAX_PATH];
            _snprintf(name, _MAX_PATH, "Shaders\\fur_wind%d_local%d_self%d.xvu", iWind, iLocal, iSelf);
			name[_MAX_PATH - 1] = '\0';
            XBUtil_CreateVertexShader(m_pd3dDevice, _FNA(name), vsdecl, &m_rdwFurVS[iConfig]);
            if (!m_rdwFurVS[iConfig])
            {
                OUTPUT_DEBUG_STRING("Initialize : error loading \"");
                OUTPUT_DEBUG_STRING(name);
                OUTPUT_DEBUG_STRING("\"\n");
            }
        }
        
        // load the fin vertex shader
        {
            DWORD vsdecl[] = 
            {
                D3DVSD_STREAM(0),
                D3DVSD_REG(0, D3DVSDT_FLOAT3),      // vertex
                D3DVSD_REG(1, D3DVSDT_FLOAT3),      // normal / hair tangent
                D3DVSD_REG(2, D3DVSDT_FLOAT2),      // u,v
                D3DVSD_REG(6, D3DVSDT_FLOAT3),      // fin face normal
                D3DVSD_END()
            };
            CHAR name[_MAX_PATH];
            _snprintf(name, _MAX_PATH, "Shaders\\fin_wind%d_local%d_self%d.xvu", iWind, iLocal, iSelf);
			name[_MAX_PATH - 1] = '\0';
            XBUtil_CreateVertexShader(m_pd3dDevice, _FNA(name), vsdecl, &m_rdwFinVS[iConfig]);
            if (!m_rdwFinVS[iConfig])
            {
                OUTPUT_DEBUG_STRING("Initialize : error loading \"");
                OUTPUT_DEBUG_STRING(name);
                OUTPUT_DEBUG_STRING("\"\n");
            }
        }
    }

    // create the fur pixel shaders
#pragma warning(push)
#pragma warning(disable: 4245)	// conversion from int to DWORD
    {
#include "furfade0.inl"
        g_pd3dDevice->CreatePixelShader(&psd, &m_rdwFurPS[0]);
    }
    {
#include "furfade1.inl"
        g_pd3dDevice->CreatePixelShader(&psd, &m_rdwFurPS[1]);
    }
    {
#include "furfade2.inl"
        g_pd3dDevice->CreatePixelShader(&psd, &m_rdwFurPS[2]);
    }
#pragma warning(pop)

    // enable lighting
    m_pd3dDevice->SetRenderState(D3DRS_AMBIENT, 0x0);
    m_pd3dDevice->SetRenderState(D3DRS_LIGHTING, TRUE);

    // init the rest of the stuff
    float fRadius = 1.f;
    m_vCameraPos = D3DXVECTOR3(0.f, fRadius * 0.3f, fRadius * 2.f);
    m_vLightPos = D3DXVECTOR3(0.f, 0.7f + fRadius * 0.3f, fRadius*0.7f);
    m_fLightAngle = 0.7f * D3DX_PI;
    m_vViewAngle = D3DXVECTOR3(0.f, 0.8 * D3DX_PI, 0.f);

    // init light position and color
    memset(&m_Light0, 0, sizeof(D3DLIGHT8));
    m_Light0.Type = D3DLIGHT_DIRECTIONAL;
    m_Light0.Position = m_vLightPos;
    D3DXVECTOR3 vLightDir;
    D3DXVec3Normalize(&vLightDir, &m_vLightPos);
    m_Light0.Direction = -vLightDir;
    m_Light0.Diffuse.r = 1.0f;
    m_Light0.Diffuse.g = 1.0f;
    m_Light0.Diffuse.b = 1.0f;
    m_Light0.Specular.r = 1.0f;
    m_Light0.Specular.g = 1.0f;
    m_Light0.Specular.b = 1.0f;
    m_Light0.Range = 1000.0f;
    m_Light0.Attenuation0 = 1.0f;
    m_Light0.Phi = D3DX_PI;
    m_Light0.Theta = D3DX_PI/4.0;
    m_Light0.Falloff = 0.f;
    m_pd3dDevice->LightEnable(0, TRUE);
    m_pd3dDevice->SetLight(0, &m_Light0);

    // light
    float fLength = 0.2f;
    float fRadius0 = 0.01f;
    float fRadius1 = fLength * sinf(m_Light0.Theta);    // inner spotlight radius
    m_LightObj.m_Model = new CXModel;
    m_LightObj.m_Model->Cylinder(fRadius0, 0xc0ffffff, fRadius1, 0x00ffffff, fLength, 40, FVF_XYZDIFF, NULL, 1.0f);

    // set base path to our media directory
    // all the _FNA commands use this
    XPath_SetBasePath(_T("d:\\media\\"));

    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: Cleanup()
// Desc: Clean up after ourselves.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Cleanup()
{
    m_Help.Destroy();
    m_Font.Destroy();
    SAFE_RELEASE(m_LightObj.m_Model);
    UINT iConfig;
    for (iConfig = 0; iConfig < VERTEXSHADER_CONFIGURATIONS; iConfig++)
    {
        if (m_rdwFurVS[iConfig])
        {
            m_pd3dDevice->DeleteVertexShader(m_rdwFurVS[iConfig]);
            m_rdwFurVS[iConfig] = 0;
        }
        if (m_rdwFinVS[iConfig])
        {
            m_pd3dDevice->DeleteVertexShader(m_rdwFinVS[iConfig]);
            m_rdwFinVS[iConfig] = 0;
        }
    }
    for (iConfig = 0; iConfig < PIXELSHADER_CONFIGURATIONS; iConfig++)
    {
        if (m_rdwFurPS[iConfig])
        {
            m_pd3dDevice->DeletePixelShader(m_rdwFurPS[iConfig]);
            m_rdwFurPS[iConfig] = 0;
        }
    }
    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: CompareDist2()
// Desc: Used by SortInstances as an ordering function to sort models from
//   near to far.
//-----------------------------------------------------------------------------
static int __cdecl CompareDist2(const void *arg1, const void *arg2 )
{
    float f1 = *(float *)arg1;
    float f2 = *(float *)arg2;
    if (f1 < f2) 
        return -1;
    else if (f1 > f2) 
        return 1;
    else
        return 0;
}

//-----------------------------------------------------------------------------
// Name: UpdateInstances()
// Desc: Arrange the instances in a triangular grid,
//       cull based on current view, and then sort front to back.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::UpdateInstances()
{
    // get Blinn-style clipping matrix for bounding box culling
    D3DXMATRIX matViewProj = m_matView * m_matProjection;
    D3DXMATRIX matViewProjClip;
    BlinnClipMatrix(&matViewProjClip, &matViewProj);

    FLOAT fScale = 3.0f;
    D3DXVECTOR3 vPosition(0.f, 0.f, 0.f);
    D3DXVECTOR3 vDir(fScale, 0.f, 0.f);
    UINT iStep = 0; // current position in leg
    UINT nStep2 = 0;  // number of steps in leg * 2
    m_iNumActiveInstances = 0;
    for (INT iInstance = 0; iInstance < m_iNumInstances; iInstance++)
    {
        // Set current position
        m_rInstance[iInstance].vPosition = vPosition;

        // set geometric level of detail
        // Simple scheme: high detail in center, less on outer rings
        if (iInstance == 0)
            m_rInstance[iInstance].iModel = 0;
        else if (iInstance < 25)
            m_rInstance[iInstance].iModel = 1;
        else
            m_rInstance[iInstance].iModel = 2;

        // Compute world matrix
        Teddy *pTeddy = &m_rTeddy[m_rInstance[iInstance].iModel];
        D3DXVECTOR3 *p = &m_rInstance[iInstance].vPosition;
        D3DXMatrixTranslation(&m_rInstance[iInstance].matWorld, p->x, p->y, p->z);

        // Cull if completely outside view frustum
        D3DXMATRIX matWorldViewProjClip = m_rInstance[iInstance].matWorld * matViewProjClip;
        if (BoundingBoxInFrustum(matWorldViewProjClip, pTeddy->m_vMin, pTeddy->m_vMax))
        {
            // compute distance squared
            D3DXVECTOR3 vEye = m_rInstance[iInstance].vPosition - m_vEyePos;
            FLOAT fDist2 = D3DXVec3LengthSq(&vEye);

            // compute level of detail based on scaled squared distance
            m_rInstance[iInstance].fLevelOfDetail = m_fLevelOfDetail * fDist2;

            // Add to active list
            m_rActiveInstance[m_iNumActiveInstances].fDist2 = fDist2;
            m_rActiveInstance[m_iNumActiveInstances].iInstance = iInstance;
            m_iNumActiveInstances++;
        }
        
        // Move to next grid position
        vPosition += vDir;
        iStep++;
        if (iStep * 2 > nStep2)
        {
            iStep = 0;
            nStep2++; // increase number of steps every two legs
            vDir = D3DXVECTOR3(-vDir.z, 0.f, vDir.x);           // Rotate direction
        }
    }
    qsort( (void *)m_rActiveInstance, m_iNumActiveInstances, sizeof(ActiveInstance), &CompareDist2 );
    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: LoadModels
// Desc: load model files
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::LoadModels()
{
    static CHAR *rstrTeddy[TEDDYCOUNT] = {
        "Models\\teddy2000.xbg",
        "Models\\teddy1000.xbg",
        "Models\\teddy0500.xbg",
    };
    for (UINT iTeddy = 0; iTeddy < TEDDYCOUNT; iTeddy++)
    {
        Teddy *pTeddy = &m_rTeddy[iTeddy];

        // Load meshes from xbg files
        if( FAILED( pTeddy->m_Mesh.Create( m_pd3dDevice, rstrTeddy[iTeddy], NULL )))
            return XBAPPERR_MEDIANOTFOUND;

        // Copy VB and IB pointers from first mesh of input model
        XBMESH_DATA *pMeshData = pTeddy->m_Mesh.GetMesh( 0 );
        pTeddy->m_FurMesh.Initialize(pMeshData->m_dwFVF, pMeshData->m_dwNumVertices, &pMeshData->m_VB,
                                     pMeshData->m_dwNumIndices, &pMeshData->m_IB);
        
        // Calc bounding box
        pTeddy->m_Mesh.ComputeBoundingBox(&pTeddy->m_vMin, &pTeddy->m_vMax);
		
        if (iTeddy == 0)    // set lookat to center of most detailed model
            g_vLookAt = 0.5f * (pTeddy->m_vMin +  pTeddy->m_vMax);  // center of bb
    }
    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: ExtractFins
// Desc: extract the fins from all the models
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::ExtractFins()
{
    for (UINT iTeddy = 0; iTeddy < TEDDYCOUNT; iTeddy++)
    {
        Teddy *pTeddy = &m_rTeddy[iTeddy];
        
        // extract fins
        UINT BinFactor = 5; // factor that chooses the number of angle bins to discretize.  See XBFurMesh.cpp for more.
        float fFinDotProductThreshold = 0.75f; // range of dot products of fin's face normal with eye vector
        float fFinEdgeTextureScale = 7.0f; // scaling term matches scale of texture as applied to underlying model
        pTeddy->m_FurMesh.ExtractFins(BinFactor, fFinDotProductThreshold, fFinEdgeTextureScale);
    }
    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: CreateHairTextures
// Desc: Create a particle system patch of hair and then sample
//       the patch into a slice texture.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::CreateHairTextures()
{
	// setup hair parameters
    DWORD numfuzz = 8000;
    DWORD slicexsize = 128;
    DWORD slicezsize = 128;
    DWORD numfuzzlib = 32;
    DWORD numslices = m_iNumSlices;
    DWORD finWidth = 256; // we can afford to make the fin texture a little larger, since there's just one instead of numslices
    DWORD finHeight = 128;
    m_Fur.m_fXSize = 0.1f;
    m_Fur.m_fYSize = 0.01f;
    m_Fur.m_fZSize = 0.1f;
    m_Fur.m_dwNumSegments   = 4;
    m_Fur.m_fuzzRandom.colorBase = D3DXCOLOR(0.2f, 0.2f, 0.2f, 0.0f);
    m_Fur.m_fuzzCenter.colorBase = D3DXCOLOR(0.501961f, 0.250980f, 0.1f, 1.f) - 0.5f * m_Fur.m_fuzzRandom.colorBase;
    m_Fur.m_fuzzRandom.colorTip = D3DXCOLOR(0.1f, 0.1f, 0.1f, 0.1f);
    m_Fur.m_fuzzCenter.colorTip = D3DXCOLOR(0.1f, 0.1f, 0.1f, 0.1f);
    m_Fur.m_fuzzCenter.dp = D3DXVECTOR3(0.0f, 4.f, 0.5f);
    m_Fur.m_fuzzRandom.dp = D3DXVECTOR3(0.25f, 0.25f, 0.25f);
    m_Fur.m_fuzzCenter.ddp = D3DXVECTOR3(0.f, 0.f, 0.0f);
    m_Fur.m_fuzzRandom.ddp = D3DXVECTOR3(0.5f, 0.5f, 0.5f);
	
    // generate hair texture
    m_Fur.InitFuzz(numfuzz, numfuzzlib);
    m_Fur.GenSlices(numslices, slicexsize, slicezsize);
    // Generate fin texture with more image samples and more fuzz to get scaling right
    static float s_fFinXFraction = 0.25f; // proportion of fur that is projected in fin texture
    static float s_fFinZFraction = 0.05f;
    m_Fur.GenFin(finWidth, finHeight, s_fFinXFraction, s_fFinZFraction);
    m_Fur.ComputeLevelOfDetailTextures();
    m_Fur.SetLevelOfDetail(0.f);
    m_Fur.m_fYSize = 0.055f;
    
    // make hair lighting texture
    D3DMATERIAL8 material;
    ZeroMemory(&material, sizeof(material));
    material.Ambient  = D3DXCOLOR(0.2f, 0.2f, 0.2f, 1.f);
    material.Diffuse  = D3DXCOLOR(0.5f, 0.5f, 0.5f, 1.f);
    material.Specular = D3DXCOLOR(1.f, 1.f, 1.f, 1.f);
    material.Power = 40.0f;
    m_Fur.SetHairLightingMaterial(&material);
	
	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // toggle help
    if(m_DefaultGamepad.wPressedButtons&XINPUT_GAMEPAD_BACK)
        m_bDrawHelp = !m_bDrawHelp;

    // load the scene in chunks so we dont wait several
    // seconds before the app starts up
    if (m_dwLoadPhase == 0)
    {
        // load the models
        LoadModels();
        m_dwLoadPhase++;
    }
    else if (m_dwLoadPhase == 1)
    {
        // compute the fins
        ExtractFins();
        m_dwLoadPhase++;
    }
    else if (m_dwLoadPhase == 2)
    {
		CreateHairTextures();
        m_dwLoadPhase++;
    }
    else if (m_dwLoadPhase == 3)
    {
        if (m_Fur.CompressNextTexture(D3DFMT_DXT4, &m_iTextureIndex) == S_OK)
            m_dwLoadPhase++;
        else 
            return S_OK;
    }

    // set number of models
    if(m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_UP)
    {
        if (m_iNumInstances < NMAXINSTANCE)
            m_iNumInstances ++ ;
    }
    if(m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_DOWN)
    {
        if (m_iNumInstances >1)
            m_iNumInstances -- ;
    }
   
    // move view
    m_vViewAngle.y -= m_DefaultGamepad.fX1*1.0f*m_fElapsedTime;
    if(m_vViewAngle.y>D3DX_PI*2)
        m_vViewAngle.y -= D3DX_PI*2;
    if(m_vViewAngle.y<0.0f)
        m_vViewAngle.y += D3DX_PI*2;

    m_vViewAngle.x += m_DefaultGamepad.fY2*1.0f*m_fElapsedTime;
    if(m_vViewAngle.x>1.0f)
        m_vViewAngle.x = 1.0f;
    if(m_vViewAngle.x<-1.0f)
        m_vViewAngle.x = -1.0f;

    m_vCameraPos.z -= m_DefaultGamepad.fY1*2.f*m_fElapsedTime;
    if(m_vCameraPos.z<0.2f)
        m_vCameraPos.z = 0.2f;

     // move the camera around the model and always point right at it
    D3DXMATRIX m, m2;
    D3DXMatrixRotationYawPitchRoll(&m, m_vViewAngle.y, m_vViewAngle.x, m_vViewAngle.z);
    D3DXVec3TransformCoord(&m_vEyePos, &m_vCameraPos, &m);
    m_vEyePos += g_vLookAt;
    D3DXVECTOR3 up(0.0f, 1.0f, 0.0f);
    D3DXMatrixLookAtLH(&m_matView, &m_vEyePos, &g_vLookAt, &up);
    m_pd3dDevice->SetTransform(D3DTS_VIEW, &m_matView);

    // move the light around the model
    m_fLightAngle -= m_DefaultGamepad.fX2*1.0f*m_fElapsedTime;
    if(m_fLightAngle>D3DX_PI*2)
        m_fLightAngle -= D3DX_PI*2;
    if(m_fLightAngle<0.0f)
        m_fLightAngle += D3DX_PI*2;
    D3DXMatrixRotationY(&m, m_fLightAngle);
    D3DXVECTOR3 lpos;
    D3DXVec3TransformCoord(&lpos, &m_vLightPos, &m);
    D3DXVECTOR3 ldir;
    D3DXVec3Normalize(&ldir, &lpos);
    lpos += g_vLookAt;
    m_Light0.Position = lpos;
    m_Light0.Direction = -ldir;
    m_pd3dDevice->SetLight(0, &m_Light0);
    m_LightObj.SetPosition(m_Light0.Position.x, m_Light0.Position.y, m_Light0.Position.z);

    // set world-space light and eye positions for vertex shader
    g_LightPos = lpos;
    g_EyePos = m_vEyePos;
    
    // light looks at g_vLookAt
    D3DXMatrixLookAtLH(&m_LightObj.m_matOrientation, &m_LightObj.m_vPosition, &g_vLookAt, &up);
    D3DXMatrixInverse(&m_LightObj.m_matOrientation, NULL, &m_LightObj.m_matOrientation);

    // Set wind parameters
    static float fWindAmplitude = 0.01f;
    static float fWindFrequency = 2.f * D3DX_PI / 0.2f;
    static float fWindZero = -0.25f;
    // static float fPenalty = 1.5f;
    static float fTangentPlaneFraction = 0.9f;
    static float fWindStart = -7.f; // start the wind gradually
    static float fWindDecay = -5.f; // stop the wind gradually 
    static float fWindSwirlRadius = 0.1f;
    static float fWindSwirlFrequency = 2.f * D3DX_PI / 0.3f;
    g_vWind1.x = g_LightPos.x;
    g_vWind1.y = g_LightPos.y;
    g_vWind1.z = g_LightPos.z;
    D3DXMATRIX *pmat = &m_LightObj.m_matOrientation;    // grab left and up out of light matrix
    D3DXVECTOR3 vX(pmat->m[0][0], pmat->m[0][1], pmat->m[0][2]);
    D3DXVECTOR3 vY(pmat->m[1][0], pmat->m[1][1], pmat->m[1][2]);
    *(D3DXVECTOR3 *)&g_vWind2 = vY;
    g_vWind2.w = fTangentPlaneFraction;
    *(D3DXVECTOR3 *)&g_vWind3 = vX;
    g_vWind3.w = 0.f;
    if(m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER])
    {
        // blow-dryer
        g_bWind = true;
        float fWind = fWindZero + fWindAmplitude * cosf(m_fTime * fWindFrequency); 
        g_fWindChoose *= expf(fWindStart * m_fElapsedTime);
        g_vWind1.w = (1.f - g_fWindChoose) * fWind;
        // move source in small swirl around light source position
        float fWindSwirlX = fWindSwirlRadius * cosf(m_fTime * fWindSwirlFrequency);
        float fWindSwirlY = fWindSwirlRadius * sinf(m_fTime * fWindSwirlFrequency);
        *(D3DXVECTOR3 *)&g_vWind1 += fWindSwirlX * vX + fWindSwirlY * vY;
    }
    else
    {
        // turn-off wind
        g_fWindChoose = 1.f;
        g_vWind1.w *= expf(fWindDecay * m_fElapsedTime);

        // wait until wind has died out to turn off the wind vertex shader
        float fWindEpsilon = 1e-3f;
        if (fabsf(g_vWind1.w) < fWindEpsilon)
            g_bWind = false;
    }

    // Position, sort, and cull the instances
    UpdateInstances();
    
    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: DrawLightIcon()
// Desc: Draw light as a bright cone
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::DrawLightIcon()
{
    // set and save state
    SET_D3DRS(D3DRS_LIGHTING, FALSE);
    SET_D3DRS(D3DRS_EMISSIVEMATERIALSOURCE, D3DMCS_COLOR1);
    SET_D3DRS(D3DRS_ALPHABLENDENABLE, TRUE);
    SET_D3DRS(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
    SET_D3DRS(D3DRS_DESTBLEND, D3DBLEND_ONE);
    SET_D3DRS(D3DRS_CULLMODE, D3DCULL_NONE);
    SET_D3DRS(D3DRS_ZWRITEENABLE, FALSE);
    SET_D3DTSS(0, D3DTSS_COLOROP,       D3DTOP_SELECTARG1);
    SET_D3DTSS(0, D3DTSS_COLORARG1, D3DTA_DIFFUSE);
    SET_D3DTSS(0, D3DTSS_ALPHAOP,       D3DTOP_SELECTARG1);
    SET_D3DTSS(0, D3DTSS_ALPHAARG1, D3DTA_DIFFUSE);

    // draw icon
    m_LightObj.Render(OBJ_NOMCALCS);
    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    D3DXVECTOR3 L(g_LightPos - g_vLookAt), E(g_EyePos - g_vLookAt);
    bool bLightBehind = (D3DXVec3Dot(&L, &E) < 0.f);

    // Clear the viewport
    RenderGradientBackground(D3DXCOLOR(0.1f, 0.1f, 0.1f, 1.f), D3DXCOLOR(0.3f, 0.3f, 0.4f, 1.f));

    m_pd3dDevice->SetRenderState(D3DRS_ZENABLE, D3DZB_TRUE);
    m_pd3dDevice->SetTransform(D3DTS_WORLD, &m_LightObj.m_matOrientation);
    if (bLightBehind) 
        DrawLightIcon();            // draw the light icon behind the fur
    m_pd3dDevice->SetTextureStageState(0, D3DTSS_MINFILTER, D3DTEXF_LINEAR);
    m_pd3dDevice->SetTextureStageState(0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR);
    m_pd3dDevice->SetTextureStageState(1, D3DTSS_MINFILTER, D3DTEXF_LINEAR);
    m_pd3dDevice->SetTextureStageState(1, D3DTSS_MAGFILTER, D3DTEXF_LINEAR);
    m_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
    m_pd3dDevice->SetRenderState(D3DRS_ALPHATESTENABLE, FALSE);
    m_pd3dDevice->SetRenderState(D3DRS_ZENABLE, D3DZB_TRUE);
    m_pd3dDevice->SetRenderState(D3DRS_CULLMODE, D3DCULL_CCW );
    m_pd3dDevice->SetRenderState(D3DRS_LIGHTING, TRUE);
    m_pd3dDevice->SetRenderState(D3DRS_EMISSIVEMATERIALSOURCE, D3DMCS_MATERIAL);
    m_pd3dDevice->SetRenderState(D3DRS_NORMALIZENORMALS, TRUE); // This is 

    // render the base meshes from near to far to initialize the skin and zbuffer
    if(m_dwLoadPhase>0)
    {
        for (INT iActiveInstance = 0; iActiveInstance < m_iNumActiveInstances; iActiveInstance++)       // near to far
        {
            INT iInstance = m_rActiveInstance[iActiveInstance].iInstance;
            UINT iTeddy = m_rInstance[iInstance].iModel;
            Teddy *pTeddy = &m_rTeddy[iTeddy];
            m_pd3dDevice->SetTransform(D3DTS_WORLD, &m_rInstance[iInstance].matWorld);  // set world transformation
            pTeddy->m_Mesh.Render(m_pd3dDevice);    // draws skin, nose, and ears
        }
    }

    // render the fur in the oppposite order, from far to near, so that alpha-blending works
    g_dwNumShellsDrawn = 0;
    if(m_dwLoadPhase>2 && (g_bDrawFins || g_bDrawShells))
    {
        // pick vertex shaders depending on current settings
        UINT iConfig = (g_bWind ? (1 << 2) : 0) | (g_bLocalLighting ? (1 << 1) : 0) | (g_bSelfShadow ? 1 : 0);
        DWORD dwFurVS = m_rdwFurVS[iConfig];
        DWORD dwFinVS = m_rdwFinVS[iConfig];
        static float fFinLODFull = 3.5f;    // fade out between fFinFull and fFinCutoff
        static float fFinLODCutoff = 4.f;   // LOD's above this value don't get fins
        static float fFinExtraNormalScale = 1.25f;
        D3DXMATRIX matViewProjection;
        D3DXMatrixMultiply(&matViewProjection, &m_matView, &m_matProjection);
        for (INT iActiveInstance = m_iNumActiveInstances - 1; iActiveInstance >= 0; iActiveInstance--)      // far to near
        {
            INT iInstance = m_rActiveInstance[iActiveInstance].iInstance;
            UINT iTeddy = m_rInstance[iInstance].iModel;
            Teddy *pTeddy = &m_rTeddy[iTeddy];
            pTeddy->m_FurMesh.Begin(&g_EyePos, &g_LightPos, &matViewProjection);
            D3DXMATRIX *pmatWorld = &m_rInstance[iInstance].matWorld;
            D3DXMATRIX matWorldInverse;
            D3DXMatrixInverse(&matWorldInverse, NULL, pmatWorld);
            m_Fur.SetLevelOfDetail(m_rInstance[iInstance].fLevelOfDetail);
            pTeddy->m_FurMesh.BeginObject(pmatWorld, &matWorldInverse);
            if (g_bDrawFins) pTeddy->m_FurMesh.DrawFins(&m_Fur, dwFinVS, fFinLODFull, fFinLODCutoff, fFinExtraNormalScale);
            if (g_bDrawShells)
            {
                pTeddy->m_FurMesh.DrawShells(&m_Fur, dwFurVS, m_rdwFurPS);
                g_dwNumShellsDrawn += m_Fur.m_dwNumSlicesLOD;
            }
            pTeddy->m_FurMesh.EndObject();
            pTeddy->m_FurMesh.End();
        }
    }

    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
    if (!bLightBehind)  
        DrawLightIcon();            // draw light icon to overlay the fur

    // show title and framerate
    m_Font.Begin();
    m_Font.DrawText(  64, 50, 0xffffffff, L"Fur" );
    if (m_dwLoadPhase > 3) 
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );

    // show shell and instance stats
    {
        const int buflen = 100;
        WCHAR buf[buflen];

        _snwprintf(buf, buflen, L"Shells Drawn %d", g_dwNumShellsDrawn);
		buf[buflen - 1] = L'\0';
        m_Font.DrawText( 576, 100, 0xffffff00, buf, XBFONT_RIGHT );

        _snwprintf(buf, buflen, L"Model Count %d", m_iNumInstances);
		buf[buflen - 1] = L'\0';
        m_Font.DrawText( 576, 125, 0xffffff00, buf, XBFONT_RIGHT );

        _snwprintf(buf, buflen, L"Active Count %d", m_iNumActiveInstances);
		buf[buflen - 1] = L'\0';
        m_Font.DrawText( 576, 150, 0xffffff00, buf, XBFONT_RIGHT );
     }

    // show status
    if ( m_dwLoadPhase == 0 )
        m_Font.DrawText( 280, 50, 0xff00ffff, L"Loading models", XBFONT_CENTER_X );
    else if ( m_dwLoadPhase == 1 )
        m_Font.DrawText( 280, 50, 0xff00ffff, L"Extracting fins", XBFONT_CENTER_X );
    else if ( m_dwLoadPhase == 2 )
        m_Font.DrawText( 280, 50, 0xff00ffff, L"Generating hair", XBFONT_CENTER_X) ;
    else if ( m_dwLoadPhase == 3 )
    {
        const int buflen = 100;
        WCHAR buf[buflen];
        _snwprintf(buf, buflen, L"Compressing texture %d of %d", m_iTextureIndex + 1, m_Fur.TotalTextureCount());
		buf[buflen - 1] = L'\0';
        m_Font.DrawText( 280, 50, 0xff00ffff, buf, XBFONT_CENTER_X);
    }
    
    // show help
    if(m_bDrawHelp)
        m_Help.Render(&m_Font, g_NormalHelpCallouts, MAX_NORMAL_HELP_CALLOUTS);
    m_Font.End();

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\fur\comp3.inl ===
// Xbox Shader Assembler 1.00.4355.1
D3DPIXELSHADERDEF psd;
ZeroMemory(&psd, sizeof(psd));
psd.PSCombinerCount=PS_COMBINERCOUNT(
    2,
    PS_COMBINERCOUNT_MUX_MSB | PS_COMBINERCOUNT_UNIQUE_C0 | PS_COMBINERCOUNT_UNIQUE_C1);
psd.PSTextureModes=PS_TEXTUREMODES(
    PS_TEXTUREMODES_PROJECT2D,
    PS_TEXTUREMODES_PROJECT2D,
    PS_TEXTUREMODES_PROJECT2D,
    PS_TEXTUREMODES_NONE);
psd.PSInputTexture=PS_INPUTTEXTURE(0,0,0,0);
psd.PSDotMapping=PS_DOTMAPPING(
    0,
    PS_DOTMAPPING_ZERO_TO_ONE,
    PS_DOTMAPPING_ZERO_TO_ONE,
    PS_DOTMAPPING_ZERO_TO_ONE);
psd.PSCompareMode=PS_COMPAREMODE(
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT);

//------------- Stage 0 -------------
psd.PSRGBInputs[0]=PS_COMBINERINPUTS(
    PS_REGISTER_T1 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_T0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_T1 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSAlphaInputs[0]=PS_COMBINERINPUTS(
    PS_REGISTER_T1 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_T0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_T1 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSRGBOutputs[0]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R1,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[0]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R1,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[0] = 0x00000000;
psd.PSConstant1[0] = 0x00000000;

//------------- Stage 1 -------------
psd.PSRGBInputs[1]=PS_COMBINERINPUTS(
    PS_REGISTER_T2 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_R1 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_T2 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSAlphaInputs[1]=PS_COMBINERINPUTS(
    PS_REGISTER_T2 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_R1 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_T2 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSRGBOutputs[1]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[1]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[1] = 0x00000000;
psd.PSConstant1[1] = 0x00000000;

psd.PSC0Mapping = 0xffffffff;
psd.PSC1Mapping = 0xffffffff;
psd.PSFinalCombinerConstants = 0x000001ff;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\fur\furfade1.inl ===
// Xbox Shader Assembler 1.00.4355.1
D3DPIXELSHADERDEF psd;
ZeroMemory(&psd, sizeof(psd));
psd.PSCombinerCount=PS_COMBINERCOUNT(
    3,
    PS_COMBINERCOUNT_MUX_MSB | PS_COMBINERCOUNT_UNIQUE_C0 | PS_COMBINERCOUNT_UNIQUE_C1);
psd.PSTextureModes=PS_TEXTUREMODES(
    PS_TEXTUREMODES_PROJECT2D,
    PS_TEXTUREMODES_PROJECT2D,
    PS_TEXTUREMODES_PROJECT2D,
    PS_TEXTUREMODES_NONE);
psd.PSInputTexture=PS_INPUTTEXTURE(0,0,0,0);
psd.PSDotMapping=PS_DOTMAPPING(
    0,
    PS_DOTMAPPING_ZERO_TO_ONE,
    PS_DOTMAPPING_ZERO_TO_ONE,
    PS_DOTMAPPING_ZERO_TO_ONE);
psd.PSCompareMode=PS_COMPAREMODE(
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT);

//------------- Stage 0 -------------
psd.PSRGBInputs[0]=PS_COMBINERINPUTS(
    PS_REGISTER_V0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_T1 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
psd.PSAlphaInputs[0]=PS_COMBINERINPUTS(
    PS_REGISTER_V0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_T1 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
psd.PSRGBOutputs[0]=PS_COMBINEROUTPUTS(
    PS_REGISTER_R1,
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_COMBINEROUTPUT_SHIFTLEFT_1 | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[0]=PS_COMBINEROUTPUTS(
    PS_REGISTER_R1,
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[0] = 0x00000000;
psd.PSConstant1[0] = 0x00000000;

//------------- Stage 1 -------------
psd.PSRGBInputs[1]=PS_COMBINERINPUTS(
    PS_REGISTER_C0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_T2 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_T0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_C0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_INVERT);
psd.PSAlphaInputs[1]=PS_COMBINERINPUTS(
    PS_REGISTER_C0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_T2 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_T0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_C0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT);
psd.PSRGBOutputs[1]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[1]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[1] = 0x00000000;
psd.PSConstant1[1] = 0x00000000;

//------------- Stage 2 -------------
psd.PSRGBInputs[2]=PS_COMBINERINPUTS(
    PS_REGISTER_R1 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_R0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
psd.PSAlphaInputs[2]=PS_COMBINERINPUTS(
    PS_REGISTER_R1 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_R0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
psd.PSRGBOutputs[2]=PS_COMBINEROUTPUTS(
    PS_REGISTER_R0,
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_COMBINEROUTPUT_SHIFTLEFT_1 | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[2]=PS_COMBINEROUTPUTS(
    PS_REGISTER_R0,
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[2] = 0x00000000;
psd.PSConstant1[2] = 0x00000000;

psd.PSC0Mapping = 0xffffff0f;
psd.PSC1Mapping = 0xffffffff;
psd.PSFinalCombinerConstants = 0x000001ff;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\fur\Mipmap.cpp ===
//-----------------------------------------------------------------------------
//  
//  File: mipmap.cpp
//  Copyright (C) 2001 Microsoft Corporation
//  All rights reserved.
//  
//  Mipmap filtering using the GPU
//
//-----------------------------------------------------------------------------
#include "mipmap.h"
#include <XBUtil.h>
#include "SwizzleFormat.h"
#include <assert.h>

extern LPDIRECT3DDEVICE8 g_pd3dDevice;

//////////////////////////////////////////////////////////////////////
// Default filter is lanczos with halfwidth 2 and 2 supersamples.  That
// works out to 8 taps per output pixel, with a small negative lobe for
// sharpness.
static MipmapFilter s_MipmapFilterDefault(2, 2.f, MipmapFilter::lanczos, MIPMAPFILTER_NORMALIZE_ADD);

//////////////////////////////////////////////////////////////////////
// Sample filter kernel, weight by super sample area, and normalize.
//
MipmapFilter::MipmapFilter(UINT nSuperSample,
						   float fHalfWidth,
						   float (*pfFilter)(float x, float fHalfWidth),
						   DWORD dwFlags)
{
	if (nSuperSample == 0) nSuperSample = 1;
	m_nSuperSample = nSuperSample;
	m_fHalfWidth = fHalfWidth;

	// If number of supersamples is even, offset by half pixel.
	float fSampleOffset;
	if (nSuperSample % 2)
		fSampleOffset = 0.f;
	else
		fSampleOffset = 0.5f;		

	// Get number of supersamples in support
	int iSuperMin = (int)ceilf(-fHalfWidth * nSuperSample - fSampleOffset);
	int iSuperMax = (int)floorf(fHalfWidth * nSuperSample - fSampleOffset);
	m_nSample = iSuperMax - iSuperMin + 1;

	// Get adjusted filter support width
	float fStretch = 1.f;
	if (dwFlags & MIPMAPFILTER_STRETCH) 
	{
		fStretch = 1.f - 0.5f / fHalfWidth;
		iSuperMin = (int)ceilf(-fHalfWidth * nSuperSample - fSampleOffset);
		iSuperMax = (int)floorf(fHalfWidth * nSuperSample - fSampleOffset);
		m_nSample = iSuperMax - iSuperMin + 1;
	}

	// Allocate sample array
	m_rSample = new Sample [ m_nSample ];

	// Sample filter at supersample positions
	float fStep = 1.f / nSuperSample;
	float fWeight = fStretch * fStep;
	UINT iSample = 0;
	m_iSuperMin = m_iSuperMax = 0;
	for (int iSuper = iSuperMin; iSuper <= iSuperMax; iSuper++)
	{
		float fOffset = (iSuper + fSampleOffset) * fStep;
		float fValue = fWeight * (*pfFilter)(fOffset * fStretch, fHalfWidth);
		if (!(dwFlags & MIPMAPFILTER_KEEPZEROS))
		{
			float fQuant = 255.f * fabsf(fValue);
			if (fQuant < 0.5f) continue; // remove values that quantize to zero
		}
		m_rSample[iSample].m_fOffset = fOffset;
		m_rSample[iSample].m_fValue = fValue;
		iSample++;
		if (iSuper < m_iSuperMin) m_iSuperMin = iSuper;
		if (iSuper > m_iSuperMax) m_iSuperMax = iSuper;
	}

	// Re-allocate sample array after removing zeros
	if (iSample < m_nSample)
	{
		Sample *rSampleOld = m_rSample;
		m_nSample = iSample;
		m_rSample = new Sample [ m_nSample ];
		for (iSample = 0; iSample < m_nSample; iSample++)
			m_rSample[iSample] = rSampleOld[iSample];
		delete [] rSampleOld;
	}

	// Normalize
	if (dwFlags & MIPMAPFILTER_NORMALIZE_MULTIPLY)
		NormalizeMultiply();
	else if (dwFlags & MIPMAPFILTER_NORMALIZE_ADD)
		NormalizeAdd();
}

//////////////////////////////////////////////////////////////////////
// Add (1 - sum)/N to each filter value.
//
void MipmapFilter::NormalizeAdd()
{
	float fSum = 0.f;
	for (UINT iSample = 0; iSample < m_nSample; iSample++)
		fSum += m_rSample[iSample].m_fValue;
	float fOffset = (1.f - fSum) / m_nSample;
	for ( iSample = 0; iSample < m_nSample; iSample++)
		m_rSample[iSample].m_fValue += fOffset;
}

//////////////////////////////////////////////////////////////////////
// Multiply each filter coefficient by 1/sum of the original coefficients.
//
void MipmapFilter::NormalizeMultiply()
{
	float fSum = 0.f;
	for (UINT iSample = 0; iSample < m_nSample; iSample++)
		fSum += m_rSample[iSample].m_fValue;
	float fScale = 1.f/fSum;
	for ( iSample = 0; iSample < m_nSample; iSample++)
		m_rSample[iSample].m_fValue *= fScale;
}

//////////////////////////////////////////////////////////////////////
// Standard sin(pi*x)/(pi*x) function that is the inverse fourier
// transform of a box filter in the frequency domain.  The problem with
// the sinc is that it has infinite extent. The lanczos and hamming filters
// below take a finite window and smoothly "roll off" at the edges.
//
float MipmapFilter::sinc(float x)
{
	if (x == 0.f)
		return 1.f;
	else
		return sinf(D3DX_PI * x) / (D3DX_PI * x);
}

//////////////////////////////////////////////////////////////////////
// Triangle filter is not a too bad approximation to a windowed sinc,
// but doesn't have a negative lobe to make the result sharp.  The
// lanczos, hamming, and mitchell filters are better.
//
float MipmapFilter::triangle(float x, float fHalfWidth)
{
	float r = x / fHalfWidth;
	if (r < -1.f || r > 1.f)
		return 0.0;
	else if (r < 0.0) 
		return (1 + r) / fHalfWidth;
	else 
		return (1 - r) / fHalfWidth;
}

//////////////////////////////////////////////////////////////////////
// Sinc-windowed sinc
//
float MipmapFilter::lanczos(float x, float fHalfWidth)
{
	if (x < -fHalfWidth || x > fHalfWidth)
		return 0.f;
	else
		return sinc(x/fHalfWidth) * sinc(x);
}

//////////////////////////////////////////////////////////////////////
// Hamming-windowed sinc
//
float MipmapFilter::hamming(float x, float fHalfWidth)
{
	if (x < -fHalfWidth || x > fHalfWidth)
		return 0.f;
	else
		return (0.46f * cosf(D3DX_PI * x / fHalfWidth) + 0.54f) * sinc(x);
}

//////////////////////////////////////////////////////////////////////
// Cubic filter that has a shape similar to the lanczos and hamming filters,
// but has slightly smaller negative lobes.
//
float MipmapFilter::mitchell(float x, float fHalfWidth)
{
	const float B = 0.3f;
	const float C = 0.3f;
	float r = (x < 0.f) ? -x : x;
	r /= 0.5f * fHalfWidth;
	if (r <= 1.f)
		return (6 - 2*B + r*r*(-18 + 12*B + 6*C + r*(12 - 9*B - 6*C)))/6;
	else if (r <= 2.f)
		return (8*B + 24*C + r*(-12*B - 48*C + r*(6*B + 30*C + r*(-B - 6*C))))/6;
	else 
		return 0.f;
}

//////////////////////////////////////////////////////////////////////
// CopyRects even if the formats are swizzled.
// 
HRESULT CopyRects(D3DSurface *pSurfaceSrc, CONST RECT *pSrcRectsArray, UINT cRects, D3DSurface *pSurfaceDst, CONST POINT *pDstPointsArray)
{
	HRESULT hr;
	D3DSURFACE_DESC descSrc;
	pSurfaceSrc->GetDesc(&descSrc);
	BOOL bSwizzledSrc = XGIsSwizzledFormat(descSrc.Format);
	D3DSURFACE_DESC descDst;
	pSurfaceDst->GetDesc(&descDst);
	BOOL bSwizzledDst = XGIsSwizzledFormat(descDst.Format);
	if (! bSwizzledSrc && !bSwizzledDst ) // if formats are both unswizzled, use regular CopyRects
		return g_pd3dDevice->CopyRects(pSurfaceSrc, pSrcRectsArray, cRects, pSurfaceDst, pDstPointsArray);
	if (MapSwizzledToLinearFormat(descSrc.Format) != MapSwizzledToLinearFormat(descDst.Format))
		return D3DERR_WRONGTEXTUREFORMAT;

	// Otherwise, copy pixel by pixel
	DWORD cbPixel = XGBytesPerPixelFromFormat(descSrc.Format);
	D3DLOCKED_RECT lockedRectSrc;
	hr = pSurfaceSrc->LockRect(&lockedRectSrc, NULL, 0);
	if (FAILED(hr))
		return hr;
	D3DLOCKED_RECT lockedRectDst;
	hr = pSurfaceDst->LockRect(&lockedRectDst, NULL, 0);
	if (FAILED(hr))
	{
		pSurfaceSrc->UnlockRect();
		return hr;
	}
	for (UINT iRect = 0; iRect < cRects; iRect++)
	{
		RECT rectSrc;
		if (pSrcRectsArray)
			rectSrc = pSrcRectsArray[iRect];
		else
		{
			rectSrc.left = 0;
			rectSrc.right = descSrc.Width;
			rectSrc.top = 0;
			rectSrc.bottom = descSrc.Height;
		}
		POINT pointDst;
		if (pDstPointsArray)
			pointDst = pDstPointsArray[iRect];
		else
			pointDst.x = pointDst.y = 0;
		if (bSwizzledSrc && bSwizzledDst)
		{
			Swizzler swizSrc(descSrc.Width, descSrc.Height, 0);
			Swizzler swizDst(descDst.Width, descDst.Height, 0);
			swizSrc.SetV(swizSrc.SwizzleV(rectSrc.top));
			swizDst.SetV(swizDst.SwizzleV(pointDst.y));
			for (long v = rectSrc.top; v < rectSrc.bottom; v++)
			{
				swizSrc.SetU(swizSrc.SwizzleU(rectSrc.left));
				swizDst.SetU(swizDst.SwizzleU(pointDst.x));
				for (long u = rectSrc.left; u < rectSrc.right; u++)
				{
					BYTE *pSrc = (BYTE *)lockedRectSrc.pBits + cbPixel * swizSrc.Get2D();
					BYTE *pDst = (BYTE *)lockedRectDst.pBits + cbPixel * swizDst.Get2D();
					memcpy(pDst, pSrc, cbPixel);
					swizSrc.IncU();
					swizDst.IncU();
				}
				swizSrc.IncV();
				swizDst.IncV();
			}
		}
		else if (bSwizzledSrc) // && !bSwizzledDst
		{
			Swizzler swizSrc(descSrc.Width, descSrc.Height, 0);
			swizSrc.SetV(swizSrc.SwizzleV(rectSrc.top));
			for (long v = rectSrc.top; v < rectSrc.bottom; v++)
			{
				long vDst = pointDst.y + v - rectSrc.top;
				swizSrc.SetU(swizSrc.SwizzleU(rectSrc.left));
				for (long u = rectSrc.left; u < rectSrc.right; u++)
				{
					long uDst = pointDst.x + u - rectSrc.left;
					BYTE *pSrc = (BYTE *)lockedRectSrc.pBits + cbPixel * swizSrc.Get2D();
					BYTE *pDst = (BYTE *)lockedRectDst.pBits + vDst * lockedRectDst.Pitch + uDst * cbPixel;
					memcpy(pDst, pSrc, cbPixel);
					swizSrc.IncU();
				}
				swizSrc.IncV();
			}
		}
		else // !bSwizzledSrc && bSwizzledDst
		{
			Swizzler swizDst(descDst.Width, descDst.Height, 0);
			swizDst.SetV(swizDst.SwizzleV(pointDst.y));
			for (long v = rectSrc.top; v < rectSrc.bottom; v++)
			{
				swizDst.SetU(swizDst.SwizzleU(pointDst.x));
				for (long u = rectSrc.left; u < rectSrc.right; u++)
				{
					BYTE *pSrc = (BYTE *)lockedRectSrc.pBits + v * lockedRectSrc.Pitch + u * cbPixel;
					BYTE *pDst = (BYTE *)lockedRectDst.pBits + cbPixel * swizDst.Get2D();
					memcpy(pDst, pSrc, cbPixel);
					swizDst.IncU();
				}
				swizDst.IncV();
			}
		}
	}
	pSurfaceSrc->UnlockRect();
	pSurfaceDst->UnlockRect();
	return S_OK;
}


//////////////////////////////////////////////////////////////////////
// Helper function for allocating scratch textures, if needed.
//
static HRESULT AllocScratchYX(MipmapFilter *pFilter,
							  D3DSURFACE_DESC &descSrc,
							  LPDIRECT3DTEXTURE8 &pTextureScratchY,
							  LPDIRECT3DTEXTURE8 &pTextureScratchX)
{
	HRESULT hr;
	if (pTextureScratchY == NULL)
	{
		DWORD width = descSrc.Width;
		DWORD height = descSrc.Height / pFilter->m_nSuperSample;	// result will be decimated in Y
		if (height < 1) height = 1;
		if (width * XGBytesPerPixelFromFormat(descSrc.Format) < 64  // Xbox render target must have at least the minimum pitch
			|| width * height < 64)
		{
			width = 64;	// 16 is smallest reasonable render target
			if (height < width)	// if source height is larger use it, otherwise use reasonable default
				height = width;
		}
		hr = g_pd3dDevice->CreateTexture(width, height, 1, D3DUSAGE_RENDERTARGET, descSrc.Format, D3DPOOL_DEFAULT, &pTextureScratchY);
		if (FAILED(hr))
			return hr;
	}
	else
	{
		D3DSURFACE_DESC descScratchY;
		pTextureScratchY->GetLevelDesc(0, &descScratchY);
		if (descScratchY.Width < descSrc.Width										// Y scratch must match _source_ width
			|| descScratchY.Height < descSrc.Height / pFilter->m_nSuperSample		// ... and destination height
			|| descScratchY.Width * XGBytesPerPixelFromFormat(descScratchY.Format) < 64  // Xbox render target must have at least the minimum pitch
			|| descScratchY.Width * descScratchY.Height < 64
			|| MapSwizzledToLinearFormat(descSrc.Format) != MapSwizzledToLinearFormat(descScratchY.Format))	// formats must be compatible
			return E_INVALIDARG;
		pTextureScratchY->AddRef();	// to balance Release, below
	}
	if (pTextureScratchX == NULL)
	{
		DWORD width = descSrc.Width / pFilter->m_nSuperSample;		// result will be decimated in X
		if (width < 1) width = 1;
		DWORD height = descSrc.Height / pFilter->m_nSuperSample;	// result will be decimated in Y by previous filter pass
		if (height < 1) height = 1;
		if (width * XGBytesPerPixelFromFormat(descSrc.Format) < 64  // Xbox render target must have at least the minimum pitch
			|| width * height < 64)
		{
			width = 64;	// 16 is smallest reasonable render target
			if (height < width)	// if source height is larger use it, otherwise use reasonable default
				height = width;
		}
		hr = g_pd3dDevice->CreateTexture(width, height, 1, D3DUSAGE_RENDERTARGET, descSrc.Format, D3DPOOL_DEFAULT, &pTextureScratchX);
		if (FAILED(hr))
		{
			SAFE_RELEASE(pTextureScratchY);
			return hr;
		}
	}
	else
	{
		D3DSURFACE_DESC descScratchX;
		pTextureScratchX->GetLevelDesc(0, &descScratchX);
		if (descScratchX.Width < descSrc.Width / pFilter->m_nSuperSample			// X scratch must match destination width
			|| descScratchX.Height < descSrc.Height / pFilter->m_nSuperSample		// ... and destination height
			|| descScratchX.Width * XGBytesPerPixelFromFormat(descScratchX.Format) < 64  // Xbox render target must have at least the minimum pitch
			|| descScratchX.Width * descScratchX.Height < 64
			|| MapSwizzledToLinearFormat(descSrc.Format) != MapSwizzledToLinearFormat(descScratchX.Format))	// formats must be compatible
		{
			SAFE_RELEASE(pTextureScratchY);
			return E_INVALIDARG;
		}
		pTextureScratchX->AddRef();	// to balance Release, below
	}
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// Uses Decimate to compute mipmaps starting with iSourceLevel
//
HRESULT GenerateMipmaps(LPDIRECT3DTEXTURE8 pTexture,
						UINT iSourceLevel,
						D3DTEXTUREADDRESS WrapU, 
						D3DTEXTUREADDRESS WrapV,
						LPDIRECT3DTEXTURE8 pTextureScratchY,
						LPDIRECT3DTEXTURE8 pTextureScratchX,
						MipmapFilter *pFilter)
{
	HRESULT hr;
	DWORD nMip = pTexture->GetLevelCount();
	if (iSourceLevel >= nMip - 1) return S_FALSE;	// nothing to filter
	if (!pFilter) pFilter = &s_MipmapFilterDefault;
	D3DSURFACE_DESC descSrc;
	hr = pTexture->GetLevelDesc(iSourceLevel, &descSrc);
	if (FAILED(hr))
		return hr;
	hr = AllocScratchYX(pFilter, descSrc, pTextureScratchY, pTextureScratchX);
	if (FAILED(hr))
		return hr;
	LPDIRECT3DSURFACE8 pSurfaceDst = NULL;
	for (UINT iMip = iSourceLevel + 1; iMip < nMip; iMip++)
	{
		hr = pTexture->GetSurfaceLevel(iMip, &pSurfaceDst); // get destination surface
		if (FAILED(hr))
			goto e_Exit;
		hr = Decimate(pSurfaceDst, pTexture, iMip - 1, WrapU, WrapV, pTextureScratchY, pTextureScratchX, pFilter);
		if (FAILED(hr))
			goto e_Exit;
		SAFE_RELEASE(pSurfaceDst);
	}
 e_Exit:
	SAFE_RELEASE(pSurfaceDst);
	SAFE_RELEASE(pTextureScratchX);
	SAFE_RELEASE(pTextureScratchY);
	return hr;
}

//////////////////////////////////////////////////////////////////////
// Use filter coefficients to resample from higher resolution
// pSurfaceSrc to lower resolution pSurfaceDst.
// The width of Src must be m_nSuperSample * width of Dst and
// the height of Src must be m_nSuperSample * height of Dst.
// The Y scratch texture must have width >= Src and height >= Src / 2.
// The X scratch texture must have width >= Src / 2 and height >= Src / 2.
HRESULT Decimate(LPDIRECT3DSURFACE8 pSurfaceDst,
				 LPDIRECT3DTEXTURE8 pTextureSrc,
				 UINT iSourceLevel,	// index of source miplevel in pTextureSrc
				 D3DTEXTUREADDRESS WrapU, 
				 D3DTEXTUREADDRESS WrapV,
				 LPDIRECT3DTEXTURE8 pTextureScratchY,
				 LPDIRECT3DTEXTURE8 pTextureScratchX,
				 MipmapFilter *pFilter)
{
	HRESULT hr;
	if (!pFilter) pFilter = &s_MipmapFilterDefault;

	// Get sizes of intermediate and final render targets
	D3DSURFACE_DESC descSrc;
	pTextureSrc->GetLevelDesc(iSourceLevel, &descSrc);
	D3DSURFACE_DESC descDst;
	pSurfaceDst->GetDesc(&descDst);
	if ((descDst.Width != 1 && descDst.Width > descSrc.Width / pFilter->m_nSuperSample)
		|| (descDst.Height != 1 && descDst.Height > descSrc.Height / pFilter->m_nSuperSample))
		return E_INVALIDARG;	// texture sizes don't match
	hr = AllocScratchYX(pFilter, descSrc, pTextureScratchY, pTextureScratchX);
	if (FAILED(hr))
		return hr;
	D3DSURFACE_DESC descScratchY, descScratchX;
	pTextureScratchY->GetLevelDesc(0, &descScratchY);
	pTextureScratchX->GetLevelDesc(0, &descScratchX);
	DWORD dwStateBlock = (DWORD)-1;
	hr = g_pd3dDevice->CreateStateBlock(D3DSBT_ALL, &dwStateBlock);
	if (FAILED(hr))
		return hr;
	
	// save current back buffer, z buffer, and pixel shader
	struct {
		IDirect3DSurface8 *pBackBuffer, *pZBuffer;
	} save;
	g_pd3dDevice->GetRenderTarget(&save.pBackBuffer);
	g_pd3dDevice->GetDepthStencilSurface(&save.pZBuffer);

	// set render state for filtering
	g_pd3dDevice->SetVertexShader(D3DFVF_XYZRHW|D3DFVF_TEX4);	// for screen-space texture-mapped quadrilateral
	g_pd3dDevice->SetRenderState(D3DRS_LIGHTING, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_ALPHATESTENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_ZENABLE, D3DZB_FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_STENCILENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_FOGENABLE, FALSE);

	// use pixel shaders to add contributions from four samples at a time
	DWORD dwPS = 0;
#pragma warning(push)
#pragma warning(disable: 4245)	// conversion from int to DWORD
#include "mipmap.inl"
#pragma warning(pop)
	g_pd3dDevice->CreatePixelShader(&psd, &dwPS);
	g_pd3dDevice->SetPixelShader(dwPS);

	// set texture stage state
	UINT xx; // texture stage index
	for (xx = 0; xx < 4; xx++)
	{
		g_pd3dDevice->SetTexture(xx, pTextureSrc);	// use our source texture for all four stages
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_COLOROP, D3DTOP_DISABLE);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_DISABLE);	// pass texture coords without transformation
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_TEXCOORDINDEX, xx); // each texture has different tex coords
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_ADDRESSU, WrapU);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_ADDRESSV, WrapV);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_MAXMIPLEVEL, iSourceLevel);	// set most-detailed level to the desired source texture
		float fBias = -1000.f; 														// bias mipmap toward the most detailed level
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_MIPMAPLODBIAS, *((LPDWORD) (&fBias)));
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_MINFILTER, D3DTEXF_POINT);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_MIPFILTER, D3DTEXF_POINT);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_MAGFILTER, D3DTEXF_POINT);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_COLORKEYOP, D3DTCOLORKEYOP_DISABLE);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_COLORSIGN, 0);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_ALPHAKILL, D3DTALPHAKILL_DISABLE);
	}

	//
	// Pass 1: Filter in Y from Src to ScratchY
	//
	{
		LPDIRECT3DSURFACE8 pSurfaceScratchY = NULL;
		pTextureScratchY->GetSurfaceLevel(0, &pSurfaceScratchY);
		hr = g_pd3dDevice->SetRenderTarget(pSurfaceScratchY, NULL); // no depth buffering
		pSurfaceScratchY->Release();
		if (FAILED(hr))
			goto e_Exit;
		DWORD width = descSrc.Width;
		DWORD height = descSrc.Height / pFilter->m_nSuperSample;
		if (height < 1) height = 1;
		struct quad {
			float x, y, z, w1;
			struct uv {
				float u, v;
			} tex[4];	// each texture has different offset
		} aQuad[4] =
		  { //   X             Y              Z   1/W     u0  v0      u1  v1      u2  v2      u3  v3
			  {-0.5f,        -0.5f,         1.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f},
			  {width - 0.5f, -0.5f,         1.0f, 1.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f},
			  {-0.5f,        height - 0.5f, 1.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f},
			  {width - 0.5f, height - 0.5f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f}
		  };
		g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
		g_pd3dDevice->SetRenderState(D3DRS_BLENDOP, D3DBLENDOP_ADD);
		g_pd3dDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_ONE);
		g_pd3dDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ZERO);	// on first rendering, copy new value over current render target contents
		xx = 0;	// current texture stage
		float rfZero[4] = {0.f, 0.f, 0.f, 0.f};
		float fOffsetScale = (float)pFilter->m_nSuperSample / (float)descSrc.Height;	// source texture coords
		for (UINT iSample = 0; iSample < pFilter->m_nSample; iSample++)
		{
			// set filter coefficients
			float fValue = pFilter->m_rSample[iSample].m_fValue;
			if (fValue > 0.f)
			{
				float rf[4] = {fValue, fValue, fValue, fValue};
				g_pd3dDevice->SetPixelShaderConstant(xx, rf, 1);			// positive coeff
				g_pd3dDevice->SetPixelShaderConstant(xx + 4, rfZero, 1);	// negative coeff set to zero
			}
			else
			{
				float rf[4] = {-fValue, -fValue, -fValue, -fValue};
				g_pd3dDevice->SetPixelShaderConstant(xx, rfZero, 1);		// positive coeff set to zero
				g_pd3dDevice->SetPixelShaderConstant(xx + 4, rf, 1);		// negative coeff
			}
			// Align supersamples with center of destination pixels
			float fOffset = pFilter->m_rSample[iSample].m_fOffset * fOffsetScale;
			aQuad[0].tex[xx].u = 0.f;
			aQuad[0].tex[xx].v = fOffset;
			aQuad[1].tex[xx].u = 1.f;
			aQuad[1].tex[xx].v = fOffset;
			aQuad[2].tex[xx].u = 0.f;
			aQuad[2].tex[xx].v = 1.f + fOffset;
			aQuad[3].tex[xx].u = 1.f;
			aQuad[3].tex[xx].v = 1.f + fOffset;
			if (!XGIsSwizzledFormat(descSrc.Format))
			{
				for (int i = 0; i < 4; i++)
				{
					aQuad[i].tex[xx].u *= descSrc.Width;
					aQuad[i].tex[xx].v *= descSrc.Height;
				}
			}
			xx++;
			if (xx == 4)	// max texture stages
			{
				// draw the quad to filter the coefficients so far
				g_pd3dDevice->DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, 2, aQuad, sizeof(quad)); // one quad blends 4 textures
				g_pd3dDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ONE); // on subsequent renderings, add to what's in the render target
				xx = 0;
			}
		}
		if (xx != 0) // add in results of final filter coefficients
		{
			// zero out rest of texture stage coefficients
			for (xx; xx < 4; xx++)
			{
				g_pd3dDevice->SetPixelShaderConstant(xx, rfZero, 1);		// positive coeff set to zero
				g_pd3dDevice->SetPixelShaderConstant(xx + 4, rfZero, 1);	// negative coeff set to zero
			}
			g_pd3dDevice->DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, 2, aQuad, sizeof(quad)); // one quad blends 4 textures
		}
	}

	//
	// Pass 2: Filter in X from ScratchY to ScratchX
	//
	{
		DWORD width = descSrc.Width / pFilter->m_nSuperSample;
		if (width < 1) width = 1;
		DWORD height = descSrc.Height / pFilter->m_nSuperSample;
		if (height < 1) height = 1;
		for (xx = 0; xx < 4; xx++)
			g_pd3dDevice->SetTexture(xx, pTextureScratchY);	// use the Y scratch texture as source for all four stages
		// Adjust scratch texture coords to include just the used region
		D3DXVECTOR2 vOrigin(0.f, 0.f);
		D3DXVECTOR2 vSize((float)descSrc.Width/(float)descScratchY.Width, (float)height/(float)descScratchY.Height);
#if 0
		if (descDst.Width * XGBytesPerPixelFromFormat(descDst.Format) >= 64  // Xbox render target must have at least the minimum pitch
			&& descDst.Width * descDst.Height >= 64)
		{
			// If destination surface is large enough, use it as a render target.
			hr = g_pd3dDevice->SetRenderTarget(pSurfaceDst, NULL); // no depth buffering
			if (FAILED(hr))
				goto e_Exit;
		}
		else
#endif
		{
			// Set scratchX as render target
			LPDIRECT3DSURFACE8 pSurfaceScratchX = NULL;
			pTextureScratchX->GetSurfaceLevel(0, &pSurfaceScratchX);
			hr = g_pd3dDevice->SetRenderTarget(pSurfaceScratchX, NULL); // no depth buffering
			pSurfaceScratchX->Release();
			if (FAILED(hr))
				goto e_Exit;
		}
		struct quad {
			float x, y, z, w1;
			struct uv {
				float u, v;
			} tex[4];	// each texture has different offset
		} aQuad[4] =
		  { //   X             Y              Z   1/W     u0  v0      u1  v1      u2  v2      u3  v3
			  {-0.5f,        -0.5f,         1.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f},
			  {width - 0.5f, -0.5f,         1.0f, 1.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f},
			  {-0.5f,        height - 0.5f, 1.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f},
			  {width - 0.5f, height - 0.5f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f}
		  };
		g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
		g_pd3dDevice->SetRenderState(D3DRS_BLENDOP, D3DBLENDOP_ADD);
		g_pd3dDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_ONE);
		g_pd3dDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ZERO);	// on first rendering, copy new value over current render target contents
		xx = 0;	// current texture stage
		float rfZero[4] = {0.f, 0.f, 0.f, 0.f};
		// TODO: review offset scale when width gets close to 1
		float fOffsetScale = (float)pFilter->m_nSuperSample / (float)descScratchY.Width;	// source texture coords
		for (UINT iSample = 0; iSample < pFilter->m_nSample; iSample++)
		{
			// set filter coefficients
			float fValue = pFilter->m_rSample[iSample].m_fValue;
			if (fValue > 0.f)
			{
				float rf[4] = {fValue, fValue, fValue, fValue};
				g_pd3dDevice->SetPixelShaderConstant(xx, rf, 1);			// positive coeff
				g_pd3dDevice->SetPixelShaderConstant(xx + 4, rfZero, 1);	// negative coeff set to zero
			}
			else
			{
				float rf[4] = {-fValue, -fValue, -fValue, -fValue};
				g_pd3dDevice->SetPixelShaderConstant(xx, rfZero, 1);		// positive coeff set to zero
				g_pd3dDevice->SetPixelShaderConstant(xx + 4, rf, 1);		// negative coeff
			}
			// Align supersamples with center of destination pixels
			float fOffset = pFilter->m_rSample[iSample].m_fOffset * fOffsetScale;
			aQuad[0].tex[xx].u = vOrigin.x + fOffset;
			aQuad[0].tex[xx].v = vOrigin.y;
			aQuad[1].tex[xx].u = vOrigin.x + vSize.x + fOffset;
			aQuad[1].tex[xx].v = vOrigin.y;
			aQuad[2].tex[xx].u = vOrigin.x + fOffset;
			aQuad[2].tex[xx].v = vOrigin.y + vSize.y;
			aQuad[3].tex[xx].u = vOrigin.x + vSize.x + fOffset;
			aQuad[3].tex[xx].v = vOrigin.y + vSize.y;
			if (!XGIsSwizzledFormat(descScratchY.Format))
			{
				for (int i = 0; i < 4; i++)
				{
					aQuad[i].tex[xx].u *= descScratchY.Width;
					aQuad[i].tex[xx].v *= descScratchY.Height;
				}
			}
			xx++;
			if (xx == 4)	// max texture stages
			{
				// draw the quad to filter the coefficients so far
				g_pd3dDevice->DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, 2, aQuad, sizeof(quad)); // one quad blends 4 textures
				g_pd3dDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ONE); // on subsequent renderings, add to what's in the render target
				xx = 0;
			}
		}
		if (xx != 0) // add in results of final filter coefficients
		{
			// zero out rest of texture stage coefficients
			for (xx; xx < 4; xx++)
			{
				g_pd3dDevice->SetPixelShaderConstant(xx, rfZero, 1);		// positive coeff set to zero
				g_pd3dDevice->SetPixelShaderConstant(xx + 4, rfZero, 1);	// negative coeff set to zero
			}
			g_pd3dDevice->DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, 2, aQuad, sizeof(quad)); // one quad blends 4 textures
		}
	}

	// 
	// Copy result to output
	//
	{
		DWORD width = descDst.Width;
		DWORD height = descDst.Height;
		
		// Stop using the scratch texture
		g_pd3dDevice->SetRenderTarget(save.pBackBuffer, save.pZBuffer);
		for (xx = 0; xx < 4; xx++)
			g_pd3dDevice->SetTexture(xx, NULL);
		g_pd3dDevice->BlockUntilIdle();

		// Copy result from scratch texture to destination surface
		LPDIRECT3DSURFACE8 pSurfaceScratchX = NULL;
		pTextureScratchX->GetSurfaceLevel(0, &pSurfaceScratchX);
		RECT rect = { 0, 0, width, height };
		POINT point = { 0, 0 };
		hr = CopyRects(pSurfaceScratchX, &rect, 1, pSurfaceDst, &point);
		pSurfaceScratchX->Release();
		if (FAILED(hr))
			goto e_Exit;
	}

e_Exit:
	SAFE_RELEASE(pTextureScratchX);
	SAFE_RELEASE(pTextureScratchY);

	// clean up pixel shaders
	g_pd3dDevice->SetPixelShader(0);
	g_pd3dDevice->DeletePixelShader(dwPS);
	
	// restore render states
	g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_LIGHTING, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_EMISSIVEMATERIALSOURCE, D3DMCS_MATERIAL);

	// clear texture stages
	for (xx=0; xx<4; xx++)
	{
		g_pd3dDevice->SetTexture(xx, NULL);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_COLOROP, D3DTOP_DISABLE);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_MIPMAPLODBIAS, 0);
	}

	// restore back buffer and z buffer
	g_pd3dDevice->SetRenderTarget(save.pBackBuffer, save.pZBuffer);
	SAFE_RELEASE(save.pBackBuffer);
	SAFE_RELEASE(save.pZBuffer);
	g_pd3dDevice->ApplyStateBlock(dwStateBlock);
	g_pd3dDevice->DeleteStateBlock(dwStateBlock);
	return hr;
}

//////////////////////////////////////////////////////////////////////
// Create a new texture and copy the current texture to the new
// texture, with a format conversion.
//
HRESULT CompressTexture(LPDIRECT3DTEXTURE8 *ppTextureDst, D3DFORMAT fmtNew, LPDIRECT3DTEXTURE8 pTextureSrc)
{
	HRESULT hr;
	if (!pTextureSrc)
		return S_FALSE;
	*ppTextureDst = NULL;
	UINT nLevel = pTextureSrc->GetLevelCount();
	BYTE *pUnswizzledSrc = NULL;
	BYTE *pUnswizzledDst = NULL;
	LPDIRECT3DTEXTURE8 pTextureDst = NULL;
	LPDIRECT3DSURFACE8 pSurfaceSrc = NULL;
	LPDIRECT3DSURFACE8 pSurfaceDst = NULL;
	D3DSURFACE_DESC desc0;
	pTextureSrc->GetLevelDesc(0, &desc0);
	hr = g_pd3dDevice->CreateTexture(desc0.Width, desc0.Height, nLevel, 0, fmtNew, 0, &pTextureDst);
	if (FAILED(hr))
		goto e_Exit;
	if (XGIsSwizzledFormat(desc0.Format))
	{
		pUnswizzledSrc = new BYTE [ desc0.Width * desc0.Height * XGBytesPerPixelFromFormat(desc0.Format)]; 
		if (pUnswizzledSrc == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto e_Exit;
		}
	}
	if (XGIsSwizzledFormat(fmtNew))
	{
		pUnswizzledDst = new BYTE [ desc0.Width * desc0.Height * XGBytesPerPixelFromFormat(fmtNew)];
		if (pUnswizzledDst == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto e_Exit;
		}
	}
	for (UINT iLevel = 0; iLevel < nLevel; iLevel++)
	{
		D3DSURFACE_DESC desc;
		pTextureSrc->GetLevelDesc(iLevel, &desc);
		assert(desc.Format == desc0.Format);
		assert(desc.Width <= desc0.Width);
		assert(desc.Height <= desc0.Height);
		hr = pTextureSrc->GetSurfaceLevel(iLevel, &pSurfaceSrc);
		if (FAILED(hr))
			goto e_Exit;
		hr = pTextureDst->GetSurfaceLevel(iLevel, &pSurfaceDst);
		if (FAILED(hr))
			goto e_Exit;
		D3DLOCKED_RECT lockedRectSrc;
		hr = pSurfaceSrc->LockRect(&lockedRectSrc, NULL, D3DLOCK_READONLY);
		if (FAILED(hr))
			goto e_Exit;
		D3DLOCKED_RECT lockedRectDst;
		hr = pSurfaceDst->LockRect(&lockedRectDst, NULL, 0);
		if (FAILED(hr))
		{
			pSurfaceSrc->UnlockRect();
			goto e_Exit;
		}
		VOID *pBufSrc;
		DWORD dwPitchSrc;
		D3DFORMAT fmtSrc;
		if (XGIsSwizzledFormat(desc.Format))
		{
			XGUnswizzleRect(lockedRectSrc.pBits, desc.Width, desc.Height, NULL, pUnswizzledSrc, 0, NULL, XGBytesPerPixelFromFormat(desc.Format));
			pBufSrc = pUnswizzledSrc;
			dwPitchSrc = 0;
			fmtSrc = MapSwizzledToLinearFormat(desc.Format);
		}
		else
		{
			pBufSrc = lockedRectSrc.pBits;
			dwPitchSrc = lockedRectSrc.Pitch;
			fmtSrc = desc.Format;
		}
		VOID *pBufDst;
		DWORD dwPitchDst;
		D3DFORMAT fmtDst;
		if (XGIsSwizzledFormat(fmtNew))
		{
			pBufDst = pUnswizzledDst;
			dwPitchDst = 0;
			fmtDst = MapSwizzledToLinearFormat(fmtNew);
		}
		else
		{
			pBufDst = lockedRectDst.pBits;
			dwPitchDst = lockedRectDst.Pitch;
			fmtDst = fmtNew;
		}
		hr = XGCompressRect(pBufDst, fmtDst, dwPitchDst, desc.Width, desc.Height, pBufSrc, fmtSrc, dwPitchSrc, 0.f, 0 );
		if (FAILED(hr))
		{
			pSurfaceSrc->UnlockRect();
			pSurfaceDst->UnlockRect();
			goto e_Exit;
		}
		if (XGIsSwizzledFormat(fmtNew))
			XGSwizzleRect(pBufDst, dwPitchDst, NULL, lockedRectDst.pBits, desc.Width, desc.Height, NULL, XGBytesPerPixelFromFormat(fmtNew));
		pSurfaceSrc->UnlockRect();
		pSurfaceDst->UnlockRect();
		SAFE_RELEASE(pSurfaceSrc);
		SAFE_RELEASE(pSurfaceDst);
	}
	*ppTextureDst = pTextureDst;	// already AddRef'd
	pTextureDst = NULL;	// to avoid a Release below
 e_Exit:
	SAFE_RELEASE(pTextureDst);
	SAFE_DELETE(pUnswizzledSrc);
	SAFE_DELETE(pUnswizzledDst);
	SAFE_RELEASE(pSurfaceSrc);
	SAFE_RELEASE(pSurfaceDst);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\fur\swizzleformat.h ===
//////////////////////////////////////////////////////////////////////
// Swizzled to linear and back format mapping.
//
//  Copyright (C) 2001 Microsoft Corporation
//  All rights reserved.
//////////////////////////////////////////////////////////////////////
inline D3DFORMAT MapLinearToSwizzledFormat(D3DFORMAT fmt)
{
	switch (fmt)
	{
    case D3DFMT_LIN_A1R5G5B5: 	return D3DFMT_A1R5G5B5;
    case D3DFMT_LIN_A4R4G4B4: 	return D3DFMT_A4R4G4B4;
    case D3DFMT_LIN_A8: 		return D3DFMT_A8;
    case D3DFMT_LIN_A8B8G8R8: 	return D3DFMT_A8B8G8R8;
    case D3DFMT_LIN_A8R8G8B8: 	return D3DFMT_A8R8G8B8;
    case D3DFMT_LIN_B8G8R8A8: 	return D3DFMT_B8G8R8A8;
    case D3DFMT_LIN_G8B8: 		return D3DFMT_G8B8;
    case D3DFMT_LIN_R4G4B4A4: 	return D3DFMT_R4G4B4A4;
    case D3DFMT_LIN_R5G5B5A1: 	return D3DFMT_R5G5B5A1;
    case D3DFMT_LIN_R5G6B5: 	return D3DFMT_R5G6B5;
    case D3DFMT_LIN_R6G5B5: 	return D3DFMT_R6G5B5;
    case D3DFMT_LIN_R8B8: 		return D3DFMT_R8B8;
    case D3DFMT_LIN_R8G8B8A8: 	return D3DFMT_R8G8B8A8;
    case D3DFMT_LIN_X1R5G5B5: 	return D3DFMT_X1R5G5B5;
    case D3DFMT_LIN_X8R8G8B8: 	return D3DFMT_X8R8G8B8;
    case D3DFMT_LIN_A8L8: 		return D3DFMT_A8L8;
    case D3DFMT_LIN_AL8: 		return D3DFMT_AL8;
    case D3DFMT_LIN_L16: 		return D3DFMT_L16;
    case D3DFMT_LIN_L8: 		return D3DFMT_L8;
    case D3DFMT_LIN_V16U16: 	return D3DFMT_V16U16;
    case D3DFMT_LIN_D24S8: 		return D3DFMT_D24S8;
    case D3DFMT_LIN_F24S8: 		return D3DFMT_F24S8;
    case D3DFMT_LIN_D16: 		return D3DFMT_D16;
    case D3DFMT_LIN_F16: 		return D3DFMT_F16;
	default:
		return fmt;
	}
}

inline D3DFORMAT MapSwizzledToLinearFormat(D3DFORMAT fmt)
{
	switch (fmt)
	{
    case D3DFMT_A1R5G5B5: 	return D3DFMT_LIN_A1R5G5B5;
    case D3DFMT_A4R4G4B4: 	return D3DFMT_LIN_A4R4G4B4;
    case D3DFMT_A8: 		return D3DFMT_LIN_A8;
    case D3DFMT_A8B8G8R8: 	return D3DFMT_LIN_A8B8G8R8;
    case D3DFMT_A8R8G8B8: 	return D3DFMT_LIN_A8R8G8B8;
    case D3DFMT_B8G8R8A8: 	return D3DFMT_LIN_B8G8R8A8;
    case D3DFMT_G8B8: 		return D3DFMT_LIN_G8B8;
    case D3DFMT_R4G4B4A4: 	return D3DFMT_LIN_R4G4B4A4;
    case D3DFMT_R5G5B5A1: 	return D3DFMT_LIN_R5G5B5A1;
    case D3DFMT_R5G6B5: 	return D3DFMT_LIN_R5G6B5;
    case D3DFMT_R6G5B5: 	return D3DFMT_LIN_R6G5B5;
    case D3DFMT_R8B8: 		return D3DFMT_LIN_R8B8;
    case D3DFMT_R8G8B8A8: 	return D3DFMT_LIN_R8G8B8A8;
    case D3DFMT_X1R5G5B5: 	return D3DFMT_LIN_X1R5G5B5;
    case D3DFMT_X8R8G8B8: 	return D3DFMT_LIN_X8R8G8B8;
    case D3DFMT_A8L8: 		return D3DFMT_LIN_A8L8;
    case D3DFMT_AL8: 		return D3DFMT_LIN_AL8;
    case D3DFMT_L16: 		return D3DFMT_LIN_L16;
    case D3DFMT_L8: 		return D3DFMT_LIN_L8;
    case D3DFMT_V16U16: 	return D3DFMT_LIN_V16U16;
    case D3DFMT_D24S8: 		return D3DFMT_LIN_D24S8;
    case D3DFMT_F24S8: 		return D3DFMT_LIN_F24S8;
    case D3DFMT_D16: 		return D3DFMT_LIN_D16;
    case D3DFMT_F16: 		return D3DFMT_LIN_F16;
	default:
		return fmt;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\fur\makefile.inc ===
#
# The fin and fur vertex shaders come in several configurations, built from
# the same source files with different defines.
#
$(FURVERTEXSHADERS) : $(VSPATH)\fur.vsh $(VSPATH)\eyelighthalf.vsh $(VSPATH)\hairlighting.vsh $(VSPATH)\wind.vsh
    @echo Assembling fur vertex shader.
	xsasm -nologo -l -D WIND -D LOCAL_LIGHTING -D SELF_SHADOWING $(VSPATH)\fur.vsh $(VSPATH)\fur_wind1_local1_self1.xvu "" $(O)\fur_wind1_local1_self1.lst
	xsasm -nologo -l -D WIND -D LOCAL_LIGHTING                   $(VSPATH)\fur.vsh $(VSPATH)\fur_wind1_local1_self0.xvu "" $(O)\fur_wind1_local1_self0.lst
	xsasm -nologo -l -D WIND                   -D SELF_SHADOWING $(VSPATH)\fur.vsh $(VSPATH)\fur_wind1_local0_self1.xvu "" $(O)\fur_wind1_local0_self1.lst
	xsasm -nologo -l -D WIND                                     $(VSPATH)\fur.vsh $(VSPATH)\fur_wind1_local0_self0.xvu "" $(O)\fur_wind1_local0_self0.lst
	xsasm -nologo -l         -D LOCAL_LIGHTING -D SELF_SHADOWING $(VSPATH)\fur.vsh $(VSPATH)\fur_wind0_local1_self1.xvu "" $(O)\fur_wind0_local1_self1.lst
	xsasm -nologo -l         -D LOCAL_LIGHTING                   $(VSPATH)\fur.vsh $(VSPATH)\fur_wind0_local1_self0.xvu "" $(O)\fur_wind0_local1_self0.lst
	xsasm -nologo -l                           -D SELF_SHADOWING $(VSPATH)\fur.vsh $(VSPATH)\fur_wind0_local0_self1.xvu "" $(O)\fur_wind0_local0_self1.lst
	xsasm -nologo -l                                             $(VSPATH)\fur.vsh $(VSPATH)\fur_wind0_local0_self0.xvu "" $(O)\fur_wind0_local0_self0.lst

$(FINVERTEXSHADERS) : $(VSPATH)\fin.vsh $(VSPATH)\eyelighthalf.vsh $(VSPATH)\hairlighting.vsh $(VSPATH)\wind.vsh
    @echo Assembling fin vertex shader.
	xsasm -nologo -l -D WIND -D LOCAL_LIGHTING -D SELF_SHADOWING $(VSPATH)\fin.vsh $(VSPATH)\fin_wind1_local1_self1.xvu "" $(O)\fin_wind1_local1_self1.lst
	xsasm -nologo -l -D WIND -D LOCAL_LIGHTING                   $(VSPATH)\fin.vsh $(VSPATH)\fin_wind1_local1_self0.xvu "" $(O)\fin_wind1_local1_self0.lst
	xsasm -nologo -l -D WIND                   -D SELF_SHADOWING $(VSPATH)\fin.vsh $(VSPATH)\fin_wind1_local0_self1.xvu "" $(O)\fin_wind1_local0_self1.lst
	xsasm -nologo -l -D WIND                                     $(VSPATH)\fin.vsh $(VSPATH)\fin_wind1_local0_self0.xvu "" $(O)\fin_wind1_local0_self0.lst
	xsasm -nologo -l         -D LOCAL_LIGHTING -D SELF_SHADOWING $(VSPATH)\fin.vsh $(VSPATH)\fin_wind0_local1_self1.xvu "" $(O)\fin_wind0_local1_self1.lst
	xsasm -nologo -l         -D LOCAL_LIGHTING                   $(VSPATH)\fin.vsh $(VSPATH)\fin_wind0_local1_self0.xvu "" $(O)\fin_wind0_local1_self0.lst
	xsasm -nologo -l                           -D SELF_SHADOWING $(VSPATH)\fin.vsh $(VSPATH)\fin_wind0_local0_self1.xvu "" $(O)\fin_wind0_local0_self1.lst
	xsasm -nologo -l                                             $(VSPATH)\fin.vsh $(VSPATH)\fin_wind0_local0_self0.xvu "" $(O)\fin_wind0_local0_self0.lst

!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\fur\OctoSphere.cpp ===
//-----------------------------------------------------------------------------
//  
//  File: octosphere.cpp
//  Copyright (C) 2001 Microsoft Corporation
//  All rights reserved.
//  
//-----------------------------------------------------------------------------
#include "octosphere.h"

//-----------------------------------------------------------------------------
// Name: OctoSphereIndex
// Desc: The octohedron is mapped to a square and layed-out in memory as follows:
//
//             DOMAIN                        MEMORY LAYOUT
//               -Y
//   -Z  +a0a1a2a3+a3a2a2a0+ -Z           Z0a0a1a2a3Y0b3b2b1b0
//      c0       /|\       d0		      c0 . . . . . . . . .
//      c1     /  |  \     d1		      c1 . . . . . . . . .
//      c2   /    |    \   d2		      c2 . . . . . . . . .
//      c3 /   +Z |      \ d3		      c3 . . . . . . . . .
//    -X +--------+--------+ +X		      X0 . . . .Z1 . . . .
//      c3 \      |      / d3		      d3 . . . . . . . . .
//      c2   \    |    /   d2		      d2 . . . . . . . . .
//      c1     \  |  /     d1		      d1 . . . . . . . . .
//      c0       \|/       d0		      d0 . . . . . . . . .
//       +b0b1b2b3+b3b2b1b0+ -Z		      X1 Y1               
//      -Z       +Y
//
// Where the a0=a0, b2=b2, etc. points are identical.
// The -Z axis is at all four corners.
// For the memory layout, the right column and bottom row are "chopped" off.
//   'b' values are packed next to 'a' values in the top row
//   'd' values are packed below 'c' values in the left column
//   X1 = +X and Y1=+Y are put at the end
//-----------------------------------------------------------------------------
inline int OctoSphereStandardIndex(int i, int j, int M)
{
	return (i + M) * M * 2 + j + M; // default indexing
}
inline int OctoSphereIndex(int i, int j, int M)
{
	if (i == -M)
	{
		if (j == -M || j == M)
			return 0; // -Z
		else if (j > 0)
			return OctoSphereStandardIndex(i, -j, M); // flipped 'a' value
		else
			return OctoSphereStandardIndex(i, j, M);
	}
	else if (i == M)
	{
		if (j == -M || j == M)
			return 0; // -Z
		else if (j == 0)
			return 4*M*M + 1; // +Y
		else if (j < 0)
			return OctoSphereStandardIndex(-M, -j, M); // flipped packed 'b' value
		else // if (j > 0)
			return OctoSphereStandardIndex(-M, j, M);   // packed 'b' value
	}
	else if (j == -M)
	{
		if (i == -M || i == M)
			return 0; // -Z
		else if (i > 0)
			return OctoSphereStandardIndex(-i, j, M); // flipped 'c' value
		else
			return OctoSphereStandardIndex(i, j, M);
	}
	else if (j == M)
	{
		if (i == -M || i == M)
			return 0; // -Z
		else if (i == 0)
			return 4*M*M; // +X
		else if (i < 0)
			return OctoSphereStandardIndex(-i, -M, M); // flipped packed 'd' value
		else // if (i > 0)
			return OctoSphereStandardIndex(i, -M, M); // packed 'd' value
	}
	else
		return OctoSphereStandardIndex(i, j, M);
}

//-----------------------------------------------------------------------------
// Name: FillOctoSphere
// Desc: Create a sphere as a subdivision of an octohedron.
//       Pass in NULL pointers to rVertex or rIndex to return needed sizes of buffers.
//-----------------------------------------------------------------------------
HRESULT FillOctoSphere(UINT nSplit, // number of splits on each edge, 0 = octohedron
					  UINT *pnVertex, D3DXVECTOR3 *rVertex, // vertices
					  UINT *pnIndex, WORD *rIndex) // triangle indices
{
	int M = nSplit + 1;
	int N = M * 2; // number of edges along one side of our domain
	if (pnVertex != NULL)
		*pnVertex = N * N + 2;
	if (pnIndex != NULL)
		*pnIndex = 3 * 2 * N * N;

	// Fill in vertices based on faces of octohedron
	if (rVertex)
	{
		// TODO: Add chord -> angle correction to get better shaped triangles
		D3DXVECTOR3 *pVertex = rVertex;
		for (int i = -M; i < M; i++)
		{
			for (int j = -M; j < M; j++)
			{
				int i0, j0;
				// handle special packing of boundaries
				if (i == -M && j > 0)
				{
					i0 = M;	 // flip i to handle 'b' boundary
					j0 = j;
				}
				else if (j == -M && i > 0)
				{
					i0 = i;
					j0 = M;	// flip j to handle 'd' boundary
				}
				else
				{
					// standard case
					i0 = i;
					j0 = j;
				}
				int i1 = (i0 < 0) ? -i0 : i0;	// flip y to positive quadrant
				int j1 = (j0 < 0) ? -j0 : j0;	// flip x to positive quadrant
				int ix, iy, iz;
				if (i1 <= M - j1)				// test against x + y = M line
				{
					ix = j0;
					iy = i0;
					iz = M - i1 - j1;
				}
				else // flip z
				{
					// reflect x and y across x + y = M line
					ix = M - i1; // swap x and y
					iy = M - j1;
					if (j0 < 0) ix = -ix; // restore quadrant
					if (i0 < 0) iy = -iy;
					iz = M - i1 - j1;  // -M + (M - i1) + (M - j1);
				}
				pVertex->x = (float)ix;
				pVertex->y = (float)iy;
				pVertex->z = (float)iz;
				D3DXVec3Normalize(pVertex, pVertex);
				pVertex++;
			}
		}
		// last two vertices are special cases
		pVertex->x = 1.f; pVertex->y = 0.f; pVertex->z = 0.f; pVertex++; // +X
		pVertex->x = 0.f; pVertex->y = 1.f; pVertex->z = 0.f; pVertex++; // +Y
	}

	// Fill in triangles, orienting triangle flips by quadrant
	if (rIndex)
	{
		WORD *pIndex = rIndex;
		for (int i = -M; i < M; i++)
		{
			for (int j = -M; j < M; j++)
			{
#define INDEX(i,j) 	((WORD)(OctoSphereIndex(i, j, M)))
				if ((i < 0 && j < 0) || (i >= 0 && j >= 0))
				{
					pIndex[0] = INDEX(i,j);
					pIndex[1] = INDEX(i+1,j);
					pIndex[2] = INDEX(i,j+1);
					pIndex += 3;
					pIndex[0] = INDEX(i,j+1);
					pIndex[1] = INDEX(i+1,j);
					pIndex[2] = INDEX(i+1,j+1);
					pIndex += 3;
				}
				else
				{
					pIndex[0] = INDEX(i,j);
					pIndex[1] = INDEX(i+1,j);
					pIndex[2] = INDEX(i+1,j+1);
					pIndex += 3;
					pIndex[0] = INDEX(i,j);
					pIndex[1] = INDEX(i+1,j+1);
					pIndex[2] = INDEX(i,j+1);
					pIndex += 3;
				}
#undef INDEX				
			}
		}
	}
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\fur\Mipmap.h ===
//-----------------------------------------------------------------------------
//  
//  File: mipmap.h
//  Copyright (C) 2001 Microsoft Corporation
//  All rights reserved.
//  
//  Mipmap filtering using the GPU
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <xgraphics.h>

//////////////////////////////////////////////////////////////////////
// Filter coefficients and offsets for separable mipmap filtering.
//
class MipmapFilter {
 public:
	UINT m_nSuperSample;		// number of source samples per destination pixel
	float m_fHalfWidth;			// size of filter support
	UINT m_nSample;				// number of filter samples
	struct Sample {
		float m_fOffset;		// offset in destination pixel coords
		float m_fValue;			// value at offset
	} *m_rSample;
	int m_iSuperMin, m_iSuperMax;	// range of supersamples
 public:
#define MIPMAPFILTER_NORMALIZE_ADD		001 /* add (1-sum)/N to each filter coefficient */
#define MIPMAPFILTER_NORMALIZE_MULTIPLY	002 /* multiply each value by 1/sum */
#define MIPMAPFILTER_STRETCH				010 /* expand filter slightly to make tighter frequency bound */
#define MIPMAPFILTER_KEEPZEROS			020 /* filter values that quantize to zero are usually culled, when 255 * f < 0.5 */
	MipmapFilter(UINT nSuperSample = 2,	// number of source samples per output pixel
		   float fHalfWidth = 2.f,	// in destination pixel coords, filter is assumed to be zero outside this bound
		   float (*pfFilter)(float x, float fHalfWidth) = lanczos,	// filter kernel
		   DWORD dwFlags = MIPMAPFILTER_NORMALIZE_ADD);	// normalization flags
	~MipmapFilter() { delete [] m_rSample; }

	// kernel helper functions
	void NormalizeAdd();		// add (1 - sum)/N to each value
	void NormalizeMultiply();	// multiply each value by 1/sum
	static float triangle(float x, float fHalfWidth);
	static float mitchell(float x, float fHalfWidth);
	static float sinc(float x);							// sin(x) / x
	static float lanczos(float x, float fHalfWidth);	// sinc windowed sinc
	static float hamming(float x, float fHalfWidth);	// hamming-windowed sinc
};

//////////////////////////////////////////////////////////////////////
// Use filter coefficients to resample from higher resolution
// pTextureSrc to lower resolution pSurfaceDst.
// The width of Src must be m_nSuperSample * width of Dst and
// the height of Src must be m_nSuperSample * height of Dst.
// The scratch texture must be swizzled and have width >= Src and height >= Src
// If either pTextureScratchY or pTextureScratchX are NULL, temporary
// textures will be created and then released when done.
//
HRESULT Decimate(LPDIRECT3DSURFACE8 pSurfaceDst,
				 LPDIRECT3DTEXTURE8 pTextureSrc,
				 UINT iSourceLevel,	// index of source miplevel in pTextureSrc
				 D3DTEXTUREADDRESS WrapU = D3DTADDRESS_WRAP, 
				 D3DTEXTUREADDRESS WrapV = D3DTADDRESS_WRAP,
				 LPDIRECT3DTEXTURE8 pTextureScratchY = NULL,	// destination for filtering in Y
				 LPDIRECT3DTEXTURE8 pTextureScratchX = NULL,	// destination for filtering in X
				 MipmapFilter *pFilter = NULL);

//////////////////////////////////////////////////////////////////////
// Compute mipmaps starting from iSourceLevel
// The scratch textures must be swizzled and have width >= Src and height >= Src
// If either pTextureScratchY or pTextureScratchX are NULL, temporary
// textures will be created and then released when done.
// The filter must have nSuperSample = 2.
//
HRESULT GenerateMipmaps(LPDIRECT3DTEXTURE8 pTexture,
						UINT iSourceLevel,
						D3DTEXTUREADDRESS WrapU = D3DTADDRESS_WRAP, 
						D3DTEXTUREADDRESS WrapV = D3DTADDRESS_WRAP,
						LPDIRECT3DTEXTURE8 pTextureScratchY = NULL,
						LPDIRECT3DTEXTURE8 pTextureScratchX = NULL,
						MipmapFilter *pFilter = NULL);

//////////////////////////////////////////////////////////////////////
// Create a new texture the same size as the source texture, with the
// same number of mipmap levels, and then copy the source to the
// destination, with a format change.  This function handles swizzled and
// unswizzled textures.
//
HRESULT CompressTexture(LPDIRECT3DTEXTURE8 *ppTextureDst, D3DFORMAT fmtNew, LPDIRECT3DTEXTURE8 pTextureSrc);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\fur\OctoSphere.h ===
//-----------------------------------------------------------------------------
//  
//  File: OctoSphere.h
//  Copyright (C) 2001 Microsoft Corporation
//  All rights reserved.
//  
//-----------------------------------------------------------------------------
#ifdef _XBOX
#include <xtl.h>
#endif
#include <d3dx8.h>
 
extern LPDIRECT3DDEVICE8 g_pd3dDevice;

//-----------------------------------------------------------------------------
// Name: FillOctoSphere
// Desc: Create a sphere by sampling the faces of an octohedron and renormalizing.
//       Pass NULL pointers to aVertex or aIndex to return needed sizes of buffers.
//-----------------------------------------------------------------------------
HRESULT FillOctoSphere(UINT nSplit, // number of splits on each edge, 0 = octohedron
					  UINT *pnVertex, D3DXVECTOR3 *rVertex, // vertices
					  UINT *pnIndex, WORD *rIndex); // triangle indices

//-----------------------------------------------------------------------------
// Name: OctoSphere
// Desc: Wrapper to handle creation of vertex and index buffers.
//-----------------------------------------------------------------------------
struct OctoSphere { // octohedron sphere
	UINT m_nVertex;
	LPDIRECT3DVERTEXBUFFER8  m_pVB;
	UINT m_nIndex;
	LPDIRECT3DINDEXBUFFER8  m_pIB;

	~OctoSphere()
	{
		Cleanup();
	}
	
	void Cleanup()
	{
		if (m_pIB)
		{
			m_pIB->Release();
			m_pIB = NULL;
		}
		if (m_pVB)
		{
			m_pVB->Release();
			m_pVB = NULL;
		}
	}
	
	HRESULT Initialize(UINT nSplit)
	{
		HRESULT hr;
		DWORD dwUsage = 0;
		hr = FillOctoSphere(nSplit, &m_nVertex, NULL, &m_nIndex, NULL); // get needed size of buffers
		if (FAILED(hr))
			return hr;
		hr = g_pd3dDevice->CreateVertexBuffer(m_nVertex * sizeof(float) * 3, dwUsage, D3DFVF_XYZ, D3DPOOL_MANAGED, &m_pVB);
		if (FAILED(hr))
			return hr;
		hr = g_pd3dDevice->CreateIndexBuffer(m_nIndex * sizeof(WORD), dwUsage, D3DFMT_INDEX16, D3DPOOL_MANAGED, &m_pIB);
		if (FAILED(hr))
			return hr;
		D3DXVECTOR3 *pVertex;
		hr = m_pVB->Lock(0, m_nVertex * sizeof(float) * 3, (BYTE **)&pVertex, 0);
		if (FAILED(hr))
			return hr;
		WORD *pIndex;
		hr = m_pIB->Lock(0, m_nIndex * sizeof(WORD), (BYTE **)&pIndex, 0);
		if (FAILED(hr))
		{
			m_pVB->Unlock();
			return hr;
		}
		hr = FillOctoSphere(nSplit, &m_nVertex, pVertex, &m_nIndex, pIndex); // fill in buffers
		m_pIB->Unlock();
		m_pVB->Unlock();
		if (FAILED(hr))
			return hr;
		return S_OK;
	}

	HRESULT Draw()
	{
		g_pd3dDevice->SetVertexShader(D3DFVF_XYZ);
		g_pd3dDevice->SetStreamSource(0, m_pVB, sizeof(float) * 3);
		g_pd3dDevice->SetIndices(m_pIB, 0);
		g_pd3dDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 0, m_nVertex, 0, m_nIndex/3);
		return S_OK;
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\fur\Mipmap.inl ===
// Xbox Shader Assembler 1.00.4030.1
D3DPIXELSHADERDEF psd;
ZeroMemory(&psd, sizeof(psd));
psd.PSCombinerCount=PS_COMBINERCOUNT(
    8,
    PS_COMBINERCOUNT_MUX_MSB | PS_COMBINERCOUNT_UNIQUE_C0 | PS_COMBINERCOUNT_UNIQUE_C1);
psd.PSTextureModes=PS_TEXTUREMODES(
    PS_TEXTUREMODES_PROJECT2D,
    PS_TEXTUREMODES_PROJECT2D,
    PS_TEXTUREMODES_PROJECT2D,
    PS_TEXTUREMODES_PROJECT2D);
psd.PSInputTexture=PS_INPUTTEXTURE(0,0,0,0);
psd.PSDotMapping=PS_DOTMAPPING(
    0,
    PS_DOTMAPPING_ZERO_TO_ONE,
    PS_DOTMAPPING_ZERO_TO_ONE,
    PS_DOTMAPPING_ZERO_TO_ONE);
psd.PSCompareMode=PS_COMPAREMODE(
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT);

//------------- Stage 0 -------------
psd.PSRGBInputs[0]=PS_COMBINERINPUTS(
    PS_REGISTER_T0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_C0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
psd.PSAlphaInputs[0]=PS_COMBINERINPUTS(
    PS_REGISTER_T0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_C0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
psd.PSRGBOutputs[0]=PS_COMBINEROUTPUTS(
    PS_REGISTER_R0,
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[0]=PS_COMBINEROUTPUTS(
    PS_REGISTER_R0,
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[0] = 0x40404040;
psd.PSConstant1[0] = 0x00000000;

//------------- Stage 1 -------------
psd.PSRGBInputs[1]=PS_COMBINERINPUTS(
    PS_REGISTER_T1 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_C0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_R0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSAlphaInputs[1]=PS_COMBINERINPUTS(
    PS_REGISTER_T1 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_C0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_R0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSRGBOutputs[1]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[1]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[1] = 0x40404040;
psd.PSConstant1[1] = 0x00000000;

//------------- Stage 2 -------------
psd.PSRGBInputs[2]=PS_COMBINERINPUTS(
    PS_REGISTER_T2 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_C0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_R0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSAlphaInputs[2]=PS_COMBINERINPUTS(
    PS_REGISTER_T2 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_C0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_R0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSRGBOutputs[2]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[2]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[2] = 0x40404040;
psd.PSConstant1[2] = 0x00000000;

//------------- Stage 3 -------------
psd.PSRGBInputs[3]=PS_COMBINERINPUTS(
    PS_REGISTER_T3 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_C0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_R0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSAlphaInputs[3]=PS_COMBINERINPUTS(
    PS_REGISTER_T3 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_C0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_R0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSRGBOutputs[3]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[3]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[3] = 0x40404040;
psd.PSConstant1[3] = 0x00000000;

//------------- Stage 4 -------------
psd.PSRGBInputs[4]=PS_COMBINERINPUTS(
    PS_REGISTER_T0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_C0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_NEGATE,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_R0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSAlphaInputs[4]=PS_COMBINERINPUTS(
    PS_REGISTER_T0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_C0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_NEGATE,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_R0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSRGBOutputs[4]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[4]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[4] = 0x00000000;
psd.PSConstant1[4] = 0x00000000;

//------------- Stage 5 -------------
psd.PSRGBInputs[5]=PS_COMBINERINPUTS(
    PS_REGISTER_T1 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_C0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_NEGATE,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_R0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSAlphaInputs[5]=PS_COMBINERINPUTS(
    PS_REGISTER_T1 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_C0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_NEGATE,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_R0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSRGBOutputs[5]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[5]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[5] = 0x00000000;
psd.PSConstant1[5] = 0x00000000;

//------------- Stage 6 -------------
psd.PSRGBInputs[6]=PS_COMBINERINPUTS(
    PS_REGISTER_T2 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_C0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_NEGATE,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_R0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSAlphaInputs[6]=PS_COMBINERINPUTS(
    PS_REGISTER_T2 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_C0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_NEGATE,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_R0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSRGBOutputs[6]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[6]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[6] = 0x00000000;
psd.PSConstant1[6] = 0x00000000;

//------------- Stage 7 -------------
psd.PSRGBInputs[7]=PS_COMBINERINPUTS(
    PS_REGISTER_T3 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_C0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_NEGATE,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_R0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSAlphaInputs[7]=PS_COMBINERINPUTS(
    PS_REGISTER_T3 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_C0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_NEGATE,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_R0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSRGBOutputs[7]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[7]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[7] = 0x00000000;
psd.PSConstant1[7] = 0x00000000;

psd.PSC0Mapping = 0x76543210;
psd.PSC1Mapping = 0xffffffff;
psd.PSFinalCombinerConstants = 0x000001ff;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\fur\util.h ===
//-----------------------------------------------------------------------------
// File: util.h
// Desc: Handy utility functions
// Copyright (c) 2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>

//-----------------------------------------------------------------------------
//  Find the bounding sphere for an array of vertices
//-----------------------------------------------------------------------------
void UnionSphere(D3DXVECTOR3 *pvCenter, float *pfRadius, const D3DXVECTOR3 &vCenter, const float &fRadius);
HRESULT ComputeBoundingSphere(
        PVOID pPointsFVF, 
        DWORD NumVertices, 
        DWORD FVF,
        D3DXVECTOR3 *pvCenter, 
        FLOAT *pfRadius);

//-----------------------------------------------------------------------------
//  Find the bounding box for an array of vertices
//-----------------------------------------------------------------------------
HRESULT ComputeBoundingBox( PVOID pPoints,
							DWORD VertexCount,
							DWORD VertexSize,
							const D3DXMATRIX *pMatrix,	// may be NULL
							D3DXVECTOR3 *pvMin,
							D3DXVECTOR3 *pvMax );

//-----------------------------------------------------------------------------
// Set state and restore on scope exit
//-----------------------------------------------------------------------------
#define SET_D3DTSS(STAGE, NAME, VALUE)\
	struct _D3DTSS_STAGE##STAGE##_##NAME {\
 		DWORD dw; \
		 _D3DTSS_STAGE##STAGE##_##NAME() { /* constructor is called to save current value and set new value */ \
 			g_pd3dDevice->GetTextureStageState(STAGE, NAME, &dw);\
			g_pd3dDevice->SetTextureStageState(STAGE, NAME, VALUE);\
		}\
		 ~_D3DTSS_STAGE##STAGE##_##NAME() { /* on scope exit, saved value is restored */ \
			 g_pd3dDevice->SetTextureStageState(STAGE, NAME, dw);\
		}\
	} __D3DTSS_STAGE##STAGE##_##NAME
#define SET_D3DTEXTURE(STAGE, TEXTURE)\
	struct _D3DTEXTURE_STAGE##STAGE {\
 		D3DBaseTexture *__pTexture; \
		 _D3DTEXTURE_STAGE##STAGE(D3DBaseTexture *pTexture) { /* constructor is called to save current value and set new value */ \
 			g_pd3dDevice->GetTexture(STAGE, &__pTexture);\
			g_pd3dDevice->SetTexture(STAGE, pTexture);\
		}\
		 ~_D3DTEXTURE_STAGE##STAGE() { /* on scope exit, saved value is restored */ \
			 g_pd3dDevice->SetTexture(STAGE, __pTexture);\
			 if (__pTexture != NULL) __pTexture->Release();\
		}\
	} __D3DTEXTURE_STAGE##STAGE(TEXTURE)
#define SET_D3DRS(NAME, VALUE)\
	struct _D3DRS_##NAME {\
 		DWORD dw; \
		 _D3DRS_##NAME() { /* constructor is called to save current value and set new value */ \
 			g_pd3dDevice->GetRenderState(NAME, &dw);\
			g_pd3dDevice->SetRenderState(NAME, VALUE);\
		}\
		 ~_D3DRS_##NAME() { /* on scope exit, saved value is restored */ \
			 g_pd3dDevice->SetRenderState(NAME, dw);\
		}\
	} __D3DRS_##NAME
#define SET_D3DVS(VALUE)\
	struct _D3DVS {\
 		DWORD dw; \
		 _D3DVS() { /* constructor is called to save current value and set new value */ \
 			g_pd3dDevice->GetVertexShader(&dw);\
			g_pd3dDevice->SetVertexShader(VALUE);\
		}\
		 ~_D3DVS() { /* on scope exit, saved value is restored */ \
			 g_pd3dDevice->SetVertexShader(dw);\
		}\
	} __D3DVS
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\fur\util.cpp ===
//-----------------------------------------------------------------------------
// File: util.cpp
// Desc: Handy utility functions
// Copyright (c) 2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "util.h"
#include <tchar.h>

extern LPDIRECT3DDEVICE8 g_pd3dDevice;

inline float MAX(float a, float b) { return a > b ? a : b; }
inline float MIN(float a, float b) { return a < b ? a : b; }

//-----------------------------------------------------------------------------
//  Take the union of two boxes
//-----------------------------------------------------------------------------
static void UnionBox(D3DXVECTOR3 *pvMin, D3DXVECTOR3 *pvMax, const D3DXVECTOR3 &vMin, const D3DXVECTOR3 &vMax)
{
	pvMin->x = MIN(pvMin->x, vMin.x);
	pvMin->y = MIN(pvMin->y, vMin.y);
	pvMin->z = MIN(pvMin->z, vMin.z);
	pvMax->x = MAX(pvMax->x, vMax.x);
	pvMax->y = MAX(pvMax->y, vMax.y);
	pvMax->z = MAX(pvMax->z, vMax.z);
}

//-----------------------------------------------------------------------------
//  Find the bounding box for the vertices
//-----------------------------------------------------------------------------
HRESULT ComputeBoundingBox( PVOID pPoints,
							DWORD VertexCount,
							DWORD VertexSize,
							const D3DXMATRIX *pMatrix,
							D3DXVECTOR3 *pvMin,
							D3DXVECTOR3 *pvMax )
{
	// initialize bounds to be reset on the first point
	pvMin->x = pvMin->y = pvMin->z = FLT_MAX;
	pvMax->x = pvMax->y = pvMax->z = -FLT_MAX;

	// walk through all the points, expanding the bbox as needed
    BYTE*       pVertices = (BYTE *)pPoints;
    D3DXVECTOR3 vPos;
	if (pMatrix != NULL)
	{
		while( VertexCount-- )
		{
			D3DXVec3TransformCoord( &vPos, (D3DXVECTOR3*)pVertices, pMatrix );
			UnionBox(pvMin, pvMax, vPos, vPos);	// expand the bounding box to include the point
			pVertices += VertexSize;
		}
	}
	else
	{
		while( VertexCount-- )
		{
			UnionBox(pvMin, pvMax, *(D3DXVECTOR3*)pVertices, *(D3DXVECTOR3*)pVertices);	// expand the bounding box to include the point
			pVertices += VertexSize;
		}
	}
    return S_OK;
}

//-----------------------------------------------------------------------------
//  Take the union of two spheres
//-----------------------------------------------------------------------------
void UnionSphere(D3DXVECTOR3 *pvCenter, float *pfRadius, 
				 const D3DXVECTOR3 &vCenter, const float &fRadius)
{
	D3DXVECTOR3 v =  vCenter - *pvCenter;
	float vlen = D3DXVec3Length(&v);
	float a = MIN(-*pfRadius, vlen - fRadius);
	float b = MAX(*pfRadius, vlen + fRadius);
	*pfRadius = 0.5f * (b - a);
	*pvCenter += (0.5f * (b + a) / vlen) * v;
}

//-----------------------------------------------------------------------------
//  Find the bounding sphere for the vertices
//-----------------------------------------------------------------------------
HRESULT ComputeBoundingSphere(
        PVOID pPointsFVF, 
        DWORD NumVertices, 
        DWORD FVF,
        D3DXVECTOR3 *pvCenter, 
        FLOAT *pfRadius)
{
	if (NumVertices == 0)
	{
		pvCenter->x = pvCenter->y = pvCenter->z = 0.f;
		*pfRadius = 0;
		return S_FALSE;
	}
	UINT cbVertexSize = D3DXGetFVFVertexSize(FVF);
	// use first vertex as starting point
	float feps = 1e-6f;  // use a small epsilon as zero radius
	*pvCenter = *(D3DXVECTOR3 *)pPointsFVF;
	*pfRadius = feps;
	// union in the rest of the points as zero-radius spheres
	for (UINT iVertex = 1; iVertex < NumVertices; iVertex++)
		UnionSphere(pvCenter, pfRadius, *(D3DXVECTOR3 *)((BYTE *)pPointsFVF + cbVertexSize * iVertex), feps);
	return S_OK;
}

//-----------------------------------------------------------------------------
// Draw hedgehog normals
//-----------------------------------------------------------------------------
HRESULT DrawNormalsOffset(LPDIRECT3DVERTEXBUFFER8 pVB, DWORD nVertex, DWORD cbVertexSize, DWORD cbPositionOffset, DWORD cbNormalOffset, float fNormalScale)
{
	HRESULT hr = S_OK;
	const UINT nLineBuf = 200;
	struct Vertex {
		float x, y, z;
		D3DCOLOR diffuse;
	} aVertex[nLineBuf*2];
	Vertex *pVertex = &aVertex[0];
	BYTE *pVertexSrc = NULL;
	UINT nLine = 0;
	D3DCOLOR color0 = D3DCOLOR_RGBA(0x00, 0xff, 0x00, 0xff);
	D3DCOLOR color1 = D3DCOLOR_RGBA(0x00, 0xff, 0xff, 0xff);
	SET_D3DRS( D3DRS_ZFUNC, D3DCMP_LESSEQUAL);
	SET_D3DRS( D3DRS_ZWRITEENABLE, TRUE);
	SET_D3DRS( D3DRS_ALPHATESTENABLE, FALSE);
	SET_D3DRS( D3DRS_NORMALIZENORMALS, FALSE);
	SET_D3DRS( D3DRS_ALPHABLENDENABLE, FALSE );
	SET_D3DRS( D3DRS_LIGHTING, FALSE);
	SET_D3DVS(D3DFVF_XYZ | D3DFVF_DIFFUSE);
	SET_D3DTEXTURE( 0, NULL);
	SET_D3DTSS( 0, D3DTSS_COLOROP, D3DTOP_SELECTARG1 );
	SET_D3DTSS( 0,D3DTSS_COLORARG1, D3DTA_DIFFUSE );
	SET_D3DTSS( 0,D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
	SET_D3DTSS( 0,D3DTSS_ALPHAARG1, D3DTA_DIFFUSE );
	SET_D3DTSS( 0,D3DTSS_ALPHAKILL, D3DTALPHAKILL_DISABLE );
	SET_D3DTEXTURE( 1, NULL);
	SET_D3DTSS( 1,D3DTSS_COLOROP, D3DTOP_DISABLE );
	SET_D3DTSS( 1,D3DTSS_ALPHAOP, D3DTOP_DISABLE);
	SET_D3DTSS( 1,D3DTSS_ALPHAKILL, D3DTALPHAKILL_DISABLE );
	SET_D3DTEXTURE( 2, NULL);
	SET_D3DTSS( 2, D3DTSS_COLOROP, D3DTOP_DISABLE );
	SET_D3DTSS( 2, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
	SET_D3DTSS( 2, D3DTSS_ALPHAKILL, D3DTALPHAKILL_DISABLE );
	SET_D3DTEXTURE( 3, NULL);
	SET_D3DTSS( 3, D3DTSS_COLOROP, D3DTOP_DISABLE );
	SET_D3DTSS( 3, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
	SET_D3DTSS( 3, D3DTSS_ALPHAKILL, D3DTALPHAKILL_DISABLE );
	hr = pVB->Lock(NULL, NULL, (BYTE **)&pVertexSrc, 0l );
	if (FAILED(hr))
		return hr;
	for (UINT iVertex = 0; iVertex < nVertex; iVertex++)
	{
		float *pfPosition = (float *)(pVertexSrc + cbVertexSize * iVertex + cbPositionOffset);
		float *pfNormal = (float *)(pVertexSrc + cbVertexSize * iVertex + cbNormalOffset);
		pVertex[0].x = pfPosition[0];
		pVertex[0].y = pfPosition[1];
		pVertex[0].z = pfPosition[2];
		pVertex[0].diffuse = color0;
		pVertex[1].x = pVertex[0].x + pfNormal[0] * fNormalScale;
		pVertex[1].y = pVertex[0].y + pfNormal[1] * fNormalScale;
		pVertex[1].z = pVertex[0].z + pfNormal[2] * fNormalScale;
		pVertex[1].diffuse = color1;
		pVertex += 2;
		nLine++;
		if (nLine == nLineBuf)
		{
			// buffer is full, so draw what we have
			hr = g_pd3dDevice->DrawPrimitiveUP(D3DPT_LINELIST, nLine, aVertex, sizeof(Vertex));
			if (FAILED(hr))
				goto e_Exit;
			nLine = 0;
			pVertex = &aVertex[0];
		}
	}
	if (nLine != 0)
	{
		// draw any left over lines
		hr = g_pd3dDevice->DrawPrimitiveUP(D3DPT_LINELIST, nLine, aVertex, sizeof(Vertex));
		if (FAILED(hr))
			goto e_Exit;
	}
e_Exit:
	if (pVertexSrc)
		pVB->Unlock();
	return hr;
}

HRESULT DrawNormals(LPDIRECT3DVERTEXBUFFER8 pVB, DWORD nVertex, DWORD dwFVF, float fNormalScale)
{
	if (!((dwFVF & D3DFVF_XYZ) && (dwFVF & D3DFVF_NORMAL)))
		return S_FALSE; // no normals to draw
	UINT cbVertexSize = D3DXGetFVFVertexSize(dwFVF);
	return DrawNormalsOffset(pVB, nVertex, cbVertexSize, 0 /* position offset */, 12 /* normal offset */, fNormalScale);
}

//-----------------------------------------------------------------------------
//  Draw coordinate axes.
//-----------------------------------------------------------------------------
HRESULT DrawAxes()
{
	const float fAxisRodRadius = 0.05f;
	const float fAxisRodLength = 0.8f;
	const float fAxisConeRadius = fAxisRodRadius * 3.f;
	const float fAxisConeLength = 1.f;
	static struct AxisVertex {
		float x, y, z;
		D3DCOLOR color;
	} XAxis[] = {
		{ 0.f,             0.f,				 0.f }, 
		{ fAxisRodLength,  fAxisRodRadius,   0.f }, 
		{ fAxisRodLength,  fAxisConeRadius,  0.f }, 
		{ fAxisConeLength, 0.f,              0.f }, 
		{ fAxisRodLength,  0.f,              fAxisConeRadius }, 
		{ fAxisRodLength,  0.f,              fAxisRodRadius }, 
		{ 0.f,             0.f,              0.f },
		{ fAxisConeLength, 0.f,              0.f }, 
	};
	const int nVertex = sizeof(XAxis)/sizeof(AxisVertex);
	static AxisVertex YAxis[nVertex];
	static AxisVertex ZAxis[nVertex];
	static bool bInitialized = false;
	if (!bInitialized)
	{
		const D3DCOLOR XColor = 0xffff0000;
		const D3DCOLOR YColor = 0xff00ff00;
		const D3DCOLOR ZColor = 0xff0000ff;
		for (UINT i = 0; i < nVertex; i++)
		{
			XAxis[i].color = XColor;
			YAxis[i].x = XAxis[i].y; YAxis[i].y = XAxis[i].x; YAxis[i].z = XAxis[i].z; // swap x and y
			YAxis[i].color = YColor;
			ZAxis[i].x = XAxis[i].z; ZAxis[i].y = XAxis[i].y; ZAxis[i].z = XAxis[i].x; // swap x and z
			ZAxis[i].color = ZColor;
		}
		bInitialized = true;
	}
	
	// set and save state
	SET_D3DRS(D3DRS_LIGHTING, FALSE);
	SET_D3DRS(D3DRS_EMISSIVEMATERIALSOURCE, D3DMCS_COLOR1);
	SET_D3DVS(D3DFVF_XYZ|D3DFVF_DIFFUSE); // vertex shader
	SET_D3DTEXTURE( 0, NULL);
	SET_D3DTSS( 0, D3DTSS_COLOROP, D3DTOP_SELECTARG1 );
	SET_D3DTSS( 0,D3DTSS_COLORARG1, D3DTA_DIFFUSE );
	SET_D3DTSS( 0,D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
	SET_D3DTSS( 0,D3DTSS_ALPHAARG1, D3DTA_DIFFUSE );
	SET_D3DTSS( 0,D3DTSS_ALPHAKILL, D3DTALPHAKILL_DISABLE );
	SET_D3DTEXTURE( 1, NULL);
	SET_D3DTSS( 1,D3DTSS_COLOROP, D3DTOP_DISABLE );
	SET_D3DTSS( 1,D3DTSS_ALPHAOP, D3DTOP_DISABLE);
	SET_D3DTSS( 1,D3DTSS_ALPHAKILL, D3DTALPHAKILL_DISABLE );
	SET_D3DTEXTURE( 2, NULL);
	SET_D3DTSS( 2, D3DTSS_COLOROP, D3DTOP_DISABLE );
	SET_D3DTSS( 2, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
	SET_D3DTSS( 2, D3DTSS_ALPHAKILL, D3DTALPHAKILL_DISABLE );
	SET_D3DTEXTURE( 3, NULL);
	SET_D3DTSS( 3, D3DTSS_COLOROP, D3DTOP_DISABLE );
	SET_D3DTSS( 3, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
	SET_D3DTSS( 3, D3DTSS_ALPHAKILL, D3DTALPHAKILL_DISABLE );

	// draw the axes
	g_pd3dDevice->DrawPrimitiveUP(D3DPT_LINESTRIP, nVertex - 1, XAxis, sizeof(AxisVertex));
	g_pd3dDevice->DrawPrimitiveUP(D3DPT_LINESTRIP, nVertex - 1, YAxis, sizeof(AxisVertex));
	g_pd3dDevice->DrawPrimitiveUP(D3DPT_LINESTRIP, nVertex - 1, ZAxis, sizeof(AxisVertex));	
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\fur\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\fur\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\FuzzyTeapot\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\fur\XBFur.cpp ===
//-----------------------------------------------------------------------------
// File: XBFur.cpp
//
// Desc: routines for generating and displaying a patch of fur,
//       which is a series of layers that give the appearance of
//       hair, fur, grass, or other fuzzy things.
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <assert.h>
#include <stdlib.h>
#include <stdio.h>

#ifdef _XBOX
#include <xtl.h>
#include <xgraphics.h>
#else
#include <d3d8.h>
#endif
#include "XBUtil.h"
#include "XBFur.h"
#include "mipmap.h"

extern LPDIRECT3DDEVICE8 g_pd3dDevice;

#define irand(a) ((rand()*(a))>>15)
#define frand(a) ((float)rand()*(a)/32768.0f)

float g_fOneInch = 0.01f;

//-----------------------------------------------------------------------------
// Name: Constructor
// Desc: 
//-----------------------------------------------------------------------------
CXBFur::CXBFur()
{
	DWORD i;
	ZeroMemory(this, sizeof(CXBFur));

	// init default patch
	m_fXSize = 0.1f;
	m_fZSize = 0.1f;

	// init default fuzzlib
	m_dwNumFuzzLib = 0;
	m_pFuzzLib = NULL;
	m_fuzzCenter.colorBase = D3DXCOLOR(1.f, 1.f, 1.f, 1.f);
	m_fuzzCenter.colorTip = D3DXCOLOR(1.f, 1.f, 1.f, 0.f);
	m_fuzzCenter.dp.y = 1.0f;

	// init default fuzz
	m_dwNumSegments = 4;
	m_pFuzz = NULL;

	// init default volume
	m_dwNumSlices = 0;
	m_dwSliceXSize = 0;
	m_dwSliceZSize = 0;
	for(i=0; i<XBFUR_MAXSLICE*2-1; i++)
		m_apSliceTexture[i] = NULL;
	m_pHairLightingTexture = NULL;
	m_pFinTexture = NULL;
	m_dwNumSlicesLOD = 0;
	m_pSliceTextureLOD = m_apSliceTexture;
	
	InitFuzz(1, 1);
}

//-----------------------------------------------------------------------------
// Name: Destructor
// Desc: 
//-----------------------------------------------------------------------------
CXBFur::~CXBFur()
{
	DWORD i;
	if(m_pFuzzLib)
		delete m_pFuzzLib;
	if(m_pFuzz)
		delete m_pFuzz;
	for(i=0; i<XBFUR_MAXSLICE*2-1; i++)
		SAFE_RELEASE(m_apSliceTexture[i]);
	SAFE_RELEASE(m_pHairLightingTexture);
}

//-----------------------------------------------------------------------------
// Name: InitFuzz
// Desc: Initializes the individual strands of fuzz in the patch.
//       Only a small number of individual fuzzes are generated
//       (determined by m_dwNumFuzzLib) because each one in the patch
//       does not need to be unique.
//-----------------------------------------------------------------------------
void CXBFur::InitFuzz(DWORD nfuzz, DWORD nfuzzlib)
{
	DWORD i;
	float y;

	if(nfuzz<=0 || nfuzzlib<0)
		return;
		
	// handle memory allocation
	if(m_dwNumFuzz!=nfuzz)				// if nfuzz has changed
	{
		if(m_pFuzz)
			delete m_pFuzz;				// nuke existing
		m_pFuzz = new FuzzInst[nfuzz];	// and get new fuzz memory
	}

	if(m_dwNumFuzzLib!=nfuzzlib)
	{
		if(m_pFuzzLib)
			delete m_pFuzzLib;

		m_pFuzzLib = new Fuzz[nfuzzlib];
	}

	m_dwNumFuzz = nfuzz;
	m_dwNumFuzzLib = nfuzzlib;

	// generate the individual fuzzes in the library
	m_fYSize = 0.0f;
	srand(m_dwSeed);
	for(i=0; i<m_dwNumFuzzLib; i++)
	{
		m_pFuzzLib[i].dp.x = (m_fuzzCenter.dp.x + m_fuzzRandom.dp.x*(2*frand(1.0f)-1.0f))*g_fOneInch;
		m_pFuzzLib[i].dp.y = (m_fuzzCenter.dp.y + m_fuzzRandom.dp.y*(2*frand(1.0f)-1.0f))*g_fOneInch;
		m_pFuzzLib[i].dp.z = (m_fuzzCenter.dp.z + m_fuzzRandom.dp.z*(2*frand(1.0f)-1.0f))*g_fOneInch;

		m_pFuzzLib[i].ddp.x = (m_fuzzCenter.ddp.x + m_fuzzRandom.ddp.x*(2*frand(1.0f)-1.0f))*g_fOneInch;
		m_pFuzzLib[i].ddp.y = (m_fuzzCenter.ddp.y + m_fuzzRandom.ddp.y*(2*frand(1.0f)-1.0f))*g_fOneInch;
		m_pFuzzLib[i].ddp.z = (m_fuzzCenter.ddp.z + m_fuzzRandom.ddp.z*(2*frand(1.0f)-1.0f))*g_fOneInch;

		m_pFuzzLib[i].colorBase = m_fuzzCenter.colorBase + (2*frand(1.f)-1.f)*m_fuzzRandom.colorBase;
		m_pFuzzLib[i].colorTip = m_fuzzCenter.colorTip + (2*frand(1.f)-1.f)*m_fuzzRandom.colorTip;

		y = m_pFuzzLib[i].dp.y + 0.5f*m_pFuzzLib[i].ddp.y;
		if(y>m_fYSize)
			m_fYSize = y;
	}

 	// initialize the fuzz locations & pick a random fuzz from the library
	srand(m_dwSeed*54795);
	for(i=0; i<m_dwNumFuzz; i++)
	{
		m_pFuzz[i].x = (frand(1.0f)-0.5f)*m_fXSize;
		m_pFuzz[i].z = (frand(1.0f)-0.5f)*m_fZSize;
		m_pFuzz[i].lidx = irand(m_dwNumFuzzLib);
	}
}

//-----------------------------------------------------------------------------
// Name: GenSlices
// Desc: Generate the fuzz volume by rendering the geometry repeatedly
//       with different z-clip ranges.
//-----------------------------------------------------------------------------
void CXBFur::GenSlices(DWORD nslices, DWORD slicexsize, DWORD slicezsize)
{
	assert(nslices <= XBFUR_MAXSLICE);
	
	// Check the format of the textures
	bool bFormatOK = true;
	if (m_dwNumSlices > 0)
	{
		D3DSURFACE_DESC desc;
		m_apSliceTexture[0]->GetLevelDesc(0, &desc);
		if (desc.Format != D3DFMT_A8R8G8B8)
			bFormatOK = false;
	}

	// make sure volume info is up to date
	if(m_dwSliceXSize!=slicexsize 
	   || m_dwSliceZSize!=slicezsize
	   || !bFormatOK)
	{
		m_dwNumSlices = 0;
		m_dwNumSlicesLOD = 0;
		for(UINT i=0; i<XBFUR_MAXSLICE*2-1; i++)
			SAFE_RELEASE(m_apSliceTexture[i]);
	}

	m_dwSliceXSize = slicexsize;
	m_dwSliceZSize = slicezsize;
	m_dwSliceSize = slicexsize*slicezsize;

	// create textures if necessary
	if(m_dwNumSlices!=nslices)
	{
		UINT i;
		// count number of level-of-detail layers needed
		UINT nLOD = 0;
		for (i = 1; (1u << i) <= nslices; i++)
			nLOD += nslices >> i;
		m_dwLODMax = i - 1;

		// create new layers and level-of-detail layers
		for(i=0; i<nslices+nLOD; i++)
			if(!m_apSliceTexture[i])
				g_pd3dDevice->CreateTexture(slicexsize, slicezsize, 0, 0, D3DFMT_A8R8G8B8, 0, &m_apSliceTexture[i]);
			
		// release unused layers
		for(i=nslices+nLOD; i<XBFUR_MAXSLICE*2-1; i++)
			SAFE_RELEASE(m_apSliceTexture[i]);

	}
	m_dwNumSlices = nslices;

	// save current back buffer, z buffer, and transforms
	struct {
		IDirect3DSurface8 *pBackBuffer, *pZBuffer;
		D3DMATRIX matWorld, matView, matProjection;
	} save;
	g_pd3dDevice->GetRenderTarget(&save.pBackBuffer);
	g_pd3dDevice->GetDepthStencilSurface(&save.pZBuffer);
	g_pd3dDevice->GetTransform( D3DTS_WORLD, &save.matWorld);
	g_pd3dDevice->GetTransform( D3DTS_VIEW, &save.matView);
	g_pd3dDevice->GetTransform( D3DTS_PROJECTION, &save.matProjection);
		
	// make a new depth buffer
	IDirect3DSurface8 *pZBuffer = NULL;
	g_pd3dDevice->CreateDepthStencilSurface(slicexsize, slicezsize, D3DFMT_LIN_D24S8, D3DMULTISAMPLE_NONE, &pZBuffer);
	D3DXVECTOR3 va(-0.5f*m_fXSize, 0.f, -0.5f*m_fZSize), vb(0.5f*m_fXSize, m_fYSize, 0.5f*m_fZSize); // bounds of fuzz patch
	D3DXVECTOR3 vwidth(vb-va), vcenter(0.5f*(vb+va)); // width and center of fuzz patch
		
	// set world transformation to scale model to unit cube [-1,1] in all dimensions
	D3DXMATRIX matWorld, matTranslate, matScale;
	D3DXMatrixTranslation(&matTranslate, -vcenter.x, -vcenter.y, -vcenter.z);
	D3DXMatrixScaling(&matScale, 2.f/vwidth.x, 2.f/vwidth.y, 2.f/vwidth.z);
	matWorld = matTranslate * matScale;
	g_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld);
		
	// set view transformation to flip z and look down y axis, with bottom-most slice scaled and translated to map to [0,1]
	D3DMATRIX matView;
	matView.m[0][0] = 1.f;	matView.m[0][1] =  0.f;	matView.m[0][2] = 0.f;				matView.m[0][3] = 0.f;
	matView.m[1][0] = 0.f;	matView.m[1][1] =  0.f;	matView.m[1][2] = 0.5f * nslices;	matView.m[1][3] = 0.f;
	matView.m[2][0] = 0.f;	matView.m[2][1] = -1.f;	matView.m[2][2] = 0.f;				matView.m[2][3] = 0.f;
	matView.m[3][0] = 0.f;	matView.m[3][1] =  0.f;	matView.m[3][2] = 0.5f * nslices;	matView.m[3][3] = 1.f;
		
	// set projection matrix to orthographic
	D3DXMATRIX matProjection;
	D3DXMatrixIdentity(&matProjection);
	g_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProjection);
	UINT numLines = m_dwNumFuzz*m_dwNumSegments;
	IDirect3DVertexBuffer8 *pVB;
	GetLinesVertexBuffer(&pVB);
	g_pd3dDevice->SetTexture(0, NULL);
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_DIFFUSE);
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_DIFFUSE);
	g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_ONE); // premultiplied alpha
	g_pd3dDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
	g_pd3dDevice->SetRenderState(D3DRS_ZWRITEENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_EMISSIVEMATERIALSOURCE, D3DMCS_COLOR1);
	g_pd3dDevice->SetRenderState(D3DRS_LIGHTING, FALSE);

	g_pd3dDevice->SetVertexShader(FVF_XYZDIFF);
	g_pd3dDevice->SetStreamSource(0, pVB, sizeof(FVFT_XYZDIFF));
		
	// draw each slice
	for (int i = 0; i < (int)nslices; i++)
	{
		// get destination surface & set as render target, then draw the fuzz slice
		LPDIRECT3DTEXTURE8 pTexture = m_apSliceTexture[i];
		IDirect3DSurface8 *pSurface;
		pTexture->GetSurfaceLevel(0, &pSurface);
		g_pd3dDevice->SetRenderTarget(pSurface, pZBuffer);
		g_pd3dDevice->Clear( 0, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL, 
			                 D3DCOLOR_RGBA(0,0,0,0), 1.0f, 0 );
		matView.m[1][2] = 0.5f * nslices;
		matView.m[3][2] = 0.5f * nslices - (float)i;	// offset to next slice
		
		// We want the texture to wrap, so draw multiple times with offsets in the plane so that 
		// the boundaries will be filled in by the overlapping geometry.
		for (int iX = -1; iX <= 1; iX++)
		{
			for (int iY = -1; iY <= 1; iY++)
			{
				matView.m[3][0] = 2.f * iX;
				matView.m[3][1] = 2.f * iY;
				g_pd3dDevice->SetTransform( D3DTS_VIEW, &matView);
				g_pd3dDevice->DrawPrimitive(D3DPT_LINELIST, 0, numLines);
			}
		}
		pSurface->Release();
		GenerateMipmaps(pTexture, 0);
	}
	
	// clean up
	pVB->Release();
	pZBuffer->Release();
	g_pd3dDevice->SetRenderTarget(save.pBackBuffer, save.pZBuffer);
	save.pBackBuffer->Release();
	save.pZBuffer->Release();
	g_pd3dDevice->SetTransform( D3DTS_WORLD, &save.matWorld);
	g_pd3dDevice->SetTransform( D3DTS_VIEW, &save.matView);
	g_pd3dDevice->SetTransform( D3DTS_PROJECTION, &save.matProjection);
	g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_ZWRITEENABLE, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_LIGHTING, TRUE);
}

//-----------------------------------------------------------------------------
// Name: GenFin
// Desc: Generate the fin texture in a similar way as GenSlices.
//-----------------------------------------------------------------------------
void CXBFur::GenFin(DWORD finWidth, DWORD finHeight, float fFinXFraction, float fFinZFraction)
{
	m_fFinXFraction = fFinXFraction;
	m_fFinZFraction = fFinZFraction;

	// Check the format of the textures
	bool bFormatOK = true;
	if (m_pFinTexture != NULL)
	{
		D3DSURFACE_DESC desc;
		m_pFinTexture->GetLevelDesc(0, &desc);
		if (desc.Format != D3DFMT_A8R8G8B8)
			bFormatOK = false;
	}

	// make sure fin info is up to date
	if(m_finWidth != finWidth
	   || m_finHeight != finHeight
	   || !bFormatOK)
	{
		SAFE_RELEASE(m_pFinTexture);
	}
	m_finWidth = finWidth;
	m_finHeight = finHeight;

	// create fin texture if needed
	if (m_pFinTexture == NULL)
		g_pd3dDevice->CreateTexture(finWidth, finHeight, 0, 0, D3DFMT_A8R8G8B8, 0, &m_pFinTexture);

	// save current back buffer, z buffer, and transforms
	struct {
		IDirect3DSurface8 *pBackBuffer, *pZBuffer;
		D3DMATRIX matWorld, matView, matProjection;
	} save;
	g_pd3dDevice->GetRenderTarget(&save.pBackBuffer);
	g_pd3dDevice->GetDepthStencilSurface(&save.pZBuffer);
	g_pd3dDevice->GetTransform( D3DTS_WORLD, &save.matWorld);
	g_pd3dDevice->GetTransform( D3DTS_VIEW, &save.matView);
	g_pd3dDevice->GetTransform( D3DTS_PROJECTION, &save.matProjection);

	// make a new depth buffer
	IDirect3DSurface8 *pZBuffer = NULL;
	g_pd3dDevice->CreateDepthStencilSurface(finWidth, finHeight, D3DFMT_LIN_D24S8, D3DMULTISAMPLE_NONE, &pZBuffer);
	D3DXVECTOR3 va(-0.5f*m_fXSize, 0.f, -0.5f*m_fZSize), vb(0.5f*m_fXSize, m_fYSize, 0.5f*m_fZSize); // bounds of fuzz patch
	D3DXVECTOR3 vwidth(vb-va), vcenter(0.5f*(vb+va)); // width and center of fuzz patch

	// set world transformation to scale model to unit cube [-1,1] in all dimensions
	D3DXMATRIX matWorld, matTranslate, matScale;
	D3DXMatrixTranslation(&matTranslate, -vcenter.x, -vcenter.y, -vcenter.z);
	D3DXMatrixScaling(&matScale, 2.f/vwidth.x, 2.f/vwidth.y, 2.f/vwidth.z);
	matWorld = matTranslate * matScale;
	g_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld);

	// set view transformation to look down z axis, with z range [0,1]
	float fXFraction = m_fFinXFraction;
	float fYFraction = 1.f;
	float fZFraction = m_fFinZFraction; 
	float fXScale = 1.f / fXFraction;
	float fYScale = 1.f / fYFraction;
	float fZScale = 1.f / fZFraction;
	D3DMATRIX matView;
	matView.m[0][0] = fXScale;	matView.m[0][1] =  0.f;		matView.m[0][2] = 0.f;				matView.m[0][3] = 0.f;
	matView.m[1][0] = 0.f;		matView.m[1][1] = -fYScale;	matView.m[1][2] = 0.f;				matView.m[1][3] = 0.f;
	matView.m[2][0] = 0.f;		matView.m[2][1] =  0.f;		matView.m[2][2] = 0.5f * fZScale;	matView.m[2][3] = 0.f;
	matView.m[3][0] = 0.f;		matView.m[3][1] =  0.f; 	matView.m[3][2] = 0.5f * fZScale;	matView.m[3][3] = 1.f;
	g_pd3dDevice->SetTransform( D3DTS_VIEW, &matView);
	// set projection matrix to orthographic

	D3DXMATRIX matProjection;
	D3DXMatrixIdentity(&matProjection);
	g_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProjection);
	UINT numLines = m_dwNumFuzz*m_dwNumSegments;
	IDirect3DVertexBuffer8 *pVB;
	GetLinesVertexBuffer(&pVB);
	g_pd3dDevice->SetTexture(0, NULL);
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_DIFFUSE);
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_DIFFUSE);
	g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_ONE); // premultiplied alpha
	g_pd3dDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
	g_pd3dDevice->SetRenderState(D3DRS_ZWRITEENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_EMISSIVEMATERIALSOURCE, D3DMCS_COLOR1);
	g_pd3dDevice->SetRenderState(D3DRS_LIGHTING, FALSE);
	g_pd3dDevice->SetVertexShader(FVF_XYZDIFF);
	g_pd3dDevice->SetStreamSource(0, pVB, sizeof(FVFT_XYZDIFF));
	
	// draw fuzz into the fin texture, looking from the side
	LPDIRECT3DTEXTURE8 pTexture = m_pFinTexture;
	IDirect3DSurface8 *pSurface;
	pTexture->GetSurfaceLevel(0, &pSurface);
	g_pd3dDevice->SetRenderTarget(pSurface, pZBuffer);
	g_pd3dDevice->Clear( 0, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL, 
		                 D3DCOLOR_RGBA(0,0,0,0), 1.0f, 0 );
	g_pd3dDevice->DrawPrimitive(D3DPT_LINELIST, 0, numLines);
	pSurface->Release();
	GenerateMipmaps(pTexture, 0, D3DTADDRESS_WRAP, D3DTADDRESS_CLAMP);

	// clean up
	pVB->Release();
	pZBuffer->Release();
	g_pd3dDevice->SetRenderTarget(save.pBackBuffer, save.pZBuffer);
	save.pBackBuffer->Release();
	save.pZBuffer->Release();
	g_pd3dDevice->SetTransform( D3DTS_WORLD, &save.matWorld);
	g_pd3dDevice->SetTransform( D3DTS_VIEW, &save.matView);
	g_pd3dDevice->SetTransform( D3DTS_PROJECTION, &save.matProjection);
	g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_ZWRITEENABLE, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_LIGHTING, TRUE);
}

//-----------------------------------------------------------------------------
// Name: GetLinesVertexBuffer
// Desc: Create and fill in a vertex buffer as a series of individual lines from the fuzz library.
//-----------------------------------------------------------------------------
void CXBFur::GetLinesVertexBuffer(IDirect3DVertexBuffer8 **ppVB)
{
	IDirect3DVertexBuffer8 *pVB;
	UINT numVertices = m_dwNumFuzz*m_dwNumSegments*2;
	g_pd3dDevice->CreateVertexBuffer(numVertices*sizeof(FVFT_XYZDIFF), 0, FVF_XYZDIFF, 0, &pVB);
	assert(pVB!=NULL);
	DWORD i, j, vidx, lidx;
	FVFT_XYZDIFF *verts;
	float x0, y0, z0;
	float dx, dy, dz;
	float ddx, ddy, ddz;
	float step, cp;
	UINT startseg = 0;
	step = 1.0f/(float)m_dwNumSegments;
	pVB->Lock(0, numVertices*sizeof(FVFT_XYZDIFF), (BYTE **)&verts, 0);
	vidx = 0;
	D3DXCOLOR colorBase, colorDelta;
	for(i=0; i<m_dwNumFuzz; i++)
	{
		// get location and index from fuzz instances
		lidx = m_pFuzz[i].lidx;
		x0 = m_pFuzz[i].x;
		y0 = 0.0f;
		z0 = m_pFuzz[i].z;

		// get params from fuzz lib
		dx = m_pFuzzLib[lidx].dp.x;
		dy = m_pFuzzLib[lidx].dp.y;
		dz = m_pFuzzLib[lidx].dp.z;
		ddx = m_pFuzzLib[lidx].ddp.x;
		ddy = m_pFuzzLib[lidx].ddp.y;
		ddz = m_pFuzzLib[lidx].ddp.z;
		colorBase = m_pFuzzLib[lidx].colorBase;
		colorDelta = m_pFuzzLib[lidx].colorTip - colorBase;

		// build linelist
		cp = (float)startseg*step;
		D3DXCOLOR color;
		for(j=startseg; j<m_dwNumSegments; j++)
		{
			verts[vidx].v.x = x0 + cp*dx + 0.5f*cp*cp*ddx;
			verts[vidx].v.y = y0 + cp*dy + 0.5f*cp*cp*ddy;
			verts[vidx].v.z = z0 + cp*dz + 0.5f*cp*cp*ddz;
			color = colorBase + cp * cp * colorDelta;
			verts[vidx].diff = color;
			vidx++;
			cp += step;

			verts[vidx].v.x = x0 + cp*dx + 0.5f*cp*cp*ddx;
			verts[vidx].v.y = y0 + cp*dy + 0.5f*cp*cp*ddy;
			verts[vidx].v.z = z0 + cp*dz + 0.5f*cp*cp*ddz;
			color = colorBase + cp * cp * colorDelta;
			verts[vidx].diff = color;
			vidx++;
		}
	}
	pVB->Unlock();
	*ppVB = pVB;
}

//-----------------------------------------------------------------------------
// Name: RenderLines
// Desc: Draw the fuzz patch as a series of individual lines.
//-----------------------------------------------------------------------------
void CXBFur::RenderLines()
{
	UINT numLines = m_dwNumFuzz*m_dwNumSegments;
	IDirect3DVertexBuffer8 *pVB;
	GetLinesVertexBuffer(&pVB);
	g_pd3dDevice->SetTexture(0, NULL);
    g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
    g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_DIFFUSE);
    g_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
    g_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_DIFFUSE);
	g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_ONE); // premultiplied alpha
	g_pd3dDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
	g_pd3dDevice->SetRenderState(D3DRS_LIGHTING, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_ZWRITEENABLE, FALSE);
	g_pd3dDevice->SetVertexShader(FVF_XYZDIFF);
	g_pd3dDevice->SetStreamSource(0, pVB, sizeof(FVFT_XYZDIFF));
	g_pd3dDevice->DrawPrimitive(D3DPT_LINELIST, 0, numLines);
	g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_ZWRITEENABLE, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_LIGHTING, TRUE);
	pVB->Release();
}

//-----------------------------------------------------------------------------
// Desc: File routines for saving and loading patch files.
//       Saving is only relevant if used on a Windows platform.
//-----------------------------------------------------------------------------
struct _fphdr
{
	char sig[5];
	int flags;
};

void CXBFur::Save(char *fname, int flags)
{
	HANDLE hFile;
	struct _fphdr hdr;

	DWORD dwNumBytesWritten;
    hFile = CreateFile(fname, GENERIC_WRITE, FILE_SHARE_WRITE, NULL,
		               OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	if(hFile == INVALID_HANDLE_VALUE)
		return;

	// write file header
	strcpy(hdr.sig, "FUZ2");
	hdr.flags = flags;

	WriteFile(hFile, &hdr, sizeof(struct _fphdr), &dwNumBytesWritten, NULL);
	

	// write fpatch data
	WriteFile(hFile, &m_dwSeed, sizeof(DWORD), &dwNumBytesWritten, NULL);
	
	WriteFile(hFile, &m_fXSize, sizeof(float), &dwNumBytesWritten, NULL);
	WriteFile(hFile, &m_fYSize, sizeof(float), &dwNumBytesWritten, NULL);
	WriteFile(hFile, &m_fZSize, sizeof(float), &dwNumBytesWritten, NULL);

	WriteFile(hFile, &m_dwNumSegments, sizeof(DWORD), &dwNumBytesWritten, NULL);
	WriteFile(hFile, &m_fFinXFraction, sizeof(float), &dwNumBytesWritten, NULL);
	WriteFile(hFile, &m_fFinZFraction, sizeof(float), &dwNumBytesWritten, NULL);
	WriteFile(hFile, &m_fuzzCenter.colorBase, sizeof(D3DXCOLOR), &dwNumBytesWritten, NULL);
	WriteFile(hFile, &m_fuzzRandom.colorBase, sizeof(D3DXCOLOR), &dwNumBytesWritten, NULL);
	WriteFile(hFile, &m_fuzzCenter.colorTip, sizeof(D3DXCOLOR), &dwNumBytesWritten, NULL);
	WriteFile(hFile, &m_fuzzRandom.colorTip, sizeof(D3DXCOLOR), &dwNumBytesWritten, NULL);
	
	WriteFile(hFile, &m_fuzzCenter.dp, sizeof(D3DVECTOR), &dwNumBytesWritten, NULL);
	WriteFile(hFile, &m_fuzzRandom.dp, sizeof(D3DVECTOR), &dwNumBytesWritten, NULL);
	WriteFile(hFile, &m_fuzzCenter.ddp, sizeof(D3DVECTOR), &dwNumBytesWritten, NULL);
	WriteFile(hFile, &m_fuzzRandom.ddp, sizeof(D3DVECTOR), &dwNumBytesWritten, 0);

	WriteFile(hFile, &m_dwNumFuzzLib, sizeof(DWORD), &dwNumBytesWritten, NULL);
	WriteFile(hFile, &m_dwNumFuzz, sizeof(DWORD), &dwNumBytesWritten, NULL);

	WriteFile(hFile, &m_dwNumSlices, sizeof(DWORD), &dwNumBytesWritten, NULL);
	WriteFile(hFile, &m_dwSliceXSize, sizeof(DWORD), &dwNumBytesWritten, NULL);
	WriteFile(hFile, &m_dwSliceZSize, sizeof(DWORD), &dwNumBytesWritten, NULL);
	
	return;



	// write volume data if available and flag is set
	{
	}

	// cleanup
	CloseHandle(hFile);
}

void CXBFur::Load(char *fname)
{
	HANDLE hFile;
	struct _fphdr hdr;
	DWORD numfuzzlib, numfuzz;
	DWORD numslices, slicexsize, slicezsize;

	DWORD dwNumBytesRead;
    hFile = CreateFile(fname, GENERIC_READ, FILE_SHARE_READ, NULL,
		               OPEN_EXISTING, FILE_ATTRIBUTE_READONLY, NULL);
	if(hFile == INVALID_HANDLE_VALUE)
		return;
	
	// read file header
	ReadFile(hFile, &hdr, sizeof(struct _fphdr), &dwNumBytesRead, 0);

	// verify signature
	bool bFUZ1 = !strcmp(hdr.sig, "FUZ1");
	bool bFUZ2 = !strcmp(hdr.sig, "FUZ2");
	if (!bFUZ1 && !bFUZ2)
		return;	// signature not understood

	// read patch data

	ReadFile(hFile, &m_dwSeed, sizeof(DWORD), &dwNumBytesRead, NULL);
	ReadFile(hFile, &m_fXSize, sizeof(float), &dwNumBytesRead, NULL);
	ReadFile(hFile, &m_fYSize, sizeof(float), &dwNumBytesRead, NULL);
	ReadFile(hFile, &m_fZSize, sizeof(float), &dwNumBytesRead, NULL);
	

	ReadFile(hFile, &m_dwNumSegments, sizeof(DWORD), &dwNumBytesRead, NULL);
	
	if (bFUZ1)
	{
		m_fFinXFraction = 1.f;
		m_fFinZFraction = 0.05f;

		ReadFile(hFile, &m_fuzzCenter.colorBase, sizeof(D3DXCOLOR), &dwNumBytesRead, NULL);
		m_fuzzCenter.colorTip = m_fuzzCenter.colorBase;
		m_fuzzRandom.colorBase = m_fuzzRandom.colorTip = 0ul;
	}
	else
	{

		ReadFile(hFile, &m_fFinXFraction, sizeof(float), &dwNumBytesRead, NULL);
		ReadFile(hFile, &m_fFinZFraction, sizeof(float), &dwNumBytesRead, NULL);
		ReadFile(hFile, &m_fuzzCenter.colorBase, sizeof(D3DXCOLOR), &dwNumBytesRead, NULL);
		ReadFile(hFile, &m_fuzzRandom.colorBase, sizeof(D3DXCOLOR), &dwNumBytesRead, NULL);
		ReadFile(hFile, &m_fuzzCenter.colorTip, sizeof(D3DXCOLOR), &dwNumBytesRead, NULL);
		ReadFile(hFile, &m_fuzzRandom.colorTip, sizeof(D3DXCOLOR), &dwNumBytesRead, NULL);
	}

	ReadFile(hFile, &m_fuzzCenter.dp, sizeof(D3DVECTOR), &dwNumBytesRead, NULL);  // velocity center
	ReadFile(hFile, &m_fuzzRandom.dp, sizeof(D3DVECTOR), &dwNumBytesRead, NULL);  // velocity random
	ReadFile(hFile, &m_fuzzCenter.ddp, sizeof(D3DVECTOR), &dwNumBytesRead, NULL); // acceleration center
	ReadFile(hFile, &m_fuzzRandom.ddp, sizeof(D3DVECTOR), &dwNumBytesRead, NULL); // acceleration random
	

	ReadFile(hFile, &numfuzzlib, sizeof(DWORD), &dwNumBytesRead, NULL);
	ReadFile(hFile, &numfuzz, sizeof(DWORD), &dwNumBytesRead, NULL);
		
	ReadFile(hFile, &numslices, sizeof(DWORD), &dwNumBytesRead, NULL);
	ReadFile(hFile, &slicexsize, sizeof(DWORD), &dwNumBytesRead, NULL);
	ReadFile(hFile, &slicezsize, sizeof(DWORD), &dwNumBytesRead, NULL);
	   
	// read volume data if available and flag is set
	{
	}

	CloseHandle(hFile);

	InitFuzz(numfuzz, numfuzzlib);
	GenSlices(numslices, slicexsize, slicezsize);
	ComputeLevelOfDetailTextures();
	SetLevelOfDetail(0.f);
}

//////////////////////////////////////////////////////////////////////
// Lighting Model
//////////////////////////////////////////////////////////////////////

inline float
Luminance(const D3DXCOLOR &c)
{
    return (0.229f * c.r) + (0.587f * c.g) + (0.114f * c.b);
}

inline float
MaxChannel(const D3DXCOLOR &c)
{
	if (c.r > c.g)
	{
		if (c.r > c.b)
			return c.r;
		else
			return c.b;
	}
	else
	{
		if (c.g > c.b)
			return c.g;
		else
			return c.b;
	}
}

inline D3DXCOLOR 
Lerp(const D3DXCOLOR &c1, const D3DXCOLOR &c2, float s)
{
    return c1 + s * (c2 - c1);
}

inline D3DXCOLOR
Desaturate(const D3DXCOLOR &rgba)
{
    float alpha = rgba.a;
    if (alpha > 1.f)
        alpha = 1.f;
    float fMaxChan = MaxChannel(rgba);
    if (fMaxChan > alpha) 
    {
        D3DXCOLOR rgbGray(alpha, alpha, alpha, alpha);
        float fYOld = Luminance(rgba);
        if (fYOld >= alpha)
            return rgbGray;
        // scale color to preserve hue
        D3DXCOLOR rgbNew;
        float fInvMaxChan = 1.f / fMaxChan;
        rgbNew.r = rgba.r * fInvMaxChan;
        rgbNew.g = rgba.g * fInvMaxChan;
        rgbNew.b = rgba.b * fInvMaxChan;
		rgbNew.a = alpha;
        float fYNew = Luminance(rgbNew);
        // add gray to preserve luminance
        return Lerp(rgbNew, rgbGray, (fYOld - fYNew) / (alpha - fYNew));
    }
    return rgba;
}

inline D3DXCOLOR &operator *=(D3DXCOLOR &p, const D3DXCOLOR &q)
{
	p.r *= q.r;
	p.g *= q.g;
	p.b *= q.b;
	p.a *= q.a;
	return p;
}

inline D3DXCOLOR operator *(const D3DXCOLOR &p, const D3DXCOLOR &q)
{
	D3DXCOLOR r;
	r.r = p.r * q.r;
	r.g = p.g * q.g;
	r.b = p.b * q.b;
	r.a = p.a * q.a;
	return r;
}

//-----------------------------------------------------------------------------
//  HairLighting
//-----------------------------------------------------------------------------
struct HairLighting {
	// like D3DMATERIAL8, except populated with D3DXCOLOR's so that color arithmetic works
	D3DXCOLOR m_colorDiffuse;
	D3DXCOLOR m_colorSpecular;
	float m_fSpecularExponent;
	D3DXCOLOR m_colorAmbient;
	D3DXCOLOR m_colorEmissive;

	HRESULT Initialize(LPDIRECT3DDEVICE8 pDevice, D3DMATERIAL8 *pMaterial);
	HRESULT CalculateColor(D3DXCOLOR *pColor, float LT, float HT);
	HRESULT CalculateClampedColor(D3DXCOLOR *pColor, float LT, float HT);
};

HRESULT HairLighting::Initialize(LPDIRECT3DDEVICE8 pDevice, D3DMATERIAL8 *pMaterial)
{
	// Get current colors modulated by light 0 and global ambient
	// ignore current alphas
	m_colorDiffuse = D3DXCOLOR(pMaterial->Diffuse.r, pMaterial->Diffuse.g, pMaterial->Diffuse.b, 1.f);
	m_colorSpecular = D3DXCOLOR(pMaterial->Specular.r, pMaterial->Specular.g, pMaterial->Specular.b, 1.f);
	m_fSpecularExponent = pMaterial->Power;
	m_colorAmbient = D3DXCOLOR(pMaterial->Ambient.r, pMaterial->Ambient.g, pMaterial->Ambient.b, 1.f);
	m_colorEmissive = D3DXCOLOR(pMaterial->Emissive.r, pMaterial->Emissive.g, pMaterial->Emissive.b, 1.f);
	return S_OK;
}

/* Zockler et al's technique worked with streamlines, and used dot(V,T) instead of the simpler dot(H,T) */
#define ZOCKLER 0 
#if ZOCKLER

HRESULT HairLighting::CalculateColor(D3DXCOLOR *pColor, float LT, float VT)
{
	// Zockler et al 1996
	float fDiffuseExponent = 2.f;	// Banks used 4.8
	float fDiffuse = powf(sqrtf(1.f - LT*LT), fDiffuseExponent);
	float VR = LT*VT - sqrtf(1.f - LT*LT) * sqrtf(1.f - VT*VT);
	float fSpecular = powf(VR, m_fSpecularExponent);
	*pColor = m_colorEmissive + m_colorAmbient + fSpecular * m_colorSpecular + fDiffuse * m_colorDiffuse;
	return S_OK;
}

#else

HRESULT HairLighting::CalculateColor(D3DXCOLOR *pColor, float LT, float HT)
{
	float fDiffuseExponent = 2.f;	// Banks used 4.8
	float fDiffuse = powf(sqrtf(1.f - LT*LT), fDiffuseExponent);
	float fSpecular = powf(sqrtf(1.f - HT*HT), m_fSpecularExponent);
	*pColor = m_colorEmissive + m_colorAmbient + fSpecular * m_colorSpecular + fDiffuse * m_colorDiffuse;
	return S_OK;
}

#endif

HRESULT HairLighting::CalculateClampedColor(D3DXCOLOR *pColor, float LT, float HT)
{
	D3DXCOLOR color;
	HRESULT hr = CalculateColor(&color, LT, HT);
	*pColor = Desaturate(color);	// bring back to 0,1 range
	return hr;
}

//////////////////////////////////////////////////////////////////////
// 
// Create a hair lighting lookup-table texture
// 
//////////////////////////////////////////////////////////////////////
HRESULT FillHairLightingTexture(D3DMATERIAL8 *pMaterial, LPDIRECT3DTEXTURE8 pTexture)
{
	/* 
	The hair lighting texture maps U as the dot product of the hair
	tangent T with the light direction L and maps V as the dot product
	of the tangent with the half vector H.  Since the lighting is a
	maximum when the tangent is perpendicular to L (or H), the maximum
	is at zero.  The minimum is at 0.5, 0.5 (or -0.5, -0.5, since
	wrapping is turned on.)  For the mapped T.H, we raise the map
	value to a specular power.
	*/
	HRESULT hr;
	D3DSURFACE_DESC desc;
	pTexture->GetLevelDesc(0, &desc);
	if (desc.Format != D3DFMT_A8R8G8B8)
		return E_NOTIMPL;
	DWORD dwPixelStride = 4;
	D3DLOCKED_RECT lockedRect;
	hr = pTexture->LockRect(0, &lockedRect, NULL, 0l);
	if (FAILED(hr))
		return hr;
	HairLighting lighting;
	lighting.Initialize(g_pd3dDevice, pMaterial);
	Swizzler s(desc.Width, desc.Height, 0);
	s.SetV(s.SwizzleV(0));
	s.SetU(s.SwizzleU(0));
	for (UINT v = 0; v < desc.Height; v++)
	{
		for (UINT u = 0; u < desc.Width; u++)
		{
			BYTE *p = (BYTE *)lockedRect.pBits + dwPixelStride * s.Get2D();
			// vertical is specular lighting
			// horizontal is diffuse lighting
			D3DXCOLOR color;
#if ZOCKLER
			// Zockler et al 1996
			float LT = 2.f * u / desc.Width - 1.0f;
			float VT = 2.f * v / desc.Height - 1.0f;
			lighting.CalculateClampedColor(&color, LT, VT);
#else
			float LT = 2.f * u / desc.Width;
			if (LT > 1.f) LT -= 2.f;
			float HT = 2.f * v / desc.Height;
			if (HT > 1.f) HT -= 2.f;
			lighting.CalculateClampedColor(&color, LT, HT);
#endif
			int r, g, b;
			r = (BYTE)(255 * color.r);
			g = (BYTE)(255 * color.g);
			b = (BYTE)(255 * color.b);
			*p++ = (BYTE)b;
			*p++ = (BYTE)g;
			*p++ = (BYTE)r;
			*p++ = 255;	// alpha
			s.IncU();
		}
		s.IncV();
	}
	pTexture->UnlockRect(0);
	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: SetHairLightingMaterial
// Desc: Create and fill the hair lighting texture
//-----------------------------------------------------------------------------
HRESULT CXBFur::SetHairLightingMaterial(D3DMATERIAL8 *pMaterial)
{
	// Create and fill the hair lighting texture
	HRESULT hr;
	m_HairLightingMaterial = *pMaterial;
	if (!m_pHairLightingTexture)
	{
		DWORD dwWidth = 8; // an extremely small texture suffices when the exponents are low
		DWORD dwHeight = 8;
		D3DFORMAT surfaceFormat = D3DFMT_A8R8G8B8;
		DWORD nMipMap = 1;
		hr = D3DXCreateTexture(g_pd3dDevice, dwWidth, dwHeight, nMipMap, 0, surfaceFormat, 0, &m_pHairLightingTexture);
		if (FAILED(hr)) goto e_Exit;
	}
	hr = FillHairLightingTexture(pMaterial, m_pHairLightingTexture);
	if (FAILED(hr)) goto e_Exit;
e_Exit:
	if (FAILED(hr))
		SAFE_RELEASE(m_pHairLightingTexture);
	return hr;
}

//-----------------------------------------------------------------------------
// Choose level of detail 
//
// 0       = finest detail, all slices of original source textures
// ...
// i       = reduced number of slices, N / (1 << i)
// i + f   = odd slices fade to clear, texLOD[2*j+1] = tex[2*j+1] * (1-f) + clear * f
//           even slices compensate,   texLOD[2*j] = (tex[2*j+1] * f) OVER tex[2*j]
// i + 1   = reduced number of slices, N / (1 << (i+1))
// ...
// log2(N) = coarsest, one slice with composite of all source textures
//-----------------------------------------------------------------------------
HRESULT CXBFur::SetLevelOfDetail(float fLevelOfDetail)
{
	// Choose number of LOD slices
	if (fLevelOfDetail < 0.f)
	{
		m_fLevelOfDetail = 0.f;
		m_iLOD = 0;
		m_fLODFraction = 0.f;
	}
	else if (fLevelOfDetail > (float)m_dwLODMax)
	{
		m_fLevelOfDetail = (float)m_dwLODMax;
		m_iLOD = m_dwLODMax;
		m_fLODFraction = 0.f;
	}
	else
	{
		m_fLevelOfDetail = fLevelOfDetail;
		m_iLOD = (UINT)floorf(fLevelOfDetail);
		m_fLODFraction = fLevelOfDetail - (float)m_iLOD;
	}
	m_dwNumSlicesLOD = LevelOfDetailCount(m_iLOD);
	UINT index = LevelOfDetailIndex(m_iLOD);
	m_pSliceTextureLOD = m_apSliceTexture + index;
	return S_OK;
}

//-----------------------------------------------------------------------------
//
// Generate level-of-detail textures by compositing together alternating layers.
//
//-----------------------------------------------------------------------------
HRESULT CXBFur::ComputeLevelOfDetailTextures()
{
	// All the textures must have the same number of mip levels.
	DWORD nMip = m_apSliceTexture[0]->GetLevelCount();

	// save current back buffer and z buffer
	struct {
		IDirect3DSurface8 *pBackBuffer, *pZBuffer;
	} save;
	g_pd3dDevice->GetRenderTarget(&save.pBackBuffer);
	g_pd3dDevice->GetDepthStencilSurface(&save.pZBuffer);

	// set render state for compositing textures
	g_pd3dDevice->SetVertexShader(D3DFVF_XYZRHW|D3DFVF_TEX1);
	g_pd3dDevice->SetRenderState(D3DRS_LIGHTING, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_ALPHATESTENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_ZENABLE, D3DZB_FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_STENCILENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_FOGENABLE, FALSE);

	// use pixel shaders to composite two or three layers at a time
#pragma warning(push)
#pragma warning(disable: 4245)	// conversion from int to DWORD
	DWORD dwPS2 = 0;
	{
#include "comp2.inl"
		g_pd3dDevice->CreatePixelShader(&psd, &dwPS2);
	}
	DWORD dwPS3 = 0;
	{
#include "comp3.inl"
		g_pd3dDevice->CreatePixelShader(&psd, &dwPS3);
	}
#pragma warning(pop)

	// set default texture stage states
	UINT xx; // texture stage index
	for (xx = 0; xx < 4; xx++)
	{
		g_pd3dDevice->SetTexture(xx, NULL);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_COLOROP, D3DTOP_DISABLE);	// Are the COLOROP and ALPHAOP needed since we're using a pixel shader?
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_DISABLE);	// pass texture coords without transformation
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_TEXCOORDINDEX, 0);			// all the textures use the same tex coords
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_MAGFILTER, D3DTEXF_POINT);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_MINFILTER, D3DTEXF_POINT);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_MIPFILTER, D3DTEXF_POINT);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_MIPMAPLODBIAS, 0);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_MAXMIPLEVEL, 0);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_COLORKEYOP, D3DTCOLORKEYOP_DISABLE);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_COLORSIGN, 0);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_ALPHAKILL, D3DTALPHAKILL_DISABLE);
	}
	
	// Compute all the level-of-detail textures
	for (UINT iLOD = 1; m_dwNumSlices >> iLOD; iLOD++)
	{
		UINT nSliceSrc = LevelOfDetailCount(iLOD-1);
		LPDIRECT3DTEXTURE8 *apTextureSrc = m_apSliceTexture + LevelOfDetailIndex(iLOD - 1);
		UINT nSliceDst = LevelOfDetailCount(iLOD);
		LPDIRECT3DTEXTURE8 *apTextureDst = m_apSliceTexture + LevelOfDetailIndex(iLOD);
		
		// Composite source textures into LOD textures
		UINT iMipNotHandled = (UINT)-1;
		for (UINT iSliceDst = 0; iSliceDst < nSliceDst; iSliceDst++)
		{
			LPDIRECT3DTEXTURE8 pTextureDst = apTextureDst[iSliceDst];
			UINT nComp;
			if (iSliceDst == nSliceDst-1 && nSliceSrc > nSliceDst * 2)
			{
				// composite 3 textures into the top-most level when number of source textures is odd
				nComp = 3;
				g_pd3dDevice->SetPixelShader(dwPS3);
			}
			else
			{
				// composite 2 textures (this is the default)
				nComp = 2;
				g_pd3dDevice->SetPixelShader(dwPS2);
			}
			for (xx = 0; xx < nComp; xx++)
			{
				g_pd3dDevice->SetTexture(xx, apTextureSrc[ iSliceDst * 2 + xx]);
				g_pd3dDevice->SetTextureStageState(xx, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
				g_pd3dDevice->SetTextureStageState(xx, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
			}
			for (; xx<4; xx++)
			{
				g_pd3dDevice->SetTexture(xx, NULL);
				g_pd3dDevice->SetTextureStageState(xx, D3DTSS_COLOROP, D3DTOP_DISABLE);
				g_pd3dDevice->SetTextureStageState(xx, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
			}
			for (UINT iMip = 0; iMip < nMip; iMip++)
			{
				DWORD width = m_dwSliceXSize / (1 << iMip);
				if (width == 0) width = 1;
				DWORD height = m_dwSliceZSize / (1 << iMip);
				if (height == 0) height = 1;

				// Xbox render target must of be at least 16x16
				if (width*4 < 64 || width * height < 64)			
				{
					iMipNotHandled = iMip;
					break; // skip rest of coarser mipmaps and go to next slice
				}

				// Use a screen space quad to do the compositing.
				struct quad {
					float x, y, z, w;
					float u, v;
				} aQuad[4] =
				{
					{-0.5f,        -0.5f,         1.0f, 1.0f, 0.0f, 0.0f},
					{width - 0.5f, -0.5f,         1.0f, 1.0f, 1.0f, 0.0f},
					{-0.5f,        height - 0.5f, 1.0f, 1.0f, 0.0f, 1.0f},
					{width - 0.5f, height - 0.5f, 1.0f, 1.0f, 1.0f, 1.0f}
				};

				// get destination surface and set as render target
				IDirect3DSurface8 *pSurface;
				pTextureDst->GetSurfaceLevel(iMip, &pSurface);
				g_pd3dDevice->SetRenderTarget(pSurface, NULL); // no depth buffering
				g_pd3dDevice->DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, 2, aQuad, sizeof(quad)); // one quad blends 2 or 3 textures
				pSurface->Release();
			}
		}
		if (iMipNotHandled > 0 && iMipNotHandled != -1)
		{
			// fill in the small mips with filtered versions of the previous levels
			for (UINT iSliceDst = 0; iSliceDst < nSliceDst; iSliceDst++)
			{
				LPDIRECT3DTEXTURE8 pTextureDst = apTextureDst[iSliceDst];
				GenerateMipmaps(pTextureDst, iMipNotHandled - 1, D3DTADDRESS_MIRROR, D3DTADDRESS_MIRROR);
			}
		}
	}

	// clean up pixel shaders
	g_pd3dDevice->SetPixelShader(0);
	g_pd3dDevice->DeletePixelShader(dwPS2);
	g_pd3dDevice->DeletePixelShader(dwPS3);
	
	// restore render states
	g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_LIGHTING, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_EMISSIVEMATERIALSOURCE, D3DMCS_MATERIAL);

	// restore texture stage states
	for (xx=0; xx<4; xx++)
	{
		g_pd3dDevice->SetTexture(xx, NULL);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_COLOROP, D3DTOP_DISABLE);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
	}

	// restore back buffer and z buffer
	g_pd3dDevice->SetRenderTarget(save.pBackBuffer, save.pZBuffer);
	save.pBackBuffer->Release();
	save.pZBuffer->Release();
	return S_OK;
}

//-----------------------------------------------------------------------------
//  Divide alpha channel into color channel.  Leave alpha unchanged.
//-----------------------------------------------------------------------------
HRESULT AlphaDivide(LPDIRECT3DTEXTURE8 pTexture)
{
	HRESULT hr;
	DWORD nMip = pTexture->GetLevelCount();
	for (UINT iMip = 0; iMip < nMip; iMip++)
	{
		D3DSURFACE_DESC desc;
		hr = pTexture->GetLevelDesc(iMip, &desc);
		if (FAILED(hr))
			return hr;
		if (desc.Format != D3DFMT_A8R8G8B8)
			return E_NOTIMPL;
		D3DLOCKED_RECT lockedRect;
		hr = pTexture->LockRect(iMip, &lockedRect, NULL, 0l);
		if (FAILED(hr))
			return hr;
		UINT dwPixelSize = 4;
		UINT nPixel = desc.Size / dwPixelSize;
		DWORD *pPixel = (DWORD *)lockedRect.pBits;
		while (nPixel--)
		{
			D3DXCOLOR c(*pPixel);
			if (c.a > 0.f)
			{
				D3DXCOLOR d;
				d.r = c.r / c.a;
				d.g = c.g / c.a;
				d.b = c.b / c.a;
				d.a = c.a;
				*pPixel = d;
			}
			pPixel++;
		}
		pTexture->UnlockRect(iMip);
	}
	return S_OK;
}

//-----------------------------------------------------------------------------
//  Multiply alpha channel into color channel.  Leave alpha unchanged.
//-----------------------------------------------------------------------------
HRESULT AlphaMultiply(LPDIRECT3DTEXTURE8 pTexture)
{
	HRESULT hr;
	DWORD nMip = pTexture->GetLevelCount();
	for (UINT iMip = 0; iMip < nMip; iMip++)
	{
		D3DSURFACE_DESC desc;
		hr = pTexture->GetLevelDesc(iMip, &desc);
		if (FAILED(hr))
			return hr;
		if (desc.Format != D3DFMT_A8R8G8B8)
			return E_NOTIMPL;
		D3DLOCKED_RECT lockedRect;
		hr = pTexture->LockRect(iMip, &lockedRect, NULL, 0l);
		if (FAILED(hr))
			return hr;
		UINT dwPixelSize = 4;
		UINT nPixel = desc.Size / dwPixelSize;
		DWORD *pPixel = (DWORD *)lockedRect.pBits;
		while (nPixel--)
		{
			D3DXCOLOR c(*pPixel);
			D3DXCOLOR d;
			d.r = c.r * c.a;
			d.g = c.g * c.a;
			d.b = c.b * c.a;
			d.a = c.a;
			*pPixel = d;
			pPixel++;
		}
		pTexture->UnlockRect(iMip);
	}
	return S_OK;
}

//-----------------------------------------------------------------------------
//
// Copy textures to new texture format
//
//-----------------------------------------------------------------------------
HRESULT CXBFur::CompressNextTexture(D3DFORMAT fmtNew, UINT *pIndex)
{
	HRESULT hr;
	for (UINT iTexture = 0; iTexture < XBFUR_MAXSLICE * 2 - 1; iTexture++)	// convert all the slice textures
	{
		LPDIRECT3DTEXTURE8 pTextureDst = NULL;
		LPDIRECT3DTEXTURE8 pTextureSrc = m_apSliceTexture[iTexture];
		if (pTextureSrc == NULL)
			break;	// we're done

		// See if this texture needs to be compressed
		D3DSURFACE_DESC desc0;
		pTextureSrc->GetLevelDesc(0, &desc0);
		if (desc0.Format == fmtNew)
			continue;	// we've already compressed this one, go to the next

		// We've found a texture that needs to be compressed
		hr = CompressTexture(&pTextureDst, fmtNew, pTextureSrc);
		if (FAILED(hr))
			return hr;
		m_apSliceTexture[iTexture] = pTextureDst; // already addref'd
		pTextureSrc->Release();	// we're done with the old texture
		if (pIndex != NULL)
			*pIndex = iTexture;	// return index of the texture we just compressed
		return S_FALSE;	// more textures are pending
	}
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\FuzzyTeapot\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\FuzzyTeapot\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\fur\XBFurMesh.h ===
#pragma once
//-----------------------------------------------------------------------------
// File: XBFurMesh.h
//
// Copyright (c) 2000-2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifdef _XBOX
#include <xtl.h>
#else
#include <d3d8.h>
#endif
#include "XBFur.h"

class CXBFurMesh
{
public:
	DWORD m_dwNumVertices;					// current # of vertices
	IDirect3DVertexBuffer8 *m_pVB;			// vertex buffer
	DWORD m_dwNumIndices;					// current # of indices
	IDirect3DIndexBuffer8 *m_pIB;			// index buffer
    IDirect3DTexture8 *m_pTexture;			// base mesh texture
	DWORD m_dwGenericVS;					// generic vertex shader used in DrawBaseMesh
	float m_fFinDotProductThreshold;		// max dot product of fin's face normal with eye vector
	UINT m_nFinBin;							// number of discretized directions for fin bins
	struct FinBin {
		D3DXVECTOR3 m_vDirection;			// selection direction for this bin
		float	m_fDirectionThreshold;		// cutoff for dot product of eye direction with m_vDirection
		DWORD m_dwNumFins;					// number of fins in this bin
		IDirect3DVertexBuffer8 *m_pFinVB;	// fin vertex buffer filled with 1 quad per edge
	} *m_rFinBin;
	struct DrawState {
		DWORD dwLighting;
		D3DXVECTOR3 vEyePos;			// position of eye in world coords
		D3DXVECTOR3 vEyeObject;			// position of eye in local object coords
		D3DXVECTOR3 vEyeDirection;		// direction from center of object to eye in local object coords
		D3DXVECTOR3 vLightPos;			// position of light in world coords
		D3DXVECTOR3 vLightObject;		// position of light in local object coords
		D3DXVECTOR3 vLightDirection;	// direction from center of object to light in local object coords
		D3DXMATRIX matViewProjection;
		D3DXVECTOR4 vOffset;
		D3DXVECTOR4 vSelfShadow;
		float fSelfShadowLog2Attenuation;
	} m_DrawState;
	
	CXBFurMesh();
	~CXBFurMesh();
	HRESULT Initialize(DWORD dwFVF, DWORD dwVertexCount, LPDIRECT3DVERTEXBUFFER8 pVB, DWORD dwIndexCount, LPDIRECT3DINDEXBUFFER8 pIB);
	HRESULT ExtractFins(UINT BinFactor, float fFinDotProductThreshold, float fEdgeTextureScale); // nFinBin = octohedron sphere subdivision = 4*(BinFactor + 1)*(BinFactor +1) + 2
	HRESULT ScaleTextureCoordinates(float fUScale, float fVScale);
	HRESULT CleanFins(); // deallocate memory
	void DrawBaseMesh();

	// State setting and drawing are put in separate functions so that when multiple furry models
	// are rendered (especially with the same fur) we can get some state-setting savings.
	void Begin(D3DXVECTOR3 *pvEyePos, D3DXVECTOR3 *pvLightPos, D3DXMATRIX *pmatViewProjection);  // set state common to both fins and fur
	void BeginObject(D3DXMATRIX *pmatWorld, D3DXMATRIX *pmatWorldInverse);
	void DrawFins(CXBFur *pFur, DWORD dwFinVS,
				  float fFinLODFull, /* LOD values less than this are fully on */
				  float fFinLODCutoff, /* LOD values beyond this are off */
				  float fFinExtraNormalScale); /* fins look better if then stick out a little more than the fur */
	void DrawShells(CXBFur *pFur, DWORD dwFurVS, DWORD dwFurPS[3]);
	void EndObject();
	void End();
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\FuzzyTeapot\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\FuzzyTeapot\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\fur\XBFurMesh.cpp ===
//-----------------------------------------------------------------------------
// File: XBFurMesh.cpp
//
// Desc: Facilitates drawing of 'fuzz' patches (hair, fur, grass, etc.)
//       by extracting fins and computing appropriate levels of detail.
//
// Copyright (c) 2000-2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <stdio.h>
#include <assert.h>
#include "XBFurMesh.h"
#include "XBUtil.h"
#include "OctoSphere.h"

extern LPDIRECT3DDEVICE8 g_pd3dDevice;

struct FinVertex {
	D3DXVECTOR3 position;				// xyz position
	D3DXVECTOR3 normal;					// hair tangent for lighting calculation
	D3DXVECTOR2 tex1;					// fin texture coordinates
	D3DXVECTOR3 normalFace;				// face normal for fading fins out as they get perpendicular to eye
};

//-----------------------------------------------------------------------------
// Name: Constructor & Destructor
//-----------------------------------------------------------------------------
CXBFurMesh::CXBFurMesh()
{
	memset(this, 0, sizeof(CXBFurMesh));
	m_dwGenericVS = FVF_XYZNORMTEX1;
}

CXBFurMesh::~CXBFurMesh()
{
	if(m_pVB)
		m_pVB->Release();
	if(m_pIB)
		m_pIB->Release();
	if(m_pTexture)
		m_pTexture->Release();
	CleanFins();
}

//-----------------------------------------------------------------------------
// Name: Initialize
// Desc: Keep pointer to object and fill initial arrays from selection.
//       If aIndices==NULL, do whole mesh.
//-----------------------------------------------------------------------------
HRESULT CXBFurMesh::Initialize(DWORD dwFVF, DWORD dwVertexCount, LPDIRECT3DVERTEXBUFFER8 pVB, DWORD dwIndexCount, LPDIRECT3DINDEXBUFFER8 pIB)
{
	assert(dwFVF==FVF_XYZNORMTEX1);	// make sure we are using correct FVF type
	m_dwNumVertices = dwVertexCount;
	LPDIRECT3DVERTEXBUFFER8 pVBOld = m_pVB;
	m_pVB = pVB;
	m_pVB->AddRef();
	if(pVBOld) pVBOld->Release();
	m_dwNumIndices = dwIndexCount;
	LPDIRECT3DINDEXBUFFER8 pIBOld = m_pIB;
	m_pIB = pIB;
	m_pIB->AddRef();
	if (pIBOld) pIBOld->Release();
	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: ExtractFins
// Desc: Find all the edges of the mesh and create an VB to draw them.
//-----------------------------------------------------------------------------
HRESULT CXBFurMesh::ExtractFins(UINT BinFactor, float fFinDotProductThreshold, float fEdgeTextureScale)
{
	HRESULT hr = S_OK;
	if (!m_pVB || !m_pIB) 
		return E_FAIL;
	DWORD dwVertexSize = D3DXGetFVFVertexSize(FVF_XYZNORMTEX1);
	DWORD dwFinVertexSize = sizeof(FinVertex);
	struct XYZNORMTEX1 {  // just like FVFT_XYZNORMTEX1, except with D3DX vector types
		D3DXVECTOR3 v;
		D3DXVECTOR3 norm;
		float tu;
		float tv;
	} *rVertex = NULL;
	UINT iFinBin;
	CleanFins();
	m_fFinDotProductThreshold = fFinDotProductThreshold;
	
	// count the number of fins by adding all the edges to a set
	UINT nFin = 0;
	UINT nFinMax = m_dwNumIndices; // 3 * nFace
	DWORD *rFin = new DWORD [nFinMax];
	if (rFin == NULL)
		return E_OUTOFMEMORY;
	WORD *piFace;
	hr = m_pIB->Lock(0, m_dwNumIndices*sizeof(WORD), (BYTE **)&piFace, 0);
	if (FAILED(hr))
		goto e_Exit;
	for (UINT iFace = 0; iFace < m_dwNumIndices/3; iFace++)
	{
		WORD *aiv = piFace + iFace * 3;
		for (UINT iCorner = 0; iCorner < 3; iCorner++)
		{
			WORD iVertex0 = aiv[iCorner];
			WORD iVertex1 = aiv[(iCorner + 1) % 3];
			if (iVertex0 > iVertex1)
			{
				// swap so the iVertex0 is always lower than iVertex1
				WORD iVertexSave = iVertex0;
				iVertex0 = iVertex1;
				iVertex1 = iVertexSave;
			}
			DWORD finKey = (((DWORD)iVertex0) << 16) | iVertex1;
			// find the right position
			UINT i = 0, j, k = nFin;
			while (i != k)
			{
				j = (i + k) >> 1;
				if (rFin[j] < finKey)
					i = j + 1;
				else if (rFin[j] > finKey)
					k = j;
				else // (rFin[i] == key)
					break; // already in table
			}
			if (i == k)
			{
				// move all the slots one up, then add new key
				assert(nFin < nFinMax);
				for (j = nFin; j > i; j--)
					rFin[j] = rFin[j-1];
				rFin[i] = finKey;
				nFin++;
			}
		}
	}
	m_pIB->Unlock();

	// Create discretized direction buckets by taking vertices from a subdivided octohedron
	hr = FillOctoSphere(BinFactor, &m_nFinBin, NULL, NULL, NULL); // get size of buffers needed
	if (FAILED(hr))
		goto e_Exit;
	m_rFinBin = new FinBin [ m_nFinBin ];
	if (FAILED(hr))
		goto e_Exit;
	{
		// copy direction vectors
		D3DXVECTOR3 *rFinDir = new D3DXVECTOR3 [ m_nFinBin ]; // temporary array to hold fin directions
		if (rFinDir == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto e_Exit;
		}
		hr = FillOctoSphere(BinFactor, &m_nFinBin, rFinDir, NULL, NULL);
		if (FAILED(hr))
		{
			delete [] rFinDir;
			goto e_Exit;
		}
		for (iFinBin = 0; iFinBin < m_nFinBin; iFinBin++)
		{
			m_rFinBin[iFinBin].m_vDirection = rFinDir[iFinBin];
			m_rFinBin[iFinBin].m_fDirectionThreshold = 1.f;	// first pass, use as dot-product threshold
			m_rFinBin[iFinBin].m_dwNumFins = 0;
			m_rFinBin[iFinBin].m_pFinVB = NULL;
//			m_rFinBin[iFinBin].m_pFinIB = NULL;
		}
		delete [] rFinDir;
	}
	// We need the original vertices to calculate fin face normals
	// and to copy over vertex data.
	hr = m_pVB->Lock(0, m_dwNumVertices*dwVertexSize, (BYTE **)&rVertex, 0);
	if (FAILED(hr))
		goto e_Exit;

	// For each fin, find the bin with the smallest dot-product
	// deviation and increment the count for that bin.  Each fin is
	// put into a single fin bin.
	float fBackfaceThreshold = -0.2f; // allow the normals to face slightly backwards
	for (UINT iFin = 0; iFin < nFin; iFin++)
	{
		// calculate face normal
		DWORD finKey = rFin[iFin];
		WORD iVertex0 = (WORD)(finKey >> 16);
		WORD iVertex1 = (WORD)(finKey & 0xffff);
		D3DXVECTOR3 e = rVertex[iVertex1].v - rVertex[iVertex0].v;
		float fEdgeLength = D3DXVec3Length(&e);
		e /= fEdgeLength; // normalize edge vector
		D3DXVECTOR3 n;
		D3DXVec3Normalize(&n, &rVertex[iVertex0].norm);
		D3DXVECTOR3 normalFace;
		D3DXVec3Cross(&normalFace, &e, &n);
		D3DXVec3Normalize(&normalFace, &normalFace);
		for (UINT iDir = 0; iDir < 2; iDir++) // add fin as both front-facing and back-facing fin
		{
			if (iDir) // flip the normal
				normalFace *= -1.f;
			// look for the best bin
			UINT iFinBinBest = (UINT)-1;
			float fDotProductBest = -1.f;
			for (iFinBin = 0; iFinBin < m_nFinBin; iFinBin++)
			{
				// Backface culling is based on the underlying mesh.  Does
				// at least one of the underlying mesh normals point in
				// the right direction, towards the eye?
				FinBin *pFinBin = &m_rFinBin[iFinBin];
				float fN0DotE = D3DXVec3Dot(&rVertex[iVertex0].norm, &pFinBin->m_vDirection);
				float fN1DotE = D3DXVec3Dot(&rVertex[iVertex1].norm, &pFinBin->m_vDirection);
				if (fN0DotE < fBackfaceThreshold && fN1DotE < fBackfaceThreshold)
					continue; // Skip the backfacing fin bin

				// Is this the best bucket?
				float fNDotD = D3DXVec3Dot(&normalFace, &pFinBin->m_vDirection);
				if (fNDotD > fDotProductBest)
				{
					iFinBinBest = iFinBin;
					fDotProductBest = fNDotD;
				}
			}
			assert(iFinBinBest != -1);	// we must have found at least one bin
			m_rFinBin[iFinBinBest].m_dwNumFins++;
		}
	}

	// Create the fin bin vertex buffers
	for (iFinBin = 0; iFinBin < m_nFinBin; iFinBin++)
	{
		FinBin *pFinBin = &m_rFinBin[iFinBin];
		if (pFinBin->m_dwNumFins == 0) continue; // empty bin
		
		// create the fin vertex buffer
		if (pFinBin->m_pFinVB)
			SAFE_RELEASE(pFinBin->m_pFinVB);
		hr = g_pd3dDevice->CreateVertexBuffer(4 * pFinBin->m_dwNumFins * dwFinVertexSize, 0, 0, 0, &pFinBin->m_pFinVB);
		if (FAILED(hr))
			goto e_Exit;

		// Use the fin count as an index into the fin vertex buffer.  Since the fin dot-product
		// test below is identical to the test above, the fin count will be the same at the end.
		pFinBin->m_dwNumFins = 0;
	}

	// Add the fins to the appropriate fin bin
	for (UINT iFin = 0; iFin < nFin; iFin++)
	{
		// calculate face normal
		DWORD finKey = rFin[iFin];
		WORD iVertex0 = (WORD)(finKey >> 16);
		WORD iVertex1 = (WORD)(finKey & 0xffff);
		D3DXVECTOR3 e = rVertex[iVertex1].v - rVertex[iVertex0].v;
		float fEdgeLength = D3DXVec3Length(&e);
		e /= fEdgeLength; // normalize edge vector
		D3DXVECTOR3 n;
		D3DXVec3Normalize(&n, &rVertex[iVertex0].norm);
		D3DXVECTOR3 normalFace;
		D3DXVec3Cross(&normalFace, &e, &n);
		D3DXVec3Normalize(&normalFace, &normalFace);
		for (UINT iDir = 0; iDir < 2; iDir++) // add fin as both front-facing and back-facing fin
		{
			if (iDir) // flip the normal
				normalFace *= -1.f;
			// look for the best bin
			UINT iFinBinBest = (UINT)-1;
			float fDotProductBest = -1.f;
			for (iFinBin = 0; iFinBin < m_nFinBin; iFinBin++)
			{
				// Backface culling is based on the underlying mesh.  Does
				// at least one of the underlying mesh normals point in
				// the right direction, towards the eye?
				FinBin *pFinBin = &m_rFinBin[iFinBin];
				float fN0DotE = D3DXVec3Dot(&rVertex[iVertex0].norm, &pFinBin->m_vDirection);
				float fN1DotE = D3DXVec3Dot(&rVertex[iVertex1].norm, &pFinBin->m_vDirection);
				if (fN0DotE < fBackfaceThreshold && fN1DotE < fBackfaceThreshold)
					continue; // Skip the backfacing fin bin

				// Is this the best bucket?
				float fNDotD = D3DXVec3Dot(&normalFace, &pFinBin->m_vDirection);
				if (fNDotD > fDotProductBest)
				{
					iFinBinBest = iFinBin;
					fDotProductBest = fNDotD;
				}
			}
			assert(iFinBinBest != -1);	// we must have found at least one bin
			FinBin *pFinBinBest = &m_rFinBin[iFinBinBest];
			UINT iFinBest =	pFinBinBest->m_dwNumFins++;	// increment the fin count for the best bin
			// get range of normal deviation for this bin
			float fNDotE = D3DXVec3Dot(&normalFace, &pFinBinBest->m_vDirection);
			if (pFinBinBest->m_fDirectionThreshold > fNDotE)
				pFinBinBest->m_fDirectionThreshold = fNDotE;

			// Copy the base and offset vertices
			FinVertex *pFinVertex;
			hr = pFinBinBest->m_pFinVB->Lock(4 * iFinBest * dwFinVertexSize, 4 * dwFinVertexSize, (BYTE **)&pFinVertex, 0);
			if (FAILED(hr))
				goto e_Exit;
			float fEps = 1e-5f; // make slight offset from surface
			float u0 = rVertex[iVertex0].tu + rVertex[iVertex0].tv;	// initial point texture coordinate
			float u1 = u0 + fEdgeTextureScale * fEdgeLength;
			
			pFinVertex[0].position = rVertex[iVertex0].v;
			pFinVertex[0].normal = rVertex[iVertex0].norm;
			pFinVertex[0].tex1.x = u0;
			pFinVertex[0].tex1.y = fEps; // slight offset
			pFinVertex[0].normalFace = normalFace;
		
			pFinVertex[1].position = rVertex[iVertex0].v; // extrusion done in fin.vsh, based on tex1.y
			pFinVertex[1].normal = rVertex[iVertex0].norm;
			pFinVertex[1].tex1.x = u0;
			pFinVertex[1].tex1.y = 1.f;
			pFinVertex[1].normalFace = normalFace;
		
			pFinVertex[2].position = rVertex[iVertex1].v; // extrusion done in fin.vsh, based on tex1.y
			pFinVertex[2].normal = rVertex[iVertex1].norm;
			pFinVertex[2].tex1.x = u1;
			pFinVertex[2].tex1.y = 1.f;
			pFinVertex[2].normalFace = normalFace;
		
			pFinVertex[3].position = rVertex[iVertex1].v;
			pFinVertex[3].normal = rVertex[iVertex1].norm;
			pFinVertex[3].tex1.x = u1;
			pFinVertex[3].tex1.y = fEps; // slight offset
			pFinVertex[3].normalFace = normalFace;
		
			pFinBinBest->m_pFinVB->Unlock();
		}
	}

	// Convert bin thresholds from dot products to angles, add in fade
	// threshold, then convert back to dot product. Since we're in the
	// monotonic region of cosine (0 to pi), this avoids an acos call
	// in the draw routine.
	// Original test: acos(NdotE) > acos(NdotB) + acos(fFinDotProductThreshold)
	// Modified test: NdotE > cos(acos(NdotB) + acos(fFinDotProductThreshold))
	// Runtime test: NdotE > fDirectionThreshold
	float f = acosf(m_fFinDotProductThreshold);
	for (iFinBin = 0; iFinBin < m_nFinBin; iFinBin++)
	{
		FinBin *pFinBin = &m_rFinBin[iFinBin];
		pFinBin->m_fDirectionThreshold = cosf(acosf(pFinBin->m_fDirectionThreshold) + f);
	}
	
e_Exit:
    if (rFin)
		delete [] rFin;
	if (rVertex)
		m_pVB->Unlock();
	if (FAILED(hr))
		CleanFins();
	return hr;
}

//-----------------------------------------------------------------------------
// Name: CleanFins
// Desc: clean up fin bins
//-----------------------------------------------------------------------------
HRESULT CXBFurMesh::CleanFins()
{
	for (UINT iFinBin = 0; iFinBin < m_nFinBin; iFinBin++)
	{
		FinBin *pFinBin = &m_rFinBin[iFinBin];
		SAFE_RELEASE(pFinBin->m_pFinVB);
	}
	SAFE_DELETE_ARRAY(m_rFinBin);
	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: ScaleTextureCoordinates
// Desc: Apply scale to texture coordinates
//-----------------------------------------------------------------------------
HRESULT CXBFurMesh::ScaleTextureCoordinates(float fUScale, float fVScale)
{
	HRESULT hr = S_OK;
	DWORD dwVertexSize = D3DXGetFVFVertexSize(FVF_XYZNORMTEX1);
	FVFT_XYZNORMTEX1 *rVertex;
	hr = m_pVB->Lock(0, m_dwNumVertices*dwVertexSize, (BYTE **)&rVertex, 0);
	if (FAILED(hr))
		return hr;
	for (UINT iVertex = 0; iVertex < m_dwNumVertices; iVertex++)
	{
		rVertex[iVertex].tu *= fUScale;
		rVertex[iVertex].tv *= fVScale;
	}
	m_pVB->Unlock();
	return hr;
}

//-----------------------------------------------------------------------------
// Name: DrawBaseMesh
// Desc: Draw the patch mesh on its own. Used to see exactly which triangles
//       are selected.
//-----------------------------------------------------------------------------
void CXBFurMesh::DrawBaseMesh()
{
	if(!m_dwNumIndices)			// make sure we have stuff to draw
		return;
	g_pd3dDevice->SetTexture(0, m_pTexture);
	g_pd3dDevice->SetVertexShader(m_dwGenericVS);
	g_pd3dDevice->SetStreamSource(0, m_pVB, sizeof(FVFT_XYZNORMTEX1));
	if (!m_pIB)
		g_pd3dDevice->DrawPrimitive(D3DPT_TRIANGLELIST, 0, m_dwNumIndices/3);
	else
	{
		g_pd3dDevice->SetIndices(m_pIB, 0);
		g_pd3dDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 0, m_dwNumVertices, 0, m_dwNumIndices/3);
	}
}

//-----------------------------------------------------------------------------
// Desc: Vertex shader constant registers must match fur.vsh and fin.vsh
//-----------------------------------------------------------------------------
#define VSC_WORLD_VIEW_PROJECTION 0
#define VSC_OFFSET 12
#define VSC_EYE 13
#define VSC_LIGHT 14
#define VSC_HALF 15 /* used only for directional lighting */
#define VSC_DIFFUSE 16
#define VSC_AMBIENT 17
#define VSC_SELFSHADOW 18
#define VSC_WIND1 20
#define VSC_WIND2 21
#define VSC_WIND3 22
#define VSC_FINFADE 23

static float s_fSelfShadowScale = 255.f; // amplication factor for the self shadow term
static D3DXCOLOR s_DiffuseConditioning(0.8f, 0.8f, 0.8f, 1.f);	// Banks' diffuse-conditioning term
static D3DXCOLOR s_AmbientConditioning(0.125f, 0.125f, 0.125f, 1.f);

//-----------------------------------------------------------------------------
// Name: Begin
// Desc: Setup texture stage and render state used for drawing both fur and fins.
//-----------------------------------------------------------------------------
void CXBFurMesh::Begin(D3DXVECTOR3 *pvEyePos, D3DXVECTOR3 *pvLightPos, D3DXMATRIX *pmatViewProjection)
{
	// Set up volume texture state.  The texture is set per-shell below.
	DWORD xx = 0;
	// No apparent perf improvement for ALPHAKILL_ENABLE, but does add pop artifact on LOD switch
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_ALPHAKILL, D3DTALPHAKILL_DISABLE /*D3DTALPHAKILL_ENABLE*/ );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_TEXCOORDINDEX, 0);
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_COLOROP, D3DTOP_MODULATE4X);
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_COLORARG1, D3DTA_TEXTURE );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_MIPFILTER, D3DTEXF_LINEAR );
	
	g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_ONE);	 // premultiplied alpha
	g_pd3dDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
	g_pd3dDevice->GetRenderState(D3DRS_LIGHTING, &m_DrawState.dwLighting);
	g_pd3dDevice->SetRenderState(D3DRS_LIGHTING, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_ALPHATESTENABLE, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_ALPHAFUNC, D3DCMP_GREATER);
	static DWORD dwAlphaRef = 0;
	g_pd3dDevice->SetRenderState(D3DRS_ALPHAREF, dwAlphaRef);

	// Set up hair lighting texture state
	xx = 1;
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_ALPHAKILL, D3DTALPHAKILL_DISABLE );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_TEXCOORDINDEX, 1);
#if ZOCKLER
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_ADDRESSU, D3DTADDRESS_MIRROR );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_ADDRESSV, D3DTADDRESS_MIRROR );
#else
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP );
#endif
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_COLOROP, D3DTOP_MODULATE2X );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_COLORARG1, D3DTA_TEXTURE );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_COLORARG2, D3DTA_CURRENT );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1 );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_ALPHAARG1, D3DTA_CURRENT );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_MIPFILTER, D3DTEXF_LINEAR );

	// Set up coarse level-of-detail texture
	xx = 2;
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_ALPHAKILL, D3DTALPHAKILL_DISABLE );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_TEXCOORDINDEX, 0);
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_ADDRESSU,  D3DTADDRESS_WRAP );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_ADDRESSV,  D3DTADDRESS_WRAP );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_COLOROP,   D3DTOP_DISABLE);
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_ALPHAOP,   D3DTOP_DISABLE);
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_MIPFILTER, D3DTEXF_LINEAR );

	// clear out the rest of the texture stages
	for (xx = 2; xx < 4; xx++)
	{
		g_pd3dDevice->SetTexture( xx, NULL);
		g_pd3dDevice->SetTextureStageState( xx, D3DTSS_COLOROP, D3DTOP_DISABLE);
		g_pd3dDevice->SetTextureStageState( xx, D3DTSS_ALPHAOP, D3DTOP_DISABLE);		
	}
	
	// For the Banks' self-shadowing attenuation factor, inside the vertex shader, 
	// we want (1-p)^d, where d = h / NdotL.   Since we have only expp which gives 
	// the result to the power of two, we use 2^(log2(1-p)*d), 
	// Since expp doesn't accept negative exponents, we negate it here and divide 
	// by the factor inside the shader.
	static float fEps = 1e-4f;
	static float fRho = 0.02f;	// attenuation factor, Banks
	m_DrawState.fSelfShadowLog2Attenuation =  -logf(1.f-fRho)/logf(2.f);
#if 1
	m_DrawState.vSelfShadow.x = fEps;	// min value for N dot L
	m_DrawState.vSelfShadow.y = s_fSelfShadowScale * m_DrawState.fSelfShadowLog2Attenuation;
#else
	float h = s_fSelfShadowScale*(m_DrawState.vOffset.y - m_DrawState.vOffset.x);
	m_DrawState.vSelfShadow.x = fEps;	// min value for N dot L
	extern bool g_bSelfShadow;	// DEBUG
	if (!g_bSelfShadow)
		m_DrawState.vSelfShadow.y = 0.f;
	else
		m_DrawState.vSelfShadow.y = h * m_DrawState.fSelfShadowLog2Attenuation;
#endif
	g_pd3dDevice->SetVertexShaderConstant(VSC_SELFSHADOW, &m_DrawState.vSelfShadow, 1);
	g_pd3dDevice->SetVertexShaderConstant(VSC_DIFFUSE, &s_DiffuseConditioning, 1);
	g_pd3dDevice->SetVertexShaderConstant(VSC_AMBIENT, &s_AmbientConditioning, 1);
	m_DrawState.vEyePos = *pvEyePos;
	m_DrawState.vLightPos = *pvLightPos;
	m_DrawState.matViewProjection = *pmatViewProjection;

	// Set fin fading constant
	D3DXVECTOR4 vFinFade(-m_fFinDotProductThreshold, 1.f/(1.f-m_fFinDotProductThreshold), 0.f, 0.f);
	g_pd3dDevice->SetVertexShaderConstant(VSC_FINFADE, &vFinFade, 1);
}

//-----------------------------------------------------------------------------
// Name: BeginObject
// Desc: Set matrix state in vertex shader constants
//-----------------------------------------------------------------------------
void CXBFurMesh::BeginObject(D3DXMATRIX *pmatWorld, D3DXMATRIX *pmatWorldInverse)
{
	// set display matrix
	D3DXMATRIX matWorldViewProjection;
	D3DXMatrixMultiply(&matWorldViewProjection, pmatWorld, &m_DrawState.matViewProjection);
	D3DXMatrixTranspose(&matWorldViewProjection, &matWorldViewProjection);
	g_pd3dDevice->SetVertexShaderConstant(VSC_WORLD_VIEW_PROJECTION, &matWorldViewProjection, 4);

	// Get direction of eye and light in object coords
	D3DXVec3TransformCoord(&m_DrawState.vEyeObject, &m_DrawState.vEyePos, pmatWorldInverse);
	D3DXVec3TransformCoord(&m_DrawState.vLightObject, &m_DrawState.vLightPos, pmatWorldInverse);
#if 0
	D3DXVECTOR3 vAt(0.f, 0.f, 0.f);	// center of object assumed to be at origin
#else
	extern D3DXVECTOR3 g_vLookAt;	// use same origin for all the objects
	D3DXVECTOR3 vAt;
	D3DXVec3TransformCoord(&vAt, &g_vLookAt, pmatWorldInverse);
#endif
	m_DrawState.vEyeDirection = m_DrawState.vEyeObject - vAt;
	D3DXVec3Normalize(&m_DrawState.vEyeDirection, &m_DrawState.vEyeDirection);
	m_DrawState.vLightDirection = m_DrawState.vLightObject - vAt;
	D3DXVec3Normalize(&m_DrawState.vLightDirection, &m_DrawState.vLightDirection);
	
	// set vertex shader light and eye positions (or directions for directional lighting) in object coords
	extern bool g_bLocalLighting;
	if (!g_bLocalLighting)
	{
		// directional lighting uses the same eye and light vectors for the whole object
		D3DXVECTOR3 vHalfDirection = (m_DrawState.vEyeDirection + m_DrawState.vLightDirection) * 0.5f;
		D3DXVec3Normalize(&vHalfDirection, &vHalfDirection);
		D3DXVECTOR4 vEye(m_DrawState.vEyeDirection.x, m_DrawState.vEyeDirection.y, m_DrawState.vEyeDirection.z, 0.f);
		D3DXVECTOR4 vLight(m_DrawState.vLightDirection.x, m_DrawState.vLightDirection.y, m_DrawState.vLightDirection.z, 0.f);
		D3DXVECTOR4 vHalf(vHalfDirection.x, vHalfDirection.y, vHalfDirection.z, 0.f);
		g_pd3dDevice->SetVertexShaderConstant(VSC_HALF, &vHalf, 1);
		g_pd3dDevice->SetVertexShaderConstant(VSC_EYE, &vEye, 1);
		g_pd3dDevice->SetVertexShaderConstant(VSC_LIGHT, &vLight, 1);
	}
	else
	{
		// local lighting computes eye and light vectors per vertex
		D3DXVECTOR4 vEye(m_DrawState.vEyeObject.x, m_DrawState.vEyeObject.y, m_DrawState.vEyeObject.z, 1.f);
		D3DXVECTOR4 vLight(m_DrawState.vLightObject.x, m_DrawState.vLightObject.y, m_DrawState.vLightObject.z, 1.f);
		g_pd3dDevice->SetVertexShaderConstant(VSC_EYE, &vEye, 1);
		g_pd3dDevice->SetVertexShaderConstant(VSC_LIGHT, &vLight, 1);
	}
	
	extern D3DXVECTOR4 g_vWind1; // source position in x,y,z, local magnitude in w
	extern D3DXVECTOR4 g_vWind2; // source up, w = out-of-tangent plane fraction
	extern D3DXVECTOR4 g_vWind3; // source left
	g_pd3dDevice->SetVertexShaderConstant(VSC_WIND1, &g_vWind1, 1);
	g_pd3dDevice->SetVertexShaderConstant(VSC_WIND2, &g_vWind2, 1);
	g_pd3dDevice->SetVertexShaderConstant(VSC_WIND3, &g_vWind3, 1);
}

//-----------------------------------------------------------------------------
// Name: DrawFins
// Desc: Draw the extruded edges
//-----------------------------------------------------------------------------
void CXBFurMesh::DrawFins(CXBFur *pFur, DWORD dwFinVS, float fFinLODFull, float fFinLODCutoff, float fFinExtraNormalScale)
{
	if (!pFur->m_pFinTexture) return;
	if (pFur->m_fLevelOfDetail > fFinLODCutoff) return;
	
	// Set hair lighting texture
	DWORD xx = 1;
	g_pd3dDevice->SetTexture( xx, pFur->m_pHairLightingTexture);

	// Setup texture stage and render state for drawing fins.
	m_DrawState.vOffset = D3DXVECTOR4(pFur->m_fYSize, pFur->m_fYSize, 0.5f, 0.f);
	m_DrawState.vOffset.x = m_DrawState.vOffset.y = fFinExtraNormalScale * pFur->m_fYSize;
	g_pd3dDevice->SetVertexShaderConstant(VSC_OFFSET, &m_DrawState.vOffset, 1);
	g_pd3dDevice->SetVertexShader(dwFinVS);
	g_pd3dDevice->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);
	g_pd3dDevice->SetRenderState(D3DRS_ZWRITEENABLE, FALSE);
	// fade fins based on LOD transition range
	if (pFur->m_fLevelOfDetail >= fFinLODFull)
	{
		float f = 1.f - (pFur->m_fLevelOfDetail - fFinLODFull) / (fFinLODCutoff - fFinLODFull);
		D3DXCOLOR diffuseFade = f * f * s_DiffuseConditioning;
		g_pd3dDevice->SetVertexShaderConstant(VSC_DIFFUSE, &diffuseFade, 1);
	}
	else
		g_pd3dDevice->SetVertexShaderConstant(VSC_DIFFUSE, &s_DiffuseConditioning, 1);
	g_pd3dDevice->SetPixelShader(NULL);
	xx = 0; // volume texture
	g_pd3dDevice->SetTexture( xx, pFur->m_pFinTexture);
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_TEXCOORDINDEX, 0);
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_COLOROP, D3DTOP_MODULATE2X );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_COLORARG1, D3DTA_TEXTURE );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_ALPHAOP, D3DTOP_MODULATE);
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE ); // fin fade
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_ALPHAKILL, D3DTALPHAKILL_DISABLE /*D3DTALPHAKILL_ENABLE*/ );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_ADDRESSU,  D3DTADDRESS_WRAP );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP ); // don't wrap tips of hair
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_MIPFILTER, D3DTEXF_LINEAR );
	// leave stage 1, hair lighting texture
	xx = 2; // disable stage 2
	g_pd3dDevice->SetTexture( xx, NULL);
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_COLOROP, D3DTOP_DISABLE);
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_ALPHAOP, D3DTOP_DISABLE);

	// Draw the active fins
	for (UINT iFinBin = 0; iFinBin < m_nFinBin; iFinBin++)
	{
		FinBin *pFinBin = &m_rFinBin[iFinBin];
		if (pFinBin->m_dwNumFins == 0) continue; // skip empty bins
		float fNDotE = D3DXVec3Dot(&m_DrawState.vEyeDirection, &pFinBin->m_vDirection);
		if (fNDotE < pFinBin->m_fDirectionThreshold)
			continue; // skip fins that are outside the active cone of normals
		// draw the active fins
		g_pd3dDevice->SetStreamSource(0, pFinBin->m_pFinVB, sizeof(FinVertex));
		g_pd3dDevice->DrawPrimitive(D3DPT_QUADLIST, 0, pFinBin->m_dwNumFins);
	}
	// Cleanup after drawing fins.
	g_pd3dDevice->SetRenderState(D3DRS_CULLMODE, D3DCULL_CCW);
}

//-----------------------------------------------------------------------------
// Name: DrawShells
// Desc: Draw the fuzz patch as layers of texture using alpha blending
//-----------------------------------------------------------------------------
void CXBFurMesh::DrawShells(CXBFur *pFur, DWORD dwFurVS, DWORD dwFurPS[3])
{
	g_pd3dDevice->SetVertexShaderConstant(VSC_DIFFUSE, &s_DiffuseConditioning, 1); // restore diffuse conditioning value
	g_pd3dDevice->SetRenderState(D3DRS_ZWRITEENABLE, TRUE);

	DWORD ixxVolumeTexture = 0;
	DWORD xx = ixxVolumeTexture;
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_COLORARG1, D3DTA_TEXTURE);
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_ALPHAKILL, D3DTALPHAKILL_DISABLE /*D3DTALPHAKILL_ENABLE*/);
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_TEXCOORDINDEX, 0);
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_ADDRESSU,  D3DTADDRESS_WRAP );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_ADDRESSV,  D3DTADDRESS_WRAP );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_MIPFILTER, D3DTEXF_LINEAR );

	xx = 1; // hair lighting texture
	g_pd3dDevice->SetTexture( xx, pFur->m_pHairLightingTexture);
	
	g_pd3dDevice->SetVertexShader(dwFurVS);
	g_pd3dDevice->SetStreamSource(0, m_pVB, sizeof(FVFT_XYZNORMTEX1));
	if (m_pIB) g_pd3dDevice->SetIndices(m_pIB, 0);
	UINT iLOD = pFur->m_iLOD > pFur->m_dwLODMax ? pFur->m_dwLODMax : pFur->m_iLOD;
	float fOffset = pFur->m_fYSize * (float)(1 << iLOD) / (float)pFur->m_dwNumSlices;
	for(UINT i=0; i<pFur->m_dwNumSlicesLOD; i++)
	{
		// set shell offset
		m_DrawState.vOffset = D3DXVECTOR4((i + 1) * fOffset, pFur->m_fYSize, 0.5f, 0.f);
		g_pd3dDevice->SetVertexShaderConstant(VSC_OFFSET, &m_DrawState.vOffset, 1);

		// Set pixel shaders and constants to fade even levels to clear and
		// odd levels to coarser level approximations that include the composited even levels.
		g_pd3dDevice->SetTexture(ixxVolumeTexture, pFur->m_pSliceTextureLOD[i]);
		if (pFur->m_fLODFraction == 0.f)
		{
			// on a level-of-detail boundary, do not blend between slice textures. 
			g_pd3dDevice->SetPixelShader(dwFurPS[0]);
			g_pd3dDevice->SetTexture(2, NULL);
			g_pd3dDevice->SetTextureStageState(2, D3DTSS_COLOROP, D3DTOP_DISABLE);
			g_pd3dDevice->SetTextureStageState(2, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
		}
		else
		{
			if (i & 1)	// odd level
			{
				// fade odd level to coarser texture as fraction goes to 1
				UINT nLOD = pFur->LevelOfDetailCount(pFur->m_iLOD);
				LPDIRECT3DTEXTURE8 pTextureLOD = (pFur->m_pSliceTextureLOD + nLOD)[i >> 1];
				xx = 2;
				g_pd3dDevice->SetPixelShader(dwFurPS[1]);
				g_pd3dDevice->SetTexture( xx, pTextureLOD);
				g_pd3dDevice->SetTextureStageState( xx, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
				g_pd3dDevice->SetTextureStageState( xx, D3DTSS_COLORARG1, D3DTA_TEXTURE);
				g_pd3dDevice->SetTextureStageState( xx, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
				g_pd3dDevice->SetTextureStageState( xx, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
				g_pd3dDevice->SetTextureStageState( xx, D3DTSS_ALPHAKILL, D3DTALPHAKILL_DISABLE /* D3DTALPHAKILL_ENABLE */ );
				g_pd3dDevice->SetTextureStageState( xx, D3DTSS_TEXCOORDINDEX, 0);	
				g_pd3dDevice->SetTextureStageState( xx, D3DTSS_ADDRESSU,  D3DTADDRESS_WRAP );
				g_pd3dDevice->SetTextureStageState( xx, D3DTSS_ADDRESSV,  D3DTADDRESS_WRAP );
				g_pd3dDevice->SetTextureStageState( xx, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
				g_pd3dDevice->SetTextureStageState( xx, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
				g_pd3dDevice->SetTextureStageState( xx, D3DTSS_MIPFILTER, D3DTEXF_LINEAR );
			}
			else // even level
			{
				// fade even level to clear as fraction goes to 1
				g_pd3dDevice->SetPixelShader(dwFurPS[2]);
				xx = 2;
				g_pd3dDevice->SetTexture( xx, NULL);
				g_pd3dDevice->SetTextureStageState( xx, D3DTSS_COLOROP, D3DTOP_DISABLE);
				g_pd3dDevice->SetTextureStageState( xx, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
			}
			D3DXCOLOR colorFraction(pFur->m_fLODFraction, pFur->m_fLODFraction, pFur->m_fLODFraction, pFur->m_fLODFraction);
			g_pd3dDevice->SetPixelShaderConstant(0, &colorFraction, 1);
		}

		// Draw the offset mesh
		if (!m_pIB)
			g_pd3dDevice->DrawPrimitive(D3DPT_TRIANGLELIST, 0, m_dwNumIndices/3);
		else
		{
			static bool bReverseOrder = false;
			if (bReverseOrder)
			{
				UINT FaceCount = m_dwNumIndices / 3;
				for (UINT iFace = 0; iFace < FaceCount; iFace++)
					g_pd3dDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 0, m_dwNumVertices, (FaceCount - 1 - iFace) * 3, 1);
			}
			else
				g_pd3dDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 0, m_dwNumVertices, 0, m_dwNumIndices/3);
		}
	}
}

//-----------------------------------------------------------------------------
// Name: EndObject
// Desc: Cleanup after drawing a furry object
//-----------------------------------------------------------------------------
void CXBFurMesh::EndObject()
{
	// currently does nothing
}

//-----------------------------------------------------------------------------
// Name: End
// Desc: Cleanup after drawing fins and fur
//-----------------------------------------------------------------------------
void CXBFurMesh::End()
{
	// Cleanup render and texture stage states.
	g_pd3dDevice->SetRenderState(D3DRS_LIGHTING, m_DrawState.dwLighting);
	g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_ALPHATESTENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_ZWRITEENABLE, TRUE);
	for (UINT iTexStage = 0; iTexStage < 4; iTexStage++)
	{
		g_pd3dDevice->SetTexture( iTexStage, NULL);
		g_pd3dDevice->SetTextureStageState( iTexStage, D3DTSS_MIPFILTER, D3DTEXF_NONE);
		g_pd3dDevice->SetTextureStageState( iTexStage, D3DTSS_ALPHAKILL, D3DTALPHAKILL_DISABLE );
	}
	g_pd3dDevice->SetPixelShader(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\grass\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\fur\XBFur.h ===
#pragma once
//-----------------------------------------------------------------------------
// File: XBFur.h
//
// Copyright (c) 2000-2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifdef _XBOX
#include <xtl.h>
#else
#include <d3d8.h>
#endif
#include "xfvf.h"

#define XBFUR_MAXSLICE_LOG2 5
#define XBFUR_MAXSLICE (1 << XBFUR_MAXSLICE_LOG2)

extern float g_fOneInch;

// patch generation

// a fuzz is a single hair follicle, blade of grass, etc.
struct Fuzz
{
	D3DVECTOR dp;			// velocity
	D3DVECTOR ddp;			// acceleration
	D3DXCOLOR colorBase;
	D3DXCOLOR colorTip;
};

// a fuzz instance is a single instance of a fuzz
// located at x, z on the patch
// we create only a limited number of unique fuzzes
// and index the library with lidx.
struct FuzzInst
{
	float x, z;				// fuzz location
	int lidx;				// library index
};

// a fur patch is a volume that holds fuzzes.
// xsize and zsize are chosen by the user
// ysize is calculated using the height of the 
// tallest fuzz
class CXBFur
{
	friend class CXBFurMesh;
public:
	DWORD m_dwSeed;			// patch seed
	
	float m_fXSize;			// patch size in world coords
	float m_fYSize;
	float m_fZSize;

	// fuzz library
	DWORD m_dwNumSegments;	// # of segments in highest LOD
	Fuzz m_fuzzCenter;		// fuzz constant
	Fuzz m_fuzzRandom;		// random offset around center
	DWORD m_dwNumFuzzLib;	// # of fuzz in the library
	Fuzz *m_pFuzzLib;		// fuzz library

	// fuzz instances
	DWORD m_dwNumFuzz;		// # of fuzz in this patch
	FuzzInst *m_pFuzz;

	// patch volume
	DWORD m_dwNumSlices;	// # of layers in the volume
	DWORD m_dwSliceSize;		// width*height
	DWORD m_dwSliceXSize;		// width of volume texture slice
	DWORD m_dwSliceZSize;		// height of volume texture slice
	LPDIRECT3DTEXTURE8 m_apSliceTexture[XBFUR_MAXSLICE * 2 - 1];	// slices of volume texture
					// ... followed by level-of-detail textures  N/2, N/4, N/8, ... 1

	// LOD textures
	DWORD m_dwNumSlicesLOD; // number of slices in current level of detail
	float m_fLevelOfDetail;	// current LOD value
	DWORD m_iLOD;			// current integer LOD value
	float m_fLODFraction;	// fraction towards next coarser level-of-detail
	DWORD m_dwLODMax;		// maximum LOD index
	LPDIRECT3DTEXTURE8 *m_pSliceTextureLOD; // current level of detail pointer into m_apSliceTexture array

	// hair lighting texture
	D3DMATERIAL8 m_HairLightingMaterial;
	LPDIRECT3DTEXTURE8 m_pHairLightingTexture;

	// fin texture
	DWORD m_finWidth, m_finHeight;		// size of fin texture
	float m_fFinXFraction, m_fFinZFraction;	// portion of hair texture to put into fin
	LPDIRECT3DTEXTURE8 m_pFinTexture;	// texture projected from the side

	CXBFur();
	~CXBFur();
	void InitFuzz(DWORD nfuzz, DWORD nfuzzlib);
	void GenSlices(DWORD nslices, DWORD slicexsize, DWORD slicezsize);
	void GenFin(DWORD finWidth, DWORD finHeight, float fFinXFraction, float fFinZFraction);
	void GetLinesVertexBuffer(IDirect3DVertexBuffer8 **ppVB);
	void RenderLines();
	void Save(char *fname, int flags);
	void Load(char *fname);
	HRESULT SetHairLightingMaterial(D3DMATERIAL8 *pMaterial);
	void SetPatchSize(float x, float z)
	{
		m_fXSize = x;
		m_fZSize = z;
		InitFuzz(m_dwNumFuzz, m_dwNumFuzzLib);	// re-init the fuzz. automatically sets ysize
	};
	void SetFVel(float cx, float cy, float cz, float rx, float ry, float rz)
	{
		m_fuzzCenter.dp.x = cx; m_fuzzCenter.dp.y = cy; m_fuzzCenter.dp.z = cz;
		m_fuzzRandom.dp.x = rx; m_fuzzRandom.dp.y = ry; m_fuzzRandom.dp.z = rz;
	};
	void SetFAcc(float cx, float cy, float cz, float rx, float ry, float rz)
	{
		m_fuzzCenter.ddp.x = cx; m_fuzzCenter.ddp.y = cy; m_fuzzCenter.ddp.z = cz;
		m_fuzzRandom.ddp.x = rx; m_fuzzRandom.ddp.y = ry; m_fuzzRandom.ddp.z = rz;
	};

	// fLevelOfDetail can range from 0 to log2(NumSlices)
	HRESULT SetLevelOfDetail(float fLevelOfDetail);
	HRESULT ComputeLevelOfDetailTextures();
	inline UINT LevelOfDetailCount(UINT iLOD)
	{
		return m_dwNumSlices >> iLOD;
	}
	inline UINT LevelOfDetailIndex(UINT iLOD)
	{
		UINT offset = 0;
		for (UINT i = 1; i <= iLOD; i++)
			offset += LevelOfDetailCount(i-1);
		return offset;
	}
	inline UINT TotalTextureCount()
	{
		UINT TextureCount = 0;
		for (UINT iLOD = 0; m_dwNumSlices >> iLOD; iLOD++)
			TextureCount += LevelOfDetailCount(iLOD);
		return TextureCount;
	}

	// Compress textures one at a time until all are done.
	// Returns S_OK when all the textures are in fmtNew format.
	// Returns S_FALSE if there are textures still to be done.
	HRESULT CompressNextTexture(D3DFORMAT fmtNew, UINT *pTextureIndex);
};

HRESULT FillHairLightingTexture(D3DMATERIAL8 *pMaterial, LPDIRECT3DTEXTURE8 pTexture);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\FuzzyTeapot\FuzzyTeapot.cpp ===
//-----------------------------------------------------------------------------
// File: FuzzyTeapot.cpp
//
// Desc: Example code showing how to use volume textures for simulating fuzzy
//       surfaces.
//
// Hist: 01.13.00 - New for February XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <XBMesh.h>
#include <XBUtil.h>
#include <xgraphics.h>




//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_LEFTSTICK,    XBHELP_PLACEMENT_1, L"Rotate" },
    { XBHELP_DPAD,         XBHELP_PLACEMENT_1, L"Zoom" },
    { XBHELP_A_BUTTON,     XBHELP_PLACEMENT_1, L"Add fuzz" },
    { XBHELP_B_BUTTON,     XBHELP_PLACEMENT_1, L"Remove fuzz" },
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_1, L"Toggle help" },
};

#define NUM_HELP_CALLOUTS 5




//-----------------------------------------------------------------------------
// Defines, constants, and global variables
//-----------------------------------------------------------------------------
const int   MAX_LAYERS =  8;
const FLOAT LAYER_BIAS =  0.02f;
const int   VOLTEXSIZE = 16;

#define irand(a) ((rand()*(a))>>15)
#define frand(a) ((float)rand()*(a)/32768.0f)

struct FUZZVERTEX
{
    FLOAT x, y, z;
    FLOAT tu, tv, tw;
};

#define D3DFVF_FUZZVERTEX (D3DFVF_XYZ|D3DFVF_TEX1|D3DFVF_TEXCOORDSIZE3(0))




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Application class. The base class provides just about all the
//       functionality we want, so we're just supplying stubs to interface with
//       the non-C++ functions of the app.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBFont                  m_Font;                     // Font class
    CXBHelp                  m_Help;                     // Help class
    BOOL                     m_bDrawHelp;                // Whether to draw help

    CXBMesh                  m_Mesh;                     // Mesh geometry
    LPDIRECT3DVERTEXBUFFER8  m_pMeshVB;
    LPDIRECT3DINDEXBUFFER8   m_pMeshIB;
    DWORD                    m_dwNumMeshVertices;
    DWORD                    m_dwNumMeshIndices;
    DWORD                    m_dwMeshFVF;
    DWORD                    m_dwMeshVertexSize;
    D3DPRIMITIVETYPE         m_dwMeshPrimType;
    DWORD                    m_dwNumMeshPrimitives;

    DWORD                    m_dwNumFuzzLayers;           // Num fuzz layers to render
    LPDIRECT3DVERTEXBUFFER8  m_pMeshFuzzVB[MAX_LAYERS];   // VBs for fuzz layers
    LPDIRECT3DVOLUMETEXTURE8 m_pFuzzTexture;              // Volume texture for fuzz

    HRESULT CreateFuzzLayers();                           // Creates fuzz layer VBs
    HRESULT CreateFuzzTexture();                          // Creates fuzz volume texture

public:
    HRESULT Initialize();
    HRESULT FrameMove();
    HRESULT Render();
    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Application constructor. Sets attributes for the app.
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    m_bDrawHelp          = FALSE;
    m_dwNumFuzzLayers    = MAX_LAYERS;
    m_pFuzzTexture       = NULL;
}




//-----------------------------------------------------------------------------
// Name: CreateFuzzLayers()
// Desc: Creates a separate VB for each fuzz layer. Each VB is a copy of the
//       original mesh's VB, but scaled slightly along vertex normals.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::CreateFuzzLayers()
{
    struct MESHVERTEX
    {
        D3DXVECTOR3 p;
        D3DXVECTOR3 n;
    };

    MESHVERTEX* pSrcVertices;
    m_pMeshVB->Lock( 0, 0, (BYTE**)&pSrcVertices, 0 );

    for( DWORD dwLayer = 0; dwLayer < MAX_LAYERS; dwLayer++ )
    {
        if( FAILED( m_pd3dDevice->CreateVertexBuffer( m_dwNumMeshVertices * sizeof(FUZZVERTEX),
                                                      D3DUSAGE_WRITEONLY ,
                                                      D3DFVF_FUZZVERTEX,
                                                      D3DPOOL_DEFAULT, &m_pMeshFuzzVB[dwLayer] ) ) )
            return E_FAIL;

        FUZZVERTEX* pDstVertices;
        m_pMeshFuzzVB[dwLayer]->Lock( 0, 0, (BYTE**)&pDstVertices, 0 );

        for( DWORD i=0; i<m_dwNumMeshVertices; i++ )
        {
            pDstVertices[i].x  = pSrcVertices[i].p.x + dwLayer * LAYER_BIAS * pSrcVertices[i].n.x;
            pDstVertices[i].y  = pSrcVertices[i].p.y + dwLayer * LAYER_BIAS * pSrcVertices[i].n.y;
            pDstVertices[i].z  = pSrcVertices[i].p.z + dwLayer * LAYER_BIAS * pSrcVertices[i].n.z;

            pDstVertices[i].tu = 3.0f * atanf( pDstVertices[i].x / pDstVertices[i].z );
            pDstVertices[i].tv = 3.0f * atanf( pDstVertices[i].y / pDstVertices[i].x );
            pDstVertices[i].tw = ((FLOAT)dwLayer)/MAX_LAYERS;
        }

        m_pMeshFuzzVB[dwLayer]->Unlock();
    }
    
    m_pMeshVB->Unlock();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CreateFuzzTexture()
// Desc: Creates the volume texture for the fuzz
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::CreateFuzzTexture()
{
    HRESULT hr;

    // Create a volume texture
    hr = m_pd3dDevice->CreateVolumeTexture( VOLTEXSIZE, VOLTEXSIZE, VOLTEXSIZE, 
                                            1, 0, D3DFMT_A8R8G8B8, 
                                            D3DPOOL_MANAGED, &m_pFuzzTexture );
    if( FAILED(hr) )
        return hr;

    // Fill the volume texture with hair
    D3DVOLUME_DESC desc;
    D3DLOCKED_BOX lock;
    m_pFuzzTexture->GetLevelDesc( 0, &desc );
    m_pFuzzTexture->LockBox( 0, &lock, 0, 0 );
    ZeroMemory( lock.pBits, VOLTEXSIZE*VOLTEXSIZE*VOLTEXSIZE*4 );
    
    for( UINT u=0; u<VOLTEXSIZE; u++ )
    {
        for( UINT v=0; v<VOLTEXSIZE; v++ )
        {
            if( frand(1) >= 0.33f )
            {
                DWORD r = 0xff;
                DWORD g = 0xcc;
                DWORD b = 0x44;
                DWORD a = 0xff;
                DWORD dwADec = 0xff/VOLTEXSIZE + irand(8);

                for( UINT w=0; w<VOLTEXSIZE; w++ )
                {
                    BYTE* pBits = (BYTE *)lock.pBits + u*4 + lock.RowPitch * v + lock.SlicePitch * w ;
                    // Write the texel
                    *(DWORD*)pBits = (a<<24) + (r<<16) + (g<<8) + (b<<0);
                    
                    if( a > dwADec ) a -= dwADec;
                    else             a  = 0;
                }
            }
        }
    }

    // Swizzle and unlock the texture
    XBUtil_SwizzleTexture3D( &lock, &desc );
    m_pFuzzTexture->UnlockBox( 0 );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create the font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the font
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create a mesh (vertex and index buffers)
    if( FAILED( m_Mesh.Create( m_pd3dDevice, "Models\\Teapot.xbg" ) ) )
        return XBAPPERR_MEDIANOTFOUND;
    m_pMeshVB             = &m_Mesh.GetMesh(0)->m_VB;
    m_dwNumMeshVertices   =  m_Mesh.GetMesh(0)->m_dwNumVertices;
    m_pMeshIB             = &m_Mesh.GetMesh(0)->m_IB;
    m_dwNumMeshIndices    =  m_Mesh.GetMesh(0)->m_dwNumIndices;
    m_dwMeshFVF           =  m_Mesh.GetMesh(0)->m_dwFVF;
    m_dwMeshVertexSize    =  m_Mesh.GetMesh(0)->m_dwVertexSize;
    m_dwMeshPrimType      =  m_Mesh.GetMesh(0)->m_dwPrimType;
    m_dwNumMeshPrimitives = (D3DPT_TRIANGLELIST==m_dwMeshPrimType) ? m_dwNumMeshIndices/3 : m_dwNumMeshIndices-2;

    // Create the geoemtry for the fuzz
    if( FAILED( CreateFuzzLayers() ) )
        return E_FAIL;

    // Create the volume texture for the fuzz
    if( FAILED( CreateFuzzTexture() ) )
        return E_FAIL;

    // Set up proj matrix
    D3DXMATRIX matProj;
    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/4, 4.0f/3.0f, 1.0f, 200.0f );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );

    // Setup a base material
    D3DMATERIAL8 mtrl;
    XBUtil_InitMaterial( mtrl, 1.0f, .5f, .5f, .5f );
    m_pd3dDevice->SetMaterial( &mtrl );

    // Setup a light
    D3DLIGHT8 light;
    XBUtil_InitLight( light, D3DLIGHT_DIRECTIONAL, -0.5f, -1.0f, 1.0f );
    light.Diffuse.r = 1.0f;
    light.Diffuse.g = 1.0f;
    light.Diffuse.b = 0.0f;
    m_pd3dDevice->SetLight( 0, &light );
    m_pd3dDevice->LightEnable( 0, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING, TRUE );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK )
      m_bDrawHelp = !m_bDrawHelp;

    // Add or remove fuzz layers
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_A] )
    {
        if( m_dwNumFuzzLayers < MAX_LAYERS )
            m_dwNumFuzzLayers++;
    }
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_B] )
    {
        if( m_dwNumFuzzLayers > 0 )
            m_dwNumFuzzLayers--;
    }

    // Set up view matrix
    static D3DXVECTOR3 vEyePt( 0,0,-6 );
    if( m_DefaultGamepad.wButtons & XINPUT_GAMEPAD_DPAD_UP )
        vEyePt.z += 10.0f*m_fElapsedTime;
    if( m_DefaultGamepad.wButtons & XINPUT_GAMEPAD_DPAD_DOWN )
        vEyePt.z -= 10.0f*m_fElapsedTime;

    D3DXMATRIX matView;
    D3DXMatrixLookAtLH( &matView, &vEyePt, &D3DXVECTOR3(0,0,0), &D3DXVECTOR3(0,1,0) );
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );

    // Setup object matrix
    D3DXMATRIX matRotate;
    FLOAT fXRotate = m_DefaultGamepad.fX1*D3DX_PI*m_fElapsedTime;
    FLOAT fYRotate = m_DefaultGamepad.fY1*D3DX_PI*m_fElapsedTime;
    D3DXMatrixRotationYawPitchRoll( &matRotate, -fXRotate, -fYRotate, 0.0f );
    
    static D3DXMATRIX  matWorld( 1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1 );
    matWorld._41 = matWorld._42 = 0.f;
    D3DXMatrixMultiply( &matWorld, &matWorld, &matRotate );
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Clear the zbuffer
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL, 
                         0x00000000, 1.0f, 0L );
    
    // Draw a gradient filled background
    RenderGradientBackground( 0xff000000, 0xff0000ff );

    // Set default state
    m_pd3dDevice->SetTexture( 0, NULL );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU,    D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV,    D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSW,    D3DTADDRESS_WRAP );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,          TRUE ); 
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE ); 
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_AMBIENT,          0xffffffff );

    // Draw the underlying (fuzzless) mesh
    m_pd3dDevice->SetVertexShader( m_dwMeshFVF );
    m_pd3dDevice->SetIndices( m_pMeshIB, 0 );
    m_pd3dDevice->SetStreamSource( 0, m_pMeshVB, m_dwMeshVertexSize );
    m_pd3dDevice->DrawIndexedPrimitive( m_dwMeshPrimType, 0, m_dwNumMeshIndices,
                                        0, m_dwNumMeshPrimitives );

    // Setup states for drawing the fuzz, using the volume texture
    m_pd3dDevice->SetTexture( 0, m_pFuzzTexture );
    m_pd3dDevice->SetVertexShader( D3DFVF_FUZZVERTEX );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,         D3DBLEND_SRCALPHA );
    m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND,        D3DBLEND_INVSRCALPHA );

    // Draw the fuzz layers
    for( DWORD i = 0; i < m_dwNumFuzzLayers; i++ )
    {
        m_pd3dDevice->SetIndices( m_pMeshIB, 0 );
        m_pd3dDevice->SetStreamSource( 0, m_pMeshFuzzVB[i], sizeof(FUZZVERTEX) );
        m_pd3dDevice->DrawIndexedPrimitive( m_dwMeshPrimType, 0, m_dwNumMeshIndices,
                                            0, m_dwNumMeshPrimitives );
    }

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        m_Font.Begin();
        m_Font.DrawText(  64, 50, 0xffffffff, L"FuzzyTeapot" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );

        WCHAR str[40];
        swprintf( str, L"Fuzz Layers: %d", m_dwNumFuzzLayers );
        m_Font.DrawText( 64, 90, 0xffffff00, str );

        m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\MatrixPaletteSkinning\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\grass\XBGrass.h ===
#pragma once
//-----------------------------------------------------------------------------
// File: XBGrass.h
//
// Copyright (c) 2000-2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifdef _XBOX
#include <xtl.h>
#else
#include <d3d8.h>
#endif
#include "xfvf.h"

#define XBGRASS_MAXSLICE_LOG2 5
#define XBGRASS_MAXSLICE (1 << XBGRASS_MAXSLICE_LOG2)

extern float g_fOneInch;

// patch generation

// a fuzz is a single hair follicle, blade of grass, etc.
struct Fuzz
{
	D3DVECTOR dp;			// velocity
	D3DVECTOR ddp;			// acceleration
	D3DXCOLOR colorBase;
	D3DXCOLOR colorTip;
};

// a fuzz instance is a single instance of a fuzz
// located at x, z on the patch
// we create only a limited number of unique fuzzes
// and index the library with lidx.
struct FuzzInst
{
	float x, z;				// fuzz location
	int lidx;				// library index
};

// a grass patch is a volume that holds fuzzes.
// xsize and zsize are chosen by the user
// ysize is calculated using the height of the 
// tallest fuzz
class CXBGrass
{
	friend class CXBGrassMesh;
public:
	DWORD m_dwSeed;			// patch seed
	
	float m_fXSize;			// patch size in world coords
	float m_fYSize;
	float m_fZSize;

	// fuzz library
	DWORD m_dwNumSegments;	// # of segments in highest LOD
	Fuzz m_fuzzCenter;		// fuzz constant
	Fuzz m_fuzzRandom;		// random offset around center
	DWORD m_dwNumFuzzLib;	// # of fuzz in the library
	Fuzz *m_pFuzzLib;		// fuzz library

	// fuzz instances
	DWORD m_dwNumFuzz;		// # of fuzz in this patch
	FuzzInst *m_pFuzz;

	// patch volume
	DWORD m_dwNumSlices;	// # of layers in the volume
	DWORD m_dwSliceSize;		// width*height
	DWORD m_dwSliceXSize;		// width of volume texture slice
	DWORD m_dwSliceZSize;		// height of volume texture slice
	LPDIRECT3DTEXTURE8 m_apSliceTexture[XBGRASS_MAXSLICE * 2 - 1];	// slices of volume texture
					// ... followed by level-of-detail textures  N/2, N/4, N/8, ... 1

	// LOD textures
	DWORD m_dwNumSlicesLOD; // number of slices in current level of detail
	float m_fLevelOfDetail;	// current LOD value
	DWORD m_iLOD;			// current integer LOD value
	float m_fLODFraction;	// fraction towards next coarser level-of-detail
	DWORD m_dwLODMax;		// maximum LOD index
	LPDIRECT3DTEXTURE8 *m_pSliceTextureLOD; // current level of detail pointer into m_apSliceTexture array

	// hair lighting texture
	D3DMATERIAL8 m_HairLightingMaterial;
	LPDIRECT3DTEXTURE8 m_pHairLightingTexture;

	// fin texture
	DWORD m_finWidth, m_finHeight;		// size of fin texture
	float m_fFinXFraction, m_fFinZFraction;	// portion of hair texture to put into fin
	LPDIRECT3DTEXTURE8 m_pFinTexture;	// texture projected from the side

	CXBGrass();
	~CXBGrass();
	void InitFuzz(DWORD nfuzz, DWORD nfuzzlib);
	void GenSlices(DWORD nslices, DWORD slicexsize, DWORD slicezsize);
	void GenFin(DWORD finWidth, DWORD finHeight, float fFinXFraction, float fFinZFraction);
	void GetLinesVertexBuffer(IDirect3DVertexBuffer8 **ppVB);
	void RenderLines();
	void Save(char *fname, int flags);
	void Load(char *fname);
	HRESULT SetHairLightingMaterial(D3DMATERIAL8 *pMaterial);
	void SetPatchSize(float x, float z)
	{
		m_fXSize = x;
		m_fZSize = z;
		InitFuzz(m_dwNumFuzz, m_dwNumFuzzLib);	// re-init the fuzz. automatically sets ysize
	};
	void SetFVel(float cx, float cy, float cz, float rx, float ry, float rz)
	{
		m_fuzzCenter.dp.x = cx; m_fuzzCenter.dp.y = cy; m_fuzzCenter.dp.z = cz;
		m_fuzzRandom.dp.x = rx; m_fuzzRandom.dp.y = ry; m_fuzzRandom.dp.z = rz;
	};
	void SetFAcc(float cx, float cy, float cz, float rx, float ry, float rz)
	{
		m_fuzzCenter.ddp.x = cx; m_fuzzCenter.ddp.y = cy; m_fuzzCenter.ddp.z = cz;
		m_fuzzRandom.ddp.x = rx; m_fuzzRandom.ddp.y = ry; m_fuzzRandom.ddp.z = rz;
	};

	// fLevelOfDetail can range from 0 to log2(NumSlices)
	HRESULT SetLevelOfDetail(float fLevelOfDetail);
	HRESULT ComputeLevelOfDetailTextures();
	inline UINT LevelOfDetailCount(UINT iLOD)
	{
		return m_dwNumSlices >> iLOD;
	}
	inline UINT LevelOfDetailIndex(UINT iLOD)
	{
		UINT offset = 0;
		for (UINT i = 1; i <= iLOD; i++)
			offset += LevelOfDetailCount(i-1);
		return offset;
	}
	HRESULT SetTextureFormat(D3DFORMAT fmtNew);
};

HRESULT FillHairLightingTexture(D3DMATERIAL8 *pMaterial, LPDIRECT3DTEXTURE8 pTexture);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\MatrixPaletteSkinning\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\grass\XBGrass.cpp ===
//-----------------------------------------------------------------------------
// File: XBGrass.cpp
//
// Desc: routines for generating and displaying a patch of grass,
//       which is a series of layers that give the appearance of
//       hair, fur, grass, or other fuzzy things.
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <assert.h>
#include <stdlib.h>
#include <stdio.h>

#ifdef _XBOX
#include <xtl.h>
#include <xgraphics.h>
#else
#include <d3d8.h>
#endif
#include "XBUtil.h"
#include "XBGrass.h"

extern LPDIRECT3DDEVICE8 g_pd3dDevice;

#define irand(a) ((rand()*(a))>>15)
#define frand(a) ((float)rand()*(a)/32768.0f)

float g_fOneInch = 0.01f;

//-----------------------------------------------------------------------------
// Name: Constructor
// Desc: 
//-----------------------------------------------------------------------------
CXBGrass::CXBGrass()
{
	DWORD i;
	ZeroMemory(this, sizeof(CXBGrass));

	// init default patch
	m_fXSize = 0.1f;
	m_fZSize = 0.1f;

	// init default fuzzlib
	m_dwNumFuzzLib = 0;
	m_pFuzzLib = NULL;
	m_fuzzCenter.colorBase = D3DXCOLOR(1.f, 1.f, 1.f, 1.f);
	m_fuzzCenter.colorTip = D3DXCOLOR(1.f, 1.f, 1.f, 0.f);
	m_fuzzCenter.dp.y = 1.0f;

	// init default fuzz
	m_dwNumSegments = 4;
	m_pFuzz = NULL;

	// init default volume
	m_dwNumSlices = 0;
	m_dwSliceXSize = 0;
	m_dwSliceZSize = 0;
	for(i=0; i<XBGRASS_MAXSLICE*2-1; i++)
		m_apSliceTexture[i] = NULL;
	m_pHairLightingTexture = NULL;
	m_pFinTexture = NULL;
	m_dwNumSlicesLOD = 0;
	m_pSliceTextureLOD = m_apSliceTexture;
	
	InitFuzz(1, 1);
}

//-----------------------------------------------------------------------------
// Name: Destructor
// Desc: 
//-----------------------------------------------------------------------------
CXBGrass::~CXBGrass()
{
	DWORD i;
	if(m_pFuzzLib)
		delete m_pFuzzLib;
	if(m_pFuzz)
		delete m_pFuzz;
	for(i=0; i<XBGRASS_MAXSLICE*2-1; i++)
		SAFE_RELEASE(m_apSliceTexture[i]);
	SAFE_RELEASE(m_pHairLightingTexture);
}

//-----------------------------------------------------------------------------
// Name: InitFuzz
// Desc: Initializes the individual strands of fuzz in the patch.
//       Only a small number of individual fuzzes are generated
//       (determined by m_dwNumFuzzLib) because each one in the patch
//       does not need to be unique.
//-----------------------------------------------------------------------------
void CXBGrass::InitFuzz(DWORD nfuzz, DWORD nfuzzlib)
{
	DWORD i;
	float y;

	if(nfuzz<=0 || nfuzzlib<0)
		return;
		
	// handle memory allocation
	if(m_dwNumFuzz!=nfuzz)				// if nfuzz has changed
	{
		if(m_pFuzz)
			delete m_pFuzz;				// nuke existing
		m_pFuzz = new FuzzInst[nfuzz];	// and get new fuzz memory
	}

	if(m_dwNumFuzzLib!=nfuzzlib)
	{
		if(m_pFuzzLib)
			delete m_pFuzzLib;

		m_pFuzzLib = new Fuzz[nfuzzlib];
	}

	m_dwNumFuzz = nfuzz;
	m_dwNumFuzzLib = nfuzzlib;

	// generate the individual fuzzes in the library
	m_fYSize = 0.0f;
	srand(m_dwSeed);
	for(i=0; i<m_dwNumFuzzLib; i++)
	{
		m_pFuzzLib[i].dp.x = (m_fuzzCenter.dp.x + m_fuzzRandom.dp.x*(2*frand(1.0f)-1.0f))*g_fOneInch;
		m_pFuzzLib[i].dp.y = (m_fuzzCenter.dp.y + m_fuzzRandom.dp.y*(2*frand(1.0f)-1.0f))*g_fOneInch;
		m_pFuzzLib[i].dp.z = (m_fuzzCenter.dp.z + m_fuzzRandom.dp.z*(2*frand(1.0f)-1.0f))*g_fOneInch;

		m_pFuzzLib[i].ddp.x = (m_fuzzCenter.ddp.x + m_fuzzRandom.ddp.x*(2*frand(1.0f)-1.0f))*g_fOneInch;
		m_pFuzzLib[i].ddp.y = (m_fuzzCenter.ddp.y + m_fuzzRandom.ddp.y*(2*frand(1.0f)-1.0f))*g_fOneInch;
		m_pFuzzLib[i].ddp.z = (m_fuzzCenter.ddp.z + m_fuzzRandom.ddp.z*(2*frand(1.0f)-1.0f))*g_fOneInch;

		m_pFuzzLib[i].colorBase = m_fuzzCenter.colorBase + (2*frand(1.f)-1.f)*m_fuzzRandom.colorBase;
		m_pFuzzLib[i].colorTip = m_fuzzCenter.colorTip + (2*frand(1.f)-1.f)*m_fuzzRandom.colorTip;

		y = m_pFuzzLib[i].dp.y + 0.5f*m_pFuzzLib[i].ddp.y;
		if(y>m_fYSize)
			m_fYSize = y;
	}

 	// initialize the fuzz locations & pick a random fuzz from the library
	srand(m_dwSeed*54795);
	for(i=0; i<m_dwNumFuzz; i++)
	{
		m_pFuzz[i].x = (frand(1.0f)-0.5f)*m_fXSize;
		m_pFuzz[i].z = (frand(1.0f)-0.5f)*m_fZSize;
		m_pFuzz[i].lidx = irand(m_dwNumFuzzLib);
	}
}

//-----------------------------------------------------------------------------
// Name: GenSlices
// Desc: Generate the fuzz volume by rendering the geometry repeatedly
//       with different z-clip ranges.
//-----------------------------------------------------------------------------
void CXBGrass::GenSlices(DWORD nslices, DWORD slicexsize, DWORD slicezsize)
{
	assert(nslices <= XBGRASS_MAXSLICE);
	
	// Check the format of the textures
	bool bFormatOK = true;
	if (m_dwNumSlices > 0)
	{
		D3DSURFACE_DESC desc;
		m_apSliceTexture[0]->GetLevelDesc(0, &desc);
		if (desc.Format != D3DFMT_A8R8G8B8)
			bFormatOK = false;
	}

	// make sure volume info is up to date
	if(m_dwSliceXSize!=slicexsize 
	   || m_dwSliceZSize!=slicezsize
	   || !bFormatOK)
	{
		m_dwNumSlices = 0;
		m_dwNumSlicesLOD = 0;
		for(UINT i=0; i<XBGRASS_MAXSLICE*2-1; i++)
			SAFE_RELEASE(m_apSliceTexture[i]);
	}

	m_dwSliceXSize = slicexsize;
	m_dwSliceZSize = slicezsize;
	m_dwSliceSize = slicexsize*slicezsize;

	// create textures if necessary
	if(m_dwNumSlices!=nslices)
	{
		UINT i;
		// count number of level-of-detail layers needed
		UINT nLOD = 0;
		for (i = 1; (1u << i) <= nslices; i++)
			nLOD += nslices >> i;
		m_dwLODMax = i - 1;

		// create new layers and level-of-detail layers
		for(i=0; i<nslices+nLOD; i++)
			if(!m_apSliceTexture[i])
				g_pd3dDevice->CreateTexture(slicexsize, slicezsize, 0, 0, D3DFMT_A8R8G8B8, 0, &m_apSliceTexture[i]);
			
		// release unused layers
		for(i=nslices+nLOD; i<XBGRASS_MAXSLICE*2-1; i++)
			SAFE_RELEASE(m_apSliceTexture[i]);

	}
	m_dwNumSlices = nslices;

	// save current back buffer, z buffer, and transforms
	struct {
		IDirect3DSurface8 *pBackBuffer, *pZBuffer;
		D3DMATRIX matWorld, matView, matProjection;
	} save;
	g_pd3dDevice->GetRenderTarget(&save.pBackBuffer);
	g_pd3dDevice->GetDepthStencilSurface(&save.pZBuffer);
	g_pd3dDevice->GetTransform( D3DTS_WORLD, &save.matWorld);
	g_pd3dDevice->GetTransform( D3DTS_VIEW, &save.matView);
	g_pd3dDevice->GetTransform( D3DTS_PROJECTION, &save.matProjection);
		
	// make a new depth buffer
	IDirect3DSurface8 *pZBuffer = NULL;
	g_pd3dDevice->CreateDepthStencilSurface(slicexsize, slicezsize, D3DFMT_LIN_D24S8, D3DMULTISAMPLE_NONE, &pZBuffer);
	D3DXVECTOR3 va(-0.5f*m_fXSize, 0.f, -0.5f*m_fZSize), vb(0.5f*m_fXSize, m_fYSize, 0.5f*m_fZSize); // bounds of fuzz patch
	D3DXVECTOR3 vwidth(vb-va), vcenter(0.5f*(vb+va)); // width and center of fuzz patch
		
	// set world transformation to scale model to unit cube [-1,1] in all dimensions
	D3DXMATRIX matWorld, matTranslate, matScale;
	D3DXMatrixTranslation(&matTranslate, -vcenter.x, -vcenter.y, -vcenter.z);
	D3DXMatrixScaling(&matScale, 2.f/vwidth.x, 2.f/vwidth.y, 2.f/vwidth.z);
	matWorld = matTranslate * matScale;
	g_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld);
		
	// set view transformation to flip z and look down y axis, with bottom-most slice scaled and translated to map to [0,1]
	D3DMATRIX matView;
	matView.m[0][0] = 1.f;	matView.m[0][1] =  0.f;	matView.m[0][2] = 0.f;				matView.m[0][3] = 0.f;
	matView.m[1][0] = 0.f;	matView.m[1][1] =  0.f;	matView.m[1][2] = 0.5f * nslices;	matView.m[1][3] = 0.f;
	matView.m[2][0] = 0.f;	matView.m[2][1] = -1.f;	matView.m[2][2] = 0.f;				matView.m[2][3] = 0.f;
	matView.m[3][0] = 0.f;	matView.m[3][1] =  0.f;	matView.m[3][2] = 0.5f * nslices;	matView.m[3][3] = 1.f;
		
	// set projection matrix to orthographic
	D3DXMATRIX matProjection;
	D3DXMatrixIdentity(&matProjection);
	g_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProjection);
	UINT numLines = m_dwNumFuzz*m_dwNumSegments;
	IDirect3DVertexBuffer8 *pVB;
	GetLinesVertexBuffer(&pVB);
	g_pd3dDevice->SetTexture(0, NULL);
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_DIFFUSE);
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_DIFFUSE);
	g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_ONE); // premultiplied alpha
	g_pd3dDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
	g_pd3dDevice->SetRenderState(D3DRS_ZWRITEENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_EMISSIVEMATERIALSOURCE, D3DMCS_COLOR1);
	g_pd3dDevice->SetRenderState(D3DRS_LIGHTING, FALSE);

	g_pd3dDevice->SetVertexShader(FVF_XYZDIFF);
	g_pd3dDevice->SetStreamSource(0, pVB, sizeof(FVFT_XYZDIFF));
		
	// draw each slice
	for (int i = 0; i < (int)nslices; i++)
	{
		// get destination surface & set as render target, then draw the fuzz slice
		LPDIRECT3DTEXTURE8 pTexture = m_apSliceTexture[i];
		IDirect3DSurface8 *pSurface;
		pTexture->GetSurfaceLevel(0, &pSurface);
		g_pd3dDevice->SetRenderTarget(pSurface, pZBuffer);
		g_pd3dDevice->Clear( 0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL, D3DCOLOR_RGBA(0,0,0,0), 1.0f, 0);
		matView.m[1][2] = 0.5f * nslices;
		matView.m[3][2] = 0.5f * nslices - (float)i;	// offset to next slice
		
		// We want the texture to wrap, so draw multiple times with offsets in the plane so that 
		// the boundaries will be filled in by the overlapping geometry.
		for (int iX = -1; iX <= 1; iX++)
		{
			for (int iY = -1; iY <= 1; iY++)
			{
				matView.m[3][0] = 2.f * iX;
				matView.m[3][1] = 2.f * iY;
				g_pd3dDevice->SetTransform( D3DTS_VIEW, &matView);
				g_pd3dDevice->DrawPrimitive(D3DPT_LINELIST, 0, numLines);
			}
		}
		pSurface->Release();
		D3DXFilterTexture(pTexture, NULL, 0, D3DX_FILTER_BOX); // have d3dx do all the mip filtering
	}
	
	// clean up
	pVB->Release();
	pZBuffer->Release();
	g_pd3dDevice->SetRenderTarget(save.pBackBuffer, save.pZBuffer);
	save.pBackBuffer->Release();
	save.pZBuffer->Release();
	g_pd3dDevice->SetTransform( D3DTS_WORLD, &save.matWorld);
	g_pd3dDevice->SetTransform( D3DTS_VIEW, &save.matView);
	g_pd3dDevice->SetTransform( D3DTS_PROJECTION, &save.matProjection);
	g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_ZWRITEENABLE, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_LIGHTING, TRUE);
}

//-----------------------------------------------------------------------------
// Name: GenFin
// Desc: Generate the fin texture in a similar way as GenSlices.
//-----------------------------------------------------------------------------
void CXBGrass::GenFin(DWORD finWidth, DWORD finHeight, float fFinXFraction, float fFinZFraction)
{
	m_fFinXFraction = fFinXFraction;
	m_fFinZFraction = fFinZFraction;

	// Check the format of the textures
	bool bFormatOK = true;
	if (m_pFinTexture != NULL)
	{
		D3DSURFACE_DESC desc;
		m_pFinTexture->GetLevelDesc(0, &desc);
		if (desc.Format != D3DFMT_A8R8G8B8)
			bFormatOK = false;
	}

	// make sure fin info is up to date
	if(m_finWidth != finWidth
	   || m_finHeight != finHeight
	   || !bFormatOK)
	{
		SAFE_RELEASE(m_pFinTexture);
	}
	m_finWidth = finWidth;
	m_finHeight = finHeight;

	// create fin texture if needed
	if (m_pFinTexture == NULL)
		g_pd3dDevice->CreateTexture(finWidth, finHeight, 0, 0, D3DFMT_A8R8G8B8, 0, &m_pFinTexture);

	// save current back buffer, z buffer, and transforms
	struct {
		IDirect3DSurface8 *pBackBuffer, *pZBuffer;
		D3DMATRIX matWorld, matView, matProjection;
	} save;
	g_pd3dDevice->GetRenderTarget(&save.pBackBuffer);
	g_pd3dDevice->GetDepthStencilSurface(&save.pZBuffer);
	g_pd3dDevice->GetTransform( D3DTS_WORLD, &save.matWorld);
	g_pd3dDevice->GetTransform( D3DTS_VIEW, &save.matView);
	g_pd3dDevice->GetTransform( D3DTS_PROJECTION, &save.matProjection);

	// make a new depth buffer
	IDirect3DSurface8 *pZBuffer = NULL;
	g_pd3dDevice->CreateDepthStencilSurface(finWidth, finHeight, D3DFMT_LIN_D24S8, D3DMULTISAMPLE_NONE, &pZBuffer);
	D3DXVECTOR3 va(-0.5f*m_fXSize, 0.f, -0.5f*m_fZSize), vb(0.5f*m_fXSize, m_fYSize, 0.5f*m_fZSize); // bounds of fuzz patch
	D3DXVECTOR3 vwidth(vb-va), vcenter(0.5f*(vb+va)); // width and center of fuzz patch

	// set world transformation to scale model to unit cube [-1,1] in all dimensions
	D3DXMATRIX matWorld, matTranslate, matScale;
	D3DXMatrixTranslation(&matTranslate, -vcenter.x, -vcenter.y, -vcenter.z);
	D3DXMatrixScaling(&matScale, 2.f/vwidth.x, 2.f/vwidth.y, 2.f/vwidth.z);
	matWorld = matTranslate * matScale;
	g_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld);

	// set view transformation to look down z axis, with z range [0,1]
	float fXFraction = m_fFinXFraction;
	float fYFraction = 1.f;
	float fZFraction = m_fFinZFraction; 
	float fXScale = 1.f / fXFraction;
	float fYScale = 1.f / fYFraction;
	float fZScale = 1.f / fZFraction;
	D3DMATRIX matView;
	matView.m[0][0] = fXScale;	matView.m[0][1] =  0.f;		matView.m[0][2] = 0.f;				matView.m[0][3] = 0.f;
	matView.m[1][0] = 0.f;		matView.m[1][1] = -fYScale;	matView.m[1][2] = 0.f;				matView.m[1][3] = 0.f;
	matView.m[2][0] = 0.f;		matView.m[2][1] =  0.f;		matView.m[2][2] = 0.5f * fZScale;	matView.m[2][3] = 0.f;
	matView.m[3][0] = 0.f;		matView.m[3][1] =  0.f; 	matView.m[3][2] = 0.5f * fZScale;	matView.m[3][3] = 1.f;
	g_pd3dDevice->SetTransform( D3DTS_VIEW, &matView);
	// set projection matrix to orthographic

	D3DXMATRIX matProjection;
	D3DXMatrixIdentity(&matProjection);
	g_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProjection);
	UINT numLines = m_dwNumFuzz*m_dwNumSegments;
	IDirect3DVertexBuffer8 *pVB;
	GetLinesVertexBuffer(&pVB);
	g_pd3dDevice->SetTexture(0, NULL);
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_DIFFUSE);
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_DIFFUSE);
	g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_ONE); // premultiplied alpha
	g_pd3dDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
	g_pd3dDevice->SetRenderState(D3DRS_ZWRITEENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_EMISSIVEMATERIALSOURCE, D3DMCS_COLOR1);
	g_pd3dDevice->SetRenderState(D3DRS_LIGHTING, FALSE);
	g_pd3dDevice->SetVertexShader(FVF_XYZDIFF);
	g_pd3dDevice->SetStreamSource(0, pVB, sizeof(FVFT_XYZDIFF));
	
	// draw fuzz into the fin texture, looking from the side
	LPDIRECT3DTEXTURE8 pTexture = m_pFinTexture;
	IDirect3DSurface8 *pSurface;
	pTexture->GetSurfaceLevel(0, &pSurface);
	g_pd3dDevice->SetRenderTarget(pSurface, pZBuffer);
	g_pd3dDevice->Clear( 0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, D3DCOLOR_RGBA(0,0,0,0), 1.0f, 0);
	g_pd3dDevice->DrawPrimitive(D3DPT_LINELIST, 0, numLines);
	pSurface->Release();
	D3DXFilterTexture(pTexture, NULL, 0, D3DX_FILTER_BOX); // have d3dx do all the mip filtering

	// clean up
	pVB->Release();
	pZBuffer->Release();
	g_pd3dDevice->SetRenderTarget(save.pBackBuffer, save.pZBuffer);
	save.pBackBuffer->Release();
	save.pZBuffer->Release();
	g_pd3dDevice->SetTransform( D3DTS_WORLD, &save.matWorld);
	g_pd3dDevice->SetTransform( D3DTS_VIEW, &save.matView);
	g_pd3dDevice->SetTransform( D3DTS_PROJECTION, &save.matProjection);
	g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_ZWRITEENABLE, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_LIGHTING, TRUE);
}

//-----------------------------------------------------------------------------
// Name: GetLinesVertexBuffer
// Desc: Create and fill in a vertex buffer as a series of individual lines from the fuzz library.
//-----------------------------------------------------------------------------
void CXBGrass::GetLinesVertexBuffer(IDirect3DVertexBuffer8 **ppVB)
{
	IDirect3DVertexBuffer8 *pVB;
	UINT numVertices = m_dwNumFuzz*m_dwNumSegments*2;
	g_pd3dDevice->CreateVertexBuffer(numVertices*sizeof(FVFT_XYZDIFF), 0, FVF_XYZDIFF, 0, &pVB);
	assert(pVB!=NULL);
	DWORD i, j, vidx, lidx;
	DWORD alpha0 = 128;
	FVFT_XYZDIFF *verts;
	float x0, y0, z0;
	float dx, dy, dz;
	float ddx, ddy, ddz;
	float step, cp;
	UINT startseg = 0;
	step = 1.0f/(float)m_dwNumSegments;
	pVB->Lock(0, numVertices*sizeof(FVFT_XYZDIFF), (BYTE **)&verts, 0);
	vidx = 0;
	D3DXCOLOR colorBase, colorDelta;
	for(i=0; i<m_dwNumFuzz; i++)
	{
		// get location and index from fuzz instances
		lidx = m_pFuzz[i].lidx;
		x0 = m_pFuzz[i].x;
		y0 = 0.0f;
		z0 = m_pFuzz[i].z;

		// get params from fuzz lib
		dx = m_pFuzzLib[lidx].dp.x;
		dy = m_pFuzzLib[lidx].dp.y;
		dz = m_pFuzzLib[lidx].dp.z;
		ddx = m_pFuzzLib[lidx].ddp.x;
		ddy = m_pFuzzLib[lidx].ddp.y;
		ddz = m_pFuzzLib[lidx].ddp.z;
		colorBase = m_pFuzzLib[lidx].colorBase;
		colorDelta = m_pFuzzLib[lidx].colorTip - colorBase;

		// build linelist
		cp = (float)startseg*step;
		D3DXCOLOR color;
		for(j=startseg; j<m_dwNumSegments; j++)
		{
			verts[vidx].v.x = x0 + cp*dx + 0.5f*cp*cp*ddx;
			verts[vidx].v.y = y0 + cp*dy + 0.5f*cp*cp*ddy;
			verts[vidx].v.z = z0 + cp*dz + 0.5f*cp*cp*ddz;
			color = colorBase + cp * cp * colorDelta;
//			color.r *= color.a; color.g *= color.a;	color.b *= color.a;	// premultiply alpha. 
			verts[vidx].diff = color;
			vidx++;
			cp += step;

			verts[vidx].v.x = x0 + cp*dx + 0.5f*cp*cp*ddx;
			verts[vidx].v.y = y0 + cp*dy + 0.5f*cp*cp*ddy;
			verts[vidx].v.z = z0 + cp*dz + 0.5f*cp*cp*ddz;
			color = colorBase + cp * cp * colorDelta;
//			color.r *= color.a; color.g *= color.a;	color.b *= color.a;	// premultiply alpha. 
			verts[vidx].diff = color;
			vidx++;
		}
	}
	pVB->Unlock();
	*ppVB = pVB;
}

//-----------------------------------------------------------------------------
// Name: RenderLines
// Desc: Draw the fuzz patch as a series of individual lines.
//-----------------------------------------------------------------------------
void CXBGrass::RenderLines()
{
	UINT numLines = m_dwNumFuzz*m_dwNumSegments;
	IDirect3DVertexBuffer8 *pVB;
	GetLinesVertexBuffer(&pVB);
	g_pd3dDevice->SetTexture(0, NULL);
    g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
    g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_DIFFUSE);
    g_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
    g_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_DIFFUSE);
	g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_ONE); // premultiplied alpha
	g_pd3dDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
	g_pd3dDevice->SetRenderState(D3DRS_LIGHTING, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_ZWRITEENABLE, FALSE);
	g_pd3dDevice->SetVertexShader(FVF_XYZDIFF);
	g_pd3dDevice->SetStreamSource(0, pVB, sizeof(FVFT_XYZDIFF));
	g_pd3dDevice->DrawPrimitive(D3DPT_LINELIST, 0, numLines);
	g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_ZWRITEENABLE, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_LIGHTING, TRUE);
	pVB->Release();
}

//-----------------------------------------------------------------------------
// Desc: File routines for saving and loading patch files.
//       Saving is only relevant if used on a Windows platform.
//-----------------------------------------------------------------------------
struct _fphdr
{
	char sig[5];
	int flags;
};

void CXBGrass::Save(char *fname, int flags)
{
	FILE *fp;
	struct _fphdr hdr;

	fp = fopen(fname, "wb");

	// write file header
	strcpy(hdr.sig, "FUZ2");
	hdr.flags = flags;
	fwrite(&hdr, sizeof(struct _fphdr), 1, fp);

	// write fpatch data
	fwrite(&m_dwSeed, sizeof(DWORD), 1, fp);
	
	fwrite(&m_fXSize, sizeof(float), 1, fp);
	fwrite(&m_fYSize, sizeof(float), 1, fp);
	fwrite(&m_fZSize, sizeof(float), 1, fp);

	fwrite(&m_dwNumSegments, sizeof(DWORD), 1, fp);
	fwrite(&m_fFinXFraction, sizeof(float), 1, fp);
	fwrite(&m_fFinZFraction, sizeof(float), 1, fp);
	fwrite(&m_fuzzCenter.colorBase, sizeof(D3DXCOLOR), 1, fp);
	fwrite(&m_fuzzRandom.colorBase, sizeof(D3DXCOLOR), 1, fp);
	fwrite(&m_fuzzCenter.colorTip, sizeof(D3DXCOLOR), 1, fp);
	fwrite(&m_fuzzRandom.colorTip, sizeof(D3DXCOLOR), 1, fp);
	
	fwrite(&m_fuzzCenter.dp, sizeof(D3DVECTOR), 1, fp);
	fwrite(&m_fuzzRandom.dp, sizeof(D3DVECTOR), 1, fp);
	fwrite(&m_fuzzCenter.ddp, sizeof(D3DVECTOR), 1, fp);
	fwrite(&m_fuzzRandom.ddp, sizeof(D3DVECTOR), 1, fp);

	fwrite(&m_dwNumFuzzLib, sizeof(DWORD), 1, fp);
	fwrite(&m_dwNumFuzz, sizeof(DWORD), 1, fp);

	fwrite(&m_dwNumSlices, sizeof(DWORD), 1, fp);
	fwrite(&m_dwSliceXSize, sizeof(DWORD), 1, fp);
	fwrite(&m_dwSliceZSize, sizeof(DWORD), 1, fp);

	// write volume data if available and flag is set
	{
	}

	fclose(fp);
}

void CXBGrass::Load(char *fname)
{
	FILE *fp;
	struct _fphdr hdr;
	DWORD numfuzzlib, numfuzz;
	DWORD numslices, slicexsize, slicezsize;

	fp = fopen(fname, "rb");
	if(!fp)
		return;

	// read file header
	fread(&hdr, sizeof(struct _fphdr), 1, fp);

	// verify signature
	bool bFUZ1 = !strcmp(hdr.sig, "FUZ1");
	bool bFUZ2 = !strcmp(hdr.sig, "FUZ2");
	if (!bFUZ1 && !bFUZ2)
		return;	// signature not understood

	// read patch data
	fread(&m_dwSeed, sizeof(DWORD), 1, fp);
	
	fread(&m_fXSize, sizeof(float), 1, fp);
	fread(&m_fYSize, sizeof(float), 1, fp);
	fread(&m_fZSize, sizeof(float), 1, fp);

	fread(&m_dwNumSegments, sizeof(DWORD), 1, fp);
	if (bFUZ1)
	{
		m_fFinXFraction = 1.f;
		m_fFinZFraction = 0.05f;
		fread(&m_fuzzCenter.colorBase, sizeof(D3DXCOLOR), 1, fp);
		m_fuzzCenter.colorTip = m_fuzzCenter.colorBase;
		m_fuzzRandom.colorBase = m_fuzzRandom.colorTip = 0ul;
	}
	else
	{
		fread(&m_fFinXFraction, sizeof(float), 1, fp);
		fread(&m_fFinZFraction, sizeof(float), 1, fp);
		fread(&m_fuzzCenter.colorBase, sizeof(D3DXCOLOR), 1, fp);
		fread(&m_fuzzRandom.colorBase, sizeof(D3DXCOLOR), 1, fp);
		fread(&m_fuzzCenter.colorTip, sizeof(D3DXCOLOR), 1, fp);
		fread(&m_fuzzRandom.colorTip, sizeof(D3DXCOLOR), 1, fp);
	}

	fread(&m_fuzzCenter.dp, sizeof(D3DVECTOR), 1, fp);	// velocity center
	fread(&m_fuzzRandom.dp, sizeof(D3DVECTOR), 1, fp);	// velocity random
	fread(&m_fuzzCenter.ddp, sizeof(D3DVECTOR), 1, fp);	// acceleration center
	fread(&m_fuzzRandom.ddp, sizeof(D3DVECTOR), 1, fp);	// acceleration random

	fread(&numfuzzlib, sizeof(DWORD), 1, fp);
	fread(&numfuzz, sizeof(DWORD), 1, fp);

	fread(&numslices, sizeof(DWORD), 1, fp);
	fread(&slicexsize, sizeof(DWORD), 1, fp);
	fread(&slicezsize, sizeof(DWORD), 1, fp);

	// read volume data if available and flag is set
	{
	}

	fclose(fp);

	InitFuzz(numfuzz, numfuzzlib);
	GenSlices(numslices, slicexsize, slicezsize);
	ComputeLevelOfDetailTextures();
	SetLevelOfDetail(0.f);
}

//////////////////////////////////////////////////////////////////////
// Lighting Model
//////////////////////////////////////////////////////////////////////

inline float
Luminance(const D3DXCOLOR &c)
{
    return (0.229f * c.r) + (0.587f * c.g) + (0.114f * c.b);
}

inline float
MaxChannel(const D3DXCOLOR &c)
{
	if (c.r > c.g)
	{
		if (c.r > c.b)
			return c.r;
		else
			return c.b;
	}
	else
	{
		if (c.g > c.b)
			return c.g;
		else
			return c.b;
	}
}

inline D3DXCOLOR 
Lerp(const D3DXCOLOR &c1, const D3DXCOLOR &c2, float s)
{
    return c1 + s * (c2 - c1);
}

inline D3DXCOLOR
Desaturate(const D3DXCOLOR &rgba)
{
    float alpha = rgba.a;
    if (alpha > 1.f)
        alpha = 1.f;
    float fMaxChan = MaxChannel(rgba);
    if (fMaxChan > alpha) 
    {
        D3DXCOLOR rgbGray(alpha, alpha, alpha, alpha);
        float fYOld = Luminance(rgba);
        if (fYOld >= alpha)
            return rgbGray;
        // scale color to preserve hue
        D3DXCOLOR rgbNew;
        float fInvMaxChan = 1.f / fMaxChan;
        rgbNew.r = rgba.r * fInvMaxChan;
        rgbNew.g = rgba.g * fInvMaxChan;
        rgbNew.b = rgba.b * fInvMaxChan;
		rgbNew.a = alpha;
        float fYNew = Luminance(rgbNew);
        // add gray to preserve luminance
        return Lerp(rgbNew, rgbGray, (fYOld - fYNew) / (alpha - fYNew));
    }
    return rgba;
}

inline D3DXCOLOR &operator *=(D3DXCOLOR &p, const D3DXCOLOR &q)
{
	p.r *= q.r;
	p.g *= q.g;
	p.b *= q.b;
	p.a *= q.a;
	return p;
}

inline D3DXCOLOR operator *(const D3DXCOLOR &p, const D3DXCOLOR &q)
{
	D3DXCOLOR r;
	r.r = p.r * q.r;
	r.g = p.g * q.g;
	r.b = p.b * q.b;
	r.a = p.a * q.a;
	return r;
}

//-----------------------------------------------------------------------------
//  HairLighting
//-----------------------------------------------------------------------------
struct HairLighting {
	// like D3DMATERIAL8, except populated with D3DXCOLOR's so that color arithmetic works
	D3DXCOLOR m_colorDiffuse;
	D3DXCOLOR m_colorSpecular;
	float m_fSpecularExponent;
	D3DXCOLOR m_colorAmbient;
	D3DXCOLOR m_colorEmissive;

	HRESULT Initialize(LPDIRECT3DDEVICE8 pDevice, D3DMATERIAL8 *pMaterial);
	HRESULT CalculateColor(D3DXCOLOR *pColor, float LT, float HT);
	HRESULT CalculateClampedColor(D3DXCOLOR *pColor, float LT, float HT);
};

HRESULT HairLighting::Initialize(LPDIRECT3DDEVICE8 pDevice, D3DMATERIAL8 *pMaterial)
{
	// Get current colors modulated by light 0 and global ambient
	// ignore current alphas
	m_colorDiffuse = D3DXCOLOR(pMaterial->Diffuse.r, pMaterial->Diffuse.g, pMaterial->Diffuse.b, 1.f);
	m_colorSpecular = D3DXCOLOR(pMaterial->Specular.r, pMaterial->Specular.g, pMaterial->Specular.b, 1.f);
	m_fSpecularExponent = pMaterial->Power;
	m_colorAmbient = D3DXCOLOR(pMaterial->Ambient.r, pMaterial->Ambient.g, pMaterial->Ambient.b, 1.f);
	m_colorEmissive = D3DXCOLOR(pMaterial->Emissive.r, pMaterial->Emissive.g, pMaterial->Emissive.b, 1.f);
	return S_OK;
}

/* Zockler et al's technique worked with streamlines, and used dot(V,T) instead of the simpler dot(H,T) */
#define ZOCKLER 0 
#if ZOCKLER

HRESULT HairLighting::CalculateColor(D3DXCOLOR *pColor, float LT, float VT)
{
	// Zockler et al 1996
	float fDiffuseExponent = 2.f;	// Banks used 4.8
	float fDiffuse = powf(sqrtf(1.f - LT*LT), fDiffuseExponent);
	float VR = LT*VT - sqrtf(1.f - LT*LT) * sqrtf(1.f - VT*VT);
	float fSpecular = powf(VR, m_fSpecularExponent);
	*pColor = m_colorEmissive + m_colorAmbient + fSpecular * m_colorSpecular + fDiffuse * m_colorDiffuse;
	return S_OK;
}

#else

HRESULT HairLighting::CalculateColor(D3DXCOLOR *pColor, float LT, float HT)
{
	float fDiffuseExponent = 2.f;	// Banks used 4.8
	float fDiffuse = powf(sqrtf(1.f - LT*LT), fDiffuseExponent);
	float fSpecular = powf(sqrtf(1.f - HT*HT), m_fSpecularExponent);
	*pColor = m_colorEmissive + m_colorAmbient + fSpecular * m_colorSpecular + fDiffuse * m_colorDiffuse;
	return S_OK;
}

#endif

HRESULT HairLighting::CalculateClampedColor(D3DXCOLOR *pColor, float LT, float HT)
{
	D3DXCOLOR color;
	HRESULT hr = CalculateColor(&color, LT, HT);
	*pColor = Desaturate(color);	// bring back to 0,1 range
	return hr;
}

//////////////////////////////////////////////////////////////////////
// 
// Create a hair lighting lookup-table texture
// 
//////////////////////////////////////////////////////////////////////
HRESULT FillHairLightingTexture(D3DMATERIAL8 *pMaterial, LPDIRECT3DTEXTURE8 pTexture)
{
	/* 
	The hair lighting texture maps U as the dot product of the hair
	tangent T with the light direction L and maps V as the dot product
	of the tangent with the half vector H.  Since the lighting is a
	maximum when the tangent is perpendicular to L (or H), the maximum
	is at zero.  The minimum is at 0.5, 0.5 (or -0.5, -0.5, since
	wrapping is turned on.)  For the mapped T.H, we raise the map
	value to a specular power.
	*/
	HRESULT hr;
	D3DSURFACE_DESC desc;
	pTexture->GetLevelDesc(0, &desc);
	if (desc.Format != D3DFMT_A8R8G8B8)
		return E_NOTIMPL;
	DWORD dwPixelStride = 4;
	D3DLOCKED_RECT lockedRect;
	hr = pTexture->LockRect(0, &lockedRect, NULL, 0l);
	if (FAILED(hr))
		return hr;
	HairLighting lighting;
	lighting.Initialize(g_pd3dDevice, pMaterial);
	Swizzler s(desc.Width, desc.Height, 0);
	s.SetV(s.SwizzleV(0));
	s.SetU(s.SwizzleU(0));
	for (UINT v = 0; v < desc.Height; v++)
	{
		for (UINT u = 0; u < desc.Width; u++)
		{
			BYTE *p = (BYTE *)lockedRect.pBits + dwPixelStride * s.Get2D();
			// vertical is specular lighting
			// horizontal is diffuse lighting
			D3DXCOLOR color;
#if ZOCKLER
			// Zockler et al 1996
			float LT = 2.f * u / desc.Width - 1.0f;
			float VT = 2.f * v / desc.Height - 1.0f;
			lighting.CalculateClampedColor(&color, LT, VT);
#else
			float LT = 2.f * u / desc.Width;
			if (LT > 1.f) LT -= 2.f;
			float HT = 2.f * v / desc.Height;
			if (HT > 1.f) HT -= 2.f;
			lighting.CalculateClampedColor(&color, LT, HT);
#endif
			int r, g, b;
			r = (BYTE)(255 * color.r);
			g = (BYTE)(255 * color.g);
			b = (BYTE)(255 * color.b);
			*p++ = (BYTE)b;
			*p++ = (BYTE)g;
			*p++ = (BYTE)r;
			*p++ = 255;	// alpha
			s.IncU();
		}
		s.IncV();
	}
	pTexture->UnlockRect(0);
	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: SetHairLightingMaterial
// Desc: Create and fill the hair lighting texture
//-----------------------------------------------------------------------------
HRESULT CXBGrass::SetHairLightingMaterial(D3DMATERIAL8 *pMaterial)
{
	// Create and fill the hair lighting texture
	HRESULT hr;
	m_HairLightingMaterial = *pMaterial;
	if (!m_pHairLightingTexture)
	{
		DWORD dwFlags = 0;
		DWORD dwWidth = 8; // an extremely small texture suffices when the exponents are low
		DWORD dwHeight = 8;
		D3DFORMAT surfaceFormat = D3DFMT_A8R8G8B8;
		DWORD nMipMap = 1;
		hr = D3DXCreateTexture(g_pd3dDevice, dwWidth, dwHeight, nMipMap, 0, surfaceFormat, 0, &m_pHairLightingTexture);
		if (FAILED(hr)) goto e_Exit;
	}
	hr = FillHairLightingTexture(pMaterial, m_pHairLightingTexture);
	if (FAILED(hr)) goto e_Exit;
e_Exit:
	if (FAILED(hr))
		SAFE_RELEASE(m_pHairLightingTexture);
	return hr;
}

//-----------------------------------------------------------------------------
// Choose level of detail 
//
// 0       = finest detail, all slices of original source textures
// ...
// i       = reduced number of slices, N / (1 << i)
// i + f   = odd slices fade to clear, texLOD[2*j+1] = tex[2*j+1] * (1-f) + clear * f
//           even slices compensate,   texLOD[2*j] = (tex[2*j+1] * f) OVER tex[2*j]
// i + 1   = reduced number of slices, N / (1 << (i+1))
// ...
// log2(N) = coarsest, one slice with composite of all source textures
//-----------------------------------------------------------------------------
HRESULT CXBGrass::SetLevelOfDetail(float fLevelOfDetail)
{
	// Choose number of LOD slices
	if (fLevelOfDetail < 0.f)
	{
		m_fLevelOfDetail = 0.f;
		m_iLOD = 0;
		m_fLODFraction = 0.f;
	}
	else if (fLevelOfDetail > (float)m_dwLODMax)
	{
		m_fLevelOfDetail = (float)m_dwLODMax;
		m_iLOD = m_dwLODMax;
		m_fLODFraction = 0.f;
	}
	else
	{
		m_fLevelOfDetail = fLevelOfDetail;
		m_iLOD = (UINT)floorf(fLevelOfDetail);
		m_fLODFraction = fLevelOfDetail - (float)m_iLOD;
	}
	m_dwNumSlicesLOD = LevelOfDetailCount(m_iLOD);
	UINT index = LevelOfDetailIndex(m_iLOD);
	m_pSliceTextureLOD = m_apSliceTexture + index;
	return S_OK;
}

//-----------------------------------------------------------------------------
//
// Generate level-of-detail textures by compositing together alternating layers.
//
//-----------------------------------------------------------------------------
HRESULT CXBGrass::ComputeLevelOfDetailTextures()
{
	// All the textures must have the same number of mip levels.
	DWORD nMip = m_apSliceTexture[0]->GetLevelCount();

	// save current back buffer and z buffer
	struct {
		IDirect3DSurface8 *pBackBuffer, *pZBuffer;
	} save;
	g_pd3dDevice->GetRenderTarget(&save.pBackBuffer);
	g_pd3dDevice->GetDepthStencilSurface(&save.pZBuffer);

	// set render state for compositing textures
	g_pd3dDevice->SetVertexShader(D3DFVF_XYZRHW|D3DFVF_TEX1);
	g_pd3dDevice->SetRenderState(D3DRS_LIGHTING, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_ALPHATESTENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_ZENABLE, D3DZB_FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_STENCILENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_FOGENABLE, FALSE);

	// use pixel shaders to composite two or three layers at a time
	DWORD dwPS2 = 0;
	{
#include "comp2.inl"
		g_pd3dDevice->CreatePixelShader(&psd, &dwPS2);
	}
	DWORD dwPS3 = 0;
	{
#include "comp3.inl"
		g_pd3dDevice->CreatePixelShader(&psd, &dwPS3);
	}

	// set default texture stage states
	UINT xx; // texture stage index
	for (xx = 0; xx < 4; xx++)
	{
		g_pd3dDevice->SetTexture(xx, NULL);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_COLOROP, D3DTOP_DISABLE);	// Are the COLOROP and ALPHAOP needed since we're using a pixel shader?
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_DISABLE);	// pass texture coords without transformation
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_TEXCOORDINDEX, 0);			// all the textures use the same tex coords
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_MAGFILTER, D3DTEXF_POINT);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_MINFILTER, D3DTEXF_POINT);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_MIPFILTER, D3DTEXF_POINT);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_MIPMAPLODBIAS, 0);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_MAXMIPLEVEL, 0);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_COLORKEYOP, D3DTCOLORKEYOP_DISABLE);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_COLORSIGN, 0);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_ALPHAKILL, D3DTALPHAKILL_DISABLE);
	}
	
	// Compute all the level-of-detail textures
	for (UINT iLOD = 1; m_dwNumSlices >> iLOD; iLOD++)
	{
		UINT nSliceSrc = LevelOfDetailCount(iLOD-1);
		LPDIRECT3DTEXTURE8 *apTextureSrc = m_apSliceTexture + LevelOfDetailIndex(iLOD - 1);
		UINT nSliceDst = LevelOfDetailCount(iLOD);
		LPDIRECT3DTEXTURE8 *apTextureDst = m_apSliceTexture + LevelOfDetailIndex(iLOD);
		
		// Composite source textures into LOD textures
		UINT iMipNotHandled = -1;
		for (UINT iSliceDst = 0; iSliceDst < nSliceDst; iSliceDst++)
		{
			LPDIRECT3DTEXTURE8 pTextureDst = apTextureDst[iSliceDst];
			UINT nComp;
			if (iSliceDst == nSliceDst-1 && nSliceSrc > nSliceDst * 2)
			{
				// composite 3 textures into the top-most level when number of source textures is odd
				nComp = 3;
				g_pd3dDevice->SetPixelShader(dwPS3);
			}
			else
			{
				// composite 2 textures (this is the default)
				nComp = 2;
				g_pd3dDevice->SetPixelShader(dwPS2);
			}
			for (xx = 0; xx < nComp; xx++)
			{
				g_pd3dDevice->SetTexture(xx, apTextureSrc[ iSliceDst * 2 + xx]);
				g_pd3dDevice->SetTextureStageState(xx, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
				g_pd3dDevice->SetTextureStageState(xx, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
			}
			for (; xx<4; xx++)
			{
				g_pd3dDevice->SetTexture(xx, NULL);
				g_pd3dDevice->SetTextureStageState(xx, D3DTSS_COLOROP, D3DTOP_DISABLE);
				g_pd3dDevice->SetTextureStageState(xx, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
			}
			for (UINT iMip = 0; iMip < nMip; iMip++)
			{
				DWORD width = m_dwSliceXSize / (1 << iMip);
				if (width == 0) width = 1;
				DWORD height = m_dwSliceZSize / (1 << iMip);
				if (height == 0) height = 1;

				// Xbox render target must of be at least 16x16
				if (width*4 < 64 || width * height < 64)			
				{
					iMipNotHandled = iMip;
					break; // skip rest of coarser mipmaps and go to next slice
				}

				// Use a screen space quad to do the compositing.
				struct quad {
					float x, y, z, w;
					float u, v;
				} aQuad[4] =
				{
					{-0.5f,        -0.5f,         1.0f, 1.0f, 0.0f, 0.0f},
					{width - 0.5f, -0.5f,         1.0f, 1.0f, 1.0f, 0.0f},
					{-0.5f,        height - 0.5f, 1.0f, 1.0f, 0.0f, 1.0f},
					{width - 0.5f, height - 0.5f, 1.0f, 1.0f, 1.0f, 1.0f}
				};

				// get destination surface and set as render target
				IDirect3DSurface8 *pSurface;
				pTextureDst->GetSurfaceLevel(iMip, &pSurface);
				g_pd3dDevice->SetRenderTarget(pSurface, NULL); // no depth buffering
				g_pd3dDevice->DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, 2, aQuad, sizeof(quad)); // one quad blends 2 or 3 textures
				pSurface->Release();
			}
		}
		if (iMipNotHandled > 0 && iMipNotHandled != -1)
		{
			// fill in the small mips with filtered versions of the previous levels
			for (UINT iSliceDst = 0; iSliceDst < nSliceDst; iSliceDst++)
			{
				LPDIRECT3DTEXTURE8 pTextureDst = apTextureDst[iSliceDst];
				D3DXFilterTexture(pTextureDst, NULL, iMipNotHandled - 1, D3DX_FILTER_BOX | D3DX_FILTER_MIRROR);
			}
		}
	}

	// clean up pixel shaders
	g_pd3dDevice->SetPixelShader(0);
	g_pd3dDevice->DeletePixelShader(dwPS2);
	g_pd3dDevice->DeletePixelShader(dwPS3);
	
	// restore render states
	g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_LIGHTING, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_EMISSIVEMATERIALSOURCE, D3DMCS_MATERIAL);

	// restore texture stage states
	for (xx=0; xx<4; xx++)
	{
		g_pd3dDevice->SetTexture(xx, NULL);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_COLOROP, D3DTOP_DISABLE);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
	}

	// restore back buffer and z buffer
	g_pd3dDevice->SetRenderTarget(save.pBackBuffer, save.pZBuffer);
	save.pBackBuffer->Release();
	save.pZBuffer->Release();
	return S_OK;
}

//-----------------------------------------------------------------------------
//  Divide alpha channel into color channel.  Leave alpha unchanged.
//-----------------------------------------------------------------------------
HRESULT AlphaDivide(LPDIRECT3DTEXTURE8 pTexture)
{
	HRESULT hr;
	DWORD nMip = pTexture->GetLevelCount();
	for (UINT iMip = 0; iMip < nMip; iMip++)
	{
		D3DSURFACE_DESC desc;
		hr = pTexture->GetLevelDesc(iMip, &desc);
		if (FAILED(hr))
			return hr;
		if (desc.Format != D3DFMT_A8R8G8B8)
			return E_NOTIMPL;
		D3DLOCKED_RECT lockedRect;
		hr = pTexture->LockRect(iMip, &lockedRect, NULL, 0l);
		if (FAILED(hr))
			return hr;
		UINT dwPixelSize = 4;
		UINT nPixel = desc.Size / dwPixelSize;
		DWORD *pPixel = (DWORD *)lockedRect.pBits;
		while (nPixel--)
		{
			D3DXCOLOR c(*pPixel);
			if (c.a > 0.f)
			{
				D3DXCOLOR d;
				d.r = c.r / c.a;
				d.g = c.g / c.a;
				d.b = c.b / c.a;
				d.a = c.a;
				*pPixel = d;
			}
			pPixel++;
		}
		pTexture->UnlockRect(iMip);
	}
	return S_OK;
}

//-----------------------------------------------------------------------------
//  Multiply alpha channel into color channel.  Leave alpha unchanged.
//-----------------------------------------------------------------------------
HRESULT AlphaMultiply(LPDIRECT3DTEXTURE8 pTexture)
{
	HRESULT hr;
	DWORD nMip = pTexture->GetLevelCount();
	for (UINT iMip = 0; iMip < nMip; iMip++)
	{
		D3DSURFACE_DESC desc;
		hr = pTexture->GetLevelDesc(iMip, &desc);
		if (FAILED(hr))
			return hr;
		if (desc.Format != D3DFMT_A8R8G8B8)
			return E_NOTIMPL;
		D3DLOCKED_RECT lockedRect;
		hr = pTexture->LockRect(iMip, &lockedRect, NULL, 0l);
		if (FAILED(hr))
			return hr;
		UINT dwPixelSize = 4;
		UINT nPixel = desc.Size / dwPixelSize;
		DWORD *pPixel = (DWORD *)lockedRect.pBits;
		while (nPixel--)
		{
			D3DXCOLOR c(*pPixel);
			D3DXCOLOR d;
			d.r = c.r * c.a;
			d.g = c.g * c.a;
			d.b = c.b * c.a;
			d.a = c.a;
			*pPixel = d;
			pPixel++;
		}
		pTexture->UnlockRect(iMip);
	}
	return S_OK;
}

//-----------------------------------------------------------------------------
//
// Copy textures to new texture format
//
//-----------------------------------------------------------------------------
HRESULT CXBGrass::SetTextureFormat(D3DFORMAT fmtNew)
{
	HRESULT hr;
	BOOL bPremult = D3DXSetDXT3DXT5(FALSE);	// use pre-multiplied alpha
	for (UINT iTexture = 0; iTexture < XBGRASS_MAXSLICE * 2 - 1; iTexture++)
	{
		LPDIRECT3DTEXTURE8 pTexture = m_apSliceTexture[iTexture];
		if (!pTexture) continue;
		UINT nLevel = pTexture->GetLevelCount();
		D3DSURFACE_DESC desc;
		pTexture->GetLevelDesc(0, &desc);
		LPDIRECT3DTEXTURE8 pTextureNew;
		hr = g_pd3dDevice->CreateTexture(desc.Width, desc.Height, nLevel, 0, fmtNew, 0, &pTextureNew);
        if (FAILED(hr))
            return hr;
		for (UINT iLevel = 0; iLevel < nLevel; iLevel++)
		{
			LPDIRECT3DSURFACE8 pSurface;
			LPDIRECT3DSURFACE8 pSurfaceNew;
            hr = pTexture->GetSurfaceLevel(iLevel, &pSurface);
            hr = pTextureNew->GetSurfaceLevel(iLevel, &pSurfaceNew);
            hr = D3DXLoadSurfaceFromSurface(pSurfaceNew, NULL, NULL, pSurface, NULL, NULL, D3DX_FILTER_TRIANGLE, 0);
			pSurface->Release();
			pSurfaceNew->Release();
        }
		m_apSliceTexture[iTexture] = pTextureNew;
		pTexture->Release();
    }
	D3DXSetDXT3DXT5(bPremult);
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\grass\Terrain.cpp ===
//-----------------------------------------------------------------------------
//  File: Terrain.cpp
//  Copyright (C) 2001 Microsoft Corporation
//  All rights reserved.
//-----------------------------------------------------------------------------
#include <assert.h>
#include <xtl.h>
#include <xgraphics.h>
#include <XBApp.h>
#include <XPath.h>
#include <XBUtil.h>
#include "Terrain.h"

extern LPDIRECT3DDEVICE8 g_pd3dDevice;

UINT GetPixelSize(D3DFORMAT format);
D3DXCOLOR *GetPixelColor(D3DXCOLOR *pColor, BYTE *pPixel, D3DFORMAT format);
HRESULT CopyRectsVB(IDirect3DSurface8* pSourceSurface, CONST RECT* pSourceRectsArray,
					UINT cRects, void *pvDestinationVertices, UINT cbDestinationStride,
					UINT cbDestinationPitch, CONST POINT* pDestinationPointsArray);

//-----------------------------------------------------------------------------
// Name: Grid::Initialize
// Desc: Allocate grid vertex buffer and allocate and fill index buffer.
//-----------------------------------------------------------------------------
HRESULT	Grid::Initialize(UINT width, UINT height, UINT cbVertexSize)
{
	HRESULT hr;

	m_width = width;
	m_height = height;
	
	// Create the vertex buffer
	SAFE_RELEASE(m_pVB);
	hr = g_pd3dDevice->CreateVertexBuffer(m_width * m_height * cbVertexSize, 0, 0, D3DPOOL_DEFAULT, &m_pVB);

	// Create the index buffer
	hr = g_pd3dDevice->CreateIndexBuffer(3*2*(m_width-1)*(m_height-1)*sizeof(WORD), D3DUSAGE_WRITEONLY, D3DFMT_INDEX16, D3DPOOL_DEFAULT, &m_pIB);
	if (FAILED(hr))
        return hr;

	// Fill the tile index buffer.
	WORD *pIndices;
	if( FAILED( m_pIB->Lock( 0, 0, (BYTE**)&pIndices, 0 ) ) )
		return E_FAIL;
	{
		for (UINT iY=0; iY < m_height-1; iY++ )
		{
			for (UINT iX=0; iX < m_width-1; iX++ )
			{
				WORD iVertex = iY*m_width + iX;
				WORD iiTri = 3*2*(iY*(m_width - 1) + iX);
				if ((iX ^ iY) & 1)
				{
					// flip alternating tiles to get "fin" coverage along both 45-degree lines
					// tri 0
					pIndices[iiTri] = iVertex;
					pIndices[iiTri+1] = iVertex+m_width;
					pIndices[iiTri+2] = iVertex+m_width+1;
					// tri 1
					pIndices[iiTri+3] = iVertex;
					pIndices[iiTri+4] = iVertex+m_width+1;
					pIndices[iiTri+5] = iVertex+1;
				}
				else
					{
					// tri 0
					pIndices[iiTri] = iVertex;
					pIndices[iiTri+1] = iVertex+m_width;
					pIndices[iiTri+2] = iVertex+1;
					// tri 1
					pIndices[iiTri+3] = iVertex+1;
					pIndices[iiTri+4] = iVertex+m_width;
					pIndices[iiTri+5] = iVertex+m_width+1;
				}
			}
		}
	}
	m_pIB->Unlock();

	return hr;
}

//-----------------------------------------------------------------------------
// Name: Grid::Cleanup
// Desc: Clean up buffers.
//-----------------------------------------------------------------------------
HRESULT	Grid::Cleanup()
{
	SAFE_RELEASE(m_pVB);
	SAFE_RELEASE(m_pIB);
	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: Terrain constructor
// Desc: Set defaults.
//-----------------------------------------------------------------------------
Terrain::Terrain()
{
	m_pTerrain = NULL;			// terrain height field
	m_pTexture = NULL;			// terrain texture
	m_dwTerrainVertexShader = 0; // terrain vertex shader handle
}

//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Create the height field vertex buffers from m_pTerrain
//       height field texture
//-----------------------------------------------------------------------------
HRESULT Terrain::Initialize(LPDIRECT3DTEXTURE8 pTerrain, LPDIRECT3DTEXTURE8 pTexture, const D3DXVECTOR3 &vMin, const D3DXVECTOR3 &vMax, float fGrassHeight)
{
	HRESULT hr;
	m_vMin = vMin;
	m_vMax = vMax;
	m_fGrassHeight = fGrassHeight;
	
	LPDIRECT3DTEXTURE8 pTerrainOld = m_pTerrain;
	m_pTerrain = pTerrain;
	pTerrain->AddRef();
	SAFE_RELEASE(pTerrainOld);
	
	LPDIRECT3DTEXTURE8 pTextureOld = m_pTexture;
	m_pTexture = pTexture;
	pTexture->AddRef();
	SAFE_RELEASE(pTextureOld);

	UINT width = 32;
	UINT height = 32;

	// Allocate terrain grid
	hr = m_grid.Initialize(width, height, sizeof(TERRAINVERTEX));
	if (FAILED(hr))
		return hr;

	// Fill terrain VB with height field data
	hr = Reset();
	if (FAILED(hr))
		return hr;
	
	// load the terrain vertex shader
	DWORD vsdecl[] = 
	{
		D3DVSD_STREAM(0),
		D3DVSD_REG(0, D3DVSDT_FLOAT3),		// u, v, height
		D3DVSD_REG(1, D3DVSDT_FLOAT3),		// tip u, v, height
		D3DVSD_END()
	};
	XBUtil_CreateVertexShader(g_pd3dDevice, _FNA("Shaders\\terrain_xyz.xvu"), vsdecl, &m_dwTerrainVertexShader);
	if(!m_dwTerrainVertexShader)
	{
		OUTPUT_DEBUG_STRING( "Initialize : error loading terrain_xyz.xvu\n" );
		return XBAPPERR_MEDIANOTFOUND;
	}
	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: GetHeightFieldNeighbors
// Desc: Returns four neighbors of normalized point
//-----------------------------------------------------------------------------
HRESULT Terrain::GetHeightFieldNeighbors(const D3DXVECTOR2 &vP, D3DXVECTOR2 *pvFraction, TERRAINVERTEX rVertex[4])
{
	HRESULT hr;
	IDirect3DSurface8 *pSurfaceTerrainLevel = NULL;
	static UINT iLevel = 0;
	hr = m_pTerrain->GetSurfaceLevel(iLevel, &pSurfaceTerrainLevel );
	if (FAILED(hr))
		return hr;
	D3DSURFACE_DESC desc;
	pSurfaceTerrainLevel->GetDesc(&desc);
	D3DFORMAT pixelFormat = desc.Format;
	DWORD dwPixelStride = GetPixelSize(pixelFormat);
	if (dwPixelStride == -1)
	{
		pSurfaceTerrainLevel->Release();
		return E_NOTIMPL;	// we can't handle the format
	}
	float fx0 = vP.x;
	float fy0 = vP.y;
#if 0
	// mirror wrap
	fx0 = fmodf(fx0, 2.f);
	if (fx0 <= -1.f) fx0 += 2.f;			// -2.f to -1.f
	else if (fx0 < 0.f) fx0 = -fx0;			// -1.f to 0.f
	else if (fx0 > 1.f) fx0 = 2.f - fx0;	//  1.f to 2.f
	fy0 = fmodf(fy0, 2.f);
	if (fy0 <= -1.f) fy0 += 2.f;			// -2.f to -1.f
	else if (fy0 < 0.f) fy0 = -fy0;			// -1.f to 0.f
	else if (fy0 > 1.f) fy0 = 2.f - fy0;	//  1.f to 2.f
#endif
	// get pixel coordinates
	float fx = fx0 * desc.Width + 0.5f;
	float fy = fy0 * desc.Height + 0.5f;
	int ix = (int)floorf(fx);
	int iy = (int)floorf(fy);
	pvFraction->x = fx - ix;
	pvFraction->y = fy - iy;
			
	// clamp to edge
	// TODO: better handling of right and bottom wrap boundaries
	if (ix < 0) ix = 0;
	if (iy < 0) iy = 0;
	if (ix >= (int)desc.Width - 1)
		ix = desc.Width - 2;
	if (iy >= (int)desc.Height - 1)
		iy = desc.Height - 2;
		
	// grab neighboring points from height-field texture
	RECT rect = {ix, iy, ix + 2, iy + 2};
	POINT point = {0, 0};
	hr = CopyRectsVB( pSurfaceTerrainLevel, &rect, 1, rVertex, sizeof(TERRAINVERTEX), 2 * sizeof(TERRAINVERTEX), &point);
	pSurfaceTerrainLevel->Release();
	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: InDomain
// Desc: Test point against 2D bounding box. Z is ignored.
//-----------------------------------------------------------------------------
inline bool InDomain(const D3DXVECTOR3 &vPosition, const D3DXVECTOR3 &vMin, const D3DXVECTOR3 &vMax)
{
	return (vPosition.x >= vMin.x
			&& vPosition.y >= vMin.y
// ignore z range
//			&& vPosition.z >= vMin.z
			&& vPosition.x < vMax.x
			&& vPosition.y < vMax.y
//			&& vPosition.z < vMax.z
			);
}

//-----------------------------------------------------------------------------
// Name: GetTerrainPoint
// Desc: Returns height and normal of point directly below vPosition.
//-----------------------------------------------------------------------------
HRESULT Terrain::GetTerrainPoint(const D3DXVECTOR3 &vPosition, float *pfTerrainHeight, D3DXVECTOR3 *pvTerrainNormal)
{
	HRESULT hr;

	// TODO: return normal, too
	*pvTerrainNormal = D3DXVECTOR3(0.f, 0.f, 1.f);
	*pfTerrainHeight = 0.f; // default height
//	if (!InDomain(vPosition, m_vMin, m_vMax))
//		return S_FALSE;

	// Map to normalized coords
	D3DXVECTOR3 vSize = m_vMax - m_vMin;
	D3DXVECTOR2 vP((vPosition.x - m_vMin.x) / vSize.x,
				   (vPosition.y - m_vMin.y) / vSize.y);

	// Lookup height-field neighbors
	D3DXVECTOR2 vFraction;
	TERRAINVERTEX rVertex[4];
	hr = GetHeightFieldNeighbors(vP, &vFraction, rVertex);
	if (FAILED(hr))
		return hr;
	
	// Get interpolated height value
	*pfTerrainHeight = (1-vFraction.x) * (1-vFraction.y) * rVertex[0].vBase.z;
	*pfTerrainHeight += vFraction.x * (1-vFraction.y) * rVertex[1].vBase.z;
	*pfTerrainHeight += (1-vFraction.x) * vFraction.y * rVertex[2].vBase.z;
	*pfTerrainHeight += vFraction.x * vFraction.y * rVertex[3].vBase.z;

	// Scale and offset to output coords
	*pfTerrainHeight *= vSize.z;
	*pfTerrainHeight += m_vMin.z;
	return S_OK;
}


// DEBUG helps
static UINT s_nPosition = 0;
static D3DXVECTOR3 s_rvPosition[1000];
static D3DXVECTOR3 s_rvPositionX[1000];
static D3DXVECTOR3 s_rvPositionY[1000];
static D3DXVECTOR3 s_rvPositionZ[1000];

//-----------------------------------------------------------------------------
// Name: Resample
// Desc: Sample the height field at the current uv positions
//-----------------------------------------------------------------------------
HRESULT Terrain::Resample()
{
	s_nPosition = 0;	// DEBUG

	HRESULT hr;
	// Loop through all the vertices in the mesh, getting height value from array
	// TODO: use mipmaps for coarser sampling densities
	TERRAINVERTEX *pVertices;
	hr = m_grid.m_pVB->Lock(0, 0, (BYTE**)&pVertices, 0);
	if (FAILED(hr))
		return hr;
	float fGrassHeightCanonical = m_fGrassHeight / (m_vMax.z - m_vMin.z);
	for (UINT iYGrid = 0; iYGrid < m_grid.m_height; iYGrid++)
	for (UINT iXGrid = 0; iXGrid < m_grid.m_width; iXGrid++)
	{
		TERRAINVERTEX *pVertex = &pVertices[iYGrid * m_grid.m_width + iXGrid];
		D3DXVECTOR2 vP(pVertex->vBase.x, pVertex->vBase.y);
		
		// lookup neighboring points from height-field texture
		D3DXVECTOR2 vFraction;
		TERRAINVERTEX rVertex[4];
		hr = GetHeightFieldNeighbors(vP, &vFraction, rVertex);
		if (FAILED(hr))
			goto e_Exit;
		
		// Get interpolated height value
		pVertex->vBase.z  = (1-vFraction.x) * (1-vFraction.y) * rVertex[0].vBase.z;
		pVertex->vBase.z +=   vFraction.x   * (1-vFraction.y) * rVertex[1].vBase.z;
		pVertex->vBase.z += (1-vFraction.x) *   vFraction.y   * rVertex[2].vBase.z;
		pVertex->vBase.z +=   vFraction.x   *   vFraction.y   * rVertex[3].vBase.z;

		// Set offset layer
		pVertex->vTip = pVertex->vBase;
		pVertex->vTip.z += fGrassHeightCanonical;
	}

 e_Exit:
	m_grid.m_pVB->Unlock();
	return S_OK;
}


//-----------------------------------------------------------------------------
// Name: BallUpdate
// Desc: Have motion of ball from A to B affect terrain.
//-----------------------------------------------------------------------------
HRESULT Terrain::BallUpdate(float fTimeStep, const D3DXVECTOR3 &vPositionA, const D3DXVECTOR3 &vPositionB, float fRadius) // ball moved from A to B
{
	// Make a pass over each vertex in mesh.  If the vertex is within fRadius, then offset tip
	HRESULT hr;
	D3DXVECTOR3 vSize(m_vMax.x - m_vMin.x, m_vMax.y - m_vMin.y, m_vMax.z - m_vMin.z);
	D3DXVECTOR3 vDelta = vPositionB - vPositionA;
	float fGrassHeightCanonical = m_fGrassHeight / (m_vMax.z - m_vMin.z);
	float fRadius2 = fRadius * fRadius;
	static float fRestoreRate = 1.f;
	float fRestore = expf(-fRestoreRate * fTimeStep);
	TERRAINVERTEX *pVertices;
	hr = m_grid.m_pVB->Lock( 0, 0, (BYTE**)&pVertices, 0);
	if (FAILED(hr))
		return hr;
#if 1
	// Keep track of a few positions for debugging
	if (s_nPosition >= 1000)
		s_nPosition = 0;
	s_rvPosition[s_nPosition] =
	s_rvPositionX[s_nPosition] =
	s_rvPositionY[s_nPosition] =
	s_rvPositionZ[s_nPosition] = vPositionA;
	s_rvPositionX[s_nPosition].x += fRadius;
	s_rvPositionY[s_nPosition].y += fRadius;
	s_rvPositionZ[s_nPosition].z += fRadius;
	s_nPosition++;
#endif
	for (UINT iY = 0; iY < m_grid.m_height; iY++)
	for (UINT iX = 0; iX < m_grid.m_width; iX++)
	{
		TERRAINVERTEX *pVertex = &pVertices[iY * m_grid.m_width + iX];
		// Map to world coords
		D3DXVECTOR3 vTipWorld = pVertex->vTip;
		vTipWorld.x *= vSize.x;
		vTipWorld.y *= vSize.y;
		vTipWorld.z *= vSize.z;
		vTipWorld += m_vMin;
		D3DXVECTOR3 vDist = vPositionA - vTipWorld;	// assume that points are updated often so we don't have to test along line
		float fLenSq = D3DXVec2LengthSq((D3DXVECTOR2 *)&vDist);	// use 2D distance
		if (fLenSq < fRadius2 && vDist.z < fRadius)	// if ball is near or in grass
		{
			// TODO: add scaling, etc., for finer control
			vTipWorld += vDelta;

			// Scale tip vector to be hair length
			D3DXVECTOR3 vBaseWorld = pVertex->vBase;
			vBaseWorld.x *= vSize.x;
			vBaseWorld.y *= vSize.y;
			vBaseWorld.z *= vSize.z;
			vBaseWorld += m_vMin;
			D3DXVECTOR3 vGrass = vTipWorld - vBaseWorld;
			static float fFlattenedFraction = 0.3f;
			float fGrassFlattenedHeight = fFlattenedFraction * m_fGrassHeight;
			if (vGrass.z < fGrassFlattenedHeight) vGrass.z = fGrassFlattenedHeight;
			float fGrassLength = D3DXVec3Length(&vGrass);
		//	if (fGrassLength > m_fGrassHeight)
				vGrass *= m_fGrassHeight / fGrassLength;
			vTipWorld = vBaseWorld + vGrass;

			// Map back into canonical coords
			vTipWorld -= m_vMin;
			vTipWorld.x /= vSize.x;
			vTipWorld.y /= vSize.y;
			vTipWorld.z /= vSize.z;
			pVertex->vTip = vTipWorld;
		}
		else
		{
			// Slowly restore grass to it's default position
			D3DXVECTOR3 vTarget = pVertex->vBase;
			vTarget.z += fGrassHeightCanonical;
			pVertex->vTip *= fRestore;
			pVertex->vTip += (1 - fRestore) * vTarget;
		}
	}
	m_grid.m_pVB->Unlock();
	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: Refine
// Desc: Expand sampling grid around specified point to get more local samples
//-----------------------------------------------------------------------------
HRESULT Terrain::Refine(const D3DXVECTOR3 &vPosition, float fEpsilon)
{
	HRESULT hr;
	
	// Map to normalized coords
	D3DXVECTOR3 vSize = m_vMax - m_vMin;
	D3DXVECTOR3 vP = vPosition - m_vMin;
	vP.x /= vSize.x;
	vP.y /= vSize.y;

	// Distort sampling field to get more local samples around point.
	// Center grid on point, and shrink samples to be close by.  Then
	// gradually move samples back out to default sampling rate.
	TERRAINVERTEX *pVertices;
	hr = m_grid.m_pVB->Lock( 0, 0, (BYTE**)&pVertices, 0);
	if (FAILED(hr))
		return hr;
	float fWidthScale = 1.f / (m_grid.m_width - 1);
	float fHeightScale = 1.f / (m_grid.m_height - 1);
	static float fShrink = 0.2f; // shrink factor for highest sampling rate
	static float fRadius = 0.45f; // radius of region with highest sampling rate
	float fRadius2 = fRadius*fRadius;
	float fExpandExp = logf(fShrink) / (fRadius - 0.5f);
	for (UINT iY = 0; iY < m_grid.m_height; iY++)
	for (UINT iX = 0; iX < m_grid.m_width; iX++)
	{
		TERRAINVERTEX *pVertex = &pVertices[iY * m_grid.m_width + iX];
		float u = iX * fWidthScale - 0.5f;	// -0.5 to 0.5
		float v = iY * fHeightScale - 0.5f;
#if 0
		// L2 norm maps a circle
		float r2 = u*u + v*v;
		if (r2 < fRadius2)
		{
			// uniform shrink
			u *= fShrink;
			v *= fShrink;
		}
		else if (r2 < 0.25f) // 0.5*0.5
		{
			// make samples further apart based on distance from point,
			// returning to unit scaling at 0.5
			float fExpand = fShrink * expf(fExpandExp * (sqrtf(r2) - fRadius));
			u *= fExpand;
			v *= fExpand;
		}
#else
		// L infinity norm maps squares
		float fu = fabsf(u), fv = fabsf(v);
		float r = fu > fv ? fu : fv;
		if (r < fRadius)
		{
			// uniform shrink
			u *= fShrink;
			v *= fShrink;
		}
		else if (r < 0.5f)
		{
			// make samples further apart based on distance from point,
			// returning to unit scaling at 0.5
			float fExpand = fShrink * expf(fExpandExp * (r - fRadius));
			u *= fExpand;
			v *= fExpand;
		}
#endif		
		pVertex->vBase.x = u + vP.x; // center on desired point
		pVertex->vBase.y = v + vP.y;
		pVertex->vBase.z = 0.f;
	}
	m_grid.m_pVB->Unlock();
	
	return Resample();
}

//-----------------------------------------------------------------------------
// Name: Reset
// Desc: Drop all refinements and use just the base height field
//-----------------------------------------------------------------------------
HRESULT Terrain::Reset()
{
	HRESULT hr;
	
	// Reset sampling grid to uniform sampling.
	TERRAINVERTEX *pVertices;
	hr = m_grid.m_pVB->Lock( 0, 0, (BYTE**)&pVertices, 0);
	if (FAILED(hr))
		return hr;
	float fWidthScale = 1.f / (m_grid.m_width - 1);
	float fHeightScale = 1.f / (m_grid.m_height - 1);
	for (UINT iY = 0; iY < m_grid.m_height; iY++)
	for (UINT iX = 0; iX < m_grid.m_width; iX++)
	{
		TERRAINVERTEX *pVertex = &pVertices[iY * m_grid.m_width + iX];
		float u = iX * fWidthScale;
		float v = iY * fHeightScale;
		pVertex->vBase.x = u;
		pVertex->vBase.y = v;
		pVertex->vBase.z = 0.f;
	}
	m_grid.m_pVB->Unlock();
	
	return Resample();
}

//-----------------------------------------------------------------------------
// Name: Begin()
// Desc: Set up drawing state
//-----------------------------------------------------------------------------
HRESULT Terrain::Begin()
{
	// Update level of detail
	// Cull active tiles that are outside the frustum
	// Calculate ordering of tiles
	UINT xx = 0;	// texture stage
	g_pd3dDevice->SetTexture( xx, m_pTexture );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_ALPHAKILL, D3DTALPHAKILL_DISABLE );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_TEXCOORDINDEX, 0);
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_COLOROP,   D3DTOP_MODULATE );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_COLORARG1, D3DTA_TEXTURE );
#if 0		
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
#else		
	g_pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, 0xff003300 ); // just the green channel, darkened
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_COLORARG2, D3DTA_TFACTOR );
#endif		
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_MIPFILTER, D3DTEXF_LINEAR );
	g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE/*D3DCULL_CW */);
	g_pd3dDevice->SetRenderState(D3DRS_ZWRITEENABLE, TRUE);
	D3DXVECTOR4 vShellOffset(0.f, 0.f, 0.f, 0.f); // base tile layer has 0 offset
	D3DXVECTOR4 vTextureScale(1.f, 1.f, 0.f, 0.f); // base tile texture scale is identity
	D3DXVECTOR4 vColor(0.1f, 0.1f, 0.1f, 1.f); // base tile color is dark
	g_pd3dDevice->SetVertexShaderConstant( 1, &vShellOffset, 1);
	g_pd3dDevice->SetVertexShaderConstant( 2, &vTextureScale, 1);
	g_pd3dDevice->SetVertexShaderConstant( 3, &vColor, 1);
	float fFraction = 0.f;
	D3DXVECTOR4 vLayerFraction(1.f, 0.f, 1.f - fFraction, fFraction);
	g_pd3dDevice->SetVertexShaderConstant( 8, &vLayerFraction, 1);
	float fExtraShadowOffset = 0.5f;
	D3DXVECTOR4 vExtraShadow(-(1.f - fExtraShadowOffset) / m_fGrassHeight, 1.f, m_fGrassHeight, 1.f);
	g_pd3dDevice->SetVertexShaderConstant( 9, &vExtraShadow, 1);
	g_pd3dDevice->SetIndices( m_grid.m_pIB, 0 );
	g_pd3dDevice->SetVertexShader( m_dwTerrainVertexShader );
	
	// Set vertex shader matrix
	D3DXVECTOR3 vSize = m_vMax - m_vMin;
    D3DXMATRIX matScale;
	D3DXMatrixScaling(&matScale, vSize.x, vSize.y, vSize.z);
	D3DXMATRIX matOffset;
	D3DXMatrixTranslation(&matOffset, m_vMin.x, m_vMin.y, m_vMin.z);
    D3DXMATRIX matWorld;
    g_pd3dDevice->GetTransform( D3DTS_WORLD, &matWorld );
    D3DXMATRIX matView;
    g_pd3dDevice->GetTransform( D3DTS_VIEW, &matView );
    D3DXMATRIX matProjection;
    g_pd3dDevice->GetTransform( D3DTS_PROJECTION, &matProjection );
	D3DXMATRIX matWorldViewProjection = matScale * matOffset * matWorld * matView * matProjection;
	D3DXMATRIX matTranspose;
	D3DXMatrixTranspose(&matTranspose, &matWorldViewProjection);
	g_pd3dDevice->SetVertexShaderConstant( 4, &matTranspose, 4 );
	D3DXVECTOR4 vFraction(1.0, 0.f, 1.f, 0.f);	// set tile fraction
	g_pd3dDevice->SetVertexShaderConstant( 0, &vFraction, 1);
	
	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: DrawTerrain()
// Desc: Draws the scene as tiles, seams, and corners
//-----------------------------------------------------------------------------
HRESULT Terrain::DrawTerrain()
{
	LPDIRECT3DVERTEXBUFFER8 pVB = m_grid.m_pVB;
	UINT width = m_grid.m_width;
	UINT height = m_grid.m_height;
	if (pVB == NULL) return S_FALSE;
	g_pd3dDevice->SetStreamSource( 0, pVB, sizeof(TERRAINVERTEX) );
	g_pd3dDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST, 0, width*height, 0, (width-1)*(height-1)*2 );
	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: DrawTerrain()
// Desc: Draws debugging display
//-----------------------------------------------------------------------------
HRESULT Terrain::DrawDebug()
{
	if (s_nPosition < 2) return S_OK;
	HRESULT hr = S_OK;
	g_pd3dDevice->SetVertexShader(D3DFVF_XYZ);
	g_pd3dDevice->SetRenderState(D3DRS_EMISSIVEMATERIALSOURCE, D3DMCS_MATERIAL);
	g_pd3dDevice->SetRenderState(D3DRS_LIGHTING, TRUE);
	D3DMATERIAL8 material;
	ZeroMemory(&material, sizeof(material));
	material.Emissive  = D3DXCOLOR(1.f, 1.f, 1.f, 1.f);
	g_pd3dDevice->SetMaterial(&material);
	g_pd3dDevice->DrawPrimitiveUP(D3DPT_LINESTRIP, s_nPosition - 1, s_rvPosition, sizeof(D3DXVECTOR3));
	material.Emissive  = D3DXCOLOR(1.f, 0.f, 0.f, 1.f);
	g_pd3dDevice->SetMaterial(&material);
	g_pd3dDevice->DrawPrimitiveUP(D3DPT_LINESTRIP, s_nPosition - 1, s_rvPositionX, sizeof(D3DXVECTOR3));
	material.Emissive  = D3DXCOLOR(0.f, 1.f, 0.f, 1.f);
	g_pd3dDevice->SetMaterial(&material);
	g_pd3dDevice->DrawPrimitiveUP(D3DPT_LINESTRIP, s_nPosition - 1, s_rvPositionY, sizeof(D3DXVECTOR3));
	material.Emissive  = D3DXCOLOR(0.f, 0.f, 1.f, 1.f);
	g_pd3dDevice->SetMaterial(&material);
	g_pd3dDevice->DrawPrimitiveUP(D3DPT_LINESTRIP, s_nPosition - 1, s_rvPositionZ, sizeof(D3DXVECTOR3));
	return hr;
}

//-----------------------------------------------------------------------------
// Name: End()
// Desc: Clean up after drawing
//-----------------------------------------------------------------------------
HRESULT Terrain::End()
{
	// does nothing
	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: Cleanup()
// Desc: Clean up after ourselves.
//-----------------------------------------------------------------------------
HRESULT Terrain::Cleanup()
{
	if (m_dwTerrainVertexShader)
	{
		g_pd3dDevice->DeleteVertexShader(m_dwTerrainVertexShader);
		m_dwTerrainVertexShader = 0;
	}
	SAFE_RELEASE(m_pTexture);
	SAFE_RELEASE(m_pTerrain);
	m_grid.Cleanup();
    return S_OK;
}


// Returns size in bytes of pixel of given format, or -1 if size can
// not be determined from the format alone (e.g., D3DFMT_VERTEXDATA).
UINT GetPixelSize(D3DFORMAT format)
{
    switch (format)
    {
		case D3DFMT_A8R8G8B8:   return 4;
		case D3DFMT_X8R8G8B8:   return 4;
		case D3DFMT_A8:         return 1;
		case D3DFMT_LIN_A8R8G8B8:   return 4;
		case D3DFMT_LIN_X8R8G8B8:   return 4;
		case D3DFMT_LIN_A8:         return 1;
		default:
			return -1;
    }
}

// Unpacks color into pColor and returns pointer to pColor,
// or returns NULL if unpacking is not possible (or unimplemented.)
D3DXCOLOR *GetPixelColor(D3DXCOLOR *pColor, BYTE *pPixel, D3DFORMAT format)
{
    switch (format)
    {
		case D3DFMT_A8R8G8B8:
		case D3DFMT_LIN_A8R8G8B8:
		{
			float f = 1.f / 255.f;
			pColor->b = f * pPixel[0];
			pColor->g = f * pPixel[1];
			pColor->r = f * pPixel[2];
			pColor->a = f * pPixel[3];
			return pColor;
		}
		
		case D3DFMT_X8R8G8B8:
		case D3DFMT_LIN_X8R8G8B8:
		{
			float f = 1.f / 255.f;
			pColor->b = f * pPixel[0];
			pColor->g = f * pPixel[1];
			pColor->r = f * pPixel[2];
			pColor->a = 1.f;
			return pColor;
		}
		
		case D3DFMT_A8:
		case D3DFMT_LIN_A8:
		{
			float f = 1.f / 255.f;
			pColor->b = 0.f;
			pColor->g = 0.f;
			pColor->r = 0.f;
			pColor->a = f * pPixel[0];
			return pColor;
		}
		default:
			return NULL;
    }
}

//-----------------------------------------------------------------------------
// Name: CopyRectsVB()
// Desc: Like IDirect3DDevice8's CopyRects, but copies pixel data
// to vertex buffers
//-----------------------------------------------------------------------------
HRESULT CopyRectsVB(
	IDirect3DSurface8* pSourceSurface,
	CONST RECT* pSourceRectsArray,
	UINT cRects,
	void *pvDestinationVertices,
	// we'd like to use IDirect3DVertexBuffer8* pDestinationVB, but
	// multiple locks on the destination with DISCARD_CONTENTS doesn't work
	UINT cbDestinationStride,
	UINT cbDestinationPitch,
	CONST POINT* pDestinationPointsArray)
{
	HRESULT hr;
	D3DSURFACE_DESC desc;
	hr = pSourceSurface->GetDesc(&desc);
	if (FAILED(hr))
		return hr;
	D3DFORMAT pixelFormat = desc.Format;
	DWORD dwPixelStride = GetPixelSize(pixelFormat);
	if (dwPixelStride == -1)
		return E_NOTIMPL;	// we can't handle the format
	RECT rectFull;
	rectFull.left = 0;
	rectFull.top = 0;
	rectFull.right = desc.Width;
	rectFull.bottom = desc.Height;
	if (pSourceRectsArray == NULL)
	{
		if (cRects != 1
			&& cRects != 0)
			return E_INVALIDARG;
		pSourceRectsArray = &rectFull;
		cRects = 1;
	}
	for (UINT iRect = 0; iRect < cRects; iRect++)
	{
		// validate size of source rect
		const RECT *pRect = &pSourceRectsArray[iRect];
		if (pRect->top < rectFull.top
			|| pRect->left < rectFull.left
			|| pRect->bottom > rectFull.bottom
			|| pRect->right > rectFull.right)
			return E_INVALIDARG;
		// Get offset to upper left corner of destination
		POINT pointDestinationOffset;
		if (pDestinationPointsArray != NULL)
		{
			pointDestinationOffset.x = pDestinationPointsArray[iRect].x - pRect->left;
			pointDestinationOffset.y = pDestinationPointsArray[iRect].y - pRect->top;
		}
		else
		{
			pointDestinationOffset.x = 0;
			pointDestinationOffset.y = 0;
		}
		// WARNING: No validation is done on the destination rect
		D3DLOCKED_RECT lockedRect;
		hr = pSourceSurface->LockRect(&lockedRect, NULL, D3DLOCK_READONLY);
		if (FAILED(hr))
			return hr;
		if (XGIsSwizzledFormat(pixelFormat))
		{
			Swizzler s(desc.Width, desc.Height, 0);
			// Expand and copy the colors
			for (LONG iY = pRect->top; iY < pRect->bottom; iY++)
			{
				BYTE *pDestinationRow = (BYTE *)pvDestinationVertices + (iY + pointDestinationOffset.y) * cbDestinationPitch;
				s.SetV(s.SwizzleV(iY));
				s.SetU(s.SwizzleU(pRect->left));
				for (LONG iX = pRect->left; iX < pRect->right; iX++)
				{
					// Unpack and then pack color
					D3DXCOLOR pixelColor;
					BYTE *pPixel = (BYTE *)lockedRect.pBits + dwPixelStride * s.Get2D();
					if (GetPixelColor(&pixelColor, pPixel, pixelFormat) == NULL)
					{
						pSourceSurface->UnlockRect();
						return E_NOTIMPL;
					}
					D3DXVECTOR3 *pxyz = (D3DXVECTOR3 *)(pDestinationRow + (iX + pointDestinationOffset.x) * cbDestinationStride);
					pxyz->x = pixelColor.r;
					pxyz->y = pixelColor.b;
					pxyz->z = pixelColor.g;	// swap with b to put g as height
					s.IncU();
				}
			}
		}
		else
		{
			// Expand and copy the colors
			for (LONG iY = pRect->top; iY < pRect->bottom; iY++)
			{
				BYTE *pSourceRow = (BYTE *)lockedRect.pBits + lockedRect.Pitch * (iY - pRect->top);
				BYTE *pDestinationRow = (BYTE *)pvDestinationVertices + (iY + pointDestinationOffset.y) * cbDestinationPitch;
				for (LONG iX = pRect->left; iX < pRect->right; iX++)
				{
					// Unpack color and copy to xyz
					D3DXCOLOR pixelColor;
					BYTE *pPixel = pSourceRow + (iX - pRect->left) * dwPixelStride;
					if (GetPixelColor(&pixelColor, pPixel, pixelFormat) == NULL)
					{
						pSourceSurface->UnlockRect();
						return E_NOTIMPL;
					}
					D3DXVECTOR3 *pxyz = (D3DXVECTOR3 *)(pDestinationRow + (iX + pointDestinationOffset.x) * cbDestinationStride);
					pxyz->x = pixelColor.r;
					pxyz->y = pixelColor.b;
					pxyz->z = pixelColor.g; // swap with b to put g as height
				}
			}
		}
		pSourceSurface->UnlockRect();
		if (FAILED(hr))
			return hr;
	}
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\grass\comp3.inl ===
// Xbox Shader Assembler 1.00.3516.1
D3DPIXELSHADERDEF psd;
ZeroMemory(&psd, sizeof(psd));
psd.PSCombinerCount=PS_COMBINERCOUNT(
    2,
    PS_COMBINERCOUNT_MUX_MSB | PS_COMBINERCOUNT_UNIQUE_C0 | PS_COMBINERCOUNT_UNIQUE_C1);
psd.PSTextureModes=PS_TEXTUREMODES(
    PS_TEXTUREMODES_PROJECT2D,
    PS_TEXTUREMODES_PROJECT2D,
    PS_TEXTUREMODES_PROJECT2D,
    PS_TEXTUREMODES_NONE);
psd.PSInputTexture=PS_INPUTTEXTURE(0,0,0,0);
psd.PSDotMapping=PS_DOTMAPPING(
    0,
    PS_DOTMAPPING_ZERO_TO_ONE,
    PS_DOTMAPPING_ZERO_TO_ONE,
    PS_DOTMAPPING_ZERO_TO_ONE);
psd.PSCompareMode=PS_COMPAREMODE(
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT);

//------------- Stage 0 -------------
psd.PSRGBInputs[0]=PS_COMBINERINPUTS(
    PS_REGISTER_T1 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_T1 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_T0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSAlphaInputs[0]=PS_COMBINERINPUTS(
    PS_REGISTER_T1 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_T1 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_T0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSRGBOutputs[0]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R1,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[0]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R1,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[0] = 0x00000000;
psd.PSConstant1[0] = 0x00000000;

//------------- Stage 1 -------------
psd.PSRGBInputs[1]=PS_COMBINERINPUTS(
    PS_REGISTER_T2 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_T2 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_R1 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSAlphaInputs[1]=PS_COMBINERINPUTS(
    PS_REGISTER_T2 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_T2 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_R1 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSRGBOutputs[1]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[1]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[1] = 0x00000000;
psd.PSConstant1[1] = 0x00000000;

psd.PSC0Mapping = 0xffffffff;
psd.PSC1Mapping = 0xffffffff;
psd.PSFinalCombinerConstants = 0x000001ff;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\grass\comp2.inl ===
// Xbox Shader Assembler 1.00.3516.1
D3DPIXELSHADERDEF psd;
ZeroMemory(&psd, sizeof(psd));
psd.PSCombinerCount=PS_COMBINERCOUNT(
    1,
    PS_COMBINERCOUNT_MUX_MSB | PS_COMBINERCOUNT_UNIQUE_C0 | PS_COMBINERCOUNT_UNIQUE_C1);
psd.PSTextureModes=PS_TEXTUREMODES(
    PS_TEXTUREMODES_PROJECT2D,
    PS_TEXTUREMODES_PROJECT2D,
    PS_TEXTUREMODES_NONE,
    PS_TEXTUREMODES_NONE);
psd.PSInputTexture=PS_INPUTTEXTURE(0,0,0,0);
psd.PSDotMapping=PS_DOTMAPPING(
    0,
    PS_DOTMAPPING_ZERO_TO_ONE,
    PS_DOTMAPPING_ZERO_TO_ONE,
    PS_DOTMAPPING_ZERO_TO_ONE);
psd.PSCompareMode=PS_COMPAREMODE(
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT);

//------------- Stage 0 -------------
psd.PSRGBInputs[0]=PS_COMBINERINPUTS(
    PS_REGISTER_T1 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_T1 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_T0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSAlphaInputs[0]=PS_COMBINERINPUTS(
    PS_REGISTER_T1 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_T1 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_T0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSRGBOutputs[0]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[0]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[0] = 0x00000000;
psd.PSConstant1[0] = 0x00000000;

psd.PSC0Mapping = 0xffffffff;
psd.PSC1Mapping = 0xffffffff;
psd.PSFinalCombinerConstants = 0x000001ff;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\MatrixPaletteSkinning\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\grass\Terrain.h ===
#pragma once
//-----------------------------------------------------------------------------
//  
//  File: Terrain.h
//  Copyright (C) 2001 Microsoft Corporation
//  All rights reserved.
//  
//-----------------------------------------------------------------------------
#include "Terrain.h"

struct Grid {
	UINT m_width, m_height;					// size of grid
	LPDIRECT3DVERTEXBUFFER8 m_pVB;	 		// vertex buffer
	LPDIRECT3DINDEXBUFFER8  m_pIB;			// triangle indices
	Grid() { m_pVB = NULL; m_pIB = NULL; }
	~Grid() { Cleanup(); }
	HRESULT Initialize(UINT width, UINT height, UINT cbVertexSize);
	HRESULT Cleanup();
};

struct TERRAINVERTEX
{
	D3DXVECTOR3 vBase; // texture coords + height field
	D3DXVECTOR3 vTip; // offset to grass tips
};

class Terrain
{
	Grid	m_grid;							// grid sampled from height field
	LPDIRECT3DTEXTURE8      m_pTerrain;		// terrain height field texture
	LPDIRECT3DTEXTURE8      m_pTexture;		// terrain texture
	DWORD m_dwTerrainVertexShader;			// terrain vertex shader handle
	D3DXVECTOR3 m_vMin, m_vMax;				// bounds of terrain
	float m_fGrassHeight;					// default height of grass in the world

	HRESULT GetHeightFieldNeighbors(const D3DXVECTOR2 &vP, D3DXVECTOR2 *pvFraction, TERRAINVERTEX rVertex[4]);
	HRESULT Resample(); // fill vertex buffer with current sampling densities
public:
	Terrain();
	~Terrain() { Cleanup(); }
	HRESULT Initialize(LPDIRECT3DTEXTURE8 pTerrain, LPDIRECT3DTEXTURE8 pTexture, const D3DXVECTOR3 &vMin, const D3DXVECTOR3 &vMax, float fGrassHeight);
	HRESULT GetTerrainPoint(const D3DXVECTOR3 &vPosition, float *pfTerrainHeight, D3DXVECTOR3 *pvTerrainNormal);	// look up terrain point from height field texture
	HRESULT BallUpdate(float fTimeStep, const D3DXVECTOR3 &vPositionA, const D3DXVECTOR3 &vPositionB, float fRadius); // ball moved from A to B
	HRESULT Refine(const D3DXVECTOR3 &vPosition, float fEpsilon); // add more samples near vPosition in the domain
	HRESULT Reset();						// drop to lowest level LOD, uniform sampling
	HRESULT Begin();						// cull tiles, calc rendering order, setup vertex shader and texture state
	HRESULT DrawTerrain();					// draw raw terrain geometry. Bracket with Begin .. End to set up rendering state.
	HRESULT DrawDebug();					// draw debugging info, such as the trajectory of the ball used in BallUpdate
	HRESULT End();							// paired with begin to cleanup unusual rendering state
	HRESULT Cleanup();
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\grass\grass.cpp ===
//-----------------------------------------------------------------------------
// Copyright (c) 2000-2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <XBMesh.h>
#include <XPath.h>
#include <XBResource.h>
#include <XBUtil.h>
#include <assert.h>
#include <xgraphics.h>
#include "XBGrass.h"
#include "Terrain.h"

// The following header file is generated from "Resource.rdf" file using the
// Bundler tool. In addition to the header, the tool outputs a binary file
// (Resource.xpr) which contains compiled (i.e. bundled) resources and is
// loaded at runtime using the CXBPackedResource class.
#include "Resource.h"

//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
	{ XBHELP_LEFTSTICK,	   XBHELP_PLACEMENT_2, L"Move in-out and left-right" },
	{ XBHELP_RIGHTSTICK,   XBHELP_PLACEMENT_2, L"Rotate and tilt view" },
	{ XBHELP_DPAD,		   XBHELP_PLACEMENT_2, L"Move up and down" },
	{ XBHELP_BLACK_BUTTON, XBHELP_PLACEMENT_1, L"Toggle grass" },
	{ XBHELP_WHITE_BUTTON, XBHELP_PLACEMENT_1, L"Toggle wire-frame" },
	{ XBHELP_A_BUTTON,	   XBHELP_PLACEMENT_2, L"Launch ball" },
	{ XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_1, L"Toggle help" },
    { XBHELP_START_BUTTON, XBHELP_PLACEMENT_1, L"Pause" },
};
#define NUM_HELP_CALLOUTS (sizeof(g_HelpCallouts) / sizeof(XBHELP_CALLOUT))

//-----------------------------------------------------------------------------
// Global scale parameters
//-----------------------------------------------------------------------------
D3DXVECTOR3 g_vGravity(0.f, 0.f, -9.8f);
D3DXVECTOR3 g_vLightDirection = D3DXVECTOR3(-0.577350269f, 0.577350269f, 0.577350269f);
D3DXVECTOR3 g_vMin(-16.f, -16.f, 0.f), g_vMax(16.f, 16.f, 0.5f);	// scale of height field in world coords
float g_fGrassHeight = 0.2f;
bool g_bWireFrame = false;
bool g_bDrawTerrain = true;
bool g_bDrawGrass = true;
bool g_bDrawBall = true;
bool g_bFollowBall = true;
bool g_bDebugBall = false;
bool g_bDebugDraw = false;
bool g_bDrawHelp = false;			// Whether to draw help

//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//		 from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
	CXBFont			m_Font;					// Font for rendering stats and help
	CXBHelp			m_Help;					// Help class
    CXBPackedResource m_xprResources;		// Packed texture resources
	D3DXVECTOR3		m_vFrom, m_vAt, m_vUp;	// Viewing parameters
	D3DXMATRIX		m_matView;
	D3DXMATRIX		m_matViewInverse;
	D3DXMATRIX		m_matProjection;
	Terrain		   *m_pTerrain; // current terrain representation
	CXBGrass		m_grass;	// grass slice texture
	D3DXVECTOR4		m_vTextureScaleGrass;
	D3DXVECTOR4		m_vOffsetGrass;
	float			m_fLODGrass;
	CXBMesh			m_meshBall;
	D3DXVECTOR3		m_vBallPosition;
	D3DXVECTOR3		m_vBallVelocity;
	D3DXMATRIX		m_matBallRoll;
	DWORD			m_dwBallVertexShader;
	float			m_fLaunchCountDown;
public:
	CXBoxSample();
	HRESULT DrawGrass();
	HRESULT LaunchBall();
	HRESULT MoveBall();
	
	// CXBApplication overrides
	HRESULT Initialize();
	HRESULT FrameMove();
	HRESULT Render();
	HRESULT Cleanup();
};

#ifndef _XBOX
//-----------------------------------------------------------------------------
// Name: wWinMain()
// Desc: Entry point to the program. Initializes everything, and goes into a
//		 message-processing loop. Idle time is used to render the scene.
//-----------------------------------------------------------------------------
INT WINAPI wWinMain( HINSTANCE, HINSTANCE, LPWSTR, INT )
{
	CXBoxSample xbApp;
	if( FAILED( xbApp.Create() ) )
		return 0;
	return xbApp.Run();
}
#else
//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program. Initializes everything, and goes into a
//		 message-processing loop. Idle time is used to render the scene.
//-----------------------------------------------------------------------------
void __cdecl main()
{
	CXBoxSample xbApp;
	if( FAILED( xbApp.Create() ) )
		return;
	xbApp.Run();
}
#endif

//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
			:CXBApplication()
{
/*
#ifdef _DEBUG	
	// Allow unlimited frame rate
	m_d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;
#endif
*/
	m_pTerrain = NULL;
	m_dwBallVertexShader = 0;
}

//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Initialize device-dependant objects.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
	HRESULT hr;
	m_bPaused = false;

	XPath_SetBasePath(_T("d:\\media\\"));

	// Create a font
	if(FAILED(hr = m_Font.Create(m_pd3dDevice, "Font.xpr")))
		return XBAPPERR_MEDIANOTFOUND;

	// Create the help
	if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
		return XBAPPERR_MEDIANOTFOUND;

    // Load resources from the packed resource file. Resources (textures, vertex
    // buffers,etc.) can be packed this way so they load super quick and require
    // no load-time processing (like parsing a .bmp file, changing formats,
    // swizzling, etc.). See the code in XBResource.cpp to see how simple it is.
    if( FAILED( m_xprResources.Create( m_pd3dDevice, "Resource.xpr", 
                                       resource_NUM_RESOURCES ) ) )
        return E_FAIL;

	// load the terrain image and create the height field mesh
	m_pTerrain = new Terrain;
	if (m_pTerrain == NULL)
		return E_OUTOFMEMORY;
	LPDIRECT3DTEXTURE8 pTextureTerrain = m_xprResources.GetTexture( (DWORD)resource_TerrainTexture_OFFSET );
	hr = m_pTerrain->Initialize(pTextureTerrain, pTextureTerrain, g_vMin, g_vMax, g_fGrassHeight); // use the terrain heightfield image as a texture map, too
	if (FAILED(hr))
		return hr;

	// Set camera parameters
	m_vFrom = D3DXVECTOR3( 1.0f, 2.f, 4.0f );
	m_vAt = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );
	m_vUp = D3DXVECTOR3( 0.0f, 0.0f, 1.0f );

	// initialize the grass slice texture
	{
		DWORD numfuzz = 8000;
		DWORD numfuzzlib = 32;
		DWORD numslices = 10;
		DWORD slicexsize = 256; // 128;
		DWORD slicezsize = 256; // 128;
		m_grass.m_dwSeed = 51101213;
		m_grass.m_fXSize = 0.1f;
		m_grass.m_fYSize = 0.01f;
		m_grass.m_fZSize = 0.1f;
		m_grass.m_dwNumSegments = 4;
		m_grass.m_fuzzRandom.colorBase = D3DXCOLOR(0.2f, 0.2f, 0.2f, 0.0f);
		m_grass.m_fuzzCenter.colorBase = D3DXCOLOR(0.2f, 1.0f, 0.2f, 1.f) - 0.5f * m_grass.m_fuzzRandom.colorBase;
		m_grass.m_fuzzRandom.colorTip = D3DXCOLOR(0.0f, 0.0f, 0.f, 0.0f);
		m_grass.m_fuzzCenter.colorTip = D3DXCOLOR(0.0f, 0.1f, 0.f, 0.1f) - 0.5f * m_grass.m_fuzzRandom.colorTip;
		m_grass.m_fuzzCenter.dp = D3DXVECTOR3(0.0f, 4.f, 0.5f);
		m_grass.m_fuzzRandom.dp = D3DXVECTOR3(0.25f, 0.25f, 0.25f);
		m_grass.m_fuzzCenter.ddp = D3DXVECTOR3(0.f, 0.f, 0.0f);
		m_grass.m_fuzzRandom.ddp = D3DXVECTOR3(0.5f, 0.5f, 0.5f);
		OUTPUT_DEBUG_STRING("Grass: distribute...");
		m_grass.InitFuzz(numfuzz, numfuzzlib);
		OUTPUT_DEBUG_STRING(" slice...");
		m_grass.GenSlices(numslices, slicexsize, slicezsize);
		OUTPUT_DEBUG_STRING(" LOD...");
		m_grass.ComputeLevelOfDetailTextures();
		m_grass.SetLevelOfDetail(0.f);
		D3DMATERIAL8 material;
		ZeroMemory(&material, sizeof(material));
		material.Ambient  = D3DXCOLOR(0.2f, 0.2f, 0.2f, 1.f);
		material.Diffuse  = D3DXCOLOR(0.5f, 0.5f, 0.5f, 1.f);
		material.Specular = D3DXCOLOR(1.f, 1.f, 1.f, 1.f);
		material.Power = 40.0f;
		m_grass.SetHairLightingMaterial(&material);
		m_vTextureScaleGrass = D3DXVECTOR4(g_vMax.x - g_vMin.x, g_vMax.y - g_vMin.y, 0.f, 0.f);
		m_vOffsetGrass = D3DXVECTOR4(0.f, 0.f, 0.2f * 0.5f / (g_vMax.z - g_vMin.z), 0.f); // Z is up
		OUTPUT_DEBUG_STRING(" compress...");
		m_grass.SetTextureFormat(D3DFMT_DXT4);
		m_fLODGrass = 0.f;
		OUTPUT_DEBUG_STRING(" done.\n");
	}

	// Load the ball mesh
	if( FAILED( m_meshBall.Create( m_pd3dDevice, "Models\\GBall.xbg" ) ) )
		return XBAPPERR_MEDIANOTFOUND;
	LaunchBall();
	D3DXMatrixIdentity(&m_matBallRoll);

	// Load the ball vertex shader
	{
		DWORD vsdecl[] = 
		{
			D3DVSD_STREAM(0),
			D3DVSD_REG(0, D3DVSDT_FLOAT3),		// position
			D3DVSD_REG(1, D3DVSDT_FLOAT3),		// normal
			D3DVSD_END()
		};
		XBUtil_CreateVertexShader(m_pd3dDevice, _FNA("Shaders\\golfball.xvu"), vsdecl, &m_dwBallVertexShader);
		if(!m_dwBallVertexShader)
			OUTPUT_DEBUG_STRING("Initialize : error loading golfball.xvu\n");
	}
	
	// set light parameters, but disable light by default
	D3DLIGHT8 light;
	ZeroMemory(&light, sizeof(D3DLIGHT8));
	light.Type = D3DLIGHT_DIRECTIONAL;
	light.Position = D3DXVECTOR3(10000.f, 10000.f, 10000.f); // sun
	light.Direction = g_vLightDirection;
	light.Ambient  = D3DXCOLOR(0.2f, 0.2f, 0.2f, 1.f);
	light.Diffuse = D3DXCOLOR(1.f, 1.f, 1.f, 1.f);
	light.Specular = D3DXCOLOR(1.f, 1.f, 1.f, 1.f);
	g_pd3dDevice->SetLight(0, &light);
	g_pd3dDevice->LightEnable(0, FALSE);
	return hr;
}

//-----------------------------------------------------------------------------
// Name: Cleanup()
// Desc: Clean up after ourselves.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Cleanup()
{
	SAFE_DELETE(m_pTerrain);
	if (m_dwBallVertexShader)
		g_pd3dDevice->DeleteVertexShader(m_dwBallVertexShader);
	return S_OK;
}



//-----------------------------------------------------------------------------
// Name: DrawGrass
// Desc:
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::DrawGrass()
{
	// Setup pixel shader texture state for grass
	UINT xx = 0;
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_ALPHAKILL, D3DTALPHAKILL_ENABLE );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_TEXCOORDINDEX, 0);
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_COLOROP, D3DTOP_MODULATE);
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_COLORARG1, D3DTA_TEXTURE );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_ALPHAOP, D3DTOP_MODULATE);
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
	g_pd3dDevice->SetTextureStageState( xx, D3DTSS_MIPFILTER, D3DTEXF_LINEAR );
	g_pd3dDevice->SetRenderState(D3DRS_CULLMODE, D3DCULL_CW );
	g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_ONE);	 // premultiplied alpha
	g_pd3dDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
	g_pd3dDevice->SetRenderState(D3DRS_LIGHTING, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_ZWRITEENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_ALPHATESTENABLE, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_ALPHAFUNC, D3DCMP_GREATER);
	static DWORD dwAlphaRef = 0;
	g_pd3dDevice->SetRenderState(D3DRS_ALPHAREF, dwAlphaRef);
	UINT nLayer;
	D3DXVECTOR4 vOffsetTotal;
	LPDIRECT3DTEXTURE8 *apSliceTexture;
	m_grass.SetLevelOfDetail(m_fLODGrass); 
	nLayer = m_grass.m_dwNumSlicesLOD;
	vOffsetTotal = m_vOffsetGrass;
	apSliceTexture = m_grass.m_pSliceTextureLOD;
	g_pd3dDevice->SetVertexShaderConstant( 2, &m_vTextureScaleGrass, 1);
	float fExtraShadowOffset = 0.5f;
	D3DXVECTOR4 vExtraShadow(-(1.f - fExtraShadowOffset) / vOffsetTotal.z, 1.f, vOffsetTotal.z, 1.f);
	g_pd3dDevice->SetVertexShaderConstant( 9, &vExtraShadow, 1);
	float fScale = 1.f/(float)nLayer;
	for (UINT iLayer = 0; iLayer < nLayer; iLayer++)
	{
		float fFraction = (iLayer+1)*fScale;
		D3DXVECTOR4 vShellOffset = fFraction * vOffsetTotal;
		g_pd3dDevice->SetTexture( 0, apSliceTexture[iLayer]);
		g_pd3dDevice->SetVertexShaderConstant( 1, &vShellOffset, 1);
		D3DXVECTOR4 vLayerFraction(1.f, 0.f, 1.f - fFraction, fFraction);
		g_pd3dDevice->SetVertexShaderConstant( 8, &vLayerFraction, 1);
		static float s_fSF = 0.f;
		float fShadowFraction = (iLayer + s_fSF) * fScale;
		float fShadow = 0.1f + 0.6f * fShadowFraction * fShadowFraction;
		D3DXVECTOR4 vColor(fShadow, fShadow, fShadow, 1.f);
		g_pd3dDevice->SetVertexShaderConstant( 3, &vColor, 1);
		m_pTerrain->DrawTerrain();
	}
	return S_OK;
}

static float fBallRadius = 0.05f/2; // meters, current art.	 Actual golf ball should be 0.042672/2 radius (1.68 inches in diameter)
static float fBallMass = 0.0460227f; // 1.62 ounces * 1 pound / 16 ounces * 1 kg / 2.2 pound

//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//		 the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
	if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK )
		g_bDrawHelp = !g_bDrawHelp;

	if (m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_BLACK])
		g_bDrawGrass = !g_bDrawGrass;
	
	if (m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_WHITE])
		g_bWireFrame = !g_bWireFrame;
	
	if (m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_A])
		LaunchBall();

	// Scale translation by height above z-plane
	float fTranslateScale = fabsf(m_vFrom.z) + 0.01f;

	// update view position
	static float fOffsetScale = 0.5f;
	float fX1 = m_DefaultGamepad.fX1;
	fX1 *= fX1 * fX1; // fX1 cubed
	float fY1 = m_DefaultGamepad.fY1;
	fY1 *= fY1 * fY1; // fY1 cubed
	D3DXVECTOR3 vOffset(fX1, 0.f, fY1);
	D3DXVec3TransformNormal(&vOffset, &vOffset, &m_matViewInverse);
	D3DXVec3Normalize(&m_vUp, &m_vUp);
	vOffset -= D3DXVec3Dot(&vOffset, &m_vUp) * m_vUp; // don't move up or down with thumb sticks
	D3DXVec3Normalize(&vOffset, &vOffset);
	vOffset *= fTranslateScale * fOffsetScale * m_fElapsedTime;
	m_vFrom += vOffset;
	m_vAt += vOffset;
	
	// move up and down with DPAD
	static float fVerticalScale = 1.f;
	D3DXVECTOR3 vVerticalOffset(0.f, 0.f, 0.f);
	if (m_DefaultGamepad.wButtons & XINPUT_GAMEPAD_DPAD_UP)
		vVerticalOffset.z += fTranslateScale * fVerticalScale * m_fElapsedTime;
	if(m_DefaultGamepad.wButtons & XINPUT_GAMEPAD_DPAD_DOWN)
		vVerticalOffset.z -= fTranslateScale * fVerticalScale * m_fElapsedTime;
	m_vFrom += vVerticalOffset;
	m_vAt += vVerticalOffset;

	// update view angle
	static float fAtOffsetScale = 4.f;
	D3DXVECTOR3 vAtOffset(0.f, 0.f, 0.f);
	float fX2 = m_DefaultGamepad.fX2;
	fX2 *= fX2 * fX2; // fX2 cubed
	float fY2 = m_DefaultGamepad.fY2;
	fY2 *= fY2 * fY2; // fY2 cubed
	vAtOffset.x += fAtOffsetScale * fX2 * m_fElapsedTime;
	D3DXVECTOR3 vE = m_vAt - m_vFrom;
	D3DXVec3Normalize(&vE, &vE);
	float fThreshold = 0.99f;
	float fEdotU = D3DXVec3Dot(&vE, &m_vUp);
	if ((fEdotU < -fThreshold && fY2 < 0.f) // near -vUp, but positive movement
		|| (fEdotU > fThreshold && fY2 > 0.f)	// near vUp, but negative movement
		|| (fEdotU > -fThreshold && fEdotU < fThreshold))		// ordinary case
		vAtOffset.y -= fAtOffsetScale * fY2 * m_fElapsedTime;
	D3DXVec3TransformNormal(&vAtOffset, &vAtOffset, &m_matViewInverse);
	m_vAt += vAtOffset;

	// For the projection matrix, we set up a perspective transform (which
	// transforms geometry from 3D view space to 2D viewport space, with
	// a perspective divide making objects smaller in the distance). To build
	// a perpsective transform, we need the field of view (1/4 pi is common),
	// the aspect ratio, and the near and far clipping planes (which define at
	// what distances geometry should be no longer be rendered).
	D3DXMatrixPerspectiveFovLH( &m_matProjection, D3DX_PI/4, 640.f/480.f, 0.01f, 100.0f );
	g_pd3dDevice->SetTransform( D3DTS_PROJECTION, &m_matProjection );

	// Set up our view matrix.
	D3DXMatrixLookAtLH( &m_matView, &m_vFrom, &m_vAt, &m_vUp);
	g_pd3dDevice->SetTransform( D3DTS_VIEW, &m_matView );
	D3DXMatrixInverse(&m_matViewInverse, NULL, &m_matView);

	// Set world matrix to identity
	D3DXMATRIX matIdentity;
	D3DXMatrixIdentity(&matIdentity);
	g_pd3dDevice->SetTransform( D3DTS_WORLD, &matIdentity );

	// Set the vertex shader constants for the ball
	//	c20-c23 = world*view*proj matrix
	//	c24 = light direction in object coords
	//	c25 = clamping color
	MoveBall();
	D3DXMATRIX matBallScale;
	static float fBallScale = 8.f; // ball looks too small, so make it appear bigger
	D3DXMatrixScaling(&matBallScale, fBallScale, fBallScale, fBallScale);
	// Make the ball roll in the direction of travel.  A better physics model would produce the rolling velocity directly.
	float fVelocity = D3DXVec2Length((D3DXVECTOR2 *)&m_vBallVelocity);
	if (fVelocity > 1e-4f)
	{
		static float fBallRollFactor = -10.f;
		float fBallRollAngle = fBallRollFactor * D3DXVec2Dot((D3DXVECTOR2 *)&m_vBallVelocity, (D3DXVECTOR2 *)&m_vBallPosition) / fVelocity;
		D3DXVECTOR3 vBallRollAxis;
		D3DXVec3Cross(&vBallRollAxis, &m_vBallVelocity, &m_vUp);
		D3DXVec3Normalize(&vBallRollAxis, &vBallRollAxis);
		D3DXMatrixRotationAxis(&m_matBallRoll, &vBallRollAxis, fBallRollAngle);
	}
	D3DXMATRIX matBallTranslate;
	D3DXMatrixTranslation(&matBallTranslate, m_vBallPosition.x, m_vBallPosition.y, m_vBallPosition.z);
	D3DXMATRIX matBall = matBallScale * m_matBallRoll * matBallTranslate;
	D3DXMATRIX matBallWorldViewProjection = matBall * m_matView * m_matProjection;
	D3DXMATRIX matBallTranspose;
	D3DXMatrixTranspose(&matBallTranspose, &matBallWorldViewProjection);
	g_pd3dDevice->SetVertexShaderConstant( 20, &matBallTranspose, 4 );

	// transform light direction
	D3DXVECTOR3 vLightDirection;
	D3DXMATRIX matBallRollTranspose;
	D3DXMatrixTranspose(&matBallRollTranspose, &m_matBallRoll);
	D3DXVec3TransformNormal(&vLightDirection, &g_vLightDirection, &matBallRollTranspose);
	g_pd3dDevice->SetVertexShaderConstant( 24, &vLightDirection, 1 );
	
	static D3DXCOLOR rColorBall[] =
	{
		D3DXCOLOR(2.0f, 2.0f, 2.0f, 1.f),		// diffuse hemisphere conditioning
		D3DXCOLOR(0.3f, 0.3f, 0.3f, 1.f),		// ambient hemisphere conditioning should be larger than clamp value
		D3DXCOLOR(-0.1f, -0.1f, -0.1f, 1.f),	// clamp to negative number to let a light "bleed" around edges
		D3DXCOLOR(1.0f, 1.0f, 1.0f, 1.f),		// diffuse dimple
		D3DXCOLOR(0.2f, 0.2f, 0.2f, 1.f),		// ambient dimple
	};
	g_pd3dDevice->SetVertexShaderConstant( 25, &rColorBall, 5 );
	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: LaunchBall
// Desc: Fire new ball in a random direction
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::LaunchBall()
{
#define fUnitRand(fmin, fmax) ((float)rand()/32768.0f*((fmax) - (fmin)) + (fmin))
	float fTheta = fUnitRand(0.f, 2.f * D3DX_PI);
	float fRadius = 16.f;
	float fX = cosf(fTheta);
	float fY = sinf(fTheta);
	m_vBallPosition = D3DXVECTOR3(fX*fRadius, fY*fRadius, 5.f);
	m_vBallVelocity = D3DXVECTOR3(-fX*fUnitRand(2.f, 10.f), -fY*fUnitRand(2.f, 10.f), fUnitRand(0.5f, 2.5f));
	if (g_bFollowBall)
	{
		m_vAt.x = m_vBallPosition.x;
		m_vAt.y = m_vBallPosition.y;
		m_vAt.z = m_vBallPosition.z;
//		m_vFrom.x = m_vAt.x + vBallOffset.x;
//		m_vFrom.y = m_vAt.y + vBallOffset.y;
	}
	static bool bAutoRefine = true;
	if (bAutoRefine)
	{
		// Get rough estimate of when ball is going to hit z=0 plane
		float a = 0.5f * g_vGravity.z;
		float b = m_vBallVelocity.z;
		float c = m_vBallPosition.z;
		// Solve quadratic a t^2 + b t + c = 0
		float q = b*b - 4.0f * a * c;
		if (q < 0.0)
			return 0; // no real solution
		if (b < 0.0) // q = -(1/2)*(b + sgn(b)*sqrt(b^2 - 4ac))
			q = -0.5f * (b - sqrtf(q));
		else
			q = -0.5f * (b + sqrtf(q));
		// Roots are q/a and c/q.
		float t = q / a;
		float t1 = c / q;
		if (t < 0.f || (t1 > 0.f && t1 < t)) // use smaller positive root
			t = t1;
		D3DXVECTOR3 vBallEstimatedHit = m_vBallPosition + t * m_vBallVelocity + 0.5f * t * t * g_vGravity;
		static float fRollTime = 0.2f;
		vBallEstimatedHit.x += fRollTime * m_vBallVelocity.x;
		vBallEstimatedHit.y += fRollTime * m_vBallVelocity.y;
		m_pTerrain->Refine(vBallEstimatedHit, -1.f); // add a refinement below the ball
		// TODO: Instead of making a rough estimate of the final position, compute the whole
		// trajectory now and then play it back at real-speed.	That way, we could adjust the
		// mesh and choose a good camera angle ahead of time.
	}
	m_fLaunchCountDown = 0.f; // stop any other pending launches
	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: MoveBall
// Desc: Called once per frame (if not paused) to update ball position
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::MoveBall()
{
	// Get forces from grass and terrain
	static float fGrassHeight = 0.2f;
	static float fGrassRest = 0.1f; // must be less than fGrassHeight
	static float fGrassSpring = 9.8f / (fGrassHeight - fGrassRest); // cancel gravity when ball is at grass resting point
	D3DXVECTOR3 vBallPosition0 = m_vBallPosition; // save current ball position for update call
	float fTerrainHeight0;
	D3DXVECTOR3 vTerrainNormal0;
	m_pTerrain->GetTerrainPoint(m_vBallPosition, &fTerrainHeight0, &vTerrainNormal0);
	float fDepth = fTerrainHeight0 + fGrassHeight - (m_vBallPosition.z - fBallRadius);	// depth of penetration of bottom of ball
	D3DXVECTOR3 vAcceleration = g_vGravity;
	if (fDepth > 0.f)
	{
		// Apply grass force.  
		// TODO: use correct normal and better friction model that separates
		// normal and tangential components. Add rolling to the model, too.
		if (fDepth > fGrassHeight) fDepth = fGrassHeight; // Terrain collision is modeled below as impulse.
		float fAcceleration = fGrassSpring * fDepth;
		vAcceleration += vTerrainNormal0 * fAcceleration;

		// Dampen velocity
		static D3DXVECTOR3 vGrassDamping(0.9f, 0.9f, 0.8f);
		m_vBallVelocity.x *= vGrassDamping.x;
		m_vBallVelocity.y *= vGrassDamping.y;
		m_vBallVelocity.z *= vGrassDamping.z;
	}
	
	// Update the position of the ball
	float dt = m_fElapsedAppTime;
	float dtThreshold = 1.f/10.f;
	if (dt > dtThreshold) dt = dtThreshold;
	m_vBallPosition += dt * m_vBallVelocity + 0.5f * dt * dt * vAcceleration;
	m_vBallVelocity += dt * vAcceleration;
	
	// Check for collisions with terrain and bounding box
	float fTerrainHeight;
	D3DXVECTOR3 vTerrainNormal; // TODO: use normal to compute new bounce direction
	m_pTerrain->GetTerrainPoint(m_vBallPosition, &fTerrainHeight, &vTerrainNormal);
	float fHeight = fTerrainHeight + fBallRadius;
	if (m_vBallPosition.x < g_vMin.x && m_vBallVelocity.x < 0.f)
		m_vBallVelocity.x = -m_vBallVelocity.x;
	else if (m_vBallPosition.x > g_vMax.x && m_vBallVelocity.x > 0.f)
		m_vBallVelocity.x = -m_vBallVelocity.x;
	if (m_vBallPosition.y < g_vMin.y && m_vBallVelocity.y < 0.f)
		m_vBallVelocity.y = -m_vBallVelocity.y;
	else if (m_vBallPosition.y > g_vMax.y && m_vBallVelocity.y > 0.f)
		m_vBallVelocity.y = -m_vBallVelocity.y;
	if (m_vBallPosition.z < fHeight /*g_vMin.z*/ && m_vBallVelocity.z < 0.f)
	{
		m_vBallPosition.z = fHeight + fGrassRest; // slide ball out of intersection
		m_vBallVelocity.z = -m_vBallVelocity.z; // reverse velocity

		// Dampen velocity
		static D3DXVECTOR3 vTerrainDamping(0.9f, 0.9f, 0.7f);
		m_vBallVelocity.x *= vTerrainDamping.x;
		m_vBallVelocity.y *= vTerrainDamping.y;
		m_vBallVelocity.z *= vTerrainDamping.z;
	}
//	else if (m_vBallPosition.z > g_vMax.z && m_vBallVelocity.z > 0.f)
//		m_vBallVelocity.z = -vBounce.z * m_vBallVelocity.z;

	// Update terrain
	static float fBallRadiusExtra = fBallRadius * 10.f;
	m_pTerrain->BallUpdate(m_fElapsedAppTime, vBallPosition0, m_vBallPosition, fBallRadiusExtra);

	// Adjust camera
	if (!m_bPaused)
	{
		static D3DXVECTOR3 sBallAt(0.2f, 0.2f, 0.04f);	// gradually follow ball with eye, x and y are faster than z
		static D3DXVECTOR3 sBallFrom(0.02f, 0.02f, 0.001f); // gradually move closer to the ball
		static D3DXVECTOR3 vBallOffset(1.f, 1.f, 1.f);	// don't get right on top of the ball
		static float fBallAnticipation = 0.1f;	// prediction time
		if (g_bFollowBall)
		{
			float dt = fBallAnticipation;
			D3DXVECTOR3 vBallPositionNext = m_vBallPosition + dt * m_vBallVelocity + 0.5f * dt * dt * g_vGravity;
			m_vAt.x = m_vAt.x + sBallAt.x * (vBallPositionNext.x - m_vAt.x);
			m_vAt.y = m_vAt.y + sBallAt.y * (vBallPositionNext.y - m_vAt.y);
			m_vAt.z = m_vAt.z + sBallAt.z * (vBallPositionNext.z - m_vAt.z);
			m_vFrom.x = m_vFrom.x + sBallFrom.x * ((vBallPositionNext.x + vBallOffset.x) - m_vFrom.x);
			m_vFrom.y = m_vFrom.y + sBallFrom.y * ((vBallPositionNext.y + vBallOffset.y) - m_vFrom.y);
			//m_vFrom.z = m_vFrom.z + sBallFrom.z * ((vBallPositionNext.z + vBallOffset.z) - m_vFrom.z);
		}
	}

	// Launch a new ball if the ball has stopped moving and there's been a while to
	// look at the effect of the ball on the grass.
	static float fVelocityThreshold = 0.01f;
	static float fCountDownStart = 5.f; // seconds until new ball is launched
	if (m_fLaunchCountDown > 0.f)
	{
		m_fLaunchCountDown -= m_fElapsedAppTime;
		if (m_fLaunchCountDown <= 0.f)
		{
			LaunchBall();	// Launch new ball
			m_fLaunchCountDown = 0.f;
		}
	}
	else if (D3DXVec3LengthSq(&m_vBallVelocity) < fVelocityThreshold)
	{
		m_fLaunchCountDown = fCountDownStart;
	}
	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//		 rendering. This function sets up render states, clears the
//		 viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
	RenderGradientBackground(D3DXCOLOR(0.2f, 0.2f, 0.2f, 1.f), D3DXCOLOR(0.3f, 0.3f, 0.6f, 1.f));
	m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
	m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  FALSE );
	m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, D3DZB_TRUE );
	g_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE, TRUE );

	if (g_bWireFrame)
		g_pd3dDevice->SetRenderState(D3DRS_FILLMODE, D3DFILL_WIREFRAME);
	else
		g_pd3dDevice->SetRenderState(D3DRS_FILLMODE, D3DFILL_SOLID);
	
	// draw the ball
	if (g_bDrawBall)
	{
		g_pd3dDevice->SetVertexShader( m_dwBallVertexShader );
		m_meshBall.Render( g_pd3dDevice, XBMESH_NOTEXTURES | XBMESH_NOFVF );
	}

	// draw the landscape
	m_pTerrain->Begin();
	if (g_bDrawTerrain)
		m_pTerrain->DrawTerrain();
	if (g_bDrawGrass)
		DrawGrass();
	if (g_bDebugDraw)
		m_pTerrain->DrawDebug();
	m_pTerrain->End();

	// show game title or help
	if( g_bDrawHelp )
		m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
	else
	{
		m_Font.Begin();
		m_Font.DrawText(60, 30, 0xffffffff, L"GRASS");
		m_Font.DrawText(600, 30, 0xffffff00, m_strFrameRate, XBFONT_RIGHT);
		m_Font.End();
	}
	
    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\MatrixPaletteSkinning\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\MatrixPaletteSkinning\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Minnaert\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Minnaert\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Minnaert\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Minnaert\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Minnaert\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\MirrorClip\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\MirrorClip\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\MatrixPaletteSkinning\obj\i386\Resource.h ===
// Automatically generated by the bundler tool from Resource.rdf

#define Resource_NUM_RESOURCES 6UL

#define Resource_M0CM0_OFFSET 0UL
#define Resource_M0BM0_OFFSET 20UL
#define Resource_M1CM0_OFFSET 40UL
#define Resource_M1BM0_OFFSET 60UL
#define Resource_M2CM0_OFFSET 80UL
#define Resource_M2BM0_OFFSET 100UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\MirrorClip\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\MatrixPaletteSkinning\Resource.h ===
// Automatically generated by the bundler tool from Resource.rdf

#define Resource_NUM_RESOURCES 6UL

#define Resource_M0CM0_OFFSET 0UL
#define Resource_M0BM0_OFFSET 20UL
#define Resource_M1CM0_OFFSET 40UL
#define Resource_M1BM0_OFFSET 60UL
#define Resource_M2CM0_OFFSET 80UL
#define Resource_M2BM0_OFFSET 100UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Minnaert\Minnaert.cpp ===
//-----------------------------------------------------------------------------
// File: Minnaert.cpp
//
// Desc: Sample to show how to use a 2D texture as a per-pixel lookup table
//       for lighting (the tu and tv coordinates are used to look up a value
//       for the LdotN contribution modulated with the EdotN contribution.)
//       This is a partial solution to a more general form of BRDF lighting,
//       and can be used to implement Minnaert lighting (nice, per-pixel self-
//       shadowing effect), as well as satin, velvet and other effects.
//
// Hist: 04.01.01 - New for May XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <XBMesh.h>
#include <XBUtil.h>




//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_RIGHTSTICK,   XBHELP_PLACEMENT_1, L"Rotate object" },
    { XBHELP_LEFTSTICK,    XBHELP_PLACEMENT_1, L"Move light" },
    { XBHELP_X_BUTTON,     XBHELP_PLACEMENT_2, L"Toggle custom\nlighting" },
    { XBHELP_Y_BUTTON,     XBHELP_PLACEMENT_2, L"Change custom\nlighting effect" },
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_2, L"Display\nhelp" },
};

#define NUM_HELP_CALLOUTS 5




// BRDFVertex
struct BRDFVERTEX
{
    D3DXVECTOR3 p;
    D3DXVECTOR3 n;
    FLOAT       tu, tv;
};

#define D3DFVF_BRDFVERTEX (D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_TEX1 | D3DFVF_TEXCOORDSIZE2(0))

enum LIGHTING_EFFECT { MINNAERT, SATIN, VELVET };

#define MINNAERT_CONSTANT 0.22456f
#define DRESS_MESHSUBSET 7


class CXBWomanMesh : public CXBMesh
{
public:
    BOOL m_bRenderDress;

    BOOL RenderCallback( LPDIRECT3DDEVICE8 pd3dDevice, DWORD dwSubset,
                         XBMESH_SUBSET* pSubset, DWORD dwFlags );
};

BOOL CXBWomanMesh::RenderCallback( LPDIRECT3DDEVICE8 pd3dDevice, DWORD dwSubset,
                                   XBMESH_SUBSET* pSubset, DWORD dwFlags )
{
    if( dwSubset == DRESS_MESHSUBSET )
        return m_bRenderDress;
    else
        return !m_bRenderDress;
}




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Application class. The base class provides just about all the
//       functionality we want, so we're just supplying stubs to interface with
//       the non-C++ functions of the app.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBFont     m_Font;               // Font class
    CXBHelp     m_Help;               // Help class
    BOOL        m_bDrawHelp;          // Whether to draw help

    FLOAT       m_fCameraDistance;    // Camera and matrices
    D3DXVECTOR3 m_vEyePt;
    D3DXVECTOR3 m_vLookatPt;
    D3DXVECTOR3 m_vUp;
    D3DXMATRIX  m_matView;
    D3DXMATRIX  m_matProj;
    
    CXBMesh     m_LightObject;        // The light
    D3DXVECTOR3 m_vLightCenter;
    FLOAT       m_fLightRadius;
    D3DXMATRIX  m_matLightObject;
    D3DXMATRIX  m_matLightMatrix;
    FLOAT       m_fLightYaw;
    FLOAT       m_fLightPitch;
    D3DXVECTOR3 m_LightDir;
    D3DXVECTOR4 m_vVertexShaderLightDir;
    D3DXVECTOR4 m_vPixelShaderLightDir;
        
    CXBWomanMesh            m_WomanObject;   // The woman with the BRDF dress
    D3DXVECTOR3             m_vWomanCenter;
    FLOAT                   m_fWomanRadius;
    DWORD                   m_dwWomanVertexShader;
    DWORD                   m_dwWomanPixelShader1;
    DWORD                   m_dwWomanPixelShader2;
    D3DXMATRIX              m_matWomanObject;
    D3DXMATRIX              m_WomanRotationMatrix;
    D3DXMATRIX              m_matWomanMatrix;
    
    LPDIRECT3DCUBETEXTURE8  m_pNormalizationCubemap; // Textures for the BRDF effect
    LPDIRECT3DTEXTURE8      m_pMinnaertTexture;
    LPDIRECT3DTEXTURE8      m_pSatinTexture;
    LPDIRECT3DTEXTURE8      m_pVelvetTexture;

    BOOL                    m_bUseCustomLighting; // Lighting options
    LIGHTING_EFFECT         m_LightingEffect;

    HRESULT CreateMinnaertMap( DWORD dwWidth, DWORD dwHeight, FLOAT k );
    HRESULT CreateSatinMap( DWORD dwWidth, DWORD dwHeight );
    HRESULT CreateVelvetMap( DWORD dwWidth, DWORD dwHeight );
    HRESULT SetBRDFShaderConstants();

public:
    HRESULT Initialize();
    HRESULT FrameMove();
    HRESULT Render();

    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Application constructor. Sets attributes for the app.
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    // Allow unlimited frame rate
    m_d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;

    // Initialize members
    m_bDrawHelp             = FALSE;

    m_bUseCustomLighting    = TRUE;
    m_LightingEffect        = MINNAERT;

    m_pMinnaertTexture      = NULL;
    m_pSatinTexture         = NULL;
    m_pVelvetTexture        = NULL;

    m_pNormalizationCubemap = NULL;

    m_LightDir.x  =  0.5f;
    m_LightDir.y  = -0.5f;
    m_LightDir.z  =  0.5f;
    D3DXVec3Normalize( &m_LightDir, &m_LightDir );
    m_fLightYaw   = -D3DX_PI/4;
    m_fLightPitch = +D3DX_PI/4;
    D3DXMatrixIdentity( &m_matLightObject );

    D3DXMatrixIdentity( &m_WomanRotationMatrix );
    D3DXMatrixIdentity( &m_matWomanObject );
}




//-----------------------------------------------------------------------------
// Name: CreatePixelShader1()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CreatePixelShader1( LPDIRECT3DDEVICE8 pd3dDevice, DWORD* pdwPixelShader )
{
    D3DPIXELSHADERDEF psd;
    ZeroMemory(&psd, sizeof(psd));

    psd.PSCombinerCount=PS_COMBINERCOUNT(
        3,
        PS_COMBINERCOUNT_MUX_MSB | PS_COMBINERCOUNT_UNIQUE_C0 | PS_COMBINERCOUNT_UNIQUE_C1);
    psd.PSTextureModes=PS_TEXTUREMODES(
        PS_TEXTUREMODES_CUBEMAP,
        PS_TEXTUREMODES_DOTPRODUCT, 
        PS_TEXTUREMODES_DOT_ST, // argb = Texture2D( oT1 dot Cubemap(oT0), oT2 dot Cubemap(oT0) )
        PS_TEXTUREMODES_CUBEMAP);
    psd.PSInputTexture=PS_INPUTTEXTURE(0,0,0,0);
    psd.PSDotMapping=PS_DOTMAPPING(
        0,
        PS_DOTMAPPING_MINUS1_TO_1_D3D,
        PS_DOTMAPPING_MINUS1_TO_1_D3D,
        PS_DOTMAPPING_MINUS1_TO_1_D3D);
    psd.PSCompareMode=PS_COMPAREMODE(
        PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
        PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
        PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
        PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT);

    //------------- Stage 0 -------------
    psd.PSRGBInputs[0]=PS_COMBINERINPUTS(
        PS_REGISTER_C0   | PS_CHANNEL_RGB | PS_INPUTMAPPING_EXPAND_NORMAL,
        PS_REGISTER_T0   | PS_CHANNEL_RGB | PS_INPUTMAPPING_EXPAND_NORMAL,
        PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
    psd.PSAlphaInputs[0]=PS_COMBINERINPUTS(
        PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY);

    psd.PSRGBOutputs[0]=PS_COMBINEROUTPUTS(
        PS_REGISTER_R0,
        PS_REGISTER_DISCARD,
        PS_REGISTER_DISCARD,
        PS_COMBINEROUTPUT_AB_DOT_PRODUCT );
    psd.PSAlphaOutputs[0]=PS_COMBINEROUTPUTS(
        PS_REGISTER_DISCARD,
        PS_REGISTER_DISCARD,
        PS_REGISTER_DISCARD,
        PS_COMBINEROUTPUT_IDENTITY );

    //------------- Stage 1 -------------
    psd.PSRGBInputs[1]=PS_COMBINERINPUTS(
        PS_REGISTER_R0   | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
        PS_REGISTER_T2   | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
    psd.PSAlphaInputs[1]=PS_COMBINERINPUTS(
        PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY);

    psd.PSRGBOutputs[1]=PS_COMBINEROUTPUTS(
        PS_REGISTER_R0,
        PS_REGISTER_DISCARD,
        PS_REGISTER_DISCARD,
        PS_COMBINEROUTPUT_AB_MULTIPLY );
    psd.PSAlphaOutputs[1]=PS_COMBINEROUTPUTS(
        PS_REGISTER_DISCARD,
        PS_REGISTER_DISCARD,
        PS_REGISTER_DISCARD,
        PS_COMBINEROUTPUT_IDENTITY );

    //------------- Stage 2 -------------
    psd.PSRGBInputs[2]=PS_COMBINERINPUTS(
        PS_REGISTER_T2   | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
        PS_REGISTER_V0   | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
    psd.PSAlphaInputs[2]=PS_COMBINERINPUTS(
        PS_REGISTER_V0   | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ONE  | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY);

    psd.PSRGBOutputs[2]=PS_COMBINEROUTPUTS(
        PS_REGISTER_R0,
        PS_REGISTER_DISCARD,
        PS_REGISTER_DISCARD,
        PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
    psd.PSAlphaOutputs[2]=PS_COMBINEROUTPUTS(
        PS_REGISTER_R0,
        PS_REGISTER_DISCARD,
        PS_REGISTER_DISCARD,
        PS_COMBINEROUTPUT_AB_MULTIPLY );

    //------------- Final combiner -------------
    psd.PSFinalCombinerInputsEFG = PS_COMBINERINPUTS( PS_REGISTER_ONE | PS_CHANNEL_RGB,
                                                      PS_REGISTER_ONE | PS_CHANNEL_RGB,
                                                      PS_REGISTER_R0  | PS_CHANNEL_ALPHA,
                                                      0 | 0 | 0 );

    psd.PSFinalCombinerInputsABCD = PS_COMBINERINPUTS( PS_REGISTER_ONE   | PS_CHANNEL_ALPHA,
                                                       PS_REGISTER_R0    | PS_CHANNEL_RGB,
                                                       PS_REGISTER_ZERO  | PS_CHANNEL_RGB,
                                                       PS_REGISTER_ZERO  | PS_CHANNEL_RGB );

    // Create the pixel shader
    if( FAILED( pd3dDevice->CreatePixelShader( &psd, pdwPixelShader ) ) )
        return E_FAIL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CreatePixelShader2()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CreatePixelShader2( LPDIRECT3DDEVICE8 pd3dDevice, DWORD* pdwPixelShader )
{
    D3DPIXELSHADERDEF psd;
    ZeroMemory(&psd, sizeof(psd));

    psd.PSCombinerCount=PS_COMBINERCOUNT(
        1,
        PS_COMBINERCOUNT_MUX_MSB | PS_COMBINERCOUNT_UNIQUE_C0 | PS_COMBINERCOUNT_UNIQUE_C1);
    psd.PSTextureModes=PS_TEXTUREMODES(
        PS_TEXTUREMODES_CUBEMAP,
        PS_TEXTUREMODES_CUBEMAP,
        PS_TEXTUREMODES_CUBEMAP,
        PS_TEXTUREMODES_CUBEMAP);
    psd.PSInputTexture=PS_INPUTTEXTURE(0,0,0,0);
    psd.PSDotMapping=PS_DOTMAPPING(
        0,
        PS_DOTMAPPING_MINUS1_TO_1_D3D,
        PS_DOTMAPPING_MINUS1_TO_1_D3D,
        PS_DOTMAPPING_MINUS1_TO_1_D3D);
    psd.PSCompareMode=PS_COMPAREMODE(
        PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
        PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
        PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
        PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT);

    //------------- Stage 0 -------------
    psd.PSRGBInputs[0]=PS_COMBINERINPUTS(
        PS_REGISTER_T1   | PS_CHANNEL_RGB | PS_INPUTMAPPING_EXPAND_NORMAL,
        PS_REGISTER_T0   | PS_CHANNEL_RGB | PS_INPUTMAPPING_EXPAND_NORMAL,
        PS_REGISTER_ONE  | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
    psd.PSAlphaInputs[0]=PS_COMBINERINPUTS(
        PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY);

    psd.PSRGBOutputs[0]=PS_COMBINEROUTPUTS(
        PS_REGISTER_R0,
        PS_REGISTER_DISCARD,
        PS_REGISTER_DISCARD,
        PS_COMBINEROUTPUT_AB_DOT_PRODUCT );
    psd.PSAlphaOutputs[0]=PS_COMBINEROUTPUTS(
        PS_REGISTER_DISCARD,
        PS_REGISTER_DISCARD,
        PS_REGISTER_DISCARD,
        PS_COMBINEROUTPUT_IDENTITY );

    //------------- Final combiner -------------
    psd.PSFinalCombinerInputsEFG = PS_COMBINERINPUTS( PS_REGISTER_ONE | PS_CHANNEL_RGB,
                                                      PS_REGISTER_ONE | PS_CHANNEL_RGB,
                                                      PS_REGISTER_R0  | PS_CHANNEL_ALPHA,
                                                      0 | 0 | 0 );

    psd.PSFinalCombinerInputsABCD = PS_COMBINERINPUTS( PS_REGISTER_V0    | PS_CHANNEL_RGB,
                                                       PS_REGISTER_R0    | PS_CHANNEL_RGB,
                                                       PS_REGISTER_ZERO  | PS_CHANNEL_RGB,
                                                       PS_REGISTER_ZERO  | PS_CHANNEL_RGB );

    // Create the pixel shader
    if( FAILED( pd3dDevice->CreatePixelShader( &psd, pdwPixelShader ) ) )
        return E_FAIL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CreateMinnaertMap()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::CreateMinnaertMap( DWORD dwWidth, DWORD dwHeight, FLOAT k )
{
    VOID*  pSrcBits = new DWORD[dwWidth*dwHeight];
    DWORD* pBits32  = (DWORD*)pSrcBits;

    for( DWORD y = 0; y < dwHeight; y++ )
    {
        for( DWORD x = 0; x < dwWidth; x++ )
        {
            FLOAT fx = ((FLOAT)x)/(dwWidth-1);
            FLOAT fy = ((FLOAT)y)/(dwHeight-1);

            fx = powf( fx, k );
            fy = powf( fy, 1-k );

            DWORD dwIntensity = (BYTE)(fx*fy* 255.0f);

            *pBits32++ = ( (dwIntensity<<16) | (dwIntensity<<8) | (dwIntensity<<0) );
        }
    }

    m_pd3dDevice->CreateTexture( dwWidth, dwHeight, 1, 0, D3DFMT_X8R8G8B8, 
                                 D3DPOOL_MANAGED, &m_pMinnaertTexture );
    
    D3DLOCKED_RECT lock;
    m_pMinnaertTexture->LockRect( 0, &lock, NULL, 0 );
    XGSwizzleRect( pSrcBits, lock.Pitch, NULL, lock.pBits, dwWidth, dwHeight, NULL, 4 );
    m_pMinnaertTexture->UnlockRect( 0 );

    delete pSrcBits;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CreateSatinMap()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::CreateSatinMap( DWORD dwWidth, DWORD dwHeight )
{
    VOID*  pSrcBits = new DWORD[dwWidth*dwHeight];
    DWORD* pBits32  = (DWORD*)pSrcBits;

    for( DWORD y = 0; y < dwHeight; y++ )
    {
        for( DWORD x = 0; x < dwWidth; x++ )
        {
            // The light (L dot N) value is stored in tu
            FLOAT fLN = ((FLOAT)x)/(dwWidth-1);

            // The eye (E dot N) value is stored in tu
            FLOAT fEN = ((FLOAT)y)/(dwHeight-1);

            // For a satin effect, intensify the falloff around the edges.
            DWORD dwIntensity = (BYTE)( fLN * fEN * fEN * 255.0f);

            *pBits32++ = ( (dwIntensity<<16) | (dwIntensity<<8) | (dwIntensity<<0) );
        }
    }

    m_pd3dDevice->CreateTexture( dwWidth, dwHeight, 1, 0, D3DFMT_X8R8G8B8, 
                                 D3DPOOL_MANAGED, &m_pSatinTexture );
    
    D3DLOCKED_RECT lock;
    m_pSatinTexture->LockRect( 0, &lock, NULL, 0 );
    XGSwizzleRect( pSrcBits, lock.Pitch, NULL, lock.pBits, dwWidth, dwHeight, NULL, 4 );
    m_pSatinTexture->UnlockRect( 0 );

    delete pSrcBits;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CreateVelvetMap()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::CreateVelvetMap( DWORD dwWidth, DWORD dwHeight )
{
    VOID*  pSrcBits = new DWORD[dwWidth*dwHeight];
    DWORD* pBits32  = (DWORD*)pSrcBits;

    for( DWORD y = 0; y < dwHeight; y++ )
    {
        for( DWORD x = 0; x < dwWidth; x++ )
        {
            // The light (L dot N) value is stored in tu
            FLOAT fLN = ((FLOAT)x)/(dwWidth-1);

            // The eye (E dot N) value is stored in tu
            FLOAT fEN = ((FLOAT)y)/(dwHeight-1);

            // For a velvet effect, modulate the light contribution by the
            // inverse of the eye value. This way, only edges get lit.
            DWORD dwIntensity = (BYTE)( (1-fEN)* 255.0f);

            *pBits32++ = ( (dwIntensity<<16) | (dwIntensity<<8) | (dwIntensity<<0) );
        }
    }

    m_pd3dDevice->CreateTexture( dwWidth, dwHeight, 1, 0, D3DFMT_X8R8G8B8, 
                                 D3DPOOL_MANAGED, &m_pVelvetTexture );
    
    D3DLOCKED_RECT lock;
    m_pVelvetTexture->LockRect( 0, &lock, NULL, 0 );
    XGSwizzleRect( pSrcBits, lock.Pitch, NULL, lock.pBits, dwWidth, dwHeight, NULL, 4 );
    m_pVelvetTexture->UnlockRect( 0 );

    delete pSrcBits;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: This creates all device-dependant display objects.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create the font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Load geometry
    if( FAILED( m_LightObject.Create( m_pd3dDevice, "Models\\DirLight.xbg" ) ) )
        return XBAPPERR_MEDIANOTFOUND;
    m_vLightCenter = D3DXVECTOR3( 0, 0, 0 );
    m_fLightRadius = 0.5f;

    if( FAILED( m_WomanObject.Create( m_pd3dDevice, "Models\\Woman.xbg" ) ) )
        return XBAPPERR_MEDIANOTFOUND;
    m_vWomanCenter = D3DXVECTOR3( 0.0f, 0.75f, 0.0f );
    m_fWomanRadius = 1.0f;

    // Create vertex shader for the BRDF
    DWORD dwWomanVertexDecl[] =
    {
        D3DVSD_STREAM( 0 ),
        D3DVSD_REG( 0, D3DVSDT_FLOAT3 ),   // v0 = Position
        D3DVSD_REG( 3, D3DVSDT_FLOAT3 ),   // v0 = Normal
        D3DVSD_REG( 6, D3DVSDT_FLOAT2 ),   // v3 = Texture coords
        D3DVSD_END()
    };

    if( FAILED( XBUtil_CreateVertexShader( m_pd3dDevice, "Shaders\\BRDF.xvu",
                                           dwWomanVertexDecl,
                                           &m_dwWomanVertexShader ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    if( FAILED( CreatePixelShader1( m_pd3dDevice, &m_dwWomanPixelShader1 ) ) )
        return E_FAIL;
    if( FAILED( CreatePixelShader2( m_pd3dDevice, &m_dwWomanPixelShader2 ) ) )
        return E_FAIL;

    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,        TRUE );
    
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_LINEAR );

    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,  D3DBLEND_SRCALPHA );
    m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA );
    
    // Create a normalization cubemap
    if( FAILED( XBUtil_CreateNormalizationCubeMap( m_pd3dDevice, 256, &m_pNormalizationCubemap ) ) )
        return E_FAIL;

    // Set the view matrix, allowing enough room for the objects
    m_fCameraDistance = 3.0f;
    m_vEyePt    = D3DXVECTOR3( 0.0f, 0.0f, -m_fCameraDistance );
    m_vLookatPt = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );
    m_vUp       = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
    D3DXMatrixLookAtLH( &m_matView, &m_vEyePt, &m_vLookatPt, &m_vUp );
    m_pd3dDevice->SetTransform( D3DTS_VIEW,       &m_matView );

    // Set the projection matrix
    D3DXMatrixPerspectiveFovLH( &m_matProj, D3DX_PI/4, 640.0f/480.0f, 
                                m_fCameraDistance/100.0f, m_fCameraDistance*100.0f );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &m_matProj );

    // Create the (NdotL, EdotL) custom lighting maps
    CreateMinnaertMap( 256, 256, MINNAERT_CONSTANT );
    CreateSatinMap( 256, 256 );
    CreateVelvetMap( 256, 256 );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK )
        m_bDrawHelp = !m_bDrawHelp;

    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_X] )
        m_bUseCustomLighting = !m_bUseCustomLighting;

    if( m_bUseCustomLighting )
    {
        if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_Y] )
        {
            switch( m_LightingEffect )
            {
                case MINNAERT: m_LightingEffect = SATIN;    break;
                case SATIN:    m_LightingEffect = VELVET;   break;
                case VELVET:   m_LightingEffect = MINNAERT; break;
            }
        }
    }

    // Update the woman orientation
    {
        FLOAT fRotateX1 = m_fElapsedTime * m_DefaultGamepad.fX2;
        FLOAT fRotateY1 = m_fElapsedTime * m_DefaultGamepad.fY2;
        D3DXMATRIX matRotateWoman;
        D3DXMatrixRotationYawPitchRoll( &matRotateWoman, -fRotateX1, fRotateY1, 0.0f );
        D3DXMatrixMultiply( &m_WomanRotationMatrix, &m_WomanRotationMatrix, &matRotateWoman );

        D3DXMATRIX matTrans;
        D3DXMatrixTranslation( &matTrans, -m_vWomanCenter.x,
                                          -m_vWomanCenter.y,
                                          -m_vWomanCenter.z );

        D3DXMatrixMultiply( &m_matWomanMatrix, &matTrans, &m_WomanRotationMatrix );
    }

    // Update the light orientation
    {
        // Update yaw and pitch from the gamepad
        m_fLightYaw   += m_fElapsedTime * m_DefaultGamepad.fX1;
        m_fLightPitch += m_fElapsedTime * m_DefaultGamepad.fY1;
        m_fLightYaw   = min( +D3DX_PI/4, max( -D3DX_PI/4, m_fLightYaw ) );
        m_fLightPitch = min( +D3DX_PI/4, max( -D3DX_PI/4, m_fLightPitch ) );

        // Transform the light position
        D3DXMATRIX matTrans, matRotateX, matRotateY, matRotateLight;
        D3DXMatrixRotationX( &matRotateX,  m_fLightPitch );
        D3DXMatrixRotationY( &matRotateY, -m_fLightYaw );
        D3DXMatrixMultiply( &matRotateLight, &matRotateY, &matRotateX );
        D3DXMatrixTranslation( &matTrans, 0, 0, -0.4f * m_fCameraDistance );
        D3DXMatrixMultiply( &m_matLightMatrix, &matTrans, &matRotateLight );

        // Transform the light direction
        D3DXVec3TransformNormal( &m_LightDir, &D3DXVECTOR3(0,0,1), &matRotateLight );
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SetBRDFShaderConstants()
// Desc: Sets up vertex shading constants for the BRDF calculations
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::SetBRDFShaderConstants()
{
    // Concat the matrices
    D3DXMATRIX matWorld, matWorldView, matWorldViewProj;
    matWorld = m_matWomanMatrix;
    D3DXMatrixMultiply( &matWorldView,     &matWorld,     &m_matView );
    D3DXMatrixMultiply( &matWorldViewProj, &matWorldView, &m_matProj );

    D3DXMatrixTranspose( &matWorld,         &matWorld );
    D3DXMatrixTranspose( &matWorldView,     &matWorldView );
    D3DXMatrixTranspose( &matWorldViewProj, &matWorldViewProj );

    // Put light in object space
    D3DXMATRIX matLightInverse;
    D3DXMatrixInverse( &matLightInverse, NULL, &m_matWomanMatrix );
    matLightInverse._41 = matLightInverse._42 = matLightInverse._43 = 0.0f;

    D3DXVECTOR3 vLightDir;
    D3DXVec3TransformCoord( &vLightDir, &m_LightDir, &matLightInverse );

    // Set light for vertex shader computations
    m_vVertexShaderLightDir.x = -vLightDir.x;
    m_vVertexShaderLightDir.y = -vLightDir.y;
    m_vVertexShaderLightDir.z = -vLightDir.z;
    m_vVertexShaderLightDir.w = 1.0f;

    // Set light for pixel shader computations. Bias and scale the light vector,
    // because the pixel shader will clamp values to [0,1].
    m_vPixelShaderLightDir.x = 0.5f * ( 1.0f - vLightDir.x );
    m_vPixelShaderLightDir.y = 0.5f * ( 1.0f - vLightDir.y );
    m_vPixelShaderLightDir.z = 0.5f * ( 1.0f - vLightDir.z );
    m_vPixelShaderLightDir.w = 1.0f;

    // Put eye in object space
    D3DXMATRIX matEyeInverse;
    D3DXMatrixInverse( &matEyeInverse, NULL, &m_matWomanMatrix );

    D3DXVECTOR4 vEyePos( 0.0f, 0.0f, 0.0f, 1.0f );
    D3DXVec3TransformCoord( (D3DXVECTOR3*)&vEyePos, &m_vEyePt, &matEyeInverse );

    // Constant 1.0f
    D3DXVECTOR4 v1( 1.0f, 1.0f, 1.0f, 1.0f );

    // Set vertex shader constants
    m_pd3dDevice->SetVertexShaderConstant(  0, &m_vVertexShaderLightDir, 1 );
    m_pd3dDevice->SetVertexShaderConstant(  5, &vEyePos,          1 );
    m_pd3dDevice->SetVertexShaderConstant(  7, &m_WomanObject.GetMesh(0)->m_pSubsets[DRESS_MESHSUBSET].mtrl.Diffuse, 1 );
    m_pd3dDevice->SetVertexShaderConstant(  6, &v1,               1 );
    m_pd3dDevice->SetVertexShaderConstant( 50, &matWorldViewProj, 4 );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Sets up render states, clears the viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Clear the viewport
    m_pd3dDevice->Clear( 0, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL, 
                         0x000000ff, 1.0f, 0L );

    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU,  D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV,  D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_POINT );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_POINT );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_LINEAR );
    
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,          TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  FALSE );

    D3DLIGHT8 light;
    XBUtil_InitLight( light, D3DLIGHT_DIRECTIONAL, m_LightDir.x, m_LightDir.y, m_LightDir.z );
    m_pd3dDevice->SetLight( 0, &light );
    m_pd3dDevice->LightEnable( 0, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING, TRUE );

    // Draw the spotlight using the fixed function pipeline
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &m_matLightMatrix );
    m_pd3dDevice->SetPixelShader( NULL );
    m_LightObject.Render( m_pd3dDevice );

    m_pd3dDevice->SetTransform( D3DTS_WORLD, &m_matWomanMatrix );
    m_pd3dDevice->SetPixelShader( NULL );
    
    // Draw the woman object (everything but the dress)
    m_WomanObject.m_bRenderDress = FALSE;
    m_WomanObject.Render( m_pd3dDevice );

    // Now for the dress, Minnaert light it in second pass
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );
    m_pd3dDevice->SetTextureStageState( 2, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
    m_pd3dDevice->SetTextureStageState( 2, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );
    m_pd3dDevice->SetTextureStageState( 3, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
    m_pd3dDevice->SetTextureStageState( 3, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );

    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_POINT );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_POINT );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_MINFILTER, D3DTEXF_POINT );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_MAGFILTER, D3DTEXF_POINT );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_MIPFILTER, D3DTEXF_NONE );
    m_pd3dDevice->SetTextureStageState( 2, D3DTSS_MINFILTER, D3DTEXF_POINT );
    m_pd3dDevice->SetTextureStageState( 2, D3DTSS_MAGFILTER, D3DTEXF_POINT );
    m_pd3dDevice->SetTextureStageState( 2, D3DTSS_MIPFILTER, D3DTEXF_NONE );

    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,         D3DBLEND_SRCALPHA );
    m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND,        D3DBLEND_INVSRCALPHA );

    SetBRDFShaderConstants();
    m_pd3dDevice->SetVertexShader( m_dwWomanVertexShader );
    
    if( m_bUseCustomLighting )
    {
        m_pd3dDevice->SetPixelShader( m_dwWomanPixelShader1 );
        
        m_pd3dDevice->SetTexture( 0, m_pNormalizationCubemap );
        m_pd3dDevice->SetTexture( 1, m_pNormalizationCubemap );
        m_pd3dDevice->SetTexture( 3, m_pNormalizationCubemap );

        switch( m_LightingEffect )
        {
            case MINNAERT: m_pd3dDevice->SetTexture( 2, m_pMinnaertTexture ); break;
            case SATIN:    m_pd3dDevice->SetTexture( 2, m_pSatinTexture );    break;
            case VELVET:   m_pd3dDevice->SetTexture( 2, m_pVelvetTexture );   break;
        }
    }
    else
    {
        m_pd3dDevice->SetPixelShader( m_dwWomanPixelShader2 );

        m_pd3dDevice->SetTexture( 0, m_pNormalizationCubemap );
        m_pd3dDevice->SetTexture( 1, m_pNormalizationCubemap );
        m_pd3dDevice->SetTexture( 2, m_pNormalizationCubemap );
        m_pd3dDevice->SetTexture( 3, m_pNormalizationCubemap );
    }

    // Pass the light direction to the pixel shader (via constant 0)
    m_pd3dDevice->SetPixelShaderConstant( 0, &m_vPixelShaderLightDir, 1 );
    
    // Draw the woman's dress
    m_WomanObject.m_bRenderDress = TRUE;
    m_WomanObject.Render( m_pd3dDevice, XBMESH_NOFVF|XBMESH_NOTEXTURES );

    // Reset states
    m_pd3dDevice->SetPixelShader( NULL );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP );

    // Show the custom lighting texture
    if( m_bUseCustomLighting )
    {
        struct SCREENVERTEX { D3DXVECTOR4 p; FLOAT tu, tv; };
        SCREENVERTEX v[4];
        v[0].p = D3DXVECTOR4(  0+64 - 0.5f,  0+100 - 0.5f, 1.0f, 1.0f );  v[0].tu = 0.0f; v[0].tv = 0.0f; 
        v[1].p = D3DXVECTOR4( 64+64 - 0.5f,  0+100 - 0.5f, 1.0f, 1.0f );  v[1].tu = 1.0f; v[1].tv = 0.0f; 
        v[2].p = D3DXVECTOR4(  0+64 - 0.5f, 64+100 - 0.5f, 1.0f, 1.0f );  v[2].tu = 0.0f; v[2].tv = 1.0f; 
        v[3].p = D3DXVECTOR4( 64+64 - 0.5f, 64+100 - 0.5f, 1.0f, 1.0f );  v[3].tu = 1.0f; v[3].tv = 1.0f; 

        switch( m_LightingEffect )
        {
            case MINNAERT: m_pd3dDevice->SetTexture( 0, m_pMinnaertTexture ); break;
            case SATIN:    m_pd3dDevice->SetTexture( 0, m_pSatinTexture );    break;
            case VELVET:   m_pd3dDevice->SetTexture( 0, m_pVelvetTexture );   break;
        }

        // Render the texture
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
        m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, FALSE ); 
        m_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_TEX1 );
        m_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, v, sizeof(v[0]) );
    }

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        m_Font.DrawText(  64, 50, 0xffffff00, L"Minnaert" );
        m_Font.DrawText( 450, 50, 0xffffffff, m_strFrameRate );
    
        if( m_bUseCustomLighting )
        {
            switch( m_LightingEffect )
            {
                case MINNAERT: m_Font.DrawText(  64, 75, 0xffffffff, L"Minnaert lighting" ); break;
                case SATIN:    m_Font.DrawText(  64, 75, 0xffffffff, L"Satin lighting" );    break;
                case VELVET:   m_Font.DrawText(  64, 75, 0xffffffff, L"Velvet lighting" );   break;
            }
        }
        else
            m_Font.DrawText(  64, 75, 0xffffffff, L"Normal lighting" );
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\MirrorClip\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\MatrixPaletteSkinning\MatrixPaletteSkinning.cpp ===
//-----------------------------------------------------------------------------
// File: MatrixPaletteSkinning.cpp
//
// Desc: This sample demonstrates how to perform matrix palette skinning on
//       the Xbox, using vertex shaders
//
// Hist: 11.9.01 - New for December XDK
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <XBMesh.h>
#include <xgraphics.h>

//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_1, L"Display help" },
    { XBHELP_START_BUTTON, XBHELP_PLACEMENT_1, L"Pause" },
    { XBHELP_LEFTSTICK,    XBHELP_PLACEMENT_1, L"Rotate camera" },
    { XBHELP_RIGHTSTICK,   XBHELP_PLACEMENT_1, L"Zoom in/out" },
    { XBHELP_DPAD,         XBHELP_PLACEMENT_2, L"Add/remove\nbones" },
    { XBHELP_A_BUTTON,     XBHELP_PLACEMENT_2, L"Next\nAnimation" },
};

#define NUM_HELP_CALLOUTS ( sizeof( g_HelpCallouts ) / sizeof( g_HelpCallouts[0] ) )



// The following header file is generated from "Resource.rdf" file using the
// Bundler tool. In addition to the header, the tool outputs a binary file
// (Resource.xpr) which contains compiled (i.e. bundled) resources and is
// loaded at runtime using the CXBPackedResource class.
#include "Resource.h"



//-----------------------------------------------------------------------------
// Map from ASCII names for the resources used by the app to offsets.
//-----------------------------------------------------------------------------
XBRESOURCE g_ResourceNames[] = 
{
    { "M0CM0.BMP", Resource_M0CM0_OFFSET },
    { "M1CM0.BMP", Resource_M1CM0_OFFSET },
    { "M2CM0.BMP", Resource_M2CM0_OFFSET },
    { NULL, 0 },
};



//-----------------------------------------------------------------------------
// Constants for how many bones and what constants register they use.
//-----------------------------------------------------------------------------
const int MIN_BONES = 5;
const int MAX_BONES = 30;
const int BONE_REGISTER_BASE = 5;

typedef enum
{
    ANIMATE_SINE = 0,
    ANIMATE_CIRCLE,
    ANIMATE_MAX,
} ANIMATE_MODE;



//-----------------------------------------------------------------------------
// Structure for per-vertex bone information.
//-----------------------------------------------------------------------------
#pragma pack(push,1)
struct BoneIndicesAndWeights
{
    short Indices[3];   // Index of the constant registers holding the bone matrix.
    float Weights[3];   // Weight for the corresponding bone matrix.
};
#pragma pack(pop)



//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
public:
    CXBoxSample();

    virtual HRESULT Initialize();
    virtual HRESULT Render();
    virtual HRESULT FrameMove();

    void    SetupBones( XBMESH_DATA& MeshData );        // Sets up the bones
    HRESULT CreateMeshWeights( XBMESH_DATA& MeshData ); // Sets up weights
    void    UpdateBoneTransforms();                     // Animates bones

    CXBFont     m_Font;             // Font object
    CXBHelp     m_Help;             // Help object
    BOOL        m_bDrawHelp;        // TRUE to draw help screen

    // Information for each bone.
    INT                     m_iNumberOfBones;
    float                   m_fBoneInfluenceRadius;
    D3DXVECTOR3             m_vBoneCenter[MAX_BONES];
    D3DXMATRIX              m_matBoneTransforms[MAX_BONES];

    CXBPackedResource       m_xprResource;      // Snake Textures
    CXBMesh                 m_Snake;            // Snake model
    DWORD                   m_dwDeformShader;   // Vertex Shader handle
    ANIMATE_MODE            m_Mode;             // Animation mode

    D3DXVECTOR3             m_vViewAngle;       // View angle
    D3DXVECTOR3             m_vCameraPos;       // Camera position

    LPDIRECT3DVERTEXBUFFER8 m_pBoneVB;          // Vertex buffer w/ bones
    LPDIRECT3DVERTEXBUFFER8 m_pBasisVB;         // Vertex buffer w/ basis vectors

};



//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}



//-----------------------------------------------------------------------------
// Name: CXBoxSample (constructor)
// Desc: Constructor for CXBoxSample class
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample() 
            :CXBApplication()
{
    m_bDrawHelp = FALSE;
    m_iNumberOfBones = 20;
}



//-----------------------------------------------------------------------------
// Name: Initialize
// Desc: Peforms initialization
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the resources
    if( FAILED( m_xprResource.Create( m_pd3dDevice, "Resource.xpr", 
                                      Resource_NUM_RESOURCES, g_ResourceNames ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Load the snake.
    if( FAILED( m_Snake.Create( m_pd3dDevice, "Models\\Snake.xbg", &m_xprResource ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create vertex shader.
    DWORD vdecl[] =
    {
        D3DVSD_STREAM(0),
        D3DVSD_REG(0, D3DVSDT_FLOAT3),  // v0 = XYZ
        D3DVSD_REG(1, D3DVSDT_FLOAT3),  // v1 = normals
        D3DVSD_REG(2, D3DVSDT_FLOAT2),  // v2 = textures

        D3DVSD_STREAM(1),
        D3DVSD_REG(3, D3DVSDT_SHORT3),  // Bone matrix indices
        D3DVSD_REG(4, D3DVSDT_FLOAT3),  // Bone weights
        
        D3DVSD_END()
    };

    if ( FAILED( XBUtil_CreateVertexShader( m_pd3dDevice, "Shaders\\MatrixPaletteSkinning.xvu", vdecl, &m_dwDeformShader ) ) )
        return E_FAIL;

    // Setup bones.
    SetupBones( m_Snake.m_pMeshFrames[0].m_MeshData );

    // Create mesh weights.
    CreateMeshWeights( m_Snake.m_pMeshFrames[0].m_MeshData );

    m_Mode       = ANIMATE_SINE;

    m_vCameraPos = D3DXVECTOR3( 0.0f, 0.0f, 3.0f );
    m_vViewAngle = D3DXVECTOR3( -0.5f, 3.0f, 0.0f );

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: SetupBones
// Desc: Define the positon and influence ofthe bones.
//-----------------------------------------------------------------------------
void CXBoxSample::SetupBones( XBMESH_DATA& MeshData )
{
    // Get the bounding box of the mesh.
    D3DXVECTOR3 vMin, vMax;
    D3DXMATRIX matIdentity;
    D3DXMatrixIdentity( &matIdentity );
    m_Snake.ComputeMeshBoundingBox( &MeshData, &matIdentity, &vMin, &vMax );

    // Space bones evenly along z, going through the middle of the snake
    float x = ( vMin.x + vMax.x ) * 0.5f;
    float y = ( vMin.y + vMax.y ) * 0.5f;
    float z_step = ( vMax.z - vMin.z ) / m_iNumberOfBones;
    float z = vMin.z + 0.5f * z_step;

    for( int i = 0; i < m_iNumberOfBones; i++ )
    {
        m_vBoneCenter[i].x = x;
        m_vBoneCenter[i].y = y;
        m_vBoneCenter[i].z = z;

        D3DXMatrixIdentity( &m_matBoneTransforms[i] );

        z += z_step;
    }

    // The z distance that the bone influences.
    m_fBoneInfluenceRadius = z_step * 1.0f;
}



//-----------------------------------------------------------------------------
// Name: CreateMeshWeights
// Desc: Create a vertex buffer to hold the bone matrix indices and the 
//       weights.  We'll walk the list of bones, and determine which vertices
//       each bone influences (we'll only keep the top 3)
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::CreateMeshWeights( XBMESH_DATA& MeshData )
{
    // Create a vertex buffer to hold the indices and weights ..
    m_pd3dDevice->CreateVertexBuffer( MeshData.m_dwNumVertices * sizeof( BoneIndicesAndWeights ),
                                    0, 0, 0, &m_pBoneVB );

    // .. and lock it so we can fill it in.
    BoneIndicesAndWeights* pVertexIndicesAndWeights;
    m_pBoneVB->Lock( 0, 0, (BYTE**)&pVertexIndicesAndWeights, 0 );

    // Initialize indices and weights.
    for( DWORD v = 0; v < MeshData.m_dwNumVertices; v++ )
    {
        for ( int j = 0; j < 3; j++ )
        {
            pVertexIndicesAndWeights[v].Indices[j] = 0;
            pVertexIndicesAndWeights[v].Weights[j] = 0.0f;
        }
    }

    BYTE* pVertices;
    MeshData.m_VB.Lock( 0, 0, &pVertices, 0 );

    // Evenly space bones long z.
    for( int i = 0; i < m_iNumberOfBones; i++ )
    {
        float z = m_vBoneCenter[i].z;

        // Caclulate influence of bones on each vertex.
        for( DWORD v = 0; v < MeshData.m_dwNumVertices; v++ )
        {
            D3DXVECTOR3* pVert = (D3DXVECTOR3*)( pVertices + v * MeshData.m_dwVertexSize );

            float weight = 1.0f - fabsf( pVert->z - z ) / m_fBoneInfluenceRadius;
            
            // Weight = min( 1 - distance / radius, 0 ).
            if( weight > 0.0f )
            {
                // Keep only the nearest 3.
                float min_weight = weight;
                int min_j = -1;

                for( int j = 0; j < 3; j++ )
                {
                    if( pVertexIndicesAndWeights[v].Weights[j] < min_weight )
                    {
                        min_weight = pVertexIndicesAndWeights[v].Weights[j];
                        min_j = j;
                    }
                }

                if( min_j != -1 )
                {
                    pVertexIndicesAndWeights[v].Indices[min_j] = BONE_REGISTER_BASE + i * 3;
                    pVertexIndicesAndWeights[v].Weights[min_j] = weight;
                }
            }   
        }
    }

    MeshData.m_VB.Unlock();

    // Normalize weights.
    for( DWORD v = 0; v < MeshData.m_dwNumVertices; v++ )
    {
        float total_weight = 0.0f;

        for( int j = 0; j < 3; j++ )
        {
            total_weight += pVertexIndicesAndWeights[v].Weights[j];
        }

        if( total_weight > 0.0f )
        {
            float inv_total_weight = 1.0f / total_weight;

            for( int j = 0; j < 3; j++ )
            {
                pVertexIndicesAndWeights[v].Weights[j] *= inv_total_weight;
            }
        }
    }

    m_pBoneVB->Unlock();

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: UpdateBoneTransforms
// Desc: Offset the bones using a time based sine fuction.
//-----------------------------------------------------------------------------
void CXBoxSample::UpdateBoneTransforms()
{
    switch( m_Mode )
    {
    case ANIMATE_SINE:
        // Update transform for each bone.
        for( int i = 0; i < m_iNumberOfBones; i++ )
        {
            D3DXMATRIX mat;

            // x = f(z+t) = sin(z+t) * 0.2
            // tangent = f'(z+t) = cos(z+t) * 0.2

            float t = 10.0f * i / m_iNumberOfBones - m_fAppTime * 2.0f;
            float angle = atanf( cosf( t ) * 0.2f );
            
            // Translate the bone back to the origin
            D3DXMatrixTranslation( &m_matBoneTransforms[i], -m_vBoneCenter[i].x,
                                   -m_vBoneCenter[i].y, -m_vBoneCenter[i].z );

            // Rotate to the tangent angle
            D3DXMatrixRotationY( &mat, angle );
            D3DXMatrixMultiply( &m_matBoneTransforms[i], &m_matBoneTransforms[i], &mat );

            // Then translate back to bone position + sine wave
            D3DXMatrixTranslation( &mat, m_vBoneCenter[i].x + sinf( t ) * 0.2f, 
                                   m_vBoneCenter[i].y, m_vBoneCenter[i].z );
            D3DXMatrixMultiply( &m_matBoneTransforms[i], &m_matBoneTransforms[i], &mat );
        }
        break;

    case ANIMATE_CIRCLE:
        for( int i = 0; i < m_iNumberOfBones; i++ )
        {
            D3DXMATRIX mat;

            // x = cos( z + time )
            // z = -sin( z + time )
            // tan = z + time

            float t = -5.0f * i / m_iNumberOfBones + m_fAppTime;
            float angle = t;

            // Translate to origin
            D3DXMatrixTranslation( &m_matBoneTransforms[i], 
                                   -m_vBoneCenter[i].x,
                                   -m_vBoneCenter[i].y,
                                   -m_vBoneCenter[i].z );

            // Rotate bone
            D3DXMatrixRotationY( &mat, angle );
            D3DXMatrixMultiply( &m_matBoneTransforms[i], &m_matBoneTransforms[i], &mat );

            // Translate to position on unit circle
            D3DXMatrixTranslation( &mat, 
                                   cosf( t ),
                                   m_vBoneCenter[i].y,
                                   -sinf( t ) );
            D3DXMatrixMultiply( &m_matBoneTransforms[i], &m_matBoneTransforms[i], &mat );
        }
        break;
    }

    D3DXMATRIX mat;

    // Send bone transforms to the vertex shader.
    for( int i = 0; i < m_iNumberOfBones; i++ )
    {
        D3DXMatrixTranspose( &mat, &m_matBoneTransforms[i] );
        m_pd3dDevice->SetVertexShaderConstant( BONE_REGISTER_BASE + i * 3, &mat, 3 );
    }
}



//-----------------------------------------------------------------------------
// Name: FrameMove
// Desc: Performs per-frame updates
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK ) 
    {
        m_bDrawHelp = !m_bDrawHelp;
    }

    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_A ] )
    {
        m_Mode = ANIMATE_MODE( ( m_Mode + 1 ) % ANIMATE_MAX );
    }

    // Set the matrices
    D3DXMATRIX matWorld;
    D3DXMatrixIdentity( &matWorld );
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld );

    // Update camera angle and position
    m_vViewAngle.y -= m_DefaultGamepad.fX1 * m_fElapsedTime;
    if( m_vViewAngle.y > 2 * D3DX_PI )
        m_vViewAngle.y -= 2 * D3DX_PI;
    else if( m_vViewAngle.y < 0.0f )
        m_vViewAngle.y += 2 * D3DX_PI;

    m_vViewAngle.x -= m_DefaultGamepad.fY1 * m_fElapsedTime;
    if( m_vViewAngle.x > 1.0f )
        m_vViewAngle.x = 1.0f;
    else if( m_vViewAngle.x < -1.0f )
        m_vViewAngle.x = -1.0f;

    m_vCameraPos.z -= m_DefaultGamepad.fY2 * m_fElapsedTime;
    if( m_vCameraPos.z < 0.2f )
        m_vCameraPos.z = 0.2f;

    // Calculate eye position based off view angle and camera zoom
    D3DXVECTOR3 vEyePosition;
    D3DXMATRIX m;
    D3DXMatrixRotationYawPitchRoll( &m, m_vViewAngle.y, m_vViewAngle.x, m_vViewAngle.z );
    D3DXVec3TransformCoord( &vEyePosition, &m_vCameraPos, &m );

    // Set up a view transform to look at the origin
    D3DXMATRIX  matView;
    D3DXVECTOR3 vLookAt( 0.0f, 0.0f, 0.0f );
    D3DXVECTOR3 vUp( 0.0f, 1.0f, 0.0f );
    D3DXMatrixLookAtLH( &matView, &vEyePosition, &vLookAt, &vUp );
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );

    // Projection transform
    D3DXMATRIX matProjection;
    D3DXMatrixPerspectiveFovLH( &matProjection, D3DX_PI/4, 4.0f/3.0f, 0.1f, 500.0f );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProjection );

    // World * View * Projection composite transformation
    D3DXMATRIX matComposite;
    D3DXMatrixMultiply( &matComposite, &matWorld, &matView );
    D3DXMatrixMultiply( &matComposite, &matComposite, &matProjection );
    D3DXMatrixTranspose( &matComposite, &matComposite );
    m_pd3dDevice->SetVertexShaderConstant( 0, &matComposite, 4 );

    // Adjust number of bones
    int iOldBones = m_iNumberOfBones;
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_UP )
    {
        if( ++m_iNumberOfBones > MAX_BONES )
            m_iNumberOfBones = MAX_BONES;
    }
    else if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_DOWN )
    {
        if( --m_iNumberOfBones < MIN_BONES )
            m_iNumberOfBones = MIN_BONES;
    }

    if( iOldBones != m_iNumberOfBones )
    {
        // Setup bones.
        SetupBones( m_Snake.m_pMeshFrames[0].m_MeshData );

        // Create mesh weights.
        CreateMeshWeights( m_Snake.m_pMeshFrames[0].m_MeshData );
    }

    // Animate bones based off current time
    UpdateBoneTransforms();

    // Set light direction
    D3DXVECTOR4 vLightDir( 0.7071067f, 0.7071067f, 0.0f, 0.0f );
    m_pd3dDevice->SetVertexShaderConstant( 4, &vLightDir, 1 );

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: Render
// Desc: Renders the scene
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Clear the zbuffer
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,
                         0x00000000, 1.0f, 0L );

    // Draw a gradient filled background
    RenderGradientBackground( 0xff404040, 0xff404080 );

    // Draw the snake.
    m_pd3dDevice->SetVertexShader( m_dwDeformShader );
    m_pd3dDevice->SetStreamSource( 1, m_pBoneVB, sizeof( BoneIndicesAndWeights ) );

    // Set up render and texture states
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU,  D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV,  D3DTADDRESS_WRAP );

    m_Snake.Render( m_pd3dDevice, XBMESH_NOFVF | XBMESH_NOMATERIALS );

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        m_Font.Begin();
        m_Font.DrawText(  64, 50, 0xffffffff, L"MatrixPaletteSkinning" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );

        WCHAR str[100];
        swprintf( str, L"Number of bones: %d", m_iNumberOfBones );
        m_Font.DrawText( 64, 80, 0xffffff00, str );
        m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\MirrorClip\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\ModifyPixelShader\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\ModifyPixelShader\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\ModifyPixelShader\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\MirrorClip\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 6UL

#define resource_Ceiling_OFFSET 0UL
#define resource_Floor_OFFSET 20UL
#define resource_EastWall_OFFSET 40UL
#define resource_WestWall_OFFSET 60UL
#define resource_NorthWall_OFFSET 80UL
#define resource_SouthWall_OFFSET 100UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\ModifyPixelShader\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\ModifyPixelShader\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\motionblur\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\MirrorClip\obj\i386\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 6UL

#define resource_Ceiling_OFFSET 0UL
#define resource_Floor_OFFSET 20UL
#define resource_EastWall_OFFSET 40UL
#define resource_WestWall_OFFSET 60UL
#define resource_NorthWall_OFFSET 80UL
#define resource_SouthWall_OFFSET 100UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\MirrorClip\MirrorClip.cpp ===
//-----------------------------------------------------------------------------
// File: MirrorClip.cpp
//
// Desc: Example code showing how to clip to a mirror plane on XBox.
//
// Hist: 02.21.00 - New for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <XBMesh.h>
#include <XBResource.h>
#include <XBUtil.h>

// The following header file is generated from "Resource.rdf" file using the
// Bundler tool. In addition to the header, the tool outputs a binary file
// (Resource.xpr) which contains compiled (i.e. bundled) resources and is
// loaded at runtime using the CXBPackedResource class.
#include "Resource.h"




//-----------------------------------------------------------------------------
// ASCII names for the resources used by the app
//-----------------------------------------------------------------------------
XBRESOURCE g_ResourceNames[] = 
{
    { "Floor.bmp",     resource_Floor_OFFSET },
    { "Ceiling.bmp",   resource_Ceiling_OFFSET },
    { "WestWall.bmp",  resource_WestWall_OFFSET },
    { "EastWall.bmp",  resource_EastWall_OFFSET },
    { "NorthWall.bmp", resource_NorthWall_OFFSET },
    { "SouthWall.bmp", resource_SouthWall_OFFSET },
    { NULL, 0 },
};




//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_LEFTSTICK,   XBHELP_PLACEMENT_1, L"Move camera" },
    { XBHELP_X_BUTTON,    XBHELP_PLACEMENT_1, L"Toggle Clipping" },
    { XBHELP_BACK_BUTTON, XBHELP_PLACEMENT_1, L"Display help" },
};

#define NUM_HELP_CALLOUTS (sizeof(g_HelpCallouts)/sizeof(g_HelpCallouts[0]))




//-----------------------------------------------------------------------------
// Custom vertex types
//-----------------------------------------------------------------------------
struct MIRRORVERT
{
    D3DVECTOR Pos;
    D3DCOLOR  Color;
};


MIRRORVERT g_MirrorVerts[] =
{
    { { 0.0f, -0.5f, -0.1f }, D3DCOLOR_ARGB(60, 0, 0, 255) },
    { { 0.0f,  0.5f, -0.1f }, D3DCOLOR_ARGB(60, 0, 0, 255) },
    { { 0.0f, -0.5f,  2.0f }, D3DCOLOR_ARGB(60, 0, 0, 255) },
    { { 0.0f,  0.5f,  2.0f }, D3DCOLOR_ARGB(60, 0, 0, 255) },
};




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBPackedResource  m_xprResource;        // Packed resources for the app
    CXBFont            m_Font;               // Font class
    CXBHelp            m_Help;               // Help class
    BOOL               m_bDrawHelp;          // Whether to draw help

    CXBMesh            m_Room;               // XBG file object to render

    bool               m_bUseClipPlane;

    D3DXVECTOR3        m_vEye;

    HRESULT RenderScene();
    HRESULT RenderMirror();

public:
    HRESULT Initialize();
    HRESULT Render();
    HRESULT FrameMove();

    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    m_bDrawHelp     = false;
    m_bUseClipPlane = false;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create the font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the resources
    if( FAILED( m_xprResource.Create( m_pd3dDevice, "Resource.xpr", 
                                      resource_NUM_RESOURCES, g_ResourceNames ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Load the main file object
    if( FAILED( m_Room.Create( m_pd3dDevice, "Models\\Room.xbg", &m_xprResource ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Set the matrices
    D3DXMATRIX matWorld, matView, matProj;

    D3DXMatrixIdentity( &matWorld );
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld );

    m_vEye = D3DXVECTOR3( 2.0f, 0.0f, 1.0f );
    D3DXVECTOR3 vAt( 0.0f, 0.0f, 1.0f );
    D3DXVECTOR3 vUp( 0.0f, 0.0f, 1.0f );

    D3DXMatrixLookAtLH( &matView, &m_vEye, &vAt, &vUp );
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );

    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/3, 4.0f/3.0f, 0.1f, 100.0f );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    D3DXMATRIX matView, matRotate;

    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK )
        m_bDrawHelp = !m_bDrawHelp;

    // Toggle clipping plane.
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_X] )
        m_bUseClipPlane = !m_bUseClipPlane;

    D3DXVECTOR3 vAt( 0.0f, 0.0f, 1.0f );
    D3DXVECTOR3 vUp( 0.0f, 0.0f, 1.0f );

    // Rotate eye around z axis.
    D3DXMatrixRotationAxis( &matRotate, &D3DXVECTOR3(0.0f,0.0f,1.0f), 
                                        m_DefaultGamepad.fX1*m_fElapsedTime );
    D3DXVec3TransformCoord( &m_vEye, &m_vEye, &matRotate );

    // Rotate eye points around side axis.
    D3DXVECTOR3 vView = (m_vEye - vAt);
    D3DXVec3Normalize( &vView, &vView );

    // Place limits so we dont go over the top or under the bottom.
    FLOAT dot = D3DXVec3Dot( &vView, &vUp );
    if( (dot > 0.0f || m_DefaultGamepad.fY1 < 0.0f) && (dot < 0.99f || m_DefaultGamepad.fY1 > 0.0f) )
    {
        D3DXVECTOR3 axis;
        D3DXVec3Cross( &axis, &vUp, &vView );
        D3DXMatrixRotationAxis( &matRotate, &axis, m_DefaultGamepad.fY1*m_fElapsedTime );
        D3DXVec3TransformCoord( &m_vEye, &m_vEye, &matRotate );
    }

    D3DXMatrixLookAtLH( &matView, &m_vEye, &vAt, &vUp );

    m_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: RenderMirror()
// Desc:
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::RenderMirror()
{
    // Turn on stencil writes.
    m_pd3dDevice->SetRenderState( D3DRS_STENCILENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_STENCILFUNC, D3DCMP_ALWAYS );
    m_pd3dDevice->SetRenderState( D3DRS_STENCILREF, 0x1 );
    m_pd3dDevice->SetRenderState( D3DRS_STENCILMASK, 0xffffffff );
    m_pd3dDevice->SetRenderState( D3DRS_STENCILWRITEMASK, 0xffffffff );
    m_pd3dDevice->SetRenderState( D3DRS_STENCILZFAIL, D3DSTENCILOP_KEEP );
    m_pd3dDevice->SetRenderState( D3DRS_STENCILFAIL, D3DSTENCILOP_KEEP );
    m_pd3dDevice->SetRenderState( D3DRS_STENCILPASS, D3DSTENCILOP_REPLACE );

    // Disable writing to the z and color buffers.
    m_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_COLORWRITEENABLE, 0 );

    // Draw the mirror into the stencil buffer
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING, FALSE );
    m_pd3dDevice->SetTexture( 0, NULL );
    m_pd3dDevice->SetVertexShader( D3DFVF_XYZ | D3DFVF_DIFFUSE );

    m_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, g_MirrorVerts, 
                                   sizeof(MIRRORVERT) );

    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING, TRUE );

    // Save the view and projection matrix.
    D3DXMATRIX matViewSaved, matProjectionSaved;
    m_pd3dDevice->GetTransform( D3DTS_VIEW, &matViewSaved );
    m_pd3dDevice->GetTransform( D3DTS_PROJECTION, &matProjectionSaved );

    if( m_bUseClipPlane )
    {
        // Build the reflection transform.
        D3DXMATRIX matView, matReflect;

        // Reflector in world space.
        D3DXVECTOR3 point(0.0f,0.0f,0.0f);
        D3DXVECTOR3 normal(-1.0f,0.0f,0.0f);
        D3DXPLANE   plane;

        // Move mirror point and normal into eye space.
        D3DXVec3TransformCoord(&point, &point, &matViewSaved);
        D3DXVec3TransformNormal(&normal, &normal, &matViewSaved);

        // Compute mirror plane.
        D3DXPlaneFromPointNormal( &plane, &point, &normal );

        D3DXMatrixReflect( &matReflect, &plane );

        D3DXMatrixMultiply( &matView, &matViewSaved, &matReflect );

        m_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );
    }
    else
    {
        // Build the reflection transform.
        D3DXMATRIX matView, matReflect;

        // Reflector in world space.
        D3DXVECTOR3 point(0.0f,0.0f,0.0f);
        D3DXVECTOR3 normal(-1.0f,0.0f,0.0f);
        D3DXPLANE plane;

        // Move mirror point and normal into eye space.
        D3DXVec3TransformCoord(&point, &point, &matViewSaved);
        D3DXVec3TransformNormal(&normal, &normal, &matViewSaved);

        // Compute mirror plane.
        D3DXPlaneFromPointNormal( &plane, &point, &normal );

        D3DXMatrixReflect( &matReflect, &plane );
        D3DXMatrixMultiply( &matView, &matViewSaved, &matReflect );

        m_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );

        //
        // Adjust the projection matrix so that the near clip plane is aligned
        // with the mirror plane.
        //
        float zn = -plane.d / plane.c;
        float zf = 100.0f;

        D3DXMATRIX matProjection;

        matProjection._11 = matProjectionSaved._11;
        matProjection._21 = 0.0f;
        matProjection._31 = 0.0f;
        matProjection._41 = 0.0f;

        matProjection._12 = 0.0f;
        matProjection._22 = matProjectionSaved._22;
        matProjection._32 = 0.0f;
        matProjection._42 = 0.0f;

        // z's dependance on x and y.
        float nxnz = normal.x / normal.z;
        float nynz = normal.y / normal.z;

        // Maximum z contributed by x and y at farclip.
        float maxxz = zf * fabsf(nxnz) * (1.0f / matProjection._11);
        float maxyz = zf * fabsf(nynz) * (1.0f / matProjection._22);

        // Scale factor for the z range.
        float zscale = zf / (zf + maxxz + maxyz - zn);

        matProjection._13 = nxnz * zscale;
        matProjection._23 = nynz * zscale;
        matProjection._33 = zscale;
        matProjection._43 = -zn * zscale;

        matProjection._14 = 0.0f;
        matProjection._24 = 0.0f;
        matProjection._34 = 1.0f;
        matProjection._44 = 0.0f;

        m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProjection );
    }

    // Setup render states to a blended render scene against mask in stencil
    // buffer. An important step here is to reverse the cull-order of the
    // polygons, since the view matrix is being relected.
    m_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE, TRUE );

    m_pd3dDevice->SetRenderState( D3DRS_COLORWRITEENABLE, D3DCOLORWRITEENABLE_ALPHA | 
                                                          D3DCOLORWRITEENABLE_BLUE |
                                                          D3DCOLORWRITEENABLE_GREEN |
                                                          D3DCOLORWRITEENABLE_RED  );

    m_pd3dDevice->SetRenderState( D3DRS_STENCILFUNC, D3DCMP_EQUAL );
    m_pd3dDevice->SetRenderState( D3DRS_STENCILPASS, D3DSTENCILOP_KEEP );
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_CW );

    // Render the scene
    RenderScene();

    // Restore the transform, projection and culling.
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_CCW );
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &matViewSaved );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProjectionSaved );

    // Blend the mirror on top of the geometry.
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING, FALSE );

    // Ignore z values in stenciled area.
    m_pd3dDevice->SetRenderState( D3DRS_ZFUNC, D3DCMP_ALWAYS );

    m_pd3dDevice->SetTexture( 0, NULL );

    m_pd3dDevice->SetVertexShader( D3DFVF_XYZ | D3DFVF_DIFFUSE );

    m_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, g_MirrorVerts, 
                                   sizeof(MIRRORVERT) );

    m_pd3dDevice->SetRenderState( D3DRS_ZFUNC, D3DCMP_LESSEQUAL );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_STENCILENABLE, FALSE );

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: RenderScene()
// Desc:
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::RenderScene()
{
    // Set up the light
    D3DLIGHT8 light;
    XBUtil_InitLight( light, D3DLIGHT_DIRECTIONAL, 0.7071067f, -0.7071067f, 0.0f );
    m_pd3dDevice->SetLight( 0, &light );
    m_pd3dDevice->LightEnable( 0, TRUE );

    m_pd3dDevice->SetRenderState( D3DRS_AMBIENT, 0x00555555 );

    // Draw the room.
    m_Room.Render( m_pd3dDevice );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Sets up render states, clears the viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Clear the viewport, zbuffer, and stencil buffer
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,
                         0x00ff0000, 1.0f, 0L );

    // Set up misc render states
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_CCW );
    m_pd3dDevice->SetRenderState( D3DRS_DITHERENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SPECULARENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP );

    // Draw the reflected stuff first.
    RenderMirror();

    // Render the scene.
    RenderScene();

    // Show title, frame rate, and help
    if( m_bDrawHelp )
    {
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    }
    else
    {
        // Show frame rate
        m_Font.DrawText(  64, 50, 0xffffffff, L"MirrorClip" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\motionblur\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\motionblur\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\ModifyPixelShader\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 4UL

#define resource_Texture0_OFFSET 0UL
#define resource_Texture1_OFFSET 20UL
#define resource_Texture2_OFFSET 40UL
#define resource_Texture3_OFFSET 60UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\motionblur\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\ModifyPixelShader\obj\i386\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 4UL

#define resource_Texture0_OFFSET 0UL
#define resource_Texture1_OFFSET 20UL
#define resource_Texture2_OFFSET 40UL
#define resource_Texture3_OFFSET 60UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\motionblur\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\NoSortAlphaBlend\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\ModifyPixelShader\ModifyPixelShader.cpp ===
//-----------------------------------------------------------------------------
// File: ModifyPixelShader.cpp
//
// Desc: Demonstrates modifying a pixelshader on the fly, using the API. Any of
//       the following render states can be used to modify a current set pixel
//       shader:
//          D3DRS_PSCOMBINERCOUNT
//          D3DRS_PSDOTMAPPING
//          D3DRS_PSINPUTTEXTURE
//          D3DRS_PSCOMPAREMODE
//          D3DRS_PSCONSTANT0_[0..7]
//          D3DRS_PSCONSTANT1_[0..7]
//          D3DRS_PSRGBINPUTS[0..7]
//          D3DRS_PSALPHAINPUTS[0..7]
//          D3DRS_PSRGBOUTPUTS[0..7]
//          D3DRS_PSALPHAOUTPUTS[0..7]
//          D3DRS_PSFINALCOMBINERINPUTSABCD
//          D3DRS_PSFINALCOMBINERINPUTSEFG
//          D3DRS_PSFINALCOMBINERCONSTANT0
//          D3DRS_PSFINALCOMBINERCONSTANT1
//
// Hist: 04.18.01 - New for May XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <XBResource.h>
#include <XBUtil.h>

// The following header file is generated from "Resource.rdf" file using the
// Bundler tool. In addition to the header, the tool outputs a binary file
// (Resource.xpr) which contains compiled (i.e. bundled) resources and is
// loaded at runtime using the CXBPackedResource class.
#include "Resource.h"




//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_LEFTSTICK,    XBHELP_PLACEMENT_1, L"Rotate object" },
    { XBHELP_RIGHTSTICK,   XBHELP_PLACEMENT_1, L"Move light" },
    { XBHELP_DPAD,         XBHELP_PLACEMENT_1, L"Zoom" },
    { XBHELP_X_BUTTON,     XBHELP_PLACEMENT_2, L"Toggle\nfog" },
    { XBHELP_Y_BUTTON,     XBHELP_PLACEMENT_2, L"Toggle mask\ntexture" },
    { XBHELP_A_BUTTON,     XBHELP_PLACEMENT_2, L"Toggle combiner\ncount" },
    { XBHELP_B_BUTTON,     XBHELP_PLACEMENT_2, L"Toggle mapping\ninvert" },
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_2, L"Display\nhelp" },
    { XBHELP_START_BUTTON, XBHELP_PLACEMENT_2, L"Pause texture\nrotation" },
};

#define NUM_HELP_CALLOUTS 9




//-----------------------------------------------------------------------------
// Global variables
//-----------------------------------------------------------------------------
struct CUSTOMVERTEX
{
    D3DXVECTOR3 position;   // Position
    D3DXVECTOR3 normal;     // Normal
    D3DCOLOR    color;      // Color
    FLOAT       tu0, tv0;   // Texture 0 coordinates
    FLOAT       tu1, tv1;   // Texture 1 coordinates
    FLOAT       tu2, tv2;   // Texture 2 coordinates
};

// Our custom FVF, which describes our custom vertex structure
#define D3DFVF_CUSTOMVERTEX (D3DFVF_XYZ|D3DFVF_NORMAL|D3DFVF_DIFFUSE|D3DFVF_TEX3)




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBPackedResource  m_xprResource;        // Packed resources for the app
    CXBFont            m_Font;               // Font class
    CXBHelp            m_Help;               // Help class
    BOOL               m_bDrawHelp;          // Whether to draw help

    LPDIRECT3DVERTEXBUFFER8 m_pCylinderVB; // Buffer for cylinder vertices
    LPDIRECT3DTEXTURE8      m_pTexture0;
    LPDIRECT3DTEXTURE8      m_pTexture1;
    LPDIRECT3DTEXTURE8      m_pTexture2;

    DWORD        m_dwPixelShader;    // Handle for pixel shader 1
    BOOL         m_bEnableFog;
    BOOL         m_bUseRobotMask;
    BOOL         m_bChangeCombinerCount;
    BOOL         m_bChangeMapping;

    D3DXMATRIX   m_matObject;        // Transform matrix for the object
    D3DXMATRIX   m_matTexture;       // Transform matrix for the texture
    FLOAT        m_fEyeScale;        // Scale of viewing distance

public:
    HRESULT Initialize();
    HRESULT Render();
    HRESULT FrameMove();

    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    m_bDrawHelp            = FALSE;

    m_pCylinderVB          = NULL;
    m_dwPixelShader        = 0L;
    m_fEyeScale            = 1.0f;

    m_bEnableFog           = FALSE;
    m_bUseRobotMask        = FALSE;
    m_bChangeCombinerCount = FALSE;
    m_bChangeMapping       = FALSE;

    D3DXMatrixIdentity( &m_matObject );
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Initialize scene objects.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create the font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the resources
    if( FAILED( m_xprResource.Create( m_pd3dDevice, "Resource.xpr", 
                                      resource_NUM_RESOURCES ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Load the textures
    m_pTexture0 = m_xprResource.GetTexture( resource_Texture0_OFFSET );
    m_pTexture1 = m_xprResource.GetTexture( resource_Texture1_OFFSET );
    m_pTexture2 = m_xprResource.GetTexture( resource_Texture2_OFFSET );
    
    // Create geometry for a cylinder
    if( FAILED( m_pd3dDevice->CreateVertexBuffer( 50*2*sizeof(CUSTOMVERTEX),
                                                  0, D3DFVF_CUSTOMVERTEX,
                                                  D3DPOOL_DEFAULT, &m_pCylinderVB ) ) )
        return E_FAIL;

    // Fill the vertex buffer. We are setting the tu and tv texture
    // coordinates, which range from 0.0 to 1.0
    CUSTOMVERTEX* v;
    if( FAILED( m_pCylinderVB->Lock( 0, 0, (BYTE**)&v, 0 ) ) )
        return E_FAIL;
    for( DWORD i=0; i<50; i++ )
    {
        FLOAT theta = (2*D3DX_PI*i)/(50-1);

        v[2*i+0].position = D3DXVECTOR3( sinf(theta),-1.2f, cosf(theta) );
        v[2*i+0].normal   = D3DXVECTOR3( sinf(theta), 0.0f, cosf(theta) );
        v[2*i+0].color    = 0xffffffff;
        v[2*i+0].tu0      = v[2*i+0].tu1 = v[2*i+0].tu2 = ((FLOAT)i*2.0f)/(50-1);
        v[2*i+0].tv0      = v[2*i+0].tv1 = v[2*i+0].tv2 = 1.0f;

        v[2*i+1].position = D3DXVECTOR3( sinf(theta), 1.2f, cosf(theta) );
        v[2*i+1].normal   = D3DXVECTOR3( sinf(theta), 0.0f, cosf(theta) );
        v[2*i+1].color    = 0xff808080;
        v[2*i+1].tu0      = v[2*i+1].tu1 = v[2*i+1].tu2 = ((FLOAT)i*2.0f)/(50-1);
        v[2*i+1].tv0      = v[2*i+1].tv1 = v[2*i+1].tv2 = 0.0f;
    }
    m_pCylinderVB->Unlock();

    //--------------------------
    // Define a hard-coded pixel shader
    //--------------------------
    D3DPIXELSHADERDEF psd;
    ZeroMemory( &psd, sizeof(psd) );
    
    // The pixel shader uses 3 combiner stages
    psd.PSCombinerCount = PS_COMBINERCOUNT( 3,
        PS_COMBINERCOUNT_MUX_MSB | PS_COMBINERCOUNT_UNIQUE_C0 | PS_COMBINERCOUNT_UNIQUE_C1 );
    psd.PSTextureModes  = PS_TEXTUREMODES( PS_TEXTUREMODES_PROJECT2D,
                                        PS_TEXTUREMODES_PROJECT2D,
                                        PS_TEXTUREMODES_PROJECT2D,
                                        PS_TEXTUREMODES_NONE );
    psd.PSInputTexture  = PS_INPUTTEXTURE( 0, 0, 0, 0 );
    psd.PSDotMapping    = PS_DOTMAPPING( 0,
                                    PS_DOTMAPPING_ZERO_TO_ONE,
                                    PS_DOTMAPPING_ZERO_TO_ONE,
                                    PS_DOTMAPPING_ZERO_TO_ONE );
    psd.PSCompareMode   = PS_COMPAREMODE( 
        PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
        PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
        PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
        PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT );

    //--------------------------
    // Stage 0: r0 = t2 (the mask texture used for the mux in stage 1)
    //--------------------------

    // A=T2.rgb, B=1, C=0, D=0 (so that AB.rgb = T2 and CD = 0 )
    psd.PSRGBInputs[0]    = PS_COMBINERINPUTS(
        PS_REGISTER_T2   | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ONE  | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY );
    
    // A=T2.b, B=1, C=0, D=0 (so that AB.a = T2.b and CD = 0 )
    psd.PSAlphaInputs[0]  = PS_COMBINERINPUTS(
        PS_REGISTER_T2   | PS_CHANNEL_BLUE  | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ONE  | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY );
    
    // R0.rgb = AB
    psd.PSRGBOutputs[0]   = PS_COMBINEROUTPUTS(
        PS_REGISTER_R0,
        PS_REGISTER_DISCARD,
        PS_REGISTER_DISCARD,
        PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM );
    
    // R0.a = AB
    psd.PSAlphaOutputs[0] = PS_COMBINEROUTPUTS(
        PS_REGISTER_R0,
        PS_REGISTER_DISCARD,
        PS_REGISTER_DISCARD,
        PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM );
    
    psd.PSConstant0[0]    = 0x00000000;
    psd.PSConstant1[0]    = 0x00000000;

    //--------------------------
    // Stage 1: r0 = T0 mux T1
    //--------------------------

    // A=T0.rgb, B=1, C=T1.rgb, D=1 (so that AB.rgb = T0 and CD = T1 )
    psd.PSRGBInputs[1]    = PS_COMBINERINPUTS(
        PS_REGISTER_T0   | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ONE  | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_T1   | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ONE  | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY );

    // A=T0.a, B=1, C=T1.a, D=1 (so that AB.a = T0 and CD = T1 )
    psd.PSAlphaInputs[1]  = PS_COMBINERINPUTS(
        PS_REGISTER_T0   | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ONE  | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_T1   | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ONE  | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY );
    
    // R0.rgb = AB mux CD
    psd.PSRGBOutputs[1]   = PS_COMBINEROUTPUTS(
        PS_REGISTER_DISCARD,
        PS_REGISTER_DISCARD,
        PS_REGISTER_R0,
        PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_MUX );

    // R0.a = AB mux CD
    psd.PSAlphaOutputs[1] = PS_COMBINEROUTPUTS(
        PS_REGISTER_DISCARD,
        PS_REGISTER_DISCARD,
        PS_REGISTER_R0,
        PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_MUX );
    psd.PSConstant0[1]    = 0x00000000;
    psd.PSConstant1[1]    = 0x00000000;

    //--------------------------
    // Stage 2: r0 = r0 * v0
    //--------------------------

    // A=R0.rgb, B=V0.rgb, C=0, D=0 (so that AB.rgb = R0*V0 and CD = 0 )
    psd.PSRGBInputs[2]    = PS_COMBINERINPUTS(
        PS_REGISTER_R0   | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_V0   | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY );

    // A=R0.a, B=V0.a, C=0, D=0 (so that AB.a = R0*V0 and CD = 0 )
    psd.PSAlphaInputs[2]  = PS_COMBINERINPUTS(
        PS_REGISTER_R0   | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_V0   | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY );

    // R0 = AB
    psd.PSRGBOutputs[2]   = PS_COMBINEROUTPUTS(
        PS_REGISTER_R0,
        PS_REGISTER_DISCARD,
        PS_REGISTER_DISCARD,
        PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM );

    // R0 = AB
    psd.PSAlphaOutputs[2] = PS_COMBINEROUTPUTS(
        PS_REGISTER_R0,
        PS_REGISTER_DISCARD,
        PS_REGISTER_DISCARD,
        PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM );
    psd.PSConstant0[2]    = 0x00000000;
    psd.PSConstant1[2]    = 0x00000000;

    //--------------------------
    // Final combiner: output = r0
    //--------------------------
    psd.PSFinalCombinerInputsABCD=PS_COMBINERINPUTS(
        PS_REGISTER_ONE  | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_R0   | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY );

    // E = 0, F = 0, G = 1. (From above, EF is not used. G is alpha and is set to 1.)
    psd.PSFinalCombinerInputsEFG=PS_COMBINERINPUTS(
        PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ONE  | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_INVERT,
        0 | 0 | 0 );
    psd.PSC0Mapping = 0x00000000;
    psd.PSC1Mapping = 0x00000000;

    // Create the hard-coded pixel shader. This shader, defined in detail above,
    // uses texture 2 as a mask to select between texture 0 and texture 1, and 
    // then modulates in the diffuse component.
    if( FAILED( m_pd3dDevice->CreatePixelShader( &psd, &m_dwPixelShader ) ) )
    {
        OUTPUT_DEBUG_STRING( "Could not create hardcoded pixel shader.\n" );
        return E_FAIL;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK )
        m_bDrawHelp = !m_bDrawHelp;

    // Perform object rotation
    D3DXMATRIX matRotate;
    FLOAT fXRotate1 = m_DefaultGamepad.fX1*m_fElapsedTime*D3DX_PI*0.5f;
    FLOAT fYRotate1 = m_DefaultGamepad.fY1*m_fElapsedTime*D3DX_PI*0.5f;
    D3DXMatrixRotationYawPitchRoll( &matRotate, -fXRotate1, -fYRotate1, 0.0f );
    D3DXMatrixMultiply( &m_matObject, &m_matObject, &matRotate );

    // Move around the texture
    FLOAT tx = m_fAppTime/2 - floorf(m_fAppTime/2);
    FLOAT ty = 0.0f;
    m_matTexture._11 = 1.0f;   m_matTexture._12 = 0.0f; 
    m_matTexture._21 = 0.0f;   m_matTexture._22 = 1.0f; 
    m_matTexture._31 = tx;     m_matTexture._32 = ty; 
    m_matTexture._41 = 0.0f;   m_matTexture._42 = 0.0f; 

    // Zoom
    if( m_DefaultGamepad.wButtons & XINPUT_GAMEPAD_DPAD_UP )
        m_fEyeScale = m_fEyeScale/1.01f;
    if( m_DefaultGamepad.wButtons & XINPUT_GAMEPAD_DPAD_DOWN )
        m_fEyeScale *= 1.01f;

    // Toggle options
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_X] )
        m_bEnableFog = !m_bEnableFog;
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_Y] )
        m_bUseRobotMask = !m_bUseRobotMask;
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_A] )
        m_bChangeCombinerCount = !m_bChangeCombinerCount;
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_B] )
        m_bChangeMapping = !m_bChangeMapping;

    // Set transforms
    D3DXMATRIX matView, matProj;
    D3DXMatrixLookAtLH( &matView, &D3DXVECTOR3( 0.0f*m_fEyeScale, 3.0f*m_fEyeScale,-5.0f*m_fEyeScale ),
                                  &D3DXVECTOR3( 0.0f, 0.0f, 0.0f ),
                                  &D3DXVECTOR3( 0.0f, 1.0f, 0.0f ) );
    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/4, 1.0f, 1.0f, 100.0f );
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &m_matObject );
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );

    // Setup a material
    D3DMATERIAL8 mtrl;
    XBUtil_InitMaterial( mtrl, 1.0f, 1.0f, 1.0f );
    m_pd3dDevice->SetMaterial( &mtrl );

    // Adjust the point light's position
    static FLOAT phi1 = 0.5f;
    phi1 += 3.0f * m_fElapsedTime * m_DefaultGamepad.fX2;
    if( phi1 < -2.3f ) phi1 = -2.3f;
    if( phi1 > -0.9f ) phi1 = -0.9f;

    static FLOAT theta1 = 0.0f;
    theta1 -= 3.0f * m_fElapsedTime * m_DefaultGamepad.fY2;
    if( theta1 < +0.9f ) theta1 = +0.9f;
    if( theta1 > +2.3f ) theta1 = +2.3f;

    D3DXVECTOR3 vPtLightPos;
    vPtLightPos.x = 2*cosf( phi1 );
    vPtLightPos.y = 2*cosf( theta1 );
    vPtLightPos.z = 2*sinf( phi1 ) * sinf( theta1 );

    // Setup the point light
    D3DLIGHT8 light;
    ZeroMemory( &light, sizeof(D3DLIGHT8) );
    light.Type         = D3DLIGHT_POINT;
    light.Diffuse.r    = 1.0f;
    light.Diffuse.g    = 1.0f;
    light.Diffuse.b    = 1.0f;
    light.Diffuse.a    = 1.0f;
    light.Position     = vPtLightPos;
    light.Range        = 1000.0f;
    light.Attenuation0 = 1.0f;
    g_pd3dDevice->SetLight( 0, &light );
    g_pd3dDevice->LightEnable( 0, TRUE );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Draw a gradient filled background
    RenderGradientBackground( 0xff0000ff, 0xff0000ff );

    // Set default state
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 2, D3DTSS_COLOROP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 2, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_DISABLE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 2, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 2, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU,    D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV,    D3DTADDRESS_WRAP );
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING,        TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,         TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE, FALSE );
    m_pd3dDevice->SetPixelShader( NULL );

    // Enable fog (in case pixel pshader might do anything with fog)
    m_pd3dDevice->SetRenderState( D3DRS_FOGENABLE,     TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_FOGCOLOR,      0xff0000ff );
    m_pd3dDevice->SetRenderState( D3DRS_FOGTABLEMODE,  D3DFOG_LINEAR );
    m_pd3dDevice->SetRenderState( D3DRS_FOGSTART,      FtoDW(4.0f) );
    m_pd3dDevice->SetRenderState( D3DRS_FOGEND,        FtoDW(6.0f) );

    // Set textures. Texture 2 is transformed with a texture matrix
    m_pd3dDevice->SetTexture( 0, m_pTexture0 );
    m_pd3dDevice->SetTexture( 1, m_pTexture1 );
    m_pd3dDevice->SetTexture( 2, m_pTexture2 );
    m_pd3dDevice->SetTextureStageState( 2, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_COUNT2 );
    m_pd3dDevice->SetTransform( D3DTS_TEXTURE2, &m_matTexture );

    // Specify pixel shader. With a pixel shader in place, we can then modify
    // it on the fly.
    g_pd3dDevice->SetPixelShader( m_dwPixelShader );

    // Show turning on fog-blending in the final combiner
    if( m_bEnableFog )
    {
        DWORD dwPSFinalCombinerInputsABCD = PS_COMBINERINPUTS(
            PS_REGISTER_FOG  | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
            PS_REGISTER_R0   | PS_CHANNEL_RGB   | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
            PS_REGISTER_FOG  | PS_CHANNEL_RGB   | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
            PS_REGISTER_ZERO | PS_CHANNEL_RGB   | PS_INPUTMAPPING_UNSIGNED_IDENTITY );

        m_pd3dDevice->SetRenderState( D3DRS_PSFINALCOMBINERINPUTSABCD, dwPSFinalCombinerInputsABCD );
    }

    // Change the mask texture in stage 0 from t2 (the checkerboard texture) to 
    // t1 (the robot texture)
    if( m_bUseRobotMask )
    { 
        DWORD dwPSRGBInputs0 = PS_COMBINERINPUTS(
            PS_REGISTER_T1   | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
            PS_REGISTER_ONE  | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
            PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
            PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY );
    
        DWORD dwPSAlphaInputs0  = PS_COMBINERINPUTS(
            PS_REGISTER_T1   | PS_CHANNEL_BLUE  | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
            PS_REGISTER_ONE  | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
            PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
            PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY );

        m_pd3dDevice->SetRenderState( D3DRS_PSRGBINPUTS0,   dwPSRGBInputs0 );
        m_pd3dDevice->SetRenderState( D3DRS_PSALPHAINPUTS0, dwPSAlphaInputs0 );
    }

    // Change the combiner count. (Knock off the third combiner)
    if( m_bChangeCombinerCount )
    {
        m_pd3dDevice->SetRenderState( D3DRS_PSCOMBINERCOUNT, 2 );
    }

    // Show changing an input mapping. In this case, invert t0.rgb
    if( m_bChangeMapping )
    { 
        DWORD dwPSRGBInputs1 = PS_COMBINERINPUTS(
            PS_REGISTER_T0   | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_INVERT,
            PS_REGISTER_ONE  | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
            PS_REGISTER_T1   | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
            PS_REGISTER_ONE  | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY );

        m_pd3dDevice->SetRenderState( D3DRS_PSRGBINPUTS1,   dwPSRGBInputs1 );
    }

    // Render some geometry
    m_pd3dDevice->SetStreamSource( 0, m_pCylinderVB, sizeof(CUSTOMVERTEX) );
    m_pd3dDevice->SetVertexShader( D3DFVF_CUSTOMVERTEX );
    m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2*50-2 );

    // Restore states
    m_pd3dDevice->SetPixelShader( NULL );

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        m_Font.Begin();
        m_Font.DrawText(  64, 50, 0xffffffff, L"ModifyPixelShader" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );

        if( m_bEnableFog )
            m_Font.DrawText( 64, 325, 0xffffff00, L"Fog enabled" );
        if( m_bUseRobotMask )
            m_Font.DrawText( 64, 350, 0xffffff00, L"Using robot texture as mask" );
        if( m_bChangeCombinerCount )
            m_Font.DrawText( 64, 375, 0xffffff00, L"Combiner count reduced to 2" );
        if( m_bChangeMapping )
            m_Font.DrawText( 64, 400, 0xffffff00, L"Texture 0's mapping inverted" );

        m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\NoSortAlphaBlend\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\NoSortAlphaBlend\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\NoSortAlphaBlend\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\NoSortAlphaBlend\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\motionblur\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 9UL

#define resource_SkyBoxXN_OFFSET 0UL
#define resource_SkyBoxXP_OFFSET 20UL
#define resource_SkyBoxYN_OFFSET 40UL
#define resource_SkyBoxYP_OFFSET 60UL
#define resource_SkyBoxZN_OFFSET 80UL
#define resource_SkyBoxZP_OFFSET 100UL
#define resource_Floor_OFFSET 120UL
#define resource_BiHull_OFFSET 140UL
#define resource_Wings_OFFSET 160UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\motionblur\motionblur.cpp ===
//-----------------------------------------------------------------------------
// File: MotionBlur.cpp
//
// Desc: Shows one way of doing motion blur on the Xbox
//
// Note: For a cool blur experience, zoom in on the rotating plane and set
//       NumPasses = 8 and PosFactor = 0.9
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <xpath.h>
#include <xmenu.h>
#include <xobj.h>

// The following header file is generated from "Resource.rdf" file using the
// Bundler tool. In addition to the header, the tool outputs a binary file
// (Resource.xpr) which contains compiled (i.e. bundled) resources and is
// loaded at runtime using the CXBPackedResource class.
#include "Resource.h"




//-----------------------------------------------------------------------------
// ASCII names for the resources used by the app
//-----------------------------------------------------------------------------
XBRESOURCE g_ResourceNames[] = 
{
    { "SkyBoxXP.bmp", resource_SkyBoxXP_OFFSET },
    { "SkyBoxXN.bmp", resource_SkyBoxXN_OFFSET },
    { "SkyBoxYP.bmp", resource_SkyBoxYP_OFFSET },
    { "SkyBoxYN.bmp", resource_SkyBoxYN_OFFSET },
    { "SkyBoxZP.bmp", resource_SkyBoxZP_OFFSET },
    { "SkyBoxZN.bmp", resource_SkyBoxZN_OFFSET },
    { "Floor.bmp",    resource_Floor_OFFSET },
    { "BiHull.bmp",   resource_BiHull_OFFSET },
    { "Wings.bmp",    resource_Wings_OFFSET },
    { NULL, 0 },
};

extern CXBPackedResource* g_pModelResource;




//-----------------------------------------------------------------------------
// Help screen definitions
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] =
{
    { XBHELP_LEFTSTICK,    XBHELP_PLACEMENT_1, L"Camera X, Z" },
    { XBHELP_RIGHTSTICK,   XBHELP_PLACEMENT_1, L"Camera Y" },
    { XBHELP_A_BUTTON,     XBHELP_PLACEMENT_1, L"Decrease Passes" },
    { XBHELP_B_BUTTON,     XBHELP_PLACEMENT_1, L"Increase Passes" },
    { XBHELP_X_BUTTON,     XBHELP_PLACEMENT_2, L"Decrease\nPosFactor" },
    { XBHELP_Y_BUTTON,     XBHELP_PLACEMENT_2, L"Increase\nPosFactor" },
    { XBHELP_BLACK_BUTTON, XBHELP_PLACEMENT_1, L"Toggle Blur" },
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_1, L"Display\nhelp" },
};
#define NUM_HELP_CALLOUTS 8




//-----------------------------------------------------------------------------
// Name: class CXBlurObject
// Desc: CXObject with additions to facilitate motion blur.
//-----------------------------------------------------------------------------
class CXBlurObject : public CXObject
{
public:
    D3DXVECTOR3 m_vLastPosition;
    D3DXVECTOR3 m_vLastRotation;
    D3DXVECTOR3 m_vPosStep;
    D3DXVECTOR3 m_vRotStep;
    D3DXVECTOR3 m_vPosSave;
    D3DXVECTOR3 m_vRotSave;

    FLOAT      m_fNumSteps;             // # of steps between last & current position
    FLOAT      m_fPosBlend;             // Last position/rotation blend factor

    CXBlurObject();

    void BeginBlur();                   // Begin the blur process
    void AdvanceBlurStep();
    void EndBlur();                     // End the blur and adjust lastpos/rot
};




//-----------------------------------------------------------------------------
// Name: CXBlurObject Constructor
// Desc: 
//-----------------------------------------------------------------------------
CXBlurObject::CXBlurObject() : CXObject()
{
    m_vLastPosition = m_vPosition;
    m_vLastRotation = m_vRotation;

    m_fNumSteps = 4.0f;
    m_fPosBlend = 0.5f;
}




void CXBlurObject::BeginBlur()
{
    m_vPosSave = m_vPosition;
    m_vRotSave = m_vRotation;

    m_vPosStep = (m_vPosition-m_vLastPosition)/(m_fNumSteps-1.0f);
    m_vRotStep = (m_vRotation-m_vLastRotation)/(m_fNumSteps-1.0f);

    m_vPosition = m_vLastPosition;
    m_vRotation = m_vLastRotation;
}




void CXBlurObject::AdvanceBlurStep()
{
    m_vPosition += m_vPosStep;
    m_vRotation += m_vRotStep;
}




void CXBlurObject::EndBlur()
{
    m_vLastPosition = m_fPosBlend*m_vLastPosition + (1.0f-m_fPosBlend)*m_vPosition;
    m_vLastRotation = m_fPosBlend*m_vLastRotation + (1.0f-m_fPosBlend)*m_vRotation;

    m_vPosition = m_vPosSave;
    m_vRotation = m_vRotSave;
}




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBPackedResource  m_xprResource;
    CXBFont            m_Font;
    CXBHelp            m_Help;
    BOOL               m_bDrawHelp;
    
    D3DXVECTOR3        m_vCameraPos;
    D3DXVECTOR3        m_vCameraRot;

    CXBlurObject       m_Plane1Obj;
    CXBlurObject       m_Plane2Obj;
    CXObject           m_BlockerObj;

    CXBMesh*           m_pSkyBox;

    LPDIRECT3DTEXTURE8 m_pBlendTexture;
    LPDIRECT3DTEXTURE8 m_pCompositeTexture;
    LPDIRECT3DSURFACE8 m_pBlendSurface;
    LPDIRECT3DSURFACE8 m_pCompositeSurface;
    LPDIRECT3DSURFACE8 m_pBlendZSurface;

    DWORD              m_bBlur;
    DWORD              m_dwNumPasses;
    FLOAT              m_fPosFactor;

public:
    HRESULT Initialize();
    HRESULT FrameMove();
    HRESULT Render();

    CXBoxSample();

    HRESULT RenderScreenTexture(LPDIRECT3DTEXTURE8 pTexture, DWORD dwTFactor );
    HRESULT AddTexture(LPDIRECT3DTEXTURE8 pTexture);
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    // Initialize our stuff
    m_bDrawHelp   = FALSE;

    m_vCameraPos  = D3DXVECTOR3( 0.0f, 0.0f, -50.0f);
    m_vCameraRot  = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );

    m_bBlur       = TRUE;
    m_dwNumPasses = 4;
    m_fPosFactor  = 0.5f;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Initialize device-dependant objects.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    HRESULT hr;

    // Create a font
    if( FAILED( hr = m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Initialize the help system
    if( FAILED( hr = m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Load the packed resource
    if( FAILED( m_xprResource.Create( m_pd3dDevice, "Resource.xpr",
                                      resource_NUM_RESOURCES, g_ResourceNames ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    g_pModelResource = &m_xprResource;

    // Set projection transform
    D3DXMATRIX matProj;
    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/4, 640.0f/480.0f, 0.1f, 100.0f );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );

    // Set base path for creating/loading geometry
    XPath_SetBasePath( _T("D:\\Media\\") );

    // Initialize the airplanes
    CXBMesh *xbm;
    xbm = new CXBMesh;
    xbm->Create(g_pd3dDevice, "Models\\Airplane.xbg", &m_xprResource );
    m_Plane1Obj.SetXBMesh( xbm );
    m_Plane1Obj.SetPosition( 20.0f, 5.0f, 0.0f );
    m_Plane2Obj.SetXBMesh( xbm );
    m_Plane2Obj.SetPosition( 0.0f, 0.0f, -10.0f );

    m_pSkyBox = new CXBMesh;
    m_pSkyBox->Create(g_pd3dDevice, "Models\\Skybox.xbg", &m_xprResource );

    // Put an object in the middle of the scene to prove zbuffering works
    m_BlockerObj.m_Model = new CXModel;
    m_BlockerObj.m_Model->Sphere( 4.0f, 16, 16, FVF_XYZTEX1, "Floor.bmp", 5.0f );
    m_BlockerObj.SetPosition(0.0f, 5.0f, 0.0f);

    // Create the texture used for blending
    m_pd3dDevice->CreateTexture( 640, 480, 1, 0, D3DFMT_LIN_A8R8G8B8, D3DPOOL_DEFAULT, &m_pBlendTexture );

    // Create the z buffer for blending
    m_pd3dDevice->CreateDepthStencilSurface( 640, 480, D3DFMT_LIN_D24S8, D3DMULTISAMPLE_NONE , &m_pBlendZSurface );

    // Create the compositing texture
    m_pd3dDevice->CreateTexture( 640, 480, 1, 0, D3DFMT_LIN_A8R8G8B8, D3DPOOL_DEFAULT, &m_pCompositeTexture );

    // Clear them out
    m_pBlendTexture->GetSurfaceLevel( 0, &m_pBlendSurface );
    m_pd3dDevice->SetRenderTarget( m_pBlendSurface, m_pBlendZSurface );
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL, 0, 1.0f, 0L );
    m_pBlendSurface->Release();

    m_pd3dDevice->SetRenderTarget( m_pBackBuffer, m_pDepthBuffer );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    m_Plane1Obj.m_vPosition.x =  20.0f * cosf( m_Plane1Obj.m_vRotation.y );
    m_Plane1Obj.m_vRotation.y += D3DX_PI*m_fElapsedTime;
    m_Plane1Obj.m_vPosition.z = -20.0f * sinf( m_Plane1Obj.m_vRotation.y );

    m_Plane2Obj.m_vRotation.x -= 1*D3DX_PI*m_fElapsedTime;
    m_Plane2Obj.m_vRotation.y -= 2*D3DX_PI*m_fElapsedTime;

    // Toggle help
    if( m_DefaultGamepad.wPressedButtons&XINPUT_GAMEPAD_BACK )
        m_bDrawHelp = !m_bDrawHelp;

    // Adjust # of passes
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_B])
        m_dwNumPasses++;
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_A])
    {
        m_dwNumPasses--;
        if( m_dwNumPasses<2 )
            m_dwNumPasses = 2;
    }
    m_Plane1Obj.m_fNumSteps = (float)m_dwNumPasses;
    m_Plane2Obj.m_fNumSteps = (float)m_dwNumPasses;

    // Adjust position factor
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_Y])
    {
        m_fPosFactor += 0.1f;
        if( m_fPosFactor>0.9f )
            m_fPosFactor = 0.9f;
    }
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_X])
    {
        m_fPosFactor -= 0.1f;
        if( m_fPosFactor<0.0f )
            m_fPosFactor = 0.0f;
    }
    m_Plane1Obj.m_fPosBlend = m_fPosFactor;
    m_Plane2Obj.m_fPosBlend = m_fPosFactor;

    // Toggle blur
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_BLACK])
        m_bBlur = !m_bBlur;

    // Adjust the camera
    D3DXMATRIX matView;
    m_vCameraPos.x += m_DefaultGamepad.fX1*m_fElapsedTime*8.0f;
    m_vCameraPos.y += m_DefaultGamepad.fY2*m_fElapsedTime*8.0f;
    m_vCameraPos.z += m_DefaultGamepad.fY1*m_fElapsedTime*8.0f;

    D3DXMatrixTranslation( &matView, -m_vCameraPos.x, -m_vCameraPos.y, -m_vCameraPos.z);
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    DWORD i, dwTfactor;

    // Clear the viewport
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL, 
                         0, 1.0f, 0L );

    // Restore state that text clobbers
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, D3DZB_TRUE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );

    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );

    // Render the Skybox
    {
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );
        
        // Center view matrix for skybox and disable zbuffer
        D3DXMATRIX matView, matViewSave;

        D3DXMatrixIdentity(&matView);
        m_pd3dDevice->SetTransform( D3DTS_WORLD,      &matView );

        m_pd3dDevice->GetTransform( D3DTS_VIEW,      &matViewSave );
        matView = matViewSave;
        matView._41 = 0.0f; matView._42 = -0.0f; matView._43 = 0.0f;
        m_pd3dDevice->SetTransform( D3DTS_VIEW,      &matView );
        m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, FALSE );

        // Render the skybox
        m_pSkyBox->Render( m_pd3dDevice );

        // Restore the render states
        m_pd3dDevice->SetTransform( D3DTS_VIEW,      &matViewSave );
        m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE );
    }

    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU,  D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV,  D3DTADDRESS_WRAP );

    // Render blocker object to prove that z buffering works
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
    m_BlockerObj.Render(0);

    if( !m_bBlur )
    {
        m_Plane1Obj.Render(0);
        m_Plane2Obj.m_vRotation.y += D3DX_PI;
        m_Plane2Obj.Render(0);
        m_Plane2Obj.m_vRotation.y -= D3DX_PI;
    }
    else
    {
        // Begin the blur for each object
        m_Plane1Obj.BeginBlur();
        m_Plane2Obj.BeginBlur();

        // Clear out the compositing surface
        m_pCompositeTexture->GetSurfaceLevel( 0, &m_pCompositeSurface );
        m_pd3dDevice->SetRenderTarget( m_pCompositeSurface, NULL );
        m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET, 0x00000000, 1.0f, 0L );

        // Adjust the tfactor to contribute the right amount of color/alpha
        // per pass
        dwTfactor = 255/m_dwNumPasses;
        dwTfactor |= (dwTfactor<<8);
        dwTfactor |= (dwTfactor<<8);
        dwTfactor |= (dwTfactor<<8);

        // Do the blur. NOTE: make sure m_dwNumPasses matches the m_fNumSteps
        // value in the blur objects
        for( i=0; i<m_dwNumPasses; i++ )
        {
            m_pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, dwTfactor );
            m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
            m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
            m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_TFACTOR );
            m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1 );
            m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TFACTOR );

            m_pBlendTexture->GetSurfaceLevel( 0, &m_pBlendSurface );
            m_pd3dDevice->SetRenderTarget( m_pBlendSurface, m_pBlendZSurface );
            
            // Clear the blend surface
            m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET, 0x00000000, 1.0f, 0L );

            // Copy the screen z buffer
            m_pd3dDevice->CopyRects( m_pDepthBuffer, NULL, 0, m_pBlendZSurface, NULL );

            // Render the blurred objects
            m_Plane1Obj.Render( 0 );
            m_Plane2Obj.Render( 0 );
            m_pBlendSurface->Release();

            // Advance the objects to the next blur step
            m_Plane1Obj.AdvanceBlurStep();
            m_Plane2Obj.AdvanceBlurStep();

            // Add this layer to the composite surface
            m_pd3dDevice->SetRenderTarget( m_pCompositeSurface, NULL );
            AddTexture( m_pBlendTexture );
        }

        // End the blur for each object
        m_Plane1Obj.EndBlur();
        m_Plane2Obj.EndBlur();

        // Release our compositing surface
        m_pCompositeSurface->Release();

        // Blend the blur texture with the existing screen
        m_pd3dDevice->SetRenderTarget( m_pBackBuffer, m_pDepthBuffer );
        RenderScreenTexture( m_pCompositeTexture, 0 );
    }

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        m_Font.Begin();
        m_Font.DrawText(  64, 50, 0xffffffff, L"MotionBlur" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );

        WCHAR str[80];
        swprintf( str, L"NumPasses: %d", m_dwNumPasses );
        m_Font.DrawText( 64, 70, 0xffffffff, str );
        swprintf( str, L"PosFactor: %3.2f", m_fPosFactor );
        m_Font.DrawText( 64, 90, 0xffffffff, str );

        m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: RenderScreenTexture()
// Desc: This function renders the motion blurred screen texture to the screen.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::RenderScreenTexture( LPDIRECT3DTEXTURE8 pTexture, DWORD dwAlphaRef )
{
    struct BACKGROUNDVERTEX { D3DXVECTOR4 p; FLOAT tu, tv; } v[4];
    // NOTE: these coords cause the full-screen poly to be shifted/stretched slightly,
    // but that's okay in this sample because it actually looks a little better.
    v[0].p = D3DXVECTOR4(   0,   0, 1.0f, 1.0f ); v[0].tu =   0.0f; v[0].tv =   0.0f; 
    v[1].p = D3DXVECTOR4( 640,   0, 1.0f, 1.0f ); v[1].tu = 639.0f; v[1].tv =   0.0f; 
    v[2].p = D3DXVECTOR4(   0, 480, 1.0f, 1.0f ); v[2].tu =   0.0f; v[2].tv = 479.0f; 
    v[3].p = D3DXVECTOR4( 640, 480, 1.0f, 1.0f ); v[3].tu = 639.0f; v[3].tv = 479.0f; 

    // Set states
    g_pd3dDevice->SetTexture( 0, pTexture );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU,  D3DTADDRESS_CLAMP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV,  D3DTADDRESS_CLAMP );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, FALSE ); 

    // If using modulate, you need to set alpharef to around 0xc0. Otherwise
    // you will see major streaks behind the objects
    if( dwAlphaRef>0 )
    {
        m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE, TRUE );
        m_pd3dDevice->SetRenderState( D3DRS_ALPHAREF,  dwAlphaRef&0xff );
        m_pd3dDevice->SetRenderState( D3DRS_ALPHAFUNC, D3DCMP_GREATEREQUAL );
    }

    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,  D3DBLEND_SRCALPHA );
    m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA );

    // Draw the textured quad
    m_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_TEX1 );
    m_pd3dDevice->DrawPrimitiveUP( D3DPT_QUADSTRIP, 1, v, sizeof(BACKGROUNDVERTEX) );

    // Reset render states
    m_pd3dDevice->SetTexture( 0, NULL );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  FALSE );
    g_pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE ); 
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: AddTexture()
// Desc: This function adds the "blend" texture to the "composite" texture.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::AddTexture( LPDIRECT3DTEXTURE8 pTexture )
{
    struct BACKGROUNDVERTEX { D3DXVECTOR4 p; FLOAT tu, tv; } v[4];
    // NOTE: these coords cause the full-screen poly to be shifted/stretched slightly,
    // but that's okay in this sample because it actually looks a little better.
    v[0].p = D3DXVECTOR4(   0,   0, 1.0f, 1.0f ); v[0].tu =   0.0f; v[0].tv =   0.0f; 
    v[1].p = D3DXVECTOR4( 640,   0, 1.0f, 1.0f ); v[1].tu = 639.0f; v[1].tv =   0.0f; 
    v[2].p = D3DXVECTOR4(   0, 480, 1.0f, 1.0f ); v[2].tu =   0.0f; v[2].tv = 479.0f; 
    v[3].p = D3DXVECTOR4( 640, 480, 1.0f, 1.0f ); v[3].tu = 639.0f; v[3].tv = 479.0f; 

    // Set states
    g_pd3dDevice->SetTexture( 0, pTexture );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU,  D3DTADDRESS_CLAMP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV,  D3DTADDRESS_CLAMP );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, FALSE ); 

    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,  D3DBLEND_ONE );
    m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_ONE );

    // Draw the textured quad
    m_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_TEX1 );
    m_pd3dDevice->DrawPrimitiveUP( D3DPT_QUADSTRIP, 1, v, sizeof(BACKGROUNDVERTEX) );

    // Reset render states
    m_pd3dDevice->SetTexture( 0, NULL );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE ); 

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Notifier\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Notifier\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\motionblur\obj\i386\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 9UL

#define resource_SkyBoxXN_OFFSET 0UL
#define resource_SkyBoxXP_OFFSET 20UL
#define resource_SkyBoxYN_OFFSET 40UL
#define resource_SkyBoxYP_OFFSET 60UL
#define resource_SkyBoxZN_OFFSET 80UL
#define resource_SkyBoxZP_OFFSET 100UL
#define resource_Floor_OFFSET 120UL
#define resource_BiHull_OFFSET 140UL
#define resource_Wings_OFFSET 160UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Notifier\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Notifier\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\NoSortAlphaBlend\NoSortAlphaBlend.cpp ===
//-----------------------------------------------------------------------------
// File: NoSortAlphaBlend.cpp
//
// Desc: Example showinging how get correct alpha blending without sorting.
//       Uses depth peeling to seperate the alpha into layers.
//
// Hist: 07.16.01 - New for August XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <XBMesh.h>
#include <XBResource.h>
#include <XBUtil.h>
#include <assert.h>




// For the farthest layer of alpha, blend then write z values in seperate passes
// so that nearer alpha values won't prevent farther alpha values from being
// blended into the scene (even though they are blended incorrectly).
#define FARTHEST_LAYER_SEPERATE_Z 1

// Maximum number of layers to blend.
const int MAX_LAYERS = 6;




//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
	{ XBHELP_LEFTSTICK,   XBHELP_PLACEMENT_1, L"Move camera" },
	{ XBHELP_A_BUTTON,	  XBHELP_PLACEMENT_2, L"Toggle Depth\nPeeling" },
	{ XBHELP_B_BUTTON,	  XBHELP_PLACEMENT_1, L"Toggle Z\nReplace" },
	{ XBHELP_X_BUTTON,	  XBHELP_PLACEMENT_2, L"Decrease #\nof Layers" },
	{ XBHELP_Y_BUTTON,	  XBHELP_PLACEMENT_2, L"Increase #\nof Layers" },
	{ XBHELP_BACK_BUTTON, XBHELP_PLACEMENT_1, L"Display help" },
	{ XBHELP_WHITE_BUTTON, XBHELP_PLACEMENT_2, L"Show Previous\nLayer" },
	{ XBHELP_BLACK_BUTTON, XBHELP_PLACEMENT_1, L"Show Next\nLayer" },
};

#define NUM_HELP_CALLOUTS (sizeof(g_HelpCallouts)/sizeof(g_HelpCallouts[0]))




//-----------------------------------------------------------------------------
// Name: class CXBAlphaMesh
// Desc: Extension to mesh that sets constant zero with diffuse material value.
//-----------------------------------------------------------------------------
class CXBAlphaMesh : public CXBMesh
{
public:
	BOOL RenderCallback( LPDIRECT3DDEVICE8 pd3dDevice, DWORD dwSubset,
                         XBMESH_SUBSET* pSubset, DWORD dwFlags )
	{
		pd3dDevice->SetPixelShaderConstant( 0, &pSubset->mtrl.Diffuse, 1 );

		return TRUE;
	}
	
};




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//		 from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
	CXBPackedResource  m_xprResource;		 // Packed resources for the app
	CXBFont 		   m_Font;				 // Font class
	CXBHelp 		   m_Help;				 // Help class
	bool			   m_bDrawHelp; 		 // Whether to draw help

	bool               m_bUseDepthPeeling;	 // Use depth peeling for alpha
	int				   m_iNumLayers;		 // Number of unique layers of alpha

	bool               m_bUseDotZW;			 // Use z replace to eliminate artifacts
	
	int				   m_iDrawLayer;		 // Limit drawing to one layer.

	CXBMesh 		   m_Room;				 // XBG file object to render
	CXBAlphaMesh       m_AlphaVolume; 		 // Alpha volume

	D3DXVECTOR3 	   m_vEye;
	D3DXMATRIX		   m_matWorld;
	D3DXMATRIX		   m_matView;
	D3DXMATRIX		   m_matProjection;

	DWORD			   m_dwAlphaVertexShader;
	D3DPIXELSHADERDEF  m_PeelPixelShader;
	D3DPIXELSHADERDEF  m_ConstantPixelShader;

    IDirect3DTexture8 *m_pDepthBuffer[MAX_LAYERS-1];

    IDirect3DSurface8 *m_pColorBuffer;
    IDirect3DSurface8 *m_pZBuffer;

	D3DPIXELSHADERDEF  m_ZRPeelPixelShader;
	D3DPIXELSHADERDEF  m_ZRConstantPixelShader;
    IDirect3DTexture8 *m_pDummyTexture;

	HRESULT RenderScene();

public:
	HRESULT Initialize();
	HRESULT Render();
	HRESULT FrameMove();

	HRESULT SetupPixelShaders();
	HRESULT CreateBuffers();

	CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
	CXBoxSample xbApp;
	if( FAILED( xbApp.Create() ) )
		return;
	xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
			:CXBApplication()
{
    // Allow unlimited frame rate
    m_d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;

	m_iNumLayers = 4;
	m_bUseDepthPeeling = true;

	m_bDrawHelp = false;

	m_bUseDotZW = false;

	m_iDrawLayer = -1;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
	// Create the font
	if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
		return XBAPPERR_MEDIANOTFOUND;

	// Create help
	if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
		return XBAPPERR_MEDIANOTFOUND;

	// Load the main file object
	if( FAILED( m_Room.Create( m_pd3dDevice, "Models\\Room2.xbg", &m_xprResource ) ) )
		return XBAPPERR_MEDIANOTFOUND;

	// Load the main file object
	if( FAILED( m_AlphaVolume.Create( m_pd3dDevice, "Models\\alphaobjs.xbg", &m_xprResource ) ) )
		return XBAPPERR_MEDIANOTFOUND;

	// Create vertex shader.
    DWORD vdecl[] =
    {
        D3DVSD_STREAM(0),
        D3DVSD_REG(0, D3DVSDT_FLOAT3), // v0 = XYZ
        D3DVSD_REG(1, D3DVSDT_FLOAT3), // v1 = normals
        D3DVSD_END()
    };

    if ( FAILED( XBUtil_CreateVertexShader( m_pd3dDevice, "Shaders\\AlphaShader.xvu", vdecl, &m_dwAlphaVertexShader ) ) )
        return E_FAIL;

	// Create pixel shader for alpha drawing.
	SetupPixelShaders();

	// Create color buffers and z buffers.
	CreateBuffers();

	// Dummy texture for z-replace.
    m_pd3dDevice->CreateTexture( 1, 1, 1, 0, D3DFMT_V16U16, 0, &m_pDummyTexture );

    // Get the original color and z-buffer.
    m_pd3dDevice->GetRenderTarget( &m_pColorBuffer );
    m_pd3dDevice->GetDepthStencilSurface( &m_pZBuffer );

	// Set the matrices
	D3DXMatrixIdentity( &m_matWorld );
	m_pd3dDevice->SetTransform( D3DTS_WORLD, &m_matWorld );

	m_vEye = D3DXVECTOR3( 10.0f, 1.0f, 0.0f );
	D3DXVECTOR3 vAt( 0.0f, 0.0f, 0.0f );
	D3DXVECTOR3 vUp( 0.0f, 1.0f, 0.0f );

	D3DXMatrixLookAtLH( &m_matView, &m_vEye, &vAt, &vUp );
	m_pd3dDevice->SetTransform( D3DTS_VIEW, &m_matView );

	D3DXMatrixPerspectiveFovLH( &m_matProjection, D3DX_PI/3, 4.0f/3.0f, 0.1f, 100.0f );
	m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &m_matProjection );

	return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//		 the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
	D3DXMATRIX matView, matRotate;

	// Toggle help
	if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK )
		m_bDrawHelp = !m_bDrawHelp;

	if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_A] )
	{
		m_bUseDepthPeeling = !m_bUseDepthPeeling;
	}

	if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_B] )
	{
		m_bUseDotZW = !m_bUseDotZW;
	}


	if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_Y] )
	{
		m_iNumLayers++;

		if( m_iNumLayers > MAX_LAYERS )
			m_iNumLayers = MAX_LAYERS;
	}

	if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_X] )
	{
		m_iNumLayers--;

		if( m_iNumLayers < 2 )
			m_iNumLayers = 2;
	}

	if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_BLACK] )
	{
		m_iDrawLayer++;

		if( m_iDrawLayer > m_iNumLayers-1 )
			m_iDrawLayer = m_iNumLayers-1;
	}

	if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_WHITE] )
	{
		m_iDrawLayer--;

		if( m_iDrawLayer < -1 )
			m_iDrawLayer = -1;
	}

	D3DXVECTOR3 vAt( 0.0f, 0.0f, 0.0f );
	D3DXVECTOR3 vUp( 0.0f, 1.0f, 0.0f );

	// Rotate eye around up axis.
	D3DXMatrixRotationAxis( &matRotate, &vUp, 
										m_DefaultGamepad.fX1*m_fElapsedTime );
	D3DXVec3TransformCoord( &m_vEye, &m_vEye, &matRotate );

	// Rotate eye points around side axis.
	D3DXVECTOR3 vView = (m_vEye - vAt);
	D3DXVec3Normalize( &vView, &vView );

	// Place limits so we dont go over the top or under the bottom.
	FLOAT dot = D3DXVec3Dot( &vView, &vUp );
	if( (dot > 0.0f || m_DefaultGamepad.fY1 < 0.0f) && (dot < 0.99f || m_DefaultGamepad.fY1 > 0.0f) )
	{
		D3DXVECTOR3 axis;
		D3DXVec3Cross( &axis, &vUp, &vView );
		D3DXMatrixRotationAxis( &matRotate, &axis, m_DefaultGamepad.fY1*m_fElapsedTime );
		D3DXVec3TransformCoord( &m_vEye, &m_vEye, &matRotate );
	}

	D3DXMatrixLookAtLH( &m_matView, &m_vEye, &vAt, &vUp );

	m_pd3dDevice->SetTransform( D3DTS_VIEW, &m_matView );

	return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SetupPixelShader()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::SetupPixelShaders()
{
	//
	// Setup the pixel shader for constant alpha with depth peeling.
	//
	// a = c0.a
	// rgb = c0.rgb
	//
	D3DPIXELSHADERDEF psd;
	ZeroMemory( &psd, sizeof(psd) );
	psd.PSCombinerCount = PS_COMBINERCOUNT( 1, PS_COMBINERCOUNT_MUX_MSB | PS_COMBINERCOUNT_UNIQUE_C0 | PS_COMBINERCOUNT_UNIQUE_C1);

	psd.PSTextureModes	= PS_TEXTUREMODES( PS_TEXTUREMODES_PROJECT3D, PS_TEXTUREMODES_NONE, 
										   PS_TEXTUREMODES_NONE, PS_TEXTUREMODES_NONE );

	psd.PSC0Mapping = 0xfffffff0;
	psd.PSC1Mapping = 0xffffffff;
	psd.PSFinalCombinerConstants = 0x000000ff;

	//------------- Stage 0 -------------
	// r0.rgb = c0.rgb
	psd.PSRGBInputs[0]	  = PS_COMBINERINPUTS( PS_REGISTER_C0 | PS_CHANNEL_RGB,
											   PS_REGISTER_ONE | PS_CHANNEL_RGB,
											   PS_REGISTER_ZERO | PS_CHANNEL_RGB,
											   PS_REGISTER_ZERO | PS_CHANNEL_RGB );

	psd.PSRGBOutputs[0]   = PS_COMBINEROUTPUTS( PS_REGISTER_R0,
												PS_REGISTER_DISCARD,
												PS_REGISTER_DISCARD,
												0 );

	// r0.a = c0.a
	psd.PSAlphaInputs[0]  = PS_COMBINERINPUTS( PS_REGISTER_C0 | PS_CHANNEL_ALPHA,
											   PS_REGISTER_ONE | PS_CHANNEL_ALPHA,
											   PS_REGISTER_ZERO | PS_CHANNEL_ALPHA,
											   PS_REGISTER_ZERO | PS_CHANNEL_ALPHA );

	psd.PSAlphaOutputs[0] = PS_COMBINEROUTPUTS( PS_REGISTER_R0,
												PS_REGISTER_DISCARD,
												PS_REGISTER_DISCARD,
												0 );

	psd.PSConstant0[0] = 0xffffffff;


	//------------- Final combiner -------------
	psd.PSFinalCombinerInputsABCD = PS_COMBINERINPUTS( PS_REGISTER_ZERO	| PS_CHANNEL_RGB,
													   PS_REGISTER_ZERO | PS_CHANNEL_RGB,
													   PS_REGISTER_ZERO	| PS_CHANNEL_RGB,
													   PS_REGISTER_R0   | PS_CHANNEL_RGB );

	psd.PSFinalCombinerInputsEFG = PS_COMBINERINPUTS( PS_REGISTER_ZERO | PS_CHANNEL_RGB,
													  PS_REGISTER_ZERO | PS_CHANNEL_RGB,
													  PS_REGISTER_R0   | PS_CHANNEL_ALPHA,
													  0 );

	memcpy( &m_PeelPixelShader, &psd, sizeof(D3DPIXELSHADERDEF) );

	// Make version that uses z-replace.
	psd.PSTextureModes	= PS_TEXTUREMODES( PS_TEXTUREMODES_PROJECT3D, PS_TEXTUREMODES_DOTPRODUCT,
										   PS_TEXTUREMODES_DOT_ZW, PS_TEXTUREMODES_NONE );

    psd.PSInputTexture  = PS_INPUTTEXTURE( 0, 0, 0, 0 );

    psd.PSDotMapping    = PS_DOTMAPPING( 0, PS_DOTMAPPING_HILO_1, PS_DOTMAPPING_HILO_1, 0 );

	memcpy( &m_ZRPeelPixelShader, &psd, sizeof(D3DPIXELSHADERDEF) );
	
	//
	// Setup the pixel shader for constant alpha.
	//
	// a = c0.a
	// rgb = c0.rgb
	//
	ZeroMemory( &psd, sizeof(psd) );
	psd.PSCombinerCount = PS_COMBINERCOUNT( 1, PS_COMBINERCOUNT_MUX_MSB | PS_COMBINERCOUNT_UNIQUE_C0 | PS_COMBINERCOUNT_UNIQUE_C1);

	psd.PSTextureModes	= PS_TEXTUREMODES( PS_TEXTUREMODES_NONE, PS_TEXTUREMODES_NONE, 
										   PS_TEXTUREMODES_NONE, PS_TEXTUREMODES_NONE );

	psd.PSC0Mapping = 0xfffffff0;
	psd.PSC1Mapping = 0xffffffff;
	psd.PSFinalCombinerConstants = 0x000000ff;

	//------------- Stage 0 -------------
	// r0.rgb = c0.rgb
	psd.PSRGBInputs[0]	  = PS_COMBINERINPUTS( PS_REGISTER_C0 | PS_CHANNEL_RGB,
											   PS_REGISTER_ONE | PS_CHANNEL_RGB,
											   PS_REGISTER_ZERO | PS_CHANNEL_RGB,
											   PS_REGISTER_ZERO | PS_CHANNEL_RGB );

	psd.PSRGBOutputs[0]   = PS_COMBINEROUTPUTS( PS_REGISTER_R0,
												PS_REGISTER_DISCARD,
												PS_REGISTER_DISCARD,
												0 );

	// r0.a = c0.a
	psd.PSAlphaInputs[0]  = PS_COMBINERINPUTS( PS_REGISTER_C0 | PS_CHANNEL_ALPHA,
											   PS_REGISTER_ONE | PS_CHANNEL_ALPHA,
											   PS_REGISTER_ZERO | PS_CHANNEL_ALPHA,
											   PS_REGISTER_ZERO | PS_CHANNEL_ALPHA );

	psd.PSAlphaOutputs[0] = PS_COMBINEROUTPUTS( PS_REGISTER_R0,
												PS_REGISTER_DISCARD,
												PS_REGISTER_DISCARD,
												0 );

	psd.PSConstant0[0] = 0xffffffff;

	//------------- Final combiner -------------
	psd.PSFinalCombinerInputsABCD = PS_COMBINERINPUTS( PS_REGISTER_ZERO	| PS_CHANNEL_RGB,
													   PS_REGISTER_ZERO | PS_CHANNEL_RGB,
													   PS_REGISTER_ZERO	| PS_CHANNEL_RGB,
													   PS_REGISTER_R0   | PS_CHANNEL_RGB );

	psd.PSFinalCombinerInputsEFG = PS_COMBINERINPUTS( PS_REGISTER_ZERO | PS_CHANNEL_RGB,
													  PS_REGISTER_ZERO | PS_CHANNEL_RGB,
													  PS_REGISTER_R0   | PS_CHANNEL_ALPHA,
													  0 );

	memcpy( &m_ConstantPixelShader, &psd, sizeof(D3DPIXELSHADERDEF) );

	// Make version that uses z-replace.
	psd.PSTextureModes	= PS_TEXTUREMODES( PS_TEXTUREMODES_PROJECT3D, PS_TEXTUREMODES_DOTPRODUCT,
										   PS_TEXTUREMODES_DOT_ZW, PS_TEXTUREMODES_NONE );

    psd.PSInputTexture  = PS_INPUTTEXTURE( 0, 0, 0, 0 );


    psd.PSDotMapping    = PS_DOTMAPPING( 0, PS_DOTMAPPING_HILO_1, PS_DOTMAPPING_HILO_1, 0 );

	memcpy( &m_ZRConstantPixelShader, &psd, sizeof(D3DPIXELSHADERDEF) );

	return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CreateBuffers()
// Desc:
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::CreateBuffers()
{
	// Create and tile z buffers.
	for( int i = 0; i < MAX_LAYERS-1; i++ )
	{
		m_pd3dDevice->CreateTexture( 640, 480, 1, D3DUSAGE_RENDERTARGET, D3DFMT_LIN_D16, 0, &m_pDepthBuffer[i] );
	}

	return S_OK;
}




//-----------------------------------------------------------------------------
// Name: RenderScene()
// Desc:
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::RenderScene()
{
	// Set up the light
	D3DLIGHT8 light;
	XBUtil_InitLight( light, D3DLIGHT_DIRECTIONAL, 0.7071067f, 0.7071067f, 0.0f );
	m_pd3dDevice->SetLight( 0, &light );
	m_pd3dDevice->LightEnable( 0, TRUE );

	m_pd3dDevice->SetRenderState( D3DRS_AMBIENT, 0x00555555 );

	// Draw the room.
	m_Room.Render( m_pd3dDevice );

	return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Sets up render states, clears the viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
	double tot_elapsed = 0.0f;
	double num_counts = 0.0f;

	// Clear the viewport, zbuffer, and stencil buffer
	m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,
						 0xff1f1f7f, 1.0f, 0L );

	// Set up misc render states
	m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_CCW );
	m_pd3dDevice->SetRenderState( D3DRS_DITHERENABLE, TRUE );
	m_pd3dDevice->SetRenderState( D3DRS_SPECULARENABLE, FALSE );
	m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
	m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE, FALSE );
	m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, D3DZB_TRUE );

	// Note: Z less is necessary.
	m_pd3dDevice->SetRenderState( D3DRS_ZFUNC, D3DCMP_LESS );

	// Render the opaque parts of the scene normally.
	RenderScene();

	for( int i = 0; i < 4; i++ )
		m_pd3dDevice->SetTexture( i, 0 );

	if( m_bUseDepthPeeling )
	{
		// Now setup to do depth peeling.
		m_pd3dDevice->SetVertexShader( m_dwAlphaVertexShader );

		if( m_bUseDotZW )
			m_pd3dDevice->SetPixelShaderProgram( &m_ZRConstantPixelShader );
		else
			m_pd3dDevice->SetPixelShaderProgram( &m_ConstantPixelShader );

		m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
		m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );
		m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_POINT );
		m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_POINT );

		// Calculate and set composite matrix and texture matrix.
		D3DXMATRIX matComposite;
		D3DXMatrixMultiply( &matComposite, &m_matWorld, &m_matView );
		D3DXMatrixMultiply( &matComposite, &matComposite, &m_matProjection );
		D3DXMatrixTranspose( &matComposite, &matComposite );
		m_pd3dDevice->SetVertexShaderConstant( 0, &matComposite, 4 );

		D3DXVECTOR4 v4Scale(640.0f * 0.5f, -480.0f * 0.5f, float(D3DZ_MAX_D16), 1.0f);
		D3DXVECTOR4 v4Offset(640.0f * 0.5f + 0.5f, 480.0f * 0.5f + 0.5f, float(-0.00002f * D3DZ_MAX_D16), 0.0f);
		m_pd3dDevice->SetVertexShaderConstant( 4, &v4Scale, 1 );
		m_pd3dDevice->SetVertexShaderConstant( 5, &v4Offset, 1 );

		// Alpha objects are double sided.
		m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );

		// Disable color writes.
		m_pd3dDevice->SetRenderState( D3DRS_COLORWRITEENABLE, 0 );

		if( m_bUseDotZW )
		{
			float fConstants[4] = { 0.0f, 0.0f, 0.0f, 1.0f };
			m_pd3dDevice->SetVertexShaderConstant( 6, fConstants, 1 );

			m_pd3dDevice->SetTexture( 0, m_pDepthBuffer[0] );
			m_pd3dDevice->SetTexture( 2, m_pDummyTexture );
		}

		// Compute z values for first n-1 layers.
		for( int i = 0; i < m_iNumLayers-1; i++ )
		{
			// Switch to z-buffer for this layer.
			IDirect3DSurface8* pDepthSurf;
			m_pDepthBuffer[i]->GetSurfaceLevel( 0, &pDepthSurf );
			m_pd3dDevice->SetRenderTarget( NULL, pDepthSurf );
			pDepthSurf->Release();

			// Clear the z buffer.
			m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL, 0, 1.0f, 0L );

			// Only use shadow texture to peel off layers after the first pass.
			if (i > 0)
			{
				// Use previous buffer as shadowbuffer texture.
				m_pd3dDevice->SetTexture( 0, m_pDepthBuffer[i-1] );

				// Keep pixels where (Buffer Z < Coordinate Z)
				m_pd3dDevice->SetRenderState( D3DRS_SHADOWFUNC, D3DCMP_LESS );
				m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAKILL, D3DTALPHAKILL_ENABLE );

				if( m_bUseDotZW )
					m_pd3dDevice->SetPixelShaderProgram( &m_ZRPeelPixelShader );
				else
					m_pd3dDevice->SetPixelShaderProgram( &m_PeelPixelShader );
			}

			// Draw any alpha blended parts of the scene (roughly front to back).
			m_AlphaVolume.Render( m_pd3dDevice, XBMESH_NOFVF | XBMESH_NOTEXTURES | XBMESH_NOMATERIALS );
		}

		// Turn on alpha blending.
		m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
		m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA );
		m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA );

		// Enable color writes.
		m_pd3dDevice->SetRenderState( D3DRS_COLORWRITEENABLE, D3DCOLORWRITEENABLE_ALL );

		// Restore regular z buffer.
		m_pd3dDevice->SetRenderTarget( NULL, m_pZBuffer );

		if( m_bUseDotZW )
		{
			// Disable z writes.
			m_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE, FALSE );

			// Make sure alpha kill is on.
			m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAKILL, D3DTALPHAKILL_ENABLE );

			// and shader is selected.
			m_pd3dDevice->SetPixelShaderProgram( &m_PeelPixelShader );

			// Blend in alpha values back to front.
			for( int i = m_iNumLayers-1; i >= 0; i-- )
			{
				if( i == m_iNumLayers-1 )
				{
					// Switch to depth texture for this layer.
					m_pd3dDevice->SetTexture( 0, m_pDepthBuffer[i-1] );

					// Keep pixels where (Buffer Z < Coordinate Z)
					m_pd3dDevice->SetRenderState( D3DRS_SHADOWFUNC, D3DCMP_LESS );
				}
				else
				{	
					// Switch to depth texture for this layer.
					m_pd3dDevice->SetTexture( 0, m_pDepthBuffer[i] );

					// Keep pixels where (Buffer Z == Coordinate Z)
					m_pd3dDevice->SetRenderState( D3DRS_SHADOWFUNC, D3DCMP_EQUAL );
				}

				if( m_iDrawLayer != -1 )
				{
					// Disable drawing to all but one layer for debugging.
					if( i != m_iDrawLayer )
						m_pd3dDevice->SetRenderState( D3DRS_COLORWRITEENABLE, 0 );
					else
						m_pd3dDevice->SetRenderState( D3DRS_COLORWRITEENABLE, D3DCOLORWRITEENABLE_ALL );
				}

				// Draw any alpha blended parts of the scene (roughly back to front).
				m_AlphaVolume.Render( m_pd3dDevice, XBMESH_NOFVF | XBMESH_NOTEXTURES | XBMESH_NOMATERIALS );
			}
		}
		else
		{
			// Blend in alpha values back to front.
			for( int i = m_iNumLayers-1; i >= 0; i-- )
			{
				if( i > 0 )
				{
					// Change to the appropriate depth texture.
					m_pd3dDevice->SetTexture( 0, m_pDepthBuffer[i-1] );

					// Keep any pixels where (Buffer Z < Coordinate Z)
					m_pd3dDevice->SetRenderState( D3DRS_SHADOWFUNC, D3DCMP_LESS );
					m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAKILL, D3DTALPHAKILL_ENABLE );

					m_pd3dDevice->SetPixelShaderProgram( &m_PeelPixelShader );
				}
				else
				{	
					// Switch off depth peeling.
					m_pd3dDevice->SetPixelShaderProgram( &m_ConstantPixelShader );
					m_pd3dDevice->SetTexture( 0, NULL );
					m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAKILL, D3DTALPHAKILL_DISABLE );
				}
				
				if( m_iDrawLayer != -1 )
				{
					// Disable drawing to all but one layer for debugging.
					if( i != m_iDrawLayer )
						m_pd3dDevice->SetRenderState( D3DRS_COLORWRITEENABLE, 0 );
					else
						m_pd3dDevice->SetRenderState( D3DRS_COLORWRITEENABLE, D3DCOLORWRITEENABLE_ALL );
				}

#if (FARTHEST_LAYER_SEPERATE_Z)
				if( i == m_iNumLayers-1 )
				{
					// Blend color values.
					m_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE, FALSE );

					// Draw any alpha blended parts of the scene (roughly back to front).
					m_AlphaVolume.Render( m_pd3dDevice, XBMESH_NOFVF | XBMESH_NOTEXTURES | XBMESH_NOMATERIALS );

					// Then write z values.
					m_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE, TRUE );
					m_pd3dDevice->SetRenderState( D3DRS_COLORWRITEENABLE, 0 );

					// Draw any alpha blended parts of the scene.
					m_AlphaVolume.Render( m_pd3dDevice, XBMESH_NOFVF | XBMESH_NOTEXTURES | XBMESH_NOMATERIALS );

					m_pd3dDevice->SetRenderState( D3DRS_COLORWRITEENABLE, D3DCOLORWRITEENABLE_ALL );
				}
				else
				{
					// Draw any alpha blended parts of the scene (roughly back to front).
					m_AlphaVolume.Render( m_pd3dDevice, XBMESH_NOFVF | XBMESH_NOTEXTURES | XBMESH_NOMATERIALS );
				}
#else
				// Draw any alpha blended parts of the scene (roughly back to front).
				m_AlphaVolume.Render( m_pd3dDevice, XBMESH_NOFVF | XBMESH_NOTEXTURES | XBMESH_NOMATERIALS );
#endif
			}
		}

		if (m_iDrawLayer != -1)
			m_pd3dDevice->SetRenderState( D3DRS_COLORWRITEENABLE, D3DCOLORWRITEENABLE_ALL );
	}
	else
	{
		// Use constant alpha blend.
		m_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE, FALSE );
		m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );

		// Turn on alpha blending.
		m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
		m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA );
		m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA );

		// Use our constant alpha pixel shader.
		m_pd3dDevice->SetPixelShaderProgram( &m_ConstantPixelShader );

		// Draw any alpha blended parts of the scene.
		m_AlphaVolume.Render( m_pd3dDevice, XBMESH_NOTEXTURES | XBMESH_NOMATERIALS );
	}	

	// Restore state.
	m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAKILL, D3DTALPHAKILL_DISABLE );
	m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_CCW );
	m_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE, TRUE );
	m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
	m_pd3dDevice->SetPixelShader( NULL );

	// Show title, frame rate, and help
	if( m_bDrawHelp )
	{
		m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
	}
	else
	{
		if( m_bUseDepthPeeling )
		{
			if( m_iDrawLayer != -1 )
			{
				WCHAR buf[80];
				swprintf( buf, L"Layer = %d", m_iDrawLayer+1 );
				m_Font.DrawText( 64, 70, 0xffffffff, buf );
			}
			else
			{
				WCHAR buf[80];
				swprintf( buf, L"NumLayers = %d", m_iNumLayers );
				m_Font.DrawText( 64, 70, 0xffffffff, buf );
			}

			if( m_bUseDotZW )
			{
				m_Font.DrawText( 280, 70, 0xffffffff, L"Depth Replace" );
			}
		}
		else
		{
			m_Font.DrawText( 64, 70, 0xffffffff, L"Incorrect Blending" );
		}

		// Show frame rate
		m_Font.DrawText(  64, 50, 0xffffffff, L"NoSortAlphaBlend" );
		m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );
	}

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Notifier\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\PaintEffect\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\PaintEffect\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\PaintEffect\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Notifier\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 3UL

#define resource_Floor_OFFSET 0UL
#define resource_BiHull_OFFSET 20UL
#define resource_Wings_OFFSET 40UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\PaintEffect\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Notifier\obj\i386\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 3UL

#define resource_Floor_OFFSET 0UL
#define resource_BiHull_OFFSET 20UL
#define resource_Wings_OFFSET 40UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\PaintEffect\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\patch\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\patch\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\patch\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\PaintEffect\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 5UL

#define resource_Texture0_OFFSET 0UL
#define resource_Texture1_OFFSET 20UL
#define resource_Checker_OFFSET 40UL
#define resource_Stroke_OFFSET 60UL
#define resource_StrokeCoffee_OFFSET 80UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\PaintEffect\PaintEffect.cpp ===
//-----------------------------------------------------------------------------
// File: PaintEffect.cpp
//
// Desc: Full screen paint effect
//
// Hist: 10.26.01 - Created
//
// Copyright (c) 2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <xgraphics.h>
#include "resource.h"

//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_1, L"Display help" },
    { XBHELP_START_BUTTON, XBHELP_PLACEMENT_1, L"Pause" },
    { XBHELP_A_BUTTON,     XBHELP_PLACEMENT_2, L"Toggle\nRaw Pixels" },
    { XBHELP_X_BUTTON,     XBHELP_PLACEMENT_2, L"Toggle\nStroke Texture" },
    { XBHELP_Y_BUTTON,     XBHELP_PLACEMENT_2, L"Toggle\nFixed-Sized Strokes" },
    { XBHELP_WHITE_BUTTON, XBHELP_PLACEMENT_2, L"Toggle\nWhite Paper" },
    { XBHELP_DPAD,         XBHELP_PLACEMENT_2, L"Select Parameter" },
    { XBHELP_LEFTSTICK,    XBHELP_PLACEMENT_2, L"Move\nCamera" },
    { XBHELP_RIGHTSTICK,   XBHELP_PLACEMENT_2, L"Rotate\nCamera" },
    { XBHELP_MISC_CALLOUT, XBHELP_PLACEMENT_2, L"Triggers Tweak\nCurrent Parameter" },
    { XBHELP_LEFT_BUTTON,  XBHELP_PLACEMENT_2, L"Decrease\nParameter" },
    { XBHELP_RIGHT_BUTTON, XBHELP_PLACEMENT_2, L"Increase\nParameter" },
};

#define NUM_HELP_CALLOUTS ( sizeof( g_HelpCallouts ) / sizeof( g_HelpCallouts[0] ) )


//-----------------------------------------------------------------------------
// Name: struct PAINTVERTEX
// Desc: vertex structure used for rendering texture as pointsprites
//-----------------------------------------------------------------------------
struct PAINTVERTEX {
    D3DXVECTOR4 Position;   // screen space position
};

//-----------------------------------------------------------------------------
// Name: struct STROKEVERTEX
// Desc: Per-vertex parameters to give random variation to the stroke.
//       These could be attached to the model as a texture instead and
//       rendered into a separate buffer.
//-----------------------------------------------------------------------------
struct STROKEVERTEX {
    FLOAT PointSize;
};


//-----------------------------------------------------------------------------
// Name: class CPaint
// Desc: draws a texture as pointsprites to create a painted look
//-----------------------------------------------------------------------------
class CPaint {
public:
    LPDIRECT3DTEXTURE8 m_pPaintTexture; // render target for scene, source for point sprites colors
    LPDIRECT3DSURFACE8 m_pPaintSurface; // most detailed texture level
    D3DVertexBuffer m_ColorVertexBuffer;    // fake vertex buffer that uses a pointer to the texture data
    LPDIRECT3DSURFACE8 m_pPaintDepthBuffer; // depth buffer that's the same size as m_pPaintSurface
#define CENTERCOUNT 37
    LPDIRECT3DVERTEXBUFFER8 m_rpPaintVertexBuffer[CENTERCOUNT]; // vertex buffer that maps to centers of strokes
    DWORD m_iPaintVertexBuffer; // current paint vertex buffer, for randomly moving centers
#define STROKECOUNT 11  // make this relatively prime to CENTERCOUNT for maximal variation
    LPDIRECT3DVERTEXBUFFER8 m_rpStrokeVertexBuffer[STROKECOUNT];    // vertex buffer that maps to centers of strokes
    DWORD m_iStrokeVertexBuffer; // current stroke vertex buffer, for randomly moving stroke attributes
    LPDIRECT3DTEXTURE8 m_pStrokeTexture;    // texture for drawing strokes
    DWORD m_dwVertexShader;
    DWORD m_Width, m_Height;
    DWORD m_ScreenWidth, m_ScreenHeight;
    BOOL m_bStrokeSizePerVertex;    // use per-vertex PointSize, otherwise use 0.5f * m_fPointSizeScale + m_fPointSizeOffset
    FLOAT m_fPointSizeOffset;
    FLOAT m_fPointSizeScale;

    CPaint()
    {
        m_pPaintTexture = NULL;
        m_pPaintSurface = NULL;
        m_pPaintDepthBuffer = NULL;
        ZeroMemory(m_rpPaintVertexBuffer, sizeof(m_rpPaintVertexBuffer));
        m_iPaintVertexBuffer = 0;
        ZeroMemory(m_rpStrokeVertexBuffer, sizeof(m_rpStrokeVertexBuffer));
        m_iStrokeVertexBuffer = 0;
        m_pStrokeTexture = NULL;
        m_dwVertexShader = 0;
        m_bStrokeSizePerVertex = true;
    }

    ~CPaint()
    {
        SAFE_RELEASE(m_pPaintTexture);
        SAFE_RELEASE(m_pPaintSurface);
        SAFE_RELEASE(m_pPaintDepthBuffer);
        for (DWORD iPaintVB = 0; iPaintVB < CENTERCOUNT; iPaintVB++)
            SAFE_RELEASE(m_rpPaintVertexBuffer[iPaintVB]);
        for (DWORD iStrokeVB = 0; iStrokeVB < STROKECOUNT; iStrokeVB++)
            SAFE_RELEASE(m_rpPaintVertexBuffer[iStrokeVB]);
        SAFE_RELEASE(m_pStrokeTexture);
        if (m_dwVertexShader)
            g_pd3dDevice->DeleteVertexShader(m_dwVertexShader);
    }

    HRESULT SetStrokeTexture(LPDIRECT3DTEXTURE8 pStrokeTexture)
    {
        LPDIRECT3DTEXTURE8 pStrokeTextureOld = m_pStrokeTexture;
        m_pStrokeTexture = pStrokeTexture;
        m_pStrokeTexture->AddRef();
        SAFE_RELEASE(pStrokeTextureOld);
        return S_OK;
    }

    HRESULT Initialize(UINT Width, UINT Height, LPDIRECT3DTEXTURE8 pStrokeTexture, UINT ScreenWidth, UINT ScreenHeight)
    {
        HRESULT hr;
        m_Width = Width;
        m_Height = Height;
        m_ScreenWidth = ScreenWidth;
        m_ScreenHeight = ScreenHeight;
        
        // Create the paint texture and get a pointer to the main surface image
        D3DFORMAT Format = D3DFMT_A8R8G8B8; // must use swizzled format texture, otherwise memory may have a stride
        SAFE_RELEASE(m_pPaintSurface);
        SAFE_RELEASE(m_pPaintTexture);
        hr = g_pd3dDevice->CreateTexture(Width, Height, 1, D3DUSAGE_RENDERTARGET, Format, 0, &m_pPaintTexture);
        if (FAILED(hr))
            return hr;
        hr = m_pPaintTexture->GetSurfaceLevel(0, &m_pPaintSurface);
        if (FAILED(hr))
            return hr;
        
        // make a depth buffer that is the same size as the texture
        SAFE_RELEASE(m_pPaintDepthBuffer);
        hr = g_pd3dDevice->CreateDepthStencilSurface(Width, Height, D3DFMT_LIN_D24S8, D3DMULTISAMPLE_NONE, &m_pPaintDepthBuffer);
        if (FAILED(hr))
            return hr;

        // Make a fake vertex buffer header that points to the texture data
        ZeroMemory( &m_ColorVertexBuffer, sizeof(D3DVertexBuffer) );
        XGSetVertexBufferHeader( Width * Height * 4, 0, D3DFVF_DIFFUSE, 0, &m_ColorVertexBuffer, m_pPaintSurface->Data);

        // Fill in the vertex buffer with output pixel offsets, accounting for
        // swizzling of the source paint texture
        FLOAT fXScale = (FLOAT)ScreenWidth / (FLOAT)Width;
        FLOAT fYScale = (FLOAT)ScreenHeight / (FLOAT)Height;
        FLOAT fXOffset = 0.f;
        FLOAT fYOffset = 0.f;
        Swizzler s(Width, Height, 0);
        UINT iVB;
        for (iVB = 0; iVB < CENTERCOUNT; iVB++)
        {
            // Create a vertex buffer that matches the paint texture size on input and maps to the screen on output
            SAFE_RELEASE(m_rpPaintVertexBuffer[iVB]);
            hr = g_pd3dDevice->CreateVertexBuffer( Width * Height * sizeof(PAINTVERTEX), 0, 0, D3DPOOL_DEFAULT, &m_rpPaintVertexBuffer[iVB]);
            if (FAILED(hr))
                return hr;
#define frand(a) ((FLOAT)rand()*(a)/32768.0f)

            PAINTVERTEX *pv;
            hr = m_rpPaintVertexBuffer[iVB]->Lock( 0, 0, (BYTE**)&pv, 0 );
            if (FAILED(hr))
                return E_FAIL;
            s.SetV(s.SwizzleV(0));
            s.SetU(s.SwizzleU(0));
            for (UINT iy = 0; iy < Height; iy++)
            {
                for (UINT ix = 0; ix < Width; ix++)
                {
                    UINT TexelOffset = s.Get2D();
                    PAINTVERTEX *p = pv + TexelOffset;
                    p->Position.x = fXScale * (ix + frand(1.f)) + fXOffset;
                    p->Position.y = fYScale * (iy + frand(1.f)) + fYOffset;
                    p->Position.z = 0.5f;
                    p->Position.w = 1.f;
                    s.IncU();
                }
                s.IncV();
            }
            m_rpPaintVertexBuffer[iVB]->Unlock();
        }

        // Set point scale and offset
        m_fPointSizeScale = 1.75f * 0.5f * (fXScale + fYScale);
        m_fPointSizeOffset = 0.25f * m_fPointSizeScale;

        // Fill in vertex buffers with stroke attributes
        for (iVB = 0; iVB < STROKECOUNT; iVB++)
        {
            // Create a vertex buffer that matches the paint texture size on input and maps to stroke attributes
            SAFE_RELEASE(m_rpStrokeVertexBuffer[iVB]);
            hr = g_pd3dDevice->CreateVertexBuffer( Width * Height * sizeof(STROKEVERTEX), 0, 0, D3DPOOL_DEFAULT, &m_rpStrokeVertexBuffer[iVB]);
            if (FAILED(hr))
                return hr;

            // Fill in the vertex buffer with output pixel offsets, accounting for
            // swizzling of the source stroke texture
            STROKEVERTEX *psv;
            hr = m_rpStrokeVertexBuffer[iVB]->Lock( 0, 0, (BYTE**)&psv, 0 );
            if (FAILED(hr))
                return E_FAIL;
            s.SetV(s.SwizzleV(0));
            s.SetU(s.SwizzleU(0));
            for (UINT iy = 0; iy < Height; iy++)
            {
                for (UINT ix = 0; ix < Width; ix++)
                {
                    UINT TexelOffset = s.Get2D();
                    STROKEVERTEX *p = psv + TexelOffset;
                    p->PointSize = frand(1.f);
                    s.IncU();
                }
                s.IncV();
            }
            m_rpStrokeVertexBuffer[iVB]->Unlock();
        }
        
        // Copy the stroke texture pointer
        SetStrokeTexture(pStrokeTexture);

        // Create the vertex shader
        if (m_dwVertexShader)
            g_pd3dDevice->DeleteVertexShader(m_dwVertexShader);
        DWORD vsdecl[] = 
        {
            D3DVSD_STREAM(0),
            D3DVSD_REG(0, D3DVSDT_FLOAT4),      // vertex
            D3DVSD_STREAM(1),
            D3DVSD_REG(1, D3DVSDT_D3DCOLOR),    // color
            D3DVSD_STREAM(2),
            D3DVSD_REG(2, D3DVSDT_FLOAT1),      // texture W coord
            D3DVSD_REG(3, D3DVSDT_FLOAT1),      // scale
            D3DVSD_END()
        };
        XBUtil_CreateVertexShader(g_pd3dDevice, "Shaders\\paint.xvu", vsdecl, &m_dwVertexShader );
        if (m_dwVertexShader == 0)
            return E_FAIL;
                
        return S_OK;
    }
    
    //-----------------------------------------------------------------------------
    // Name: DrawPointSprites
    // Desc:  
    //-----------------------------------------------------------------------------
    HRESULT DrawPointSprites()
    {
        // Set the render states for using point sprites. 
        // Note that pointsprites use texture stage 3 only.
        g_pd3dDevice->SetPixelShader( 0 );
        g_pd3dDevice->SetTexture( 0, NULL );
        g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
        g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_DIFFUSE );
        g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1 );
        g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_DIFFUSE );
        g_pd3dDevice->SetTexture( 1, NULL );
        g_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
        g_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLORARG1, D3DTA_CURRENT );
        g_pd3dDevice->SetTextureStageState( 1, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1 );
        g_pd3dDevice->SetTextureStageState( 1, D3DTSS_ALPHAARG1, D3DTA_CURRENT );
        g_pd3dDevice->SetTexture( 2, NULL );
        g_pd3dDevice->SetTextureStageState( 2, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
        g_pd3dDevice->SetTextureStageState( 2, D3DTSS_COLORARG1, D3DTA_CURRENT );
        g_pd3dDevice->SetTextureStageState( 2, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1 );
        g_pd3dDevice->SetTextureStageState( 2, D3DTSS_ALPHAARG1, D3DTA_CURRENT );

        g_pd3dDevice->SetTexture( 3, m_pStrokeTexture );
        static DWORD dwColorOp = D3DTOP_MODULATE;
        static DWORD dwColorArg1 = D3DTA_TEXTURE;
        static DWORD dwColorArg2 = D3DTA_CURRENT;
        g_pd3dDevice->SetTextureStageState( 3, D3DTSS_COLOROP,   dwColorOp );
        g_pd3dDevice->SetTextureStageState( 3, D3DTSS_COLORARG1, dwColorArg1 );
        g_pd3dDevice->SetTextureStageState( 3, D3DTSS_COLORARG2, dwColorArg2 );
        g_pd3dDevice->SetTextureStageState( 3, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
        g_pd3dDevice->SetTextureStageState( 3, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
        g_pd3dDevice->SetTextureStageState( 3, D3DTSS_ALPHAARG2, D3DTA_TFACTOR );
        
        static D3DCOLOR TFACTOR = 0xffffffff;
        g_pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, TFACTOR );
        
        g_pd3dDevice->SetRenderState( D3DRS_ZENABLE, FALSE );
        g_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE, FALSE );
        g_pd3dDevice->SetRenderState( D3DRS_LIGHTING,  FALSE );
    
        // Turn on alphablending
        g_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
        g_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,         D3DBLEND_ONE );
        g_pd3dDevice->SetRenderState( D3DRS_DESTBLEND,        D3DBLEND_INVSRCALPHA );
        g_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  TRUE );
        g_pd3dDevice->SetRenderState( D3DRS_ALPHAREF,         0x1 );
        g_pd3dDevice->SetRenderState( D3DRS_ALPHAFUNC,        D3DCMP_GREATEREQUAL );

        // Turn on point sprites
        g_pd3dDevice->SetVertexShader( m_dwVertexShader );
        D3DXVECTOR4 vPointSize(m_fPointSizeScale, m_fPointSizeOffset, 0.f, 0.f);
        g_pd3dDevice->SetVertexShaderConstant( 0, &vPointSize, 1 );
        g_pd3dDevice->SetRenderState( D3DRS_POINTSPRITEENABLE, TRUE );
        FLOAT fDefaultPointSize = m_fPointSizeScale * 0.5f + m_fPointSizeOffset;
        g_pd3dDevice->SetRenderState( D3DRS_POINTSIZE,         FtoDW(fDefaultPointSize) );
        g_pd3dDevice->SetRenderState( D3DRS_POINTSCALEENABLE,  m_bStrokeSizePerVertex );
        static FLOAT fA = 1.f;
        static FLOAT fB = 0.f;
        static FLOAT fC = 0.f;
        g_pd3dDevice->SetRenderState( D3DRS_POINTSCALE_A,      FtoDW(fA) );
        g_pd3dDevice->SetRenderState( D3DRS_POINTSCALE_B,      FtoDW(fB) );
        g_pd3dDevice->SetRenderState( D3DRS_POINTSCALE_C,      FtoDW(fC) );

        
        // Render particles
        g_pd3dDevice->SetStreamSource( 0, m_rpPaintVertexBuffer[m_iPaintVertexBuffer], sizeof(PAINTVERTEX));
        g_pd3dDevice->SetStreamSource( 1, &m_ColorVertexBuffer, sizeof(DWORD) );        // fake vertex buffer from texture
        g_pd3dDevice->SetStreamSource( 2, m_rpStrokeVertexBuffer[m_iStrokeVertexBuffer], sizeof(STROKEVERTEX));
        g_pd3dDevice->DrawPrimitive( D3DPT_POINTLIST, 0, m_Width * m_Height);   // lots of points
    
        // Reset render states
        g_pd3dDevice->SetTexture( 3, NULL );
        g_pd3dDevice->SetTextureStageState( 3, D3DTSS_COLOROP, D3DTOP_DISABLE );
        g_pd3dDevice->SetRenderState( D3DRS_POINTSPRITEENABLE, FALSE );
        g_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE,  FALSE );
        return S_OK;
    }
    
    //-----------------------------------------------------------------------------
    // Name: DrawQuad
    // Desc:  
    //-----------------------------------------------------------------------------
    HRESULT DrawQuad()
    {
        struct BACKGROUNDVERTEX { D3DXVECTOR4 p; FLOAT tu, tv; } v[4];
        v[0].p = D3DXVECTOR4( -0.5f,                -0.5f,                 1.f, 1.f ); v[0].tu = 0.f; v[0].tv = 0.f;
        v[1].p = D3DXVECTOR4( m_ScreenWidth - 0.5f, -0.5f,                 1.f, 1.f ); v[1].tu = 1.f; v[1].tv = 0.f;
        v[2].p = D3DXVECTOR4( -0.5f,                m_ScreenHeight - 0.5f, 1.f, 1.f ); v[2].tu = 0.f; v[2].tv = 1.f;
        v[3].p = D3DXVECTOR4( m_ScreenWidth - 0.5f, m_ScreenHeight - 0.5f, 1.f, 1.f ); v[3].tu = 1.f; v[3].tv = 1.f;
    
        // Set states
        g_pd3dDevice->SetPixelShader( 0 );
        g_pd3dDevice->SetTexture( 0, m_pPaintTexture );
        g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
        g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );
        g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_SELECTARG1 );
        static DWORD dwColorArg1 = D3DTA_TEXTURE;
        g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, dwColorArg1 );
        g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1 );
        g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TFACTOR );
        g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
        g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );
        static D3DCOLOR colorBlend = 0xffffffff;
        g_pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, colorBlend );
        g_pd3dDevice->SetRenderState( D3DRS_ZENABLE, FALSE ); 
        g_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE, FALSE ); 
        g_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE, FALSE );
        g_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
        g_pd3dDevice->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_ONE );
        g_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA );
        g_pd3dDevice->SetRenderState( D3DRS_FILLMODE, D3DFILL_SOLID);

        // Render the screen-aligned quadrilateral
        g_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_TEX1 );
        g_pd3dDevice->DrawPrimitiveUP( D3DPT_QUADSTRIP, 1, v, sizeof(BACKGROUNDVERTEX) );
        
        // Reset render states
        g_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
        g_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE, FALSE );
        g_pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE );
        g_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE, TRUE );
        g_pd3dDevice->SetTexture( 0, NULL );
        g_pd3dDevice->SetTexture( 1, NULL );
        g_pd3dDevice->SetPixelShader( 0 );
        
        return S_OK;
    }

};


//-----------------------------------------------------------------------------
// Vertex for cylinder drawing
//-----------------------------------------------------------------------------
struct CUSTOMVERTEX
{
    D3DXVECTOR3 position;   // The position
    D3DXVECTOR3 normal;     // The vertex normals
    FLOAT tu, tv;           // texture coords
};

// Our custom FVF, which describes our custom vertex structure
#define D3DFVF_CUSTOMVERTEX (D3DFVF_XYZ|D3DFVF_NORMAL|D3DFVF_TEX1)

//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
public:
    CXBPackedResource  m_xprResource;        // Packed resources for the app
    CXBFont     m_Font;             // Font object
    CXBHelp     m_Help;             // Help object
    BOOL        m_bDrawHelp;        // TRUE to draw help screen
    BOOL        m_bClearPaper;      // TRUE to clear the paper before drawing point sprites
    BOOL        m_bDrawQuad;        // TRUE to draw the paint texture full screen
    FLOAT       m_fTimeScale;       // Target animation frame rate
    enum {
        TWEAK_TIME_SCALE,			// adjust rate of stepping through random center position VB's
        TWEAK_STROKE_SIZE,			// adjust both stroke size offset and scale
        TWEAK_STROKE_SIZE_SCALE,	// adjust only stroke size scale
    } m_TweakMode;                  // tweak mode detrmines what triggers do
    FLOAT           m_TweakActive;      // tweaking in progess if > zero
    D3DXVECTOR3     m_vFrom, m_vAt, m_vUp;  // Viewing parameters
    D3DXMATRIX      m_matWorld;
    D3DXMATRIX      m_matView;
    D3DXMATRIX      m_matViewInverse;
    D3DXMATRIX      m_matProjection;

    // Generic scene
    D3DVertexBuffer *m_pCylinderVB; // Buffer for cylinder vertices, which is the basic object
    UINT m_nObjectCount;
    struct Object {                 // put a few objects around in the scene
        D3DXVECTOR3 m_vPosition;
        D3DXCOLOR m_color;
        UINT m_iTexture;            // texture index
    } *m_rObjects;
#define TEXTURE_COUNT 3
    D3DTexture *m_rpTexture[TEXTURE_COUNT]; // object textures

    // Paint effect
    CPaint m_Paint;

    // Constructor
    CXBoxSample();

    // Overrides of XBApp virtuals
    virtual HRESULT Initialize();
    virtual HRESULT Render();
    virtual HRESULT FrameMove();

    // Helpers
    HRESULT SetCameraTransformations();
    HRESULT RenderToPaintTexture();
};



//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}



//-----------------------------------------------------------------------------
// Name: CXBoxSample (constructor)
// Desc: Constructor for CXBoxSample class
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample() 
            :CXBApplication()
{
#ifdef _DEBUG
    m_d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;    // Allow unlimited frame rate
#endif
    m_bDrawHelp = FALSE;
    m_bClearPaper = FALSE;
    m_bDrawQuad = FALSE;
    m_fTimeScale = 12.f; // Target animation frame rate
    m_TweakMode = TWEAK_STROKE_SIZE;
    m_TweakActive = 0.f;
}



//-----------------------------------------------------------------------------
// Name: Initialize
// Desc: Peforms initialization
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    HRESULT hr;

    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the resources
    if( FAILED( m_xprResource.Create( m_pd3dDevice, "Resource.xpr", resource_NUM_RESOURCES, NULL ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Get the texture pointers
    m_rpTexture[0] = m_xprResource.GetTexture( resource_Texture0_OFFSET );
    m_rpTexture[1] = m_xprResource.GetTexture( resource_Texture1_OFFSET );
    m_rpTexture[2] = m_xprResource.GetTexture( resource_Checker_OFFSET );

    // Initialize the Paint effect
    srand(0x123456);
    LPDIRECT3DTEXTURE8 pStrokeTexture = m_xprResource.GetTexture( resource_Stroke_OFFSET );
    hr = m_Paint.Initialize(64, 64, pStrokeTexture, m_d3dpp.BackBufferWidth, m_d3dpp.BackBufferHeight);
    if (FAILED(hr))
        return hr;
    
    // Create geometry for a cylinder
#define NSAMPLE 25
   if( FAILED( m_pd3dDevice->CreateVertexBuffer( NSAMPLE*2*sizeof(CUSTOMVERTEX),
                                                  0, D3DFVF_CUSTOMVERTEX,
                                                  D3DPOOL_DEFAULT, &m_pCylinderVB ) ) )
        return E_FAIL;
   
    // Fill the vertex buffer. We are setting the tu and tv texture
    // coordinates, which range from 0.0 to 1.0
    CUSTOMVERTEX* v;
    if( FAILED( m_pCylinderVB->Lock( 0, 0, (BYTE**)&v, 0 ) ) )
        return E_FAIL;
    for(UINT i=0; i<NSAMPLE; i++ )
    {
        FLOAT theta = (2*D3DX_PI*i)/(NSAMPLE-1);

        v[2*i+0].position = D3DXVECTOR3( sinf(theta),-1.2f, cosf(theta) );
        v[2*i+0].normal   = D3DXVECTOR3( sinf(theta), 0.0f, cosf(theta) );
        v[2*i+0].tu = ((FLOAT)i*2.0f)/(NSAMPLE-1);
        v[2*i+0].tv = 1.0f;
        
        v[2*i+1].position = D3DXVECTOR3( sinf(theta), 1.2f, cosf(theta) );
        v[2*i+1].normal   = D3DXVECTOR3( sinf(theta), 0.0f, cosf(theta) );
        v[2*i+1].tu = ((FLOAT)i*2.0f)/(NSAMPLE-1);
        v[2*i+1].tv = 0.0f;
    }
    m_pCylinderVB->Unlock();

    // Position the objects
    m_nObjectCount = 100;
    m_rObjects = new Object [ m_nObjectCount ];
    if (m_rObjects == NULL)
        return E_OUTOFMEMORY;
#define irand(a) ((rand()*(a))>>15)
#define frand(a) ((FLOAT)rand()*(a)/32768.0f)
    FLOAT fScale = 100.f;
    srand(123456);
    for (UINT i = 0; i < m_nObjectCount; i++)
    {
        m_rObjects[i].m_vPosition = D3DXVECTOR3( frand(fScale), 0.f, frand(fScale));
        m_rObjects[i].m_color = D3DXCOLOR( frand(1.f), frand(1.f), frand(1.f), 1.f);
        m_rObjects[i].m_iTexture = irand(TEXTURE_COUNT);
    }
    
    // Set camera parameters and initialize camera matrices
    m_vAt = m_rObjects[0].m_vPosition;
    m_vFrom = m_vAt - D3DXVECTOR3(8.f, -0.1f, 0.f);
    m_vUp = D3DXVECTOR3( 0.0f, 1.0f , 0.0f);
    SetCameraTransformations();

    // Setup the light
    D3DLIGHT8 light;
    ZeroMemory( &light, sizeof(D3DLIGHT8) );
    light.Type         = D3DLIGHT_DIRECTIONAL;
    light.Ambient      = D3DXCOLOR(0.3f, 0.3f, 0.3f, 1.f);
    light.Diffuse      = D3DXCOLOR(1.f, 1.f, 1.f, 1.f);
    light.Direction    = D3DXVECTOR3( 1.f, 1.f, 1.f );
    light.Range        = 1000.0f;
    light.Attenuation0 = 1.0f;
    g_pd3dDevice->SetLight( 0, &light );
    g_pd3dDevice->LightEnable( 0, TRUE );

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: SetCameraTransformations()
// Desc: Calculate camera matrices and set transformation state
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::SetCameraTransformations()
{
    // Set world matrix to identity
    D3DXMatrixIdentity(&m_matWorld);
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &m_matWorld );
    
    // Set our view matrix.
    D3DXMatrixLookAtLH( &m_matView, &m_vFrom, &m_vAt, &m_vUp);
    D3DXMatrixInverse( &m_matViewInverse, NULL, &m_matView);
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &m_matView );

    // Set projection 
    static FLOAT fNear = 1.f;
    static FLOAT fFar = 50.f;
    D3DXMatrixPerspectiveFovLH( &m_matProjection, D3DX_PI/4, 640.f / 480.f, fNear, fFar);
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &m_matProjection );

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: FrameMove
// Desc: Performs per-frame updates
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK ) 
    {
        m_bDrawHelp = !m_bDrawHelp;
    }

    // Toggle quad drawing to show raw pixels or painterly effect
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_A] )
    {
        m_bDrawQuad = !m_bDrawQuad;
    }

    // Switch to next stroke texture
    if (m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_X])
    {
        static UINT rStrokeOffset[] = {
            resource_Stroke_OFFSET,
            resource_StrokeCoffee_OFFSET,
        };
        static UINT nStrokeCount = sizeof(rStrokeOffset) / sizeof(UINT);
        
        // find current stroke texture
        UINT iStroke;
        for (iStroke = 0; iStroke < nStrokeCount; iStroke++)
            if (m_Paint.m_pStrokeTexture == m_xprResource.GetTexture( rStrokeOffset[iStroke] ))
                break;
        
        // go to next
        if (iStroke >= nStrokeCount - 1)
            iStroke = 0;
        else
            iStroke++;
        m_Paint.SetStrokeTexture( m_xprResource.GetTexture( rStrokeOffset[iStroke] ));
    }

    // Toggle paper clearing
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_WHITE] )
    {
        m_bClearPaper = !m_bClearPaper;
    }

    // Toggle stroke size per vertex
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_Y] )
    {
        m_Paint.m_bStrokeSizePerVertex = !m_Paint.m_bStrokeSizePerVertex;
        
        // Set tweak mode according to new stroke-size per vertex setting
        if (m_Paint.m_bStrokeSizePerVertex)
            m_TweakMode = TWEAK_STROKE_SIZE_SCALE;
        else
            m_TweakMode = TWEAK_STROKE_SIZE;
        m_TweakActive = 2.f;
    }

    // Set tweak parameter
    if ( m_DefaultGamepad.wButtons & XINPUT_GAMEPAD_DPAD_UP 
         || m_DefaultGamepad.wButtons & XINPUT_GAMEPAD_DPAD_DOWN 
         || m_DefaultGamepad.wButtons & XINPUT_GAMEPAD_DPAD_LEFT 
         || m_DefaultGamepad.wButtons & XINPUT_GAMEPAD_DPAD_RIGHT )
        m_TweakActive = 2.f; // show tweak display when DPAD is pressed
    if ( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_RIGHT
		 || m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_LEFT )
    {
        if (m_TweakMode == TWEAK_TIME_SCALE)
            m_TweakMode = TWEAK_STROKE_SIZE;
		else
			m_TweakMode = TWEAK_TIME_SCALE;
	}
    if ( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_UP
		 || m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_DOWN )
	{
		if (m_TweakMode == TWEAK_STROKE_SIZE
			&& m_Paint.m_bStrokeSizePerVertex) // enter stroke scale mode only if enabled
			m_TweakMode = TWEAK_STROKE_SIZE_SCALE;
		else
			m_TweakMode = TWEAK_STROKE_SIZE;
	}

    // Tweak stroke size offset and scale, or time scale
    int delta = m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] 
        - m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER];
    if (delta)
    {
        m_TweakActive = 1.f;
        if (m_TweakMode == TWEAK_TIME_SCALE)
        {
            static FLOAT fDeltaScale = 0.001f;
            FLOAT fScale = 1.f + m_fElapsedTime * delta * fDeltaScale;
            m_fTimeScale *= fScale;
        }
        else if (m_TweakMode == TWEAK_STROKE_SIZE)
        {
            static FLOAT fDeltaScale = 0.001f;
            FLOAT fScale = 1.f + m_fElapsedTime * delta * fDeltaScale;
            m_Paint.m_fPointSizeOffset *= fScale;
            m_Paint.m_fPointSizeScale *= fScale;    // tweak both to scale mean
        }
        else if (m_TweakMode == TWEAK_STROKE_SIZE_SCALE)
        {
            static FLOAT fDeltaScale = 0.001f;
            FLOAT fScale = 1.f + m_fElapsedTime * delta * fDeltaScale;
            m_Paint.m_fPointSizeScale *= fScale;    // moves mean, but always above offset
        }
    }
    else if (m_TweakActive > 0.f)   // keep the tweaking debug display active for a while
        m_TweakActive -= m_fElapsedTime;

    // Choose current paint vertex buffers, to give the impression of random center positions and stroke sizes
    UINT iOldPaintVB = m_Paint.m_iPaintVertexBuffer;
    UINT iOldStrokeVB = m_Paint.m_iStrokeVertexBuffer;
    m_Paint.m_iPaintVertexBuffer = (UINT)fmod(m_fAppTime * m_fTimeScale, CENTERCOUNT);
    if (m_Paint.m_iPaintVertexBuffer >= CENTERCOUNT)
        m_Paint.m_iPaintVertexBuffer = 0;
    m_Paint.m_iStrokeVertexBuffer = (UINT)fmod(m_fAppTime * m_fTimeScale, STROKECOUNT);
    if (m_Paint.m_iStrokeVertexBuffer >= STROKECOUNT)
        m_Paint.m_iStrokeVertexBuffer = 0;

    // update view position
    static FLOAT fOffsetScale = 3.f;
    FLOAT fX1 = m_DefaultGamepad.fX1;
    fX1 *= fX1 * fX1; // fX1 cubed
    FLOAT fY1 = m_DefaultGamepad.fY1;
    fY1 *= fY1 * fY1; // fY1 cubed
    D3DXVECTOR3 vOffset(fX1, 0.f, fY1); // screen space offset, X moves left-right, Y moves in-out in depth
    D3DXVec3TransformNormal(&vOffset, &vOffset, &m_matViewInverse);
    D3DXVec3Normalize(&m_vUp, &m_vUp);
    vOffset -= D3DXVec3Dot(&vOffset, &m_vUp) * m_vUp; // don't move up or down with thumb sticks
    D3DXVec3Normalize(&vOffset, &vOffset);
    vOffset *= fOffsetScale * m_fElapsedTime;
    m_vFrom += vOffset;
    m_vAt += vOffset;

    // update view angle
    static FLOAT fAtOffsetScale = 8.f;
    D3DXVECTOR3 vAtOffset(0.f, 0.f, 0.f);
    FLOAT fX2 = m_DefaultGamepad.fX2;
    fX2 *= fX2 * fX2; // fX2 cubed
    FLOAT fY2 = m_DefaultGamepad.fY2;
    fY2 *= fY2 * fY2; // fY2 cubed
    vAtOffset.x += fAtOffsetScale * fX2 * m_fElapsedTime;
    D3DXVECTOR3 vE = m_vAt - m_vFrom;
    D3DXVec3Normalize(&vE, &vE);
    FLOAT fThreshold = 0.99f;
    FLOAT fEdotU = D3DXVec3Dot(&vE, &m_vUp);
    if ((fEdotU < -fThreshold && fY2 < 0.f) // near -vUp, but positive movement
        || (fEdotU > fThreshold && fY2 > 0.f)   // near vUp, but negative movement
        || (fEdotU > -fThreshold && fEdotU < fThreshold))       // ordinary case
        vAtOffset.y -= fAtOffsetScale * fY2 * m_fElapsedTime;   // screen-space Y displacement means up-down view turn
    D3DXVec3TransformNormal(&vAtOffset, &vAtOffset, &m_matViewInverse);
    m_vAt += vAtOffset;

    SetCameraTransformations();
    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: RenderToPaintTexture
// Desc: Renders the scene to a texture
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::RenderToPaintTexture()
{
    // Set texture as render target
    g_pd3dDevice->SetRenderTarget(m_Paint.m_pPaintSurface, m_Paint.m_pPaintDepthBuffer);

    // Clear the zbuffer
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL, 0x00000000, 1.0f, 0L );

    // Draw a gradient filled background
    RenderGradientBackground( 0xff404040, 0xff404080 ); // This will render just the upper left corner of the regular gradient texture

    // Set default state
    m_pd3dDevice->SetTexture( 0, NULL );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTexture( 1, NULL );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTexture( 2, NULL );
    m_pd3dDevice->SetTextureStageState( 2, D3DTSS_COLOROP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 2, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTexture( 3, NULL );
    m_pd3dDevice->SetTextureStageState( 3, D3DTSS_COLOROP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 3, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING,        TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,         TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE,    TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_DIFFUSEMATERIALSOURCE, D3DMCS_MATERIAL );
    m_pd3dDevice->SetRenderState( D3DRS_AMBIENTMATERIALSOURCE, D3DMCS_MATERIAL );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_POINT );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_POINT );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_POINT );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP );

    // Render some geometry
    m_pd3dDevice->SetPixelShader( NULL );
    m_pd3dDevice->SetStreamSource( 0, m_pCylinderVB, sizeof(CUSTOMVERTEX) );
    m_pd3dDevice->SetVertexShader( D3DFVF_CUSTOMVERTEX );
    D3DXMATRIX matWorld;
    D3DMATERIAL8 material;
    XBUtil_InitMaterial( material, 1.0f, 1.0f, 1.0f );
    for (UINT i = 0; i < m_nObjectCount; i++)
    {
        m_pd3dDevice->SetTexture(0, m_rpTexture[m_rObjects[i].m_iTexture] );
        material.Diffuse = material.Ambient = m_rObjects[i].m_color;
        m_pd3dDevice->SetMaterial( &material );
        D3DXMatrixTranslation(&matWorld, m_rObjects[i].m_vPosition.x, m_rObjects[i].m_vPosition.y, m_rObjects[i].m_vPosition.z);
        m_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld );
        m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2*NSAMPLE-2 );
    }
    
    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: Render
// Desc: Renders the scene
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Draw the scene to a texture
    RenderToPaintTexture();

    // Set the render target to the backbuffer
    m_pd3dDevice->SetRenderTarget(m_pBackBuffer, m_pDepthBuffer);
    
    // Use the texture to draw a painterly rendering of the scene
    if (m_bClearPaper)
        m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET, 0xffffffff, 1.0f, 0L );
    if (m_bDrawQuad)
        m_Paint.DrawQuad();
    else
        m_Paint.DrawPointSprites();

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        m_Font.Begin();
        m_Font.DrawText(  64, 50, 0xffffffff, L"PaintEffect" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );
        if (m_TweakActive > 0.f)
        {
            CONST INT buflen = 200;
            WCHAR buf[buflen];
            if (m_TweakMode == TWEAK_TIME_SCALE)
            {
                m_Font.DrawText(64, 80, 0xff00ff00, L"Animation");
                _snwprintf(buf, buflen, L"rate=%f fps", m_fTimeScale);
                m_Font.DrawText(64, 110, 0xff66ff33, buf);
            }
            else if (!m_Paint.m_bStrokeSizePerVertex)
            {
                FLOAT fFixedPointSize = m_Paint.m_fPointSizeScale * 0.5f + m_Paint.m_fPointSizeOffset;
                m_Font.DrawText(64, 80, 0xff00ff00, L"Stroke Size, fixed");
                _snwprintf(buf, buflen, L"size=%f", fFixedPointSize);
                m_Font.DrawText(64, 110, 0xff66ff33, buf);
            }
            else
            {
                DWORD color1, color2;
                if (m_TweakMode == TWEAK_STROKE_SIZE)
                {
                    color1 = 0xff66ff33;
                    color2 = 0xff00ff00;
                }
                else
                {
                    color1 = 0xff00ff00;
                    color2 = 0xff66ff33;
                }
                m_Font.DrawText(64, 80, 0xff00ff00, L"Stroke Size, offset + random * scale");
                _snwprintf(buf, buflen, L"offset=%f", m_Paint.m_fPointSizeOffset);
                m_Font.DrawText(64, 110, color1, buf);
                _snwprintf(buf, buflen, L"scale=%f", m_Paint.m_fPointSizeScale);
                m_Font.DrawText(64, 140, color2, buf);
            }
        }
        m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Notifier\notifier.cpp ===
//-----------------------------------------------------------------------------
// File: Notifier.cpp
//
// Desc: Illustrates how to use vblank routines and notifiers on the Xbox.
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <xpath.h>
#include <xmenu.h>
#include <xobj.h>

// The following header file is generated from "Resource.rdf" file using the
// Bundler tool. In addition to the header, the tool outputs a binary file
// (Resource.xpr) which contains compiled (i.e. bundled) resources and is
// loaded at runtime using the CXBPackedResource class.
#include "Resource.h"




//-----------------------------------------------------------------------------
// ASCII names for the resources used by the app
//-----------------------------------------------------------------------------
XBRESOURCE g_ResourceNames[] = 
{
    { "Floor.bmp",    resource_Floor_OFFSET },
    { "BiHull.bmp",   resource_BiHull_OFFSET },
    { "Wings.bmp",    resource_Wings_OFFSET },
    { NULL, 0 },
};

extern CXBPackedResource* g_pModelResource;




//-----------------------------------------------------------------------------
// Help screen definitions
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] =
{
    { XBHELP_LEFTSTICK,   XBHELP_PLACEMENT_1, L"Move Camera X, Z" },
    { XBHELP_RIGHTSTICK,  XBHELP_PLACEMENT_1, L"Move Camera Y" },
    { XBHELP_BACK_BUTTON, XBHELP_PLACEMENT_1, L"Display\nhelp" },
    { XBHELP_A_BUTTON,    XBHELP_PLACEMENT_1, L"Toggle WaitVBlank" },
};
#define NUM_HELP_CALLOUTS 4




// Vertical blank callback
void __cdecl VBlankCallback( D3DVBLANKDATA *pData );
DWORD g_dwVBCount = 0;

// Pushbuffer callback
void __cdecl PushBufferCallback( DWORD Context );
DWORD g_dwPBCount = 0;

// # of spheres to draw
#define MAX_SPHERE 128




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBPackedResource m_xprResource;
    CXBFont     m_Font;
    CXBHelp     m_Help;
    BOOL        m_bDrawHelp;
    BOOL        m_bWaitVBlank;

    D3DXVECTOR3 m_vCameraPos;
    D3DXVECTOR3 m_vCameraRot;

    CXModel*    m_pSphereModel;
    CXObject    m_SphereObj[MAX_SPHERE];
    CXObject    m_PlaneObj;

    float       m_fTime[8];

public:
    HRESULT Initialize();
    HRESULT FrameMove();
    HRESULT Render();

    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    // Allow unlimited frame rate
    m_d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;

    // initialize our stuff
    m_bDrawHelp  = FALSE;
    m_bWaitVBlank = FALSE;

    m_vCameraPos = D3DXVECTOR3( 0.0f, 0.0f,-15.0f );
    m_vCameraRot = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Initialize device-dependant objects.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    HRESULT hr;

    // Create a font
    if( FAILED( hr = m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Initialize the help system
    if( FAILED( hr = m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Load the packed resource
    if( FAILED( m_xprResource.Create( m_pd3dDevice, "Resource.xpr",
                                      resource_NUM_RESOURCES, g_ResourceNames ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    g_pModelResource = &m_xprResource;

    // Set projection transform
    D3DXMATRIX matProj;
    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/4, 640.0f/480.0f, 0.1f, 1000.0f );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );

    // Set the view matrix based on the camera position
    D3DXMATRIX matView;
    D3DXMatrixTranslation( &matView, -m_vCameraPos.x, -m_vCameraPos.y, -m_vCameraPos.z );
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );

    // Set base path for creating/loading geometry
    XPath_SetBasePath( _T("D:\\Media\\") );

    // Create the sphere objects
    m_pSphereModel = new CXModel;
    m_pSphereModel->Sphere( 5.0f, 16, 16, FVF_XYZTEX1, "Floor.bmp", 5.0f );

    for( DWORD i=0; i<MAX_SPHERE; i++ )
    {
        m_SphereObj[i].SetModel(m_pSphereModel);
        m_SphereObj[i].SetPosition( (float)rand()*100.0f/32768.0f-50.0f, 
                                    (float)rand()*100.0f/32768.0f-50.0f, 
                                    30.0f+(float)rand()*100.0f/32768.0f );
    }

    // Load up the plane object
    CXBMesh *xbm = new CXBMesh;
    xbm->Create(g_pd3dDevice, "models\\airplane.xbg", &m_xprResource );
    m_PlaneObj.SetXBMesh( xbm );
    m_PlaneObj.SetPosition( 0.0f, 0.0f, 10.0f );

    // Register our vblank callback
    g_pd3dDevice->SetVerticalBlankCallback( VBlankCallback );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK )
        m_bDrawHelp = !m_bDrawHelp;

    // Toggle vblank wait
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_A] )
        m_bWaitVBlank = !m_bWaitVBlank;

    // Rotate the spheres...
    for( DWORD i=0; i<MAX_SPHERE; i++ )
        m_SphereObj[i].m_vRotation.y += m_fElapsedTime*1.0f;

    // ...and the plane
    m_PlaneObj.m_vRotation.y += m_fElapsedTime*0.5f;
    m_PlaneObj.m_vRotation.z += m_fElapsedTime;

    // Adjust the camera
    D3DXMATRIX matView;
    m_vCameraPos.x += m_DefaultGamepad.fX1*m_fElapsedTime*8.0f;
    m_vCameraPos.y += m_DefaultGamepad.fY2*m_fElapsedTime*8.0f;
    m_vCameraPos.z += m_DefaultGamepad.fY1*m_fElapsedTime*8.0f;

    D3DXMatrixTranslation( &matView, -m_vCameraPos.x, -m_vCameraPos.y, -m_vCameraPos.z);
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    WCHAR str[80];
    float fBaseTime;
    DWORD dwFence0;

    fBaseTime = XBUtil_Timer(TIMER_GETABSOLUTETIME);

    // Clear the viewport
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL, 
                         0xff400000, 1.0f, 0L );

    // Restore state that text clobbers
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, D3DZB_TRUE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU,  D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV,  D3DTADDRESS_WRAP );

    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );

    // Render some spheres
    for( DWORD i=0; i<MAX_SPHERE/4; i++ )
        m_SphereObj[i].Render(0);

    // Do a callback at this point
    m_pd3dDevice->InsertCallback( D3DCALLBACK_READ, (D3DCALLBACK)PushBufferCallback, 0 );

    // Render some more spheres
    for( i=MAX_SPHERE/4; i<MAX_SPHERE; i++ )
        m_SphereObj[i].Render(0);

    // Insert a fence here
    m_fTime[0] = XBUtil_Timer(TIMER_GETABSOLUTETIME) - fBaseTime;
    dwFence0 = m_pd3dDevice->InsertFence();

    // Render the plane
    m_PlaneObj.Render(0);

    // Wait for the fence
    m_pd3dDevice->BlockOnFence(dwFence0);
    m_fTime[1] = XBUtil_Timer(TIMER_GETABSOLUTETIME) - fBaseTime;

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        m_Font.Begin();
        m_Font.DrawText(  64, 50, 0xffffffff, L"Notifier" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );

        swprintf( str, L"VBCount: %d", g_dwVBCount );
        m_Font.DrawText( 64, 70, 0xff00ff00, str );
        swprintf( str, L"PBCount: %d", g_dwPBCount );
        m_Font.DrawText( 64, 90, 0xff00ff00, str );

        swprintf( str, L"Fence Start: %5.4f, Stop: %5.4f", m_fTime[0], m_fTime[1] );
        m_Font.DrawText( 64, 110, 0xff00ff00, str );

        if( m_bWaitVBlank )
            m_Font.DrawText( 64, 130, 0xffffffff, L"WaitVBlank" );

        m_Font.End();
    }

    // If waiting for the vblank, then block until we get it
    if( m_bWaitVBlank )
        m_pd3dDevice->BlockUntilVerticalBlank();

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: VBlankCallback
// Desc: This routine is called at the beginning of the vertical blank.
//-----------------------------------------------------------------------------
void __cdecl VBlankCallback( D3DVBLANKDATA *pData )
{
    g_dwVBCount++;
}




//-----------------------------------------------------------------------------
// Name: PushBufferCallback
// Desc: This routine is called when the pushbuffer hits the point where
//       the callback was added.
//-----------------------------------------------------------------------------
void __cdecl PushBufferCallback( DWORD Context )
{
    g_dwPBCount++;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\patch\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\patch\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\PerfTest\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\PerfTest\Font12.h ===
// Automatically generated by the bundler tool from Font12.rdf

#define Font12_NUM_RESOURCES 2UL

#define Font12_Font_OFFSET 0UL
#define Font12_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\PerfTest\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\PerfTest\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\PaintEffect\obj\i386\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 5UL

#define resource_Texture0_OFFSET 0UL
#define resource_Texture1_OFFSET 20UL
#define resource_Checker_OFFSET 40UL
#define resource_Stroke_OFFSET 60UL
#define resource_StrokeCoffee_OFFSET 80UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\PerfTest\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\PerfTest\obj\i386\Font12.h ===
// Automatically generated by the bundler tool from Font12.rdf

#define Font12_NUM_RESOURCES 2UL

#define Font12_Font_OFFSET 0UL
#define Font12_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\PerfTest\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 9UL

#define resource_Light_OFFSET 0UL
#define resource_SkyBoxXP_OFFSET 20UL
#define resource_SkyBoxXN_OFFSET 40UL
#define resource_SkyBoxYP_OFFSET 60UL
#define resource_SkyBoxYN_OFFSET 80UL
#define resource_SkyBoxZP_OFFSET 100UL
#define resource_SkyBoxZN_OFFSET 120UL
#define resource_StoneHen_OFFSET 140UL
#define resource_StoneHea_OFFSET 160UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\PerfTest\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\PerfTest\VolumeLight.cpp ===
//-----------------------------------------------------------------------------
// File: VolumeLight.cpp
//
// Desc: Code to render a scene used to show off performance testing. This
//       file contains functions to initialize and run the app. Please see the
//       PerfTest.cpp file for information on using the Xbox's performance
//       testing API.
//
//       Note: this sample is only relevant for DEBUG builds.
//
// Hist: 05.14.01 - Modifed version to show off performance testing
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBMesh.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <XBResource.h>
#include <XBUtil.h>
#include <xgraphics.h>
#include "Resource.h" // Resource header produced by the bundler tool




//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_LEFTSTICK,    XBHELP_PLACEMENT_1, L"Move light" },
    { XBHELP_RIGHTSTICK,   XBHELP_PLACEMENT_1, L"Move camera" },
    { XBHELP_DPAD,         XBHELP_PLACEMENT_2, L"Change light\nFOV" },
    { XBHELP_START_BUTTON, XBHELP_PLACEMENT_1, L"Pause" },
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_1, L"Display help" },
};

#define NUM_HELP_CALLOUTS 5




//-----------------------------------------------------------------------------
// ASCII names for the resources used by the app
//-----------------------------------------------------------------------------
XBRESOURCE g_ResourceNames[] = 
{
    { "Light.bmp",    resource_Light_OFFSET },
    { "SkyBoxXP.bmp", resource_SkyBoxXP_OFFSET },
    { "SkyBoxXN.bmp", resource_SkyBoxXN_OFFSET },
    { "SkyBoxYP.bmp", resource_SkyBoxYP_OFFSET },
    { "SkyBoxYN.bmp", resource_SkyBoxYN_OFFSET },
    { "SkyBoxZP.bmp", resource_SkyBoxZP_OFFSET },
    { "SkyBoxZN.bmp", resource_SkyBoxZN_OFFSET },
    { "StoneHen.bmp", resource_StoneHen_OFFSET },
    { "StoneHea.bmp", resource_StoneHea_OFFSET },
    { NULL, 0 },
};




//-----------------------------------------------------------------------------
// Defines, constants, and global variables
//-----------------------------------------------------------------------------
#define VOLTEX_WIDTH  256
#define VOLTEX_HEIGHT 256
#define VOLTEX_DEPTH   16

FLOAT       g_fFlashLightFOV    = D3DX_PI/4; // Field of view of flashlight beam
FLOAT       g_fFlashLightExtent = 25.0f;     // How far lighting effects extend
D3DXVECTOR3 g_vFlashLightPos;
D3DXVECTOR3 g_vFlashLightDir;

FLOAT       g_fMinOffset = 0.050f; // Parameters for the volume light
FLOAT       g_fMaxOffset = 0.200f;
FLOAT       g_fMinSigma  = 0.020f;
FLOAT       g_fMaxSigma  = 0.500f;
FLOAT       g_fScale     = 3.0f;




//-----------------------------------------------------------------------------
// Externals for linking to the Perf Test functions
//-----------------------------------------------------------------------------
extern VOID UpdateMenus( XBGAMEPAD* pGamepad );
extern VOID DisplayMenus( CXBFont* pFont );
extern VOID StartPerfTest();
extern VOID DisplayPerfResults( CXBFont* pFont );

extern BOOL g_bPerfTestRunning;
extern BOOL g_bDisplayPerfResults;
extern BOOL g_bDisplayPerfTestMenu;




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBFont                  m_Font16;         // System font
    CXBFont                  m_Font12;         // System font
    CXBHelp                  m_Help;           // Application help
    BOOL                     m_bDrawHelp;      // Whether to display help

    CXBPackedResource        m_xprResource;    // Packed resources (textures)
    
    CXBMesh                  m_SkyBoxObject;   // The skybox geometry
    D3DXMATRIX               m_matSkyBox;      // Matrix to orient skybox

    CXBMesh                  m_TerrainObject;  // The terrain geometry
    D3DXMATRIX               m_matWorld;       // Matrix set
    D3DXMATRIX               m_matView;
    D3DXMATRIX               m_matProj;

    FLOAT                    m_fViewAngle;     // Scene parameters
    FLOAT                    m_fCameraX;
    FLOAT                    m_fCameraY;
    FLOAT                    m_fCameraZ;
    FLOAT                    m_fLightPhi;
    FLOAT                    m_fLightTheta;

    CXBMesh                  m_FlashLightObject;    // The flashlight geometry
    D3DXMATRIX               m_matLightOrientation; // Matrix to orient flashlight

    LPDIRECT3DTEXTURE8       m_pLightTexture;  // Texture for flahlight lens flare

    LPDIRECT3DVOLUMETEXTURE8 m_pVolumeTexture; // Volumetexture for the light beam

    DWORD                    m_dwVertexShader; // Vertex shader for the lit terrain
    DWORD                    m_dwPixelShader;  // Pixel shader for the lit terrain

    HRESULT CreateVolumeTexture();             // Creates the volume light texture
    HRESULT CreatePixelShader();               // Creates the pixel shader

public:
    HRESULT Initialize();
    HRESULT Render();
    HRESULT FrameMove();

    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    // Allow unlimited frame rate
    m_d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;

    // Clear member variables
    m_bDrawHelp      = FALSE;
    m_pLightTexture  = NULL;
    m_pVolumeTexture = NULL;

    // Initial scene parameters
    m_fViewAngle  =  3.53f;
    m_fCameraX    =  4.54f;
    m_fCameraY    =  2.00f;
    m_fCameraZ    =  6.75f;
    m_fLightPhi   = +0.00f;
    m_fLightTheta = -0.32f;

}




//-----------------------------------------------------------------------------
// Name: CreatePixelShader()
// Desc: Creates the pixel shader for the lit terrain
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::CreatePixelShader()
{
    // Setup the pixel shader
    D3DPIXELSHADERDEF psd;
    ZeroMemory( &psd, sizeof(psd) );
    psd.PSCombinerCount = PS_COMBINERCOUNT( 2,
                                            PS_COMBINERCOUNT_MUX_MSB | PS_COMBINERCOUNT_UNIQUE_C0 | PS_COMBINERCOUNT_UNIQUE_C1);
    psd.PSTextureModes  = PS_TEXTUREMODES( PS_TEXTUREMODES_PROJECT2D, PS_TEXTUREMODES_PROJECT3D,
                                           PS_TEXTUREMODES_NONE, PS_TEXTUREMODES_NONE );

    //------------- Stage 0 -------------
    // Combine base texture (t0) with the diffuse lighting contribution (v0)
    psd.PSRGBInputs[0]    = PS_COMBINERINPUTS( PS_REGISTER_T0  | PS_CHANNEL_RGB,
                                               PS_REGISTER_V0  | PS_CHANNEL_RGB,
                                               PS_REGISTER_ONE | PS_CHANNEL_RGB,
                                               PS_REGISTER_ONE | PS_CHANNEL_RGB );
    psd.PSAlphaInputs[0]  = PS_COMBINERINPUTS( PS_REGISTER_ONE | PS_CHANNEL_ALPHA,
                                               PS_REGISTER_ONE | PS_CHANNEL_ALPHA,
                                               PS_REGISTER_ONE | PS_CHANNEL_ALPHA,
                                               PS_REGISTER_ONE | PS_CHANNEL_ALPHA );
    psd.PSRGBOutputs[0]   = PS_COMBINEROUTPUTS( PS_REGISTER_R0,
                                                PS_REGISTER_DISCARD,
                                                PS_REGISTER_DISCARD,
                                                PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM );
    psd.PSAlphaOutputs[0] = PS_COMBINEROUTPUTS( PS_REGISTER_R0,
                                                PS_REGISTER_DISCARD,
                                                PS_REGISTER_DISCARD,
                                                PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM );

    //------------- Stage 1 -------------
    // Modulate in volume light (t1) and add in some ambient (c0)
    psd.PSRGBInputs[1]    = PS_COMBINERINPUTS( PS_REGISTER_R0  | PS_CHANNEL_RGB,
                                               PS_REGISTER_T1  | PS_CHANNEL_RGB,
                                               PS_REGISTER_R0  | PS_CHANNEL_RGB,
                                               PS_REGISTER_C0  | PS_CHANNEL_RGB );
    psd.PSAlphaInputs[1]  = PS_COMBINERINPUTS( PS_REGISTER_ONE | PS_CHANNEL_ALPHA,
                                               PS_REGISTER_ONE | PS_CHANNEL_ALPHA,
                                               PS_REGISTER_ONE | PS_CHANNEL_ALPHA,
                                               PS_REGISTER_ONE | PS_CHANNEL_ALPHA );
    psd.PSRGBOutputs[1]   = PS_COMBINEROUTPUTS( PS_REGISTER_DISCARD,
                                                PS_REGISTER_DISCARD,
                                                PS_REGISTER_R0,
                                                PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM );
    psd.PSAlphaOutputs[1] = PS_COMBINEROUTPUTS( PS_REGISTER_R0,
                                                PS_REGISTER_DISCARD,
                                                PS_REGISTER_DISCARD,
                                                PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM );
    psd.PSConstant0[1] = 0x40404040;

    //------------- Final combiner -------------
    
    // Output r0
    psd.PSFinalCombinerInputsABCD = PS_COMBINERINPUTS( PS_REGISTER_ONE     | PS_CHANNEL_ALPHA,
                                                       PS_REGISTER_R0      | PS_CHANNEL_RGB,
                                                       PS_REGISTER_ZERO     | PS_CHANNEL_RGB,
                                                       PS_REGISTER_ZERO    | PS_CHANNEL_RGB );

    psd.PSFinalCombinerInputsEFG = PS_COMBINERINPUTS( PS_REGISTER_ONE | PS_CHANNEL_RGB,
                                                      PS_REGISTER_ONE | PS_CHANNEL_RGB,
                                                      PS_REGISTER_ONE | PS_CHANNEL_RGB,
                                                      0 | 0 | 0 );

    // Create the pixel shader, as defined above.
    if( FAILED( m_pd3dDevice->CreatePixelShader( &psd, &m_dwPixelShader ) ) )
        return E_FAIL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CreateVolumeTexture()
// Desc: Creates the volume light. The flashlight's beam is modelled here in
//       the 3D space of a volume texture.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::CreateVolumeTexture()
{
    HRESULT hr;

    // Create a volume texture
    hr = m_pd3dDevice->CreateVolumeTexture( VOLTEX_WIDTH, VOLTEX_HEIGHT, VOLTEX_DEPTH, 
                                            1, 0, D3DFMT_L8, D3DPOOL_MANAGED,
                                            &m_pVolumeTexture );
    if( FAILED(hr) )
        return hr;

    // Lock and fill the volume texture
    D3DVOLUME_DESC desc;
    D3DLOCKED_BOX lock;
    m_pVolumeTexture->GetLevelDesc( 0, &desc );
    m_pVolumeTexture->LockBox( 0, &lock, 0, 0L );
    BYTE* pBits = (BYTE*)lock.pBits;

    for( UINT w=0; w<VOLTEX_DEPTH; w++ )
    {
        FLOAT z = (1.0f*w)/(VOLTEX_DEPTH-1); // Ranges from 0 to +1

        // Paramaters for Gaussian falloff
        FLOAT fOffset = g_fMinOffset + (g_fMaxOffset-g_fMinOffset)*z;
        FLOAT fSigma  = g_fMinSigma + (g_fMaxSigma-g_fMinSigma)*z;
        FLOAT fBias   = expf( -(1.0f-fOffset)*(1.0f-fOffset)/(2*fSigma*fSigma) );
        FLOAT fMaxAmplitude = ( expf( -(fOffset*fOffset)/(2*fSigma*fSigma) ) - fBias );
        FLOAT fScale  = 1.0f / fMaxAmplitude;

        for( UINT v=0; v<VOLTEX_HEIGHT; v++ )
        {
            for( UINT u=0; u<VOLTEX_WIDTH; u++ )
            {
                FLOAT x = (2.0f*u)/(VOLTEX_HEIGHT-1) - 1.0f; // Ranges from -1 to +1
                FLOAT y = (2.0f*v)/(VOLTEX_WIDTH-1) - 1.0f;  // Ranges from -1 to +1
                FLOAT r = sqrtf( x*x + y*y );

                // Compute the intensity
                FLOAT fIntensity = fScale * ( expf( -(r-fOffset)*(r-fOffset)/(2*fSigma*fSigma) ) - fBias );
                if( fIntensity > 1.0f ) fIntensity = 1.0f;
                if( fIntensity < 0.0f ) fIntensity = 0.0f;

                // Write the texel
                (*pBits++) = (BYTE)(255*fIntensity);
            }
        }
    }
    
    // Swizzle and unlock the texture
    XBUtil_SwizzleTexture3D( &lock, &desc );
    m_pVolumeTexture->UnlockBox( 0 );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create the fonts
    if( FAILED( m_Font16.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;
    if( FAILED( m_Font12.Create( m_pd3dDevice, "Font12.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the resources
    if( FAILED( m_xprResource.Create( m_pd3dDevice, "Resource.xpr", 
                                      resource_NUM_RESOURCES, g_ResourceNames ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Load the geometry models
    if( FAILED( m_SkyBoxObject.Create( m_pd3dDevice, "Models\\SkyBox.xbg", &m_xprResource ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    if( FAILED( m_TerrainObject.Create( m_pd3dDevice, "Models\\StoneHenge.xbg", &m_xprResource ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    if( FAILED( m_FlashLightObject.Create( m_pd3dDevice, "Models\\Light.xbg", &m_xprResource ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Get the light's texture
    m_pLightTexture = m_xprResource.GetTexture( "Light.bmp" );
    
    // Create the volume texture
    if( FAILED( CreateVolumeTexture() ) )
        return E_FAIL;

    // Create the pixel shader
    if( FAILED( CreatePixelShader() ) )
        return E_FAIL;

    // Set the matrices
    D3DXMatrixIdentity( &m_matWorld );
    D3DXMatrixPerspectiveFovLH( &m_matProj, D3DX_PI/3, 4.0f/3.0f, 1.0f, 100.0f );
    m_pd3dDevice->SetTransform( D3DTS_WORLD,      &m_matWorld );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &m_matProj );

    // Create vertex shader
    DWORD dwVertexDecl[20];
    XBUtil_DeclaratorFromFVF( m_TerrainObject.GetMesh(0)->m_dwFVF, dwVertexDecl );

    if( FAILED( XBUtil_CreateVertexShader( m_pd3dDevice, "Shaders\\Shader.xvu",
                                           dwVertexDecl, &m_dwVertexShader ) ) )
        return E_FAIL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    BOOL bAcceptSceneInput  = FALSE;

    // Limit input selections if the performance is running
    if( g_bPerfTestRunning )
    {
        // Allow user to manipulate the scene
        bAcceptSceneInput = TRUE;
    }
    else
    {
        if( g_bDisplayPerfTestMenu )
        {
            UpdateMenus( &m_DefaultGamepad );

            if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_BLACK ] )
                g_bDisplayPerfTestMenu = FALSE;
        }
        else if( g_bDisplayPerfResults )
        {
            if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_BLACK ] )
                g_bDisplayPerfResults = FALSE;
        }
        else
        {
            // Display menu
            if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_BLACK ] )
                g_bDisplayPerfTestMenu = TRUE;

            // Start perf test
            if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_WHITE ] )
                StartPerfTest();

            // Toggle help
            if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK )
                m_bDrawHelp = !m_bDrawHelp;

            // Allow user to manipulate the scene
            bAcceptSceneInput = TRUE;
        }
    }


    // Check gamepad to move camera, orient the light, etc.
    if( bAcceptSceneInput )
    {
        // Change the field of view of the flashlight
        if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_DOWN )
            g_fFlashLightFOV += D3DX_PI * ( 5.0f / 180.0f );
        if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_UP )
            g_fFlashLightFOV -= D3DX_PI * ( 5.0f / 180.0f );

        // Rotate and position the camera with the gamepad
        m_fViewAngle += 2.0f * m_DefaultGamepad.fX2*m_fElapsedTime;
        m_fCameraX   += 5.0f * m_DefaultGamepad.fY2*m_fElapsedTime*sinf(m_fViewAngle);
        m_fCameraZ   += 5.0f * m_DefaultGamepad.fY2*m_fElapsedTime*cosf(m_fViewAngle);

        // Position and orient the light
        m_fLightPhi   += +3.0f * m_DefaultGamepad.fX1*m_fElapsedTime;
        m_fLightTheta += +3.0f * m_DefaultGamepad.fY1*m_fElapsedTime;
        m_fLightTheta = min( +D3DX_PI/2, max( m_fLightTheta, -D3DX_PI/2 ) );
    }

    // Set the view transform
    D3DXVECTOR3 from = D3DXVECTOR3( m_fCameraX, m_fCameraY, m_fCameraZ );
    D3DXVECTOR3 at   = D3DXVECTOR3( sinf(m_fViewAngle), 0.0f, cosf(m_fViewAngle) ) + from;
    D3DXVECTOR3 up   = D3DXVECTOR3(0.0f, 1.0f, 0.0f);
    D3DXMatrixLookAtLH( &m_matView, &from, &at, &up );
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &m_matView );

    // Set the skybox view transform (which retains the view orientation, but not
    // the translation)
    m_matSkyBox     = m_matView;
    m_matSkyBox._41 = 0.0f; 
    m_matSkyBox._42 = 0.0f; 
    m_matSkyBox._43 = 0.0f;

    g_vFlashLightPos.x = 3.0f * sinf( 1.0f * m_fAppTime ) + 1.0f;
    g_vFlashLightPos.y = 0.0f * sinf( 5.0f * m_fAppTime ) + 1.0f;
    g_vFlashLightPos.z = 2.0f * cosf( 1.0f * m_fAppTime ) - 1.0f;

    g_vFlashLightDir.x = +cosf( m_fLightPhi + m_fAppTime );
    g_vFlashLightDir.y = +sinf( m_fLightTheta );
    g_vFlashLightDir.z = -sinf( m_fLightPhi + m_fAppTime );
    D3DXVec3Normalize( &g_vFlashLightDir, &g_vFlashLightDir );

    // Use the inverse of a camera lookat matrix to get an orientation matrix
    // for the light. Note: the inverse step could be optimized out, since we
    // re-invert the matrix later, but we don't do that here, to illustrate the
    // math the really happens.
    D3DXMATRIX matLookAt;
    D3DXMatrixLookAtLH( &matLookAt, &g_vFlashLightPos, 
                                    &(g_vFlashLightPos+g_vFlashLightDir), 
                                    &D3DXVECTOR3(0,1,0) );
    D3DXMatrixInverse( &m_matLightOrientation, NULL, &matLookAt );

    // Set up texture matrix used to orient the volume texture. First, orient
    // to the desired volume texture orientation.
    D3DXMATRIX matTexGen, matTrans1, matScale, matTrans2;
    D3DXMatrixInverse( &matTexGen, NULL, &m_matLightOrientation );

    // Scale to mimic the light beam, and translate the result to the volume
    // texture's origin
    FLOAT fBeamWidth  = g_fFlashLightExtent * cosf( (D3DX_PI-g_fFlashLightFOV)/2 );
    FLOAT fBeamLength = g_fFlashLightExtent * sinf( (D3DX_PI-g_fFlashLightFOV)/2 );
    D3DXMatrixScaling( &matScale, 1.0f/fBeamWidth, 1.0f/fBeamWidth, 1.0f/fBeamLength );
    D3DXMatrixTranslation( &matTrans2, 0.5f, 0.5f, 0.0f );
    D3DXMatrixMultiply( &matTexGen, &matTexGen, &matScale );
    D3DXMatrixMultiply( &matTexGen, &matTexGen, &matTrans2 );

    // Finally, pass the transformed texture matrix to the vertex shader
    D3DXMatrixTranspose( &matTexGen, &matTexGen );
    m_pd3dDevice->SetVertexShaderConstant( 16, &matTexGen, 4 );

    // Pass the transform set to the vertex shader
    D3DXMATRIX matW, matWV, matWVP;
    D3DXMatrixMultiply( &matWV, &m_matWorld, &m_matView );
    D3DXMatrixMultiply( &matWVP, &matWV, &m_matProj );
    D3DXMatrixTranspose( &matW,   &m_matWorld );
    D3DXMatrixTranspose( &matWV,  &matWV );
    D3DXMatrixTranspose( &matWVP, &matWVP );
    m_pd3dDevice->SetVertexShaderConstant(  4, &matW,   4 );
    m_pd3dDevice->SetVertexShaderConstant(  8, &matWV,  4 );
    m_pd3dDevice->SetVertexShaderConstant( 12, &matWVP, 4 );

    // Pass the unattenuated point light values to the vertex shader
    D3DXVECTOR4 v0( 0.0f, 1.0f, 1.0f, 1.0f );
    D3DXVECTOR4 v1( 1.0f, 1.0f, 1.0f, 1.0f );
    D3DXVECTOR4 vLightPos( g_vFlashLightPos.x, g_vFlashLightPos.y, g_vFlashLightPos.z, 0.0f );
    D3DXVECTOR4 vLightColor( 1.0f, 1.0f, 1.0f, 1.0f );
    D3DXVECTOR4 vAmbientColor( 0.0f, 0.0f, 0.0f, 0.0f );
    m_pd3dDevice->SetVertexShaderConstant(  0,  &v0, 1 );
    m_pd3dDevice->SetVertexShaderConstant(  1,  &v1, 1 );
    m_pd3dDevice->SetVertexShaderConstant( 20, &vLightPos,     1 );
    m_pd3dDevice->SetVertexShaderConstant( 21, &vLightColor,   1 );
    m_pd3dDevice->SetVertexShaderConstant( 22, &vAmbientColor, 1 );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DrawBox()
// Desc: Helper function to draw an outlined, filled, screen-space rectangle
//-----------------------------------------------------------------------------
HRESULT DrawBox( FLOAT x1, FLOAT y1, FLOAT x2, FLOAT y2,
                 DWORD dwFillColor, DWORD dwOutlineColor )
{
    D3DXVECTOR4 v[4];
    v[0] = D3DXVECTOR4( x1-0.5f, y1-0.5f, 0, 0 );
    v[1] = D3DXVECTOR4( x2-0.5f, y1-0.5f, 0, 0 );
    v[2] = D3DXVECTOR4( x2-0.5f, y2-0.5f, 0, 0 );
    v[3] = D3DXVECTOR4( x1-0.5f, y2-0.5f, 0, 0 );

    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TFACTOR );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1 );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TFACTOR );
    g_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
    g_pd3dDevice->SetTextureStageState( 1, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
    g_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    g_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,  D3DBLEND_SRCALPHA );
    g_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA );
    g_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW );

    // Render the box
    g_pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, dwFillColor );
    g_pd3dDevice->DrawVerticesUP( D3DPT_QUADLIST, 4, v, sizeof(v[0]) );

    // Render the lines
    g_pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, dwOutlineColor );
    g_pd3dDevice->DrawVerticesUP( D3DPT_LINELOOP, 4, v, sizeof(v[0]) );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Sets up render states, clears the viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Clear the viewport
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,
                         0x00000000, 1.0f, 0L );

    // Render the skybox
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU,  D3DTADDRESS_CLAMP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV,  D3DTADDRESS_CLAMP );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, FALSE );
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &m_matWorld );
    m_pd3dDevice->SetTransform( D3DTS_VIEW,  &m_matSkyBox );
    m_SkyBoxObject.Render( m_pd3dDevice );

    // Set default state
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,  TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  FALSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU,  D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV,  D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &m_matView );

    // Draw the terrain, using the vertex shader, pixel shader, and the volume
    // light in stage 1
    m_pd3dDevice->SetTexture( 1, m_pVolumeTexture );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ADDRESSU,  D3DTADDRESS_BORDER );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ADDRESSV,  D3DTADDRESS_BORDER );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ADDRESSW,  D3DTADDRESS_BORDER );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_BORDERCOLOR, 0x00000000 );
    m_pd3dDevice->SetPixelShader( m_dwPixelShader );
    m_pd3dDevice->SetVertexShader( m_dwVertexShader );
    m_TerrainObject.Render( m_pd3dDevice, XBMESH_NOFVF );

    // Restore state
    m_pd3dDevice->SetPixelShader( NULL );
    m_pd3dDevice->SetTexture( 1, NULL );

    // Render the flashlight body
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXCOORDINDEX, 0 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE ); 
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU,  D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV,  D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetRenderState( D3DRS_AMBIENT,  0xff808080 );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING, TRUE );
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &m_matLightOrientation );
    m_FlashLightObject.Render( m_pd3dDevice );

    // Render the flashlight lens flare
    m_pd3dDevice->SetTexture( 3, m_pLightTexture );
    m_pd3dDevice->SetTextureStageState( 3, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 3, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetRenderState( D3DRS_POINTSPRITEENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_POINTSCALEENABLE,  TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_POINTSIZE,         FtoDW(0.2f) );
    m_pd3dDevice->SetRenderState( D3DRS_POINTSCALE_A,      FtoDW(0.0f) );
    m_pd3dDevice->SetRenderState( D3DRS_POINTSCALE_B,      FtoDW(0.0f) );
    m_pd3dDevice->SetRenderState( D3DRS_POINTSCALE_C,      FtoDW(1.0f) );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,  D3DBLEND_ONE );
    m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_ONE );
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &m_matWorld );
    m_pd3dDevice->SetVertexShader( D3DFVF_XYZ );
    m_pd3dDevice->DrawPrimitiveUP( D3DPT_POINTLIST, 1, g_vFlashLightPos, sizeof(D3DXVECTOR3) );
    m_pd3dDevice->SetRenderState( D3DRS_POINTSPRITEENABLE, FALSE );

    // Limit display options if the performance is running
    if( FALSE == g_bPerfTestRunning )
    {
        if( m_bDrawHelp )
        {
            // Draw the help
            m_Help.Render( &m_Font16, g_HelpCallouts, NUM_HELP_CALLOUTS );
        }
        else
        {
            // Display text, depending on thee app state
            if( g_bDisplayPerfTestMenu )
            {
                DrawBox( 59,  45, 571, 118, 0x40008000, 0xff008000 );
                DrawBox( 59, 128, 571, 435, 0x40008000, 0xff008000 );
                m_Font16.DrawText( 320,  50, 0xffffffff, L"Peformance Test Options", XBFONT_CENTER_X );
                m_Font12.DrawText( 320,  75, 0xff00ffff, L"Use DPAD to change options", XBFONT_CENTER_X );
                m_Font12.DrawText( 320,  94, 0xff00ffff, L"Press BLACK to return to the app", XBFONT_CENTER_X );
                DisplayMenus( &m_Font16 );
            }
            else if( g_bDisplayPerfResults )
            {
                DrawBox( 59,  45, 571, 118, 0x40008000, 0xff008000 );
                DrawBox( 59, 128, 571, 435, 0x40008000, 0xff008000 );
                m_Font16.DrawText( 320,  50, 0xffffffff, L"Performance Test Results", XBFONT_CENTER_X );
                m_Font12.DrawText( 320,  94, 0xff00ffff, L"Press BLACK to return to the app", XBFONT_CENTER_X );
                DisplayPerfResults( &m_Font12 );
            }
            else
            {
                DrawBox( 59, 45, 571, 118, 0x40008000, 0xff008000 );
                m_Font16.DrawText(  64,  50, 0xffffffff, L"PerfTest" );
                m_Font16.DrawText( 450,  50, 0xffffff00, m_strFrameRate );
                m_Font12.DrawText(  64,  75, 0xff00ffff, L"Press WHITE to run the performance test" );
                m_Font12.DrawText(  64,  94, 0xff00ffff, L"Press BLACK to change perf test options" );
            }
        }
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\patch\patch.cpp ===
//-----------------------------------------------------------------------------
// File: Patch.cpp
//
// Desc: Example code showing how to use higher-order primitives (rectangular 
//       patches) in D3D.
//
// Hist: 12.18.00 - New for February XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include "Teapot.h"



//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_LEFTSTICK,   XBHELP_PLACEMENT_1, L"Rotate model" },
    { XBHELP_X_BUTTON,    XBHELP_PLACEMENT_2, L"Inc # of\nsegments" },
    { XBHELP_A_BUTTON,    XBHELP_PLACEMENT_2, L"Dec # of\nsegments" },
    { XBHELP_Y_BUTTON,    XBHELP_PLACEMENT_2, L"Toggle\nwireframe" },
    { XBHELP_BACK_BUTTON, XBHELP_PLACEMENT_2, L"Display\nhelp" },
};

#define NUM_HELP_CALLOUTS 5




//-----------------------------------------------------------------------------
// Defines, constants, and global variables
//-----------------------------------------------------------------------------

// A structure for our custom vertex type
struct CUSTOMVERTEX
{
    D3DXVECTOR3 p; // The original position of the vertex
};




// Surface handles should start with 1 and be assigned incrementally for 
// efficiency, since patches are really stored in an array. To do otherwise
// would unnecessarily result in waste of memory for the handles array
#define SURFACEHANDLEBASE 1




// The data used by this sample is made from 4x4 patches
#define PATCH_SIZE 4




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Application class. The base class provides just about all the
//       functionality we want, so we're just supplying stubs to interface with
//       the non-C++ functions of the app.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBFont                 m_Font;
    CXBHelp                 m_Help;
    BOOL                    m_bDrawHelp;

    LPDIRECT3DVERTEXBUFFER8 m_pVB;            // Buffer to hold vertices
    DWORD                   m_hVShader;       // Handle to vertex shader

    DWORD                   m_dwNumSegments;  // Amount to tessellate
    BOOL                    m_bRetessellate;  // Need to retessellate patches
    UINT                    m_dwNumPatches;
    BOOL                    m_bWireframe;

protected:
    HRESULT Initialize();
    HRESULT Render();
    HRESULT FrameMove();

public:
    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Application constructor. Sets attributes for the app.
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    // Allow unlimited frame rate
    m_d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;

    // Initialize class members
    m_bDrawHelp         = FALSE;  // Help flag

    m_pVB               = NULL;   // Geometry
    m_bWireframe        = FALSE;

    m_dwNumSegments     = 8;      // Initial # of patches
    m_bRetessellate     = TRUE;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: This creates all device-dependent managed objects, such as managed
//       textures and managed vertex buffers.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create the font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the vertex buffer
    UINT dwNumVertices = sizeof(g_vTeapotData) / sizeof(D3DXVECTOR3);
    m_dwNumPatches = dwNumVertices / (PATCH_SIZE * PATCH_SIZE);

    if( FAILED( m_pd3dDevice->CreateVertexBuffer( dwNumVertices*sizeof(CUSTOMVERTEX),
                                                  D3DUSAGE_RTPATCHES, 0L, 
                                                  D3DPOOL_DEFAULT, &m_pVB ) ) )
        return E_FAIL;

    // Create a vertex buffer and fill it with our vertices.
    CUSTOMVERTEX* pVertices;
    m_pVB->Lock( 0, 0, (BYTE**)&pVertices, 0 );
    for( DWORD i=0; i<dwNumVertices; i++ )
        pVertices[i].p = g_vTeapotData[i] - g_vTeapotCenter;
    m_pVB->Unlock();

    // Set up matrices
    D3DXMATRIX matWorld, matView, matProj;
    D3DXMatrixIdentity( &matWorld );
    D3DXMatrixLookAtLH( &matView, &D3DXVECTOR3( 0.0f, 3.0f,-400.0f ), 
                                  &D3DXVECTOR3( 0.0f, 0.0f,   0.0f ), 
                                  &D3DXVECTOR3( 0.0f, 1.0f,   0.0f ) );
    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/4, 640.0f/480.0f, 1.0f, 800.0f );
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld );
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );

    // Set up a material
    D3DMATERIAL8 mtrl;
    XBUtil_InitMaterial( mtrl, 1.0f, 1.0f, 0.0f, 1.0f );
    m_pd3dDevice->SetMaterial( &mtrl );

    // Set up a directional light
    D3DLIGHT8 light;
    XBUtil_InitLight( light, D3DLIGHT_DIRECTIONAL, 0.0f, -1.0f, 1.0f );
    m_pd3dDevice->SetLight( 0, &light );
    m_pd3dDevice->LightEnable( 0, TRUE );

    // Vertex declaration
    DWORD decl[] =
    {
        D3DVSD_STREAM(0),
        D3DVSD_REG( D3DVSDE_POSITION, D3DVSDT_FLOAT3 ),
        // Data generation section implemented as a virtual stream
        D3DVSD_STREAM_TESS(),
        // Generate normal using the position input and copy it to the normal
        // register (output)
        D3DVSD_TESSNORMAL( D3DVSDE_POSITION, D3DVSDE_NORMAL ),
        D3DVSD_END()
    };

    // Create the tesselating vertex shader
    m_pd3dDevice->CreateVertexShader( decl, NULL, &m_hVShader, 0 );
    
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK )
        m_bDrawHelp = !m_bDrawHelp;

    // Check user input for changing options
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_X] )
        if( m_dwNumSegments < 16 )
            m_dwNumSegments++;

    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_A] )
        if( m_dwNumSegments > 1 )
            m_dwNumSegments--;

    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_Y] )
        m_bWireframe = !m_bWireframe;
    
    // Perform object rotation
    static D3DXMATRIX matWorld( 1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1 );
    D3DXMATRIX matRotate;
    FLOAT fXRotate1 = m_DefaultGamepad.fX1*m_fElapsedTime*D3DX_PI*0.5f;
    FLOAT fYRotate1 = m_DefaultGamepad.fY1*m_fElapsedTime*D3DX_PI*0.5f;
    D3DXMatrixRotationYawPitchRoll( &matRotate, -fXRotate1, -fYRotate1, 0.0f );
    D3DXMatrixMultiply( &matWorld, &matWorld, &matRotate );
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Draw a gradient filled background
    RenderGradientBackground( 0xff000000, 0xff0000ff );

    // Set default render states
    m_pd3dDevice->SetRenderState( D3DRS_DITHERENABLE,     TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,          TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING,         TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_NORMALIZENORMALS, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_AMBIENT,          0x00101010 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_DIFFUSE );

    // Set fillmode options
    m_pd3dDevice->SetRenderState( D3DRS_FILLMODE, m_bWireframe ? D3DFILL_WIREFRAME : D3DFILL_SOLID );
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, m_bWireframe ? D3DCULL_NONE : D3DCULL_CCW );

    // Render the patches
    m_pd3dDevice->SetVertexShader( m_hVShader );
    m_pd3dDevice->SetStreamSource( 0, m_pVB, sizeof(CUSTOMVERTEX) );

    for( DWORD patch = 0; patch < m_dwNumPatches; patch++ ) 
    {
        FLOAT fNumEdgeSegments[PATCH_SIZE];
        for( DWORD i = 0; i<PATCH_SIZE; i++ )
            fNumEdgeSegments[i] = (FLOAT)m_dwNumSegments;
    
        // First time through, tesellate
        if( m_bRetessellate ) 
        {
            // Setup the patch info, where the geometry is a long narrow (1  N)
            // rectangular patch (a cubic, bezier strip). Note that all the units
            // in this structure are in number of vertices
            D3DRECTPATCH_INFO rect;
            rect.Width  = PATCH_SIZE;      // Width of each vertex
            rect.Height = PATCH_SIZE;      // Height of each vertex
            rect.Stride = PATCH_SIZE;      // Stride between segments
            rect.Basis  = D3DBASIS_BEZIER; // Basis type for the patch
            rect.Order  = D3DORDER_CUBIC;  // Order type for the patch
            rect.StartVertexOffsetWidth  = 0;                  // Starting vertex offset width
            rect.StartVertexOffsetHeight = patch * PATCH_SIZE; // Starting vertex offset height

            // Tessellate using the patch info
            m_pd3dDevice->DrawRectPatch( SURFACEHANDLEBASE + patch, 
                                         fNumEdgeSegments, &rect );
        }
        else 
        {
            // After the first time, the patch is cached, so we can use the
            // existing surface handles. Note: This is more effecient, but if we
            // were using dynamic patches, we could specify the D3DRECTPATCH_INFO
            // structure every time.
            m_pd3dDevice->DrawRectPatch( SURFACEHANDLEBASE + patch, 
                                         fNumEdgeSegments, NULL );
        }
    }

    // Reset the flag that triggers tesselation
    m_bRetessellate = FALSE;
    
    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        WCHAR strBuffer[50];
        swprintf( strBuffer, L"%d segments per patch", m_dwNumSegments );

        m_Font.Begin();
        m_Font.DrawText(  64, 50, 0xffffffff, L"Patch" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );
        m_Font.DrawText(  64, 75, 0xffffffff, strBuffer );
        m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\PerfTest\PerfTest.cpp ===
//-----------------------------------------------------------------------------
// File: PerfTest.cpp
//
// Desc: Functions for gathering performance statistics. Note: this code is
//       only valid for DEBUG builds
//
// Note: The simplest way to use the Perf Counters API is to run your app,
//       hit a breakpoint, and then directly modify D3D::g_PerfCounters in 
//       a debugger watch window, setting the m_FrameRateIntervalTime member
//       for how often the internal perftest functions should dump perftest
//       information. (Or, instead of using the debugger window, you could call
//       the D3DPERF_SetShowFrameRateInterval() function in your code.) By
//       default, the perftest functions dump information to the debug port.
//
//       Alternatively, you can use the m_pfnDumpFrameRateInfoHandler member
//       to override the funtion, having it call a function in your app
//       instead. This latter method is used in this app, just to demonstrate
//       it. In many cases, the information dumped to the debug port will be
//       all you need to do performance testing on your app.
//
// Hist: 05.14.01 - New
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBUtil.h>
#include <xgraphics.h>
#include <D3D8Perf.h>



// Menu structures and definitions for the perf test options
struct MenuItem
{
    WCHAR* strLabel;
    DWORD  dwSelection;
    WCHAR* strOptions[10];
};

MenuItem g_Menus[] = 
{
    { L"Test duration:",        2, { L"1 second", L"2 seconds", L"5 seconds", NULL }, },
    { L"Output method:",        0, { L"Onscreen", L"Debug port", NULL }, },
    { L"Enable perf profiler:", 0, { L"Yes", L"No", NULL }, },
    { NULL }
};

#define MENU_TESTDURATION          0
#define MENU_TESTDURATION_1SECOND     0
#define MENU_TESTDURATION_2SECONDS    1
#define MENU_TESTDURATION_5SECONDS    2

#define MENU_OUTPUTMETHOD          1
#define MENU_OUTPUTMETHOD_ONSCREEN     0
#define MENU_OUTPUTMETHOD_DEBUGPORT    1

#define MENU_PERFPROFILER          2
#define MENU_PERFPROFILER_ENABLED      0
#define MENU_PERFPROFILER_DISABLED     1


// Menu control
BOOL  g_bDisplayPerfTestMenu = FALSE;
DWORD g_dwSelectedMenu       = 0;


// Perf test options
FLOAT g_fPerfTestTime       = 5.0f;
BOOL  g_bPerfTestRunning    = FALSE;
BOOL  g_bEnablePerfProfiler = FALSE;
BOOL  g_bDumpToScreen       = FALSE;
BOOL  g_bDisplayPerfResults = FALSE;


// Global perf test reuslts
FLOAT g_fTime;
DWORD g_dwNumFrames;
FLOAT g_fFPS;
FLOAT g_fPushBufferBytes;
FLOAT g_fVertices;
FLOAT g_fMinFrameTime;
FLOAT g_fAvgFrameTime;
FLOAT g_fMaxFrameTime;
DWORD g_dwNumProfileSamples;
DWORD g_dwNumGPUSamples;
DWORD g_dwNumFrontEndSamples;
DWORD g_dwNumBackEndSamples;
DWORD g_dwObjectLockWaits;
FLOAT g_fObjectLockWaitTime;
FLOAT g_fObjectLockTimePerWait;
DWORD g_dwPushBufferWaits;
FLOAT g_fPushBufferWaitTime;
FLOAT g_fPushBufferTimePerWait;
DWORD g_dwPresentWaits;
FLOAT g_fPresentWaitTime;
FLOAT g_fPresentTimePerWait;


// Perf testing function protocols
VOID StartPerfTest();
VOID StopPerfTest();
VOID PerfTestCallback();
VOID GetPerfStatistics();
VOID DisplayPerfResults( CXBFont* pFont );
VOID DumpPerfResults();


// Helper for getting the current time
__forceinline ULONGLONG ReadTimeStampCounter()
{
    _asm rdtsc
}


    
    
//-----------------------------------------------------------------------------
// Name: UpdateMenus()
// Desc: Update the perf test options in a menu. The menus are for the user to
//       be able to select various perf testing options.
//-----------------------------------------------------------------------------
VOID UpdateMenus( XBGAMEPAD* pGamepad )
{
    if( pGamepad->wPressedButtons & XINPUT_GAMEPAD_DPAD_DOWN )
    {
        if( g_Menus[g_dwSelectedMenu+1].strLabel )
            g_dwSelectedMenu++;
    }

    if( pGamepad->wPressedButtons & XINPUT_GAMEPAD_DPAD_UP )
    {
        if( g_dwSelectedMenu > 0 )
            g_dwSelectedMenu--;
    }

    if( pGamepad->wPressedButtons & XINPUT_GAMEPAD_DPAD_RIGHT )
    {
        if( g_Menus[g_dwSelectedMenu].strOptions[g_Menus[g_dwSelectedMenu].dwSelection+1] )
            g_Menus[g_dwSelectedMenu].dwSelection++;
    }

    if( pGamepad->wPressedButtons & XINPUT_GAMEPAD_DPAD_LEFT )
    {
        if( g_Menus[g_dwSelectedMenu].dwSelection > 0 )
            g_Menus[g_dwSelectedMenu].dwSelection--;
    }
}




//-----------------------------------------------------------------------------
// Name: DisplayMenus()
// Desc: Display the perf test options in a menu. The menus are for the user to
//       be able to select various perf testing options.
//-----------------------------------------------------------------------------
VOID DisplayMenus( CXBFont* pFont )
{
    // Draw the menus
    for( DWORD i=0; i<1000; i++ )
    {
        if( NULL == g_Menus[i].strLabel )
            break;

        // Show the selected menu in a different color
        DWORD dwColor = 0xff00ff00;
        if( i == g_dwSelectedMenu )
            dwColor = 0xffffffff;

        // Draw the text
        pFont->DrawText( 310.0f, 133.0f+i*25.0f, dwColor, g_Menus[i].strLabel, XBFONT_RIGHT );
        pFont->DrawText( 330.0f, 133.0f+i*25.0f, dwColor, g_Menus[i].strOptions[g_Menus[i].dwSelection] );
    }
}




//-----------------------------------------------------------------------------
// Name: StartPerfTest()
// Desc: Starts the performance testing by setting the m_FrameRateIntervalTime
//       to a non-zero amount in milliseconds. Note that this "typical" way to
//       do this is simply by modifying the global D3D::g_PerfCounters directly
//       in a debugger watch window.
//-----------------------------------------------------------------------------
VOID StartPerfTest()
{
    // Get perf test options from the in-app menu selections
    if( g_Menus[MENU_TESTDURATION].dwSelection == MENU_TESTDURATION_1SECOND )
        g_fPerfTestTime = 1.0f;
    if( g_Menus[MENU_TESTDURATION].dwSelection == MENU_TESTDURATION_2SECONDS )
        g_fPerfTestTime = 2.0f;
    if( g_Menus[MENU_TESTDURATION].dwSelection == MENU_TESTDURATION_5SECONDS )
        g_fPerfTestTime = 5.0f;

    if( g_Menus[MENU_OUTPUTMETHOD].dwSelection == MENU_OUTPUTMETHOD_ONSCREEN )
        g_bDumpToScreen = TRUE;
    else 
        g_bDumpToScreen = FALSE;

    if( g_Menus[MENU_PERFPROFILER].dwSelection == MENU_PERFPROFILER_ENABLED )
        g_bEnablePerfProfiler = TRUE;
    else 
        g_bEnablePerfProfiler = FALSE;

    // Start the perf test by setting the FrameRateIntervalTime
    D3DPERF_Reset();
    D3DPERF* pPerfCounters   = D3DPERF_GetStatistics();
    pPerfCounters->m_pfnDumpFrameRateInfoHandler = (PFNDumpFrameRateInfoHandler)PerfTestCallback;
    pPerfCounters->m_FrameRateIntervalTime       = (DWORD)g_fPerfTestTime*1000;
    if( g_bEnablePerfProfiler )
        D3DPERF_StartPerfProfile();

    g_bPerfTestRunning = TRUE;
}




//-----------------------------------------------------------------------------
// Name: StopPerfTest()
// Desc: Stops the performance testing by setting the m_FrameRateIntervalTime
//       to zero. Note that this "typical" way to do this is simply by
//       modifying the global D3D::g_PerfCounters directly in a debugger watch
//       window.
//-----------------------------------------------------------------------------
VOID StopPerfTest()
{
    // Access the perf counters
    D3DPERF* pPerfCounters = D3DPERF_GetStatistics();

    // Turn off the perf test by setting the FrameRateIntervalTime to zero
    pPerfCounters->m_FrameRateIntervalTime = 0;
    if( g_bEnablePerfProfiler )
        D3DPERF_StopPerfProfile();

    g_bPerfTestRunning = FALSE;
}




//-----------------------------------------------------------------------------
// Name: GetPerfStatistics()
// Desc: Extracts perfromance statistics from the API and stores them in
//       external variables. This code is only used by the optional callback
//       functions which display the results of the perf testing. (The callback
//       functions are optional because the internal perf testing API, by
//       default, dumps similiar information to the debug port.)
//-----------------------------------------------------------------------------
VOID GetPerfStatistics()
{
    // Access the perf counters
    D3DPERF* pPerfCounters = D3DPERF_GetStatistics();

    // Get time (in microseconds), number of frames, and framerate
    g_fTime       = (FLOAT)(ReadTimeStampCounter() - pPerfCounters->m_TSCLastResetVal) / 733.0f;
    g_dwNumFrames = pPerfCounters->m_APICounters[API_D3DDEVICE_PRESENT];
    g_fFPS        = 1000000.0f * g_dwNumFrames / g_fTime;

    // Get pushbuffer and vertex stats for frames
    D3DPUSHBUFFERINFO PushBufferInfo;
    D3DPERF_GetPushBufferInfo( &PushBufferInfo );
    g_fPushBufferBytes = ((FLOAT)PushBufferInfo.PushBufferBytesWritten)/g_dwNumFrames;
    g_fVertices        = ((FLOAT)pPerfCounters->m_PerformanceCounters[PERF_VERTICES].Count)/g_dwNumFrames;

    // Calc avg, min and max frame times
    g_fMinFrameTime = (FLOAT)(pPerfCounters->m_FrameTimeMin.Cycles)/733000.0f;
    g_fAvgFrameTime = 0.001f * g_fTime / g_dwNumFrames;
    g_fMaxFrameTime = (FLOAT)(pPerfCounters->m_FrameTimeMax.Cycles)/733000.0f;

    // Get profile results
    g_dwNumProfileSamples  = pPerfCounters->m_ProfileSamples;
    g_dwNumGPUSamples      = pPerfCounters->m_ProfileBusyCounts[0];
    g_dwNumFrontEndSamples = pPerfCounters->m_ProfileBusyCounts[1];
    g_dwNumBackEndSamples  = pPerfCounters->m_ProfileBusyCounts[2];

    g_dwObjectLockWaits      = pPerfCounters->m_PerformanceCounters[PERF_OBJECTLOCK_WAITS].Count;
    g_fObjectLockWaitTime    = (FLOAT)(pPerfCounters->m_PerformanceCounters[PERF_OBJECTLOCK_WAITS].Cycles) / 733.0f;
    g_fObjectLockTimePerWait = g_fObjectLockWaitTime / g_dwObjectLockWaits;

    g_dwPushBufferWaits      = pPerfCounters->m_PerformanceCounters[PERF_PUSHBUFFER_WAITS].Count;
    g_fPushBufferWaitTime    = (FLOAT)(pPerfCounters->m_PerformanceCounters[PERF_PUSHBUFFER_WAITS].Cycles) / 733.0f;
    g_fPushBufferTimePerWait = g_fPushBufferWaitTime / g_dwPushBufferWaits;
    
    g_dwPresentWaits         = pPerfCounters->m_PerformanceCounters[PERF_PRESENT_WAITS].Count;
    g_fPresentWaitTime       = (FLOAT)(pPerfCounters->m_PerformanceCounters[PERF_PRESENT_WAITS].Cycles) / 733.0f;
    g_fPresentTimePerWait    = g_fPresentWaitTime / g_dwPresentWaits;
}




//-----------------------------------------------------------------------------
// Name: PerfTestCallback()
// Desc: This function is called by the D3D8Perf API. We set this callback
//       function by setting the m_pfnDumpFrameRateInfoHandler member in the
//       D3DPERF structure. If we don't set this member, then the internal
//       performance testing functions will simply dump information repeatedly
//       to the debug port, which is adequate for most uses of perf testing.
//       The only reason we supply a callback is to demonstrate it in case an
//       app would want to customize the formatting of the results, or display
//       the information on screen.
//-----------------------------------------------------------------------------
VOID PerfTestCallback()
{
    // Get the perf stats
    GetPerfStatistics();

    // Turn off the perf test. We could let the performance testing run
    // indefinately or, as we use it here, treat it as a one-shot deal.
    StopPerfTest();

    if( g_bDumpToScreen )
    {
        // Flag the app to display the perf results on the screen
        g_bDisplayPerfResults = TRUE;
    }
    else
    {
        // Do an immediate dump of the perf results to the debug port
        DumpPerfResults();
    }
}




//-----------------------------------------------------------------------------
// Name: DumpPerfResults()
// Desc: Dumps the perf results to the debug port. This function mimics the
//       default behavior of how the perftest internal functions will dump info
//       to the debug port. We mimic it here to demonstate the use of the user-
//       supplied callback function.
//-----------------------------------------------------------------------------
VOID DumpPerfResults()
{
    // Display header
    CHAR strBuffer[200];
    sprintf( strBuffer, "\nPERFORMANCE TEST RESULTS\n"
                        "---------------------------------------------\n" );
    OUTPUT_DEBUG_STRING( strBuffer );
    
    // Display test stats
    sprintf( strBuffer, "Test stats:\n" );
    OUTPUT_DEBUG_STRING( strBuffer );
    sprintf( strBuffer, "   Test ran for %1.3f ms\n", g_fTime*0.001f );
    OUTPUT_DEBUG_STRING( strBuffer );
    sprintf( strBuffer, "   Test covered %ld frames\n", g_dwNumFrames );
    OUTPUT_DEBUG_STRING( strBuffer );
    sprintf( strBuffer, "   %1.0f bytes/frame written to pushbuffer\n", g_fPushBufferBytes );
    OUTPUT_DEBUG_STRING( strBuffer );
    sprintf( strBuffer, "   %1.0f vertices/frame\n", g_fVertices );
    OUTPUT_DEBUG_STRING( strBuffer );
    OUTPUT_DEBUG_STRING( "\n" );

    // Output avg, min and max frame times
    sprintf( strBuffer, "Frame stats:\n"
                        "   Frame rate was %1.2f fps\n"
                        "   Min frame time was %1.3f ms\n"
                        "   Avg frame time was %1.3f ms\n"
                        "   Max frame time was %1.3f ms\n",
                        g_fFPS,
                        g_fMinFrameTime,
                        g_fAvgFrameTime,
                        g_fMaxFrameTime );
    OUTPUT_DEBUG_STRING( strBuffer );

    // Dump profile results
    if( g_bEnablePerfProfiler && g_dwNumProfileSamples )
    {
        sprintf( strBuffer, "Profiling:\n" );
        OUTPUT_DEBUG_STRING( strBuffer );
        sprintf( strBuffer, "   %ld samples for GPU (%ld%% busy)\n", 
                            g_dwNumGPUSamples,
                            g_dwNumGPUSamples * 100 / g_dwNumProfileSamples );
        OUTPUT_DEBUG_STRING( strBuffer );
        sprintf( strBuffer, "   %ld samples for vertex processing (%ld%% busy)\n", 
                            g_dwNumFrontEndSamples,
                            g_dwNumFrontEndSamples * 100 / g_dwNumProfileSamples );
        OUTPUT_DEBUG_STRING( strBuffer );
        sprintf( strBuffer, "   %ld samples for rasterization (%ld%% busy)\n",
                            g_dwNumBackEndSamples,
                            g_dwNumBackEndSamples * 100 / g_dwNumProfileSamples );
        OUTPUT_DEBUG_STRING( strBuffer );
        sprintf( strBuffer, "   %ld total samples\n", g_dwNumProfileSamples );
        OUTPUT_DEBUG_STRING( strBuffer );
    }

    OUTPUT_DEBUG_STRING( "\n" );

    // Output wait info
    sprintf( strBuffer, "Wait info:\n" );
    OUTPUT_DEBUG_STRING( strBuffer );

    // Output number of times we waited while objects were begin locked
    if( g_dwObjectLockWaits )
    {
        sprintf( strBuffer, "   %ld Object lock waits took %1.3f ms (%1.1f waits/frame at %1.3f ms/frame)\n",
                            g_dwObjectLockWaits, g_fObjectLockWaitTime*0.001f, (FLOAT)(g_dwObjectLockWaits)/g_dwNumFrames, 
                            g_fObjectLockWaitTime*0.001f/g_dwNumFrames );
        OUTPUT_DEBUG_STRING( strBuffer );
    }

    // Output number of times we waited for the pushbuffer
    if( g_dwPushBufferWaits )
    {
        sprintf( strBuffer, "   %ld Pushbuffer waits took %1.3f ms (%1.1f waits/frame at %1.3f ms/frame)\n",
                            g_dwPushBufferWaits, g_fPushBufferWaitTime*0.001f, (FLOAT)(g_dwPushBufferWaits)/g_dwNumFrames,
                            g_fPushBufferWaitTime*0.001f/g_dwNumFrames );
        OUTPUT_DEBUG_STRING( strBuffer );
    }

    // Output number of times we waited to present
    if( g_dwPresentWaits )
    {
        sprintf( strBuffer, "   Present waits took %5.2f%% of the total time (%1.1f waits/frame taking %1.3f ms/frame)\n",
                            100*g_fPresentWaitTime/g_fTime, (FLOAT)(g_dwPresentWaits)/g_dwNumFrames,
                            g_fPresentWaitTime*0.001f/g_dwNumFrames );
        OUTPUT_DEBUG_STRING( strBuffer );
    }

    if( g_dwObjectLockWaits==0 && g_dwPushBufferWaits==0 && g_dwPresentWaits==0 )
    {
        sprintf( strBuffer, "   No waits occurred.\n" );
        OUTPUT_DEBUG_STRING( strBuffer );
    }

    OUTPUT_DEBUG_STRING( "\n" );

}




//-----------------------------------------------------------------------------
// Name: DisplayPerfResults()
// Desc: Displays the perf results on the screen. This function mimics the
//       default behavior of how the perftest internal functions will dump info
//       to the debug port. We mimic it here to demonstate the use of the user-
//       supplied callback function.
//-----------------------------------------------------------------------------
VOID DisplayPerfResults( CXBFont* pFont )
{
    // Access the perf counters
    WCHAR strBuffer[200];
    FLOAT sx =  64;
    FLOAT sy = 133;

    // Display test stats
    swprintf( strBuffer, L"Test ran for %1.3f ms, covering %ld frames\n", g_fTime*0.001f, g_dwNumFrames );
    pFont->DrawText( sx, sy, 0xffffffff, strBuffer ); sy+=19;
    swprintf( strBuffer, L"Frame rate was %1.2f fps:\n"
                         L"   Min frame time was %1.3f ms\n"
                         L"   Avg frame time was %1.3f ms\n"
                         L"   Max frame time was %1.3f ms\n",
                         g_fFPS,
                         g_fMinFrameTime,
                         g_fAvgFrameTime,
                         g_fMaxFrameTime );
    pFont->DrawText( sx, sy, 0xffffffff, strBuffer ); sy+=95;

    // Dump profile results
    if( g_bEnablePerfProfiler && g_dwNumProfileSamples )
    {
        swprintf( strBuffer, L"Profiling (%ld samples total):\n", g_dwNumProfileSamples );
        pFont->DrawText( sx, sy, 0xffffffff, strBuffer ); sy+=19;
        swprintf( strBuffer, L"   %ld samples for GPU (%ld%% busy)\n", 
                             g_dwNumGPUSamples,
                             g_dwNumGPUSamples * 100 / g_dwNumProfileSamples );
        pFont->DrawText( sx, sy, 0xffffffff, strBuffer ); sy+=19;
        swprintf( strBuffer, L"   %ld samples for vertex processing (%ld%% busy)\n", 
                             g_dwNumFrontEndSamples,
                             g_dwNumFrontEndSamples * 100 / g_dwNumProfileSamples );
        pFont->DrawText( sx, sy, 0xffffffff, strBuffer ); sy+=19;
        swprintf( strBuffer, L"   %ld samples for rasterization (%ld%% busy)\n",
                             g_dwNumBackEndSamples,
                             g_dwNumBackEndSamples * 100 / g_dwNumProfileSamples );
        pFont->DrawText( sx, sy, 0xffffffff, strBuffer ); sy+=38;
    }

    // Output wait info
    swprintf( strBuffer, L"Wait info:\n" );
    pFont->DrawText( sx, sy, 0xffffffff, strBuffer ); sy+=19;

    // Output number of times we waited while objects were begin locked
    if( g_dwObjectLockWaits )
    {
        swprintf( strBuffer, L"   Object lock waits took %5.2f%% of the total time (%1.1f waits/frame taking %1.3f ms/frame)\n",
                             100*g_fObjectLockWaitTime/g_fTime, (FLOAT)(g_dwObjectLockWaits)/g_dwNumFrames,
                             g_fObjectLockWaitTime*0.001f/g_dwNumFrames );
        pFont->DrawText( sx, sy, 0xffffffff, strBuffer ); sy+=19;
    }

    // Output number of times we waited for the pushbuffer
    if( g_dwPushBufferWaits )
    {
        swprintf( strBuffer, L"   Pushbuffer waits took %5.2f%% of the total time (%1.1f waits/frame taking %1.3f ms/frame)\n",
                             100*g_fPushBufferWaitTime/g_fTime, (FLOAT)(g_dwPushBufferWaits)/g_dwNumFrames,
                             g_fPushBufferWaitTime*0.001f/g_dwNumFrames );
        pFont->DrawText( sx, sy, 0xffffffff, strBuffer ); sy+=19;
    }

    // Output number of times we waited to present
    if( g_dwPresentWaits )
    {
        swprintf( strBuffer, L"   %1.1f Present waits/frame took %5.2f%% of the total time\n",
                             (FLOAT)(g_dwPresentWaits)/g_dwNumFrames, 100*g_fPresentWaitTime/g_fTime );
        pFont->DrawText( sx, sy, 0xffffffff, strBuffer ); sy+=19;
    }

    if( g_dwObjectLockWaits==0 && g_dwPushBufferWaits==0 && g_dwPresentWaits==0 )
    {
        swprintf( strBuffer, L"   No waits occurred.\n" );
        pFont->DrawText( sx, sy, 0xffffffff, strBuffer ); sy+=19;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\PerfTest\obj\i386\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 9UL

#define resource_Light_OFFSET 0UL
#define resource_SkyBoxXP_OFFSET 20UL
#define resource_SkyBoxXN_OFFSET 40UL
#define resource_SkyBoxYP_OFFSET 60UL
#define resource_SkyBoxYN_OFFSET 80UL
#define resource_SkyBoxZP_OFFSET 100UL
#define resource_SkyBoxZN_OFFSET 120UL
#define resource_StoneHen_OFFSET 140UL
#define resource_StoneHea_OFFSET 160UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\perpixellighting\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\perpixellighting\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\perpixellighting\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\perpixellighting\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\perpixellighting\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\patch\teapot.h ===
//-----------------------------------------------------------------------------
// File: Teapot.h
//
// Desc: Bezier patch data for a teapot
//
// Hist: 12.18.00 - New for January XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------




// Geometric center of the teapot patch data
const D3DXVECTOR3 g_vTeapotCenter = D3DXVECTOR3( 0.0f, 0.0f, -64.0f );




// Utah Teapot Bezier Patch Data
const D3DXVECTOR3 g_vTeapotData[] = 
{
    // Back
    D3DXVECTOR3(-80.00f,  0.00f,-30.00f ),     D3DXVECTOR3(-80.00f,-44.80f,-30.00f ),
    D3DXVECTOR3(-44.80f,-80.00f,-30.00f ),     D3DXVECTOR3(  0.00f,-80.00f,-30.00f ),
    D3DXVECTOR3(-80.00f,  0.00f,-12.00f ),     D3DXVECTOR3(-80.00f,-44.80f,-12.00f ),
    D3DXVECTOR3(-44.80f,-80.00f,-12.00f ),     D3DXVECTOR3(  0.00f,-80.00f,-12.00f ),
    D3DXVECTOR3(-60.00f,  0.00f, -3.00f ),     D3DXVECTOR3(-60.00f,-33.60f, -3.00f ),
    D3DXVECTOR3(-33.60f,-60.00f, -3.00f ),     D3DXVECTOR3(  0.00f,-60.00f, -3.00f ),
    D3DXVECTOR3(-60.00f,  0.00f,  0.00f ),     D3DXVECTOR3(-60.00f,-33.60f,  0.00f ),
    D3DXVECTOR3(-33.60f,-60.00f,  0.00f ),     D3DXVECTOR3(  0.00f,-60.00f,  0.00f ),

    D3DXVECTOR3(  0.00f,-80.00f,-30.00f ),     D3DXVECTOR3( 44.80f,-80.00f,-30.00f ),
    D3DXVECTOR3( 80.00f,-44.80f,-30.00f ),     D3DXVECTOR3( 80.00f,  0.00f,-30.00f ),
    D3DXVECTOR3(  0.00f,-80.00f,-12.00f ),     D3DXVECTOR3( 44.80f,-80.00f,-12.00f ),
    D3DXVECTOR3( 80.00f,-44.80f,-12.00f ),     D3DXVECTOR3( 80.00f,  0.00f,-12.00f ),
    D3DXVECTOR3(  0.00f,-60.00f, -3.00f ),     D3DXVECTOR3( 33.60f,-60.00f, -3.00f ),
    D3DXVECTOR3( 60.00f,-33.60f, -3.00f ),     D3DXVECTOR3( 60.00f,  0.00f, -3.00f ),
    D3DXVECTOR3(  0.00f,-60.00f,  0.00f ),     D3DXVECTOR3( 33.60f,-60.00f,  0.00f ),
    D3DXVECTOR3( 60.00f,-33.60f,  0.00f ),     D3DXVECTOR3( 60.00f,  0.00f,  0.00f ),

    D3DXVECTOR3(-60.00f,  0.00f,-90.00f ),     D3DXVECTOR3(-60.00f,-33.60f,-90.00f ),
    D3DXVECTOR3(-33.60f,-60.00f,-90.00f ),     D3DXVECTOR3(  0.00f,-60.00f,-90.00f ),
    D3DXVECTOR3(-70.00f,  0.00f,-69.00f ),     D3DXVECTOR3(-70.00f,-39.20f,-69.00f ),
    D3DXVECTOR3(-39.20f,-70.00f,-69.00f ),     D3DXVECTOR3(  0.00f,-70.00f,-69.00f ),
    D3DXVECTOR3(-80.00f,  0.00f,-48.00f ),     D3DXVECTOR3(-80.00f,-44.80f,-48.00f ),
    D3DXVECTOR3(-44.80f,-80.00f,-48.00f ),     D3DXVECTOR3(  0.00f,-80.00f,-48.00f ),
    D3DXVECTOR3(-80.00f,  0.00f,-30.00f ),     D3DXVECTOR3(-80.00f,-44.80f,-30.00f ),
    D3DXVECTOR3(-44.80f,-80.00f,-30.00f ),     D3DXVECTOR3(  0.00f,-80.00f,-30.00f ),

    D3DXVECTOR3(  0.00f,-60.00f,-90.00f ),     D3DXVECTOR3( 33.60f,-60.00f,-90.00f ),
    D3DXVECTOR3( 60.00f,-33.60f,-90.00f ),     D3DXVECTOR3( 60.00f,  0.00f,-90.00f ),
    D3DXVECTOR3(  0.00f,-70.00f,-69.00f ),     D3DXVECTOR3( 39.20f,-70.00f,-69.00f ),
    D3DXVECTOR3( 70.00f,-39.20f,-69.00f ),     D3DXVECTOR3( 70.00f,  0.00f,-69.00f ),
    D3DXVECTOR3(  0.00f,-80.00f,-48.00f ),     D3DXVECTOR3( 44.80f,-80.00f,-48.00f ),
    D3DXVECTOR3( 80.00f,-44.80f,-48.00f ),     D3DXVECTOR3( 80.00f,  0.00f,-48.00f ),
    D3DXVECTOR3(  0.00f,-80.00f,-30.00f ),     D3DXVECTOR3( 44.80f,-80.00f,-30.00f ),
    D3DXVECTOR3( 80.00f,-44.80f,-30.00f ),     D3DXVECTOR3( 80.00f,  0.00f,-30.00f ),

    D3DXVECTOR3(-56.00f,  0.00f,-90.00f ),     D3DXVECTOR3(-56.00f,-31.36f,-90.00f ),
    D3DXVECTOR3(-31.36f,-56.00f,-90.00f ),     D3DXVECTOR3(  0.00f,-56.00f,-90.00f ),
    D3DXVECTOR3(-53.50f,  0.00f,-95.25f ),     D3DXVECTOR3(-53.50f,-29.96f,-95.25f ),
    D3DXVECTOR3(-29.96f,-53.50f,-95.25f ),     D3DXVECTOR3(  0.00f,-53.50f,-95.25f ),
    D3DXVECTOR3(-57.50f,  0.00f,-95.25f ),     D3DXVECTOR3(-57.50f,-32.20f,-95.25f ),
    D3DXVECTOR3(-32.20f,-57.50f,-95.25f ),     D3DXVECTOR3(  0.00f,-57.50f,-95.25f ),
    D3DXVECTOR3(-60.00f,  0.00f,-90.00f ),     D3DXVECTOR3(-60.00f,-33.60f,-90.00f ),
    D3DXVECTOR3(-33.60f,-60.00f,-90.00f ),     D3DXVECTOR3(  0.00f,-60.00f,-90.00f ),

    D3DXVECTOR3(  0.00f,-56.00f,-90.00f ),     D3DXVECTOR3( 31.36f,-56.00f,-90.00f ),
    D3DXVECTOR3( 56.00f,-31.36f,-90.00f ),     D3DXVECTOR3( 56.00f,  0.00f,-90.00f ),
    D3DXVECTOR3(  0.00f,-53.50f,-95.25f ),     D3DXVECTOR3( 29.96f,-53.50f,-95.25f ),
    D3DXVECTOR3( 53.50f,-29.96f,-95.25f ),     D3DXVECTOR3( 53.50f,  0.00f,-95.25f ),
    D3DXVECTOR3(  0.00f,-57.50f,-95.25f ),     D3DXVECTOR3( 32.20f,-57.50f,-95.25f ),
    D3DXVECTOR3( 57.50f,-32.20f,-95.25f ),     D3DXVECTOR3( 57.50f,  0.00f,-95.25f ),
    D3DXVECTOR3(  0.00f,-60.00f,-90.00f ),     D3DXVECTOR3( 33.60f,-60.00f,-90.00f ),
    D3DXVECTOR3( 60.00f,-33.60f,-90.00f ),     D3DXVECTOR3( 60.00f,  0.00f,-90.00f ),

    // Front
    D3DXVECTOR3( 80.00f,  0.00f,-30.00f ),     D3DXVECTOR3( 80.00f, 44.80f,-30.00f ),
    D3DXVECTOR3( 44.80f, 80.00f,-30.00f ),     D3DXVECTOR3(  0.00f, 80.00f,-30.00f ),
    D3DXVECTOR3( 80.00f,  0.00f,-12.00f ),     D3DXVECTOR3( 80.00f, 44.80f,-12.00f ),
    D3DXVECTOR3( 44.80f, 80.00f,-12.00f ),     D3DXVECTOR3(  0.00f, 80.00f,-12.00f ),
    D3DXVECTOR3( 60.00f,  0.00f, -3.00f ),     D3DXVECTOR3( 60.00f, 33.60f, -3.00f ),
    D3DXVECTOR3( 33.60f, 60.00f, -3.00f ),     D3DXVECTOR3(  0.00f, 60.00f, -3.00f ),
    D3DXVECTOR3( 60.00f,  0.00f,  0.00f ),     D3DXVECTOR3( 60.00f, 33.60f,  0.00f ),
    D3DXVECTOR3( 33.60f, 60.00f,  0.00f ),     D3DXVECTOR3(  0.00f, 60.00f,  0.00f ),

    D3DXVECTOR3(  0.00f, 80.00f,-30.00f ),     D3DXVECTOR3(-44.80f, 80.00f,-30.00f ),
    D3DXVECTOR3(-80.00f, 44.80f,-30.00f ),     D3DXVECTOR3(-80.00f,  0.00f,-30.00f ),
    D3DXVECTOR3(  0.00f, 80.00f,-12.00f ),     D3DXVECTOR3(-44.80f, 80.00f,-12.00f ),
    D3DXVECTOR3(-80.00f, 44.80f,-12.00f ),     D3DXVECTOR3(-80.00f,  0.00f,-12.00f ),
    D3DXVECTOR3(  0.00f, 60.00f, -3.00f ),     D3DXVECTOR3(-33.60f, 60.00f, -3.00f ),
    D3DXVECTOR3(-60.00f, 33.60f, -3.00f ),     D3DXVECTOR3(-60.00f,  0.00f, -3.00f ),
    D3DXVECTOR3(  0.00f, 60.00f,  0.00f ),     D3DXVECTOR3(-33.60f, 60.00f,  0.00f ),
    D3DXVECTOR3(-60.00f, 33.60f,  0.00f ),     D3DXVECTOR3(-60.00f,  0.00f,  0.00f ),

    D3DXVECTOR3( 60.00f,  0.00f,-90.00f ),     D3DXVECTOR3( 60.00f, 33.60f,-90.00f ),
    D3DXVECTOR3( 33.60f, 60.00f,-90.00f ),     D3DXVECTOR3(  0.00f, 60.00f,-90.00f ),
    D3DXVECTOR3( 70.00f,  0.00f,-69.00f ),     D3DXVECTOR3( 70.00f, 39.20f,-69.00f ),
    D3DXVECTOR3( 39.20f, 70.00f,-69.00f ),     D3DXVECTOR3(  0.00f, 70.00f,-69.00f ),
    D3DXVECTOR3( 80.00f,  0.00f,-48.00f ),     D3DXVECTOR3( 80.00f, 44.80f,-48.00f ),
    D3DXVECTOR3( 44.80f, 80.00f,-48.00f ),     D3DXVECTOR3(  0.00f, 80.00f,-48.00f ),
    D3DXVECTOR3( 80.00f,  0.00f,-30.00f ),     D3DXVECTOR3( 80.00f, 44.80f,-30.00f ),
    D3DXVECTOR3( 44.80f, 80.00f,-30.00f ),     D3DXVECTOR3(  0.00f, 80.00f,-30.00f ),

    D3DXVECTOR3(  0.00f, 60.00f,-90.00f ),     D3DXVECTOR3(-33.60f, 60.00f,-90.00f ),
    D3DXVECTOR3(-60.00f, 33.60f,-90.00f ),     D3DXVECTOR3(-60.00f,  0.00f,-90.00f ),
    D3DXVECTOR3(  0.00f, 70.00f,-69.00f ),     D3DXVECTOR3(-39.20f, 70.00f,-69.00f ),
    D3DXVECTOR3(-70.00f, 39.20f,-69.00f ),     D3DXVECTOR3(-70.00f,  0.00f,-69.00f ),
    D3DXVECTOR3(  0.00f, 80.00f,-48.00f ),     D3DXVECTOR3(-44.80f, 80.00f,-48.00f ),
    D3DXVECTOR3(-80.00f, 44.80f,-48.00f ),     D3DXVECTOR3(-80.00f,  0.00f,-48.00f ),
    D3DXVECTOR3(  0.00f, 80.00f,-30.00f ),     D3DXVECTOR3(-44.80f, 80.00f,-30.00f ),
    D3DXVECTOR3(-80.00f, 44.80f,-30.00f ),     D3DXVECTOR3(-80.00f,  0.00f,-30.00f ),

    D3DXVECTOR3( 56.00f,  0.00f,-90.00f ),     D3DXVECTOR3( 56.00f, 31.36f,-90.00f ),
    D3DXVECTOR3( 31.36f, 56.00f,-90.00f ),     D3DXVECTOR3(  0.00f, 56.00f,-90.00f ),
    D3DXVECTOR3( 53.50f,  0.00f,-95.25f ),     D3DXVECTOR3( 53.50f, 29.96f,-95.25f ),
    D3DXVECTOR3( 29.96f, 53.50f,-95.25f ),     D3DXVECTOR3(  0.00f, 53.50f,-95.25f ),
    D3DXVECTOR3( 57.50f,  0.00f,-95.25f ),     D3DXVECTOR3( 57.50f, 32.20f,-95.25f ),
    D3DXVECTOR3( 32.20f, 57.50f,-95.25f ),     D3DXVECTOR3(  0.00f, 57.50f,-95.25f ),
    D3DXVECTOR3( 60.00f,  0.00f,-90.00f ),     D3DXVECTOR3( 60.00f, 33.60f,-90.00f ),
    D3DXVECTOR3( 33.60f, 60.00f,-90.00f ),     D3DXVECTOR3(  0.00f, 60.00f,-90.00f ),

    D3DXVECTOR3(  0.00f, 56.00f,-90.00f ),     D3DXVECTOR3(-31.36f, 56.00f,-90.00f ),
    D3DXVECTOR3(-56.00f, 31.36f,-90.00f ),     D3DXVECTOR3(-56.00f,  0.00f,-90.00f ),
    D3DXVECTOR3(  0.00f, 53.50f,-95.25f ),     D3DXVECTOR3(-29.96f, 53.50f,-95.25f ),
    D3DXVECTOR3(-53.50f, 29.96f,-95.25f ),     D3DXVECTOR3(-53.50f,  0.00f,-95.25f ),
    D3DXVECTOR3(  0.00f, 57.50f,-95.25f ),     D3DXVECTOR3(-32.20f, 57.50f,-95.25f ),
    D3DXVECTOR3(-57.50f, 32.20f,-95.25f ),     D3DXVECTOR3(-57.50f,  0.00f,-95.25f ),
    D3DXVECTOR3(  0.00f, 60.00f,-90.00f ),     D3DXVECTOR3(-33.60f, 60.00f,-90.00f ),
    D3DXVECTOR3(-60.00f, 33.60f,-90.00f ),     D3DXVECTOR3(-60.00f,  0.00f,-90.00f ),

    // Handle
    D3DXVECTOR3( -64.00f,  0.00f,-75.00f ),    D3DXVECTOR3( -64.00f, 12.00f,-75.00f ),
    D3DXVECTOR3( -60.00f, 12.00f,-84.00f ),    D3DXVECTOR3( -60.00f,  0.00f,-84.00f ),
    D3DXVECTOR3( -92.00f,  0.00f,-75.00f ),    D3DXVECTOR3( -92.00f, 12.00f,-75.00f ),
    D3DXVECTOR3(-100.00f, 12.00f,-84.00f ),    D3DXVECTOR3(-100.00f,  0.00f,-84.00f ),
    D3DXVECTOR3(-108.00f,  0.00f,-75.00f ),    D3DXVECTOR3(-108.00f, 12.00f,-75.00f ),
    D3DXVECTOR3(-120.00f, 12.00f,-84.00f ),    D3DXVECTOR3(-120.00f,  0.00f,-84.00f ),
    D3DXVECTOR3(-108.00f,  0.00f,-66.00f ),    D3DXVECTOR3(-108.00f, 12.00f,-66.00f ),
    D3DXVECTOR3(-120.00f, 12.00f,-66.00f ),    D3DXVECTOR3(-120.00f,  0.00f,-66.00f ),

    D3DXVECTOR3( -60.00f,  0.00f,-84.00f ),    D3DXVECTOR3( -60.00f,-12.00f,-84.00f ),
    D3DXVECTOR3( -64.00f,-12.00f,-75.00f ),    D3DXVECTOR3( -64.00f,  0.00f,-75.00f ),
    D3DXVECTOR3(-100.00f,  0.00f,-84.00f ),    D3DXVECTOR3(-100.00f,-12.00f,-84.00f ),
    D3DXVECTOR3( -92.00f,-12.00f,-75.00f ),    D3DXVECTOR3( -92.00f,  0.00f,-75.00f ),
    D3DXVECTOR3(-120.00f,  0.00f,-84.00f ),    D3DXVECTOR3(-120.00f,-12.00f,-84.00f ),
    D3DXVECTOR3(-108.00f,-12.00f,-75.00f ),    D3DXVECTOR3(-108.00f,  0.00f,-75.00f ),
    D3DXVECTOR3(-120.00f,  0.00f,-66.00f ),    D3DXVECTOR3(-120.00f,-12.00f,-66.00f ),
    D3DXVECTOR3(-108.00f,-12.00f,-66.00f ),    D3DXVECTOR3(-108.00f,  0.00f,-66.00f ),

    D3DXVECTOR3(-108.00f,  0.00f,-66.00f ),    D3DXVECTOR3(-108.00f, 12.00f,-66.00f ),
    D3DXVECTOR3(-120.00f, 12.00f,-66.00f ),    D3DXVECTOR3(-120.00f,  0.00f,-66.00f ),
    D3DXVECTOR3(-108.00f,  0.00f,-57.00f ),    D3DXVECTOR3(-108.00f, 12.00f,-57.00f ),
    D3DXVECTOR3(-120.00f, 12.00f,-48.00f ),    D3DXVECTOR3(-120.00f,  0.00f,-48.00f ),
    D3DXVECTOR3(-100.00f,  0.00f,-39.00f ),    D3DXVECTOR3(-100.00f, 12.00f,-39.00f ),
    D3DXVECTOR3(-106.00f, 12.00f,-31.50f ),    D3DXVECTOR3(-106.00f,  0.00f,-31.50f ),
    D3DXVECTOR3( -80.00f,  0.00f,-30.00f ),    D3DXVECTOR3( -80.00f, 12.00f,-30.00f ),
    D3DXVECTOR3( -76.00f, 12.00f,-18.00f ),    D3DXVECTOR3( -76.00f,  0.00f,-18.00f ),

    D3DXVECTOR3(-120.00f,  0.00f,-66.00f ),    D3DXVECTOR3(-120.00f,-12.00f,-66.00f ),
    D3DXVECTOR3(-108.00f,-12.00f,-66.00f ),    D3DXVECTOR3(-108.00f,  0.00f,-66.00f ),
    D3DXVECTOR3(-120.00f,  0.00f,-48.00f ),    D3DXVECTOR3(-120.00f,-12.00f,-48.00f ),
    D3DXVECTOR3(-108.00f,-12.00f,-57.00f ),    D3DXVECTOR3(-108.00f,  0.00f,-57.00f ),
    D3DXVECTOR3(-106.00f,  0.00f,-31.50f ),    D3DXVECTOR3(-106.00f,-12.00f,-31.50f ),
    D3DXVECTOR3(-100.00f,-12.00f,-39.00f ),    D3DXVECTOR3(-100.00f,  0.00f,-39.00f ),
    D3DXVECTOR3( -76.00f,  0.00f,-18.00f ),    D3DXVECTOR3( -76.00f,-12.00f,-18.00f ),
    D3DXVECTOR3( -80.00f,-12.00f,-30.00f ),    D3DXVECTOR3( -80.00f,  0.00f,-30.00f ),

    // Spout
    D3DXVECTOR3( 68.00f,  0.00f,-51.00f ),     D3DXVECTOR3( 68.00f, 26.40f,-51.00f ),
    D3DXVECTOR3( 68.00f, 26.40f,-18.00f ),     D3DXVECTOR3( 68.00f,  0.00f,-18.00f ),
    D3DXVECTOR3(104.00f,  0.00f,-51.00f ),     D3DXVECTOR3(104.00f, 26.40f,-51.00f ),
    D3DXVECTOR3(124.00f, 26.40f,-27.00f ),     D3DXVECTOR3(124.00f,  0.00f,-27.00f ),
    D3DXVECTOR3( 92.00f,  0.00f,-78.00f ),     D3DXVECTOR3( 92.00f, 10.00f,-78.00f ),
    D3DXVECTOR3( 96.00f, 10.00f,-75.00f ),     D3DXVECTOR3( 96.00f,  0.00f,-75.00f ),
    D3DXVECTOR3(108.00f,  0.00f,-90.00f ),     D3DXVECTOR3(108.00f, 10.00f,-90.00f ),
    D3DXVECTOR3(132.00f, 10.00f,-90.00f ),     D3DXVECTOR3(132.00f,  0.00f,-90.00f ),

    D3DXVECTOR3( 68.00f,  0.00f,-18.00f ),     D3DXVECTOR3( 68.00f,-26.40f,-18.00f ),
    D3DXVECTOR3( 68.00f,-26.40f,-51.00f ),     D3DXVECTOR3( 68.00f,  0.00f,-51.00f ),
    D3DXVECTOR3(124.00f,  0.00f,-27.00f ),     D3DXVECTOR3(124.00f,-26.40f,-27.00f ),
    D3DXVECTOR3(104.00f,-26.40f,-51.00f ),     D3DXVECTOR3(104.00f,  0.00f,-51.00f ),
    D3DXVECTOR3( 96.00f,  0.00f,-75.00f ),     D3DXVECTOR3( 96.00f,-10.00f,-75.00f ),
    D3DXVECTOR3( 92.00f,-10.00f,-78.00f ),     D3DXVECTOR3( 92.00f,  0.00f,-78.00f ),
    D3DXVECTOR3(132.00f,  0.00f,-90.00f ),     D3DXVECTOR3(132.00f,-10.00f,-90.00f ),
    D3DXVECTOR3(108.00f,-10.00f,-90.00f ),     D3DXVECTOR3(108.00f,  0.00f,-90.00f ),

    D3DXVECTOR3(108.00f,  0.00f,-90.00f ),     D3DXVECTOR3(108.00f, 10.00f,-90.00f ),
    D3DXVECTOR3(132.00f, 10.00f,-90.00f ),     D3DXVECTOR3(132.00f,  0.00f,-90.00f ),
    D3DXVECTOR3(112.00f,  0.00f,-93.00f ),     D3DXVECTOR3(112.00f, 10.00f,-93.00f ),
    D3DXVECTOR3(141.00f, 10.00f,-93.75f ),     D3DXVECTOR3(141.00f,  0.00f,-93.75f ),
    D3DXVECTOR3(116.00f,  0.00f,-93.00f ),     D3DXVECTOR3(116.00f,  6.00f,-93.00f ),
    D3DXVECTOR3(138.00f,  6.00f,-94.50f ),     D3DXVECTOR3(138.00f,  0.00f,-94.50f ),
    D3DXVECTOR3(112.00f,  0.00f,-90.00f ),     D3DXVECTOR3(112.00f,  6.00f,-90.00f ),
    D3DXVECTOR3(128.00f,  6.00f,-90.00f ),     D3DXVECTOR3(128.00f,  0.00f,-90.00f ),

    D3DXVECTOR3(132.00f,  0.00f,-90.00f ),     D3DXVECTOR3(132.00f,-10.00f,-90.00f ),
    D3DXVECTOR3(108.00f,-10.00f,-90.00f ),     D3DXVECTOR3(108.00f,  0.00f,-90.00f ),
    D3DXVECTOR3(141.00f,  0.00f,-93.75f ),     D3DXVECTOR3(141.00f,-10.00f,-93.75f ),
    D3DXVECTOR3(112.00f,-10.00f,-93.00f ),     D3DXVECTOR3(112.00f,  0.00f,-93.00f ),
    D3DXVECTOR3(138.00f,  0.00f,-94.50f ),     D3DXVECTOR3(138.00f, -6.00f,-94.50f ),
    D3DXVECTOR3(116.00f, -6.00f,-93.00f ),     D3DXVECTOR3(116.00f,  0.00f,-93.00f ),
    D3DXVECTOR3(128.00f,  0.00f,-90.00f ),     D3DXVECTOR3(128.00f, -6.00f,-90.00f ),
    D3DXVECTOR3(112.00f, -6.00f,-90.00f ),     D3DXVECTOR3(112.00f,  0.00f,-90.00f ),

    // Lip
    D3DXVECTOR3( 50.00f,  0.00f,-90.00f ),     D3DXVECTOR3( 50.00f, 28.00f,-90.00f ),
    D3DXVECTOR3( 28.00f, 50.00f,-90.00f ),     D3DXVECTOR3(  0.00f, 50.00f,-90.00f ),
    D3DXVECTOR3( 52.00f,  0.00f,-90.00f ),     D3DXVECTOR3( 52.00f, 29.12f,-90.00f ),
    D3DXVECTOR3( 29.12f, 52.00f,-90.00f ),     D3DXVECTOR3(  0.00f, 52.00f,-90.00f ),
    D3DXVECTOR3( 54.00f,  0.00f,-90.00f ),     D3DXVECTOR3( 54.00f, 30.24f,-90.00f ),
    D3DXVECTOR3( 30.24f, 54.00f,-90.00f ),     D3DXVECTOR3(  0.00f, 54.00f,-90.00f ),
    D3DXVECTOR3( 56.00f,  0.00f,-90.00f ),     D3DXVECTOR3( 56.00f, 31.36f,-90.00f ),
    D3DXVECTOR3( 31.36f, 56.00f,-90.00f ),     D3DXVECTOR3(  0.00f, 56.00f,-90.00f ),

    D3DXVECTOR3(  0.00f, 50.00f,-90.00f ),     D3DXVECTOR3(-28.00f, 50.00f,-90.00f ),
    D3DXVECTOR3(-50.00f, 28.00f,-90.00f ),     D3DXVECTOR3(-50.00f,  0.00f,-90.00f ),
    D3DXVECTOR3(  0.00f, 52.00f,-90.00f ),     D3DXVECTOR3(-29.12f, 52.00f,-90.00f ),
    D3DXVECTOR3(-52.00f, 29.12f,-90.00f ),     D3DXVECTOR3(-52.00f,  0.00f,-90.00f ),
    D3DXVECTOR3(  0.00f, 54.00f,-90.00f ),     D3DXVECTOR3(-30.24f, 54.00f,-90.00f ),
    D3DXVECTOR3(-54.00f, 30.24f,-90.00f ),     D3DXVECTOR3(-54.00f,  0.00f,-90.00f ),
    D3DXVECTOR3(  0.00f, 56.00f,-90.00f ),     D3DXVECTOR3(-31.36f, 56.00f,-90.00f ),
    D3DXVECTOR3(-56.00f, 31.36f,-90.00f ),     D3DXVECTOR3(-56.00f,  0.00f,-90.00f ),

    D3DXVECTOR3(-50.00f,  0.00f,-90.00f ),     D3DXVECTOR3(-50.00f,-28.00f,-90.00f ),
    D3DXVECTOR3(-28.00f,-50.00f,-90.00f ),     D3DXVECTOR3(  0.00f,-50.00f,-90.00f ),
    D3DXVECTOR3(-52.00f,  0.00f,-90.00f ),     D3DXVECTOR3(-52.00f,-29.12f,-90.00f ),
    D3DXVECTOR3(-29.12f,-52.00f,-90.00f ),     D3DXVECTOR3(  0.00f,-52.00f,-90.00f ),
    D3DXVECTOR3(-54.00f,  0.00f,-90.00f ),     D3DXVECTOR3(-54.00f,-30.24f,-90.00f ),
    D3DXVECTOR3(-30.24f,-54.00f,-90.00f ),     D3DXVECTOR3(  0.00f,-54.00f,-90.00f ),
    D3DXVECTOR3(-56.00f,  0.00f,-90.00f ),     D3DXVECTOR3(-56.00f,-31.36f,-90.00f ),
    D3DXVECTOR3(-31.36f,-56.00f,-90.00f ),     D3DXVECTOR3(  0.00f,-56.00f,-90.00f ),

    D3DXVECTOR3(  0.00f,-50.00f,-90.00f ),     D3DXVECTOR3( 28.00f,-50.00f,-90.00f ),
    D3DXVECTOR3( 50.00f,-28.00f,-90.00f ),     D3DXVECTOR3( 50.00f,  0.00f,-90.00f ),
    D3DXVECTOR3(  0.00f,-52.00f,-90.00f ),     D3DXVECTOR3( 29.12f,-52.00f,-90.00f ),
    D3DXVECTOR3( 52.00f,-29.12f,-90.00f ),     D3DXVECTOR3( 52.00f,  0.00f,-90.00f ),
    D3DXVECTOR3(  0.00f,-54.00f,-90.00f ),     D3DXVECTOR3( 30.24f,-54.00f,-90.00f ),
    D3DXVECTOR3( 54.00f,-30.24f,-90.00f ),     D3DXVECTOR3( 54.00f,  0.00f,-90.00f ),
    D3DXVECTOR3(  0.00f,-56.00f,-90.00f ),     D3DXVECTOR3( 31.36f,-56.00f,-90.00f ),
    D3DXVECTOR3( 56.00f,-31.36f,-90.00f ),     D3DXVECTOR3( 56.00f,  0.00f,-90.00f ),

    // Lid
    D3DXVECTOR3(  8.00f,  0.00f,-102.00f ),     D3DXVECTOR3(  8.00f,  4.48f,-102.00f ),
    D3DXVECTOR3(  4.48f,  8.00f,-102.00f ),     D3DXVECTOR3(  0.00f,  8.00f,-102.00f ),
    D3DXVECTOR3( 16.00f,  0.00f, -96.00f ),     D3DXVECTOR3( 16.00f,  8.96f, -96.00f ),
    D3DXVECTOR3(  8.96f, 16.00f, -96.00f ),     D3DXVECTOR3(  0.00f, 16.00f, -96.00f ),
    D3DXVECTOR3( 52.00f,  0.00f, -96.00f ),     D3DXVECTOR3( 52.00f, 29.12f, -96.00f ),
    D3DXVECTOR3( 29.12f, 52.00f, -96.00f ),     D3DXVECTOR3(  0.00f, 52.00f, -96.00f ),
    D3DXVECTOR3( 52.00f,  0.00f, -90.00f ),     D3DXVECTOR3( 52.00f, 29.12f, -90.00f ),
    D3DXVECTOR3( 29.12f, 52.00f, -90.00f ),     D3DXVECTOR3(  0.00f, 52.00f, -90.00f ),

    D3DXVECTOR3(  0.00f,  8.00f,-102.00f ),     D3DXVECTOR3( -4.48f,  8.00f,-102.00f ),
    D3DXVECTOR3( -8.00f,  4.48f,-102.00f ),     D3DXVECTOR3( -8.00f,  0.00f,-102.00f ),
    D3DXVECTOR3(  0.00f, 16.00f, -96.00f ),     D3DXVECTOR3( -8.96f, 16.00f, -96.00f ),
    D3DXVECTOR3(-16.00f,  8.96f, -96.00f ),     D3DXVECTOR3(-16.00f,  0.00f, -96.00f ),
    D3DXVECTOR3(  0.00f, 52.00f, -96.00f ),     D3DXVECTOR3(-29.12f, 52.00f, -96.00f ),
    D3DXVECTOR3(-52.00f, 29.12f, -96.00f ),     D3DXVECTOR3(-52.00f,  0.00f, -96.00f ),
    D3DXVECTOR3(  0.00f, 52.00f, -90.00f ),     D3DXVECTOR3(-29.12f, 52.00f, -90.00f ),
    D3DXVECTOR3(-52.00f, 29.12f, -90.00f ),     D3DXVECTOR3(-52.00f,  0.00f, -90.00f ),

    D3DXVECTOR3( -8.00f,  0.00f,-102.00f ),     D3DXVECTOR3( -8.00f, -4.48f,-102.00f ),
    D3DXVECTOR3( -4.48f, -8.00f,-102.00f ),     D3DXVECTOR3(  0.00f, -8.00f,-102.00f ),
    D3DXVECTOR3(-16.00f,  0.00f, -96.00f ),     D3DXVECTOR3(-16.00f, -8.96f, -96.00f ),
    D3DXVECTOR3( -8.96f,-16.00f, -96.00f ),     D3DXVECTOR3(  0.00f,-16.00f, -96.00f ),
    D3DXVECTOR3(-52.00f,  0.00f, -96.00f ),     D3DXVECTOR3(-52.00f,-29.12f, -96.00f ),
    D3DXVECTOR3(-29.12f,-52.00f, -96.00f ),     D3DXVECTOR3(  0.00f,-52.00f, -96.00f ),
    D3DXVECTOR3(-52.00f,  0.00f, -90.00f ),     D3DXVECTOR3(-52.00f,-29.12f, -90.00f ),
    D3DXVECTOR3(-29.12f,-52.00f, -90.00f ),     D3DXVECTOR3(  0.00f,-52.00f, -90.00f ),

    D3DXVECTOR3(  0.00f, -8.00f,-102.00f ),     D3DXVECTOR3(  4.48f, -8.00f,-102.00f ),
    D3DXVECTOR3(  8.00f, -4.48f,-102.00f ),     D3DXVECTOR3(  8.00f,  0.00f,-102.00f ),
    D3DXVECTOR3(  0.00f,-16.00f, -96.00f ),     D3DXVECTOR3(  8.96f,-16.00f, -96.00f ),
    D3DXVECTOR3( 16.00f, -8.96f, -96.00f ),     D3DXVECTOR3( 16.00f,  0.00f, -96.00f ),
    D3DXVECTOR3(  0.00f,-52.00f, -96.00f ),     D3DXVECTOR3( 29.12f,-52.00f, -96.00f ),
    D3DXVECTOR3( 52.00f,-29.12f, -96.00f ),     D3DXVECTOR3( 52.00f,  0.00f, -96.00f ),
    D3DXVECTOR3(  0.00f,-52.00f, -90.00f ),     D3DXVECTOR3( 29.12f,-52.00f, -90.00f ),
    D3DXVECTOR3( 52.00f,-29.12f, -90.00f ),     D3DXVECTOR3( 52.00f,  0.00f, -90.00f ),

    // Knob
    D3DXVECTOR3(  0.00f,  0.00f,-120.00f ),     D3DXVECTOR3(  0.00f,  0.00f,-120.00f ),
    D3DXVECTOR3(  0.00f,  0.00f,-120.00f ),     D3DXVECTOR3(  0.00f,  0.00f,-120.00f ),
    D3DXVECTOR3( 32.00f,  0.00f,-120.00f ),     D3DXVECTOR3( 32.00f, 18.00f,-120.00f ),
    D3DXVECTOR3( 18.00f, 32.00f,-120.00f ),     D3DXVECTOR3(  0.00f, 32.00f,-120.00f ),
    D3DXVECTOR3(  0.00f,  0.00f,-108.00f ),     D3DXVECTOR3(  0.00f,  0.00f,-108.00f ),
    D3DXVECTOR3(  0.00f,  0.00f,-108.00f ),     D3DXVECTOR3(  0.00f,  0.00f,-108.00f ),
    D3DXVECTOR3(  8.00f,  0.00f,-102.00f ),     D3DXVECTOR3(  8.00f,  4.48f,-102.00f ),
    D3DXVECTOR3(  4.48f,  8.00f,-102.00f ),     D3DXVECTOR3(  0.00f,  8.00f,-102.00f ),

    D3DXVECTOR3(  0.00f,  0.00f,-120.00f ),     D3DXVECTOR3(  0.00f,  0.00f,-120.00f ),
    D3DXVECTOR3(  0.00f,  0.00f,-120.00f ),     D3DXVECTOR3(  0.00f,  0.00f,-120.00f ),
    D3DXVECTOR3(  0.00f, 32.00f,-120.00f ),     D3DXVECTOR3(-18.00f, 32.00f,-120.00f ),
    D3DXVECTOR3(-32.00f, 18.00f,-120.00f ),     D3DXVECTOR3(-32.00f,  0.00f,-120.00f ),
    D3DXVECTOR3(  0.00f,  0.00f,-108.00f ),     D3DXVECTOR3(  0.00f,  0.00f,-108.00f ),
    D3DXVECTOR3(  0.00f,  0.00f,-108.00f ),     D3DXVECTOR3(  0.00f,  0.00f,-108.00f ),
    D3DXVECTOR3(  0.00f,  8.00f,-102.00f ),     D3DXVECTOR3( -4.48f,  8.00f,-102.00f ),
    D3DXVECTOR3( -8.00f,  4.48f,-102.00f ),     D3DXVECTOR3( -8.00f,  0.00f,-102.00f ),

    D3DXVECTOR3(  0.00f,  0.00f,-120.00f ),     D3DXVECTOR3(  0.00f,  0.00f,-120.00f ),
    D3DXVECTOR3(  0.00f,  0.00f,-120.00f ),     D3DXVECTOR3(  0.00f,  0.00f,-120.00f ),
    D3DXVECTOR3(-32.00f,  0.00f,-120.00f ),     D3DXVECTOR3(-32.00f,-18.00f,-120.00f ),
    D3DXVECTOR3(-18.00f,-32.00f,-120.00f ),     D3DXVECTOR3(  0.00f,-32.00f,-120.00f ),
    D3DXVECTOR3(  0.00f,  0.00f,-108.00f ),     D3DXVECTOR3(  0.00f,  0.00f,-108.00f ),
    D3DXVECTOR3(  0.00f,  0.00f,-108.00f ),     D3DXVECTOR3(  0.00f,  0.00f,-108.00f ),
    D3DXVECTOR3( -8.00f,  0.00f,-102.00f ),     D3DXVECTOR3( -8.00f, -4.48f,-102.00f ),
    D3DXVECTOR3( -4.48f, -8.00f,-102.00f ),     D3DXVECTOR3(  0.00f, -8.00f,-102.00f ),

    D3DXVECTOR3(  0.00f,  0.00f,-120.00f ),     D3DXVECTOR3(  0.00f,  0.00f,-120.00f ),
    D3DXVECTOR3(  0.00f,  0.00f,-120.00f ),     D3DXVECTOR3(  0.00f,  0.00f,-120.00f ),
    D3DXVECTOR3(  0.00f,-32.00f,-120.00f ),     D3DXVECTOR3( 18.00f,-32.00f,-120.00f ),
    D3DXVECTOR3( 32.00f,-18.00f,-120.00f ),     D3DXVECTOR3( 32.00f,  0.00f,-120.00f ),
    D3DXVECTOR3(  0.00f,  0.00f,-108.00f ),     D3DXVECTOR3(  0.00f,  0.00f,-108.00f ),
    D3DXVECTOR3(  0.00f,  0.00f,-108.00f ),     D3DXVECTOR3(  0.00f,  0.00f,-108.00f ),
    D3DXVECTOR3(  0.00f, -8.00f,-102.00f ),     D3DXVECTOR3(  4.48f, -8.00f,-102.00f ),
    D3DXVECTOR3(  8.00f, -4.48f,-102.00f ),     D3DXVECTOR3(  8.00f,  0.00f,-102.00f ),

    // Bottom
    D3DXVECTOR3(  30.00f,   0.00f,  0.00f ),   D3DXVECTOR3(  20.00f,  10.00f,  0.00f ),
    D3DXVECTOR3(  10.00f,  20.00f,  0.00f ),   D3DXVECTOR3(   0.00f,  30.00f,  0.00f ),
    D3DXVECTOR3(  20.00f, -10.00f,  0.00f ),   D3DXVECTOR3(  10.00f,   0.00f,  0.00f ),
    D3DXVECTOR3(   0.00f,  10.00f,  0.00f ),   D3DXVECTOR3( -10.00f,  20.00f,  0.00f ),
    D3DXVECTOR3(  10.00f, -20.00f,  0.00f ),   D3DXVECTOR3(   0.00f, -10.00f,  0.00f ),
    D3DXVECTOR3( -10.00f,   0.00f,  0.00f ),   D3DXVECTOR3( -20.00f,  10.00f,  0.00f ),
    D3DXVECTOR3(   0.00f, -30.00f,  0.00f ),   D3DXVECTOR3( -10.00f, -20.00f,  0.00f ),
    D3DXVECTOR3( -20.00f, -10.00f,  0.00f ),   D3DXVECTOR3( -30.00f,   0.00f,  0.00f ),

    D3DXVECTOR3(  0.00f, 30.00f,  0.00f ),     D3DXVECTOR3( 10.00f, 20.00f,  0.00f ),
    D3DXVECTOR3( 20.00f, 10.00f,  0.00f ),     D3DXVECTOR3( 30.00f,  0.00f,  0.00f ),
    D3DXVECTOR3(  0.00f, 40.00f,  0.00f ),     D3DXVECTOR3( 17.20f, 33.00f,  0.00f ),
    D3DXVECTOR3( 33.00f, 17.20f,  0.00f ),     D3DXVECTOR3( 40.00f,  0.00f,  0.00f ),
    D3DXVECTOR3(  0.00f, 50.00f,  0.00f ),     D3DXVECTOR3( 24.40f, 47.00f,  0.00f ),
    D3DXVECTOR3( 47.00f, 24.40f,  0.00f ),     D3DXVECTOR3( 50.00f,  0.00f,  0.00f ),
    D3DXVECTOR3(  0.00f, 60.00f,  0.00f ),     D3DXVECTOR3( 33.60f, 60.00f,  0.00f ),
    D3DXVECTOR3( 60.00f, 33.60f,  0.00f ),     D3DXVECTOR3( 60.00f,  0.00f,  0.00f ), 

    D3DXVECTOR3(  0.00f,-30.00f,  0.00f ),     D3DXVECTOR3(-10.00f,-20.00f,  0.00f ),
    D3DXVECTOR3(-20.00f,-10.00f,  0.00f ),     D3DXVECTOR3(-30.00f,  0.00f,  0.00f ),
    D3DXVECTOR3(  0.00f,-40.00f,  0.00f ),     D3DXVECTOR3(-17.20f,-33.00f,  0.00f ),
    D3DXVECTOR3(-33.00f,-17.20f,  0.00f ),     D3DXVECTOR3(-40.00f,  0.00f,  0.00f ),
    D3DXVECTOR3(  0.00f,-50.00f,  0.00f ),     D3DXVECTOR3(-24.40f,-47.00f,  0.00f ),
    D3DXVECTOR3(-47.00f,-24.40f,  0.00f ),     D3DXVECTOR3(-50.00f,  0.00f,  0.00f ),
    D3DXVECTOR3(  0.00f,-60.00f,  0.00f ),     D3DXVECTOR3(-33.60f,-60.00f,  0.00f ),
    D3DXVECTOR3(-60.00f,-33.60f,  0.00f ),     D3DXVECTOR3(-60.00f,  0.00f,  0.00f ), 

    D3DXVECTOR3( 30.00f,  0.00f,  0.00f ),     D3DXVECTOR3( 20.00f,-10.00f,  0.00f ),
    D3DXVECTOR3( 10.00f,-20.00f,  0.00f ),     D3DXVECTOR3(  0.00f,-30.00f,  0.00f ),
    D3DXVECTOR3( 40.00f,  0.00f,  0.00f ),     D3DXVECTOR3( 33.00f,-17.20f,  0.00f ),
    D3DXVECTOR3( 17.00f,-33.20f,  0.00f ),     D3DXVECTOR3(  0.00f,-40.00f,  0.00f ),
    D3DXVECTOR3( 50.00f,  0.00f,  0.00f ),     D3DXVECTOR3( 47.00f,-24.40f,  0.00f ),
    D3DXVECTOR3( 24.00f,-47.40f,  0.00f ),     D3DXVECTOR3(  0.00f,-50.00f,  0.00f ),
    D3DXVECTOR3( 60.00f,  0.00f,  0.00f ),     D3DXVECTOR3( 60.00f,-33.60f,  0.00f ),
    D3DXVECTOR3( 33.00f,-60.60f,  0.00f ),     D3DXVECTOR3(  0.00f,-60.00f,  0.00f ), 

    D3DXVECTOR3(-30.00f,  0.00f,  0.00f ),     D3DXVECTOR3(-20.00f, 10.00f,  0.00f ),
    D3DXVECTOR3(-10.00f, 20.00f,  0.00f ),     D3DXVECTOR3(  0.00f, 30.00f,  0.00f ),
    D3DXVECTOR3(-40.00f,  0.00f,  0.00f ),     D3DXVECTOR3(-33.00f, 17.20f,  0.00f ),
    D3DXVECTOR3(-17.00f, 33.20f,  0.00f ),     D3DXVECTOR3(  0.00f, 40.00f,  0.00f ),
    D3DXVECTOR3(-50.00f,  0.00f,  0.00f ),     D3DXVECTOR3(-47.00f, 24.40f,  0.00f ),
    D3DXVECTOR3(-24.00f, 47.40f,  0.00f ),     D3DXVECTOR3(  0.00f, 50.00f,  0.00f ),
    D3DXVECTOR3(-60.00f,  0.00f,  0.00f ),     D3DXVECTOR3(-60.00f, 33.60f,  0.00f ),
    D3DXVECTOR3(-33.00f, 60.60f,  0.00f ),     D3DXVECTOR3(  0.00f, 60.00f,  0.00f ), 
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\perpixellightingvs\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\perpixellightingvs\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\perpixellightingvs\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\perpixellightingvs\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\perpixellighting\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 2UL

#define resource_Earth_OFFSET 0UL
#define resource_EarthBmp_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\perpixellighting\obj\i386\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 2UL

#define resource_Earth_OFFSET 0UL
#define resource_EarthBmp_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\perpixellightingvs\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 2UL

#define resource_Earth_OFFSET 0UL
#define resource_EarthBmp_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\perpixellightingvs\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\perpixellighting\perpixellighting.cpp ===
//-----------------------------------------------------------------------------
// File: PerPixelLighting.cpp
//
// Desc: Example code showing how to do perpixel lighting.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <XBResource.h>
#include <XBUtil.h>
#include <xgraphics.h>

// The following header file is generated from "Resource.rdf" file using the
// Bundler tool. In addition to the header, the tool outputs a binary file
// (Resource.xpr) which contains compiled (i.e. bundled) resources and is
// loaded at runtime using the CXBPackedResource class.
#include "Resource.h"




//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_LEFTSTICK,    XBHELP_PLACEMENT_2, L"Move point\nlight" },
    { XBHELP_RIGHTSTICK,   XBHELP_PLACEMENT_2, L"Move dir.\nlight" },
    { XBHELP_X_BUTTON,     XBHELP_PLACEMENT_2, L"Toggle base\ntexture" },
    { XBHELP_Y_BUTTON,     XBHELP_PLACEMENT_2, L"Toggle ambient\nlight" },
    { XBHELP_A_BUTTON,     XBHELP_PLACEMENT_2, L"Toggle dir.\nlight" },
    { XBHELP_B_BUTTON,     XBHELP_PLACEMENT_2, L"Toggle pt.\nlight" },
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_1, L"Display help" },
    { XBHELP_START_BUTTON, XBHELP_PLACEMENT_1, L"Pause" },
};

#define NUM_HELP_CALLOUTS 8




//-----------------------------------------------------------------------------
// Name: struct CUSTOMVERTEX
// Desc: 
//-----------------------------------------------------------------------------
struct CUSTOMVERTEX
{
    D3DXVECTOR3 p;         // Position
    D3DXVECTOR3 n;         // Normal
    D3DCOLOR    diffuse;
    FLOAT       tu, tv;    // Texture coords
    FLOAT       t1u, t1v, t1w;
}; 

#define D3DFVF_CUSTOMVERTEX (D3DFVF_XYZ|D3DFVF_NORMAL|D3DFVF_DIFFUSE|D3DFVF_TEX2| \
                             D3DFVF_TEXCOORDSIZE2(0)|D3DFVF_TEXCOORDSIZE3(1))




//-----------------------------------------------------------------------------
// Name: struct TANGENTSPACE
// Desc: Three orthogonal tangent space vectors for each vertex
//-----------------------------------------------------------------------------
struct TANGENTSPACE
{
    D3DXVECTOR3 vTangent;
    D3DXVECTOR3 vBinormal;
    D3DXVECTOR3 vNormal;
}; 




//-----------------------------------------------------------------------------
// Name: class CBumpyObject
// Desc: 
//-----------------------------------------------------------------------------
class CBumpyObject
{
    LPDIRECT3DDEVICE8       m_pd3dDevice;        // Local copy of the d3d device

    LPDIRECT3DVERTEXBUFFER8 m_pTangentSpaceVB;   // Hold tangent space vectors
    LPDIRECT3DVERTEXBUFFER8 m_pSphereVerticesVB; // Hold geometry
    LPDIRECT3DINDEXBUFFER8  m_pSphereIndicesIB;
    DWORD                   m_dwNumVertices;
    DWORD                   m_dwNumIndices;

    LPDIRECT3DTEXTURE8      m_pBaseTexture;      // Base texture
    LPDIRECT3DTEXTURE8      m_pNormalMap;        // Normal texture (bumpmap)
    LPDIRECT3DCUBETEXTURE8  m_pCubeMap;          // Normalization cubemap

public:
    CBumpyObject();
    virtual ~CBumpyObject();

    HRESULT Init( LPDIRECT3DDEVICE8 pd3dDevice, CXBPackedResource* pResource );
    VOID    InitSphere( FLOAT radius, DWORD nLat, DWORD nLong );
    VOID    CreateBasisMatrices();

    VOID    ProcessVertices( D3DXVECTOR3* pLightDir, D3DXVECTOR3* pLightPos );

    HRESULT Render( LPDIRECT3DDEVICE8 m_pd3dDevice );
    HRESULT RenderObject( LPDIRECT3DDEVICE8 m_pd3dDevice );
};




//-----------------------------------------------------------------------------
// Globally accessed attributes
//-----------------------------------------------------------------------------
D3DXVECTOR3 g_vPtLightPos;        // Point light position
DWORD       g_dwPtLightColor;     // Point light color
D3DXVECTOR3 g_vDirLightDirection; // Directional light direction
DWORD       g_dwDirLightColor;    // Color of directional light
DWORD       g_dwAmbientColor;     // Ambient light value

BOOL        g_bEnableBaseTexturePass  = TRUE;
BOOL        g_bEnableAmbientLightPass = TRUE;
BOOL        g_bEnableDirLightPass     = TRUE;
BOOL        g_bEnablePointLightPass   = TRUE;




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Application class. The base class provides just about all the
//       functionality we want, so we're just supplying stubs to interface with
//       the non-C++ functions of the app.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBPackedResource   m_xprResource;        // Packed resources for the app
    CXBFont             m_Font;               // Font class
    CXBHelp             m_Help;               // Help class
    BOOL                m_bDrawHelp;          // Whether to draw help

    CBumpyObject        m_BumpyObject;

    D3DXMATRIX          m_matWorld;

    VOID    DrawLight();

protected:
    HRESULT Initialize();
    HRESULT FrameMove();
    HRESULT Render();

public:
    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Application constructor. Sets attributes for the app.
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    m_bDrawHelp          = FALSE;

    // Initial light attributes
    g_vPtLightPos        = D3DXVECTOR3( -1.0f, 1.0f, -2.75f );
    g_dwPtLightColor     = 0x00ff0000;

    g_vDirLightDirection = D3DXVECTOR3( 1.0f, 1.0f, 1.5f );
    g_dwDirLightColor    = 0x008080ff;

    g_dwAmbientColor     = 0x00404040;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: This creates all device-dependant objects.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    HRESULT hr;
    
    // Create the font
    if( FAILED( hr = m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the help
    if( FAILED( hr = m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the resources
    if( FAILED( m_xprResource.Create( m_pd3dDevice, "Resource.xpr", 
                                      resource_NUM_RESOURCES ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the bumpy object
    if( FAILED( hr = m_BumpyObject.Init( m_pd3dDevice, &m_xprResource ) ) )
        return hr;

    // Set the transform matrices
    D3DXMATRIX matView, matProj;
    D3DXMatrixIdentity( &m_matWorld );
    D3DXMatrixTranslation( &matView, 0.0f, 0.0f, 5.0f );
    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/3, 640.0f/480.0f, 1.0f, 20.0f );

    m_pd3dDevice->SetTransform( D3DTS_WORLD,      &m_matWorld );
    m_pd3dDevice->SetTransform( D3DTS_VIEW,       &matView );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK )
        m_bDrawHelp = !m_bDrawHelp;

    // Rotate the scene
    D3DXMATRIX matRotate;
    D3DXMatrixRotationY( &matRotate, -m_fElapsedAppTime/2 );
    D3DXMatrixMultiply( &m_matWorld, &m_matWorld, &matRotate );

    // Toggle the render passes
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_A] )
        g_bEnableDirLightPass     = !g_bEnableDirLightPass;
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_B] )
        g_bEnablePointLightPass   = !g_bEnablePointLightPass;
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_X] )
        g_bEnableBaseTexturePass  = !g_bEnableBaseTexturePass;
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_Y] )
        g_bEnableAmbientLightPass = !g_bEnableAmbientLightPass;

    // Adjust the point light's position
    static FLOAT phi1 = 0.5f;
    phi1 += 3.0f * m_fElapsedTime * m_DefaultGamepad.fX1;
    if( phi1 < -2.3f ) phi1 = -2.3f;
    if( phi1 > -0.9f ) phi1 = -0.9f;

    static FLOAT theta1 = 0.0f;
    theta1 -= 3.0f * m_fElapsedTime * m_DefaultGamepad.fY1;
    if( theta1 < +0.9f ) theta1 = +0.9f;
    if( theta1 > +2.3f ) theta1 = +2.3f;

    g_vPtLightPos.x = 2*cosf( phi1 );
    g_vPtLightPos.y = 2*cosf( theta1 );
    g_vPtLightPos.z = 2*sinf( phi1 ) * sinf( theta1 );

    // Adjust the directional light's direction
    static FLOAT phi2 = 0.5f;
    phi2 += 3.0f * m_fElapsedTime * m_DefaultGamepad.fX2;
    if( phi2 < -2.3f ) phi2 = -2.3f;
    if( phi2 > -0.9f ) phi2 = -0.9f;

    static FLOAT theta2 = 0.0f;
    theta2 -= 3.0f * m_fElapsedTime * m_DefaultGamepad.fY2;
    if( theta2 < +0.9f ) theta2 = +0.9f;
    if( theta2 > +2.3f ) theta2 = +2.3f;

    g_vDirLightDirection.x = -2*cosf( phi2 );
    g_vDirLightDirection.y = -2*cosf( theta2 );
    g_vDirLightDirection.z = -2*sinf( phi2 ) * sinf( theta2 );
    D3DXVec3Normalize( &g_vDirLightDirection, &g_vDirLightDirection );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
VOID CXBoxSample::DrawLight()
{
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING,         FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE ); 
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TFACTOR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );

    // Get the inverse of the world matrix
    D3DXMATRIX matInvWorld;
    D3DXMatrixInverse( &matInvWorld, NULL, &m_matWorld );

    // Setup some points to draw crosshairs
    D3DXVECTOR3 line[6];
    D3DXVec3TransformCoord( &line[0], &(g_vPtLightPos+D3DXVECTOR3(+0.2f, 0.0f, 0.0f)), &matInvWorld );
    D3DXVec3TransformCoord( &line[1], &(g_vPtLightPos+D3DXVECTOR3(-0.2f, 0.0f, 0.0f)), &matInvWorld );
    D3DXVec3TransformCoord( &line[2], &(g_vPtLightPos+D3DXVECTOR3( 0.0f,+0.2f, 0.0f)), &matInvWorld );
    D3DXVec3TransformCoord( &line[3], &(g_vPtLightPos+D3DXVECTOR3( 0.0f,-0.2f, 0.0f)), &matInvWorld );
    D3DXVec3TransformCoord( &line[4], &(g_vPtLightPos+D3DXVECTOR3( 0.0f, 0.0f,+0.2f)), &matInvWorld );
    D3DXVec3TransformCoord( &line[5], &(g_vPtLightPos+D3DXVECTOR3( 0.0f, 0.0f,-0.2f)), &matInvWorld );

    // Set the crosshair's color 
    m_pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, g_dwPtLightColor );

    // Draw the crosshairs
    m_pd3dDevice->SetVertexShader( D3DFVF_XYZ );
    m_pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 3, line, sizeof(D3DXVECTOR3) );
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Clear the viewport
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_ZBUFFER, 0x00000000, 1.0f, 0L );

    // Draw a gradient filled background
    RenderGradientBackground( 0xff000000, 0xff888844 );

    // Draw the main object
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &m_matWorld );
    m_BumpyObject.Render( m_pd3dDevice );

    // Draw the position of the point light
    if( g_bEnablePointLightPass )
        DrawLight();

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        m_Font.Begin();
        m_Font.DrawText(  64, 50, 0xffffffff, L"PerPixelLighting" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );
        m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
CBumpyObject::CBumpyObject()
{
    m_pd3dDevice        = NULL;
    m_pTangentSpaceVB   = NULL;
    m_pSphereVerticesVB = NULL;
    m_pSphereIndicesIB  = NULL;
    m_pBaseTexture      = NULL;
    m_pNormalMap        = NULL;
    m_pCubeMap          = NULL;
}




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
CBumpyObject::~CBumpyObject()
{
    SAFE_RELEASE( m_pTangentSpaceVB );
    SAFE_RELEASE( m_pSphereVerticesVB );
    SAFE_RELEASE( m_pSphereIndicesIB );
    SAFE_RELEASE( m_pBaseTexture );
    SAFE_RELEASE( m_pNormalMap );
    SAFE_RELEASE( m_pCubeMap );
}




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CBumpyObject::Init( LPDIRECT3DDEVICE8 pd3dDevice, 
                            CXBPackedResource* pResource )
{
    HRESULT hr;

    // Keep track of the device
    m_pd3dDevice = pd3dDevice;

    // Initialize the sphere's geometry, and create it's basis matrices
    InitSphere( 1.7f, 24, 24 );
    CreateBasisMatrices();

    // Create the base texture
    m_pBaseTexture = pResource->GetTexture( resource_Earth_OFFSET );
    
    // Load grayscale texture to be used for making the normal map
    m_pNormalMap = pResource->GetTexture( resource_EarthBmp_OFFSET );

    // Compute the normal map from the gray scale texture
    D3DSURFACE_DESC desc;
    D3DLOCKED_RECT  lock;
    m_pNormalMap->GetLevelDesc( 0, &desc );
    m_pNormalMap->LockRect( 0, &lock, 0, 0L );
    XBUtil_UnswizzleTexture2D( &lock, &desc );
    DWORD* pDstBits = (DWORD*)lock.pBits;
    DWORD* pSrcBits = new DWORD[ desc.Height * desc.Width ];
    memcpy( pSrcBits, pDstBits, sizeof(DWORD) * desc.Height * desc.Width );

    for( DWORD y=0; y<desc.Height; y++ )
    {
        for( DWORD x=0; x<desc.Width; x++ )
        {
            DWORD x0 = x,   x1 = (x+1<desc.Width)  ? x+1 : 0;
            DWORD y0 = y,   y1 = (y+1<desc.Height) ? y+1 : 0;

            DWORD* p00 = ((DWORD*)pSrcBits) + x0 + desc.Width*y0;
            DWORD* p10 = ((DWORD*)pSrcBits) + x1 + desc.Width*y0;
            DWORD* p01 = ((DWORD*)pSrcBits) + x0 + desc.Width*y1;

            FLOAT fHeight00 = (FLOAT)(((*p00)&0x00ff0000)>>16)/255.0f;
            FLOAT fHeight10 = (FLOAT)(((*p10)&0x00ff0000)>>16)/255.0f;
            FLOAT fHeight01 = (FLOAT)(((*p01)&0x00ff0000)>>16)/255.0f;

            D3DXVECTOR3 vPoint00( x+0.0f, y+0.0f, fHeight00 );
            D3DXVECTOR3 vPoint10( x+0.1f, y+0.0f, fHeight10 );
            D3DXVECTOR3 vPoint01( x+0.0f, y+0.1f, fHeight01 );
            D3DXVECTOR3 v10 = vPoint10 - vPoint00;
            D3DXVECTOR3 v01 = vPoint01 - vPoint00;

            D3DXVECTOR3 v;
            D3DXVec3Cross( &v, &v10, &v01 );
            D3DXVec3Normalize( &v, &v );

            *pDstBits++ = XBUtil_VectorToRGBA( &v );
        }
    }
    delete[] pSrcBits;
    XBUtil_SwizzleTexture2D( &lock, &desc );
    m_pNormalMap->UnlockRect( 0 );

    // Create the normalization cube map
    hr = XBUtil_CreateNormalizationCubeMap( m_pd3dDevice, 256, &m_pCubeMap );
    if( FAILED(hr) )
        return E_FAIL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: InitSphere()
// Desc: 
//-----------------------------------------------------------------------------
VOID CBumpyObject::InitSphere( FLOAT fRadius, DWORD dwNumSphereRings, 
                               DWORD dwNumSphereSegments )
{
    // Establish constants used in sphere generation
    FLOAT fDeltaRingAngle = ( D3DX_PI / dwNumSphereRings );
    FLOAT fDeltaSegAngle  = ( 2.0f * D3DX_PI / dwNumSphereSegments );

    m_dwNumVertices = dwNumSphereRings*(dwNumSphereSegments+1)*2;
    m_dwNumIndices  = 3*(m_dwNumVertices-2);

    // Create the vertex buffer and fill it
    m_pd3dDevice->CreateVertexBuffer( m_dwNumVertices*sizeof(CUSTOMVERTEX),
                                      D3DUSAGE_WRITEONLY, 0L,
                                      D3DPOOL_MANAGED, &m_pSphereVerticesVB );

    CUSTOMVERTEX* pVertices;
    m_pSphereVerticesVB->Lock( 0, 0, (BYTE**)&pVertices, 0 );

    // Generate the group of rings for the sphere
    for( DWORD ring = 0; ring < dwNumSphereRings; ring++ )
    {
        FLOAT r0 = sinf( (ring+0) * fDeltaRingAngle );
        FLOAT r1 = sinf( (ring+1) * fDeltaRingAngle );
        FLOAT y0 = cosf( (ring+0) * fDeltaRingAngle );
        FLOAT y1 = cosf( (ring+1) * fDeltaRingAngle );

        // Generate the group of segments for the current ring
        for( DWORD seg = 0; seg < (dwNumSphereSegments+1); seg++ )
        {
            FLOAT x0 =  r0 * sinf( seg * fDeltaSegAngle );
            FLOAT z0 =  r0 * cosf( seg * fDeltaSegAngle );
            FLOAT x1 =  r1 * sinf( seg * fDeltaSegAngle );
            FLOAT z1 =  r1 * cosf( seg * fDeltaSegAngle );

            // Add two vertices to the strip which makes up the sphere
            // (using the transformed normal to generate texture coords)
            pVertices->p  = fRadius * D3DXVECTOR3(x0,y0,z0);
            pVertices->n  = D3DXVECTOR3(x0,y0,z0);
            pVertices->tu = -((FLOAT)seg)/dwNumSphereSegments;
            pVertices->tv = (ring+0)/(FLOAT)dwNumSphereRings;
            pVertices++;

            pVertices->p  = fRadius * D3DXVECTOR3(x1,y1,z1);
            pVertices->n  = D3DXVECTOR3(x1,y1,z1);
            pVertices->tu = -((FLOAT)seg)/dwNumSphereSegments;
            pVertices->tv = (ring+1)/(FLOAT)dwNumSphereRings;
            pVertices++;
        }
    }

    m_pSphereVerticesVB->Unlock();

    // Create the index buffer and fill it
    m_pd3dDevice->CreateIndexBuffer( m_dwNumIndices*sizeof(WORD),
                                     D3DUSAGE_WRITEONLY, D3DFMT_INDEX16, 
                                     D3DPOOL_MANAGED, &m_pSphereIndicesIB );

    WORD* pIndices;
    m_pSphereIndicesIB->Lock( 0, 0, (BYTE**)&pIndices, 0 );

    for( DWORD i=0; i<m_dwNumVertices-2; i++ )
    {
        (*pIndices++) = (WORD)(i+0);
        (*pIndices++) = (WORD)(i+1+(i%2));
        (*pIndices++) = (WORD)(i+2-(i%2));
    }

    m_pSphereIndicesIB->Unlock();
}




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
VOID CBumpyObject::CreateBasisMatrices()
{
    WORD i,j;

    m_pd3dDevice->CreateVertexBuffer( m_dwNumVertices*sizeof(TANGENTSPACE),
                                      D3DUSAGE_WRITEONLY, 0L,
                                      D3DPOOL_MANAGED, &m_pTangentSpaceVB );


    TANGENTSPACE* pTangentSpace;
    CUSTOMVERTEX* pVertices;
    WORD*         pIndices;
    m_pTangentSpaceVB->Lock( 0, 0, (BYTE**)&pTangentSpace, 0 );
    m_pSphereVerticesVB->Lock( 0, 0, (BYTE**)&pVertices, 0 );
    m_pSphereIndicesIB->Lock( 0, 0, (BYTE**)&pIndices, 0 );

    // Clear out the tangent space area
    ZeroMemory( pTangentSpace, m_dwNumVertices*sizeof(TANGENTSPACE) );

    // Loop through all triangles, accumulating du and dv offsets to build
    // basis vectors
    for( i = 0; i < m_dwNumIndices; i += 3 )
    {       
        WORD i0 = pIndices[i+0];
        WORD i1 = pIndices[i+1];
        WORD i2 = pIndices[i+2];

        if( i0<m_dwNumVertices && i1<m_dwNumVertices  && i2<m_dwNumVertices )
        { 
            CUSTOMVERTEX* v0 = &pVertices[i0];
            CUSTOMVERTEX* v1 = &pVertices[i1];
            CUSTOMVERTEX* v2 = &pVertices[i2];
            D3DXVECTOR3   du, dv;
            D3DXVECTOR3   cp;

            // Skip degnerate triangles
            if( fabs(v0->p.x-v1->p.x)<1e-6 && fabs(v0->p.y-v1->p.y)<1e-6 && fabs(v0->p.z-v1->p.z)<1e-6 )
                continue;
            if( fabs(v1->p.x-v2->p.x)<1e-6 && fabs(v1->p.y-v2->p.y)<1e-6 && fabs(v1->p.z-v2->p.z)<1e-6 )
                continue;
            if( fabs(v2->p.x-v0->p.x)<1e-6 && fabs(v2->p.y-v0->p.y)<1e-6 && fabs(v2->p.z-v0->p.z)<1e-6 )
                continue;

            D3DXVECTOR3 edge01( v1->p.x - v0->p.x, v1->tu - v0->tu, v1->tv - v0->tv );
            D3DXVECTOR3 edge02( v2->p.x - v0->p.x, v2->tu - v0->tu, v2->tv - v0->tv );
            D3DXVec3Cross( &cp, &edge01, &edge02 );
            if( fabs(cp.x) > 1e-8 )
            {
                du.x = -cp.y / cp.x;        
                dv.x = -cp.z / cp.x;
            }

            edge01 = D3DXVECTOR3( v1->p.y - v0->p.y, v1->tu - v0->tu, v1->tv - v0->tv );
            edge02 = D3DXVECTOR3( v2->p.y - v0->p.y, v2->tu - v0->tu, v2->tv - v0->tv );
            D3DXVec3Cross( &cp, &edge01, &edge02 );
            if( fabs(cp.x) > 1e-8 )
            {
                du.y = -cp.y / cp.x;
                dv.y = -cp.z / cp.x;
            }

            edge01 = D3DXVECTOR3( v1->p.z - v0->p.z, v1->tu - v0->tu, v1->tv - v0->tv );
            edge02 = D3DXVECTOR3( v2->p.z - v0->p.z, v2->tu - v0->tu, v2->tv - v0->tv );
            D3DXVec3Cross( &cp, &edge01, &edge02 );
            if( fabs(cp.x) > 1e-8 )
            {
                du.z = -cp.y / cp.x;
                dv.z = -cp.z / cp.x;
            }

            pTangentSpace[i0].vTangent += du;
            pTangentSpace[i1].vTangent += du;
            pTangentSpace[i2].vTangent += du;

            pTangentSpace[i0].vNormal  += dv;
            pTangentSpace[i1].vNormal  += dv;
            pTangentSpace[i2].vNormal  += dv;
        }
    }

    for( i = 0; i < m_dwNumVertices; i++)
    {       
        // vBinormal = vTangent x vNormal
        D3DXVec3Normalize( &pTangentSpace[i].vTangent, &pTangentSpace[i].vTangent );
        D3DXVec3Normalize( &pTangentSpace[i].vNormal,  &pTangentSpace[i].vNormal );
        D3DXVec3Cross( &pTangentSpace[i].vBinormal, &pTangentSpace[i].vTangent, 
                       &pTangentSpace[i].vNormal );

        // Get the vertex normal (make sure it's normalized)
        D3DXVECTOR3 normal;
        D3DXVec3Normalize( &normal, &pVertices[i].n );

        // Make sure the basis vector and normal point in the same direction
        if( D3DXVec3Dot( &pTangentSpace[i].vBinormal, &normal ) < 0.0f )
            pTangentSpace[i].vBinormal = -pTangentSpace[i].vBinormal;
    }

    // Find duplicate vertices in the mesh, and average their tangent spaces
    // together. This is necessary to avoid discontinuities at the seams.
    for( i=0; i < m_dwNumVertices; i++ )
    {
        D3DXVECTOR3 vT = pTangentSpace[i].vTangent;
        D3DXVECTOR3 vB = pTangentSpace[i].vBinormal;
        D3DXVECTOR3 vN = pTangentSpace[i].vNormal;

        for( j=i+1; j < m_dwNumVertices; j++ )
        {
            FLOAT dist = D3DXVec3LengthSq( &(pVertices[i].p - pVertices[j].p) );

            if( dist < 1.0e-8f )
            {
                vT += pTangentSpace[j].vTangent;
                vB += pTangentSpace[j].vBinormal;
                vN += pTangentSpace[j].vNormal;
            }
        }

        // Normalize the vectors of the basis matrix
        D3DXVec3Normalize( &vT, &vT );
        D3DXVec3Normalize( &vB, &vB );
        D3DXVec3Normalize( &vN, &vN );

        for( j=i; j < m_dwNumVertices; j++ )
        {
            FLOAT dist = D3DXVec3LengthSq( &(pVertices[i].p - pVertices[j].p) );

            if( dist < 1.0e-8f )
            {
                pTangentSpace[j].vTangent  = vT;
                pTangentSpace[j].vBinormal = vB;
                pTangentSpace[j].vNormal   = vN;
            }
        }
    }

    m_pTangentSpaceVB->Unlock();
    m_pSphereVerticesVB->Unlock();
    m_pSphereIndicesIB->Unlock();
}




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CBumpyObject::RenderObject( LPDIRECT3DDEVICE8 m_pd3dDevice )
{
    // Render the object
    m_pd3dDevice->SetVertexShader( D3DFVF_CUSTOMVERTEX ); 
    m_pd3dDevice->SetStreamSource( 0, m_pSphereVerticesVB, sizeof(CUSTOMVERTEX) );
    m_pd3dDevice->SetIndices( m_pSphereIndicesIB, 0 );
    m_pd3dDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST, 0, m_dwNumVertices,
                                        0, m_dwNumIndices/3 );
    
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CBumpyObject::Render( LPDIRECT3DDEVICE8 m_pd3dDevice )
{
    m_pd3dDevice->SetRenderState( D3DRS_COLORVERTEX,      TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING,         FALSE );              
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP, D3DTOP_DISABLE );        
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ALPHAOP, D3DTOP_DISABLE );        

    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );

    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU,  D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV,  D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ADDRESSU,  D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ADDRESSV,  D3DTADDRESS_WRAP );

    // Process the vertices for the perpixel lighting effect.
    ProcessVertices( &g_vDirLightDirection, &g_vPtLightPos );

    // Render the ambient lighting
    if( g_bEnableAmbientLightPass )
    {
        m_pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, g_dwAmbientColor );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TFACTOR );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
        m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
        RenderObject( m_pd3dDevice );
    }

    // Set blending to add the upcoming passes to the previous pass
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );  
    m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,  D3DBLEND_ONE );
    m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_ONE );

    // Render the bumps lit by the directional light. The normal from the
    // normal map is dotproducted with the directional light vector, which
    // was stored in the vertex's diffuse component during vertex processing.
    // The second texture stage is used to modulate the result with the 
    // directional light's color.
    if( g_bEnableDirLightPass )
    {
        m_pd3dDevice->SetTexture( 0, m_pNormalMap );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXCOORDINDEX, 0 );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_DOTPRODUCT3 );
        m_pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, g_dwDirLightColor );
        m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLORARG1, D3DTA_TFACTOR );
        m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLORARG2, D3DTA_CURRENT );
        m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_MODULATE );
        RenderObject( m_pd3dDevice );
    }

    // Set blending to add the upcoming passes to the previous pass
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );  
    m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,  D3DBLEND_ONE );
    m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_ONE );

    // Render the bumps lit by the point light. This normalizes the
    // normal from the normal map, by dotproducting it with the
    // normalization cubemap
    if( g_bEnablePointLightPass )
    {
        m_pd3dDevice->SetTexture( 0, m_pNormalMap );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXCOORDINDEX, 0 );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
        m_pd3dDevice->SetTexture( 1, m_pCubeMap );
        m_pd3dDevice->SetTextureStageState( 1, D3DTSS_TEXCOORDINDEX, 1 );
        m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLORARG2, D3DTA_TEXTURE );
        m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLORARG1, D3DTA_CURRENT );
        m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DOTPRODUCT3 );
        RenderObject( m_pd3dDevice );
    }

    // Set blending to blend in the base texture
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE ); 
    m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,         D3DBLEND_DESTCOLOR );
    m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND,        D3DBLEND_ZERO );

    // Finally, render the object with the base texture
    if( g_bEnableBaseTexturePass )
    {
        m_pd3dDevice->SetTexture( 0, m_pBaseTexture );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXCOORDINDEX, 0 );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
        m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
        RenderObject( m_pd3dDevice );
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: ProcessVertices()
// Desc: 
//-----------------------------------------------------------------------------
VOID CBumpyObject::ProcessVertices( D3DXVECTOR3* pDirLightDir, 
                                    D3DXVECTOR3* pPtLightPos )
{
    // Compute the matrix set
    D3DXMATRIX matMatrixSet, matWorld, matView, matProj;
    m_pd3dDevice->GetTransform( D3DTS_WORLD,      &matWorld );
    m_pd3dDevice->GetTransform( D3DTS_VIEW,       &matView );
    m_pd3dDevice->GetTransform( D3DTS_PROJECTION, &matProj );
    D3DXMatrixMultiply( &matMatrixSet, &matWorld, &matView );
    D3DXMatrixMultiply( &matMatrixSet, &matMatrixSet, &matProj );
    D3DXMatrixTranspose( &matMatrixSet, &matMatrixSet );
    
    // Get inverse of world matrix
    D3DXMATRIX matInvWorld;
    D3DXMatrixInverse( &matInvWorld, NULL, &matWorld );

    // Transform point light position into object space
    D3DXVECTOR3 vPtLightWorldPos;
    D3DXVec3TransformCoord( &vPtLightWorldPos, pPtLightPos, &matInvWorld );

    // Transform directional light direction into object space
    matInvWorld._41 = matInvWorld._42 = matInvWorld._43 = 0;
    D3DXVECTOR3 vDirLightWorldDir;

    D3DXVec3TransformCoord( &vDirLightWorldDir, &(-(*pDirLightDir)), &matInvWorld );
    D3DXVec3Normalize( &vDirLightWorldDir, &vDirLightWorldDir );

    // Process vertices manually. For each vertex, transform the light vectors
    // to put them in the vertex's tangent space. Store the direction light
    // vector in the diffuse component (so it can be picked up by the D3DTA_DIFFUSE
    // texture stage state) and store the point light vector as texture coordinates
    // (so the texture coords are used to address the normalization cubemap during
    // rasterization).
    TANGENTSPACE* pTangentSpace;
    CUSTOMVERTEX* pVertices;
    m_pTangentSpaceVB->Lock( 0, 0, (BYTE**)&pTangentSpace, 0 );
    m_pSphereVerticesVB->Lock( 0, 0, (BYTE**)&pVertices, 0 );

    for( DWORD i=0; i<m_dwNumVertices; i++ )
    {
        D3DXVECTOR3 vLight;
        vLight.x = D3DXVec3Dot( &vDirLightWorldDir, &pTangentSpace[i].vTangent );
        vLight.y = D3DXVec3Dot( &vDirLightWorldDir, &pTangentSpace[i].vNormal );
        vLight.z = D3DXVec3Dot( &vDirLightWorldDir, &pTangentSpace[i].vBinormal );
        pVertices[i].diffuse = XBUtil_VectorToRGBA( &vLight );

        D3DXVECTOR3 vPtLightDir = vPtLightWorldPos - pVertices[i].p;
        pVertices[i].t1u = D3DXVec3Dot( &vPtLightDir, &pTangentSpace[i].vTangent );
        pVertices[i].t1v = D3DXVec3Dot( &vPtLightDir, &pTangentSpace[i].vNormal );
        pVertices[i].t1w = D3DXVec3Dot( &vPtLightDir, &pTangentSpace[i].vBinormal );
    }

    m_pTangentSpaceVB->Unlock();
    m_pSphereVerticesVB->Unlock();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\perpixellightingvs\obj\i386\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 2UL

#define resource_Earth_OFFSET 0UL
#define resource_EarthBmp_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\PersistDisplay\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\PersistDisplay\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\perpixellightingvs\perpixellightingvs.cpp ===
//-----------------------------------------------------------------------------
// File: PerPixelLighting.cpp
//
// Desc: Example code showing how to do perpixel lighting using vertex shaders.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <XBResource.h>
#include <XBUtil.h>
#include <xgraphics.h>

// The following header file is generated from "Resource.rdf" file using the
// Bundler tool. In addition to the header, the tool outputs a binary file
// (Resource.xpr) which contains compiled (i.e. bundled) resources and is
// loaded at runtime using the CXBPackedResource class.
#include "Resource.h"




//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_LEFTSTICK,    XBHELP_PLACEMENT_2, L"Move point\nlight" },
    { XBHELP_RIGHTSTICK,   XBHELP_PLACEMENT_2, L"Move dir. light" },
    { XBHELP_X_BUTTON,     XBHELP_PLACEMENT_2, L"Toggle base\ntexture" },
    { XBHELP_Y_BUTTON,     XBHELP_PLACEMENT_2, L"Toggle ambient\nlight" },
    { XBHELP_A_BUTTON,     XBHELP_PLACEMENT_2, L"Toggle dir.\nlight" },
    { XBHELP_B_BUTTON,     XBHELP_PLACEMENT_2, L"Toggle pt.\nlight" },
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_1, L"Display help" },
    { XBHELP_START_BUTTON, XBHELP_PLACEMENT_1, L"Pause" },
};

#define NUM_HELP_CALLOUTS 8




//-----------------------------------------------------------------------------
// Name: struct CUSTOMVERTEX
// Desc: A position, normal, and tex coords for each vertex
//-----------------------------------------------------------------------------
struct CUSTOMVERTEX
{
    D3DXVECTOR3 p;         // Position
    D3DXVECTOR3 n;         // Normal
    FLOAT       tu, tv;    // Texture coords
}; 




//-----------------------------------------------------------------------------
// Name: struct TANGENTSPACE
// Desc: Three orthogonal tangent space vectors for each vertex
//-----------------------------------------------------------------------------
struct TANGENTSPACE
{
    D3DXVECTOR3 vTangent;
    D3DXVECTOR3 vBinormal;
    D3DXVECTOR3 vNormal;
}; 




//-----------------------------------------------------------------------------
// Name: class CBumpyObject
// Desc: 
//-----------------------------------------------------------------------------
class CBumpyObject
{
    LPDIRECT3DDEVICE8       m_pd3dDevice;        // Local copy of the d3d device

    LPDIRECT3DVERTEXBUFFER8 m_pTangentSpaceVB;   // Hold tangent space vectors
    LPDIRECT3DVERTEXBUFFER8 m_pSphereVerticesVB; // Hold geometry
    LPDIRECT3DINDEXBUFFER8  m_pSphereIndicesIB;
    DWORD                   m_dwNumVertices;
    DWORD                   m_dwNumIndices;

    LPDIRECT3DTEXTURE8      m_pBaseTexture;      // Base texture
    LPDIRECT3DTEXTURE8      m_pNormalMap;        // Normal texture (bumpmap)
    LPDIRECT3DCUBETEXTURE8  m_pCubeMap;          // Normalization cubemap

    DWORD                   m_dwVertexShader;    // Custom vertex shader

public:
    CBumpyObject();
    virtual ~CBumpyObject();

    HRESULT Init( LPDIRECT3DDEVICE8 pd3dDevice, CXBPackedResource* pResource );
    VOID    InitSphere( FLOAT radius, DWORD nLat, DWORD nLong );
    VOID    CreateBasisMatrices();

    VOID    ProcessVertices( D3DXVECTOR3* pLightDir, D3DXVECTOR3* pLightPos );

    HRESULT Render( LPDIRECT3DDEVICE8 m_pd3dDevice );
    HRESULT RenderObject( LPDIRECT3DDEVICE8 m_pd3dDevice );
};




//-----------------------------------------------------------------------------
// Globally accessed attributes
//-----------------------------------------------------------------------------
D3DXVECTOR3 g_vPtLightPos;        // Point light position
DWORD       g_dwPtLightColor;     // Point light color
D3DXVECTOR3 g_vDirLightDirection; // Directional light direction
DWORD       g_dwDirLightColor;    // Color of directional light
DWORD       g_dwAmbientColor;     // Ambient light value

BOOL        g_bEnableBaseTexturePass  = TRUE;
BOOL        g_bEnableAmbientLightPass = TRUE;
BOOL        g_bEnableDirLightPass     = TRUE;
BOOL        g_bEnablePointLightPass   = TRUE;




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Application class. The base class provides just about all the
//       functionality we want, so we're just supplying stubs to interface with
//       the non-C++ functions of the app.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBPackedResource   m_xprResource;        // Packed resources for the app
    CXBFont             m_Font;               // Font class
    CXBHelp             m_Help;               // Help class
    BOOL                m_bDrawHelp;          // Whether to draw help

    CBumpyObject        m_BumpyObject;

    D3DXMATRIX          m_matWorld;

    VOID DrawLight();

protected:
    HRESULT Initialize();
    HRESULT FrameMove();
    HRESULT Render();

public:
    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Application constructor. Sets attributes for the app.
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    m_bDrawHelp          = FALSE;

    // Initial light attributes
    g_vPtLightPos        = D3DXVECTOR3( -1.0f, 1.0f, -2.75f );
    g_dwPtLightColor     = 0x00ff0000;

    g_vDirLightDirection = D3DXVECTOR3( 1.0f, 1.0f, 1.5f );
    g_dwDirLightColor    = 0x008080ff;

    g_dwAmbientColor     = 0x00404040;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: This creates all device-dependant objects.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    HRESULT hr;
    
    // Create the font
    if( FAILED( hr = m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the help
    if( FAILED( hr = m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the resources
    if( FAILED( m_xprResource.Create( m_pd3dDevice, "Resource.xpr", 
                                      resource_NUM_RESOURCES ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the bumpy object
    if( FAILED( hr = m_BumpyObject.Init( m_pd3dDevice, &m_xprResource ) ) )
        return hr;

    // Set the transform matrices
    D3DXMATRIX matView, matProj;
    D3DXMatrixIdentity( &m_matWorld );
    D3DXMatrixTranslation( &matView, 0.0f, 0.0f, 5.0f );
    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/3, 640.0f/480.0f, 1.0f, 20.0f );

    m_pd3dDevice->SetTransform( D3DTS_WORLD,      &m_matWorld );
    m_pd3dDevice->SetTransform( D3DTS_VIEW,       &matView );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK )
        m_bDrawHelp = !m_bDrawHelp;

    // Rotate the scene
    D3DXMATRIX matRotate;
    D3DXMatrixRotationY( &matRotate, -m_fElapsedAppTime/2 );
    D3DXMatrixMultiply( &m_matWorld, &m_matWorld, &matRotate );

    // Toggle the render passes
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_A] )
        g_bEnableDirLightPass     = !g_bEnableDirLightPass;
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_B] )
        g_bEnablePointLightPass   = !g_bEnablePointLightPass;
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_X] )
        g_bEnableBaseTexturePass  = !g_bEnableBaseTexturePass;
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_Y] )
        g_bEnableAmbientLightPass = !g_bEnableAmbientLightPass;

    // Adjust the point light's position
    static FLOAT phi1 = 0.5f;
    phi1 += 3.0f * m_fElapsedTime * m_DefaultGamepad.fX1;
    if( phi1 < -2.3f ) phi1 = -2.3f;
    if( phi1 > -0.9f ) phi1 = -0.9f;

    static FLOAT theta1 = 0.0f;
    theta1 -= 3.0f * m_fElapsedTime * m_DefaultGamepad.fY1;
    if( theta1 < +0.9f ) theta1 = +0.9f;
    if( theta1 > +2.3f ) theta1 = +2.3f;

    g_vPtLightPos.x = 2*cosf( phi1 );
    g_vPtLightPos.y = 2*cosf( theta1 );
    g_vPtLightPos.z = 2*sinf( phi1 ) * sinf( theta1 );

    // Adjust the directional light's direction
    static FLOAT phi2 = 0.5f;
    phi2 += 3.0f * m_fElapsedTime * m_DefaultGamepad.fX2;
    if( phi2 < -2.3f ) phi2 = -2.3f;
    if( phi2 > -0.9f ) phi2 = -0.9f;

    static FLOAT theta2 = 0.0f;
    theta2 -= 3.0f * m_fElapsedTime * m_DefaultGamepad.fY2;
    if( theta2 < +0.9f ) theta2 = +0.9f;
    if( theta2 > +2.3f ) theta2 = +2.3f;

    g_vDirLightDirection.x = -2*cosf( phi2 );
    g_vDirLightDirection.y = -2*cosf( theta2 );
    g_vDirLightDirection.z = -2*sinf( phi2 ) * sinf( theta2 );
    D3DXVec3Normalize( &g_vDirLightDirection, &g_vDirLightDirection );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
VOID CXBoxSample::DrawLight()
{
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING,         FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE ); 
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TFACTOR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );

    // Get the inverse of the world matrix
    D3DXMATRIX matInvWorld;
    D3DXMatrixInverse( &matInvWorld, NULL, &m_matWorld );

    // Setup some points to draw crosshairs
    D3DXVECTOR3 line[6];
    D3DXVec3TransformCoord( &line[0], &(g_vPtLightPos+D3DXVECTOR3(+0.2f, 0.0f, 0.0f)), &matInvWorld );
    D3DXVec3TransformCoord( &line[1], &(g_vPtLightPos+D3DXVECTOR3(-0.2f, 0.0f, 0.0f)), &matInvWorld );
    D3DXVec3TransformCoord( &line[2], &(g_vPtLightPos+D3DXVECTOR3( 0.0f,+0.2f, 0.0f)), &matInvWorld );
    D3DXVec3TransformCoord( &line[3], &(g_vPtLightPos+D3DXVECTOR3( 0.0f,-0.2f, 0.0f)), &matInvWorld );
    D3DXVec3TransformCoord( &line[4], &(g_vPtLightPos+D3DXVECTOR3( 0.0f, 0.0f,+0.2f)), &matInvWorld );
    D3DXVec3TransformCoord( &line[5], &(g_vPtLightPos+D3DXVECTOR3( 0.0f, 0.0f,-0.2f)), &matInvWorld );

    // Set the crosshair's color 
    m_pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, g_dwPtLightColor );

    // Draw the crosshairs
    m_pd3dDevice->SetVertexShader( D3DFVF_XYZ );
    m_pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 3, line, sizeof(D3DXVECTOR3) );
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Clear the viewport
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_ZBUFFER, 0x00000000, 1.0f, 0L );

    // Draw a gradient filled background
    RenderGradientBackground( 0xff000000, 0xff888844 );

    // Draw the main object
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &m_matWorld );
    m_BumpyObject.Render( m_pd3dDevice );

    // Draw the position of the point light
    if( g_bEnablePointLightPass )
        DrawLight();

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        m_Font.Begin();
        m_Font.DrawText(  64, 50, 0xffffffff, L"PerPixelLightingVS" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );
        m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
CBumpyObject::CBumpyObject()
{
    m_pd3dDevice        = NULL;
    m_pTangentSpaceVB   = NULL;
    m_pSphereVerticesVB = NULL;
    m_pSphereIndicesIB  = NULL;
    m_pBaseTexture      = NULL;
    m_pNormalMap        = NULL;
    m_pCubeMap          = NULL;
    m_dwVertexShader    = 0L;
}




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
CBumpyObject::~CBumpyObject()
{
    SAFE_RELEASE( m_pTangentSpaceVB );
    SAFE_RELEASE( m_pSphereVerticesVB );
    SAFE_RELEASE( m_pSphereIndicesIB );
    SAFE_RELEASE( m_pBaseTexture );
    SAFE_RELEASE( m_pNormalMap );
    SAFE_RELEASE( m_pCubeMap );
    
    if( m_pd3dDevice )
        m_pd3dDevice->DeleteVertexShader( m_dwVertexShader );
}




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CBumpyObject::Init( LPDIRECT3DDEVICE8 pd3dDevice, 
                            CXBPackedResource* pResource )
{
    HRESULT hr;

    // Keep track of the device
    m_pd3dDevice = pd3dDevice;

    // Initialize the sphere's geometry, and create it's basis matrices
    InitSphere( 1.7f, 24, 24 );
    CreateBasisMatrices();

    // Create the base texture
    m_pBaseTexture = pResource->GetTexture( resource_Earth_OFFSET );
    
    // Load grayscale texture to be used for making the normal map
    m_pNormalMap = pResource->GetTexture( resource_EarthBmp_OFFSET );

    // Compute the normal map from the gray scale texture
    D3DSURFACE_DESC desc;
    D3DLOCKED_RECT  lock;
    m_pNormalMap->GetLevelDesc( 0, &desc );
    m_pNormalMap->LockRect( 0, &lock, 0, 0L );
    XBUtil_UnswizzleTexture2D( &lock, &desc );
    DWORD* pDstBits = (DWORD*)lock.pBits;
    DWORD* pSrcBits = new DWORD[ desc.Height * desc.Width ];
    memcpy( pSrcBits, pDstBits, sizeof(DWORD) * desc.Height * desc.Width );

    for( DWORD y=0; y<desc.Height; y++ )
    {
        for( DWORD x=0; x<desc.Width; x++ )
        {
            DWORD x0 = x,   x1 = (x+1<desc.Width)  ? x+1 : 0;
            DWORD y0 = y,   y1 = (y+1<desc.Height) ? y+1 : 0;

            DWORD* p00 = ((DWORD*)pSrcBits) + x0 + desc.Width*y0;
            DWORD* p10 = ((DWORD*)pSrcBits) + x1 + desc.Width*y0;
            DWORD* p01 = ((DWORD*)pSrcBits) + x0 + desc.Width*y1;

            FLOAT fHeight00 = (FLOAT)(((*p00)&0x00ff0000)>>16)/255.0f;
            FLOAT fHeight10 = (FLOAT)(((*p10)&0x00ff0000)>>16)/255.0f;
            FLOAT fHeight01 = (FLOAT)(((*p01)&0x00ff0000)>>16)/255.0f;

            D3DXVECTOR3 vPoint00( x+0.0f, y+0.0f, fHeight00 );
            D3DXVECTOR3 vPoint10( x+0.1f, y+0.0f, fHeight10 );
            D3DXVECTOR3 vPoint01( x+0.0f, y+0.1f, fHeight01 );
            D3DXVECTOR3 v10 = vPoint10 - vPoint00;
            D3DXVECTOR3 v01 = vPoint01 - vPoint00;

            D3DXVECTOR3 v;
            D3DXVec3Cross( &v, &v10, &v01 );
            D3DXVec3Normalize( &v, &v );

            *pDstBits++ = XBUtil_VectorToRGBA( &v );
        }
    }
    delete[] pSrcBits;
    XBUtil_SwizzleTexture2D( &lock, &desc );
    m_pNormalMap->UnlockRect( 0 );

    // Create the normalization cube map
    hr = XBUtil_CreateNormalizationCubeMap( m_pd3dDevice, 256, &m_pCubeMap );
    if( FAILED(hr) )
        return E_FAIL;

    // Create a vertex shader
    DWORD dwVertexDecl[] =
    {
        D3DVSD_STREAM( 0 ),
        D3DVSD_REG( 0, D3DVSDT_FLOAT3 ),     // v0 = Position
        D3DVSD_REG( 1, D3DVSDT_FLOAT3 ),     // v1 = Normal
        D3DVSD_REG( 2, D3DVSDT_FLOAT2 ),     // v2 = Base tex coords
        D3DVSD_STREAM( 1 ),
        D3DVSD_REG( 3, D3DVSDT_FLOAT3 ),     // v3 = Tangent space tangent
        D3DVSD_REG( 4, D3DVSDT_FLOAT3 ),     // v4 = Tangent space binormal
        D3DVSD_REG( 5, D3DVSDT_FLOAT3 ),     // v5 = Tangent space normal
        D3DVSD_END()
    };

    if( FAILED( XBUtil_CreateVertexShader( m_pd3dDevice, "Shaders\\PPLight.xvu",
                                           dwVertexDecl,
                                           &m_dwVertexShader ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: InitSphere()
// Desc: 
//-----------------------------------------------------------------------------
VOID CBumpyObject::InitSphere( FLOAT fRadius, DWORD dwNumSphereRings, 
                               DWORD dwNumSphereSegments )
{
    // Establish constants used in sphere generation
    FLOAT fDeltaRingAngle = ( D3DX_PI / dwNumSphereRings );
    FLOAT fDeltaSegAngle  = ( 2.0f * D3DX_PI / dwNumSphereSegments );

    m_dwNumVertices = dwNumSphereRings*(dwNumSphereSegments+1)*2;
    m_dwNumIndices  = 3*(m_dwNumVertices-2);

    // Create the vertex buffer and fill it
    m_pd3dDevice->CreateVertexBuffer( m_dwNumVertices*sizeof(CUSTOMVERTEX),
                                      D3DUSAGE_WRITEONLY, 0L,
                                      D3DPOOL_MANAGED, &m_pSphereVerticesVB );

    CUSTOMVERTEX* pVertices;
    m_pSphereVerticesVB->Lock( 0, 0, (BYTE**)&pVertices, 0 );

    // Generate the group of rings for the sphere
    for( DWORD ring = 0; ring < dwNumSphereRings; ring++ )
    {
        FLOAT r0 = sinf( (ring+0) * fDeltaRingAngle );
        FLOAT r1 = sinf( (ring+1) * fDeltaRingAngle );
        FLOAT y0 = cosf( (ring+0) * fDeltaRingAngle );
        FLOAT y1 = cosf( (ring+1) * fDeltaRingAngle );

        // Generate the group of segments for the current ring
        for( DWORD seg = 0; seg < (dwNumSphereSegments+1); seg++ )
        {
            FLOAT x0 =  r0 * sinf( seg * fDeltaSegAngle );
            FLOAT z0 =  r0 * cosf( seg * fDeltaSegAngle );
            FLOAT x1 =  r1 * sinf( seg * fDeltaSegAngle );
            FLOAT z1 =  r1 * cosf( seg * fDeltaSegAngle );

            // Add two vertices to the strip which makes up the sphere
            // (using the transformed normal to generate texture coords)
            pVertices->p  = fRadius * D3DXVECTOR3(x0,y0,z0);
            pVertices->n  = D3DXVECTOR3(x0,y0,z0);
            pVertices->tu = -((FLOAT)seg)/dwNumSphereSegments;
            pVertices->tv = (ring+0)/(FLOAT)dwNumSphereRings;
            pVertices++;

            pVertices->p  = fRadius * D3DXVECTOR3(x1,y1,z1);
            pVertices->n  = D3DXVECTOR3(x1,y1,z1);
            pVertices->tu = -((FLOAT)seg)/dwNumSphereSegments;
            pVertices->tv = (ring+1)/(FLOAT)dwNumSphereRings;
            pVertices++;
        }
    }

    m_pSphereVerticesVB->Unlock();

    // Create the index buffer and fill it
    m_pd3dDevice->CreateIndexBuffer( m_dwNumIndices*sizeof(WORD),
                                     D3DUSAGE_WRITEONLY, D3DFMT_INDEX16, 
                                     D3DPOOL_MANAGED, &m_pSphereIndicesIB );

    WORD* pIndices;
    m_pSphereIndicesIB->Lock( 0, 0, (BYTE**)&pIndices, 0 );

    for( DWORD i=0; i<m_dwNumVertices-2; i++ )
    {
        (*pIndices++) = (WORD)(i+0);
        (*pIndices++) = (WORD)(i+1+(i%2));
        (*pIndices++) = (WORD)(i+2-(i%2));
    }

    m_pSphereIndicesIB->Unlock();
}




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
VOID CBumpyObject::CreateBasisMatrices()
{
    WORD i,j;

    m_pd3dDevice->CreateVertexBuffer( m_dwNumVertices*sizeof(TANGENTSPACE),
                                      D3DUSAGE_WRITEONLY, 0L,
                                      D3DPOOL_MANAGED, &m_pTangentSpaceVB );


    TANGENTSPACE* pTangentSpace;
    CUSTOMVERTEX* pVertices;
    WORD*         pIndices;
    m_pTangentSpaceVB->Lock( 0, 0, (BYTE**)&pTangentSpace, 0 );
    m_pSphereVerticesVB->Lock( 0, 0, (BYTE**)&pVertices, 0 );
    m_pSphereIndicesIB->Lock( 0, 0, (BYTE**)&pIndices, 0 );

    // Clear out the tangent space area
    ZeroMemory( pTangentSpace, m_dwNumVertices*sizeof(TANGENTSPACE) );

    // Loop through all triangles, accumulating du and dv offsets to build
    // basis vectors
    for( i = 0; i < m_dwNumIndices; i += 3 )
    {       
        WORD i0 = pIndices[i+0];
        WORD i1 = pIndices[i+1];
        WORD i2 = pIndices[i+2];

        if( i0<m_dwNumVertices && i1<m_dwNumVertices  && i2<m_dwNumVertices )
        { 
            CUSTOMVERTEX* v0 = &pVertices[i0];
            CUSTOMVERTEX* v1 = &pVertices[i1];
            CUSTOMVERTEX* v2 = &pVertices[i2];
            D3DXVECTOR3   du, dv;
            D3DXVECTOR3   cp;

            // Skip degnerate triangles
            if( fabs(v0->p.x-v1->p.x)<1e-6 && fabs(v0->p.y-v1->p.y)<1e-6 && fabs(v0->p.z-v1->p.z)<1e-6 )
                continue;
            if( fabs(v1->p.x-v2->p.x)<1e-6 && fabs(v1->p.y-v2->p.y)<1e-6 && fabs(v1->p.z-v2->p.z)<1e-6 )
                continue;
            if( fabs(v2->p.x-v0->p.x)<1e-6 && fabs(v2->p.y-v0->p.y)<1e-6 && fabs(v2->p.z-v0->p.z)<1e-6 )
                continue;

            D3DXVECTOR3 edge01( v1->p.x - v0->p.x, v1->tu - v0->tu, v1->tv - v0->tv );
            D3DXVECTOR3 edge02( v2->p.x - v0->p.x, v2->tu - v0->tu, v2->tv - v0->tv );
            D3DXVec3Cross( &cp, &edge01, &edge02 );
            if( fabs(cp.x) > 1e-8 )
            {
                du.x = -cp.y / cp.x;        
                dv.x = -cp.z / cp.x;
            }

            edge01 = D3DXVECTOR3( v1->p.y - v0->p.y, v1->tu - v0->tu, v1->tv - v0->tv );
            edge02 = D3DXVECTOR3( v2->p.y - v0->p.y, v2->tu - v0->tu, v2->tv - v0->tv );
            D3DXVec3Cross( &cp, &edge01, &edge02 );
            if( fabs(cp.x) > 1e-8 )
            {
                du.y = -cp.y / cp.x;
                dv.y = -cp.z / cp.x;
            }

            edge01 = D3DXVECTOR3( v1->p.z - v0->p.z, v1->tu - v0->tu, v1->tv - v0->tv );
            edge02 = D3DXVECTOR3( v2->p.z - v0->p.z, v2->tu - v0->tu, v2->tv - v0->tv );
            D3DXVec3Cross( &cp, &edge01, &edge02 );
            if( fabs(cp.x) > 1e-8 )
            {
                du.z = -cp.y / cp.x;
                dv.z = -cp.z / cp.x;
            }

            pTangentSpace[i0].vTangent += du;
            pTangentSpace[i1].vTangent += du;
            pTangentSpace[i2].vTangent += du;

            pTangentSpace[i0].vNormal  += dv;
            pTangentSpace[i1].vNormal  += dv;
            pTangentSpace[i2].vNormal  += dv;
        }
    }

    for( i = 0; i < m_dwNumVertices; i++)
    {       
        // vBinormal = vTangent x vNormal
        D3DXVec3Normalize( &pTangentSpace[i].vTangent, &pTangentSpace[i].vTangent );
        D3DXVec3Normalize( &pTangentSpace[i].vNormal,  &pTangentSpace[i].vNormal );
        D3DXVec3Cross( &pTangentSpace[i].vBinormal, &pTangentSpace[i].vTangent, 
                       &pTangentSpace[i].vNormal );

        // Get the vertex normal (make sure it's normalized)
        D3DXVECTOR3 normal;
        D3DXVec3Normalize( &normal, &pVertices[i].n );

        // Make sure the basis vector and normal point in the same direction
        if( D3DXVec3Dot( &pTangentSpace[i].vBinormal, &normal ) < 0.0f )
            pTangentSpace[i].vBinormal = -pTangentSpace[i].vBinormal;
    }

    // Find duplicate vertices in the mesh, and average their tangent spaces
    // together. This is necessary to avoid discontinuities at the seams.
    for( i=0; i < m_dwNumVertices; i++ )
    {
        D3DXVECTOR3 vT = pTangentSpace[i].vTangent;
        D3DXVECTOR3 vB = pTangentSpace[i].vBinormal;
        D3DXVECTOR3 vN = pTangentSpace[i].vNormal;

        for( j=i+1; j < m_dwNumVertices; j++ )
        {
            FLOAT dist = D3DXVec3LengthSq( &(pVertices[i].p - pVertices[j].p) );

            if( dist < 1.0e-8f )
            {
                vT += pTangentSpace[j].vTangent;
                vB += pTangentSpace[j].vBinormal;
                vN += pTangentSpace[j].vNormal;
            }
        }

        // Normalize the vectors of the basis matrix
        D3DXVec3Normalize( &vT, &vT );
        D3DXVec3Normalize( &vB, &vB );
        D3DXVec3Normalize( &vN, &vN );

        for( j=i; j < m_dwNumVertices; j++ )
        {
            FLOAT dist = D3DXVec3LengthSq( &(pVertices[i].p - pVertices[j].p) );

            if( dist < 1.0e-8f )
            {
                pTangentSpace[j].vTangent  = vT;
                pTangentSpace[j].vBinormal = vB;
                pTangentSpace[j].vNormal   = vN;
            }
        }
    }

    m_pTangentSpaceVB->Unlock();
    m_pSphereVerticesVB->Unlock();
    m_pSphereIndicesIB->Unlock();
}




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CBumpyObject::RenderObject( LPDIRECT3DDEVICE8 m_pd3dDevice )
{
    // Render the object
    m_pd3dDevice->SetVertexShader( m_dwVertexShader ); 
    m_pd3dDevice->SetStreamSource( 0, m_pSphereVerticesVB, sizeof(CUSTOMVERTEX) );
    m_pd3dDevice->SetStreamSource( 1, m_pTangentSpaceVB, sizeof(TANGENTSPACE) );
    m_pd3dDevice->SetIndices( m_pSphereIndicesIB, 0 );
    m_pd3dDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST, 0, m_dwNumVertices,
                                        0, m_dwNumIndices/3 );
    
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CBumpyObject::Render( LPDIRECT3DDEVICE8 m_pd3dDevice )
{
    m_pd3dDevice->SetRenderState( D3DRS_COLORVERTEX,      TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING,         FALSE );              
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP, D3DTOP_DISABLE );        
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ALPHAOP, D3DTOP_DISABLE );        

    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );

    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU,  D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV,  D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ADDRESSU,  D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ADDRESSV,  D3DTADDRESS_WRAP );

    // Process the vertices for the perpixel lighting effect.
    ProcessVertices( &g_vDirLightDirection, &g_vPtLightPos );

    // Render the ambient lighting
    if( g_bEnableAmbientLightPass )
    {
        m_pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, g_dwAmbientColor );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TFACTOR );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
        m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
        RenderObject( m_pd3dDevice );
    }

    // Set blending to add the upcoming passes to the previous pass
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );  
    m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,  D3DBLEND_ONE );
    m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_ONE );

    // Render the bumps lit by the directional light. The normal from the
    // normal map is dotproducted with the directional light vector, which
    // was stored in the vertex's diffuse component during vertex processing.
    // The second texture stage is used to modulate the result with the 
    // directional light's color.
    if( g_bEnableDirLightPass )
    {
        m_pd3dDevice->SetTexture( 0, m_pNormalMap );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXCOORDINDEX, 0 );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_DOTPRODUCT3 );
        m_pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, g_dwDirLightColor );
        m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLORARG1, D3DTA_TFACTOR );
        m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLORARG2, D3DTA_CURRENT );
        m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_MODULATE );
        RenderObject( m_pd3dDevice );
    }

    // Set blending to add the upcoming passes to the previous pass
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );  
    m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,  D3DBLEND_ONE );
    m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_ONE );

    // Render the bumps lit by the point light. This normalizes the
    // normal from the normal map, by dotproducting it with the
    // normalization cubemap
    if( g_bEnablePointLightPass )
    {
        m_pd3dDevice->SetTexture( 0, m_pNormalMap );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXCOORDINDEX, 0 );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
        m_pd3dDevice->SetTexture( 1, m_pCubeMap );
        m_pd3dDevice->SetTextureStageState( 1, D3DTSS_TEXCOORDINDEX, 1 );
        m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLORARG2, D3DTA_TEXTURE );
        m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLORARG1, D3DTA_CURRENT );
        m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DOTPRODUCT3 );
        RenderObject( m_pd3dDevice );
    }

    // Set blending to blend in the base texture
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE ); 
    m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,         D3DBLEND_DESTCOLOR );
    m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND,        D3DBLEND_ZERO );

    // Finally, render the object with the base texture
    if( g_bEnableBaseTexturePass )
    {
        m_pd3dDevice->SetTexture( 0, m_pBaseTexture );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXCOORDINDEX, 0 );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
        m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
        RenderObject( m_pd3dDevice );
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: ProcessVertices()
// Desc: 
//-----------------------------------------------------------------------------
VOID CBumpyObject::ProcessVertices( D3DXVECTOR3* pDirLightDir, 
                                    D3DXVECTOR3* pPtLightPos )
{
    // Compute the matrix set
    D3DXMATRIX matMatrixSet, matWorld, matView, matProj;
    m_pd3dDevice->GetTransform( D3DTS_WORLD,      &matWorld );
    m_pd3dDevice->GetTransform( D3DTS_VIEW,       &matView );
    m_pd3dDevice->GetTransform( D3DTS_PROJECTION, &matProj );
    D3DXMatrixMultiply( &matMatrixSet, &matWorld, &matView );
    D3DXMatrixMultiply( &matMatrixSet, &matMatrixSet, &matProj );
    D3DXMatrixTranspose( &matMatrixSet, &matMatrixSet );
    
    // Get inverse of world matrix
    D3DXMATRIX matInvWorld;
    D3DXMatrixInverse( &matInvWorld, NULL, &matWorld );

    // Transform point light position into object space
    D3DXVECTOR3 vPtLightWorldPos;
    D3DXVec3TransformCoord( &vPtLightWorldPos, pPtLightPos, &matInvWorld );

    // Transform directional light direction into object space
    matInvWorld._41 = matInvWorld._42 = matInvWorld._43 = 0;
    D3DXVECTOR3 vDirLightWorldDir;
    D3DXVec3TransformCoord( &vDirLightWorldDir, &(-(*pDirLightDir)), &matInvWorld );
    D3DXVec3Normalize( &vDirLightWorldDir, &vDirLightWorldDir );

    // If we are using a vertex shader, we simply pass variables to
    // the vertex shader, and the vertex shader will do the rest.
    D3DXVECTOR4 vConstants0( 0.0f, 0.0f, 0.0f, 0.0f );
    D3DXVECTOR4 vConstants1( 0.0f, 0.5f, 1.0f, 2.0f );
    m_pd3dDevice->SetVertexShaderConstant(  0, &vConstants0,       1 );
    m_pd3dDevice->SetVertexShaderConstant(  1, &vConstants1,       1 );
    m_pd3dDevice->SetVertexShaderConstant(  4, &matMatrixSet,      4 );
    m_pd3dDevice->SetVertexShaderConstant( 10, &vDirLightWorldDir, 1 );
    m_pd3dDevice->SetVertexShaderConstant( 11, &vPtLightWorldPos,  1 );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\PersistDisplay\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\PixelShader\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\PixelShader\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\PixelShader\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\PixelShader\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 3UL

#define resource_Texture0_OFFSET 0UL
#define resource_Texture1_OFFSET 20UL
#define resource_Checker_OFFSET 40UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\PixelShader\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\PersistDisplay\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 35UL

#define resource_TextureToPersist_OFFSET 0UL
#define resource_DolphinTexture_OFFSET 20UL
#define resource_SeaFloorTexture_OFFSET 40UL
#define resource_WaterCaustic00_OFFSET 60UL
#define resource_WaterCaustic01_OFFSET 80UL
#define resource_WaterCaustic02_OFFSET 100UL
#define resource_WaterCaustic03_OFFSET 120UL
#define resource_WaterCaustic04_OFFSET 140UL
#define resource_WaterCaustic05_OFFSET 160UL
#define resource_WaterCaustic06_OFFSET 180UL
#define resource_WaterCaustic07_OFFSET 200UL
#define resource_WaterCaustic08_OFFSET 220UL
#define resource_WaterCaustic09_OFFSET 240UL
#define resource_WaterCaustic10_OFFSET 260UL
#define resource_WaterCaustic11_OFFSET 280UL
#define resource_WaterCaustic12_OFFSET 300UL
#define resource_WaterCaustic13_OFFSET 320UL
#define resource_WaterCaustic14_OFFSET 340UL
#define resource_WaterCaustic15_OFFSET 360UL
#define resource_WaterCaustic16_OFFSET 380UL
#define resource_WaterCaustic17_OFFSET 400UL
#define resource_WaterCaustic18_OFFSET 420UL
#define resource_WaterCaustic19_OFFSET 440UL
#define resource_WaterCaustic20_OFFSET 460UL
#define resource_WaterCaustic21_OFFSET 480UL
#define resource_WaterCaustic22_OFFSET 500UL
#define resource_WaterCaustic23_OFFSET 520UL
#define resource_WaterCaustic24_OFFSET 540UL
#define resource_WaterCaustic25_OFFSET 560UL
#define resource_WaterCaustic26_OFFSET 580UL
#define resource_WaterCaustic27_OFFSET 600UL
#define resource_WaterCaustic28_OFFSET 620UL
#define resource_WaterCaustic29_OFFSET 640UL
#define resource_WaterCaustic30_OFFSET 660UL
#define resource_WaterCaustic31_OFFSET 680UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\PixelShader\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\PixelShader\obj\i386\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 3UL

#define resource_Texture0_OFFSET 0UL
#define resource_Texture1_OFFSET 20UL
#define resource_Checker_OFFSET 40UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\PersistDisplay\obj\i386\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 35UL

#define resource_TextureToPersist_OFFSET 0UL
#define resource_DolphinTexture_OFFSET 20UL
#define resource_SeaFloorTexture_OFFSET 40UL
#define resource_WaterCaustic00_OFFSET 60UL
#define resource_WaterCaustic01_OFFSET 80UL
#define resource_WaterCaustic02_OFFSET 100UL
#define resource_WaterCaustic03_OFFSET 120UL
#define resource_WaterCaustic04_OFFSET 140UL
#define resource_WaterCaustic05_OFFSET 160UL
#define resource_WaterCaustic06_OFFSET 180UL
#define resource_WaterCaustic07_OFFSET 200UL
#define resource_WaterCaustic08_OFFSET 220UL
#define resource_WaterCaustic09_OFFSET 240UL
#define resource_WaterCaustic10_OFFSET 260UL
#define resource_WaterCaustic11_OFFSET 280UL
#define resource_WaterCaustic12_OFFSET 300UL
#define resource_WaterCaustic13_OFFSET 320UL
#define resource_WaterCaustic14_OFFSET 340UL
#define resource_WaterCaustic15_OFFSET 360UL
#define resource_WaterCaustic16_OFFSET 380UL
#define resource_WaterCaustic17_OFFSET 400UL
#define resource_WaterCaustic18_OFFSET 420UL
#define resource_WaterCaustic19_OFFSET 440UL
#define resource_WaterCaustic20_OFFSET 460UL
#define resource_WaterCaustic21_OFFSET 480UL
#define resource_WaterCaustic22_OFFSET 500UL
#define resource_WaterCaustic23_OFFSET 520UL
#define resource_WaterCaustic24_OFFSET 540UL
#define resource_WaterCaustic25_OFFSET 560UL
#define resource_WaterCaustic26_OFFSET 580UL
#define resource_WaterCaustic27_OFFSET 600UL
#define resource_WaterCaustic28_OFFSET 620UL
#define resource_WaterCaustic29_OFFSET 640UL
#define resource_WaterCaustic30_OFFSET 660UL
#define resource_WaterCaustic31_OFFSET 680UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\PlayField\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\PersistDisplay\PersistDisplay.cpp ===
//-----------------------------------------------------------------------------
// File: PersistDisplay.cpp
//
// Desc: Xbox sample showing how to persist the display during the launching
//       of a title, and then using that persisted surface in a startup
//       transition effect when the title starts. For simplicity, this sample
//       relaunches itslelf.
//
// Hist: 10.08.01 - New for the November XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBMesh.h>
#include <XBResource.h>
#include <XBUtil.h>
#include "Resource.h" // Resource header produced by the Bundler tool




//-----------------------------------------------------------------------------
// Globals variables and definitions
//-----------------------------------------------------------------------------
DWORD g_dwWaterColor     = 0x00004080; // Color of the water
FLOAT g_fLightAngle      = 0.0f;       // Orientation of light from above


// Vertex for the 3D meshes
struct SEAFLOORVERTEX
{
    D3DXVECTOR3 p;           // Position
    D3DXVECTOR3 n;           // Normal
    FLOAT       tu, tv;      // Tex coords
};

// Persisted surface transition constants
#define TRANSITION_FADEIN_END    2.0f    // Dolphin finishes fading-in in 3 seconds
#define TRANSITION_FADEOUT_BEGIN 4.0f    // Transition begins fade at 5 seconds
#define TRANSITION_FADEOUT_END   6.0f    // Transition ends fade at 7 seconds
#define RELAUNCH_FADE_TIME       2.0f    // Relaunch screen takes 2 seconds to fade




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    // Packed resources for the app
    CXBPackedResource       m_xprResource;

    // Font
    CXBFont                 m_Font;

    // Transform matrices
    D3DXMATRIX              m_matWorld;
    D3DXMATRIX              m_matView;
    D3DXMATRIX              m_matProj;

    // Dolphin object
    LPDIRECT3DTEXTURE8      m_pDolphinTexture;
    CXBMesh                 m_DolphinMesh1;
    CXBMesh                 m_DolphinMesh2;
    CXBMesh                 m_DolphinMesh3;
    LPDIRECT3DVERTEXBUFFER8 m_pDolphinVB1;
    LPDIRECT3DVERTEXBUFFER8 m_pDolphinVB2;
    LPDIRECT3DVERTEXBUFFER8 m_pDolphinVB3;
    LPDIRECT3DINDEXBUFFER8  m_pDolphinIB;
    DWORD                   m_dwNumDolphinVertices;
    DWORD                   m_dwNumDolphinIndices;
    DWORD                   m_dwDolphinVertexShader;
    DWORD                   m_dwDolphinVertexSize;

    LPDIRECT3DVERTEXBUFFER8 m_pDolphinStream1;
    LPDIRECT3DVERTEXBUFFER8 m_pDolphinStream2;

    // Seafloor object
    LPDIRECT3DTEXTURE8      m_pSeaFloorTexture;
    CXBMesh                 m_SeaFloorMesh;
    LPDIRECT3DVERTEXBUFFER8 m_pSeaFloorVB;
    LPDIRECT3DINDEXBUFFER8  m_pSeaFloorIB;
    DWORD                   m_dwNumSeaFloorVertices;
    DWORD                   m_dwNumSeaFloorIndices;
    DWORD                   m_dwSeaFloorVertexShader;
    DWORD                   m_dwSeaFloorVertexSize;

    // Water caustics
    LPDIRECT3DTEXTURE8      m_pCausticTextures[32];
    LPDIRECT3DTEXTURE8      m_pCurrentCausticTexture;
    DWORD                   m_dwUnderWaterPixelShader;

    // Image to persist when launching new title
    LPDIRECT3DTEXTURE8      m_pTextureToPersist;
    CHAR                    m_strLaunchTitleName[80];
    BOOL                    m_bAboutToLaunchNewTitle;
    FLOAT                   m_fRelaunchCountdownTime;

    // Startup animation transition
    BOOL                    m_bDoingStartupTransition;
    LPDIRECT3DSURFACE8      m_pPersistedSurface;   // Persisted surface from the startup screen
    LPDIRECT3DTEXTURE8      m_pPersistedTexture;   // Texture interface for the surface

    // Internal functions
    HRESULT CreatePixelShader();
    HRESULT RenderQuad(  LPDIRECT3DTEXTURE8 pTexture, FLOAT fAlpha );

public:
    HRESULT Initialize();
    HRESULT Render();
    HRESULT FrameMove();

    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    // Allow unlimited frame rate
    m_d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;

    // Dolphin object
    m_pDolphinTexture        = NULL;
    m_pDolphinVB1            = NULL;
    m_pDolphinVB2            = NULL;
    m_pDolphinVB3            = NULL;
    m_pDolphinIB             = NULL;
    m_dwDolphinVertexShader  = 0L;

    // SeaFloor object
    m_pSeaFloorTexture       = NULL;
    m_pSeaFloorVB            = NULL;
    m_pSeaFloorIB            = NULL;
    m_dwSeaFloorVertexShader = 0L;

    // Water caustics
    for( DWORD t=0; t<32; t++ )
        m_pCausticTextures[t] = NULL;
    m_dwUnderWaterPixelShader = 0L;

    // Startup animation transition
    m_pPersistedSurface = NULL;
    m_pPersistedTexture = NULL;

    m_bAboutToLaunchNewTitle  = FALSE;
    m_bDoingStartupTransition = FALSE;
}




//-----------------------------------------------------------------------------
// Name: CreatePixelShader()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::CreatePixelShader()
{
    //
    // Setup the pixel shader. To blend in water caustics, we want the
    // following effect:
    //    result = t0 * ( t1 * v0 + c0 )
    // where:
    //    t0 = Base texture
    //    t1 = Water caustics texture
    //    c0 = Ambient light contribution
    //    v0 = Directional light contribution
    //
    // This can be encoded into a pixel shader with:
    //    1st stage: r0 = (t1*v0 + c0*1)
    //    Final:     A*B + (1-A)*C + D
    //               E*F = r0 * t0
    // where:
    //    A = Fog factor
    //    B = EF
    //    C = Fog color
    //    D = 0
    //    E = r0
    //    F = t0
    //
    D3DPIXELSHADERDEF psd;
    ZeroMemory( &psd, sizeof(psd) );
    psd.PSCombinerCount = PS_COMBINERCOUNT( 1,
                                            PS_COMBINERCOUNT_MUX_MSB | PS_COMBINERCOUNT_UNIQUE_C0 | PS_COMBINERCOUNT_UNIQUE_C1);
    psd.PSTextureModes  = PS_TEXTUREMODES( PS_TEXTUREMODES_PROJECT2D, PS_TEXTUREMODES_PROJECT2D,
                                           PS_TEXTUREMODES_NONE, PS_TEXTUREMODES_NONE );
    psd.PSInputTexture  = PS_INPUTTEXTURE( 0, 0, 0, 0 );
    psd.PSDotMapping    = PS_DOTMAPPING( 0, PS_DOTMAPPING_ZERO_TO_ONE,
                                         PS_DOTMAPPING_ZERO_TO_ONE, PS_DOTMAPPING_ZERO_TO_ONE );
    psd.PSCompareMode   = PS_COMPAREMODE( PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
                                          PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
                                          PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
                                          PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT );

    //------------- Stage 0 -------------
    // Build factor from caustics and lighting (R0 = T1*V0 + C0)
    psd.PSRGBInputs[0]    = PS_COMBINERINPUTS( PS_REGISTER_T1  | PS_CHANNEL_RGB,
                                               PS_REGISTER_V0  | PS_CHANNEL_RGB,
                                               PS_REGISTER_C0  | PS_CHANNEL_RGB,
                                               PS_REGISTER_ONE | PS_CHANNEL_RGB );
    psd.PSAlphaInputs[0]  = PS_COMBINERINPUTS( PS_REGISTER_T1  | PS_CHANNEL_ALPHA,
                                               PS_REGISTER_V0  | PS_CHANNEL_ALPHA,
                                               PS_REGISTER_C0  | PS_CHANNEL_ALPHA,
                                               PS_REGISTER_ONE | PS_CHANNEL_ALPHA );
    psd.PSRGBOutputs[0]   = PS_COMBINEROUTPUTS( PS_REGISTER_DISCARD,
                                                PS_REGISTER_DISCARD,
                                                PS_REGISTER_R0,
                                                PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM );
    psd.PSAlphaOutputs[0] = PS_COMBINEROUTPUTS( PS_REGISTER_DISCARD,
                                                PS_REGISTER_DISCARD,
                                                PS_REGISTER_R0,
                                                PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM );

    psd.PSC0Mapping = 0xfffffff0;
    psd.PSC1Mapping = 0xffffffff;

    //------------- Final combiner -------------
    
    // EF is R0*T0. G is alpha and is set to 1.
    psd.PSFinalCombinerInputsEFG = PS_COMBINERINPUTS( PS_REGISTER_R0  | PS_CHANNEL_RGB,
                                                      PS_REGISTER_T0  | PS_CHANNEL_RGB,
                                                      PS_REGISTER_ONE | PS_CHANNEL_RGB,
                                                      0 | 0 | 0 );

    // Just factor the fog in with the results from the last stage:
    //    Result = Fog.a * R0 + (1-Fog.a)*Fog.rgb + 0
    psd.PSFinalCombinerInputsABCD = PS_COMBINERINPUTS( PS_REGISTER_FOG     | PS_CHANNEL_ALPHA,
                                                       PS_REGISTER_EF_PROD | PS_CHANNEL_RGB,
                                                       PS_REGISTER_FOG     | PS_CHANNEL_RGB,
                                                       PS_REGISTER_ZERO    | PS_CHANNEL_RGB );

    // Create the pixel shader, as defined above.
    if( FAILED( m_pd3dDevice->CreatePixelShader( &psd, &m_dwUnderWaterPixelShader ) ) )
        return E_FAIL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    HRESULT    hr;

    // Create the resources
    if( FAILED( m_xprResource.Create( m_pd3dDevice, "Resource.xpr", 
                                      resource_NUM_RESOURCES ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create texture for the image to persiste
    m_pTextureToPersist = m_xprResource.GetTexture( resource_TextureToPersist_OFFSET );

    // Create texture for the dolphin
    m_pDolphinTexture = m_xprResource.GetTexture( resource_DolphinTexture_OFFSET );

    // Load the file-based mesh objects for the dolphin
    if( FAILED( m_DolphinMesh1.Create( m_pd3dDevice, "Models\\Dolphin1.xbg" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    if( FAILED( m_DolphinMesh2.Create( m_pd3dDevice, "Models\\Dolphin2.xbg" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    if( FAILED( m_DolphinMesh3.Create( m_pd3dDevice, "Models\\Dolphin3.xbg" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    m_pDolphinVB1 = &m_DolphinMesh1.GetMesh(0)->m_VB;
    m_pDolphinVB2 = &m_DolphinMesh2.GetMesh(0)->m_VB;
    m_pDolphinVB3 = &m_DolphinMesh3.GetMesh(0)->m_VB;
    m_pDolphinIB  = &m_DolphinMesh1.GetMesh(0)->m_IB;
    m_dwNumDolphinVertices = m_DolphinMesh1.GetMesh(0)->m_dwNumVertices;
    m_dwNumDolphinIndices  = m_DolphinMesh1.GetMesh(0)->m_dwNumIndices;
    m_dwDolphinVertexSize  = m_DolphinMesh1.GetMesh(0)->m_dwVertexSize;

    // Create vertex shader for the dolphin
    DWORD dwDolphinVertexDecl[] =
    {
        // m_pDolphinVB1
        D3DVSD_STREAM( 0 ),              // This data comes from stream 0
        D3DVSD_REG( 0, D3DVSDT_FLOAT3 ), // v0 = Position of first mesh
        D3DVSD_REG( 3, D3DVSDT_FLOAT3 ), // v3 = Normal
        D3DVSD_REG( 6, D3DVSDT_FLOAT2 ), // v6 = Tex coords

        // m_pDolphinVB2
        D3DVSD_STREAM( 1 ),              // This data comes from stream 1
        D3DVSD_REG( 1, D3DVSDT_FLOAT3 ), // v1 = Position of second mesh
        D3DVSD_REG( 4, D3DVSDT_FLOAT3 ), // v4 = Normal
        D3DVSD_REG( 7, D3DVSDT_FLOAT2 ), // v7 = Tex coords

        // m_pDolphinVB3
        D3DVSD_STREAM( 2 ),              // This data comes from stream 2
        D3DVSD_REG( 2, D3DVSDT_FLOAT3 ), // v2 = Position of second mesh
        D3DVSD_REG( 5, D3DVSDT_FLOAT3 ), // v5 = Normal
        D3DVSD_REG( 8, D3DVSDT_FLOAT2 ), // v8 = Tex coords
        D3DVSD_END()
    };

    hr = XBUtil_CreateVertexShader( m_pd3dDevice, "Shaders\\Dolphin.xvu",
                                    dwDolphinVertexDecl, &m_dwDolphinVertexShader );
    if( FAILED(hr) )
        return hr;

    // Create textures for the seafloor
    m_pSeaFloorTexture = m_xprResource.GetTexture( resource_SeaFloorTexture_OFFSET );
    
    // Load the file-based mesh object for the seafloor
    if( FAILED( m_SeaFloorMesh.Create( m_pd3dDevice, "Models\\SeaFloor.xbg" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    m_pSeaFloorVB = &m_SeaFloorMesh.GetMesh(0)->m_VB;
    m_pSeaFloorIB = &m_SeaFloorMesh.GetMesh(0)->m_IB;
    m_dwNumSeaFloorVertices = m_SeaFloorMesh.GetMesh(0)->m_dwNumVertices;
    m_dwNumSeaFloorIndices  = m_SeaFloorMesh.GetMesh(0)->m_dwNumIndices;
    m_dwSeaFloorVertexSize  = m_SeaFloorMesh.GetMesh(0)->m_dwVertexSize;

    // Add some bumpiness to the seafloor mesh
    SEAFLOORVERTEX* pDst;
    m_pSeaFloorVB->Lock( 0, 0, (BYTE**)&pDst, 0 );
    srand(5);
    for( DWORD i=0; i<m_dwNumSeaFloorVertices; i++ )
    {
        pDst[i].p.y += (rand()/(FLOAT)RAND_MAX);
        pDst[i].p.y += (rand()/(FLOAT)RAND_MAX);
        pDst[i].p.y += (rand()/(FLOAT)RAND_MAX);
        pDst[i].tu  *= 10;
        pDst[i].tv  *= 10;
    }
    m_pSeaFloorVB->Unlock();

    // Create vertex shader for the seafloor
    DWORD dwSeaFloorVertexDecl[] =
    {
        D3DVSD_STREAM( 0 ),
        D3DVSD_REG( 0, D3DVSDT_FLOAT3 ), // Position of first mesh
        D3DVSD_REG( 3, D3DVSDT_FLOAT3 ), // Normal
        D3DVSD_REG( 6, D3DVSDT_FLOAT2 ), // Tex coords
        D3DVSD_END()
    };

    if( FAILED( hr = XBUtil_CreateVertexShader( m_pd3dDevice, "Shaders\\SeaFloor.xvu",
                                                dwSeaFloorVertexDecl,
                                                &m_dwSeaFloorVertexShader ) ) )
        return hr;

    // Create a pixel shader for the underwater effect
    hr = CreatePixelShader();
    if( FAILED(hr) )
        return hr;

    // Create textures for the water caustics
    m_pCausticTextures[ 0] = m_xprResource.GetTexture( resource_WaterCaustic00_OFFSET );
    m_pCausticTextures[ 1] = m_xprResource.GetTexture( resource_WaterCaustic01_OFFSET );
    m_pCausticTextures[ 2] = m_xprResource.GetTexture( resource_WaterCaustic02_OFFSET );
    m_pCausticTextures[ 3] = m_xprResource.GetTexture( resource_WaterCaustic03_OFFSET );
    m_pCausticTextures[ 4] = m_xprResource.GetTexture( resource_WaterCaustic04_OFFSET );
    m_pCausticTextures[ 5] = m_xprResource.GetTexture( resource_WaterCaustic05_OFFSET );
    m_pCausticTextures[ 6] = m_xprResource.GetTexture( resource_WaterCaustic06_OFFSET );
    m_pCausticTextures[ 7] = m_xprResource.GetTexture( resource_WaterCaustic07_OFFSET );
    m_pCausticTextures[ 8] = m_xprResource.GetTexture( resource_WaterCaustic08_OFFSET );
    m_pCausticTextures[ 9] = m_xprResource.GetTexture( resource_WaterCaustic09_OFFSET );
    m_pCausticTextures[10] = m_xprResource.GetTexture( resource_WaterCaustic10_OFFSET );
    m_pCausticTextures[11] = m_xprResource.GetTexture( resource_WaterCaustic11_OFFSET );
    m_pCausticTextures[12] = m_xprResource.GetTexture( resource_WaterCaustic12_OFFSET );
    m_pCausticTextures[13] = m_xprResource.GetTexture( resource_WaterCaustic13_OFFSET );
    m_pCausticTextures[14] = m_xprResource.GetTexture( resource_WaterCaustic14_OFFSET );
    m_pCausticTextures[15] = m_xprResource.GetTexture( resource_WaterCaustic15_OFFSET );
    m_pCausticTextures[16] = m_xprResource.GetTexture( resource_WaterCaustic16_OFFSET );
    m_pCausticTextures[17] = m_xprResource.GetTexture( resource_WaterCaustic17_OFFSET );
    m_pCausticTextures[18] = m_xprResource.GetTexture( resource_WaterCaustic18_OFFSET );
    m_pCausticTextures[19] = m_xprResource.GetTexture( resource_WaterCaustic19_OFFSET );
    m_pCausticTextures[20] = m_xprResource.GetTexture( resource_WaterCaustic20_OFFSET );
    m_pCausticTextures[21] = m_xprResource.GetTexture( resource_WaterCaustic21_OFFSET );
    m_pCausticTextures[22] = m_xprResource.GetTexture( resource_WaterCaustic22_OFFSET );
    m_pCausticTextures[23] = m_xprResource.GetTexture( resource_WaterCaustic23_OFFSET );
    m_pCausticTextures[24] = m_xprResource.GetTexture( resource_WaterCaustic24_OFFSET );
    m_pCausticTextures[25] = m_xprResource.GetTexture( resource_WaterCaustic25_OFFSET );
    m_pCausticTextures[26] = m_xprResource.GetTexture( resource_WaterCaustic26_OFFSET );
    m_pCausticTextures[27] = m_xprResource.GetTexture( resource_WaterCaustic27_OFFSET );
    m_pCausticTextures[28] = m_xprResource.GetTexture( resource_WaterCaustic28_OFFSET );
    m_pCausticTextures[29] = m_xprResource.GetTexture( resource_WaterCaustic29_OFFSET );
    m_pCausticTextures[30] = m_xprResource.GetTexture( resource_WaterCaustic30_OFFSET );
    m_pCausticTextures[31] = m_xprResource.GetTexture( resource_WaterCaustic31_OFFSET );

    // Set the transform matrices
    D3DXVECTOR3 vEyePt      = D3DXVECTOR3( 0.0f, 0.0f,-5.0f );
    D3DXVECTOR3 vLookatPt   = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );
    D3DXVECTOR3 vUpVec      = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
    D3DXMatrixIdentity( &m_matWorld );
    D3DXMatrixLookAtLH( &m_matView, &vEyePt, &vLookatPt, &vUpVec );
    D3DXMatrixPerspectiveFovLH( &m_matProj, D3DX_PI/3, 4.0f/3.0f, 1.0f, 10000.0f );

    // Create a texture surface for the persisted surface
    LPDIRECT3DSURFACE8 pPersistedSurface;
    m_pd3dDevice->GetPersistedSurface( &pPersistedSurface );
    if( pPersistedSurface )
    {
        // Create an empty surface to hold the persistent screen
        m_pd3dDevice->CreateTexture( 640, 480, 1, 0, D3DFMT_LIN_A8R8G8B8, 0, &m_pPersistedTexture );
        m_pPersistedTexture->GetSurfaceLevel( 0, &m_pPersistedSurface );
    
        // Copy persisted bits to our surface, scaling and converting if necessary
        D3DXLoadSurfaceFromSurface( m_pPersistedSurface, NULL, NULL, pPersistedSurface, 
                                    NULL, NULL, D3DX_FILTER_TRIANGLE, 0 );

        // Note that the persisted surface is not reference-counted, so we do
        // not need to call Release() on it

        // With a valid surface, we can safely do the transition
        m_bDoingStartupTransition = TRUE;
    }

    // Find the name of the executable. We'll use this later when we call
    // XLaunchNewImage() to re-launch this app.
    WIN32_FIND_DATA wfd;
    HANDLE hFind = FindFirstFile( "d:\\*.xbe", &wfd );
    if( INVALID_HANDLE_VALUE == hFind )
    {
        OUTPUT_DEBUG_STRING( "Error: Could not find any .xbe files.\n" );
        return E_FAIL;
    }
    sprintf( m_strLaunchTitleName, "d:\\%s", wfd.cFileName );
    FindClose( hFind );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    if( !m_bDoingStartupTransition )
    {
        // When the user presses the Y button, kick off the process to persist the
        // display and relaunch the title.
        if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_Y] )
        {
            m_bAboutToLaunchNewTitle = TRUE;
            m_fRelaunchCountdownTime = RELAUNCH_FADE_TIME;
        }
        
        // Keep the countdown going
        m_fRelaunchCountdownTime -= m_fElapsedAppTime;
    }
    
    // Animation attributes for the dolphin
    FLOAT fKickFreq    = 2*m_fAppTime;
    FLOAT fPhase       = m_fAppTime/3-1.3f;
    FLOAT fBlendWeight = sinf( fKickFreq );

    // Move the dolphin in a circle
    D3DXMATRIX matDolphin, matTrans, matRotate1, matRotate2;
    D3DXMatrixScaling( &matDolphin, 0.01f, 0.01f, 0.01f );
    D3DXMatrixRotationZ( &matRotate1, -cosf(fKickFreq)/6 );
    D3DXMatrixMultiply( &matDolphin, &matDolphin, &matRotate1 );
    D3DXMatrixRotationY( &matRotate2, fPhase );
    D3DXMatrixMultiply( &matDolphin, &matDolphin, &matRotate2 );
    D3DXMatrixTranslation( &matTrans, -5.0f*sinf(fPhase), sinf(fKickFreq)/2, 10.0f-10.0f*cosf(fPhase) );
    D3DXMatrixMultiply( &matDolphin, &matDolphin, &matTrans );

    // Blend weight and vertex buffer selection for vertex tweening
    FLOAT fWeight1, fWeight2;
    if ( fBlendWeight > 0.0f )
    {
        // Use vertex sets one the two.
        fWeight1 = fBlendWeight;
        fWeight2 = 1.0f - fBlendWeight;

        m_pDolphinStream1 = m_pDolphinVB1;
        m_pDolphinStream2 = m_pDolphinVB2;
    }
    else
    {
        // Use vertex sets two and three.
        fWeight1 = 1.0f + fBlendWeight;
        fWeight2 = -fBlendWeight;

        m_pDolphinStream1 = m_pDolphinVB2;
        m_pDolphinStream2 = m_pDolphinVB3;
    }

    // Values passed into the vertex shader for lighting, etc.
    D3DXVECTOR4 fConstants0( 0.0f, 0.0f, 0.0f, 0.00f );
    D3DXVECTOR4 fConstants1( 1.0f, 0.5f, 0.2f, 0.05f );
    D3DXVECTOR4 fLight( sinf(g_fLightAngle), cosf(g_fLightAngle), 0.0f, 0.0f );
    D3DXVECTOR4 fDiffuse( 1.00f, 1.00f, 1.00f, 1.00f );
    D3DXVECTOR4 fAmbient( 0.25f, 0.25f, 0.25f, 0.25f );
    D3DXVECTOR4 fFog( 0.5f, 50.0f, 1.0f/(50.0f-1.0f), 0.0f );
    D3DXVECTOR4 fCaustics( 0.05f, 0.05f, sinf(m_fAppTime)/8, cosf(m_fAppTime)/10 - m_fAppTime/10 );
    D3DXVECTOR4 fWeight( fWeight1, fWeight2, 0.0f, 0.0f );

    // Calculate and set composite matrix for dolphin.
    D3DXMATRIX matComposite;
    D3DXMatrixMultiply( &matComposite, &matDolphin, &m_matView );
    D3DXMatrixMultiply( &matComposite, &matComposite, &m_matProj );
    D3DXMatrixTranspose( &matComposite, &matComposite );
    m_pd3dDevice->SetVertexShaderConstant( 4, &matComposite, 4 );

    // Scale and offset fog start and end by values from projection matrix.
    float fFogStart = 1.0f;
    float fFogEnd = 50.0f;

    fFogStart = fFogStart * m_matProj._33 + m_matProj._43;
    fFogEnd = fFogEnd * m_matProj._33 + m_matProj._43;

    fFog[2] = 1.0f / (fFogEnd - fFogStart);
    fFog[1] = fFogEnd * fFog[2];

    // Calculate and set composite matrix for seafloor.
    D3DXMatrixMultiply( &matComposite, &m_matView, &m_matProj );
    D3DXMatrixTranspose( &matComposite, &matComposite );
    m_pd3dDevice->SetVertexShaderConstant( 8, &matComposite, 4 );

    // Calculate and set texgen matrix for dolphin.
    D3DXMatrixMultiply( &matComposite, &matDolphin, &m_matView );
    matComposite *= 0.5f;
    D3DXMatrixTranspose( &matComposite, &matComposite );
    m_pd3dDevice->SetVertexShaderConstant( 12, &matComposite, 4 );

    // Set the vertex shader constants
    m_pd3dDevice->SetVertexShaderConstant(  0, &fConstants0, 1 ); // Some constants
    m_pd3dDevice->SetVertexShaderConstant(  1, &fConstants1, 1 ); // More constants
    m_pd3dDevice->SetVertexShaderConstant(  2, &fWeight,     1 );

    m_pd3dDevice->SetVertexShaderConstant( 20, &fLight,      1 ); // Light direction
    m_pd3dDevice->SetVertexShaderConstant( 21, &fDiffuse,    1 ); // Diffuse color
    m_pd3dDevice->SetVertexShaderConstant( 23, &fFog,        1 ); // Fog factors
    m_pd3dDevice->SetVertexShaderConstant( 24, &fCaustics,   1 ); // Misc constants
    
    // Animate the caustic textures
    DWORD tex = ((DWORD)(m_fAppTime*32))%32;
    m_pCurrentCausticTexture = m_pCausticTextures[tex];

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: RenderQuad()
// Desc: Renders a quad textured with the persisted surface
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::RenderQuad( LPDIRECT3DTEXTURE8 pTexture, FLOAT fAlpha )
{
    // Set up the vertices (notice the pixel centers are shifted by -0.5f to
    // line them up with the texel centers). The texture coordinates assume
    // a linear texture will be used.
    struct VERTEX { D3DXVECTOR4 p; FLOAT tu, tv; };
    VERTEX v[4];
    v[0].p = D3DXVECTOR4(   0 - 0.5f,   0 - 0.5f, 0.0f, 0.0f ); v[0].tu =   0; v[0].tv =   0;
    v[1].p = D3DXVECTOR4( 640 - 0.5f,   0 - 0.5f, 0.0f, 0.0f ); v[1].tu = 640; v[1].tv =   0;
    v[2].p = D3DXVECTOR4( 640 - 0.5f, 480 - 0.5f, 0.0f, 0.0f ); v[2].tu = 640; v[2].tv = 480;
    v[3].p = D3DXVECTOR4(   0 - 0.5f, 480 - 0.5f, 0.0f, 0.0f ); v[3].tu =   0; v[3].tv = 480;

    // Set state to render the image
    m_pd3dDevice->SetTexture( 0, pTexture );
    m_pd3dDevice->SetPixelShader( NULL );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TFACTOR );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU,  D3DTADDRESS_CLAMP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV,  D3DTADDRESS_CLAMP );
    m_pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, (DWORD)(255.0f*fAlpha)<<24L );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,  D3DBLEND_SRCALPHA );
    m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_FOGENABLE,    FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_FOGTABLEMODE, D3DFOG_NONE );

    // Render the quad
    m_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_TEX1 );
    m_pd3dDevice->DrawPrimitiveUP( D3DPT_QUADLIST, 1, v, sizeof(v[0]) );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Sets up render states, clears the viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Clear the viewport (normal clear, no transition)
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,
                         g_dwWaterColor, 1.0f, 0L );

    // Set default render states
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,          TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_FOGENABLE,        TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_FOGCOLOR,         g_dwWaterColor );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_POINT );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_MIPFILTER, D3DTEXF_POINT );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU,  D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV,  D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ADDRESSU,  D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ADDRESSV,  D3DTADDRESS_WRAP );

    // Turn on the pixel shader for the underwater effect, which blends in the
    // current caustic texture.
    m_pd3dDevice->SetPixelShader( m_dwUnderWaterPixelShader );
    m_pd3dDevice->SetTexture( 1, m_pCurrentCausticTexture );

    // Set the ambient color input to the pixel shader.
    // Note: This must be done after the pixel shader is set.
    D3DXVECTOR4 fAmbient( 0.25f, 0.25f, 0.25f, 0.25f );
    m_pd3dDevice->SetPixelShaderConstant( 0, &fAmbient, 1 );

    // Render the seafloor. The vertex shader does the transformation, texture
    // projection (for the water caustics) and fog calculations.
    m_pd3dDevice->SetTexture( 0, m_pSeaFloorTexture );
    m_pd3dDevice->SetVertexShader( m_dwSeaFloorVertexShader );
    m_pd3dDevice->SetStreamSource( 0, m_pSeaFloorVB, m_dwSeaFloorVertexSize );
    m_pd3dDevice->SetIndices( m_pSeaFloorIB, 0 );
    m_pd3dDevice->DrawIndexedVertices( D3DPT_TRIANGLESTRIP, m_dwNumSeaFloorIndices, 
                                       D3D__IndexData );

    // At the beginning of the app, we keep access to the persisted surface, so
    // we can have a transistion effect. Render that effect here, after the
    // seafloor, but before the dolphin to get a cool effect.
    if( m_bDoingStartupTransition )
    {
        if( m_fAppTime < TRANSITION_FADEOUT_BEGIN )
        {
            // For the first few seconds, keep the persisted display as is
            RenderQuad( m_pPersistedTexture, 1.0f );
        }
        else if( m_fAppTime < TRANSITION_FADEOUT_END )
        {
            // Over the next few seconds, fade out the persisted display
            RenderQuad( m_pPersistedTexture, 
                        1.0f-(m_fAppTime-TRANSITION_FADEOUT_BEGIN)/(TRANSITION_FADEOUT_END-TRANSITION_FADEOUT_BEGIN) );
        }
        else
        {
            // We're done with the surface
            m_pPersistedTexture->Release();
            m_pPersistedTexture = NULL;
            m_bDoingStartupTransition = FALSE;
        }
    }

    // Restore state that would've gotten trashed rendering a quad above
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,          TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_FOGENABLE,        TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_FOGCOLOR,         g_dwWaterColor );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU,  D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV,  D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ADDRESSU,  D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ADDRESSV,  D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTexture( 1, m_pCurrentCausticTexture );
    m_pd3dDevice->SetPixelShader( m_dwUnderWaterPixelShader );
    m_pd3dDevice->SetPixelShaderConstant( 0, &fAmbient, 1 );

    // Render the dolphin. The vertex shader does the vertex tweening, 
    // transformation, texture projection (for the water caustics) and fog
    // calculations.
    m_pd3dDevice->SetTexture( 0, m_pDolphinTexture );
    m_pd3dDevice->SetVertexShader( m_dwDolphinVertexShader );
    m_pd3dDevice->SetStreamSource( 0, m_pDolphinStream1, m_dwDolphinVertexSize );
    m_pd3dDevice->SetStreamSource( 1, m_pDolphinStream2, m_dwDolphinVertexSize );
    m_pd3dDevice->SetIndices( m_pDolphinIB, 0 );
    m_pd3dDevice->DrawIndexedVertices( D3DPT_TRIANGLESTRIP, m_dwNumDolphinIndices, 
                                       D3D__IndexData );

    // If we're in the startup transition, let's render the persisted surface
    // again, so it looks like the dolphin fades into existance.
    if( m_bDoingStartupTransition )
    {
        if( m_fAppTime < TRANSITION_FADEIN_END )
        {
            // Over the first few seconds, fade out the persisted display which
            // is kinda like the same thing as fading in the dolphin
            RenderQuad( m_pPersistedTexture, 
                        1.0f - (m_fAppTime)/(TRANSITION_FADEIN_END) );
        }
    }

    // Draw the title and framerate
    if( !m_bDoingStartupTransition && !m_bAboutToLaunchNewTitle )
    {
        m_Font.Begin();
        m_Font.DrawText(  64,  50, 0xffffffff, L"PersistDisplay" );
        m_Font.DrawText( 450,  50, 0xffffff00, m_strFrameRate );
        m_Font.DrawText(  64,  75, 0xffffff00, L"Press the Y button to persist the display" );
        m_Font.DrawText(  64, 100, 0xffffff00, L"and relaunch this title" );
        m_Font.End();
    }

    // Before launching a new title, fade in an image to persist. The image will
    // be something akin to "Loading next level..."
    if( m_bAboutToLaunchNewTitle )
    {
        if( m_fRelaunchCountdownTime > 0.0f )
        {
            // Over the first few seconds, fade in the image to persist
            RenderQuad( m_pTextureToPersist, 1.0f - m_fRelaunchCountdownTime/RELAUNCH_FADE_TIME );
        }
        else
        {
            // When the countdown is done, persist the  display and relaunch
            // the title.
            RenderQuad( m_pTextureToPersist, 1.0f );
            m_pd3dDevice->Present( NULL, NULL, NULL, NULL );
            m_pd3dDevice->PersistDisplay();
            XLaunchNewImage( m_strLaunchTitleName, NULL );
        }
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\PlayField\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\PlayField\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\PlayField\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\PixelShader\PixelShader.cpp ===
//-----------------------------------------------------------------------------
// File: PixelShader.cpp
//
// Desc: Demonstrates the use of pixel shaders. The sample shows two different
//       pixel shaders (one created manually, and one file-based) on two
//       different geometries (a cylinder or a quad).
//
//       The hard-coded pixel shader uses texture 2 (T2, in shader speak) as a
//       mask to select between texture 0 (T0) and texture 1 (T1). The shader 
//       also modulates in the diffuse component (V0).
//
//       The file-based shader does a different effect. The diffuse color (V0)
//       is used as a factor to linearly-interpolate between textures 0 and 1
//       (T0 and T1). Note that the second texture is not used in this shader.
//
// Hist: 12.15.00 - New for December XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <XBResource.h>
#include <XBUtil.h>

// The following header file is generated from "Resource.rdf" file using the
// Bundler tool. In addition to the header, the tool outputs a binary file
// (Resource.xpr) which contains compiled (i.e. bundled) resources and is
// loaded at runtime using the CXBPackedResource class.
#include "Resource.h"




//-----------------------------------------------------------------------------
// ASCII names for the resources used by the app
//-----------------------------------------------------------------------------
XBRESOURCE g_ResourceNames[] = 
{
    { "Texture0.tga", resource_Texture0_OFFSET },
    { "Texture1.tga", resource_Texture1_OFFSET },
    { "Checker.bmp",  resource_Checker_OFFSET },
    { NULL, 0 },
};




//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_LEFTSTICK,    XBHELP_PLACEMENT_1, L"Rotate object" },
    { XBHELP_RIGHTSTICK,   XBHELP_PLACEMENT_1, L"Move light" },
    { XBHELP_DPAD,         XBHELP_PLACEMENT_1, L"Zoom" },
    { XBHELP_X_BUTTON,     XBHELP_PLACEMENT_2, L"Toggle\npshader" },
    { XBHELP_A_BUTTON,     XBHELP_PLACEMENT_1, L"Toggle\nmodels" },
    { XBHELP_B_BUTTON,     XBHELP_PLACEMENT_1, L"Toggle\nwireframe" },
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_1, L"Display\nhelp" },
    { XBHELP_START_BUTTON, XBHELP_PLACEMENT_1, L"Pause" },
};

#define NUM_HELP_CALLOUTS 8




//-----------------------------------------------------------------------------
// Global variables
//-----------------------------------------------------------------------------
struct CUSTOMVERTEX
{
    D3DXVECTOR3 position;   // The position
    D3DXVECTOR3 normal;     // The vertex normals
    D3DCOLOR    color;      // The color
    FLOAT       tu0, tv0;   // Texture 0 coordinates
    FLOAT       tu1, tv1;   // Texture 1 coordinates
    FLOAT       tu2, tv2;   // Texture 2 coordinates
};

// Our custom FVF, which describes our custom vertex structure
#define D3DFVF_CUSTOMVERTEX (D3DFVF_XYZ|D3DFVF_NORMAL|D3DFVF_DIFFUSE|D3DFVF_TEX1|D3DFVF_TEX2|D3DFVF_TEX3)




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBPackedResource  m_xprResource;        // Packed resources for the app
    CXBFont            m_Font;               // Font class
    CXBHelp            m_Help;               // Help class
    BOOL               m_bDrawHelp;          // Whether to draw help

    LPDIRECT3DVERTEXBUFFER8 m_pCylinderVB; // Buffer for cylinder vertices
    LPDIRECT3DVERTEXBUFFER8 m_pQuadVB;     // Buffer for quad vertices
    LPDIRECT3DTEXTURE8      m_pTexture0;
    LPDIRECT3DTEXTURE8      m_pTexture1;
    LPDIRECT3DTEXTURE8      m_pTexture2;

    UINT         m_bCylinder;        // Displayed model
    BOOL         m_bHardcodedShader; // Render type
    BOOL         m_bWireframe;

    DWORD        m_dwPixelShader1;   // Handle for pixel shader 1
    DWORD        m_dwPixelShader2;   // Handle for pixel shader 2

    D3DXMATRIX   m_matObject;        // Transform matrix for the object
    D3DXMATRIX   m_matTexture;       // Transform matrix for the texture
    FLOAT        m_fEyeScale;        // Scale of viewing distance

    HRESULT InitGeometry();

public:
    HRESULT Initialize();
    HRESULT Render();
    HRESULT FrameMove();

    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    m_bDrawHelp        = FALSE;

    m_bCylinder        = TRUE;
    m_bHardcodedShader = TRUE;
    m_bWireframe       = FALSE;
    m_pCylinderVB      = NULL;
    m_pQuadVB          = NULL;
    m_pTexture0        = NULL;
    m_pTexture1        = NULL;
    m_pTexture2        = NULL;
    m_dwPixelShader1   = 0L;
    m_dwPixelShader2   = 0L;
    m_fEyeScale        = 1.0f;

    D3DXMatrixIdentity( &m_matObject );
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Initialize scene objects.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create the font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the resources
    if( FAILED( m_xprResource.Create( m_pd3dDevice, "Resource.xpr", 
                                      resource_NUM_RESOURCES, g_ResourceNames ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Load the textures
	m_pTexture0 = m_xprResource.GetTexture( "Texture0.tga" );
	m_pTexture1 = m_xprResource.GetTexture( "Texture1.tga" );
	m_pTexture2 = m_xprResource.GetTexture( "Checker.bmp" );
    
    // Create geometry for a quad
    if( FAILED( m_pd3dDevice->CreateVertexBuffer( 4*sizeof(CUSTOMVERTEX),
                                                  0, D3DFVF_CUSTOMVERTEX,
                                                  D3DPOOL_DEFAULT, &m_pQuadVB ) ) )
        return E_FAIL;

    CUSTOMVERTEX* v;
    m_pQuadVB->Lock( 0, 0, (BYTE**)&v, 0 );
    for( DWORD i=0; i<4; i++ )
    {
        FLOAT x = i<2 ? 1.0f : -1.0f;
        FLOAT y = i%2 ? 1.0f : -1.0f;

        v[i].position = D3DXVECTOR3( x, y, 0.0f );
        v[i].normal   = D3DXVECTOR3( 0.0f, 0.0f, -1.0f );
        v[i].tu0      = v[i].tu1 = v[i].tu2 = (1+x)/2;
        v[i].tv0      = v[i].tv1 = v[i].tv2 = (1-y)/2;

        if( i==0 ) v[i].color = 0xff00ff00;
        if( i==1 ) v[i].color = 0xff0000ff;
        if( i==2 ) v[i].color = 0xffff0000;
        if( i==3 ) v[i].color = 0xffffffff;
    }
    m_pQuadVB->Unlock();

    // Create geometry for a cylinder
    if( FAILED( m_pd3dDevice->CreateVertexBuffer( 50*2*sizeof(CUSTOMVERTEX),
                                                  0, D3DFVF_CUSTOMVERTEX,
                                                  D3DPOOL_DEFAULT, &m_pCylinderVB ) ) )
        return E_FAIL;

    // Fill the vertex buffer. We are setting the tu and tv texture
    // coordinates, which range from 0.0 to 1.0
    if( FAILED( m_pCylinderVB->Lock( 0, 0, (BYTE**)&v, 0 ) ) )
        return E_FAIL;
    for( i=0; i<50; i++ )
    {
        FLOAT theta = (2*D3DX_PI*i)/(50-1);

        v[2*i+0].position = D3DXVECTOR3( sinf(theta),-1.2f, cosf(theta) );
        v[2*i+0].normal   = D3DXVECTOR3( sinf(theta), 0.0f, cosf(theta) );
        v[2*i+0].color    = 0xffffffff;
        v[2*i+0].tu0      = v[2*i+0].tu1 = v[2*i+0].tu2 = ((FLOAT)i*2.0f)/(50-1);
        v[2*i+0].tv0      = v[2*i+0].tv1 = v[2*i+0].tv2 = 1.0f;

        v[2*i+1].position = D3DXVECTOR3( sinf(theta), 1.2f, cosf(theta) );
        v[2*i+1].normal   = D3DXVECTOR3( sinf(theta), 0.0f, cosf(theta) );
        v[2*i+1].color    = 0xff808080;
        v[2*i+1].tu0      = v[2*i+1].tu1 = v[2*i+1].tu2 = ((FLOAT)i*2.0f)/(50-1);
        v[2*i+1].tv0      = v[2*i+1].tv1 = v[2*i+1].tv2 = 0.0f;
    }
    m_pCylinderVB->Unlock();

    //--------------------------
    // Define a hard-coded pixel shader
    //--------------------------
    D3DPIXELSHADERDEF psd;
    ZeroMemory( &psd, sizeof(psd) );
    
    // The pixel shader uses 3 combiner stages
    psd.PSCombinerCount = PS_COMBINERCOUNT( 3,
        PS_COMBINERCOUNT_MUX_MSB | PS_COMBINERCOUNT_UNIQUE_C0 | PS_COMBINERCOUNT_UNIQUE_C1 );
    psd.PSTextureModes  = PS_TEXTUREMODES( PS_TEXTUREMODES_PROJECT2D,
                                        PS_TEXTUREMODES_PROJECT2D,
                                        PS_TEXTUREMODES_PROJECT2D,
                                        PS_TEXTUREMODES_NONE );
    psd.PSInputTexture  = PS_INPUTTEXTURE( 0, 0, 0, 0 );
    psd.PSDotMapping    = PS_DOTMAPPING( 0,
                                    PS_DOTMAPPING_ZERO_TO_ONE,
                                    PS_DOTMAPPING_ZERO_TO_ONE,
                                    PS_DOTMAPPING_ZERO_TO_ONE );
    psd.PSCompareMode   = PS_COMPAREMODE( 
        PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
        PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
        PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
        PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT );

    //--------------------------
    // Stage 0 
    //--------------------------

    // A=T2.rgb, B=1, C=0, D=0 (so that AB.rgb = T2 and CD = 0 )
    psd.PSRGBInputs[0]    = PS_COMBINERINPUTS(
        PS_REGISTER_T2   | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ONE  | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY );
    
    // A=T2.b, B=1, C=0, D=0 (so that AB.a = T2.b and CD = 0 )
    psd.PSAlphaInputs[0]  = PS_COMBINERINPUTS(
        PS_REGISTER_T2   | PS_CHANNEL_BLUE  | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ONE  | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY );
    
    // R0.rgb = AB
    psd.PSRGBOutputs[0]   = PS_COMBINEROUTPUTS(
        PS_REGISTER_R0,
        PS_REGISTER_DISCARD,
        PS_REGISTER_DISCARD,
        PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM );
    
    // R0.a = AB
    psd.PSAlphaOutputs[0] = PS_COMBINEROUTPUTS(
        PS_REGISTER_R0,
        PS_REGISTER_DISCARD,
        PS_REGISTER_DISCARD,
        PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM );
    
    psd.PSConstant0[0]    = 0x00000000;
    psd.PSConstant1[0]    = 0x00000000;

    //--------------------------
    // Stage 1
    //--------------------------

    // A=T0.rgb, B=1, C=T1.rgb, D=1 (so that AB.rgb = T0 and CD = T1 )
    psd.PSRGBInputs[1]    = PS_COMBINERINPUTS(
        PS_REGISTER_T0   | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ONE  | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_T1   | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ONE  | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY );

    // A=T0.a, B=1, C=T1.a, D=1 (so that AB.a = T0 and CD = T1 )
    psd.PSAlphaInputs[1]  = PS_COMBINERINPUTS(
        PS_REGISTER_T0   | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ONE  | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_T1   | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ONE  | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY );
    
    // R0.rgb = AB mux CD
    psd.PSRGBOutputs[1]   = PS_COMBINEROUTPUTS(
        PS_REGISTER_DISCARD,
        PS_REGISTER_DISCARD,
        PS_REGISTER_R0,
        PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_MUX );

    // R0.a = AB mux CD
    psd.PSAlphaOutputs[1] = PS_COMBINEROUTPUTS(
        PS_REGISTER_DISCARD,
        PS_REGISTER_DISCARD,
        PS_REGISTER_R0,
        PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_MUX );
    psd.PSConstant0[1]    = 0x00000000;
    psd.PSConstant1[1]    = 0x00000000;

    //--------------------------
    // Stage 2
    //--------------------------

    // A=R0.rgb, B=V0.rgb, C=0, D=0 (so that AB.rgb = R0*V0 and CD = 0 )
    psd.PSRGBInputs[2]    = PS_COMBINERINPUTS(
        PS_REGISTER_R0   | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_V0   | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY );

    // A=R0.a, B=V0.a, C=0, D=0 (so that AB.a = R0*V0 and CD = 0 )
    psd.PSAlphaInputs[2]  = PS_COMBINERINPUTS(
        PS_REGISTER_R0   | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_V0   | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY );

    // R0 = AB
    psd.PSRGBOutputs[2]   = PS_COMBINEROUTPUTS(
        PS_REGISTER_R0,
        PS_REGISTER_DISCARD,
        PS_REGISTER_DISCARD,
        PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM );

    // R0 = AB
    psd.PSAlphaOutputs[2] = PS_COMBINEROUTPUTS(
        PS_REGISTER_R0,
        PS_REGISTER_DISCARD,
        PS_REGISTER_DISCARD,
        PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM );
    psd.PSConstant0[2]    = 0x00000000;
    psd.PSConstant1[2]    = 0x00000000;

    //--------------------------
    // Final combiner
    //--------------------------
    psd.PSFinalCombinerInputsABCD=PS_COMBINERINPUTS(
        PS_REGISTER_ONE  | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_R0   | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY );

    // E = 0, F = 0, G = 1. (From above, EF is not used. G is alpha and is set to 1.)
    psd.PSFinalCombinerInputsEFG=PS_COMBINERINPUTS(
        PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ONE  | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_INVERT,
        0 | 0 | 0 );
    psd.PSC0Mapping = 0x00000000;
    psd.PSC1Mapping = 0x00000000;

    // Create the hard-coded pixel shader. This shader, defined in detail above,
    // uses texture 2 as a mask to select between texture 0 and texture 1, and 
    // then modulates in the diffuse component.
    if( FAILED( m_pd3dDevice->CreatePixelShader( &psd, &m_dwPixelShader1 ) ) )
    {
        OUTPUT_DEBUG_STRING( "Could not create hardcoded pixel shader.\n" );
        return E_FAIL;
    }

    // Create a file-based pixel shader. This shader uses the difffuse value to
    // linearly interpolate between the first two textures, as in:
    //      ps.1.0
    //      tex t0
    //      tex t1
    //      mov r1, t1
    //      lrp r0, v0, t0, r1
    if( FAILED( XBUtil_CreatePixelShader( m_pd3dDevice, "D:\\Media\\Shaders\\PShader.xpu",
                                          &m_dwPixelShader2 ) ) )
    {
        OUTPUT_DEBUG_STRING( "Could not create file-based pixel shader.\n" );
        return E_FAIL;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK )
        m_bDrawHelp = !m_bDrawHelp;

    // Perform object rotation
    D3DXMATRIX matRotate;
    FLOAT fXRotate1 = m_DefaultGamepad.fX1*m_fElapsedTime*D3DX_PI*0.5f;
    FLOAT fYRotate1 = m_DefaultGamepad.fY1*m_fElapsedTime*D3DX_PI*0.5f;
    D3DXMatrixRotationYawPitchRoll( &matRotate, -fXRotate1, -fYRotate1, 0.0f );
    D3DXMatrixMultiply( &m_matObject, &m_matObject, &matRotate );

    // Move around the texture
    FLOAT tx = m_fAppTime/2 - floorf(m_fAppTime/2);
    FLOAT ty = 0.0f;
    m_matTexture._11 = 1.0f;   m_matTexture._12 = 0.0f; 
    m_matTexture._21 = 0.0f;   m_matTexture._22 = 1.0f; 
    m_matTexture._31 = tx;     m_matTexture._32 = ty; 
    m_matTexture._41 = 0.0f;   m_matTexture._42 = 0.0f; 

    // Zoom
    if( m_DefaultGamepad.wButtons & XINPUT_GAMEPAD_DPAD_UP )
        m_fEyeScale = m_fEyeScale/1.01f;
    if( m_DefaultGamepad.wButtons & XINPUT_GAMEPAD_DPAD_DOWN )
        m_fEyeScale *= 1.01f;

    // Toggle pixel shaders
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_X] )
        m_bHardcodedShader = !m_bHardcodedShader;

    // Toggle models
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_A] )
        m_bCylinder = !m_bCylinder;

    // Toggle wireframe
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_B] )
        m_bWireframe = !m_bWireframe;

    // Set transforms
    D3DXMATRIX matView, matProj;
    D3DXMatrixLookAtLH( &matView, &D3DXVECTOR3( 0.0f*m_fEyeScale, 3.0f*m_fEyeScale,-5.0f*m_fEyeScale ),
                                  &D3DXVECTOR3( 0.0f, 0.0f, 0.0f ),
                                  &D3DXVECTOR3( 0.0f, 1.0f, 0.0f ) );
    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/4, 1.0f, 1.0f, 100.0f );
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &m_matObject );
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );

    // Setup a material
    D3DMATERIAL8 mtrl;
    XBUtil_InitMaterial( mtrl, 1.0f, 1.0f, 1.0f );
    m_pd3dDevice->SetMaterial( &mtrl );

    // Adjust the point light's position
    static FLOAT phi1 = 0.5f;
    phi1 += 3.0f * m_fElapsedTime * m_DefaultGamepad.fX2;
    if( phi1 < -2.3f ) phi1 = -2.3f;
    if( phi1 > -0.9f ) phi1 = -0.9f;

    static FLOAT theta1 = 0.0f;
    theta1 -= 3.0f * m_fElapsedTime * m_DefaultGamepad.fY2;
    if( theta1 < +0.9f ) theta1 = +0.9f;
    if( theta1 > +2.3f ) theta1 = +2.3f;

    D3DXVECTOR3 vPtLightPos;
    vPtLightPos.x = 2*cosf( phi1 );
    vPtLightPos.y = 2*cosf( theta1 );
    vPtLightPos.z = 2*sinf( phi1 ) * sinf( theta1 );

    // Setup the point light
    D3DLIGHT8 light;
    ZeroMemory( &light, sizeof(D3DLIGHT8) );
    light.Type         = D3DLIGHT_POINT;
    light.Diffuse.r    = 1.0f;
    light.Diffuse.g    = 1.0f;
    light.Diffuse.b    = 1.0f;
    light.Diffuse.a    = 1.0f;
    light.Position     = vPtLightPos;
    light.Range        = 1000.0f;
    light.Attenuation0 = 1.0f;
    g_pd3dDevice->SetLight( 0, &light );
    g_pd3dDevice->LightEnable( 0, TRUE );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Draw a gradient filled background
    RenderGradientBackground( 0xff0000ff, 0xff000000 );

    // Set default state
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 2, D3DTSS_COLOROP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 2, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_DISABLE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 2, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 2, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU,    D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV,    D3DTADDRESS_WRAP );
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING,        TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,         TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE, FALSE );
    m_pd3dDevice->SetPixelShader( NULL );
    
    if( m_bWireframe )
        m_pd3dDevice->SetRenderState( D3DRS_FILLMODE, D3DFILL_WIREFRAME );

    // Set textures. Texture 2 is transformed with a texture matrix
    m_pd3dDevice->SetTexture( 0, m_pTexture0 );
    m_pd3dDevice->SetTexture( 1, m_pTexture1 );
    m_pd3dDevice->SetTexture( 2, m_pTexture2 );
    m_pd3dDevice->SetTextureStageState( 2, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_COUNT2 );
    m_pd3dDevice->SetTransform( D3DTS_TEXTURE2, &m_matTexture );

    // Specify pixel shader
    if( m_bHardcodedShader )
        g_pd3dDevice->SetPixelShader( m_dwPixelShader1 );
    else
        m_pd3dDevice->SetPixelShader( m_dwPixelShader2 );

    // Render some geometry
    if( m_bCylinder )
    {
        // Render the cylinder
        m_pd3dDevice->SetStreamSource( 0, m_pCylinderVB, sizeof(CUSTOMVERTEX) );
        m_pd3dDevice->SetVertexShader( D3DFVF_CUSTOMVERTEX );
        m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2*50-2 );
    }
    else
    {
        // Render the quad
        m_pd3dDevice->SetStreamSource( 0, m_pQuadVB, sizeof(CUSTOMVERTEX) );
        m_pd3dDevice->SetVertexShader( D3DFVF_CUSTOMVERTEX );
        m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );
    }

    // Restore states
    m_pd3dDevice->SetPixelShader( NULL );
    m_pd3dDevice->SetRenderState( D3DRS_FILLMODE, D3DFILL_SOLID );

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        m_Font.Begin();
        m_Font.DrawText(  64, 50, 0xffffffff, L"PixelShader" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );

        if( m_bHardcodedShader )
        {
            m_Font.DrawText( 64,  75, 0xffffff00, L"Using hard-coded shader:" );
            m_Font.DrawText( 64, 100, 0xffffff00, L"Output is:" );
            m_Font.DrawText( 64, 125, 0xffffff00, L"   v0 * (t2.a > 0.5 ? t0 : t1 )" );
            m_Font.DrawText( 64, 150, 0xffffff00, L"Where:" );
            m_Font.DrawText( 64, 175, 0xffffff00, L"   v0 = diffuse color" );
            m_Font.DrawText( 64, 200, 0xffffff00, L"   t0 = robot texture" );
            m_Font.DrawText( 64, 225, 0xffffff00, L"   t1 = girl texture" );
            m_Font.DrawText( 64, 250, 0xffffff00, L"   t2 = checkerboard texture" );
        }
        else
        {
            m_Font.DrawText( 64,  75, 0xffffff00, L"Using file-based shader:" );
            m_Font.DrawText( 64, 100, 0xffffff00, L"Output is:" );
            m_Font.DrawText( 64, 125, 0xffffff00, L"   v0 * t0 + ( 1 - v0 ) * t1" );
            m_Font.DrawText( 64, 150, 0xffffff00, L"Where:" );
            m_Font.DrawText( 64, 175, 0xffffff00, L"   v0 = diffuse color" );
            m_Font.DrawText( 64, 200, 0xffffff00, L"   t0 = robot texture" );
            m_Font.DrawText( 64, 225, 0xffffff00, L"   t1 = girl texture" );
        }

        m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\PlayField\Ball.h ===
#pragma once
//-----------------------------------------------------------------------------
//  File: Ball.h
//  Copyright (C) 2001 Microsoft Corporation
//  All rights reserved.
//-----------------------------------------------------------------------------
#include <XBMesh.h>

extern D3DXVECTOR3 g_vGravity;

class CBall {
public:
	CXBMesh			m_mesh;
	D3DXVECTOR3		m_vPosition;
	D3DXVECTOR3		m_vVelocity;
	D3DXMATRIX		m_matRoll;
	D3DXMATRIX		m_matWorld;
	float m_fGrassRestFraction;	// distance within grass that force of grass resistance equals gravity
	float m_fBallRadius;
	float m_fBallMass;
	bool m_bShadowed;
	D3DCOLOR	m_rcolorSave[4];
	D3DXVECTOR3	m_vPositionShadowed;
public:
	HRESULT Initialize();
	HRESULT Render();
	HRESULT LaunchBall(const D3DXVECTOR3 &vFrom, const D3DXVECTOR3 &vTargetPosition);
	HRESULT MoveBall(float dt);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\PlayField\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\PlayField\Ball.cpp ===
//-----------------------------------------------------------------------------
//  File: Ball.cpp
//  Copyright (C) 2001 Microsoft Corporation
//  All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <xgraphics.h>
#include <XbApp.h>
#include "Ball.h"

D3DXVECTOR3	g_vGravity = D3DXVECTOR3(0.f, -9.8f, 0.f);
extern HRESULT GetTerrainColors(const D3DXVECTOR3 &vPosition, D3DCOLOR *rColor);
extern HRESULT SetTerrainColors(const D3DXVECTOR3 &vPosition, D3DCOLOR *rColor);
extern HRESULT GetTerrainPoint(const D3DXVECTOR3 &vPosition, float *pfGrassThickness, float *pfHeight);
extern HRESULT MarkTerrain(const D3DXVECTOR3 &vPosition, 
						   const D3DXCOLOR &colorScale, 
						   const D3DXCOLOR &colorOffset, 
						   const D3DXCOLOR &colorMin, 
						   D3DCOLOR *rColorPrevious);	// 2x2 array of previous colors

HRESULT CBall::Initialize()
{
	// Set simulation parameters
	m_fGrassRestFraction = 1.f/2.f;
	m_fBallRadius = 0.05f/2.f; // meters, current art. Actual golf ball should be 0.042672/2 radius (1.68 inches in diameter)
	m_fBallMass = 0.0460227f; // 1.62 ounces * 1 pound / 16 ounces * 1 kg / 2.2 pound
	D3DXMatrixIdentity(&m_matRoll);
	m_bShadowed = false;
	
	// Load the ball mesh
	if( FAILED( m_mesh.Create( g_pd3dDevice, "Models\\GBall.xbg" ) ) )
		return XBAPPERR_MEDIANOTFOUND;
	
	D3DXVECTOR3 vFrom(100.f, 10.f, 0.f);
	D3DXVECTOR3 vTarget(0.f, 0.f, 0.f);
	return LaunchBall(vFrom, vTarget);
}

//-----------------------------------------------------------------------------
// Name: Render
// Desc: Draw the ball
//-----------------------------------------------------------------------------
HRESULT CBall::Render()
{
    g_pd3dDevice->SetPixelShader( 0 );
    g_pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE ); 
    g_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE, TRUE ); 
    g_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
	g_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE);
	g_pd3dDevice->SetTexture( 0, NULL );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_DISABLE );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP, D3DTOP_DISABLE );
	g_pd3dDevice->SetTexture( 1, NULL );
    g_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP, D3DTOP_DISABLE );
    g_pd3dDevice->SetTextureStageState( 1, D3DTSS_ALPHAOP, D3DTOP_DISABLE );
	g_pd3dDevice->SetTexture( 2, NULL );
    g_pd3dDevice->SetTextureStageState( 2, D3DTSS_COLOROP, D3DTOP_DISABLE );
    g_pd3dDevice->SetTextureStageState( 2, D3DTSS_ALPHAOP, D3DTOP_DISABLE );
	g_pd3dDevice->SetTexture( 3, NULL );
    g_pd3dDevice->SetTextureStageState( 3, D3DTSS_COLOROP, D3DTOP_DISABLE );
    g_pd3dDevice->SetTextureStageState( 3, D3DTSS_ALPHAOP, D3DTOP_DISABLE );
	g_pd3dDevice->SetTransform( D3DTS_WORLD, &m_matWorld );
	m_mesh.Render( g_pd3dDevice, XBMESH_NOTEXTURES );
	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: LaunchBall
// Desc: Fire new ball in a random direction
//-----------------------------------------------------------------------------
HRESULT CBall::LaunchBall(const D3DXVECTOR3 &vFrom, const D3DXVECTOR3 &vTargetPosition)
{
	// Pick a random velocity and position
#define fUnitRand(fmin, fmax) ((float)rand()/32768.0f*((fmax) - (fmin)) + (fmin))
	float fTheta = 0.7f * D3DX_PI * fUnitRand(-0.5f, 0.5f);
	float fRadius = 1.f;
	float fX = cosf(fTheta);
	float fZ = sinf(fTheta);
	m_vVelocity = D3DXVECTOR3(-fX*fUnitRand(2.f, 10.f), fUnitRand(0.5f, 2.5f), fZ*fUnitRand(2.f, 10.f));
	m_vPosition = vFrom + fRadius * D3DXVECTOR3(fX * fUnitRand(-0.5f, 0.5f), fUnitRand(0.f, 1.f), fZ * fUnitRand(-0.5f, 0.5f));
	
	// Solve for time when ball is going to hit z=0 plane
	float a = 0.5f * g_vGravity.y;
	float b = m_vVelocity.y;
	float c = m_vPosition.y;
	// Solve quadratic a t^2 + b t + c = 0
	float q = b*b - 4.0f * a * c;
	if (q < 0.0)
		return 0; // no real solution
	if (b < 0.0) // q = -(1/2)*(b + sgn(b)*sqrt(b^2 - 4ac))
		q = -0.5f * (b - sqrtf(q));
	else
		q = -0.5f * (b + sqrtf(q));
	// Roots are q/a and c/q.
	float t = q / a;
	float t1 = c / q;
	if (t < 0.f || (t1 > 0.f && t1 < t)) // use smaller positive root
		t = t1;

	// Get position of collision
	D3DXVECTOR3 vEstimatedHit = vFrom + t * m_vVelocity + 0.5f * t * t * g_vGravity;
	static float fRollTime = 0.0f;
	vEstimatedHit.x += fRollTime * m_vVelocity.x;
	vEstimatedHit.z += fRollTime * m_vVelocity.z;

	// Translate starting point to match target
	m_vPosition.x += vTargetPosition.x - vEstimatedHit.x;
	m_vPosition.z += vTargetPosition.z - vEstimatedHit.z;
	
	return MoveBall(0.f);
}

//-----------------------------------------------------------------------------
// Name: MoveBall
// Desc: Called once per frame (if not paused) to update ball position.
//
// The physics implemented here is extremely simple-minded. It's just
// to show how the ball interacts with the grass.
//-----------------------------------------------------------------------------
HRESULT CBall::MoveBall(float dt)
{
	// Restore current shadowed point
	if (m_bShadowed)
	{
		SetTerrainColors(m_vPositionShadowed, m_rcolorSave);
		m_bShadowed = false;
	}

	// Get current terrain values
	D3DXVECTOR3 vPosition0 = m_vPosition; // save current ball position for update call
	float fGrassThickness0;
	float fHeight0;
	GetTerrainPoint(m_vPosition, &fGrassThickness0, &fHeight0);
	
	// Apply grass force if the ball is penetrating the grass
	float fDepth = fHeight0 + fGrassThickness0 - (m_vPosition.y - m_fBallRadius);	// depth of penetration of bottom of ball
	D3DXVECTOR3 vAcceleration = g_vGravity;
	if (fDepth > 0.f && fGrassThickness0 > 0.f)
	{
		// TODO: use correct normal and better friction model that separates
		// normal and tangential components. Add rolling to the model, too.
		
		float fGrassSpring = 9.8f / (fGrassThickness0 * (1.f - m_fGrassRestFraction)); // cancel gravity when ball is at grass resting point
		if (fDepth > fGrassThickness0) fDepth = fGrassThickness0; // Terrain collision is modeled below as impulse.
		vAcceleration.y += fGrassSpring * fDepth;

		// Dampen velocity
		static D3DXVECTOR3 vGrassDamping(0.9f, 0.85f, 0.9f);
		m_vVelocity.x *= vGrassDamping.x;
		m_vVelocity.y *= vGrassDamping.y;
		m_vVelocity.z *= vGrassDamping.z;

		// Mark grass
		static D3DXCOLOR colorScale(0.9f, 0.98f, 0.9f, 0.9f);
		static D3DXCOLOR colorOffset(0.f, 0.f, 0.f, -0.03f);
		static D3DXCOLOR colorMin(0.3f, 0.4f, 0.1f, 0.3f);
		MarkTerrain(m_vPosition, colorScale, colorOffset, colorMin, NULL);
	}
	
	// Update the position of the ball
	static float dtMax = 1.f / 10.f;
	if (dt > dtMax) dt = dtMax;
	m_vPosition += dt * m_vVelocity + 0.5f * dt * dt * vAcceleration;
	m_vVelocity += dt * vAcceleration;

	// Check for collisions with terrain
	float fGrassThickness;
	float fHeight;
	GetTerrainPoint(m_vPosition, &fGrassThickness, &fHeight);
	float fBallCenterHeight = fHeight + m_fBallRadius;
	if (m_vPosition.y < fBallCenterHeight && m_vVelocity.y < 0.f)
	{
		m_vPosition.y = fBallCenterHeight + fGrassThickness * m_fGrassRestFraction; // slide ball out of intersection
		m_vVelocity.y = -m_vVelocity.y; // reverse velocity

		// Dampen velocity
		static D3DXVECTOR3 vTerrainDamping(0.9f, 0.8f, 0.9f);
		m_vVelocity.x *= vTerrainDamping.x;
		m_vVelocity.y *= vTerrainDamping.y;
		m_vVelocity.z *= vTerrainDamping.z;

		// Mark the grass where we hit
		static float fYMin = 6.f;
		static float fYMax = 12.f;
		if (m_vVelocity.y >= fYMin)
		{
			float fLerp = (m_vVelocity.y - fYMin) / (fYMax - fYMin);
			if (fLerp < 0.f) fLerp = 0.f;
			else if (fLerp > 1.f) fLerp = 1.f;
			static float fScaleMin = 0.9f;
			static float fScaleMax = 0.1f;
			float fScale = fScaleMin + fLerp * (fScaleMax - fScaleMin);
			D3DXCOLOR colorScale(fScale, fScale, fScale, fScale);
			static D3DXCOLOR colorOffset(0.4f * 0.1f, 0.3f * 0.1f, 0.1f * 0.1f, 0.1f);
			static D3DXCOLOR colorMin(0.4f, 0.3f, 0.1f, 0.0f);
			MarkTerrain(m_vPosition, colorScale, colorOffset, colorMin, NULL);
		}
	}

	// Darken the shadow point
	// To make this more realistic, we should project from the sun's position.  This gives the
	// basic idea, though.
	static float fMinHeight = 0.f;
	static float fMaxHeight = 3.f;
	float fBallHeight = m_vPosition.y - fHeight;
	if (fBallHeight < fMaxHeight)
	{
		float fLerp = (fBallHeight - fMinHeight) / (fMaxHeight - fMinHeight);
		if (fLerp < 0.f) fLerp = 0.f;
		static D3DXCOLOR shadowScaleDarkest(0.3f, 0.3f, 0.3f, 1.f);
		static D3DXCOLOR shadowScaleLightest(1.f, 1.f, 1.f, 1.f);
		static D3DXCOLOR shadowOffset(0.f, 0.f, 0.f, 0.f);
		static D3DXCOLOR shadowMin(0.f, 0.f, 0.f, 0.f);
		D3DXCOLOR shadowScale = shadowScaleDarkest + fLerp * (shadowScaleLightest - shadowScaleDarkest);
		if (MarkTerrain(m_vPosition, shadowScale, shadowOffset, shadowMin, m_rcolorSave) == S_OK)
		{
			m_bShadowed = true;
			m_vPositionShadowed = m_vPosition;
		}
	}

	// Update matrices
	D3DXMATRIX matScale;
	static float fBallScale = 2.f;	// extra scaling to make the ball look right
	D3DXMatrixScaling(&matScale, fBallScale, fBallScale, fBallScale);
	D3DXMATRIX matTranslate;
	D3DXMatrixTranslation(&matTranslate, m_vPosition.x, m_vPosition.y, m_vPosition.z);
	D3DXVECTOR3 vFlatVelocity(m_vVelocity.x, 0.f, m_vVelocity.z);
	float fRollSpeed = D3DXVec3Length(&vFlatVelocity);
	static float fRollSpeedThreshold = 1e-3f;
	if (fRollSpeed > fRollSpeedThreshold)
	{
		// Make the ball roll in the direction of travel.  A better physics model would produce the rolling directly.
		static float fRollFactor = -10.f;
		float fRollAngle = fRollFactor * D3DXVec3Dot(&vFlatVelocity, &m_vPosition) / fRollSpeed;
		D3DXVECTOR3 vUp(0.f, 1.f, 0.f);
		D3DXVECTOR3 vRollAxis;
		D3DXVec3Cross(&vRollAxis, &vFlatVelocity, &vUp);
		D3DXVec3Normalize(&vRollAxis, &vRollAxis);
		D3DXMatrixRotationAxis(&m_matRoll, &vRollAxis, fRollAngle);
	}
	m_matWorld = matScale * m_matRoll * matTranslate;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\pointsprites\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\pointsprites\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\PlayField\Resource.h ===
// Automatically generated by the bundler tool from Resource.rdf

#define Resource_NUM_RESOURCES 4UL

#define Resource_Fairway_OFFSET 0UL
#define Resource_Football_OFFSET 20UL
#define Resource_GrassStrip_OFFSET 40UL
#define Resource_Grass_OFFSET 60UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\pointsprites\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\PlayField\PlayField.cpp ===
//-----------------------------------------------------------------------------
// File: PlayField.cpp
//
// Desc: Grassy sports field.
//
// Copyright (c) 2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <xgraphics.h>
#include "Ball.h"

//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
	{ XBHELP_LEFTSTICK,	   XBHELP_PLACEMENT_1, L"Move" },
	{ XBHELP_RIGHTSTICK,   XBHELP_PLACEMENT_1, L"Tilt" },
	{ XBHELP_A_BUTTON,	   XBHELP_PLACEMENT_1, L"Launch ball" },
	{ XBHELP_X_BUTTON,	   XBHELP_PLACEMENT_2, L"Next\nfield texture" },
	{ XBHELP_BLACK_BUTTON, XBHELP_PLACEMENT_2, L"Reload\nvertex buffers" },
	{ XBHELP_WHITE_BUTTON, XBHELP_PLACEMENT_1, L"Wire-frame" },
	{ XBHELP_MISC_CALLOUT, XBHELP_PLACEMENT_1, L"Use triggers for height" },
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_1, L"Display help" },
    { XBHELP_START_BUTTON, XBHELP_PLACEMENT_1, L"Pause" },
};

#define NUM_HELP_CALLOUTS (sizeof(g_HelpCallouts) / sizeof(XBHELP_CALLOUT))

//-----------------------------------------------------------------------------
// The grass on the sports field is drawn as a series of strips, drawn from
// back-to-front and tilted with respect to the viewer.  The tilt allows a
// wider range of viewing angles.
//-----------------------------------------------------------------------------
#define FEET 0.3048f	/* meters / foot */

#define GRASS_FIELD_LENGTH	(400.f * FEET)
#define GRASS_FIELD_WIDTH	(200.f * FEET)
#define GRASS_HEIGHT		(0.5f * FEET)

D3DXVECTOR3 g_vMin(-GRASS_FIELD_LENGTH / 2.f, 0.f, -GRASS_FIELD_WIDTH / 2.f);
D3DXVECTOR3 g_vSize(GRASS_FIELD_LENGTH, GRASS_HEIGHT, GRASS_FIELD_WIDTH);

struct FieldVertex {
	D3DXVECTOR3	position;
	D3DXVECTOR2	tex0;	// field texture coords
	D3DXVECTOR2	tex1;	// grass top-view texture coords
};

struct GrassVertex {
	D3DXVECTOR3	position;
	D3DXVECTOR2	tex0;	// field texture coords
	D3DXVECTOR2	tex1;	// grass strip side-view texture coords
};

//-----------------------------------------------------------------------------
// There are three textures used to draw the grass.
//
// 1) The whole field texture gives large-scale variation to the grass,
// 	  such as chaulk lines or dirt patches. The alpha channel of the
// 	  whole-field texture modulates where the grass slices are
// 	  drawn. Look closely at the edge of the green while using the
// 	  "Fairway" texture to see the transition.
//
// 2) The GrassStrip texture is applied to the grass strips to give the side
//    view of the grass.
//
// 3) The top-view Grass texture gives high-frequency detail to regions
//    where the slice-texture grass is bare.
//
//-----------------------------------------------------------------------------

#include "Resource.h"
XBRESOURCE g_ResourceNames[Resource_NUM_RESOURCES] =
{
	{ "Fairway", Resource_Fairway_OFFSET },		// whole-field golf-style texture
	{ "Football", Resource_Football_OFFSET },		// whole-field football texture
    { "GrassStrip",  Resource_GrassStrip_OFFSET },	// grass side-view texture
	{ "Grass", Resource_Grass_OFFSET }, // grass top-view texture
};

// The first range of textures can be switched to give different types of fields.
UINT g_nFieldTexture = 2;

//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
public:
    CXBoxSample();

    virtual HRESULT Initialize();
    virtual HRESULT Render();
    virtual HRESULT FrameMove();

    // Font and help
    CXBFont     m_Font;
    CXBHelp     m_Help;
    bool        m_bDrawHelp;
	bool		m_bWireFrame;

	// Textures
    CXBPackedResource m_xprResources;
	UINT m_iCurrentFieldTexture;	// index into g_FieldNames to set m_pFieldTexture
    LPDIRECT3DTEXTURE8 m_pFieldTexture;
    LPDIRECT3DTEXTURE8 m_pFieldGrassTexture;
	LPDIRECT3DTEXTURE8 m_pGrassStripTexture;
	HRESULT SetCurrentFieldTexture(UINT i);
	
	// Field geometry
	LPDIRECT3DVERTEXBUFFER8 m_pFieldVertexBuffer;
	HRESULT	FillFieldVertexBuffer();
	
	// Grass geometry
	UINT m_nGrassStripCount;
	UINT m_nGrassQuadCountPerStrip;
	LPDIRECT3DVERTEXBUFFER8 m_pGrassVertexBuffer;
	HRESULT	FillGrassVertexBuffer();

	// Camera position and direction
	D3DXVECTOR3 m_vFrom;
	float m_fAzim, m_fTilt;
	D3DXMATRIX m_matWorld;

	// A ball to bounce and interact with the grass
#define BALLCOUNT 2
	CBall *m_rpBall[BALLCOUNT];
	float m_fCountDown;
};


//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}

//-----------------------------------------------------------------------------
// Name: GetTerrainColors
// Desc: Get the 4 texture colors in the neighborhood of vPosition
//-----------------------------------------------------------------------------
static LPDIRECT3DTEXTURE8 s_pFieldTexture = NULL;
static Swizzler s_swizzler;

HRESULT GetTerrainColors(const D3DXVECTOR3 &vPosition, D3DCOLOR *rColor, float *pfXFraction, float *pfZFraction)
{
	LPDIRECT3DTEXTURE8 pTexture = s_pFieldTexture;
	if (pTexture)
	{
		D3DSURFACE_DESC desc;
		pTexture->GetLevelDesc(0, &desc);
		float fx = (vPosition.x - g_vMin.x) / g_vSize.x * (float)desc.Width - 0.5f;
		float fz = (vPosition.z - g_vMin.z) / g_vSize.z * (float)desc.Height - 0.5f;
		LONG x = (LONG)fx;
		LONG z = (LONG)fz;
		if (pfXFraction)
			*pfXFraction = fx - (float)x;
		if (pfZFraction)
			*pfZFraction = fz - (float)z;
		if (x >= -1 && x < (LONG)desc.Width &&
			z >= -1 && z < (LONG)desc.Height)
		{
			D3DLOCKED_RECT lockedRect;
			if ( SUCCEEDED(pTexture->LockRect(0, &lockedRect, NULL, 0) ))
			{
				SWIZNUM s;
				if (x >= 0 
					&& z >= 0)
				{
					s = s_swizzler.Swizzle(x, z, 0);
					rColor[0] = *((DWORD *)(lockedRect.pBits) + s);	// we're using a A8R8G8B8 texture
				}
				if (x + 1 < (LONG)desc.Width
					&& z >= 0)
				{
					s = s_swizzler.Swizzle(x + 1, z, 0);
					rColor[1] = *((DWORD *)(lockedRect.pBits) + s);
				}
				if (x >= 0 
					&& z + 1 < (LONG)desc.Height)
				{
					s = s_swizzler.Swizzle(x, z + 1, 0);
					rColor[2] = *((DWORD *)(lockedRect.pBits) + s);
				}
				if (x + 1 < (LONG)desc.Width 
					&& z + 1  < (LONG)desc.Height)
				{
					s = s_swizzler.Swizzle(x + 1, z + 1, 0);
					rColor[3] = *((DWORD *)(lockedRect.pBits) + s);
				}
				pTexture->UnlockRect(0);
				return S_OK;
			}
		}
	}
	return S_FALSE;
}

HRESULT SetTerrainColors(const D3DXVECTOR3 &vPosition, D3DCOLOR *rColor)
{
	LPDIRECT3DTEXTURE8 pTexture = s_pFieldTexture;
	if (pTexture)
	{
		D3DSURFACE_DESC desc;
		pTexture->GetLevelDesc(0, &desc);
		float fx = (vPosition.x - g_vMin.x) / g_vSize.x * (float)desc.Width - 0.5f;
		float fz = (vPosition.z - g_vMin.z) / g_vSize.z * (float)desc.Height - 0.5f;
		LONG x = (LONG)fx;
		LONG z = (LONG)fz;
		if (x >= -1 && x < (LONG)desc.Width &&
			z >= -1 && z < (LONG)desc.Height)
		{
			D3DLOCKED_RECT lockedRect;
			if ( SUCCEEDED(pTexture->LockRect(0, &lockedRect, NULL, 0) ))
			{
				SWIZNUM s;
				if (x >= 0 
					&& z >= 0)
				{
					s = s_swizzler.Swizzle(x, z, 0);
					*((DWORD *)(lockedRect.pBits) + s) = rColor[0];	// we're using a A8R8G8B8 texture
				}
				if (x + 1 < (LONG)desc.Width
					&& z >= 0)
				{
					s = s_swizzler.Swizzle(x + 1, z, 0);
					*((DWORD *)(lockedRect.pBits) + s) = rColor[1];
				}
				if (x >= 0 
					&& z + 1 < (LONG)desc.Height)
				{
					s = s_swizzler.Swizzle(x, z + 1, 0);
					*((DWORD *)(lockedRect.pBits) + s) = rColor[2];
				}
				if (x + 1 < (LONG)desc.Width 
					&& z + 1  < (LONG)desc.Height)
				{
					s = s_swizzler.Swizzle(x + 1, z + 1, 0);
					*((DWORD *)(lockedRect.pBits) + s) = rColor[3];
				}
				pTexture->UnlockRect(0);
				return S_OK;
			}
		}
	}
	return S_FALSE;
}


//-----------------------------------------------------------------------------
// Name: GetTerrainPoint
// Desc: Get the value of the terrain below the given position.
//-----------------------------------------------------------------------------
HRESULT GetTerrainPoint(const D3DXVECTOR3 &vPosition, float *pfGrassThickness, float *pfHeight)
{
	*pfHeight = 0.f;	// this should look up a value in a height field for more interesting terrain
	*pfGrassThickness = 0.3f * FEET;	// default grass thickness
	D3DCOLOR rColor[4];
	if (GetTerrainColors(vPosition, rColor, NULL, NULL) == S_OK)
	{
		DWORD dwAlpha = rColor[0] >> 24;
		*pfGrassThickness *= (float)dwAlpha * (1.f/255.f);
	}
	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: MarkTerrain
// Desc: Adds color to current value
//-----------------------------------------------------------------------------
HRESULT MarkTerrain(const D3DXVECTOR3 &vPosition, 
					const D3DXCOLOR &colorScale, 
					const D3DXCOLOR &colorOffset, 
					const D3DXCOLOR &colorMin, 
					D3DCOLOR *rColorPrevious)
{
	D3DCOLOR rColorTmp[4];
	if (rColorPrevious == NULL)
		rColorPrevious = rColorTmp;
	float xfrac, zfrac;
	if (GetTerrainColors(vPosition, rColorPrevious, &xfrac, &zfrac) == S_OK)
	{
		int i;
		float frac[4] = {
			(1.f - xfrac) * (1.f - zfrac),
			xfrac * (1.f - zfrac),
			(1.f - xfrac) * zfrac,
			xfrac * zfrac 
		};
		// Compute interpolated color
		D3DXCOLOR color0 = D3DXCOLOR(rColorPrevious[0]) * frac[0];
		for (i = 1; i < 4; i++)
			color0 += frac[i] * D3DXCOLOR(rColorPrevious[i]);

		// Apply color scaling to interpolated value
		D3DXCOLOR color = color0;
		color.r *= colorScale.r;
		color.g *= colorScale.g;
		color.b *= colorScale.b;
		color.a *= colorScale.a;
		color += colorOffset;
		if (color.r < colorMin.r) color.r = colorMin.r;
		if (color.g < colorMin.g) color.g = colorMin.g;
		if (color.b < colorMin.b) color.b = colorMin.b;
		if (color.a < colorMin.a) color.a = colorMin.a;

		// Add weighted delta to the four corner points
		D3DXCOLOR colorDelta = color - color0;
		D3DCOLOR rColor[4];
		for (i = 0; i < 4; i++)
		{
			D3DXCOLOR colorNew = D3DXCOLOR(rColorPrevious[i]) + frac[i] * colorDelta;
			rColor[i] = (D3DCOLOR)colorNew;
		}
		return SetTerrainColors(vPosition, rColor);
	}
	return S_FALSE;
}

//-----------------------------------------------------------------------------
// Name: CXBoxSample (constructor)
// Desc: Constructor for CXBoxSample class
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample() 
            :CXBApplication()
{
#ifdef _DEBUG	
	m_d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;	// Allow unlimited frame rate
#endif
    m_bDrawHelp = false;
    m_bWireFrame = false;
    m_pFieldTexture = NULL;
    m_pFieldGrassTexture = NULL;
	m_pGrassStripTexture = NULL;
	m_pFieldVertexBuffer = NULL;
	m_pGrassVertexBuffer = NULL;
	for (UINT iBall = 0; iBall < BALLCOUNT; iBall++)
		m_rpBall[iBall] = NULL;
}



//-----------------------------------------------------------------------------
// Name: Initialize
// Desc: Peforms initialization
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::Initialize()
{
    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

	// Load the field and grass textures
    if( FAILED( m_xprResources.Create( m_pd3dDevice, "Resource.xpr", Resource_NUM_RESOURCES, g_ResourceNames ) ) )
        return E_FAIL;
	SetCurrentFieldTexture(0);
	m_pFieldGrassTexture = m_xprResources.GetTexture( Resource_Grass_OFFSET );
	m_pGrassStripTexture = m_xprResources.GetTexture( Resource_GrassStrip_OFFSET );
	
	// Fill the field vertex buffer
	if ( FAILED( FillFieldVertexBuffer() ) )
		return E_FAIL;

	// Fill the grass vertex buffer
	if ( FAILED( FillGrassVertexBuffer() ) )
		return E_FAIL;

	// Camera position and orientation
	m_vFrom = D3DXVECTOR3(50.f * 3.f * FEET, 6.f * FEET, 0.f);
	m_fAzim = 0.f;
	m_fTilt = 0.f;
	
	// set light parameters
	D3DLIGHT8 light;
	ZeroMemory(&light, sizeof(D3DLIGHT8));
	light.Type = D3DLIGHT_DIRECTIONAL;
	light.Position = D3DXVECTOR3(10000.f, 10000.f, 10000.f); // sun
	light.Direction = D3DXVECTOR3(0.577350269f, -0.577350269f, 0.577350269f);
	light.Ambient  = D3DXCOLOR(0.4f, 0.4f, 0.4f, 1.f);
	light.Diffuse = D3DXCOLOR(1.f, 1.f, 1.f, 1.f);
	light.Specular = D3DXCOLOR(1.f, 1.f, 1.f, 1.f);
	g_pd3dDevice->SetLight(0, &light);
	g_pd3dDevice->LightEnable(0, TRUE);

	// Load the balls
	for (UINT iBall = 0; iBall < BALLCOUNT; iBall++)
	{
		m_rpBall[iBall] = new CBall;
		if ( FAILED(m_rpBall[iBall]->Initialize()) )
			return XBAPPERR_MEDIANOTFOUND;
	}
	m_fCountDown = 0.f;
	
    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: SetCurrentFieldTexture
// Desc: Assign current field texture and setup the GetTerrainPoint functions
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::SetCurrentFieldTexture(UINT i)
{ 
	m_iCurrentFieldTexture = i;
	if (m_iCurrentFieldTexture >= g_nFieldTexture)
		m_iCurrentFieldTexture = 0;
	m_pFieldTexture = m_xprResources.GetTexture( g_ResourceNames[m_iCurrentFieldTexture].dwOffset );

	s_pFieldTexture = m_pFieldTexture;
	D3DSURFACE_DESC desc;
	s_pFieldTexture->GetLevelDesc(0, &desc);
	s_swizzler.Init(desc.Width, desc.Height, 1);

	return S_OK;
}



//-----------------------------------------------------------------------------
// Name: FillFieldVertexBuffer
// Desc: Set vertex positions for whole field
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::FillFieldVertexBuffer()
{
	HRESULT hr;
	UINT cbFieldVertexSize = sizeof(FieldVertex);
	UINT length = 2;
	UINT width = 2;
	static float fXScale = 60.f;	// repeat scaling of grass top-view texture
	static float fZScale = 30.f;
	D3DXVECTOR3 vMin(-GRASS_FIELD_LENGTH / 2.f, 0.f, -GRASS_FIELD_WIDTH / 2.f);
	D3DXVECTOR3 vSize(GRASS_FIELD_LENGTH, 1.f, GRASS_FIELD_WIDTH);
	SAFE_RELEASE(m_pFieldVertexBuffer);
	hr = g_pd3dDevice->CreateVertexBuffer(length * width * cbFieldVertexSize, 0, 0, D3DPOOL_DEFAULT, &m_pFieldVertexBuffer);
	if (FAILED(hr))
		return hr;
	FieldVertex *pVertices;
	hr = m_pFieldVertexBuffer->Lock(0, 0, (BYTE**)&pVertices, 0);
	if (FAILED(hr))
		return hr;
	for (UINT iXGrid = 0; iXGrid < length; iXGrid++)
	{
		float fX = (float)iXGrid / (float)(length - 1);
		for (UINT iZGrid = 0; iZGrid < width; iZGrid++)
		{
			float fZ = (float)iZGrid / (float)(width - 1);
			FieldVertex *pVertex;
			pVertex = &pVertices[iXGrid * width + iZGrid];
			pVertex->position.x = vMin.x + vSize.x * fX;
			pVertex->position.y = vMin.y;
			pVertex->position.z = vMin.z + vSize.z * fZ;
			pVertex->tex0.x = fX;
			pVertex->tex0.y = fZ;
			pVertex->tex1.x = fX * fXScale;
			pVertex->tex1.y = fZ * fZScale;
		}
	}
	m_pFieldVertexBuffer->Unlock();
	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: FillGrassVertexBuffer
// Desc: Set vertex positions for grass vertex buffer
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::FillGrassVertexBuffer()
{
	HRESULT hr;
	UINT cbGrassVertexSize = sizeof(GrassVertex);
	static UINT length = 800;	// number of strips
	static UINT width = 2;	// number of horizontal samples per strip, must be >= 2
	static float fGrassHeight = GRASS_HEIGHT;
	static float fTilt = -1.f * FEET;			// strips are tilted away from the current view
	static float fZScale = 50.f / 8.f;	// texture coordinate scaling
	static float fYScale = 1.f;
	static UINT seed = 0x123456;	// start with the same random seed so the per-strip offsets are the same from call to call
	srand(seed);
	UINT depth = 2;	// number of vertical samples per strip, currently must be 2 due the drawprimitive call used below
	// Set a break-point here and press the reload button to hit it.  Then, adjust the
	// above parameters to see how they affect the appearance of the grass.
	D3DXVECTOR3 vMin(-GRASS_FIELD_LENGTH / 2.f, 0.f, -GRASS_FIELD_WIDTH / 2.f);
	D3DXVECTOR3 vSize(GRASS_FIELD_LENGTH, fGrassHeight, GRASS_FIELD_WIDTH);
	SAFE_RELEASE(m_pGrassVertexBuffer);
	hr = g_pd3dDevice->CreateVertexBuffer(length * width * depth * cbGrassVertexSize, 0, 0, D3DPOOL_DEFAULT, &m_pGrassVertexBuffer);
	if (FAILED(hr))
		return hr;
	GrassVertex *pVertices;
	hr = m_pGrassVertexBuffer->Lock(0, 0, (BYTE**)&pVertices, 0);
	if (FAILED(hr))
		return hr;
	for (UINT iXGrid = 0; iXGrid < length; iXGrid++)
	{
		float fX = (float)iXGrid / (float)(length - 1);
		float fZOffset = fZScale * (float)rand() / (float)0xffff;	// pick random horizontal texture offset for each strip
		for (UINT iZGrid = 0; iZGrid < width; iZGrid++)
		{
			float fZ = (float)iZGrid / (float)(width - 1);
			for (UINT iYGrid = 0; iYGrid < depth; iYGrid++)
			{
				float fY = (float)iYGrid / (depth - 1);
				GrassVertex *pVertex;
				pVertex = &pVertices[depth * (iXGrid * width + iZGrid) + iYGrid ];
				pVertex->position.x = vMin.x + vSize.x * fX + fTilt * fY;
				pVertex->position.y = vMin.y + vSize.y * fY;
				pVertex->position.z = vMin.z + vSize.z * fZ;
				pVertex->tex0.x = (pVertex->position.x - vMin.x) / vSize.x;
				pVertex->tex0.y = (pVertex->position.z - vMin.z) / vSize.z;
				pVertex->tex1.x = fZ * fZScale + fZOffset;
				pVertex->tex1.y = fYScale * (1.f - fY);
			}
		}
	}
	m_pGrassVertexBuffer->Unlock();
	m_nGrassStripCount = length;
	m_nGrassQuadCountPerStrip = width - 1;
	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: FrameMove
// Desc: Performs per-frame updates
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::FrameMove()
{
    // Toggle help
    if ( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK )
    {
        m_bDrawHelp = !m_bDrawHelp;
    }

    // Toggle wire-frame drawing
    if ( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_WHITE]  )
    {
        m_bWireFrame = !m_bWireFrame;
    }

	// Refill vertex buffers
    if ( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_BLACK] ) 
    {
		FillFieldVertexBuffer();
        FillGrassVertexBuffer();
    }

	// Go to next field texture
	if ( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_X ] )
	{
		SetCurrentFieldTexture(m_iCurrentFieldTexture + 1);
	}

	// Update view position
	float fX1 = m_DefaultGamepad.fX1;
	fX1 *= fX1 * fX1; // fX1 cubed
	float fY1 = m_DefaultGamepad.fY1;
	fY1 *= fY1 * fY1; // fY1 cubed
	static float fScaleFromX = 60.f * FEET;
	static float fScaleFromY = 20.f * FEET;
	static float fScaleFromZ = 60.f * FEET;
	float fDelta = (1.f/255.f) * 
		(m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] 
		 - m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER]);
	m_vFrom.x -= fScaleFromX * fY1 * m_fElapsedTime;
	m_vFrom.y += fScaleFromY * fDelta * m_fElapsedTime;
	m_vFrom.z += fScaleFromZ * fX1 * m_fElapsedTime;
	static D3DXVECTOR3 vFromMin = D3DXVECTOR3(-150.f, 2.f, -100.f) * FEET;
	static D3DXVECTOR3 vFromMax = D3DXVECTOR3( 220.f, 125.f, 100.f) * FEET;
	if (m_vFrom.x < vFromMin.x) m_vFrom.x = vFromMin.x;
	if (m_vFrom.x > vFromMax.x) m_vFrom.x = vFromMax.x;
	if (m_vFrom.y < vFromMin.y) m_vFrom.y = vFromMin.y;
	if (m_vFrom.y > vFromMax.y) m_vFrom.y = vFromMax.y;
	if (m_vFrom.z < vFromMin.z) m_vFrom.z = vFromMin.z;
	if (m_vFrom.z > vFromMax.z) m_vFrom.z = vFromMax.z;

	// Update view orientation
	float fX2 = m_DefaultGamepad.fX2;
	fX2 *= fX2 * fX2; // fX2 cubed
	float fY2 = m_DefaultGamepad.fY2;
	fY2 *= fY2 * fY2; // fY2 cubed
	static float fAzimScale = 10.f;
	static float fAzimMin = -0.6f;
	static float fAzimMax = 0.6f;
	m_fAzim += fAzimScale * fX2 * m_fElapsedTime;
	if (m_fAzim < fAzimMin) m_fAzim = fAzimMin;
	if (m_fAzim > fAzimMax) m_fAzim = fAzimMax;
	static float fTiltScale = 3.f;
	static float fTiltMin = -0.3f;
	static float fTiltMax = 0.6f;
	m_fTilt += fTiltScale * fY2 * m_fElapsedTime;
	if (m_fTilt < fTiltMin) m_fTilt = fTiltMin;
	if (m_fTilt > fTiltMax) m_fTilt = fTiltMax;
	D3DXVECTOR3 vAt = m_vFrom + D3DXVECTOR3(-cosf(m_fAzim) * cosf(m_fTilt), -sinf(m_fTilt), sinf(m_fAzim) * cosf(m_fTilt));
	D3DXVECTOR3 vUp(0.f, 1.f, 0.f);

	// Launch a ball
	m_fCountDown -= m_fElapsedAppTime;
	if ( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_A ]
		|| m_fCountDown < 0.f)
	{
		// Re-use the slowest ball
		UINT iBall = 0;
		float fSpeedMin = D3DXVec3Length(&m_rpBall[iBall]->m_vVelocity);
		for (UINT jBall = 1; jBall < BALLCOUNT; jBall++)
		{
			float fSpeed = D3DXVec3Length(&m_rpBall[jBall]->m_vVelocity);
			if (fSpeed < fSpeedMin)
			{
				fSpeedMin = fSpeed;
				iBall = jBall;
			}
		}
		
		// Make target be intersection of view direction with plane
		D3DXVECTOR3 vRay = vAt - m_vFrom;
		float t;
		if (vRay.y >= 0)
			t = m_vFrom.x * 0.5f;
		else 
			t = -m_vFrom.y / vRay.y;
		D3DXVECTOR3 vTarget = m_vFrom + vRay * t;
		static D3DXVECTOR3 vTargetMin(-GRASS_FIELD_LENGTH / 2.f, 0.f, -GRASS_FIELD_WIDTH / 2.f);
		static D3DXVECTOR3 vTargetMax( GRASS_FIELD_LENGTH / 2.f, 0.f,  GRASS_FIELD_WIDTH / 2.f);
		if (vTarget.x < vTargetMin.x) vTarget.x = vTargetMin.x;
		if (vTarget.x > vTargetMax.x) vTarget.x = vTargetMax.x;
		if (vTarget.y < vTargetMin.y) vTarget.y = vTargetMin.y;
		if (vTarget.y > vTargetMax.y) vTarget.y = vTargetMax.y;
		if (vTarget.z < vTargetMin.z) vTarget.z = vTargetMin.z;
		if (vTarget.z > vTargetMax.z) vTarget.z = vTargetMax.z;
		m_rpBall[iBall]->LaunchBall(m_vFrom, vTarget);

		if (m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_A ])
			m_fCountDown = 30.f; // if user launched the ball, wait a long time before autolaunching
		else
			m_fCountDown = 5.f;	// countdown between launches
	}

	// Move the balls
	for (UINT iBall = 0; iBall < BALLCOUNT; iBall++)
		m_rpBall[iBall]->MoveBall(m_fElapsedAppTime);

	// Set matrices
	D3DXMATRIX matProjection;
	D3DXMatrixPerspectiveFovLH( &matProjection, D3DX_PI/4, 640.f/480.f, 0.4f, 4000.0f );
	g_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProjection);

	D3DXMATRIX matView;
	D3DXMatrixLookAtLH( &matView, &m_vFrom, &vAt, &vUp);
	g_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );
	
	D3DXMatrixIdentity(&m_matWorld);
    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: Render
// Desc: Renders the scene
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::Render()
{
    // Clear the zbuffer
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL, 0x00000000, 1.0f, 0L );

    // Draw a gradient filled background
    RenderGradientBackground( 0xff404040, 0xff404080 );

	// Draw in wire-frame, if desired
	if (m_bWireFrame)
		g_pd3dDevice->SetRenderState(D3DRS_FILLMODE, D3DFILL_WIREFRAME);
	else
		g_pd3dDevice->SetRenderState(D3DRS_FILLMODE, D3DFILL_SOLID);

	// Draw the balls
	for (UINT iBall = 0; iBall < BALLCOUNT; iBall++)
		m_rpBall[iBall]->Render();

	// Draw the ground below the grass
	g_pd3dDevice->SetTransform( D3DTS_WORLD, &m_matWorld );
    g_pd3dDevice->SetPixelShader( 0 );
    g_pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE ); 
    g_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE, TRUE ); 
    g_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
	g_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE);
    g_pd3dDevice->SetTexture( 0, m_pFieldTexture );
	static DWORD dwGroundColor = 0xffffffff;
 	g_pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, dwGroundColor );
	g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_MODULATE );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
	g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_TFACTOR );
	g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG2 );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
	g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_TFACTOR );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );
	static DWORD dwMaxAnisotropy0 = 4;
	g_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAXANISOTROPY, dwMaxAnisotropy0 ); // make the field texture sharper as it recedes
	g_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_ANISOTROPIC );
	g_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
	g_pd3dDevice->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_LINEAR );
	g_pd3dDevice->SetTexture( 1, m_pFieldGrassTexture );
    g_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP, D3DTOP_MODULATE );
    g_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLORARG1, D3DTA_CURRENT );
    g_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLORARG2, D3DTA_TEXTURE );
    g_pd3dDevice->SetTextureStageState( 1, D3DTSS_ALPHAOP, D3DTOP_MODULATE );
    g_pd3dDevice->SetTextureStageState( 1, D3DTSS_ALPHAARG1, D3DTA_CURRENT );
    g_pd3dDevice->SetTextureStageState( 1, D3DTSS_ALPHAARG2, D3DTA_TEXTURE );
    g_pd3dDevice->SetTextureStageState( 1, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP );
    g_pd3dDevice->SetTextureStageState( 1, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP );
	static DWORD dwMaxAnisotropy1 = 2;
	g_pd3dDevice->SetTextureStageState( 1, D3DTSS_MAXANISOTROPY, dwMaxAnisotropy1 );
	g_pd3dDevice->SetTextureStageState( 1, D3DTSS_MINFILTER, D3DTEXF_ANISOTROPIC );
	g_pd3dDevice->SetTextureStageState( 1, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
	g_pd3dDevice->SetTextureStageState( 1, D3DTSS_MIPFILTER, D3DTEXF_LINEAR );
	g_pd3dDevice->SetTexture( 2, NULL );
    g_pd3dDevice->SetTextureStageState( 2, D3DTSS_COLOROP, D3DTOP_DISABLE );
    g_pd3dDevice->SetTextureStageState( 2, D3DTSS_ALPHAOP, D3DTOP_DISABLE );
    g_pd3dDevice->SetVertexShader( D3DFVF_XYZ|D3DFVF_TEX2|D3DFVF_TEXCOORDSIZE2(0)|D3DFVF_TEXCOORDSIZE2(1) );
	g_pd3dDevice->SetStreamSource( 0, m_pFieldVertexBuffer, sizeof(FieldVertex) );
	g_pd3dDevice->DrawPrimitive( D3DPT_QUADSTRIP, 0, 1);

	// Draw the field of grass modulated by the field texture
    g_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE, FALSE ); 
	g_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE, TRUE );
	g_pd3dDevice->SetRenderState( D3DRS_ALPHAREF, 0 );
	g_pd3dDevice->SetRenderState( D3DRS_ALPHAFUNC, D3DCMP_GREATER );
    g_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    g_pd3dDevice->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_ONE );
    g_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA );
	// Stage 0 is used for the whole-field texture. Most settings are inherited from above.
	g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_MODULATE );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
	g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_TEXTURE | D3DTA_ALPHAREPLICATE );	// multiply color by alpha
	g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1 );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
	// Stage 1 is used for the side-view grass strip texture
	g_pd3dDevice->SetTexture( 1, m_pGrassStripTexture );
    g_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP, D3DTOP_MODULATE );
    g_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLORARG1, D3DTA_CURRENT );
    g_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLORARG2, D3DTA_TEXTURE );
    g_pd3dDevice->SetTextureStageState( 1, D3DTSS_ALPHAOP, D3DTOP_MODULATE );
    g_pd3dDevice->SetTextureStageState( 1, D3DTSS_ALPHAARG1, D3DTA_CURRENT );
    g_pd3dDevice->SetTextureStageState( 1, D3DTSS_ALPHAARG2, D3DTA_TEXTURE );
    g_pd3dDevice->SetTextureStageState( 1, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP );
    g_pd3dDevice->SetTextureStageState( 1, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );
	g_pd3dDevice->SetTextureStageState( 1, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
	g_pd3dDevice->SetTextureStageState( 1, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
	g_pd3dDevice->SetTextureStageState( 1, D3DTSS_MIPFILTER, D3DTEXF_LINEAR );
	// Stage 2 is used to fade the strips in the distance
	g_pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, dwGroundColor );
	g_pd3dDevice->SetTexture( 2, NULL );
    g_pd3dDevice->SetTextureStageState( 2, D3DTSS_COLOROP, D3DTOP_MODULATE );
    g_pd3dDevice->SetTextureStageState( 2, D3DTSS_COLORARG1, D3DTA_CURRENT );
	g_pd3dDevice->SetTextureStageState( 2, D3DTSS_COLORARG2, D3DTA_TFACTOR );
    g_pd3dDevice->SetTextureStageState( 2, D3DTSS_ALPHAOP, D3DTOP_MODULATE );
    g_pd3dDevice->SetTextureStageState( 2, D3DTSS_ALPHAARG1, D3DTA_CURRENT );
	g_pd3dDevice->SetTextureStageState( 2, D3DTSS_ALPHAARG2, D3DTA_TFACTOR );
    g_pd3dDevice->SetVertexShader( D3DFVF_XYZ|D3DFVF_TEX2|D3DFVF_TEXCOORDSIZE2(0)|D3DFVF_TEXCOORDSIZE2(1) );
	g_pd3dDevice->SetStreamSource( 0, m_pGrassVertexBuffer, sizeof(GrassVertex) );
	
	// Fade the grass strips as they recede in the distance to avoid 
	// aliasing near the horizon and to give better performance. 
	// The following parameters can be adjusted to increase or decrease the
	// grass fade-out distance and range.
	static DWORD dwAlphaMin = 5;
	static float fDistMin = 50.f * FEET;	// starting distance for alpha fade
	static float fDistMax = 100.f * FEET;	// strips fade to 0 alpha at this distance
	DWORD dwFade = 0xffffffff;
	g_pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, dwFade );

	// get range of active grass strips
	float fScale = GRASS_FIELD_LENGTH / (float)(m_nGrassStripCount - 1);
	float fOffset = -0.5f * GRASS_FIELD_LENGTH;
	UINT iMin;
	float fiMin = (m_vFrom.x - fDistMax - fOffset) / fScale - 1.f;
	if (fiMin < 0) 
		iMin = 0;
	else
		iMin = (UINT)fiMin;
	UINT iMax;
	float fiMax = (m_vFrom.x - fOffset) / fScale + 1.f;
	if (fiMax < 0)
		iMax = 0;
	else
	{
		iMax = (UINT)fiMax;
		if (iMax > m_nGrassStripCount)
			iMax = m_nGrassStripCount;
	}

	// draw each active grass strip
	for (UINT i = iMin; i < iMax; i++)
	{
		float fX = (float)i * fScale + fOffset;
		float fDist = m_vFrom.x - fX;
		if (fDist < 0.f) continue;
		DWORD dwFadeNew;
		if (fDist > fDistMax)
			continue;				// completely off
		else if (fDist < fDistMin)
			dwFadeNew = 0xffffffff;	// fully on
		else
		{
			// in fade region
			float t = (fDist - fDistMin) / (fDistMax - fDistMin);
			float fAlpha = 1.f - (-2.f * t + 3.f) * t * t;
			DWORD dwAlpha = (DWORD)(fAlpha * 255);
			if (dwAlpha < dwAlphaMin) continue;
			if (dwAlpha > 255) dwAlpha = 255;
			dwFadeNew = (dwAlpha << 24) | (dwAlpha << 16) | (dwAlpha << 8) | dwAlpha;
		}
		if (dwFadeNew != dwFade)
		{
			dwFade = dwFadeNew;
			g_pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, dwFade );
		}
		// draw the current grass quad
		g_pd3dDevice->DrawPrimitive( D3DPT_QUADSTRIP, i * (m_nGrassQuadCountPerStrip + 1) * 2, m_nGrassQuadCountPerStrip);
	}	

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        m_Font.Begin();
        m_Font.DrawText(  64, 50, 0xffffffff, L"PlayField" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );
        m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\pointsprites\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\pointsprites\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\PolynomialTextureMaps\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\PolynomialTextureMaps\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\PlayField\obj\i386\Resource.h ===
// Automatically generated by the bundler tool from Resource.rdf

#define Resource_NUM_RESOURCES 4UL

#define Resource_Fairway_OFFSET 0UL
#define Resource_Football_OFFSET 20UL
#define Resource_GrassStrip_OFFSET 40UL
#define Resource_Grass_OFFSET 60UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\PolynomialTextureMaps\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\pointsprites\obj\i386\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 2UL

#define resource_Ground2_OFFSET 0UL
#define resource_Particle_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\pointsprites\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 2UL

#define resource_Ground2_OFFSET 0UL
#define resource_Particle_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\pointsprites\pointsprites.cpp ===
//-----------------------------------------------------------------------------
// File: PointSprites.cpp
//
// Desc: Sample showing how to use point sprites to do particle effects. Note:
//       this sample uses a significant number of alpha-blended pointsprites
//       (several pointsprites are used per particle, to get a motion-blur
//       effect), so it uses alot of CPU computations and uses alot of pixel 
//       fill.
//
// Performance Notes: 
//       A huge performance win for this app (as with most other apps using 
//       dynamic vertex buffers) is to multi-buffer the dynamic vertex
//       buffers. Since one vertex buffer will be tied up during render, we use
//       a free vertex buffer to fill and use for the current frame.
//       
//       This sample also gains a big boost in performance by setting a
//       smaller kickoff size, so that our dynamic-VBs can be re-locked
//       sooner after rendering. This reduces stalls significantly. Note 
//       that in a real-world app, reducing the kickoff size probably would not
//       be necessary, as there would be lots of other rendering happening
//       every frame. So kickoffs would automatically happen more often, thus
//       avoiding the problem of stalling when frequently locking dynamic
//       vertex buffers.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//       03.24.01 - Pointsize scale factor changed for April XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <XBResource.h>
#include <XBUtil.h>

// The following header file is generated from "Resource.rdf" file using the
// Bundler tool. In addition to the header, the tool outputs a binary file
// (Resource.xpr) which contains compiled (i.e. bundled) resources and is
// loaded at runtime using the CXBPackedResource class.
#include "Resource.h"




//-----------------------------------------------------------------------------
// PERFORMANCE NOTES.
//
// Set smaller kickoff size, so that our dynamic-VBs can be re-locked
// sooner after rendering.  This will reduce stalls in this app.
//
// Note that in a real-world app, reducing the kickoff size probably would
// not be necessary, as there would be lots of other rendering happening
// every frame.  So kickoffs would automatically happen more often, thus
// avoiding the problem of stalling when we frequently lock our "deep"
// dynamic vertex buffers.
//-----------------------------------------------------------------------------
#define NUM_PARTICLE_BUFFERS 3                  // # of vertex buffers for the particle system
#define KICKOFF_SIZE         (4 * (1<<10))      // Kick off size. Must be power of 2.
#define PUSHBUFFER_SIZE      (128*KICKOFF_SIZE) // Push buffer size as a multiple of kickoff size




//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_DPAD,         XBHELP_PLACEMENT_1, L"Zoom" },
    { XBHELP_LEFTSTICK,    XBHELP_PLACEMENT_2, L"Move\ncamera" },
    { XBHELP_RIGHTSTICK,   XBHELP_PLACEMENT_2, L"Rotate\ncamera" },
    { XBHELP_X_BUTTON,     XBHELP_PLACEMENT_2, L"Add\nparticles" },
    { XBHELP_Y_BUTTON,     XBHELP_PLACEMENT_2, L"Remove\nparticles" },
    { XBHELP_A_BUTTON,     XBHELP_PLACEMENT_2, L"Animate\nemitter" },
    { XBHELP_B_BUTTON,     XBHELP_PLACEMENT_2, L"Change\ncolor" },
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_2, L"Display\nhelp" },
};

#define NUM_HELP_CALLOUTS 8




//-----------------------------------------------------------------------------
// Custom vertex type
//-----------------------------------------------------------------------------
struct PARTICLEVERTEX
{
    D3DXVECTOR3 v;
    D3DCOLOR    color;
};

#define D3DFVF_PARTICLEVERTEX (D3DFVF_XYZ|D3DFVF_DIFFUSE)

struct LIGHTVERTEX
{
    D3DXVECTOR3 v;
    D3DCOLOR    color;
    FLOAT       tu;
    FLOAT       tv;
};

#define D3DFVF_LIGHTVERTEX (D3DFVF_XYZ|D3DFVF_DIFFUSE|D3DFVF_TEX1)

struct GROUNDVERTEX
{
    D3DXVECTOR3 v;
    D3DCOLOR    color;
    FLOAT       tu;
    FLOAT       tv;
};

#define D3DFVF_GROUNDVERTEX (D3DFVF_XYZ|D3DFVF_DIFFUSE|D3DFVF_TEX1)





//-----------------------------------------------------------------------------
// Global structs and data for the ground object
//-----------------------------------------------------------------------------
#define GROUND_SIZE  20.0f
#define GROUND_COLOR 0xddeeeeff




//-----------------------------------------------------------------------------
// Global data for the particles
//-----------------------------------------------------------------------------
struct PARTICLE
{
    BOOL        m_bSpark;     // Spark? or real particle?

    D3DXVECTOR3 m_vPos;       // Current position
    D3DXVECTOR3 m_vVel;       // Current velocity

    D3DXVECTOR3 m_vPos0;      // Initial position
    D3DXVECTOR3 m_vVel0;      // Initial velocity
    FLOAT       m_fTime0;     // Time of creation

    D3DXCOLOR   m_clrDiffuse; // Initial diffuse color
    D3DXCOLOR   m_clrFade;    // Faded diffuse color
    FLOAT       m_fFade;      // Fade progression
};


enum PARTICLE_COLORS { COLOR_WHITE, COLOR_RED, COLOR_GREEN, COLOR_BLUE, NUM_COLORS };


D3DXCOLOR g_clrColor[NUM_COLORS] =
{
    D3DXCOLOR( 1.0f,   1.0f,   1.0f,   1.0f ),
    D3DXCOLOR( 1.0f,   0.5f,   0.5f,   1.0f ),
    D3DXCOLOR( 0.5f,   1.0f,   0.5f,   1.0f ),
    D3DXCOLOR( 0.125f, 0.5f,   1.0f,   1.0f )
};


DWORD g_clrColorFade[NUM_COLORS] =
{
    D3DXCOLOR( 1.0f,   0.25f,   0.25f,   1.0f ),
    D3DXCOLOR( 1.0f,   0.25f,   0.25f,   1.0f ),
    D3DXCOLOR( 0.25f,  0.75f,   0.25f,   1.0f ),
    D3DXCOLOR( 0.125f, 0.25f,   0.75f,   1.0f )
};




//-----------------------------------------------------------------------------
// Name:
// Desc:
//-----------------------------------------------------------------------------
class CParticleSystem
{
protected:
    FLOAT                   m_fRadius;
    PARTICLE*               m_pParticles;
    DWORD                   m_dwMaxParticles;
    DWORD                   m_dwNumParticles;

    // Geometry
    LPDIRECT3DVERTEXBUFFER8 m_pPointSpritesVBs[NUM_PARTICLE_BUFFERS];
    LPDIRECT3DVERTEXBUFFER8 m_pLightsVBs[NUM_PARTICLE_BUFFERS];
    LPDIRECT3DVERTEXBUFFER8 m_pPointSpritesVB;
    LPDIRECT3DVERTEXBUFFER8 m_pLightsVB;
    DWORD                   m_dwCurrentBuffer;
    DWORD                   m_dwNumParticlesToRender;
    DWORD                   m_dwNumLightsToRender;

    // Rendering device
    LPDIRECT3DDEVICE8       m_pd3dDevice;

public:
    CParticleSystem( DWORD dwMaxParticles, FLOAT fRadius );
   ~CParticleSystem();

    HRESULT InitDeviceObjects( LPDIRECT3DDEVICE8 pd3dDevice );
    HRESULT DeleteDeviceObjects();

    HRESULT Update( FLOAT fSecsPerFrame, DWORD dwNumParticlesToEmit,
                    const D3DXCOLOR &dwEmitColor, const D3DXCOLOR &dwFadeColor,
                    FLOAT fEmitVel, D3DXVECTOR3 vPosition );

    HRESULT RenderParticles( LPDIRECT3DTEXTURE8 pTexture );
    HRESULT RenderLights( LPDIRECT3DTEXTURE8 pTexture );
};




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Application class. The base class provides just about all the
//       functionality we want, so we're just supplying stubs to interface with
//       the non-C++ functions of the app.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBPackedResource  m_xprResource;      // Packed resources for the app
    CXBFont            m_Font;             // Font class
    CXBHelp            m_Help;             // Help class
    BOOL               m_bDrawHelp;        // Whether to draw help

    // Particle system timing
    BOOL               m_bParticleSystemRunning;
    FLOAT              m_fParticleSystemTime;
    FLOAT              m_fElapsedParticleSystemTime;

    // Ground stuff
    LPDIRECT3DVERTEXBUFFER8 m_pGroundVB;
    LPDIRECT3DTEXTURE8 m_pGroundTexture;
    D3DXPLANE          m_planeGround;

    // Particle stuff
    LPDIRECT3DTEXTURE8 m_pParticleTexture;
    CParticleSystem*   m_pParticleSystem;
    DWORD              m_dwNumParticlesToEmit;
    DWORD              m_dwParticleColor;
    BOOL               m_bAnimateEmitter;

    // Static vectors for determining view position
    D3DXVECTOR3        m_vPosition;
    D3DXVECTOR3        m_vVelocity;
    FLOAT              m_fYaw;
    FLOAT              m_fYawVelocity;
    FLOAT              m_fPitch;
    FLOAT              m_fPitchVelocity;
    D3DXMATRIX         m_matView;
    D3DXMATRIX         m_matReflectedView;
    D3DXMATRIX         m_matOrientation;

protected:
    HRESULT Initialize();
    HRESULT FrameMove();
    HRESULT Render();

public:
    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Application constructor.
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    // Allow unlimited frame rate
    m_d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;

    // Set the push buffer and kickoff size. See comment about performance at
    // the top of this file.
    Direct3D_SetPushBufferSize( PUSHBUFFER_SIZE, KICKOFF_SIZE );

    // Init member variables
    m_bDrawHelp            = FALSE;

    m_bParticleSystemRunning     = TRUE;
    m_fParticleSystemTime        = 0.0f;
    m_fElapsedParticleSystemTime = 0.0f;

    m_pGroundTexture       = NULL;
    m_pGroundVB            = NULL;
    m_planeGround          = D3DXPLANE( 0.0f, 1.0f, 0.0f, 0.0f );

    m_pParticleTexture     = NULL;
    m_pParticleSystem      = new CParticleSystem( 4096, 0.03f );
    m_dwNumParticlesToEmit = 10;
    m_bAnimateEmitter      = FALSE;
    m_dwParticleColor      = COLOR_WHITE;

    m_vPosition            = D3DXVECTOR3( 0.0f, 3.0f,-4.0f );
    m_vVelocity            = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );
    m_fYaw                 = 0.0f;
    m_fYawVelocity         = 0.0f;
    m_fPitch               = 0.5f;
    m_fPitchVelocity       = 0.0f;
    D3DXMatrixTranslation( &m_matView, 0.0f, 0.0f, 10.0f );
    D3DXMatrixTranslation( &m_matOrientation, 0.0f, 0.0f, 0.0f );
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Initialize scene objects.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    HRESULT hr;

    // Create the font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the resources
    if( FAILED( m_xprResource.Create( m_pd3dDevice, "Resource.xpr", 
                                      resource_NUM_RESOURCES ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create textures
    m_pGroundTexture   = m_xprResource.GetTexture( resource_Ground2_OFFSET );
    m_pParticleTexture = m_xprResource.GetTexture( resource_Particle_OFFSET );

    // Create vertex buffer for ground object
    hr = m_pd3dDevice->CreateVertexBuffer( 4*sizeof(GROUNDVERTEX),
                                           D3DUSAGE_WRITEONLY, D3DFVF_GROUNDVERTEX,
                                           D3DPOOL_MANAGED, &m_pGroundVB );
    if( FAILED(hr) )
        return E_FAIL;

    // Fill vertex buffer
    GROUNDVERTEX* pVertices;
    m_pGroundVB->Lock( 0, 0, (BYTE**)&pVertices, NULL );
    pVertices[0].v     = GROUND_SIZE * D3DXVECTOR3( -0.5f, 0.0f, -0.5f );
    pVertices[0].color = GROUND_COLOR;
    pVertices[0].tu    = 0.0f;
    pVertices[0].tv    = 0.0f;
    pVertices[1].v     = GROUND_SIZE * D3DXVECTOR3( -0.5f, 0.0f, +0.5f );
    pVertices[1].color = GROUND_COLOR;
    pVertices[1].tu    = 0.0f;
    pVertices[1].tv    = 3.0f;
    pVertices[2].v     = GROUND_SIZE * D3DXVECTOR3( +0.5f, 0.0f, +0.5f );
    pVertices[2].color = GROUND_COLOR;
    pVertices[2].tu    = 3.0f;
    pVertices[2].tv    = 3.0f;
    pVertices[3].v     = GROUND_SIZE * D3DXVECTOR3( +0.5f, 0.0f, -0.5f );
    pVertices[3].color = GROUND_COLOR;
    pVertices[3].tu    = 3.0f;
    pVertices[3].tv    = 0.0f;
    m_pGroundVB->Unlock();

    // Initialize the particle system
    if( FAILED( hr = m_pParticleSystem->InitDeviceObjects( m_pd3dDevice ) ) )
        return hr;

    // Set the world matrix
    D3DXMATRIX matWorld;
    D3DXMatrixIdentity( &matWorld );
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld );

    // Set projection matrix
    D3DXMATRIX matProj;
    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/4, 4.0f/3.0f, 0.1f, 100.0f );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Animate the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // De-accelerate the camera movement (for smooth motion)
    FLOAT fScale = max( 0.0f, ( 1.0f - 2.0f*m_fElapsedTime) );
    m_vVelocity      *= fScale;
    m_fYawVelocity   *= fScale;
    m_fPitchVelocity *= fScale;

    // Update velocities from the gamepad
    m_vVelocity.x    += 1.0f*m_fElapsedTime*m_DefaultGamepad.fX1; // Slide left/right
    m_vVelocity.y    += 1.0f*m_fElapsedTime*m_DefaultGamepad.fY1; // Slide up/down
    if( m_DefaultGamepad.wButtons&XINPUT_GAMEPAD_DPAD_UP )   
        m_vVelocity.z += 1.0f*m_fElapsedTime;
    if( m_DefaultGamepad.wButtons&XINPUT_GAMEPAD_DPAD_DOWN ) 
        m_vVelocity.z -= 1.0f*m_fElapsedTime;

    m_fYawVelocity   += 1.0f*m_fElapsedTime*m_DefaultGamepad.fX2; // Turn left/right
    m_fPitchVelocity += 1.0f*m_fElapsedTime*m_DefaultGamepad.fY2; // Turn up/down

    // Handle options
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK )
        m_bDrawHelp = !m_bDrawHelp;

    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_X] )
        if( m_dwNumParticlesToEmit < 10 ) 
            m_dwNumParticlesToEmit += 1;
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_Y] )
        if( m_dwNumParticlesToEmit > 0 )
            m_dwNumParticlesToEmit -= 1;
    
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_A] )
        m_bAnimateEmitter = !m_bAnimateEmitter;
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_B] )
        m_dwParticleColor = (m_dwParticleColor+1)%NUM_COLORS;

    // Update the position vector
    D3DXVECTOR3 vT = m_vVelocity * 5.0f * m_fElapsedTime;
    D3DXVec3TransformNormal( &vT, &vT, &m_matOrientation );
    m_vPosition += vT;
    if( m_vPosition.y < 1.0f )
        m_vPosition.y = 1.0f;

    // Update the yaw-pitch-rotation vector
    m_fYaw   += 5.0f * m_fElapsedTime * m_fYawVelocity;
    m_fPitch += 5.0f * m_fElapsedTime * m_fPitchVelocity;
    if( m_fPitch < 0.0f )      m_fPitch = 0.0f;
    if( m_fPitch > D3DX_PI/2 ) m_fPitch = D3DX_PI/2;

    // Set the view matrix
    D3DXQUATERNION qR;
    D3DXQuaternionRotationYawPitchRoll( &qR, m_fYaw, m_fPitch, 0.0f );
    D3DXMatrixAffineTransformation( &m_matOrientation, 1.25f, NULL, &qR, &m_vPosition );
    D3DXMatrixInverse( &m_matView, NULL, &m_matOrientation );

    // Computed the reflected view
    D3DXMatrixReflect( &m_matReflectedView, &m_planeGround );
    D3DXMatrixMultiply( &m_matReflectedView, &m_matReflectedView, &m_matView );

    // Check the Start button to start/stop the particle system
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_START )
        m_bParticleSystemRunning = !m_bParticleSystemRunning;

    if( m_bParticleSystemRunning )
        m_fElapsedParticleSystemTime = m_fElapsedTime;
    else
        m_fElapsedParticleSystemTime = 0.0f;
    m_fParticleSystemTime += m_fElapsedParticleSystemTime;

    // Determine emitter position
    D3DXVECTOR3 vEmitterPostion( 0.0f, 0.0f, 0.f );
    if( m_bAnimateEmitter )
        vEmitterPostion = D3DXVECTOR3( 3*sinf(m_fParticleSystemTime), 0.0f, 3*cosf(m_fParticleSystemTime) );

    // Update particle system
    m_pParticleSystem->Update( m_fElapsedParticleSystemTime, m_dwNumParticlesToEmit,
                               g_clrColor[m_dwParticleColor],
                               g_clrColorFade[m_dwParticleColor], 8.0f,
                               vEmitterPostion );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Clear the viewport
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,
                         0x000000ff, 1.0f, 0L );

    // Set state
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU,  D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV,  D3DTADDRESS_WRAP );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING,  FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,   D3DZB_FALSE ); // we don't require z-buffer

    // Draw the ground
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &m_matView );
    m_pd3dDevice->SetTexture( 0, m_pGroundTexture );
    m_pd3dDevice->SetVertexShader( D3DFVF_GROUNDVERTEX );
    m_pd3dDevice->SetStreamSource( 0, m_pGroundVB, sizeof(GROUNDVERTEX) );
    m_pd3dDevice->DrawPrimitive( D3DPT_QUADLIST, 0, 1 );

    // Render the particles
    m_pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, 0xff000000 );
    m_pParticleSystem->RenderParticles( m_pParticleTexture );

    // Render the ground effect lights
    m_pParticleSystem->RenderLights( m_pParticleTexture );

    // Draw reflection of particles
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &m_matReflectedView );
    m_pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, 0x40000000 );
    m_pParticleSystem->RenderParticles( m_pParticleTexture );

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        m_Font.Begin();
        m_Font.DrawText(  64,  50, 0xffffffff, L"PointSprites" );
        m_Font.DrawText( 450,  50, 0xffffff00, m_strFrameRate );
        m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CParticleSystem()
// Desc:
//-----------------------------------------------------------------------------
CParticleSystem::CParticleSystem( DWORD dwMaxParticles, float fRadius )
{
    m_fRadius          = fRadius;

    m_pParticles       = new PARTICLE[dwMaxParticles];
    m_dwMaxParticles   = dwMaxParticles;
    m_dwNumParticles   = 0;

    m_pd3dDevice       = NULL;
    
    m_pPointSpritesVB  = NULL;
    m_pLightsVB        = NULL;
    m_dwCurrentBuffer  = 0;

    m_dwNumParticlesToRender = 0;
    m_dwNumLightsToRender    = 0;
}




//-----------------------------------------------------------------------------
// Name: ~CParticleSystem()
// Desc:
//-----------------------------------------------------------------------------
CParticleSystem::~CParticleSystem()
{
    DeleteDeviceObjects();

    SAFE_DELETE( m_pParticles );
}




//-----------------------------------------------------------------------------
// Name: InitDeviceObjects()
// Desc:
//-----------------------------------------------------------------------------
HRESULT CParticleSystem::InitDeviceObjects( LPDIRECT3DDEVICE8 pd3dDevice )
{
    HRESULT hr;

    // Save the device ptr
    m_pd3dDevice = pd3dDevice;

    // Create the particle texture
    // Create the particle system's vertex buffers. Each point sprite particle
    // requires one vertex and each light takes four vertices.
    for( DWORD buf = 0; buf < NUM_PARTICLE_BUFFERS; buf++ )
    {
        hr = m_pd3dDevice->CreateVertexBuffer( (m_dwMaxParticles+1)*sizeof(PARTICLEVERTEX),
                                               D3DUSAGE_WRITEONLY, D3DFVF_PARTICLEVERTEX,
                                               D3DPOOL_DEFAULT, &m_pPointSpritesVBs[buf] );
        if( FAILED(hr) )
            return E_FAIL;

        hr = m_pd3dDevice->CreateVertexBuffer( 4*(m_dwMaxParticles+1)*sizeof(LIGHTVERTEX),
                                               D3DUSAGE_WRITEONLY, D3DFVF_LIGHTVERTEX,
                                               D3DPOOL_DEFAULT, &m_pLightsVBs[buf] );
        if( FAILED(hr) )
            return E_FAIL;

        // Write default values to light vertices (the texture coordinates for
        // the quads never changes)
        LIGHTVERTEX* pLightVertices;
        m_pLightsVBs[buf]->Lock( 0, 0, (BYTE**)&pLightVertices, NULL );
        ZeroMemory( pLightVertices, 4*m_dwMaxParticles*sizeof(LIGHTVERTEX) );
        
        for( DWORD i=0; i<m_dwMaxParticles; i++ )
        {
            pLightVertices[1].tv = 1.0f;
            pLightVertices[2].tu = 1.0f;
            pLightVertices[2].tv = 1.0f;
            pLightVertices[3].tu = 1.0f;
            pLightVertices += 4;
        }

        // Unlock the vertex buffer
        m_pLightsVBs[buf]->Unlock();
    }

    // Select starting vertex buffers
    m_dwCurrentBuffer = 0;
    m_pPointSpritesVB = m_pPointSpritesVBs[m_dwCurrentBuffer];
    m_pLightsVB       = m_pLightsVBs[m_dwCurrentBuffer];

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DeleteDeviceObjects()
// Desc:
//-----------------------------------------------------------------------------
HRESULT CParticleSystem::DeleteDeviceObjects()
{
    m_pd3dDevice = NULL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Update()
// Desc: Update the particles in the particle system.
//-----------------------------------------------------------------------------
HRESULT CParticleSystem::Update( FLOAT fSecsPerFrame, DWORD dwNumParticlesToEmit,
                                 const D3DXCOLOR &clrEmitColor,
                                 const D3DXCOLOR &clrFadeColor, float fEmitVel,
                                 D3DXVECTOR3 vPosition )
{
    static float fTime = 0.0f;
    fTime += fSecsPerFrame;

    // For performance reasons, vertex buffers are multi-buffered. Each time
    // the vertex buffer contents are updated, use a new vertex buffer.
    if( m_pPointSpritesVB->IsBusy() )
    {
        if( ++m_dwCurrentBuffer >= NUM_PARTICLE_BUFFERS )
            m_dwCurrentBuffer = 0;
        m_pPointSpritesVB = m_pPointSpritesVBs[m_dwCurrentBuffer];
        m_pLightsVB       = m_pLightsVBs[m_dwCurrentBuffer];
    }
 
    // Lock vertex buffers
    PARTICLEVERTEX* pPointSpriteVertices;
    LIGHTVERTEX*    pLightVertices;
    m_pPointSpritesVB->Lock( 0, 0, (BYTE**)&pPointSpriteVertices, NULL );
    m_pLightsVB->Lock( 0, 0, (BYTE**)&pLightVertices, NULL );
    m_dwNumParticlesToRender = 0;
    m_dwNumLightsToRender    = 0;

    // Update particles
    for( DWORD i=0; i<m_dwNumParticles; i++ )
    {
        PARTICLE* pParticle = &m_pParticles[i];

        // Calculate new position
        FLOAT t = fTime - pParticle->m_fTime0;

        if( pParticle->m_bSpark )
        {
            pParticle->m_vPos    = pParticle->m_vVel0 * t + pParticle->m_vPos0;
            pParticle->m_vPos.y -= (0.5f * 5.0f) * (t * t);
            pParticle->m_vVel.y  = pParticle->m_vVel0.y - 5.0f * t;
            pParticle->m_fFade  -= fSecsPerFrame * 2.25f;
        }
        else
        {
            pParticle->m_vPos    = pParticle->m_vVel0 * t + pParticle->m_vPos0;
            pParticle->m_vPos.y -= (0.5f * 9.8f) * (t * t);
            pParticle->m_vVel.y  = pParticle->m_vVel0.y - 9.8f * t;
            pParticle->m_fFade  -= fSecsPerFrame * 0.25f;
        }

        if( pParticle->m_fFade < 0.0f )
            pParticle->m_fFade = 0.0f;

        // Kill old particles
        if( pParticle->m_vPos.y < m_fRadius || pParticle->m_bSpark && pParticle->m_fFade <= 0.0f )
        {
            // Emit sparks
            if( !pParticle->m_bSpark )
            {
                for( int j=0; j<4; j++ )
                {
                    FLOAT fRand1 = ((FLOAT)rand()/(FLOAT)RAND_MAX) * D3DX_PI * 2.00f;
                    FLOAT fRand2 = ((FLOAT)rand()/(FLOAT)RAND_MAX) * D3DX_PI * 0.25f;

                    PARTICLE* pSpark = &m_pParticles[m_dwNumParticles++];
                    pSpark->m_bSpark   = TRUE;
                    pSpark->m_vPos0    = pParticle->m_vPos;
                    pSpark->m_vPos0.y  = m_fRadius;
                    pSpark->m_vVel0.x  = pParticle->m_vVel.x * 0.25f + cosf(fRand1) * sinf(fRand2);
                    pSpark->m_vVel0.z  = pParticle->m_vVel.z * 0.25f + sinf(fRand1) * sinf(fRand2);
                    pSpark->m_vVel0.y  = cosf(fRand2);
                    pSpark->m_vVel0.y *= ((FLOAT)rand()/(FLOAT)RAND_MAX) * 1.5f;
                    pSpark->m_vPos     = pSpark->m_vPos0;
                    pSpark->m_vVel     = pSpark->m_vVel0;
                    D3DXColorLerp( &pSpark->m_clrDiffuse, &pParticle->m_clrFade,
                                   &pParticle->m_clrDiffuse, pParticle->m_fFade );
                    pSpark->m_clrFade  = D3DXCOLOR(0.0f, 0.0f, 0.0f, 1.0f);
                    pSpark->m_fFade    = 1.0f;
                    pSpark->m_fTime0   = fTime;
                }
            }

            // Kill this particle (we can do this fast, by simply moving the
            // last particle to take the current particle's place).
            m_pParticles[i--] = m_pParticles[--m_dwNumParticles];
        }
        else
        {
            // Build vertex buffers for the particles
            FLOAT fSpeed = D3DXVec3LengthSq( &pParticle->m_vVel );
            UINT  dwSteps;
            if( fSpeed < 1.0f )        dwSteps = 2;
            else if( fSpeed <  4.00f ) dwSteps = 3;
            else if( fSpeed <  9.00f ) dwSteps = 4;
            else if( fSpeed < 12.25f ) dwSteps = 5;
            else if( fSpeed < 16.00f ) dwSteps = 6;
            else if( fSpeed < 20.25f ) dwSteps = 7;
            else                       dwSteps = 8;

            D3DXVECTOR3 vPos = pParticle->m_vPos;
            D3DXVECTOR3 vVel = pParticle->m_vVel * -0.04f / (FLOAT)dwSteps;

            D3DXCOLOR clrDiffuse;
            D3DXColorLerp( &clrDiffuse, &pParticle->m_clrFade, &pParticle->m_clrDiffuse, 
                                        pParticle->m_fFade );
            DWORD dwDiffuse = (DWORD)clrDiffuse;

            // Compute vertices for ground lighting effects
            if( vPos.y < 1.0f )
            {
                FLOAT fY = vPos.y;
                if( fY < 0.0f )
                    fY = 0.0f;

                FLOAT fSize     = fY * 0.25f + m_fRadius;
                DWORD dwLightDiffuse = (DWORD)( clrDiffuse * ( (1.0f-fY) * 0.5f ) );

                pLightVertices[0].v.x   = pLightVertices[1].v.x   = vPos.x + fSize;
                pLightVertices[0].v.z   = pLightVertices[3].v.z   = vPos.z + fSize;
                pLightVertices[2].v.x   = pLightVertices[3].v.x   = vPos.x - fSize;
                pLightVertices[1].v.z   = pLightVertices[2].v.z   = vPos.z - fSize;
                pLightVertices[0].color = pLightVertices[1].color = dwLightDiffuse;
                pLightVertices[2].color = pLightVertices[3].color = dwLightDiffuse;

                // Advance to next light
                pLightVertices += 4;
                m_dwNumLightsToRender++;
            }

            // Use multiple pointsprites per particle to get a motion-blur effect
            for( DWORD j = 0; j < dwSteps; j++ )
            {
                if( vPos.y >= 0.0f )
                {
                    pPointSpriteVertices->v     = vPos;
                    pPointSpriteVertices->color = dwDiffuse;
                    pPointSpriteVertices++;
                    m_dwNumParticlesToRender++;

                    // Stop if the VB gets full.
                    if( m_dwNumParticlesToRender >= m_dwMaxParticles )
                        break;
                }
                vPos += vVel;
            }
        }
    }

    // Unlock the vertex buffers
    m_pPointSpritesVB->Unlock();
    m_pLightsVB->Unlock();

    // Emit new particles
    while( dwNumParticlesToEmit > 0 && m_dwNumParticles < m_dwMaxParticles/4 )
    {
        FLOAT fRand1 = ((FLOAT)rand()/(FLOAT)RAND_MAX) * D3DX_PI * 2.00f;
        FLOAT fRand2 = ((FLOAT)rand()/(FLOAT)RAND_MAX) * D3DX_PI * 0.25f;

        PARTICLE* pParticle = &m_pParticles[m_dwNumParticles];
        pParticle->m_bSpark     = FALSE;
        pParticle->m_vPos0      = vPosition + D3DXVECTOR3( 0.0f, m_fRadius, 0.0f );
        pParticle->m_vVel0.x    = cosf(fRand1) * sinf(fRand2) * 2.5f;
        pParticle->m_vVel0.z    = sinf(fRand1) * sinf(fRand2) * 2.5f;
        pParticle->m_vVel0.y    = cosf(fRand2);
        pParticle->m_vVel0.y   *= ((FLOAT)rand()/(FLOAT)RAND_MAX) * fEmitVel;
        pParticle->m_vPos       = pParticle->m_vPos0;
        pParticle->m_vVel       = pParticle->m_vVel0;
        pParticle->m_clrDiffuse = clrEmitColor;
        pParticle->m_clrFade    = clrFadeColor;
        pParticle->m_fFade      = 1.0f;
        pParticle->m_fTime0     = fTime;

        dwNumParticlesToEmit--;
        m_dwNumParticles++;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: RenderParticles()
// Desc: Renders the particle system using pointsprites.
//-----------------------------------------------------------------------------
HRESULT CParticleSystem::RenderParticles( LPDIRECT3DTEXTURE8 pTexture )
{
    if( 0 == m_dwNumParticlesToRender )
        return S_OK;

    // Set the render states for using point sprites. Note that pointsprites
    // use texture stage 3 only.
    m_pd3dDevice->SetTexture( 3, pTexture );
    m_pd3dDevice->SetTextureStageState( 3, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 3, D3DTSS_COLORARG1, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 3, D3DTSS_COLORARG2, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 3, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 3, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 3, D3DTSS_ALPHAARG2, D3DTA_TFACTOR );
    m_pd3dDevice->SetRenderState( D3DRS_POINTSPRITEENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_POINTSCALEENABLE,  TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_POINTSIZE,         FtoDW(0.10f) );
    m_pd3dDevice->SetRenderState( D3DRS_POINTSCALE_A,      FtoDW(0.00f) );
    m_pd3dDevice->SetRenderState( D3DRS_POINTSCALE_B,      FtoDW(0.00f) );
    m_pd3dDevice->SetRenderState( D3DRS_POINTSCALE_C,      FtoDW(1.00f) );

    // Turn on alphablending
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,         D3DBLEND_SRCALPHA );
    m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND,        D3DBLEND_ONE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHAREF,         0x08 );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHAFUNC,        D3DCMP_GREATEREQUAL );

    // Render particles
    m_pd3dDevice->SetStreamSource( 0, m_pPointSpritesVB, sizeof(PARTICLEVERTEX) );
    m_pd3dDevice->SetVertexShader( D3DFVF_PARTICLEVERTEX );
    m_pd3dDevice->DrawPrimitive( D3DPT_POINTLIST, 0, m_dwNumParticlesToRender );

    // Reset render states
    m_pd3dDevice->SetTexture( 3, NULL );
    m_pd3dDevice->SetTextureStageState( 3, D3DTSS_COLOROP, D3DTOP_DISABLE );
    m_pd3dDevice->SetRenderState( D3DRS_POINTSPRITEENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_POINTSCALEENABLE,  FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE,  FALSE );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: RenderLights()
// Desc: Renders ground lighting effects for the particle system.
//-----------------------------------------------------------------------------
HRESULT CParticleSystem::RenderLights( LPDIRECT3DTEXTURE8 pTexture )
{
    if( 0 == m_dwNumLightsToRender )
        return S_OK;

    // Turn on alphablending
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,         D3DBLEND_ONE );
    m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND,        D3DBLEND_ONE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHAREF,         0x08 );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHAFUNC,        D3DCMP_GREATEREQUAL );

    // Set state for rendering lights
    m_pd3dDevice->SetTexture( 0, pTexture );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
    
    // Render lights
    m_pd3dDevice->SetStreamSource( 0, m_pLightsVB, sizeof(LIGHTVERTEX) );
    m_pd3dDevice->SetVertexShader( D3DFVF_LIGHTVERTEX );
    m_pd3dDevice->DrawPrimitive( D3DPT_QUADLIST, 0, m_dwNumLightsToRender );

    // Restore state
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\PolynomialTextureMaps\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\PolynomialTextureMaps\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\projectedtexture\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\PolynomialTextureMaps\Resource.h ===
// Automatically generated by the bundler tool from Resource.rdf

#define Resource_NUM_RESOURCES 3UL

#define Resource_MoonPoly1_OFFSET 0UL
#define Resource_MoonPoly2_OFFSET 20UL
#define Resource_MoonColor_OFFSET 40UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\PolynomialTextureMaps\obj\i386\Resource.h ===
// Automatically generated by the bundler tool from Resource.rdf

#define Resource_NUM_RESOURCES 3UL

#define Resource_MoonPoly1_OFFSET 0UL
#define Resource_MoonPoly2_OFFSET 20UL
#define Resource_MoonColor_OFFSET 40UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\projectedtexture\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\projectedtexture\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\projectedtexture\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\projectedtexture\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\PolynomialTextureMaps\PolynomialTextureMaps.cpp ===
//-----------------------------------------------------------------------------
// File: PTM.cpp
//
// Desc: Example showing how to implement polynomial texture maps using the 
//       XBox GPU.
//
//       For a full description of polynomail texture maps see 
//       T. Malzbender, D. Gelb, and H. Wolters. Polynomial Texture Maps. In 
//       "Computer Graphics Proceedings", "Annual Conference Series", 2001, 
//       pages 519-528, August 2001.
//
// Hist: 01.21.02 - New for February XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <XBMesh.h>
#include <XBResource.h>
#include <XBUtil.h>
#include <assert.h>

// The following header file is generated from "Resource.rdf" file using the
// Bundler tool. In addition to the header, the tool outputs a binary file
// (Resource.xpr) which contains compiled (i.e. bundled) resources and is
// loaded at runtime using the CXBPackedResource class.
#include "Resource.h"




// By default we load the pre-computed polynomial textures from the resource
// file.  Setting this option to 1 will cause the textures to be computed
// from the sample textures.  However, in order to do so you will need to
// supply you own singular value decomposition routines.
#define COMPUTE_POLYNOMIAL_TEXTURE_MAPS 0




//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_LEFTSTICK,    XBHELP_PLACEMENT_1, L"Move Light" },
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_1, L"Display help" },
};

#define NUM_HELP_CALLOUTS (sizeof(g_HelpCallouts)/sizeof(g_HelpCallouts[0]))




//-----------------------------------------------------------------------------
// Data defining the quad the polynomial texure is applied to.
//-----------------------------------------------------------------------------
struct QUADVERT
{
    D3DVECTOR Pos;
    float U, V;
};


QUADVERT g_QuadVerts[] =
{
    {{ -1.0f,  1.0f, 0.0f, }, 0.0f, 0.0f },
    {{  1.0f,  1.0f, 0.0f, }, 1.0f, 0.0f },
    {{  1.0f, -1.0f, 0.0f, }, 1.0f, 1.0f },
    {{ -1.0f, -1.0f, 0.0f, }, 0.0f, 1.0f },
};


struct LINEVERT
{
    D3DVECTOR pos;
    D3DCOLOR color;
};




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBPackedResource  m_xprResource;        // Packed resources for the app
    CXBFont            m_Font;               // Font class
    CXBHelp            m_Help;               // Help class
    BOOL               m_bDrawHelp;          // Whether to draw help

    IDirect3DTexture8* m_pCoeff1Texture;    // a0, a1, a2
    IDirect3DTexture8* m_pCoeff2Texture;    // a3, a4, a5
    IDirect3DTexture8* m_pColorTexture;     // r, g, b

    DWORD              m_dwPTMVertexShader;
    DWORD              m_dwPTMPixelShader;

    int                m_iBias[6];

    D3DXVECTOR3        m_vLight;
    D3DXVECTOR3        m_vEye;
    D3DXMATRIX         m_matWorld;
    D3DXMATRIX         m_matView;
    D3DXMATRIX         m_matProjection;

    HRESULT ComputePolynomialTextures();

public:
    HRESULT Initialize();
    HRESULT Render();
    HRESULT FrameMove();

    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    // Allow unlimited frame rate
    m_d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;

    m_bDrawHelp     = false;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Load the resource, create the shaders, and intialize the view.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create the font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the resources
    if( FAILED( m_xprResource.Create( m_pd3dDevice, "Resource.xpr", Resource_NUM_RESOURCES, NULL ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the vertex shader.
    DWORD vdecl[] =
    {
        D3DVSD_STREAM(0),
        D3DVSD_REG(0, D3DVSDT_FLOAT3), // v0 = xyz
        D3DVSD_REG(1, D3DVSDT_FLOAT2), // v1 = uv
        D3DVSD_END()
    };

    if ( FAILED( XBUtil_CreateVertexShader( m_pd3dDevice, "Shaders\\PTM.xvu", vdecl, &m_dwPTMVertexShader ) ) )
        return E_FAIL;

    // Create the pixel shader.
    if ( FAILED( XBUtil_CreatePixelShader( m_pd3dDevice, "Shaders\\PTM.xpu", &m_dwPTMPixelShader ) ) )
        return E_FAIL;

#if (COMPUTE_POLYNOMIAL_TEXTURE_MAPS)

    ComputePolynomialTextures();

#else

    // Get the textures.
    m_pCoeff1Texture = m_xprResource.GetTexture( Resource_MoonPoly1_OFFSET );
    m_pCoeff2Texture = m_xprResource.GetTexture( Resource_MoonPoly2_OFFSET );
    m_pColorTexture = m_xprResource.GetTexture( Resource_MoonColor_OFFSET );

    // Read the bias factors for the polynomial coefficients.
    FILE* fp = fopen( "D:\\Media\\MoonCoeffs.txt", "r" );
	if(!fp)
		return E_FAIL;

    for (int i = 0; i < 6; i++)
    {
        if(fscanf(fp, "%d", &m_iBias[i]) != 1)
			return E_FAIL;
    }

    fclose(fp);

#endif

    // Set the matrices
    D3DXMatrixIdentity( &m_matWorld );
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &m_matWorld );

    m_vLight = D3DXVECTOR3( 0.0f, 0.0f, -1.0f );
    m_vEye = D3DXVECTOR3( 0.0f, 0.0f, -2.0f );
    D3DXVECTOR3 vAt( 0.0f, 0.0f, 0.0f );
    D3DXVECTOR3 vUp( 0.0f, 1.0f, 0.0f );

    D3DXMatrixLookAtLH( &m_matView, &m_vEye, &vAt, &vUp );
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &m_matView );

    D3DXMatrixPerspectiveFovLH( &m_matProjection, D3DX_PI/3, 4.0f/3.0f, 0.1f, 40.0f );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &m_matProjection );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    D3DXMATRIX matView, matRotate;

    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK )
        m_bDrawHelp = !m_bDrawHelp;

    D3DXVECTOR3 vNormal( 0.0f, 0.0f, -1.0f );
    D3DXVECTOR3 vUp( 0.0f, 1.0f, 0.0f );

    D3DXVECTOR3 vTemp;

    // Rotate light around up axis.
    D3DXMatrixRotationAxis( &matRotate, &vUp, -m_DefaultGamepad.fX1 * m_fElapsedTime );
    D3DXVec3TransformCoord( &vTemp, &m_vLight, &matRotate );

    // Place limits so we dont go around the back of the plane.
    FLOAT dot = D3DXVec3Dot( &vTemp, &vNormal );
    if( dot > 0.0f )
    {
        m_vLight = vTemp;
    }

    // Rotate eye points around side axis.
    D3DXVECTOR3 axis( 1.0f, 0.0f, 0.0f );
    D3DXMatrixRotationAxis( &matRotate, &axis, m_DefaultGamepad.fY1 * m_fElapsedTime );
    D3DXVec3TransformCoord( &vTemp, &m_vLight, &matRotate );

    dot = D3DXVec3Dot( &vTemp, &vNormal );
    if ( dot > 0.0f )
    {
        m_vLight = vTemp;
    }

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Sets up render states, clears the viewport, and renders the quad with
//       the polynomail texture map on it.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Clear the viewport, zbuffer, and stencil buffer
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,
                         0x00000000, 1.0f, 0 );

    // Begin the scene
    m_pd3dDevice->BeginScene();

    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,          TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SPECULARENABLE,   TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE,         D3DCULL_CCW );
    
    // Draw a quad with the textures.
    m_pd3dDevice->SetVertexShader( m_dwPTMVertexShader );
    m_pd3dDevice->SetPixelShader( m_dwPTMPixelShader );

    D3DXMATRIX matComposite;
    D3DXMatrixMultiply( &matComposite, &m_matWorld, &m_matView );
    D3DXMatrixMultiply( &matComposite, &matComposite, &m_matProjection );
    D3DXMatrixTranspose( &matComposite, &matComposite );
    m_pd3dDevice->SetVertexShaderConstant( 0, &matComposite, 4 );

    D3DXVECTOR4 vLightDir = m_vLight;
    m_pd3dDevice->SetVertexShaderConstant( 5, &vLightDir, 1 );

    float fConstants[4] = { 0.5f, 0.5f, 1.0f, 0.0f };
    m_pd3dDevice->SetVertexShaderConstant( 6, fConstants, 1 );

    // Set bias for the polynomial coefficients.
    fConstants[0] = float(m_iBias[0]/255.0f);
    fConstants[1] = float(m_iBias[1]/255.0f);
    fConstants[2] = float(m_iBias[2]/255.0f);
    m_pd3dDevice->SetPixelShaderConstant( 0, fConstants, 1 );

    fConstants[0] = float(m_iBias[3]/255.0f);
    fConstants[1] = float(m_iBias[4]/255.0f);
    fConstants[2] = float(m_iBias[5]/255.0f);
    m_pd3dDevice->SetPixelShaderConstant( 1, fConstants, 1 );

    m_pd3dDevice->SetTexture( 0, m_pCoeff1Texture );
    m_pd3dDevice->SetTexture( 1, m_pCoeff2Texture );

    m_pd3dDevice->SetTexture( 2, m_pColorTexture );

    // Draw the quad.
    m_pd3dDevice->DrawPrimitiveUP( D3DPT_QUADLIST, 1, g_QuadVerts, sizeof(QUADVERT) );

    // Show the vector to the light.
    m_pd3dDevice->SetVertexShader( D3DFVF_XYZ | D3DFVF_DIFFUSE );
    m_pd3dDevice->SetPixelShader( 0 );

    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING, FALSE );

    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_DIFFUSE );

    LINEVERT LineVerts[2];

    LineVerts[0].pos = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
    LineVerts[0].color = 0xff00ff00;

    LineVerts[1].pos = m_vLight * 0.75f;
    LineVerts[1].color = 0xff00ff00;

    m_pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, LineVerts, sizeof(LINEVERT) );

    // Show title, frame rate, and help
    if( m_bDrawHelp )
    {
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    }
    else
    {
        // Show frame rate
        m_Font.DrawText(  64, 50, 0xffffffff, L"Polynomial Texture Maps" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );
    }

    // End the scene.
    m_pd3dDevice->EndScene();

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}




#if (COMPUTE_POLYNOMIAL_TEXTURE_MAPS)


// Turn off double->float conversion warning.
#pragma warning( disable : 4305 )


//-----------------------------------------------------------------------------
// Structure defining what images to use as input samples.
//-----------------------------------------------------------------------------
struct
{
    D3DVECTOR vLightPos;        // Direction of light.
    char *strFileName;          // File to load.
}
g_ImageList[] = 
{
    {{0.0000,-250.0000,0.0000},         "D:\\Media\\Textures\\TestImage0000.bmp"},
    {{223.6068,-111.8034,0.0000},       "D:\\Media\\Textures\\TestImage0001.bmp"},
    {{69.0983,-111.8034,212.6627},      "D:\\Media\\Textures\\TestImage0002.bmp"},
    {{-180.9017,-111.8034,131.4328},    "D:\\Media\\Textures\\TestImage0003.bmp"},
    {{-180.9017,-111.8034,-131.4328},   "D:\\Media\\Textures\\TestImage0004.bmp"},
    {{69.0983,-111.8034,-212.6627},     "D:\\Media\\Textures\\TestImage0005.bmp"},
    {{90.1823,-233.1676,0.0000},        "D:\\Media\\Textures\\TestImage0006.bmp"},
    {{168.2207,-184.9372,0.0000},       "D:\\Media\\Textures\\TestImage0007.bmp"},
    {{27.8679,-233.1676,85.7685},       "D:\\Media\\Textures\\TestImage0008.bmp"},
    {{51.9831,-184.9372,159.9874},      "D:\\Media\\Textures\\TestImage0009.bmp"},
    {{-72.9590,-233.1676,53.0078},      "D:\\Media\\Textures\\TestImage0010.bmp"},
    {{-136.0934,-184.9372,98.8777},     "D:\\Media\\Textures\\TestImage0011.bmp"},
    {{-72.9590,-233.1676,-53.0078},     "D:\\Media\\Textures\\TestImage0012.bmp"},
    {{-136.0934,-184.9372,-98.8777},    "D:\\Media\\Textures\\TestImage0013.bmp"},
    {{27.8679,-233.1676,-85.7684},      "D:\\Media\\Textures\\TestImage0014.bmp"},
    {{51.9831,-184.9372,-159.9874},     "D:\\Media\\Textures\\TestImage0015.bmp"},
    {{196.0886,-129.2015,85.7684},      "D:\\Media\\Textures\\TestImage0016.bmp"},
    {{142.1653,-129.2015,159.9874},     "D:\\Media\\Textures\\TestImage0017.bmp"},
    {{-20.9759,-129.2015,212.9952},     "D:\\Media\\Textures\\TestImage0018.bmp"},
    {{-108.2256,-129.2015,184.6461},    "D:\\Media\\Textures\\TestImage0019.bmp"},
    {{-209.0524,-129.2015,45.8698},     "D:\\Media\\Textures\\TestImage0020.bmp"},
    {{-209.0524,-129.2015,-45.8699},    "D:\\Media\\Textures\\TestImage0021.bmp"},
    {{-108.2256,-129.2015,-184.6461},   "D:\\Media\\Textures\\TestImage0022.bmp"},
    {{-20.9759,-129.2015,-212.9952},    "D:\\Media\\Textures\\TestImage0023.bmp"},
    {{142.1654,-129.2015,-159.9874},    "D:\\Media\\Textures\\TestImage0024.bmp"},
    {{196.0886,-129.2015,-85.7684},     "D:\\Media\\Textures\\TestImage0025.bmp"},
    {{241.1797,-39.0192,53.0078},       "D:\\Media\\Textures\\TestImage0026.bmp"},
    {{24.1152,-39.0192,245.7558},       "D:\\Media\\Textures\\TestImage0027.bmp"},
    {{-226.2757,-39.0192,98.8776},      "D:\\Media\\Textures\\TestImage0028.bmp"},
    {{-163.9613,-39.0192,-184.6461},    "D:\\Media\\Textures\\TestImage0029.bmp"},
    {{124.9421,-39.0192,-212.9952},     "D:\\Media\\Textures\\TestImage0030.bmp"},
    {{241.1798,-39.0192,-53.0078},      "D:\\Media\\Textures\\TestImage0031.bmp"},
    {{124.9421,-39.0192,212.9952},      "D:\\Media\\Textures\\TestImage0032.bmp"},
    {{-163.9613,-39.0192,184.6461},     "D:\\Media\\Textures\\TestImage0033.bmp"},
    {{-226.2757,-39.0192,-98.8777},     "D:\\Media\\Textures\\TestImage0034.bmp"},
    {{24.1152,-39.0192,-245.7559},      "D:\\Media\\Textures\\TestImage0035.bmp"},
    {{119.8765,-201.3555,87.0954},      "D:\\Media\\Textures\\TestImage0036.bmp"},
    {{-45.7887,-201.3555,140.9232},     "D:\\Media\\Textures\\TestImage0037.bmp"},
    {{-148.1754,-201.3555,-0.0000},     "D:\\Media\\Textures\\TestImage0038.bmp"},
    {{-45.7887,-201.3555,-140.9232},    "D:\\Media\\Textures\\TestImage0039.bmp"},
    {{119.8765,-201.3555,-87.0953},     "D:\\Media\\Textures\\TestImage0040.bmp"},
    {{199.3126,-42.4832,144.8091},      "D:\\Media\\Textures\\TestImage0041.bmp"},
    {{-76.1306,-42.4832,234.3059},      "D:\\Media\\Textures\\TestImage0042.bmp"},
    {{-246.3639,-42.4832,-0.0000},      "D:\\Media\\Textures\\TestImage0043.bmp"},
    {{-76.1306,-42.4833,-234.3060},     "D:\\Media\\Textures\\TestImage0044.bmp"},
    {{199.3126,-42.4833,-144.8090},     "D:\\Media\\Textures\\TestImage0045.bmp"},
};

const int g_NumSourceImages = sizeof(g_ImageList)/sizeof(g_ImageList[0]);




//-----------------------------------------------------------------------------
// .BMP header structs so we can save out the data.
//-----------------------------------------------------------------------------
#pragma pack(push,1)
typedef struct tagBITMAPFILEHEADER { 
  WORD    bfType; 
  DWORD   bfSize; 
  WORD    bfReserved1; 
  WORD    bfReserved2; 
  DWORD   bfOffBits; 
} BITMAPFILEHEADER, *PBITMAPFILEHEADER; 

typedef struct tagBITMAPINFOHEADER{
  DWORD  biSize; 
  LONG   biWidth; 
  LONG   biHeight; 
  WORD   biPlanes; 
  WORD   biBitCount; 
  DWORD  biCompression; 
  DWORD  biSizeImage; 
  LONG   biXPelsPerMeter; 
  LONG   biYPelsPerMeter; 
  DWORD  biClrUsed; 
  DWORD  biClrImportant; 
} BITMAPINFOHEADER, *PBITMAPINFOHEADER; 
#pragma pack(pop)



//-----------------------------------------------------------------------------
// Name: ComputePolynomialTextures()
// Desc: Compute the polynomial textures (and the color texture) from a set of 
//       sample textures.  Also saved out the textures, and the polynomail bias
//       factors.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::ComputePolynomialTextures()
{
    HRESULT hr;
    int width = 512, height = 512;

    LPDIRECT3DTEXTURE8 pSourceTextures[g_NumSourceImages];
    DWORD* pSrcBits[g_NumSourceImages];
    D3DXVECTOR3 vLightDir[g_NumSourceImages];

    // Read the image textures and lock them.
    for ( int i = 0; i < g_NumSourceImages; i++ )
    {
        vLightDir[i] = g_ImageList[i].vLightPos;
        vLightDir[i].z = -vLightDir[i].z;
        D3DXVec3Normalize( &vLightDir[i], &vLightDir[i] );

        hr = D3DXCreateTextureFromFileEx( m_pd3dDevice,
                                          g_ImageList[i].strFileName,
                                          D3DX_DEFAULT,
                                          D3DX_DEFAULT,
                                          1,
                                          0,
                                          D3DFMT_A8R8G8B8,
                                          0,
                                          D3DX_FILTER_NONE,
                                          D3DX_FILTER_NONE,
                                          0,
                                          NULL,
                                          NULL,
                                          pSourceTextures+i );

        D3DLOCKED_RECT lock;
        pSourceTextures[i]->LockRect( 0, &lock, 0, 0 );

        pSrcBits[i] = (DWORD*)lock.pBits;
    }

    assert( pSourceTextures[0] );

    D3DSURFACE_DESC Desc;
    pSourceTextures[0]->GetLevelDesc( 0, &Desc );

    width = Desc.Width;
    height = Desc.Height;

    // Create textures to hold the polynomial coefficients and the rgb values.
    hr = m_pd3dDevice->CreateTexture( width, height, 1, 0, D3DFMT_A8R8G8B8, 0, &m_pCoeff1Texture );
    hr = m_pd3dDevice->CreateTexture( width, height, 1, 0, D3DFMT_A8R8G8B8, 0, &m_pCoeff2Texture );
    hr = m_pd3dDevice->CreateTexture( width, height, 1, 0, D3DFMT_A8R8G8B8, 0, &m_pColorTexture );
    
    D3DSURFACE_DESC desc_color;
    m_pColorTexture->GetLevelDesc( 0, &desc_color );

    D3DLOCKED_RECT lock_color;
    m_pColorTexture->LockRect( 0, &lock_color, 0, 0 );

    DWORD* pBitsColor = (DWORD*)lock_color.pBits;

    // Allocate storage to hold polynomial coeff's.
    double* pCoeffs = new double[height*width*6];

    int m = g_NumSourceImages;
    int n = 6;

    double a[g_NumSourceImages][6];
    double u[g_NumSourceImages][6];
    double w[6];
    double vt[6][6];
    double b[g_NumSourceImages];
    double xx[6];

    // Keep track of minimum and maximum of each coeffient.
    double MinCoeff[6];
    double MaxCoeff[6];

    for ( int i = 0; i < 6; i++ )
    {
        MinCoeff[i] =  100000.0;
        MaxCoeff[i] = -100000.0;
    }

    // Solve a system of equations for each pixel.
    for ( int y = 0; y < height; y++ )
    {
        for ( int x = 0; x < width; x++ )
        {
            double luminance[g_NumSourceImages];
            double max_luminance = -1.0;

            for ( int i = 0; i < g_NumSourceImages; i++ )
            {
                double red = ((pSrcBits[i][y*width+x] >> 16) & 0xff) / 255.0;
                double green = ((pSrcBits[i][y*width+x] >> 8) & 0xff) / 255.0;
                double blue = (pSrcBits[i][y*width+x] & 0xff) / 255.0;

                luminance[i] = (0.299 * red + 0.587 * green + 0.144 * blue);

                if (luminance[i] > max_luminance)
                {
                    // Save the maximum luminance.
                    max_luminance = luminance[i];

                    // Use this color for the pixel.
                    int r1 = int(red * 255.0f);
                    int g1 = int(green * 255.0f);
                    int b1= int(blue * 255.0f);

                    if (r1 > 255) r1 = 255;
                    if (g1 > 255) g1 = 255;
                    if (b1 > 256) b1 = 255;

                    pBitsColor[y*width+x] = (r1 << 16) | (g1 << 8) | b1;
                }
            }

            // Form the system of equations ..
            for ( int i = 0; i < g_NumSourceImages; i++ )
            {
                a[i][0] = vLightDir[i].x * vLightDir[i].x;
                a[i][1] = vLightDir[i].z * vLightDir[i].z;
                a[i][2] = vLightDir[i].x * vLightDir[i].z;
                a[i][3] = vLightDir[i].x;
                a[i][4] = vLightDir[i].z;
                a[i][5] = 1.0f;

                // Compute luminance of pixel (normalized).
                if (max_luminance > 0.0)
                    b[i] = luminance[i] / max_luminance;
                else
                    b[i] = 0.0f;
            }

            // .. and solve it for best fit.
            #error "You need to supply your own SVD routines."
            //num_svd(&a[0][0], m, n, &u[0][0], w, &vt[0][0]);
            //num_svd_backsubst(m, n, &u[0][0], w, &vt[0][0], b, xx, 0.0);

            for ( int i = 0; i < 6; i++ )
            {
                pCoeffs[(y*width+x)*6+i] = xx[i];

                if (xx[i] < MinCoeff[i])
                    MinCoeff[i] = xx[i];

                if (xx[i] > MaxCoeff[i])
                    MaxCoeff[i] = xx[i];
            }
        }
    }

    // Unlock source textures.
    for ( int i = 0; i < g_NumSourceImages; i++ )
    {
        pSourceTextures[i]->UnlockRect( 0 );
    }

    // Determine scale and bias to use.
    double Scale[6];
    double Bias[6];

    for ( int i = 0; i < 6; i++ )
    {
        // Scale is fixed at 2.0 becuase that is what our vertex shader uses.
        Scale[i] = 2.0f;

        // Compute bias.
        Bias[i] = -MinCoeff[i] / Scale[i];

        assert( Bias[i] >= 0.0 && Bias[i] <= 1.0 );

        m_iBias[i] = (int)(Bias[i] * 255.0);
    }

    // Lock and fill the textures
    D3DSURFACE_DESC desc1;
    m_pCoeff1Texture->GetLevelDesc( 0, &desc1 );

    D3DLOCKED_RECT lock1;
    m_pCoeff1Texture->LockRect( 0, &lock1, 0, 0 );

    DWORD* pBits1 = (DWORD*)lock1.pBits;

    D3DSURFACE_DESC desc2;
    m_pCoeff2Texture->GetLevelDesc( 0, &desc2 );

    D3DLOCKED_RECT lock2;
    m_pCoeff2Texture->LockRect( 0, &lock2, 0, 0 );

    DWORD* pBits2 = (DWORD*)lock2.pBits;

    for ( int y = 0; y < height; y++ )
    {
        for ( int x = 0; x < width; x++ )
        {
            unsigned char buf[6];

            for ( int i = 0; i < 6; i++ )
            {
                double value = pCoeffs[(y*width+x)*6+i] / Scale[i] + Bias[i];

                assert( value >= 0.0 && value <= 1.0 );

                buf[i] = (unsigned char)(value * 255.0);
            }

            pBits1[y*width+x] = (buf[0] << 16) | (buf[1] << 8) | buf[2];
            pBits2[y*width+x] = (buf[3] << 16) | (buf[4] << 8) | buf[5];
        }
    }

    delete[] pCoeffs;


    // Save the computed textures.
    DWORD* pTempBits = new DWORD[width*height];

    BITMAPFILEHEADER bf;
    BITMAPINFOHEADER bi;

    bf.bfType = 'MB';
    bf.bfSize = sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER) + width * height * 4;
    bf.bfReserved1 = 0;
    bf.bfReserved2 = 0;
    bf.bfOffBits = sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER);

    bi.biSize = sizeof(BITMAPINFOHEADER);
    bi.biWidth = width;
    bi.biHeight = height;
    bi.biPlanes = 1;
    bi.biBitCount = 32;
    bi.biCompression = 0;
    bi.biSizeImage = width * height * 4;
    bi.biXPelsPerMeter = 2834; 
    bi.biYPelsPerMeter = 2834;
    bi.biClrUsed = 0;
    bi.biClrImportant = 0;

    FILE *fp;

    fp = fopen( "D:\\Media\\Textures\\MoonPoly1.BMP", "wb" );

    fwrite( &bf, sizeof(BITMAPFILEHEADER), 1, fp );
    fwrite( &bi, sizeof(BITMAPINFOHEADER), 1, fp );
    XGUnswizzleRect( pBits1, width, height, NULL, pTempBits, 0, NULL, sizeof(DWORD) );
    fwrite( pTempBits, width*height, 4, fp );

    fclose(fp);

    fp = fopen( "D:\\Media\\Textures\\MoonPoly2.BMP", "wb" );

    fwrite( &bf, sizeof(BITMAPFILEHEADER), 1, fp );
    fwrite( &bi, sizeof(BITMAPINFOHEADER), 1, fp );
    XGUnswizzleRect( pBits2, width, height, NULL, pTempBits, 0, NULL, sizeof(DWORD) );
    fwrite( pTempBits, width*height, 4, fp );

    fclose(fp);

    fp = fopen( "D:\\Media\\Textures\\MoonColor.BMP", "wb" );

    fwrite( &bf, sizeof(BITMAPFILEHEADER), 1, fp );
    fwrite( &bi, sizeof(BITMAPINFOHEADER), 1, fp );
    XGUnswizzleRect( pBitsColor, width, height, NULL, pTempBits, 0, NULL, sizeof(DWORD) );
    fwrite( pTempBits, width*height, 4, fp );

    fclose(fp);

    fp = fopen( "D:\\Media\\MoonCoeffs.txt", "w" );

    for ( int i = 0; i < 6; i++ )
    {
        fprintf(fp, "%d\n", m_iBias[i]);
    }

    fclose(fp);

    delete[] pTempBits;

    
    // Unlock the textures
    m_pCoeff1Texture->UnlockRect( 0 );
    m_pCoeff2Texture->UnlockRect( 0 );
    m_pColorTexture->UnlockRect( 0 );

    return S_OK;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\PTM\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\PushBuffer\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\PushBuffer\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\PushBuffer\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\PushBuffer\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\PushBuffer\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\shadowbuffer\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\shadowbuffer\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\shadowbuffer\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\PTM\PolynomialTextureMaps.cpp ===
//-----------------------------------------------------------------------------
// File: PTM.cpp
//
// Desc: Example showing how to implement polynomial texture maps using the 
//       XBox GPU.
//
//       For a full description of polynomail texture maps see 
//       T. Malzbender, D. Gelb, and H. Wolters. Polynomial Texture Maps. In 
//       "Computer Graphics Proceedings", "Annual Conference Series", 2001, 
//       pages 519-528, August 2001.
//
// Hist: 01.21.02 - New for February XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <XBMesh.h>
#include <XBResource.h>
#include <XBUtil.h>
#include <assert.h>

// The following header file is generated from "Resource.rdf" file using the
// Bundler tool. In addition to the header, the tool outputs a binary file
// (Resource.xpr) which contains compiled (i.e. bundled) resources and is
// loaded at runtime using the CXBPackedResource class.
#include "Resource.h"




// By default we load the pre-computed polynomial textures from the resource
// file.  Setting this option to 1 will cause the textures to be computed
// from the sample textures.  However, in order to do so you will need to
// supply you own singular value decomposition routines.
#define COMPUTE_POLYNOMIAL_TEXTURE_MAPS 0




//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_LEFTSTICK,    XBHELP_PLACEMENT_1, L"Move Light" },
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_1, L"Display help" },
};

#define NUM_HELP_CALLOUTS (sizeof(g_HelpCallouts)/sizeof(g_HelpCallouts[0]))




//-----------------------------------------------------------------------------
// Data defining the quad the polynomial texure is applied to.
//-----------------------------------------------------------------------------
struct QUADVERT
{
    D3DVECTOR Pos;
    float U, V;
};


QUADVERT g_QuadVerts[] =
{
    {{ -1.0f,  1.0f, 0.0f, }, 0.0f, 0.0f },
    {{  1.0f,  1.0f, 0.0f, }, 1.0f, 0.0f },
    {{  1.0f, -1.0f, 0.0f, }, 1.0f, 1.0f },
    {{ -1.0f, -1.0f, 0.0f, }, 0.0f, 1.0f },
};


struct LINEVERT
{
    D3DVECTOR pos;
    D3DCOLOR color;
};




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBPackedResource  m_xprResource;        // Packed resources for the app
    CXBFont            m_Font;               // Font class
    CXBHelp            m_Help;               // Help class
    BOOL               m_bDrawHelp;          // Whether to draw help

    IDirect3DTexture8* m_pCoeff1Texture;    // a0, a1, a2
    IDirect3DTexture8* m_pCoeff2Texture;    // a3, a4, a5
    IDirect3DTexture8* m_pColorTexture;     // r, g, b

    DWORD              m_dwPTMVertexShader;
    DWORD              m_dwPTMPixelShader;

    int                m_iBias[6];

    D3DXVECTOR3        m_vLight;
    D3DXVECTOR3        m_vEye;
    D3DXMATRIX         m_matWorld;
    D3DXMATRIX         m_matView;
    D3DXMATRIX         m_matProjection;

    HRESULT ComputePolynomialTextures();

public:
    HRESULT Initialize();
    HRESULT Render();
    HRESULT FrameMove();

    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    // Allow unlimited frame rate
    m_d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;

    m_bDrawHelp     = false;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Load the resource, create the shaders, and intialize the view.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create the font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the resources
    if( FAILED( m_xprResource.Create( m_pd3dDevice, "Resource.xpr", Resource_NUM_RESOURCES, NULL ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the vertex shader.
    DWORD vdecl[] =
    {
        D3DVSD_STREAM(0),
        D3DVSD_REG(0, D3DVSDT_FLOAT3), // v0 = xyz
        D3DVSD_REG(1, D3DVSDT_FLOAT2), // v1 = uv
        D3DVSD_END()
    };

    if ( FAILED( XBUtil_CreateVertexShader( m_pd3dDevice, "Shaders\\PTM.xvu", vdecl, &m_dwPTMVertexShader ) ) )
        return E_FAIL;

    // Create the pixel shader.
    if ( FAILED( XBUtil_CreatePixelShader( m_pd3dDevice, "Shaders\\PTM.xpu", &m_dwPTMPixelShader ) ) )
        return E_FAIL;

#if (COMPUTE_POLYNOMIAL_TEXTURE_MAPS)

    ComputePolynomialTextures();

#else

    // Get the textures.
    m_pCoeff1Texture = m_xprResource.GetTexture( Resource_MoonPoly1_OFFSET );
    m_pCoeff2Texture = m_xprResource.GetTexture( Resource_MoonPoly2_OFFSET );
    m_pColorTexture = m_xprResource.GetTexture( Resource_MoonColor_OFFSET );

    // Read the bias factors for the polynomial coefficients.
    FILE* fp = fopen( "D:\\Media\\MoonCoeffs.txt", "r" );
	if(!fp)
		return E_FAIL;

    for (int i = 0; i < 6; i++)
    {
        if(fscanf(fp, "%d", &m_iBias[i]) != 1)
			return E_FAIL;
    }

    fclose(fp);

#endif

    // Set the matrices
    D3DXMatrixIdentity( &m_matWorld );
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &m_matWorld );

    m_vLight = D3DXVECTOR3( 0.0f, 0.0f, -1.0f );
    m_vEye = D3DXVECTOR3( 0.0f, 0.0f, -2.0f );
    D3DXVECTOR3 vAt( 0.0f, 0.0f, 0.0f );
    D3DXVECTOR3 vUp( 0.0f, 1.0f, 0.0f );

    D3DXMatrixLookAtLH( &m_matView, &m_vEye, &vAt, &vUp );
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &m_matView );

    D3DXMatrixPerspectiveFovLH( &m_matProjection, D3DX_PI/3, 4.0f/3.0f, 0.1f, 40.0f );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &m_matProjection );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    D3DXMATRIX matView, matRotate;

    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK )
        m_bDrawHelp = !m_bDrawHelp;

    D3DXVECTOR3 vNormal( 0.0f, 0.0f, -1.0f );
    D3DXVECTOR3 vUp( 0.0f, 1.0f, 0.0f );

    D3DXVECTOR3 vTemp;

    // Rotate light around up axis.
    D3DXMatrixRotationAxis( &matRotate, &vUp, -m_DefaultGamepad.fX1 * m_fElapsedTime );
    D3DXVec3TransformCoord( &vTemp, &m_vLight, &matRotate );

    // Place limits so we dont go around the back of the plane.
    FLOAT dot = D3DXVec3Dot( &vTemp, &vNormal );
    if( dot > 0.0f )
    {
        m_vLight = vTemp;
    }

    // Rotate eye points around side axis.
    D3DXVECTOR3 axis( 1.0f, 0.0f, 0.0f );
    D3DXMatrixRotationAxis( &matRotate, &axis, m_DefaultGamepad.fY1 * m_fElapsedTime );
    D3DXVec3TransformCoord( &vTemp, &m_vLight, &matRotate );

    dot = D3DXVec3Dot( &vTemp, &vNormal );
    if ( dot > 0.0f )
    {
        m_vLight = vTemp;
    }

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Sets up render states, clears the viewport, and renders the quad with
//       the polynomail texture map on it.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Clear the viewport, zbuffer, and stencil buffer
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,
                         0x00000000, 1.0f, 0 );

    // Begin the scene
    m_pd3dDevice->BeginScene();

    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,          TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SPECULARENABLE,   TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE,         D3DCULL_CCW );
    
    // Draw a quad with the textures.
    m_pd3dDevice->SetVertexShader( m_dwPTMVertexShader );
    m_pd3dDevice->SetPixelShader( m_dwPTMPixelShader );

    D3DXMATRIX matComposite;
    D3DXMatrixMultiply( &matComposite, &m_matWorld, &m_matView );
    D3DXMatrixMultiply( &matComposite, &matComposite, &m_matProjection );
    D3DXMatrixTranspose( &matComposite, &matComposite );
    m_pd3dDevice->SetVertexShaderConstant( 0, &matComposite, 4 );

    D3DXVECTOR4 vLightDir = m_vLight;
    m_pd3dDevice->SetVertexShaderConstant( 5, &vLightDir, 1 );

    float fConstants[4] = { 0.5f, 0.5f, 1.0f, 0.0f };
    m_pd3dDevice->SetVertexShaderConstant( 6, fConstants, 1 );

    // Set bias for the polynomial coefficients.
    fConstants[0] = float(m_iBias[0]/255.0f);
    fConstants[1] = float(m_iBias[1]/255.0f);
    fConstants[2] = float(m_iBias[2]/255.0f);
    m_pd3dDevice->SetPixelShaderConstant( 0, fConstants, 1 );

    fConstants[0] = float(m_iBias[3]/255.0f);
    fConstants[1] = float(m_iBias[4]/255.0f);
    fConstants[2] = float(m_iBias[5]/255.0f);
    m_pd3dDevice->SetPixelShaderConstant( 1, fConstants, 1 );

    m_pd3dDevice->SetTexture( 0, m_pCoeff1Texture );
    m_pd3dDevice->SetTexture( 1, m_pCoeff2Texture );

    m_pd3dDevice->SetTexture( 2, m_pColorTexture );

    // Draw the quad.
    m_pd3dDevice->DrawPrimitiveUP( D3DPT_QUADLIST, 1, g_QuadVerts, sizeof(QUADVERT) );

    // Show the vector to the light.
    m_pd3dDevice->SetVertexShader( D3DFVF_XYZ | D3DFVF_DIFFUSE );
    m_pd3dDevice->SetPixelShader( 0 );

    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING, FALSE );

    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_DIFFUSE );

    LINEVERT LineVerts[2];

    LineVerts[0].pos = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
    LineVerts[0].color = 0xff00ff00;

    LineVerts[1].pos = m_vLight * 0.75f;
    LineVerts[1].color = 0xff00ff00;

    m_pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, LineVerts, sizeof(LINEVERT) );

    // Show title, frame rate, and help
    if( m_bDrawHelp )
    {
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    }
    else
    {
        // Show frame rate
        m_Font.DrawText(  64, 50, 0xffffffff, L"Polynomial Texture Maps" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );
    }

    // End the scene.
    m_pd3dDevice->EndScene();

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}




#if (COMPUTE_POLYNOMIAL_TEXTURE_MAPS)


// Turn off double->float conversion warning.
#pragma warning( disable : 4305 )


//-----------------------------------------------------------------------------
// Structure defining what images to use as input samples.
//-----------------------------------------------------------------------------
struct
{
    D3DVECTOR vLightPos;        // Direction of light.
    char *strFileName;          // File to load.
}
g_ImageList[] = 
{
    {{0.0000,-250.0000,0.0000},         "D:\\Media\\Textures\\TestImage0000.bmp"},
    {{223.6068,-111.8034,0.0000},       "D:\\Media\\Textures\\TestImage0001.bmp"},
    {{69.0983,-111.8034,212.6627},      "D:\\Media\\Textures\\TestImage0002.bmp"},
    {{-180.9017,-111.8034,131.4328},    "D:\\Media\\Textures\\TestImage0003.bmp"},
    {{-180.9017,-111.8034,-131.4328},   "D:\\Media\\Textures\\TestImage0004.bmp"},
    {{69.0983,-111.8034,-212.6627},     "D:\\Media\\Textures\\TestImage0005.bmp"},
    {{90.1823,-233.1676,0.0000},        "D:\\Media\\Textures\\TestImage0006.bmp"},
    {{168.2207,-184.9372,0.0000},       "D:\\Media\\Textures\\TestImage0007.bmp"},
    {{27.8679,-233.1676,85.7685},       "D:\\Media\\Textures\\TestImage0008.bmp"},
    {{51.9831,-184.9372,159.9874},      "D:\\Media\\Textures\\TestImage0009.bmp"},
    {{-72.9590,-233.1676,53.0078},      "D:\\Media\\Textures\\TestImage0010.bmp"},
    {{-136.0934,-184.9372,98.8777},     "D:\\Media\\Textures\\TestImage0011.bmp"},
    {{-72.9590,-233.1676,-53.0078},     "D:\\Media\\Textures\\TestImage0012.bmp"},
    {{-136.0934,-184.9372,-98.8777},    "D:\\Media\\Textures\\TestImage0013.bmp"},
    {{27.8679,-233.1676,-85.7684},      "D:\\Media\\Textures\\TestImage0014.bmp"},
    {{51.9831,-184.9372,-159.9874},     "D:\\Media\\Textures\\TestImage0015.bmp"},
    {{196.0886,-129.2015,85.7684},      "D:\\Media\\Textures\\TestImage0016.bmp"},
    {{142.1653,-129.2015,159.9874},     "D:\\Media\\Textures\\TestImage0017.bmp"},
    {{-20.9759,-129.2015,212.9952},     "D:\\Media\\Textures\\TestImage0018.bmp"},
    {{-108.2256,-129.2015,184.6461},    "D:\\Media\\Textures\\TestImage0019.bmp"},
    {{-209.0524,-129.2015,45.8698},     "D:\\Media\\Textures\\TestImage0020.bmp"},
    {{-209.0524,-129.2015,-45.8699},    "D:\\Media\\Textures\\TestImage0021.bmp"},
    {{-108.2256,-129.2015,-184.6461},   "D:\\Media\\Textures\\TestImage0022.bmp"},
    {{-20.9759,-129.2015,-212.9952},    "D:\\Media\\Textures\\TestImage0023.bmp"},
    {{142.1654,-129.2015,-159.9874},    "D:\\Media\\Textures\\TestImage0024.bmp"},
    {{196.0886,-129.2015,-85.7684},     "D:\\Media\\Textures\\TestImage0025.bmp"},
    {{241.1797,-39.0192,53.0078},       "D:\\Media\\Textures\\TestImage0026.bmp"},
    {{24.1152,-39.0192,245.7558},       "D:\\Media\\Textures\\TestImage0027.bmp"},
    {{-226.2757,-39.0192,98.8776},      "D:\\Media\\Textures\\TestImage0028.bmp"},
    {{-163.9613,-39.0192,-184.6461},    "D:\\Media\\Textures\\TestImage0029.bmp"},
    {{124.9421,-39.0192,-212.9952},     "D:\\Media\\Textures\\TestImage0030.bmp"},
    {{241.1798,-39.0192,-53.0078},      "D:\\Media\\Textures\\TestImage0031.bmp"},
    {{124.9421,-39.0192,212.9952},      "D:\\Media\\Textures\\TestImage0032.bmp"},
    {{-163.9613,-39.0192,184.6461},     "D:\\Media\\Textures\\TestImage0033.bmp"},
    {{-226.2757,-39.0192,-98.8777},     "D:\\Media\\Textures\\TestImage0034.bmp"},
    {{24.1152,-39.0192,-245.7559},      "D:\\Media\\Textures\\TestImage0035.bmp"},
    {{119.8765,-201.3555,87.0954},      "D:\\Media\\Textures\\TestImage0036.bmp"},
    {{-45.7887,-201.3555,140.9232},     "D:\\Media\\Textures\\TestImage0037.bmp"},
    {{-148.1754,-201.3555,-0.0000},     "D:\\Media\\Textures\\TestImage0038.bmp"},
    {{-45.7887,-201.3555,-140.9232},    "D:\\Media\\Textures\\TestImage0039.bmp"},
    {{119.8765,-201.3555,-87.0953},     "D:\\Media\\Textures\\TestImage0040.bmp"},
    {{199.3126,-42.4832,144.8091},      "D:\\Media\\Textures\\TestImage0041.bmp"},
    {{-76.1306,-42.4832,234.3059},      "D:\\Media\\Textures\\TestImage0042.bmp"},
    {{-246.3639,-42.4832,-0.0000},      "D:\\Media\\Textures\\TestImage0043.bmp"},
    {{-76.1306,-42.4833,-234.3060},     "D:\\Media\\Textures\\TestImage0044.bmp"},
    {{199.3126,-42.4833,-144.8090},     "D:\\Media\\Textures\\TestImage0045.bmp"},
};

const int g_NumSourceImages = sizeof(g_ImageList)/sizeof(g_ImageList[0]);




//-----------------------------------------------------------------------------
// .BMP header structs so we can save out the data.
//-----------------------------------------------------------------------------
#pragma pack(push,1)
typedef struct tagBITMAPFILEHEADER { 
  WORD    bfType; 
  DWORD   bfSize; 
  WORD    bfReserved1; 
  WORD    bfReserved2; 
  DWORD   bfOffBits; 
} BITMAPFILEHEADER, *PBITMAPFILEHEADER; 

typedef struct tagBITMAPINFOHEADER{
  DWORD  biSize; 
  LONG   biWidth; 
  LONG   biHeight; 
  WORD   biPlanes; 
  WORD   biBitCount; 
  DWORD  biCompression; 
  DWORD  biSizeImage; 
  LONG   biXPelsPerMeter; 
  LONG   biYPelsPerMeter; 
  DWORD  biClrUsed; 
  DWORD  biClrImportant; 
} BITMAPINFOHEADER, *PBITMAPINFOHEADER; 
#pragma pack(pop)



//-----------------------------------------------------------------------------
// Name: ComputePolynomialTextures()
// Desc: Compute the polynomial textures (and the color texture) from a set of 
//       sample textures.  Also saved out the textures, and the polynomail bias
//       factors.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::ComputePolynomialTextures()
{
    HRESULT hr;
    int width = 512, height = 512;

    LPDIRECT3DTEXTURE8 pSourceTextures[g_NumSourceImages];
    DWORD* pSrcBits[g_NumSourceImages];
    D3DXVECTOR3 vLightDir[g_NumSourceImages];

    // Read the image textures and lock them.
    for ( int i = 0; i < g_NumSourceImages; i++ )
    {
        vLightDir[i] = g_ImageList[i].vLightPos;
        vLightDir[i].z = -vLightDir[i].z;
        D3DXVec3Normalize( &vLightDir[i], &vLightDir[i] );

        hr = D3DXCreateTextureFromFileEx( m_pd3dDevice,
                                          g_ImageList[i].strFileName,
                                          D3DX_DEFAULT,
                                          D3DX_DEFAULT,
                                          1,
                                          0,
                                          D3DFMT_A8R8G8B8,
                                          0,
                                          D3DX_FILTER_NONE,
                                          D3DX_FILTER_NONE,
                                          0,
                                          NULL,
                                          NULL,
                                          pSourceTextures+i );

        D3DLOCKED_RECT lock;
        pSourceTextures[i]->LockRect( 0, &lock, 0, 0 );

        pSrcBits[i] = (DWORD*)lock.pBits;
    }

    assert( pSourceTextures[0] );

    D3DSURFACE_DESC Desc;
    pSourceTextures[0]->GetLevelDesc( 0, &Desc );

    width = Desc.Width;
    height = Desc.Height;

    // Create textures to hold the polynomial coefficients and the rgb values.
    hr = m_pd3dDevice->CreateTexture( width, height, 1, 0, D3DFMT_A8R8G8B8, 0, &m_pCoeff1Texture );
    hr = m_pd3dDevice->CreateTexture( width, height, 1, 0, D3DFMT_A8R8G8B8, 0, &m_pCoeff2Texture );
    hr = m_pd3dDevice->CreateTexture( width, height, 1, 0, D3DFMT_A8R8G8B8, 0, &m_pColorTexture );
    
    D3DSURFACE_DESC desc_color;
    m_pColorTexture->GetLevelDesc( 0, &desc_color );

    D3DLOCKED_RECT lock_color;
    m_pColorTexture->LockRect( 0, &lock_color, 0, 0 );

    DWORD* pBitsColor = (DWORD*)lock_color.pBits;

    // Allocate storage to hold polynomial coeff's.
    double* pCoeffs = new double[height*width*6];

    int m = g_NumSourceImages;
    int n = 6;

    double a[g_NumSourceImages][6];
    double u[g_NumSourceImages][6];
    double w[6];
    double vt[6][6];
    double b[g_NumSourceImages];
    double xx[6];

    // Keep track of minimum and maximum of each coeffient.
    double MinCoeff[6];
    double MaxCoeff[6];

    for ( int i = 0; i < 6; i++ )
    {
        MinCoeff[i] =  100000.0;
        MaxCoeff[i] = -100000.0;
    }

    // Solve a system of equations for each pixel.
    for ( int y = 0; y < height; y++ )
    {
        for ( int x = 0; x < width; x++ )
        {
            double luminance[g_NumSourceImages];
            double max_luminance = -1.0;

            for ( int i = 0; i < g_NumSourceImages; i++ )
            {
                double red = ((pSrcBits[i][y*width+x] >> 16) & 0xff) / 255.0;
                double green = ((pSrcBits[i][y*width+x] >> 8) & 0xff) / 255.0;
                double blue = (pSrcBits[i][y*width+x] & 0xff) / 255.0;

                luminance[i] = (0.299 * red + 0.587 * green + 0.144 * blue);

                if (luminance[i] > max_luminance)
                {
                    // Save the maximum luminance.
                    max_luminance = luminance[i];

                    // Use this color for the pixel.
                    int r1 = int(red * 255.0f);
                    int g1 = int(green * 255.0f);
                    int b1= int(blue * 255.0f);

                    if (r1 > 255) r1 = 255;
                    if (g1 > 255) g1 = 255;
                    if (b1 > 256) b1 = 255;

                    pBitsColor[y*width+x] = (r1 << 16) | (g1 << 8) | b1;
                }
            }

            // Form the system of equations ..
            for ( int i = 0; i < g_NumSourceImages; i++ )
            {
                a[i][0] = vLightDir[i].x * vLightDir[i].x;
                a[i][1] = vLightDir[i].z * vLightDir[i].z;
                a[i][2] = vLightDir[i].x * vLightDir[i].z;
                a[i][3] = vLightDir[i].x;
                a[i][4] = vLightDir[i].z;
                a[i][5] = 1.0f;

                // Compute luminance of pixel (normalized).
                if (max_luminance > 0.0)
                    b[i] = luminance[i] / max_luminance;
                else
                    b[i] = 0.0f;
            }

            // .. and solve it for best fit.
            #error "You need to supply your own SVD routines."
            //num_svd(&a[0][0], m, n, &u[0][0], w, &vt[0][0]);
            //num_svd_backsubst(m, n, &u[0][0], w, &vt[0][0], b, xx, 0.0);

            for ( int i = 0; i < 6; i++ )
            {
                pCoeffs[(y*width+x)*6+i] = xx[i];

                if (xx[i] < MinCoeff[i])
                    MinCoeff[i] = xx[i];

                if (xx[i] > MaxCoeff[i])
                    MaxCoeff[i] = xx[i];
            }
        }
    }

    // Unlock source textures.
    for ( int i = 0; i < g_NumSourceImages; i++ )
    {
        pSourceTextures[i]->UnlockRect( 0 );
    }

    // Determine scale and bias to use.
    double Scale[6];
    double Bias[6];

    for ( int i = 0; i < 6; i++ )
    {
        // Scale is fixed at 2.0 becuase that is what our vertex shader uses.
        Scale[i] = 2.0f;

        // Compute bias.
        Bias[i] = -MinCoeff[i] / Scale[i];

        assert( Bias[i] >= 0.0 && Bias[i] <= 1.0 );

        m_iBias[i] = (int)(Bias[i] * 255.0);
    }

    // Lock and fill the textures
    D3DSURFACE_DESC desc1;
    m_pCoeff1Texture->GetLevelDesc( 0, &desc1 );

    D3DLOCKED_RECT lock1;
    m_pCoeff1Texture->LockRect( 0, &lock1, 0, 0 );

    DWORD* pBits1 = (DWORD*)lock1.pBits;

    D3DSURFACE_DESC desc2;
    m_pCoeff2Texture->GetLevelDesc( 0, &desc2 );

    D3DLOCKED_RECT lock2;
    m_pCoeff2Texture->LockRect( 0, &lock2, 0, 0 );

    DWORD* pBits2 = (DWORD*)lock2.pBits;

    for ( int y = 0; y < height; y++ )
    {
        for ( int x = 0; x < width; x++ )
        {
            unsigned char buf[6];

            for ( int i = 0; i < 6; i++ )
            {
                double value = pCoeffs[(y*width+x)*6+i] / Scale[i] + Bias[i];

                assert( value >= 0.0 && value <= 1.0 );

                buf[i] = (unsigned char)(value * 255.0);
            }

            pBits1[y*width+x] = (buf[0] << 16) | (buf[1] << 8) | buf[2];
            pBits2[y*width+x] = (buf[3] << 16) | (buf[4] << 8) | buf[5];
        }
    }

    delete[] pCoeffs;


    // Save the computed textures.
    DWORD* pTempBits = new DWORD[width*height];

    BITMAPFILEHEADER bf;
    BITMAPINFOHEADER bi;

    bf.bfType = 'MB';
    bf.bfSize = sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER) + width * height * 4;
    bf.bfReserved1 = 0;
    bf.bfReserved2 = 0;
    bf.bfOffBits = sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER);

    bi.biSize = sizeof(BITMAPINFOHEADER);
    bi.biWidth = width;
    bi.biHeight = height;
    bi.biPlanes = 1;
    bi.biBitCount = 32;
    bi.biCompression = 0;
    bi.biSizeImage = width * height * 4;
    bi.biXPelsPerMeter = 2834; 
    bi.biYPelsPerMeter = 2834;
    bi.biClrUsed = 0;
    bi.biClrImportant = 0;

    FILE *fp;

    fp = fopen( "D:\\Media\\Textures\\MoonPoly1.BMP", "wb" );

    fwrite( &bf, sizeof(BITMAPFILEHEADER), 1, fp );
    fwrite( &bi, sizeof(BITMAPINFOHEADER), 1, fp );
    XGUnswizzleRect( pBits1, width, height, NULL, pTempBits, 0, NULL, sizeof(DWORD) );
    fwrite( pTempBits, width*height, 4, fp );

    fclose(fp);

    fp = fopen( "D:\\Media\\Textures\\MoonPoly2.BMP", "wb" );

    fwrite( &bf, sizeof(BITMAPFILEHEADER), 1, fp );
    fwrite( &bi, sizeof(BITMAPINFOHEADER), 1, fp );
    XGUnswizzleRect( pBits2, width, height, NULL, pTempBits, 0, NULL, sizeof(DWORD) );
    fwrite( pTempBits, width*height, 4, fp );

    fclose(fp);

    fp = fopen( "D:\\Media\\Textures\\MoonColor.BMP", "wb" );

    fwrite( &bf, sizeof(BITMAPFILEHEADER), 1, fp );
    fwrite( &bi, sizeof(BITMAPINFOHEADER), 1, fp );
    XGUnswizzleRect( pBitsColor, width, height, NULL, pTempBits, 0, NULL, sizeof(DWORD) );
    fwrite( pTempBits, width*height, 4, fp );

    fclose(fp);

    fp = fopen( "D:\\Media\\MoonCoeffs.txt", "w" );

    for ( int i = 0; i < 6; i++ )
    {
        fprintf(fp, "%d\n", m_iBias[i]);
    }

    fclose(fp);

    delete[] pTempBits;

    
    // Unlock the textures
    m_pCoeff1Texture->UnlockRect( 0 );
    m_pCoeff2Texture->UnlockRect( 0 );
    m_pColorTexture->UnlockRect( 0 );

    return S_OK;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\projectedtexture\projectedtexture.cpp ===
//-----------------------------------------------------------------------------
// File: ProjectedTexture.cpp
//
// Desc: Sample to show off projected textures
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <XBUtil.h>
#include <xgraphics.h>




//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_LEFTSTICK,    XBHELP_PLACEMENT_2, L"Rotate\ncube" },
    { XBHELP_RIGHTSTICK,   XBHELP_PLACEMENT_2, L"Move projection\ndirection\n" },
    { XBHELP_X_BUTTON,     XBHELP_PLACEMENT_2, L"Show\nfrustrum" },
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_1, L"Display help" },
    { XBHELP_MISC_CALLOUT, XBHELP_PLACEMENT_2, L"W/left trigger, the right stick\nmoves projection point" },
};

#define NUM_HELP_CALLOUTS 5




//-----------------------------------------------------------------------------
// Globals variables and definitions
//-----------------------------------------------------------------------------

struct PROJTEXVERTEX
{
    D3DXVECTOR3 p;
    D3DCOLOR    color;
};

#define D3DFVF_PROJTEXVERTEX (D3DFVF_XYZ|D3DFVF_DIFFUSE)




//----------------------------------------------------------------------------
// projection frustrum
struct LINEVERTEX
{
    FLOAT x, y, z;
    DWORD color;
};

LINEVERTEX g_FrustumLines[] =
{
    {  0.0f, 0.0f, 0.0f, 0xffffffff },
    {  1.0f, 1.0f, 1.0f, 0xffffffff },

    {  0.0f, 0.0f, 0.0f, 0xffffffff },
    { -1.0f, 1.0f, 1.0f, 0xffffffff },

    {  0.0f, 0.0f, 0.0f, 0xffffffff },
    {  1.0f,-1.0f, 1.0f, 0xffffffff },

    {  0.0f, 0.0f, 0.0f, 0xffffffff },
    { -1.0f,-1.0f, 1.0f, 0xffffffff },
};




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBFont                m_Font;
    CXBHelp                m_Help;
    BOOL                   m_bDrawHelp;

    BOOL                   m_bDrawFrustrum;

    PROJTEXVERTEX          m_vCube[36];      // Mesh vertex data
    LPDIRECT3DTEXTURE8     m_pSpotLightTexture;   // procedurally generated spotlight texture

    D3DXMATRIX             m_matTexProj;   // texture projection matrix

    D3DXVECTOR3            m_vTexEyePt;    // texture eye pt.
    D3DXVECTOR3            m_vTexLookatPt; // texture lookat pt.

    VOID    CalculateTexProjMatrix();
    HRESULT CreateSpotLightTexture( BOOL bBorder );
    VOID    ShowTexture( LPDIRECT3DTEXTURE8 pTexture );

public:
    HRESULT Initialize();
    HRESULT Render();
    HRESULT FrameMove();

    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    m_bDrawHelp         = FALSE;

    m_pSpotLightTexture = NULL;

    m_vTexEyePt    = D3DXVECTOR3(-2.0f, -2.0f, -7.0f );
    m_vTexLookatPt = D3DXVECTOR3( 0.0f,  0.0f,  0.0f );

    // Cube vertices
    m_vCube[ 0].p = D3DXVECTOR3( 2.0f, 2.0f,-2.0f); m_vCube[ 0].color = 0xff0080ff;
    m_vCube[ 1].p = D3DXVECTOR3(-2.0f, 2.0f,-2.0f); m_vCube[ 1].color = 0xff0080ff;
    m_vCube[ 2].p = D3DXVECTOR3(-2.0f, 2.0f, 2.0f); m_vCube[ 2].color = 0xff0080ff;
    m_vCube[ 3].p = D3DXVECTOR3( 2.0f, 2.0f, 2.0f); m_vCube[ 3].color = 0xff0080ff;
    m_vCube[ 4].p = D3DXVECTOR3( 2.0f, 2.0f,-2.0f); m_vCube[ 4].color = 0xff0080ff;
    m_vCube[ 5].p = D3DXVECTOR3(-2.0f, 2.0f, 2.0f); m_vCube[ 5].color = 0xff0080ff;

    m_vCube[ 6].p = D3DXVECTOR3(-2.0f,-2.0f,-2.0f); m_vCube[ 6].color = 0xffff00ff;
    m_vCube[ 7].p = D3DXVECTOR3( 2.0f,-2.0f,-2.0f); m_vCube[ 7].color = 0xffff00ff;
    m_vCube[ 8].p = D3DXVECTOR3( 2.0f,-2.0f, 2.0f); m_vCube[ 8].color = 0xffff00ff;
    m_vCube[ 9].p = D3DXVECTOR3(-2.0f,-2.0f, 2.0f); m_vCube[ 9].color = 0xffff00ff;
    m_vCube[10].p = D3DXVECTOR3(-2.0f,-2.0f,-2.0f); m_vCube[10].color = 0xffff00ff;
    m_vCube[11].p = D3DXVECTOR3( 2.0f,-2.0f, 2.0f); m_vCube[11].color = 0xffff00ff;

    m_vCube[12].p = D3DXVECTOR3( 2.0f,-2.0f,-2.0f); m_vCube[12].color = 0xff00ff00;
    m_vCube[13].p = D3DXVECTOR3( 2.0f, 2.0f,-2.0f); m_vCube[13].color = 0xff00ff00;
    m_vCube[14].p = D3DXVECTOR3( 2.0f, 2.0f, 2.0f); m_vCube[14].color = 0xff00ff00;
    m_vCube[15].p = D3DXVECTOR3( 2.0f,-2.0f, 2.0f); m_vCube[15].color = 0xff00ff00;
    m_vCube[16].p = D3DXVECTOR3( 2.0f,-2.0f,-2.0f); m_vCube[16].color = 0xff00ff00;
    m_vCube[17].p = D3DXVECTOR3( 2.0f, 2.0f, 2.0f); m_vCube[17].color = 0xff00ff00;

    m_vCube[18].p = D3DXVECTOR3(-2.0f, 2.0f,-2.0f); m_vCube[18].color = 0xff808000;
    m_vCube[19].p = D3DXVECTOR3(-2.0f,-2.0f,-2.0f); m_vCube[19].color = 0xff808000;
    m_vCube[20].p = D3DXVECTOR3(-2.0f,-2.0f, 2.0f); m_vCube[20].color = 0xff808000;
    m_vCube[21].p = D3DXVECTOR3(-2.0f, 2.0f, 2.0f); m_vCube[21].color = 0xff808000;
    m_vCube[22].p = D3DXVECTOR3(-2.0f, 2.0f,-2.0f); m_vCube[22].color = 0xff808000;
    m_vCube[23].p = D3DXVECTOR3(-2.0f,-2.0f, 2.0f); m_vCube[23].color = 0xff808000;

    m_vCube[24].p = D3DXVECTOR3( 2.0f,-2.0f,-2.0f); m_vCube[24].color = 0xff0000ff;
    m_vCube[25].p = D3DXVECTOR3(-2.0f,-2.0f,-2.0f); m_vCube[25].color = 0xff0000ff;
    m_vCube[26].p = D3DXVECTOR3(-2.0f, 2.0f,-2.0f); m_vCube[26].color = 0xff0000ff;
    m_vCube[27].p = D3DXVECTOR3( 2.0f, 2.0f,-2.0f); m_vCube[27].color = 0xff0000ff;
    m_vCube[28].p = D3DXVECTOR3( 2.0f,-2.0f,-2.0f); m_vCube[28].color = 0xff0000ff;
    m_vCube[29].p = D3DXVECTOR3(-2.0f, 2.0f,-2.0f); m_vCube[29].color = 0xff0000ff;

    m_vCube[30].p = D3DXVECTOR3(-2.0f,-2.0f, 2.0f); m_vCube[30].color = 0xffff0000;
    m_vCube[31].p = D3DXVECTOR3( 2.0f,-2.0f, 2.0f); m_vCube[31].color = 0xffff0000;
    m_vCube[32].p = D3DXVECTOR3( 2.0f, 2.0f, 2.0f); m_vCube[32].color = 0xffff0000;
    m_vCube[33].p = D3DXVECTOR3(-2.0f, 2.0f, 2.0f); m_vCube[33].color = 0xffff0000;
    m_vCube[34].p = D3DXVECTOR3(-2.0f,-2.0f, 2.0f); m_vCube[34].color = 0xffff0000;
    m_vCube[35].p = D3DXVECTOR3( 2.0f, 2.0f, 2.0f); m_vCube[35].color = 0xffff0000;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create the font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Set the view matrix
    D3DXVECTOR3 vEyePt    = D3DXVECTOR3( 0.0f, 0.0f,-15.0f );
    D3DXVECTOR3 vLookatPt = D3DXVECTOR3( 0.0f, 0.0f,  0.0f );
    D3DXMATRIX  matView;
    D3DXMatrixLookAtLH( &matView, &vEyePt, &vLookatPt, &D3DXVECTOR3(0.0f,1.0f,0.0f) );
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );

    // Set the projection matrix
    D3DXMATRIX matProj;
    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/4, 4.0f/3.0f, 1.0f, 200.0f );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );

    // Set up a point light
    D3DLIGHT8 light;
    XBUtil_InitLight( light, D3DLIGHT_POINT, 0.0f, 0.0f, -10.0f );
    light.Attenuation0 = 0.0f;
    light.Attenuation1 = 0.0f;
    light.Attenuation2 = 1.0f;
    m_pd3dDevice->SetLight( 0, &light );
    m_pd3dDevice->LightEnable( 0, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_AMBIENT, 0x00333333 );

    // Set a default white material
    D3DMATERIAL8 mtrl;
    XBUtil_InitMaterial( mtrl, 1.0f, 1.0f, 1.0f );
    m_pd3dDevice->SetMaterial( &mtrl );

    // Create the texture for our procedural spotlight texmap
    m_bDrawFrustrum = TRUE;
    CreateSpotLightTexture( m_bDrawFrustrum );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CreateSpotLightTexture()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::CreateSpotLightTexture( BOOL bBorder )
{
    // Release the old texture
    SAFE_RELEASE( m_pSpotLightTexture );

    // Create a new texture
    m_pd3dDevice->CreateTexture( 128, 128, 1, 0, D3DFMT_X8R8G8B8, 
                                 D3DPOOL_DEFAULT, &m_pSpotLightTexture );

    D3DLOCKED_RECT lock;
    m_pSpotLightTexture->LockRect( 0, &lock, NULL, 0L );

    D3DSURFACE_DESC desc;
    m_pSpotLightTexture->GetLevelDesc( 0, &desc );
    DWORD* pBits    = (DWORD*)lock.pBits;
    DWORD* pLine    = (DWORD*)lock.pBits;
    DWORD  dwStride = lock.Pitch / sizeof(DWORD);

    // Generate the spotlight tex
    for( DWORD y = 0; y < 128; y++ )
    {
        for( DWORD x = 0; x < 128; x++ )
        {
            FLOAT dx = ( 64.0f - x + 0.5f ) / 64.0f;
            FLOAT dy = ( 64.0f - y + 0.5f ) / 64.0f;
            FLOAT r  = cosf( sqrtf( dx*dx + dy*dy ) * D3DX_PI / 2.0f );
            r = (r > 0.0f) ? r*r : 0.0f;
            int c = (int)min((r*r + 0.15f) * 0xff, 0xff);

            pLine[x] = 0xff000000 + 0x00010101*c;
        }

        pLine += dwStride;
    }

    if( bBorder )
    {
        // Draw border around spotlight texture
        DWORD* pLineX1 = (DWORD*)pBits + dwStride;
        DWORD* pLineX2 = (DWORD*)pBits + dwStride * (128 - 2);
        DWORD* pLineY1 = (DWORD*)pBits + 1;
        DWORD* pLineY2 = (DWORD*)pBits + dwStride - 2;

        for( DWORD x = 0; x < 128; x++ )
        {
            if( x != 0 && x != 127 )
            {
                *pLineX1 = *pLineX2 = 0xffffffff;
                *pLineY1 = *pLineY2 = 0xffffffff;
            }

            pLineX1 += 1;
            pLineX2 += 1;
            pLineY1 += dwStride;
            pLineY2 += dwStride;
        }
    }

    // Swizzle and unlock the texture
    XBUtil_SwizzleTexture2D( &lock, &desc );
    m_pSpotLightTexture->UnlockRect(0);

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: ShowTexture()
// Desc: 
//-----------------------------------------------------------------------------
VOID CXBoxSample::ShowTexture( LPDIRECT3DTEXTURE8 pTexture )
{
    D3DSURFACE_DESC d3dsd;
    pTexture->GetLevelDesc( 0, &d3dsd );
    FLOAT x1 = 50.0f, x2 = x1 + (FLOAT)d3dsd.Width;
    FLOAT y1 = 50.0f, y2 = x1 + (FLOAT)d3dsd.Height;

    struct SPRITEVERTEX
    {
        FLOAT sx, sy, sz, rhw;
        FLOAT tu, tv;
    };
    
    SPRITEVERTEX vSprite[4] =
    {
        { x1-0.5f, y1-0.5f, 0.99f, 1.0f,  0.0f, 0.0f },
        { x2-0.5f, y1-0.5f, 0.99f, 1.0f,  1.0f, 0.0f },
        { x2-0.5f, y2-0.5f, 0.99f, 1.0f,  1.0f, 1.0f },
        { x1-0.5f, y2-0.5f, 0.99f, 1.0f,  0.0f, 1.0f },
    };

    // Set state
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1,  D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,    D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,    D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_DISABLE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXCOORDINDEX, 0 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_POINT );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_POINT );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING, FALSE );

    // Display the sprite
    m_pd3dDevice->SetTexture( 0, pTexture );
    m_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_TEX1 );
    m_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLEFAN, 2, vSprite, sizeof(SPRITEVERTEX) );
}




//-----------------------------------------------------------------------------
// Name: CalculateTexProjMatrix()
// Desc: 
//-----------------------------------------------------------------------------
VOID CXBoxSample::CalculateTexProjMatrix()
{
    // Get the current view matrix
    D3DXMATRIX matView, matInvView;
    m_pd3dDevice->GetTransform( D3DTS_VIEW, &matView );
    D3DXMatrixInverse( &matInvView,  NULL, &matView );

    // Compute view matrix
    D3DXMATRIX matTexView;
    D3DXMatrixLookAtLH( &matTexView, &m_vTexEyePt, &m_vTexLookatPt, &D3DXVECTOR3(0.0f,1.0f,0.0f) );
    
    // Compute projection matrix
    D3DXMATRIX matTexProj;
    D3DXMatrixPerspectiveFovLH( &matTexProj, D3DX_PI/6, 1.0f, 1.0f, 200.0f );

    D3DXMATRIX matScale;
    D3DXMatrixIdentity( &matScale );
    matScale._11 = 0.5f;
    matScale._22 = 0.5f;

    D3DXMATRIX matBias;
    D3DXMatrixIdentity( &matBias );
    matBias._31 = 0.5f;
    matBias._32 = 0.5f;

    D3DXMatrixIdentity( &m_matTexProj );
    D3DXMatrixMultiply( &m_matTexProj, &m_matTexProj, &matInvView ); // Transform cameraspaceposition to worldspace
    D3DXMatrixMultiply( &m_matTexProj, &m_matTexProj, &matTexView ); // Transform to worldspace
    D3DXMatrixMultiply( &m_matTexProj, &m_matTexProj, &matTexProj ); // Situate verts relative to projector's view
    D3DXMatrixMultiply( &m_matTexProj, &m_matTexProj, &matScale );   // Scale and bias to map the near clipping plane to texcoords
    D3DXMatrixMultiply( &m_matTexProj, &m_matTexProj, &matBias );    // Scale and bias to map the near clipping plane to texcoords

    // Convert from homogeneous texmap coords to worldspace
    D3DXMATRIX matInvTexView, matInvTexProj;
    D3DXMatrixInverse( &matInvTexView, NULL, &matTexView );
    D3DXMatrixInverse( &matInvTexProj, NULL, &matTexProj );          

    for( int i = 0; i < 8; i++ )
    {
        D3DXVECTOR4 vT( 0.0f, 0.0f, 0.0f, 1.0f );
        vT.x = (i%2) * ( i&0x2 ? -1.0f : 1.0f );
        vT.y = (i%2) * ( i&0x4 ? -1.0f : 1.0f );
        vT.z = (i%2) * ( 1.0f );

        D3DXVec4Transform( &vT, &vT, &matInvTexProj );
        D3DXVec4Transform( &vT, &vT, &matInvTexView );

        g_FrustumLines[i].x = vT.x / vT.w;
        g_FrustumLines[i].y = vT.y / vT.w;
        g_FrustumLines[i].z = vT.z / vT.w;
    }
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK )
        m_bDrawHelp = !m_bDrawHelp;

    // Toggle drawing of the projection frustum
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_X] )
    {
        m_bDrawFrustrum = !m_bDrawFrustrum;
        CreateSpotLightTexture( m_bDrawFrustrum );
    }

    // Perform a basic arcball rotation
    static D3DXMATRIX matWorld( 1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1 );
    D3DXMATRIX matRotate;
    FLOAT fXRotate = m_DefaultGamepad.fX1 * m_fElapsedTime * D3DX_PI * 0.5f;
    FLOAT fYRotate = m_DefaultGamepad.fY1 * m_fElapsedTime * D3DX_PI * 0.5f;
    D3DXMatrixRotationYawPitchRoll( &matRotate, -fXRotate, -fYRotate, 0.0f );
    D3DXMatrixMultiply( &matWorld, &matWorld, &matRotate );
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld );
    
    if( m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER] )
    {
        // Move texture-projection eye point
        m_vTexEyePt.x += m_DefaultGamepad.fX2 * m_fElapsedTime * 5.0f;
        m_vTexEyePt.y += m_DefaultGamepad.fY2 * m_fElapsedTime * 5.0f;
    }
    else
    {
        // Move where the texture-projection is being projected to
        m_vTexLookatPt.x += m_DefaultGamepad.fX2 * m_fElapsedTime * 5.0f;
        m_vTexLookatPt.y += m_DefaultGamepad.fY2 * m_fElapsedTime * 5.0f;
    }

    // Recalculate our texture projection matrix
    CalculateTexProjMatrix();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    m_pd3dDevice->Clear( 0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL, 0x00000000, 1.0f, 0L );

    // Draw a gradient filled background
    RenderGradientBackground( 0xff0000ff, 0xff000000 );

    // Set default render states
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,  TRUE );

    // Draw our SpotLight texture in upper left
    if( m_bDrawFrustrum )
        ShowTexture( m_pSpotLightTexture );

    // Set up texture and states to draw the projected spotlight
    m_pd3dDevice->SetTexture( 1, m_pSpotLightTexture );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_ADD );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLORARG2, D3DTA_CURRENT );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ADDRESSU,  D3DTADDRESS_CLAMP );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ADDRESSV,  D3DTADDRESS_CLAMP );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );

    // Enable texture transforms
    m_pd3dDevice->SetTransform( D3DTS_TEXTURE1, &m_matTexProj );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_PROJECTED | D3DTTFF_COUNT3 );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_TEXCOORDINDEX,         D3DTSS_TCI_CAMERASPACEPOSITION );

    // Draw the cube
    m_pd3dDevice->SetVertexShader( D3DFVF_PROJTEXVERTEX );
    m_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLELIST, 12, 
                                   m_vCube, sizeof(PROJTEXVERTEX) );
    
    // Draw texture projection frustrum
    if( m_bDrawFrustrum )
    {
        D3DXMATRIX matIdentity;
        D3DXMatrixIdentity( &matIdentity );
        m_pd3dDevice->SetTransform( D3DTS_WORLD, &matIdentity );
        m_pd3dDevice->SetVertexShader( D3DFVF_XYZ|D3DFVF_DIFFUSE );
        m_pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 4, g_FrustumLines, 
                                       sizeof(g_FrustumLines[0]) );
    }

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        m_Font.Begin();
        m_Font.DrawText(  64, 50, 0xffffffff, L"ProjectedTexture" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );
        m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\shadowbuffer\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\shadowbuffer\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\PushBuffer\PushBuffer.cpp ===
//-----------------------------------------------------------------------------
// File: PushBuffer.cpp
//
// Desc: Demonstrates using static pushbuffers. Pushbuffers can be thought of
//       as display lists or instruction buffers to the GPU. Rather than
//       rendering a scene via a myriad of D3D calls each frame, the calls can
//       be recorded into a static pushpuffer. Any dynamic data within a
//       pushbuffer, such as vertex shader constants that control the rotation
//       of an object, can be modified on the fly via "fixup" objects.
//
// Hist: 03.20.01 - New for April XDK
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <XBMesh.h>
#include <XBUtil.h>




//------------------------------------------------------------------------------
// Define a triangle.
//------------------------------------------------------------------------------
struct VERTEX
{ 
    FLOAT x,y,z; 
    DWORD color; 
};

VERTEX m_Vertices[] =
{
    {-0.666f,  -1.0f, 0.0f, 0xffff0000, },
    { 0.0f,     1.0f, 0.0f, 0xff00ff00, },
    { 0.666f,  -1.0f, 0.0f, 0xff0000ff, },
};




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBFont               m_Font;        // Font for text display

    DWORD                 m_dwVertexShader;
    
    LPDIRECT3DPUSHBUFFER8 m_pPushBufer;  // The static push buffer
    DWORD                 m_dwVertexShaderConstantOffset; // Offset into the push buffer

    LPDIRECT3DFIXUP8      m_pFixups[2];  // Buffer of fixup objects
    DWORD                 m_dwFixup;     // Which fixup is being used
    DWORD                 m_dwFixupSize; // Size of the fixup object

    // The following function is called once, to record the pushbuffer
    HRESULT RecordPushBuffer();

    // The next two functions are called every frame to update the transform
    // matrices (world, view, and projection) and apply the fixups to the
    // pushbuffer.
    VOID    UpdateTransformMatrices( D3DXMATRIX* pmatWVP );
    VOID    ApplyFixups( LPDIRECT3DPUSHBUFFER8 pPushBuffer, 
                         LPDIRECT3DFIXUP8 pFixup, D3DXMATRIX* pmatWVP );

public:
    HRESULT Initialize();                // Initialize the sample
    HRESULT Render();                    // Render the scene
    HRESULT FrameMove();                 // Perform per-frame updates

    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample (constructor)
// Desc: Constructor for CXBoxSample class
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample() 
            :CXBApplication()
{
    m_dwFixup    = 0;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Peforms initialization
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create the font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create vertex shader.
    DWORD dwShaderVertexDecl[] =
    {
        D3DVSD_STREAM( 0 ),
        D3DVSD_REG( 0, D3DVSDT_FLOAT3 ),   // Position
        D3DVSD_REG( 1, D3DVSDT_D3DCOLOR ), // Diffuse color
        D3DVSD_END()
    };

    if( FAILED( XBUtil_CreateVertexShader( m_pd3dDevice, "Shaders\\Shader.xvu",
                                           dwShaderVertexDecl, &m_dwVertexShader ) ) )
       return E_FAIL;

    //-------------------------------------------------------------------------
    // Create the push buffer
    //-------------------------------------------------------------------------

    // Create a push-buffer, two fix-up buffers that we'll ping-pong between,
    // and a fix-up buffer that we'll use just for determining our fix-up
    // size.
    m_pd3dDevice->CreatePushBuffer( 16 * 4096, FALSE, &m_pPushBufer );

    // Now record the push-buffer.
    RecordPushBuffer();

    //-------------------------------------------------------------------------
    // Determine the fixup size
    //-------------------------------------------------------------------------

    // Create an empty fixup object, which will be used to determine the size
    // needed for fixup objects
    LPDIRECT3DFIXUP8 pEmptyFixup;
    m_pd3dDevice->CreateFixup( 0, &pEmptyFixup );

    // Call the app-dependent function which builds the fixup objects
    D3DXMATRIX mat;
    ApplyFixups( m_pPushBufer, pEmptyFixup, &mat );
    
    // Finally, get the size of the fixup, and release it
    pEmptyFixup->GetSize( &m_dwFixupSize );
    pEmptyFixup->Release();
    
    //-------------------------------------------------------------------------
    // Create the fixup objects
    //-------------------------------------------------------------------------

    // Create two (for double-buffering) fixup objects. These objects will be
    // filled by the app-dependent ApplyFixups() function, and then used when
    // push buffer is rendered.
    m_pd3dDevice->CreateFixup( 1024, &m_pFixups[0] );
    m_pd3dDevice->CreateFixup( 1024, &m_pFixups[1] );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: RecordPushBuffer()
// Desc: Records the push buffer. At any point in recording the push buffer,
//       you can call GetPushBufferOffset() to save offsets where you can later
//       fix up the data there.
//
//       Note that the following APIs are not permitted while recording a push-buffer:
//          Present()
//          InsertFence()
//          CopyRects()
//          UpdateTexture()
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::RecordPushBuffer()
{
    // Note that this matrix isn't initialized, which is okay because we'll
    // always fix it (the push buffer) up before playback.
    D3DXMATRIX mat;

    // Start recording the push buffer. 
    m_pd3dDevice->BeginPushBuffer( m_pPushBufer );

    // Set some state
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG2 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE,         D3DCULL_NONE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );

    // At this point, save the push buffer offset so we know exactly where to
    // fixup the push shader before rendering it
    m_pd3dDevice->GetPushBufferOffset( &m_dwVertexShaderConstantOffset );
    m_pd3dDevice->SetVertexShaderConstant( 0, &mat, 4 );

    // Draw the vertex streamsetup in stream 0.
    m_pd3dDevice->SetVertexShader( m_dwVertexShader );
    m_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLELIST, 1, m_Vertices, 
                                   sizeof(m_Vertices[0]) );

    // Stop recording the push buffer
    m_pd3dDevice->EndPushBuffer();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: UpdateTransformMatrices()
// Desc: Rotates the world, and builds the world, view, and proj matrices.
//-----------------------------------------------------------------------------
VOID CXBoxSample::UpdateTransformMatrices( D3DXMATRIX* pmatWVP )
{
    // Rotate around the Y axis
    D3DXMATRIX matWorld;
    D3DXMatrixRotationY( &matWorld, m_fAppTime );

    // Set up our view matrix.
    D3DXMATRIX matView;
    D3DXMatrixLookAtLH( &matView, &D3DXVECTOR3( 0.0f, 0.0f,-3.0f ), 
                                  &D3DXVECTOR3( 0.0f, 0.0f, 0.0f ), 
                                  &D3DXVECTOR3( 0.0f, 1.0f, 0.0f ) );

    // Set up our projection matrix.
    D3DXMATRIX matProj;
    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/4, 480.0f/640.0f, 1.0f, 800.0f );

    // Calculate concatenated World x ( View x Projection) matrix.
    D3DXMatrixMultiply( pmatWVP, &matWorld, &matView );
    D3DXMatrixMultiply( pmatWVP, pmatWVP,   &matProj );
}




//-----------------------------------------------------------------------------
// Name: ApplyFixups()
// Desc: Fixes up the pushbuffer.
//
//       Note that when fixing up a push buffer, any of the following functions
//       can be used:
//          RunPushBuffer()
//          SetModelView()
//          SetVertexBlendModelView()
//          SetVertexShaderInput()
//          SetRenderTarget()
//          SetTexture()
//          SetPalette()
//          EndVisibilityTest()
//          SetVertexShaderConstant()
//-----------------------------------------------------------------------------
VOID CXBoxSample::ApplyFixups( LPDIRECT3DPUSHBUFFER8 pPushBuffer, 
                               LPDIRECT3DFIXUP8 pFixup, 
                               D3DXMATRIX* pmatWVP )
{
    // Begin the pushbuffer fixup
    m_pPushBufer->BeginFixup( pFixup, 0 );

    // Pass the new matrix (don't forget to transpose it) to the vertex shader.
    // The offset value used here was determined when the pushbuffer was
    // recorded.
    D3DXMATRIX matWVPT;
    D3DXMatrixTranspose( &matWVPT, pmatWVP );
    m_pPushBufer->SetVertexShaderConstant( m_dwVertexShaderConstantOffset, 0, &matWVPT, 4 );
    
    // End the pushbuffer fixup
    m_pPushBufer->EndFixup();
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    D3DXMATRIX mat;
    UpdateTransformMatrices( &mat );

    // Chheck the space of the current fixup object
    DWORD dwSpace;
    m_pFixups[m_dwFixup]->GetSpace( &dwSpace );

    // Check if we overflowed the fix-up buffer that we wanted to use. If so,
    // use the other fixup buffer
    if( dwSpace < m_dwFixupSize )
    {
        // Note: If we tried to reset the same buffer we were just using, D3D
        // would have to sit and spin until the GPU is idle, since we just
        // used that buffer.
        m_dwFixup = (m_dwFixup+1) % 2;
        m_pFixups[m_dwFixup]->Reset();
    }

    // Okay, do the fix-up for real
    ApplyFixups( m_pPushBufer, m_pFixups[m_dwFixup], &mat );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Dets up render states, clears the viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Clear the render target and z-buffer
    m_pd3dDevice->Clear( 0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL,
                         0xff0000ff, 1.0, 0 );

    // Actually run the push-buffer, which renders the whole scene.
    m_pd3dDevice->RunPushBuffer( m_pPushBufer, m_pFixups[m_dwFixup] );

    // Draw the app title
    m_Font.Begin();
    m_Font.DrawText(  64, 48, 0xffffffff, L"PushBuffer" );
    m_Font.DrawText( 450, 48, 0xffffff00, m_strFrameRate );
    m_Font.End();

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\stencilbuffer\shadowvolume\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\stencilbuffer\shadowvolume\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\stencilbuffer\shadowvolume\makefile.inc ===
!include "..\..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\shadowbuffer\shadowbuffer.cpp ===
//-----------------------------------------------------------------------------
// File: ShadowBuffer.cpp
//
// Desc: Illustrates how to do shadow buffering on the XBox.
//
// Hist: 06.06.01 - Adding start/stop capability
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include "resource.h"
#include "xpath.h"
#include "xmenu.h"
#include "xobj.h"




//-----------------------------------------------------------------------------
// ASCII names for the resources used by the app
//-----------------------------------------------------------------------------
XBRESOURCE g_ResourceNames[] = 
{
    { "Floor.bmp",  resource_Floor_OFFSET },
    { "Wings.bmp",  resource_Wings_OFFSET },
    { "BiHull.bmp", resource_BiHull_OFFSET },
    { NULL, 0 },
};

extern CXBPackedResource* g_pModelResource;




//-----------------------------------------------------------------------------
// Shadowbuffer types
//-----------------------------------------------------------------------------
#define SHADOWBUFFERTYPE_D16    0
#define SHADOWBUFFERTYPE_D24S8  1
#define SHADOWBUFFERTYPE_F16    2
#define SHADOWBUFFERTYPE_F24S8  3

// Z ranges for all buffer types
float g_fShadowBufferZRange[4] = { D3DZ_MAX_D16, D3DZ_MAX_D24S8, 
                                   D3DZ_MAX_F16, (float)D3DZ_MAX_F24S8 };

// Descriptions
WCHAR g_fShadowBufferDesc[4][8] = { L"D16", L"D24S8", L"F16", L"F24S8" };

// Shadow buffer width and height.
const int SHADOWBUFFERWIDTH  = 512;
const int SHADOWBUFFERHEIGHT = 512;



//-----------------------------------------------------------------------------
// Projection frustrum
//-----------------------------------------------------------------------------
struct LINEVERTEX
{
    FLOAT x, y, z;
    DWORD color;
};


D3DXVECTOR4 g_vHomogenousFrustum[8] =
{
    D3DXVECTOR4( 1.0f, 1.0f, 0.0f, 1.0f ),
    D3DXVECTOR4( 1.0f, 1.0f, 1.0f, 1.0f ),

    D3DXVECTOR4(-1.0f, 1.0f, 0.0f, 1.0f ),
    D3DXVECTOR4(-1.0f, 1.0f, 1.0f, 1.0f ),

    D3DXVECTOR4(-1.0f,-1.0f, 0.0f, 1.0f ),
    D3DXVECTOR4(-1.0f,-1.0f, 1.0f, 1.0f ),

    D3DXVECTOR4( 1.0f,-1.0f, 0.0f, 1.0f ),
    D3DXVECTOR4( 1.0f,-1.0f, 1.0f, 1.0f ),
};


LINEVERTEX g_vFrustumLines[8] =
{
    { 1.0f, 1.0f, 0.0f, 0xffffffff },
    { 1.0f, 1.0f, 1.0f, 0xffffffff },

    {-1.0f, 1.0f, 0.0f, 0xffffffff },
    {-1.0f, 1.0f, 1.0f, 0xffffffff },

    {-1.0f,-1.0f, 0.0f, 0xffffffff },
    {-1.0f,-1.0f, 1.0f, 0xffffffff },

    { 1.0f,-1.0f, 0.0f, 0xffffffff },
    { 1.0f,-1.0f, 1.0f, 0xffffffff },
};



//-----------------------------------------------------------------------------
// Help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_LEFTSTICK,    XBHELP_PLACEMENT_1, L"Move light" },
    { XBHELP_RIGHTSTICK,   XBHELP_PLACEMENT_1, L"Move camera" },
    { XBHELP_DPAD,         XBHELP_PLACEMENT_2, L"Adjust\nZ offset/slope" },
    { XBHELP_A_BUTTON,     XBHELP_PLACEMENT_1, L"Toggle rotation" },
    { XBHELP_BLACK_BUTTON, XBHELP_PLACEMENT_1, L"Toggle frustum" },
    { XBHELP_WHITE_BUTTON, XBHELP_PLACEMENT_2, L"Change\nZ-buffer format" },
    { XBHELP_LEFT_BUTTON,  XBHELP_PLACEMENT_1, L"Zoom Out" },
    { XBHELP_RIGHT_BUTTON, XBHELP_PLACEMENT_1, L"Zoom In" },
    { XBHELP_START_BUTTON, XBHELP_PLACEMENT_1, L"Pause" },
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_1, L"Display help" },
};

#define NUM_HELP_CALLOUTS (sizeof(g_HelpCallouts)/sizeof(g_HelpCallouts[0]))




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBFont     m_Font;
    CXBHelp     m_Help;
    BOOL        m_bDrawHelp;
    
    CXBPackedResource  m_xprResource;

    D3DXMATRIX  m_matProj;
    D3DXMATRIX  m_matShadowProj;
    D3DXVECTOR3 m_vCameraPos;
    D3DXVECTOR3 m_vCameraRot;
    D3DXMATRIX  m_matView;

    D3DXVECTOR3 m_vLightPos;
    D3DXMATRIX  m_matTexture;                    // Texture projection matrix

    CXObject    m_FloorObj;
    CXObject    m_Obj;
    CXObject    m_LightObj;

    float       m_fObjRadius;

    LPDIRECT3DSURFACE8 m_pShadowBufferTarget;
    LPDIRECT3DTEXTURE8 m_pShadowBufferDepth;    // Shadow buffer depth texture

    LPDIRECT3DSURFACE8 m_pRenderTarget;
    LPDIRECT3DSURFACE8 m_pZBuffer;              // Back buffer depth surface

    D3DSurface  m_FakeTarget;

    DWORD       m_dwShadowBufVS;                // Shadow buffer vertex shader
    DWORD       m_dwShadowBufPS;                // Shadow buffer pixel shader

    DWORD       m_dwShadowBufferType;           // Shadowbuffer type
    float       m_fZOffset;                     // Shadowbuffer z offset
    float       m_fZSlopeScale;                 // Shadowbuffer z slope scale

    BOOL        m_bRotateFlag;                  // Object rotate flag
    BOOL        m_bDrawFrustum;                 // Draw frustum flag

public:
    HRESULT Initialize();
    HRESULT FrameMove();
    HRESULT Render();
    HRESULT InitPixelShader();

    HRESULT DisplaySBObject(CXObject *obj);

    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program. Initializes everything, and goes into a
//       message-processing loop. Idle time is used to render the scene.
//-----------------------------------------------------------------------------
void __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    m_vCameraPos = D3DXVECTOR3(0.0f, 20.0f, -30.0f);
    m_vCameraRot = D3DXVECTOR3(0.0f, 0.0f, 0.0f);

    m_fZOffset = 4.0f;
    m_fZSlopeScale = 2.0f;
    m_bRotateFlag = true;
    m_bDrawFrustum = true;
    m_bDrawHelp = false;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Initialize device-dependant objects.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    D3DXVECTOR3 v;

    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create our vertex shader
    DWORD vdecl[] =
    {
        D3DVSD_STREAM(0),
        D3DVSD_REG(0, D3DVSDT_FLOAT3), // v0 = XYZ
        D3DVSD_REG(1, D3DVSDT_FLOAT3), // v1 = normals
        D3DVSD_REG(2, D3DVSDT_FLOAT2), // v2 = TEX1
        D3DVSD_END()
    };

    if( FAILED( XBUtil_CreateVertexShader( m_pd3dDevice, "shaders\\vshader.xvu", vdecl, &m_dwShadowBufVS ) ) )
        return E_FAIL;

    if( FAILED( XBUtil_CreatePixelShader( m_pd3dDevice, "shaders\\shadwbuf.xpu", &m_dwShadowBufPS ) ) )
        return E_FAIL;

    // Set projection transform
    D3DXMatrixPerspectiveFovLH( &m_matProj, D3DX_PI/4, 640.0f/480.0f, 1.0f, 1000.0f );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &m_matProj );

    // Create the resources
    if( FAILED( m_xprResource.Create( m_pd3dDevice, "Resource.xpr", 
                                      resource_NUM_RESOURCES, g_ResourceNames ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Set the resource globally so the CXModel can access textures
    g_pModelResource = &m_xprResource;

    // Set base path to point to our data. All the _FNA commands use this
    XPath_SetBasePath( _T("d:\\media\\") );

    // Floor
    m_FloorObj.m_Model = new CXModel;
    m_FloorObj.m_Model->GridXZ(16, 16, 80.0f, 80.0f, FVF_XYZNORMTEX1, "Floor.bmp", 10.0f, 10.0f);

    // Object
    CXBMesh *xbm = new CXBMesh;
    xbm->Create(g_pd3dDevice, "Models\\Airplane.xbg", &m_xprResource);
    m_Obj.SetXBMesh(xbm);
    m_Obj.SetPosition(0.0f, 4.0f, 0.0f);
    m_Obj.SetRotation(-1.5708f, 0.0f, 0.0f);
    m_fObjRadius = m_Obj.GetRadius();

    // Light
    m_LightObj.m_Model = new CXModel;
    m_LightObj.m_Model->Cylinder( 0.2f, 0xc0ffffff, 0.5f, 0x00ffffff, 0.6f, 16, FVF_XYZDIFF, NULL, 1.0f );
    m_LightObj.SetPosition( 10.0f, 10.0f, 0.0f );

    // Create shadow buffer
    m_pd3dDevice->CreateTexture( SHADOWBUFFERWIDTH, SHADOWBUFFERHEIGHT, 1, 0, 
                                 D3DFMT_LIN_D16, 0, &m_pShadowBufferDepth );
    m_dwShadowBufferType = SHADOWBUFFERTYPE_D16;

    // Setup dummy color buffer (bad things will happen if you write to it).
    ZeroMemory( &m_FakeTarget, sizeof(m_FakeTarget) );
    XGSetSurfaceHeader( SHADOWBUFFERWIDTH, SHADOWBUFFERHEIGHT, D3DFMT_LIN_R5G6B5,
                        &m_FakeTarget, 0, 0 );

    m_pShadowBufferTarget = &m_FakeTarget;

    // Get original color and z-buffer.
    m_pd3dDevice->GetDepthStencilSurface( &m_pZBuffer );
    m_pd3dDevice->GetRenderTarget( &m_pRenderTarget );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    D3DXVECTOR3 up(0.0f, 1.0f, 0.0f);
    D3DXMATRIX  mat;

    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK )
        m_bDrawHelp = !m_bDrawHelp;

    // Toggle frustum
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_BLACK] )
        m_bDrawFrustum = !m_bDrawFrustum;

    // Toggle object rotation
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_A] )
        m_bRotateFlag = !m_bRotateFlag;

    // Rotate the object
    if( m_bRotateFlag )
        m_Obj.m_vRotation.y += 1.57f*m_fElapsedAppTime;
    m_Obj.m_vRotation.x = 0.0f;

    // Check for buffer change
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_WHITE] )
    {
        // Release existing depth buffer
        m_pShadowBufferDepth->Release();

        switch( m_dwShadowBufferType )
        {
            case SHADOWBUFFERTYPE_D16:
                m_pd3dDevice->CreateTexture( SHADOWBUFFERWIDTH, SHADOWBUFFERHEIGHT, 1, 0, 
                                             D3DFMT_LIN_D24S8, 0, &m_pShadowBufferDepth );
                m_dwShadowBufferType = SHADOWBUFFERTYPE_D24S8;
                break;
            case SHADOWBUFFERTYPE_D24S8:
                m_pd3dDevice->CreateTexture( SHADOWBUFFERWIDTH, SHADOWBUFFERHEIGHT, 1, 0, 
                                             D3DFMT_LIN_F16, 0, &m_pShadowBufferDepth );
                m_dwShadowBufferType = SHADOWBUFFERTYPE_F16;
                break;
            case SHADOWBUFFERTYPE_F16:
                m_pd3dDevice->CreateTexture( SHADOWBUFFERWIDTH, SHADOWBUFFERHEIGHT, 1, 0, 
                                             D3DFMT_LIN_F24S8, 0, &m_pShadowBufferDepth );
                m_dwShadowBufferType = SHADOWBUFFERTYPE_F24S8;
                break;
            case SHADOWBUFFERTYPE_F24S8:
                m_pd3dDevice->CreateTexture( SHADOWBUFFERWIDTH, SHADOWBUFFERHEIGHT, 1, 0, 
                                             D3DFMT_LIN_D16, 0, &m_pShadowBufferDepth );
                m_dwShadowBufferType = SHADOWBUFFERTYPE_D16;
                break;
        }
    }

    // Adjust z offset
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_UP )
        m_fZOffset += 0.5f;
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_DOWN )
        m_fZOffset -= 0.5f;

    // Adjust z offset slope scale
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_LEFT )
        m_fZSlopeScale += 0.1f;
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_RIGHT )
        m_fZSlopeScale -= 0.1f;

    // Adjust light position
    m_LightObj.m_vPosition.x += m_DefaultGamepad.fX1*m_fElapsedTime*8.0f;
    m_LightObj.m_vPosition.z += m_DefaultGamepad.fY1*m_fElapsedTime*8.0f;

    // Adjust camera position
    D3DXVECTOR3 vAt(0.0f, 4.0f, 0.0f);
    D3DXVECTOR3 vUp(0.0f, 1.0f, 0.0f);

    // Rotate camera around z axis.
    D3DXMATRIX matRotate;
    D3DXMatrixRotationAxis( &matRotate, &vUp, m_DefaultGamepad.fX2*m_fElapsedTime );
    D3DXVec3TransformCoord( &m_vCameraPos, &m_vCameraPos, &matRotate );

    // Rotate camera points around side axis.
    D3DXVECTOR3 vView = (m_vCameraPos - vAt);
    D3DXVec3Normalize(&vView, &vView);

    // Place limits so we dont go over the top or under the bottom.
    FLOAT dot = D3DXVec3Dot(&vView, &vUp);
    if( (dot > -0.99f || m_DefaultGamepad.fY2 < 0.0f) && (dot < 0.99f || m_DefaultGamepad.fY2 > 0.0f) )
    {
        D3DXVECTOR3 axis;
        D3DXVec3Cross( &axis, &vUp, &vView );
        D3DXMatrixRotationAxis( &matRotate, &axis, m_DefaultGamepad.fY2*m_fElapsedTime );
        D3DXVec3TransformCoord( &m_vCameraPos, &m_vCameraPos, &matRotate );
    }

    // In/out based on triggers.
    float fIn = (m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] / 255.0f);
    float fOut = (m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER] / 255.0f);

    if( fIn > 0.1f )
        m_vCameraPos -= vView * 30.0f * fIn * m_fElapsedTime;

    if( fOut > 0.1f )
        m_vCameraPos += vView * 30.0f * fOut * m_fElapsedTime;

    D3DXMatrixLookAtLH( &m_matView, &m_vCameraPos, &vAt, &vUp );

    // Light orientation (looks at object)
    D3DXMatrixLookAtLH( &m_LightObj.m_matOrientation, &m_LightObj.m_vPosition, &m_Obj.m_vPosition, &up );
    D3DXMatrixInverse( &m_LightObj.m_matOrientation, NULL, &m_LightObj.m_matOrientation );

    // Generate the texture transform matrix
    //
    // Note: if you are using multiple lights & shadow buffers, this needs
    // to be calculated for each light.
    //
    // We are starting with worldspace coordinates, so we need to
    // transform from worldspace to lightspace.
    //
    // We go from 3D worldspace to 3D lightspace by multiplying by the
    // inverse of the light matrix.
    // You will probably notice that we are doing two inverses in a row (see previous
    // line of code). I did this to clearly illustrate the steps in generating the
    // texture matrix. The previous line would not always be available.
    D3DXMatrixInverse( &m_matTexture, NULL, &m_LightObj.m_matOrientation );

    // Find a projection that will fit all the objects we want to shadow into the
    // view frustum of the light.
    float fRadius = m_fObjRadius;
    float fDist   = D3DXVec3Length( &(m_Obj.m_vPosition - m_LightObj.m_vPosition) );
    float fNear   = fDist - fRadius;
    float fFar    = fNear + 100.0f;
    float fAngle  = 2.0f * asinf(fRadius / fDist);
    
    D3DXMatrixPerspectiveFovLH( &m_matShadowProj, fAngle, 1.0f, fNear, fFar );

    // Combine the light orientation matrix with the shaowbuffer projection 
    // matrix.  This projects our light space position onto the shadowbuffer 
    // the same way a projection matrix projects a cameraspace coordinate onto 
    // the screen.
    D3DXMatrixMultiply( &m_matTexture, &m_matTexture, &m_matShadowProj );

    // Finally, we scale and offset by SHADOWBUFFERWIDTH/2, SHADOWBUFFERHEIGHT/2
    // to move from [-1,+1] space to [0:0, SHADOWBUFFERWIDTH:SHADOWBUFFERHEIGHT]
    // texture space we also need to scale z by the zbuffer range.  An additional
    // half texel offset is necessary because of the differences between texture
    // addressing and pixel addressing.
    D3DXMatrixIdentity( &mat );

    // Scale
    mat._11 = SHADOWBUFFERWIDTH * 0.5f;
    mat._22 = -SHADOWBUFFERHEIGHT * 0.5f;
    mat._33 = g_fShadowBufferZRange[m_dwShadowBufferType];

    // Offset
    mat._41 = SHADOWBUFFERWIDTH*0.5f + 0.5f;
    mat._42 = SHADOWBUFFERHEIGHT*0.5f + 0.5f;

    D3DXMatrixMultiply( &m_matTexture, &m_matTexture, &mat );

    // m_TextureMat now holds the appropriate transformation matrix
    // for shadowmapping on the XBox GPU.

    // Calculate the frustum lines
    D3DXMATRIX matInvTexProj;
    D3DXMatrixInverse( &matInvTexProj, NULL, &m_matShadowProj );

    for( int i = 0; i < 8; i++ )
    {
        D3DXVECTOR4 vT = g_vHomogenousFrustum[i];

        D3DXVec4Transform( &vT, &vT, &matInvTexProj );
        D3DXVec4Transform( &vT, &vT, &m_LightObj.m_matOrientation );

        g_vFrustumLines[i].x = vT.x / vT.w;
        g_vFrustumLines[i].y = vT.y / vT.w;
        g_vFrustumLines[i].z = vT.z / vT.w;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    D3DXMATRIX m;
    LPDIRECT3DSURFACE8 pSurface;

    // Restore state that text clobbers
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, D3DZB_TRUE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP );

    // Render the scene into the shadow buffer from the viewpoint of the light

    // Set shadowbuffer as render target z buffer & clear it
    m_pShadowBufferDepth->GetSurfaceLevel( 0, &pSurface );

    m_pd3dDevice->SetRenderTarget( m_pShadowBufferTarget, pSurface );

    D3DVIEWPORT8 viewport = { 0, 0, SHADOWBUFFERWIDTH, SHADOWBUFFERHEIGHT, 0.0f, 1.0f };
    m_pd3dDevice->SetViewport( &viewport );

    m_pd3dDevice->Clear( 0, NULL, D3DCLEAR_ZBUFFER, 0, 1.0f, 0 ); 

    D3DXMatrixInverse( &m, NULL, &m_LightObj.m_matOrientation );
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &m );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &m_matShadowProj );
    
    // Disable color writes
    m_pd3dDevice->SetRenderState( D3DRS_COLORWRITEENABLE, 0 );

    // Disable culling so all triangles cause shadows
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );

    // Turn on z-offset.
    m_pd3dDevice->SetRenderState( D3DRS_SOLIDOFFSETENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_POLYGONOFFSETZOFFSET, FtoDW(m_fZOffset) );
    m_pd3dDevice->SetRenderState( D3DRS_POLYGONOFFSETZSLOPESCALE, FtoDW(m_fZSlopeScale) );

    // Render our scene into the shadowbuffer
    m_FloorObj.Render(0);
    m_Obj.Render(0);

    // Restore important state
    m_pd3dDevice->SetRenderTarget( m_pRenderTarget, m_pZBuffer );
    m_pd3dDevice->SetRenderState( D3DRS_COLORWRITEENABLE, D3DCOLORWRITEENABLE_ALL );
    m_pd3dDevice->SetRenderState( D3DRS_SOLIDOFFSETENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_CCW );

    pSurface->Release();

    // Now render the scene from the point of view of the camera
    // with shadow compare functionality enabled

    // Clear the main view
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL, 0xff400000, 1.0f, 0L );
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &m_matView );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &m_matProj );

    // Set shadowbuffer state
    m_pd3dDevice->SetRenderState( D3DRS_SHADOWFUNC, D3DCMP_GREATER );

    // Set shadowbuffer texture
    m_pd3dDevice->SetTexture( 1, m_pShadowBufferDepth );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ADDRESSU, D3DTADDRESS_BORDER );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ADDRESSV, D3DTADDRESS_BORDER );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_BORDERCOLOR, 0xffffffff );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_MINFILTER, D3DTEXF_LINEAR );

    // Set the shadowbuffer pixel shader
    m_pd3dDevice->SetPixelShader( m_dwShadowBufPS );

    // Render the objects in the scene 
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );

    DisplaySBObject( &m_FloorObj );
    DisplaySBObject( &m_Obj );

    // Reset shadowbuffer state
    m_pd3dDevice->SetPixelShader( NULL );
    m_pd3dDevice->SetTexture( 1, NULL );
    m_pd3dDevice->SetRenderState(D3DRS_SHADOWFUNC, D3DCMP_NEVER );

    // Draw the light object
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_DIFFUSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA );
    m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_ONE );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );
    m_LightObj.Render( OBJ_NOMCALCS );
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_CCW );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP, D3DTOP_DISABLE );

    // Draw light frustrum
    if( m_bDrawFrustum )
    {
        m_pd3dDevice->SetTexture( 1, NULL );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_DIFFUSE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
        m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );

        D3DXMATRIX matIdentity;
        D3DXMatrixIdentity( &matIdentity );
        m_pd3dDevice->SetTransform( D3DTS_WORLD, &matIdentity );
        m_pd3dDevice->SetVertexShader( D3DFVF_XYZ|D3DFVF_DIFFUSE );
        m_pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 4, g_vFrustumLines, 
                                       sizeof(g_vFrustumLines[0]) );

        m_pd3dDevice->DrawVerticesUP( D3DPT_LINELOOP, 4, g_vFrustumLines, 
                                      sizeof(g_vFrustumLines[0])*2 );

        m_pd3dDevice->DrawVerticesUP( D3DPT_LINELOOP, 4, g_vFrustumLines+1, 
                                      sizeof(g_vFrustumLines[0])*2 );
    }

    // Show title, frame rate, and help
    if( m_bDrawHelp )
    {
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    }
    else
    {
        m_Font.Begin();
        m_Font.DrawText(  64, 50, 0xffffffff, L"ShadowBuffer" );
        m_Font.DrawText( 640-64, 50, 0xffffff00, m_strFrameRate, XBFONT_RIGHT );

        // Show buffer description
        WCHAR strBuffer[80];
        swprintf( strBuffer, L"Type: %s, ZOffset: %.01f, ZOffset Slope Scale: %.01f", 
                             g_fShadowBufferDesc[m_dwShadowBufferType], 
                             m_fZOffset, m_fZSlopeScale );
        m_Font.DrawText( 64, 70, 0xffffffff, strBuffer );

        m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DisplaySBObject
// Desc: Displays a shadowbuffered object. 
//       The two matrices set up here are the World*View*Projection matrix
//       that transforms the objects points on to the screen, and the
//       World*Texture matrix that transforms the objects points into
//       shadowbuffer space.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::DisplaySBObject( CXObject* pObject )
{
    D3DXMATRIX m, wvpmat, wtmat;

    pObject->CrunchMatrix();                    // Get object orientation matrix

    // WVP matrix
    D3DXMatrixMultiply( &m, &pObject->m_matOrientation, &m_matView );
    D3DXMatrixMultiply( &wvpmat, &m, &m_matProj );
    D3DXMatrixTranspose( &wvpmat, &wvpmat );
    m_pd3dDevice->SetVertexShaderConstant( 0, &wvpmat, 4 );

    // WT matrix
    D3DXMatrixMultiply( &wtmat, &pObject->m_matOrientation, &m_matTexture );
    D3DXMatrixTranspose( &wtmat, &wtmat);
    m_pd3dDevice->SetVertexShaderConstant( 4, &wtmat, 4 );

    // Light position
    D3DXVECTOR4 v4LocalLightPos;
    D3DXMatrixInverse( &m, NULL, &pObject->m_matOrientation );
    D3DXVec3Transform( &v4LocalLightPos, &m_LightObj.m_vPosition, &m );
    m_pd3dDevice->SetVertexShaderConstant( 8, &v4LocalLightPos, 1 );

    // Ambient color
    float fAmbient[4] = { 0.5f, 0.5f, 0.5f, 1.0f };
    m_pd3dDevice->SetPixelShaderConstant( 0, fAmbient, 1 );

    // Send the object
    if( pObject->m_Model )
    {
        pObject->m_Model->SetVertexShader( m_dwShadowBufVS );         // Set shadow buffer vshader
        pObject->m_Model->Render();
        pObject->m_Model->SetVertexShader( 0 );                       // Restore to fvf vshader
    }
    else    // Object has an XBG model
    {
        g_pd3dDevice->SetVertexShader( m_dwShadowBufVS );
        pObject->m_pXBMesh->Render( m_pd3dDevice, XBMESH_NOFVF );
    }       

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\shadowbuffer\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 3UL

#define resource_Floor_OFFSET 0UL
#define resource_Wings_OFFSET 20UL
#define resource_BiHull_OFFSET 40UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\stencilbuffer\shadowvolume\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\stencilbuffer\shadowvolume\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\stencilbuffer\stencildepth\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\stencilbuffer\stencildepth\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\stencilbuffer\stencildepth\makefile.inc ===
!include "..\..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\stencilbuffer\shadowvolume\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 3UL

#define resource_Seafloor_OFFSET 0UL
#define resource_BiHull_OFFSET 20UL
#define resource_Wings_OFFSET 40UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\shadowbuffer\obj\i386\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 3UL

#define resource_Floor_OFFSET 0UL
#define resource_Wings_OFFSET 20UL
#define resource_BiHull_OFFSET 40UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\stencilbuffer\stencildepth\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\stencilbuffer\stencildepth\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\stencilbuffer\stencilmirror\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\stencilbuffer\stencilmirror\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\stencilbuffer\stencilmirror\makefile.inc ===
!include "..\..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\stencilbuffer\shadowvolume\shadowvolume.cpp ===
//-----------------------------------------------------------------------------
// File: ShadowVolume.cpp
//
// Desc: Sample code showing how to use stencil buffers to implement shadow
//       volumes.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <XBMesh.h>
#include <XBUtil.h>

// The following header file is generated from "Resource.rdf" file using the
// Bundler tool. In addition to the header, the tool outputs a binary file
// (Resource.xpr) which contains compiled (i.e. bundled) resources and is
// loaded at runtime using the CXBPackedResource class.
#include "Resource.h"




//-----------------------------------------------------------------------------
// ASCII names for the resources used by the app
//-----------------------------------------------------------------------------
XBRESOURCE g_ResourceNames[] = 
{
    { "Seafloor.bmp", resource_Seafloor_OFFSET },
    { "BiHull.bmp",   resource_BiHull_OFFSET },
    { "Wings.bmp",    resource_Wings_OFFSET },
    { NULL, 0 },
};




//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_LEFTSTICK,    XBHELP_PLACEMENT_1, L"Move airplane" },
    { XBHELP_RIGHTSTICK,   XBHELP_PLACEMENT_1, L"Move light" },
    { XBHELP_X_BUTTON,     XBHELP_PLACEMENT_1, L"Show shadow volume" },
    { XBHELP_A_BUTTON,     XBHELP_PLACEMENT_1, L"Show silhouette" },
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_1, L"Display help" },
};

#define NUM_HELP_CALLOUTS 5




//-----------------------------------------------------------------------------
// External definitions and prototypes
//-----------------------------------------------------------------------------
#define FOG_COLOR 0xff0000ff

struct D3DVERTEX
{
    D3DXVECTOR3 p;
    D3DXVECTOR3 n;
    FLOAT       tu, tv;
};

struct SHADOWVERTEX
{
    D3DXVECTOR4 p;
    D3DCOLOR    color;
};

#define D3DFVF_VERTEX       (D3DFVF_XYZ|D3DFVF_NORMAL|D3DFVF_TEX1)
#define D3DFVF_SHADOWVERTEX (D3DFVF_XYZRHW|D3DFVF_DIFFUSE)




//-----------------------------------------------------------------------------
// Name: class ShadowVolume
// Desc: A shadow volume object
//-----------------------------------------------------------------------------
class ShadowVolume
{
    LPDIRECT3DVERTEXBUFFER8 m_pShadowVolumeVB;
    DWORD             m_dwNumVertices;
    DWORD             m_dwMaxVertices;

    LPDIRECT3DINDEXBUFFER8 m_pShadowVolumeIB;
    DWORD             m_dwNumEdges;
    DWORD             m_dwMaxEdges;

public:
    // Constructor
    ShadowVolume()
    { 
        m_pShadowVolumeVB = NULL; m_dwMaxVertices = 0L; m_dwNumVertices = 0L; 
        m_pShadowVolumeIB = NULL; m_dwMaxEdges    = 0L; m_dwMaxEdges    = 0L; 
    }

    // Resets the shadow volume contents
    VOID    Reset() { m_dwNumVertices = 0L; }
    
    // Builds a shadow volume from a mesh and a light source
    HRESULT Build( LPDIRECT3DDEVICE8 pd3dDevice, 
                   LPDIRECT3DVERTEXBUFFER8 pVB, DWORD dwNumVertices, 
                   LPDIRECT3DINDEXBUFFER8 pIB,  DWORD dwNumFaces, 
                   D3DXVECTOR3 vLightPos );
    
    // Renders the shadow volume
    HRESULT Render( LPDIRECT3DDEVICE8 pd3dDevice );

    // Renders the shadow volume's ede list
    HRESULT RenderEdges( LPDIRECT3DDEVICE8 pd3dDevice );
};




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Application class. The base class provides just about all the
//       functionality we want, so we're just supplying stubs to interface with
//       the non-C++ functions of the app.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBPackedResource  m_xprResource;        // Packed resources for the app
    CXBFont            m_Font;               // Font class
    CXBHelp            m_Help;               // Help class
    BOOL               m_bDrawHelp;          // Whether to draw help

    CXBMesh*      m_pAirplaneObject;
    CXBMesh*      m_pTerrainObject;
    ShadowVolume  m_ShadowVolume;

    BOOL          m_bDrawShadowVolume;
    BOOL          m_bDrawSilhouette;

    D3DXMATRIX    m_matObjectMatrix;
    D3DXMATRIX    m_matTerrainMatrix;

    HRESULT DrawShadow();
    HRESULT RenderShadow();

protected:
    HRESULT Initialize();
    HRESULT FrameMove();
    HRESULT Render();

public:
    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name:
// Desc:
//-----------------------------------------------------------------------------
HRESULT ShadowVolume::RenderEdges( LPDIRECT3DDEVICE8 pd3dDevice )
{
    pd3dDevice->SetVertexShader( D3DFVF_XYZ );
    pd3dDevice->SetStreamSource( 0, m_pShadowVolumeVB, sizeof(D3DXVECTOR3) );
    pd3dDevice->SetIndices( m_pShadowVolumeIB, 0 );
    pd3dDevice->DrawIndexedPrimitive( D3DPT_LINELIST, 0, 2*m_dwNumEdges,
                                      0, m_dwNumEdges );
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name:
// Desc:
//-----------------------------------------------------------------------------
HRESULT ShadowVolume::Render( LPDIRECT3DDEVICE8 pd3dDevice )
{
    pd3dDevice->SetVertexShader( D3DFVF_XYZ );
    pd3dDevice->SetStreamSource( 0, m_pShadowVolumeVB, sizeof(D3DXVECTOR3) );
    pd3dDevice->DrawPrimitive( D3DPT_QUADLIST, 0, m_dwNumVertices/4 );
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: AddEdge()
// Desc: Adds an edge to a list of silohuette edges of a shadow volume.
//-----------------------------------------------------------------------------
DWORD AddEdge( WORD* pEdges, DWORD& dwNumEdges, WORD v0, WORD v1 )
{
    // Remove interior edges (which appear in the list twice)
    for( DWORD i=0; i < dwNumEdges; i++ )
    {
        // Check if this edge already appears in the list. Note: it will be in
        // opposite order, due to the winding of the polygons
        if( ( pEdges[2*i+0] == v1 && pEdges[2*i+1] == v0 ) )
        {
            // If it does, remove it (fast way is to replace it with the last
            // edge in the list, and decrement the # of edges)
            if( dwNumEdges > 1 )
            {
                pEdges[2*i+0] = pEdges[2*(dwNumEdges-1)+0];
                pEdges[2*i+1] = pEdges[2*(dwNumEdges-1)+1];
            }
            return dwNumEdges--;
        }
    }

    // Add the edge to the list
    pEdges[2*dwNumEdges+0] = v0;
    pEdges[2*dwNumEdges+1] = v1;
    return dwNumEdges++;
}




//-----------------------------------------------------------------------------
// Name: BuildFromMesh()
// Desc: Takes a mesh as input, and uses it to build a shadowvolume. The
//       technique used considers each triangle of the mesh, and adds it's
//       edges to a temporary list. The edge list is maintained, such that
//       only silohuette edges are kept. Finally, the silohuette edges are
//       extruded to make the shadow volume vertex list.
//-----------------------------------------------------------------------------
HRESULT ShadowVolume::Build( LPDIRECT3DDEVICE8 pd3dDevice, 
                             LPDIRECT3DVERTEXBUFFER8 pMeshVB, DWORD dwNumVertices, 
                             LPDIRECT3DINDEXBUFFER8 pMeshIB, DWORD dwNumFaces, 
                             D3DXVECTOR3 vLightPos )
{
    // Note: the MESHVERTEX format depends on the FVF of the mesh
    struct MESHVERTEX { D3DXVECTOR3 p, n; FLOAT tu, tv; };
    MESHVERTEX*  pMeshVertices;
    WORD*        pMeshIndices;

    // Allocate an edge list
    if( dwNumFaces*3 > m_dwMaxEdges )
    {
        m_dwMaxEdges = dwNumFaces*3;

        SAFE_RELEASE( m_pShadowVolumeIB );
        if( FAILED( pd3dDevice->CreateIndexBuffer( m_dwMaxEdges*2*sizeof(WORD),
                                                   D3DUSAGE_WRITEONLY, D3DFMT_INDEX16,
                                                   D3DPOOL_DEFAULT, &m_pShadowVolumeIB ) ) )
            return E_FAIL;
    }
    m_dwNumEdges = 0;

    // Lock the geometry buffers
    pMeshVB->Lock( 0L, 0L, (BYTE**)&pMeshVertices, 0L );
    pMeshIB->Lock( 0L, 0L, (BYTE**)&pMeshIndices, 0L );

    // Lock the shadowvolume index buffer
    WORD* pShadowEdges;
    m_pShadowVolumeIB->Lock( 0L, 0L, (BYTE**)&pShadowEdges, 0L );

    // Loop through polygons and add edges for ones that face the light
    for( DWORD i=0; i<dwNumFaces; i++ )
    {
        // Get the vertices for this polygon
        WORD wIndex0 = pMeshIndices[3*i+0];
        WORD wIndex1 = pMeshIndices[3*i+1];
        WORD wIndex2 = pMeshIndices[3*i+2];
        D3DXVECTOR3 v0 = pMeshVertices[wIndex0].p;
        D3DXVECTOR3 v1 = pMeshVertices[wIndex1].p;
        D3DXVECTOR3 v2 = pMeshVertices[wIndex2].p;

        // Get the normal and the light vectors
        D3DXVECTOR3 vNormal;
        D3DXVec3Cross( &vNormal, &(v2-v1), &(v1-v0) );
        D3DXVECTOR3 vLight = vLightPos - v0;

        // Add edges for polys that face the light
        if( D3DXVec3Dot( &vNormal, &vLight ) >= 0.0f )
        {
            AddEdge( pShadowEdges, m_dwNumEdges, wIndex0, wIndex1 );
            AddEdge( pShadowEdges, m_dwNumEdges, wIndex1, wIndex2 );
            AddEdge( pShadowEdges, m_dwNumEdges, wIndex2, wIndex0 );
        }
    }

    // Allocate a vertex buffer
    if( m_dwNumEdges*4 > m_dwMaxVertices )
    {
        m_dwMaxVertices = m_dwNumEdges*4;

        SAFE_RELEASE( m_pShadowVolumeVB );
        if( FAILED( pd3dDevice->CreateVertexBuffer( m_dwMaxVertices*sizeof(D3DXVECTOR3),
                                                    D3DUSAGE_WRITEONLY, 0,
                                                    D3DPOOL_DEFAULT, &m_pShadowVolumeVB ) ) )
            return E_FAIL;
    }

    // Lock the shadowvolume vertex buffer
    D3DXVECTOR3* pShadowVertices;
    m_pShadowVolumeVB->Lock( 0L, 0L, (BYTE**)&pShadowVertices, 0L );

    // Fill the shadowvolume vertex buffer
    for( i=0; i<m_dwNumEdges; i++ )
    {
        D3DXVECTOR3* vPos0 = &pMeshVertices[pShadowEdges[2*i+0]].p;
        D3DXVECTOR3* vPos1 = &pMeshVertices[pShadowEdges[2*i+1]].p;

        // Re-assign the edge (for subsequent drawing of the edge list)
        pShadowEdges[2*i+0] = (WORD)(m_dwNumVertices+0);
        pShadowEdges[2*i+1] = (WORD)(m_dwNumVertices+1);

        // Add a quad (two triangles) to the vertex list
        pShadowVertices[m_dwNumVertices++] = (*vPos0);
        pShadowVertices[m_dwNumVertices++] = (*vPos1);
        pShadowVertices[m_dwNumVertices++] = (*vPos1) - vLightPos*10;
        pShadowVertices[m_dwNumVertices++] = (*vPos0) - vLightPos*10;
    }

    // Unlock the shadowvolume vertex buffer
    m_pShadowVolumeVB->Unlock();

    // Unlock the shadowvolume index buffer
    m_pShadowVolumeIB->Unlock();

    // Unlock the geometry buffers
    pMeshVB->Unlock();
    pMeshIB->Unlock();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    // Override base class members
    m_d3dpp.BackBufferFormat       = D3DFMT_X8R8G8B8;
    m_d3dpp.AutoDepthStencilFormat = D3DFMT_D24S8;

    m_pAirplaneObject   = new CXBMesh();
    m_pTerrainObject    = new CXBMesh();
    m_bDrawShadowVolume = FALSE;
    m_bDrawSilhouette   = FALSE;
    m_bDrawHelp         = FALSE;

    D3DXMatrixIdentity( &m_matTerrainMatrix );
}




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
inline FLOAT HeightField( FLOAT x, FLOAT z )
{
    FLOAT y = 0.0f;
    y += 7.0f * cosf( 0.051f*x + 0.0f ) * sinf( 0.055f*x + 0.0f );
    y += 7.0f * cosf( 0.053f*z + 0.0f ) * sinf( 0.057f*z + 0.0f );
    y += 1.0f * cosf( 0.101f*x + 0.0f ) * sinf( 0.105f*x + 0.0f );
    y += 1.0f * cosf( 0.103f*z + 0.0f ) * sinf( 0.107f*z + 0.0f );
    y += 1.0f * cosf( 0.251f*x + 0.0f ) * sinf( 0.255f*x + 0.0f );
    y += 1.0f * cosf( 0.253f*z + 0.0f ) * sinf( 0.257f*z + 0.0f );
    return y;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Initialize scene objects.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create the font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the resources
    if( FAILED( m_xprResource.Create( m_pd3dDevice, "Resource.xpr", 
                                      resource_NUM_RESOURCES, g_ResourceNames ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Load an object to cast the shadow
    if( FAILED( m_pAirplaneObject->Create( m_pd3dDevice, "Models\\Airplane.xbg", &m_xprResource ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Load some terrain
    if( FAILED( m_pTerrainObject->Create( m_pd3dDevice, "Models\\SeaFloor.xbg", &m_xprResource ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Tweak the terrain vertices
    {
        LPDIRECT3DVERTEXBUFFER8 pVB = &m_pTerrainObject->GetMesh(0)->m_VB;
        DWORD   dwNumVertices = m_pTerrainObject->GetMesh(0)->m_dwNumVertices;

        // Lock the vertex buffer to access the terrain geometry
        D3DVERTEX* pVertices;
        pVB->Lock( 0, 0, (BYTE**)&pVertices, 0 );

        // Add some more bumpiness to the terrain object
        for( DWORD i=0; i<dwNumVertices; i++ )
        {
            pVertices[i].p.x = 0.4f * pVertices[i].p.x +  0.0f;
            pVertices[i].p.z = 0.4f * pVertices[i].p.z + 20.0f;
            pVertices[i].p.y = HeightField( 25+2*pVertices[i].p.x, -25+2*pVertices[i].p.z ) - 8.0f;
        }

        // Release the vertex buffer
        pVB->Unlock();
    }

    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );

    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,        TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_DITHERENABLE,   TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SPECULARENABLE, FALSE );

    // Set the transform matrices
    D3DXVECTOR3 vEyePt    = D3DXVECTOR3( 0.0f, 10.0f, -20.0f );
    D3DXVECTOR3 vLookatPt = D3DXVECTOR3( 0.0f,  0.0f,   0.0f  );
    D3DXVECTOR3 vUpVec    = D3DXVECTOR3( 0.0f,  1.0f,   0.0f  );
    D3DXMATRIX matWorld, matView, matProj;

    D3DXMatrixIdentity( &matWorld );
    D3DXMatrixLookAtLH( &matView, &vEyePt, &vLookatPt, &vUpVec );
    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/4, 4.0f/3.0f, 1.0f, 100.0f );

    m_pd3dDevice->SetTransform( D3DTS_WORLD,      &matWorld );
    m_pd3dDevice->SetTransform( D3DTS_VIEW,       &matView );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );

    // Turn on fog
    FLOAT fFogStart =  30.0f;
    FLOAT fFogEnd   =  80.0f;
    m_pd3dDevice->SetRenderState( D3DRS_FOGENABLE,      TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_FOGCOLOR,       FOG_COLOR );
    m_pd3dDevice->SetRenderState( D3DRS_FOGTABLEMODE,   D3DFOG_LINEAR );
    m_pd3dDevice->SetRenderState( D3DRS_RANGEFOGENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_FOGSTART,       FtoDW(fFogStart) );
    m_pd3dDevice->SetRenderState( D3DRS_FOGEND,         FtoDW(fFogEnd) );

    m_pd3dDevice->LightEnable( 0, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_AMBIENT,  0x00303030 );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK )
        m_bDrawHelp = !m_bDrawHelp;

    // Whether or not to draw the shadowvolume
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_X] )
        m_bDrawShadowVolume = !m_bDrawShadowVolume;

    // Whether or not to draw the silhouette used to build the shadowvolume
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_A] )
        m_bDrawSilhouette = !m_bDrawSilhouette;

    // Setup viewing postion from Gamepad
    static FLOAT fRotateX1 = 0.0f;
    static FLOAT fRotateY1 = 0.0f;
    fRotateX1 += m_DefaultGamepad.fX1*m_fElapsedTime*D3DX_PI*0.5f;
    fRotateY1 += m_DefaultGamepad.fY1*m_fElapsedTime*D3DX_PI*0.5f;
    D3DXMatrixRotationYawPitchRoll( &m_matObjectMatrix, -fRotateX1, -fRotateY1, 0.0f );

    // Setup light postion from Gamepad
    static FLOAT Lx = 0.0f;
    static FLOAT Lz = 0.0f;
    Lx = ( Lx + m_DefaultGamepad.fX2*m_fElapsedTime*10.0f ) * 0.99f;
    Lz = ( Lz + m_DefaultGamepad.fY2*m_fElapsedTime*10.0f ) * 0.99f;
    D3DXVECTOR3 vLight( Lx+0.0f, 5.0f, Lz+0.0f );

    // Move the light
    D3DLIGHT8 light;
    XBUtil_InitLight( light, D3DLIGHT_POINT, vLight.x, vLight.y, vLight.z );
    light.Attenuation0 = 0.9f;
    m_pd3dDevice->SetLight( 0, &light );

    // Transform the light vector to be in object space
    D3DXMATRIX m;
    D3DXMatrixInverse( &m, NULL, &m_matObjectMatrix );
    D3DXVec3TransformCoord( &vLight, &vLight, &m );

    // Build the shadow volume
    m_ShadowVolume.Reset();
    m_ShadowVolume.Build( m_pd3dDevice, 
                         &m_pAirplaneObject->GetMesh(0)->m_VB, 
                          m_pAirplaneObject->GetMesh(0)->m_dwNumVertices, 
                         &m_pAirplaneObject->GetMesh(0)->m_IB, 
                          m_pAirplaneObject->GetMesh(0)->m_dwNumIndices/3, 
                          vLight );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: RenderShadow()
// Desc:
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::RenderShadow()
{
    // Disable z-buffer writes (note: z-testing still occurs), and enable the
    // stencil-buffer
    m_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE,  FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_STENCILENABLE, TRUE );

    // Dont bother with interpolating color
    m_pd3dDevice->SetRenderState( D3DRS_SHADEMODE,     D3DSHADE_FLAT );

    // Set up stencil compare fuction, reference value, and masks.
    // Stencil test passes if ((ref & mask) cmpfn (stencil & mask)) is true.
    // Note: since we set up the stencil-test to always pass, the STENCILFAIL
    // renderstate is really not needed.
    m_pd3dDevice->SetRenderState( D3DRS_STENCILFUNC,   D3DCMP_ALWAYS );
    m_pd3dDevice->SetRenderState( D3DRS_STENCILZFAIL,  D3DSTENCILOP_KEEP );
    m_pd3dDevice->SetRenderState( D3DRS_STENCILFAIL,   D3DSTENCILOP_KEEP );

    // If ztest passes, inc/decrement stencil buffer value
    m_pd3dDevice->SetRenderState( D3DRS_STENCILREF,       0x1 );
    m_pd3dDevice->SetRenderState( D3DRS_STENCILMASK,      0xffffffff );
    m_pd3dDevice->SetRenderState( D3DRS_STENCILWRITEMASK, 0xffffffff );
    m_pd3dDevice->SetRenderState( D3DRS_STENCILPASS,      D3DSTENCILOP_INCR );

    // Make sure that no pixels get drawn to the frame buffer
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,  D3DBLEND_ZERO );
    m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_ONE );

    // Draw front-side of shadow volume in stencil/z only
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &m_matObjectMatrix );
    m_ShadowVolume.Render( m_pd3dDevice );

    // Unless we want to visualize the entire shadow volume (for debugging
    // purposes), then we need to do the following to remove the backfacing
    // sides of the shadow volume.
    if( FALSE == m_bDrawShadowVolume )
    {
        // Now reverse cull order so back sides of shadow volume are written.
        m_pd3dDevice->SetRenderState( D3DRS_CULLMODE,   D3DCULL_CW );

        // Decrement stencil buffer value
        m_pd3dDevice->SetRenderState( D3DRS_STENCILPASS, D3DSTENCILOP_DECR );

        // Draw back-side of shadow volume in stencil/z only
        m_pd3dDevice->SetTransform( D3DTS_WORLD, &m_matObjectMatrix );
        m_ShadowVolume.Render( m_pd3dDevice );
    }

    // Restore render states
    m_pd3dDevice->SetRenderState( D3DRS_SHADEMODE, D3DSHADE_GOURAUD );
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE,  D3DCULL_CCW );
    m_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE,     TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_STENCILENABLE,    FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DrawShadow()
// Desc: Draws a big gray polygon over scene according to the mask in the
//       stencil buffer. (Any pixel with stencil==1 is in the shadow.)
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::DrawShadow()
{
    // Set renderstates (disable z-buffering, enable stencil, disable fog, and
    // turn on alphablending)
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,          FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_STENCILENABLE,    TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,  D3DBLEND_SRCALPHA );
    m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA );

    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );

    // The stencilbuffer values indicates # of shadows that overlap each pixel.
    // We only want to draw pixels that are in shadow, which was set up in
    // RenderShadow() such that StencilBufferValue >= 1. In the Direct3D API, 
    // the stencil test is pseudo coded as:
    //    StencilRef CompFunc StencilBufferValue
    // so we set our renderstates with StencilRef = 1 and CompFunc = LESSEQUAL.
    m_pd3dDevice->SetRenderState( D3DRS_STENCILREF,  0x1 );
    m_pd3dDevice->SetRenderState( D3DRS_STENCILFUNC, D3DCMP_LESSEQUAL );

    // Draw a big, gray square
    SHADOWVERTEX v[4];
    v[0].p = D3DXVECTOR4(   0 - 0.5f, 480 - 0.5f, 0.0f, 1.0f );  v[0].color = 0x7f000000;
    v[1].p = D3DXVECTOR4(   0 - 0.5f,   0 - 0.5f, 0.0f, 1.0f );  v[1].color = 0x7f000000;
    v[2].p = D3DXVECTOR4( 640 - 0.5f, 480 - 0.5f, 0.0f, 1.0f );  v[2].color = 0x7f000000;
    v[3].p = D3DXVECTOR4( 640 - 0.5f,   0 - 0.5f, 0.0f, 1.0f );  v[3].color = 0x7f000000;
    m_pd3dDevice->SetVertexShader( D3DFVF_SHADOWVERTEX );
    m_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, v, sizeof(v[0]) );

    // Restore render states
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,          TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_STENCILENABLE,    FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Clear the viewport, zbuffer, and stencil buffer
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,
                         FOG_COLOR, 1.0f, 0L );

    // Set state
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,        TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_DITHERENABLE,   TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SPECULARENABLE, FALSE );
    m_pd3dDevice->LightEnable( 0, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_AMBIENT,  0x00303030 );

    // Turn on fog
    FLOAT fFogStart =  30.0f;
    FLOAT fFogEnd   =  80.0f;
    m_pd3dDevice->SetRenderState( D3DRS_FOGENABLE,      TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_FOGCOLOR,       FOG_COLOR );
    m_pd3dDevice->SetRenderState( D3DRS_FOGTABLEMODE,   D3DFOG_LINEAR );
    m_pd3dDevice->SetRenderState( D3DRS_RANGEFOGENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_FOGSTART,       FtoDW(fFogStart) );
    m_pd3dDevice->SetRenderState( D3DRS_FOGEND,         FtoDW(fFogEnd) );

    // Draw the terrain
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &m_matTerrainMatrix );
    m_pTerrainObject->Render( m_pd3dDevice );

    // Draw the airplane
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &m_matObjectMatrix );
    m_pAirplaneObject->Render( m_pd3dDevice );

    // Turn off fog
    m_pd3dDevice->SetRenderState( D3DRS_FOGENABLE,    FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_FOGTABLEMODE, D3DFOG_NONE );
    
    // Render the shadow volume into the stencil buffer, then draw the shadow
    // in the scene
    RenderShadow();
    DrawShadow();

    // Draw the silhouette used to build the shadow volume 
    if( m_bDrawSilhouette )
    {
        m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, FALSE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TFACTOR );
        m_pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, 0xffffffff );
        m_ShadowVolume.RenderEdges( m_pd3dDevice );
    }

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        m_Font.Begin();
        m_Font.DrawText(  64, 50, 0xffffffff, L"ShadowVolume" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );
        m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\stencilbuffer\stencilmirror\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 3UL

#define resource_Seafloor_OFFSET 0UL
#define resource_BiHull_OFFSET 20UL
#define resource_Wings_OFFSET 40UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\stencilbuffer\stencilmirror\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\stencilbuffer\stencilmirror\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\stencilbuffer\shadowvolume\obj\i386\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 3UL

#define resource_Seafloor_OFFSET 0UL
#define resource_BiHull_OFFSET 20UL
#define resource_Wings_OFFSET 40UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\stencilbuffer\stencilmirror\obj\i386\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 3UL

#define resource_Seafloor_OFFSET 0UL
#define resource_BiHull_OFFSET 20UL
#define resource_Wings_OFFSET 40UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\stencilbuffer\stencildepth\stencildepth.cpp ===
//-----------------------------------------------------------------------------
// File: StencilDepth.cpp
//
// Desc: Example code showing how to use stencil buffers to show the depth
//       complexity of a scene.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <XBMesh.h>
#include <XBUtil.h>




//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_LEFTSTICK,    XBHELP_PLACEMENT_2, L"Rotate\nhelicopter" },
    { XBHELP_X_BUTTON,     XBHELP_PLACEMENT_2, L"Display depth\ncomplexity" },
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_2, L"Display\nhelp" },
};

#define NUM_HELP_CALLOUTS 3




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBFont   m_Font;                 // Font
    CXBHelp   m_Help;                 // Help class
    BOOL      m_bDrawHelp;            // Whether to draw help

    BOOL      m_bShowDepthComplexity; // Whether to show the depth complexity
    CXBMesh   m_FileObject;           // A file based object

    // Internal functions
    VOID    SetStatesForRecordingDepthComplexity();
    VOID    ShowDepthComplexity();

public:
    HRESULT Initialize();
    HRESULT Render();
    HRESULT FrameMove();

    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    // Override base class member variables
    m_d3dpp.BackBufferFormat       = D3DFMT_X8R8G8B8;
    m_d3dpp.AutoDepthStencilFormat = D3DFMT_D24S8;

    // Initialize member variables
    m_bDrawHelp            = FALSE;
    m_bShowDepthComplexity = FALSE;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Initialize scene objects.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Load a .X file
    if( FAILED( m_FileObject.Create( m_pd3dDevice, "Models\\Heli.xbg" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Set the transform matrices
    D3DXVECTOR3 vEyePt    = D3DXVECTOR3( 0.0f, 0.0f,-15.0f );
    D3DXVECTOR3 vLookatPt = D3DXVECTOR3( 0.0f, 0.0f,  0.0f );
    D3DXVECTOR3 vUpVec    = D3DXVECTOR3( 0.0f, 1.0f,  0.0f );
    D3DXMATRIX  matWorld, matView, matProj;

    D3DXMatrixIdentity( &matWorld );
    D3DXMatrixLookAtLH( &matView, &vEyePt, &vLookatPt, &vUpVec );
    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/4, 4.0f/3.0f, 1.0f, 100.0f );

    m_pd3dDevice->SetTransform( D3DTS_WORLD,      &matWorld );
    m_pd3dDevice->SetTransform( D3DTS_VIEW,       &matView );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );

    // Setup a material
    D3DMATERIAL8 mtrl;
    XBUtil_InitMaterial( mtrl, 1.0f, 1.0f, 1.0f );
    m_pd3dDevice->SetMaterial( &mtrl );

    D3DLIGHT8 light;
    XBUtil_InitLight( light, D3DLIGHT_DIRECTIONAL, 0.0f, -1.0f, 0.0f );
    m_pd3dDevice->SetLight( 0, &light );
    m_pd3dDevice->LightEnable( 0, TRUE );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK )
        m_bDrawHelp = !m_bDrawHelp;

    // Toggle options with the gamepad
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_X] )
        m_bShowDepthComplexity = !m_bShowDepthComplexity;

    // Rotate the camera with the gamepad
    static FLOAT m_fXRotate = 0.0f;
    static FLOAT m_fYRotate = 0.0f;
    m_fXRotate += m_DefaultGamepad.fX1*m_fElapsedTime*D3DX_PI*0.5f;
    m_fYRotate += m_DefaultGamepad.fY1*m_fElapsedTime*D3DX_PI*0.5f;
    D3DXMATRIX matTrackBall, matTrans, matView;
    D3DXMatrixRotationYawPitchRoll( &matTrackBall, -m_fXRotate, -m_fYRotate, 0.0f );
    D3DXMatrixTranslation( &matTrans, 0.0f, 0.0f, 15.0f );
    D3DXMatrixMultiply( &matView, &matTrackBall, &matTrans );
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SetStatesForRecordingDepthComplexity()
// Desc: Turns on stencil and other states for recording the depth complexity
//       during the rendering of a scene.
//-----------------------------------------------------------------------------
VOID CXBoxSample::SetStatesForRecordingDepthComplexity()
{
    // Clear the stencil buffer
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_STENCIL, 0x0, 1.0f, 0L );

    // Turn on stenciling
    m_pd3dDevice->SetRenderState( D3DRS_STENCILENABLE,   TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_STENCILFUNC,     D3DCMP_ALWAYS );
    m_pd3dDevice->SetRenderState( D3DRS_STENCILREF,      0 );
    m_pd3dDevice->SetRenderState( D3DRS_STENCILMASK,     0x00000000 );
    m_pd3dDevice->SetRenderState( D3DRS_STENCILWRITEMASK,0xffffffff );

    // Increment the stencil buffer for each pixel drawn
    m_pd3dDevice->SetRenderState( D3DRS_STENCILZFAIL, D3DSTENCILOP_INCRSAT );
    m_pd3dDevice->SetRenderState( D3DRS_STENCILFAIL,  D3DSTENCILOP_KEEP );
    m_pd3dDevice->SetRenderState( D3DRS_STENCILPASS,  D3DSTENCILOP_INCRSAT );

    // Since we are only writing into the stencil buffer, we can turn off the
    // frame buffer.
    m_pd3dDevice->SetRenderState( D3DRS_COLORWRITEENABLE, 0x00000000 );
}




//-----------------------------------------------------------------------------
// Name: ShowDepthComplexity()
// Desc: Draws the contents of the stencil buffer in false color. Use alpha
//       blending of one red, one green, and one blue rectangle to do false
//       coloring of bits 1, 2, and 4 in the stencil buffer.
//-----------------------------------------------------------------------------
VOID CXBoxSample::ShowDepthComplexity()
{
    // Re-enable framebuffer writes, turn off the buffer, and enable alpha
    // blending
    m_pd3dDevice->SetRenderState( D3DRS_COLORWRITEENABLE, D3DCOLORWRITEENABLE_RED |
                                                          D3DCOLORWRITEENABLE_GREEN |
                                                          D3DCOLORWRITEENABLE_BLUE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,          FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,  D3DBLEND_SRCCOLOR );
    m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCCOLOR );

    // Set up the stencil states
    m_pd3dDevice->SetRenderState( D3DRS_STENCILZFAIL, D3DSTENCILOP_KEEP );
    m_pd3dDevice->SetRenderState( D3DRS_STENCILFAIL,  D3DSTENCILOP_KEEP );
    m_pd3dDevice->SetRenderState( D3DRS_STENCILPASS,  D3DSTENCILOP_KEEP );
    m_pd3dDevice->SetRenderState( D3DRS_STENCILFUNC,  D3DCMP_NOTEQUAL );
    m_pd3dDevice->SetRenderState( D3DRS_STENCILREF,   0 );

    // Set the background to black
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET, 0x00000000, 1.0f, 0L );

    // Set render states for drawing a rectangle that covers the viewport.
    // The color of the rectangle will be passed in D3DRS_TEXTUREFACTOR
    D3DXVECTOR4 v[4];
    v[0] = D3DXVECTOR4(   0 - 0.5f, 480 - 0.5f, 0.0f, 1.0f );
    v[1] = D3DXVECTOR4(   0 - 0.5f,   0 - 0.5f, 0.0f, 1.0f );
    v[2] = D3DXVECTOR4( 640 - 0.5f, 480 - 0.5f, 0.0f, 1.0f );
    v[3] = D3DXVECTOR4( 640 - 0.5f,   0 - 0.5f, 0.0f, 1.0f );
    m_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TFACTOR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );

    // Draw a red rectangle wherever the 1st stencil bit is set
    m_pd3dDevice->SetRenderState( D3DRS_STENCILMASK, 0x01 );
    m_pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, 0xffff0000 );
    m_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, v, sizeof(v[0]) );

    // Draw a green rectangle wherever the 2nd stencil bit is set
    m_pd3dDevice->SetRenderState( D3DRS_STENCILMASK, 0x02 );
    m_pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, 0xff00ff00 );
    m_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, v, sizeof(v[0]) );

    // Draw a blue rectangle wherever the 3rd stencil bit is set
    m_pd3dDevice->SetRenderState( D3DRS_STENCILMASK, 0x04 );
    m_pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, 0xff0000ff );
    m_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, v, sizeof(v[0]) );

    // Restore states
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,          TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_STENCILENABLE,    FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Draw a gradient filled background
    if( FALSE == m_bShowDepthComplexity )
        RenderGradientBackground( 0xff0000ff, 0xffffffff );

    // Set default states
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetRenderState( D3DRS_DITHERENABLE,   TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SPECULARENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,        TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_COLORVERTEX,    TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_AMBIENT,        0x00000000 );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING,       TRUE );

    // Set states necessary to record the depth complexity of the scene
    if( m_bShowDepthComplexity )
        SetStatesForRecordingDepthComplexity();

    // Render the scene's opaque parts
    m_FileObject.Render( m_pd3dDevice, XBMESH_OPAQUEONLY );

    // Render the scene's alpha parts
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,  D3DBLEND_SRCALPHA );
    m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA );
    m_FileObject.Render( m_pd3dDevice, XBMESH_ALPHAONLY );

    // Show the depth complexity of the scene
    if( m_bShowDepthComplexity )
        ShowDepthComplexity();

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        m_Font.Begin();
        m_Font.DrawText(  64, 50, 0xffffffff, L"StencilDepth" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );
        m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Strip\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Strip\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Strip\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Strip\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\stencilbuffer\stencilmirror\stencilmirror.cpp ===
//-----------------------------------------------------------------------------
// File: StencilMirror.cpp
//
// Desc: Example code showing how to use stencil buffers to implement planar
//       mirrors.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBMesh.h>
#include <XBResource.h>
#include <XBUtil.h>

// The following header file is generated from "Resource.rdf" file using the
// Bundler tool. In addition to the header, the tool outputs a binary file
// (Resource.xpr) which contains compiled (i.e. bundled) resources and is
// loaded at runtime using the CXBPackedResource class.
#include "Resource.h"




//-----------------------------------------------------------------------------
// ASCII names for the resources used by the app
//-----------------------------------------------------------------------------
XBRESOURCE g_ResourceNames[] = 
{
    { "Seafloor.bmp", resource_Seafloor_OFFSET },
    { "BiHull.bmp",   resource_BiHull_OFFSET },
    { "Wings.bmp",    resource_Wings_OFFSET },
    { NULL, 0 },
};




//-----------------------------------------------------------------------------
// Custom vertex types
//-----------------------------------------------------------------------------
struct MESHVERTEX
{
    D3DXVECTOR3 p;
    D3DXVECTOR3 n;
    FLOAT       tu, tv;
};

#define D3DFVF_MESHVERTEX   (D3DFVF_XYZ|D3DFVF_NORMAL|D3DFVF_TEX1)

// Fog color
#define FOG_COLOR 0xff000000

// Function for creating a height field
FLOAT HeightField( FLOAT x, FLOAT z )
{
    FLOAT y = 0.0f;
    y += 7.0f * cosf( 0.051f*x + 0.0f ) * sinf( 0.055f*x + 0.0f );
    y += 7.0f * cosf( 0.053f*z + 0.0f ) * sinf( 0.057f*z + 0.0f );
    y += 1.0f * cosf( 0.101f*x + 0.0f ) * sinf( 0.105f*x + 0.0f );
    y += 1.0f * cosf( 0.103f*z + 0.0f ) * sinf( 0.107f*z + 0.0f );
    y += 1.0f * cosf( 0.251f*x + 0.0f ) * sinf( 0.255f*x + 0.0f );
    y += 1.0f * cosf( 0.253f*z + 0.0f ) * sinf( 0.257f*z + 0.0f );
    return y*1.0f-10.0f;
}




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Application class. The base class provides just about all the
//       functionality we want, so we're just supplying stubs to interface with
//       the non-C++ functions of the app.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBPackedResource  m_xprResource;        // Packed resources for the app
    CXBFont            m_Font;               // Font class

    D3DXVECTOR3  m_vMirror[4];               // Vertices for the mirror
    D3DMATERIAL8 m_mtrlMirrorMaterial;       // Material of the mirror
    D3DXMATRIX   m_matMirrorMatrix;          // Matrix to position mirror
    BOOL         m_bRenderingReflectedScene; // Whether we are rendering the reflection

    CXBMesh      m_Terrain;                  // X file of terrain
    D3DXMATRIX   m_matTerrainMatrix;         // Matrix to position terrain

    CXBMesh      m_Airplane;                 // X file object to render
    D3DXMATRIX   m_matAirplaneMatrix;        // Matrix to animate X file object

    HRESULT RenderScene();
    HRESULT RenderMirror();

public:
    HRESULT Initialize();
    HRESULT FrameMove();
    HRESULT Render();

    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Application constructor. Sets attributes for the app.
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    // Override base class member variables
    m_d3dpp.BackBufferFormat       = D3DFMT_X8R8G8B8;
    m_d3dpp.AutoDepthStencilFormat = D3DFMT_D24S8;

    // Initialize member variables
    m_vMirror[0] = D3DXVECTOR3(-80.0f, 0.0f,-80.0f );
    m_vMirror[1] = D3DXVECTOR3(-80.0f, 0.0f, 80.0f );
    m_vMirror[2] = D3DXVECTOR3( 80.0f, 0.0f,-80.0f );
    m_vMirror[3] = D3DXVECTOR3( 80.0f, 0.0f, 80.0f );
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Initialize scene objects.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create the font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the resources
    if( FAILED( m_xprResource.Create( m_pd3dDevice, "Resource.xpr", 
                                      resource_NUM_RESOURCES, g_ResourceNames ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Load an object to cast the shadow
    if( FAILED( m_Airplane.Create( m_pd3dDevice, "Models\\Airplane.xbg", &m_xprResource ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Load some terrain
    if( FAILED( m_Terrain.Create( m_pd3dDevice, "Models\\SeaFloor.xbg", &m_xprResource ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Tweak the terrain vertices to add some bumpy terrain
    {
        // Get access to the mesh vertices
        LPDIRECT3DVERTEXBUFFER8 pVB = &m_Terrain.GetMesh(0)->m_VB;
        DWORD dwNumVertices = m_Terrain.GetMesh(0)->m_dwNumVertices;
        MESHVERTEX* pVertices;
        pVB->Lock( 0, 0, (BYTE**)&pVertices, 0 );

        for( DWORD i=0; i<dwNumVertices; i++ )
        {
            D3DXVECTOR3 v00( pVertices[i].p.x + 0.0f, 0.0f, pVertices[i].p.z + 0.0f );
            D3DXVECTOR3 v10( pVertices[i].p.x + 0.1f, 0.0f, pVertices[i].p.z + 0.0f );
            D3DXVECTOR3 v01( pVertices[i].p.x + 0.0f, 0.0f, pVertices[i].p.z + 0.1f );
            v00.y = HeightField( 1*v00.x, 1*v00.z );
            v10.y = HeightField( 1*v10.x, 1*v10.z );
            v01.y = HeightField( 1*v01.x, 1*v01.z );

            D3DXVECTOR3 n;
            D3DXVec3Cross( &n, &(v01-v00), &(v10-v00) );
            D3DXVec3Normalize( &n, &n );

            pVertices[i].p.y  = v00.y;
            pVertices[i].n.x  = n.x;
            pVertices[i].n.y  = n.y;
            pVertices[i].n.z  = n.z;
            pVertices[i].tu  *= 10;
            pVertices[i].tv  *= 10;
        }

        pVB->Unlock();
    }

    // Set the transform matrices
    D3DXVECTOR3 vEyePt    = D3DXVECTOR3( 0.0f, 5.5f, -15.0f );
    D3DXVECTOR3 vLookatPt = D3DXVECTOR3( 0.0f, 1.5f,   0.0f  );
    D3DXVECTOR3 vUpVec    = D3DXVECTOR3( 0.0f, 1.0f,   0.0f  );
    D3DXMATRIX matWorld, matView, matProj;

    D3DXMatrixIdentity( &matWorld );
    D3DXMatrixLookAtLH( &matView, &vEyePt, &vLookatPt, &vUpVec );
    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/4, 4.0f/3.0f, 1.0f, 1000.0f );

    m_pd3dDevice->SetTransform( D3DTS_WORLD,      &matWorld );
    m_pd3dDevice->SetTransform( D3DTS_VIEW,       &matView );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );

    // Set up a material
    D3DMATERIAL8 mtrl;
    XBUtil_InitMaterial( mtrl, 0.5f, 0.8f, 1.0f );
    m_pd3dDevice->SetMaterial( &mtrl );
    XBUtil_InitMaterial( m_mtrlMirrorMaterial, 0.0f, 0.5f, 0.5f );

    // Set up the light
    D3DLIGHT8 light;
    XBUtil_InitLight( light, D3DLIGHT_DIRECTIONAL, 0.0f, -0.4f, 1.0f );
    m_pd3dDevice->SetLight( 0, &light );
    m_pd3dDevice->LightEnable( 0, TRUE );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // Position the terrain
    D3DXMatrixTranslation( &m_matTerrainMatrix, 0.0f, 8.0f, 0.0f );

    // Position the mirror (water polygon intersecting with terrain)
    D3DXMatrixTranslation( &m_matMirrorMatrix, 0.0f, 0.0f, 0.0f );

    // Position and animate the main object
    FLOAT fObjectPosX = 50.0f*sinf(m_fAppTime/2);
    FLOAT fObjectPosY = 6;
    FLOAT fObjectPosZ = 10.0f*cosf(m_fAppTime/2);
    D3DXMATRIX matRoll, matPitch, matRotate, matScale, matTranslate;
    D3DXMatrixRotationZ( &matRoll, 0.2f*sinf(m_fAppTime/2)  );
    D3DXMatrixRotationY( &matRotate, m_fAppTime/2-D3DX_PI/2  );
    D3DXMatrixRotationX( &matPitch, -0.1f * (1+cosf(m_fAppTime))  );
    D3DXMatrixScaling( &matScale, 0.5f, 0.5f, 0.5f );
    D3DXMatrixTranslation( &matTranslate, fObjectPosX, fObjectPosY, fObjectPosZ );
    D3DXMatrixMultiply( &m_matAirplaneMatrix, &matScale, &matTranslate );
    D3DXMatrixMultiply( &m_matAirplaneMatrix, &matRoll, &m_matAirplaneMatrix );
    D3DXMatrixMultiply( &m_matAirplaneMatrix, &matRotate, &m_matAirplaneMatrix );
    D3DXMatrixMultiply( &m_matAirplaneMatrix, &matPitch, &m_matAirplaneMatrix );

    // Move the camera around
    FLOAT fEyeX = 10.0f * sinf( m_fAppTime/2.0f );
    FLOAT fEyeY =  3.0f * sinf( m_fAppTime/25.0f ) + 13.0f;
    FLOAT fEyeZ =  5.0f * cosf( m_fAppTime/2.0f );
    D3DXMATRIX matView;
    D3DXVECTOR3 vEyePt    = D3DXVECTOR3( fEyeX, fEyeY, fEyeZ );
    D3DXVECTOR3 vLookatPt = D3DXVECTOR3( fObjectPosX, fObjectPosY, fObjectPosZ );
    D3DXVECTOR3 vUpVec    = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
    D3DXMatrixLookAtLH( &matView, &vEyePt, &vLookatPt, &vUpVec );
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: RenderScene()
// Desc:
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::RenderScene()
{
    // Render terrain
    if( FALSE == m_bRenderingReflectedScene )
    {
        m_pd3dDevice->SetTransform( D3DTS_WORLD, &m_matTerrainMatrix );
        m_Terrain.Render( m_pd3dDevice );
    }

    // Draw the mirror
    if( FALSE == m_bRenderingReflectedScene )
    {
        m_pd3dDevice->SetTexture( 0, NULL );
        m_pd3dDevice->SetMaterial( &m_mtrlMirrorMaterial );
        m_pd3dDevice->SetTransform( D3DTS_WORLD, &m_matMirrorMatrix );
        m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
        m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,     D3DBLEND_DESTCOLOR );
        m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND,    D3DBLEND_ZERO );
        m_pd3dDevice->SetVertexShader( D3DFVF_XYZ );
        m_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, m_vMirror, 
                                       sizeof(D3DXVECTOR3) );
    }

    // Restore states
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );

    // Draw the object. Note: do this last, in case the object has alpha
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &m_matAirplaneMatrix );
    m_Airplane.Render( m_pd3dDevice );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: RenderMirror()
// Desc:
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::RenderMirror()
{
    // Turn depth buffer off, and stencil buffer on
    m_pd3dDevice->SetRenderState( D3DRS_STENCILENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_STENCILFUNC,     D3DCMP_ALWAYS );
    m_pd3dDevice->SetRenderState( D3DRS_STENCILREF,      0x1 );
    m_pd3dDevice->SetRenderState( D3DRS_STENCILMASK,     0xffffffff );
    m_pd3dDevice->SetRenderState( D3DRS_STENCILWRITEMASK,0xffffffff );
    m_pd3dDevice->SetRenderState( D3DRS_STENCILZFAIL, D3DSTENCILOP_KEEP );
    m_pd3dDevice->SetRenderState( D3DRS_STENCILFAIL,  D3DSTENCILOP_KEEP );
    m_pd3dDevice->SetRenderState( D3DRS_STENCILPASS,  D3DSTENCILOP_REPLACE );

    // Make sure no pixels are written to the z-buffer or frame buffer
    m_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE,  FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_COLORWRITEENABLE, 0x00000000 );

    // Draw the reflecting surface into the stencil buffer
    m_pd3dDevice->SetTexture( 0, NULL);
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &m_matMirrorMatrix );
    m_pd3dDevice->SetVertexShader( D3DFVF_XYZ );
    m_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, m_vMirror, 
                                   sizeof(D3DXVECTOR3) );
    
    // Save the view matrix
    D3DXMATRIX matViewSaved;
    m_pd3dDevice->GetTransform( D3DTS_VIEW, &matViewSaved );

    // Reflect camera in X-Z plane mirror
    D3DXMATRIX matView, matReflect;
    D3DXPLANE plane;
    D3DXPlaneFromPointNormal( &plane, &D3DXVECTOR3(0,0,0), &D3DXVECTOR3(0,1,0) );
    D3DXMatrixReflect( &matReflect, &plane );
    D3DXMatrixMultiply( &matView, &matReflect, &matViewSaved );
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );

    // Reenable the framebuffer and zbuffer
    m_pd3dDevice->SetRenderState( D3DRS_COLORWRITEENABLE, D3DCOLORWRITEENABLE_RED |
                                                          D3DCOLORWRITEENABLE_GREEN |
                                                          D3DCOLORWRITEENABLE_BLUE );
    m_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE, TRUE );

    // Setup render states to a blended render scene against mask in stencil
    // buffer. An important step here is to reverse the cull-order of the
    // polygons, since the view matrix is being reflected.
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,     D3DBLEND_DESTCOLOR );
    m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND,    D3DBLEND_ZERO );
    m_pd3dDevice->SetRenderState( D3DRS_STENCILFUNC,  D3DCMP_EQUAL );
    m_pd3dDevice->SetRenderState( D3DRS_STENCILPASS,  D3DSTENCILOP_KEEP );
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE,     D3DCULL_CW );

    // Clear the zbuffer (leave frame- and stencil-buffer intact)
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_ZBUFFER, 0L, 1.0f, 0L );

    // Render the scene
    m_bRenderingReflectedScene = TRUE;
    RenderScene();

    // Restore render states
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE,         D3DCULL_CCW );
    m_pd3dDevice->SetRenderState( D3DRS_STENCILENABLE,    FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &matViewSaved );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Clear the viewport, zbuffer, and stencil buffer
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,
                         FOG_COLOR, 1.0f, 0L );

    // Set render state
    FLOAT fFogStart =  10.0f;
    FLOAT fFogEnd   = 100.0f;
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_NONE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,        TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_DITHERENABLE,   TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SPECULARENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_AMBIENT,        0xff555555 );
    m_pd3dDevice->SetRenderState( D3DRS_FOGENABLE,      TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_FOGCOLOR,       FOG_COLOR );
    m_pd3dDevice->SetRenderState( D3DRS_FOGTABLEMODE,   D3DFOG_LINEAR );
    m_pd3dDevice->SetRenderState( D3DRS_RANGEFOGENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_FOGSTART,       FtoDW(fFogStart) );
    m_pd3dDevice->SetRenderState( D3DRS_FOGEND,         FtoDW(fFogEnd) );
    
    // Render the scene
    m_bRenderingReflectedScene = FALSE;
    RenderScene();

    // Render the reflection in the mirror
    RenderMirror();

    // Show frame rate
    m_Font.Begin();
    m_Font.DrawText(  64, 50, 0xffffffff, L"StencilMirror" );
    m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );
    m_Font.End();

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Strip\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\SwapCallback\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\SwapCallback\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\SwapCallback\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\SwapCallback\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\swizzle\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\SwapCallback\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Strip\Strip.cpp ===
//-----------------------------------------------------------------------------
// File: Strip.cpp
//
// Desc: Sample to show off tri-stripping performance results. This sample
//       creates a mesh, stripifies it, then displays several copies of it
//       along with performance data.
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBPerf.h>
#include <XBStrip.h>
#include <XBUtil.h>
#include <XBHelp.h>
#include <XMenu.h>




//-----------------------------------------------------------------------------
// Help support
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_NormalHelpCallouts[] =
{
    { XBHELP_LEFTSTICK,    XBHELP_PLACEMENT_1, L"Rotate the model" },
    { XBHELP_RIGHTSTICK,   XBHELP_PLACEMENT_1, L"Zoom in/out" },
    { XBHELP_START_BUTTON, XBHELP_PLACEMENT_2, L"Bring up\noptions menu" },
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_2, L"Display\nhelp" },
};
#define MAX_NORMAL_HELP_CALLOUTS    4




//-----------------------------------------------------------------------------
// Global variables and definitions
//-----------------------------------------------------------------------------

// Constants definitions
#define COLOR_YELLOW                0xffffff00
#define COLOR_WHITE                 0xffffffff

#define MENUSELECT_DELETE           0
#define MENUSELECT_ADD              1
#define MENUSELECT_DISABLE          0
#define MENUSELECT_ENABLE           1

#define MENUCMD_DIRLIGHT            0x00000002
#define MENUCMD_POINTLIGHT          0x00000004
#define MENUCMD_SPOTLIGHT           0x00000008
#define MENUCMD_TEXTURES            0x00000020
#define MENUCMD_ZENABLE             0x00000040
#define MENUCMD_SPECULARENABLE      0x00000080
#define MENUCMD_LOCALVIEWER         0x00000100
#define MENUCMD_ANTIALIAS           0x00000200
#define MENUCMD_FILLMODE            0x00000400
#define MENUCMD_CULLMODE            0x00000800
#define MENUCMD_EXPENSIVEOP         0x00001000
#define MENUCMD_DISPLAYINFO         0x00002000


// Structure declarations
struct MODELVERT
{
    D3DXVECTOR3 p;
    D3DXVECTOR3 n;
    FLOAT       tu, tv;
};


struct MODELDATA
{
    D3DXMATRIX* pMatrix;
    DWORD       dwNumVertices;
    MODELVERT*  pVertices;
    DWORD       dwNumIndices;
    WORD*       pIndices;
};


enum MESHTYPE { MESH_Original, MESH_Xbox, MESH_Max };


struct OPTIONS
{
    MESHTYPE    meshtype;
    UINT        dwNumTextures;

    BOOL        bZenable;
    BOOL        bSpecularenable;
    BOOL        bLocalviewer;
    BOOL        bAntiAlias;

    INT         nNumLights;
    INT         dwDirectionalLights;
    INT         dwSpotLights;
    INT         dwPointLights;

    BOOL        bRebuildVBs;
    BOOL        bLightsChanged;

    BOOL        bDisplayArgs;
    D3DCULL     cullmode;
    D3DFILLMODE FillMode;    // current fill mode
};

struct ROBOTSTATS
{
    DWORD       dwNumVertices;
    DWORD       dwCacheHits;
    DWORD       dwPagesCrossed;
    DWORD       dwDegenerateTris;
    
    DWORD       dwDrawPassesX;
    DWORD       dwDrawPassesY;


    double      fdAvgTriPerSec;
    double      fdAvgTriPerSec2;
    double      fdMaxTriPerSec;
    double      fdMinTriPerSec;
    DWORD       dwAvgCount;
    DWORD       dwTriCount;
    DWORD       dwIndCount;
    DWORD       dwTime;
    DWORD       dwFrames;
};

struct MESHINFO
{
    D3DPRIMITIVETYPE        dwPrimType;   // primitive type

    DWORD                   dwIndexCount; // index count
    WORD*                   pwIndices;    // index list
    LPDIRECT3DINDEXBUFFER8  pIndexBuffer; // dx8 index buffer

    DWORD                   dwNumVertices; // num verts
    LPDIRECT3DVERTEXBUFFER8 pVertexBuffer; // vbs

    DWORD                   dwPrimitiveCount;

    DWORD                   dwDegenerateTris;
    DWORD                   dwCacheHits;
    DWORD                   dwPagesCrossed;
};


// Function decls
VOID    ResetOptions();
DWORD   ToggleMeshMenuProc( DWORD cmd, XMenuItem* pmi );
DWORD   AddDeleteMenuProc( DWORD cmd, XMenuItem* pmi );
DWORD   CullModeMenuProc( DWORD cmd, XMenuItem* pmi );
DWORD   FillModeMenuProc( DWORD cmd, XMenuItem* pmi );
DWORD   ResetAllProc( DWORD cmd, XMenuItem* pmi );




// render 12 robots
static const int C_ROBOTS_X = 4;
static const int C_ROBOTS_Y = 3;




// Mesh data from MODELDATA.CPP
extern DWORD     g_cModelData;
extern MODELDATA g_ModelData[];

#define MAX_LIGHTS                  8

// Camera location
D3DXVECTOR3 g_vEye(10.0f, -20.0f, 9.0f);
D3DXVECTOR3 g_vAt(0.0f, 0.0f, 0.0f);
D3DXVECTOR3 g_vUp(0.0f, 0.0f, 1.0f);

// Global options
OPTIONS     g_Options;




//-----------------------------------------------------------------------------
// Name: class CRobotX
// Desc: Main Robot class
//-----------------------------------------------------------------------------
class CRobotX
{
    D3DMATERIAL8           m_mat;          // material

    DWORD                  m_dwNumMeshes;  // count of VBs to draw
    MESHINFO*              m_pMeshes;      // our list of VBs

    LPDIRECT3DTEXTURE8     m_pTexture1;    // texture1
    LPDIRECT3DCUBETEXTURE8 m_pTexture2;    // texture2

    LPDIRECT3DDEVICE8      m_pd3dDevice;   // d3d device

public:
    DWORD                  m_dwFVF;        // Mesh FVF
    DWORD                  m_dwVertexSize; // Vertex size

    HRESULT Init( LPDIRECT3DDEVICE8 );
    HRESULT InitVertexBuffers();
    VOID    Release();

    HRESULT SetStates();
    HRESULT RestoreStates();
    HRESULT Render( ROBOTSTATS* pStats = NULL );

    CRobotX();
    ~CRobotX() { Release(); }
};




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Application class. The base class provides just about all the
//       functionality we want, so we're just supplying stubs to interface with
//       the non-C++ functions of the app.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
private:
    // current state of the world
    struct STRIPSTATE
    {
//      BOOL        bDisplayHelp;
//      BOOL        bDisplayStats;
//      BOOL        bDisplaySysInfo;
//      UINT        cPause;
    };

    BOOL            m_bDisplayHelp;
    BOOL            m_bDisplayStats;
    UINT            m_cPause;

    STRIPSTATE      m_State;

    // the robot object
    ROBOTSTATS      m_Stats;
    CRobotX         m_Robot;

    // Font for rendering stats and help
    FLOAT           m_fFontHeight;
    FLOAT           m_fSecsPerTick;

    CXBFont         m_Font;
    CXBHelp         m_Help;

    // Menu system
    DWORD           m_dwMenuCommand;
    XMenu*          m_pMainMenu;
    XMenu*          m_pMeshMenu;
    XMenu*          m_pAddDeleteMenu;
    XMenu*          m_pEnableDisableMenu;
    XMenu*          m_pCullMenu;
    XMenu*          m_pFillMenu;

    HRESULT InitLights();
    HRESULT InitFrameworkStuff();
    BOOL    HandleInput();
    VOID    DisplayInfo( const WCHAR* str );
    VOID    DisplayArgs();
    VOID    DisplayStartupInfo();
    VOID    DisplayCmdParams();   

public:
    HRESULT Initialize();
    HRESULT FrameMove();
    HRESULT Render();
    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Main app constructor
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
{
    // Enable anti-aliasing and unlimited frame rates
    m_d3dpp.MultiSampleType = D3DMULTISAMPLE_2_SAMPLES;
    m_d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;

    // Initialize derived member variables
    ZeroMemory( &m_State, sizeof(m_State) );

    ZeroMemory(&m_Stats, sizeof(m_Stats));
    m_Stats.dwDrawPassesX   = C_ROBOTS_X;
    m_Stats.dwDrawPassesY   = C_ROBOTS_Y;
    m_Stats.dwAvgCount      = 0;
    m_Stats.fdAvgTriPerSec  = 0.0;
    m_Stats.fdAvgTriPerSec2 = 0.0;
    m_Stats.fdMaxTriPerSec  = 0.0;
    m_Stats.fdMinTriPerSec  = 1e99;

    m_d3dpp.BackBufferFormat = D3DFMT_X8R8G8B8;
    m_d3dpp.AutoDepthStencilFormat = D3DFMT_D16;

    m_pMainMenu = NULL;
    m_pMeshMenu = NULL;
    m_pAddDeleteMenu = NULL;
    m_pEnableDisableMenu = NULL;
    m_pCullMenu = NULL;
    m_pFillMenu = NULL;

    ResetOptions();
    g_Options.bRebuildVBs = false;
    g_Options.bLightsChanged = false;

}




//-----------------------------------------------------------------------------
// Name: ResetOptions()
// Desc: Reset options
//-----------------------------------------------------------------------------
void ResetOptions()
{
    g_Options.dwNumTextures = 2;
    g_Options.dwDirectionalLights = 0;
    g_Options.dwSpotLights = 0;
    g_Options.dwPointLights = 1;

    g_Options.bZenable        = TRUE;
    g_Options.bSpecularenable = TRUE;
    g_Options.bLocalviewer    = TRUE;
    g_Options.bAntiAlias      = TRUE;
    g_Options.cullmode = D3DCULL_CCW;
    g_Options.FillMode = D3DFILL_SOLID;

    g_Options.meshtype = MESH_Xbox; // start with tri-strips
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Initialize all dependencies and states
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    HRESULT hr;

    g_Options.bDisplayArgs = TRUE;
    m_bDisplayStats        = TRUE;
    m_bDisplayHelp         = FALSE;
    m_cPause               = 0;

    hr = InitFrameworkStuff();
    if( FAILED(hr) )
        return hr;
    
    // Disable antialiasing by default
    m_pd3dDevice->SetRenderState( D3DRS_MULTISAMPLEANTIALIAS, FALSE );

    // Display initial wait screen
    m_pd3dDevice->Clear(0, NULL, D3DCLEAR_TARGET, 0x00000000, 1.0f, 0L);
    DisplayStartupInfo();
    m_pd3dDevice->Present(NULL, NULL, NULL, NULL);

    // initialize robot data
    hr = m_Robot.Init(m_pd3dDevice);
    if( FAILED(hr) )
        return hr;
    
    D3DXMATRIX matView;
    D3DXMatrixLookAtLH( &matView, &g_vEye, &g_vAt, &g_vUp );
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );

    D3DXMATRIX matProj;
    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI * 100.0f / 360.0f,
                                640.0f  / 480.0f, 1.0f, 1000.0f );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );

    // Initalize our lights
    InitLights();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: InitFrameworkStuff()
// Desc: Initialize framework objects
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::InitFrameworkStuff()
{
    HRESULT             hr;

    if( FAILED( hr = m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    if( FAILED( hr = m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    FLOAT fFontWidth;
    m_Font.GetTextExtent( L"M", &fFontWidth, &m_fFontHeight, TRUE );

    XMenuItem   *pmi;
    XMenu_SetFont( &m_Font );

    // sub-menu for mesh selection
    m_pMeshMenu = XMenu_Init(320.0f, 100.0f, 2, 0, NULL);
    m_pMeshMenu->topcolor    = 0xffffffff;
    m_pMeshMenu->bottomcolor = 0xffffffff;
    m_pMeshMenu->itemcolor   = 0xff000000;
    m_pMeshMenu->seltopcolor = 0xffcedfad;
    m_pMeshMenu->selbotcolor = 0xff84b642;

    XMenu_AddItem( m_pMeshMenu, MITEM_ROUTINE, L"Xbox Mesh",
                   ToggleMeshMenuProc);
    XMenu_AddItem( m_pMeshMenu, MITEM_ROUTINE, L"Original Mesh",
                   ToggleMeshMenuProc );

    // sub-menu for add/delete options
    m_pAddDeleteMenu = XMenu_Init(320.0f, 100.0f, 2, 0, NULL);
    m_pAddDeleteMenu->topcolor = 0xffffffff;
    m_pAddDeleteMenu->bottomcolor = 0xffffffff;
    m_pAddDeleteMenu->itemcolor = 0xff000000;
    m_pAddDeleteMenu->seltopcolor = 0xffcedfad;
    m_pAddDeleteMenu->selbotcolor = 0xff84b642;

    pmi = XMenu_AddItem( m_pAddDeleteMenu, MITEM_ROUTINE, L"Add",
                         AddDeleteMenuProc );
    pmi->val2 = MENUSELECT_ADD;
    pmi = XMenu_AddItem( m_pAddDeleteMenu, MITEM_ROUTINE, L"Delete",
                         AddDeleteMenuProc);
    pmi->val2 = MENUSELECT_DELETE;

    // sub-menu for enable/disable options
    m_pEnableDisableMenu = XMenu_Init(320.0f, 100.0f, 2, 0, NULL);
    m_pEnableDisableMenu->topcolor = 0xffffffff;
    m_pEnableDisableMenu->bottomcolor = 0xffffffff;
    m_pEnableDisableMenu->itemcolor = 0xff000000;
    m_pEnableDisableMenu->seltopcolor = 0xffcedfad;
    m_pEnableDisableMenu->selbotcolor = 0xff84b642;

    pmi = XMenu_AddItem( m_pEnableDisableMenu, MITEM_ROUTINE, L"Enable",
                         AddDeleteMenuProc );
    pmi->val2 = MENUSELECT_ENABLE;
    pmi = XMenu_AddItem( m_pEnableDisableMenu, MITEM_ROUTINE, L"Disable",
                         AddDeleteMenuProc );
    pmi->val2 = MENUSELECT_DISABLE;

    // sub-menu for cull mode
    m_pCullMenu = XMenu_Init(320.0f, 100.0f, 3, 0, NULL);
    m_pCullMenu->topcolor = 0xffffffff;
    m_pCullMenu->bottomcolor = 0xffffffff;
    m_pCullMenu->itemcolor = 0xff000000;
    m_pCullMenu->seltopcolor = 0xffcedfad;
    m_pCullMenu->selbotcolor = 0xff84b642;

    pmi = XMenu_AddItem( m_pCullMenu, MITEM_ROUTINE, L"None", CullModeMenuProc );
    pmi->val1 = D3DCULL_NONE;
    pmi = XMenu_AddItem( m_pCullMenu, MITEM_ROUTINE, L"CW", CullModeMenuProc );
    pmi->val1 = D3DCULL_CW;
    pmi = XMenu_AddItem( m_pCullMenu, MITEM_ROUTINE, L"CCW", CullModeMenuProc );
    pmi->val1 = D3DCULL_CCW;

    // sub-menu for fill mode
    m_pFillMenu = XMenu_Init(320.0f, 100.0f, 3, 0, NULL);
    m_pFillMenu->topcolor = 0xffffffff;
    m_pFillMenu->bottomcolor = 0xffffffff;
    m_pFillMenu->itemcolor = 0xff000000;
    m_pFillMenu->seltopcolor = 0xffcedfad;
    m_pFillMenu->selbotcolor = 0xff84b642;

    pmi = XMenu_AddItem( m_pFillMenu, MITEM_ROUTINE, L"Solid", FillModeMenuProc );
    pmi->val1 = D3DFILL_SOLID;
    pmi = XMenu_AddItem( m_pFillMenu, MITEM_ROUTINE, L"WireFrame", FillModeMenuProc );
    pmi->val1 = D3DFILL_WIREFRAME;
    pmi = XMenu_AddItem( m_pFillMenu, MITEM_ROUTINE, L"Point", FillModeMenuProc );
    pmi->val1 = D3DFILL_POINT;

    // main menu
    m_pMainMenu = XMenu_Init(320.0f, 100.0f, 17, MENU_WRAP, NULL);
    m_pMainMenu->topcolor = 0xffffffff;
    m_pMainMenu->bottomcolor = 0xffffffff;
    m_pMainMenu->itemcolor = 0xff000000;
    m_pMainMenu->seltopcolor = 0xffcedfad;
    m_pMainMenu->selbotcolor = 0xff84b642;

    XMenu_AddItem( m_pMainMenu, 0, L"Change Mesh", m_pMeshMenu );            
    pmi = XMenu_AddItem( m_pMainMenu, 0, L"Expensive Operations",
                         m_pEnableDisableMenu );
    pmi->val1 = MENUCMD_EXPENSIVEOP;
    XMenu_AddItem( m_pMainMenu, 0, L"Cull mode", m_pCullMenu );
    XMenu_AddItem( m_pMainMenu, 0, L"Fill mode", m_pFillMenu );

    XMenu_AddItem(m_pMainMenu, MITEM_SEPARATOR, NULL, NULL);
    pmi = XMenu_AddItem( m_pMainMenu, 0, L"Directional Light",
                         m_pAddDeleteMenu );
    pmi->val1 = MENUCMD_DIRLIGHT;
    pmi = XMenu_AddItem( m_pMainMenu, 0, L"Point Light", m_pAddDeleteMenu );
    pmi->val1 = MENUCMD_POINTLIGHT;
    pmi = XMenu_AddItem( m_pMainMenu, 0, L"Spot Light", m_pAddDeleteMenu );
    pmi->val1 = MENUCMD_SPOTLIGHT;

    XMenu_AddItem(m_pMainMenu, MITEM_SEPARATOR, NULL, NULL);
    pmi = XMenu_AddItem( m_pMainMenu, 0, L"Texture", m_pAddDeleteMenu );
    pmi->val1 = MENUCMD_TEXTURES;
    pmi = XMenu_AddItem( m_pMainMenu, 0, L"Z-enable", m_pEnableDisableMenu );
    pmi->val1 = MENUCMD_ZENABLE;
    pmi = XMenu_AddItem( m_pMainMenu, 0, L"Specular", m_pEnableDisableMenu );
    pmi->val1 = MENUCMD_SPECULARENABLE;
    pmi = XMenu_AddItem( m_pMainMenu, 0, L"LocalViewer", m_pEnableDisableMenu );
    pmi->val1 = MENUCMD_LOCALVIEWER;
    pmi = XMenu_AddItem( m_pMainMenu, 0, L"AntiAliasing", m_pEnableDisableMenu );
    pmi->val1 = MENUCMD_ANTIALIAS;

    XMenu_AddItem(m_pMainMenu, MITEM_SEPARATOR, NULL, NULL);
    pmi = XMenu_AddItem( m_pMainMenu, 0, L"Toggle Display Info",
                         m_pEnableDisableMenu );
    pmi->val1 = MENUCMD_DISPLAYINFO;
    pmi = XMenu_AddItem( m_pMainMenu, MITEM_ROUTINE, L"Reset Parameters",
                         ResetAllProc );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: ToggleMeshMenuProc()
// Desc: Toggles the mesh to use
//-----------------------------------------------------------------------------
DWORD ToggleMeshMenuProc(DWORD cmd, XMenuItem *pmi)
{

    if (g_Options.meshtype == MESH_Original)
    {
        g_Options.meshtype = MESH_Xbox;
        g_Options.bRebuildVBs = true;
    }
    else
    {
        g_Options.meshtype = MESH_Original;
        g_Options.bRebuildVBs = true;
    }

    return MROUTINE_DIE;
}




//-----------------------------------------------------------------------------
// Name: CullModeMenuProc()
// Desc: Changes the cull mode (none, cw, ccw)
//-----------------------------------------------------------------------------
DWORD CullModeMenuProc(DWORD cmd, XMenuItem *pmi)
{
    g_Options.cullmode = D3DCULL(pmi->val1);
    
    return MROUTINE_DIE;
}




//-----------------------------------------------------------------------------
// Name: FillModeMenuProc()
// Desc: Changes the fill mode (solid, wireframe, point)
//-----------------------------------------------------------------------------
DWORD FillModeMenuProc(DWORD cmd, XMenuItem *pmi)
{
    g_Options.FillMode = D3DFILLMODE(pmi->val1);

    return MROUTINE_DIE;
}




//-----------------------------------------------------------------------------
// Name: AddDeleteMenuProc()
// Desc: Menu callback for submenus add/delete and enable/disable.
//-----------------------------------------------------------------------------
DWORD AddDeleteMenuProc(DWORD cmd, XMenuItem *pmi)
{
    _xmenu           *pMenuParent = pmi->menu->parent;
    DWORD            val1Parent;
    
    // get the val1 of the parent menu
    val1Parent = pMenuParent->items[pMenuParent->curitem].val1;

    // pmi->val2 holds the action (add/delete)
    switch (val1Parent)
    {
        case MENUCMD_DIRLIGHT:
            if (pmi->val2)
            {
                g_Options.dwDirectionalLights = (g_Options.dwDirectionalLights + 
                        MAX_LIGHTS + 1) % MAX_LIGHTS;
            }
            else
            {
                g_Options.dwDirectionalLights = (g_Options.dwDirectionalLights +
                        MAX_LIGHTS - 1) % MAX_LIGHTS;
            }
            g_Options.bLightsChanged = true;
            break;

        case MENUCMD_POINTLIGHT:
            if (pmi->val2)
            {
                g_Options.dwPointLights = (g_Options.dwPointLights +
                        MAX_LIGHTS + 1) % MAX_LIGHTS;
            }
            else
            {
                g_Options.dwPointLights = (g_Options.dwPointLights +
                        MAX_LIGHTS - 1) % MAX_LIGHTS;
            }
            g_Options.bLightsChanged = true;
            break;

        case MENUCMD_SPOTLIGHT:
            if (pmi->val2)
            {
                g_Options.dwSpotLights = (g_Options.dwSpotLights + MAX_LIGHTS +
                        1) % MAX_LIGHTS;
            }
            else
            {
                g_Options.dwSpotLights = (g_Options.dwSpotLights + MAX_LIGHTS -
                        1) % MAX_LIGHTS;
            }
            g_Options.bLightsChanged = true;
            break;


        case MENUCMD_TEXTURES:
            if (pmi->val2)
            {
                g_Options.dwNumTextures++;

                if(g_Options.dwNumTextures > 2)
                    g_Options.dwNumTextures = 2;
            }
            else
            {
                g_Options.dwNumTextures--;

                if(g_Options.dwNumTextures < 0)
                    g_Options.dwNumTextures = 0;
            }
            break;

        case MENUCMD_ZENABLE:
            g_Options.bZenable = (pmi->val2) ? TRUE : FALSE;
            break;

        case MENUCMD_SPECULARENABLE:
            g_Options.bSpecularenable = (pmi->val2) ? TRUE : FALSE;
            break;

        case MENUCMD_LOCALVIEWER:
            g_Options.bLocalviewer = (pmi->val2) ? TRUE : FALSE;
            break;

        case MENUCMD_ANTIALIAS:
            g_Options.bAntiAlias = (pmi->val2) ? TRUE : FALSE;
            break;

        case MENUCMD_EXPENSIVEOP:   // toggles expensive op on/off
            if (pmi->val2)
            {
                g_Options.dwDirectionalLights = 0;
                g_Options.dwSpotLights    = 0;
                g_Options.dwPointLights   = 1;
                g_Options.dwNumTextures   = 2;
                g_Options.bSpecularenable = TRUE;
                g_Options.bLocalviewer    = TRUE;
                g_Options.bAntiAlias      = TRUE;
            }
            else
            {
                g_Options.dwDirectionalLights = 1;
                g_Options.dwSpotLights    = 0;
                g_Options.dwPointLights   = 0;
                g_Options.dwNumTextures   = 0;
                g_Options.bSpecularenable = FALSE;
                g_Options.bLocalviewer    = FALSE;
                g_Options.bAntiAlias      = FALSE;
            }
            g_Options.bRebuildVBs = true;
            break;

        case MENUCMD_DISPLAYINFO:
            g_Options.bDisplayArgs = pmi->val2 ? true : false;
            break;

    }

    return MROUTINE_DIE;
}




//-----------------------------------------------------------------------------
// Name: ResetAllProc()
// Desc: Menu callback to reset all options to the original states.
//-----------------------------------------------------------------------------
DWORD ResetAllProc(DWORD cmd, XMenuItem *pmi)
{
    ResetOptions();

    // rebuild everything
    g_Options.bRebuildVBs = true;
    g_Options.bLightsChanged = true;
    return MROUTINE_DIE;
}




//-----------------------------------------------------------------------------
// Name: InitLights()
// Desc: Initialize all lights
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::InitLights()
{
    // disable all our existing lights
    while( g_Options.nNumLights-- )
        m_pd3dDevice->LightEnable( g_Options.nNumLights, FALSE );

    // get a count of the new dudes
    g_Options.nNumLights = g_Options.dwDirectionalLights +
                           g_Options.dwPointLights +
                           g_Options.dwSpotLights;

    // setup lights
    float fIntensity = 1.0f / ( g_Options.nNumLights );

    DWORD dwIndex = 0;
    for (int nT = 0; nT < g_Options.dwDirectionalLights; nT++)
    {
        D3DLIGHT8 light;

        ZeroMemory(&light, sizeof(light));
        light.Type        =  D3DLIGHT_DIRECTIONAL;
        light.Diffuse.r   =  1.0f * fIntensity;
        light.Diffuse.g   =  1.0f * fIntensity;
        light.Diffuse.b   =  1.0f * fIntensity;
        light.Direction.x =  0.2f;
        light.Direction.y =  0.3f;
        light.Direction.z = -0.8f;
        m_pd3dDevice->SetLight(dwIndex, &light);
        m_pd3dDevice->LightEnable(dwIndex, TRUE);

        dwIndex++;
    }
    for (nT = 0; nT < g_Options.dwPointLights; nT++)
    {
        D3DLIGHT8 light;

        ZeroMemory(&light, sizeof(light));
        light.Type         =  D3DLIGHT_POINT;
        light.Diffuse.r    =  1.0f * fIntensity;
        light.Diffuse.g    =  1.0f * fIntensity;
        light.Diffuse.b    =  1.0f * fIntensity;
        light.Specular.r   =  0.5f * fIntensity;
        light.Specular.g   =  0.5f * fIntensity;
        light.Specular.b   =  0.5f * fIntensity;
        light.Position.x   =  0.0f;
        light.Position.y   =  -10.0f;
        light.Position.z   =  40.0f;
        light.Range        = 10000.0f;
        light.Attenuation0 = 0.0f;
        light.Attenuation1 = 0.02f;
        light.Attenuation2 = 0.0f;
        m_pd3dDevice->SetLight(dwIndex, &light);
        m_pd3dDevice->LightEnable(dwIndex, TRUE);

        dwIndex++;
    }
    for (nT = 0; nT < g_Options.dwSpotLights; nT++)
    {
        D3DLIGHT8 light;

        ZeroMemory(&light, sizeof(light));
        light.Type         =  D3DLIGHT_SPOT;
        light.Diffuse.r    =  1.0f * fIntensity;
        light.Diffuse.g    =  1.0f * fIntensity;
        light.Diffuse.b    =  1.0f * fIntensity;
        light.Position.x   = -1.0f;
        light.Position.y   = -5.0f;
        light.Position.z   =  6.0f;
        light.Direction.x  =  0.1f;
        light.Direction.y  =  0.5f;
        light.Direction.z  = -0.6f;
        light.Range        = 999.0f;
        light.Theta        = 0.1f;
        light.Phi          = 0.5f;
        light.Falloff      = 1.0f;
        light.Attenuation0 = 1.0f;
        m_pd3dDevice->SetLight(dwIndex, &light);
        m_pd3dDevice->LightEnable(dwIndex, TRUE);

        dwIndex++;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    m_dwMenuCommand = XMenu_GetCommand(&m_DefaultGamepad);
    if (m_dwMenuCommand == MENU_ACTIVATE)
        XMenu_Activate(m_pMainMenu);

    if (XMenu_IsActive())
        return S_OK;

    HandleInput();

    if (g_Options.bRebuildVBs)
    {
        m_pd3dDevice->Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0x00000000, 1.0f, 0L);
        DisplayInfo( L"Recalculating...." );
        m_pd3dDevice->Present(NULL, NULL, NULL, NULL);
        m_Robot.InitVertexBuffers();
        g_Options.bRebuildVBs = false;

        // Clear the averages
        m_Stats.dwAvgCount      = 0;
        m_Stats.fdAvgTriPerSec  = 0.0;
        m_Stats.fdAvgTriPerSec2 = 0.0;
        m_Stats.fdMaxTriPerSec  = 0.0;
        m_Stats.fdMinTriPerSec  = 1e99;
    }

    if (g_Options.bLightsChanged)
    {
        InitLights();
        g_Options.bLightsChanged = false;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: HandleInput()
// Desc: Handle input from the gamepad. A return of true means new options
//       require re-initializing vertex/index buffers
//-----------------------------------------------------------------------------
BOOL CXBoxSample::HandleInput()
{
    static short        sCullMode = 0;
    float               fX = 0.0f;
    float               fLY = 0.0f;
    float               fRY = 0.0f;

    if(m_DefaultGamepad.fX1)
    {
        fX = m_DefaultGamepad.fX1 * 3.0f;
    }
    if(m_DefaultGamepad.fY1)
    {
        fLY = m_DefaultGamepad.fY1 * 3.0f;
    }
    if(m_DefaultGamepad.fY2)
    {
        fRY = m_DefaultGamepad.fY2 * 3.0f;
    }

    if(m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK) 
    {
        // display the help screen
        static BOOL     bPrevDisplayArgs = g_Options.bDisplayArgs;

        g_Options.bDisplayArgs = false;
        m_bDisplayHelp = !m_bDisplayHelp;

        if (!m_bDisplayHelp)
            g_Options.bDisplayArgs = bPrevDisplayArgs;
    }


    if (fX || fLY || fRY)
    {
        D3DXMATRIX matView;

        // in / out
        float fLength = D3DXVec3LengthSq(&g_vEye);
        D3DXVECTOR3 vEyeNorm = g_vEye / fLength;
        g_vEye += vEyeNorm * fRY * .75f;

        // up / down
        g_vEye.z += fLY;

        // left / right
        float fCos = cosf(fX * D3DX_PI / 180);
        float fSin = sinf(fX * D3DX_PI / 180);
        g_vEye.x = g_vEye.x * fCos - g_vEye.y * fSin;
        g_vEye.y = g_vEye.x * fSin + g_vEye.y * fCos;

        D3DXMatrixLookAtLH(&matView, &g_vEye, &g_vAt, &g_vUp);
        m_pd3dDevice->SetTransform(D3DTS_VIEW, &matView);
    }

    return FALSE;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    static WCHAR s_strStats[MAX_PATH] = L"Running...";
    DWORD       dwFrames         = 0;
    DWORD       dwPrimitiveCount = 0;
    DWORD       dwTriCount       = 0;
    DWORD       dwIndCount       = 0;
    DWORD       dwNumVertices    = 0;
    DWORD       dwCacheHits      = 0;
    DWORD       dwPagesCrossed   = 0;
    DWORD       dwDegenerateTris = 0;

    DWORD       dwStart = GetTickCount();
    DWORD       dwNow   = dwStart;
    DWORD       dwNext  = dwStart + 2000;

    // Clear the viewport
    m_pd3dDevice->Clear( 0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0x00000000,
                         1.0f, 0L );

    // Render the robot
    m_Robot.SetStates();
    
    // Draw robot a bunch of times
    for( DWORD dwX = 0; dwX < m_Stats.dwDrawPassesX; dwX++ )
    {
        for( DWORD dwY = 0; dwY < m_Stats.dwDrawPassesY; dwY++ )
        {
            D3DXMATRIX matWorld;
            D3DXMatrixTranslation( &matWorld, (dwX - m_Stats.dwDrawPassesX / 2.0f) * 3.5f, 
                                              0.0f, 
                                              (dwY - m_Stats.dwDrawPassesY / 2.0f) * 4.0f );
            m_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld );

            m_Robot.Render( &m_Stats );
        }
    }

    m_Robot.RestoreStates();

    dwFrames++;
    dwNow = GetTickCount();

    DisplayInfo( s_strStats );

    XMenu_Routine(m_dwMenuCommand); 

    if (m_cPause == 1)
        return S_OK;

    FLOAT fElapsedTime = 0.001f * (dwNow-dwStart);
    FLOAT tps = 1e-6f * (m_Stats.dwTriCount)   / fElapsedTime;
    FLOAT sps = 1e-6f * (m_Stats.dwIndCount)   / fElapsedTime;
    FLOAT ips = 1e-6f * (m_Stats.dwIndCount*2) / fElapsedTime;
    swprintf( s_strStats, L"%6.1f MTri/s,   %6.1f MVerts/s", tps, sps );

    m_Stats.dwAvgCount++;
    m_Stats.fdAvgTriPerSec  += tps;
    m_Stats.fdAvgTriPerSec2 += 1e-6f * (m_Stats.dwTriCount - m_Stats.dwDegenerateTris) / fElapsedTime;
    m_Stats.fdMaxTriPerSec   = max(tps, m_Stats.fdMaxTriPerSec);
    m_Stats.fdMinTriPerSec   = min(tps, m_Stats.fdMinTriPerSec);
    m_Stats.dwTime           = dwNow - dwStart;
    m_Stats.dwFrames         = dwFrames;

    m_Stats.dwTriCount       = dwTriCount;
    m_Stats.dwIndCount       = dwIndCount;
    m_Stats.dwNumVertices    = dwNumVertices;
    m_Stats.dwCacheHits      = dwCacheHits;
    m_Stats.dwPagesCrossed   = dwPagesCrossed;
    m_Stats.dwDegenerateTris = dwDegenerateTris;

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DisplayStartupInfo()
// Desc: Display the various system info.
//-----------------------------------------------------------------------------
VOID CXBoxSample::DisplayStartupInfo()
{
    WCHAR        str[128];
    static DWORD s_dwCpuSpeed = (DWORD)XBPerf_GetCpuSpeed();

    m_Font.DrawText(  64,  50,  COLOR_WHITE, L"Xbox Tri-stripper demo" );
    m_Font.DrawText(  64,  75,   0xff00ffff, L"Calculating data. Please wait..." );

    swprintf( str, L"%d MHz", s_dwCpuSpeed);
    m_Font.DrawText(  64, 125,  COLOR_WHITE, L"CPU speed:" );
    m_Font.DrawText( 200, 125, COLOR_YELLOW, str );

    swprintf( str, L"%d", m_d3dpp.BackBufferWidth );
    m_Font.DrawText(  64, 150,  COLOR_WHITE, L"Width:" );
    m_Font.DrawText( 200, 150, COLOR_YELLOW, str );

    swprintf( str, L"%d", m_d3dpp.BackBufferHeight );
    m_Font.DrawText(  64, 175,  COLOR_WHITE, L"Height:" );
    m_Font.DrawText( 200, 175, COLOR_YELLOW, str );
}




//-----------------------------------------------------------------------------
// Name: DisplayInfo()
// Desc: Display the various info.
//-----------------------------------------------------------------------------
VOID CXBoxSample::DisplayInfo( const WCHAR* str )
{

    // Update status
    if( m_bDisplayStats )
        m_Font.DrawText( 64.0f, 75.0f, 0xff00ffff, str );

    // Display help/args
    if( g_Options.bDisplayArgs )
        DisplayArgs();

    if( m_bDisplayHelp )
        m_Help.Render( &m_Font, g_NormalHelpCallouts, MAX_NORMAL_HELP_CALLOUTS );
    else
    {
        // Draw title and framerate
        m_Font.DrawText(  64, 50, 0xffffffff, L"Strip" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );
    }
}




//-----------------------------------------------------------------------------
// Name: DisplayArgs()
// Desc: Display the various stats and options.
//-----------------------------------------------------------------------------
void CXBoxSample::DisplayArgs()
{
    WCHAR str[128];
    float fX[4]   = { 64.0f, 250.0f, 365.0f, 500.0f };
    float fY      = 125.0f;
    float fHeight = m_fFontHeight;

    // Draw left-hand column
    fY      = 125.0f;

    DWORD dwRobotsDrawn = max(1, ( m_Stats.dwFrames * m_Stats.dwDrawPassesX * m_Stats.dwDrawPassesY ) );

    swprintf( str, L"%d", m_Stats.dwTriCount );
    m_Font.DrawText( fX[0], fY,  COLOR_WHITE, L"Num triangles:" );
    m_Font.DrawText( fX[1], fY, COLOR_YELLOW, str );
    fY += fHeight;

    swprintf( str, L"%d", m_Stats.dwDegenerateTris );
    m_Font.DrawText( fX[0], fY,  COLOR_WHITE, L"Num degenerate:" );
    m_Font.DrawText( fX[1], fY, COLOR_YELLOW, str );
    fY += fHeight;

    swprintf( str, L"%d", m_Stats.dwNumVertices );
    m_Font.DrawText( fX[0], fY,  COLOR_WHITE, L"Num vertices:" );
    m_Font.DrawText( fX[1], fY, COLOR_YELLOW, str );
    fY += fHeight;

    swprintf( str, L"%d", m_Stats.dwIndCount );
    m_Font.DrawText( fX[0], fY,  COLOR_WHITE, L"Num indices:" );
    m_Font.DrawText( fX[1], fY, COLOR_YELLOW, str );
    fY += fHeight;

    swprintf( str, L"%.3f", m_Stats.fdMaxTriPerSec );
    m_Font.DrawText( fX[0], fY,  COLOR_WHITE, L"Max tri/s" );
    m_Font.DrawText( fX[1], fY, COLOR_YELLOW, str );
    fY += fHeight;

    swprintf( str, L"%.3f", m_Stats.fdMinTriPerSec );
    m_Font.DrawText( fX[0], fY,  COLOR_WHITE, L"Min tri/s" );
    m_Font.DrawText( fX[1], fY, COLOR_YELLOW, str );
    fY += fHeight;

    swprintf( str, L"%.3f", m_Stats.fdAvgTriPerSec / m_Stats.dwAvgCount );
    m_Font.DrawText( fX[0], fY,  COLOR_WHITE, L"Avg tri/s" );
    m_Font.DrawText( fX[1], fY, COLOR_YELLOW, str );
    fY += fHeight;

    swprintf( str, L"%.3f", m_Stats.fdAvgTriPerSec2 / m_Stats.dwAvgCount );
    m_Font.DrawText( fX[0], fY,  COLOR_WHITE, L"Real avg tri/s:" );
    m_Font.DrawText( fX[1], fY, COLOR_YELLOW, str );
    fY += fHeight;

    swprintf( str, L"%d", m_Stats.dwCacheHits );
    m_Font.DrawText( fX[0], fY,  COLOR_WHITE, L"GPU cache hits:" );
    m_Font.DrawText( fX[1], fY, COLOR_YELLOW, str );
    fY += fHeight;

    DWORD vbpages = (m_Stats.dwNumVertices + m_Stats.dwNumVertices * m_Robot.m_dwVertexSize) / (1024 * 4);
    swprintf( str, L"%d", vbpages );
    m_Font.DrawText( fX[0], fY,  COLOR_WHITE, L"VB pages:" );
    m_Font.DrawText( fX[1], fY, COLOR_YELLOW, str );
    fY += fHeight;

    swprintf( str, L"%d", m_Stats.dwPagesCrossed );
    m_Font.DrawText( fX[0], fY,  COLOR_WHITE, L"Pages crossed:" );
    m_Font.DrawText( fX[1], fY, COLOR_YELLOW, str );
    fY += fHeight;

    swprintf( str, L"%d ms", m_Stats.dwTime);
    m_Font.DrawText( fX[0], fY,  COLOR_WHITE, L"Time/frame:" );
    m_Font.DrawText( fX[1], fY, COLOR_YELLOW, str );
    fY += fHeight;

    // Draw right-hand column
    fY = 125.0f;
    
    static const WCHAR *rgMeshType[MESH_Max] = { L"Original", L"Stripped" };
    swprintf( str, L"%s", rgMeshType[g_Options.meshtype] );
    m_Font.DrawText( fX[2], fY,  COLOR_WHITE, L"Mesh:" );
    m_Font.DrawText( fX[3], fY, COLOR_YELLOW, str );
    fY += fHeight;

    static const WCHAR *rgszCullMode[] = { L"None", L"CCW", L"CW" };
    swprintf( str, L"%s", rgszCullMode[(g_Options.cullmode == 0) ? 0 : ((g_Options.cullmode & 0xf) + 1)] );
    m_Font.DrawText( fX[2], fY,  COLOR_WHITE, L"Cull mode:" );
    m_Font.DrawText( fX[3], fY, COLOR_YELLOW, str );
    fY += fHeight;

    swprintf( str, L"%d", g_Options.dwNumTextures );
    m_Font.DrawText( fX[2], fY,  COLOR_WHITE, L"Tex (2 max):" );
    m_Font.DrawText( fX[3], fY, COLOR_YELLOW, str );
    fY += fHeight;

    static const WCHAR *rgszFillMode[] = { L"Point", L"Wireframe", L"Solid" };
    swprintf( str, L"%s", rgszFillMode[g_Options.FillMode & 0xf] );
    m_Font.DrawText( fX[2], fY,  COLOR_WHITE, L"Fill mode:" );
    m_Font.DrawText( fX[3], fY, COLOR_YELLOW, str );
    fY += fHeight;

    swprintf( str, L"%d", g_Options.dwSpotLights );
    m_Font.DrawText( fX[2], fY,  COLOR_WHITE, L"Spotlights:" );
    m_Font.DrawText( fX[3], fY, COLOR_YELLOW, str );
    fY += fHeight;

    swprintf( str, L"%s", g_Options.bZenable ? L"Yes" : L"No" );
    m_Font.DrawText( fX[2], fY,  COLOR_WHITE, L"Z-enable:" );
    m_Font.DrawText( fX[3], fY, COLOR_YELLOW, str );
    fY += fHeight;

    swprintf( str, L"%d", g_Options.dwDirectionalLights );
    m_Font.DrawText( fX[2], fY,  COLOR_WHITE, L"DirLights:" );
    m_Font.DrawText( fX[3], fY, COLOR_YELLOW, str );
    fY += fHeight;

    swprintf( str, L"%s", g_Options.bSpecularenable ? L"Yes" : L"No" );
    m_Font.DrawText( fX[2], fY,  COLOR_WHITE, L"Specular:" );
    m_Font.DrawText( fX[3], fY, COLOR_YELLOW, str );
    fY += fHeight;

    swprintf( str, L"%d", g_Options.dwPointLights );
    m_Font.DrawText( fX[2], fY,  COLOR_WHITE, L"Pointlights:" );
    m_Font.DrawText( fX[3], fY, COLOR_YELLOW, str );
    fY += fHeight;

    swprintf( str, L"%s", g_Options.bLocalviewer ? L"Yes" : L"No" );
    m_Font.DrawText( fX[2], fY,  COLOR_WHITE, L"LocalViewer:" );
    m_Font.DrawText( fX[3], fY, COLOR_YELLOW, str );
    fY += fHeight;
    
    swprintf( str, L"%s", g_Options.bAntiAlias ? L"Yes" : L"No" );
    m_Font.DrawText( fX[2], fY,  COLOR_WHITE, L"AntiAliasing:" );
    m_Font.DrawText( fX[3], fY, COLOR_YELLOW, str );
    fY += fHeight;
}




//-----------------------------------------------------------------------------
// Name: CRobotX()
// Desc: CRobotX constructor
//-----------------------------------------------------------------------------
CRobotX::CRobotX()
{
    m_dwNumMeshes = 0;
    m_pMeshes     = NULL;

    m_pTexture1  = NULL;
    m_pTexture2  = NULL;
    m_pd3dDevice = NULL;
}




//-----------------------------------------------------------------------------
// Name: ~CRobotX()
// Desc: CRobotX destructor
//-----------------------------------------------------------------------------
void CRobotX::Release()
{
    for( DWORD i = 0; i < m_dwNumMeshes; i++ )
    {
        SAFE_RELEASE( m_pMeshes[i].pIndexBuffer );
        SAFE_RELEASE( m_pMeshes[i].pVertexBuffer );
    }

    SAFE_DELETE_ARRAY( m_pMeshes );
    m_dwNumMeshes = 0;

    SAFE_RELEASE( m_pTexture1 );
    SAFE_RELEASE( m_pTexture2 );
}




//-----------------------------------------------------------------------------
// Name: Init()
// Desc: Initialize robot dependencies
//-----------------------------------------------------------------------------
HRESULT CRobotX::Init( LPDIRECT3DDEVICE8 pd3dDevice )
{
    HRESULT     hr;

    if( pd3dDevice == NULL )
        return E_INVALIDARG;

    m_pd3dDevice = pd3dDevice;

    // Create our vertex buffers and indices
    InitVertexBuffers();

    // Set material
    ZeroMemory( &m_mat, sizeof(D3DMATERIAL8) );
    m_mat.Diffuse.r  =  1.0f;
    m_mat.Diffuse.g  =  1.0f;
    m_mat.Diffuse.b  =  1.0f;
    m_mat.Diffuse.a  =  1.0f;
    m_mat.Ambient.r  =  1.0f;
    m_mat.Ambient.g  =  1.0f;
    m_mat.Ambient.b  =  1.0f;
    m_mat.Ambient.a  =  1.0f;
    m_mat.Specular.r =  0.8f;
    m_mat.Specular.g =  0.8f;
    m_mat.Specular.b =  0.8f;
    m_mat.Specular.a =  0.4f;
    m_mat.Power      = 16.0f;

    // Load the texture
    hr = D3DXCreateTextureFromFileA( pd3dDevice, "D:\\Media\\Textures\\Strip_T.dds", 
                                     &m_pTexture1 );
    if (FAILED(hr))
        return hr;

    // Load the environment map textures
    hr = D3DXCreateCubeTextureFromFileA( pd3dDevice, "D:\\Media\\Textures\\Strip_C.dds", 
                                         &m_pTexture2 );
    if (FAILED(hr))
        return hr;

    OUTPUT_DEBUG_STRING( "Strip: Successfull CRobotX::Init()\n" );
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Renders the robot mesh 12 times and calc stats
//-----------------------------------------------------------------------------
HRESULT CRobotX::Render( ROBOTSTATS* pStats )
{
    D3DXMATRIX matWorld;
    m_pd3dDevice->GetTransform( D3DTS_WORLD, &matWorld );
    
    // Render each part
    for( DWORD iVB = 0; iVB < m_dwNumMeshes; iVB++ )
    {
        // Set our world transform
        D3DXMATRIX matObject(*g_ModelData[iVB].pMatrix);
        D3DXMatrixMultiply( &matObject, &matObject, &matWorld );
        m_pd3dDevice->SetTransform( D3DTS_WORLD, &matObject );

        // Draw robot
        m_pd3dDevice->SetVertexShader( m_dwFVF );
        m_pd3dDevice->SetStreamSource( 0, m_pMeshes[iVB].pVertexBuffer, m_dwVertexSize );
        m_pd3dDevice->SetIndices( m_pMeshes[iVB].pIndexBuffer, 0 );
        m_pd3dDevice->DrawIndexedPrimitive( m_pMeshes[iVB].dwPrimType, 
                                            0, m_pMeshes[iVB].dwNumVertices, 
                                            0, m_pMeshes[iVB].dwPrimitiveCount );

        // Record stats
        pStats->dwTriCount       += m_pMeshes[iVB].dwPrimitiveCount;
        pStats->dwIndCount       += m_pMeshes[iVB].dwIndexCount;
        pStats->dwNumVertices    += m_pMeshes[iVB].dwNumVertices;
        pStats->dwCacheHits      += m_pMeshes[iVB].dwCacheHits;
        pStats->dwPagesCrossed   += m_pMeshes[iVB].dwPagesCrossed;
        pStats->dwDegenerateTris += m_pMeshes[iVB].dwDegenerateTris;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SetStates()
// Desc: Set states that will be used to render the scene
//-----------------------------------------------------------------------------
HRESULT CRobotX::SetStates()
{
    m_pd3dDevice->SetMaterial( &m_mat );

    m_pd3dDevice->SetRenderState(D3DRS_LIGHTING, TRUE);
    m_pd3dDevice->SetRenderState(D3DRS_AMBIENT, D3DCOLOR_COLORVALUE(.5, .5, .5, 1.0f));
    m_pd3dDevice->SetRenderState(D3DRS_NORMALIZENORMALS, TRUE);
    m_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
    m_pd3dDevice->SetRenderState(D3DRS_ALPHATESTENABLE, FALSE);

    m_pd3dDevice->SetRenderState(D3DRS_ZENABLE, g_Options.bZenable);
    m_pd3dDevice->SetRenderState(D3DRS_SPECULARENABLE, g_Options.bSpecularenable);
    m_pd3dDevice->SetRenderState(D3DRS_LOCALVIEWER, g_Options.bLocalviewer);
    m_pd3dDevice->SetRenderState(D3DRS_MULTISAMPLEANTIALIAS, g_Options.bAntiAlias);

    for(DWORD dwStage = 0; dwStage < 2; dwStage++)
    {
        m_pd3dDevice->SetTextureStageState(dwStage, D3DTSS_MAXANISOTROPY, 3);
        m_pd3dDevice->SetTextureStageState(dwStage, D3DTSS_MINFILTER, D3DTEXF_ANISOTROPIC);
        m_pd3dDevice->SetTextureStageState(dwStage, D3DTSS_MAGFILTER, D3DTEXF_ANISOTROPIC);
        m_pd3dDevice->SetTextureStageState(dwStage, D3DTSS_MIPFILTER, D3DTEXF_LINEAR);
    }

    m_pd3dDevice->SetRenderState(D3DRS_CULLMODE, g_Options.cullmode);
    m_pd3dDevice->SetRenderState(D3DRS_FILLMODE, g_Options.FillMode);

    if(g_Options.dwNumTextures)
    {
        m_pd3dDevice->SetTexture(0, m_pTexture1);

        // Modulate texture 0 with diffuse
        m_pd3dDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_MODULATE);
        m_pd3dDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
        m_pd3dDevice->SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_DIFFUSE);

        m_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
        m_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);

        if(g_Options.dwNumTextures > 1)
        {
            // transform incoming camera space reflection vectors to world space
            D3DXMATRIX matTex;

            m_pd3dDevice->GetTransform(D3DTS_VIEW, &matTex);
            matTex.m[3][0] = 0.0f;
            matTex.m[3][1] = 0.0f;
            matTex.m[3][2] = 0.0f;

            D3DXMatrixInverse(&matTex, NULL, &matTex);
            m_pd3dDevice->SetTransform(D3DTS_TEXTURE1, &matTex);

            m_pd3dDevice->SetTexture(1, m_pTexture2);

            // Modulate the color of the second argument, using the alpha of the first argument;
            // then add the result to arg one.
            m_pd3dDevice->SetTextureStageState(1, D3DTSS_COLOROP, D3DTOP_MODULATEALPHA_ADDCOLOR);
            m_pd3dDevice->SetTextureStageState(1, D3DTSS_COLORARG1, D3DTA_CURRENT);
            m_pd3dDevice->SetTextureStageState(1, D3DTSS_COLORARG2, D3DTA_TEXTURE);

            // Generate camera-space reflection vectors as tex coords
            m_pd3dDevice->SetTextureStageState(1, D3DTSS_TEXCOORDINDEX,
                D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR | 1);

            // Setup the texture transform pipeline for 3d tex coords
            m_pd3dDevice->SetTextureStageState(1, D3DTSS_TEXTURETRANSFORMFLAGS,
                D3DTTFF_COUNT3);

            m_pd3dDevice->SetTextureStageState(2, D3DTSS_COLOROP, D3DTOP_DISABLE);
        }
        else
        {
            m_pd3dDevice->SetTextureStageState(1, D3DTSS_COLOROP, D3DTOP_DISABLE);
            m_pd3dDevice->SetTextureStageState(1, D3DTSS_ALPHAOP, D3DTOP_DISABLE);

            D3DXMATRIX matIdentity;
            D3DXMatrixIdentity(&matIdentity);
            m_pd3dDevice->SetTransform(D3DTS_TEXTURE1, &matIdentity);

            m_pd3dDevice->SetTextureStageState(1, D3DTSS_TEXCOORDINDEX, 0);
            m_pd3dDevice->SetTextureStageState(1, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_DISABLE);
        }
    }
    else
    {
        m_pd3dDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_DISABLE);
        m_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: RestoreStates()
// Desc: Restore all used states
//-----------------------------------------------------------------------------
HRESULT CRobotX::RestoreStates()
{
    if(g_Options.dwNumTextures)
    {
        m_pd3dDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_DISABLE);
        m_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_DISABLE);

        if(g_Options.dwNumTextures > 1)
        {
            m_pd3dDevice->SetTextureStageState(1, D3DTSS_COLOROP, D3DTOP_DISABLE);
            m_pd3dDevice->SetTextureStageState(1, D3DTSS_ALPHAOP, D3DTOP_DISABLE);

            D3DXMATRIX matIdentity;
            D3DXMatrixIdentity(&matIdentity);
            m_pd3dDevice->SetTransform(D3DTS_TEXTURE1, &matIdentity);

            m_pd3dDevice->SetTextureStageState(1, D3DTSS_TEXCOORDINDEX, 0);
            m_pd3dDevice->SetTextureStageState(1, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_DISABLE);
        }
    }

    m_pd3dDevice->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);
    m_pd3dDevice->SetRenderState(D3DRS_FILLMODE, D3DFILL_SOLID);

    for(DWORD dwStage = 0; dwStage < 2; dwStage++)
    {
        m_pd3dDevice->SetTextureStageState(dwStage, D3DTSS_MAXANISOTROPY, 1);
        m_pd3dDevice->SetTextureStageState(dwStage, D3DTSS_MINFILTER, D3DTEXF_POINT);
        m_pd3dDevice->SetTextureStageState(dwStage, D3DTSS_MAGFILTER, D3DTEXF_POINT);
        m_pd3dDevice->SetTextureStageState(dwStage, D3DTSS_MIPFILTER, D3DTEXF_NONE);
    }

    m_pd3dDevice->SetRenderState( D3DRS_AMBIENT,          0x00000000 );
    m_pd3dDevice->SetRenderState( D3DRS_NORMALIZENORMALS, FALSE);
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,          D3DZB_TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SPECULARENABLE,   FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_LOCALVIEWER,      TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_MULTISAMPLEANTIALIAS, FALSE );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: InitVertexBuffers()
// Desc: Create vertex and index buffers based on the mesh type being used
//-----------------------------------------------------------------------------
HRESULT CRobotX::InitVertexBuffers()
{
    OUTPUT_DEBUG_STRING( "Strip: Begin initializing vertex buffers\n" );

    // Release any previously allocated meshes
    for( DWORD i = 0; i < m_dwNumMeshes; i++ )
    {
        SAFE_RELEASE( m_pMeshes[i].pIndexBuffer );
        SAFE_RELEASE( m_pMeshes[i].pVertexBuffer );
    }
    SAFE_DELETE_ARRAY( m_pMeshes );
    m_dwNumMeshes = 0;

    // FVF for creating vertex buffers
    m_dwFVF        = D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_TEX1;
    m_dwVertexSize = D3DXGetFVFVertexSize(m_dwFVF);

    // Initialize new mesh array
    m_dwNumMeshes = g_cModelData;
    m_pMeshes     = new MESHINFO[m_dwNumMeshes];
    ZeroMemory( m_pMeshes, m_dwNumMeshes * sizeof(MESHINFO) );

    for( i = 0; i < m_dwNumMeshes; i++ )
    {
        MODELDATA* pModelData = &g_ModelData[i];
        MESHINFO*  pMesh      = &m_pMeshes[i];

        pMesh->dwNumVertices = pModelData->dwNumVertices;
        pMesh->dwIndexCount  = pModelData->dwNumIndices;
        pMesh->pwIndices     = pModelData->pIndices;

        if( g_Options.meshtype == MESH_Xbox )
        {
            DWORD dwNumVertices = pMesh->dwNumVertices;
            DWORD dwStrippedIndexCount;   // Tristrip count
            WORD* pwStrippedIndices;      // Tristrip indices
            WORD* pwVertexPermutation;    // Array for sorting
            
            // Run the tri-list through our tri-stripper
            Stripify( pModelData->dwNumIndices / 3, pModelData->pIndices,
                      &dwStrippedIndexCount, &pwStrippedIndices );

            // Sort the vertices...
            ComputeVertexPermutation( dwStrippedIndexCount, pwStrippedIndices,
                                      dwNumVertices, &pwVertexPermutation );

            // Create a vertex buffer
            m_pd3dDevice->CreateVertexBuffer( dwNumVertices * m_dwVertexSize, 
                                              D3DUSAGE_WRITEONLY, m_dwFVF, 
                                              D3DPOOL_DEFAULT, &pMesh->pVertexBuffer );

            // Lock and fill the vertex buffer, remapping vertices through the
            // vertex permutation array.
            MODELVERT* pVertices;
            pMesh->pVertexBuffer->Lock( 0, 0, (BYTE**)&pVertices, 0 );
            for( DWORD i = 0; i < dwNumVertices; i++ )
                pVertices[i] = pModelData->pVertices[pwVertexPermutation[i]];
            pMesh->pVertexBuffer->Unlock();

            // Free the array allocated by the ComputeVertexPermutation() call
            SAFE_DELETE_ARRAY( pwVertexPermutation );

            pMesh->dwPrimType       = D3DPT_TRIANGLESTRIP;
            pMesh->dwPrimitiveCount = dwStrippedIndexCount - 2;

            // Create an index buffer for using DrawIndexedPrimitive.
            m_pd3dDevice->CreateIndexBuffer( dwStrippedIndexCount * sizeof(WORD),
                                             D3DUSAGE_WRITEONLY, D3DFMT_INDEX16, 
                                             D3DPOOL_DEFAULT, &pMesh->pIndexBuffer );

            // Lock and fill the index buffer
            WORD* pIndices;
            pMesh->pIndexBuffer->Lock( 0, 0, (BYTE**)&pIndices, 0 );
            memcpy( pIndices, pwStrippedIndices, dwStrippedIndexCount * sizeof(WORD) );
            pMesh->pIndexBuffer->Unlock();

            // Free the array allocated by the Stripify() call
            SAFE_DELETE_ARRAY( pwStrippedIndices );
        }
        else // original mesh
        {
            // Create a vertex buffers
            m_pd3dDevice->CreateVertexBuffer( pMesh->dwNumVertices * m_dwVertexSize, 
                                              D3DUSAGE_WRITEONLY, m_dwFVF, 
                                              D3DPOOL_DEFAULT, &pMesh->pVertexBuffer );

            // Lock and fill the vertex buffer
            MODELVERT* pVertices;
            pMesh->pVertexBuffer->Lock( 0, 0, (BYTE**)&pVertices, 0 );
            memcpy( pVertices, pModelData->pVertices, pMesh->dwNumVertices * m_dwVertexSize );
            pMesh->pVertexBuffer->Unlock();

            pMesh->dwPrimType       = D3DPT_TRIANGLELIST;
            pMesh->dwPrimitiveCount = pModelData->dwNumIndices / 3;

            // Create an index buffer for using DrawIndexedPrimitive.
            m_pd3dDevice->CreateIndexBuffer( pMesh->dwIndexCount * sizeof(WORD),
                                             D3DUSAGE_WRITEONLY, D3DFMT_INDEX16, 
                                             D3DPOOL_DEFAULT, &pMesh->pIndexBuffer );

            // Lock and fill the index buffer
            WORD* pIndices;
            pMesh->pIndexBuffer->Lock( 0, 0, (BYTE**)&pIndices, 0 );
            memcpy( pIndices, pModelData->pIndices, pMesh->dwIndexCount*sizeof(WORD) );
            pMesh->pIndexBuffer->Unlock();
        }

        // Figure out how many degenerate triangles and cache hits we've got
        XBPerf_CalcCacheHits( pMesh->dwPrimType, m_dwVertexSize,
                              pMesh->pwIndices, pMesh->dwIndexCount,
                              &pMesh->dwDegenerateTris,
                              &pMesh->dwCacheHits,
                              &pMesh->dwPagesCrossed );
    }

    OUTPUT_DEBUG_STRING( "Strip: Finished initializing vertex buffers\n" );
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\swizzle\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\swizzle\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\swizzle\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\swizzle\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\TextureCompression\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Strip\ModelData.cpp ===
//-----------------------------------------------------------------------------
// File: ModelData.cpp
//
// Desc: Robot data
//
// Copyright (c) 1999-2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>




struct MODELVERT
{
    struct { FLOAT x, y, z; } pos;
    struct { FLOAT x, y, z; } norm;
    struct { FLOAT tu, tv; }  tex;
};

struct MODELDATA
{
    D3DMATRIX*  pMatrix;

    UINT        dwNumVertices;
    MODELVERT*  pVertices;

    UINT        dwNumIndices;
    WORD*       pIndices;
};




// Contains mesh, matrix and indices data for all 77 robot parts

D3DMATRIX g_tmat0 = 
{
    0.989814f, -0.130762f, 0.056304f, 0.000000f, 
    0.131153f, 0.991357f, -0.003276f, 0.000000f, 
    -0.055389f, 0.010627f, 0.998408f, 0.000000f, 
    1.055667f, -2.671128f, 4.426410f, 1.000000f, 
};

// Mesh #0 Tris:572 Verts:498
MODELVERT g_tmesh0[] = 
{
    { {-0.156914f, 0.046228f, 0.004718f}, {-0.830090f, -0.058911f, 0.554509f}, {0.373404f, 0.288829f} },
    { {-0.132361f, 0.119576f, 0.048854f}, {-0.566299f, -0.012994f, 0.824097f}, {0.360292f, 0.299315f} },
    { {-0.133328f, -0.060680f, 0.024243f}, {-0.557874f, -0.135962f, 0.818713f}, {0.386556f, 0.287202f} },
    { {-0.179343f, -0.090213f, -0.191889f}, {-0.001187f, 0.051588f, -0.998668f}, {0.395406f, 0.244101f} },
    { {0.204175f, -0.090213f, -0.191889f}, {0.003755f, 0.047848f, -0.998848f}, {0.356706f, 0.219935f} },
    { {0.222117f, 0.153352f, -0.180154f}, {0.001451f, 0.047630f, -0.998864f}, {0.319530f, 0.230789f} },
    { {0.082351f, -0.238392f, -0.024905f}, {0.052866f, -0.415802f, 0.907917f}, {0.390580f, 0.256447f} },
    { {0.119104f, -0.095733f, 0.034582f}, {0.029104f, -0.273630f, 0.961395f}, {0.366178f, 0.272067f} },
    { {0.133892f, -0.158299f, 0.012588f}, {0.401356f, -0.365975f, 0.839628f}, {0.373763f, 0.264118f} },
    { {0.179192f, -0.229515f, -0.200734f}, {0.001690f, 0.067698f, -0.997704f}, {0.379452f, 0.214212f} },
    { {0.012416f, -0.288615f, -0.205027f}, {0.001690f, 0.067698f, -0.997704f}, {0.404862f, 0.221513f} },
    { {0.216843f, 0.294829f, -0.141574f}, {0.972463f, 0.069564f, -0.222432f}, {0.299532f, 0.244673f} },
    { {0.202750f, 0.300422f, -0.166224f}, {0.654346f, 0.372862f, -0.657880f}, {0.300133f, 0.240666f} },
    { {0.197109f, 0.277387f, -0.174412f}, {0.005167f, 0.079851f, -0.996793f}, {0.304044f, 0.238420f} },
    { {0.157193f, 0.119576f, 0.048854f}, {0.531128f, 0.002530f, 0.847288f}, {0.331073f, 0.281070f} },
    { {0.158160f, -0.060680f, 0.024243f}, {0.570671f, -0.130663f, 0.810717f}, {0.357142f, 0.268835f} },
    { {0.104172f, -0.003373f, 0.052956f}, {0.182303f, -0.095810f, 0.978563f}, {0.354279f, 0.280441f} },
    { {-0.119731f, 0.257021f, -0.002460f}, {-0.176057f, 0.040645f, 0.983541f}, {0.339038f, 0.293261f} },
    { {-0.174981f, 0.144788f, -0.007712f}, {-0.303599f, 0.035593f, 0.952135f}, {0.360910f, 0.291253f} },
    { {-0.178634f, 0.274376f, -0.013721f}, {-0.388991f, 0.106729f, 0.915038f}, {0.342458f, 0.295317f} },
    { {-0.172277f, 0.277387f, -0.174412f}, {-0.017043f, 0.116235f, -0.993075f}, {0.341318f, 0.261695f} },
    { {-0.197285f, 0.153352f, -0.180154f}, {-0.001790f, 0.047093f, -0.998889f}, {0.361851f, 0.257216f} },
    { {0.094468f, 0.325028f, -0.125006f}, {-0.017300f, 0.999453f, -0.028171f}, {0.307501f, 0.257005f} },
    { {0.091529f, 0.327527f, -0.034567f}, {-0.017300f, 0.999453f, -0.028172f}, {0.307470f, 0.276053f} },
    { {-0.067465f, 0.321578f, -0.147991f}, {-0.017300f, 0.999453f, -0.028171f}, {0.324334f, 0.262305f} },
    { {0.012416f, 0.298162f, -0.171667f}, {-0.003030f, 0.349812f, -0.936815f}, {0.319665f, 0.251441f} },
    { {-0.179343f, -0.090213f, -0.191889f}, {-0.087498f, 0.045359f, -0.995131f}, {0.395406f, 0.244101f} },
    { {-0.213947f, -0.003178f, -0.156198f}, {-0.964919f, -0.169144f, -0.200804f}, {0.386273f, 0.257099f} },
    { {-0.154361f, -0.229514f, -0.200734f}, {-0.314695f, -0.013332f, -0.949099f}, {0.413111f, 0.235230f} },
    { {-0.225906f, 0.180506f, -0.098044f}, {-0.279167f, 0.958783f, 0.052933f}, {0.360827f, 0.277120f} },
    { {-0.228950f, 0.177953f, -0.149863f}, {-0.465326f, 0.883771f, -0.049205f}, {0.361486f, 0.266461f} },
    { {-0.153266f, 0.180902f, -0.058265f}, {-0.072247f, 0.978543f, -0.192961f}, {0.353455f, 0.280812f} },
    { {0.243459f, 0.175589f, -0.052590f}, {0.384553f, 0.715516f, -0.583229f}, {0.314196f, 0.256783f} },
    { {0.226482f, 0.262381f, -0.044806f}, {0.549902f, -0.643394f, -0.532590f}, {0.303308f, 0.262871f} },
    { {0.169694f, 0.230989f, -0.052927f}, {0.309499f, -0.315496f, -0.897036f}, {0.313594f, 0.263533f} },
    { {0.238829f, -0.000246f, -0.100141f}, {0.960469f, -0.201476f, 0.192110f}, {0.340179f, 0.240315f} },
    { {0.208951f, -0.098962f, -0.085008f}, {0.695161f, -0.248900f, 0.674389f}, {0.357535f, 0.241466f} },
    { {0.219480f, 0.010202f, -0.048829f}, {0.686468f, -0.290588f, 0.666574f}, {0.340634f, 0.252589f} },
    { {-0.114184f, 0.250138f, 0.026587f}, {-0.701983f, 0.343188f, 0.624053f}, {0.339489f, 0.298669f} },
    { {-0.154372f, 0.126917f, 0.014747f}, {-0.751020f, 0.113468f, 0.650457f}, {0.361434f, 0.293913f} },
    { {-0.056580f, 0.289847f, -0.000801f}, {-0.077059f, 0.453895f, 0.887717f}, {0.327900f, 0.290914f} },
    { {-0.091972f, 0.330840f, -0.025292f}, {-0.040965f, 0.556673f, 0.829721f}, {0.325509f, 0.289669f} },
    { {0.081412f, 0.289847f, -0.000801f}, {0.047763f, 0.511323f, 0.858060f}, {0.313975f, 0.282219f} },
    { {0.202089f, 0.014364f, -0.035950f}, {0.934001f, -0.113881f, 0.338633f}, {0.341789f, 0.256521f} },
    { {0.193350f, -0.097738f, -0.075685f}, {0.931898f, -0.274870f, 0.236672f}, {0.358935f, 0.244432f} },
    { {0.177745f, -0.084249f, -0.001971f}, {0.879375f, -0.204786f, 0.429840f}, {0.358579f, 0.261238f} },
    { {-0.113625f, -0.326053f, -0.124061f}, {-0.126249f, -0.988341f, 0.085112f}, {0.295071f, 0.095036f} },
    { {-0.105671f, -0.322635f, -0.072574f}, {-0.126249f, -0.988341f, 0.085112f}, {0.304123f, 0.035019f} },
    { {-0.066700f, -0.338326f, -0.196973f}, {-0.126249f, -0.988341f, 0.085112f}, {0.348478f, 0.180005f} },
    { {0.261614f, 0.150090f, -0.149601f}, {0.963192f, 0.178092f, -0.201359f}, {0.316030f, 0.234512f} },
    { {0.260250f, 0.007423f, -0.155483f}, {0.987618f, -0.122898f, -0.097505f}, {0.336883f, 0.227783f} },
    { {0.261643f, 0.144869f, -0.092754f}, {0.987265f, 0.093366f, 0.128806f}, {0.316806f, 0.246099f} },
    { {0.225822f, -0.001293f, -0.186107f}, {0.098686f, 0.040636f, -0.994289f}, {0.341611f, 0.223257f} },
    { {-0.090923f, 0.329660f, -0.152080f}, {0.037068f, 0.375743f, -0.925982f}, {0.325526f, 0.263252f} },
    { {-0.203336f, 0.148095f, -0.025046f}, {-0.627310f, -0.044240f, 0.777512f}, {0.363284f, 0.289572f} },
    { {-0.196180f, 0.269912f, -0.027523f}, {-0.789888f, 0.290230f, 0.540225f}, {0.344871f, 0.293384f} },
    { {-0.188324f, 0.322763f, -0.090437f}, {0.807552f, 0.589796f, -0.000210f}, {0.336380f, 0.281908f} },
    { {-0.137425f, 0.244339f, -0.060789f}, {0.805812f, 0.556982f, -0.201091f}, {0.342643f, 0.281777f} },
    { {-0.179329f, 0.311088f, -0.043828f}, {-0.095551f, 0.780275f, -0.618095f}, {0.337185f, 0.290554f} },
    { {-0.175074f, 0.313104f, -0.151387f}, {0.142205f, 0.508494f, 0.849242f}, {0.336422f, 0.268049f} },
    { {-0.126157f, 0.338890f, -0.149275f}, {-0.367376f, 0.177022f, 0.913071f}, {0.327742f, 0.266416f} },
    { {-0.134229f, 0.246195f, -0.144817f}, {-0.070671f, 0.054052f, 0.996034f}, {0.342019f, 0.264215f} },
    { {-0.166005f, -0.251929f, -0.179434f}, {-0.940750f, -0.216279f, -0.261176f}, {0.417549f, 0.239504f} },
    { {-0.166005f, -0.260320f, -0.133280f}, {-0.969209f, -0.220923f, 0.108753f}, {0.418785f, 0.248751f} },
    { {-0.113297f, -0.330995f, -0.198590f}, {-0.157280f, -0.985435f, 0.064652f}, {0.295445f, 0.181910f} },
    { {-0.113625f, -0.326053f, -0.124061f}, {-0.157280f, -0.985435f, 0.064652f}, {0.295071f, 0.095036f} },
    { {-0.066700f, -0.338326f, -0.196973f}, {-0.157280f, -0.985435f, 0.064652f}, {0.348478f, 0.180005f} },
    { {0.154265f, 0.351758f, -0.089141f}, {0.952611f, -0.304028f, -0.009915f}, {0.297599f, 0.261727f} },
    { {0.154253f, 0.353718f, -0.127817f}, {0.996757f, -0.070239f, -0.039274f}, {0.297301f, 0.253780f} },
    { {0.120493f, 0.265569f, -0.143173f}, {0.860137f, -0.294658f, 0.416344f}, {0.313503f, 0.249265f} },
    { {0.199905f, 0.313104f, -0.151387f}, {-0.041225f, 0.406359f, 0.912783f}, {0.298584f, 0.244421f} },
    { {0.213115f, 0.324779f, -0.129407f}, {-0.481854f, 0.875592f, -0.034006f}, {0.295564f, 0.248607f} },
    { {0.164055f, 0.243634f, -0.127734f}, {-0.848555f, 0.527935f, 0.035193f}, {0.312298f, 0.248864f} },
    { {-0.057247f, -0.236592f, -0.029863f}, {-0.093972f, -0.381226f, 0.919694f}, {0.404404f, 0.264285f} },
    { {0.012416f, -0.242755f, -0.030275f}, {-0.000232f, -0.385743f, 0.922606f}, {0.398269f, 0.259568f} },
    { {-0.049471f, -0.322029f, -0.064483f}, {-0.067999f, -0.382798f, 0.921326f}, {0.416013f, 0.253262f} },
    { {0.135947f, -0.324219f, -0.098136f}, {0.962318f, -0.197342f, 0.187082f}, {0.397608f, 0.234511f} },
    { {0.127406f, -0.322612f, -0.073847f}, {0.453764f, -0.369112f, 0.811082f}, {0.398245f, 0.240151f} },
    { {0.140613f, -0.205294f, -0.027846f}, {0.625499f, -0.329683f, 0.707150f}, {0.379894f, 0.253463f} },
    { {-0.238298f, 0.089694f, -0.056701f}, {0.999659f, 0.023222f, -0.011905f}, {0.375281f, 0.282918f} },
    { {-0.238767f, 0.062993f, -0.059707f}, {0.684990f, -0.568338f, 0.455829f}, {0.379204f, 0.281277f} },
    { {-0.237447f, 0.116162f, -0.000658f}, {0.957776f, -0.090949f, 0.272751f}, {0.371373f, 0.295530f} },
    { {-0.254298f, 0.063203f, -0.059150f}, {-0.885339f, -0.315098f, 0.341888f}, {0.380741f, 0.282379f} },
    { {-0.260257f, 0.111576f, -0.070581f}, {-0.989453f, 0.029162f, 0.141890f}, {0.374314f, 0.282280f} },
    { {-0.248030f, 0.107956f, -0.001674f}, {-0.839176f, -0.326910f, 0.434642f}, {0.373632f, 0.295664f} },
    { {0.251226f, 0.183131f, -0.147112f}, {0.088838f, 0.995458f, 0.034210f}, {0.312281f, 0.236978f} },
    { {0.178097f, 0.180902f, -0.058265f}, {0.065004f, 0.982073f, -0.176936f}, {0.320017f, 0.259932f} },
    { {0.236580f, 0.281581f, -0.134919f}, {0.879158f, -0.476379f, -0.012007f}, {0.299467f, 0.244291f} },
    { {0.222112f, 0.264450f, -0.155247f}, {0.383024f, -0.131027f, 0.914398f}, {0.303406f, 0.240313f} },
    { {0.167364f, 0.233806f, -0.146815f}, {0.413802f, -0.513867f, 0.751471f}, {0.313384f, 0.244311f} },
    { {0.090413f, 0.210890f, 0.067369f}, {0.136172f, -0.022958f, 0.990419f}, {0.324559f, 0.292699f} },
    { {-0.069031f, 0.115598f, 0.066693f}, {-0.131638f, -0.044936f, 0.990279f}, {0.354486f, 0.298869f} },
    { {-0.094915f, 0.220883f, 0.059865f}, {-0.273465f, 0.089793f, 0.957682f}, {0.341806f, 0.303212f} },
    { {0.012432f, 0.185813f, 0.072730f}, {-0.019250f, -0.005540f, 0.999799f}, {0.336071f, 0.297742f} },
    { {-0.232847f, 0.004898f, -0.156681f}, {-0.984237f, -0.119470f, -0.130402f}, {0.387007f, 0.258506f} },
    { {-0.239203f, 0.147559f, -0.148651f}, {-0.968807f, 0.214477f, -0.124146f}, {0.366934f, 0.266166f} },
    { {-0.236812f, 0.144869f, -0.092754f}, {-0.988830f, 0.074594f, 0.129037f}, {0.367105f, 0.277508f} },
    { {0.123516f, 0.316455f, -0.020386f}, {0.139848f, 0.531402f, 0.835497f}, {0.305855f, 0.276545f} },
    { {0.199813f, 0.144788f, -0.007712f}, {0.303599f, 0.035593f, 0.952135f}, {0.323090f, 0.267637f} },
    { {0.144563f, 0.257021f, -0.002460f}, {0.176057f, 0.040645f, 0.983541f}, {0.312369f, 0.276608f} },
    { {0.203466f, 0.274376f, -0.013721f}, {0.388991f, 0.106729f, 0.915038f}, {0.303900f, 0.271241f} },
    { {0.181762f, 0.046223f, 0.004689f}, {0.830032f, -0.058911f, 0.554596f}, {0.339229f, 0.267482f} },
    { {0.246263f, 0.022736f, -0.045255f}, {0.895928f, -0.219084f, 0.386412f}, {0.336112f, 0.252135f} },
    { {0.258327f, 0.008637f, -0.101601f}, {0.964139f, -0.223654f, 0.142883f}, {0.336921f, 0.239131f} },
    { {-0.201650f, 0.262381f, -0.044806f}, {-0.549902f, -0.643394f, -0.532590f}, {0.346510f, 0.289848f} },
    { {-0.218627f, 0.175589f, -0.052589f}, {-0.412084f, 0.487288f, -0.769894f}, {0.360824f, 0.285899f} },
    { {-0.144862f, 0.230989f, -0.052927f}, {-0.309500f, -0.315496f, -0.897035f}, {0.345335f, 0.283354f} },
    { {-0.178634f, 0.274376f, -0.013721f}, {-0.678289f, 0.214678f, 0.702736f}, {0.342458f, 0.295317f} },
    { {-0.192072f, 0.291818f, -0.083354f}, {-0.985974f, -0.146639f, 0.079704f}, {0.341255f, 0.282400f} },
    { {-0.195436f, 0.313192f, -0.085642f}, {-0.979182f, 0.135972f, 0.150710f}, {0.338489f, 0.282976f} },
    { {-0.257124f, 0.028063f, -0.124740f}, {-0.922798f, -0.375626f, -0.085720f}, {0.386105f, 0.267571f} },
    { {-0.260257f, 0.111576f, -0.070581f}, {-0.999915f, 0.004358f, 0.012290f}, {0.374314f, 0.282280f} },
    { {-0.256158f, 0.028283f, -0.097885f}, {-0.868327f, -0.480250f, 0.123964f}, {0.385985f, 0.273091f} },
    { {-0.238298f, 0.089694f, -0.056701f}, {0.999724f, -0.005891f, 0.022749f}, {0.375281f, 0.282918f} },
    { {-0.236115f, 0.064229f, -0.159250f}, {0.996475f, 0.010704f, -0.083205f}, {0.378720f, 0.260505f} },
    { {-0.238767f, 0.062993f, -0.059707f}, {0.995646f, 0.027132f, 0.089184f}, {0.379204f, 0.281277f} },
    { {-0.168512f, -0.097768f, -0.075695f}, {-0.934421f, -0.258434f, 0.245090f}, {0.395454f, 0.267230f} },
    { {-0.177270f, 0.014345f, -0.036006f}, {-0.934020f, -0.113852f, 0.338593f}, {0.380072f, 0.280412f} },
    { {-0.152914f, -0.084249f, -0.001971f}, {-0.893839f, -0.235713f, 0.381433f}, {0.391945f, 0.282073f} },
    { {-0.105671f, -0.322635f, -0.072574f}, {-0.633128f, -0.322732f, 0.703557f}, {0.421769f, 0.255101f} },
    { {-0.113625f, -0.326053f, -0.124061f}, {-0.865010f, -0.381372f, 0.326056f}, {0.423048f, 0.244786f} },
    { {-0.115782f, -0.205294f, -0.027846f}, {-0.675517f, -0.312485f, 0.667855f}, {0.405766f, 0.269619f} },
    { {0.144563f, 0.257021f, -0.002460f}, {0.002110f, 0.160343f, 0.987059f}, {0.312369f, 0.276608f} },
    { {0.123516f, 0.316455f, -0.020386f}, {-0.469745f, 0.488343f, 0.735432f}, {0.305855f, 0.276545f} },
    { {0.171449f, 0.311491f, -0.011366f}, {0.051143f, 0.233865f, 0.970923f}, {0.301742f, 0.275202f} },
    { {0.142392f, 0.354118f, -0.135062f}, {-0.595835f, 0.796653f, -0.101611f}, {0.298437f, 0.253040f} },
    { {0.142409f, 0.351527f, -0.083928f}, {-0.475469f, 0.866542f, 0.151767f}, {0.298831f, 0.263546f} },
    { {0.127277f, 0.335080f, -0.080349f}, {-0.737519f, 0.670951f, 0.076757f}, {0.302748f, 0.264598f} },
    { {-0.230994f, 0.006441f, -0.101700f}, {-0.968342f, -0.216424f, 0.124394f}, {0.386617f, 0.269857f} },
    { {-0.139223f, 0.243634f, -0.127733f}, {0.848555f, 0.527935f, 0.035193f}, {0.342902f, 0.267973f} },
    { {-0.096039f, 0.265130f, -0.059437f}, {-0.909423f, -0.317284f, -0.268850f}, {0.335449f, 0.280265f} },
    { {-0.095661f, 0.265569f, -0.143173f}, {-0.919938f, -0.344663f, 0.186871f}, {0.335315f, 0.262885f} },
    { {-0.126916f, 0.338929f, -0.042088f}, {-0.889636f, -0.042675f, -0.454671f}, {0.327854f, 0.288704f} },
    { {0.120871f, 0.265129f, -0.059437f}, {0.890000f, -0.272244f, -0.365765f}, {0.313560f, 0.266597f} },
    { {0.162257f, 0.244339f, -0.060789f}, {-0.805812f, 0.556982f, -0.201091f}, {0.312403f, 0.262894f} },
    { {0.213156f, 0.322763f, -0.090437f}, {-0.807552f, 0.589797f, -0.000210f}, {0.295867f, 0.256610f} },
    { {0.238779f, -0.003178f, -0.156198f}, {0.964919f, -0.169144f, -0.200804f}, {0.340588f, 0.228572f} },
    { {0.190837f, -0.251929f, -0.179434f}, {0.940750f, -0.216279f, -0.261176f}, {0.381540f, 0.217019f} },
    { {0.190837f, -0.260320f, -0.133280f}, {0.952340f, -0.275195f, 0.131591f}, {0.382776f, 0.226266f} },
    { {0.127406f, -0.322612f, -0.073847f}, {0.081135f, -0.992245f, 0.094169f}, {0.569393f, 0.036504f} },
    { {0.135947f, -0.324219f, -0.098136f}, {0.081135f, -0.992245f, 0.094169f}, {0.579114f, 0.064816f} },
    { {0.079159f, -0.338276f, -0.197319f}, {0.081135f, -0.992245f, 0.094169f}, {0.514482f, 0.180408f} },
    { {0.011656f, 0.326121f, -0.035390f}, {-0.017300f, 0.999453f, -0.028171f}, {0.315733f, 0.280860f} },
    { {-0.032894f, 0.325352f, -0.035306f}, {-0.017300f, 0.999453f, -0.028171f}, {0.320340f, 0.283654f} },
    { {-0.129421f, 0.353718f, -0.127817f}, {-0.970784f, -0.239951f, -0.001542f}, {0.325927f, 0.271655f} },
    { {-0.129433f, 0.351758f, -0.089141f}, {-0.997444f, -0.069357f, 0.017187f}, {0.326227f, 0.279603f} },
    { {-0.049471f, -0.322029f, -0.064483f}, {0.000081f, -0.992521f, 0.122075f}, {0.368086f, 0.025589f} },
    { {0.077463f, -0.322010f, -0.064411f}, {0.000081f, -0.992521f, 0.122075f}, {0.512552f, 0.025505f} },
    { {-0.066700f, -0.338326f, -0.196973f}, {0.000081f, -0.992521f, 0.122075f}, {0.348478f, 0.180005f} },
    { {0.077463f, -0.322010f, -0.064411f}, {0.074433f, -0.385017f, 0.919903f}, {0.403201f, 0.245280f} },
    { {-0.114803f, -0.290904f, -0.205202f}, {0.004361f, -0.166678f, -0.986002f}, {0.418032f, 0.229403f} },
    { {-0.066700f, -0.338326f, -0.196973f}, {0.004361f, -0.166678f, -0.986002f}, {0.420068f, 0.226220f} },
    { {0.012416f, -0.288615f, -0.205027f}, {0.004361f, -0.166678f, -0.986002f}, {0.404862f, 0.221513f} },
    { {0.162417f, -0.299332f, -0.186005f}, {0.821682f, -0.489324f, -0.292232f}, {0.391289f, 0.215588f} },
    { {-0.113246f, 0.334514f, -0.163431f}, {0.301988f, 0.737734f, -0.603782f}, {0.327070f, 0.262493f} },
    { {-0.150400f, 0.326081f, -0.162798f}, {-0.069686f, 0.368015f, -0.927205f}, {0.332044f, 0.264635f} },
    { {-0.078565f, 0.336212f, -0.033721f}, {0.846480f, 0.485549f, -0.218433f}, {0.323373f, 0.287286f} },
    { {-0.081579f, 0.351135f, -0.081767f}, {0.931983f, 0.360536f, 0.037707f}, {0.321491f, 0.278093f} },
    { {-0.067465f, 0.321578f, -0.147991f}, {0.772046f, 0.185679f, 0.607839f}, {0.324334f, 0.262305f} },
    { {0.175696f, 0.184516f, -0.148911f}, {0.130620f, 0.672817f, 0.728186f}, {0.319701f, 0.241418f} },
    { {0.166888f, 0.238831f, -0.127652f}, {0.506279f, -0.858669f, -0.079813f}, {0.312710f, 0.248514f} },
    { {-0.184119f, -0.098962f, -0.085008f}, {-0.695161f, -0.248900f, 0.674389f}, {0.397199f, 0.266234f} },
    { {-0.213997f, -0.000246f, -0.100141f}, {-0.960469f, -0.201476f, 0.192110f}, {0.385873f, 0.268848f} },
    { {-0.194648f, 0.010202f, -0.048829f}, {-0.686467f, -0.290588f, 0.666574f}, {0.382423f, 0.278684f} },
    { {-0.201077f, 0.051771f, -0.012251f}, {-0.474188f, -0.365770f, 0.800848f}, {0.377049f, 0.288308f} },
    { {-0.201911f, 0.123809f, 0.000012f}, {-0.344100f, -0.057279f, 0.937184f}, {0.366677f, 0.293729f} },
    { {-0.154892f, 0.046742f, 0.000454f}, {-0.284736f, -0.297900f, 0.911143f}, {0.373124f, 0.287837f} },
    { {-0.214469f, 0.179202f, -0.159194f}, {-0.659427f, 0.284739f, 0.695758f}, {0.359839f, 0.263661f} },
    { {-0.197281f, 0.264451f, -0.155247f}, {-0.891150f, -0.009364f, 0.453613f}, {0.345727f, 0.266739f} },
    { {-0.150864f, 0.184516f, -0.148911f}, {-0.170855f, 0.659397f, 0.732123f}, {0.352653f, 0.261995f} },
    { {-0.211749f, 0.281581f, -0.134918f}, {-0.903154f, -0.419548f, -0.091059f}, {0.344707f, 0.272540f} },
    { {-0.142532f, 0.233806f, -0.146815f}, {-0.413802f, -0.513867f, 0.751471f}, {0.344656f, 0.263838f} },
    { {-0.142056f, 0.238831f, -0.127652f}, {-0.506279f, -0.858668f, -0.079813f}, {0.343885f, 0.267980f} },
    { {0.146914f, -0.246147f, -0.100302f}, {0.918313f, -0.324857f, 0.226208f}, {0.385163f, 0.236431f} },
    { {0.141767f, -0.206975f, -0.023153f}, {0.845308f, -0.367672f, 0.387649f}, {0.380023f, 0.254298f} },
    { {0.144675f, -0.327306f, -0.144741f}, {0.793724f, -0.578919f, 0.186696f}, {0.397157f, 0.224170f} },
    { {-0.239649f, 0.138610f, -0.112829f}, {0.931804f, 0.357883f, -0.060510f}, {0.368293f, 0.273276f} },
    { {-0.238796f, 0.132393f, -0.086698f}, {0.978012f, 0.205933f, 0.032936f}, {0.369119f, 0.278400f} },
    { {-0.257160f, 0.114193f, -0.158237f}, {-0.935200f, 0.240489f, -0.259933f}, {0.373588f, 0.264001f} },
    { {-0.257834f, 0.088991f, -0.167543f}, {-0.938245f, 0.056215f, -0.341374f}, {0.377312f, 0.261124f} },
    { {-0.054223f, -0.185049f, 0.006650f}, {-0.015906f, -0.342281f, 0.939463f}, {0.396627f, 0.273691f} },
    { {-0.109060f, -0.158299f, 0.012588f}, {-0.321452f, -0.300465f, 0.897992f}, {0.398279f, 0.279427f} },
    { {-0.079340f, -0.003373f, 0.052956f}, {-0.101575f, -0.198920f, 0.974738f}, {0.372797f, 0.292004f} },
    { {0.012432f, 0.048936f, 0.064906f}, {0.022451f, -0.116407f, 0.992948f}, {0.355945f, 0.290752f} },
    { {0.179165f, 0.126894f, 0.014798f}, {0.735425f, 0.093447f, 0.671131f}, {0.327780f, 0.272906f} },
    { {0.139016f, 0.250138f, 0.026587f}, {0.663540f, 0.335899f, 0.668496f}, {0.313939f, 0.282714f} },
    { {0.226743f, 0.123809f, 0.000012f}, {0.382338f, -0.092212f, 0.919410f}, {0.323422f, 0.266720f} },
    { {0.225908f, 0.051771f, -0.012251f}, {0.528059f, -0.352868f, 0.772423f}, {0.333962f, 0.261403f} },
    { {0.181762f, 0.046223f, 0.004689f}, {0.340802f, -0.259463f, 0.903622f}, {0.339229f, 0.267482f} },
    { {0.228167f, 0.148095f, -0.025046f}, {0.627310f, -0.044240f, 0.777512f}, {0.319742f, 0.262383f} },
    { {0.179165f, 0.126894f, 0.014798f}, {0.290505f, -0.087068f, 0.952904f}, {0.327780f, 0.272906f} },
    { {0.239300f, 0.179202f, -0.159194f}, {0.863569f, 0.325686f, 0.384937f}, {0.314050f, 0.235069f} },
    { {0.235717f, 0.274368f, -0.092664f}, {0.807135f, -0.589225f, -0.036701f}, {0.300617f, 0.252829f} },
    { {-0.137586f, -0.299332f, -0.186005f}, {-0.783698f, -0.417217f, -0.460160f}, {0.421562f, 0.234491f} },
    { {-0.113297f, -0.330995f, -0.198590f}, {0.008669f, -0.162426f, -0.986683f}, {0.423704f, 0.229108f} },
    { {0.128911f, 0.337566f, -0.129698f}, {0.694478f, 0.660652f, -0.285025f}, {0.302203f, 0.254353f} },
    { {0.127277f, 0.335080f, -0.080349f}, {0.817797f, 0.549248f, 0.171854f}, {0.302748f, 0.264598f} },
    { {0.118647f, 0.348087f, -0.080852f}, {0.822041f, 0.550979f, 0.143770f}, {0.301730f, 0.265547f} },
    { {0.175081f, 0.326813f, -0.162760f}, {0.026759f, 0.283844f, -0.958497f}, {0.299093f, 0.244163f} },
    { {0.124035f, 0.315179f, -0.157278f}, {-0.085952f, 0.361745f, -0.928307f}, {0.305936f, 0.248061f} },
    { {-0.221431f, 0.022736f, -0.045255f}, {-0.900457f, -0.219540f, 0.375473f}, {0.383307f, 0.281605f} },
    { {-0.194648f, 0.010202f, -0.048829f}, {-0.335495f, -0.839066f, 0.428266f}, {0.382423f, 0.278684f} },
    { {-0.213997f, -0.000246f, -0.100141f}, {-0.372009f, -0.895411f, 0.244639f}, {0.385873f, 0.268848f} },
    { {0.166888f, 0.238831f, -0.127652f}, {0.985688f, 0.167454f, -0.019438f}, {0.312710f, 0.248514f} },
    { {0.175696f, 0.184516f, -0.148911f}, {0.985688f, 0.167454f, -0.019438f}, {0.319701f, 0.241418f} },
    { {0.178097f, 0.180902f, -0.058265f}, {0.985688f, 0.167454f, -0.019438f}, {0.320017f, 0.259932f} },
    { {0.242306f, 0.161048f, -0.037286f}, {0.948638f, -0.110620f, 0.296393f}, {0.316429f, 0.259461f} },
    { {0.253300f, 0.175096f, -0.096475f}, {0.975322f, -0.212395f, 0.060301f}, {0.313257f, 0.247038f} },
    { {0.238759f, 0.155249f, -0.091182f}, {0.778947f, -0.627063f, -0.005818f}, {0.317609f, 0.248275f} },
    { {-0.146617f, 0.311491f, -0.011366f}, {-0.053675f, 0.235313f, 0.970436f}, {0.333838f, 0.295243f} },
    { {-0.119731f, 0.257021f, -0.002460f}, {-0.002520f, 0.160145f, 0.987090f}, {0.339038f, 0.293261f} },
    { {-0.116602f, 0.254798f, -0.059625f}, {-0.070956f, 0.198909f, -0.977446f}, {0.339024f, 0.281117f} },
    { {-0.059863f, 0.278412f, 0.027075f}, {-0.120857f, 0.788921f, 0.602492f}, {0.329902f, 0.296456f} },
    { {0.084695f, 0.278412f, 0.027075f}, {0.088941f, 0.739855f, 0.666861f}, {0.315315f, 0.287347f} },
    { {-0.078725f, 0.240354f, 0.058563f}, {-0.105275f, 0.635231f, 0.765114f}, {0.337344f, 0.302685f} },
    { {-0.104085f, 0.335078f, -0.080311f}, {-0.823275f, 0.551442f, 0.134649f}, {0.326095f, 0.279184f} },
    { {-0.095455f, 0.348085f, -0.080814f}, {-0.748939f, 0.656999f, 0.086273f}, {0.323335f, 0.279046f} },
    { {-0.100324f, 0.316453f, -0.020348f}, {-0.416940f, 0.456864f, 0.785771f}, {0.328443f, 0.290658f} },
    { {-0.081564f, 0.353128f, -0.121338f}, {-0.487221f, 0.837471f, -0.247504f}, {0.321186f, 0.269960f} },
    { {-0.104067f, 0.337566f, -0.129698f}, {-0.601633f, 0.779397f, -0.174863f}, {0.325713f, 0.269034f} },
    { {-0.090923f, 0.329660f, -0.152080f}, {-0.025702f, 0.574827f, -0.817872f}, {0.325526f, 0.263252f} },
    { {0.144563f, 0.257021f, -0.002460f}, {0.205183f, 0.348499f, 0.914576f}, {0.312369f, 0.276608f} },
    { {0.103566f, 0.240345f, 0.058564f}, {0.362508f, 0.387201f, 0.847740f}, {0.318950f, 0.291199f} },
    { {-0.095661f, 0.265569f, -0.143173f}, {-0.448975f, 0.893540f, 0.002659f}, {0.335315f, 0.262885f} },
    { {-0.096039f, 0.265130f, -0.059437f}, {-0.448975f, 0.893541f, 0.002659f}, {0.335449f, 0.280265f} },
    { {-0.139223f, 0.243634f, -0.127733f}, {-0.448975f, 0.893541f, 0.002659f}, {0.342902f, 0.267973f} },
    { {0.091529f, 0.327527f, -0.034567f}, {-0.758572f, 0.571058f, -0.313786f}, {0.307470f, 0.276053f} },
    { {0.094468f, 0.325028f, -0.125006f}, {-0.905170f, 0.424112f, -0.028212f}, {0.307501f, 0.257005f} },
    { {0.105125f, 0.351135f, -0.081767f}, {-0.882764f, 0.469674f, 0.011611f}, {0.302651f, 0.266329f} },
    { {0.128911f, 0.337566f, -0.129698f}, {0.465850f, 0.848086f, -0.252455f}, {0.302203f, 0.254353f} },
    { {0.105110f, 0.353128f, -0.121338f}, {0.373789f, 0.898163f, -0.231483f}, {0.302348f, 0.258198f} },
    { {0.109007f, 0.333449f, -0.147819f}, {0.052542f, 0.859093f, -0.509115f}, {0.304803f, 0.251686f} },
    { {-0.239706f, 0.138357f, -0.013831f}, {0.877865f, 0.478139f, 0.027133f}, {0.368373f, 0.293809f} },
    { {-0.254327f, 0.132603f, -0.086141f}, {-0.636505f, 0.771266f, 0.003279f}, {0.370656f, 0.279502f} },
    { {-0.238796f, 0.132393f, -0.086698f}, {0.766846f, 0.640400f, -0.042840f}, {0.369119f, 0.278400f} },
    { {-0.255179f, 0.138820f, -0.112272f}, {-0.671365f, 0.738235f, 0.065414f}, {0.369829f, 0.274378f} },
    { {-0.213927f, 0.155250f, -0.091182f}, {-0.408296f, 0.907996f, 0.094009f}, {0.363289f, 0.276799f} },
    { {-0.197285f, 0.153352f, -0.180154f}, {-0.683600f, 0.093366f, -0.723860f}, {0.361851f, 0.257216f} },
    { {0.012432f, 0.234524f, 0.069391f}, {-0.011418f, 0.396419f, 0.917999f}, {0.328996f, 0.298959f} },
    { {-0.150864f, 0.184516f, -0.148911f}, {-0.985688f, 0.167454f, -0.019438f}, {0.352653f, 0.261995f} },
    { {-0.142056f, 0.238831f, -0.127652f}, {-0.985688f, 0.167454f, -0.019438f}, {0.343885f, 0.267980f} },
    { {-0.153266f, 0.180902f, -0.058265f}, {-0.985688f, 0.167454f, -0.019438f}, {0.353455f, 0.280812f} },
    { {0.203466f, 0.274376f, -0.013721f}, {0.642389f, 0.077681f, 0.762432f}, {0.303900f, 0.271241f} },
    { {0.180561f, 0.330042f, -0.042560f}, {0.154428f, 0.339641f, -0.927791f}, {0.298117f, 0.268883f} },
    { {0.151747f, 0.338929f, -0.042089f}, {0.871809f, 0.332283f, -0.359912f}, {0.299734f, 0.271145f} },
    { {0.216904f, 0.291818f, -0.083354f}, {0.985974f, -0.146639f, 0.079704f}, {0.299985f, 0.256630f} },
    { {0.220268f, 0.313192f, -0.085642f}, {0.987956f, 0.120755f, 0.096751f}, {0.296541f, 0.256782f} },
    { {0.177873f, 0.324713f, -0.022244f}, {0.429332f, 0.684372f, 0.589329f}, {0.299170f, 0.273058f} },
    { {0.204161f, 0.311088f, -0.043828f}, {-0.181802f, 0.793887f, -0.580251f}, {0.298488f, 0.266390f} },
    { {0.208376f, 0.297757f, -0.024020f}, {0.802049f, 0.369585f, 0.469175f}, {0.300006f, 0.269711f} },
    { {-0.233497f, 0.045141f, -0.079018f}, {0.945193f, -0.174412f, 0.276027f}, {0.381258f, 0.276238f} },
    { {-0.234407f, 0.033817f, -0.100153f}, {0.842435f, -0.518052f, 0.148077f}, {0.382986f, 0.271467f} },
    { {-0.235270f, 0.033621f, -0.124131f}, {0.659474f, -0.740286f, -0.130651f}, {0.383093f, 0.266539f} },
    { {-0.154372f, 0.126917f, 0.014747f}, {-0.294482f, -0.024939f, 0.955332f}, {0.361434f, 0.293913f} },
    { {-0.122063f, -0.246178f, -0.100233f}, {-0.917543f, -0.318924f, 0.237490f}, {0.412309f, 0.253393f} },
    { {-0.130359f, -0.325244f, -0.193240f}, {-0.802897f, -0.596103f, 0.004182f}, {0.424593f, 0.231519f} },
    { {-0.166005f, -0.260320f, -0.133280f}, {-0.817523f, -0.536828f, 0.208496f}, {0.418785f, 0.248751f} },
    { {0.139723f, 0.255905f, -0.142659f}, {0.448975f, 0.893541f, 0.002659f}, {0.312966f, 0.247781f} },
    { {0.120871f, 0.265129f, -0.059437f}, {0.448975f, 0.893541f, 0.002659f}, {0.313560f, 0.266597f} },
    { {0.120493f, 0.265569f, -0.143173f}, {0.448974f, 0.893541f, 0.002659f}, {0.313503f, 0.249265f} },
    { {0.139723f, 0.255905f, -0.142659f}, {0.077613f, 0.070098f, 0.994516f}, {0.312966f, 0.247781f} },
    { {-0.249958f, 0.133278f, -0.006799f}, {-0.905439f, 0.361945f, 0.221754f}, {0.370147f, 0.295715f} },
    { {-0.172277f, 0.277387f, -0.174412f}, {-0.647706f, 0.247030f, -0.720731f}, {0.341318f, 0.261695f} },
    { {-0.192012f, 0.294829f, -0.141574f}, {-0.596379f, 0.762613f, -0.250504f}, {0.340789f, 0.270435f} },
    { {-0.188283f, 0.324779f, -0.129407f}, {0.672799f, 0.739252f, 0.029110f}, {0.336068f, 0.273899f} },
    { {-0.177918f, 0.300422f, -0.166224f}, {-0.494973f, 0.481589f, -0.723238f}, {0.338545f, 0.264652f} },
    { {-0.119848f, -0.244917f, -0.103542f}, {-0.207231f, -0.212512f, 0.954931f}, {0.411902f, 0.252616f} },
    { {-0.155930f, -0.249418f, -0.110819f}, {-0.470159f, -0.234072f, 0.850976f}, {0.416193f, 0.253204f} },
    { {-0.119848f, -0.244917f, -0.103542f}, {-0.839074f, -0.192990f, 0.508635f}, {0.411902f, 0.252616f} },
    { {-0.116952f, -0.207003f, -0.023184f}, {-0.704166f, -0.427300f, 0.567067f}, {0.406134f, 0.270593f} },
    { {-0.235904f, 0.088021f, -0.162347f}, {0.343366f, -0.013299f, -0.939108f}, {0.375242f, 0.260782f} },
    { {-0.241629f, 0.113983f, -0.158794f}, {0.666735f, 0.362514f, -0.651189f}, {0.372051f, 0.262898f} },
    { {-0.235886f, 0.044596f, -0.145458f}, {0.376473f, -0.744637f, -0.551165f}, {0.381553f, 0.262583f} },
    { {-0.257814f, 0.040355f, -0.148627f}, {-0.942908f, -0.247052f, -0.223359f}, {0.384380f, 0.263141f} },
    { {0.082078f, -0.236592f, -0.029863f}, {0.092895f, -0.377642f, 0.921280f}, {0.390345f, 0.255506f} },
    { {0.180762f, -0.249418f, -0.110819f}, {0.450188f, -0.284854f, 0.846280f}, {0.382218f, 0.231988f} },
    { {0.144679f, -0.244917f, -0.103542f}, {0.198201f, -0.228883f, 0.953063f}, {0.385208f, 0.235948f} },
    { {0.144679f, -0.244917f, -0.103542f}, {0.965210f, -0.141226f, 0.220054f}, {0.385208f, 0.235948f} },
    { {-0.066700f, -0.338326f, -0.196973f}, {-0.002288f, -0.156370f, -0.987696f}, {0.420068f, 0.226220f} },
    { {0.079159f, -0.338276f, -0.197319f}, {-0.002288f, -0.156370f, -0.987696f}, {0.405342f, 0.216960f} },
    { {0.012416f, -0.288615f, -0.205027f}, {-0.002288f, -0.156370f, -0.987696f}, {0.404862f, 0.221513f} },
    { {0.079159f, -0.338276f, -0.197319f}, {0.000629f, -0.992593f, 0.121487f}, {0.514482f, 0.180408f} },
    { {0.248127f, 0.141378f, -0.036900f}, {0.934469f, 0.136264f, 0.328937f}, {0.318698f, 0.258403f} },
    { {0.236395f, 0.132649f, -0.009161f}, {0.820279f, 0.125039f, 0.558128f}, {0.321160f, 0.264555f} },
    { {0.199813f, 0.144788f, -0.007712f}, {0.359975f, 0.816949f, 0.450569f}, {0.323090f, 0.267637f} },
    { {0.152632f, -0.274838f, -0.203985f}, {0.097472f, 0.015172f, -0.995123f}, {0.388713f, 0.213434f} },
    { {0.179192f, -0.229515f, -0.200734f}, {0.174021f, 0.021754f, -0.984502f}, {0.379452f, 0.214212f} },
    { {-0.192072f, 0.291818f, -0.083354f}, {-0.619568f, 0.765708f, 0.172706f}, {0.341255f, 0.282400f} },
    { {-0.210886f, 0.274368f, -0.092664f}, {-0.807136f, -0.589224f, -0.036701f}, {0.345683f, 0.280970f} },
    { {0.238829f, -0.000246f, -0.100141f}, {0.399083f, -0.886171f, 0.235442f}, {0.340179f, 0.240315f} },
    { {0.225822f, -0.001293f, -0.186107f}, {0.896037f, -0.192104f, -0.400268f}, {0.341611f, 0.223257f} },
    { {0.204175f, -0.090213f, -0.191889f}, {0.119072f, 0.038704f, -0.992131f}, {0.356706f, 0.219935f} },
    { {0.225822f, -0.001293f, -0.186107f}, {0.212744f, -0.284626f, -0.934734f}, {0.341611f, 0.223257f} },
    { {0.238779f, -0.003178f, -0.156198f}, {0.434274f, -0.900480f, -0.023302f}, {0.340588f, 0.228572f} },
    { {0.246148f, 0.008568f, -0.184466f}, {0.633806f, -0.018660f, -0.773267f}, {0.338128f, 0.222704f} },
    { {0.222117f, 0.153352f, -0.180154f}, {0.631072f, 0.051157f, -0.774035f}, {0.319530f, 0.230789f} },
    { {0.238674f, 0.158322f, -0.148325f}, {0.780410f, -0.610973f, -0.132941f}, {0.317150f, 0.236545f} },
    { {0.253781f, 0.177953f, -0.149863f}, {0.865504f, -0.458938f, -0.200695f}, {0.312774f, 0.236043f} },
    { {0.249962f, 0.143351f, -0.178035f}, {0.608620f, 0.214723f, -0.763856f}, {0.318173f, 0.229082f} },
    { {0.222117f, 0.153352f, -0.180154f}, {0.117821f, 0.154954f, -0.980871f}, {0.319530f, 0.230789f} },
    { {-0.119731f, 0.257021f, -0.002460f}, {-0.201964f, 0.342150f, 0.917684f}, {0.339038f, 0.293261f} },
    { {0.101203f, 0.335191f, -0.143437f}, {-0.183632f, -0.256091f, 0.949050f}, {0.305339f, 0.253156f} },
    { {0.105110f, 0.353128f, -0.121338f}, {-0.933224f, 0.357762f, -0.033150f}, {0.302348f, 0.258198f} },
    { {0.090775f, 0.324315f, -0.148048f}, {-0.129083f, -0.279580f, 0.951405f}, {0.307969f, 0.252430f} },
    { {-0.211564f, 0.132649f, -0.009161f}, {-0.828594f, 0.082569f, 0.553727f}, {0.366363f, 0.292781f} },
    { {-0.223296f, 0.141378f, -0.036900f}, {-0.934469f, 0.136264f, 0.328937f}, {0.366269f, 0.288107f} },
    { {-0.174981f, 0.144788f, -0.007712f}, {-0.381612f, 0.798060f, 0.466339f}, {0.360910f, 0.291253f} },
    { {-0.100324f, 0.316453f, -0.020348f}, {0.483669f, 0.531043f, 0.695743f}, {0.328443f, 0.290658f} },
    { {-0.153192f, 0.323980f, -0.022282f}, {-0.513337f, 0.688841f, 0.511843f}, {0.332684f, 0.293882f} },
    { {0.150989f, 0.338890f, -0.149275f}, {0.532064f, 0.110938f, 0.839405f}, {0.299776f, 0.248952f} },
    { {0.138077f, 0.334514f, -0.163431f}, {-0.193212f, 0.752530f, -0.629577f}, {0.301709f, 0.246657f} },
    { {-0.255138f, 0.040965f, -0.074214f}, {-0.730808f, -0.517981f, 0.444540f}, {0.384050f, 0.278435f} },
    { {-0.077657f, 0.335191f, -0.143437f}, {0.091544f, -0.253606f, 0.962966f}, {0.323388f, 0.264426f} },
    { {-0.081564f, 0.353128f, -0.121338f}, {0.891783f, 0.448566f, -0.059263f}, {0.321186f, 0.269960f} },
    { {0.162257f, 0.244339f, -0.060789f}, {0.448975f, 0.893540f, 0.002659f}, {0.312403f, 0.262894f} },
    { {0.141434f, 0.254798f, -0.059625f}, {0.448975f, 0.893540f, 0.002659f}, {0.312986f, 0.264858f} },
    { {0.164055f, 0.243634f, -0.127734f}, {0.448975f, 0.893540f, 0.002659f}, {0.312298f, 0.248864f} },
    { {0.141434f, 0.254798f, -0.059625f}, {0.076178f, 0.188532f, -0.979108f}, {0.312986f, 0.264858f} },
    { {-0.137425f, 0.244339f, -0.060789f}, {-0.448975f, 0.893541f, 0.002659f}, {0.342643f, 0.281777f} },
    { {-0.116602f, 0.254798f, -0.059625f}, {-0.448975f, 0.893541f, 0.002659f}, {0.339024f, 0.281117f} },
    { {-0.213842f, 0.158322f, -0.148324f}, {-0.809271f, -0.583107f, -0.071184f}, {0.362812f, 0.265058f} },
    { {-0.217474f, 0.161048f, -0.037286f}, {-0.952750f, -0.219545f, 0.209924f}, {0.362825f, 0.288432f} },
    { {0.202089f, 0.014364f, -0.035950f}, {0.408493f, -0.659751f, 0.630763f}, {0.341789f, 0.256521f} },
    { {0.219480f, 0.010202f, -0.048829f}, {0.335495f, -0.839066f, 0.428266f}, {0.340634f, 0.252589f} },
    { {0.139080f, 0.334566f, -0.021720f}, {-0.222794f, 0.791800f, 0.568696f}, {0.301654f, 0.275998f} },
    { {-0.256202f, 0.132175f, -0.138291f}, {-0.861827f, 0.474331f, -0.179623f}, {0.370888f, 0.268784f} },
    { {0.115164f, 0.330842f, -0.025330f}, {0.484486f, 0.654537f, 0.580392f}, {0.304607f, 0.276610f} },
    { {0.123516f, 0.316455f, -0.020386f}, {0.000171f, 0.325123f, 0.945672f}, {0.305855f, 0.276545f} },
    { {-0.091972f, 0.330840f, -0.025292f}, {-0.055934f, 0.626399f, 0.777493f}, {0.325509f, 0.289669f} },
    { {0.115164f, 0.330842f, -0.025330f}, {0.045801f, 0.529097f, 0.847325f}, {0.304607f, 0.276610f} },
    { {0.215531f, 0.272507f, -0.166049f}, {0.649727f, 0.221401f, -0.727212f}, {0.302897f, 0.238802f} },
    { {0.216843f, 0.294829f, -0.141574f}, {0.567734f, 0.765382f, -0.303100f}, {0.299532f, 0.244673f} },
    { {-0.258070f, 0.062343f, -0.164074f}, {-0.944162f, -0.097894f, -0.314602f}, {0.381207f, 0.260814f} },
    { {-0.174981f, 0.015052f, -0.039604f}, {-0.227580f, -0.676683f, 0.700220f}, {0.379737f, 0.279549f} },
    { {-0.105671f, -0.322635f, -0.072574f}, {-0.007002f, -0.992385f, 0.122979f}, {0.304123f, 0.035019f} },
    { {-0.200990f, -0.001293f, -0.186107f}, {-0.098686f, 0.040636f, -0.994289f}, {0.384680f, 0.250151f} },
    { {-0.200990f, -0.001293f, -0.186107f}, {-0.896037f, -0.192104f, -0.400267f}, {0.384680f, 0.250151f} },
    { {0.238759f, 0.155249f, -0.091182f}, {0.393613f, 0.913504f, 0.102857f}, {0.317609f, 0.248275f} },
    { {0.238674f, 0.158322f, -0.148325f}, {0.337341f, 0.927866f, -0.158950f}, {0.317150f, 0.236545f} },
    { {-0.121379f, 0.258132f, 0.001496f}, {-0.659705f, 0.638171f, 0.396897f}, {0.339045f, 0.294230f} },
    { {-0.176996f, 0.145316f, -0.003786f}, {-0.723829f, 0.247062f, 0.644229f}, {0.361038f, 0.292215f} },
    { {0.012422f, 0.338435f, -0.030255f}, {0.015980f, 0.209867f, -0.977599f}, {0.313870f, 0.282360f} },
    { {-0.068318f, 0.324761f, -0.034510f}, {0.527606f, 0.592703f, -0.608552f}, {0.324001f, 0.286028f} },
    { {-0.144862f, 0.230989f, -0.052927f}, {-0.985688f, 0.167454f, -0.019438f}, {0.345335f, 0.283354f} },
    { {0.169694f, 0.230989f, -0.052927f}, {0.985688f, 0.167454f, -0.019438f}, {0.313594f, 0.263533f} },
    { {-0.197285f, 0.153352f, -0.180154f}, {-0.117821f, 0.154954f, -0.980871f}, {0.361851f, 0.257216f} },
    { {-0.213842f, 0.158322f, -0.148324f}, {-0.377672f, 0.914446f, -0.145443f}, {0.362812f, 0.265058f} },
    { {-0.225130f, 0.143351f, -0.178035f}, {-0.741316f, 0.138485f, -0.656713f}, {0.366114f, 0.259018f} },
    { {-0.221316f, 0.008568f, -0.184466f}, {-0.465570f, -0.028337f, -0.884557f}, {0.385300f, 0.252159f} },
    { {-0.240671f, 0.131966f, -0.138847f}, {0.856750f, 0.419992f, -0.299310f}, {0.369351f, 0.267681f} },
    { {0.221011f, 0.269912f, -0.027523f}, {0.789888f, 0.290230f, 0.540225f}, {0.302773f, 0.267096f} },
    { {0.216904f, 0.291818f, -0.083354f}, {0.619568f, 0.765707f, 0.172706f}, {0.299985f, 0.256630f} },
    { {-0.193129f, 0.265980f, -0.037432f}, {-0.958556f, 0.167664f, 0.230347f}, {0.345131f, 0.290982f} },
    { {0.217961f, 0.265980f, -0.037432f}, {0.958556f, 0.167664f, 0.230347f}, {0.303648f, 0.265079f} },
    { {-0.248909f, 0.127366f, -0.008510f}, {-0.745103f, 0.624360f, -0.234511f}, {0.370899f, 0.295062f} },
    { {-0.237635f, 0.123798f, -0.007584f}, {0.997092f, -0.027271f, -0.071167f}, {0.370280f, 0.294404f} },
    { {-0.233883f, 0.205718f, 0.186489f}, {0.308522f, 0.883203f, -0.353224f}, {0.358079f, 0.337645f} },
    { {-0.248906f, 0.120534f, -0.005850f}, {-0.726081f, -0.633016f, 0.268510f}, {0.371892f, 0.295346f} },
    { {-0.233878f, 0.194664f, 0.190792f}, {0.309293f, -0.889316f, 0.336830f}, {0.359685f, 0.338104f} },
    { {0.077463f, -0.322010f, -0.064411f}, {0.010996f, -0.992517f, 0.121610f}, {0.512552f, 0.025505f} },
    { {0.127406f, -0.322612f, -0.073847f}, {0.010996f, -0.992517f, 0.121610f}, {0.569393f, 0.036504f} },
    { {0.079159f, -0.338276f, -0.197319f}, {0.010996f, -0.992517f, 0.121610f}, {0.514482f, 0.180408f} },
    { {-0.231358f, 0.204220f, 0.198988f}, {-0.539229f, -0.721674f, 0.434073f}, {0.358046f, 0.340021f} },
    { {-0.238631f, 0.206522f, 0.198391f}, {-0.958936f, -0.229804f, 0.166230f}, {0.358446f, 0.340445f} },
    { {-0.104067f, 0.337566f, -0.129698f}, {0.671036f, 0.732344f, -0.115684f}, {0.325713f, 0.269034f} },
    { {-0.117561f, 0.354118f, -0.135062f}, {0.560583f, 0.828009f, 0.012141f}, {0.324669f, 0.269420f} },
    { {0.066791f, 0.337477f, -0.030174f}, {0.000143f, 0.590278f, 0.807200f}, {0.308523f, 0.278913f} },
    { {-0.104085f, 0.335078f, -0.080311f}, {0.584234f, 0.800358f, 0.134528f}, {0.326095f, 0.279184f} },
    { {0.128911f, 0.337566f, -0.129698f}, {-0.800504f, 0.577911f, -0.158783f}, {0.302203f, 0.254353f} },
    { {-0.127800f, -0.274838f, -0.203985f}, {-0.097472f, 0.015172f, -0.995123f}, {0.417011f, 0.231105f} },
    { {0.102111f, 0.336212f, -0.033721f}, {-0.602853f, 0.758626f, -0.247092f}, {0.305141f, 0.275902f} },
    { {0.066791f, 0.337477f, -0.030174f}, {-0.022528f, 0.356441f, -0.934046f}, {0.308523f, 0.278913f} },
    { {-0.238309f, 0.114740f, -0.066442f}, {0.999713f, 0.020445f, 0.012507f}, {0.371641f, 0.281880f} },
    { {-0.213947f, -0.003178f, -0.156198f}, {-0.383649f, -0.923326f, -0.016807f}, {0.386273f, 0.257099f} },
    { {0.194030f, 0.141687f, 0.009672f}, {0.392702f, 0.482001f, 0.783237f}, {0.324130f, 0.271486f} },
    { {0.194030f, 0.141687f, 0.009672f}, {0.751958f, 0.288093f, 0.592926f}, {0.324130f, 0.271486f} },
    { {0.146125f, 0.258205f, 0.001532f}, {0.722965f, 0.571171f, 0.388696f}, {0.312041f, 0.277384f} },
    { {-0.114248f, 0.334566f, -0.021720f}, {0.399403f, 0.828715f, 0.392057f}, {0.327217f, 0.291960f} },
    { {-0.203336f, 0.148095f, -0.025046f}, {-0.444898f, 0.862282f, 0.241942f}, {0.363284f, 0.289572f} },
    { {0.139635f, -0.290904f, -0.205203f}, {0.638609f, -0.025587f, -0.769106f}, {0.392357f, 0.213371f} },
    { {0.152663f, -0.325114f, -0.193247f}, {0.638609f, -0.025587f, -0.769106f}, {0.396015f, 0.213689f} },
    { {0.162417f, -0.299332f, -0.186005f}, {0.638609f, -0.025587f, -0.769106f}, {0.391289f, 0.215588f} },
    { {0.144675f, -0.327306f, -0.144741f}, {0.806986f, -0.512712f, 0.293088f}, {0.397157f, 0.224170f} },
    { {0.162417f, -0.299332f, -0.186005f}, {0.914005f, -0.383214f, 0.133196f}, {0.391289f, 0.215588f} },
    { {0.152663f, -0.325114f, -0.193247f}, {0.740339f, -0.665932f, 0.091828f}, {0.396015f, 0.213689f} },
    { {0.199813f, 0.015052f, -0.039604f}, {0.257598f, -0.681033f, 0.685447f}, {0.341917f, 0.255933f} },
    { {0.228167f, 0.148095f, -0.025046f}, {0.444898f, 0.862282f, 0.241942f}, {0.319742f, 0.262383f} },
    { {-0.200990f, -0.001293f, -0.186107f}, {-0.192646f, -0.266568f, -0.944367f}, {0.384680f, 0.250151f} },
    { {-0.176996f, 0.145316f, -0.003786f}, {-0.312533f, 0.555993f, 0.770191f}, {0.361038f, 0.292215f} },
    { {0.153951f, -0.289631f, -0.119929f}, {0.489689f, -0.483482f, 0.725569f}, {0.390760f, 0.230211f} },
    { {0.153951f, -0.289631f, -0.119929f}, {-0.499154f, -0.387531f, 0.775026f}, {0.390760f, 0.230211f} },
    { {-0.113297f, -0.330995f, -0.198590f}, {-0.301347f, -0.951512f, 0.061768f}, {0.423704f, 0.229108f} },
    { {-0.114803f, -0.290904f, -0.205202f}, {-0.345372f, -0.165357f, -0.923783f}, {0.418032f, 0.229403f} },
    { {-0.130359f, -0.325244f, -0.193240f}, {-0.345372f, -0.165357f, -0.923783f}, {0.424593f, 0.231519f} },
    { {-0.113297f, -0.330995f, -0.198590f}, {-0.345372f, -0.165357f, -0.923783f}, {0.423704f, 0.229108f} },
    { {-0.077657f, 0.335191f, -0.143437f}, {0.007335f, 0.863259f, -0.504707f}, {0.323388f, 0.264426f} },
    { {-0.090923f, 0.329660f, -0.152080f}, {0.009881f, 0.835324f, -0.549669f}, {0.325526f, 0.263252f} },
    { {-0.081564f, 0.353128f, -0.121338f}, {-0.094425f, 0.962368f, -0.254816f}, {0.321186f, 0.269960f} },
    { {0.135600f, -0.330881f, -0.198596f}, {0.163166f, -0.985868f, 0.037957f}, {0.398572f, 0.213428f} },
    { {0.109007f, 0.333449f, -0.147819f}, {0.040478f, 0.542850f, -0.838854f}, {0.304803f, 0.251686f} },
    { {0.012416f, 0.298162f, -0.171667f}, {0.015272f, 0.530859f, -0.847323f}, {0.319665f, 0.251441f} },
    { {0.124035f, 0.315179f, -0.157278f}, {0.121263f, 0.533236f, -0.837230f}, {0.305936f, 0.248061f} },
    { {-0.155930f, -0.249418f, -0.110819f}, {-0.412157f, -0.371297f, 0.832025f}, {0.416193f, 0.253204f} },
    { {-0.032894f, 0.325352f, -0.035306f}, {-0.008397f, 0.385348f, -0.922733f}, {0.320340f, 0.283654f} },
    { {0.011656f, 0.326121f, -0.035390f}, {0.000707f, 0.384878f, -0.922967f}, {0.315733f, 0.280860f} },
    { {0.012422f, 0.338435f, -0.030255f}, {-0.019946f, 0.988152f, -0.152177f}, {0.313870f, 0.282360f} },
    { {0.011656f, 0.326121f, -0.035390f}, {0.002215f, 0.408546f, -0.912735f}, {0.315733f, 0.280860f} },
    { {0.118647f, 0.348087f, -0.080852f}, {0.333635f, 0.934891f, 0.121108f}, {0.301730f, 0.265547f} },
    { {0.164055f, 0.243634f, -0.127734f}, {-0.797422f, 0.517297f, 0.310679f}, {0.312298f, 0.248864f} },
    { {0.159060f, 0.246195f, -0.144817f}, {-0.797422f, 0.517297f, 0.310679f}, {0.312424f, 0.245734f} },
    { {0.199905f, 0.313104f, -0.151387f}, {-0.797422f, 0.517297f, 0.310679f}, {0.298584f, 0.244421f} },
    { {-0.192012f, 0.294829f, -0.141574f}, {-0.983309f, -0.131187f, -0.126065f}, {0.340789f, 0.270435f} },
    { {-0.195382f, 0.315857f, -0.137164f}, {-0.939207f, 0.160238f, -0.303668f}, {0.338077f, 0.272387f} },
    { {-0.119731f, 0.257021f, -0.002460f}, {-0.615456f, 0.646145f, -0.451343f}, {0.339038f, 0.293261f} },
    { {-0.056580f, 0.289847f, -0.000801f}, {-0.083678f, 0.884404f, -0.459160f}, {0.327900f, 0.290914f} },
    { {-0.056946f, 0.291773f, 0.003012f}, {-0.214396f, 0.868787f, -0.446367f}, {0.327658f, 0.291803f} },
    { {0.081702f, 0.291799f, 0.002973f}, {0.143723f, 0.879558f, -0.453565f}, {0.313664f, 0.283060f} },
    { {-0.254327f, 0.132603f, -0.086141f}, {-0.598451f, 0.774789f, 0.203856f}, {0.370656f, 0.279502f} },
    { {-0.174981f, 0.015052f, -0.039604f}, {-0.826281f, 0.321766f, -0.462305f}, {0.379737f, 0.279549f} },
    { {-0.154892f, 0.046742f, 0.000454f}, {-0.818058f, 0.459500f, -0.345891f}, {0.373124f, 0.287837f} },
    { {-0.177270f, 0.014345f, -0.036006f}, {-0.827234f, 0.325160f, -0.458209f}, {0.380072f, 0.280412f} },
    { {-0.166251f, -0.096684f, -0.079069f}, {-0.834284f, 0.010833f, -0.551228f}, {0.395068f, 0.266430f} },
    { {0.135947f, -0.324219f, -0.098136f}, {0.131074f, -0.989230f, 0.065148f}, {0.579114f, 0.064816f} },
    { {0.135600f, -0.330881f, -0.198596f}, {0.131074f, -0.989230f, 0.065148f}, {0.578720f, 0.181918f} },
    { {0.079159f, -0.338276f, -0.197319f}, {0.131074f, -0.989230f, 0.065148f}, {0.514482f, 0.180408f} },
    { {0.135600f, -0.330881f, -0.198596f}, {-0.000969f, -0.162954f, -0.986633f}, {0.398572f, 0.213428f} },
    { {0.139635f, -0.290904f, -0.205203f}, {-0.000969f, -0.162954f, -0.986633f}, {0.392357f, 0.213371f} },
    { {-0.213927f, 0.155250f, -0.091182f}, {-0.783592f, -0.621089f, 0.015257f}, {0.363289f, 0.276799f} },
    { {-0.142532f, 0.233806f, -0.146815f}, {-0.985688f, 0.167454f, -0.019438f}, {0.344656f, 0.263838f} },
    { {0.167364f, 0.233806f, -0.146815f}, {0.985688f, 0.167453f, -0.019437f}, {0.313384f, 0.244311f} },
    { {0.159060f, 0.246195f, -0.144817f}, {0.122216f, 0.022821f, 0.992241f}, {0.312424f, 0.245734f} },
    { {0.159060f, 0.246195f, -0.144817f}, {0.448975f, 0.893540f, 0.002660f}, {0.312424f, 0.245734f} },
    { {0.066791f, 0.337477f, -0.030174f}, {0.044086f, 0.998872f, 0.017613f}, {0.308523f, 0.278913f} },
    { {0.012422f, -0.244623f, -0.025344f}, {0.000010f, -0.473116f, 0.881000f}, {0.398541f, 0.260518f} },
    { {-0.057501f, -0.238399f, -0.024907f}, {-0.130734f, -0.498773f, 0.856816f}, {0.404694f, 0.265258f} },
    { {-0.134229f, 0.246195f, -0.144817f}, {-0.448975f, 0.893540f, 0.002660f}, {0.342019f, 0.264215f} },
    { {-0.139223f, 0.243634f, -0.127733f}, {0.797422f, 0.517297f, 0.310679f}, {0.342902f, 0.267973f} },
    { {-0.175074f, 0.313104f, -0.151387f}, {0.797422f, 0.517297f, 0.310679f}, {0.336422f, 0.268049f} },
    { {-0.134229f, 0.246195f, -0.144817f}, {0.797422f, 0.517297f, 0.310679f}, {0.342019f, 0.264215f} },
    { {-0.115782f, -0.205294f, -0.027846f}, {0.568909f, -0.822033f, -0.024561f}, {0.405766f, 0.269619f} },
    { {-0.119848f, -0.244917f, -0.103542f}, {-0.721637f, -0.335057f, -0.605786f}, {0.411902f, 0.252616f} },
    { {-0.122063f, -0.246178f, -0.100233f}, {0.039446f, -0.826952f, -0.560887f}, {0.412309f, 0.253393f} },
    { {-0.168512f, -0.097768f, -0.075695f}, {-0.814959f, -0.077823f, -0.574269f}, {0.395454f, 0.267230f} },
    { {-0.121379f, 0.258132f, 0.001496f}, {-0.727574f, 0.514237f, -0.454088f}, {0.339045f, 0.294230f} },
    { {-0.176996f, 0.145316f, -0.003786f}, {-0.787900f, 0.409941f, -0.459524f}, {0.361038f, 0.292215f} },
    { {-0.174981f, 0.144788f, -0.007712f}, {-0.791083f, 0.410926f, -0.453130f}, {0.360910f, 0.291253f} },
    { {0.199813f, 0.144788f, -0.007712f}, {0.856707f, 0.376827f, 0.352212f}, {0.323090f, 0.267637f} },
    { {0.081702f, 0.291799f, 0.002973f}, {0.086617f, 0.875467f, 0.475453f}, {0.313664f, 0.283060f} },
    { {-0.254298f, 0.063203f, -0.059150f}, {-0.569206f, -0.498646f, 0.653726f}, {0.380741f, 0.282379f} },
    { {0.101203f, 0.335191f, -0.143437f}, {-0.037249f, 0.904071f, -0.425756f}, {0.305339f, 0.253156f} },
    { {0.144679f, -0.244917f, -0.103542f}, {-0.051879f, -0.823612f, -0.564776f}, {0.385208f, 0.235948f} },
    { {0.140613f, -0.205294f, -0.027846f}, {-0.005647f, -0.954138f, -0.299312f}, {0.379894f, 0.253463f} },
    { {0.141767f, -0.206975f, -0.023153f}, {-0.557645f, -0.829753f, -0.023277f}, {0.380023f, 0.254298f} },
    { {0.082351f, -0.238392f, -0.024905f}, {0.326145f, -0.873617f, -0.361140f}, {0.390580f, 0.256447f} },
    { {0.191083f, -0.096684f, -0.079069f}, {0.290989f, -0.297331f, 0.909351f}, {0.359009f, 0.243914f} },
    { {-0.166251f, -0.096684f, -0.079069f}, {-0.290989f, -0.297331f, 0.909351f}, {0.395068f, 0.266430f} },
    { {-0.137586f, -0.299332f, -0.186005f}, {-0.827174f, -0.075213f, -0.556889f}, {0.421562f, 0.234491f} },
    { {-0.114803f, -0.290904f, -0.205202f}, {-0.650626f, 0.030396f, -0.758790f}, {0.418032f, 0.229403f} },
    { {-0.078565f, 0.336212f, -0.033721f}, {-0.103557f, 0.905216f, 0.412142f}, {0.323373f, 0.287286f} },
    { {-0.081579f, 0.351135f, -0.081767f}, {-0.193077f, 0.952370f, 0.236037f}, {0.321491f, 0.278093f} },
    { {0.139635f, -0.290904f, -0.205203f}, {0.350855f, -0.187045f, -0.917559f}, {0.392357f, 0.213371f} },
    { {0.135600f, -0.330881f, -0.198596f}, {0.350855f, -0.187045f, -0.917559f}, {0.398572f, 0.213428f} },
    { {0.152663f, -0.325114f, -0.193247f}, {0.350855f, -0.187045f, -0.917559f}, {0.396015f, 0.213689f} },
    { {0.146125f, 0.258205f, 0.001532f}, {0.684037f, 0.581570f, -0.440307f}, {0.312041f, 0.277384f} },
    { {0.144563f, 0.257021f, -0.002460f}, {0.618108f, 0.646696f, -0.446907f}, {0.312369f, 0.276608f} },
    { {0.199813f, 0.144788f, -0.007712f}, {0.799319f, 0.413878f, -0.435653f}, {0.323090f, 0.267637f} },
    { {0.081412f, 0.289847f, -0.000801f}, {0.139009f, 0.875202f, -0.463355f}, {0.313975f, 0.282219f} },
    { {0.199813f, 0.015052f, -0.039604f}, {0.847312f, 0.117157f, -0.518011f}, {0.341917f, 0.255933f} },
    { {0.191083f, -0.096684f, -0.079069f}, {0.812786f, -0.076398f, -0.577532f}, {0.359009f, 0.243914f} },
    { {0.193350f, -0.097738f, -0.075685f}, {0.835912f, 0.010323f, -0.548767f}, {0.358935f, 0.244432f} },
    { {0.146914f, -0.246147f, -0.100302f}, {0.717548f, -0.339152f, -0.608359f}, {0.385163f, 0.236431f} },
    { {0.102111f, 0.336212f, -0.033721f}, {0.167553f, 0.927881f, 0.333110f}, {0.305141f, 0.275902f} },
    { {-0.174981f, 0.015052f, -0.039604f}, {-0.330368f, -0.337182f, 0.881570f}, {0.379737f, 0.279549f} },
    { {-0.056946f, 0.291773f, 0.003012f}, {-0.147974f, 0.872145f, 0.466333f}, {0.327658f, 0.291803f} },
    { {-0.095455f, 0.348085f, -0.080814f}, {-0.197031f, 0.959508f, 0.201305f}, {0.323335f, 0.279046f} },
    { {0.199813f, 0.015052f, -0.039604f}, {0.330368f, -0.337182f, 0.881570f}, {0.341917f, 0.255933f} },
    { {0.012422f, -0.244623f, -0.025344f}, {0.028340f, -0.935926f, -0.351055f}, {0.398541f, 0.260518f} },
    { {0.082078f, -0.236592f, -0.029863f}, {0.206955f, -0.914804f, -0.346847f}, {0.390345f, 0.255506f} },
    { {0.012416f, -0.242755f, -0.030275f}, {-0.028642f, -0.935779f, -0.351421f}, {0.398269f, 0.259568f} },
    { {-0.057501f, -0.238399f, -0.024907f}, {-0.205926f, -0.914934f, -0.347117f}, {0.404694f, 0.265258f} },
    { {-0.057247f, -0.236592f, -0.029863f}, {-0.325490f, -0.872679f, -0.363988f}, {0.404404f, 0.264285f} },
    { {-0.116952f, -0.207003f, -0.023184f}, {0.008743f, -0.953294f, -0.301918f}, {0.406134f, 0.270593f} },
    { {0.139635f, -0.290904f, -0.205203f}, {0.519102f, -0.361224f, -0.774629f}, {0.392357f, 0.213371f} },
    { {0.162417f, -0.299332f, -0.186005f}, {0.519102f, -0.361224f, -0.774629f}, {0.391289f, 0.215588f} },
    { {0.152632f, -0.274838f, -0.203985f}, {0.519102f, -0.361224f, -0.774629f}, {0.388713f, 0.213434f} },
    { {-0.114803f, -0.290904f, -0.205202f}, {-0.519101f, -0.361225f, -0.774629f}, {0.418032f, 0.229403f} },
    { {-0.127800f, -0.274838f, -0.203985f}, {-0.519101f, -0.361225f, -0.774629f}, {0.417011f, 0.231105f} },
    { {-0.137586f, -0.299332f, -0.186005f}, {-0.519101f, -0.361225f, -0.774629f}, {0.421562f, 0.234491f} },
    { {-0.114803f, -0.290904f, -0.205202f}, {0.000017f, 0.075588f, -0.997139f}, {0.418032f, 0.229403f} },
    { {0.197109f, 0.277387f, -0.174412f}, {0.454350f, 0.250092f, -0.854997f}, {0.304044f, 0.238420f} },
    { {0.090775f, 0.324315f, -0.148048f}, {-0.017300f, 0.999453f, -0.028170f}, {0.307969f, 0.252430f} },
    { {0.139635f, -0.290904f, -0.205203f}, {-0.000018f, 0.075589f, -0.997139f}, {0.392357f, 0.213371f} },
    { {0.105125f, 0.351135f, -0.081767f}, {0.203341f, 0.960035f, 0.192315f}, {0.302651f, 0.266329f} },
    { {-0.156914f, 0.046228f, 0.004718f}, {-0.864342f, 0.342029f, -0.368686f}, {0.373404f, 0.288829f} },
    { {-0.154372f, 0.126917f, 0.014747f}, {-0.904341f, 0.080580f, -0.419136f}, {0.361434f, 0.293913f} },
    { {-0.032894f, 0.325352f, -0.035306f}, {-0.027517f, 0.441563f, -0.896808f}, {0.320340f, 0.283654f} },
    { {-0.068318f, 0.324761f, -0.034510f}, {-0.017300f, 0.999453f, -0.028171f}, {0.324001f, 0.286028f} },
    { {0.202089f, 0.014364f, -0.035950f}, {0.852713f, 0.114203f, -0.509744f}, {0.341789f, 0.256521f} },
};

WORD g_tind0[] = 
{
    2, 1, 0,    5, 4, 3,    8, 7, 6,    10, 3, 9,    13, 12, 11,
    16, 15, 14,    19, 18, 17,    13, 21, 20,    24, 23, 22,    20, 25, 13,
    28, 27, 26,    31, 30, 29,    34, 33, 32,    37, 36, 35,    39, 1, 38,
    42, 41, 40,    45, 44, 43,    48, 47, 46,    51, 50, 49,    52, 4, 5,
    53, 25, 20,    55, 54, 19,    58, 57, 56,    61, 60, 59,    63, 27, 62,
    66, 65, 64,    69, 68, 67,    72, 71, 70,    75, 74, 73,    78, 77, 76,
    81, 80, 79,    84, 83, 82,    86, 32, 85,    89, 88, 87,    90, 16, 14,
    93, 92, 91,    5, 3, 21,    96, 95, 94,    41, 42, 97,    100, 99, 98,
    43, 101, 45,    103, 51, 102,    106, 105, 104,    109, 108, 107,    112, 111, 110,
    115, 114, 113,    118, 117, 116,    121, 120, 119,    124, 123, 122,    127, 126, 125,
    39, 0, 1,    94, 128, 96,    56, 57, 129,    132, 131, 130,    67, 133, 69,
    135, 72, 134,    138, 137, 136,    141, 140, 139,    143, 142, 24,    131, 145, 144,
    148, 147, 146,    74, 75, 149,    152, 151, 150,    138, 153, 137,    53, 155, 154,
    158, 157, 156,    85, 159, 86,    33, 34, 160,    163, 162, 161,    166, 165, 164,
    169, 168, 167,    171, 170, 168,    30, 31, 169,    104, 172, 106,    174, 173, 44,
    153, 138, 175,    177, 114, 176,    179, 111, 178,    182, 181, 180,    91, 183, 93,
    185, 14, 184,    188, 187, 186,    98, 189, 100,    188, 186, 190,    13, 5, 21,
    159, 191, 88,    160, 192, 33,    72, 135, 71,    63, 62, 193,    151, 194, 150,
    197, 196, 195,    199, 198, 13,    96, 128, 200,    200, 202, 201,    159, 88, 89,
    205, 204, 203,    208, 207, 206,    191, 159, 85,    107, 210, 209,    211, 58, 132,
    214, 213, 212,    92, 38, 1,    217, 216, 215,    220, 219, 218,    42, 221, 97,
    222, 14, 185,    225, 224, 223,    60, 61, 131,    228, 227, 226,    231, 230, 229,
    234, 233, 232,    235, 177, 176,    236, 95, 96,    237, 167, 168,    213, 214, 238,
    222, 185, 213,    168, 169, 171,    241, 240, 239,    122, 242, 124,    133, 244, 243,
    246, 242, 245,    249, 248, 247,    251, 114, 250,    110, 252, 112,    18, 19, 54,
    165, 166, 253,    116, 254, 118,    256, 255, 120,    259, 258, 257,    260, 70, 69,
    79, 232, 81,    83, 84, 261,    263, 262, 170,    53, 20, 155,    265, 264, 59,
    129, 59, 264,    267, 266, 161,    268, 120, 121,    217, 40, 41,    217, 41, 216,
    269, 118, 254,    269, 181, 118,    179, 271, 270,    273, 114, 272,    6, 7, 180,
    149, 78, 274,    101, 184, 14,    14, 15, 101,    8, 15, 7,    174, 44, 45,
    276, 275, 36,    76, 277, 78,    280, 279, 278,    148, 281, 147,    90, 93, 183,
    213, 238, 222,    63, 267, 161,    63, 161, 162,    138, 35, 36,    138, 36, 275,
    284, 283, 282,    283, 102, 282,    286, 285, 10,    153, 285, 286,    19, 287, 55,
    288, 172, 104,    289, 103, 102,    136, 291, 290,    50, 293, 292,    50, 294, 49,
    297, 296, 295,    299, 298, 294,    214, 212, 38,    40, 217, 300,    227, 302, 301,
    301, 158, 303,    306, 305, 304,    304, 305, 200,    209, 210, 307,    132, 58, 308,
    91, 92, 1,    182, 1, 2,    69, 70, 309,    199, 310, 198,    311, 251, 250,
    82, 80, 84,    158, 301, 312,    158, 312, 313,    316, 315, 314,    248, 134, 317,
    58, 211, 57,    319, 225, 318,    320, 30, 237,    320, 321, 30,    187, 188, 322,
    102, 323, 289,    324, 123, 124,    247, 243, 244,    261, 233, 83,    178, 111, 325,
    196, 197, 326,    329, 328, 327,    7, 182, 180,    182, 2, 181,    246, 245, 11,
    331, 87, 330,    273, 111, 332,    332, 114, 273,    0, 117, 118,    164, 333, 166,
    148, 146, 334,    121, 119, 75,    335, 21, 3,    27, 336, 26,    337, 51, 49,
    298, 299, 338,    212, 339, 38,    38, 339, 340,    342, 156, 341,    156, 342, 158,
    240, 241, 343,    105, 106, 31,    205, 203, 344,    32, 86, 34,    262, 237, 168,
    168, 170, 262,    286, 26, 291,    286, 291, 136,    269, 180, 181,    75, 73, 121,
    347, 346, 345,    345, 348, 347,    325, 349, 178,    349, 114, 271,    58, 109, 107,
    107, 308, 58,    350, 100, 189,    100, 350, 351,    29, 30, 321,    321, 352, 105,
    207, 32, 206,    206, 32, 353,    7, 183, 182,    16, 7, 15,    356, 355, 354,
    358, 357, 355,    361, 360, 359,    78, 149, 77,    362, 355, 356,    363, 354, 362,
    154, 364, 53,    144, 145, 365,    142, 23, 24,    41, 326, 366,    365, 307, 367,
    364, 154, 365,    126, 123, 324,    133, 67, 244,    330, 88, 191,    87, 88, 330,
    125, 368, 127,    310, 199, 368,    10, 369, 28,    193, 28, 369,    226, 370, 228,
    371, 370, 226,    8, 6, 174,    174, 45, 8,    372, 114, 177,    232, 372, 234,
    373, 128, 94,    27, 63, 162,    49, 294, 298,    338, 49, 298,    186, 374, 190,
    184, 375, 185,    185, 375, 376,    376, 213, 185,    365, 145, 377,    377, 132, 308,
    96, 378, 236,    305, 306, 378,    368, 125, 310,    68, 69, 309,    381, 380, 379,
    384, 383, 382,    385, 102, 187,    187, 102, 283,    248, 249, 246,    134, 248, 135,
    51, 337, 386,    282, 386, 284,    95, 346, 347,    347, 94, 95,    333, 164, 200,
    164, 304, 200,    169, 167, 30,    237, 30, 167,    295, 191, 297,    191, 295, 330,
    94, 387, 373,    94, 347, 348,    59, 60, 155,    265, 59, 155,    165, 253, 388,
    39, 38, 340,    112, 252, 251,    252, 114, 251,    389, 175, 138,    382, 390, 277,
    12, 13, 198,    70, 198, 310,    136, 35, 138,    103, 289, 293,    255, 391, 120,
    394, 393, 392,    362, 357, 358,    358, 355, 362,    311, 111, 112,    112, 251, 311,
    396, 395, 231,    395, 396, 397,    218, 219, 216,    158, 313, 157,    277, 76, 382,
    382, 76, 398,    400, 220, 399,    401, 399, 195,    120, 402, 256,    402, 120, 268,
    405, 404, 403,    406, 371, 226,    229, 230, 407,    227, 228, 302,    365, 154, 60,
    154, 155, 60,    202, 200, 128,    128, 373, 202,    316, 257, 315,    410, 409, 408,
    90, 14, 222,    238, 90, 222,    109, 411, 108,    412, 264, 265,    415, 414, 413,
    414, 415, 416,    235, 111, 417,    417, 177, 235,    307, 365, 377,    307, 377, 209,
    420, 419, 418,    420, 418, 421,    288, 55, 287,    263, 170, 287,    192, 351, 350,
    87, 331, 351,    84, 81, 261,    81, 84, 80,    424, 423, 422,    426, 425, 279,
    54, 321, 427,    54, 55, 321,    258, 315, 257,    243, 317, 133,    240, 428, 239,
    170, 171, 172,    87, 160, 89,    203, 204, 429,    28, 62, 27,    62, 28, 193,
    286, 136, 137,    153, 286, 137,    430, 70, 260,    316, 431, 257,    178, 349, 271,
    178, 271, 179,    305, 378, 96,    305, 96, 200,    377, 145, 132,    131, 132, 145,
    432, 405, 328,    404, 405, 432,    51, 386, 282,    51, 282, 102,    293, 50, 103,
    50, 51, 103,    71, 246, 11,    71, 11, 12,    56, 109, 58,    412, 109, 264,
    55, 288, 352,    352, 321, 55,    350, 353, 192,    353, 350, 206,    310, 309, 70,
    68, 309, 310,    180, 434, 433,    180, 269, 434,    224, 225, 319,    132, 130, 211,
    261, 81, 232,    261, 232, 233,    223, 435, 225,    438, 437, 436,    25, 199, 13,
    400, 399, 401,    441, 440, 439,    440, 441, 442,    126, 127, 123,    326, 97, 196,
    207, 85, 32,    85, 297, 191,    138, 275, 389,    276, 389, 275,    304, 388, 306,
    445, 444, 443,    446, 376, 375,    283, 284, 374,    376, 447, 213,    447, 212, 213,
    50, 292, 294,    294, 292, 299,    387, 94, 348,    387, 348, 345,    238, 214, 92,
    38, 92, 214,    110, 272, 252,    272, 114, 252,    332, 270, 114,    271, 114, 270,
    45, 101, 15,    15, 8, 45,    448, 250, 115,    250, 114, 115,    395, 449, 231,
    231, 449, 230,    70, 12, 198,    70, 71, 12,    2, 118, 181,    118, 2, 0,
    452, 451, 450,    451, 452, 453,    276, 36, 454,    454, 36, 37,    161, 266, 455,
    455, 163, 161,    216, 219, 215,    365, 367, 364,    113, 114, 372,    232, 79, 372,
    332, 111, 179,    179, 270, 332,    206, 189, 208,    350, 189, 206,    456, 255, 256,
    255, 456, 457,    20, 412, 265,    20, 265, 155,    105, 29, 321,    31, 29, 105,
    110, 111, 273,    273, 272, 110,    448, 111, 311,    311, 250, 448,    405, 458, 328,
    458, 459, 328,    398, 384, 382,    462, 461, 460,    325, 111, 235,    235, 176, 325,
    374, 186, 283,    283, 186, 187,    249, 242, 246,    247, 242, 249,    362, 354, 357,
    357, 354, 355,    104, 105, 352,    352, 288, 104,    33, 353, 32,    192, 353, 33,
    464, 416, 463,    464, 463, 465,    416, 464, 466,    416, 466, 414,    442, 421, 440,
    421, 442, 420,    469, 468, 467,    468, 469, 470,    244, 324, 247,    324, 244, 126,
    49, 338, 337,    208, 296, 297,    443, 413, 445,    413, 443, 415,    365, 60, 144,
    60, 131, 144,    182, 183, 91,    91, 1, 182,    388, 304, 165,    304, 164, 165,
    321, 320, 427,    95, 236, 346,    471, 329, 407,    329, 471, 432,    356, 354, 363,
    362, 356, 363,    163, 455, 472,    200, 201, 333,    135, 246, 71,    246, 135, 248,
    208, 297, 207,    85, 207, 297,    412, 20, 411,    411, 109, 412,    470, 450, 468,
    450, 470, 452,    176, 114, 349,    325, 176, 349,    209, 377, 308,    308, 107, 209,
    339, 212, 473,    212, 447, 473,    459, 397, 474,    459, 474, 328,    56, 264, 109,
    129, 264, 56,    37, 475, 454,    102, 385, 323,    287, 170, 288,    172, 288, 170,
    351, 192, 87,    160, 87, 192,    90, 238, 93,    92, 93, 238,    149, 274, 74,
    180, 433, 6,    477, 453, 476,    453, 477, 451,    124, 247, 324,    247, 124, 242,
    476, 478, 477,    478, 476, 479,    479, 480, 478,    480, 479, 481,    28, 26, 10,
    484, 483, 482,    487, 486, 485,    369, 10, 488,    16, 90, 183,    7, 16, 183,
    330, 489, 331,    489, 330, 295,    67, 126, 244,    67, 68, 126,    22, 490, 24,
    301, 303, 227,    426, 279, 152,    10, 285, 491,    492, 407, 230,    471, 407, 492,
    419, 420, 493,    419, 493, 494,    439, 481, 441,    481, 439, 480,    68, 125, 126,
    125, 68, 310,    341, 495, 342,    143, 24, 496,    243, 247, 248,    317, 243, 248,
    187, 322, 385,    467, 497, 469,
};

D3DMATRIX g_tmat1 = 
{
    -0.859661f, -0.429042f, -0.277320f, 0.000000f, 
    0.365274f, -0.895727f, 0.253472f, 0.000000f, 
    -0.357153f, 0.116602f, 0.926740f, 0.000000f, 
    2.627484f, -2.707155f, 2.942882f, 1.000000f, 
};

// Mesh #1 Tris:518 Verts:420
MODELVERT g_tmesh1[] = 
{
    { {-0.179223f, -0.243226f, -0.492815f}, {-0.381066f, -0.907097f, 0.178784f}, {0.360827f, 0.293406f} },
    { {-0.113078f, -0.187273f, -0.036920f}, {-0.448027f, -0.868280f, 0.212983f}, {0.418612f, 0.283345f} },
    { {0.003280f, -0.250421f, -0.175655f}, {-0.162907f, -0.974865f, 0.151986f}, {0.401214f, 0.256179f} },
    { {-0.064235f, 0.273579f, -0.527082f}, {0.345688f, 0.933844f, -0.091841f}, {0.358227f, 0.291105f} },
    { {-0.145451f, 0.278733f, -0.559698f}, {-0.181684f, 0.973950f, 0.135692f}, {0.353941f, 0.308064f} },
    { {-0.100669f, 0.282022f, -0.654248f}, {0.277908f, 0.960477f, -0.015857f}, {0.342134f, 0.298646f} },
    { {-0.301333f, 0.151490f, -0.746869f}, {-0.979034f, 0.176058f, 0.102449f}, {0.329625f, 0.334517f} },
    { {-0.318896f, 0.032339f, -0.751519f}, {-0.985371f, 0.097986f, 0.139434f}, {0.328663f, 0.333157f} },
    { {-0.314131f, 0.097835f, -0.812849f}, {-0.976413f, 0.215665f, -0.010306f}, {0.321127f, 0.334735f} },
    { {-0.257180f, 0.163135f, -0.978453f}, {0.863795f, -0.425465f, -0.269885f}, {0.300564f, 0.325185f} },
    { {-0.289646f, -0.001626f, -0.986113f}, {0.933142f, -0.001056f, -0.359506f}, {0.299060f, 0.324996f} },
    { {-0.213815f, 0.000285f, -0.614902f}, {0.971200f, -0.106044f, -0.213366f}, {0.346040f, 0.310422f} },
    { {-0.097258f, -0.280375f, -0.559845f}, {0.174175f, -0.984705f, -0.004407f}, {0.352461f, 0.274665f} },
    { {0.115681f, -0.223095f, -0.262161f}, {0.595661f, -0.774408f, -0.213262f}, {0.390645f, 0.233771f} },
    { {0.013460f, -0.209421f, -0.525912f}, {0.655481f, -0.704640f, -0.271710f}, {0.357195f, 0.254779f} },
    { {-0.039611f, 0.248033f, -0.564295f}, {0.619946f, 0.775119f, -0.121895f}, {0.353520f, 0.284823f} },
    { {-0.275019f, 0.110675f, -0.511310f}, {-0.990375f, 0.052266f, 0.128164f}, {0.359269f, 0.328030f} },
    { {-0.277326f, -0.103176f, -0.513368f}, {-0.989018f, -0.071195f, 0.129519f}, {0.358402f, 0.319549f} },
    { {-0.318866f, -0.032603f, -0.751210f}, {-0.986746f, -0.038107f, 0.157733f}, {0.328520f, 0.330433f} },
    { {-0.086608f, -0.234596f, -0.840245f}, {-0.261155f, 0.877645f, -0.401916f}, {0.317264f, 0.273568f} },
    { {-0.103168f, -0.151813f, -0.537545f}, {0.609733f, 0.718316f, -0.335033f}, {0.355621f, 0.281337f} },
    { {-0.159967f, -0.266001f, -0.935382f}, {0.584376f, 0.715493f, -0.382851f}, {0.305012f, 0.287189f} },
    { {0.243721f, -0.081149f, -0.191827f}, {0.980860f, -0.167589f, -0.099140f}, {0.400208f, 0.213371f} },
    { {0.239713f, 0.094006f, -0.145502f}, {0.985422f, 0.169998f, 0.006685f}, {0.406532f, 0.221668f} },
    { {0.234378f, 0.001498f, -0.302609f}, {0.937980f, -0.065509f, -0.340445f}, {0.386452f, 0.218450f} },
    { {0.181630f, 0.004477f, -0.000022f}, {0.056256f, 0.007525f, 0.998388f}, {0.424486f, 0.230380f} },
    { {-0.000481f, 0.187504f, -0.001664f}, {-0.001498f, 0.324490f, 0.945888f}, {0.424372f, 0.275793f} },
    { {0.157354f, 0.096682f, -0.000785f}, {0.363396f, 0.252532f, 0.896756f}, {0.424593f, 0.239271f} },
    { {-0.325616f, -0.097929f, -0.233881f}, {-0.963551f, -0.264392f, 0.040835f}, {0.393540f, 0.330583f} },
    { {-0.318483f, -0.054752f, -0.449401f}, {-0.950812f, -0.246393f, -0.187742f}, {0.366508f, 0.330293f} },
    { {-0.318558f, 0.052693f, -0.449628f}, {-0.990316f, 0.102233f, -0.093927f}, {0.366781f, 0.334806f} },
    { {-0.128172f, 0.183499f, -0.038998f}, {-0.343389f, 0.904966f, 0.251238f}, {0.419359f, 0.301991f} },
    { {-0.125055f, 0.243577f, -0.391905f}, {-0.564111f, 0.812543f, 0.146807f}, {0.375043f, 0.302846f} },
    { {0.003260f, 0.254780f, -0.178100f}, {-0.159252f, 0.977585f, 0.137715f}, {0.402327f, 0.277327f} },
    { {0.168645f, -0.062578f, -0.682154f}, {-0.402087f, 0.799827f, -0.445649f}, {0.338270f, 0.228304f} },
    { {-0.028301f, -0.089107f, -0.480119f}, {-0.542019f, 0.727311f, -0.420991f}, {0.363210f, 0.268605f} },
    { {0.064378f, 0.136271f, -0.736941f}, {-0.350573f, -0.864343f, -0.360570f}, {0.331681f, 0.258089f} },
    { {-0.086614f, 0.233171f, -0.842824f}, {-0.202073f, -0.889849f, -0.409066f}, {0.318255f, 0.293145f} },
    { {-0.028377f, 0.090884f, -0.480898f}, {-0.531166f, -0.742321f, -0.408440f}, {0.363618f, 0.276154f} },
    { {-0.299008f, -0.151060f, -0.710175f}, {-0.995835f, -0.081683f, 0.040501f}, {0.333406f, 0.321474f} },
    { {-0.296138f, -0.238953f, -0.707743f}, {-0.943929f, -0.292146f, 0.153784f}, {0.333472f, 0.317206f} },
    { {-0.287354f, -0.270231f, -0.862502f}, {-0.947662f, -0.253255f, -0.194418f}, {0.313893f, 0.313631f} },
    { {0.053649f, -0.102568f, -0.808674f}, {0.859130f, -0.174817f, -0.480972f}, {0.321941f, 0.250108f} },
    { {0.027138f, -0.022148f, -0.848868f}, {0.834009f, -0.000827f, -0.551750f}, {0.317038f, 0.258855f} },
    { {0.000352f, -0.082072f, -0.890030f}, {0.838747f, 0.021274f, -0.544105f}, {0.311618f, 0.261782f} },
    { {0.122326f, 0.148038f, -0.626495f}, {0.578826f, 0.810317f, 0.091362f}, {0.345773f, 0.246885f} },
    { {-0.017351f, 0.228943f, -0.574206f}, {0.541605f, 0.832437f, 0.117103f}, {0.352269f, 0.279380f} },
    { {-0.026142f, 0.217419f, -0.759678f}, {0.628094f, 0.763454f, -0.150453f}, {0.328833f, 0.280187f} },
    { {0.164635f, 0.183652f, -0.269651f}, {0.734387f, 0.587513f, -0.339859f}, {0.390958f, 0.240630f} },
    { {0.068681f, 0.161295f, -0.486253f}, {0.765951f, 0.507052f, -0.395243f}, {0.363366f, 0.258965f} },
    { {0.217029f, 0.074870f, -0.307833f}, {0.847550f, 0.401184f, -0.347435f}, {0.385960f, 0.225103f} },
    { {-0.237025f, 0.355417f, -0.801611f}, {-0.791425f, 0.604192f, -0.092729f}, {0.323447f, 0.329565f} },
    { {-0.287599f, 0.268474f, -0.865200f}, {-0.929730f, 0.285090f, -0.233079f}, {0.315068f, 0.336227f} },
    { {-0.228107f, 0.303220f, -0.909603f}, {-0.515779f, 0.505580f, -0.691636f}, {0.309706f, 0.325221f} },
    { {-0.308430f, 0.086681f, -0.928340f}, {-0.915571f, 0.260848f, -0.306085f}, {0.306548f, 0.332754f} },
    { {-0.265598f, 0.175773f, -0.970599f}, {-0.796233f, 0.341088f, -0.499672f}, {0.301571f, 0.327482f} },
    { {-0.178120f, 0.003595f, -0.000021f}, {-0.196709f, 0.023143f, 0.980189f}, {0.423651f, 0.304927f} },
    { {-0.100373f, 0.154322f, -0.001425f}, {-0.082285f, 0.092811f, 0.992278f}, {0.424078f, 0.295114f} },
    { {-0.326429f, 0.095848f, -0.197092f}, {-0.925098f, 0.377319f, 0.042716f}, {0.398722f, 0.338970f} },
    { {0.194426f, 0.000181f, -0.659919f}, {-0.630638f, 0.154300f, -0.760583f}, {0.341310f, 0.225651f} },
    { {0.120640f, -0.108226f, -0.451658f}, {0.827757f, -0.370080f, -0.421733f}, {0.367089f, 0.237008f} },
    { {0.206999f, -0.115456f, -0.283250f}, {0.790649f, -0.512081f, -0.335630f}, {0.388501f, 0.219285f} },
    { {-0.264640f, -0.170323f, -0.974635f}, {0.795507f, 0.434257f, -0.422598f}, {0.300090f, 0.312782f} },
    { {-0.247239f, -0.347870f, -0.805583f}, {-0.792052f, -0.605970f, -0.073859f}, {0.320944f, 0.302227f} },
    { {-0.241921f, -0.298953f, -0.900987f}, {-0.501447f, -0.494696f, -0.709808f}, {0.309066f, 0.302899f} },
    { {-0.265718f, 0.119637f, -0.227038f}, {-0.636144f, 0.768593f, 0.067712f}, {0.395154f, 0.327294f} },
    { {-0.277007f, 0.091821f, -0.434097f}, {-0.767317f, 0.636072f, 0.081466f}, {0.368945f, 0.327875f} },
    { {-0.296355f, 0.239045f, -0.709974f}, {-0.943898f, 0.290530f, 0.157001f}, {0.334535f, 0.337257f} },
    { {-0.244751f, 0.171533f, -0.529133f}, {-0.931511f, 0.186300f, 0.312378f}, {0.357263f, 0.324251f} },
    { {-0.283443f, 0.150018f, -0.639518f}, {-0.967620f, 0.054675f, 0.246417f}, {0.343197f, 0.331055f} },
    { {0.053649f, 0.088421f, -0.809507f}, {0.870000f, 0.327169f, -0.368864f}, {0.322373f, 0.258101f} },
    { {-0.057216f, 0.215246f, -0.929271f}, {0.712408f, 0.540264f, -0.447873f}, {0.307374f, 0.286051f} },
    { {-0.038783f, 0.080638f, -0.953663f}, {0.724008f, 0.184509f, -0.664657f}, {0.303963f, 0.276524f} },
    { {-0.120570f, 0.089088f, -1.009109f}, {0.575541f, 0.101111f, -0.811498f}, {0.296808f, 0.293675f} },
    { {-0.079070f, 0.036981f, -0.980766f}, {0.560879f, -0.003612f, -0.827890f}, {0.300330f, 0.282971f} },
    { {-0.033481f, 0.242775f, -0.567025f}, {0.653335f, 0.753417f, -0.074275f}, {0.353176f, 0.283324f} },
    { {-0.150226f, 0.355854f, -0.737025f}, {0.480329f, 0.876362f, 0.035683f}, {0.331791f, 0.311774f} },
    { {-0.153822f, 0.348759f, -0.832157f}, {0.325837f, 0.915129f, -0.237422f}, {0.319770f, 0.311949f} },
    { {-0.099022f, 0.301221f, -0.803187f}, {0.722763f, 0.686325f, -0.081063f}, {0.323415f, 0.298680f} },
    { {0.159776f, -0.111390f, -0.653979f}, {0.767077f, -0.623751f, 0.150093f}, {0.341664f, 0.228180f} },
    { {0.116427f, -0.090895f, -0.493256f}, {0.891656f, -0.355984f, 0.279687f}, {0.361884f, 0.238487f} },
    { {0.180354f, -0.062428f, -0.632481f}, {0.937320f, -0.219811f, 0.270398f}, {0.344560f, 0.226026f} },
    { {0.119287f, 0.086448f, -0.519417f}, {0.762385f, 0.531572f, 0.369054f}, {0.359092f, 0.245244f} },
    { {0.180343f, 0.062737f, -0.633171f}, {0.908439f, 0.232350f, 0.347494f}, {0.344825f, 0.231266f} },
    { {0.153242f, 0.000321f, -0.562159f}, {0.949678f, -0.001961f, 0.313220f}, {0.353539f, 0.234476f} },
    { {-0.209975f, -0.052832f, -0.623959f}, {0.910357f, 0.315414f, -0.267887f}, {0.344758f, 0.307376f} },
    { {0.077422f, 0.000482f, -0.562139f}, {-0.708510f, -0.132937f, -0.693066f}, {0.353367f, 0.250202f} },
    { {0.168841f, 0.062564f, -0.683081f}, {-0.549789f, -0.641722f, -0.534719f}, {0.338506f, 0.233500f} },
    { {-0.150023f, -0.356274f, -0.733465f}, {0.368679f, -0.929498f, 0.010468f}, {0.330237f, 0.281928f} },
    { {-0.098916f, -0.302310f, -0.800127f}, {0.722798f, -0.686956f, -0.075197f}, {0.322103f, 0.273400f} },
    { {-0.153662f, -0.350080f, -0.828632f}, {0.523278f, -0.770801f, -0.363380f}, {0.318248f, 0.282668f} },
    { {-0.177289f, -0.266724f, -0.503205f}, {-0.378994f, -0.790752f, 0.480701f}, {0.359455f, 0.291991f} },
    { {-0.138182f, -0.280522f, -0.573702f}, {0.513027f, -0.780980f, 0.356195f}, {0.350619f, 0.283103f} },
    { {-0.166597f, -0.348701f, -0.682263f}, {0.259787f, -0.893608f, 0.366026f}, {0.336675f, 0.285828f} },
    { {-0.038783f, -0.084928f, -0.952941f}, {0.744270f, -0.173143f, -0.645046f}, {0.303589f, 0.269595f} },
    { {-0.056982f, -0.230438f, -0.927518f}, {0.737280f, -0.330972f, -0.588962f}, {0.306342f, 0.267349f} },
    { {0.000045f, -0.195560f, -0.849464f}, {0.822797f, -0.504429f, -0.261832f}, {0.316413f, 0.257210f} },
    { {0.195601f, -0.054308f, -0.021966f}, {0.860316f, -0.143978f, 0.489005f}, {0.421586f, 0.224959f} },
    { {0.243828f, 0.002604f, -0.110258f}, {0.963595f, -0.020606f, 0.266570f}, {0.410727f, 0.217089f} },
    { {0.239692f, -0.089536f, -0.144682f}, {0.928262f, -0.212696f, 0.305107f}, {0.406118f, 0.213991f} },
    { {0.085489f, -0.239986f, -0.197332f}, {0.260692f, -0.964247f, 0.047627f}, {0.398701f, 0.239510f} },
    { {0.058555f, 0.088973f, -0.682995f}, {0.640830f, 0.762551f, 0.088616f}, {0.338336f, 0.257471f} },
    { {-0.033197f, 0.181250f, -0.813534f}, {0.449526f, 0.879122f, 0.158337f}, {0.321926f, 0.279981f} },
    { {0.051241f, 0.180265f, -0.492491f}, {0.667426f, 0.683856f, -0.294759f}, {0.362593f, 0.263357f} },
    { {0.115608f, 0.226547f, -0.264156f}, {0.584566f, 0.785634f, -0.202635f}, {0.391658f, 0.252606f} },
    { {0.192480f, 0.140619f, -0.060648f}, {0.751071f, 0.433800f, 0.497704f}, {0.417251f, 0.233656f} },
    { {0.212862f, 0.072687f, -0.048684f}, {0.861539f, 0.147599f, 0.485763f}, {0.418615f, 0.226620f} },
    { {-0.162171f, 0.161838f, -0.039337f}, {-0.602643f, 0.721182f, 0.341640f}, {0.419176f, 0.308132f} },
    { {-0.237951f, 0.086572f, -0.063299f}, {-0.638933f, 0.150683f, 0.754360f}, {0.415768f, 0.320623f} },
    { {-0.166831f, 0.348800f, -0.685687f}, {0.298435f, 0.893795f, 0.334765f}, {0.338205f, 0.315068f} },
    { {-0.094573f, 0.292271f, -0.681512f}, {0.646856f, 0.737078f, 0.195687f}, {0.338740f, 0.297733f} },
    { {-0.153827f, 0.290312f, -0.558821f}, {0.127994f, 0.909765f, 0.394898f}, {0.354065f, 0.310288f} },
    { {-0.250080f, 0.285174f, -0.628681f}, {-0.813692f, 0.468419f, 0.344221f}, {0.345020f, 0.329828f} },
    { {-0.339781f, -0.067670f, -0.814326f}, {-0.980778f, -0.136672f, 0.139270f}, {0.320415f, 0.333119f} },
    { {-0.347887f, -0.062072f, -0.917349f}, {-0.971539f, -0.236832f, 0.004729f}, {0.307424f, 0.334738f} },
    { {-0.346777f, 0.078705f, -0.902125f}, {-0.976881f, 0.204639f, 0.061854f}, {0.309742f, 0.340445f} },
    { {-0.292838f, -0.171336f, -0.858821f}, {-0.910172f, -0.386903f, -0.147961f}, {0.314623f, 0.318919f} },
    { {-0.228130f, -0.234069f, -0.919247f}, {-0.740673f, -0.600598f, -0.301139f}, {0.306978f, 0.302703f} },
    { {-0.123553f, -0.108099f, -1.014521f}, {0.604489f, -0.092150f, -0.791266f}, {0.295564f, 0.286022f} },
    { {-0.084692f, -0.022739f, -0.984314f}, {0.585468f, 0.013532f, -0.810582f}, {0.299702f, 0.281626f} },
    { {0.010733f, -0.207596f, -0.581273f}, {0.529045f, -0.843369f, 0.094025f}, {0.350215f, 0.255261f} },
    { {0.120055f, -0.148001f, -0.661840f}, {0.603381f, -0.794661f, -0.066677f}, {0.340478f, 0.234860f} },
    { {-0.026107f, -0.218121f, -0.757499f}, {0.647203f, -0.739436f, -0.185371f}, {0.327883f, 0.261952f} },
    { {0.099066f, -0.112090f, -0.510745f}, {0.613129f, -0.745097f, 0.262495f}, {0.359579f, 0.241149f} },
    { {-0.073385f, 0.273931f, -0.610752f}, {0.673471f, 0.736283f, -0.065751f}, {0.347658f, 0.292776f} },
    { {-0.086197f, 0.280692f, -0.682389f}, {0.707271f, 0.706359f, -0.028704f}, {0.338616f, 0.295509f} },
    { {-0.087159f, -0.239109f, -0.889184f}, {0.531256f, -0.826606f, 0.185715f}, {0.311081f, 0.273353f} },
    { {0.056102f, -0.102292f, -0.745402f}, {0.616686f, -0.759032f, 0.208731f}, {0.329924f, 0.249793f} },
    { {-0.246208f, -0.105762f, -0.115843f}, {-0.667620f, -0.733331f, 0.128491f}, {0.408584f, 0.314132f} },
    { {-0.172217f, -0.221183f, -0.433095f}, {-0.685257f, -0.713455f, 0.146303f}, {0.368434f, 0.293048f} },
    { {-0.243285f, -0.143140f, -0.425406f}, {-0.754681f, -0.649208f, 0.094794f}, {0.369458f, 0.311071f} },
    { {-0.249837f, -0.284215f, -0.626107f}, {-0.767107f, -0.520450f, 0.375072f}, {0.343744f, 0.305947f} },
    { {-0.252970f, -0.181216f, -0.527356f}, {-0.872935f, -0.316922f, 0.370870f}, {0.356476f, 0.311192f} },
    { {-0.210018f, 0.053350f, -0.624426f}, {0.835386f, -0.408331f, -0.367963f}, {0.344997f, 0.311829f} },
    { {-0.103301f, 0.153130f, -0.538942f}, {0.618576f, -0.721749f, -0.310551f}, {0.356302f, 0.294127f} },
    { {-0.184829f, -0.043959f, -0.580271f}, {0.725254f, 0.043101f, -0.687131f}, {0.350349f, 0.302660f} },
    { {-0.101594f, -0.121970f, -0.510247f}, {0.648324f, 0.061798f, -0.758852f}, {0.359150f, 0.282338f} },
    { {-0.101713f, 0.123551f, -0.511353f}, {0.668266f, -0.098212f, -0.737411f}, {0.359701f, 0.292639f} },
    { {-0.237917f, -0.080509f, -0.062460f}, {-0.692227f, -0.042671f, 0.720417f}, {0.415404f, 0.313623f} },
    { {-0.076156f, -0.138782f, -0.515990f}, {-0.434731f, 0.831907f, -0.344876f}, {0.358437f, 0.276344f} },
    { {-0.045497f, 0.073639f, -0.467682f}, {0.581266f, -0.131067f, -0.803089f}, {0.365196f, 0.279020f} },
    { {-0.028915f, 0.001189f, -0.439564f}, {-0.360301f, -0.004177f, -0.932827f}, {0.368576f, 0.272630f} },
    { {0.014003f, 0.211140f, -0.521770f}, {0.625116f, 0.778506f, -0.056202f}, {0.358902f, 0.272285f} },
    { {-0.315506f, -0.097981f, -0.814408f}, {-0.972348f, -0.231858f, 0.027967f}, {0.320376f, 0.326817f} },
    { {-0.299008f, -0.151060f, -0.710175f}, {-0.977832f, -0.182012f, 0.103516f}, {0.333406f, 0.321474f} },
    { {-0.311119f, -0.105246f, -0.899364f}, {-0.923044f, -0.339521f, -0.180871f}, {0.309655f, 0.325359f} },
    { {-0.026107f, -0.218121f, -0.757499f}, {0.685586f, -0.677314f, -0.266867f}, {0.327883f, 0.261952f} },
    { {-0.073449f, -0.273479f, -0.608265f}, {0.606942f, -0.792906f, -0.054056f}, {0.346431f, 0.269878f} },
    { {0.010733f, -0.207596f, -0.581273f}, {0.668387f, -0.738482f, -0.088902f}, {0.350215f, 0.255261f} },
    { {-0.094418f, -0.292291f, -0.678621f}, {0.649250f, -0.732092f, 0.206192f}, {0.337460f, 0.273236f} },
    { {-0.006911f, -0.059431f, -0.898257f}, {0.782646f, -0.002715f, -0.622461f}, {0.310628f, 0.264212f} },
    { {0.015565f, -0.015366f, -0.870189f}, {0.782646f, -0.002716f, -0.622461f}, {0.314343f, 0.261477f} },
    { {-0.057217f, 0.040341f, -0.961944f}, {0.770016f, -0.115034f, -0.627569f}, {0.302763f, 0.278635f} },
    { {0.192413f, -0.135378f, -0.059439f}, {0.733666f, -0.516516f, 0.441526f}, {0.416627f, 0.222118f} },
    { {0.157146f, -0.090978f, -0.000162f}, {0.313931f, -0.241578f, 0.918198f}, {0.424143f, 0.231459f} },
    { {-0.000555f, -0.181629f, 0.000000f}, {0.013595f, -0.312671f, 0.949764f}, {0.423543f, 0.260359f} },
    { {-0.228263f, 0.231721f, -0.921502f}, {-0.493066f, 0.143174f, -0.858130f}, {0.308004f, 0.322225f} },
    { {-0.111010f, 0.288276f, -0.848110f}, {0.576097f, 0.608849f, -0.545358f}, {0.317687f, 0.300495f} },
    { {-0.207834f, 0.340828f, -0.881291f}, {0.181943f, 0.867297f, -0.463349f}, {0.313428f, 0.322673f} },
    { {-0.168935f, 0.281539f, -0.914452f}, {0.304272f, 0.524033f, -0.795492f}, {0.309171f, 0.312031f} },
    { {-0.293830f, 0.166670f, -0.860373f}, {-0.943166f, 0.311219f, -0.116533f}, {0.315376f, 0.333271f} },
    { {0.011310f, 0.227668f, -0.055473f}, {-0.020305f, 0.937285f, 0.347972f}, {0.417729f, 0.274875f} },
    { {0.111005f, 0.183967f, -0.022195f}, {0.313899f, 0.583215f, 0.749218f}, {0.422032f, 0.252473f} },
    { {0.219252f, 0.135316f, -0.132764f}, {0.767371f, 0.623812f, 0.148323f}, {0.408206f, 0.227676f} },
    { {0.154323f, 0.176027f, -0.051902f}, {0.599954f, 0.743034f, 0.296572f}, {0.418365f, 0.243074f} },
    { {0.152023f, 0.206205f, -0.140182f}, {0.584329f, 0.806234f, 0.092448f}, {0.407315f, 0.244561f} },
    { {-0.209637f, 0.077956f, -0.969399f}, {0.604624f, -0.595582f, -0.528879f}, {0.301576f, 0.311788f} },
    { {-0.209637f, -0.091813f, -0.968659f}, {0.126885f, 0.399184f, -0.908049f}, {0.301192f, 0.304683f} },
    { {-0.158624f, 0.078283f, -0.901158f}, {0.713344f, -0.408958f, -0.569116f}, {0.310299f, 0.301422f} },
    { {-0.158624f, -0.091485f, -0.900417f}, {0.711557f, 0.456526f, -0.534107f}, {0.309914f, 0.294317f} },
    { {-0.265598f, 0.175773f, -0.970599f}, {-0.674783f, 0.686970f, -0.269703f}, {0.301571f, 0.327482f} },
    { {-0.228263f, 0.231721f, -0.921502f}, {-0.674783f, 0.686970f, -0.269703f}, {0.308004f, 0.322225f} },
    { {-0.274284f, 0.185943f, -0.890154f}, {-0.749208f, 0.642196f, -0.162086f}, {0.311721f, 0.329940f} },
    { {-0.159930f, 0.263629f, -0.937995f}, {0.573460f, -0.732429f, -0.367004f}, {0.306173f, 0.309347f} },
    { {-0.246208f, -0.105762f, -0.115843f}, {-0.139823f, -0.970141f, 0.198183f}, {0.408584f, 0.314132f} },
    { {-0.268205f, -0.114153f, -0.274776f}, {-0.009659f, -0.998167f, -0.059743f}, {0.388472f, 0.317884f} },
    { {-0.237951f, 0.086572f, -0.063299f}, {-0.454997f, 0.008038f, 0.890457f}, {0.415768f, 0.320623f} },
    { {-0.237917f, -0.080509f, -0.062460f}, {-0.552456f, -0.304338f, 0.775997f}, {0.415404f, 0.313623f} },
    { {-0.304241f, -0.080884f, -0.101796f}, {-0.761021f, -0.254593f, 0.596682f}, {0.410290f, 0.327245f} },
    { {-0.120192f, -0.116372f, -0.980875f}, {-0.606289f, -0.204266f, 0.768563f}, {0.299790f, 0.285076f} },
    { {-0.067450f, -0.199010f, -0.916532f}, {-0.801558f, 0.588540f, -0.105476f}, {0.307791f, 0.270866f} },
    { {-0.081717f, -0.221532f, -0.933773f}, {-0.863383f, -0.504536f, 0.003491f}, {0.305521f, 0.272832f} },
    { {-0.087159f, -0.239109f, -0.889184f}, {-0.223365f, -0.971912f, 0.074134f}, {0.311081f, 0.273353f} },
    { {-0.148775f, -0.220040f, -0.844590f}, {-0.422901f, -0.897512f, 0.125008f}, {0.316614f, 0.287053f} },
    { {-0.074869f, -0.194830f, -0.682154f}, {-0.143277f, -0.966022f, 0.215112f}, {0.337334f, 0.273253f} },
    { {0.129558f, 0.074100f, -0.476283f}, {0.849658f, 0.285968f, -0.443061f}, {0.364519f, 0.242722f} },
    { {0.117428f, -0.096207f, -0.475550f}, {0.870866f, -0.265139f, -0.413876f}, {0.364104f, 0.238108f} },
    { {-0.074869f, 0.181816f, -0.683797f}, {0.408151f, 0.904016f, 0.127155f}, {0.338187f, 0.289017f} },
    { {-0.148775f, 0.205570f, -0.846447f}, {0.164126f, 0.975770f, 0.144689f}, {0.317577f, 0.304866f} },
    { {-0.134508f, 0.184155f, -0.862865f}, {-0.449942f, -0.709613f, -0.542219f}, {0.315480f, 0.300965f} },
    { {-0.066344f, 0.183910f, -0.919107f}, {-0.449943f, -0.709613f, -0.542219f}, {0.308547f, 0.286661f} },
    { {-0.080612f, 0.206280f, -0.936544f}, {-0.449942f, -0.709613f, -0.542219f}, {0.306378f, 0.290506f} },
    { {-0.287559f, -0.087231f, -0.418772f}, {-0.790564f, -0.608778f, 0.066315f}, {0.370349f, 0.322610f} },
    { {-0.100669f, 0.282022f, -0.654248f}, {0.752979f, 0.542587f, 0.372319f}, {0.342134f, 0.298646f} },
    { {-0.145451f, 0.278733f, -0.559698f}, {0.740416f, 0.512710f, 0.434641f}, {0.353941f, 0.308064f} },
    { {-0.094573f, 0.292271f, -0.681512f}, {0.758793f, 0.532572f, 0.374967f}, {0.338740f, 0.297733f} },
    { {-0.301586f, 0.074268f, -0.090249f}, {-0.917061f, 0.102321f, 0.385396f}, {0.412188f, 0.333223f} },
    { {-0.289472f, 0.086407f, -0.440199f}, {-0.513960f, 0.842912f, -0.159203f}, {0.368132f, 0.330215f} },
    { {-0.265718f, 0.119637f, -0.227038f}, {-0.358419f, 0.933558f, 0.002343f}, {0.395154f, 0.327294f} },
    { {-0.244751f, 0.171533f, -0.529133f}, {-0.759752f, 0.582826f, 0.288255f}, {0.357263f, 0.324251f} },
    { {-0.283443f, 0.150018f, -0.639518f}, {-0.883233f, 0.440025f, 0.162105f}, {0.343197f, 0.331055f} },
    { {-0.285367f, 0.034234f, -0.489707f}, {-0.978632f, 0.078806f, -0.189917f}, {0.361753f, 0.327037f} },
    { {-0.057217f, 0.040341f, -0.961944f}, {0.823644f, -0.328791f, -0.462068f}, {0.302763f, 0.278635f} },
    { {0.019909f, 0.055507f, -0.898525f}, {0.536388f, -0.198426f, -0.820314f}, {0.310980f, 0.263462f} },
    { {-0.011666f, 0.084789f, -0.933007f}, {0.823681f, 0.174264f, -0.539613f}, {0.306642f, 0.271136f} },
    { {0.000352f, 0.078330f, -0.890730f}, {0.837706f, -0.041233f, -0.544562f}, {0.311981f, 0.268495f} },
    { {0.023298f, 0.037530f, -0.854899f}, {0.834791f, -0.006826f, -0.550525f}, {0.316437f, 0.262133f} },
    { {0.110930f, -0.178327f, -0.020607f}, {0.388879f, -0.661082f, 0.641673f}, {0.421213f, 0.237325f} },
    { {0.151998f, -0.201704f, -0.138329f}, {0.556870f, -0.810323f, 0.182406f}, {0.406401f, 0.227493f} },
    { {-0.228130f, -0.234069f, -0.919247f}, {-0.530275f, -0.123233f, -0.838822f}, {0.306978f, 0.302703f} },
    { {-0.110939f, -0.289771f, -0.845251f}, {0.637297f, -0.588546f, -0.497459f}, {0.316422f, 0.276288f} },
    { {-0.168836f, -0.283720f, -0.911697f}, {0.304428f, -0.544630f, -0.781474f}, {0.307928f, 0.288354f} },
    { {-0.313166f, 0.059401f, -0.940323f}, {-0.845080f, 0.071818f, -0.529794f}, {0.304950f, 0.332559f} },
    { {-0.314121f, -0.063663f, -0.939642f}, {-0.861233f, -0.163070f, -0.481338f}, {0.304687f, 0.327607f} },
    { {-0.111010f, 0.288276f, -0.848110f}, {0.761552f, 0.361680f, -0.537797f}, {0.317687f, 0.300495f} },
    { {-0.164366f, 0.280574f, -0.924125f}, {0.489716f, 0.582350f, -0.648881f}, {0.307959f, 0.311016f} },
    { {0.159761f, 0.111560f, -0.655196f}, {0.755517f, 0.623802f, -0.200163f}, {0.342138f, 0.237514f} },
    { {0.214517f, 0.143190f, -0.204062f}, {0.799145f, 0.588068f, -0.124674f}, {0.399229f, 0.228782f} },
    { {-0.231684f, -0.356903f, -0.727607f}, {-0.469407f, -0.854969f, 0.220646f}, {0.330785f, 0.298848f} },
    { {-0.207636f, -0.342661f, -0.877877f}, {-0.035174f, -0.940165f, -0.338898f}, {0.311936f, 0.294027f} },
    { {-0.033481f, 0.242775f, -0.567025f}, {0.631298f, 0.772394f, -0.069791f}, {0.353176f, 0.283324f} },
    { {-0.017351f, 0.228943f, -0.574206f}, {0.730134f, 0.643624f, -0.229463f}, {0.352269f, 0.279380f} },
    { {-0.231957f, 0.356720f, -0.731112f}, {-0.402229f, 0.888687f, 0.220107f}, {0.332350f, 0.328772f} },
    { {-0.274284f, 0.185943f, -0.890154f}, {-0.725204f, 0.089421f, -0.682702f}, {0.311721f, 0.329940f} },
    { {-0.301333f, 0.151490f, -0.746869f}, {-0.998908f, 0.046032f, 0.007970f}, {0.329625f, 0.334517f} },
    { {-0.293830f, 0.166670f, -0.860373f}, {-0.983519f, 0.051986f, -0.173168f}, {0.315376f, 0.333271f} },
    { {-0.120570f, 0.089088f, -1.009109f}, {-0.669177f, -0.734735f, -0.111205f}, {0.296808f, 0.293675f} },
    { {-0.123553f, -0.108099f, -1.014521f}, {-0.974458f, 0.165722f, 0.151551f}, {0.295564f, 0.286022f} },
    { {-0.090897f, 0.078040f, -0.956987f}, {-0.869248f, -0.215211f, 0.445076f}, {0.303416f, 0.287210f} },
    { {0.088690f, -0.208318f, -0.055283f}, {0.253499f, -0.929269f, 0.268695f}, {0.416705f, 0.240580f} },
    { {-0.000565f, -0.221561f, -0.053018f}, {-0.039332f, -0.917954f, 0.394731f}, {0.416747f, 0.258537f} },
    { {-0.283332f, -0.149265f, -0.638342f}, {-0.970476f, -0.044818f, 0.236996f}, {0.342503f, 0.318506f} },
    { {-0.297092f, -0.003123f, -0.490962f}, {-0.823502f, -0.024467f, -0.566785f}, {0.361463f, 0.327900f} },
    { {-0.266295f, -0.126764f, -0.497731f}, {-0.822589f, -0.565299f, 0.061511f}, {0.360333f, 0.316319f} },
    { {-0.187823f, 0.257136f, -0.493392f}, {-0.481468f, 0.759854f, 0.436818f}, {0.362142f, 0.316135f} },
    { {-0.237407f, 0.200826f, -0.508192f}, {-0.837398f, 0.402481f, 0.369830f}, {0.360003f, 0.324015f} },
    { {-0.074869f, -0.194830f, -0.682154f}, {0.565414f, -0.812793f, 0.140269f}, {0.337334f, 0.273253f} },
    { {0.058555f, -0.102016f, -0.682162f}, {0.605211f, -0.790105f, 0.097234f}, {0.337903f, 0.249477f} },
    { {-0.090897f, -0.091728f, -0.956246f}, {-0.557548f, 0.804455f, 0.204919f}, {0.303032f, 0.280105f} },
    { {-0.186058f, -0.112643f, -0.025237f}, {-0.521761f, -0.276073f, 0.807186f}, {0.420126f, 0.301634f} },
    { {-0.092340f, -0.156881f, 0.000000f}, {-0.078030f, -0.091309f, 0.992761f}, {0.423400f, 0.280424f} },
    { {-0.162195f, -0.156213f, -0.037788f}, {-0.583819f, -0.647571f, 0.489701f}, {0.418477f, 0.294826f} },
    { {-0.076278f, 0.140271f, -0.517250f}, {-0.435129f, -0.834949f, -0.336931f}, {0.359063f, 0.288048f} },
    { {-0.094573f, 0.292271f, -0.681512f}, {0.753850f, 0.656291f, 0.031499f}, {0.338740f, 0.297733f} },
    { {-0.086197f, 0.280692f, -0.682389f}, {0.766059f, 0.526233f, 0.369096f}, {0.338616f, 0.295509f} },
    { {0.088748f, 0.213635f, -0.057201f}, {0.308539f, 0.911990f, 0.270330f}, {0.417651f, 0.258228f} },
    { {0.085463f, 0.244043f, -0.199591f}, {0.254891f, 0.965071f, 0.060572f}, {0.399778f, 0.259773f} },
    { {0.099066f, -0.112090f, -0.510745f}, {0.783997f, -0.602540f, -0.149309f}, {0.359579f, 0.241149f} },
    { {0.117428f, -0.096207f, -0.475550f}, {0.794055f, -0.575187f, -0.196562f}, {0.364104f, 0.238108f} },
    { {0.116427f, -0.090895f, -0.493256f}, {0.910090f, -0.379951f, -0.165447f}, {0.361884f, 0.238487f} },
    { {0.119287f, 0.086448f, -0.519417f}, {0.768841f, 0.607305f, -0.200159f}, {0.359092f, 0.245244f} },
    { {0.219216f, -0.130803f, -0.131569f}, {0.802289f, -0.581487f, 0.134929f}, {0.407608f, 0.216546f} },
    { {-0.110939f, -0.289771f, -0.845251f}, {0.755069f, -0.399879f, -0.519584f}, {0.316422f, 0.276288f} },
    { {-0.094418f, -0.292291f, -0.678621f}, {0.737461f, -0.675380f, 0.003603f}, {0.337460f, 0.273236f} },
    { {-0.098916f, -0.302310f, -0.800127f}, {0.774758f, -0.626343f, -0.086285f}, {0.322103f, 0.273400f} },
    { {-0.244625f, -0.169629f, -0.528409f}, {-0.776785f, -0.595470f, 0.204989f}, {0.356395f, 0.309944f} },
    { {-0.266295f, -0.126764f, -0.497731f}, {-0.857843f, -0.484958f, 0.170061f}, {0.360333f, 0.316319f} },
    { {-0.164366f, 0.280574f, -0.924125f}, {-0.569003f, 0.723200f, -0.391429f}, {0.307959f, 0.311016f} },
    { {-0.045428f, -0.071708f, -0.467055f}, {0.173919f, 0.426063f, -0.887819f}, {0.364866f, 0.272922f} },
    { {-0.133354f, 0.123084f, -1.000163f}, {-0.678128f, 0.672031f, -0.297518f}, {0.298001f, 0.297774f} },
    { {-0.080612f, 0.206280f, -0.936544f}, {-0.750624f, 0.657806f, 0.062086f}, {0.306378f, 0.290506f} },
    { {-0.066344f, 0.183910f, -0.919107f}, {-0.771902f, 0.003209f, 0.635734f}, {0.308547f, 0.286661f} },
    { {-0.187376f, -0.262309f, -0.941172f}, {-0.456905f, -0.694500f, -0.555795f}, {0.304229f, 0.293009f} },
    { {0.150369f, 0.000897f, -0.453144f}, {0.889359f, -0.065555f, -0.452486f}, {0.367278f, 0.235409f} },
    { {0.064378f, 0.136271f, -0.736941f}, {0.632762f, 0.507397f, -0.584945f}, {0.331681f, 0.258089f} },
    { {0.168841f, 0.062564f, -0.683081f}, {0.737925f, 0.431899f, -0.518584f}, {0.338506f, 0.233500f} },
    { {-0.073449f, -0.273479f, -0.608265f}, {0.719683f, -0.693696f, -0.029016f}, {0.346431f, 0.269878f} },
    { {-0.288660f, -0.066098f, -0.467843f}, {-0.884916f, -0.357023f, -0.299096f}, {0.364220f, 0.323582f} },
    { {-0.287559f, -0.087231f, -0.418772f}, {-0.367015f, -0.904303f, -0.218027f}, {0.370349f, 0.322610f} },
    { {-0.149881f, -0.221286f, -0.877532f}, {-0.774245f, -0.186973f, -0.604637f}, {0.312455f, 0.287136f} },
    { {0.082572f, -0.074891f, -0.697795f}, {0.945011f, -0.290777f, -0.149677f}, {0.336064f, 0.245589f} },
    { {0.079156f, -0.075319f, -0.795873f}, {0.787246f, 0.414680f, -0.456382f}, {0.323690f, 0.245997f} },
    { {0.053649f, -0.102568f, -0.808674f}, {0.750428f, -0.489599f, -0.444017f}, {0.321941f, 0.250108f} },
    { {0.053649f, 0.088421f, -0.809507f}, {0.709351f, 0.381145f, -0.592917f}, {0.322373f, 0.258101f} },
    { {-0.283332f, -0.149265f, -0.638342f}, {-0.869046f, -0.458677f, 0.185403f}, {0.342503f, 0.318506f} },
    { {-0.311119f, -0.105246f, -0.899364f}, {-0.665628f, -0.738214f, -0.109446f}, {0.309655f, 0.325359f} },
    { {-0.315506f, -0.097981f, -0.814408f}, {-0.765279f, -0.627169f, 0.144938f}, {0.320376f, 0.326817f} },
    { {-0.239780f, 0.100096f, -0.076736f}, {-0.349723f, 0.903404f, 0.248102f}, {0.414108f, 0.321530f} },
    { {-0.064838f, -0.015807f, -0.971281f}, {0.782646f, -0.002715f, -0.622461f}, {0.301410f, 0.277838f} },
    { {0.168645f, -0.062578f, -0.682154f}, {0.718941f, -0.460215f, -0.520889f}, {0.338270f, 0.228304f} },
    { {-0.301183f, -0.182923f, -0.857768f}, {-0.953415f, -0.136430f, -0.269047f}, {0.314704f, 0.320167f} },
    { {0.012403f, 0.028529f, -0.874357f}, {0.729095f, -0.292147f, -0.618927f}, {0.313933f, 0.263959f} },
    { {0.019909f, 0.055507f, -0.898525f}, {0.562084f, -0.633139f, -0.532162f}, {0.310980f, 0.263462f} },
    { {-0.006911f, -0.059431f, -0.898257f}, {0.704060f, 0.546418f, -0.453572f}, {0.310628f, 0.264212f} },
    { {-0.064838f, -0.015807f, -0.971281f}, {0.934857f, 0.342825f, -0.092271f}, {0.301410f, 0.277838f} },
    { {-0.019764f, -0.071392f, -0.947854f}, {0.857004f, 0.278137f, -0.433802f}, {0.304312f, 0.266233f} },
    { {0.143502f, -0.021399f, -0.474583f}, {0.930545f, -0.365956f, 0.012734f}, {0.364496f, 0.235837f} },
    { {0.193153f, -0.169557f, -0.180855f}, {0.755732f, -0.644349f, -0.116977f}, {0.401225f, 0.220185f} },
    { {-0.175642f, -0.116173f, -0.935165f}, {0.818800f, -0.570137f, 0.067161f}, {0.305425f, 0.296712f} },
    { {-0.134460f, -0.138894f, -0.998116f}, {-0.351223f, -0.803724f, -0.480281f}, {0.297520f, 0.287041f} },
    { {0.068959f, -0.159165f, -0.485596f}, {0.760266f, -0.506149f, -0.407195f}, {0.362548f, 0.245492f} },
    { {-0.336610f, -0.000319f, -0.767166f}, {-0.963207f, 0.126635f, 0.237056f}, {0.326558f, 0.335417f} },
    { {-0.119086f, 0.100714f, -0.982726f}, {-0.423177f, 0.373520f, 0.825472f}, {0.300170f, 0.293930f} },
    { {-0.174537f, 0.100913f, -0.937017f}, {0.887107f, 0.424446f, -0.181345f}, {0.305805f, 0.305566f} },
    { {0.129558f, 0.074100f, -0.476283f}, {0.950395f, 0.298770f, 0.086515f}, {0.364519f, 0.242722f} },
    { {0.068681f, 0.161295f, -0.486253f}, {0.809705f, 0.581719f, -0.077340f}, {0.363366f, 0.258965f} },
    { {-0.099022f, 0.301221f, -0.803187f}, {0.774425f, 0.626026f, -0.091417f}, {0.323415f, 0.298680f} },
    { {0.070327f, 0.154172f, -0.494126f}, {0.753174f, 0.623167f, -0.210691f}, {0.362357f, 0.258302f} },
    { {0.000045f, 0.181086f, -0.851107f}, {0.728272f, 0.683488f, 0.049628f}, {0.317265f, 0.272974f} },
    { {-0.168836f, -0.283720f, -0.911697f}, {-0.053763f, -0.908523f, -0.414360f}, {0.307928f, 0.288354f} },
    { {-0.073449f, -0.273479f, -0.608265f}, {0.458107f, -0.883316f, 0.099453f}, {0.346431f, 0.269878f} },
    { {-0.138182f, -0.280522f, -0.573702f}, {-0.064958f, -0.977181f, 0.202230f}, {0.350619f, 0.283103f} },
    { {-0.239780f, 0.100096f, -0.076736f}, {-0.674186f, 0.693383f, 0.254349f}, {0.414108f, 0.321530f} },
    { {0.082572f, 0.061898f, -0.698392f}, {0.993560f, -0.061597f, -0.095106f}, {0.336374f, 0.251314f} },
    { {0.079156f, 0.061470f, -0.796470f}, {0.688176f, -0.089806f, 0.719964f}, {0.324000f, 0.251722f} },
    { {0.047449f, 0.061478f, -0.794808f}, {0.029929f, -0.817872f, 0.574621f}, {0.324136f, 0.258301f} },
    { {0.047449f, -0.075312f, -0.794211f}, {0.049264f, 0.341702f, 0.938516f}, {0.323826f, 0.252576f} },
    { {0.117428f, -0.096207f, -0.475550f}, {0.934213f, -0.323679f, -0.149926f}, {0.364104f, 0.238108f} },
    { {0.143502f, -0.021399f, -0.474583f}, {0.995155f, 0.019896f, 0.096284f}, {0.364496f, 0.235837f} },
    { {-0.295252f, 0.063643f, -0.467933f}, {-0.583063f, 0.437697f, -0.684441f}, {0.364558f, 0.330380f} },
    { {-0.277326f, -0.103176f, -0.513368f}, {-0.937019f, -0.125249f, -0.326050f}, {0.358402f, 0.319549f} },
    { {-0.285367f, 0.034234f, -0.489707f}, {-0.267665f, 0.382492f, -0.884339f}, {0.361753f, 0.327037f} },
    { {0.051471f, -0.178218f, -0.491727f}, {0.711340f, -0.696352f, -0.095339f}, {0.361681f, 0.248303f} },
    { {0.068959f, -0.159165f, -0.485596f}, {0.743177f, -0.568704f, -0.352510f}, {0.362548f, 0.245492f} },
    { {0.070466f, -0.152673f, -0.492891f}, {0.787955f, -0.598722f, -0.143733f}, {0.361650f, 0.245431f} },
    { {-0.189910f, -0.138695f, -0.952406f}, {0.374944f, -0.638518f, -0.672096f}, {0.303155f, 0.298677f} },
    { {0.042496f, -0.021459f, -0.864444f}, {0.792147f, -0.283880f, -0.540292f}, {0.315112f, 0.255655f} },
    { {0.012403f, 0.028529f, -0.874357f}, {-0.273078f, -0.342646f, -0.898900f}, {0.313933f, 0.263959f} },
    { {0.001102f, -0.086215f, -0.916208f}, {0.704961f, -0.054854f, -0.707122f}, {0.308308f, 0.261377f} },
    { {0.015565f, -0.015366f, -0.870189f}, {0.193020f, 0.372926f, -0.907562f}, {0.314343f, 0.261477f} },
    { {-0.065011f, -0.002186f, -0.999701f}, {0.512580f, 0.263735f, -0.817132f}, {0.297865f, 0.278362f} },
    { {-0.054993f, 0.048354f, -0.987325f}, {0.808697f, 0.029090f, -0.587506f}, {0.299591f, 0.278437f} },
    { {-0.308430f, 0.086681f, -0.928340f}, {-0.232943f, 0.953365f, -0.191919f}, {0.306548f, 0.332754f} },
    { {-0.314131f, 0.097835f, -0.812849f}, {-0.824347f, 0.530940f, 0.196353f}, {0.321127f, 0.334735f} },
    { {0.014003f, 0.211140f, -0.521770f}, {0.717367f, 0.615120f, -0.327126f}, {0.358902f, 0.272285f} },
    { {-0.039611f, 0.248033f, -0.564295f}, {0.708601f, 0.597942f, -0.374633f}, {0.353520f, 0.284823f} },
    { {0.022804f, 0.201807f, -0.520019f}, {0.708601f, 0.597942f, -0.374633f}, {0.359117f, 0.270075f} },
    { {0.070327f, 0.154172f, -0.494126f}, {0.743230f, 0.566002f, -0.356724f}, {0.362357f, 0.258302f} },
    { {0.068681f, 0.161295f, -0.486253f}, {0.743230f, 0.566002f, -0.356724f}, {0.363366f, 0.258965f} },
    { {0.051241f, 0.180265f, -0.492491f}, {0.736185f, 0.606196f, -0.300928f}, {0.362593f, 0.263357f} },
    { {-0.096790f, -0.279776f, -0.642951f}, {0.104699f, -0.994482f, -0.006572f}, {0.341987f, 0.274354f} },
    { {0.050866f, -0.074884f, -0.696134f}, {-0.042524f, 0.579325f, -0.813987f}, {0.336200f, 0.252167f} },
    { {-0.148775f, 0.205570f, -0.846447f}, {-0.790197f, 0.608110f, 0.076101f}, {0.317577f, 0.304866f} },
    { {-0.197991f, 0.089366f, -0.945288f}, {-0.997450f, 0.068700f, 0.019313f}, {0.304675f, 0.309921f} },
    { {-0.188805f, 0.123284f, -0.954454f}, {-0.682572f, 0.665594f, -0.301796f}, {0.303636f, 0.309410f} },
    { {0.085932f, -0.133077f, -0.490008f}, {0.784016f, -0.595248f, -0.176066f}, {0.362104f, 0.243053f} },
    { {-0.026142f, 0.217419f, -0.759678f}, {0.731287f, 0.527950f, -0.431844f}, {0.328833f, 0.280187f} },
    { {-0.135613f, -0.198765f, -0.860290f}, {0.647981f, 0.159618f, -0.744744f}, {0.314725f, 0.285170f} },
    { {-0.148776f, 0.206526f, -0.880302f}, {-0.449942f, -0.709614f, -0.542219f}, {0.313311f, 0.304809f} },
    { {-0.134508f, 0.184155f, -0.862865f}, {0.827045f, 0.095724f, -0.553926f}, {0.315480f, 0.300965f} },
    { {-0.148776f, 0.206526f, -0.880302f}, {0.293781f, 0.795350f, -0.530199f}, {0.313311f, 0.304809f} },
    { {0.038322f, 0.036483f, -0.869945f}, {0.884960f, 0.429050f, 0.181001f}, {0.314572f, 0.258931f} },
    { {0.050866f, 0.061906f, -0.696731f}, {-0.042523f, -0.586406f, -0.808900f}, {0.336510f, 0.257892f} },
    { {0.086115f, -0.139362f, -0.479913f}, {0.776381f, -0.528640f, -0.343179f}, {0.363360f, 0.242781f} },
    { {-0.177289f, -0.266724f, -0.503205f}, {0.020912f, -0.402860f, 0.915023f}, {0.359455f, 0.291991f} },
    { {-0.252970f, -0.181216f, -0.527356f}, {-0.641754f, 0.103549f, 0.759887f}, {0.356476f, 0.311192f} },
    { {-0.179223f, -0.243226f, -0.492815f}, {-0.070185f, -0.186305f, 0.979982f}, {0.360827f, 0.293406f} },
    { {-0.138182f, -0.280522f, -0.573702f}, {0.851398f, -0.151919f, 0.502039f}, {0.350619f, 0.283103f} },
    { {-0.110939f, -0.289771f, -0.845251f}, {0.788891f, -0.504803f, -0.350465f}, {0.316422f, 0.276288f} },
    { {-0.179447f, 0.245557f, -0.494269f}, {-0.635044f, 0.688257f, 0.350744f}, {0.362018f, 0.313912f} },
    { {0.129558f, 0.074100f, -0.476283f}, {0.907836f, 0.407332f, -0.099572f}, {0.364519f, 0.242722f} },
    { {0.153242f, 0.000321f, -0.562159f}, {0.978687f, 0.145485f, 0.144932f}, {0.353539f, 0.234476f} },
    { {0.144636f, 0.000784f, -0.474740f}, {0.948712f, 0.189790f, -0.252833f}, {0.364542f, 0.236531f} },
    { {-0.318866f, -0.032603f, -0.751210f}, {-0.771415f, -0.322733f, 0.548419f}, {0.328520f, 0.330433f} },
    { {0.180343f, 0.062737f, -0.633171f}, {0.929002f, 0.301128f, -0.215122f}, {0.344825f, 0.231266f} },
    { {0.194426f, 0.000181f, -0.659919f}, {0.959052f, -0.061899f, 0.276385f}, {0.341310f, 0.225651f} },
    { {0.000352f, 0.078330f, -0.890730f}, {0.527326f, 0.836612f, 0.148351f}, {0.311981f, 0.268495f} },
    { {-0.057216f, 0.215246f, -0.929271f}, {0.090710f, 0.793339f, -0.601985f}, {0.307374f, 0.286051f} },
    { {-0.084692f, -0.022739f, -0.984314f}, {-0.650936f, -0.319277f, -0.688727f}, {0.299702f, 0.281626f} },
    { {-0.038783f, -0.084928f, -0.952941f}, {0.000775f, -0.830159f, -0.557526f}, {0.303589f, 0.269595f} },
    { {-0.059720f, -0.040260f, -0.992882f}, {0.159391f, -0.446941f, -0.880249f}, {0.298630f, 0.275691f} },
    { {-0.079070f, 0.036981f, -0.980766f}, {-0.552279f, 0.385441f, -0.739204f}, {0.300330f, 0.282971f} },
    { {-0.096790f, -0.279776f, -0.642951f}, {-0.212089f, -0.926463f, 0.310940f}, {0.341987f, 0.274354f} },
    { {-0.094418f, -0.292291f, -0.678621f}, {-0.212089f, -0.926463f, 0.310940f}, {0.337460f, 0.273236f} },
    { {0.058555f, -0.102016f, -0.682162f}, {0.714763f, -0.258287f, 0.649924f}, {0.337903f, 0.249477f} },
    { {0.058555f, 0.088973f, -0.682995f}, {0.761213f, 0.373922f, 0.529846f}, {0.338336f, 0.257471f} },
    { {-0.056982f, -0.230438f, -0.927518f}, {0.046792f, -0.631444f, -0.774009f}, {0.306342f, 0.267349f} },
    { {0.000352f, -0.082072f, -0.890030f}, {0.543057f, -0.780559f, 0.309542f}, {0.311618f, 0.261782f} },
    { {0.027138f, -0.022148f, -0.848868f}, {0.703844f, -0.191319f, 0.684106f}, {0.317038f, 0.258855f} },
    { {-0.197991f, -0.104702f, -0.944441f}, {-0.901798f, -0.002802f, 0.432149f}, {0.304236f, 0.301799f} },
    { {0.022804f, 0.201807f, -0.520019f}, {0.727254f, 0.638630f, -0.251502f}, {0.359117f, 0.270075f} },
    { {0.070466f, -0.152673f, -0.492891f}, {0.757908f, -0.551929f, -0.347778f}, {0.361650f, 0.245431f} },
    { {0.086115f, -0.139362f, -0.479913f}, {0.757908f, -0.551929f, -0.347778f}, {0.363360f, 0.242781f} },
    { {0.085932f, -0.133077f, -0.490008f}, {0.758742f, -0.546726f, -0.354120f}, {0.362104f, 0.243053f} },
    { {0.068959f, -0.159165f, -0.485596f}, {0.756851f, -0.558060f, -0.340214f}, {0.362548f, 0.245492f} },
    { {-0.339677f, 0.058648f, -0.937757f}, {-0.960994f, 0.110365f, -0.253593f}, {0.305210f, 0.338031f} },
    { {-0.325925f, 0.078992f, -0.939183f}, {-0.417730f, 0.754133f, -0.506740f}, {0.305119f, 0.336028f} },
    { {-0.038783f, 0.080638f, -0.953663f}, {-0.139809f, 0.888664f, -0.436725f}, {0.303963f, 0.276524f} },
    { {-0.186058f, -0.112643f, -0.025237f}, {-0.672625f, -0.623058f, 0.399217f}, {0.420126f, 0.301634f} },
    { {-0.168935f, 0.281539f, -0.914452f}, {-0.299780f, 0.924916f, -0.233800f}, {0.309171f, 0.312031f} },
    { {-0.228263f, 0.231721f, -0.921502f}, {-0.578612f, 0.738161f, -0.346880f}, {0.308004f, 0.322225f} },
    { {-0.096790f, -0.279776f, -0.642951f}, {0.534785f, -0.785601f, 0.311186f}, {0.341987f, 0.274354f} },
    { {-0.094418f, -0.292291f, -0.678621f}, {0.534785f, -0.785601f, 0.311186f}, {0.337460f, 0.273236f} },
    { {-0.138182f, -0.280522f, -0.573702f}, {0.534785f, -0.785601f, 0.311186f}, {0.350619f, 0.283103f} },
    { {-0.299008f, -0.151060f, -0.710175f}, {-0.811158f, 0.574010f, -0.111960f}, {0.333406f, 0.321474f} },
    { {-0.301183f, -0.182923f, -0.857768f}, {-0.811158f, 0.574010f, -0.111960f}, {0.314704f, 0.320167f} },
    { {-0.292838f, -0.171336f, -0.858821f}, {-0.811158f, 0.574010f, -0.111960f}, {0.314623f, 0.318919f} },
    { {-0.301183f, -0.182923f, -0.857768f}, {-0.494743f, 0.281596f, -0.822152f}, {0.314704f, 0.320167f} },
    { {-0.318896f, 0.032339f, -0.751519f}, {-0.855752f, 0.246124f, 0.455095f}, {0.328663f, 0.333157f} },
    { {-0.111010f, 0.288276f, -0.848110f}, {0.788831f, 0.501672f, -0.355065f}, {0.317687f, 0.300495f} },
    { {-0.244625f, -0.169629f, -0.528409f}, {-0.553153f, 0.461408f, 0.693631f}, {0.356395f, 0.309944f} },
    { {-0.283332f, -0.149265f, -0.638342f}, {-0.739388f, 0.565678f, 0.365122f}, {0.342503f, 0.318506f} },
    { {-0.179447f, 0.245557f, -0.494269f}, {0.465415f, -0.056981f, 0.883257f}, {0.362018f, 0.313912f} },
    { {-0.153827f, 0.290312f, -0.558821f}, {0.722165f, 0.485090f, 0.493119f}, {0.354065f, 0.310288f} },
    { {-0.237407f, 0.200826f, -0.508192f}, {0.147274f, -0.462896f, 0.874093f}, {0.360003f, 0.324015f} },
    { {-0.187823f, 0.257136f, -0.493392f}, {0.354576f, 0.187144f, 0.916107f}, {0.362142f, 0.316135f} },
    { {-0.313166f, 0.059401f, -0.940323f}, {0.398748f, 0.309901f, -0.863111f}, {0.304950f, 0.332559f} },
    { {-0.197991f, 0.089366f, -0.945288f}, {-0.253222f, 0.915994f, -0.311182f}, {0.304675f, 0.309921f} },
    { {-0.209637f, 0.077956f, -0.969399f}, {-0.253222f, 0.915994f, -0.311182f}, {0.301576f, 0.311788f} },
    { {-0.120570f, 0.089088f, -1.009109f}, {-0.253222f, 0.915994f, -0.311182f}, {0.296808f, 0.293675f} },
    { {0.023298f, 0.037530f, -0.854899f}, {0.652741f, 0.433000f, 0.621642f}, {0.316437f, 0.262133f} },
    { {-0.244751f, 0.171533f, -0.529133f}, {0.287257f, -0.603684f, 0.743672f}, {0.357263f, 0.324251f} },
    { {-0.314121f, -0.063663f, -0.939642f}, {0.599979f, -0.533832f, -0.595860f}, {0.304687f, 0.327607f} },
    { {-0.327872f, -0.080690f, -0.938233f}, {-0.310202f, -0.858388f, -0.408588f}, {0.304785f, 0.329749f} },
    { {-0.277007f, 0.091821f, -0.434097f}, {-0.263622f, 0.922982f, -0.280371f}, {0.368945f, 0.327875f} },
    { {0.056102f, -0.102292f, -0.745402f}, {-0.050209f, -0.998719f, 0.006305f}, {0.329924f, 0.249793f} },
    { {-0.073385f, 0.273931f, -0.610752f}, {0.199886f, 0.978185f, 0.056573f}, {0.347658f, 0.292776f} },
    { {-0.100669f, 0.282022f, -0.654248f}, {0.199886f, 0.978185f, 0.056573f}, {0.342134f, 0.298646f} },
    { {-0.086197f, 0.280692f, -0.682389f}, {0.199886f, 0.978185f, 0.056573f}, {0.338616f, 0.295509f} },
    { {-0.274284f, 0.185943f, -0.890154f}, {-0.805437f, 0.570915f, -0.159146f}, {0.311721f, 0.329940f} },
    { {-0.325925f, 0.078992f, -0.939183f}, {0.158173f, -0.175037f, -0.971773f}, {0.305119f, 0.336028f} },
    { {-0.339677f, 0.058648f, -0.937757f}, {0.158173f, -0.175037f, -0.971773f}, {0.305210f, 0.338031f} },
    { {-0.347887f, -0.062072f, -0.917349f}, {0.158173f, -0.175037f, -0.971773f}, {0.307424f, 0.334738f} },
    { {-0.325925f, 0.078992f, -0.939183f}, {-0.719889f, 0.004650f, -0.694073f}, {0.305119f, 0.336028f} },
    { {-0.347887f, -0.062072f, -0.917349f}, {-0.719889f, 0.004650f, -0.694073f}, {0.307424f, 0.334738f} },
    { {-0.327872f, -0.080690f, -0.938233f}, {-0.719889f, 0.004650f, -0.694073f}, {0.304785f, 0.329749f} },
    { {-0.325925f, 0.078992f, -0.939183f}, {-0.096124f, -0.004751f, -0.995358f}, {0.305119f, 0.336028f} },
    { {-0.327872f, -0.080690f, -0.938233f}, {-0.096124f, -0.004751f, -0.995358f}, {0.304785f, 0.329749f} },
    { {-0.314121f, -0.063663f, -0.939642f}, {-0.096124f, -0.004751f, -0.995358f}, {0.304687f, 0.327607f} },
    { {-0.313166f, 0.059401f, -0.940323f}, {-0.096241f, -0.004760f, -0.995347f}, {0.304950f, 0.332559f} },
};

WORD g_tind1[] = 
{
    2, 1, 0,    5, 4, 3,    8, 7, 6,    11, 10, 9,    14, 13, 12,
    15, 5, 3,    18, 17, 16,    21, 20, 19,    24, 23, 22,    27, 26, 25,
    30, 29, 28,    33, 32, 31,    35, 34, 19,    38, 37, 36,    41, 40, 39,
    2, 0, 12,    44, 43, 42,    47, 46, 45,    50, 49, 48,    53, 52, 51,
    55, 10, 54,    57, 56, 25,    58, 30, 28,    35, 59, 34,    61, 60, 24,
    62, 20, 21,    41, 64, 63,    66, 65, 32,    69, 68, 67,    72, 71, 70,
    72, 74, 73,    47, 75, 46,    78, 77, 76,    81, 80, 79,    84, 83, 82,
    62, 85, 20,    87, 86, 38,    90, 89, 88,    93, 92, 91,    96, 95, 94,
    99, 98, 97,    100, 2, 12,    102, 101, 70,    104, 103, 3,    106, 23, 105,
    73, 71, 72,    107, 32, 65,    108, 56, 107,    111, 110, 109,    68, 112, 67,
    115, 114, 113,    117, 116, 62,    95, 118, 94,    119, 118, 73,    122, 121, 120,
    79, 80, 123,    47, 125, 124,    127, 126, 96,    130, 129, 128,    132, 131, 91,
    9, 134, 133,    137, 136, 135,    138, 56, 108,    129, 1, 128,    139, 35, 19,
    141, 136, 140,    15, 3, 142,    116, 144, 143,    145, 116, 143,    148, 147, 146,
    88, 89, 149,    152, 151, 150,    118, 119, 94,    97, 154, 153,    154, 25, 155,
    53, 156, 52,    159, 158, 157,    43, 70, 42,    55, 54, 160,    160, 8, 6,
    162, 161, 26,    165, 164, 163,    168, 167, 166,    167, 168, 169,    172, 171, 170,
    134, 9, 173,    28, 175, 174,    178, 177, 176,    45, 46, 82,    181, 180, 179,
    184, 183, 182,    185, 49, 50,    60, 186, 24,    188, 187, 102,    191, 190, 189,
    130, 128, 192,    18, 144, 17,    195, 194, 193,    196, 178, 176,    58, 198, 197,
    200, 66, 199,    16, 17, 201,    204, 203, 202,    70, 206, 205,    208, 153, 207,
    24, 22, 61,    64, 41, 209,    90, 211, 210,    10, 213, 212,    62, 116, 145,
    134, 173, 37,    37, 215, 214,    86, 87, 59,    82, 83, 216,    165, 217, 104,
    50, 48, 217,    93, 91, 218,    219, 88, 218,    221, 220, 103,    111, 109, 222,
    77, 222, 76,    102, 187, 101,    156, 223, 52,    52, 225, 224,    168, 166, 226,
    228, 226, 227,    2, 100, 229,    230, 207, 155,    231, 40, 132,    232, 29, 30,
    17, 233, 192,    233, 130, 192,    84, 80, 81,    32, 199, 66,    112, 235, 234,
    149, 92, 93,    237, 236, 126,    238, 227, 167,    227, 238, 228,    230, 155, 1,
    241, 240, 239,    137, 140, 136,    37, 38, 242,    47, 243, 125,    244, 195, 193,
    3, 4, 33,    246, 161, 245,    75, 47, 124,    249, 248, 247,    160, 54, 8,
    250, 221, 103,    56, 57, 107,    161, 31, 26,    12, 13, 100,    153, 208, 251,
    19, 252, 21,    254, 122, 253,    200, 16, 66,    7, 16, 6,    129, 130, 255,
    256, 255, 130,    171, 257, 170,    156, 53, 159,    86, 59, 35,    141, 258, 136,
    261, 260, 259,    240, 56, 239,    240, 25, 56,    62, 262, 117,    64, 209, 211,
    10, 85, 62,    62, 213, 10,    24, 186, 263,    264, 47, 216,    83, 265, 216,
    122, 266, 253,    267, 29, 232,    268, 28, 29,    180, 181, 269,    272, 271, 270,
    271, 272, 273,    106, 105, 27,    165, 245, 164,    256, 274, 255,    17, 274, 256,
    276, 114, 275,    226, 228, 168,    277, 58, 196,    58, 28, 196,    150, 278, 152,
    74, 119, 73,    122, 279, 121,    279, 81, 79,    120, 121, 123,    41, 63, 40,
    218, 91, 131,    209, 41, 280,    41, 39, 280,    152, 282, 281,    206, 70, 43,
    153, 99, 97,    99, 153, 251,    197, 30, 58,    16, 201, 66,    285, 284, 283,
    94, 44, 42,    84, 286, 80,    14, 61, 13,    61, 22, 287,    289, 179, 288,
    179, 289, 181,    158, 222, 77,    77, 157, 158,    33, 246, 3,    104, 3, 246,
    61, 290, 60,    7, 18, 16,    113, 291, 115,    33, 4, 32,    222, 234, 111,
    28, 178, 196,    178, 28, 174,    259, 293, 292,    259, 292, 261,    250, 295, 294,
    110, 78, 76,    47, 296, 243,    51, 52, 67,    67, 52, 224,    96, 126, 95,
    181, 182, 183,    103, 297, 250,    295, 250, 297,    217, 23, 50,    23, 163, 105,
    211, 219, 64,    64, 219, 63,    71, 188, 102,    71, 298, 70,    262, 299, 117,
    299, 21, 252,    300, 14, 12,    301, 12, 0,    142, 3, 103,    37, 173, 215,
    173, 55, 215,    241, 239, 128,    178, 174, 177,    107, 65, 302,    198, 58, 277,
    167, 169, 238,    305, 304, 303,    304, 305, 306,    258, 139, 136,    136, 20, 135,
    308, 307, 249,    30, 197, 309,    30, 309, 232,    232, 311, 310,    267, 232, 310,
    137, 135, 133,    11, 9, 133,    314, 313, 312,    31, 32, 107,    31, 107, 57,
    315, 167, 289,    167, 315, 269,    159, 53, 158,    53, 51, 158,    42, 127, 96,
    42, 96, 94,    317, 203, 316,    319, 316, 318,    284, 285, 320,    284, 320, 321,
    115, 323, 322,    115, 291, 323,    23, 24, 50,    24, 185, 50,    326, 325, 324,
    48, 49, 103,    329, 328, 327,    222, 158, 51,    51, 67, 222,    321, 202, 284,
    202, 321, 204,    300, 12, 330,    26, 57, 25,    26, 31, 57,    331, 270, 271,
    331, 303, 270,    334, 333, 332,    333, 334, 259,    13, 61, 287,    13, 287, 208,
    283, 318, 285,    318, 283, 319,    314, 312, 247,    247, 248, 335,    37, 336, 36,
    37, 214, 336,    213, 62, 145,    207, 154, 155,    153, 154, 207,    337, 269, 315,
    269, 337, 180,    189, 338, 191,    340, 339, 293,    203, 204, 341,    341, 316, 203,
    146, 19, 34,    19, 146, 252,    242, 140, 137,    134, 137, 133,    149, 93, 88,
    218, 88, 93,    303, 342, 305,    303, 331, 342,    76, 109, 110,    76, 222, 109,
    335, 248, 343,    346, 345, 344,    346, 344, 347,    348, 122, 254,    89, 90, 210,
    349, 199, 32,    349, 32, 4,    84, 82, 350,    294, 308, 351,    219, 218, 63,
    63, 218, 40,    263, 352, 185,    185, 24, 263,    162, 26, 27,    105, 162, 27,
    268, 174, 175,    28, 268, 175,    247, 335, 314,    97, 98, 106,    25, 106, 27,
    18, 143, 144,    291, 113, 353,    59, 87, 354,    355, 83, 84,    205, 72, 70,
    356, 341, 204,    259, 226, 333,    226, 259, 357,    360, 359, 358,    320, 358, 361,
    67, 224, 69,    6, 16, 200,    20, 85, 135,    85, 10, 11,    222, 112, 234,
    222, 67, 112,    230, 2, 229,    1, 2, 230,    86, 141, 38,    86, 35, 141,
    155, 240, 1,    240, 155, 25,    40, 218, 131,    132, 40, 131,    288, 315, 289,
    315, 288, 337,    363, 147, 362,    303, 365, 364,    303, 273, 365,    141, 35, 258,
    35, 139, 258,    48, 103, 104,    48, 104, 217,    364, 270, 303,    270, 364, 272,
    293, 334, 340,    293, 259, 334,    290, 343, 60,    343, 186, 60,    33, 161, 246,
    33, 31, 161,    289, 227, 366,    289, 167, 227,    316, 368, 367,    368, 316, 341,
    167, 369, 333,    369, 167, 183,    370, 324, 329,    290, 61, 14,    373, 372, 371,
    372, 374, 371,    269, 183, 167,    183, 269, 181,    10, 212, 54,    115, 375, 114,
    376, 375, 115,    217, 165, 163,    163, 23, 217,    340, 332, 357,    332, 340, 334,
    377, 204, 321,    204, 377, 356,    271, 306, 331,    306, 271, 304,    100, 208, 229,
    100, 13, 208,    23, 98, 22,    98, 23, 106,    285, 318, 359,    285, 359, 360,
    378, 177, 174,    138, 239, 56,    165, 246, 245,    246, 165, 104,    311, 309, 197,
    311, 232, 309,    1, 241, 128,    241, 1, 240,    22, 251, 287,    208, 287, 251,
    260, 357, 259,    357, 260, 340,    265, 264, 216,    38, 36, 87,    45, 82, 216,
    216, 47, 45,    302, 108, 107,    196, 176, 277,    367, 318, 316,    318, 367, 359,
    273, 304, 271,    273, 303, 304,    90, 88, 219,    90, 219, 211,    182, 181, 366,
    366, 181, 289,    214, 215, 379,    215, 380, 379,    186, 308, 263,    37, 242, 134,
    242, 137, 134,    301, 330, 12,    383, 382, 381,    386, 385, 384,    116, 117, 387,
    323, 291, 388,    291, 353, 388,    55, 173, 9,    10, 55, 9,    77, 78, 157,
    47, 389, 296,    262, 62, 21,    21, 299, 262,    164, 105, 163,    164, 162, 105,
    345, 346, 390,    345, 390, 391,    121, 79, 123,    279, 79, 121,    355, 81, 279,
    355, 84, 81,    393, 392, 194,    194, 195, 393,    392, 395, 394,    392, 393, 395,
    229, 208, 207,    229, 207, 230,    148, 312, 147,    247, 312, 148,    322, 396, 376,
    322, 376, 115,    333, 166, 167,    399, 398, 397,    341, 356, 400,    341, 400, 368,
    361, 321, 320,    321, 361, 377,    112, 68, 235,    394, 401, 392,    403, 402, 275,
    114, 403, 275,    0, 1, 129,    0, 129, 255,    276, 353, 113,    113, 114, 276,
    40, 231, 39,    144, 274, 17,    19, 20, 139,    139, 20, 136,    141, 140, 38,
    38, 140, 242,    404, 197, 198,    197, 404, 311,    98, 99, 22,    22, 99, 251,
    281, 151, 152,    316, 319, 317,    245, 161, 162,    164, 245, 162,    267, 310, 268,
    267, 268, 29,    405, 272, 364,    127, 237, 126,    11, 133, 135,    85, 11, 135,
    408, 407, 406,    97, 106, 25,    25, 154, 97,    298, 102, 70,    71, 102, 298,
    223, 225, 52,    409, 55, 160,    360, 320, 285,    358, 320, 360,    412, 411, 410,
    415, 414, 413,    418, 417, 416,    419, 418, 416,
};

D3DMATRIX g_tmat2 = 
{
    -0.690816f, -0.082855f, 0.718268f, 0.000000f, 
    -0.623065f, -0.435789f, -0.649521f, 0.000000f, 
    0.366829f, -0.896228f, 0.249426f, 0.000000f, 
    2.848442f, -2.911283f, 2.227438f, 1.000000f, 
};

// Mesh #2 Tris:86 Verts:117
MODELVERT g_tmesh2[] = 
{
    { {-0.048231f, 0.150767f, -0.161141f}, {-0.995966f, 0.065354f, -0.061480f}, {0.334194f, 0.232142f} },
    { {-0.048231f, 0.219470f, -0.018737f}, {-0.979462f, 0.151365f, 0.133199f}, {0.303841f, 0.321623f} },
    { {-0.061755f, 0.013359f, -0.018737f}, {-0.998084f, 0.019425f, 0.058739f}, {0.394898f, 0.321623f} },
    { {0.076964f, 0.155822f, -0.162275f}, {0.991117f, 0.044735f, -0.125243f}, {0.388196f, 0.231429f} },
    { {0.069884f, 0.012708f, -0.016901f}, {0.962641f, -0.206570f, 0.175076f}, {0.324971f, 0.322777f} },
    { {0.076977f, 0.155601f, -0.017293f}, {0.986528f, 0.049433f, 0.155946f}, {0.388099f, 0.322531f} },
    { {-0.061755f, 0.013359f, -0.161141f}, {-0.978362f, -0.100482f, -0.180861f}, {0.394898f, 0.232142f} },
    { {0.070469f, 0.014308f, -0.161727f}, {0.961065f, -0.235191f, -0.145051f}, {0.325678f, 0.231774f} },
    { {0.029492f, 0.238208f, -0.161141f}, {0.143656f, 0.986975f, -0.072410f}, {0.337435f, 0.232142f} },
    { {-0.029493f, 0.238208f, -0.018737f}, {-0.142485f, 0.987408f, 0.068724f}, {0.393777f, 0.321623f} },
    { {-0.029493f, 0.238208f, -0.161141f}, {-0.325926f, 0.933930f, -0.146787f}, {0.393777f, 0.232142f} },
    { {0.007858f, 0.151002f, -0.179758f}, {-0.265223f, 0.047282f, -0.963027f}, {0.362592f, 0.302624f} },
    { {-0.029493f, 0.219470f, -0.179879f}, {-0.283177f, 0.068813f, -0.956596f}, {0.393777f, 0.332293f} },
    { {-0.006763f, 0.013360f, -0.179879f}, {-0.091471f, -0.105317f, -0.990223f}, {0.372065f, 0.242616f} },
    { {-0.043018f, 0.013359f, -0.179879f}, {-0.321952f, -0.059376f, -0.944892f}, {0.406695f, 0.242616f} },
    { {-0.043018f, -0.005378f, -0.161141f}, {-0.137791f, -0.987004f, -0.082680f}, {0.313461f, 0.232142f} },
    { {0.040554f, -0.006684f, -0.016344f}, {0.079004f, -0.991538f, 0.103012f}, {0.382721f, 0.321623f} },
    { {0.036022f, -0.009814f, -0.164977f}, {0.248503f, -0.961097f, -0.120576f}, {0.382721f, 0.232142f} },
    { {-0.043018f, -0.005378f, -0.018737f}, {-0.285845f, -0.949802f, 0.127157f}, {0.313461f, 0.321623f} },
    { {-0.043018f, 0.013359f, 0.000000f}, {-0.340387f, -0.022118f, 0.940025f}, {0.313461f, 0.242616f} },
    { {-0.029493f, 0.219470f, 0.000000f}, {-0.214532f, 0.142942f, 0.966201f}, {0.326380f, 0.332293f} },
    { {0.007857f, 0.151002f, 0.000121f}, {-0.073126f, 0.020361f, 0.997115f}, {0.357565f, 0.302624f} },
    { {0.029492f, 0.238208f, -0.018737f}, {0.303608f, 0.943568f, 0.132293f}, {0.337435f, 0.321623f} },
    { {0.029492f, 0.219470f, 0.000000f}, {0.075160f, 0.355281f, 0.931733f}, {0.382721f, 0.332293f} },
    { {0.004562f, 0.015324f, 0.011255f}, {-0.106600f, -0.033539f, 0.993736f}, {0.358908f, 0.243471f} },
    { {0.047223f, 0.215465f, 0.006962f}, {0.325074f, 0.058733f, 0.943863f}, {0.399657f, 0.330550f} },
    { {0.044351f, 0.014199f, 0.010476f}, {0.389880f, -0.107649f, 0.914552f}, {0.396914f, 0.242981f} },
    { {-0.043018f, -0.005378f, -0.018737f}, {-0.285845f, -0.949802f, 0.127157f}, {0.313461f, 0.234464f} },
    { {-0.006763f, 0.013359f, 0.000000f}, {-0.009123f, -0.284679f, 0.958580f}, {0.348091f, 0.242616f} },
    { {0.040554f, -0.006684f, -0.016344f}, {0.079004f, -0.991538f, 0.103012f}, {0.382721f, 0.234464f} },
    { {0.044321f, 0.015142f, -0.190224f}, {0.410873f, -0.107494f, -0.905333f}, {0.326046f, 0.213867f} },
    { {0.052044f, 0.155416f, -0.189759f}, {0.422483f, 0.081365f, -0.902711f}, {0.388017f, 0.214159f} },
    { {0.037350f, 0.185354f, -0.179758f}, {0.041561f, 0.145399f, -0.988500f}, {0.334421f, 0.317570f} },
    { {0.029492f, 0.219470f, -0.179879f}, {0.143266f, 0.442417f, -0.885292f}, {0.337436f, 0.332293f} },
    { {-0.056530f, 0.009535f, -0.152260f}, {-0.976008f, 0.022787f, -0.216539f}, {0.396587f, 0.237722f} },
    { {-0.030164f, -0.053857f, -0.026749f}, {-0.675225f, -0.682567f, 0.279596f}, {0.424593f, 0.316589f} },
    { {-0.030164f, -0.053857f, -0.152260f}, {-0.320831f, -0.905176f, -0.278792f}, {0.424593f, 0.237722f} },
    { {0.038382f, -0.049965f, -0.152260f}, {0.747916f, -0.602409f, -0.278792f}, {0.297283f, 0.237722f} },
    { {0.057402f, 0.016005f, -0.026749f}, {0.966868f, 0.134285f, 0.217104f}, {0.326427f, 0.316589f} },
    { {0.057402f, 0.016005f, -0.152260f}, {0.270247f, 0.931382f, -0.243916f}, {0.326427f, 0.237722f} },
    { {0.038382f, -0.049965f, -0.026749f}, {0.420534f, -0.863121f, 0.279596f}, {0.297283f, 0.316589f} },
    { {-0.056531f, 0.009535f, -0.026749f}, {-0.370910f, 0.896064f, 0.243916f}, {0.396587f, 0.316589f} },
    { {0.044321f, 0.015142f, -0.190224f}, {0.410873f, -0.107494f, -0.905333f}, {0.323272f, 0.243392f} },
    { {0.014733f, 0.150587f, -0.190893f}, {-0.129359f, 0.062892f, -0.989601f}, {0.357703f, 0.274128f} },
    { {0.004591f, 0.014434f, -0.190665f}, {-0.310749f, -0.080017f, -0.947118f}, {0.361220f, 0.243083f} },
    { {-0.043018f, -0.005378f, -0.161141f}, {-0.137791f, -0.987004f, -0.082680f}, {0.406695f, 0.234464f} },
    { {0.036022f, -0.009814f, -0.164977f}, {0.248503f, -0.961097f, -0.120576f}, {0.337436f, 0.234464f} },
    { {0.036022f, -0.009814f, -0.164977f}, {0.248503f, -0.961097f, -0.120576f}, {0.315021f, 0.229731f} },
    { {0.040554f, -0.006684f, -0.016344f}, {0.079004f, -0.991538f, 0.103012f}, {0.316404f, 0.323127f} },
    { {0.040554f, -0.006684f, -0.016344f}, {0.079004f, -0.991538f, 0.103012f}, {0.393288f, 0.233895f} },
    { {0.001363f, -0.003565f, -0.163563f}, {0.030680f, 0.915610f, -0.400895f}, {0.364303f, 0.235252f} },
    { {-0.056530f, 0.009535f, -0.152260f}, {-0.976008f, 0.022787f, -0.216539f}, {0.402488f, 0.239188f} },
    { {-0.030164f, -0.053857f, -0.152260f}, {-0.320831f, -0.905176f, -0.278792f}, {0.394418f, 0.213371f} },
    { {0.001363f, -0.003565f, -0.163563f}, {0.030680f, 0.915610f, -0.400895f}, {0.364303f, 0.230620f} },
    { {-0.056531f, 0.009535f, -0.026749f}, {-0.370910f, 0.896064f, 0.243916f}, {0.419603f, 0.316589f} },
    { {-0.056530f, 0.009535f, -0.152260f}, {-0.976008f, 0.022787f, -0.216539f}, {0.419602f, 0.237722f} },
    { {0.038382f, -0.049965f, -0.026749f}, {0.420534f, -0.863121f, 0.279596f}, {0.391213f, 0.215064f} },
    { {0.001363f, -0.003565f, -0.016099f}, {-0.133937f, 0.906763f, 0.399802f}, {0.355853f, 0.235252f} },
    { {0.057402f, 0.016005f, -0.026749f}, {0.966868f, 0.134285f, 0.217104f}, {0.392814f, 0.241132f} },
    { {0.057402f, 0.016005f, -0.152260f}, {0.270247f, 0.931382f, -0.243916f}, {0.310776f, 0.237722f} },
    { {0.057402f, 0.016005f, -0.026749f}, {0.966868f, 0.134285f, 0.217104f}, {0.310776f, 0.316589f} },
    { {0.001363f, -0.003565f, -0.016099f}, {-0.133937f, 0.906763f, 0.399802f}, {0.364303f, 0.323281f} },
    { {0.038382f, -0.049965f, -0.152260f}, {0.747916f, -0.602409f, -0.278792f}, {0.328944f, 0.215064f} },
    { {-0.030164f, -0.053857f, -0.152260f}, {-0.320831f, -0.905176f, -0.278792f}, {0.325738f, 0.237722f} },
    { {0.038382f, -0.049965f, -0.026749f}, {0.420534f, -0.863121f, 0.279596f}, {0.391213f, 0.316589f} },
    { {0.038382f, -0.049965f, -0.152260f}, {0.747916f, -0.602409f, -0.278792f}, {0.391213f, 0.237722f} },
    { {-0.030164f, -0.053857f, -0.026749f}, {-0.675225f, -0.682567f, 0.279596f}, {0.325738f, 0.213371f} },
    { {-0.030164f, -0.053857f, -0.026749f}, {-0.675225f, -0.682567f, 0.279596f}, {0.325738f, 0.316589f} },
    { {0.007857f, 0.151002f, 0.000121f}, {-0.088768f, 0.025550f, 0.995725f}, {0.368596f, 0.302326f} },
    { {0.052044f, 0.155416f, -0.189759f}, {0.422483f, 0.081365f, -0.902711f}, {0.315895f, 0.304423f} },
    { {0.014733f, 0.150587f, -0.190893f}, {-0.129359f, 0.062892f, -0.989601f}, {0.351533f, 0.302322f} },
    { {0.059797f, 0.217123f, -0.017889f}, {0.901064f, 0.429898f, 0.057197f}, {0.415278f, 0.322156f} },
    { {0.059621f, 0.217453f, -0.162832f}, {0.795861f, 0.574656f, -0.190724f}, {0.415424f, 0.231079f} },
    { {0.036022f, -0.009814f, -0.164977f}, {0.248503f, -0.961097f, -0.120576f}, {0.331199f, 0.232534f} },
    { {-0.043018f, -0.005378f, -0.018737f}, {-0.285845f, -0.949802f, 0.127157f}, {0.403176f, 0.321623f} },
    { {-0.043018f, 0.013359f, 0.000000f}, {-0.340387f, -0.022118f, 0.940025f}, {0.394898f, 0.333397f} },
    { {0.044351f, 0.014199f, 0.010476f}, {0.389880f, -0.107649f, 0.914552f}, {0.325629f, 0.339979f} },
    { {0.047223f, 0.215465f, 0.006962f}, {0.325074f, 0.058733f, 0.943863f}, {0.414546f, 0.337772f} },
    { {0.059621f, 0.217453f, -0.162832f}, {0.795861f, 0.574656f, -0.190724f}, {0.416315f, 0.232142f} },
    { {0.059797f, 0.217123f, -0.017889f}, {0.901064f, 0.429898f, 0.057197f}, {0.416315f, 0.321623f} },
    { {0.029492f, 0.238208f, -0.018737f}, {0.303608f, 0.943568f, 0.132293f}, {0.424593f, 0.321623f} },
    { {0.057402f, 0.016005f, -0.152260f}, {0.270247f, 0.931382f, -0.243916f}, {0.327342f, 0.241132f} },
    { {-0.043018f, -0.005378f, -0.161141f}, {-0.137791f, -0.987004f, -0.082680f}, {0.403176f, 0.232142f} },
    { {-0.029493f, 0.219470f, -0.179879f}, {-0.283177f, 0.068813f, -0.956596f}, {0.303841f, 0.220368f} },
    { {-0.043018f, 0.013359f, -0.179879f}, {-0.321952f, -0.059376f, -0.944892f}, {0.394898f, 0.220368f} },
    { {-0.056531f, 0.009535f, -0.026749f}, {-0.370910f, 0.896064f, 0.243916f}, {0.300554f, 0.240952f} },
    { {-0.029493f, 0.238208f, -0.161141f}, {-0.325926f, 0.933930f, -0.146787f}, {0.295564f, 0.232142f} },
    { {-0.029493f, 0.238208f, -0.018737f}, {-0.142485f, 0.987408f, 0.068724f}, {0.295564f, 0.321623f} },
    { {-0.029493f, 0.219470f, 0.000000f}, {-0.214532f, 0.142942f, 0.966201f}, {0.303841f, 0.333397f} },
    { {0.037350f, 0.185354f, -0.179758f}, {0.041561f, 0.145399f, -0.988500f}, {0.329930f, 0.317449f} },
    { {0.037350f, 0.185354f, -0.179758f}, {0.041561f, 0.145399f, -0.988500f}, {0.401605f, 0.216678f} },
    { {-0.048231f, 0.219470f, -0.161141f}, {-0.971543f, 0.208189f, -0.112970f}, {0.303841f, 0.232142f} },
    { {0.037350f, 0.185354f, -0.179758f}, {0.041561f, 0.145399f, -0.988500f}, {0.401365f, 0.220368f} },
    { {0.029492f, 0.219470f, -0.179879f}, {0.143266f, 0.442417f, -0.885292f}, {0.416315f, 0.220368f} },
    { {0.029492f, 0.238208f, -0.161141f}, {0.143656f, 0.986975f, -0.072410f}, {0.424593f, 0.232142f} },
    { {0.004591f, 0.014434f, -0.190665f}, {-0.310749f, -0.080017f, -0.947118f}, {0.394423f, 0.213590f} },
    { {0.014733f, 0.150587f, -0.190893f}, {-0.129359f, 0.062892f, -0.989601f}, {0.334273f, 0.213446f} },
    { {0.007858f, 0.151002f, -0.179758f}, {-0.265223f, 0.047282f, -0.963027f}, {0.334090f, 0.220443f} },
    { {0.037350f, 0.185354f, -0.179758f}, {0.041561f, 0.145399f, -0.988500f}, {0.318914f, 0.220443f} },
    { {0.029492f, 0.238208f, -0.018737f}, {0.303608f, 0.943568f, 0.132293f}, {0.382721f, 0.340445f} },
    { {0.029492f, 0.219470f, 0.000000f}, {0.075160f, 0.355281f, 0.931733f}, {0.416315f, 0.333397f} },
    { {-0.029493f, 0.238208f, -0.018737f}, {-0.142485f, 0.987408f, 0.068724f}, {0.326380f, 0.340445f} },
    { {-0.029493f, 0.238208f, -0.161141f}, {-0.325926f, 0.933930f, -0.146787f}, {0.393777f, 0.340445f} },
    { {0.007857f, 0.151002f, 0.000121f}, {-0.709423f, 0.074742f, 0.700809f}, {0.362056f, 0.302503f} },
    { {0.004562f, 0.015324f, 0.011255f}, {-0.669844f, -0.213159f, 0.711247f}, {0.352583f, 0.242495f} },
    { {-0.006763f, 0.013359f, 0.000000f}, {-0.669844f, -0.213159f, 0.711247f}, {0.348091f, 0.242616f} },
    { {0.040554f, -0.006684f, -0.016344f}, {-0.239083f, -0.886844f, 0.395408f}, {0.387213f, 0.234343f} },
    { {0.029492f, 0.238208f, -0.161141f}, {0.143656f, 0.986975f, -0.072410f}, {0.337435f, 0.340445f} },
    { {0.007857f, 0.151002f, 0.000121f}, {-0.312161f, 0.090258f, 0.945732f}, {0.362056f, 0.302503f} },
    { {0.029492f, 0.219470f, 0.000000f}, {-0.244542f, 0.428953f, 0.869597f}, {0.387213f, 0.332172f} },
    { {0.059797f, 0.217123f, -0.017889f}, {0.901064f, 0.429898f, 0.057197f}, {0.308488f, 0.322156f} },
    { {0.047223f, 0.215465f, 0.006962f}, {0.325074f, 0.058733f, 0.943863f}, {0.320499f, 0.337772f} },
    { {0.029492f, 0.219470f, 0.000000f}, {-0.001204f, 0.315874f, 0.948800f}, {0.332944f, 0.333473f} },
    { {-0.006763f, 0.013360f, -0.179879f}, {-0.091471f, -0.105317f, -0.990223f}, {0.396632f, 0.218796f} },
    { {0.036022f, -0.009814f, -0.164977f}, {-0.316025f, -0.851948f, -0.417507f}, {0.389661f, 0.231303f} },
    { {0.004591f, 0.014434f, -0.190665f}, {-0.316025f, -0.851948f, -0.417507f}, {0.354445f, 0.213514f} },
    { {-0.006763f, 0.013360f, -0.179879f}, {-0.316025f, -0.851948f, -0.417507f}, {0.348091f, 0.220368f} },
};

WORD g_tind2[] = 
{
    2, 1, 0,    5, 4, 3,    6, 2, 0,    3, 4, 7,    10, 9, 8,
    13, 12, 11,    14, 12, 13,    17, 16, 15,    16, 18, 15,    21, 20, 19,
    9, 22, 8,    21, 23, 20,    26, 25, 24,    29, 28, 27,    31, 3, 30,
    12, 33, 32,    36, 35, 34,    39, 38, 37,    38, 40, 37,    35, 41, 34,
    44, 43, 42,    13, 46, 45,    4, 48, 47,    49, 26, 24,    52, 51, 50,
    55, 54, 53,    58, 57, 56,    61, 60, 59,    62, 52, 50,    65, 64, 63,
    56, 57, 66,    64, 67, 63,    28, 21, 19,    24, 25, 68,    70, 69, 42,
    11, 12, 32,    72, 71, 3,    72, 3, 31,    7, 4, 47,    42, 73, 44,
    74, 2, 6,    2, 75, 1,    77, 76, 4,    4, 76, 48,    80, 79, 78,
    5, 77, 4,    81, 62, 50,    53, 61, 59,    82, 74, 6,    84, 6, 83,
    66, 57, 85,    54, 61, 53,    1, 87, 86,    75, 88, 1,    70, 89, 69,
    90, 72, 31,    91, 1, 86,    6, 0, 83,    93, 78, 92,    94, 80, 78,
    97, 96, 95,    96, 97, 98,    3, 7, 30,    7, 47, 30,    20, 23, 99,
    80, 100, 79,    1, 88, 87,    101, 20, 99,    13, 45, 14,    82, 6, 84,
    91, 86, 83,    12, 102, 33,    28, 19, 27,    74, 75, 2,    71, 77, 5,
    71, 5, 3,    105, 104, 103,    104, 105, 106,    102, 107, 33,    94, 78, 93,
    25, 109, 108,    112, 111, 110,    95, 113, 97,    116, 115, 114,    0, 1, 91,
    0, 91, 83,
};

D3DMATRIX g_tmat3 = 
{
    -0.881305f, -0.248936f, 0.401664f, 0.000000f, 
    -0.297891f, -0.367162f, -0.881166f, 0.000000f, 
    0.366829f, -0.896228f, 0.249426f, 0.000000f, 
    2.689724f, -3.000043f, 2.064546f, 1.000000f, 
};

// Mesh #3 Tris:96 Verts:126
MODELVERT g_tmesh3[] = 
{
    { {0.047789f, 0.023048f, -0.133575f}, {0.992428f, -0.059513f, -0.107446f}, {0.324198f, 0.227597f} },
    { {0.047807f, 0.130240f, -0.014095f}, {0.994373f, 0.041688f, 0.097389f}, {0.391531f, 0.319903f} },
    { {0.043033f, 0.168836f, -0.125763f}, {0.956423f, 0.238992f, -0.167741f}, {0.415776f, 0.233632f} },
    { {-0.037649f, 0.169679f, -0.124916f}, {-0.987881f, 0.132022f, -0.081620f}, {0.303851f, 0.234286f} },
    { {-0.044909f, 0.076245f, -0.006147f}, {-0.992219f, 0.074700f, 0.099609f}, {0.362543f, 0.326044f} },
    { {-0.044999f, 0.077181f, -0.133336f}, {-0.996216f, 0.042231f, -0.075969f}, {0.361955f, 0.227781f} },
    { {-0.037388f, 0.130414f, -0.014525f}, {-0.975095f, 0.101428f, 0.197237f}, {0.328516f, 0.319571f} },
    { {0.047688f, 0.021380f, -0.005583f}, {0.959434f, -0.246517f, 0.136803f}, {0.323149f, 0.326479f} },
    { {-0.030384f, 0.022987f, 0.008378f}, {-0.317084f, -0.107926f, 0.942237f}, {0.316933f, 0.241533f} },
    { {0.000932f, 0.075979f, 0.008391f}, {0.000148f, 0.075149f, 0.997172f}, {0.355923f, 0.274481f} },
    { {-0.003717f, 0.022987f, 0.008378f}, {-0.036191f, -0.315818f, 0.948129f}, {0.355923f, 0.241533f} },
    { {-0.030474f, 0.009398f, -0.133336f}, {-0.154203f, -0.985914f, -0.064765f}, {0.316801f, 0.227781f} },
    { {-0.030384f, 0.008461f, -0.006147f}, {-0.441924f, -0.890138f, 0.111164f}, {0.316933f, 0.326044f} },
    { {0.002588f, 0.005169f, -0.003219f}, {-0.015711f, -0.999013f, 0.041536f}, {0.355923f, 0.326044f} },
    { {0.002501f, 0.022255f, -0.151770f}, {-0.126351f, -0.144826f, -0.981357f}, {0.364365f, 0.242112f} },
    { {-0.030474f, 0.077181f, -0.147861f}, {-0.307433f, 0.122357f, -0.943670f}, {0.403355f, 0.275060f} },
    { {-0.030474f, 0.023923f, -0.147861f}, {-0.321364f, -0.298091f, -0.898814f}, {0.403355f, 0.242112f} },
    { {0.027508f, 0.009131f, -0.133324f}, {0.485356f, -0.862754f, -0.141721f}, {0.313391f, 0.227281f} },
    { {-0.030384f, 0.076245f, 0.008378f}, {-0.377300f, 0.116479f, 0.918737f}, {0.316933f, 0.274481f} },
    { {-0.022863f, 0.130414f, -0.000000f}, {-0.203150f, 0.192207f, 0.960097f}, {0.327930f, 0.307992f} },
    { {0.018244f, 0.182873f, -0.124916f}, {0.130233f, 0.989208f, -0.067126f}, {0.332125f, 0.234286f} },
    { {0.018244f, 0.182873f, -0.014525f}, {0.451395f, 0.887465f, 0.092996f}, {0.332125f, 0.319571f} },
    { {-0.027481f, 0.182873f, -0.014525f}, {-0.141730f, 0.945723f, 0.292439f}, {0.398980f, 0.319571f} },
    { {0.004649f, 0.130148f, -0.139428f}, {-0.102071f, 0.214895f, -0.971289f}, {0.358799f, 0.307992f} },
    { {0.002504f, 0.077052f, -0.151976f}, {-0.122551f, 0.115201f, -0.985754f}, {0.364365f, 0.275060f} },
    { {-0.027481f, 0.182873f, -0.124916f}, {-0.308693f, 0.745445f, -0.590780f}, {0.398980f, 0.234286f} },
    { {-0.030474f, 0.077181f, -0.147861f}, {-0.307433f, 0.122357f, -0.943670f}, {0.361955f, 0.216560f} },
    { {-0.044999f, 0.023923f, -0.133336f}, {-0.943568f, -0.301419f, -0.137205f}, {0.395410f, 0.227781f} },
    { {-0.030474f, 0.023923f, -0.147861f}, {-0.321364f, -0.298091f, -0.898814f}, {0.395410f, 0.216560f} },
    { {-0.030384f, 0.008461f, -0.006147f}, {-0.441924f, -0.890138f, 0.111164f}, {0.405122f, 0.326044f} },
    { {-0.030474f, 0.009398f, -0.133336f}, {-0.154203f, -0.985914f, -0.064765f}, {0.404534f, 0.227781f} },
    { {0.022892f, 0.168082f, -0.006326f}, {0.352744f, 0.379368f, 0.855367f}, {0.388032f, 0.331459f} },
    { {-0.000000f, 0.130414f, -0.000000f}, {-0.000000f, 0.157783f, 0.987474f}, {0.361357f, 0.307992f} },
    { {-0.000000f, 0.130414f, -0.000000f}, {-0.155677f, 0.169445f, 0.973167f}, {0.370588f, 0.308172f} },
    { {0.026104f, 0.168665f, -0.002552f}, {0.290662f, 0.188291f, 0.938116f}, {0.399525f, 0.331655f} },
    { {0.030633f, 0.076089f, 0.012287f}, {0.312575f, 0.090140f, 0.945606f}, {0.406147f, 0.274384f} },
    { {0.000932f, 0.075979f, 0.008391f}, {-0.129919f, 0.081563f, 0.988164f}, {0.365149f, 0.274508f} },
    { {-0.003717f, 0.022987f, 0.008378f}, {-0.122219f, -0.099080f, 0.987545f}, {0.365143f, 0.240982f} },
    { {0.027599f, 0.008195f, -0.006134f}, {0.504857f, -0.852753f, 0.133910f}, {0.312718f, 0.326572f} },
    { {0.030576f, 0.077223f, -0.151715f}, {0.463515f, 0.098008f, -0.880652f}, {0.314093f, 0.275086f} },
    { {0.006312f, 0.130709f, -0.143510f}, {-0.092174f, 0.176041f, -0.980058f}, {0.349571f, 0.308174f} },
    { {0.002504f, 0.077052f, -0.151976f}, {-0.041693f, 0.055952f, -0.997563f}, {0.355138f, 0.274980f} },
    { {0.002501f, 0.022255f, -0.151770f}, {0.005520f, -0.426688f, -0.904382f}, {0.355143f, 0.241080f} },
    { {0.027508f, 0.009131f, -0.133324f}, {0.485356f, -0.862754f, -0.141721f}, {0.312433f, 0.230928f} },
    { {0.030536f, 0.023098f, -0.151723f}, {0.260172f, -0.183559f, -0.947954f}, {0.314152f, 0.241602f} },
    { {-0.040394f, 0.020009f, -0.117522f}, {-0.977898f, 0.099049f, -0.184133f}, {0.397868f, 0.239999f} },
    { {-0.026551f, -0.021767f, -0.021530f}, {-0.733362f, -0.636450f, 0.238978f}, {0.424111f, 0.314159f} },
    { {-0.026551f, -0.021767f, -0.117522f}, {-0.389644f, -0.889579f, -0.238384f}, {0.424111f, 0.239999f} },
    { {0.017453f, -0.022536f, -0.117522f}, {0.710417f, -0.662178f, -0.238384f}, {0.295564f, 0.239999f} },
    { {0.032746f, 0.018733f, -0.021530f}, {0.980614f, 0.065869f, 0.184544f}, {0.321487f, 0.314159f} },
    { {0.032746f, 0.018733f, -0.117522f}, {0.341136f, 0.916514f, -0.208875f}, {0.321487f, 0.239999f} },
    { {0.017453f, -0.022536f, -0.021530f}, {0.357771f, -0.902712f, 0.238978f}, {0.295564f, 0.314159f} },
    { {-0.040394f, 0.020009f, -0.021530f}, {-0.306270f, 0.928746f, 0.208875f}, {0.397868f, 0.314159f} },
    { {-0.003807f, 0.009398f, -0.133336f}, {-0.006736f, -0.819098f, -0.573614f}, {0.355166f, 0.231090f} },
    { {-0.003807f, 0.009398f, -0.133336f}, {-0.013684f, -0.994354f, -0.105228f}, {0.355791f, 0.227781f} },
    { {0.027599f, 0.008195f, -0.006134f}, {0.032383f, -0.999166f, -0.024889f}, {0.394913f, 0.326044f} },
    { {0.027508f, 0.009131f, -0.133324f}, {-0.008498f, -0.999937f, -0.007353f}, {0.394781f, 0.227781f} },
    { {0.030432f, 0.021453f, 0.012179f}, {0.235140f, -0.294928f, 0.926135f}, {0.405853f, 0.240584f} },
    { {0.002588f, 0.005169f, -0.003219f}, {0.006703f, -0.693070f, 0.720839f}, {0.365141f, 0.230510f} },
    { {-0.030384f, 0.008461f, -0.006147f}, {-0.441924f, -0.890138f, 0.111164f}, {0.316933f, 0.232547f} },
    { {0.002588f, 0.005169f, -0.003219f}, {-0.015711f, -0.999013f, 0.041536f}, {0.355923f, 0.232547f} },
    { {0.043033f, 0.168836f, -0.125763f}, {0.956423f, 0.238992f, -0.167741f}, {0.295880f, 0.233632f} },
    { {0.043162f, 0.168584f, -0.014252f}, {0.840361f, 0.529426f, 0.116197f}, {0.295691f, 0.319782f} },
    { {0.022892f, 0.168082f, -0.006326f}, {-0.045011f, 0.998697f, 0.024036f}, {0.325328f, 0.325905f} },
    { {0.030633f, 0.076089f, 0.012287f}, {0.312575f, 0.090140f, 0.945606f}, {0.357516f, 0.340285f} },
    { {0.026104f, 0.168665f, -0.002552f}, {0.290662f, 0.188291f, 0.938116f}, {0.415668f, 0.328821f} },
    { {-0.004007f, 0.008885f, -0.124767f}, {0.101519f, 0.932365f, -0.346971f}, {0.364658f, 0.232809f} },
    { {-0.040394f, 0.020009f, -0.117522f}, {-0.977898f, 0.099049f, -0.184133f}, {0.401394f, 0.237561f} },
    { {-0.026551f, -0.021767f, -0.117522f}, {-0.389644f, -0.889579f, -0.238384f}, {0.397619f, 0.213846f} },
    { {-0.004007f, 0.008885f, -0.124767f}, {0.101519f, 0.932365f, -0.346971f}, {0.364658f, 0.234401f} },
    { {-0.040394f, 0.020009f, -0.021530f}, {-0.306270f, 0.928746f, 0.208875f}, {0.417860f, 0.314159f} },
    { {-0.040394f, 0.020009f, -0.117522f}, {-0.977898f, 0.099049f, -0.184133f}, {0.417860f, 0.239999f} },
    { {0.017453f, -0.022536f, -0.021530f}, {0.357771f, -0.902712f, 0.238978f}, {0.386877f, 0.213371f} },
    { {-0.004007f, 0.008885f, -0.014703f}, {-0.068707f, 0.935666f, 0.346133f}, {0.355499f, 0.232809f} },
    { {0.032746f, 0.018733f, -0.021530f}, {0.980614f, 0.065869f, 0.184544f}, {0.392605f, 0.237016f} },
    { {0.032746f, 0.018733f, -0.117522f}, {0.341136f, 0.916514f, -0.208875f}, {0.310920f, 0.239999f} },
    { {0.032746f, 0.018733f, -0.021530f}, {0.980614f, 0.065869f, 0.184544f}, {0.310920f, 0.314159f} },
    { {-0.004007f, 0.008885f, -0.014703f}, {-0.068707f, 0.935666f, 0.346133f}, {0.364658f, 0.319433f} },
    { {0.017453f, -0.022536f, -0.117522f}, {0.710417f, -0.662178f, -0.238384f}, {0.333280f, 0.213371f} },
    { {-0.026551f, -0.021767f, -0.117522f}, {-0.389644f, -0.889579f, -0.238384f}, {0.322537f, 0.239999f} },
    { {0.017453f, -0.022536f, -0.021530f}, {0.357771f, -0.902712f, 0.238978f}, {0.386877f, 0.314159f} },
    { {0.017453f, -0.022536f, -0.117522f}, {0.710417f, -0.662178f, -0.238384f}, {0.386877f, 0.239999f} },
    { {-0.026551f, -0.021767f, -0.021530f}, {-0.733362f, -0.636450f, 0.238978f}, {0.322537f, 0.213846f} },
    { {-0.026551f, -0.021767f, -0.021530f}, {-0.733362f, -0.636450f, 0.238978f}, {0.322537f, 0.314159f} },
    { {0.025387f, 0.168822f, -0.137052f}, {0.222695f, 0.625153f, -0.748058f}, {0.321680f, 0.224910f} },
    { {0.030576f, 0.077223f, -0.151715f}, {0.463515f, 0.098008f, -0.880652f}, {0.358228f, 0.213582f} },
    { {0.025387f, 0.168822f, -0.137052f}, {0.222695f, 0.625153f, -0.748058f}, {0.415767f, 0.224910f} },
    { {-0.044909f, 0.022987f, -0.006147f}, {-0.990446f, -0.124467f, 0.059372f}, {0.395998f, 0.326044f} },
    { {-0.030384f, 0.076245f, 0.008378f}, {-0.377300f, 0.116479f, 0.918737f}, {0.362543f, 0.337265f} },
    { {-0.027481f, 0.182873f, -0.124916f}, {-0.308693f, 0.745445f, -0.590780f}, {0.398980f, 0.340445f} },
    { {0.030536f, 0.023098f, -0.151723f}, {0.260172f, -0.183559f, -0.947954f}, {0.324229f, 0.213576f} },
    { {-0.003807f, 0.009398f, -0.133336f}, {-0.013684f, -0.994354f, -0.105228f}, {0.364365f, 0.233126f} },
    { {0.027599f, 0.008195f, -0.006134f}, {0.504857f, -0.852753f, 0.133910f}, {0.407590f, 0.230266f} },
    { {0.018244f, 0.168348f, -0.133103f}, {-0.098942f, 0.292287f, -0.951199f}, {0.332125f, 0.331459f} },
    { {0.025387f, 0.168822f, -0.137052f}, {0.222695f, 0.625153f, -0.748058f}, {0.321680f, 0.331753f} },
    { {0.032746f, 0.018733f, -0.117522f}, {0.341136f, 0.916514f, -0.208875f}, {0.327551f, 0.237016f} },
    { {-0.040394f, 0.020009f, -0.021530f}, {-0.306270f, 0.928746f, 0.208875f}, {0.318762f, 0.237561f} },
    { {0.018244f, 0.182873f, -0.124916f}, {0.130233f, 0.989208f, -0.067126f}, {0.332125f, 0.340445f} },
    { {0.025387f, 0.168822f, -0.137052f}, {0.917975f, 0.396272f, -0.017035f}, {0.415469f, 0.234286f} },
    { {0.018244f, 0.182873f, -0.014525f}, {0.451395f, 0.887465f, 0.092996f}, {0.424593f, 0.319571f} },
    { {0.018244f, 0.182873f, -0.124916f}, {0.130233f, 0.989208f, -0.067126f}, {0.424593f, 0.234286f} },
    { {-0.030384f, 0.022987f, 0.008378f}, {-0.317084f, -0.107926f, 0.942237f}, {0.395998f, 0.337265f} },
    { {-0.022863f, 0.130414f, -0.000000f}, {-0.203150f, 0.192207f, 0.960097f}, {0.328516f, 0.330792f} },
    { {-0.027481f, 0.182873f, -0.124916f}, {-0.308693f, 0.745445f, -0.590780f}, {0.295564f, 0.234286f} },
    { {-0.027481f, 0.182873f, -0.014525f}, {-0.141730f, 0.945723f, 0.292439f}, {0.295564f, 0.319571f} },
    { {-0.037649f, 0.169679f, -0.014525f}, {-0.950033f, 0.279917f, 0.138146f}, {0.303851f, 0.319571f} },
    { {0.030432f, 0.021453f, 0.012179f}, {0.235140f, -0.294928f, 0.926135f}, {0.323195f, 0.340202f} },
    { {-0.027481f, 0.182873f, -0.124916f}, {-0.308693f, 0.745445f, -0.590780f}, {0.304407f, 0.227962f} },
    { {0.022892f, 0.168082f, -0.006326f}, {0.352744f, 0.379368f, 0.855367f}, {0.415469f, 0.325896f} },
    { {0.018244f, 0.182873f, -0.014525f}, {0.451395f, 0.887465f, 0.092996f}, {0.388032f, 0.340445f} },
    { {-0.027481f, 0.182873f, -0.014525f}, {-0.141730f, 0.945723f, 0.292439f}, {0.321176f, 0.340445f} },
    { {-0.030474f, 0.009398f, -0.133336f}, {-0.154203f, -0.985914f, -0.064765f}, {0.403355f, 0.233126f} },
    { {0.018244f, 0.168348f, -0.133103f}, {-0.098942f, 0.292287f, -0.951199f}, {0.415469f, 0.227962f} },
    { {0.006312f, 0.130709f, -0.143510f}, {-0.468158f, 0.370263f, -0.802330f}, {0.328164f, 0.219911f} },
    { {0.025387f, 0.168822f, -0.137052f}, {-0.468158f, 0.370263f, -0.802330f}, {0.304223f, 0.224901f} },
    { {0.018244f, 0.168348f, -0.133103f}, {-0.468158f, 0.370263f, -0.802330f}, {0.304688f, 0.227962f} },
    { {-0.037649f, 0.169679f, -0.014525f}, {-0.950033f, 0.279917f, 0.138146f}, {0.306310f, 0.332283f} },
    { {-0.000000f, 0.130414f, -0.000000f}, {-0.155677f, 0.169445f, 0.973167f}, {0.328683f, 0.330802f} },
    { {0.022892f, 0.168082f, -0.006326f}, {-0.045011f, 0.998697f, 0.024036f}, {0.304855f, 0.325905f} },
    { {0.026104f, 0.168665f, -0.002552f}, {0.290662f, 0.188291f, 0.938116f}, {0.304489f, 0.328821f} },
    { {0.026104f, 0.168665f, -0.002552f}, {0.290662f, 0.188291f, 0.938116f}, {0.320631f, 0.328821f} },
    { {0.043162f, 0.168584f, -0.014252f}, {0.840361f, 0.529426f, 0.116197f}, {0.415617f, 0.319782f} },
    { {0.018244f, 0.168348f, -0.133103f}, {-0.879012f, 0.363858f, -0.308133f}, {0.304855f, 0.227971f} },
    { {0.004649f, 0.130148f, -0.139428f}, {-0.912295f, 0.227656f, -0.340427f}, {0.328683f, 0.223074f} },
    { {0.006312f, 0.130709f, -0.143510f}, {-0.092174f, 0.176041f, -0.980058f}, {0.328331f, 0.219921f} },
    { {0.002504f, 0.077052f, -0.151976f}, {-0.041693f, 0.055952f, -0.997563f}, {0.362036f, 0.213380f} },
};

WORD g_tind3[] = 
{
    2, 1, 0,    5, 4, 3,    4, 6, 3,    1, 7, 0,    10, 9, 8,
    13, 12, 11,    16, 15, 14,    0, 7, 17,    9, 19, 18,    22, 21, 20,
    24, 15, 23,    25, 22, 20,    28, 27, 26,    30, 29, 27,    32, 31, 19,
    35, 34, 33,    37, 35, 36,    7, 38, 17,    41, 40, 39,    44, 43, 42,
    47, 46, 45,    50, 49, 48,    49, 51, 48,    46, 52, 45,    42, 43, 53,
    56, 55, 54,    58, 57, 37,    60, 10, 59,    63, 62, 61,    65, 64, 1,
    68, 67, 66,    71, 70, 69,    74, 73, 72,    77, 76, 75,    78, 68, 66,
    81, 80, 79,    72, 73, 82,    80, 83, 79,    61, 84, 63,    86, 2, 85,
    29, 87, 27,    4, 88, 6,    5, 3, 26,    15, 89, 23,    2, 0, 85,
    0, 17, 90,    14, 91, 16,    54, 55, 11,    55, 13, 11,    92, 57, 58,
    23, 89, 93,    40, 94, 39,    95, 78, 66,    69, 77, 75,    82, 73, 96,
    70, 77, 69,    1, 64, 7,    57, 35, 37,    89, 97, 93,    100, 99, 98,
    36, 35, 33,    9, 32, 19,    10, 8, 59,    29, 101, 87,    88, 102, 6,
    105, 104, 103,    41, 39, 44,    85, 0, 90,    64, 106, 7,    7, 106, 38,
    26, 3, 107,    3, 105, 103,    14, 15, 24,    42, 41, 44,    99, 108, 98,
    110, 31, 109,    91, 111, 16,    30, 27, 28,    100, 98, 112,    115, 114, 113,
    27, 87, 5,    27, 5, 26,    9, 18, 8,    101, 88, 4,    31, 110, 19,
    19, 110, 116,    87, 101, 4,    87, 4, 5,    119, 118, 117,    63, 120, 62,
    121, 65, 1,    121, 1, 2,    124, 123, 122,    123, 124, 125,    6, 102, 105,
    6, 105, 3,
};

D3DMATRIX g_tmat4 = 
{
    -0.845713f, -0.432969f, -0.311943f, 0.000000f, 
    0.387565f, -0.096513f, -0.916776f, 0.000000f, 
    0.366829f, -0.896228f, 0.249426f, 0.000000f, 
    2.628758f, -3.053249f, 1.897803f, 1.000000f, 
};

// Mesh #4 Tris:74 Verts:98
MODELVERT g_tmesh4[] = 
{
    { {-0.028660f, 0.022378f, -0.099933f}, {-0.954250f, -0.257611f, -0.151803f}, {0.399661f, 0.228668f} },
    { {-0.038275f, 0.106688f, -0.021795f}, {-0.991157f, -0.034084f, 0.128240f}, {0.330727f, 0.313958f} },
    { {-0.028660f, 0.022378f, -0.011620f}, {-0.960957f, -0.253132f, 0.111740f}, {0.399661f, 0.325064f} },
    { {0.038583f, 0.022115f, -0.100090f}, {0.992702f, 0.054489f, -0.107583f}, {0.320281f, 0.228497f} },
    { {0.038500f, 0.021590f, -0.011201f}, {0.984197f, -0.087556f, 0.153917f}, {0.319851f, 0.325521f} },
    { {0.026559f, 0.107000f, -0.020047f}, {0.966262f, 0.233486f, 0.108728f}, {0.389685f, 0.315865f} },
    { {-0.038374f, 0.107393f, -0.094738f}, {-0.977200f, -0.010134f, -0.212081f}, {0.330150f, 0.234339f} },
    { {0.026397f, 0.107692f, -0.096050f}, {0.900214f, 0.381837f, -0.209322f}, {0.390251f, 0.232906f} },
    { {0.017843f, 0.107867f, -0.095511f}, {0.999689f, 0.009693f, -0.022995f}, {0.390394f, 0.233495f} },
    { {0.009443f, 0.108574f, -0.009203f}, {0.671311f, 0.115472f, 0.732126f}, {0.391887f, 0.327691f} },
    { {0.014326f, 0.136946f, -0.026711f}, {0.976126f, 0.179467f, 0.122350f}, {0.414170f, 0.308592f} },
    { {-0.024591f, 0.109598f, -0.010116f}, {-0.276907f, 0.185007f, 0.942919f}, {0.319766f, 0.308158f} },
    { {0.002368f, 0.139351f, -0.015699f}, {-0.020322f, 0.485891f, 0.873783f}, {0.367105f, 0.332117f} },
    { {0.009443f, 0.108574f, -0.009203f}, {0.671311f, 0.115472f, 0.732126f}, {0.373424f, 0.308235f} },
    { {0.014171f, 0.138048f, -0.092316f}, {0.846282f, 0.450438f, -0.284451f}, {0.415071f, 0.236982f} },
    { {0.019169f, 0.066195f, -0.113669f}, {-0.072613f, 0.093202f, -0.992996f}, {0.336170f, 0.273605f} },
    { {-0.024512f, 0.109038f, -0.106453f}, {-0.320577f, 0.065624f, -0.944946f}, {0.400252f, 0.307707f} },
    { {-0.010878f, 0.020877f, -0.113937f}, {-0.326764f, -0.014165f, -0.945000f}, {0.387131f, 0.237925f} },
    { {-0.010876f, 0.007516f, -0.100084f}, {0.014910f, -0.997409f, -0.070374f}, {0.343850f, 0.228503f} },
    { {0.024845f, 0.008012f, -0.011432f}, {0.177256f, -0.981035f, 0.078432f}, {0.406575f, 0.325269f} },
    { {0.025304f, 0.008153f, -0.100283f}, {0.367146f, -0.916727f, -0.157528f}, {0.407381f, 0.228285f} },
    { {0.025308f, 0.021815f, -0.113888f}, {0.269106f, -0.189331f, -0.944318f}, {0.312768f, 0.237472f} },
    { {0.019169f, 0.066195f, -0.113669f}, {0.498220f, 0.127136f, -0.857679f}, {0.323548f, 0.273208f} },
    { {-0.010878f, 0.020877f, -0.113937f}, {0.007773f, -0.355599f, -0.934606f}, {0.376311f, 0.236717f} },
    { {-0.010921f, 0.007558f, -0.011119f}, {0.001179f, -0.966827f, 0.255431f}, {0.343770f, 0.325611f} },
    { {-0.017040f, 0.022378f, -0.000000f}, {-0.059918f, -0.188262f, 0.980289f}, {0.343820f, 0.236925f} },
    { {0.018954f, 0.067556f, 0.002229f}, {0.497141f, 0.138989f, 0.856466f}, {0.396230f, 0.274304f} },
    { {0.024965f, 0.021440f, 0.002387f}, {0.164742f, -0.269311f, 0.948858f}, {0.406785f, 0.237170f} },
    { {0.002561f, 0.149597f, -0.090944f}, {-0.124892f, 0.990559f, -0.056532f}, {0.295564f, 0.238739f} },
    { {0.002747f, 0.148271f, -0.029496f}, {0.165145f, 0.979830f, 0.112519f}, {0.296680f, 0.305025f} },
    { {-0.033379f, 0.136797f, -0.028121f}, {-0.560507f, 0.792602f, 0.240029f}, {0.306109f, 0.307053f} },
    { {0.002368f, 0.139351f, -0.015699f}, {-0.020322f, 0.485891f, 0.873783f}, {0.303181f, 0.319853f} },
    { {-0.024591f, 0.109598f, -0.010116f}, {-0.276907f, 0.185007f, 0.942919f}, {0.328348f, 0.326706f} },
    { {-0.027666f, 0.023067f, -0.092014f}, {-0.983332f, 0.071759f, -0.167061f}, {0.399098f, 0.237312f} },
    { {-0.016930f, -0.007959f, -0.015460f}, {-0.719473f, -0.640292f, 0.269043f}, {0.424465f, 0.320873f} },
    { {-0.016928f, -0.007972f, -0.092014f}, {-0.374339f, -0.887654f, -0.268218f}, {0.424476f, 0.237312f} },
    { {0.015916f, -0.008115f, -0.092014f}, {0.712974f, -0.646471f, -0.271558f}, {0.295564f, 0.237312f} },
    { {0.026923f, 0.022842f, -0.015460f}, {0.982153f, 0.076093f, 0.172003f}, {0.320875f, 0.320873f} },
    { {0.026924f, 0.022829f, -0.092014f}, {0.558919f, 0.807075f, -0.190368f}, {0.320864f, 0.237312f} },
    { {-0.027668f, 0.023080f, -0.015460f}, {-0.563893f, 0.803843f, 0.189369f}, {0.399087f, 0.320873f} },
    { {0.015914f, -0.008102f, -0.015460f}, {0.365630f, -0.889997f, 0.272436f}, {0.295574f, 0.320873f} },
    { {-0.033550f, 0.138012f, -0.091621f}, {-0.832409f, 0.543603f, -0.107663f}, {0.305115f, 0.237740f} },
    { {-0.024512f, 0.109038f, -0.106453f}, {-0.320577f, 0.065624f, -0.944946f}, {0.328805f, 0.221551f} },
    { {-0.010921f, 0.007558f, -0.011119f}, {-0.641338f, -0.766245f, 0.039417f}, {0.409162f, 0.325064f} },
    { {-0.010921f, 0.007558f, -0.011119f}, {0.001179f, -0.966827f, 0.255431f}, {0.343770f, 0.225992f} },
    { {-0.016930f, -0.007959f, -0.015460f}, {-0.719473f, -0.640292f, 0.269043f}, {0.333220f, 0.213497f} },
    { {-0.000770f, 0.022699f, -0.010365f}, {0.001219f, 0.925712f, 0.378228f}, {0.361595f, 0.238184f} },
    { {0.015914f, -0.008102f, -0.015460f}, {0.365630f, -0.889997f, 0.272436f}, {0.390892f, 0.213381f} },
    { {-0.016928f, -0.007972f, -0.092014f}, {-0.374339f, -0.887654f, -0.268218f}, {0.333223f, 0.237312f} },
    { {-0.016930f, -0.007959f, -0.015460f}, {-0.719473f, -0.640292f, 0.269043f}, {0.333220f, 0.320873f} },
    { {0.015914f, -0.008102f, -0.015460f}, {0.365630f, -0.889997f, 0.272436f}, {0.390892f, 0.320873f} },
    { {0.006055f, 0.109061f, -0.106898f}, {0.187266f, 0.193895f, -0.962983f}, {0.391370f, 0.221065f} },
    { {-0.013316f, 0.140325f, -0.103361f}, {-0.115457f, 0.372149f, -0.920964f}, {0.416047f, 0.224553f} },
    { {-0.013316f, 0.140325f, -0.103361f}, {-0.115457f, 0.372149f, -0.920964f}, {0.303224f, 0.224926f} },
    { {0.018954f, 0.067556f, 0.002229f}, {0.497141f, 0.138989f, 0.856466f}, {0.357434f, 0.340181f} },
    { {0.026397f, 0.107692f, -0.096050f}, {0.900214f, 0.381837f, -0.209322f}, {0.310857f, 0.232906f} },
    { {0.026559f, 0.107000f, -0.020047f}, {0.966262f, 0.233486f, 0.108728f}, {0.310572f, 0.315865f} },
    { {0.009443f, 0.108574f, -0.009203f}, {0.240881f, 0.930326f, 0.276531f}, {0.340628f, 0.327702f} },
    { {-0.010876f, 0.007516f, -0.100084f}, {-0.638575f, -0.763148f, -0.099128f}, {0.409162f, 0.228668f} },
    { {-0.010876f, 0.007516f, -0.100084f}, {0.014910f, -0.997409f, -0.070374f}, {0.376307f, 0.225958f} },
    { {0.025304f, 0.008153f, -0.100283f}, {0.367146f, -0.916727f, -0.157528f}, {0.312776f, 0.226470f} },
    { {-0.000769f, 0.022686f, -0.097421f}, {0.006901f, 0.923993f, -0.382347f}, {0.358559f, 0.238173f} },
    { {-0.027666f, 0.023067f, -0.092014f}, {-0.983332f, 0.071759f, -0.167061f}, {0.390974f, 0.236500f} },
    { {-0.016928f, -0.007972f, -0.092014f}, {-0.374339f, -0.887654f, -0.268218f}, {0.386934f, 0.213486f} },
    { {-0.000769f, 0.022686f, -0.097421f}, {0.006901f, 0.923993f, -0.382347f}, {0.358559f, 0.231410f} },
    { {-0.027668f, 0.023080f, -0.015460f}, {-0.563893f, 0.803843f, 0.189369f}, {0.405793f, 0.320873f} },
    { {-0.027666f, 0.023067f, -0.092014f}, {-0.983332f, 0.071759f, -0.167061f}, {0.405790f, 0.237312f} },
    { {0.015914f, -0.008102f, -0.015460f}, {0.365630f, -0.889997f, 0.272436f}, {0.382023f, 0.219172f} },
    { {0.026923f, 0.022842f, -0.015460f}, {0.982153f, 0.076093f, 0.172003f}, {0.395371f, 0.236378f} },
    { {0.026924f, 0.022829f, -0.092014f}, {0.558919f, 0.807075f, -0.190368f}, {0.309930f, 0.237312f} },
    { {0.026923f, 0.022842f, -0.015460f}, {0.982153f, 0.076093f, 0.172003f}, {0.309933f, 0.320873f} },
    { {-0.000770f, 0.022699f, -0.010365f}, {0.001219f, 0.925712f, 0.378228f}, {0.358562f, 0.326434f} },
    { {0.019169f, 0.066195f, -0.113669f}, {0.498220f, 0.127136f, -0.857679f}, {0.356322f, 0.213675f} },
    { {0.006055f, 0.109061f, -0.106898f}, {0.187266f, 0.193895f, -0.962983f}, {0.346577f, 0.307726f} },
    { {0.015916f, -0.008115f, -0.092014f}, {0.712974f, -0.646471f, -0.271558f}, {0.329261f, 0.213371f} },
    { {0.015916f, -0.008115f, -0.092014f}, {0.712974f, -0.646471f, -0.271558f}, {0.390896f, 0.237312f} },
    { {0.025308f, 0.021815f, -0.113888f}, {0.269106f, -0.189331f, -0.944318f}, {0.320036f, 0.213435f} },
    { {0.025304f, 0.008153f, -0.100283f}, {0.367146f, -0.916727f, -0.157528f}, {0.308865f, 0.228285f} },
    { {-0.017040f, 0.022378f, -0.000000f}, {-0.438055f, 0.031296f, 0.898403f}, {0.333026f, 0.237925f} },
    { {0.018954f, 0.067556f, 0.002229f}, {-0.136332f, 0.146493f, 0.979772f}, {0.383649f, 0.274708f} },
    { {-0.017040f, 0.022378f, -0.000000f}, {-0.438055f, 0.031296f, 0.898403f}, {0.399661f, 0.337748f} },
    { {-0.010878f, 0.020877f, -0.113937f}, {-0.326764f, -0.014165f, -0.945000f}, {0.399661f, 0.215984f} },
    { {0.009443f, 0.108574f, -0.009203f}, {0.240881f, 0.930326f, 0.276531f}, {0.391829f, 0.329704f} },
    { {0.015916f, -0.008115f, -0.092014f}, {0.712974f, -0.646471f, -0.271558f}, {0.338131f, 0.219162f} },
    { {0.026924f, 0.022829f, -0.092014f}, {0.558919f, 0.807075f, -0.190368f}, {0.324783f, 0.236367f} },
    { {0.002368f, 0.139351f, -0.015699f}, {-0.020322f, 0.485891f, 0.873783f}, {0.416136f, 0.320612f} },
    { {-0.027668f, 0.023080f, -0.015460f}, {-0.563893f, 0.803843f, 0.189369f}, {0.329179f, 0.236510f} },
    { {0.006055f, 0.109061f, -0.106898f}, {0.456753f, 0.367538f, -0.810119f}, {0.391223f, 0.219061f} },
    { {0.024965f, 0.021440f, 0.002387f}, {0.164742f, -0.269311f, 0.948858f}, {0.319729f, 0.340354f} },
    { {0.024845f, 0.008012f, -0.011432f}, {0.177256f, -0.981035f, 0.078432f}, {0.308750f, 0.325269f} },
    { {-0.013316f, 0.140325f, -0.103361f}, {-0.115457f, 0.372149f, -0.920964f}, {0.380591f, 0.332901f} },
    { {0.002747f, 0.148271f, -0.029496f}, {0.165145f, 0.979830f, 0.112519f}, {0.423429f, 0.305552f} },
    { {0.002561f, 0.149597f, -0.090944f}, {-0.124892f, 0.990559f, -0.056532f}, {0.424513f, 0.238480f} },
    { {-0.033550f, 0.138012f, -0.091621f}, {-0.832409f, 0.543603f, -0.107663f}, {0.416123f, 0.331038f} },
    { {-0.038374f, 0.107393f, -0.094738f}, {-0.977200f, -0.010134f, -0.212081f}, {0.424593f, 0.306382f} },
    { {0.024845f, 0.008012f, -0.011432f}, {0.177256f, -0.981035f, 0.078432f}, {0.406575f, 0.226357f} },
    { {0.017843f, 0.107867f, -0.095511f}, {0.020710f, 0.999776f, 0.004268f}, {0.319772f, 0.233506f} },
    { {0.006055f, 0.109061f, -0.106898f}, {0.456753f, 0.367538f, -0.810119f}, {0.332916f, 0.219061f} },
};

WORD g_tind4[] = 
{
    2, 1, 0,    5, 4, 3,    0, 1, 6,    7, 5, 3,    10, 9, 8,
    13, 12, 11,    14, 10, 8,    17, 16, 15,    20, 19, 18,    23, 22, 21,
    19, 24, 18,    27, 26, 25,    30, 29, 28,    32, 31, 30,    35, 34, 33,
    38, 37, 36,    34, 39, 33,    37, 40, 36,    41, 30, 28,    0, 6, 42,
    43, 2, 0,    27, 25, 44,    47, 46, 45,    50, 49, 48,    52, 14, 51,
    41, 28, 53,    5, 54, 4,    57, 56, 55,    58, 43, 0,    60, 59, 23,
    63, 62, 61,    66, 65, 64,    68, 46, 67,    71, 70, 69,    7, 3, 72,
    16, 73, 15,    74, 63, 61,    75, 50, 48,    72, 3, 76,    3, 4, 77,
    79, 11, 78,    80, 32, 1,    81, 0, 42,    58, 0, 81,    82, 54, 5,
    79, 13, 11,    84, 83, 61,    64, 71, 69,    10, 85, 9,    30, 31, 29,
    45, 46, 86,    65, 71, 64,    14, 8, 51,    87, 7, 72,    54, 88, 4,
    4, 89, 77,    1, 32, 30,    1, 30, 41,    42, 6, 53,    16, 90, 73,
    21, 60, 23,    3, 77, 76,    43, 80, 2,    2, 80, 1,    92, 91, 14,
    92, 14, 52,    91, 85, 10,    91, 10, 14,    6, 1, 41,    94, 93, 90,
    95, 27, 44,    4, 88, 89,    55, 96, 57,    96, 55, 97,
};

D3DMATRIX g_tmat5 = 
{
    0.914258f, -0.280937f, 0.291903f, 0.000000f, 
    0.039589f, -0.655111f, -0.754495f, 0.000000f, 
    0.403194f, 0.701359f, -0.587818f, 0.000000f, 
    3.186302f, -2.861483f, 2.087815f, 1.000000f, 
};

// Mesh #5 Tris:86 Verts:117
MODELVERT g_tmesh5[] = 
{
    { {0.079072f, 0.155685f, -0.162306f}, {0.988601f, 0.045595f, -0.143492f}, {0.388136f, 0.231410f} },
    { {0.071993f, 0.012571f, -0.016931f}, {0.961662f, -0.211914f, 0.174065f}, {0.324910f, 0.322758f} },
    { {0.079086f, 0.155464f, -0.017324f}, {0.986528f, 0.049433f, 0.155946f}, {0.388038f, 0.322511f} },
    { {-0.048230f, 0.150767f, -0.161141f}, {-0.995966f, 0.065353f, -0.061480f}, {0.334194f, 0.232142f} },
    { {-0.048230f, 0.219470f, -0.018737f}, {-0.979462f, 0.151365f, 0.133199f}, {0.303841f, 0.321623f} },
    { {-0.061755f, 0.013360f, -0.018737f}, {-0.998084f, 0.019424f, 0.058739f}, {0.394898f, 0.321623f} },
    { {-0.061755f, 0.013360f, -0.161141f}, {-0.978362f, -0.100482f, -0.180861f}, {0.394898f, 0.232142f} },
    { {0.072578f, 0.014171f, -0.161757f}, {0.958562f, -0.245327f, -0.144824f}, {0.325617f, 0.231754f} },
    { {0.009966f, 0.150865f, -0.179789f}, {-0.174909f, 0.040014f, -0.983771f}, {0.362592f, 0.302623f} },
    { {-0.029493f, 0.219470f, -0.179879f}, {-0.283223f, 0.068863f, -0.956579f}, {0.393777f, 0.332293f} },
    { {-0.006762f, 0.013360f, -0.179879f}, {-0.163492f, -0.085934f, -0.982795f}, {0.372065f, 0.242616f} },
    { {0.029493f, 0.238208f, -0.161141f}, {0.142482f, 0.987099f, -0.073042f}, {0.337435f, 0.232142f} },
    { {-0.029493f, 0.238208f, -0.018737f}, {-0.142484f, 0.987408f, 0.068724f}, {0.393777f, 0.321623f} },
    { {-0.029493f, 0.238208f, -0.161141f}, {-0.325925f, 0.933931f, -0.146787f}, {0.393777f, 0.232142f} },
    { {-0.043017f, -0.005378f, -0.161141f}, {-0.147403f, -0.985950f, -0.078588f}, {0.313461f, 0.232142f} },
    { {-0.043017f, -0.005378f, -0.018737f}, {-0.281015f, -0.950684f, 0.131265f}, {0.313461f, 0.321623f} },
    { {0.042663f, -0.006821f, -0.016374f}, {0.063136f, -0.991707f, 0.111944f}, {0.382721f, 0.321623f} },
    { {0.006670f, 0.015187f, 0.011224f}, {-0.167180f, -0.089859f, 0.981823f}, {0.360922f, 0.243411f} },
    { {0.049331f, 0.215328f, 0.006931f}, {0.329310f, 0.099933f, 0.938919f}, {0.405109f, 0.304298f} },
    { {0.046459f, 0.014062f, 0.010445f}, {0.389880f, -0.107649f, 0.914552f}, {0.398927f, 0.242921f} },
    { {-0.030164f, -0.053857f, -0.152260f}, {-0.320831f, -0.905176f, -0.278792f}, {0.325738f, 0.237722f} },
    { {0.038383f, -0.049964f, -0.026749f}, {0.420533f, -0.863121f, 0.279596f}, {0.391213f, 0.316589f} },
    { {0.038383f, -0.049964f, -0.152260f}, {0.747916f, -0.602409f, -0.278792f}, {0.391213f, 0.237722f} },
    { {0.057403f, 0.016005f, -0.152260f}, {0.270247f, 0.931381f, -0.243916f}, {0.310776f, 0.237722f} },
    { {0.001364f, -0.003564f, -0.016098f}, {-0.053786f, 0.947201f, 0.316096f}, {0.364303f, 0.323281f} },
    { {0.001364f, -0.003564f, -0.163563f}, {-0.047710f, 0.840193f, -0.540185f}, {0.364303f, 0.230620f} },
    { {0.029493f, 0.238208f, -0.018737f}, {0.287631f, 0.947595f, 0.139043f}, {0.337435f, 0.321623f} },
    { {-0.029493f, 0.219470f, 0.000000f}, {-0.215137f, 0.150552f, 0.964909f}, {0.326380f, 0.332293f} },
    { {0.049331f, 0.215328f, 0.006931f}, {0.329310f, 0.099933f, 0.938919f}, {0.382721f, 0.332293f} },
    { {0.009966f, 0.150865f, 0.000090f}, {-0.186834f, 0.015437f, 0.982270f}, {0.357565f, 0.302623f} },
    { {0.035693f, -0.011572f, -0.166098f}, {0.244655f, -0.962219f, -0.119489f}, {0.382721f, 0.232142f} },
    { {0.046429f, 0.015005f, -0.190255f}, {0.411618f, -0.092375f, -0.906663f}, {0.321258f, 0.243332f} },
    { {0.016842f, 0.150449f, -0.190924f}, {-0.241869f, 0.058560f, -0.968540f}, {0.349520f, 0.302262f} },
    { {0.006700f, 0.014297f, -0.190695f}, {-0.164046f, -0.103318f, -0.981027f}, {0.359207f, 0.243024f} },
    { {-0.043017f, 0.013360f, 0.000000f}, {-0.321587f, -0.025721f, 0.946531f}, {0.313461f, 0.242616f} },
    { {-0.043017f, -0.005378f, -0.018737f}, {-0.281015f, -0.950684f, 0.131265f}, {0.313461f, 0.234463f} },
    { {0.000048f, 0.012945f, 0.000090f}, {-0.179923f, -0.277224f, 0.943808f}, {0.348091f, 0.242616f} },
    { {0.042663f, -0.006821f, -0.016374f}, {0.063136f, -0.991707f, 0.111944f}, {0.382721f, 0.234463f} },
    { {0.049617f, 0.189506f, -0.190334f}, {0.410402f, 0.091825f, -0.907270f}, {0.318213f, 0.319256f} },
    { {0.032648f, 0.185631f, -0.179879f}, {-0.084656f, 0.169456f, -0.981895f}, {0.334421f, 0.317570f} },
    { {0.029493f, 0.219470f, -0.179879f}, {0.141203f, 0.433150f, -0.890193f}, {0.337435f, 0.332293f} },
    { {-0.043017f, -0.005378f, -0.161141f}, {-0.147403f, -0.985950f, -0.078588f}, {0.406695f, 0.234463f} },
    { {0.035693f, -0.011572f, -0.166098f}, {0.244655f, -0.962219f, -0.119489f}, {0.337436f, 0.234463f} },
    { {-0.043017f, 0.013360f, -0.179879f}, {-0.321952f, -0.059376f, -0.944892f}, {0.406695f, 0.242616f} },
    { {0.038383f, -0.049964f, -0.152260f}, {0.747916f, -0.602409f, -0.278792f}, {0.297283f, 0.237722f} },
    { {0.038383f, -0.049964f, -0.026749f}, {0.420533f, -0.863121f, 0.279596f}, {0.297283f, 0.316589f} },
    { {0.057403f, 0.016005f, -0.026749f}, {0.966868f, 0.134286f, 0.217104f}, {0.326427f, 0.316589f} },
    { {-0.056530f, 0.009536f, -0.152260f}, {-0.808876f, 0.550706f, -0.206017f}, {0.396587f, 0.237722f} },
    { {-0.056530f, 0.009536f, -0.026749f}, {-0.815625f, 0.429128f, 0.388079f}, {0.396587f, 0.316589f} },
    { {-0.030164f, -0.053857f, -0.026749f}, {-0.675225f, -0.682567f, 0.279596f}, {0.424593f, 0.316589f} },
    { {0.001364f, -0.003564f, -0.163563f}, {-0.047710f, 0.840193f, -0.540185f}, {0.364303f, 0.235252f} },
    { {-0.030164f, -0.053857f, -0.152260f}, {-0.320831f, -0.905176f, -0.278792f}, {0.394418f, 0.213371f} },
    { {0.038383f, -0.049964f, -0.152260f}, {0.747916f, -0.602409f, -0.278792f}, {0.328944f, 0.215064f} },
    { {-0.030164f, -0.053857f, -0.152260f}, {-0.320831f, -0.905176f, -0.278792f}, {0.424593f, 0.237722f} },
    { {0.035693f, -0.011572f, -0.166098f}, {0.244655f, -0.962219f, -0.119489f}, {0.314244f, 0.229027f} },
    { {0.042663f, -0.006821f, -0.016374f}, {0.063136f, -0.991707f, 0.111944f}, {0.316343f, 0.323108f} },
    { {0.042663f, -0.006821f, -0.016374f}, {0.063136f, -0.991707f, 0.111944f}, {0.395301f, 0.233836f} },
    { {0.035693f, -0.011572f, -0.166098f}, {0.244655f, -0.962219f, -0.119489f}, {0.331513f, 0.231768f} },
    { {0.038383f, -0.049964f, -0.026749f}, {0.420533f, -0.863121f, 0.279596f}, {0.391213f, 0.215064f} },
    { {0.001364f, -0.003564f, -0.016098f}, {-0.053786f, 0.947201f, 0.316096f}, {0.355853f, 0.235252f} },
    { {0.057403f, 0.016005f, -0.026749f}, {0.966868f, 0.134286f, 0.217104f}, {0.392814f, 0.241132f} },
    { {0.057403f, 0.016005f, -0.026749f}, {0.966868f, 0.134286f, 0.217104f}, {0.310776f, 0.316589f} },
    { {0.057403f, 0.016005f, -0.152260f}, {0.270247f, 0.931381f, -0.243916f}, {0.327342f, 0.241132f} },
    { {0.057403f, 0.016005f, -0.152260f}, {0.270247f, 0.931381f, -0.243916f}, {0.326427f, 0.237722f} },
    { {-0.030164f, -0.053857f, -0.026749f}, {-0.675225f, -0.682567f, 0.279596f}, {0.325738f, 0.213371f} },
    { {-0.030164f, -0.053857f, -0.026749f}, {-0.675225f, -0.682567f, 0.279596f}, {0.325738f, 0.316589f} },
    { {0.046429f, 0.015005f, -0.190255f}, {0.411618f, -0.092375f, -0.906663f}, {0.325986f, 0.213848f} },
    { {0.049617f, 0.189506f, -0.190334f}, {0.410402f, 0.091825f, -0.907270f}, {0.403077f, 0.213798f} },
    { {0.061906f, 0.216986f, -0.017919f}, {0.901844f, 0.429790f, 0.044244f}, {0.415217f, 0.322137f} },
    { {0.061730f, 0.217316f, -0.162863f}, {0.777671f, 0.610329f, -0.150752f}, {0.415363f, 0.231060f} },
    { {0.016812f, 0.150458f, 0.011307f}, {-0.304471f, 0.085248f, 0.948699f}, {0.370609f, 0.302266f} },
    { {0.049331f, 0.215328f, 0.006931f}, {0.329310f, 0.099933f, 0.938919f}, {0.401671f, 0.330491f} },
    { {0.006670f, 0.015187f, 0.011224f}, {-0.167180f, -0.089859f, 0.981823f}, {0.364445f, 0.274069f} },
    { {0.061730f, 0.217316f, -0.162863f}, {0.777671f, 0.610329f, -0.150752f}, {0.304025f, 0.232198f} },
    { {0.032648f, 0.185631f, -0.179879f}, {-0.084656f, 0.169456f, -0.981895f}, {0.318974f, 0.220424f} },
    { {0.049617f, 0.189506f, -0.190334f}, {0.410402f, 0.091825f, -0.907270f}, {0.317079f, 0.213798f} },
    { {-0.043017f, -0.005378f, -0.018737f}, {-0.281015f, -0.950684f, 0.131265f}, {0.403176f, 0.321623f} },
    { {-0.043017f, 0.013360f, 0.000000f}, {-0.321587f, -0.025721f, 0.946531f}, {0.394898f, 0.333397f} },
    { {0.046459f, 0.014062f, 0.010445f}, {0.389880f, -0.107649f, 0.914552f}, {0.325569f, 0.339960f} },
    { {0.049331f, 0.215328f, 0.006931f}, {0.329310f, 0.099933f, 0.938919f}, {0.414485f, 0.337752f} },
    { {0.061730f, 0.217316f, -0.162863f}, {0.777671f, 0.610329f, -0.150752f}, {0.416315f, 0.232142f} },
    { {0.061906f, 0.216986f, -0.017919f}, {0.901844f, 0.429790f, 0.044244f}, {0.416315f, 0.321623f} },
    { {0.029493f, 0.238208f, -0.018737f}, {0.287631f, 0.947595f, 0.139043f}, {0.424593f, 0.321623f} },
    { {-0.043017f, -0.005378f, -0.161141f}, {-0.147403f, -0.985950f, -0.078588f}, {0.403176f, 0.232142f} },
    { {-0.029493f, 0.219470f, -0.179879f}, {-0.283223f, 0.068863f, -0.956579f}, {0.303841f, 0.220368f} },
    { {-0.043017f, 0.013360f, -0.179879f}, {-0.321952f, -0.059376f, -0.944892f}, {0.394898f, 0.220368f} },
    { {-0.056530f, 0.009536f, -0.026749f}, {-0.815625f, 0.429128f, 0.388079f}, {0.300554f, 0.240952f} },
    { {-0.056530f, 0.009536f, -0.026749f}, {-0.815625f, 0.429128f, 0.388079f}, {0.419602f, 0.316589f} },
    { {-0.056530f, 0.009536f, -0.152260f}, {-0.808876f, 0.550706f, -0.206017f}, {0.419602f, 0.237722f} },
    { {0.009966f, 0.150865f, -0.179789f}, {-0.174909f, 0.040014f, -0.983771f}, {0.334150f, 0.220424f} },
    { {-0.006762f, 0.013360f, -0.179879f}, {-0.163492f, -0.085934f, -0.982795f}, {0.364552f, 0.220424f} },
    { {0.016842f, 0.150449f, -0.190924f}, {-0.241869f, 0.058560f, -0.968540f}, {0.334334f, 0.213427f} },
    { {-0.029493f, 0.238208f, -0.161141f}, {-0.325925f, 0.933931f, -0.146787f}, {0.295564f, 0.232142f} },
    { {-0.029493f, 0.238208f, -0.018737f}, {-0.142484f, 0.987408f, 0.068724f}, {0.295564f, 0.321623f} },
    { {-0.029493f, 0.219470f, 0.000000f}, {-0.215137f, 0.150552f, 0.964909f}, {0.303841f, 0.333397f} },
    { {0.032648f, 0.185631f, -0.179879f}, {-0.084656f, 0.169456f, -0.981895f}, {0.401365f, 0.220368f} },
    { {0.029493f, 0.219470f, -0.179879f}, {0.141203f, 0.433150f, -0.890193f}, {0.416315f, 0.220368f} },
    { {0.029493f, 0.238208f, -0.161141f}, {0.142482f, 0.987099f, -0.073042f}, {0.424593f, 0.232142f} },
    { {0.016812f, 0.150458f, 0.011307f}, {-0.304471f, 0.085248f, 0.948699f}, {0.334330f, 0.340502f} },
    { {0.006670f, 0.015187f, 0.011224f}, {-0.167180f, -0.089859f, 0.981823f}, {0.394090f, 0.340450f} },
    { {0.009966f, 0.150865f, 0.000090f}, {-0.186834f, 0.015437f, 0.982270f}, {0.334150f, 0.333454f} },
    { {0.049331f, 0.215328f, 0.006931f}, {0.329310f, 0.099933f, 0.938919f}, {0.305671f, 0.337752f} },
    { {-0.048230f, 0.219470f, -0.161141f}, {-0.971543f, 0.208189f, -0.112970f}, {0.303841f, 0.232142f} },
    { {-0.056530f, 0.009536f, -0.152260f}, {-0.808876f, 0.550706f, -0.206017f}, {0.402488f, 0.239188f} },
    { {0.029493f, 0.238208f, -0.018737f}, {0.287631f, 0.947595f, 0.139043f}, {0.382721f, 0.340445f} },
    { {0.049331f, 0.215328f, 0.006931f}, {0.329310f, 0.099933f, 0.938919f}, {0.416315f, 0.333397f} },
    { {-0.029493f, 0.238208f, -0.018737f}, {-0.142484f, 0.987408f, 0.068724f}, {0.326380f, 0.340445f} },
    { {-0.029493f, 0.238208f, -0.161141f}, {-0.325925f, 0.933931f, -0.146787f}, {0.393777f, 0.340445f} },
    { {0.000048f, 0.012945f, 0.000090f}, {-0.179923f, -0.277224f, 0.943808f}, {0.395081f, 0.333454f} },
    { {0.042663f, -0.006821f, -0.016374f}, {0.063136f, -0.991707f, 0.111944f}, {0.395301f, 0.323108f} },
    { {0.000048f, 0.012945f, 0.000090f}, {-0.179923f, -0.277224f, 0.943808f}, {0.354596f, 0.333454f} },
    { {0.006670f, 0.015187f, 0.011224f}, {-0.167180f, -0.089859f, 0.981823f}, {0.360922f, 0.340450f} },
    { {0.006700f, 0.014297f, -0.190695f}, {-0.164046f, -0.103318f, -0.981027f}, {0.394484f, 0.213571f} },
    { {0.035693f, -0.011572f, -0.166098f}, {-0.325430f, -0.817136f, -0.475798f}, {0.389661f, 0.231303f} },
    { {0.006700f, 0.014297f, -0.190695f}, {-0.325430f, -0.817136f, -0.475798f}, {0.354445f, 0.213514f} },
    { {-0.006762f, 0.013360f, -0.179879f}, {-0.325430f, -0.817136f, -0.475798f}, {0.348091f, 0.220368f} },
    { {0.029493f, 0.238208f, -0.161141f}, {0.142482f, 0.987099f, -0.073042f}, {0.337435f, 0.340445f} },
};

WORD g_tind5[] = 
{
    2, 1, 0,    5, 4, 3,    6, 5, 3,    0, 1, 7,    10, 9, 8,
    13, 12, 11,    16, 15, 14,    19, 18, 17,    22, 21, 20,    25, 24, 23,
    12, 26, 11,    29, 28, 27,    30, 16, 14,    33, 32, 31,    29, 27, 34,
    37, 36, 35,    32, 38, 31,    9, 40, 39,    10, 42, 41,    43, 9, 10,
    46, 45, 44,    49, 48, 47,    52, 51, 50,    53, 49, 47,    1, 55, 54,
    56, 19, 17,    7, 1, 54,    31, 57, 33,    60, 59, 58,    24, 61, 23,
    62, 52, 50,    63, 46, 44,    58, 59, 64,    21, 65, 20,    67, 0, 66,
    69, 68, 0,    36, 29, 34,    72, 71, 70,    75, 74, 73,    69, 0, 67,
    76, 5, 6,    5, 77, 4,    79, 78, 1,    1, 78, 55,    82, 81, 80,
    2, 79, 1,    83, 76, 6,    85, 6, 84,    64, 59, 86,    88, 87, 24,
    91, 90, 89,    74, 75, 91,    4, 93, 92,    77, 94, 4,    96, 80, 95,
    97, 82, 80,    100, 99, 98,    100, 98, 101,    102, 4, 92,    6, 3, 84,
    0, 7, 66,    7, 54, 66,    88, 24, 25,    51, 103, 50,    27, 28, 104,
    82, 105, 81,    4, 94, 93,    106, 27, 104,    10, 41, 43,    83, 6, 85,
    102, 92, 84,    9, 107, 40,    36, 34, 35,    76, 77, 5,    68, 79, 2,
    68, 2, 0,    99, 100, 108,    111, 110, 109,    91, 89, 74,    8, 9, 39,
    90, 91, 112,    115, 114, 113,    107, 116, 40,    97, 80, 96,    3, 4, 102,
    3, 102, 84,
};

D3DMATRIX g_tmat6 = 
{
    0.828152f, -0.552950f, -0.091713f, 0.000000f, 
    -0.389357f, -0.449825f, -0.803778f, 0.000000f, 
    0.403194f, 0.701359f, -0.587818f, 0.000000f, 
    3.199389f, -3.014915f, 1.899158f, 1.000000f, 
};

// Mesh #6 Tris:96 Verts:128
MODELVERT g_tmesh6[] = 
{
    { {-0.037387f, 0.130414f, -0.124915f}, {-0.987603f, 0.115430f, -0.106376f}, {0.328516f, 0.234286f} },
    { {-0.037387f, 0.130414f, -0.014525f}, {-0.989338f, 0.072500f, 0.126311f}, {0.328516f, 0.319571f} },
    { {-0.044908f, 0.076245f, -0.006146f}, {-0.990068f, 0.091846f, 0.106437f}, {0.362543f, 0.326044f} },
    { {0.046677f, 0.023112f, -0.133577f}, {0.993320f, -0.042028f, -0.107463f}, {0.324238f, 0.227594f} },
    { {0.046694f, 0.130304f, -0.014098f}, {0.994373f, 0.041688f, 0.097389f}, {0.391571f, 0.319901f} },
    { {0.041920f, 0.168900f, -0.125765f}, {0.975199f, 0.140323f, -0.171162f}, {0.415816f, 0.233630f} },
    { {0.046576f, 0.021444f, -0.005586f}, {0.972365f, -0.189884f, 0.135830f}, {0.323189f, 0.326477f} },
    { {-0.044998f, 0.077181f, -0.133336f}, {-0.996087f, 0.054654f, -0.069460f}, {0.361955f, 0.227781f} },
    { {-0.003807f, 0.009398f, -0.133336f}, {-0.051932f, -0.992013f, -0.114947f}, {0.355791f, 0.227781f} },
    { {-0.002061f, 0.005435f, -0.003231f}, {-0.077621f, -0.996788f, 0.019722f}, {0.394913f, 0.326044f} },
    { {0.030599f, 0.005908f, -0.133986f}, {-0.101403f, -0.994425f, -0.028927f}, {0.399951f, 0.227788f} },
    { {0.029423f, 0.023162f, -0.151725f}, {0.150623f, -0.162858f, -0.975084f}, {0.315779f, 0.241641f} },
    { {-0.000271f, 0.076979f, -0.147851f}, {-0.164733f, 0.037804f, -0.985613f}, {0.356765f, 0.275019f} },
    { {-0.003807f, 0.023923f, -0.147861f}, {-0.112999f, -0.353336f, -0.928647f}, {0.356770f, 0.241120f} },
    { {-0.030383f, 0.076245f, 0.008379f}, {-0.384200f, 0.117068f, 0.915798f}, {0.316933f, 0.274481f} },
    { {-0.022862f, 0.130414f, 0.000000f}, {-0.224693f, 0.180775f, 0.957514f}, {0.327930f, 0.307992f} },
    { {-0.000181f, 0.076043f, 0.008388f}, {0.000029f, 0.072766f, 0.997349f}, {0.355923f, 0.274481f} },
    { {0.018244f, 0.182873f, -0.124915f}, {0.131089f, 0.989139f, -0.066483f}, {0.332125f, 0.234286f} },
    { {0.018244f, 0.182873f, -0.014525f}, {0.342506f, 0.937372f, 0.063431f}, {0.332125f, 0.319571f} },
    { {-0.027481f, 0.182873f, -0.014525f}, {-0.154776f, 0.943301f, 0.293646f}, {0.398980f, 0.319571f} },
    { {-0.000271f, 0.076979f, -0.147851f}, {0.000842f, 0.079004f, -0.996874f}, {0.364365f, 0.275060f} },
    { {-0.030473f, 0.077181f, -0.147861f}, {-0.320425f, 0.122418f, -0.939330f}, {0.403355f, 0.275060f} },
    { {-0.003807f, 0.023923f, -0.147861f}, {0.000147f, -0.112768f, -0.993621f}, {0.364365f, 0.242112f} },
    { {-0.027481f, 0.182873f, -0.124915f}, {-0.371149f, 0.721082f, -0.585055f}, {0.398980f, 0.234286f} },
    { {-0.030383f, 0.022987f, 0.008379f}, {-0.307522f, -0.113372f, 0.944763f}, {0.316933f, 0.241533f} },
    { {-0.000181f, 0.022784f, 0.008388f}, {-0.033614f, -0.286842f, 0.957388f}, {0.355923f, 0.241533f} },
    { {-0.030473f, 0.009398f, -0.133336f}, {-0.247698f, -0.965902f, -0.075357f}, {0.316801f, 0.227781f} },
    { {-0.030383f, 0.008462f, -0.006146f}, {-0.464591f, -0.877852f, 0.116327f}, {0.316933f, 0.326044f} },
    { {-0.002061f, 0.005435f, -0.003231f}, {-0.077621f, -0.996788f, 0.019722f}, {0.355923f, 0.326044f} },
    { {-0.030473f, 0.077181f, -0.147861f}, {-0.320425f, 0.122418f, -0.939330f}, {0.361955f, 0.216559f} },
    { {-0.044998f, 0.023923f, -0.133336f}, {-0.943568f, -0.301420f, -0.137205f}, {0.395410f, 0.227781f} },
    { {-0.030473f, 0.023923f, -0.147861f}, {-0.283630f, -0.283944f, -0.915931f}, {0.395410f, 0.216559f} },
    { {-0.030383f, 0.008462f, -0.006146f}, {-0.464591f, -0.877852f, 0.116327f}, {0.405122f, 0.326044f} },
    { {-0.030473f, 0.009398f, -0.133336f}, {-0.247698f, -0.965902f, -0.075357f}, {0.404534f, 0.227781f} },
    { {-0.004006f, 0.008885f, -0.124767f}, {0.015325f, 0.877965f, -0.478479f}, {0.364658f, 0.234401f} },
    { {-0.004006f, 0.008885f, -0.014703f}, {0.016801f, 0.962513f, 0.270715f}, {0.364658f, 0.319433f} },
    { {-0.040394f, 0.020010f, -0.117522f}, {-0.774058f, 0.608349f, -0.175343f}, {0.417860f, 0.239999f} },
    { {0.017454f, -0.022535f, -0.117521f}, {0.710417f, -0.662178f, -0.238385f}, {0.295564f, 0.239999f} },
    { {0.032747f, 0.018733f, -0.021530f}, {0.980614f, 0.065870f, 0.184544f}, {0.321487f, 0.314159f} },
    { {0.032747f, 0.018733f, -0.117521f}, {0.341137f, 0.916514f, -0.208874f}, {0.321487f, 0.239999f} },
    { {-0.000181f, 0.076043f, 0.008388f}, {-0.129948f, 0.077255f, 0.988506f}, {0.363522f, 0.274548f} },
    { {0.029520f, 0.076153f, 0.012284f}, {0.320756f, 0.090187f, 0.942858f}, {0.404519f, 0.274424f} },
    { {-0.000181f, 0.022784f, 0.008388f}, {-0.131796f, -0.089999f, 0.987183f}, {0.363516f, 0.241021f} },
    { {0.024992f, 0.168728f, -0.002555f}, {-0.054071f, 0.337005f, 0.939949f}, {0.388032f, 0.331459f} },
    { {0.000000f, 0.130414f, 0.000000f}, {-0.000000f, 0.117250f, 0.993102f}, {0.361357f, 0.307992f} },
    { {0.029320f, 0.021517f, 0.012177f}, {0.239114f, -0.285324f, 0.928124f}, {0.404226f, 0.240623f} },
    { {0.030599f, 0.005908f, -0.133986f}, {-0.018910f, -0.999786f, -0.008342f}, {0.399951f, 0.227788f} },
    { {-0.002061f, 0.005435f, -0.003231f}, {-0.018910f, -0.999786f, -0.008342f}, {0.394913f, 0.326044f} },
    { {0.030508f, 0.004838f, -0.005465f}, {-0.018910f, -0.999786f, -0.008342f}, {0.400083f, 0.326051f} },
    { {-0.004006f, 0.008885f, -0.124767f}, {0.015325f, 0.877965f, -0.478479f}, {0.364658f, 0.232809f} },
    { {-0.040394f, 0.020010f, -0.117522f}, {-0.774058f, 0.608349f, -0.175343f}, {0.401394f, 0.237561f} },
    { {-0.026550f, -0.021767f, -0.117521f}, {-0.389644f, -0.889579f, -0.238384f}, {0.397619f, 0.213846f} },
    { {-0.040394f, 0.020010f, -0.117522f}, {-0.774058f, 0.608349f, -0.175343f}, {0.397868f, 0.239999f} },
    { {-0.026550f, -0.021767f, -0.021530f}, {-0.733362f, -0.636451f, 0.238978f}, {0.424111f, 0.314159f} },
    { {-0.026550f, -0.021767f, -0.117521f}, {-0.389644f, -0.889579f, -0.238384f}, {0.424111f, 0.239999f} },
    { {0.017454f, -0.022536f, -0.021530f}, {0.357770f, -0.902713f, 0.238977f}, {0.295564f, 0.314159f} },
    { {-0.040394f, 0.020010f, -0.021530f}, {-0.792979f, 0.508455f, 0.335645f}, {0.397868f, 0.314159f} },
    { {0.018244f, 0.168348f, -0.133102f}, {-0.099037f, 0.292615f, -0.951088f}, {0.332125f, 0.331459f} },
    { {-0.027481f, 0.182873f, -0.124915f}, {-0.371149f, 0.721082f, -0.585055f}, {0.398980f, 0.340445f} },
    { {0.003536f, 0.130212f, -0.139431f}, {-0.075916f, 0.198080f, -0.977242f}, {0.358799f, 0.307992f} },
    { {0.029464f, 0.077287f, -0.151718f}, {0.425061f, 0.090585f, -0.900620f}, {0.315720f, 0.275125f} },
    { {0.024275f, 0.168885f, -0.137055f}, {0.234455f, 0.573196f, -0.785161f}, {0.323307f, 0.331792f} },
    { {0.005199f, 0.130773f, -0.143513f}, {-0.148016f, 0.149507f, -0.977619f}, {0.351198f, 0.308214f} },
    { {0.029464f, 0.077287f, -0.151718f}, {0.425061f, 0.090585f, -0.900620f}, {0.358268f, 0.213580f} },
    { {0.030599f, 0.005908f, -0.133986f}, {0.621758f, -0.758668f, -0.194524f}, {0.314060f, 0.230967f} },
    { {-0.030473f, 0.023923f, -0.147861f}, {-0.283630f, -0.283944f, -0.915931f}, {0.403355f, 0.242112f} },
    { {-0.003807f, 0.009398f, -0.133336f}, {-0.084773f, -0.704561f, -0.704561f}, {0.356794f, 0.231129f} },
    { {0.029520f, 0.076153f, 0.012284f}, {0.320756f, 0.090187f, 0.942858f}, {0.357556f, 0.340282f} },
    { {0.024275f, 0.168885f, -0.137055f}, {0.662712f, 0.745716f, -0.068707f}, {0.415469f, 0.234286f} },
    { {0.042049f, 0.168647f, -0.014254f}, {0.512987f, 0.858395f, -0.001732f}, {0.415469f, 0.319571f} },
    { {0.018244f, 0.182873f, -0.014525f}, {0.342506f, 0.937372f, 0.063431f}, {0.424593f, 0.319571f} },
    { {0.017454f, -0.022536f, -0.021530f}, {0.357770f, -0.902713f, 0.238977f}, {0.386877f, 0.213371f} },
    { {-0.004006f, 0.008885f, -0.014703f}, {0.016801f, 0.962513f, 0.270715f}, {0.355499f, 0.232809f} },
    { {0.032747f, 0.018733f, -0.021530f}, {0.980614f, 0.065870f, 0.184544f}, {0.392605f, 0.237016f} },
    { {0.032747f, 0.018733f, -0.117521f}, {0.341137f, 0.916514f, -0.208874f}, {0.310920f, 0.239999f} },
    { {0.032747f, 0.018733f, -0.021530f}, {0.980614f, 0.065870f, 0.184544f}, {0.310920f, 0.314159f} },
    { {0.017454f, -0.022535f, -0.117521f}, {0.710417f, -0.662178f, -0.238385f}, {0.333280f, 0.213371f} },
    { {-0.026550f, -0.021767f, -0.117521f}, {-0.389644f, -0.889579f, -0.238384f}, {0.322537f, 0.239999f} },
    { {0.017454f, -0.022536f, -0.021530f}, {0.357770f, -0.902713f, 0.238977f}, {0.386877f, 0.314159f} },
    { {0.017454f, -0.022535f, -0.117521f}, {0.710417f, -0.662178f, -0.238385f}, {0.386877f, 0.239999f} },
    { {-0.026550f, -0.021767f, -0.021530f}, {-0.733362f, -0.636451f, 0.238978f}, {0.322537f, 0.213846f} },
    { {-0.026550f, -0.021767f, -0.021530f}, {-0.733362f, -0.636451f, 0.238978f}, {0.322537f, 0.314159f} },
    { {-0.002061f, 0.005435f, -0.003231f}, {-0.038537f, -0.651064f, 0.758044f}, {0.363514f, 0.230549f} },
    { {-0.030383f, 0.008462f, -0.006146f}, {-0.464591f, -0.877852f, 0.116327f}, {0.316933f, 0.232547f} },
    { {-0.002061f, 0.005435f, -0.003231f}, {-0.077621f, -0.996788f, 0.019722f}, {0.355923f, 0.232547f} },
    { {-0.044908f, 0.022987f, -0.006146f}, {-0.990446f, -0.124468f, 0.059372f}, {0.395998f, 0.326044f} },
    { {-0.030383f, 0.076245f, 0.008379f}, {-0.384200f, 0.117068f, 0.915798f}, {0.362543f, 0.337265f} },
    { {0.042049f, 0.168647f, -0.014254f}, {0.874007f, 0.470563f, 0.121170f}, {0.297319f, 0.319780f} },
    { {0.024275f, 0.168885f, -0.137055f}, {0.234455f, 0.573196f, -0.785161f}, {0.323307f, 0.224908f} },
    { {0.041920f, 0.168900f, -0.125765f}, {0.975199f, 0.140323f, -0.171162f}, {0.297507f, 0.233630f} },
    { {0.024275f, 0.168885f, -0.137055f}, {0.234455f, 0.573196f, -0.785161f}, {0.415807f, 0.224908f} },
    { {0.030599f, 0.005908f, -0.133986f}, {0.621758f, -0.758668f, -0.194524f}, {0.313431f, 0.227279f} },
    { {0.029423f, 0.023162f, -0.151725f}, {0.150623f, -0.162858f, -0.975084f}, {0.324269f, 0.213574f} },
    { {-0.003807f, 0.009398f, -0.133336f}, {-0.051932f, -0.992013f, -0.114947f}, {0.364365f, 0.233126f} },
    { {-0.040394f, 0.020010f, -0.021530f}, {-0.792979f, 0.508455f, 0.335645f}, {0.318762f, 0.237561f} },
    { {-0.040394f, 0.020010f, -0.021530f}, {-0.792979f, 0.508455f, 0.335645f}, {0.417860f, 0.314159f} },
    { {0.000000f, 0.130414f, 0.000000f}, {-0.130137f, 0.151037f, 0.979925f}, {0.368960f, 0.308212f} },
    { {0.024992f, 0.168728f, -0.002555f}, {0.328801f, 0.152419f, 0.932018f}, {0.397898f, 0.331695f} },
    { {0.024992f, 0.168728f, -0.002555f}, {0.328801f, 0.152419f, 0.932018f}, {0.415708f, 0.328819f} },
    { {0.029320f, 0.021517f, 0.012177f}, {0.239114f, -0.285324f, 0.928124f}, {0.323235f, 0.340199f} },
    { {0.030508f, 0.004838f, -0.005465f}, {0.629426f, -0.748491f, 0.208768f}, {0.312758f, 0.326570f} },
    { {0.018244f, 0.182873f, -0.124915f}, {0.131089f, 0.989139f, -0.066483f}, {0.332125f, 0.340445f} },
    { {0.018244f, 0.182873f, -0.124915f}, {0.131089f, 0.989139f, -0.066483f}, {0.424593f, 0.234286f} },
    { {-0.030383f, 0.022987f, 0.008379f}, {-0.307522f, -0.113372f, 0.944763f}, {0.395998f, 0.337265f} },
    { {-0.022862f, 0.130414f, 0.000000f}, {-0.224693f, 0.180775f, 0.957514f}, {0.328516f, 0.330792f} },
    { {-0.027481f, 0.182873f, -0.124915f}, {-0.371149f, 0.721082f, -0.585055f}, {0.295564f, 0.234286f} },
    { {-0.027481f, 0.182873f, -0.014525f}, {-0.154776f, 0.943301f, 0.293646f}, {0.295564f, 0.319571f} },
    { {-0.037649f, 0.169679f, -0.014525f}, {-0.950033f, 0.279916f, 0.138146f}, {0.303851f, 0.319571f} },
    { {0.032747f, 0.018733f, -0.117521f}, {0.341137f, 0.916514f, -0.208874f}, {0.327551f, 0.237016f} },
    { {-0.027481f, 0.182873f, -0.124915f}, {-0.371149f, 0.721082f, -0.585055f}, {0.304407f, 0.227962f} },
    { {-0.037649f, 0.169679f, -0.124915f}, {-0.993740f, 0.104492f, -0.039521f}, {0.303851f, 0.234286f} },
    { {0.030508f, 0.004838f, -0.005465f}, {0.629426f, -0.748491f, 0.208768f}, {0.405963f, 0.230305f} },
    { {0.018244f, 0.182873f, -0.014525f}, {0.342506f, 0.937372f, 0.063431f}, {0.388032f, 0.340445f} },
    { {-0.027481f, 0.182873f, -0.014525f}, {-0.154776f, 0.943301f, 0.293646f}, {0.321176f, 0.340445f} },
    { {0.024992f, 0.168728f, -0.002555f}, {-0.054071f, 0.337005f, 0.939949f}, {0.415469f, 0.325896f} },
    { {-0.030473f, 0.009398f, -0.133336f}, {-0.247698f, -0.965902f, -0.075357f}, {0.403355f, 0.233126f} },
    { {0.018244f, 0.168348f, -0.133102f}, {-0.099037f, 0.292615f, -0.951088f}, {0.415469f, 0.227962f} },
    { {0.005199f, 0.130773f, -0.143513f}, {-0.528470f, 0.392088f, -0.752985f}, {0.328164f, 0.219911f} },
    { {0.024275f, 0.168885f, -0.137055f}, {-0.528470f, 0.392088f, -0.752985f}, {0.304223f, 0.224900f} },
    { {0.018244f, 0.168348f, -0.133102f}, {-0.528470f, 0.392088f, -0.752985f}, {0.304688f, 0.227962f} },
    { {0.042049f, 0.168647f, -0.014254f}, {0.874007f, 0.470563f, 0.121170f}, {0.415657f, 0.319780f} },
    { {-0.037649f, 0.169679f, -0.014525f}, {-0.950033f, 0.279916f, 0.138146f}, {0.306310f, 0.332283f} },
    { {0.018244f, 0.168348f, -0.133102f}, {-0.871550f, 0.386249f, -0.302014f}, {0.304815f, 0.227969f} },
    { {0.003536f, 0.130212f, -0.139431f}, {-0.910273f, 0.239023f, -0.338041f}, {0.328643f, 0.223072f} },
    { {0.005199f, 0.130773f, -0.143513f}, {-0.148016f, 0.149507f, -0.977619f}, {0.328291f, 0.219919f} },
    { {-0.000271f, 0.076979f, -0.147851f}, {-0.164733f, 0.037804f, -0.985613f}, {0.362082f, 0.216567f} },
    { {-0.037649f, 0.169679f, -0.124915f}, {-0.993740f, 0.104492f, -0.039521f}, {0.413847f, 0.332283f} },
    { {-0.037387f, 0.130414f, -0.124915f}, {-0.987603f, 0.115430f, -0.106376f}, {0.413465f, 0.307992f} },
};

WORD g_tind6[] = 
{
    2, 1, 0,    5, 4, 3,    4, 6, 3,    7, 2, 0,    10, 9, 8,
    13, 12, 11,    16, 15, 14,    19, 18, 17,    22, 21, 20,    23, 19, 17,
    25, 16, 24,    28, 27, 26,    31, 30, 29,    33, 32, 30,    36, 35, 34,
    39, 38, 37,    42, 41, 40,    44, 43, 15,    45, 41, 42,    48, 47, 46,
    51, 50, 49,    54, 53, 52,    38, 55, 37,    53, 56, 52,    59, 58, 57,
    62, 61, 60,    5, 3, 63,    11, 64, 13,    65, 21, 22,    13, 64, 66,
    4, 67, 6,    70, 69, 68,    73, 72, 71,    35, 75, 74,    76, 51, 49,
    79, 78, 77,    71, 72, 80,    78, 81, 77,    82, 45, 42,    84, 25, 83,
    32, 85, 30,    2, 86, 1,    7, 0, 29,    21, 58, 59,    89, 88, 87,
    90, 5, 63,    3, 6, 91,    3, 91, 92,    22, 93, 65,    8, 28, 26,
    80, 72, 94,    36, 95, 35,    41, 97, 96,    98, 67, 4,    67, 99, 6,
    6, 100, 91,    58, 101, 57,    102, 70, 68,    40, 41, 96,    16, 44, 15,
    25, 24, 83,    32, 103, 85,    86, 104, 1,    107, 106, 105,    12, 60, 11,
    63, 3, 92,    20, 21, 59,    12, 62, 60,    34, 35, 74,    108, 76, 49,
    29, 0, 109,    110, 107, 105,    111, 45, 82,    6, 99, 100,    113, 43, 112,
    70, 114, 69,    93, 115, 65,    33, 30, 31,    30, 85, 7,    30, 7, 29,
    102, 68, 116,    119, 118, 117,    16, 14, 24,    103, 86, 2,    120, 98, 4,
    120, 4, 5,    43, 113, 15,    15, 113, 121,    85, 103, 2,    85, 2, 7,
    124, 123, 122,    123, 124, 125,    1, 104, 107,    1, 107, 110,    0, 1, 110,
    127, 126, 58,
};

D3DMATRIX g_tmat7 = 
{
    0.791192f, -0.589941f, -0.161200f, 0.000000f, 
    -0.459837f, -0.400083f, -0.792770f, 0.000000f, 
    0.403194f, 0.701359f, -0.587818f, 0.000000f, 
    3.125393f, -3.101635f, 1.753837f, 1.000000f, 
};

// Mesh #7 Tris:74 Verts:95
MODELVERT g_tmesh7[] = 
{
    { {-0.028660f, 0.022378f, -0.099933f}, {-0.959203f, -0.254396f, -0.123342f}, {0.399661f, 0.228668f} },
    { {-0.038275f, 0.106688f, -0.021795f}, {-0.991157f, -0.034085f, 0.128240f}, {0.330727f, 0.313958f} },
    { {-0.028660f, 0.022377f, -0.011620f}, {-0.961998f, -0.249094f, 0.111860f}, {0.399661f, 0.325064f} },
    { {0.038098f, 0.022271f, -0.100091f}, {0.992864f, 0.056486f, -0.105030f}, {0.320408f, 0.228495f} },
    { {0.038015f, 0.021746f, -0.011202f}, {0.957103f, -0.233257f, 0.171885f}, {0.319979f, 0.325520f} },
    { {0.031893f, 0.065474f, -0.010799f}, {0.968061f, 0.170780f, 0.183555f}, {0.355732f, 0.325960f} },
    { {-0.038374f, 0.107393f, -0.094738f}, {-0.977200f, -0.010134f, -0.212081f}, {0.330150f, 0.234339f} },
    { {0.026074f, 0.107156f, -0.020049f}, {0.976585f, 0.205815f, 0.062628f}, {0.389813f, 0.315864f} },
    { {0.025912f, 0.107848f, -0.096052f}, {0.944167f, 0.244383f, -0.220965f}, {0.390378f, 0.232904f} },
    { {0.017843f, 0.107867f, -0.095511f}, {0.962226f, 0.242439f, -0.123871f}, {0.390394f, 0.233495f} },
    { {0.026074f, 0.107156f, -0.020049f}, {0.906475f, 0.378518f, 0.187157f}, {0.389921f, 0.315671f} },
    { {0.014326f, 0.136946f, -0.026711f}, {0.926401f, 0.374852f, 0.035590f}, {0.414170f, 0.308592f} },
    { {-0.024591f, 0.109598f, -0.010116f}, {-0.279673f, 0.185086f, 0.942086f}, {0.319766f, 0.308158f} },
    { {0.002368f, 0.139351f, -0.015699f}, {0.070784f, 0.478823f, 0.875053f}, {0.367105f, 0.332117f} },
    { {0.008958f, 0.108730f, -0.009204f}, {0.096942f, 0.254954f, 0.962081f}, {0.373424f, 0.308235f} },
    { {0.014171f, 0.138048f, -0.092316f}, {0.890795f, 0.422421f, -0.167466f}, {0.415071f, 0.236982f} },
    { {0.018684f, 0.066351f, -0.113670f}, {-0.089613f, 0.077195f, -0.992981f}, {0.336170f, 0.273605f} },
    { {-0.024513f, 0.109038f, -0.106453f}, {-0.321325f, 0.065073f, -0.944730f}, {0.400252f, 0.307707f} },
    { {-0.017040f, 0.022378f, -0.111553f}, {-0.325710f, -0.012423f, -0.945388f}, {0.387131f, 0.237925f} },
    { {-0.011361f, 0.007672f, -0.100085f}, {0.014825f, -0.996776f, -0.078854f}, {0.342998f, 0.228501f} },
    { {0.024360f, 0.008168f, -0.011433f}, {0.177255f, -0.981035f, 0.078431f}, {0.405723f, 0.325268f} },
    { {0.024819f, 0.008309f, -0.100285f}, {0.360263f, -0.916253f, -0.175189f}, {0.406529f, 0.228284f} },
    { {0.024823f, 0.021972f, -0.113889f}, {0.199032f, -0.200200f, -0.959326f}, {0.313620f, 0.237598f} },
    { {0.018684f, 0.066351f, -0.113670f}, {0.462851f, 0.119250f, -0.878378f}, {0.324400f, 0.273334f} },
    { {-0.017040f, 0.022378f, -0.111553f}, {-0.043709f, -0.316802f, -0.947484f}, {0.377162f, 0.236843f} },
    { {-0.016928f, -0.007972f, -0.092014f}, {-0.374450f, -0.913549f, -0.158793f}, {0.333222f, 0.237312f} },
    { {0.015914f, -0.008102f, -0.015460f}, {0.341143f, -0.853440f, 0.394033f}, {0.390892f, 0.320873f} },
    { {0.015916f, -0.008115f, -0.092014f}, {0.687144f, -0.610534f, -0.393803f}, {0.390895f, 0.237312f} },
    { {0.026924f, 0.022829f, -0.092014f}, {0.298041f, 0.931216f, -0.209784f}, {0.309931f, 0.237312f} },
    { {-0.027668f, 0.023080f, -0.015460f}, {-0.280441f, 0.903306f, 0.324640f}, {0.405793f, 0.320873f} },
    { {-0.027666f, 0.023067f, -0.092014f}, {-0.787009f, 0.421429f, -0.450571f}, {0.405790f, 0.237312f} },
    { {-0.027666f, 0.023067f, -0.092014f}, {-0.787009f, 0.421429f, -0.450571f}, {0.399098f, 0.237312f} },
    { {-0.027668f, 0.023080f, -0.015460f}, {-0.280441f, 0.903306f, 0.324640f}, {0.399087f, 0.320873f} },
    { {-0.016930f, -0.007959f, -0.015460f}, {-0.743732f, -0.649287f, 0.159024f}, {0.424465f, 0.320873f} },
    { {0.015916f, -0.008115f, -0.092014f}, {0.687144f, -0.610534f, -0.393803f}, {0.295564f, 0.237312f} },
    { {0.015914f, -0.008102f, -0.015460f}, {0.341143f, -0.853440f, 0.394033f}, {0.295574f, 0.320873f} },
    { {0.026922f, 0.022842f, -0.015460f}, {0.844733f, 0.442899f, 0.300444f}, {0.320875f, 0.320873f} },
    { {-0.011406f, 0.007714f, -0.011121f}, {0.001678f, -0.967435f, 0.253115f}, {0.342918f, 0.325609f} },
    { {-0.017040f, 0.022377f, 0.000000f}, {-0.059876f, -0.188282f, 0.980288f}, {0.342968f, 0.237051f} },
    { {0.018469f, 0.067712f, 0.002228f}, {0.409762f, 0.106529f, 0.905951f}, {0.395379f, 0.274430f} },
    { {0.024480f, 0.021596f, 0.002386f}, {0.166657f, -0.269949f, 0.948342f}, {0.405934f, 0.237296f} },
    { {0.002561f, 0.149597f, -0.090944f}, {-0.119100f, 0.991420f, -0.053873f}, {0.295564f, 0.238739f} },
    { {0.002747f, 0.148270f, -0.029496f}, {0.165145f, 0.979830f, 0.112521f}, {0.296680f, 0.305025f} },
    { {-0.033380f, 0.136797f, -0.028121f}, {-0.560507f, 0.792602f, 0.240030f}, {0.306109f, 0.307053f} },
    { {0.002368f, 0.139351f, -0.015699f}, {0.070784f, 0.478823f, 0.875053f}, {0.303181f, 0.319853f} },
    { {-0.024591f, 0.109598f, -0.010116f}, {-0.279673f, 0.185086f, 0.942086f}, {0.328348f, 0.326706f} },
    { {-0.033550f, 0.138012f, -0.091621f}, {-0.832409f, 0.543603f, -0.107662f}, {0.305115f, 0.237740f} },
    { {-0.024513f, 0.109038f, -0.106453f}, {-0.321325f, 0.065073f, -0.944730f}, {0.328805f, 0.221551f} },
    { {0.015914f, -0.008102f, -0.015460f}, {0.341143f, -0.853440f, 0.394033f}, {0.390892f, 0.213381f} },
    { {-0.027668f, 0.023080f, -0.015460f}, {-0.280441f, 0.903306f, 0.324640f}, {0.329179f, 0.236510f} },
    { {0.026922f, 0.022842f, -0.015460f}, {0.844733f, 0.442899f, 0.300444f}, {0.395370f, 0.236378f} },
    { {0.026922f, 0.022842f, -0.015460f}, {0.844733f, 0.442899f, 0.300444f}, {0.309934f, 0.320873f} },
    { {-0.011406f, 0.007714f, -0.011121f}, {-0.647782f, -0.760785f, 0.039808f}, {0.409162f, 0.325064f} },
    { {-0.011406f, 0.007714f, -0.011121f}, {0.001678f, -0.967435f, 0.253115f}, {0.342918f, 0.226117f} },
    { {-0.027666f, 0.023067f, -0.092014f}, {-0.787009f, 0.421429f, -0.450571f}, {0.390975f, 0.236500f} },
    { {-0.016928f, -0.007972f, -0.092014f}, {-0.374450f, -0.913549f, -0.158793f}, {0.386934f, 0.213486f} },
    { {0.015916f, -0.008115f, -0.092014f}, {0.687144f, -0.610534f, -0.393803f}, {0.329261f, 0.213371f} },
    { {-0.016928f, -0.007972f, -0.092014f}, {-0.374450f, -0.913549f, -0.158793f}, {0.424476f, 0.237312f} },
    { {0.006055f, 0.109061f, -0.106898f}, {0.185380f, 0.143989f, -0.972060f}, {0.391370f, 0.221065f} },
    { {0.002383f, 0.139242f, -0.103703f}, {0.372815f, 0.367480f, -0.852037f}, {0.416047f, 0.224553f} },
    { {-0.013316f, 0.140325f, -0.103361f}, {-0.286277f, 0.348830f, -0.892392f}, {0.303224f, 0.224926f} },
    { {0.018469f, 0.067712f, 0.002228f}, {-0.138630f, 0.146143f, 0.979502f}, {0.383649f, 0.274707f} },
    { {0.026924f, 0.022829f, -0.092014f}, {0.298041f, 0.931216f, -0.209784f}, {0.324783f, 0.236367f} },
    { {0.026924f, 0.022829f, -0.092014f}, {0.298041f, 0.931216f, -0.209784f}, {0.320864f, 0.237312f} },
    { {0.018684f, 0.066351f, -0.113670f}, {0.462851f, 0.119250f, -0.878378f}, {0.356449f, 0.213673f} },
    { {0.006055f, 0.109061f, -0.106898f}, {0.185380f, 0.143989f, -0.972060f}, {0.346577f, 0.307726f} },
    { {-0.016930f, -0.007959f, -0.015460f}, {-0.743732f, -0.649287f, 0.159024f}, {0.333219f, 0.213497f} },
    { {-0.016930f, -0.007959f, -0.015460f}, {-0.743732f, -0.649287f, 0.159024f}, {0.333219f, 0.320873f} },
    { {-0.011361f, 0.007672f, -0.100085f}, {-0.646250f, -0.759467f, -0.074633f}, {0.409162f, 0.228668f} },
    { {-0.011361f, 0.007672f, -0.100085f}, {0.014825f, -0.996776f, -0.078854f}, {0.377158f, 0.226083f} },
    { {0.024819f, 0.008309f, -0.100285f}, {0.360263f, -0.916253f, -0.175189f}, {0.313627f, 0.226596f} },
    { {-0.017040f, 0.022377f, 0.000000f}, {-0.440618f, 0.031596f, 0.897138f}, {0.333026f, 0.237925f} },
    { {-0.017040f, 0.022377f, 0.000000f}, {-0.440618f, 0.031596f, 0.897138f}, {0.399661f, 0.337748f} },
    { {0.024819f, 0.008309f, -0.100285f}, {0.360263f, -0.916253f, -0.175189f}, {0.308992f, 0.228284f} },
    { {0.024823f, 0.021972f, -0.113889f}, {0.199032f, -0.200200f, -0.959326f}, {0.320163f, 0.213434f} },
    { {0.002368f, 0.139351f, -0.015699f}, {0.070784f, 0.478823f, 0.875053f}, {0.416136f, 0.320612f} },
    { {0.006055f, 0.109061f, -0.106898f}, {0.463665f, 0.362941f, -0.808263f}, {0.391350f, 0.219060f} },
    { {0.024480f, 0.021596f, 0.002386f}, {0.166657f, -0.269949f, 0.948342f}, {0.319857f, 0.340352f} },
    { {0.018469f, 0.067712f, 0.002228f}, {0.409762f, 0.106529f, 0.905951f}, {0.357562f, 0.340179f} },
    { {0.024360f, 0.008168f, -0.011433f}, {0.177255f, -0.981035f, 0.078431f}, {0.308877f, 0.325268f} },
    { {0.008958f, 0.108730f, -0.009204f}, {0.096942f, 0.254954f, 0.962081f}, {0.391887f, 0.327691f} },
    { {0.008958f, 0.108730f, -0.009204f}, {0.610797f, 0.296802f, 0.734054f}, {0.391957f, 0.329702f} },
    { {-0.017040f, 0.022378f, -0.111553f}, {-0.325710f, -0.012423f, -0.945388f}, {0.399661f, 0.215984f} },
    { {-0.013316f, 0.140325f, -0.103361f}, {-0.286277f, 0.348830f, -0.892392f}, {0.380591f, 0.332901f} },
    { {0.002747f, 0.148270f, -0.029496f}, {0.165145f, 0.979830f, 0.112521f}, {0.423429f, 0.305552f} },
    { {0.002561f, 0.149597f, -0.090944f}, {-0.119100f, 0.991420f, -0.053873f}, {0.424513f, 0.238480f} },
    { {-0.033550f, 0.138012f, -0.091621f}, {-0.832409f, 0.543603f, -0.107662f}, {0.416123f, 0.331038f} },
    { {-0.038374f, 0.107393f, -0.094738f}, {-0.977200f, -0.010134f, -0.212081f}, {0.424593f, 0.306382f} },
    { {0.024360f, 0.008168f, -0.011433f}, {0.177255f, -0.981035f, 0.078431f}, {0.405723f, 0.226483f} },
    { {0.026074f, 0.107156f, -0.020049f}, {0.976585f, 0.205815f, 0.062628f}, {0.311424f, 0.315864f} },
    { {0.017843f, 0.107867f, -0.095511f}, {0.003725f, 0.999771f, 0.021068f}, {0.320624f, 0.233505f} },
    { {0.025912f, 0.107848f, -0.096052f}, {0.944167f, 0.244383f, -0.220965f}, {0.311708f, 0.232904f} },
    { {0.006055f, 0.109061f, -0.106898f}, {0.463665f, 0.362941f, -0.808263f}, {0.333767f, 0.219060f} },
    { {0.002383f, 0.139242f, -0.103703f}, {0.372815f, 0.367480f, -0.852037f}, {0.353024f, 0.332029f} },
    { {0.002561f, 0.149597f, -0.090944f}, {-0.119100f, 0.991420f, -0.053873f}, {0.352712f, 0.340367f} },
};

WORD g_tind7[] = 
{
    2, 1, 0,    5, 4, 3,    0, 1, 6,    8, 7, 3,    11, 10, 9,
    14, 13, 12,    15, 11, 9,    18, 17, 16,    21, 20, 19,    24, 23, 22,
    27, 26, 25,    30, 29, 28,    33, 32, 31,    36, 35, 34,    20, 37, 19,
    40, 39, 38,    43, 42, 41,    45, 44, 43,    46, 43, 41,    0, 6, 47,
    50, 49, 48,    29, 51, 28,    52, 2, 0,    40, 38, 53,    56, 55, 54,
    57, 33, 31,    59, 15, 58,    46, 41, 60,    7, 5, 3,    61, 14, 12,
    62, 56, 54,    63, 36, 34,    8, 3, 64,    17, 65, 16,    48, 49, 66,
    26, 67, 25,    68, 52, 0,    70, 69, 24,    61, 12, 71,    72, 45, 1,
    3, 4, 73,    64, 3, 74,    11, 75, 10,    43, 44, 42,    15, 9, 58,
    76, 8, 64,    78, 77, 4,    4, 79, 73,    75, 80, 10,    7, 81, 5,
    82, 0, 47,    68, 0, 82,    1, 45, 43,    1, 43, 46,    81, 78, 5,
    5, 78, 4,    47, 6, 60,    17, 83, 65,    22, 70, 24,    3, 73, 74,
    52, 72, 2,    2, 72, 1,    85, 84, 15,    85, 15, 59,    84, 75, 11,
    84, 11, 15,    6, 1, 46,    87, 86, 83,    88, 40, 53,    4, 77, 79,
    91, 90, 89,    90, 91, 92,    83, 94, 93,    83, 93, 65,
};

D3DMATRIX g_tmat8 = 
{
    0.926815f, 0.375228f, -0.014807f, 0.000000f, 
    0.080321f, -0.236602f, -0.968281f, 0.000000f, 
    -0.366829f, 0.896228f, -0.249425f, 0.000000f, 
    3.110476f, -2.658877f, 2.033078f, 1.000000f, 
};

// Mesh #8 Tris:86 Verts:117
MODELVERT g_tmesh8[] = 
{
    { {-0.048229f, 0.150767f, -0.161142f}, {-0.995966f, 0.065353f, -0.061480f}, {0.334194f, 0.232142f} },
    { {-0.048229f, 0.219470f, -0.018738f}, {-0.979463f, 0.151365f, 0.133198f}, {0.303841f, 0.321623f} },
    { {-0.061753f, 0.013360f, -0.018738f}, {-0.998084f, 0.019424f, 0.058738f}, {0.394898f, 0.321623f} },
    { {0.078142f, 0.155741f, -0.162318f}, {0.991117f, 0.044735f, -0.125243f}, {0.388161f, 0.231402f} },
    { {0.071062f, 0.012627f, -0.016944f}, {0.962098f, -0.209551f, 0.174514f}, {0.324935f, 0.322750f} },
    { {0.078155f, 0.155521f, -0.017337f}, {0.986528f, 0.049434f, 0.155946f}, {0.388063f, 0.322504f} },
    { {-0.061753f, 0.013360f, -0.161141f}, {-0.978362f, -0.100482f, -0.180862f}, {0.394898f, 0.232142f} },
    { {0.071647f, 0.014228f, -0.161770f}, {0.959667f, -0.240908f, -0.144924f}, {0.325642f, 0.231747f} },
    { {0.009036f, 0.150921f, -0.179801f}, {-0.170725f, 0.045420f, -0.984271f}, {0.362592f, 0.302624f} },
    { {-0.029491f, 0.219470f, -0.179879f}, {-0.280784f, 0.068242f, -0.957342f}, {0.393777f, 0.332293f} },
    { {-0.006761f, 0.013360f, -0.179879f}, {-0.165380f, -0.089067f, -0.982200f}, {0.372065f, 0.242616f} },
    { {0.029494f, 0.238208f, -0.161142f}, {0.143003f, 0.987044f, -0.072764f}, {0.337435f, 0.232142f} },
    { {-0.029491f, 0.238208f, -0.018738f}, {-0.142484f, 0.987408f, 0.068724f}, {0.393777f, 0.321623f} },
    { {-0.029491f, 0.238208f, -0.161142f}, {-0.325925f, 0.933931f, -0.146787f}, {0.393777f, 0.232142f} },
    { {-0.043016f, -0.005378f, -0.161141f}, {-0.143209f, -0.986418f, -0.080435f}, {0.313461f, 0.232142f} },
    { {-0.043016f, -0.005378f, -0.018738f}, {-0.282715f, -0.950257f, 0.130706f}, {0.313461f, 0.321623f} },
    { {0.041732f, -0.006764f, -0.016387f}, {0.066977f, -0.991670f, 0.110025f}, {0.382721f, 0.321623f} },
    { {-0.043016f, 0.013360f, -0.000000f}, {-0.325536f, -0.025365f, 0.945189f}, {0.313461f, 0.242616f} },
    { {0.009035f, 0.150921f, 0.000077f}, {-0.189726f, 0.015945f, 0.981708f}, {0.357565f, 0.302624f} },
    { {-0.000883f, 0.013002f, 0.000077f}, {-0.182469f, -0.278443f, 0.942961f}, {0.348091f, 0.242616f} },
    { {-0.029491f, 0.219470f, -0.000000f}, {-0.217649f, 0.151833f, 0.964145f}, {0.326380f, 0.332293f} },
    { {0.029494f, 0.238208f, -0.018738f}, {0.290677f, 0.946542f, 0.139873f}, {0.337435f, 0.321623f} },
    { {0.035840f, -0.010795f, -0.165603f}, {0.246316f, -0.961730f, -0.120017f}, {0.382721f, 0.232142f} },
    { {0.045499f, 0.015062f, -0.190267f}, {0.410852f, -0.107217f, -0.905376f}, {0.322148f, 0.243357f} },
    { {0.015911f, 0.150506f, -0.190937f}, {-0.211573f, 0.066188f, -0.975118f}, {0.350410f, 0.302287f} },
    { {0.005770f, 0.014353f, -0.190708f}, {-0.167212f, -0.107527f, -0.980040f}, {0.360097f, 0.243048f} },
    { {0.035840f, -0.010795f, -0.165603f}, {0.246316f, -0.961730f, -0.120017f}, {0.314588f, 0.229338f} },
    { {0.041732f, -0.006764f, -0.016387f}, {0.066977f, -0.991670f, 0.110025f}, {0.316368f, 0.323100f} },
    { {0.005740f, 0.015244f, 0.011211f}, {-0.167179f, -0.089858f, 0.981823f}, {0.360032f, 0.243436f} },
    { {0.048401f, 0.215385f, 0.006919f}, {0.330143f, 0.099083f, 0.938716f}, {0.404219f, 0.304322f} },
    { {0.045529f, 0.014118f, 0.010433f}, {0.389880f, -0.107648f, 0.914552f}, {0.398037f, 0.242946f} },
    { {0.045499f, 0.015062f, -0.190267f}, {0.410852f, -0.107217f, -0.905376f}, {0.326011f, 0.213840f} },
    { {0.053222f, 0.155336f, -0.189803f}, {0.422483f, 0.081365f, -0.902711f}, {0.387981f, 0.214132f} },
    { {0.038528f, 0.185273f, -0.179801f}, {0.040988f, 0.146677f, -0.988335f}, {0.334421f, 0.317570f} },
    { {0.029494f, 0.219470f, -0.179879f}, {0.141665f, 0.444002f, -0.884756f}, {0.337436f, 0.332293f} },
    { {-0.056529f, 0.009535f, -0.152260f}, {-0.976008f, 0.022786f, -0.216539f}, {0.396587f, 0.237722f} },
    { {-0.030163f, -0.053857f, -0.026749f}, {-0.675225f, -0.682567f, 0.279595f}, {0.424593f, 0.316589f} },
    { {-0.030163f, -0.053857f, -0.152260f}, {-0.320831f, -0.905175f, -0.278792f}, {0.424593f, 0.237722f} },
    { {0.038384f, -0.049965f, -0.152260f}, {0.747916f, -0.602410f, -0.278792f}, {0.297283f, 0.237722f} },
    { {0.057404f, 0.016005f, -0.026749f}, {0.966868f, 0.134286f, 0.217105f}, {0.326427f, 0.316589f} },
    { {0.057404f, 0.016005f, -0.152260f}, {0.270247f, 0.931382f, -0.243916f}, {0.326427f, 0.237722f} },
    { {-0.043016f, -0.005378f, -0.161141f}, {-0.143209f, -0.986418f, -0.080435f}, {0.406695f, 0.234464f} },
    { {0.035840f, -0.010795f, -0.165603f}, {0.246316f, -0.961730f, -0.120017f}, {0.337436f, 0.234464f} },
    { {-0.043016f, 0.013360f, -0.179879f}, {-0.321952f, -0.059376f, -0.944892f}, {0.406695f, 0.242616f} },
    { {0.038384f, -0.049965f, -0.026749f}, {0.420533f, -0.863121f, 0.279596f}, {0.297283f, 0.316589f} },
    { {-0.056529f, 0.009535f, -0.026749f}, {-0.370909f, 0.896065f, 0.243916f}, {0.396587f, 0.316589f} },
    { {-0.043016f, -0.005378f, -0.018738f}, {-0.282715f, -0.950257f, 0.130706f}, {0.313461f, 0.234464f} },
    { {0.041732f, -0.006764f, -0.016387f}, {0.066977f, -0.991670f, 0.110025f}, {0.382721f, 0.234464f} },
    { {0.041732f, -0.006764f, -0.016387f}, {0.066977f, -0.991670f, 0.110025f}, {0.394411f, 0.233860f} },
    { {0.001365f, -0.003565f, -0.163563f}, {0.030680f, 0.915610f, -0.400895f}, {0.364303f, 0.235252f} },
    { {-0.056529f, 0.009535f, -0.152260f}, {-0.976008f, 0.022786f, -0.216539f}, {0.402488f, 0.239188f} },
    { {-0.030163f, -0.053857f, -0.152260f}, {-0.320831f, -0.905175f, -0.278792f}, {0.394418f, 0.213371f} },
    { {0.001365f, -0.003565f, -0.163563f}, {0.030680f, 0.915610f, -0.400895f}, {0.364303f, 0.230620f} },
    { {-0.056529f, 0.009535f, -0.026749f}, {-0.370909f, 0.896065f, 0.243916f}, {0.419603f, 0.316589f} },
    { {-0.056529f, 0.009535f, -0.152260f}, {-0.976008f, 0.022786f, -0.216539f}, {0.419602f, 0.237722f} },
    { {0.038384f, -0.049965f, -0.026749f}, {0.420533f, -0.863121f, 0.279596f}, {0.391213f, 0.215064f} },
    { {0.001365f, -0.003565f, -0.016099f}, {-0.133936f, 0.906763f, 0.399802f}, {0.355853f, 0.235252f} },
    { {0.057404f, 0.016005f, -0.026749f}, {0.966868f, 0.134286f, 0.217105f}, {0.392814f, 0.241132f} },
    { {0.057404f, 0.016005f, -0.152260f}, {0.270247f, 0.931382f, -0.243916f}, {0.310776f, 0.237722f} },
    { {0.057404f, 0.016005f, -0.026749f}, {0.966868f, 0.134286f, 0.217105f}, {0.310776f, 0.316589f} },
    { {0.001365f, -0.003565f, -0.016099f}, {-0.133936f, 0.906763f, 0.399802f}, {0.364303f, 0.323281f} },
    { {0.038384f, -0.049965f, -0.152260f}, {0.747916f, -0.602410f, -0.278792f}, {0.328944f, 0.215064f} },
    { {-0.030163f, -0.053857f, -0.152260f}, {-0.320831f, -0.905175f, -0.278792f}, {0.325738f, 0.237722f} },
    { {0.038384f, -0.049965f, -0.026749f}, {0.420533f, -0.863121f, 0.279596f}, {0.391213f, 0.316589f} },
    { {0.038384f, -0.049965f, -0.152260f}, {0.747916f, -0.602410f, -0.278792f}, {0.391213f, 0.237722f} },
    { {-0.030163f, -0.053857f, -0.026749f}, {-0.675225f, -0.682567f, 0.279595f}, {0.325738f, 0.213371f} },
    { {-0.030163f, -0.053857f, -0.026749f}, {-0.675225f, -0.682567f, 0.279595f}, {0.325738f, 0.316589f} },
    { {0.048401f, 0.215385f, 0.006919f}, {0.330143f, 0.099083f, 0.938716f}, {0.382721f, 0.332293f} },
    { {0.015882f, 0.150514f, 0.011294f}, {-0.304471f, 0.085248f, 0.948699f}, {0.369719f, 0.302291f} },
    { {0.048401f, 0.215385f, 0.006919f}, {0.330143f, 0.099083f, 0.938716f}, {0.400781f, 0.330515f} },
    { {0.005740f, 0.015244f, 0.011211f}, {-0.167179f, -0.089858f, 0.981823f}, {0.363555f, 0.274093f} },
    { {0.053222f, 0.155336f, -0.189803f}, {0.422483f, 0.081365f, -0.902711f}, {0.314771f, 0.304388f} },
    { {0.060975f, 0.217042f, -0.017932f}, {0.904180f, 0.424851f, 0.044278f}, {0.415242f, 0.322129f} },
    { {0.060800f, 0.217373f, -0.162876f}, {0.788050f, 0.585131f, -0.191310f}, {0.415388f, 0.231052f} },
    { {0.035840f, -0.010795f, -0.165603f}, {0.246316f, -0.961730f, -0.120017f}, {0.331374f, 0.232107f} },
    { {-0.043016f, -0.005378f, -0.018738f}, {-0.282715f, -0.950257f, 0.130706f}, {0.403176f, 0.321623f} },
    { {-0.043016f, 0.013360f, -0.000000f}, {-0.325536f, -0.025365f, 0.945189f}, {0.394898f, 0.333397f} },
    { {0.045529f, 0.014118f, 0.010433f}, {0.389880f, -0.107648f, 0.914552f}, {0.325594f, 0.339953f} },
    { {0.048401f, 0.215385f, 0.006919f}, {0.330143f, 0.099083f, 0.938716f}, {0.414510f, 0.337745f} },
    { {0.057404f, 0.016005f, -0.152260f}, {0.270247f, 0.931382f, -0.243916f}, {0.327342f, 0.241132f} },
    { {-0.043016f, -0.005378f, -0.161141f}, {-0.143209f, -0.986418f, -0.080435f}, {0.403176f, 0.232142f} },
    { {-0.029491f, 0.219470f, -0.179879f}, {-0.280784f, 0.068242f, -0.957342f}, {0.303841f, 0.220368f} },
    { {-0.043016f, 0.013360f, -0.179879f}, {-0.321952f, -0.059376f, -0.944892f}, {0.394898f, 0.220368f} },
    { {0.060800f, 0.217373f, -0.162876f}, {0.788050f, 0.585131f, -0.191310f}, {0.416315f, 0.232142f} },
    { {0.060975f, 0.217042f, -0.017932f}, {0.904180f, 0.424851f, 0.044278f}, {0.416315f, 0.321623f} },
    { {0.029494f, 0.238208f, -0.018738f}, {0.290677f, 0.946542f, 0.139873f}, {0.424593f, 0.321623f} },
    { {-0.056529f, 0.009535f, -0.026749f}, {-0.370909f, 0.896065f, 0.243916f}, {0.300554f, 0.240952f} },
    { {-0.029491f, 0.238208f, -0.161142f}, {-0.325925f, 0.933931f, -0.146787f}, {0.295564f, 0.232142f} },
    { {-0.029491f, 0.238208f, -0.018738f}, {-0.142484f, 0.987408f, 0.068724f}, {0.295564f, 0.321623f} },
    { {-0.029491f, 0.219470f, -0.000000f}, {-0.217649f, 0.151833f, 0.964145f}, {0.303841f, 0.333397f} },
    { {0.038528f, 0.185273f, -0.179801f}, {0.040988f, 0.146677f, -0.988335f}, {0.318915f, 0.317771f} },
    { {0.038528f, 0.185273f, -0.179801f}, {0.040988f, 0.146677f, -0.988335f}, {0.401570f, 0.216651f} },
    { {0.015882f, 0.150514f, 0.011294f}, {-0.304471f, 0.085248f, 0.948699f}, {0.334305f, 0.340494f} },
    { {0.005740f, 0.015244f, 0.011211f}, {-0.167179f, -0.089858f, 0.981823f}, {0.394065f, 0.340442f} },
    { {0.009035f, 0.150921f, 0.000077f}, {-0.189726f, 0.015945f, 0.981708f}, {0.334125f, 0.333446f} },
    { {0.048401f, 0.215385f, 0.006919f}, {0.330143f, 0.099083f, 0.938716f}, {0.305646f, 0.337745f} },
    { {-0.048229f, 0.219470f, -0.161142f}, {-0.971543f, 0.208188f, -0.112971f}, {0.303841f, 0.232142f} },
    { {0.038528f, 0.185273f, -0.179801f}, {0.040988f, 0.146677f, -0.988335f}, {0.401365f, 0.220368f} },
    { {0.029494f, 0.219470f, -0.179879f}, {0.141665f, 0.444002f, -0.884756f}, {0.416315f, 0.220368f} },
    { {0.029494f, 0.238208f, -0.161142f}, {0.143003f, 0.987044f, -0.072764f}, {0.424593f, 0.232142f} },
    { {0.009036f, 0.150921f, -0.179801f}, {-0.170725f, 0.045420f, -0.984271f}, {0.334125f, 0.220417f} },
    { {-0.006761f, 0.013360f, -0.179879f}, {-0.165380f, -0.089067f, -0.982200f}, {0.364527f, 0.220417f} },
    { {0.015911f, 0.150506f, -0.190937f}, {-0.211573f, 0.066188f, -0.975118f}, {0.334309f, 0.213420f} },
    { {0.038528f, 0.185273f, -0.179801f}, {0.040988f, 0.146677f, -0.988335f}, {0.318949f, 0.220417f} },
    { {0.029494f, 0.238208f, -0.018738f}, {0.290677f, 0.946542f, 0.139873f}, {0.382721f, 0.340445f} },
    { {0.048401f, 0.215385f, 0.006919f}, {0.330143f, 0.099083f, 0.938716f}, {0.416315f, 0.333397f} },
    { {-0.029491f, 0.238208f, -0.018738f}, {-0.142484f, 0.987408f, 0.068724f}, {0.326380f, 0.340445f} },
    { {-0.029491f, 0.238208f, -0.161142f}, {-0.325925f, 0.933931f, -0.146787f}, {0.393777f, 0.340445f} },
    { {-0.000883f, 0.013002f, 0.000077f}, {-0.182469f, -0.278443f, 0.942961f}, {0.395056f, 0.333446f} },
    { {0.041732f, -0.006764f, -0.016387f}, {0.066977f, -0.991670f, 0.110025f}, {0.394411f, 0.323100f} },
    { {-0.000883f, 0.013002f, 0.000077f}, {-0.182469f, -0.278443f, 0.942961f}, {0.353706f, 0.333446f} },
    { {0.005740f, 0.015244f, 0.011211f}, {-0.167179f, -0.089858f, 0.981823f}, {0.360032f, 0.340442f} },
    { {0.005770f, 0.014353f, -0.190708f}, {-0.167212f, -0.107527f, -0.980040f}, {0.394459f, 0.213563f} },
    { {0.035840f, -0.010795f, -0.165603f}, {-0.322043f, -0.833418f, -0.449113f}, {0.389661f, 0.231303f} },
    { {0.005770f, 0.014353f, -0.190708f}, {-0.322043f, -0.833418f, -0.449113f}, {0.354445f, 0.213514f} },
    { {-0.006761f, 0.013360f, -0.179879f}, {-0.322043f, -0.833418f, -0.449113f}, {0.348091f, 0.220368f} },
    { {0.029494f, 0.238208f, -0.161142f}, {0.143003f, 0.987044f, -0.072764f}, {0.337435f, 0.340445f} },
};

WORD g_tind8[] = 
{
    2, 1, 0,    5, 4, 3,    6, 2, 0,    3, 4, 7,    10, 9, 8,
    13, 12, 11,    16, 15, 14,    19, 18, 17,    18, 20, 17,    12, 21, 11,
    22, 16, 14,    25, 24, 23,    4, 27, 26,    30, 29, 28,    32, 3, 31,
    9, 34, 33,    37, 36, 35,    40, 39, 38,    10, 42, 41,    43, 9, 10,
    39, 44, 38,    36, 45, 35,    47, 19, 46,    48, 30, 28,    51, 50, 49,
    54, 53, 52,    57, 56, 55,    60, 59, 58,    61, 51, 49,    64, 63, 62,
    55, 56, 65,    63, 66, 62,    18, 67, 20,    70, 69, 68,    24, 71, 23,
    8, 9, 33,    73, 72, 3,    73, 3, 32,    7, 4, 26,    23, 74, 25,
    75, 2, 6,    2, 76, 1,    78, 77, 4,    4, 77, 27,    79, 61, 49,
    52, 60, 58,    80, 75, 6,    82, 6, 81,    85, 84, 83,    5, 78, 4,
    65, 56, 86,    53, 60, 52,    1, 88, 87,    76, 89, 1,    24, 90, 71,
    91, 73, 32,    94, 93, 92,    94, 92, 95,    96, 1, 87,    6, 0, 81,
    98, 83, 97,    99, 85, 83,    3, 7, 31,    7, 26, 31,    102, 101, 100,
    102, 100, 103,    20, 67, 104,    85, 105, 84,    1, 89, 88,    106, 20, 104,
    10, 41, 43,    80, 6, 82,    96, 87, 81,    9, 107, 34,    19, 17, 46,
    75, 76, 2,    72, 78, 5,    72, 5, 3,    93, 94, 108,    111, 110, 109,
    101, 102, 112,    115, 114, 113,    107, 116, 34,    99, 83, 98,    0, 1, 96,
    0, 96, 81,
};

D3DMATRIX g_tmat9 = 
{
    0.831287f, 0.195432f, -0.520355f, 0.000000f, 
    -0.417611f, -0.398225f, -0.816712f, 0.000000f, 
    -0.366830f, 0.896228f, -0.249425f, 0.000000f, 
    3.128304f, -2.712259f, 1.796256f, 1.000000f, 
};

// Mesh #9 Tris:96 Verts:130
MODELVERT g_tmesh9[] = 
{
    { {-0.037650f, 0.169680f, -0.124916f}, {-0.987881f, 0.132021f, -0.081621f}, {0.303851f, 0.234286f} },
    { {-0.037388f, 0.130415f, -0.014525f}, {-0.975095f, 0.101427f, 0.197236f}, {0.328516f, 0.319571f} },
    { {-0.044909f, 0.076246f, -0.006147f}, {-0.992219f, 0.074699f, 0.099608f}, {0.362543f, 0.326044f} },
    { {0.047218f, 0.023082f, -0.133577f}, {0.993320f, -0.042028f, -0.107462f}, {0.324218f, 0.227595f} },
    { {0.047235f, 0.130273f, -0.014097f}, {0.994373f, 0.041688f, 0.097390f}, {0.391552f, 0.319902f} },
    { {0.042461f, 0.168869f, -0.125764f}, {0.956423f, 0.238993f, -0.167740f}, {0.415796f, 0.233631f} },
    { {-0.044999f, 0.077182f, -0.133336f}, {-0.996215f, 0.042230f, -0.075969f}, {0.361955f, 0.227781f} },
    { {0.047117f, 0.021413f, -0.005585f}, {0.972365f, -0.189884f, 0.135831f}, {0.323170f, 0.326478f} },
    { {-0.030474f, 0.009398f, -0.133336f}, {-0.181494f, -0.982128f, -0.049840f}, {0.316801f, 0.227781f} },
    { {-0.030384f, 0.008462f, -0.006147f}, {-0.433200f, -0.895298f, 0.103825f}, {0.316933f, 0.326044f} },
    { {-0.003717f, 0.008462f, -0.006147f}, {-0.056565f, -0.997038f, 0.052105f}, {0.355923f, 0.326044f} },
    { {-0.030384f, 0.022987f, 0.008378f}, {-0.318670f, -0.108464f, 0.941639f}, {0.316933f, 0.241533f} },
    { {0.000360f, 0.076012f, 0.008389f}, {0.000132f, 0.075123f, 0.997174f}, {0.355923f, 0.274481f} },
    { {-0.003717f, 0.022987f, 0.008378f}, {0.000001f, -0.333774f, 0.942653f}, {0.355923f, 0.241533f} },
    { {0.029964f, 0.023131f, -0.151724f}, {0.149498f, -0.163103f, -0.975217f}, {0.314988f, 0.241622f} },
    { {0.000270f, 0.076948f, -0.147851f}, {-0.163806f, 0.038015f, -0.985760f}, {0.355973f, 0.275000f} },
    { {-0.003807f, 0.023923f, -0.147861f}, {-0.115884f, -0.238447f, -0.964217f}, {0.355979f, 0.241101f} },
    { {-0.003807f, 0.009398f, -0.133336f}, {-0.051860f, -0.992907f, -0.106986f}, {0.355791f, 0.227781f} },
    { {0.031048f, 0.004807f, -0.005465f}, {-0.074346f, -0.997203f, -0.007692f}, {0.394913f, 0.326044f} },
    { {0.031140f, 0.005878f, -0.133985f}, {-0.100381f, -0.994914f, -0.008358f}, {0.394781f, 0.227781f} },
    { {-0.030384f, 0.076246f, 0.008378f}, {-0.380814f, 0.116779f, 0.917248f}, {0.316933f, 0.274481f} },
    { {-0.022863f, 0.130415f, -0.000000f}, {-0.204655f, 0.192047f, 0.959809f}, {0.327930f, 0.307992f} },
    { {0.018243f, 0.182874f, -0.124916f}, {0.130671f, 0.989173f, -0.066798f}, {0.332125f, 0.234286f} },
    { {0.018243f, 0.182874f, -0.014525f}, {0.457851f, 0.884016f, 0.094277f}, {0.332125f, 0.319571f} },
    { {-0.027482f, 0.182874f, -0.014525f}, {-0.141942f, 0.946310f, 0.290431f}, {0.398980f, 0.319571f} },
    { {0.000270f, 0.076948f, -0.147851f}, {0.000953f, 0.079029f, -0.996872f}, {0.364365f, 0.275060f} },
    { {-0.030474f, 0.077182f, -0.147861f}, {-0.276895f, 0.117290f, -0.953715f}, {0.403355f, 0.275060f} },
    { {-0.003807f, 0.023923f, -0.147861f}, {0.000167f, -0.111849f, -0.993725f}, {0.364365f, 0.242112f} },
    { {-0.027482f, 0.182874f, -0.124916f}, {-0.309703f, 0.747070f, -0.588192f}, {0.398980f, 0.234286f} },
    { {-0.030474f, 0.077182f, -0.147861f}, {-0.276895f, 0.117290f, -0.953715f}, {0.361955f, 0.216560f} },
    { {-0.044999f, 0.023923f, -0.133336f}, {-0.943568f, -0.301420f, -0.137206f}, {0.395410f, 0.227781f} },
    { {-0.030474f, 0.023923f, -0.147861f}, {-0.283631f, -0.283944f, -0.915931f}, {0.395410f, 0.216560f} },
    { {-0.030384f, 0.008462f, -0.006147f}, {-0.433200f, -0.895298f, 0.103825f}, {0.405122f, 0.326044f} },
    { {-0.030474f, 0.009398f, -0.133336f}, {-0.181494f, -0.982128f, -0.049840f}, {0.404534f, 0.227781f} },
    { {0.000360f, 0.076012f, 0.008389f}, {-0.129918f, 0.081562f, 0.988164f}, {0.364314f, 0.274528f} },
    { {0.030061f, 0.076123f, 0.012285f}, {0.314498f, 0.090048f, 0.944977f}, {0.405311f, 0.274405f} },
    { {-0.003717f, 0.022987f, 0.008378f}, {-0.124733f, -0.144530f, 0.981607f}, {0.364308f, 0.241002f} },
    { {0.022320f, 0.168115f, -0.006327f}, {0.356132f, 0.366739f, 0.859460f}, {0.388032f, 0.331459f} },
    { {-0.000001f, 0.130415f, -0.000000f}, {0.000001f, 0.157783f, 0.987474f}, {0.361357f, 0.307992f} },
    { {0.029860f, 0.021486f, 0.012177f}, {0.251093f, -0.230507f, 0.940116f}, {0.405018f, 0.240604f} },
    { {-0.040394f, 0.020010f, -0.117522f}, {-0.977898f, 0.099048f, -0.184134f}, {0.397868f, 0.239999f} },
    { {-0.026551f, -0.021767f, -0.021530f}, {-0.733362f, -0.636451f, 0.238977f}, {0.424111f, 0.314159f} },
    { {-0.026551f, -0.021767f, -0.117522f}, {-0.389644f, -0.889579f, -0.238384f}, {0.424111f, 0.239999f} },
    { {0.017453f, -0.022535f, -0.117522f}, {0.710417f, -0.662179f, -0.238383f}, {0.295564f, 0.239999f} },
    { {0.032746f, 0.018734f, -0.021530f}, {0.980614f, 0.065869f, 0.184545f}, {0.321487f, 0.314159f} },
    { {0.032746f, 0.018733f, -0.117522f}, {0.341136f, 0.916514f, -0.208874f}, {0.321487f, 0.239999f} },
    { {0.017453f, -0.022535f, -0.021530f}, {0.357770f, -0.902713f, 0.238978f}, {0.295564f, 0.314159f} },
    { {-0.040394f, 0.020010f, -0.021530f}, {-0.306269f, 0.928747f, 0.208874f}, {0.397868f, 0.314159f} },
    { {0.030005f, 0.077256f, -0.151717f}, {0.425061f, 0.090586f, -0.900621f}, {0.358248f, 0.213581f} },
    { {0.031140f, 0.005878f, -0.133985f}, {0.667565f, -0.732309f, -0.134461f}, {0.313269f, 0.230948f} },
    { {0.018243f, 0.168348f, -0.133103f}, {-0.098991f, 0.292456f, -0.951141f}, {0.332125f, 0.331459f} },
    { {-0.027482f, 0.182874f, -0.124916f}, {-0.309703f, 0.747070f, -0.588192f}, {0.398980f, 0.340445f} },
    { {0.004077f, 0.130181f, -0.139430f}, {-0.074947f, 0.197604f, -0.977413f}, {0.358799f, 0.307992f} },
    { {0.030005f, 0.077256f, -0.151717f}, {0.425061f, 0.090586f, -0.900621f}, {0.314928f, 0.275106f} },
    { {0.024815f, 0.168855f, -0.137054f}, {0.222696f, 0.625153f, -0.748058f}, {0.322515f, 0.331773f} },
    { {0.005740f, 0.130743f, -0.143512f}, {-0.148049f, 0.148919f, -0.977704f}, {0.350406f, 0.308195f} },
    { {-0.030474f, 0.023923f, -0.147861f}, {-0.283631f, -0.283944f, -0.915931f}, {0.403355f, 0.242112f} },
    { {-0.003807f, 0.023923f, -0.147861f}, {-0.084061f, -0.704604f, -0.704604f}, {0.355979f, 0.241101f} },
    { {-0.003807f, 0.009398f, -0.133336f}, {-0.084061f, -0.704604f, -0.704604f}, {0.361963f, 0.231254f} },
    { {0.031140f, 0.005878f, -0.133985f}, {-0.084061f, -0.704604f, -0.704604f}, {0.356002f, 0.231110f} },
    { {0.030061f, 0.076123f, 0.012285f}, {0.314498f, 0.090048f, 0.944977f}, {0.357536f, 0.340283f} },
    { {0.042461f, 0.168869f, -0.125764f}, {0.956423f, 0.238993f, -0.167740f}, {0.296716f, 0.233631f} },
    { {0.042590f, 0.168617f, -0.014253f}, {0.840360f, 0.529427f, 0.116197f}, {0.296527f, 0.319781f} },
    { {0.022320f, 0.168115f, -0.006327f}, {-0.045056f, 0.998693f, 0.024137f}, {0.326163f, 0.325904f} },
    { {-0.004007f, 0.008886f, -0.124768f}, {0.101519f, 0.932365f, -0.346971f}, {0.364658f, 0.232809f} },
    { {-0.040394f, 0.020010f, -0.117522f}, {-0.977898f, 0.099048f, -0.184134f}, {0.401394f, 0.237561f} },
    { {-0.026551f, -0.021767f, -0.117522f}, {-0.389644f, -0.889579f, -0.238384f}, {0.397619f, 0.213846f} },
    { {-0.004007f, 0.008886f, -0.124768f}, {0.101519f, 0.932365f, -0.346971f}, {0.364658f, 0.234401f} },
    { {-0.040394f, 0.020010f, -0.021530f}, {-0.306269f, 0.928747f, 0.208874f}, {0.417860f, 0.314159f} },
    { {-0.040394f, 0.020010f, -0.117522f}, {-0.977898f, 0.099048f, -0.184134f}, {0.417860f, 0.239999f} },
    { {0.017453f, -0.022535f, -0.021530f}, {0.357770f, -0.902713f, 0.238978f}, {0.386877f, 0.213371f} },
    { {-0.004007f, 0.008886f, -0.014703f}, {-0.068706f, 0.935666f, 0.346133f}, {0.355499f, 0.232809f} },
    { {0.032746f, 0.018734f, -0.021530f}, {0.980614f, 0.065869f, 0.184545f}, {0.392605f, 0.237016f} },
    { {0.032746f, 0.018733f, -0.117522f}, {0.341136f, 0.916514f, -0.208874f}, {0.310920f, 0.239999f} },
    { {0.032746f, 0.018734f, -0.021530f}, {0.980614f, 0.065869f, 0.184545f}, {0.310920f, 0.314159f} },
    { {-0.004007f, 0.008886f, -0.014703f}, {-0.068706f, 0.935666f, 0.346133f}, {0.364658f, 0.319433f} },
    { {0.017453f, -0.022535f, -0.117522f}, {0.710417f, -0.662179f, -0.238383f}, {0.333280f, 0.213371f} },
    { {-0.026551f, -0.021767f, -0.117522f}, {-0.389644f, -0.889579f, -0.238384f}, {0.322537f, 0.239999f} },
    { {0.017453f, -0.022535f, -0.021530f}, {0.357770f, -0.902713f, 0.238978f}, {0.386877f, 0.314159f} },
    { {0.017453f, -0.022535f, -0.117522f}, {0.710417f, -0.662179f, -0.238383f}, {0.386877f, 0.239999f} },
    { {-0.026551f, -0.021767f, -0.021530f}, {-0.733362f, -0.636451f, 0.238977f}, {0.322537f, 0.213846f} },
    { {-0.026551f, -0.021767f, -0.021530f}, {-0.733362f, -0.636451f, 0.238977f}, {0.322537f, 0.314159f} },
    { {-0.044909f, 0.022987f, -0.006147f}, {-0.990446f, -0.124468f, 0.059371f}, {0.395998f, 0.326044f} },
    { {-0.030384f, 0.076246f, 0.008378f}, {-0.380814f, 0.116779f, 0.917248f}, {0.362543f, 0.337265f} },
    { {0.024815f, 0.168855f, -0.137054f}, {0.222696f, 0.625153f, -0.748058f}, {0.322515f, 0.224909f} },
    { {0.024815f, 0.168855f, -0.137054f}, {0.222696f, 0.625153f, -0.748058f}, {0.415787f, 0.224909f} },
    { {0.031140f, 0.005878f, -0.133985f}, {0.667565f, -0.732309f, -0.134461f}, {0.313411f, 0.227280f} },
    { {0.029964f, 0.023131f, -0.151724f}, {0.149498f, -0.163103f, -0.975217f}, {0.324249f, 0.213575f} },
    { {-0.003807f, 0.009398f, -0.133336f}, {-0.051860f, -0.992907f, -0.106986f}, {0.364365f, 0.233126f} },
    { {-0.003717f, 0.022987f, 0.008378f}, {-0.087875f, -0.704372f, 0.704371f}, {0.358346f, 0.241146f} },
    { {0.031048f, 0.004807f, -0.005465f}, {-0.087875f, -0.704372f, 0.704371f}, {0.364305f, 0.230530f} },
    { {-0.003717f, 0.008462f, -0.006147f}, {-0.087875f, -0.704372f, 0.704371f}, {0.358344f, 0.230675f} },
    { {-0.030384f, 0.008462f, -0.006147f}, {-0.433200f, -0.895298f, 0.103825f}, {0.316933f, 0.232547f} },
    { {-0.003717f, 0.008462f, -0.006147f}, {-0.056565f, -0.997038f, 0.052105f}, {0.355923f, 0.232547f} },
    { {0.032746f, 0.018733f, -0.117522f}, {0.341136f, 0.916514f, -0.208874f}, {0.327551f, 0.237016f} },
    { {-0.040394f, 0.020010f, -0.021530f}, {-0.306269f, 0.928747f, 0.208874f}, {0.318762f, 0.237561f} },
    { {-0.000001f, 0.130415f, -0.000000f}, {-0.157648f, 0.169578f, 0.972826f}, {0.369752f, 0.308192f} },
    { {0.025532f, 0.168698f, -0.002554f}, {0.293300f, 0.188111f, 0.937331f}, {0.398689f, 0.331676f} },
    { {0.025532f, 0.168698f, -0.002554f}, {0.293300f, 0.188111f, 0.937331f}, {0.415688f, 0.328820f} },
    { {0.029860f, 0.021486f, 0.012177f}, {0.251093f, -0.230507f, 0.940116f}, {0.323216f, 0.340200f} },
    { {0.031048f, 0.004807f, -0.005465f}, {0.607306f, -0.764664f, 0.215564f}, {0.312739f, 0.326571f} },
    { {0.018243f, 0.182874f, -0.124916f}, {0.130671f, 0.989173f, -0.066798f}, {0.332125f, 0.340445f} },
    { {0.024815f, 0.168855f, -0.137054f}, {0.931255f, 0.364050f, -0.015192f}, {0.415469f, 0.234286f} },
    { {0.018243f, 0.182874f, -0.014525f}, {0.457851f, 0.884016f, 0.094277f}, {0.424593f, 0.319571f} },
    { {0.018243f, 0.182874f, -0.124916f}, {0.130671f, 0.989173f, -0.066798f}, {0.424593f, 0.234286f} },
    { {-0.030384f, 0.022987f, 0.008378f}, {-0.318670f, -0.108464f, 0.941639f}, {0.395998f, 0.337265f} },
    { {-0.022863f, 0.130415f, -0.000000f}, {-0.204655f, 0.192047f, 0.959809f}, {0.328516f, 0.330792f} },
    { {-0.027482f, 0.182874f, -0.124916f}, {-0.309703f, 0.747070f, -0.588192f}, {0.295564f, 0.234286f} },
    { {-0.027482f, 0.182874f, -0.014525f}, {-0.141942f, 0.946310f, 0.290431f}, {0.295564f, 0.319571f} },
    { {-0.037650f, 0.169680f, -0.014525f}, {-0.950033f, 0.279916f, 0.138145f}, {0.303851f, 0.319571f} },
    { {-0.027482f, 0.182874f, -0.124916f}, {-0.309703f, 0.747070f, -0.588192f}, {0.304407f, 0.227962f} },
    { {0.031048f, 0.004807f, -0.005465f}, {0.607306f, -0.764664f, 0.215564f}, {0.406754f, 0.230286f} },
    { {0.022320f, 0.168115f, -0.006327f}, {0.356132f, 0.366739f, 0.859460f}, {0.415469f, 0.325896f} },
    { {0.018243f, 0.182874f, -0.014525f}, {0.457851f, 0.884016f, 0.094277f}, {0.388032f, 0.340445f} },
    { {-0.027482f, 0.182874f, -0.014525f}, {-0.141942f, 0.946310f, 0.290431f}, {0.321176f, 0.340445f} },
    { {-0.030474f, 0.009398f, -0.133336f}, {-0.181494f, -0.982128f, -0.049840f}, {0.403355f, 0.233126f} },
    { {0.018243f, 0.168348f, -0.133103f}, {-0.098991f, 0.292456f, -0.951141f}, {0.415469f, 0.227962f} },
    { {0.005740f, 0.130743f, -0.143512f}, {-0.497761f, 0.381139f, -0.779081f}, {0.328164f, 0.219911f} },
    { {0.024815f, 0.168855f, -0.137054f}, {-0.497761f, 0.381139f, -0.779081f}, {0.304223f, 0.224901f} },
    { {0.018243f, 0.168348f, -0.133103f}, {-0.497761f, 0.381139f, -0.779081f}, {0.304688f, 0.227962f} },
    { {-0.037650f, 0.169680f, -0.014525f}, {-0.950033f, 0.279916f, 0.138145f}, {0.306310f, 0.332283f} },
    { {0.042590f, 0.168617f, -0.014253f}, {0.840360f, 0.529427f, 0.116197f}, {0.415637f, 0.319781f} },
    { {-0.000001f, 0.130415f, -0.000000f}, {-0.157648f, 0.169578f, 0.972826f}, {0.328663f, 0.330801f} },
    { {0.022320f, 0.168115f, -0.006327f}, {-0.045056f, 0.998693f, 0.024137f}, {0.304834f, 0.325904f} },
    { {0.025532f, 0.168698f, -0.002554f}, {0.293300f, 0.188111f, 0.937331f}, {0.304468f, 0.328820f} },
    { {0.025532f, 0.168698f, -0.002554f}, {0.293300f, 0.188111f, 0.937331f}, {0.321467f, 0.328820f} },
    { {0.018243f, 0.168348f, -0.133103f}, {-0.875232f, 0.375422f, -0.305004f}, {0.304834f, 0.227970f} },
    { {0.004077f, 0.130181f, -0.139430f}, {-0.911200f, 0.233901f, -0.339123f}, {0.328663f, 0.223073f} },
    { {0.005740f, 0.130743f, -0.143512f}, {-0.148049f, 0.148919f, -0.977704f}, {0.328310f, 0.219920f} },
    { {0.000270f, 0.076948f, -0.147851f}, {-0.163806f, 0.038015f, -0.985760f}, {0.362102f, 0.216568f} },
};

WORD g_tind9[] = 
{
    2, 1, 0,    5, 4, 3,    6, 2, 0,    4, 7, 3,    10, 9, 8,
    13, 12, 11,    16, 15, 14,    19, 18, 17,    12, 21, 20,    24, 23, 22,
    27, 26, 25,    28, 24, 22,    31, 30, 29,    33, 32, 30,    36, 35, 34,
    38, 37, 21,    18, 10, 8,    39, 35, 36,    42, 41, 40,    45, 44, 43,
    44, 46, 43,    41, 47, 40,    5, 3, 48,    14, 49, 16,    52, 51, 50,
    55, 54, 53,    56, 26, 27,    59, 58, 57,    4, 60, 7,    63, 62, 61,
    66, 65, 64,    69, 68, 67,    72, 71, 70,    75, 74, 73,    76, 66, 64,
    79, 78, 77,    70, 71, 80,    78, 81, 77,    32, 82, 30,    2, 83, 1,
    6, 0, 29,    26, 51, 52,    61, 84, 63,    85, 5, 48,    3, 7, 86,
    3, 86, 87,    27, 88, 56,    17, 18, 8,    91, 90, 89,    93, 13, 92,
    94, 76, 64,    67, 75, 73,    80, 71, 95,    68, 75, 67,    35, 97, 96,
    98, 60, 4,    60, 99, 7,    7, 100, 86,    51, 101, 50,    104, 103, 102,
    34, 35, 96,    12, 38, 21,    13, 11, 92,    32, 105, 82,    83, 106, 1,
    109, 108, 107,    15, 53, 14,    48, 3, 87,    25, 26, 52,    15, 55, 53,
    29, 0, 110,    0, 109, 107,    111, 39, 36,    7, 99, 100,    103, 112, 102,
    114, 37, 113,    88, 115, 56,    33, 30, 31,    104, 102, 116,    119, 118, 117,
    30, 82, 6,    30, 6, 29,    12, 20, 11,    105, 83, 2,    37, 114, 21,
    21, 114, 120,    82, 105, 2,    82, 2, 6,    121, 98, 4,    121, 4, 5,
    124, 123, 122,    63, 125, 62,    128, 127, 126,    127, 128, 129,    1, 106, 109,
    1, 109, 0,
};

D3DMATRIX g_tmat10 = 
{
    0.567472f, 0.003115f, -0.823387f, 0.000000f, 
    -0.737165f, -0.443585f, -0.509727f, 0.000000f, 
    -0.366830f, 0.896228f, -0.249425f, 0.000000f, 
    3.052369f, -2.788628f, 1.646262f, 1.000000f, 
};

// Mesh #10 Tris:74 Verts:96
MODELVERT g_tmesh10[] = 
{
    { {-0.028661f, 0.022378f, -0.099933f}, {-0.956482f, -0.264726f, -0.122730f}, {0.399661f, 0.228668f} },
    { {-0.038276f, 0.106688f, -0.021795f}, {-0.987223f, -0.033598f, 0.155765f}, {0.330727f, 0.313958f} },
    { {-0.028661f, 0.022378f, -0.011620f}, {-0.953058f, -0.251438f, 0.168697f}, {0.399661f, 0.325064f} },
    { {0.039335f, 0.021873f, -0.100087f}, {0.992702f, 0.054489f, -0.107582f}, {0.320082f, 0.228499f} },
    { {0.039252f, 0.021347f, -0.011199f}, {0.984197f, -0.087556f, 0.153917f}, {0.319653f, 0.325524f} },
    { {0.027311f, 0.106758f, -0.020045f}, {0.966262f, 0.233486f, 0.108729f}, {0.389487f, 0.315868f} },
    { {-0.038375f, 0.107393f, -0.094738f}, {-0.977200f, -0.010134f, -0.212081f}, {0.330150f, 0.234339f} },
    { {0.027149f, 0.107450f, -0.096048f}, {0.896960f, 0.388404f, -0.211200f}, {0.390052f, 0.232908f} },
    { {0.017842f, 0.107867f, -0.095511f}, {0.999419f, 0.020424f, -0.027281f}, {0.390394f, 0.233495f} },
    { {0.010195f, 0.108332f, -0.009201f}, {0.668525f, 0.131503f, 0.731971f}, {0.391887f, 0.327691f} },
    { {0.014325f, 0.136947f, -0.026711f}, {0.974834f, 0.188919f, 0.118353f}, {0.414170f, 0.308592f} },
    { {-0.024592f, 0.109598f, -0.010116f}, {-0.271731f, 0.186508f, 0.944128f}, {0.319766f, 0.308158f} },
    { {0.002367f, 0.139352f, -0.015699f}, {-0.018900f, 0.484937f, 0.874345f}, {0.367105f, 0.332117f} },
    { {0.010195f, 0.108332f, -0.009201f}, {0.668525f, 0.131503f, 0.731971f}, {0.373424f, 0.308235f} },
    { {0.014170f, 0.138048f, -0.092316f}, {0.890795f, 0.422421f, -0.167466f}, {0.415071f, 0.236982f} },
    { {0.019921f, 0.065953f, -0.113666f}, {-0.087037f, 0.076525f, -0.993261f}, {0.336170f, 0.273605f} },
    { {-0.024513f, 0.109038f, -0.106453f}, {-0.317115f, 0.064909f, -0.946163f}, {0.400252f, 0.307707f} },
    { {-0.017041f, 0.022378f, -0.111553f}, {-0.319360f, -0.013788f, -0.947533f}, {0.387131f, 0.237925f} },
    { {-0.010124f, 0.007274f, -0.100082f}, {0.014810f, -0.996599f, -0.081059f}, {0.345172f, 0.228505f} },
    { {0.025597f, 0.007770f, -0.011430f}, {0.177256f, -0.981035f, 0.078433f}, {0.407897f, 0.325272f} },
    { {0.026056f, 0.007911f, -0.100281f}, {0.358581f, -0.916164f, -0.179060f}, {0.408703f, 0.228288f} },
    { {0.026060f, 0.021573f, -0.113886f}, {0.193497f, -0.201005f, -0.960290f}, {0.311446f, 0.237277f} },
    { {0.019921f, 0.065953f, -0.113666f}, {0.455249f, 0.121237f, -0.882071f}, {0.322226f, 0.273013f} },
    { {-0.017041f, 0.022378f, -0.111553f}, {-0.044161f, -0.313611f, -0.948524f}, {0.374989f, 0.236521f} },
    { {-0.016929f, -0.007972f, -0.092014f}, {-0.374340f, -0.887653f, -0.268218f}, {0.333223f, 0.237312f} },
    { {0.015913f, -0.008102f, -0.015460f}, {0.341143f, -0.853439f, 0.394035f}, {0.390892f, 0.320873f} },
    { {0.015915f, -0.008115f, -0.092014f}, {0.712975f, -0.646470f, -0.271557f}, {0.390896f, 0.237312f} },
    { {0.026923f, 0.022829f, -0.092014f}, {0.404238f, 0.904139f, -0.138292f}, {0.309930f, 0.237312f} },
    { {-0.027669f, 0.023080f, -0.015460f}, {-0.271730f, 0.910032f, 0.313058f}, {0.405793f, 0.320873f} },
    { {-0.000770f, 0.022687f, -0.097421f}, {0.003661f, 0.838983f, -0.544146f}, {0.358559f, 0.231410f} },
    { {-0.027667f, 0.023067f, -0.092014f}, {-0.983332f, 0.071758f, -0.167062f}, {0.399098f, 0.237312f} },
    { {-0.027669f, 0.023080f, -0.015460f}, {-0.271730f, 0.910032f, 0.313058f}, {0.399087f, 0.320873f} },
    { {-0.016930f, -0.007959f, -0.015460f}, {-0.743733f, -0.649287f, 0.159025f}, {0.424465f, 0.320873f} },
    { {0.015915f, -0.008115f, -0.092014f}, {0.712975f, -0.646470f, -0.271557f}, {0.295564f, 0.237312f} },
    { {0.015913f, -0.008102f, -0.015460f}, {0.341143f, -0.853439f, 0.394035f}, {0.295574f, 0.320873f} },
    { {0.026922f, 0.022842f, -0.015460f}, {0.844734f, 0.442898f, 0.300444f}, {0.320875f, 0.320873f} },
    { {-0.010169f, 0.007316f, -0.011117f}, {0.013167f, -0.973910f, 0.226551f}, {0.345092f, 0.325613f} },
    { {-0.010141f, 0.020894f, 0.002484f}, {0.004431f, -0.219273f, 0.975653f}, {0.345142f, 0.236730f} },
    { {0.019706f, 0.067313f, 0.002231f}, {0.537691f, 0.146669f, 0.830287f}, {0.397552f, 0.274109f} },
    { {0.025717f, 0.021198f, 0.002390f}, {0.225275f, -0.292820f, 0.929251f}, {0.408107f, 0.236975f} },
    { {0.002560f, 0.149597f, -0.090944f}, {-0.119100f, 0.991419f, -0.053875f}, {0.295564f, 0.238739f} },
    { {0.002746f, 0.148271f, -0.029496f}, {0.165146f, 0.979830f, 0.112519f}, {0.296680f, 0.305025f} },
    { {-0.033380f, 0.136797f, -0.028120f}, {-0.560508f, 0.792602f, 0.240028f}, {0.306109f, 0.307053f} },
    { {0.002367f, 0.139352f, -0.015699f}, {-0.018900f, 0.484937f, 0.874345f}, {0.303181f, 0.319853f} },
    { {-0.024592f, 0.109598f, -0.010116f}, {-0.271731f, 0.186508f, 0.944128f}, {0.328348f, 0.326706f} },
    { {-0.033551f, 0.138012f, -0.091621f}, {-0.832410f, 0.543602f, -0.107664f}, {0.305115f, 0.237740f} },
    { {-0.024513f, 0.109038f, -0.106453f}, {-0.317115f, 0.064909f, -0.946163f}, {0.328805f, 0.221551f} },
    { {-0.010141f, 0.020894f, 0.002484f}, {-0.428181f, 0.026180f, 0.903314f}, {0.399661f, 0.337748f} },
    { {-0.010169f, 0.007316f, -0.011117f}, {0.013167f, -0.973910f, 0.226551f}, {0.345092f, 0.225796f} },
    { {0.015913f, -0.008102f, -0.015460f}, {0.341143f, -0.853439f, 0.394035f}, {0.390892f, 0.213381f} },
    { {-0.027669f, 0.023080f, -0.015460f}, {-0.271730f, 0.910032f, 0.313058f}, {0.329179f, 0.236510f} },
    { {0.026922f, 0.022842f, -0.015460f}, {0.844734f, 0.442898f, 0.300444f}, {0.395371f, 0.236378f} },
    { {0.026922f, 0.022842f, -0.015460f}, {0.844734f, 0.442898f, 0.300444f}, {0.309933f, 0.320873f} },
    { {-0.000770f, 0.022687f, -0.097421f}, {0.003661f, 0.838983f, -0.544146f}, {0.358559f, 0.238173f} },
    { {-0.016929f, -0.007972f, -0.092014f}, {-0.374340f, -0.887653f, -0.268218f}, {0.386934f, 0.213486f} },
    { {0.015915f, -0.008115f, -0.092014f}, {0.712975f, -0.646470f, -0.271557f}, {0.329261f, 0.213371f} },
    { {-0.016929f, -0.007972f, -0.092014f}, {-0.374340f, -0.887653f, -0.268218f}, {0.424476f, 0.237312f} },
    { {0.006054f, 0.109061f, -0.106898f}, {0.184715f, 0.143326f, -0.972285f}, {0.391370f, 0.221065f} },
    { {0.002382f, 0.139242f, -0.103703f}, {0.372815f, 0.367481f, -0.852037f}, {0.416047f, 0.224553f} },
    { {-0.013317f, 0.140325f, -0.103361f}, {-0.286278f, 0.348830f, -0.892391f}, {0.303224f, 0.224926f} },
    { {0.019706f, 0.067313f, 0.002231f}, {0.537691f, 0.146669f, 0.830287f}, {0.357236f, 0.340183f} },
    { {0.027149f, 0.107450f, -0.096048f}, {0.896960f, 0.388404f, -0.211200f}, {0.309534f, 0.232908f} },
    { {0.027311f, 0.106758f, -0.020045f}, {0.966262f, 0.233486f, 0.108729f}, {0.309250f, 0.315868f} },
    { {0.010195f, 0.108332f, -0.009201f}, {0.242799f, 0.931546f, 0.270685f}, {0.339306f, 0.327705f} },
    { {0.019921f, 0.065953f, -0.113666f}, {0.455249f, 0.121237f, -0.882071f}, {0.356123f, 0.213677f} },
    { {0.006054f, 0.109061f, -0.106898f}, {0.184715f, 0.143326f, -0.972285f}, {0.346577f, 0.307726f} },
    { {0.026060f, 0.021573f, -0.113886f}, {0.193497f, -0.201005f, -0.960290f}, {0.319837f, 0.213438f} },
    { {0.026056f, 0.007911f, -0.100281f}, {0.358581f, -0.916164f, -0.179060f}, {0.308666f, 0.228288f} },
    { {0.026923f, 0.022829f, -0.092014f}, {0.404238f, 0.904139f, -0.138292f}, {0.324783f, 0.236367f} },
    { {0.026923f, 0.022829f, -0.092014f}, {0.404238f, 0.904139f, -0.138292f}, {0.320864f, 0.237312f} },
    { {-0.016930f, -0.007959f, -0.015460f}, {-0.743733f, -0.649287f, 0.159025f}, {0.333220f, 0.213497f} },
    { {-0.016930f, -0.007959f, -0.015460f}, {-0.743733f, -0.649287f, 0.159025f}, {0.333220f, 0.320873f} },
    { {-0.010169f, 0.007316f, -0.011117f}, {-0.631541f, -0.773385f, 0.055066f}, {0.409162f, 0.325064f} },
    { {-0.010124f, 0.007274f, -0.100082f}, {-0.630344f, -0.772896f, -0.072782f}, {0.409162f, 0.228668f} },
    { {-0.010124f, 0.007274f, -0.100082f}, {0.014810f, -0.996599f, -0.081059f}, {0.374985f, 0.225762f} },
    { {0.026056f, 0.007911f, -0.100281f}, {0.358581f, -0.916164f, -0.179060f}, {0.311454f, 0.226275f} },
    { {-0.010141f, 0.020894f, 0.002484f}, {-0.428181f, 0.026180f, 0.903314f}, {0.333026f, 0.237925f} },
    { {0.019706f, 0.067313f, 0.002231f}, {-0.121209f, 0.159124f, 0.979790f}, {0.383649f, 0.274708f} },
    { {0.010195f, 0.108332f, -0.009201f}, {0.242799f, 0.931546f, 0.270685f}, {0.391631f, 0.329706f} },
    { {0.006054f, 0.109061f, -0.106898f}, {0.446611f, 0.374196f, -0.812721f}, {0.391024f, 0.219064f} },
    { {0.002367f, 0.139352f, -0.015699f}, {-0.018900f, 0.484937f, 0.874345f}, {0.416136f, 0.320612f} },
    { {0.025717f, 0.021198f, 0.002390f}, {0.225275f, -0.292820f, 0.929251f}, {0.319531f, 0.340356f} },
    { {0.025597f, 0.007770f, -0.011430f}, {0.177256f, -0.981035f, 0.078433f}, {0.308551f, 0.325272f} },
    { {-0.017041f, 0.022378f, -0.111553f}, {-0.319360f, -0.013788f, -0.947533f}, {0.399661f, 0.215984f} },
    { {-0.013317f, 0.140325f, -0.103361f}, {-0.286278f, 0.348830f, -0.892391f}, {0.380591f, 0.332901f} },
    { {0.002746f, 0.148271f, -0.029496f}, {0.165146f, 0.979830f, 0.112519f}, {0.423429f, 0.305552f} },
    { {0.002560f, 0.149597f, -0.090944f}, {-0.119100f, 0.991419f, -0.053875f}, {0.424513f, 0.238480f} },
    { {-0.033551f, 0.138012f, -0.091621f}, {-0.832410f, 0.543602f, -0.107664f}, {0.416123f, 0.331038f} },
    { {-0.038375f, 0.107393f, -0.094738f}, {-0.977200f, -0.010134f, -0.212081f}, {0.424593f, 0.306382f} },
    { {0.025597f, 0.007770f, -0.011430f}, {0.177256f, -0.981035f, 0.078433f}, {0.407897f, 0.226162f} },
    { {0.017842f, 0.107867f, -0.095511f}, {0.045125f, 0.998966f, 0.005549f}, {0.318450f, 0.233509f} },
    { {0.006054f, 0.109061f, -0.106898f}, {0.446611f, 0.374196f, -0.812721f}, {0.331594f, 0.219064f} },
    { {0.002382f, 0.139242f, -0.103703f}, {0.372815f, 0.367481f, -0.852037f}, {0.353024f, 0.332029f} },
    { {0.002560f, 0.149597f, -0.090944f}, {-0.119100f, 0.991419f, -0.053875f}, {0.352712f, 0.340367f} },
    { {-0.027667f, 0.023067f, -0.092014f}, {-0.983332f, 0.071758f, -0.167062f}, {0.390974f, 0.236500f} },
    { {-0.027667f, 0.023067f, -0.092014f}, {-0.983332f, 0.071758f, -0.167062f}, {0.405790f, 0.237312f} },
};

WORD g_tind10[] = 
{
    2, 1, 0,    5, 4, 3,    0, 1, 6,    7, 5, 3,    10, 9, 8,
    13, 12, 11,    14, 10, 8,    17, 16, 15,    20, 19, 18,    23, 22, 21,
    26, 25, 24,    29, 28, 27,    32, 31, 30,    35, 34, 33,    19, 36, 18,
    39, 38, 37,    42, 41, 40,    44, 43, 42,    45, 42, 40,    0, 6, 46,
    2, 47, 1,    39, 37, 48,    51, 50, 49,    28, 52, 27,    55, 54, 53,
    56, 32, 30,    58, 14, 57,    45, 40, 59,    5, 60, 4,    63, 62, 61,
    7, 3, 64,    16, 65, 15,    64, 3, 66,    3, 4, 67,    68, 55, 53,
    69, 35, 33,    49, 50, 70,    25, 71, 24,    73, 72, 0,    75, 74, 23,
    77, 11, 76,    47, 44, 1,    78, 60, 5,    77, 13, 11,    79, 7, 64,
    14, 8, 57,    10, 80, 9,    42, 43, 41,    72, 47, 2,    72, 2, 0,
    60, 81, 4,    4, 82, 67,    73, 0, 83,    83, 0, 46,    46, 6, 59,
    16, 84, 65,    1, 44, 42,    1, 42, 45,    21, 75, 23,    3, 67, 66,
    86, 85, 14,    86, 14, 58,    85, 80, 10,    85, 10, 14,    6, 1, 45,
    88, 87, 84,    89, 39, 48,    4, 81, 82,    61, 90, 63,    90, 61, 91,
    84, 93, 92,    84, 92, 65,    54, 94, 53,    95, 28, 29,
};

D3DMATRIX g_tmat11 = 
{
    0.624756f, 0.773882f, 0.103868f, 0.000000f, 
    -0.126061f, 0.231248f, -0.964693f, 0.000000f, 
    -0.770578f, 0.589604f, 0.242030f, 0.000000f, 
    2.947726f, -2.548667f, 2.062682f, 1.000000f, 
};

// Mesh #11 Tris:86 Verts:114
MODELVERT g_tmesh11[] = 
{
    { {0.080575f, 0.155593f, -0.162286f}, {0.988601f, 0.045595f, -0.143492f}, {0.388095f, 0.231422f} },
    { {0.073496f, 0.012479f, -0.016912f}, {0.961158f, -0.214486f, 0.173697f}, {0.324870f, 0.322770f} },
    { {0.080589f, 0.155373f, -0.017304f}, {0.986528f, 0.049433f, 0.155945f}, {0.387998f, 0.322524f} },
    { {-0.048230f, 0.150767f, -0.161141f}, {-0.992931f, 0.077232f, -0.090134f}, {0.334194f, 0.232142f} },
    { {-0.048230f, 0.219470f, -0.018737f}, {-0.968950f, 0.189710f, 0.158576f}, {0.303841f, 0.321623f} },
    { {-0.061755f, 0.082063f, -0.018737f}, {-0.995462f, 0.077428f, 0.055314f}, {0.364546f, 0.321623f} },
    { {-0.061755f, 0.013359f, -0.161141f}, {-0.983925f, -0.077215f, -0.161026f}, {0.394898f, 0.232142f} },
    { {0.074081f, 0.014080f, -0.161738f}, {0.955016f, -0.258971f, -0.144493f}, {0.325577f, 0.231767f} },
    { {0.011469f, 0.150773f, -0.179769f}, {-0.170553f, 0.039018f, -0.984576f}, {0.362592f, 0.302624f} },
    { {-0.029493f, 0.219470f, -0.179879f}, {-0.280634f, 0.068236f, -0.957386f}, {0.393777f, 0.332293f} },
    { {-0.006763f, 0.013359f, -0.179879f}, {-0.151796f, -0.091391f, -0.984178f}, {0.372065f, 0.242616f} },
    { {0.029492f, 0.238208f, -0.161141f}, {0.141655f, 0.987185f, -0.073482f}, {0.337435f, 0.232142f} },
    { {-0.029493f, 0.238208f, -0.018737f}, {-0.142485f, 0.987408f, 0.068723f}, {0.393777f, 0.321623f} },
    { {-0.029493f, 0.238208f, -0.161141f}, {-0.325926f, 0.933930f, -0.146788f}, {0.393777f, 0.232142f} },
    { {-0.043018f, -0.005378f, -0.161141f}, {-0.113375f, -0.989579f, -0.088762f}, {0.313461f, 0.232142f} },
    { {-0.043017f, -0.005378f, -0.018737f}, {-0.278325f, -0.951353f, 0.132148f}, {0.313461f, 0.321623f} },
    { {0.044166f, -0.006913f, -0.016355f}, {0.085881f, -0.992030f, 0.092202f}, {0.382721f, 0.321623f} },
    { {0.008173f, 0.015096f, 0.011244f}, {-0.208132f, -0.061106f, 0.976190f}, {0.362358f, 0.243371f} },
    { {0.050834f, 0.215237f, 0.006951f}, {0.277138f, 0.103416f, 0.955249f}, {0.403107f, 0.330451f} },
    { {0.047962f, 0.013970f, 0.010465f}, {0.389880f, -0.107649f, 0.914552f}, {0.400363f, 0.242882f} },
    { {-0.030164f, -0.053857f, -0.152260f}, {-0.320831f, -0.905176f, -0.278792f}, {0.325738f, 0.237722f} },
    { {-0.030164f, -0.053857f, -0.026749f}, {-0.675225f, -0.682566f, 0.279596f}, {0.325738f, 0.316589f} },
    { {0.038382f, -0.049965f, -0.026749f}, {0.420534f, -0.863121f, 0.279596f}, {0.391212f, 0.316589f} },
    { {-0.056530f, 0.009535f, -0.026749f}, {-0.370909f, 0.896064f, 0.243915f}, {0.419603f, 0.316589f} },
    { {0.001364f, -0.003565f, -0.163563f}, {-0.053773f, 0.946965f, -0.316806f}, {0.364303f, 0.230620f} },
    { {0.001364f, -0.003565f, -0.016099f}, {-0.047777f, 0.841363f, 0.538355f}, {0.364303f, 0.323281f} },
    { {0.029492f, 0.238208f, -0.018737f}, {0.282875f, 0.949214f, 0.137748f}, {0.337435f, 0.321623f} },
    { {-0.029493f, 0.219470f, 0.000000f}, {-0.211206f, 0.148547f, 0.966088f}, {0.326380f, 0.332293f} },
    { {0.050834f, 0.215237f, 0.006951f}, {0.277138f, 0.103416f, 0.955249f}, {0.382721f, 0.332293f} },
    { {0.011469f, 0.150773f, 0.000110f}, {-0.136182f, 0.010976f, 0.990623f}, {0.357565f, 0.302624f} },
    { {0.036757f, -0.005889f, -0.162476f}, {0.239747f, -0.963029f, -0.122872f}, {0.382721f, 0.232142f} },
    { {0.047932f, 0.014913f, -0.190235f}, {0.411302f, -0.104518f, -0.905487f}, {0.319822f, 0.243292f} },
    { {0.018344f, 0.150358f, -0.190904f}, {-0.237554f, 0.057551f, -0.969668f}, {0.348084f, 0.302223f} },
    { {0.008203f, 0.014205f, -0.190676f}, {-0.163883f, -0.120490f, -0.979094f}, {0.357771f, 0.242984f} },
    { {-0.043017f, 0.013359f, -0.000000f}, {-0.304957f, -0.025404f, 0.952027f}, {0.313461f, 0.242616f} },
    { {-0.043017f, -0.005378f, -0.018737f}, {-0.278325f, -0.951353f, 0.132148f}, {0.313461f, 0.234464f} },
    { {0.001551f, 0.012854f, 0.000110f}, {-0.175981f, -0.275334f, 0.945104f}, {0.348091f, 0.242616f} },
    { {0.044166f, -0.006913f, -0.016355f}, {0.085881f, -0.992030f, 0.092202f}, {0.382721f, 0.234464f} },
    { {0.047932f, 0.014913f, -0.190235f}, {0.411302f, -0.104518f, -0.905487f}, {0.325945f, 0.213860f} },
    { {0.051120f, 0.189414f, -0.190314f}, {0.407822f, 0.094043f, -0.908205f}, {0.403037f, 0.213811f} },
    { {0.032648f, 0.185631f, -0.179879f}, {-0.083004f, 0.170034f, -0.981936f}, {0.334421f, 0.317570f} },
    { {0.029492f, 0.219470f, -0.179879f}, {0.139872f, 0.432016f, -0.890954f}, {0.337436f, 0.332293f} },
    { {-0.043018f, -0.005378f, -0.161141f}, {-0.113375f, -0.989579f, -0.088762f}, {0.406695f, 0.234464f} },
    { {0.036757f, -0.005889f, -0.162476f}, {0.239747f, -0.963029f, -0.122872f}, {0.337436f, 0.234464f} },
    { {-0.043018f, 0.013359f, -0.179879f}, {-0.321952f, -0.059375f, -0.944892f}, {0.406695f, 0.242616f} },
    { {-0.056530f, 0.009535f, -0.152260f}, {-0.976008f, 0.022787f, -0.216538f}, {0.396587f, 0.237722f} },
    { {-0.030164f, -0.053857f, -0.026749f}, {-0.675225f, -0.682566f, 0.279596f}, {0.424593f, 0.316589f} },
    { {-0.030164f, -0.053857f, -0.152260f}, {-0.320831f, -0.905176f, -0.278792f}, {0.424593f, 0.237722f} },
    { {0.038382f, -0.049965f, -0.152260f}, {0.747916f, -0.602409f, -0.278792f}, {0.297283f, 0.237722f} },
    { {0.057402f, 0.016005f, -0.026749f}, {0.739764f, 0.640453f, 0.206322f}, {0.326427f, 0.316589f} },
    { {0.057402f, 0.016005f, -0.152260f}, {0.764470f, 0.515659f, -0.386886f}, {0.326427f, 0.237722f} },
    { {-0.030164f, -0.053857f, -0.026749f}, {-0.675225f, -0.682566f, 0.279596f}, {0.325738f, 0.213371f} },
    { {0.001364f, -0.003565f, -0.016099f}, {-0.047777f, 0.841363f, 0.538355f}, {0.355853f, 0.235252f} },
    { {0.038382f, -0.049965f, -0.026749f}, {0.420534f, -0.863121f, 0.279596f}, {0.391212f, 0.215064f} },
    { {0.038382f, -0.049965f, -0.026749f}, {0.420534f, -0.863121f, 0.279596f}, {0.297283f, 0.316589f} },
    { {0.036757f, -0.005889f, -0.162476f}, {0.239747f, -0.963029f, -0.122872f}, {0.313690f, 0.228524f} },
    { {0.036757f, -0.005889f, -0.162476f}, {0.239747f, -0.963029f, -0.122872f}, {0.331738f, 0.231223f} },
    { {0.044166f, -0.006913f, -0.016355f}, {0.085881f, -0.992030f, 0.092202f}, {0.316303f, 0.323120f} },
    { {0.044166f, -0.006913f, -0.016355f}, {0.085881f, -0.992030f, 0.092202f}, {0.396737f, 0.233796f} },
    { {0.001364f, -0.003565f, -0.163563f}, {-0.053773f, 0.946965f, -0.316806f}, {0.364303f, 0.235252f} },
    { {-0.056530f, 0.009535f, -0.152260f}, {-0.976008f, 0.022787f, -0.216538f}, {0.402488f, 0.239188f} },
    { {-0.030164f, -0.053857f, -0.152260f}, {-0.320831f, -0.905176f, -0.278792f}, {0.394418f, 0.213371f} },
    { {-0.056530f, 0.009535f, -0.152260f}, {-0.976008f, 0.022787f, -0.216538f}, {0.419603f, 0.237722f} },
    { {0.038382f, -0.049965f, -0.152260f}, {0.747916f, -0.602409f, -0.278792f}, {0.328944f, 0.215064f} },
    { {0.038382f, -0.049965f, -0.152260f}, {0.747916f, -0.602409f, -0.278792f}, {0.391212f, 0.237722f} },
    { {-0.056530f, 0.009535f, -0.026749f}, {-0.370909f, 0.896064f, 0.243915f}, {0.300554f, 0.240952f} },
    { {-0.056530f, 0.009535f, -0.026749f}, {-0.370909f, 0.896064f, 0.243915f}, {0.396587f, 0.316589f} },
    { {0.011469f, 0.150773f, 0.000110f}, {-0.136182f, 0.010976f, 0.990623f}, {0.372045f, 0.302226f} },
    { {0.063409f, 0.216894f, -0.017900f}, {0.898049f, 0.437670f, 0.044189f}, {0.415177f, 0.322149f} },
    { {0.063233f, 0.217224f, -0.162843f}, {0.766922f, 0.623043f, -0.153777f}, {0.415323f, 0.231072f} },
    { {0.051120f, 0.189414f, -0.190314f}, {0.407822f, 0.094043f, -0.908205f}, {0.316777f, 0.319216f} },
    { {0.063233f, 0.217224f, -0.162843f}, {0.766922f, 0.623043f, -0.153777f}, {0.304065f, 0.232211f} },
    { {0.032648f, 0.185631f, -0.179879f}, {-0.083004f, 0.170034f, -0.981936f}, {0.319015f, 0.220437f} },
    { {0.051120f, 0.189414f, -0.190314f}, {0.407822f, 0.094043f, -0.908205f}, {0.317120f, 0.213811f} },
    { {-0.061755f, 0.013359f, -0.018737f}, {-0.971543f, -0.208188f, 0.112971f}, {0.394898f, 0.321623f} },
    { {-0.043017f, -0.005378f, -0.018737f}, {-0.278325f, -0.951353f, 0.132148f}, {0.403176f, 0.321623f} },
    { {-0.043017f, 0.013359f, -0.000000f}, {-0.304957f, -0.025404f, 0.952027f}, {0.394898f, 0.333397f} },
    { {0.047962f, 0.013970f, 0.010465f}, {0.389880f, -0.107649f, 0.914552f}, {0.325528f, 0.339973f} },
    { {0.050834f, 0.215237f, 0.006951f}, {0.277138f, 0.103416f, 0.955249f}, {0.414445f, 0.337765f} },
    { {0.063233f, 0.217224f, -0.162843f}, {0.766922f, 0.623043f, -0.153777f}, {0.416315f, 0.232142f} },
    { {0.063409f, 0.216894f, -0.017900f}, {0.898049f, 0.437670f, 0.044189f}, {0.416315f, 0.321623f} },
    { {0.029492f, 0.238208f, -0.018737f}, {0.282875f, 0.949214f, 0.137748f}, {0.424593f, 0.321623f} },
    { {0.057402f, 0.016005f, -0.152260f}, {0.764470f, 0.515659f, -0.386886f}, {0.327342f, 0.241132f} },
    { {0.057402f, 0.016005f, -0.152260f}, {0.764470f, 0.515659f, -0.386886f}, {0.310776f, 0.237722f} },
    { {0.057402f, 0.016005f, -0.026749f}, {0.739764f, 0.640453f, 0.206322f}, {0.310776f, 0.316589f} },
    { {-0.043018f, -0.005378f, -0.161141f}, {-0.113375f, -0.989579f, -0.088762f}, {0.403176f, 0.232142f} },
    { {-0.029493f, 0.219470f, -0.179879f}, {-0.280634f, 0.068236f, -0.957386f}, {0.303841f, 0.220368f} },
    { {-0.043018f, 0.013359f, -0.179879f}, {-0.321952f, -0.059375f, -0.944892f}, {0.394898f, 0.220368f} },
    { {-0.029493f, 0.238208f, -0.161141f}, {-0.325926f, 0.933930f, -0.146788f}, {0.295564f, 0.232142f} },
    { {-0.029493f, 0.238208f, -0.018737f}, {-0.142485f, 0.987408f, 0.068723f}, {0.295564f, 0.321623f} },
    { {-0.029493f, 0.219470f, 0.000000f}, {-0.211206f, 0.148547f, 0.966088f}, {0.303841f, 0.333397f} },
    { {0.032648f, 0.185631f, -0.179879f}, {-0.083004f, 0.170034f, -0.981936f}, {0.401365f, 0.220368f} },
    { {0.029492f, 0.219470f, -0.179879f}, {0.139872f, 0.432016f, -0.890954f}, {0.416315f, 0.220368f} },
    { {0.029492f, 0.238208f, -0.161141f}, {0.141655f, 0.987185f, -0.073482f}, {0.424593f, 0.232142f} },
    { {0.011469f, 0.150773f, -0.179769f}, {-0.170553f, 0.039018f, -0.984576f}, {0.334191f, 0.220437f} },
    { {-0.006763f, 0.013359f, -0.179879f}, {-0.151796f, -0.091391f, -0.984178f}, {0.364592f, 0.220437f} },
    { {0.018344f, 0.150358f, -0.190904f}, {-0.237554f, 0.057551f, -0.969668f}, {0.334374f, 0.213440f} },
    { {-0.048230f, 0.219470f, -0.161141f}, {-0.971543f, 0.208189f, -0.112970f}, {0.303841f, 0.232142f} },
    { {0.057402f, 0.016005f, -0.026749f}, {0.739764f, 0.640453f, 0.206322f}, {0.392814f, 0.241132f} },
    { {0.029492f, 0.238208f, -0.018737f}, {0.282875f, 0.949214f, 0.137748f}, {0.382721f, 0.340445f} },
    { {0.050834f, 0.215237f, 0.006951f}, {0.277138f, 0.103416f, 0.955249f}, {0.416315f, 0.333397f} },
    { {-0.029493f, 0.238208f, -0.018737f}, {-0.142485f, 0.987408f, 0.068723f}, {0.326380f, 0.340445f} },
    { {-0.029493f, 0.238208f, -0.161141f}, {-0.325926f, 0.933930f, -0.146788f}, {0.393777f, 0.340445f} },
    { {0.008203f, 0.014205f, -0.190676f}, {-0.163883f, -0.120490f, -0.979094f}, {0.394524f, 0.213583f} },
    { {0.036757f, -0.005889f, -0.162476f}, {-0.234838f, -0.888136f, -0.395052f}, {0.389661f, 0.231303f} },
    { {0.008203f, 0.014205f, -0.190676f}, {-0.234838f, -0.888136f, -0.395052f}, {0.354445f, 0.213514f} },
    { {-0.006763f, 0.013359f, -0.179879f}, {-0.234838f, -0.888136f, -0.395052f}, {0.348091f, 0.220368f} },
    { {0.001551f, 0.012854f, 0.000110f}, {-0.175981f, -0.275334f, 0.945104f}, {0.395121f, 0.333466f} },
    { {0.011469f, 0.150773f, 0.000110f}, {-0.136182f, 0.010976f, 0.990623f}, {0.334191f, 0.333466f} },
    { {0.008173f, 0.015096f, 0.011244f}, {-0.208132f, -0.061106f, 0.976190f}, {0.394131f, 0.340462f} },
    { {0.044166f, -0.006913f, -0.016355f}, {0.085881f, -0.992030f, 0.092202f}, {0.396737f, 0.323120f} },
    { {0.001551f, 0.012854f, 0.000110f}, {-0.175981f, -0.275334f, 0.945104f}, {0.356032f, 0.333466f} },
    { {0.008173f, 0.015096f, 0.011244f}, {-0.208132f, -0.061106f, 0.976190f}, {0.362358f, 0.340462f} },
    { {0.029492f, 0.238208f, -0.161141f}, {0.141655f, 0.987185f, -0.073482f}, {0.337435f, 0.340445f} },
};

WORD g_tind11[] = 
{
    2, 1, 0,    5, 4, 3,    6, 5, 3,    0, 1, 7,    10, 9, 8,
    13, 12, 11,    16, 15, 14,    19, 18, 17,    22, 21, 20,    25, 24, 23,
    12, 26, 11,    29, 28, 27,    30, 16, 14,    33, 32, 31,    29, 27, 34,
    37, 36, 35,    39, 0, 38,    9, 41, 40,    10, 43, 42,    44, 9, 10,
    47, 46, 45,    50, 49, 48,    53, 52, 51,    49, 54, 48,    7, 1, 55,
    31, 56, 33,    1, 57, 55,    58, 19, 17,    61, 60, 59,    62, 23, 24,
    63, 61, 59,    64, 22, 20,    51, 52, 65,    46, 66, 45,    17, 18, 67,
    36, 29, 34,    69, 68, 0,    69, 0, 39,    32, 70, 31,    73, 72, 71,
    75, 74, 6,    5, 76, 4,    78, 77, 1,    1, 77, 57,    81, 80, 79,
    2, 78, 1,    82, 63, 59,    24, 84, 83,    85, 75, 6,    87, 6, 86,
    4, 89, 88,    76, 90, 4,    92, 79, 91,    93, 81, 79,    96, 95, 94,
    72, 73, 96,    97, 4, 88,    6, 3, 86,    0, 7, 38,    7, 55, 38,
    84, 24, 25,    98, 52, 53,    27, 28, 99,    81, 100, 80,    4, 90, 89,
    101, 27, 99,    10, 42, 44,    85, 6, 87,    68, 78, 2,    68, 2, 0,
    97, 88, 86,    9, 102, 41,    36, 34, 35,    75, 76, 74,    95, 96, 103,
    106, 105, 104,    109, 108, 107,    112, 111, 110,    96, 94, 72,    8, 9, 40,
    102, 113, 41,    93, 79, 92,    3, 4, 97,    3, 97, 86,    74, 76, 5,
    74, 5, 6,
};

D3DMATRIX g_tmat12 = 
{
    0.390174f, 0.736669f, -0.552344f, 0.000000f, 
    -0.503960f, -0.331190f, -0.797708f, 0.000000f, 
    -0.770578f, 0.589604f, 0.242030f, 0.000000f, 
    2.931443f, -2.503402f, 1.823379f, 1.000000f, 
};

// Mesh #12 Tris:96 Verts:126
MODELVERT g_tmesh12[] = 
{
    { {-0.037649f, 0.169679f, -0.124915f}, {-0.987881f, 0.132022f, -0.081620f}, {0.303851f, 0.234286f} },
    { {-0.037388f, 0.130414f, -0.014525f}, {-0.975095f, 0.101428f, 0.197237f}, {0.328516f, 0.319571f} },
    { {-0.044909f, 0.076245f, -0.006146f}, {-0.992219f, 0.074700f, 0.099610f}, {0.362543f, 0.326044f} },
    { {0.047699f, 0.023053f, -0.133575f}, {0.993320f, -0.042029f, -0.107464f}, {0.324201f, 0.227596f} },
    { {0.047598f, 0.021385f, -0.005583f}, {0.965402f, -0.219547f, 0.140703f}, {0.323153f, 0.326479f} },
    { {0.047717f, 0.130245f, -0.014095f}, {0.994373f, 0.041688f, 0.097389f}, {0.391534f, 0.319903f} },
    { {0.042943f, 0.168841f, -0.125763f}, {0.956423f, 0.238993f, -0.167742f}, {0.415779f, 0.233632f} },
    { {-0.044999f, 0.077181f, -0.133336f}, {-0.996216f, 0.042231f, -0.075968f}, {0.361955f, 0.227781f} },
    { {-0.030383f, 0.022987f, 0.008379f}, {-0.317334f, -0.108011f, 0.942143f}, {0.316933f, 0.241533f} },
    { {0.000842f, 0.075984f, 0.008391f}, {0.000145f, 0.075145f, 0.997173f}, {0.355923f, 0.274481f} },
    { {-0.003717f, 0.022987f, 0.008379f}, {-0.035887f, -0.299913f, 0.953291f}, {0.355923f, 0.241533f} },
    { {-0.030474f, 0.009397f, -0.133336f}, {-0.154304f, -0.985964f, -0.063755f}, {0.316801f, 0.227781f} },
    { {-0.030383f, 0.008461f, -0.006146f}, {-0.466494f, -0.877549f, 0.110866f}, {0.316933f, 0.326044f} },
    { {-0.002061f, 0.005435f, -0.003231f}, {-0.015275f, -0.999294f, 0.034318f}, {0.355923f, 0.326044f} },
    { {-0.030383f, 0.076245f, 0.008379f}, {-0.377851f, 0.116526f, 0.918504f}, {0.316933f, 0.274481f} },
    { {-0.022862f, 0.130414f, 0.000000f}, {-0.203387f, 0.192181f, 0.960052f}, {0.327930f, 0.307992f} },
    { {0.018244f, 0.182873f, -0.124915f}, {0.130302f, 0.989203f, -0.067074f}, {0.332125f, 0.234286f} },
    { {0.018244f, 0.182873f, -0.014525f}, {0.452402f, 0.886931f, 0.093196f}, {0.332125f, 0.319571f} },
    { {-0.027481f, 0.182873f, -0.014525f}, {-0.141763f, 0.945816f, 0.292122f}, {0.398980f, 0.319571f} },
    { {-0.003807f, 0.009397f, -0.133336f}, {-0.059632f, -0.994361f, -0.087697f}, {0.355791f, 0.227781f} },
    { {0.027509f, 0.008200f, -0.006134f}, {-0.008759f, -0.999872f, -0.013416f}, {0.401578f, 0.326053f} },
    { {0.031621f, 0.005849f, -0.133983f}, {-0.099364f, -0.994937f, 0.015098f}, {0.401446f, 0.227791f} },
    { {0.030486f, 0.077228f, -0.151715f}, {0.425062f, 0.090585f, -0.900620f}, {0.358231f, 0.213582f} },
    { {0.004558f, 0.130153f, -0.139428f}, {-0.074101f, 0.197189f, -0.977561f}, {0.358799f, 0.307992f} },
    { {-0.030474f, 0.077181f, -0.147861f}, {-0.281288f, 0.122930f, -0.951717f}, {0.403355f, 0.275060f} },
    { {0.000752f, 0.076920f, -0.147849f}, {0.001338f, 0.113624f, -0.993523f}, {0.364365f, 0.275060f} },
    { {-0.027481f, 0.182873f, -0.124915f}, {-0.308852f, 0.745701f, -0.590372f}, {0.398980f, 0.234286f} },
    { {-0.026550f, -0.021768f, -0.117522f}, {-0.389644f, -0.889579f, -0.238384f}, {0.322538f, 0.239999f} },
    { {-0.026550f, -0.021768f, -0.021530f}, {-0.733362f, -0.636450f, 0.238979f}, {0.322538f, 0.314159f} },
    { {0.017454f, -0.022536f, -0.021530f}, {0.357771f, -0.902713f, 0.238978f}, {0.386877f, 0.314159f} },
    { {-0.040394f, 0.020009f, -0.021530f}, {-0.306270f, 0.928747f, 0.208875f}, {0.417860f, 0.314159f} },
    { {-0.004006f, 0.008885f, -0.124767f}, {0.016798f, 0.962364f, -0.271243f}, {0.364657f, 0.234401f} },
    { {-0.004006f, 0.008885f, -0.014703f}, {0.015339f, 0.878779f, 0.476982f}, {0.364657f, 0.319433f} },
    { {-0.030474f, 0.077181f, -0.147861f}, {-0.281288f, 0.122930f, -0.951717f}, {0.361955f, 0.216559f} },
    { {-0.044999f, 0.023923f, -0.133336f}, {-0.943568f, -0.301419f, -0.137204f}, {0.395410f, 0.227781f} },
    { {-0.030474f, 0.023923f, -0.147861f}, {-0.321818f, -0.298196f, -0.898617f}, {0.395410f, 0.216559f} },
    { {-0.030383f, 0.008461f, -0.006146f}, {-0.466494f, -0.877549f, 0.110866f}, {0.405122f, 0.326044f} },
    { {-0.030474f, 0.009397f, -0.133336f}, {-0.154304f, -0.985964f, -0.063755f}, {0.404534f, 0.227781f} },
    { {0.000842f, 0.075984f, 0.008391f}, {-0.129920f, 0.081562f, 0.988164f}, {0.365017f, 0.274511f} },
    { {0.030543f, 0.076094f, 0.012287f}, {0.312877f, 0.090125f, 0.945508f}, {0.406015f, 0.274388f} },
    { {-0.003717f, 0.022987f, 0.008379f}, {-0.122264f, -0.094923f, 0.987948f}, {0.365011f, 0.240985f} },
    { {0.031621f, 0.005849f, -0.133983f}, {0.557038f, -0.815081f, -0.159222f}, {0.313394f, 0.227281f} },
    { {0.027509f, 0.008200f, -0.006134f}, {0.491288f, -0.853261f, 0.174874f}, {0.312721f, 0.326572f} },
    { {0.022802f, 0.168087f, -0.006326f}, {0.353278f, 0.377398f, 0.856017f}, {0.388032f, 0.331459f} },
    { {0.000000f, 0.130414f, 0.000000f}, {-0.000001f, 0.157783f, 0.987474f}, {0.361357f, 0.307992f} },
    { {0.000000f, 0.130414f, 0.000000f}, {-0.155986f, 0.169465f, 0.973113f}, {0.370456f, 0.308175f} },
    { {0.026014f, 0.168670f, -0.002552f}, {0.291075f, 0.188263f, 0.937994f}, {0.399393f, 0.331659f} },
    { {0.002410f, 0.022260f, -0.151770f}, {-0.073168f, -0.116944f, -0.990440f}, {0.364365f, 0.242112f} },
    { {-0.030474f, 0.023923f, -0.147861f}, {-0.321818f, -0.298196f, -0.898617f}, {0.403355f, 0.242112f} },
    { {-0.003807f, 0.009397f, -0.133336f}, {-0.091106f, -0.802004f, -0.590330f}, {0.355298f, 0.231093f} },
    { {0.031621f, 0.005849f, -0.133983f}, {0.557038f, -0.815081f, -0.159222f}, {0.312565f, 0.230931f} },
    { {0.002410f, 0.022260f, -0.151770f}, {-0.021694f, -0.383331f, -0.923356f}, {0.355275f, 0.241083f} },
    { {-0.040394f, 0.020009f, -0.117522f}, {-0.977898f, 0.099049f, -0.184133f}, {0.397868f, 0.239999f} },
    { {-0.026550f, -0.021768f, -0.021530f}, {-0.733362f, -0.636450f, 0.238979f}, {0.424111f, 0.314159f} },
    { {-0.026550f, -0.021768f, -0.117522f}, {-0.389644f, -0.889579f, -0.238384f}, {0.424111f, 0.239999f} },
    { {0.017454f, -0.022536f, -0.117522f}, {0.710417f, -0.662178f, -0.238384f}, {0.295564f, 0.239999f} },
    { {0.032747f, 0.018733f, -0.021530f}, {0.793619f, 0.582533f, 0.175568f}, {0.321487f, 0.314159f} },
    { {0.032747f, 0.018733f, -0.117522f}, {0.812300f, 0.477614f, -0.334745f}, {0.321487f, 0.239999f} },
    { {-0.026550f, -0.021768f, -0.021530f}, {-0.733362f, -0.636450f, 0.238979f}, {0.322538f, 0.213846f} },
    { {-0.004006f, 0.008885f, -0.014703f}, {0.015339f, 0.878779f, 0.476982f}, {0.355499f, 0.232809f} },
    { {0.017454f, -0.022536f, -0.021530f}, {0.357771f, -0.902713f, 0.238978f}, {0.386877f, 0.213371f} },
    { {0.017454f, -0.022536f, -0.021530f}, {0.357771f, -0.902713f, 0.238978f}, {0.295564f, 0.314159f} },
    { {0.030486f, 0.077228f, -0.151715f}, {0.425062f, 0.090585f, -0.900620f}, {0.314225f, 0.275089f} },
    { {0.006222f, 0.130714f, -0.143510f}, {-0.148076f, 0.148396f, -0.977779f}, {0.349703f, 0.308178f} },
    { {0.000752f, 0.076920f, -0.147849f}, {-0.131451f, 0.059466f, -0.989537f}, {0.355270f, 0.274983f} },
    { {0.030445f, 0.023103f, -0.151722f}, {0.218854f, -0.133706f, -0.966554f}, {0.314284f, 0.241605f} },
    { {0.030342f, 0.021458f, 0.012179f}, {0.230599f, -0.305351f, 0.923897f}, {0.405721f, 0.240587f} },
    { {-0.002061f, 0.005435f, -0.003231f}, {0.003431f, -0.696778f, 0.717279f}, {0.365009f, 0.230513f} },
    { {-0.030383f, 0.008461f, -0.006146f}, {-0.466494f, -0.877549f, 0.110866f}, {0.316933f, 0.232547f} },
    { {-0.002061f, 0.005435f, -0.003231f}, {-0.015275f, -0.999294f, 0.034318f}, {0.355923f, 0.232547f} },
    { {0.042943f, 0.168841f, -0.125763f}, {0.956423f, 0.238993f, -0.167742f}, {0.296012f, 0.233632f} },
    { {0.043072f, 0.168589f, -0.014252f}, {0.840361f, 0.529426f, 0.116196f}, {0.295823f, 0.319782f} },
    { {0.022802f, 0.168087f, -0.006326f}, {-0.045018f, 0.998697f, 0.024052f}, {0.325460f, 0.325905f} },
    { {0.030543f, 0.076094f, 0.012287f}, {0.312877f, 0.090125f, 0.945508f}, {0.357519f, 0.340284f} },
    { {0.026014f, 0.168670f, -0.002552f}, {0.291075f, 0.188263f, 0.937994f}, {0.415671f, 0.328821f} },
    { {-0.004006f, 0.008885f, -0.124767f}, {0.016798f, 0.962364f, -0.271243f}, {0.364657f, 0.232809f} },
    { {-0.040394f, 0.020009f, -0.117522f}, {-0.977898f, 0.099049f, -0.184133f}, {0.401394f, 0.237561f} },
    { {-0.026550f, -0.021768f, -0.117522f}, {-0.389644f, -0.889579f, -0.238384f}, {0.397619f, 0.213846f} },
    { {-0.040394f, 0.020009f, -0.117522f}, {-0.977898f, 0.099049f, -0.184133f}, {0.417860f, 0.239999f} },
    { {0.017454f, -0.022536f, -0.117522f}, {0.710417f, -0.662178f, -0.238384f}, {0.333280f, 0.213371f} },
    { {0.017454f, -0.022536f, -0.117522f}, {0.710417f, -0.662178f, -0.238384f}, {0.386877f, 0.239999f} },
    { {-0.040394f, 0.020009f, -0.021530f}, {-0.306270f, 0.928747f, 0.208875f}, {0.318763f, 0.237561f} },
    { {-0.040394f, 0.020009f, -0.021530f}, {-0.306270f, 0.928747f, 0.208875f}, {0.397868f, 0.314159f} },
    { {0.025297f, 0.168827f, -0.137052f}, {0.222696f, 0.625152f, -0.748058f}, {0.321812f, 0.224910f} },
    { {0.025297f, 0.168827f, -0.137052f}, {0.222696f, 0.625152f, -0.748058f}, {0.415770f, 0.224910f} },
    { {-0.044909f, 0.022986f, -0.006146f}, {-0.990446f, -0.124467f, 0.059372f}, {0.395998f, 0.326044f} },
    { {-0.030383f, 0.076245f, 0.008379f}, {-0.377851f, 0.116526f, 0.918504f}, {0.362543f, 0.337265f} },
    { {-0.027481f, 0.182873f, -0.124915f}, {-0.308852f, 0.745701f, -0.590372f}, {0.398980f, 0.340445f} },
    { {0.027509f, 0.008200f, -0.006134f}, {0.491288f, -0.853261f, 0.174874f}, {0.407458f, 0.230269f} },
    { {0.030445f, 0.023103f, -0.151722f}, {0.218854f, -0.133706f, -0.966554f}, {0.324232f, 0.213576f} },
    { {-0.003807f, 0.009397f, -0.133336f}, {-0.059632f, -0.994361f, -0.087697f}, {0.364365f, 0.233126f} },
    { {0.018244f, 0.168348f, -0.133102f}, {-0.098949f, 0.292314f, -0.951189f}, {0.332125f, 0.331459f} },
    { {0.025297f, 0.168827f, -0.137052f}, {0.222696f, 0.625152f, -0.748058f}, {0.321812f, 0.331756f} },
    { {0.032747f, 0.018733f, -0.117522f}, {0.812300f, 0.477614f, -0.334745f}, {0.327551f, 0.237016f} },
    { {0.032747f, 0.018733f, -0.117522f}, {0.812300f, 0.477614f, -0.334745f}, {0.310919f, 0.239999f} },
    { {0.032747f, 0.018733f, -0.021530f}, {0.793619f, 0.582533f, 0.175568f}, {0.310919f, 0.314159f} },
    { {0.018244f, 0.182873f, -0.124915f}, {0.130302f, 0.989203f, -0.067074f}, {0.332125f, 0.340445f} },
    { {0.025297f, 0.168827f, -0.137052f}, {0.920117f, 0.391284f, -0.016750f}, {0.415469f, 0.234286f} },
    { {0.018244f, 0.182873f, -0.014525f}, {0.452402f, 0.886931f, 0.093196f}, {0.424593f, 0.319571f} },
    { {0.018244f, 0.182873f, -0.124915f}, {0.130302f, 0.989203f, -0.067074f}, {0.424593f, 0.234286f} },
    { {-0.030383f, 0.022987f, 0.008379f}, {-0.317334f, -0.108011f, 0.942143f}, {0.395998f, 0.337265f} },
    { {-0.022862f, 0.130414f, 0.000000f}, {-0.203387f, 0.192181f, 0.960052f}, {0.328516f, 0.330792f} },
    { {-0.027481f, 0.182873f, -0.124915f}, {-0.308852f, 0.745701f, -0.590372f}, {0.295564f, 0.234286f} },
    { {-0.027481f, 0.182873f, -0.014525f}, {-0.141763f, 0.945816f, 0.292122f}, {0.295564f, 0.319571f} },
    { {-0.037649f, 0.169679f, -0.014525f}, {-0.950033f, 0.279917f, 0.138146f}, {0.303851f, 0.319571f} },
    { {0.030342f, 0.021458f, 0.012179f}, {0.230599f, -0.305351f, 0.923897f}, {0.323199f, 0.340201f} },
    { {0.032747f, 0.018733f, -0.021530f}, {0.793619f, 0.582533f, 0.175568f}, {0.392606f, 0.237016f} },
    { {-0.027481f, 0.182873f, -0.124915f}, {-0.308852f, 0.745701f, -0.590372f}, {0.304407f, 0.227962f} },
    { {0.022802f, 0.168087f, -0.006326f}, {0.353278f, 0.377398f, 0.856017f}, {0.415469f, 0.325896f} },
    { {0.018244f, 0.182873f, -0.014525f}, {0.452402f, 0.886931f, 0.093196f}, {0.388032f, 0.340445f} },
    { {-0.027481f, 0.182873f, -0.014525f}, {-0.141763f, 0.945816f, 0.292122f}, {0.321176f, 0.340445f} },
    { {-0.030474f, 0.009397f, -0.133336f}, {-0.154304f, -0.985964f, -0.063755f}, {0.403355f, 0.233126f} },
    { {0.018244f, 0.168348f, -0.133102f}, {-0.098949f, 0.292314f, -0.951189f}, {0.415469f, 0.227962f} },
    { {0.006222f, 0.130714f, -0.143510f}, {-0.472651f, 0.371933f, -0.798916f}, {0.328164f, 0.219911f} },
    { {0.025297f, 0.168827f, -0.137052f}, {-0.472651f, 0.371933f, -0.798916f}, {0.304223f, 0.224900f} },
    { {0.018244f, 0.168348f, -0.133102f}, {-0.472651f, 0.371933f, -0.798916f}, {0.304688f, 0.227962f} },
    { {-0.037649f, 0.169679f, -0.014525f}, {-0.950033f, 0.279917f, 0.138146f}, {0.306310f, 0.332283f} },
    { {0.000000f, 0.130414f, 0.000000f}, {-0.155986f, 0.169465f, 0.973113f}, {0.328680f, 0.330802f} },
    { {0.022802f, 0.168087f, -0.006326f}, {-0.045018f, 0.998697f, 0.024052f}, {0.304852f, 0.325905f} },
    { {0.026014f, 0.168670f, -0.002552f}, {0.291075f, 0.188263f, 0.937994f}, {0.304485f, 0.328821f} },
    { {0.026014f, 0.168670f, -0.002552f}, {0.291075f, 0.188263f, 0.937994f}, {0.320763f, 0.328821f} },
    { {0.043072f, 0.168589f, -0.014252f}, {0.840361f, 0.529426f, 0.116196f}, {0.415620f, 0.319782f} },
    { {0.018244f, 0.168348f, -0.133102f}, {-0.878422f, 0.365694f, -0.307641f}, {0.304852f, 0.227971f} },
    { {0.004558f, 0.130153f, -0.139428f}, {-0.912004f, 0.229338f, -0.340078f}, {0.328680f, 0.223074f} },
    { {0.006222f, 0.130714f, -0.143510f}, {-0.148076f, 0.148396f, -0.977779f}, {0.328328f, 0.219921f} },
    { {0.000752f, 0.076920f, -0.147849f}, {-0.131451f, 0.059466f, -0.989537f}, {0.362119f, 0.216569f} },
};

WORD g_tind12[] = 
{
    2, 1, 0,    5, 4, 3,    6, 5, 3,    7, 2, 0,    10, 9, 8,
    13, 12, 11,    9, 15, 14,    18, 17, 16,    21, 20, 19,    6, 3, 22,
    25, 24, 23,    26, 18, 16,    29, 28, 27,    32, 31, 30,    35, 34, 33,
    37, 36, 34,    40, 39, 38,    4, 42, 41,    44, 43, 15,    39, 46, 45,
    48, 24, 47,    51, 50, 49,    54, 53, 52,    57, 56, 55,    60, 59, 58,
    56, 61, 55,    64, 63, 62,    65, 50, 51,    67, 66, 40,    69, 10, 68,
    72, 71, 70,    74, 73, 5,    77, 76, 75,    78, 30, 31,    79, 77, 75,
    80, 29, 27,    58, 59, 81,    53, 82, 52,    70, 83, 72,    84, 6, 22,
    36, 85, 34,    2, 86, 1,    7, 0, 33,    24, 87, 23,    88, 66, 67,
    20, 13, 11,    3, 4, 41,    3, 41, 89,    47, 90, 48,    19, 20, 11,
    23, 87, 91,    63, 92, 62,    93, 79, 75,    31, 95, 94,    5, 73, 4,
    66, 39, 40,    87, 96, 91,    99, 98, 97,    38, 39, 45,    9, 44, 15,
    10, 8, 68,    36, 100, 85,    86, 101, 1,    104, 103, 102,    64, 62, 65,
    22, 3, 89,    73, 105, 4,    4, 105, 42,    95, 31, 32,    106, 59, 60,
    33, 0, 107,    0, 104, 102,    47, 24, 25,    51, 64, 65,    98, 108, 97,
    110, 43, 109,    90, 111, 48,    37, 34, 35,    99, 97, 112,    115, 114, 113,
    34, 85, 7,    34, 7, 33,    9, 14, 8,    100, 86, 2,    43, 110, 15,
    15, 110, 116,    85, 100, 2,    85, 2, 7,    119, 118, 117,    72, 120, 71,
    121, 74, 5,    121, 5, 6,    124, 123, 122,    123, 124, 125,    1, 101, 104,
    1, 104, 0,
};

D3DMATRIX g_tmat13 = 
{
    0.134923f, 0.522047f, -0.842178f, 0.000000f, 
    -0.622902f, -0.616308f, -0.481829f, 0.000000f, 
    -0.770578f, 0.589604f, 0.242030f, 0.000000f, 
    2.842277f, -2.567515f, 1.674885f, 1.000000f, 
};

// Mesh #13 Tris:74 Verts:96
MODELVERT g_tmesh13[] = 
{
    { {-0.028660f, 0.022378f, -0.099933f}, {-0.956107f, -0.266115f, -0.122645f}, {0.399661f, 0.228668f} },
    { {-0.038275f, 0.106688f, -0.021795f}, {-0.991157f, -0.034084f, 0.128240f}, {0.330727f, 0.313958f} },
    { {-0.028660f, 0.022378f, -0.011620f}, {-0.958951f, -0.260729f, 0.111507f}, {0.399661f, 0.325064f} },
    { {0.039504f, 0.021818f, -0.100087f}, {0.992702f, 0.054488f, -0.107583f}, {0.320038f, 0.228500f} },
    { {0.039421f, 0.021293f, -0.011199f}, {0.984197f, -0.087556f, 0.153916f}, {0.319608f, 0.325524f} },
    { {0.027480f, 0.106703f, -0.020045f}, {0.966262f, 0.233486f, 0.108728f}, {0.389442f, 0.315868f} },
    { {-0.038374f, 0.107393f, -0.094738f}, {-0.977200f, -0.010133f, -0.212080f}, {0.330151f, 0.234339f} },
    { {0.027318f, 0.107395f, -0.096048f}, {0.896232f, 0.389855f, -0.211615f}, {0.390008f, 0.232909f} },
    { {0.017843f, 0.107867f, -0.095511f}, {0.999341f, 0.022808f, -0.028235f}, {0.390394f, 0.233495f} },
    { {0.010364f, 0.108277f, -0.009200f}, {0.667888f, 0.135024f, 0.731912f}, {0.391887f, 0.327691f} },
    { {0.014326f, 0.136946f, -0.026711f}, {0.974534f, 0.191014f, 0.117463f}, {0.414170f, 0.308592f} },
    { {-0.024591f, 0.109598f, -0.010116f}, {-0.271772f, 0.184857f, 0.944440f}, {0.319766f, 0.308158f} },
    { {0.002368f, 0.139352f, -0.015699f}, {-0.018588f, 0.484726f, 0.874468f}, {0.367105f, 0.332117f} },
    { {0.010364f, 0.108277f, -0.009200f}, {0.667888f, 0.135024f, 0.731912f}, {0.373424f, 0.308235f} },
    { {0.014171f, 0.138048f, -0.092316f}, {0.890795f, 0.422420f, -0.167467f}, {0.415071f, 0.236982f} },
    { {0.020090f, 0.065898f, -0.113666f}, {-0.086695f, 0.076436f, -0.993298f}, {0.336170f, 0.273605f} },
    { {-0.024512f, 0.109038f, -0.106454f}, {-0.316549f, 0.064886f, -0.946354f}, {0.400252f, 0.307707f} },
    { {-0.017040f, 0.022378f, -0.111553f}, {-0.318515f, -0.013969f, -0.947815f}, {0.387131f, 0.237925f} },
    { {-0.009955f, 0.007219f, -0.100082f}, {0.014809f, -0.996575f, -0.081360f}, {0.345467f, 0.228506f} },
    { {0.025766f, 0.007715f, -0.011429f}, {0.177256f, -0.981035f, 0.078432f}, {0.408192f, 0.325272f} },
    { {0.026225f, 0.007856f, -0.100281f}, {0.358352f, -0.916151f, -0.179586f}, {0.408998f, 0.228288f} },
    { {0.026229f, 0.021519f, -0.113885f}, {0.192763f, -0.201113f, -0.960415f}, {0.311151f, 0.237233f} },
    { {0.020090f, 0.065898f, -0.113666f}, {0.454238f, 0.121499f, -0.882557f}, {0.321931f, 0.272969f} },
    { {-0.017040f, 0.022378f, -0.111553f}, {-0.044219f, -0.313191f, -0.948660f}, {0.374693f, 0.236478f} },
    { {-0.016928f, -0.007972f, -0.092014f}, {-0.374339f, -0.887654f, -0.268219f}, {0.333223f, 0.237312f} },
    { {0.015914f, -0.008102f, -0.015460f}, {0.341143f, -0.853439f, 0.394034f}, {0.390892f, 0.320873f} },
    { {0.015916f, -0.008115f, -0.092014f}, {0.712974f, -0.646470f, -0.271558f}, {0.390895f, 0.237312f} },
    { {0.026924f, 0.022829f, -0.092014f}, {0.404238f, 0.904139f, -0.138292f}, {0.309930f, 0.237312f} },
    { {-0.027668f, 0.023080f, -0.015460f}, {-0.271731f, 0.910031f, 0.313059f}, {0.405793f, 0.320873f} },
    { {-0.000769f, 0.022686f, -0.097421f}, {0.003661f, 0.838983f, -0.544146f}, {0.358559f, 0.231410f} },
    { {-0.027666f, 0.023067f, -0.092014f}, {-0.983332f, 0.071759f, -0.167060f}, {0.399098f, 0.237312f} },
    { {-0.027668f, 0.023080f, -0.015460f}, {-0.271731f, 0.910031f, 0.313059f}, {0.399087f, 0.320873f} },
    { {-0.016930f, -0.007959f, -0.015460f}, {-0.743732f, -0.649287f, 0.159026f}, {0.424465f, 0.320873f} },
    { {0.015916f, -0.008115f, -0.092014f}, {0.712974f, -0.646470f, -0.271558f}, {0.295564f, 0.237312f} },
    { {0.015914f, -0.008102f, -0.015460f}, {0.341143f, -0.853439f, 0.394034f}, {0.295574f, 0.320873f} },
    { {0.026922f, 0.022842f, -0.015460f}, {0.844733f, 0.442899f, 0.300443f}, {0.320875f, 0.320873f} },
    { {-0.010000f, 0.007261f, -0.011117f}, {0.000238f, -0.965664f, 0.259795f}, {0.345387f, 0.325614f} },
    { {-0.017040f, 0.022378f, -0.000000f}, {-0.059997f, -0.188223f, 0.980292f}, {0.345437f, 0.236686f} },
    { {0.019875f, 0.067259f, 0.002232f}, {0.493746f, 0.138069f, 0.858576f}, {0.397848f, 0.274065f} },
    { {0.025886f, 0.021144f, 0.002390f}, {0.161189f, -0.268120f, 0.949805f}, {0.408403f, 0.236931f} },
    { {0.002561f, 0.149597f, -0.090944f}, {-0.119101f, 0.991419f, -0.053874f}, {0.295564f, 0.238739f} },
    { {0.002747f, 0.148271f, -0.029496f}, {0.165145f, 0.979830f, 0.112520f}, {0.296680f, 0.305025f} },
    { {-0.033379f, 0.136797f, -0.028121f}, {-0.560507f, 0.792602f, 0.240029f}, {0.306109f, 0.307053f} },
    { {0.002368f, 0.139352f, -0.015699f}, {-0.018588f, 0.484726f, 0.874468f}, {0.303181f, 0.319853f} },
    { {-0.024591f, 0.109598f, -0.010116f}, {-0.271772f, 0.184857f, 0.944440f}, {0.328348f, 0.326706f} },
    { {-0.033550f, 0.138012f, -0.091622f}, {-0.832409f, 0.543603f, -0.107662f}, {0.305115f, 0.237740f} },
    { {-0.024512f, 0.109038f, -0.106454f}, {-0.316549f, 0.064886f, -0.946354f}, {0.328805f, 0.221551f} },
    { {0.015914f, -0.008102f, -0.015460f}, {0.341143f, -0.853439f, 0.394034f}, {0.390892f, 0.213381f} },
    { {-0.027668f, 0.023080f, -0.015460f}, {-0.271731f, 0.910031f, 0.313059f}, {0.329179f, 0.236510f} },
    { {0.026922f, 0.022842f, -0.015460f}, {0.844733f, 0.442899f, 0.300443f}, {0.395370f, 0.236378f} },
    { {0.026922f, 0.022842f, -0.015460f}, {0.844733f, 0.442899f, 0.300443f}, {0.309934f, 0.320873f} },
    { {-0.010000f, 0.007261f, -0.011117f}, {-0.629686f, -0.775885f, 0.038707f}, {0.409162f, 0.325064f} },
    { {-0.010000f, 0.007261f, -0.011117f}, {0.000238f, -0.965664f, 0.259795f}, {0.345387f, 0.225753f} },
    { {-0.000769f, 0.022686f, -0.097421f}, {0.003661f, 0.838983f, -0.544146f}, {0.358559f, 0.238173f} },
    { {-0.016928f, -0.007972f, -0.092014f}, {-0.374339f, -0.887654f, -0.268219f}, {0.386934f, 0.213486f} },
    { {0.015916f, -0.008115f, -0.092014f}, {0.712974f, -0.646470f, -0.271558f}, {0.329261f, 0.213371f} },
    { {-0.016928f, -0.007972f, -0.092014f}, {-0.374339f, -0.887654f, -0.268219f}, {0.424476f, 0.237312f} },
    { {0.006055f, 0.109061f, -0.106898f}, {0.184626f, 0.143235f, -0.972315f}, {0.391370f, 0.221065f} },
    { {0.002383f, 0.139242f, -0.103703f}, {0.372815f, 0.367480f, -0.852037f}, {0.416047f, 0.224553f} },
    { {-0.013316f, 0.140325f, -0.103361f}, {-0.286277f, 0.348830f, -0.892392f}, {0.303224f, 0.224926f} },
    { {0.019875f, 0.067259f, 0.002232f}, {0.493746f, 0.138069f, 0.858576f}, {0.357191f, 0.340184f} },
    { {0.027318f, 0.107395f, -0.096048f}, {0.896232f, 0.389855f, -0.211615f}, {0.309239f, 0.232909f} },
    { {0.027480f, 0.106703f, -0.020045f}, {0.966262f, 0.233486f, 0.108728f}, {0.308955f, 0.315868f} },
    { {0.010364f, 0.108277f, -0.009200f}, {0.243211f, 0.931805f, 0.269420f}, {0.339010f, 0.327705f} },
    { {0.020090f, 0.065898f, -0.113666f}, {0.454238f, 0.121499f, -0.882557f}, {0.356079f, 0.213678f} },
    { {0.006055f, 0.109061f, -0.106898f}, {0.184626f, 0.143235f, -0.972315f}, {0.346577f, 0.307726f} },
    { {0.026924f, 0.022829f, -0.092014f}, {0.404238f, 0.904139f, -0.138292f}, {0.324783f, 0.236367f} },
    { {0.026924f, 0.022829f, -0.092014f}, {0.404238f, 0.904139f, -0.138292f}, {0.320864f, 0.237312f} },
    { {-0.016930f, -0.007959f, -0.015460f}, {-0.743732f, -0.649287f, 0.159026f}, {0.333219f, 0.213497f} },
    { {-0.016930f, -0.007959f, -0.015460f}, {-0.743732f, -0.649287f, 0.159026f}, {0.333219f, 0.320873f} },
    { {-0.009955f, 0.007219f, -0.100082f}, {-0.628286f, -0.774593f, -0.072543f}, {0.409162f, 0.228668f} },
    { {-0.009955f, 0.007219f, -0.100082f}, {0.014809f, -0.996575f, -0.081360f}, {0.374689f, 0.225719f} },
    { {0.026225f, 0.007856f, -0.100281f}, {0.358352f, -0.916151f, -0.179586f}, {0.311158f, 0.226231f} },
    { {-0.017040f, 0.022378f, -0.000000f}, {-0.433262f, 0.030738f, 0.900744f}, {0.333026f, 0.237925f} },
    { {0.019875f, 0.067259f, 0.002232f}, {-0.132115f, 0.147135f, 0.980254f}, {0.383649f, 0.274707f} },
    { {-0.017040f, 0.022378f, -0.000000f}, {-0.433262f, 0.030738f, 0.900744f}, {0.399661f, 0.337748f} },
    { {0.026225f, 0.007856f, -0.100281f}, {0.358352f, -0.916151f, -0.179586f}, {0.308622f, 0.228288f} },
    { {0.026229f, 0.021519f, -0.113885f}, {0.192763f, -0.201113f, -0.960415f}, {0.319793f, 0.213438f} },
    { {0.010364f, 0.108277f, -0.009200f}, {0.243211f, 0.931805f, 0.269420f}, {0.391587f, 0.329707f} },
    { {0.006055f, 0.109061f, -0.106898f}, {0.444439f, 0.375609f, -0.813260f}, {0.390980f, 0.219064f} },
    { {0.002368f, 0.139352f, -0.015699f}, {-0.018588f, 0.484726f, 0.874468f}, {0.416136f, 0.320612f} },
    { {0.025886f, 0.021144f, 0.002390f}, {0.161189f, -0.268120f, 0.949805f}, {0.319486f, 0.340357f} },
    { {0.025766f, 0.007715f, -0.011429f}, {0.177256f, -0.981035f, 0.078432f}, {0.308507f, 0.325272f} },
    { {-0.017040f, 0.022378f, -0.111553f}, {-0.318515f, -0.013969f, -0.947815f}, {0.399661f, 0.215984f} },
    { {-0.013316f, 0.140325f, -0.103361f}, {-0.286277f, 0.348830f, -0.892392f}, {0.380591f, 0.332901f} },
    { {0.002747f, 0.148271f, -0.029496f}, {0.165145f, 0.979830f, 0.112520f}, {0.423429f, 0.305552f} },
    { {0.002561f, 0.149597f, -0.090944f}, {-0.119101f, 0.991419f, -0.053874f}, {0.424513f, 0.238480f} },
    { {-0.033550f, 0.138012f, -0.091622f}, {-0.832409f, 0.543603f, -0.107662f}, {0.416123f, 0.331038f} },
    { {-0.038374f, 0.107393f, -0.094738f}, {-0.977200f, -0.010133f, -0.212080f}, {0.424593f, 0.306382f} },
    { {0.025766f, 0.007715f, -0.011429f}, {0.177256f, -0.981035f, 0.078432f}, {0.408192f, 0.226118f} },
    { {0.017843f, 0.107867f, -0.095511f}, {0.050036f, 0.998731f, 0.005807f}, {0.318155f, 0.233509f} },
    { {0.006055f, 0.109061f, -0.106898f}, {0.444439f, 0.375609f, -0.813260f}, {0.331298f, 0.219064f} },
    { {0.002383f, 0.139242f, -0.103703f}, {0.372815f, 0.367480f, -0.852037f}, {0.353024f, 0.332029f} },
    { {0.002561f, 0.149597f, -0.090944f}, {-0.119101f, 0.991419f, -0.053874f}, {0.352712f, 0.340367f} },
    { {-0.027666f, 0.023067f, -0.092014f}, {-0.983332f, 0.071759f, -0.167060f}, {0.390975f, 0.236500f} },
    { {-0.027666f, 0.023067f, -0.092014f}, {-0.983332f, 0.071759f, -0.167060f}, {0.405790f, 0.237312f} },
};

WORD g_tind13[] = 
{
    2, 1, 0,    5, 4, 3,    0, 1, 6,    7, 5, 3,    10, 9, 8,
    13, 12, 11,    14, 10, 8,    17, 16, 15,    20, 19, 18,    23, 22, 21,
    26, 25, 24,    29, 28, 27,    32, 31, 30,    35, 34, 33,    19, 36, 18,
    39, 38, 37,    42, 41, 40,    44, 43, 42,    45, 42, 40,    0, 6, 46,
    49, 48, 47,    28, 50, 27,    51, 2, 0,    39, 37, 52,    55, 54, 53,
    56, 32, 30,    58, 14, 57,    45, 40, 59,    5, 60, 4,    63, 62, 61,
    7, 3, 64,    16, 65, 15,    66, 55, 53,    67, 35, 33,    47, 48, 68,
    25, 69, 24,    70, 51, 0,    72, 71, 23,    74, 11, 73,    75, 44, 1,
    3, 4, 76,    64, 3, 77,    78, 60, 5,    74, 13, 11,    14, 8, 57,
    79, 7, 64,    10, 80, 9,    42, 43, 41,    60, 81, 4,    4, 82, 76,
    70, 0, 83,    83, 0, 46,    46, 6, 59,    16, 84, 65,    1, 44, 42,
    1, 42, 45,    51, 75, 2,    2, 75, 1,    21, 72, 23,    3, 76, 77,
    86, 85, 14,    86, 14, 58,    85, 80, 10,    85, 10, 14,    6, 1, 45,
    88, 87, 84,    89, 39, 52,    4, 81, 82,    61, 90, 63,    90, 61, 91,
    84, 93, 92,    84, 92, 65,    54, 94, 53,    95, 28, 29,
};

D3DMATRIX g_tmat14 = 
{
    0.197245f, -0.965505f, 0.169982f, 0.000000f, 
    0.910019f, 0.244812f, 0.334565f, 0.000000f, 
    -0.364638f, 0.088696f, 0.926916f, 0.000000f, 
    2.630079f, -2.652705f, 2.926059f, 1.000000f, 
};

// Mesh #14 Tris:216 Verts:218
MODELVERT g_tmesh14[] = 
{
    { {0.000000f, -0.000000f, -0.000000f}, {-0.000000f, -0.000000f, -1.000000f}, {0.424593f, 0.276908f} },
    { {0.210381f, 0.076572f, -0.000000f}, {-0.000000f, -0.000000f, -1.000000f}, {0.424593f, 0.254842f} },
    { {0.223883f, -0.000000f, -0.000000f}, {-0.000000f, -0.000000f, -1.000000f}, {0.424593f, 0.276908f} },
    { {0.171504f, 0.143909f, -0.000000f}, {-0.000000f, -0.000000f, -1.000000f}, {0.424593f, 0.235437f} },
    { {0.111941f, 0.193888f, -0.000000f}, {-0.000000f, -0.000000f, -1.000000f}, {0.424593f, 0.221034f} },
    { {0.038877f, 0.220481f, -0.000000f}, {-0.000000f, -0.000000f, -1.000000f}, {0.424593f, 0.213371f} },
    { {-0.038877f, 0.220481f, -0.000000f}, {-0.000000f, -0.000000f, -1.000000f}, {0.424593f, 0.213371f} },
    { {-0.111941f, 0.193888f, -0.000000f}, {-0.000000f, -0.000000f, -1.000000f}, {0.424593f, 0.221034f} },
    { {-0.171504f, 0.143909f, -0.000000f}, {-0.000000f, -0.000000f, -1.000000f}, {0.424593f, 0.235437f} },
    { {-0.210381f, 0.076572f, -0.000000f}, {-0.000000f, -0.000000f, -1.000000f}, {0.424593f, 0.254842f} },
    { {-0.223883f, -0.000000f, -0.000000f}, {-0.000000f, -0.000000f, -1.000000f}, {0.424593f, 0.276908f} },
    { {-0.210381f, -0.076573f, -0.000000f}, {-0.000000f, -0.000000f, -1.000000f}, {0.424593f, 0.298974f} },
    { {-0.171504f, -0.143909f, -0.000000f}, {-0.000000f, -0.000000f, -1.000000f}, {0.424593f, 0.318379f} },
    { {-0.111941f, -0.193888f, -0.000000f}, {-0.000000f, -0.000000f, -1.000000f}, {0.424593f, 0.332782f} },
    { {-0.038877f, -0.220482f, -0.000000f}, {-0.000000f, -0.000000f, -1.000000f}, {0.424593f, 0.340445f} },
    { {0.038877f, -0.220482f, -0.000000f}, {-0.000000f, -0.000000f, -1.000000f}, {0.424593f, 0.340445f} },
    { {0.111942f, -0.193888f, -0.000000f}, {-0.000000f, -0.000000f, -1.000000f}, {0.424593f, 0.332782f} },
    { {0.171504f, -0.143909f, -0.000000f}, {-0.000000f, -0.000000f, -1.000000f}, {0.424593f, 0.318379f} },
    { {0.210381f, -0.076572f, -0.000000f}, {-0.000000f, -0.000000f, -1.000000f}, {0.424593f, 0.298974f} },
    { {0.223883f, -0.000000f, -0.000000f}, {0.998277f, 0.058674f, -0.000000f}, {0.424593f, 0.276908f} },
    { {0.210381f, 0.076572f, 0.018574f}, {0.958142f, 0.286295f, -0.000000f}, {0.381583f, 0.254842f} },
    { {0.223883f, -0.000000f, 0.018574f}, {0.998277f, -0.058674f, 0.000000f}, {0.381583f, 0.276908f} },
    { {0.210381f, 0.076572f, -0.000000f}, {0.918006f, 0.396567f, -0.000000f}, {0.424593f, 0.254842f} },
    { {0.171504f, 0.143909f, 0.018574f}, {0.802440f, 0.596733f, -0.000000f}, {0.381583f, 0.235437f} },
    { {0.171504f, 0.143909f, -0.000000f}, {0.727009f, 0.686627f, -0.000000f}, {0.424593f, 0.235437f} },
    { {0.111941f, 0.193888f, 0.018574f}, {0.549952f, 0.835196f, -0.000000f}, {0.381583f, 0.221034f} },
    { {0.111941f, 0.193888f, -0.000000f}, {0.448325f, 0.893871f, -0.000000f}, {0.424593f, 0.221034f} },
    { {0.038877f, 0.220481f, 0.018574f}, {0.231132f, 0.972922f, -0.000000f}, {0.381583f, 0.213371f} },
    { {0.038877f, 0.220481f, -0.000000f}, {0.115566f, 0.993300f, -0.000000f}, {0.424593f, 0.213371f} },
    { {-0.038877f, 0.220481f, 0.018574f}, {-0.115566f, 0.993300f, -0.000000f}, {0.381583f, 0.213371f} },
    { {-0.038877f, 0.220481f, -0.000000f}, {-0.231132f, 0.972922f, -0.000000f}, {0.424593f, 0.213371f} },
    { {-0.111941f, 0.193888f, 0.018574f}, {-0.448325f, 0.893871f, -0.000000f}, {0.381583f, 0.221034f} },
    { {-0.111941f, 0.193888f, -0.000000f}, {-0.549952f, 0.835196f, -0.000000f}, {0.424593f, 0.221034f} },
    { {-0.171504f, 0.143909f, 0.018574f}, {-0.727009f, 0.686627f, -0.000000f}, {0.381583f, 0.235437f} },
    { {-0.171504f, 0.143909f, -0.000000f}, {-0.802440f, 0.596733f, -0.000000f}, {0.424593f, 0.235437f} },
    { {-0.210381f, 0.076572f, 0.018574f}, {-0.918006f, 0.396567f, -0.000000f}, {0.381583f, 0.254842f} },
    { {-0.210381f, 0.076572f, -0.000000f}, {-0.958142f, 0.286295f, -0.000000f}, {0.424593f, 0.254842f} },
    { {-0.223883f, -0.000000f, 0.018574f}, {-0.998277f, 0.058674f, -0.000000f}, {0.381583f, 0.276908f} },
    { {-0.223883f, -0.000000f, -0.000000f}, {-0.998277f, -0.058674f, 0.000000f}, {0.424593f, 0.276908f} },
    { {-0.210381f, -0.076573f, 0.018574f}, {-0.958142f, -0.286295f, 0.000000f}, {0.381583f, 0.298974f} },
    { {-0.210381f, -0.076573f, -0.000000f}, {-0.918006f, -0.396567f, -0.000000f}, {0.424593f, 0.298974f} },
    { {-0.171504f, -0.143909f, 0.018574f}, {-0.802440f, -0.596733f, -0.000000f}, {0.381583f, 0.318379f} },
    { {-0.171504f, -0.143909f, -0.000000f}, {-0.727009f, -0.686628f, -0.000000f}, {0.424593f, 0.318379f} },
    { {-0.111941f, -0.193888f, 0.018574f}, {-0.549952f, -0.835196f, 0.000000f}, {0.381583f, 0.332782f} },
    { {-0.111941f, -0.193888f, -0.000000f}, {-0.448325f, -0.893871f, 0.000000f}, {0.424593f, 0.332782f} },
    { {-0.038877f, -0.220482f, 0.018574f}, {-0.231132f, -0.972923f, 0.000000f}, {0.381583f, 0.340445f} },
    { {-0.038877f, -0.220482f, -0.000000f}, {-0.115566f, -0.993300f, 0.000000f}, {0.424593f, 0.340445f} },
    { {0.038877f, -0.220482f, 0.018574f}, {0.115566f, -0.993300f, 0.000000f}, {0.381583f, 0.340445f} },
    { {0.038877f, -0.220482f, -0.000000f}, {0.231132f, -0.972922f, 0.000000f}, {0.424593f, 0.340445f} },
    { {0.111942f, -0.193888f, 0.018574f}, {0.448325f, -0.893870f, 0.000000f}, {0.381583f, 0.332782f} },
    { {0.111942f, -0.193888f, -0.000000f}, {0.549952f, -0.835196f, 0.000000f}, {0.424593f, 0.332782f} },
    { {0.171504f, -0.143909f, 0.018574f}, {0.727010f, -0.686627f, 0.000001f}, {0.381583f, 0.318379f} },
    { {0.171504f, -0.143909f, -0.000000f}, {0.802440f, -0.596733f, 0.000001f}, {0.424593f, 0.318379f} },
    { {0.210381f, -0.076572f, 0.018574f}, {0.918006f, -0.396567f, 0.000000f}, {0.381583f, 0.298974f} },
    { {0.210381f, -0.076572f, -0.000000f}, {0.958142f, -0.286295f, 0.000000f}, {0.424593f, 0.298974f} },
    { {0.188144f, -0.001984f, 0.018574f}, {0.998277f, 0.058674f, 0.000000f}, {0.381583f, 0.277480f} },
    { {0.176702f, 0.062908f, 0.037149f}, {0.958142f, 0.286295f, 0.000000f}, {0.338573f, 0.258779f} },
    { {0.188144f, -0.001984f, 0.037149f}, {0.998277f, -0.058674f, 0.000000f}, {0.338573f, 0.277480f} },
    { {0.176702f, 0.062908f, 0.018574f}, {0.918006f, 0.396567f, 0.000000f}, {0.381583f, 0.258779f} },
    { {0.143756f, 0.119973f, 0.037149f}, {0.802440f, 0.596733f, 0.000000f}, {0.338573f, 0.242335f} },
    { {0.143756f, 0.119973f, 0.018574f}, {0.727009f, 0.686627f, -0.000000f}, {0.381583f, 0.242335f} },
    { {0.093279f, 0.162328f, 0.037149f}, {0.549952f, 0.835196f, -0.000000f}, {0.338573f, 0.230129f} },
    { {0.093279f, 0.162328f, 0.018574f}, {0.448325f, 0.893871f, -0.000000f}, {0.381583f, 0.230129f} },
    { {0.031360f, 0.184865f, 0.037149f}, {0.231132f, 0.972922f, -0.000000f}, {0.338573f, 0.223634f} },
    { {0.031360f, 0.184865f, 0.018574f}, {0.115566f, 0.993300f, -0.000000f}, {0.381583f, 0.223634f} },
    { {-0.034533f, 0.184865f, 0.037149f}, {-0.115566f, 0.993300f, -0.000000f}, {0.338573f, 0.223634f} },
    { {-0.034533f, 0.184865f, 0.018574f}, {-0.231132f, 0.972922f, -0.000000f}, {0.381583f, 0.223634f} },
    { {-0.096452f, 0.162328f, 0.037149f}, {-0.448325f, 0.893871f, -0.000001f}, {0.338573f, 0.230129f} },
    { {-0.096452f, 0.162328f, 0.018574f}, {-0.549952f, 0.835196f, -0.000000f}, {0.381583f, 0.230129f} },
    { {-0.146929f, 0.119973f, 0.037149f}, {-0.727009f, 0.686628f, -0.000000f}, {0.338573f, 0.242335f} },
    { {-0.146929f, 0.119973f, 0.018574f}, {-0.802440f, 0.596733f, 0.000000f}, {0.381583f, 0.242335f} },
    { {-0.179876f, 0.062908f, 0.037149f}, {-0.918006f, 0.396567f, 0.000000f}, {0.338573f, 0.258779f} },
    { {-0.179876f, 0.062908f, 0.018574f}, {-0.958142f, 0.286295f, 0.000000f}, {0.381583f, 0.258779f} },
    { {-0.191318f, -0.001984f, 0.037149f}, {-0.998277f, 0.058674f, 0.000000f}, {0.338573f, 0.277480f} },
    { {-0.191318f, -0.001984f, 0.018574f}, {-0.998277f, -0.058674f, 0.000000f}, {0.381583f, 0.277480f} },
    { {-0.179876f, -0.066875f, 0.037149f}, {-0.958142f, -0.286295f, 0.000000f}, {0.338573f, 0.296180f} },
    { {-0.179876f, -0.066875f, 0.018574f}, {-0.918006f, -0.396567f, 0.000000f}, {0.381583f, 0.296180f} },
    { {-0.146929f, -0.123940f, 0.037149f}, {-0.802440f, -0.596733f, 0.000000f}, {0.338573f, 0.312625f} },
    { {-0.146929f, -0.123940f, 0.018574f}, {-0.727009f, -0.686628f, 0.000000f}, {0.381583f, 0.312625f} },
    { {-0.096452f, -0.166295f, 0.037149f}, {-0.549952f, -0.835196f, 0.000000f}, {0.338573f, 0.324830f} },
    { {-0.096452f, -0.166295f, 0.018574f}, {-0.448325f, -0.893871f, -0.000000f}, {0.381583f, 0.324830f} },
    { {-0.034533f, -0.188832f, 0.037149f}, {-0.231132f, -0.972923f, -0.000000f}, {0.338573f, 0.331325f} },
    { {-0.034533f, -0.188832f, 0.018574f}, {-0.115566f, -0.993300f, 0.000000f}, {0.381583f, 0.331325f} },
    { {0.031360f, -0.188832f, 0.037149f}, {0.115566f, -0.993300f, 0.000000f}, {0.338573f, 0.331325f} },
    { {0.031360f, -0.188832f, 0.018574f}, {0.231132f, -0.972922f, 0.000000f}, {0.381583f, 0.331325f} },
    { {0.093279f, -0.166295f, 0.037149f}, {0.448325f, -0.893871f, 0.000000f}, {0.338573f, 0.324830f} },
    { {0.093279f, -0.166295f, 0.018574f}, {0.549952f, -0.835196f, 0.000000f}, {0.381583f, 0.324830f} },
    { {0.143756f, -0.123940f, 0.037149f}, {0.727010f, -0.686627f, 0.000000f}, {0.338573f, 0.312624f} },
    { {0.143756f, -0.123940f, 0.018574f}, {0.802440f, -0.596733f, 0.000000f}, {0.381583f, 0.312624f} },
    { {0.176702f, -0.066875f, 0.037149f}, {0.918006f, -0.396567f, 0.000000f}, {0.338573f, 0.296180f} },
    { {0.176702f, -0.066875f, 0.018574f}, {0.958142f, -0.286295f, 0.000000f}, {0.381583f, 0.296180f} },
    { {0.223883f, -0.000000f, 0.037148f}, {0.998277f, 0.058674f, 0.000000f}, {0.338573f, 0.276908f} },
    { {0.210381f, 0.076572f, 0.055723f}, {0.958142f, 0.286295f, -0.000000f}, {0.295564f, 0.254842f} },
    { {0.223883f, -0.000000f, 0.055723f}, {0.998277f, -0.058674f, 0.000000f}, {0.295564f, 0.276908f} },
    { {0.210381f, 0.076572f, 0.037148f}, {0.918006f, 0.396567f, 0.000000f}, {0.338573f, 0.254842f} },
    { {0.171504f, 0.143909f, 0.055723f}, {0.802440f, 0.596733f, 0.000000f}, {0.295564f, 0.235437f} },
    { {0.171504f, 0.143909f, 0.037148f}, {0.727009f, 0.686628f, 0.000000f}, {0.338573f, 0.235437f} },
    { {0.111941f, 0.193888f, 0.055723f}, {0.549952f, 0.835196f, 0.000000f}, {0.295564f, 0.221034f} },
    { {0.111941f, 0.193888f, 0.037149f}, {0.448325f, 0.893871f, -0.000000f}, {0.338573f, 0.221034f} },
    { {0.038877f, 0.220481f, 0.055723f}, {0.231132f, 0.972922f, -0.000001f}, {0.295564f, 0.213371f} },
    { {0.038877f, 0.220481f, 0.037149f}, {0.115566f, 0.993300f, -0.000001f}, {0.338573f, 0.213371f} },
    { {-0.038877f, 0.220481f, 0.055723f}, {-0.115566f, 0.993300f, -0.000000f}, {0.295564f, 0.213371f} },
    { {-0.038877f, 0.220481f, 0.037149f}, {-0.231132f, 0.972922f, -0.000000f}, {0.338573f, 0.213371f} },
    { {-0.111941f, 0.193888f, 0.055723f}, {-0.448325f, 0.893871f, -0.000000f}, {0.295564f, 0.221034f} },
    { {-0.111941f, 0.193888f, 0.037149f}, {-0.549952f, 0.835196f, 0.000000f}, {0.338573f, 0.221034f} },
    { {-0.171504f, 0.143909f, 0.055723f}, {-0.727009f, 0.686627f, 0.000000f}, {0.295564f, 0.235437f} },
    { {-0.171504f, 0.143909f, 0.037149f}, {-0.802440f, 0.596733f, -0.000000f}, {0.338573f, 0.235437f} },
    { {-0.210381f, 0.076572f, 0.055723f}, {-0.918006f, 0.396567f, -0.000000f}, {0.295564f, 0.254842f} },
    { {-0.210381f, 0.076572f, 0.037149f}, {-0.958142f, 0.286295f, -0.000000f}, {0.338573f, 0.254842f} },
    { {-0.223883f, -0.000000f, 0.055723f}, {-0.998277f, 0.058674f, -0.000000f}, {0.295564f, 0.276908f} },
    { {-0.223883f, -0.000000f, 0.037149f}, {-0.998277f, -0.058674f, 0.000000f}, {0.338573f, 0.276908f} },
    { {-0.210381f, -0.076573f, 0.055723f}, {-0.958141f, -0.286295f, 0.000000f}, {0.295564f, 0.298974f} },
    { {-0.210381f, -0.076573f, 0.037149f}, {-0.918006f, -0.396567f, 0.000000f}, {0.338573f, 0.298974f} },
    { {-0.171504f, -0.143909f, 0.055723f}, {-0.802440f, -0.596733f, 0.000000f}, {0.295564f, 0.318379f} },
    { {-0.171504f, -0.143909f, 0.037149f}, {-0.727009f, -0.686628f, 0.000000f}, {0.338573f, 0.318379f} },
    { {-0.111941f, -0.193888f, 0.055723f}, {-0.549952f, -0.835196f, 0.000000f}, {0.295564f, 0.332782f} },
    { {-0.111941f, -0.193888f, 0.037149f}, {-0.448325f, -0.893871f, -0.000000f}, {0.338573f, 0.332782f} },
    { {-0.038877f, -0.220482f, 0.055723f}, {-0.231132f, -0.972922f, -0.000000f}, {0.295564f, 0.340445f} },
    { {-0.038877f, -0.220482f, 0.037149f}, {-0.115566f, -0.993300f, -0.000000f}, {0.338573f, 0.340445f} },
    { {0.038877f, -0.220482f, 0.055723f}, {0.115566f, -0.993300f, 0.000000f}, {0.295564f, 0.340445f} },
    { {0.038877f, -0.220482f, 0.037149f}, {0.231132f, -0.972922f, 0.000000f}, {0.338573f, 0.340445f} },
    { {0.111942f, -0.193888f, 0.055723f}, {0.448325f, -0.893870f, 0.000000f}, {0.295564f, 0.332782f} },
    { {0.111942f, -0.193888f, 0.037149f}, {0.549952f, -0.835196f, 0.000000f}, {0.338573f, 0.332782f} },
    { {0.171504f, -0.143909f, 0.055723f}, {0.727010f, -0.686627f, 0.000000f}, {0.295564f, 0.318379f} },
    { {0.171504f, -0.143909f, 0.037149f}, {0.802440f, -0.596733f, 0.000000f}, {0.338573f, 0.318379f} },
    { {0.210381f, -0.076572f, 0.055723f}, {0.918006f, -0.396567f, 0.000000f}, {0.295564f, 0.298974f} },
    { {0.210381f, -0.076572f, 0.037149f}, {0.958142f, -0.286295f, 0.000000f}, {0.338573f, 0.298974f} },
    { {0.000000f, -0.000000f, 0.055723f}, {0.000000f, 0.000000f, 1.000000f}, {0.295564f, 0.276908f} },
    { {0.223883f, -0.000000f, 0.055723f}, {0.000000f, 0.000000f, 1.000000f}, {0.295564f, 0.276908f} },
    { {0.210381f, 0.076572f, 0.055723f}, {0.000000f, 0.000000f, 1.000000f}, {0.295564f, 0.254842f} },
    { {0.171504f, 0.143909f, 0.055723f}, {0.000000f, 0.000000f, 1.000000f}, {0.295564f, 0.235437f} },
    { {0.111941f, 0.193888f, 0.055723f}, {0.000000f, 0.000000f, 1.000000f}, {0.295564f, 0.221034f} },
    { {0.038877f, 0.220481f, 0.055723f}, {0.000000f, 0.000000f, 1.000000f}, {0.295564f, 0.213371f} },
    { {-0.038877f, 0.220481f, 0.055723f}, {0.000000f, 0.000000f, 1.000000f}, {0.295564f, 0.213371f} },
    { {-0.111941f, 0.193888f, 0.055723f}, {0.000000f, 0.000000f, 1.000000f}, {0.295564f, 0.221034f} },
    { {-0.171504f, 0.143909f, 0.055723f}, {0.000000f, 0.000000f, 1.000000f}, {0.295564f, 0.235437f} },
    { {-0.210381f, 0.076572f, 0.055723f}, {0.000000f, 0.000000f, 1.000000f}, {0.295564f, 0.254842f} },
    { {-0.223883f, -0.000000f, 0.055723f}, {0.000000f, 0.000000f, 1.000000f}, {0.295564f, 0.276908f} },
    { {-0.210381f, -0.076573f, 0.055723f}, {0.000000f, 0.000000f, 1.000000f}, {0.295564f, 0.298974f} },
    { {-0.171504f, -0.143909f, 0.055723f}, {0.000000f, 0.000000f, 1.000000f}, {0.295564f, 0.318379f} },
    { {-0.111941f, -0.193888f, 0.055723f}, {0.000000f, 0.000000f, 1.000000f}, {0.295564f, 0.332782f} },
    { {-0.038877f, -0.220482f, 0.055723f}, {0.000000f, 0.000000f, 1.000000f}, {0.295564f, 0.340445f} },
    { {0.038877f, -0.220482f, 0.055723f}, {0.000000f, 0.000000f, 1.000000f}, {0.295564f, 0.340445f} },
    { {0.111942f, -0.193888f, 0.055723f}, {0.000000f, 0.000000f, 1.000000f}, {0.295564f, 0.332782f} },
    { {0.171504f, -0.143909f, 0.055723f}, {0.000000f, 0.000000f, 1.000000f}, {0.295564f, 0.318379f} },
    { {0.210381f, -0.076572f, 0.055723f}, {0.000000f, 0.000000f, 1.000000f}, {0.295564f, 0.298974f} },
    { {0.223883f, -0.000000f, 0.018574f}, {0.000000f, 0.000000f, 1.000000f}, {0.381583f, 0.276908f} },
    { {0.210381f, 0.076572f, 0.018574f}, {0.000000f, 0.000000f, 1.000000f}, {0.381583f, 0.254842f} },
    { {0.176702f, 0.062908f, 0.018574f}, {0.000000f, 0.000000f, 1.000000f}, {0.381583f, 0.258779f} },
    { {0.188144f, -0.001984f, 0.018574f}, {0.000000f, 0.000000f, 1.000000f}, {0.381583f, 0.277480f} },
    { {0.171504f, 0.143909f, 0.018574f}, {0.000000f, 0.000000f, 1.000000f}, {0.381583f, 0.235437f} },
    { {0.143756f, 0.119973f, 0.018574f}, {0.000000f, 0.000000f, 1.000000f}, {0.381583f, 0.242335f} },
    { {0.111941f, 0.193888f, 0.018574f}, {0.000000f, 0.000000f, 1.000000f}, {0.381583f, 0.221034f} },
    { {0.093279f, 0.162328f, 0.018574f}, {0.000000f, 0.000000f, 1.000000f}, {0.381583f, 0.230129f} },
    { {0.038877f, 0.220481f, 0.018574f}, {0.000000f, 0.000000f, 1.000000f}, {0.381583f, 0.213371f} },
    { {0.031360f, 0.184865f, 0.018574f}, {0.000000f, 0.000000f, 1.000000f}, {0.381583f, 0.223634f} },
    { {-0.038877f, 0.220481f, 0.018574f}, {0.000000f, 0.000000f, 1.000000f}, {0.381583f, 0.213371f} },
    { {-0.034533f, 0.184865f, 0.018574f}, {0.000000f, 0.000000f, 1.000000f}, {0.381583f, 0.223634f} },
    { {-0.111941f, 0.193888f, 0.018574f}, {0.000000f, 0.000000f, 1.000000f}, {0.381583f, 0.221034f} },
    { {-0.096452f, 0.162328f, 0.018574f}, {0.000000f, 0.000000f, 1.000000f}, {0.381583f, 0.230129f} },
    { {-0.171504f, 0.143909f, 0.018574f}, {0.000000f, 0.000000f, 1.000000f}, {0.381583f, 0.235437f} },
    { {-0.146929f, 0.119973f, 0.018574f}, {0.000000f, 0.000000f, 1.000000f}, {0.381583f, 0.242335f} },
    { {-0.210381f, 0.076572f, 0.018574f}, {0.000000f, 0.000000f, 1.000000f}, {0.381583f, 0.254842f} },
    { {-0.179876f, 0.062908f, 0.018574f}, {0.000000f, 0.000000f, 1.000000f}, {0.381583f, 0.258779f} },
    { {-0.223883f, -0.000000f, 0.018574f}, {0.000000f, 0.000000f, 1.000000f}, {0.381583f, 0.276908f} },
    { {-0.191318f, -0.001984f, 0.018574f}, {0.000000f, 0.000000f, 1.000000f}, {0.381583f, 0.277480f} },
    { {-0.210381f, -0.076573f, 0.018574f}, {0.000000f, 0.000000f, 1.000000f}, {0.381583f, 0.298974f} },
    { {-0.179876f, -0.066875f, 0.018574f}, {0.000000f, 0.000000f, 1.000000f}, {0.381583f, 0.296180f} },
    { {-0.171504f, -0.143909f, 0.018574f}, {0.000000f, 0.000000f, 1.000000f}, {0.381583f, 0.318379f} },
    { {-0.146929f, -0.123940f, 0.018574f}, {0.000000f, 0.000000f, 1.000000f}, {0.381583f, 0.312625f} },
    { {-0.111941f, -0.193888f, 0.018574f}, {0.000000f, 0.000000f, 1.000000f}, {0.381583f, 0.332782f} },
    { {-0.096452f, -0.166295f, 0.018574f}, {0.000000f, 0.000000f, 1.000000f}, {0.381583f, 0.324830f} },
    { {-0.038877f, -0.220482f, 0.018574f}, {0.000000f, 0.000000f, 1.000000f}, {0.381583f, 0.340445f} },
    { {-0.034533f, -0.188832f, 0.018574f}, {0.000000f, 0.000000f, 1.000000f}, {0.381583f, 0.331325f} },
    { {0.038877f, -0.220482f, 0.018574f}, {0.000000f, 0.000000f, 1.000000f}, {0.381583f, 0.340445f} },
    { {0.031360f, -0.188832f, 0.018574f}, {0.000000f, 0.000000f, 1.000000f}, {0.381583f, 0.331325f} },
    { {0.111942f, -0.193888f, 0.018574f}, {0.000000f, 0.000000f, 1.000000f}, {0.381583f, 0.332782f} },
    { {0.093279f, -0.166295f, 0.018574f}, {0.000000f, 0.000000f, 1.000000f}, {0.381583f, 0.324830f} },
    { {0.171504f, -0.143909f, 0.018574f}, {0.000000f, 0.000000f, 1.000000f}, {0.381583f, 0.318379f} },
    { {0.143756f, -0.123940f, 0.018574f}, {0.000000f, 0.000000f, 1.000000f}, {0.381583f, 0.312624f} },
    { {0.210381f, -0.076572f, 0.018574f}, {0.000000f, 0.000000f, 1.000000f}, {0.381583f, 0.298974f} },
    { {0.176702f, -0.066875f, 0.018574f}, {0.000000f, 0.000000f, 1.000000f}, {0.381583f, 0.296180f} },
    { {0.210381f, 0.076572f, 0.037148f}, {-0.000000f, -0.000000f, -1.000000f}, {0.338573f, 0.254842f} },
    { {0.223883f, -0.000000f, 0.037148f}, {-0.000000f, -0.000000f, -1.000000f}, {0.338573f, 0.276908f} },
    { {0.188144f, -0.001984f, 0.037149f}, {-0.000000f, -0.000000f, -1.000000f}, {0.338573f, 0.277480f} },
    { {0.176702f, 0.062908f, 0.037149f}, {-0.000000f, -0.000000f, -1.000000f}, {0.338573f, 0.258779f} },
    { {0.171504f, 0.143909f, 0.037148f}, {-0.000000f, -0.000000f, -1.000000f}, {0.338573f, 0.235437f} },
    { {0.143756f, 0.119973f, 0.037149f}, {-0.000000f, -0.000000f, -1.000000f}, {0.338573f, 0.242335f} },
    { {0.111941f, 0.193888f, 0.037149f}, {-0.000000f, -0.000000f, -1.000000f}, {0.338573f, 0.221034f} },
    { {0.093279f, 0.162328f, 0.037149f}, {-0.000000f, -0.000000f, -1.000000f}, {0.338573f, 0.230129f} },
    { {0.038877f, 0.220481f, 0.037149f}, {-0.000000f, 0.000000f, -1.000000f}, {0.338573f, 0.213371f} },
    { {0.031360f, 0.184865f, 0.037149f}, {-0.000000f, -0.000000f, -1.000000f}, {0.338573f, 0.223634f} },
    { {-0.038877f, 0.220481f, 0.037149f}, {-0.000000f, -0.000000f, -1.000000f}, {0.338573f, 0.213371f} },
    { {-0.034533f, 0.184865f, 0.037149f}, {-0.000000f, -0.000000f, -1.000000f}, {0.338573f, 0.223634f} },
    { {-0.111941f, 0.193888f, 0.037149f}, {-0.000000f, -0.000000f, -1.000000f}, {0.338573f, 0.221034f} },
    { {-0.096452f, 0.162328f, 0.037149f}, {-0.000000f, -0.000000f, -1.000000f}, {0.338573f, 0.230129f} },
    { {-0.171504f, 0.143909f, 0.037149f}, {-0.000000f, -0.000000f, -1.000000f}, {0.338573f, 0.235437f} },
    { {-0.146929f, 0.119973f, 0.037149f}, {-0.000000f, -0.000000f, -1.000000f}, {0.338573f, 0.242335f} },
    { {-0.210381f, 0.076572f, 0.037149f}, {-0.000000f, -0.000000f, -1.000000f}, {0.338573f, 0.254842f} },
    { {-0.179876f, 0.062908f, 0.037149f}, {-0.000000f, -0.000000f, -1.000000f}, {0.338573f, 0.258779f} },
    { {-0.223883f, -0.000000f, 0.037149f}, {-0.000000f, -0.000000f, -1.000000f}, {0.338573f, 0.276908f} },
    { {-0.191318f, -0.001984f, 0.037149f}, {-0.000000f, -0.000000f, -1.000000f}, {0.338573f, 0.277480f} },
    { {-0.210381f, -0.076573f, 0.037149f}, {-0.000000f, -0.000000f, -1.000000f}, {0.338573f, 0.298974f} },
    { {-0.179876f, -0.066875f, 0.037149f}, {-0.000000f, -0.000000f, -1.000000f}, {0.338573f, 0.296180f} },
    { {-0.171504f, -0.143909f, 0.037149f}, {-0.000000f, -0.000000f, -1.000000f}, {0.338573f, 0.318379f} },
    { {-0.146929f, -0.123940f, 0.037149f}, {-0.000000f, -0.000000f, -1.000000f}, {0.338573f, 0.312625f} },
    { {-0.111941f, -0.193888f, 0.037149f}, {-0.000000f, -0.000000f, -1.000000f}, {0.338573f, 0.332782f} },
    { {-0.096452f, -0.166295f, 0.037149f}, {-0.000000f, -0.000000f, -1.000000f}, {0.338573f, 0.324830f} },
    { {-0.038877f, -0.220482f, 0.037149f}, {-0.000000f, -0.000000f, -1.000000f}, {0.338573f, 0.340445f} },
    { {-0.034533f, -0.188832f, 0.037149f}, {-0.000000f, -0.000000f, -1.000000f}, {0.338573f, 0.331325f} },
    { {0.038877f, -0.220482f, 0.037149f}, {-0.000000f, -0.000000f, -1.000000f}, {0.338573f, 0.340445f} },
    { {0.031360f, -0.188832f, 0.037149f}, {-0.000000f, -0.000000f, -1.000000f}, {0.338573f, 0.331325f} },
    { {0.111942f, -0.193888f, 0.037149f}, {-0.000000f, -0.000000f, -1.000000f}, {0.338573f, 0.332782f} },
    { {0.093279f, -0.166295f, 0.037149f}, {-0.000000f, -0.000000f, -1.000000f}, {0.338573f, 0.324830f} },
    { {0.171504f, -0.143909f, 0.037149f}, {-0.000000f, -0.000000f, -1.000000f}, {0.338573f, 0.318379f} },
    { {0.143756f, -0.123940f, 0.037149f}, {-0.000000f, 0.000000f, -1.000000f}, {0.338573f, 0.312624f} },
    { {0.210381f, -0.076572f, 0.037149f}, {-0.000000f, -0.000000f, -1.000000f}, {0.338573f, 0.298974f} },
    { {0.176702f, -0.066875f, 0.037149f}, {-0.000000f, -0.000000f, -1.000000f}, {0.338573f, 0.296180f} },
};

WORD g_tind14[] = 
{
    0, 1, 2,    0, 3, 1,    0, 4, 3,    0, 5, 4,    0, 6, 5,
    0, 7, 6,    0, 8, 7,    0, 9, 8,    0, 10, 9,    0, 11, 10,
    0, 12, 11,    0, 13, 12,    0, 14, 13,    0, 15, 14,    0, 16, 15,
    0, 17, 16,    0, 18, 17,    0, 2, 18,    19, 20, 21,    19, 22, 20,
    22, 23, 20,    22, 24, 23,    24, 25, 23,    24, 26, 25,    26, 27, 25,
    26, 28, 27,    28, 29, 27,    28, 30, 29,    30, 31, 29,    30, 32, 31,
    32, 33, 31,    32, 34, 33,    34, 35, 33,    34, 36, 35,    36, 37, 35,
    36, 38, 37,    38, 39, 37,    38, 40, 39,    40, 41, 39,    40, 42, 41,
    42, 43, 41,    42, 44, 43,    44, 45, 43,    44, 46, 45,    46, 47, 45,
    46, 48, 47,    48, 49, 47,    48, 50, 49,    50, 51, 49,    50, 52, 51,
    52, 53, 51,    52, 54, 53,    54, 21, 53,    54, 19, 21,    55, 56, 57,
    55, 58, 56,    58, 59, 56,    58, 60, 59,    60, 61, 59,    60, 62, 61,
    62, 63, 61,    62, 64, 63,    64, 65, 63,    64, 66, 65,    66, 67, 65,
    66, 68, 67,    68, 69, 67,    68, 70, 69,    70, 71, 69,    70, 72, 71,
    72, 73, 71,    72, 74, 73,    74, 75, 73,    74, 76, 75,    76, 77, 75,
    76, 78, 77,    78, 79, 77,    78, 80, 79,    80, 81, 79,    80, 82, 81,
    82, 83, 81,    82, 84, 83,    84, 85, 83,    84, 86, 85,    86, 87, 85,
    86, 88, 87,    88, 89, 87,    88, 90, 89,    90, 57, 89,    90, 55, 57,
    91, 92, 93,    91, 94, 92,    94, 95, 92,    94, 96, 95,    96, 97, 95,
    96, 98, 97,    98, 99, 97,    98, 100, 99,    100, 101, 99,    100, 102, 101,
    102, 103, 101,    102, 104, 103,    104, 105, 103,    104, 106, 105,    106, 107, 105,
    106, 108, 107,    108, 109, 107,    108, 110, 109,    110, 111, 109,    110, 112, 111,
    112, 113, 111,    112, 114, 113,    114, 115, 113,    114, 116, 115,    116, 117, 115,
    116, 118, 117,    118, 119, 117,    118, 120, 119,    120, 121, 119,    120, 122, 121,
    122, 123, 121,    122, 124, 123,    124, 125, 123,    124, 126, 125,    126, 93, 125,
    126, 91, 93,    127, 128, 129,    127, 129, 130,    127, 130, 131,    127, 131, 132,
    127, 132, 133,    127, 133, 134,    127, 134, 135,    127, 135, 136,    127, 136, 137,
    127, 137, 138,    127, 138, 139,    127, 139, 140,    127, 140, 141,    127, 141, 142,
    127, 142, 143,    127, 143, 144,    127, 144, 145,    127, 145, 128,    146, 147, 148,
    148, 149, 146,    147, 150, 151,    151, 148, 147,    150, 152, 153,    153, 151, 150,
    152, 154, 155,    155, 153, 152,    154, 156, 157,    157, 155, 154,    156, 158, 159,
    159, 157, 156,    158, 160, 161,    161, 159, 158,    160, 162, 163,    163, 161, 160,
    162, 164, 165,    165, 163, 162,    164, 166, 167,    167, 165, 164,    166, 168, 169,
    169, 167, 166,    168, 170, 171,    171, 169, 168,    170, 172, 173,    173, 171, 170,
    172, 174, 175,    175, 173, 172,    174, 176, 177,    177, 175, 174,    176, 178, 179,
    179, 177, 176,    178, 180, 181,    181, 179, 178,    180, 146, 149,    149, 181, 180,
    182, 183, 184,    184, 185, 182,    186, 182, 185,    185, 187, 186,    188, 186, 187,
    187, 189, 188,    190, 188, 189,    189, 191, 190,    192, 190, 191,    191, 193, 192,
    194, 192, 193,    193, 195, 194,    196, 194, 195,    195, 197, 196,    198, 196, 197,
    197, 199, 198,    200, 198, 199,    199, 201, 200,    202, 200, 201,    201, 203, 202,
    204, 202, 203,    203, 205, 204,    206, 204, 205,    205, 207, 206,    208, 206, 207,
    207, 209, 208,    210, 208, 209,    209, 211, 210,    212, 210, 211,    211, 213, 212,
    214, 212, 213,    213, 215, 214,    216, 214, 215,    215, 217, 216,    183, 216, 217,
    217, 184, 183,
};

D3DMATRIX g_tmat15 = 
{
    -0.197246f, 0.965505f, -0.169982f, 0.000000f, 
    0.356683f, -0.090828f, -0.929800f, 0.000000f, 
    -0.913166f, -0.244029f, -0.326463f, 0.000000f, 
    2.562958f, -2.634022f, 3.104457f, 1.000000f, 
};

// Mesh #15 Tris:240 Verts:268
MODELVERT g_tmesh15[] = 
{
    { {-0.175005f, 0.161276f, 0.060015f}, {-0.540196f, -0.187847f, 0.820306f}, {0.299864f, 0.340445f} },
    { {-0.111651f, -0.027068f, 0.060015f}, {-0.624257f, -0.211734f, 0.751979f}, {0.321800f, 0.255821f} },
    { {-0.119107f, -0.029546f, 0.053128f}, {-0.932604f, -0.332628f, 0.140031f}, {0.319219f, 0.254707f} },
    { {-0.187427f, 0.160766f, 0.053128f}, {-0.860278f, 0.507417f, 0.049498f}, {0.295564f, 0.340216f} },
    { {-0.104445f, -0.047558f, 0.060015f}, {-0.585513f, -0.294122f, 0.755425f}, {0.324295f, 0.246615f} },
    { {-0.111468f, -0.051265f, 0.053128f}, {-0.893692f, -0.443361f, 0.068891f}, {0.321863f, 0.244949f} },
    { {-0.093655f, -0.066055f, 0.060015f}, {-0.518354f, -0.396886f, 0.757490f}, {0.328031f, 0.238304f} },
    { {-0.100031f, -0.070872f, 0.053128f}, {-0.795036f, -0.602594f, 0.069273f}, {0.325824f, 0.236139f} },
    { {-0.079704f, -0.082138f, 0.060015f}, {-0.435631f, -0.485499f, 0.757968f}, {0.332862f, 0.231078f} },
    { {-0.085243f, -0.087920f, 0.053128f}, {-0.669831f, -0.739268f, 0.069348f}, {0.330944f, 0.228480f} },
    { {-0.063015f, -0.095382f, 0.060015f}, {-0.338514f, -0.559035f, 0.756893f}, {0.338640f, 0.225127f} },
    { {-0.067552f, -0.101959f, 0.053128f}, {-0.520892f, -0.850822f, 0.069088f}, {0.337069f, 0.222172f} },
    { {-0.044010f, -0.105367f, 0.060015f}, {-0.227917f, -0.615881f, 0.754152f}, {0.345220f, 0.220641f} },
    { {-0.047407f, -0.112543f, 0.053128f}, {-0.350890f, -0.933912f, 0.068442f}, {0.344044f, 0.217417f} },
    { {-0.023113f, -0.111667f, 0.060015f}, {-0.105575f, -0.653436f, 0.749584f}, {0.352456f, 0.217810f} },
    { {-0.025256f, -0.119221f, 0.053128f}, {-0.164112f, -0.984139f, 0.067360f}, {0.351714f, 0.214416f} },
    { {-0.000746f, -0.113861f, 0.060015f}, {0.035312f, -0.668972f, 0.742449f}, {0.360200f, 0.216824f} },
    { {-0.001548f, -0.121547f, 0.053128f}, {0.047368f, -0.996855f, 0.063537f}, {0.359922f, 0.213371f} },
    { {0.025427f, -0.110842f, 0.060015f}, {0.179485f, -0.655114f, 0.733901f}, {0.369262f, 0.218181f} },
    { {0.026196f, -0.118346f, 0.053128f}, {0.257841f, -0.963945f, 0.065784f}, {0.369529f, 0.214809f} },
    { {0.049464f, -0.102241f, 0.060015f}, {0.327122f, -0.608765f, 0.722770f}, {0.377585f, 0.222045f} },
    { {0.051675f, -0.109230f, 0.053128f}, {0.467227f, -0.881857f, 0.063459f}, {0.378350f, 0.218905f} },
    { {0.070674f, -0.088749f, 0.060015f}, {0.460787f, -0.531991f, 0.710394f}, {0.384929f, 0.228107f} },
    { {0.074158f, -0.094928f, 0.053128f}, {0.649150f, -0.758203f, 0.061100f}, {0.386135f, 0.225331f} },
    { {0.088370f, -0.071053f, 0.060015f}, {0.575940f, -0.426779f, 0.697246f}, {0.391056f, 0.236058f} },
    { {0.092915f, -0.076170f, 0.053128f}, {0.798653f, -0.598917f, 0.058752f}, {0.392629f, 0.233759f} },
    { {0.101862f, -0.049843f, 0.060015f}, {0.667688f, -0.294634f, 0.683655f}, {0.395727f, 0.245588f} },
    { {0.107217f, -0.053687f, 0.053128f}, {0.911072f, -0.408369f, 0.056410f}, {0.397581f, 0.243861f} },
    { {0.110462f, -0.025806f, 0.060015f}, {0.729249f, -0.138651f, 0.670053f}, {0.398705f, 0.256388f} },
    { {0.116334f, -0.028209f, 0.053128f}, {0.979842f, -0.192318f, 0.054077f}, {0.400738f, 0.255308f} },
    { {0.113482f, 0.000367f, 0.060015f}, {0.749897f, -0.018783f, 0.661288f}, {0.399751f, 0.268148f} },
    { {0.119535f, -0.000465f, 0.053128f}, {0.997476f, -0.030048f, 0.064334f}, {0.401846f, 0.267774f} },
    { {0.112676f, 0.013993f, 0.060015f}, {0.749776f, 0.104265f, 0.653425f}, {0.399471f, 0.274270f} },
    { {0.118680f, 0.013979f, 0.053128f}, {0.989543f, 0.134474f, 0.052161f}, {0.401550f, 0.274264f} },
    { {0.110318f, 0.027147f, 0.060015f}, {0.736428f, 0.192534f, 0.648540f}, {0.398655f, 0.280180f} },
    { {0.116181f, 0.027922f, 0.053128f}, {0.966975f, 0.249640f, 0.051366f}, {0.400685f, 0.280528f} },
    { {0.106502f, 0.039736f, 0.060015f}, {0.712404f, 0.277771f, 0.644457f}, {0.397334f, 0.285836f} },
    { {0.112136f, 0.041266f, 0.053128f}, {0.931579f, 0.359986f, 0.050704f}, {0.399284f, 0.286524f} },
    { {0.101320f, 0.051668f, 0.060015f}, {0.678402f, 0.358581f, 0.641241f}, {0.395539f, 0.291197f} },
    { {0.106642f, 0.053914f, 0.053128f}, {0.884370f, 0.464082f, 0.050178f}, {0.397382f, 0.292207f} },
    { {0.094863f, 0.062850f, 0.060015f}, {0.635186f, 0.433911f, 0.638952f}, {0.393304f, 0.296222f} },
    { {0.099799f, 0.065767f, 0.053128f}, {0.826356f, 0.560942f, 0.049788f}, {0.395013f, 0.297532f} },
    { {0.087226f, 0.073190f, 0.060015f}, {0.588163f, 0.506545f, 0.630458f}, {0.390659f, 0.300868f} },
    { {0.091703f, 0.076727f, 0.053128f}, {0.758416f, 0.649885f, 0.049535f}, {0.392210f, 0.302457f} },
    { {0.071969f, 0.090203f, 0.060015f}, {0.349907f, -0.577540f, 0.737572f}, {0.385377f, 0.308512f} },
    { {0.082452f, 0.086698f, 0.053128f}, {0.483298f, -0.874092f, 0.048844f}, {0.389007f, 0.306937f} },
    { {0.136078f, 0.114536f, 0.060015f}, {0.310459f, -0.715533f, 0.625801f}, {0.407574f, 0.319444f} },
    { {0.142321f, 0.111221f, 0.053128f}, {0.412098f, -0.907365f, 0.082852f}, {0.409736f, 0.317955f} },
    { {0.148487f, 0.121611f, 0.060015f}, {0.411076f, -0.613300f, 0.674447f}, {0.411871f, 0.322623f} },
    { {0.155474f, 0.118721f, 0.053128f}, {0.553226f, -0.831104f, 0.056631f}, {0.414290f, 0.321325f} },
    { {0.157838f, 0.128481f, 0.060015f}, {0.469567f, -0.530679f, 0.705611f}, {0.415108f, 0.325710f} },
    { {0.165386f, 0.126004f, 0.053128f}, {0.658445f, -0.750128f, 0.061301f}, {0.417722f, 0.324597f} },
    { {0.164640f, 0.135182f, 0.060015f}, {0.523891f, -0.430452f, 0.735017f}, {0.417464f, 0.328721f} },
    { {0.172597f, 0.133106f, 0.053128f}, {0.768075f, -0.636926f, 0.066224f}, {0.420219f, 0.327788f} },
    { {0.169404f, 0.141746f, 0.060015f}, {0.566247f, -0.325551f, 0.757219f}, {0.419113f, 0.331670f} },
    { {0.177646f, 0.140064f, 0.053128f}, {0.862579f, -0.501015f, 0.070295f}, {0.421967f, 0.330914f} },
    { {0.172638f, 0.148208f, 0.060015f}, {0.592671f, -0.235401f, 0.770277f}, {0.420233f, 0.334573f} },
    { {0.181075f, 0.146913f, 0.053128f}, {0.925627f, -0.371381f, 0.072744f}, {0.423154f, 0.333992f} },
    { {0.174853f, 0.154601f, 0.060015f}, {0.604906f, -0.177753f, 0.776204f}, {0.421000f, 0.337446f} },
    { {0.183423f, 0.153691f, 0.053128f}, {0.956292f, -0.282964f, 0.073732f}, {0.423967f, 0.337037f} },
    { {0.176559f, 0.160961f, 0.060015f}, {0.607482f, -0.162911f, 0.777448f}, {0.421590f, 0.340304f} },
    { {0.185231f, 0.160432f, 0.053128f}, {0.011112f, 0.999937f, 0.001463f}, {0.424593f, 0.340066f} },
    { {-0.187427f, 0.160766f, 0.053128f}, {-0.860278f, 0.507417f, 0.049498f}, {0.295796f, 0.333161f} },
    { {-0.119107f, -0.029546f, 0.053128f}, {-0.932604f, -0.332628f, 0.140031f}, {0.382620f, 0.333161f} },
    { {-0.119107f, -0.029546f, -0.053059f}, {-0.940523f, -0.337233f, -0.041119f}, {0.382620f, 0.220845f} },
    { {-0.187427f, 0.160766f, -0.053059f}, {-0.305647f, 0.950665f, -0.053056f}, {0.295796f, 0.220845f} },
    { {-0.111468f, -0.051265f, 0.053128f}, {-0.893692f, -0.443361f, 0.068891f}, {0.392529f, 0.333161f} },
    { {-0.111468f, -0.051265f, -0.053059f}, {-0.917108f, -0.392726f, -0.068408f}, {0.392529f, 0.220845f} },
    { {-0.100031f, -0.070872f, 0.053128f}, {-0.795036f, -0.602594f, 0.069273f}, {0.401474f, 0.333161f} },
    { {-0.100031f, -0.070873f, -0.053059f}, {-0.826930f, -0.558053f, -0.069025f}, {0.401474f, 0.220845f} },
    { {-0.100031f, -0.070872f, 0.053128f}, {-0.795036f, -0.602594f, 0.069273f}, {0.325824f, 0.333161f} },
    { {-0.085243f, -0.087920f, 0.053128f}, {-0.669831f, -0.739268f, 0.069348f}, {0.330944f, 0.333161f} },
    { {-0.085243f, -0.087920f, -0.053059f}, {-0.709185f, -0.701611f, -0.069271f}, {0.330944f, 0.220845f} },
    { {-0.100031f, -0.070873f, -0.053059f}, {-0.826930f, -0.558053f, -0.069025f}, {0.325824f, 0.220845f} },
    { {-0.067552f, -0.101959f, 0.053128f}, {-0.520892f, -0.850822f, 0.069088f}, {0.337069f, 0.333161f} },
    { {-0.067552f, -0.101959f, -0.053059f}, {-0.566959f, -0.820835f, -0.069191f}, {0.337069f, 0.220845f} },
    { {-0.047407f, -0.112543f, 0.053128f}, {-0.350890f, -0.933912f, 0.068442f}, {0.344044f, 0.333161f} },
    { {-0.047407f, -0.112543f, -0.053059f}, {-0.402805f, -0.912696f, -0.068807f}, {0.344044f, 0.220845f} },
    { {-0.025256f, -0.119221f, 0.053128f}, {-0.164112f, -0.984139f, 0.067360f}, {0.351714f, 0.333161f} },
    { {-0.025256f, -0.119221f, -0.053059f}, {-0.220337f, -0.973042f, -0.068128f}, {0.351714f, 0.220845f} },
    { {-0.001548f, -0.121547f, 0.053128f}, {0.047368f, -0.996855f, 0.063537f}, {0.359922f, 0.333161f} },
    { {-0.001548f, -0.121547f, -0.053059f}, {-0.014794f, -0.997479f, -0.069405f}, {0.359922f, 0.220845f} },
    { {0.026196f, -0.118346f, 0.053128f}, {0.257841f, -0.963945f, 0.065784f}, {0.369529f, 0.333161f} },
    { {0.026196f, -0.118346f, -0.053059f}, {0.192314f, -0.979256f, -0.063818f}, {0.369529f, 0.220845f} },
    { {0.051675f, -0.109230f, 0.053128f}, {0.467227f, -0.881857f, 0.063459f}, {0.378350f, 0.333161f} },
    { {0.051675f, -0.109230f, -0.053059f}, {0.408329f, -0.910721f, -0.062095f}, {0.378350f, 0.220845f} },
    { {0.074158f, -0.094928f, 0.053128f}, {0.649150f, -0.758203f, 0.061100f}, {0.386135f, 0.333161f} },
    { {0.074158f, -0.094928f, -0.053059f}, {0.598951f, -0.798524f, -0.060141f}, {0.386135f, 0.220845f} },
    { {0.092915f, -0.076170f, 0.053128f}, {0.798653f, -0.598917f, 0.058752f}, {0.392629f, 0.333161f} },
    { {0.092915f, -0.076170f, -0.053059f}, {0.758407f, -0.649185f, -0.058125f}, {0.392629f, 0.220845f} },
    { {0.092915f, -0.076170f, 0.053128f}, {0.798653f, -0.598917f, 0.058752f}, {0.316265f, 0.333161f} },
    { {0.107217f, -0.053687f, 0.053128f}, {0.911072f, -0.408369f, 0.056410f}, {0.326523f, 0.333161f} },
    { {0.107217f, -0.053687f, -0.053059f}, {0.882293f, -0.467336f, -0.056176f}, {0.326523f, 0.220845f} },
    { {0.092915f, -0.076170f, -0.053059f}, {0.758407f, -0.649185f, -0.058125f}, {0.316265f, 0.220845f} },
    { {0.116334f, -0.028209f, 0.053128f}, {0.979842f, -0.192318f, 0.054077f}, {0.338146f, 0.333161f} },
    { {0.116334f, -0.028209f, -0.053059f}, {0.964636f, -0.257910f, -0.054408f}, {0.338146f, 0.220845f} },
    { {0.119535f, -0.000465f, 0.053128f}, {0.997476f, -0.030048f, 0.064334f}, {0.350804f, 0.333161f} },
    { {0.119535f, -0.000465f, -0.053059f}, {0.996140f, -0.076419f, -0.043193f}, {0.350804f, 0.220845f} },
    { {0.118680f, 0.013979f, 0.053128f}, {0.989543f, 0.134474f, 0.052161f}, {0.357393f, 0.333161f} },
    { {0.118680f, 0.013979f, -0.053059f}, {0.993670f, 0.100004f, -0.051172f}, {0.357393f, 0.220845f} },
    { {0.116181f, 0.027922f, 0.053128f}, {0.966975f, 0.249640f, 0.051366f}, {0.363754f, 0.333161f} },
    { {0.116181f, 0.027922f, -0.053059f}, {0.975027f, 0.216245f, -0.050595f}, {0.363754f, 0.220845f} },
    { {0.112136f, 0.041266f, 0.053128f}, {0.931579f, 0.359986f, 0.050704f}, {0.369842f, 0.333161f} },
    { {0.112136f, 0.041266f, -0.053059f}, {0.943285f, 0.328179f, -0.050119f}, {0.369842f, 0.220845f} },
    { {0.106642f, 0.053914f, 0.053128f}, {0.884370f, 0.464082f, 0.050178f}, {0.375612f, 0.333161f} },
    { {0.106642f, 0.053914f, -0.053059f}, {0.899427f, 0.434231f, -0.049750f}, {0.375612f, 0.220845f} },
    { {0.099799f, 0.065767f, 0.053128f}, {0.826356f, 0.560942f, 0.049788f}, {0.381020f, 0.333161f} },
    { {0.099799f, 0.065767f, -0.053059f}, {0.844480f, 0.533296f, -0.049494f}, {0.381020f, 0.220845f} },
    { {0.091703f, 0.076727f, 0.053128f}, {0.758416f, 0.649885f, 0.049535f}, {0.386020f, 0.333161f} },
    { {0.091703f, 0.076727f, -0.053059f}, {0.778611f, 0.624667f, -0.059640f}, {0.386020f, 0.220845f} },
    { {0.091703f, 0.076727f, 0.053128f}, {0.758416f, 0.649885f, 0.049535f}, {0.327947f, 0.333161f} },
    { {0.082452f, 0.086698f, 0.053128f}, {0.483298f, -0.874092f, 0.048844f}, {0.331150f, 0.333161f} },
    { {0.082452f, 0.086698f, -0.053059f}, {0.697257f, -0.706254f, -0.122625f}, {0.331150f, 0.220845f} },
    { {0.091703f, 0.076727f, -0.053059f}, {0.778611f, 0.624667f, -0.059640f}, {0.327947f, 0.220845f} },
    { {0.082452f, 0.086698f, 0.053128f}, {0.483298f, -0.874092f, 0.048844f}, {0.389007f, 0.333161f} },
    { {0.142321f, 0.111221f, 0.053128f}, {0.412098f, -0.907365f, 0.082852f}, {0.409736f, 0.333161f} },
    { {0.142321f, 0.111221f, -0.053059f}, {0.392354f, -0.919224f, -0.032937f}, {0.409736f, 0.220845f} },
    { {0.082452f, 0.086698f, -0.053059f}, {0.697257f, -0.706254f, -0.122625f}, {0.389007f, 0.220845f} },
    { {0.155474f, 0.118721f, 0.053128f}, {0.553226f, -0.831104f, 0.056631f}, {0.414290f, 0.333161f} },
    { {0.155474f, 0.118721f, -0.053059f}, {0.525129f, -0.849489f, -0.051071f}, {0.414290f, 0.220845f} },
    { {0.165386f, 0.126004f, 0.053128f}, {0.658445f, -0.750128f, 0.061301f}, {0.417722f, 0.333161f} },
    { {0.165386f, 0.126004f, -0.053059f}, {0.626531f, -0.777391f, -0.055867f}, {0.417722f, 0.220845f} },
    { {0.172597f, 0.133106f, 0.053128f}, {0.768075f, -0.636926f, 0.066224f}, {0.420219f, 0.333161f} },
    { {0.172597f, 0.133106f, -0.053059f}, {0.736637f, -0.673496f, -0.061397f}, {0.420219f, 0.220845f} },
    { {0.172597f, 0.133106f, 0.053128f}, {0.768075f, -0.636926f, 0.066224f}, {0.411741f, 0.333161f} },
    { {0.177646f, 0.140064f, 0.053128f}, {0.862579f, -0.501015f, 0.070295f}, {0.414916f, 0.333161f} },
    { {0.177646f, 0.140064f, -0.053059f}, {0.837741f, -0.541987f, -0.066633f}, {0.414916f, 0.220845f} },
    { {0.172597f, 0.133106f, -0.053059f}, {0.736637f, -0.673496f, -0.061397f}, {0.411741f, 0.220845f} },
    { {0.181075f, 0.146913f, 0.053128f}, {0.925627f, -0.371381f, 0.072744f}, {0.418040f, 0.333161f} },
    { {0.181075f, 0.146913f, -0.053059f}, {0.910845f, -0.406682f, -0.070504f}, {0.418040f, 0.220845f} },
    { {0.183423f, 0.153691f, 0.053128f}, {0.956292f, -0.282964f, 0.073732f}, {0.421132f, 0.333161f} },
    { {0.183423f, 0.153691f, -0.053059f}, {0.950207f, -0.303015f, -0.072721f}, {0.421132f, 0.220845f} },
    { {0.185231f, 0.160432f, 0.053128f}, {0.011112f, 0.999937f, 0.001463f}, {0.424208f, 0.333161f} },
    { {0.185231f, 0.160432f, -0.053059f}, {0.038639f, 0.999252f, -0.001516f}, {0.424208f, 0.220845f} },
    { {0.185231f, 0.160432f, 0.053128f}, {0.011112f, 0.999937f, 0.001463f}, {0.295564f, 0.333161f} },
    { {-0.187427f, 0.160766f, 0.053128f}, {-0.860278f, 0.507417f, 0.049498f}, {0.424593f, 0.333161f} },
    { {-0.187427f, 0.160766f, -0.053059f}, {-0.305647f, 0.950665f, -0.053056f}, {0.424593f, 0.220845f} },
    { {0.185231f, 0.160432f, -0.053059f}, {0.038639f, 0.999252f, -0.001516f}, {0.295564f, 0.220845f} },
    { {-0.187427f, 0.160766f, -0.053059f}, {-0.305647f, 0.950665f, -0.053056f}, {0.424593f, 0.340216f} },
    { {-0.119107f, -0.029546f, -0.053059f}, {-0.940523f, -0.337233f, -0.041119f}, {0.400938f, 0.254707f} },
    { {-0.111651f, -0.027068f, -0.060125f}, {-0.553356f, -0.192535f, -0.810387f}, {0.398356f, 0.255821f} },
    { {-0.175005f, 0.161276f, -0.060125f}, {-0.482855f, -0.162418f, -0.860506f}, {0.420292f, 0.340445f} },
    { {-0.111468f, -0.051265f, -0.053059f}, {-0.917108f, -0.392726f, -0.068408f}, {0.398293f, 0.244949f} },
    { {-0.104445f, -0.047558f, -0.060125f}, {-0.613648f, -0.259131f, -0.745847f}, {0.395861f, 0.246615f} },
    { {-0.100031f, -0.070873f, -0.053059f}, {-0.826930f, -0.558053f, -0.069025f}, {0.394333f, 0.236139f} },
    { {-0.093655f, -0.066055f, -0.060125f}, {-0.551456f, -0.368185f, -0.748556f}, {0.392125f, 0.238304f} },
    { {-0.085243f, -0.087920f, -0.053059f}, {-0.709185f, -0.701611f, -0.069271f}, {0.389213f, 0.228480f} },
    { {-0.079704f, -0.082138f, -0.060125f}, {-0.472823f, -0.463175f, -0.749605f}, {0.387295f, 0.231078f} },
    { {-0.067552f, -0.101959f, -0.053059f}, {-0.566959f, -0.820835f, -0.069191f}, {0.383087f, 0.222172f} },
    { {-0.063015f, -0.095382f, -0.060125f}, {-0.379219f, -0.543208f, -0.749078f}, {0.381516f, 0.225127f} },
    { {-0.047407f, -0.112543f, -0.053059f}, {-0.402805f, -0.912696f, -0.068807f}, {0.376112f, 0.217417f} },
    { {-0.044010f, -0.105367f, -0.060125f}, {-0.271577f, -0.606938f, -0.746909f}, {0.374936f, 0.220641f} },
    { {-0.025256f, -0.119221f, -0.053059f}, {-0.220337f, -0.973042f, -0.068128f}, {0.368443f, 0.214416f} },
    { {-0.023113f, -0.111667f, -0.060125f}, {-0.151251f, -0.652057f, -0.742930f}, {0.367701f, 0.217810f} },
    { {-0.001548f, -0.121547f, -0.053059f}, {-0.014794f, -0.997479f, -0.069405f}, {0.360234f, 0.213371f} },
    { {-0.000746f, -0.113861f, -0.060125f}, {-0.014035f, -0.675966f, -0.736799f}, {0.359957f, 0.216824f} },
    { {0.026196f, -0.118346f, -0.053059f}, {0.192314f, -0.979256f, -0.063818f}, {0.350628f, 0.214809f} },
    { {0.025427f, -0.110842f, -0.060125f}, {0.127942f, -0.672921f, -0.728566f}, {0.350894f, 0.218181f} },
    { {0.051675f, -0.109230f, -0.053059f}, {0.408329f, -0.910721f, -0.062095f}, {0.341806f, 0.218905f} },
    { {0.049464f, -0.102241f, -0.060125f}, {0.281063f, -0.636931f, -0.717860f}, {0.342572f, 0.222045f} },
    { {0.074158f, -0.094928f, -0.053059f}, {0.598951f, -0.798524f, -0.060141f}, {0.334022f, 0.225331f} },
    { {0.070674f, -0.088749f, -0.060125f}, {0.421817f, -0.569243f, -0.705715f}, {0.335228f, 0.228107f} },
    { {0.092915f, -0.076170f, -0.053059f}, {0.758407f, -0.649185f, -0.058125f}, {0.327527f, 0.233759f} },
    { {0.088370f, -0.071053f, -0.060125f}, {0.545188f, -0.472217f, -0.692663f}, {0.329101f, 0.236058f} },
    { {0.107217f, -0.053687f, -0.053059f}, {0.882293f, -0.467336f, -0.056176f}, {0.322575f, 0.243861f} },
    { {0.101862f, -0.049843f, -0.060125f}, {0.646625f, -0.347466f, -0.679076f}, {0.324429f, 0.245588f} },
    { {0.116334f, -0.028209f, -0.053059f}, {0.964636f, -0.257910f, -0.054408f}, {0.319419f, 0.255308f} },
    { {0.110462f, -0.025806f, -0.060125f}, {0.720033f, -0.197271f, -0.665310f}, {0.321452f, 0.256388f} },
    { {0.119535f, -0.000465f, -0.053059f}, {0.996140f, -0.076419f, -0.043193f}, {0.318310f, 0.267774f} },
    { {0.113482f, 0.000367f, -0.060125f}, {0.754579f, -0.060489f, -0.653415f}, {0.320406f, 0.268148f} },
    { {0.118680f, 0.013979f, -0.053059f}, {0.993670f, 0.100004f, -0.051172f}, {0.318606f, 0.274264f} },
    { {0.112676f, 0.013993f, -0.060125f}, {0.760052f, 0.074096f, -0.645624f}, {0.320685f, 0.274270f} },
    { {0.116181f, 0.027922f, -0.053059f}, {0.975027f, 0.216245f, -0.050595f}, {0.319472f, 0.280528f} },
    { {0.110318f, 0.027147f, -0.060125f}, {0.750296f, 0.163968f, -0.640445f}, {0.321501f, 0.280180f} },
    { {0.112136f, 0.041266f, -0.053059f}, {0.943285f, 0.328179f, -0.050119f}, {0.320872f, 0.286524f} },
    { {0.106502f, 0.039736f, -0.060125f}, {0.729570f, 0.251327f, -0.636052f}, {0.322823f, 0.285836f} },
    { {0.106642f, 0.053914f, -0.053059f}, {0.899427f, 0.434231f, -0.049750f}, {0.322774f, 0.292207f} },
    { {0.101320f, 0.051668f, -0.060125f}, {0.698530f, 0.334643f, -0.632512f}, {0.324617f, 0.291197f} },
    { {0.099799f, 0.065767f, -0.053059f}, {0.844480f, 0.533296f, -0.049494f}, {0.325144f, 0.297532f} },
    { {0.094863f, 0.062850f, -0.060125f}, {0.657940f, 0.412748f, -0.629884f}, {0.326853f, 0.296222f} },
    { {0.091703f, 0.076727f, -0.053059f}, {0.778611f, 0.624667f, -0.059640f}, {0.327947f, 0.302457f} },
    { {0.087226f, 0.073190f, -0.060125f}, {0.604941f, 0.489301f, -0.628196f}, {0.329497f, 0.300868f} },
    { {0.082452f, 0.086698f, -0.053059f}, {0.697257f, -0.706254f, -0.122625f}, {0.331150f, 0.306937f} },
    { {0.071969f, 0.090203f, -0.060125f}, {0.441367f, -0.340616f, -0.830167f}, {0.334779f, 0.308512f} },
    { {0.142321f, 0.111221f, -0.053059f}, {0.392354f, -0.919224f, -0.032937f}, {0.310421f, 0.317955f} },
    { {0.136078f, 0.114536f, -0.060125f}, {0.284839f, -0.694573f, -0.660632f}, {0.312582f, 0.319444f} },
    { {0.155474f, 0.118721f, -0.053059f}, {0.525129f, -0.849489f, -0.051071f}, {0.305866f, 0.321325f} },
    { {0.148487f, 0.121611f, -0.060125f}, {0.395643f, -0.644115f, -0.654662f}, {0.308286f, 0.322623f} },
    { {0.165386f, 0.126004f, -0.053059f}, {0.626531f, -0.777391f, -0.055867f}, {0.302435f, 0.324597f} },
    { {0.157838f, 0.128481f, -0.060125f}, {0.454929f, -0.568615f, -0.685358f}, {0.305048f, 0.325710f} },
    { {0.172597f, 0.133106f, -0.053059f}, {0.736637f, -0.673496f, -0.061397f}, {0.299938f, 0.327788f} },
    { {0.164640f, 0.135182f, -0.060125f}, {0.512917f, -0.472872f, -0.716455f}, {0.302693f, 0.328721f} },
    { {0.177646f, 0.140064f, -0.053059f}, {0.837741f, -0.541987f, -0.066633f}, {0.298190f, 0.330914f} },
    { {0.169404f, 0.141746f, -0.060125f}, {0.561336f, -0.366504f, -0.742009f}, {0.301044f, 0.331670f} },
    { {0.181075f, 0.146913f, -0.053059f}, {0.910845f, -0.406682f, -0.070504f}, {0.297002f, 0.333992f} },
    { {0.172638f, 0.148208f, -0.060125f}, {0.594194f, -0.267725f, -0.758456f}, {0.299924f, 0.334573f} },
    { {0.183423f, 0.153691f, -0.053059f}, {0.950207f, -0.303015f, -0.072721f}, {0.296189f, 0.337037f} },
    { {0.174853f, 0.154601f, -0.060125f}, {0.611329f, -0.196219f, -0.766665f}, {0.299157f, 0.337446f} },
    { {0.185231f, 0.160432f, -0.053059f}, {0.038639f, 0.999252f, -0.001516f}, {0.295564f, 0.340066f} },
    { {0.176559f, 0.160961f, -0.060125f}, {0.616902f, -0.165437f, -0.769456f}, {0.298566f, 0.340304f} },
    { {0.176559f, 0.160961f, 0.060015f}, {-0.000000f, -0.000000f, 1.000000f}, {0.421590f, 0.340304f} },
    { {-0.111651f, -0.027068f, 0.060015f}, {-0.000000f, -0.000000f, 1.000000f}, {0.321800f, 0.255821f} },
    { {-0.175005f, 0.161276f, 0.060015f}, {-0.000000f, -0.000000f, 1.000000f}, {0.299864f, 0.340445f} },
    { {0.174853f, 0.154601f, 0.060015f}, {-0.000000f, 0.000000f, 1.000000f}, {0.421000f, 0.337446f} },
    { {0.172638f, 0.148208f, 0.060015f}, {-0.000000f, -0.000000f, 1.000000f}, {0.420233f, 0.334573f} },
    { {-0.000746f, -0.113861f, 0.060015f}, {0.000000f, -0.000000f, 1.000000f}, {0.360200f, 0.216824f} },
    { {0.049464f, -0.102241f, 0.060015f}, {-0.000000f, -0.000000f, 1.000000f}, {0.377585f, 0.222045f} },
    { {0.025427f, -0.110842f, 0.060015f}, {0.000000f, -0.000001f, 1.000000f}, {0.369262f, 0.218181f} },
    { {0.070674f, -0.088749f, 0.060015f}, {-0.000000f, -0.000000f, 1.000000f}, {0.384929f, 0.228107f} },
    { {0.088370f, -0.071053f, 0.060015f}, {-0.000000f, -0.000000f, 1.000000f}, {0.391056f, 0.236058f} },
    { {0.101862f, -0.049843f, 0.060015f}, {-0.000000f, 0.000000f, 1.000000f}, {0.395727f, 0.245588f} },
    { {0.110462f, -0.025806f, 0.060015f}, {-0.000000f, -0.000000f, 1.000000f}, {0.398705f, 0.256388f} },
    { {0.113482f, 0.000367f, 0.060015f}, {-0.000000f, -0.000000f, 1.000000f}, {0.399751f, 0.268148f} },
    { {-0.023113f, -0.111667f, 0.060015f}, {-0.000000f, -0.000000f, 1.000000f}, {0.352456f, 0.217810f} },
    { {-0.044010f, -0.105367f, 0.060015f}, {-0.000000f, 0.000000f, 1.000000f}, {0.345220f, 0.220641f} },
    { {-0.063015f, -0.095382f, 0.060015f}, {-0.000000f, -0.000000f, 1.000000f}, {0.338640f, 0.225127f} },
    { {-0.079704f, -0.082138f, 0.060015f}, {-0.000000f, -0.000000f, 1.000000f}, {0.332862f, 0.231078f} },
    { {-0.093655f, -0.066055f, 0.060015f}, {-0.000000f, -0.000000f, 1.000000f}, {0.328031f, 0.238304f} },
    { {-0.104445f, -0.047558f, 0.060015f}, {-0.000000f, -0.000000f, 1.000000f}, {0.324295f, 0.246615f} },
    { {0.112676f, 0.013993f, 0.060015f}, {-0.000000f, -0.000000f, 1.000000f}, {0.399471f, 0.274270f} },
    { {0.110318f, 0.027147f, 0.060015f}, {-0.000000f, -0.000000f, 1.000000f}, {0.398655f, 0.280180f} },
    { {0.106502f, 0.039736f, 0.060015f}, {-0.000000f, -0.000000f, 1.000000f}, {0.397334f, 0.285836f} },
    { {0.101320f, 0.051668f, 0.060015f}, {-0.000000f, -0.000000f, 1.000000f}, {0.395539f, 0.291197f} },
    { {0.094863f, 0.062850f, 0.060015f}, {-0.000000f, -0.000000f, 1.000000f}, {0.393304f, 0.296222f} },
    { {0.087226f, 0.073190f, 0.060015f}, {-0.000000f, -0.000000f, 1.000000f}, {0.390659f, 0.300868f} },
    { {0.071969f, 0.090203f, 0.060015f}, {-0.000000f, -0.000000f, 1.000000f}, {0.385377f, 0.308512f} },
    { {0.172638f, 0.148208f, 0.060015f}, {0.000000f, 0.000000f, -1.000000f}, {0.299924f, 0.334573f} },
    { {0.071969f, 0.090203f, 0.060015f}, {0.000000f, 0.000000f, -1.000000f}, {0.334779f, 0.308512f} },
    { {-0.111651f, -0.027068f, 0.060015f}, {0.000000f, 0.000000f, -1.000000f}, {0.398356f, 0.255821f} },
    { {0.136078f, 0.114536f, 0.060015f}, {0.000000f, -0.000001f, 1.000000f}, {0.407574f, 0.319444f} },
    { {0.148487f, 0.121611f, 0.060015f}, {-0.000001f, 0.000000f, 1.000000f}, {0.411871f, 0.322623f} },
    { {0.157838f, 0.128481f, 0.060015f}, {-0.000002f, 0.000002f, 1.000000f}, {0.415108f, 0.325710f} },
    { {0.164640f, 0.135182f, 0.060015f}, {0.000000f, 0.000000f, 1.000000f}, {0.417464f, 0.328721f} },
    { {0.169404f, 0.141746f, 0.060015f}, {0.000000f, 0.000000f, 1.000000f}, {0.419113f, 0.331670f} },
    { {0.176559f, 0.160961f, -0.060125f}, {0.000000f, 0.000000f, -1.000000f}, {0.298566f, 0.340304f} },
    { {-0.175005f, 0.161276f, -0.060125f}, {0.000000f, 0.000000f, -1.000000f}, {0.420292f, 0.340445f} },
    { {-0.111651f, -0.027068f, -0.060125f}, {0.000000f, 0.000000f, -1.000000f}, {0.398356f, 0.255821f} },
    { {0.174853f, 0.154601f, -0.060125f}, {-0.000000f, 0.000001f, -1.000000f}, {0.299157f, 0.337446f} },
    { {0.172638f, 0.148208f, -0.060125f}, {-0.000000f, 0.000000f, -1.000000f}, {0.299924f, 0.334573f} },
    { {-0.000746f, -0.113861f, -0.060125f}, {-0.000000f, 0.000000f, -1.000000f}, {0.359957f, 0.216824f} },
    { {0.025427f, -0.110842f, -0.060125f}, {-0.000000f, 0.000001f, -1.000000f}, {0.350894f, 0.218181f} },
    { {0.049464f, -0.102241f, -0.060125f}, {-0.000000f, 0.000000f, -1.000000f}, {0.342572f, 0.222045f} },
    { {0.070674f, -0.088749f, -0.060125f}, {-0.000000f, 0.000001f, -1.000000f}, {0.335228f, 0.228107f} },
    { {0.088370f, -0.071053f, -0.060125f}, {-0.000000f, 0.000000f, -1.000000f}, {0.329101f, 0.236058f} },
    { {0.101862f, -0.049843f, -0.060125f}, {-0.000000f, 0.000000f, -1.000000f}, {0.324429f, 0.245588f} },
    { {0.110462f, -0.025806f, -0.060125f}, {-0.000000f, 0.000000f, -1.000000f}, {0.321452f, 0.256388f} },
    { {0.113482f, 0.000367f, -0.060125f}, {0.000000f, 0.000000f, -1.000000f}, {0.320406f, 0.268148f} },
    { {-0.023113f, -0.111667f, -0.060125f}, {0.000000f, 0.000000f, -1.000000f}, {0.367701f, 0.217810f} },
    { {-0.044010f, -0.105367f, -0.060125f}, {0.000000f, -0.000000f, -1.000000f}, {0.374936f, 0.220641f} },
    { {-0.063015f, -0.095382f, -0.060125f}, {0.000000f, -0.000000f, -1.000000f}, {0.381516f, 0.225127f} },
    { {-0.079704f, -0.082138f, -0.060125f}, {0.000000f, 0.000000f, -1.000000f}, {0.387295f, 0.231078f} },
    { {-0.093655f, -0.066055f, -0.060125f}, {0.000000f, 0.000000f, -1.000000f}, {0.392125f, 0.238304f} },
    { {-0.104445f, -0.047558f, -0.060125f}, {0.000000f, 0.000000f, -1.000000f}, {0.395861f, 0.246615f} },
    { {0.112676f, 0.013993f, -0.060125f}, {0.000000f, 0.000000f, -1.000000f}, {0.320685f, 0.274270f} },
    { {0.110318f, 0.027147f, -0.060125f}, {0.000000f, 0.000000f, -1.000000f}, {0.321501f, 0.280180f} },
    { {0.106502f, 0.039736f, -0.060125f}, {0.000000f, 0.000000f, -1.000000f}, {0.322823f, 0.285836f} },
    { {0.101320f, 0.051668f, -0.060125f}, {0.000000f, -0.000000f, -1.000000f}, {0.324617f, 0.291197f} },
    { {0.094863f, 0.062850f, -0.060125f}, {0.000000f, -0.000000f, -1.000000f}, {0.326853f, 0.296222f} },
    { {0.087226f, 0.073190f, -0.060125f}, {0.000000f, 0.000000f, -1.000000f}, {0.329497f, 0.300868f} },
    { {0.071969f, 0.090203f, -0.060125f}, {0.000000f, -0.000000f, -1.000000f}, {0.334779f, 0.308512f} },
    { {0.172638f, 0.148208f, -0.060125f}, {-0.000000f, -0.000000f, 1.000000f}, {0.420233f, 0.334573f} },
    { {-0.111651f, -0.027068f, -0.060125f}, {-0.000000f, -0.000000f, 1.000000f}, {0.321800f, 0.255821f} },
    { {0.071969f, 0.090203f, -0.060125f}, {-0.000000f, -0.000000f, 1.000000f}, {0.385377f, 0.308512f} },
    { {0.136078f, 0.114536f, -0.060125f}, {0.000000f, -0.000000f, -1.000000f}, {0.312582f, 0.319444f} },
    { {0.148487f, 0.121611f, -0.060125f}, {0.000000f, 0.000000f, -1.000000f}, {0.308286f, 0.322623f} },
    { {0.157838f, 0.128481f, -0.060125f}, {0.000000f, 0.000000f, -1.000000f}, {0.305048f, 0.325710f} },
    { {0.164640f, 0.135182f, -0.060125f}, {0.000000f, 0.000000f, -1.000000f}, {0.302693f, 0.328721f} },
    { {0.169404f, 0.141746f, -0.060125f}, {0.000000f, 0.000000f, -1.000000f}, {0.301044f, 0.331670f} },
};

WORD g_tind15[] = 
{
    2, 1, 0,    3, 2, 0,    5, 4, 1,    2, 5, 1,    7, 6, 4,
    5, 7, 4,    9, 8, 6,    7, 9, 6,    11, 10, 8,    9, 11, 8,
    13, 12, 10,    11, 13, 10,    15, 14, 12,    13, 15, 12,    17, 16, 14,
    15, 17, 14,    19, 18, 16,    17, 19, 16,    21, 20, 18,    19, 21, 18,
    23, 22, 20,    21, 23, 20,    25, 24, 22,    23, 25, 22,    27, 26, 24,
    25, 27, 24,    29, 28, 26,    27, 29, 26,    31, 30, 28,    29, 31, 28,
    33, 32, 30,    31, 33, 30,    35, 34, 32,    33, 35, 32,    37, 36, 34,
    35, 37, 34,    39, 38, 36,    37, 39, 36,    41, 40, 38,    39, 41, 38,
    43, 42, 40,    41, 43, 40,    45, 44, 42,    43, 45, 42,    47, 46, 44,
    45, 47, 44,    49, 48, 46,    47, 49, 46,    51, 50, 48,    49, 51, 48,
    53, 52, 50,    51, 53, 50,    55, 54, 52,    53, 55, 52,    57, 56, 54,
    55, 57, 54,    59, 58, 56,    57, 59, 56,    61, 60, 58,    59, 61, 58,
    64, 63, 62,    65, 64, 62,    67, 66, 63,    64, 67, 63,    69, 68, 66,
    67, 69, 66,    72, 71, 70,    73, 72, 70,    75, 74, 71,    72, 75, 71,
    77, 76, 74,    75, 77, 74,    79, 78, 76,    77, 79, 76,    81, 80, 78,
    79, 81, 78,    83, 82, 80,    81, 83, 80,    85, 84, 82,    83, 85, 82,
    87, 86, 84,    85, 87, 84,    89, 88, 86,    87, 89, 86,    92, 91, 90,
    93, 92, 90,    95, 94, 91,    92, 95, 91,    97, 96, 94,    95, 97, 94,
    99, 98, 96,    97, 99, 96,    101, 100, 98,    99, 101, 98,    103, 102, 100,
    101, 103, 100,    105, 104, 102,    103, 105, 102,    107, 106, 104,    105, 107, 104,
    109, 108, 106,    107, 109, 106,    112, 111, 110,    113, 112, 110,    116, 115, 114,
    117, 116, 114,    119, 118, 115,    116, 119, 115,    121, 120, 118,    119, 121, 118,
    123, 122, 120,    121, 123, 120,    126, 125, 124,    127, 126, 124,    129, 128, 125,
    126, 129, 125,    131, 130, 128,    129, 131, 128,    133, 132, 130,    131, 133, 130,
    136, 135, 134,    137, 136, 134,    140, 139, 138,    141, 140, 138,    143, 142, 139,
    140, 143, 139,    145, 144, 142,    143, 145, 142,    147, 146, 144,    145, 147, 144,
    149, 148, 146,    147, 149, 146,    151, 150, 148,    149, 151, 148,    153, 152, 150,
    151, 153, 150,    155, 154, 152,    153, 155, 152,    157, 156, 154,    155, 157, 154,
    159, 158, 156,    157, 159, 156,    161, 160, 158,    159, 161, 158,    163, 162, 160,
    161, 163, 160,    165, 164, 162,    163, 165, 162,    167, 166, 164,    165, 167, 164,
    169, 168, 166,    167, 169, 166,    171, 170, 168,    169, 171, 168,    173, 172, 170,
    171, 173, 170,    175, 174, 172,    173, 175, 172,    177, 176, 174,    175, 177, 174,
    179, 178, 176,    177, 179, 176,    181, 180, 178,    179, 181, 178,    183, 182, 180,
    181, 183, 180,    185, 184, 182,    183, 185, 182,    187, 186, 184,    185, 187, 184,
    189, 188, 186,    187, 189, 186,    191, 190, 188,    189, 191, 188,    193, 192, 190,
    191, 193, 190,    195, 194, 192,    193, 195, 192,    197, 196, 194,    195, 197, 194,
    199, 198, 196,    197, 199, 196,    202, 201, 200,    200, 201, 203,    203, 201, 204,
    207, 206, 205,    206, 208, 205,    208, 209, 205,    209, 210, 205,    210, 211, 205,
    211, 212, 205,    205, 212, 213,    213, 212, 214,    214, 212, 215,    215, 212, 216,
    216, 212, 217,    217, 212, 218,    218, 212, 201,    212, 219, 201,    219, 220, 201,
    220, 221, 201,    221, 222, 201,    222, 223, 201,    223, 224, 201,    224, 225, 201,
    228, 227, 226,    225, 229, 204,    229, 230, 204,    230, 231, 204,    231, 232, 204,
    232, 233, 204,    236, 235, 234,    236, 234, 237,    236, 237, 238,    241, 240, 239,
    242, 241, 239,    243, 242, 239,    244, 243, 239,    245, 244, 239,    246, 245, 239,
    246, 239, 247,    246, 247, 248,    246, 248, 249,    246, 249, 250,    246, 250, 251,
    246, 251, 252,    246, 252, 236,    253, 246, 236,    254, 253, 236,    255, 254, 236,
    256, 255, 236,    257, 256, 236,    258, 257, 236,    259, 258, 236,    262, 261, 260,
    263, 259, 238,    264, 263, 238,    265, 264, 238,    266, 265, 238,    267, 266, 238,

};

D3DMATRIX g_tmat16 = 
{
    0.910018f, 0.244813f, 0.334565f, 0.000000f, 
    0.197246f, -0.965505f, 0.169982f, 0.000000f, 
    0.364638f, -0.088695f, -0.926916f, 0.000000f, 
    2.584553f, -2.546772f, 2.961063f, 1.000000f, 
};

// Mesh #16 Tris:108 Verts:129
MODELVERT g_tmesh16[] = 
{
    { {0.189369f, 0.074403f, -0.066566f}, {-0.165934f, 0.255192f, 0.952546f}, {0.417168f, 0.337846f} },
    { {0.189575f, -0.112498f, -0.019950f}, {-0.032158f, 0.214955f, 0.976094f}, {0.417232f, 0.259504f} },
    { {0.184071f, -0.108596f, -0.026890f}, {-0.938286f, 0.343806f, 0.037656f}, {0.415514f, 0.261140f} },
    { {0.184157f, 0.079180f, -0.072246f}, {-0.997346f, 0.070282f, 0.019020f}, {0.415541f, 0.339848f} },
    { {0.135684f, -0.166680f, -0.017821f}, {-0.016664f, 0.203588f, 0.978915f}, {0.400408f, 0.236793f} },
    { {0.131751f, -0.160875f, -0.024836f}, {-0.097863f, 0.994907f, 0.024141f}, {0.399180f, 0.239226f} },
    { {0.135684f, -0.166680f, -0.017821f}, {-0.016664f, 0.203588f, 0.978915f}, {0.319749f, 0.340445f} },
    { {-0.122455f, -0.165973f, -0.017849f}, {0.074515f, 0.243741f, 0.966974f}, {0.400340f, 0.340430f} },
    { {-0.118740f, -0.160875f, -0.024836f}, {0.266357f, 0.962970f, 0.041741f}, {0.399180f, 0.336670f} },
    { {-0.118740f, -0.160875f, -0.024836f}, {0.266357f, 0.962970f, 0.041741f}, {0.320977f, 0.239226f} },
    { {-0.122455f, -0.165973f, -0.017849f}, {0.074515f, 0.243741f, 0.966974f}, {0.319817f, 0.237089f} },
    { {-0.176562f, -0.113620f, -0.019906f}, {0.064848f, 0.194615f, 0.978734f}, {0.302925f, 0.259034f} },
    { {-0.171060f, -0.108596f, -0.026890f}, {0.987364f, 0.156145f, 0.027041f}, {0.304642f, 0.261140f} },
    { {-0.174977f, 0.077051f, -0.066566f}, {-0.094817f, 0.284222f, 0.954058f}, {0.303420f, 0.338956f} },
    { {-0.170972f, 0.079347f, -0.072363f}, {0.881094f, 0.462394f, 0.099321f}, {0.304670f, 0.339918f} },
    { {-0.193822f, 0.041549f, -0.063373f}, {-0.385224f, 0.234918f, 0.892421f}, {0.297536f, 0.324075f} },
    { {-0.200140f, 0.043878f, -0.069169f}, {-0.997454f, 0.068670f, 0.019214f}, {0.295564f, 0.325051f} },
    { {-0.174977f, 0.077051f, -0.066566f}, {-0.094817f, 0.284222f, 0.954058f}, {0.416737f, 0.314209f} },
    { {-0.200140f, 0.043878f, -0.069169f}, {-0.997454f, 0.068670f, 0.019214f}, {0.424593f, 0.312807f} },
    { {-0.170972f, 0.079347f, -0.072363f}, {0.881094f, 0.462394f, 0.099321f}, {0.415487f, 0.311088f} },
    { {-0.195350f, -0.126008f, -0.019419f}, {-0.307879f, 0.062799f, 0.949351f}, {0.297059f, 0.253841f} },
    { {-0.200140f, -0.127771f, -0.026136f}, {-0.925300f, -0.378001f, 0.030595f}, {0.295564f, 0.253102f} },
    { {-0.135497f, -0.179319f, -0.020343f}, {-0.017751f, -0.214180f, 0.976633f}, {0.315745f, 0.231495f} },
    { {-0.138926f, -0.188938f, -0.023733f}, {-0.671562f, -0.718889f, 0.179450f}, {0.314675f, 0.227463f} },
    { {0.148726f, -0.180027f, -0.020315f}, {0.065343f, -0.216608f, 0.974069f}, {0.404480f, 0.231199f} },
    { {0.151937f, -0.188938f, -0.023733f}, {0.671330f, -0.726075f, 0.148766f}, {0.405482f, 0.227463f} },
    { {0.208363f, -0.124887f, -0.019463f}, {0.390223f, 0.112355f, 0.913839f}, {0.423098f, 0.254311f} },
    { {0.213151f, -0.127771f, -0.026136f}, {0.983925f, -0.176673f, 0.026042f}, {0.424593f, 0.253102f} },
    { {0.208101f, 0.043211f, -0.063373f}, {0.314589f, 0.262537f, 0.912200f}, {0.423016f, 0.324771f} },
    { {0.213151f, 0.043878f, -0.069169f}, {0.972806f, 0.225745f, 0.051848f}, {0.424593f, 0.325051f} },
    { {0.208101f, 0.043211f, -0.063373f}, {0.314589f, 0.262537f, 0.912200f}, {0.408678f, 0.315927f} },
    { {0.189369f, 0.074403f, -0.066566f}, {-0.165934f, 0.255192f, 0.952546f}, {0.421954f, 0.314209f} },
    { {0.184157f, 0.079180f, -0.072246f}, {-0.997346f, 0.070282f, 0.019020f}, {0.423987f, 0.311151f} },
    { {0.184157f, 0.079180f, -0.072246f}, {-0.997346f, 0.070282f, 0.019020f}, {0.296170f, 0.311151f} },
    { {0.184071f, -0.108596f, -0.026890f}, {-0.938286f, 0.343806f, 0.037656f}, {0.376089f, 0.335564f} },
    { {0.184071f, -0.108572f, -0.234969f}, {-0.986991f, 0.158800f, -0.025106f}, {0.376079f, 0.223566f} },
    { {0.184157f, 0.079555f, -0.195696f}, {-0.887553f, 0.447644f, -0.108927f}, {0.296010f, 0.244704f} },
    { {0.184071f, -0.108596f, -0.026890f}, {-0.938286f, 0.343806f, 0.037656f}, {0.304642f, 0.335564f} },
    { {0.131751f, -0.160875f, -0.024836f}, {-0.097863f, 0.994907f, 0.024141f}, {0.320977f, 0.336670f} },
    { {0.131751f, -0.159886f, -0.245176f}, {-0.264490f, 0.964020f, -0.026672f}, {0.320977f, 0.218072f} },
    { {0.184071f, -0.108572f, -0.234969f}, {-0.986991f, 0.158800f, -0.025106f}, {0.304642f, 0.223566f} },
    { {-0.118740f, -0.159886f, -0.245176f}, {0.096205f, 0.995308f, -0.010340f}, {0.399180f, 0.218072f} },
    { {-0.171060f, -0.108596f, -0.026890f}, {0.987364f, 0.156145f, 0.027041f}, {0.415514f, 0.335564f} },
    { {-0.171060f, -0.108572f, -0.234969f}, {0.939782f, 0.340231f, -0.032448f}, {0.415514f, 0.223566f} },
    { {-0.171060f, -0.108596f, -0.026890f}, {0.987364f, 0.156145f, 0.027041f}, {0.344067f, 0.335564f} },
    { {-0.170972f, 0.079347f, -0.072363f}, {0.881094f, 0.462394f, 0.099321f}, {0.424058f, 0.311088f} },
    { {-0.170972f, 0.080604f, -0.195139f}, {0.997501f, 0.068891f, -0.015702f}, {0.424593f, 0.245004f} },
    { {-0.171060f, -0.108572f, -0.234969f}, {0.939782f, 0.340231f, -0.032448f}, {0.344078f, 0.223566f} },
    { {-0.200140f, 0.043628f, -0.205716f}, {-0.972427f, 0.225879f, -0.058008f}, {0.424593f, 0.239311f} },
    { {-0.170972f, 0.080604f, -0.195139f}, {0.997501f, 0.068891f, -0.015702f}, {0.415487f, 0.245004f} },
    { {-0.200140f, 0.043878f, -0.069169f}, {-0.997454f, 0.068670f, 0.019214f}, {0.311195f, 0.312807f} },
    { {-0.200140f, -0.127771f, -0.026136f}, {-0.925300f, -0.378001f, 0.030595f}, {0.384250f, 0.335970f} },
    { {-0.200140f, -0.127393f, -0.238713f}, {-0.983939f, -0.176550f, -0.026360f}, {0.384089f, 0.221551f} },
    { {-0.200140f, 0.043628f, -0.205716f}, {-0.972427f, 0.225879f, -0.058008f}, {0.311301f, 0.239311f} },
    { {-0.200140f, -0.127771f, -0.026136f}, {-0.925300f, -0.378001f, 0.030595f}, {0.295564f, 0.335970f} },
    { {-0.138926f, -0.188938f, -0.023733f}, {-0.671562f, -0.718889f, 0.179450f}, {0.314675f, 0.337263f} },
    { {-0.138926f, -0.187431f, -0.250655f}, {-0.675522f, -0.724451f, -0.137263f}, {0.314675f, 0.215123f} },
    { {-0.200140f, -0.127393f, -0.238713f}, {-0.983939f, -0.176550f, -0.026360f}, {0.295564f, 0.221551f} },
    { {-0.103622f, -0.222431f, -0.053277f}, {-0.081016f, -0.995615f, 0.046770f}, {0.325696f, 0.321361f} },
    { {0.116633f, -0.222431f, -0.053277f}, {0.061568f, -0.982676f, 0.174808f}, {0.394460f, 0.321361f} },
    { {0.116633f, -0.222558f, -0.225927f}, {0.081497f, -0.995580f, -0.046668f}, {0.394460f, 0.228433f} },
    { {-0.103622f, -0.222558f, -0.225927f}, {-0.064130f, -0.981462f, -0.180610f}, {0.325696f, 0.228433f} },
    { {0.151937f, -0.188938f, -0.023733f}, {0.671330f, -0.726075f, 0.148766f}, {0.405482f, 0.337263f} },
    { {0.213151f, -0.127771f, -0.026136f}, {0.983925f, -0.176673f, 0.026042f}, {0.424593f, 0.335970f} },
    { {0.213151f, -0.127393f, -0.238713f}, {0.924988f, -0.378602f, -0.032525f}, {0.424593f, 0.221551f} },
    { {0.151937f, -0.187431f, -0.250655f}, {0.673192f, -0.720876f, -0.164773f}, {0.405482f, 0.215123f} },
    { {0.213151f, -0.127771f, -0.026136f}, {0.983925f, -0.176673f, 0.026042f}, {0.335906f, 0.335970f} },
    { {0.213151f, 0.043878f, -0.069169f}, {0.972806f, 0.225745f, 0.051848f}, {0.408962f, 0.312807f} },
    { {0.213151f, 0.043628f, -0.205716f}, {0.997677f, 0.066510f, -0.014766f}, {0.408855f, 0.239311f} },
    { {0.213151f, -0.127393f, -0.238713f}, {0.924988f, -0.378602f, -0.032525f}, {0.336067f, 0.221551f} },
    { {0.213151f, 0.043878f, -0.069169f}, {0.972806f, 0.225745f, 0.051848f}, {0.295564f, 0.312807f} },
    { {0.184157f, 0.079180f, -0.072246f}, {-0.997346f, 0.070282f, 0.019020f}, {0.304615f, 0.311151f} },
    { {0.184157f, 0.079555f, -0.195696f}, {-0.887553f, 0.447644f, -0.108927f}, {0.304615f, 0.244704f} },
    { {0.213151f, 0.043628f, -0.205716f}, {0.997677f, 0.066510f, -0.014766f}, {0.295564f, 0.239311f} },
    { {0.184157f, 0.079555f, -0.195696f}, {-0.887553f, 0.447644f, -0.108927f}, {0.304615f, 0.340005f} },
    { {0.184071f, -0.108572f, -0.234969f}, {-0.986991f, 0.158800f, -0.025106f}, {0.304642f, 0.261150f} },
    { {0.189575f, -0.111252f, -0.242876f}, {-0.245944f, 0.213160f, -0.945555f}, {0.302924f, 0.260026f} },
    { {0.189369f, 0.074006f, -0.201491f}, {-0.247092f, 0.261473f, -0.933047f}, {0.302988f, 0.337680f} },
    { {0.131751f, -0.159886f, -0.245176f}, {-0.264490f, 0.964020f, -0.026672f}, {0.320977f, 0.239641f} },
    { {0.135684f, -0.164434f, -0.253454f}, {-0.051030f, 0.283085f, -0.957736f}, {0.319749f, 0.237734f} },
    { {-0.122455f, -0.163740f, -0.253316f}, {0.026565f, 0.525166f, -0.850585f}, {0.400340f, 0.213690f} },
    { {0.135684f, -0.164434f, -0.253454f}, {-0.051030f, 0.283085f, -0.957736f}, {0.319749f, 0.213616f} },
    { {-0.118740f, -0.159886f, -0.245176f}, {0.096205f, 0.995308f, -0.010340f}, {0.399180f, 0.239641f} },
    { {-0.171060f, -0.108572f, -0.234969f}, {0.939782f, 0.340231f, -0.032448f}, {0.415514f, 0.261150f} },
    { {-0.176562f, -0.112353f, -0.243095f}, {0.220975f, 0.243091f, -0.944498f}, {0.417232f, 0.259565f} },
    { {-0.122455f, -0.163740f, -0.253316f}, {0.026565f, 0.525166f, -0.850585f}, {0.400340f, 0.238025f} },
    { {-0.170972f, 0.080604f, -0.195139f}, {0.997501f, 0.068891f, -0.015702f}, {0.415487f, 0.340445f} },
    { {-0.174977f, 0.076581f, -0.200873f}, {0.472026f, 0.199728f, -0.858662f}, {0.416737f, 0.338759f} },
    { {-0.200140f, 0.043628f, -0.205716f}, {-0.972427f, 0.225879f, -0.058008f}, {0.424593f, 0.324946f} },
    { {-0.193822f, 0.042807f, -0.212270f}, {-0.088646f, 0.237749f, -0.967273f}, {0.422620f, 0.324602f} },
    { {-0.170972f, 0.080604f, -0.195139f}, {0.997501f, 0.068891f, -0.015702f}, {0.295564f, 0.245004f} },
    { {-0.193822f, 0.042807f, -0.212270f}, {-0.088646f, 0.237749f, -0.967273f}, {0.311651f, 0.235783f} },
    { {-0.174977f, 0.076581f, -0.200873f}, {0.472026f, 0.199728f, -0.858662f}, {0.297276f, 0.241918f} },
    { {-0.200140f, -0.127393f, -0.238713f}, {-0.983939f, -0.176550f, -0.026360f}, {0.424593f, 0.253261f} },
    { {-0.195350f, -0.124513f, -0.245513f}, {-0.347937f, 0.120476f, -0.929745f}, {0.423098f, 0.254468f} },
    { {-0.138926f, -0.187431f, -0.250655f}, {-0.675522f, -0.724451f, -0.137263f}, {0.405482f, 0.228095f} },
    { {-0.135497f, -0.179021f, -0.253771f}, {-0.052269f, -0.046153f, -0.997566f}, {0.404411f, 0.231620f} },
    { {0.151937f, -0.187431f, -0.250655f}, {0.673192f, -0.720876f, -0.164773f}, {0.314675f, 0.228095f} },
    { {0.148726f, -0.179715f, -0.253910f}, {0.026985f, -0.107927f, -0.993793f}, {0.315677f, 0.231329f} },
    { {0.213151f, -0.127393f, -0.238713f}, {0.924988f, -0.378602f, -0.032525f}, {0.295564f, 0.253261f} },
    { {0.208363f, -0.123412f, -0.245294f}, {0.264199f, 0.081079f, -0.961054f}, {0.297058f, 0.254929f} },
    { {0.213151f, 0.043628f, -0.205716f}, {0.997677f, 0.066510f, -0.014766f}, {0.295564f, 0.324946f} },
    { {0.208101f, 0.044422f, -0.211882f}, {0.205207f, 0.215178f, -0.954771f}, {0.297140f, 0.325279f} },
    { {0.189369f, 0.074006f, -0.201491f}, {-0.247092f, 0.261473f, -0.933047f}, {0.302988f, 0.241585f} },
    { {-0.138926f, -0.188938f, -0.023733f}, {-0.281922f, -0.666865f, 0.689791f}, {0.314675f, 0.227463f} },
    { {0.151937f, -0.188938f, -0.023733f}, {0.602809f, -0.700511f, 0.381976f}, {0.405482f, 0.227463f} },
    { {0.140466f, -0.203565f, -0.033185f}, {0.372401f, -0.797415f, 0.474812f}, {0.401901f, 0.221332f} },
    { {-0.127455f, -0.203565f, -0.033185f}, {-0.380167f, -0.798086f, 0.467474f}, {0.318256f, 0.221332f} },
    { {-0.138926f, -0.187431f, -0.250655f}, {-0.619857f, -0.655453f, -0.431462f}, {0.314675f, 0.215123f} },
    { {-0.138926f, -0.188938f, -0.023733f}, {-0.281922f, -0.666865f, 0.689791f}, {0.314675f, 0.337263f} },
    { {-0.127455f, -0.203565f, -0.033185f}, {-0.380167f, -0.798086f, 0.467474f}, {0.318256f, 0.332175f} },
    { {-0.127455f, -0.203565f, -0.033185f}, {-0.380167f, -0.798086f, 0.467474f}, {0.416509f, 0.332175f} },
    { {-0.127455f, -0.203356f, -0.243607f}, {-0.396751f, -0.753831f, -0.523763f}, {0.416420f, 0.218916f} },
    { {-0.138926f, -0.187431f, -0.250655f}, {-0.619857f, -0.655453f, -0.431462f}, {0.409642f, 0.215123f} },
    { {0.151937f, -0.188938f, -0.023733f}, {0.602809f, -0.700511f, 0.381976f}, {0.309873f, 0.337263f} },
    { {0.151937f, -0.187431f, -0.250655f}, {0.309805f, -0.562422f, -0.766617f}, {0.310514f, 0.215123f} },
    { {0.140466f, -0.203356f, -0.243607f}, {0.398396f, -0.763770f, -0.507874f}, {0.303736f, 0.218916f} },
    { {0.140466f, -0.203356f, -0.243607f}, {0.398396f, -0.763770f, -0.507874f}, {0.401901f, 0.218916f} },
    { {0.140466f, -0.203565f, -0.033185f}, {0.372401f, -0.797415f, 0.474812f}, {0.401901f, 0.332175f} },
    { {0.151937f, -0.188938f, -0.023733f}, {0.602809f, -0.700511f, 0.381976f}, {0.405482f, 0.337263f} },
    { {0.151937f, -0.187431f, -0.250655f}, {0.309805f, -0.562422f, -0.766617f}, {0.314675f, 0.228095f} },
    { {-0.138926f, -0.187431f, -0.250655f}, {-0.619857f, -0.655453f, -0.431462f}, {0.405482f, 0.228095f} },
    { {-0.127455f, -0.203356f, -0.243607f}, {-0.396751f, -0.753831f, -0.523763f}, {0.401901f, 0.221420f} },
    { {0.140466f, -0.203356f, -0.243607f}, {0.398396f, -0.763770f, -0.507874f}, {0.318256f, 0.221420f} },
    { {0.116633f, -0.222431f, -0.053277f}, {0.061568f, -0.982676f, 0.174808f}, {0.394460f, 0.213424f} },
    { {-0.103622f, -0.222431f, -0.053277f}, {-0.081016f, -0.995615f, 0.046770f}, {0.325696f, 0.213424f} },
    { {-0.103622f, -0.222558f, -0.225927f}, {-0.064130f, -0.981462f, -0.180610f}, {0.394460f, 0.213371f} },
    { {0.116633f, -0.222558f, -0.225927f}, {0.081497f, -0.995580f, -0.046668f}, {0.325696f, 0.213371f} },
    { {-0.127455f, -0.203356f, -0.243607f}, {-0.396751f, -0.753831f, -0.523763f}, {0.318256f, 0.218916f} },
};

WORD g_tind16[] = 
{
    2, 1, 0,    3, 2, 0,    5, 4, 1,    2, 5, 1,    8, 7, 6,
    5, 9, 4,    12, 11, 10,    9, 12, 10,    14, 13, 11,    12, 14, 11,
    16, 15, 13,    19, 18, 17,    21, 20, 15,    16, 21, 15,    23, 22, 20,
    21, 23, 20,    25, 24, 22,    23, 25, 22,    27, 26, 24,    25, 27, 24,
    29, 28, 26,    27, 29, 26,    32, 31, 30,    29, 3, 28,    35, 34, 33,
    36, 35, 33,    39, 38, 37,    40, 39, 37,    41, 8, 38,    39, 41, 38,
    43, 42, 8,    41, 43, 8,    46, 45, 44,    47, 46, 44,    48, 18, 19,
    49, 48, 19,    52, 51, 50,    53, 52, 50,    56, 55, 54,    57, 56, 54,
    60, 59, 58,    61, 60, 58,    64, 63, 62,    65, 64, 62,    68, 67, 66,
    69, 68, 66,    72, 71, 70,    73, 72, 70,    76, 75, 74,    77, 76, 74,
    79, 78, 75,    76, 79, 75,    80, 41, 39,    81, 80, 39,    84, 83, 82,
    85, 84, 82,    87, 86, 83,    84, 87, 83,    89, 88, 86,    92, 91, 90,
    94, 93, 88,    89, 94, 88,    96, 95, 93,    94, 96, 93,    98, 97, 95,
    96, 98, 95,    100, 99, 97,    98, 100, 97,    102, 101, 99,    100, 102, 99,
    103, 72, 73,    102, 77, 101,    13, 15, 11,    15, 20, 11,    0, 1, 28,
    28, 1, 26,    26, 1, 24,    1, 4, 24,    24, 4, 22,    4, 10, 22,
    20, 22, 11,    11, 22, 10,    89, 87, 84,    94, 89, 84,    76, 77, 102,
    76, 102, 100,    76, 100, 98,    79, 76, 98,    79, 98, 96,    85, 79, 96,
    96, 94, 84,    96, 84, 85,    106, 105, 104,    104, 107, 106,    110, 109, 108,
    113, 112, 111,    116, 115, 114,    119, 118, 117,    122, 121, 120,    120, 123, 122,
    124, 106, 107,    107, 125, 124,    60, 117, 118,    118, 59, 60,    126, 122, 123,
    123, 127, 126,    58, 110, 128,    128, 61, 58,
};

D3DMATRIX g_tmat17 = 
{
    0.354010f, -0.038931f, -0.934431f, 0.000000f, 
    0.909975f, 0.245014f, 0.334536f, 0.000000f, 
    0.215925f, -0.968738f, 0.122163f, 0.000000f, 
    2.074058f, -2.660393f, 3.924587f, 1.000000f, 
};

// Mesh #17 Tris:200 Verts:138
MODELVERT g_tmesh17[] = 
{
    { {-0.000000f, -0.000000f, 0.346479f}, {0.000000f, 0.000000f, 1.000000f}, {0.360078f, 0.276908f} },
    { {-0.000000f, 0.150331f, 0.312167f}, {-0.045174f, 0.495998f, 0.867148f}, {0.360078f, 0.248631f} },
    { {-0.065226f, 0.135444f, 0.312167f}, {-0.255906f, 0.427278f, 0.867148f}, {0.347300f, 0.251432f} },
    { {-0.117534f, 0.093730f, 0.312167f}, {-0.415952f, 0.273931f, 0.867148f}, {0.337053f, 0.259278f} },
    { {-0.146562f, 0.033452f, 0.312167f}, {-0.493614f, 0.066328f, 0.867148f}, {0.331367f, 0.270616f} },
    { {-0.146562f, -0.033452f, 0.312167f}, {-0.473510f, -0.154412f, 0.867148f}, {0.331367f, 0.283200f} },
    { {-0.117534f, -0.093730f, 0.312167f}, {-0.359621f, -0.344568f, 0.867148f}, {0.337053f, 0.294538f} },
    { {-0.065226f, -0.135444f, 0.312167f}, {-0.174505f, -0.466479f, 0.867148f}, {0.347300f, 0.302384f} },
    { {-0.000000f, -0.150332f, 0.312167f}, {0.045174f, -0.495998f, 0.867148f}, {0.360078f, 0.305185f} },
    { {0.065226f, -0.135444f, 0.312167f}, {0.255906f, -0.427278f, 0.867148f}, {0.372856f, 0.302384f} },
    { {0.117534f, -0.093730f, 0.312167f}, {0.415952f, -0.273931f, 0.867148f}, {0.383103f, 0.294538f} },
    { {0.146562f, -0.033452f, 0.312167f}, {0.423005f, -0.096548f, 0.900969f}, {0.388790f, 0.283200f} },
    { {0.146562f, 0.033452f, 0.312167f}, {0.489136f, 0.092383f, 0.867301f}, {0.388790f, 0.270616f} },
    { {0.117534f, 0.093730f, 0.312167f}, {0.288036f, 0.229702f, 0.929662f}, {0.383103f, 0.259278f} },
    { {0.065226f, 0.135444f, 0.312167f}, {0.198610f, 0.455712f, 0.867687f}, {0.372856f, 0.251432f} },
    { {-0.000000f, 0.270888f, 0.216026f}, {-0.053692f, 0.791678f, 0.608574f}, {0.360078f, 0.225955f} },
    { {-0.117534f, 0.244061f, 0.216026f}, {-0.374530f, 0.705479f, 0.601687f}, {0.337053f, 0.231001f} },
    { {-0.211789f, 0.168896f, 0.216026f}, {-0.643536f, 0.473112f, 0.601687f}, {0.318589f, 0.245139f} },
    { {-0.264096f, 0.060278f, 0.216026f}, {-0.785081f, 0.147039f, 0.601687f}, {0.308341f, 0.265570f} },
    { {-0.264096f, -0.060279f, 0.216026f}, {-0.771131f, -0.208157f, 0.601687f}, {0.308341f, 0.288246f} },
    { {-0.211789f, -0.168896f, 0.216026f}, {-0.604449f, -0.522124f, 0.601687f}, {0.318589f, 0.308677f} },
    { {-0.117534f, -0.244062f, 0.216026f}, {-0.318049f, -0.732679f, 0.601687f}, {0.337053f, 0.322815f} },
    { {0.000000f, -0.270888f, 0.216026f}, {0.031345f, -0.798117f, 0.601687f}, {0.360078f, 0.327861f} },
    { {0.117534f, -0.244062f, 0.216026f}, {0.374531f, -0.705479f, 0.601687f}, {0.383103f, 0.322815f} },
    { {0.211789f, -0.168896f, 0.216026f}, {0.643536f, -0.473111f, 0.601687f}, {0.401568f, 0.308677f} },
    { {0.264096f, -0.060279f, 0.216026f}, {0.716116f, -0.183133f, 0.673528f}, {0.411815f, 0.288246f} },
    { {0.264096f, 0.012128f, 0.216026f}, {0.860799f, 0.000000f, 0.508945f}, {0.411815f, 0.274627f} },
    { {0.231341f, 0.052802f, 0.242820f}, {0.614528f, 0.108139f, 0.781448f}, {0.405398f, 0.266976f} },
    { {0.166765f, 0.132990f, 0.261951f}, {0.487833f, 0.388277f, 0.781831f}, {0.392748f, 0.251893f} },
    { {0.102484f, 0.212811f, 0.243687f}, {0.242046f, 0.575116f, 0.781445f}, {0.380155f, 0.236879f} },
    { {-0.000000f, 0.337791f, 0.077099f}, {-0.215990f, 0.965544f, 0.145168f}, {0.360078f, 0.213371f} },
    { {-0.146563f, 0.304340f, 0.077099f}, {-0.433805f, 0.875003f, 0.214905f}, {0.331367f, 0.219663f} },
    { {-0.264096f, 0.210609f, 0.077099f}, {-0.770494f, 0.600129f, 0.214905f}, {0.308341f, 0.237293f} },
    { {-0.329323f, 0.075165f, 0.077099f}, {-0.954577f, 0.206393f, 0.214905f}, {0.295564f, 0.262770f} },
    { {-0.329323f, -0.075166f, 0.077099f}, {-0.949595f, -0.228223f, 0.214905f}, {0.295564f, 0.291046f} },
    { {-0.264096f, -0.210610f, 0.077099f}, {-0.756533f, -0.617635f, 0.214905f}, {0.308341f, 0.316523f} },
    { {-0.146562f, -0.304340f, 0.077099f}, {-0.413631f, -0.884718f, 0.214905f}, {0.331367f, 0.334153f} },
    { {0.000000f, -0.337792f, 0.077099f}, {0.011195f, -0.976571f, 0.214905f}, {0.360078f, 0.340445f} },
    { {0.146562f, -0.304340f, 0.077099f}, {0.433805f, -0.875003f, 0.214905f}, {0.388790f, 0.334153f} },
    { {0.264096f, -0.210610f, 0.077099f}, {0.770494f, -0.600129f, 0.214905f}, {0.411815f, 0.316523f} },
    { {0.329323f, -0.075166f, 0.077099f}, {0.870737f, -0.405657f, 0.277955f}, {0.424593f, 0.291046f} },
    { {0.002249f, 0.337278f, 0.077099f}, {0.203182f, 0.892875f, 0.401859f}, {0.360519f, 0.213467f} },
    { {0.068261f, 0.255307f, 0.216026f}, {0.191269f, 0.838007f, 0.511038f}, {0.373451f, 0.228886f} },
    { {-0.000000f, 0.337791f, -0.077098f}, {-0.206955f, 0.938231f, -0.277296f}, {0.360078f, 0.213371f} },
    { {-0.146562f, 0.304340f, -0.077098f}, {-0.413631f, 0.884718f, -0.214905f}, {0.331367f, 0.219663f} },
    { {-0.264096f, 0.210609f, -0.077098f}, {-0.756533f, 0.617635f, -0.214905f}, {0.308341f, 0.237293f} },
    { {-0.329323f, 0.075165f, -0.077098f}, {-0.949595f, 0.228222f, -0.214905f}, {0.295564f, 0.262770f} },
    { {-0.329323f, -0.075166f, -0.077098f}, {-0.954577f, -0.206393f, -0.214905f}, {0.295564f, 0.291046f} },
    { {-0.264096f, -0.210610f, -0.077098f}, {-0.770494f, -0.600129f, -0.214905f}, {0.308341f, 0.316523f} },
    { {-0.146562f, -0.304340f, -0.077098f}, {-0.433805f, -0.875003f, -0.214905f}, {0.331367f, 0.334153f} },
    { {0.000000f, -0.337792f, -0.077098f}, {-0.011195f, -0.976571f, -0.214905f}, {0.360078f, 0.340445f} },
    { {0.146562f, -0.304340f, -0.077098f}, {0.413631f, -0.884718f, -0.214905f}, {0.388790f, 0.334153f} },
    { {0.264096f, -0.210610f, -0.077098f}, {0.756533f, -0.617635f, -0.214905f}, {0.411815f, 0.316523f} },
    { {0.329323f, -0.075166f, -0.077098f}, {0.898851f, -0.413631f, -0.144832f}, {0.424593f, 0.291046f} },
    { {0.329323f, -0.068868f, 0.077099f}, {0.928899f, -0.000000f, 0.370334f}, {0.424593f, 0.289862f} },
    { {0.329323f, -0.068868f, -0.077098f}, {0.918268f, -0.000001f, -0.395959f}, {0.424593f, 0.289862f} },
    { {-0.000000f, 0.270888f, -0.216026f}, {-0.060198f, 0.759738f, -0.647437f}, {0.360078f, 0.225955f} },
    { {-0.117534f, 0.244061f, -0.216026f}, {-0.318049f, 0.732679f, -0.601687f}, {0.337053f, 0.231001f} },
    { {-0.211789f, 0.168896f, -0.216026f}, {-0.604450f, 0.522124f, -0.601687f}, {0.318589f, 0.245139f} },
    { {-0.264096f, 0.060278f, -0.216026f}, {-0.771131f, 0.208157f, -0.601687f}, {0.308341f, 0.265570f} },
    { {-0.264096f, -0.060278f, -0.216026f}, {-0.785081f, -0.147039f, -0.601687f}, {0.308341f, 0.288246f} },
    { {-0.211789f, -0.168896f, -0.216026f}, {-0.643536f, -0.473112f, -0.601687f}, {0.318589f, 0.308677f} },
    { {-0.117534f, -0.244062f, -0.216026f}, {-0.374530f, -0.705479f, -0.601687f}, {0.337053f, 0.322815f} },
    { {0.000000f, -0.270888f, -0.216026f}, {-0.031345f, -0.798117f, -0.601687f}, {0.360078f, 0.327861f} },
    { {0.117534f, -0.244062f, -0.216026f}, {0.318049f, -0.732679f, -0.601687f}, {0.383103f, 0.322815f} },
    { {0.211789f, -0.168896f, -0.216026f}, {0.604449f, -0.522124f, -0.601687f}, {0.401568f, 0.308677f} },
    { {0.264096f, -0.060278f, -0.216026f}, {0.766948f, -0.238510f, -0.595738f}, {0.411815f, 0.288246f} },
    { {0.264096f, 0.012128f, -0.216026f}, {0.761763f, 0.000000f, -0.647856f}, {0.411815f, 0.274627f} },
    { {0.068261f, 0.255308f, -0.216026f}, {0.161825f, 0.709003f, -0.686387f}, {0.373451f, 0.228886f} },
    { {0.002204f, 0.337335f, -0.076759f}, {0.203451f, 0.887900f, -0.412603f}, {0.360510f, 0.213457f} },
    { {-0.000000f, 0.150331f, -0.312166f}, {0.030222f, 0.475778f, -0.879046f}, {0.360078f, 0.248631f} },
    { {-0.065226f, 0.135444f, -0.312166f}, {-0.174505f, 0.466479f, -0.867148f}, {0.347300f, 0.251432f} },
    { {-0.117534f, 0.093730f, -0.312166f}, {-0.359621f, 0.344568f, -0.867148f}, {0.337053f, 0.259278f} },
    { {-0.146562f, 0.033452f, -0.312166f}, {-0.473510f, 0.154411f, -0.867148f}, {0.331367f, 0.270616f} },
    { {-0.146562f, -0.033452f, -0.312166f}, {-0.493614f, -0.066328f, -0.867148f}, {0.331367f, 0.283200f} },
    { {-0.117534f, -0.093730f, -0.312166f}, {-0.415952f, -0.273931f, -0.867148f}, {0.337053f, 0.294538f} },
    { {-0.065226f, -0.135444f, -0.312166f}, {-0.255906f, -0.427278f, -0.867148f}, {0.347300f, 0.302384f} },
    { {0.000000f, -0.150332f, -0.312166f}, {-0.045174f, -0.495998f, -0.867148f}, {0.360078f, 0.305185f} },
    { {0.065226f, -0.135444f, -0.312166f}, {0.174505f, -0.466479f, -0.867148f}, {0.372856f, 0.302384f} },
    { {0.117534f, -0.093730f, -0.312166f}, {0.359621f, -0.344568f, -0.867148f}, {0.383103f, 0.294538f} },
    { {0.146562f, -0.033452f, -0.312166f}, {0.473510f, -0.154412f, -0.867148f}, {0.388790f, 0.283200f} },
    { {0.146562f, 0.033452f, -0.312166f}, {0.482882f, 0.057486f, -0.873797f}, {0.388790f, 0.270616f} },
    { {0.231341f, 0.052802f, -0.242819f}, {0.590637f, 0.207201f, -0.779882f}, {0.405398f, 0.266976f} },
    { {0.166765f, 0.132990f, -0.261951f}, {0.460376f, 0.421793f, -0.781117f}, {0.392748f, 0.251893f} },
    { {0.117534f, 0.093730f, -0.312166f}, {0.364562f, 0.243791f, -0.898700f}, {0.383103f, 0.259278f} },
    { {0.065226f, 0.135444f, -0.312166f}, {0.206727f, 0.429612f, -0.879032f}, {0.372856f, 0.251432f} },
    { {0.102484f, 0.212811f, -0.243687f}, {0.309353f, 0.542393f, -0.781095f}, {0.380155f, 0.236879f} },
    { {0.000000f, -0.000000f, -0.346478f}, {-0.000000f, -0.000000f, -1.000000f}, {0.360078f, 0.276908f} },
    { {0.097666f, -0.114897f, 0.035825f}, {0.778847f, 0.627214f, 0.000000f}, {0.382545f, 0.468793f} },
    { {0.097666f, -0.114897f, -0.055568f}, {0.778847f, 0.627214f, 0.000000f}, {0.382545f, 0.468793f} },
    { {0.059006f, -0.066891f, 0.118166f}, {0.778847f, 0.627214f, 0.000000f}, {0.375201f, 0.459347f} },
    { {-0.036781f, 0.052053f, 0.134561f}, {0.778847f, 0.627214f, 0.000000f}, {0.357005f, 0.435941f} },
    { {0.001318f, 0.004743f, 0.145386f}, {0.778847f, 0.627214f, 0.000000f}, {0.364242f, 0.445251f} },
    { {-0.096217f, 0.125858f, -0.055367f}, {0.778847f, 0.627214f, 0.000000f}, {0.345714f, 0.421418f} },
    { {-0.057065f, 0.077241f, 0.118166f}, {0.778847f, 0.627213f, -0.000000f}, {0.353152f, 0.430985f} },
    { {-0.096190f, 0.125825f, 0.035825f}, {0.778848f, 0.627213f, -0.000000f}, {0.345719f, 0.421425f} },
    { {0.059006f, -0.066891f, -0.137910f}, {0.778847f, 0.627214f, 0.000000f}, {0.375201f, 0.459347f} },
    { {-0.057065f, 0.077241f, -0.137910f}, {0.778847f, 0.627214f, 0.000000f}, {0.353152f, 0.430985f} },
    { {0.039592f, -0.042784f, 0.134047f}, {0.778847f, 0.627214f, 0.000000f}, {0.371513f, 0.454603f} },
    { {0.001318f, 0.004743f, -0.165129f}, {0.778847f, 0.627214f, 0.000000f}, {0.364242f, 0.445251f} },
    { {0.039592f, -0.042784f, -0.153790f}, {0.778847f, 0.627214f, -0.000000f}, {0.371513f, 0.454603f} },
    { {-0.036781f, 0.052053f, -0.154304f}, {0.778847f, 0.627214f, 0.000000f}, {0.357005f, 0.435941f} },
    { {0.231341f, 0.052802f, 0.242820f}, {0.209403f, 0.521325f, -0.827267f}, {0.407939f, 0.435794f} },
    { {0.264096f, 0.012128f, 0.216026f}, {-0.038017f, 0.814909f, -0.578341f}, {0.414161f, 0.443797f} },
    { {0.059006f, -0.066891f, 0.118166f}, {0.025214f, 0.751292f, -0.659488f}, {0.375201f, 0.459347f} },
    { {0.039592f, -0.042784f, 0.134047f}, {0.251809f, 0.462347f, -0.850193f}, {0.371513f, 0.454603f} },
    { {0.166765f, 0.132990f, 0.261951f}, {0.354026f, 0.336428f, -0.872629f}, {0.395672f, 0.420015f} },
    { {0.001318f, 0.004743f, 0.145386f}, {0.420590f, 0.250077f, -0.872104f}, {0.364242f, 0.445251f} },
    { {0.102484f, 0.212811f, 0.243687f}, {0.513989f, 0.130267f, -0.847848f}, {0.383461f, 0.404308f} },
    { {-0.036781f, 0.052053f, 0.134561f}, {0.567592f, 0.065408f, -0.820708f}, {0.357005f, 0.435941f} },
    { {0.002249f, 0.337278f, 0.077099f}, {0.799651f, -0.267316f, -0.537680f}, {0.364420f, 0.379815f} },
    { {0.068261f, 0.255307f, 0.216026f}, {0.749380f, -0.176738f, -0.638117f}, {0.376959f, 0.395945f} },
    { {-0.057065f, 0.077241f, 0.118166f}, {0.785380f, -0.238938f, -0.571041f}, {0.353152f, 0.430985f} },
    { {-0.096190f, 0.125825f, 0.035825f}, {0.799651f, -0.267316f, -0.537680f}, {0.345719f, 0.421425f} },
    { {0.329323f, -0.068868f, 0.077099f}, {-0.194886f, 0.980826f, -0.000000f}, {0.426552f, 0.459736f} },
    { {0.329323f, -0.068868f, -0.077098f}, {-0.194886f, 0.980826f, 0.000000f}, {0.426552f, 0.459736f} },
    { {0.097666f, -0.114897f, -0.055568f}, {-0.194886f, 0.980826f, -0.000000f}, {0.382545f, 0.468793f} },
    { {0.097666f, -0.114897f, 0.035825f}, {-0.194886f, 0.980826f, -0.000000f}, {0.382545f, 0.468793f} },
    { {0.329323f, -0.068868f, -0.077098f}, {-0.115427f, 0.833594f, 0.540184f}, {0.426552f, 0.459736f} },
    { {0.264096f, 0.012128f, -0.216026f}, {-0.048717f, 0.763292f, 0.644214f}, {0.414161f, 0.443797f} },
    { {0.059006f, -0.066891f, -0.137910f}, {-0.094611f, 0.813215f, 0.574221f}, {0.375201f, 0.459347f} },
    { {0.097666f, -0.114897f, -0.055568f}, {-0.115427f, 0.833594f, 0.540184f}, {0.382545f, 0.468793f} },
    { {0.068261f, 0.255308f, -0.216026f}, {0.752007f, -0.264392f, 0.603807f}, {0.376959f, 0.395945f} },
    { {0.002204f, 0.337335f, -0.076759f}, {0.777525f, -0.306303f, 0.549211f}, {0.364411f, 0.379804f} },
    { {-0.096217f, 0.125858f, -0.055367f}, {0.777525f, -0.306303f, 0.549211f}, {0.345714f, 0.421418f} },
    { {-0.057065f, 0.077241f, -0.137910f}, {0.698511f, -0.188825f, 0.690237f}, {0.353152f, 0.430985f} },
    { {0.231341f, 0.052802f, -0.242819f}, {0.184210f, 0.446173f, 0.875783f}, {0.407939f, 0.435794f} },
    { {0.039592f, -0.042784f, -0.153790f}, {0.135531f, 0.515934f, 0.845839f}, {0.371513f, 0.454603f} },
    { {0.166765f, 0.132990f, -0.261951f}, {0.347698f, 0.236427f, 0.907308f}, {0.395672f, 0.420015f} },
    { {0.102484f, 0.212811f, -0.243687f}, {0.504725f, 0.042168f, 0.862250f}, {0.383461f, 0.404308f} },
    { {-0.036781f, 0.052053f, -0.154304f}, {0.452918f, 0.100200f, 0.885903f}, {0.357005f, 0.435941f} },
    { {0.001318f, 0.004743f, -0.165129f}, {0.277342f, 0.324838f, 0.904191f}, {0.364242f, 0.445251f} },
    { {0.329323f, -0.068868f, 0.077099f}, {-0.074028f, 0.846018f, -0.527990f}, {0.426552f, 0.459736f} },
    { {0.097666f, -0.114897f, 0.035825f}, {-0.074028f, 0.846018f, -0.527990f}, {0.382545f, 0.468793f} },
    { {0.002204f, 0.337335f, -0.076759f}, {0.906607f, -0.421977f, -0.000426f}, {0.364411f, 0.379804f} },
    { {0.002249f, 0.337278f, 0.077099f}, {0.906607f, -0.421977f, -0.000426f}, {0.364420f, 0.379815f} },
    { {-0.096190f, 0.125825f, 0.035825f}, {0.906607f, -0.421977f, -0.000426f}, {0.345719f, 0.421425f} },
    { {-0.096217f, 0.125858f, -0.055367f}, {0.906607f, -0.421977f, -0.000426f}, {0.345714f, 0.421418f} },
};

WORD g_tind17[] = 
{
    0, 1, 2,    0, 2, 3,    0, 3, 4,    0, 4, 5,    0, 5, 6,
    0, 6, 7,    0, 7, 8,    0, 8, 9,    0, 9, 10,    0, 10, 11,
    0, 11, 12,    0, 12, 13,    0, 13, 14,    0, 14, 1,    1, 15, 16,
    1, 16, 2,    2, 16, 17,    2, 17, 3,    3, 17, 18,    3, 18, 4,
    4, 18, 19,    4, 19, 5,    5, 19, 20,    5, 20, 6,    6, 20, 21,
    6, 21, 7,    7, 21, 22,    7, 22, 8,    8, 22, 23,    8, 23, 9,
    9, 23, 24,    9, 24, 10,    10, 24, 25,    10, 25, 11,    11, 25, 12,
    25, 26, 27,    27, 12, 25,    12, 27, 28,    28, 13, 12,    13, 28, 14,
    29, 14, 28,    14, 29, 15,    14, 15, 1,    15, 30, 31,    15, 31, 16,
    16, 31, 32,    16, 32, 17,    17, 32, 33,    17, 33, 18,    18, 33, 34,
    18, 34, 19,    19, 34, 35,    19, 35, 20,    20, 35, 36,    20, 36, 21,
    21, 36, 37,    21, 37, 22,    22, 37, 38,    22, 38, 23,    23, 38, 39,
    23, 39, 24,    24, 39, 40,    24, 40, 25,    41, 30, 15,    15, 42, 41,
    30, 43, 44,    30, 44, 31,    31, 44, 45,    31, 45, 32,    32, 45, 46,
    32, 46, 33,    33, 46, 47,    33, 47, 34,    34, 47, 48,    34, 48, 35,
    35, 48, 49,    35, 49, 36,    36, 49, 50,    36, 50, 37,    37, 50, 51,
    37, 51, 38,    38, 51, 52,    38, 52, 39,    39, 52, 53,    39, 53, 40,
    40, 53, 54,    55, 54, 53,    41, 43, 30,    43, 56, 57,    43, 57, 44,
    44, 57, 58,    44, 58, 45,    45, 58, 59,    45, 59, 46,    46, 59, 60,
    46, 60, 47,    47, 60, 61,    47, 61, 48,    48, 61, 62,    48, 62, 49,
    49, 62, 63,    49, 63, 50,    50, 63, 64,    50, 64, 51,    51, 64, 65,
    51, 65, 52,    52, 65, 66,    52, 66, 53,    66, 67, 55,    68, 56, 69,
    43, 69, 56,    56, 70, 71,    56, 71, 57,    57, 71, 72,    57, 72, 58,
    58, 72, 73,    58, 73, 59,    59, 73, 74,    59, 74, 60,    60, 74, 75,
    60, 75, 61,    61, 75, 76,    61, 76, 62,    62, 76, 77,    62, 77, 63,
    63, 77, 78,    63, 78, 64,    64, 78, 79,    64, 79, 65,    65, 79, 80,
    65, 80, 66,    81, 82, 67,    83, 84, 85,    85, 86, 83,    85, 70, 68,
    56, 68, 70,    87, 71, 70,    87, 72, 71,    87, 73, 72,    87, 74, 73,
    87, 75, 74,    87, 76, 75,    87, 77, 76,    87, 78, 77,    87, 79, 78,
    87, 80, 79,    87, 81, 80,    87, 84, 81,    87, 85, 84,    87, 70, 85,
    25, 40, 54,    29, 42, 15,    55, 53, 66,    54, 26, 25,    66, 80, 81,
    81, 67, 66,    69, 43, 41,    82, 81, 84,    84, 83, 82,    68, 86, 85,
    88, 89, 90,    91, 92, 93,    91, 93, 94,    93, 95, 94,    96, 97, 89,
    92, 98, 93,    90, 89, 98,    97, 93, 89,    98, 89, 93,    99, 97, 96,
    96, 100, 99,    99, 101, 97,    102, 103, 104,    104, 105, 102,    106, 102, 105,
    105, 107, 106,    108, 106, 107,    107, 109, 108,    110, 111, 112,    112, 113, 110,
    114, 115, 116,    116, 117, 114,    118, 119, 120,    120, 121, 118,    122, 123, 124,
    124, 125, 122,    119, 126, 127,    127, 120, 119,    128, 129, 130,    130, 131, 128,
    111, 108, 109,    109, 112, 111,    103, 132, 133,    133, 104, 103,    134, 135, 136,
    136, 137, 134,    126, 128, 131,    131, 127, 126,    129, 122, 125,    125, 130, 129,

};

D3DMATRIX g_tmat18 = 
{
    0.215924f, -0.968738f, 0.122163f, 0.000000f, 
    0.909975f, 0.245013f, 0.334536f, 0.000000f, 
    -0.354009f, 0.038930f, 0.934431f, 0.000000f, 
    2.501749f, -2.635053f, 3.262205f, 1.000000f, 
};

// Mesh #18 Tris:312 Verts:334
MODELVERT g_tmesh18[] = 
{
    { {-0.000000f, 0.000000f, -0.000000f}, {0.000000f, 0.000000f, -1.000000f}, {0.318760f, 0.276908f} },
    { {0.210381f, 0.076572f, -0.000000f}, {0.000000f, 0.000000f, -1.000000f}, {0.318760f, 0.254842f} },
    { {0.223882f, 0.000000f, -0.000000f}, {0.000000f, 0.000000f, -1.000000f}, {0.318760f, 0.276908f} },
    { {0.171504f, 0.143909f, -0.000000f}, {0.000000f, 0.000000f, -1.000000f}, {0.318760f, 0.235437f} },
    { {0.111941f, 0.193888f, -0.000000f}, {0.000000f, 0.000000f, -1.000000f}, {0.318760f, 0.221034f} },
    { {0.038876f, 0.220481f, -0.000000f}, {0.000000f, 0.000000f, -1.000000f}, {0.318760f, 0.213371f} },
    { {-0.038877f, 0.220481f, -0.000000f}, {0.000000f, 0.000000f, -1.000000f}, {0.318760f, 0.213371f} },
    { {-0.111942f, 0.193888f, -0.000000f}, {0.000000f, 0.000000f, -1.000000f}, {0.318760f, 0.221034f} },
    { {-0.171504f, 0.143909f, -0.000000f}, {0.000000f, 0.000000f, -1.000000f}, {0.318760f, 0.235437f} },
    { {-0.210381f, 0.076572f, -0.000000f}, {0.000000f, 0.000000f, -1.000000f}, {0.318760f, 0.254842f} },
    { {-0.223883f, -0.000000f, -0.000000f}, {0.000000f, 0.000000f, -1.000000f}, {0.318760f, 0.276908f} },
    { {-0.210381f, -0.076572f, -0.000000f}, {0.000000f, 0.000000f, -1.000000f}, {0.318760f, 0.298974f} },
    { {-0.171504f, -0.143909f, -0.000000f}, {0.000000f, 0.000000f, -1.000000f}, {0.318760f, 0.318379f} },
    { {-0.111942f, -0.193888f, -0.000000f}, {0.000000f, 0.000000f, -1.000000f}, {0.318760f, 0.332782f} },
    { {-0.038877f, -0.220481f, -0.000000f}, {0.000000f, 0.000000f, -1.000000f}, {0.318760f, 0.340445f} },
    { {0.038877f, -0.220481f, -0.000000f}, {0.000000f, 0.000000f, -1.000000f}, {0.318760f, 0.340445f} },
    { {0.111941f, -0.193888f, -0.000000f}, {0.000000f, 0.000000f, -1.000000f}, {0.318760f, 0.332782f} },
    { {0.171504f, -0.143909f, -0.000000f}, {0.000000f, 0.000000f, -1.000000f}, {0.318760f, 0.318379f} },
    { {0.210381f, -0.076572f, -0.000000f}, {0.000000f, 0.000000f, -1.000000f}, {0.318760f, 0.298974f} },
    { {0.223882f, 0.000000f, -0.000000f}, {0.998277f, 0.058674f, -0.000000f}, {0.318760f, 0.276908f} },
    { {0.210381f, 0.076572f, 0.018574f}, {0.958142f, 0.286295f, -0.000000f}, {0.311028f, 0.254842f} },
    { {0.223882f, 0.000000f, 0.018574f}, {0.998277f, -0.058674f, 0.000000f}, {0.311028f, 0.276908f} },
    { {0.210381f, 0.076572f, -0.000000f}, {0.918006f, 0.396567f, -0.000000f}, {0.318760f, 0.254842f} },
    { {0.171504f, 0.143909f, 0.018574f}, {0.802440f, 0.596733f, -0.000000f}, {0.311028f, 0.235437f} },
    { {0.171504f, 0.143909f, -0.000000f}, {0.727009f, 0.686628f, 0.000000f}, {0.318760f, 0.235437f} },
    { {0.111941f, 0.193888f, 0.018574f}, {0.549952f, 0.835196f, 0.000000f}, {0.311028f, 0.221034f} },
    { {0.111941f, 0.193888f, -0.000000f}, {0.448325f, 0.893871f, 0.000000f}, {0.318760f, 0.221034f} },
    { {0.038876f, 0.220481f, 0.018574f}, {0.231132f, 0.972922f, 0.000000f}, {0.311028f, 0.213371f} },
    { {0.038876f, 0.220481f, -0.000000f}, {0.115566f, 0.993300f, 0.000000f}, {0.318760f, 0.213371f} },
    { {-0.038877f, 0.220481f, 0.018574f}, {-0.115566f, 0.993300f, 0.000000f}, {0.311028f, 0.213371f} },
    { {-0.038877f, 0.220481f, -0.000000f}, {-0.231132f, 0.972922f, 0.000000f}, {0.318760f, 0.213371f} },
    { {-0.111942f, 0.193888f, 0.018574f}, {-0.448325f, 0.893871f, 0.000000f}, {0.311028f, 0.221034f} },
    { {-0.111942f, 0.193888f, -0.000000f}, {-0.549952f, 0.835196f, 0.000000f}, {0.318760f, 0.221034f} },
    { {-0.171504f, 0.143909f, 0.018574f}, {-0.727010f, 0.686627f, 0.000000f}, {0.311028f, 0.235437f} },
    { {-0.171504f, 0.143909f, -0.000000f}, {-0.802440f, 0.596733f, 0.000000f}, {0.318760f, 0.235437f} },
    { {-0.210381f, 0.076572f, 0.018574f}, {-0.918006f, 0.396567f, 0.000000f}, {0.311028f, 0.254842f} },
    { {-0.210381f, 0.076572f, -0.000000f}, {-0.958142f, 0.286295f, 0.000000f}, {0.318760f, 0.254842f} },
    { {-0.223883f, 0.000000f, 0.018574f}, {-0.998277f, 0.058674f, 0.000000f}, {0.311028f, 0.276908f} },
    { {-0.223883f, -0.000000f, -0.000000f}, {-0.998277f, -0.058675f, 0.000000f}, {0.318760f, 0.276908f} },
    { {-0.210381f, -0.076572f, 0.018574f}, {-0.958141f, -0.286295f, 0.000000f}, {0.311028f, 0.298974f} },
    { {-0.210381f, -0.076572f, -0.000000f}, {-0.918006f, -0.396567f, 0.000000f}, {0.318760f, 0.298974f} },
    { {-0.171504f, -0.143909f, 0.018574f}, {-0.802440f, -0.596733f, 0.000000f}, {0.311028f, 0.318379f} },
    { {-0.171504f, -0.143909f, -0.000000f}, {-0.727009f, -0.686628f, 0.000000f}, {0.318760f, 0.318379f} },
    { {-0.111942f, -0.193888f, 0.018574f}, {-0.549952f, -0.835196f, 0.000000f}, {0.311028f, 0.332782f} },
    { {-0.111942f, -0.193888f, -0.000000f}, {-0.448325f, -0.893871f, 0.000000f}, {0.318760f, 0.332782f} },
    { {-0.038877f, -0.220481f, 0.018574f}, {-0.231132f, -0.972922f, 0.000000f}, {0.311028f, 0.340445f} },
    { {-0.038877f, -0.220481f, -0.000000f}, {-0.115566f, -0.993300f, 0.000000f}, {0.318760f, 0.340445f} },
    { {0.038877f, -0.220481f, 0.018574f}, {0.115566f, -0.993300f, 0.000000f}, {0.311028f, 0.340445f} },
    { {0.038877f, -0.220481f, -0.000000f}, {0.231132f, -0.972922f, 0.000000f}, {0.318760f, 0.340445f} },
    { {0.111941f, -0.193888f, 0.018574f}, {0.448325f, -0.893871f, 0.000000f}, {0.311028f, 0.332782f} },
    { {0.111941f, -0.193888f, -0.000000f}, {0.549952f, -0.835196f, 0.000000f}, {0.318760f, 0.332782f} },
    { {0.171504f, -0.143909f, 0.018574f}, {0.727010f, -0.686627f, 0.000000f}, {0.311028f, 0.318379f} },
    { {0.171504f, -0.143909f, -0.000000f}, {0.802440f, -0.596733f, 0.000000f}, {0.318760f, 0.318379f} },
    { {0.210381f, -0.076572f, 0.018574f}, {0.918006f, -0.396567f, 0.000000f}, {0.311028f, 0.298974f} },
    { {0.210381f, -0.076572f, -0.000000f}, {0.958142f, -0.286295f, 0.000000f}, {0.318760f, 0.298974f} },
    { {0.188144f, -0.001983f, 0.018574f}, {0.998277f, 0.058675f, -0.000000f}, {0.311028f, 0.277480f} },
    { {0.176702f, 0.062908f, 0.037149f}, {0.958142f, 0.286295f, -0.000000f}, {0.303296f, 0.258779f} },
    { {0.188144f, -0.001983f, 0.037149f}, {0.998277f, -0.058674f, 0.000000f}, {0.303296f, 0.277480f} },
    { {0.176702f, 0.062908f, 0.018574f}, {0.918006f, 0.396567f, 0.000000f}, {0.311028f, 0.258779f} },
    { {0.143755f, 0.119973f, 0.037149f}, {0.802440f, 0.596733f, 0.000000f}, {0.303296f, 0.242335f} },
    { {0.143755f, 0.119973f, 0.018574f}, {0.727009f, 0.686628f, 0.000000f}, {0.311028f, 0.242335f} },
    { {0.093278f, 0.162329f, 0.037149f}, {0.549952f, 0.835196f, 0.000000f}, {0.303296f, 0.230129f} },
    { {0.093278f, 0.162329f, 0.018574f}, {0.448325f, 0.893871f, 0.000000f}, {0.311028f, 0.230129f} },
    { {0.031359f, 0.184865f, 0.037149f}, {0.231132f, 0.972922f, 0.000000f}, {0.303296f, 0.223634f} },
    { {0.031359f, 0.184865f, 0.018574f}, {0.115566f, 0.993300f, 0.000000f}, {0.311028f, 0.223634f} },
    { {-0.034534f, 0.184865f, 0.037149f}, {-0.115566f, 0.993300f, 0.000000f}, {0.303296f, 0.223634f} },
    { {-0.034534f, 0.184865f, 0.018574f}, {-0.231132f, 0.972922f, 0.000000f}, {0.311028f, 0.223634f} },
    { {-0.096453f, 0.162329f, 0.037149f}, {-0.448325f, 0.893871f, 0.000000f}, {0.303296f, 0.230129f} },
    { {-0.096453f, 0.162329f, 0.018574f}, {-0.549952f, 0.835196f, 0.000000f}, {0.311028f, 0.230129f} },
    { {-0.146930f, 0.119973f, 0.037149f}, {-0.727009f, 0.686627f, 0.000000f}, {0.303296f, 0.242335f} },
    { {-0.146930f, 0.119973f, 0.018574f}, {-0.802440f, 0.596733f, -0.000000f}, {0.311028f, 0.242335f} },
    { {-0.179876f, 0.062908f, 0.037149f}, {-0.918006f, 0.396567f, -0.000000f}, {0.303296f, 0.258779f} },
    { {-0.179876f, 0.062908f, 0.018574f}, {-0.958142f, 0.286295f, -0.000000f}, {0.311028f, 0.258779f} },
    { {-0.191318f, -0.001983f, 0.037149f}, {-0.998277f, 0.058674f, -0.000000f}, {0.303296f, 0.277480f} },
    { {-0.191318f, -0.001983f, 0.018574f}, {-0.998277f, -0.058675f, -0.000000f}, {0.311028f, 0.277480f} },
    { {-0.179876f, -0.066875f, 0.037149f}, {-0.958141f, -0.286295f, 0.000000f}, {0.303296f, 0.296180f} },
    { {-0.179876f, -0.066875f, 0.018574f}, {-0.918006f, -0.396567f, 0.000000f}, {0.311028f, 0.296180f} },
    { {-0.146930f, -0.123940f, 0.037149f}, {-0.802440f, -0.596733f, 0.000000f}, {0.303296f, 0.312625f} },
    { {-0.146930f, -0.123940f, 0.018574f}, {-0.727009f, -0.686628f, 0.000000f}, {0.311028f, 0.312625f} },
    { {-0.096453f, -0.166295f, 0.037149f}, {-0.549952f, -0.835196f, 0.000000f}, {0.303296f, 0.324830f} },
    { {-0.096453f, -0.166295f, 0.018574f}, {-0.448325f, -0.893871f, 0.000000f}, {0.311028f, 0.324830f} },
    { {-0.034533f, -0.188832f, 0.037149f}, {-0.231132f, -0.972922f, 0.000000f}, {0.303296f, 0.331325f} },
    { {-0.034533f, -0.188832f, 0.018574f}, {-0.115566f, -0.993300f, 0.000000f}, {0.311028f, 0.331325f} },
    { {0.031359f, -0.188832f, 0.037149f}, {0.115566f, -0.993300f, 0.000000f}, {0.303296f, 0.331325f} },
    { {0.031359f, -0.188832f, 0.018574f}, {0.231132f, -0.972922f, 0.000000f}, {0.311028f, 0.331325f} },
    { {0.093279f, -0.166295f, 0.037149f}, {0.448325f, -0.893871f, 0.000000f}, {0.303296f, 0.324830f} },
    { {0.093279f, -0.166295f, 0.018574f}, {0.549952f, -0.835196f, 0.000000f}, {0.311028f, 0.324830f} },
    { {0.143755f, -0.123940f, 0.037149f}, {0.727010f, -0.686627f, 0.000000f}, {0.303296f, 0.312624f} },
    { {0.143755f, -0.123940f, 0.018574f}, {0.802440f, -0.596733f, 0.000000f}, {0.311028f, 0.312624f} },
    { {0.176702f, -0.066875f, 0.037149f}, {0.918006f, -0.396567f, 0.000000f}, {0.303296f, 0.296180f} },
    { {0.176702f, -0.066875f, 0.018574f}, {0.958142f, -0.286295f, 0.000000f}, {0.311028f, 0.296180f} },
    { {0.223882f, 0.000000f, 0.037149f}, {0.998277f, 0.058674f, 0.000000f}, {0.303296f, 0.276908f} },
    { {0.210381f, 0.076572f, 0.055723f}, {0.958142f, 0.286295f, -0.000000f}, {0.295564f, 0.254842f} },
    { {0.223882f, 0.000000f, 0.055723f}, {0.998277f, -0.058674f, 0.000000f}, {0.295564f, 0.276908f} },
    { {0.210381f, 0.076572f, 0.037149f}, {0.918006f, 0.396567f, -0.000000f}, {0.303296f, 0.254842f} },
    { {0.171504f, 0.143909f, 0.055723f}, {0.802440f, 0.596733f, -0.000000f}, {0.295564f, 0.235437f} },
    { {0.171504f, 0.143909f, 0.037149f}, {0.727009f, 0.686628f, -0.000000f}, {0.303296f, 0.235437f} },
    { {0.111941f, 0.193888f, 0.055723f}, {0.549952f, 0.835196f, -0.000000f}, {0.295564f, 0.221034f} },
    { {0.111941f, 0.193888f, 0.037149f}, {0.448325f, 0.893871f, 0.000000f}, {0.303296f, 0.221034f} },
    { {0.038876f, 0.220481f, 0.055723f}, {0.231132f, 0.972922f, 0.000000f}, {0.295564f, 0.213371f} },
    { {0.038876f, 0.220481f, 0.037149f}, {0.115566f, 0.993300f, 0.000000f}, {0.303296f, 0.213371f} },
    { {-0.038877f, 0.220481f, 0.055723f}, {-0.115566f, 0.993300f, 0.000000f}, {0.295564f, 0.213371f} },
    { {-0.038877f, 0.220481f, 0.037149f}, {-0.231132f, 0.972922f, 0.000000f}, {0.303296f, 0.213371f} },
    { {-0.111942f, 0.193888f, 0.055723f}, {-0.448325f, 0.893871f, 0.000000f}, {0.295564f, 0.221034f} },
    { {-0.111942f, 0.193888f, 0.037149f}, {-0.549952f, 0.835196f, -0.000000f}, {0.303296f, 0.221034f} },
    { {-0.171504f, 0.143909f, 0.055723f}, {-0.727010f, 0.686627f, -0.000000f}, {0.295564f, 0.235437f} },
    { {-0.171504f, 0.143909f, 0.037149f}, {-0.802440f, 0.596733f, -0.000001f}, {0.303296f, 0.235437f} },
    { {-0.210381f, 0.076572f, 0.055723f}, {-0.918006f, 0.396567f, -0.000001f}, {0.295564f, 0.254842f} },
    { {-0.210381f, 0.076572f, 0.037149f}, {-0.958142f, 0.286295f, -0.000001f}, {0.303296f, 0.254842f} },
    { {-0.223883f, 0.000000f, 0.055723f}, {-0.998277f, 0.058674f, -0.000000f}, {0.295564f, 0.276908f} },
    { {-0.223883f, 0.000000f, 0.037149f}, {-0.998277f, -0.058675f, -0.000000f}, {0.303296f, 0.276908f} },
    { {-0.210381f, -0.076572f, 0.055723f}, {-0.958141f, -0.286295f, 0.000000f}, {0.295564f, 0.298974f} },
    { {-0.210381f, -0.076572f, 0.037149f}, {-0.918006f, -0.396567f, 0.000000f}, {0.303296f, 0.298974f} },
    { {-0.171504f, -0.143909f, 0.055723f}, {-0.802440f, -0.596733f, 0.000000f}, {0.295564f, 0.318379f} },
    { {-0.171504f, -0.143909f, 0.037149f}, {-0.727009f, -0.686628f, 0.000000f}, {0.303296f, 0.318379f} },
    { {-0.111942f, -0.193888f, 0.055723f}, {-0.549952f, -0.835196f, 0.000000f}, {0.295564f, 0.332782f} },
    { {-0.111942f, -0.193888f, 0.037149f}, {-0.448325f, -0.893871f, 0.000000f}, {0.303296f, 0.332782f} },
    { {-0.038877f, -0.220481f, 0.055723f}, {-0.231132f, -0.972922f, 0.000000f}, {0.295564f, 0.340445f} },
    { {-0.038877f, -0.220481f, 0.037149f}, {-0.115566f, -0.993300f, 0.000000f}, {0.303296f, 0.340445f} },
    { {0.038877f, -0.220481f, 0.055723f}, {0.115566f, -0.993300f, 0.000000f}, {0.295564f, 0.340445f} },
    { {0.038877f, -0.220481f, 0.037149f}, {0.231132f, -0.972922f, 0.000000f}, {0.303296f, 0.340445f} },
    { {0.111941f, -0.193888f, 0.055723f}, {0.448325f, -0.893871f, 0.000000f}, {0.295564f, 0.332782f} },
    { {0.111941f, -0.193888f, 0.037149f}, {0.549952f, -0.835196f, 0.000000f}, {0.303296f, 0.332782f} },
    { {0.171504f, -0.143909f, 0.055723f}, {0.727010f, -0.686627f, 0.000000f}, {0.295564f, 0.318379f} },
    { {0.171504f, -0.143909f, 0.037149f}, {0.802440f, -0.596733f, 0.000000f}, {0.303296f, 0.318379f} },
    { {0.210381f, -0.076572f, 0.055723f}, {0.918006f, -0.396567f, 0.000000f}, {0.295564f, 0.298974f} },
    { {0.210381f, -0.076572f, 0.037149f}, {0.958142f, -0.286295f, 0.000000f}, {0.303296f, 0.298974f} },
    { {-0.000000f, 0.000000f, 0.055723f}, {-0.000000f, -0.000000f, 1.000000f}, {0.295564f, 0.276908f} },
    { {0.223882f, 0.000000f, 0.055723f}, {-0.000000f, -0.000000f, 1.000000f}, {0.295564f, 0.276908f} },
    { {0.210381f, 0.076572f, 0.055723f}, {-0.000000f, -0.000000f, 1.000000f}, {0.295564f, 0.254842f} },
    { {0.171504f, 0.143909f, 0.055723f}, {-0.000000f, -0.000000f, 1.000000f}, {0.295564f, 0.235437f} },
    { {0.111941f, 0.193888f, 0.055723f}, {-0.000000f, -0.000000f, 1.000000f}, {0.295564f, 0.221034f} },
    { {0.038876f, 0.220481f, 0.055723f}, {-0.000000f, -0.000000f, 1.000000f}, {0.295564f, 0.213371f} },
    { {-0.038877f, 0.220481f, 0.055723f}, {-0.000000f, -0.000000f, 1.000000f}, {0.295564f, 0.213371f} },
    { {-0.111942f, 0.193888f, 0.055723f}, {-0.000000f, -0.000000f, 1.000000f}, {0.295564f, 0.221034f} },
    { {-0.171504f, 0.143909f, 0.055723f}, {-0.000000f, -0.000000f, 1.000000f}, {0.295564f, 0.235437f} },
    { {-0.210381f, 0.076572f, 0.055723f}, {-0.000000f, -0.000000f, 1.000000f}, {0.295564f, 0.254842f} },
    { {-0.223883f, 0.000000f, 0.055723f}, {-0.000000f, -0.000000f, 1.000000f}, {0.295564f, 0.276908f} },
    { {-0.210381f, -0.076572f, 0.055723f}, {-0.000000f, -0.000000f, 1.000000f}, {0.295564f, 0.298974f} },
    { {-0.171504f, -0.143909f, 0.055723f}, {-0.000000f, -0.000000f, 1.000000f}, {0.295564f, 0.318379f} },
    { {-0.111942f, -0.193888f, 0.055723f}, {-0.000000f, -0.000000f, 1.000000f}, {0.295564f, 0.332782f} },
    { {-0.038877f, -0.220481f, 0.055723f}, {-0.000000f, -0.000000f, 1.000000f}, {0.295564f, 0.340445f} },
    { {0.038877f, -0.220481f, 0.055723f}, {-0.000000f, -0.000000f, 1.000000f}, {0.295564f, 0.340445f} },
    { {0.111941f, -0.193888f, 0.055723f}, {-0.000000f, -0.000000f, 1.000000f}, {0.295564f, 0.332782f} },
    { {0.171504f, -0.143909f, 0.055723f}, {-0.000000f, -0.000000f, 1.000000f}, {0.295564f, 0.318379f} },
    { {0.210381f, -0.076572f, 0.055723f}, {-0.000000f, -0.000000f, 1.000000f}, {0.295564f, 0.298974f} },
    { {0.223882f, 0.000000f, 0.018574f}, {-0.000000f, -0.000000f, 1.000000f}, {0.311028f, 0.276908f} },
    { {0.210381f, 0.076572f, 0.018574f}, {-0.000000f, -0.000000f, 1.000000f}, {0.311028f, 0.254842f} },
    { {0.176702f, 0.062908f, 0.018574f}, {-0.000000f, -0.000000f, 1.000000f}, {0.311028f, 0.258779f} },
    { {0.188144f, -0.001983f, 0.018574f}, {-0.000000f, -0.000000f, 1.000000f}, {0.311028f, 0.277480f} },
    { {0.171504f, 0.143909f, 0.018574f}, {-0.000000f, -0.000000f, 1.000000f}, {0.311028f, 0.235437f} },
    { {0.143755f, 0.119973f, 0.018574f}, {-0.000000f, -0.000000f, 1.000000f}, {0.311028f, 0.242335f} },
    { {0.111941f, 0.193888f, 0.018574f}, {-0.000000f, -0.000000f, 1.000000f}, {0.311028f, 0.221034f} },
    { {0.093278f, 0.162329f, 0.018574f}, {-0.000000f, -0.000000f, 1.000000f}, {0.311028f, 0.230129f} },
    { {0.038876f, 0.220481f, 0.018574f}, {-0.000000f, -0.000000f, 1.000000f}, {0.311028f, 0.213371f} },
    { {0.031359f, 0.184865f, 0.018574f}, {-0.000000f, -0.000000f, 1.000000f}, {0.311028f, 0.223634f} },
    { {-0.038877f, 0.220481f, 0.018574f}, {-0.000000f, -0.000000f, 1.000000f}, {0.311028f, 0.213371f} },
    { {-0.034534f, 0.184865f, 0.018574f}, {-0.000000f, -0.000000f, 1.000000f}, {0.311028f, 0.223634f} },
    { {-0.111942f, 0.193888f, 0.018574f}, {-0.000000f, -0.000000f, 1.000000f}, {0.311028f, 0.221034f} },
    { {-0.096453f, 0.162329f, 0.018574f}, {-0.000000f, -0.000000f, 1.000000f}, {0.311028f, 0.230129f} },
    { {-0.171504f, 0.143909f, 0.018574f}, {-0.000000f, -0.000000f, 1.000000f}, {0.311028f, 0.235437f} },
    { {-0.146930f, 0.119973f, 0.018574f}, {-0.000000f, -0.000000f, 1.000000f}, {0.311028f, 0.242335f} },
    { {-0.210381f, 0.076572f, 0.018574f}, {-0.000000f, -0.000000f, 1.000000f}, {0.311028f, 0.254842f} },
    { {-0.179876f, 0.062908f, 0.018574f}, {-0.000000f, -0.000000f, 1.000000f}, {0.311028f, 0.258779f} },
    { {-0.223883f, 0.000000f, 0.018574f}, {-0.000000f, -0.000000f, 1.000000f}, {0.311028f, 0.276908f} },
    { {-0.191318f, -0.001983f, 0.018574f}, {-0.000000f, -0.000000f, 1.000000f}, {0.311028f, 0.277480f} },
    { {-0.210381f, -0.076572f, 0.018574f}, {-0.000000f, -0.000000f, 1.000000f}, {0.311028f, 0.298974f} },
    { {-0.179876f, -0.066875f, 0.018574f}, {-0.000000f, -0.000000f, 1.000000f}, {0.311028f, 0.296180f} },
    { {-0.171504f, -0.143909f, 0.018574f}, {-0.000000f, -0.000000f, 1.000000f}, {0.311028f, 0.318379f} },
    { {-0.146930f, -0.123940f, 0.018574f}, {-0.000000f, -0.000000f, 1.000000f}, {0.311028f, 0.312625f} },
    { {-0.111942f, -0.193888f, 0.018574f}, {-0.000000f, -0.000000f, 1.000000f}, {0.311028f, 0.332782f} },
    { {-0.096453f, -0.166295f, 0.018574f}, {-0.000000f, -0.000000f, 1.000000f}, {0.311028f, 0.324830f} },
    { {-0.038877f, -0.220481f, 0.018574f}, {-0.000000f, -0.000000f, 1.000000f}, {0.311028f, 0.340445f} },
    { {-0.034533f, -0.188832f, 0.018574f}, {-0.000000f, -0.000000f, 1.000000f}, {0.311028f, 0.331325f} },
    { {0.038877f, -0.220481f, 0.018574f}, {-0.000000f, -0.000000f, 1.000000f}, {0.311028f, 0.340445f} },
    { {0.031359f, -0.188832f, 0.018574f}, {-0.000000f, -0.000000f, 1.000000f}, {0.311028f, 0.331325f} },
    { {0.111941f, -0.193888f, 0.018574f}, {-0.000000f, -0.000000f, 1.000000f}, {0.311028f, 0.332782f} },
    { {0.093279f, -0.166295f, 0.018574f}, {-0.000000f, -0.000000f, 1.000000f}, {0.311028f, 0.324830f} },
    { {0.171504f, -0.143909f, 0.018574f}, {-0.000000f, -0.000000f, 1.000000f}, {0.311028f, 0.318379f} },
    { {0.143755f, -0.123940f, 0.018574f}, {-0.000000f, -0.000000f, 1.000000f}, {0.311028f, 0.312624f} },
    { {0.210381f, -0.076572f, 0.018574f}, {-0.000000f, -0.000000f, 1.000000f}, {0.311028f, 0.298974f} },
    { {0.176702f, -0.066875f, 0.018574f}, {-0.000000f, -0.000000f, 1.000000f}, {0.311028f, 0.296180f} },
    { {0.210381f, 0.076572f, 0.037149f}, {0.000000f, 0.000000f, -1.000000f}, {0.303296f, 0.254842f} },
    { {0.223882f, 0.000000f, 0.037149f}, {0.000000f, 0.000000f, -1.000000f}, {0.303296f, 0.276908f} },
    { {0.188144f, -0.001983f, 0.037149f}, {0.000000f, 0.000000f, -1.000000f}, {0.303296f, 0.277480f} },
    { {0.176702f, 0.062908f, 0.037149f}, {0.000000f, 0.000000f, -1.000000f}, {0.303296f, 0.258779f} },
    { {0.171504f, 0.143909f, 0.037149f}, {0.000000f, 0.000000f, -1.000000f}, {0.303296f, 0.235437f} },
    { {0.143755f, 0.119973f, 0.037149f}, {0.000000f, 0.000000f, -1.000000f}, {0.303296f, 0.242335f} },
    { {0.111941f, 0.193888f, 0.037149f}, {0.000000f, 0.000000f, -1.000000f}, {0.303296f, 0.221034f} },
    { {0.093278f, 0.162329f, 0.037149f}, {0.000000f, 0.000000f, -1.000000f}, {0.303296f, 0.230129f} },
    { {0.038876f, 0.220481f, 0.037149f}, {0.000000f, 0.000000f, -1.000000f}, {0.303296f, 0.213371f} },
    { {0.031359f, 0.184865f, 0.037149f}, {0.000000f, 0.000000f, -1.000000f}, {0.303296f, 0.223634f} },
    { {-0.038877f, 0.220481f, 0.037149f}, {0.000000f, 0.000000f, -1.000000f}, {0.303296f, 0.213371f} },
    { {-0.034534f, 0.184865f, 0.037149f}, {0.000000f, 0.000000f, -1.000000f}, {0.303296f, 0.223634f} },
    { {-0.111942f, 0.193888f, 0.037149f}, {0.000000f, 0.000000f, -1.000000f}, {0.303296f, 0.221034f} },
    { {-0.096453f, 0.162329f, 0.037149f}, {0.000000f, 0.000000f, -1.000000f}, {0.303296f, 0.230129f} },
    { {-0.171504f, 0.143909f, 0.037149f}, {0.000000f, 0.000000f, -1.000000f}, {0.303296f, 0.235437f} },
    { {-0.146930f, 0.119973f, 0.037149f}, {0.000000f, 0.000000f, -1.000000f}, {0.303296f, 0.242335f} },
    { {-0.210381f, 0.076572f, 0.037149f}, {0.000000f, 0.000000f, -1.000000f}, {0.303296f, 0.254842f} },
    { {-0.179876f, 0.062908f, 0.037149f}, {0.000000f, 0.000000f, -1.000000f}, {0.303296f, 0.258779f} },
    { {-0.223883f, 0.000000f, 0.037149f}, {0.000000f, 0.000000f, -1.000000f}, {0.303296f, 0.276908f} },
    { {-0.191318f, -0.001983f, 0.037149f}, {0.000000f, 0.000000f, -1.000000f}, {0.303296f, 0.277480f} },
    { {-0.210381f, -0.076572f, 0.037149f}, {0.000000f, 0.000000f, -1.000000f}, {0.303296f, 0.298974f} },
    { {-0.179876f, -0.066875f, 0.037149f}, {0.000000f, 0.000000f, -1.000000f}, {0.303296f, 0.296180f} },
    { {-0.171504f, -0.143909f, 0.037149f}, {0.000000f, 0.000000f, -1.000000f}, {0.303296f, 0.318379f} },
    { {-0.146930f, -0.123940f, 0.037149f}, {0.000000f, 0.000000f, -1.000000f}, {0.303296f, 0.312625f} },
    { {-0.111942f, -0.193888f, 0.037149f}, {0.000000f, 0.000000f, -1.000000f}, {0.303296f, 0.332782f} },
    { {-0.096453f, -0.166295f, 0.037149f}, {0.000000f, 0.000000f, -1.000000f}, {0.303296f, 0.324830f} },
    { {-0.038877f, -0.220481f, 0.037149f}, {0.000000f, 0.000000f, -1.000000f}, {0.303296f, 0.340445f} },
    { {-0.034533f, -0.188832f, 0.037149f}, {0.000000f, 0.000000f, -1.000000f}, {0.303296f, 0.331325f} },
    { {0.038877f, -0.220481f, 0.037149f}, {0.000000f, 0.000000f, -1.000000f}, {0.303296f, 0.340445f} },
    { {0.031359f, -0.188832f, 0.037149f}, {0.000000f, 0.000000f, -1.000000f}, {0.303296f, 0.331325f} },
    { {0.111941f, -0.193888f, 0.037149f}, {0.000000f, 0.000000f, -1.000000f}, {0.303296f, 0.332782f} },
    { {0.093279f, -0.166295f, 0.037149f}, {0.000000f, 0.000000f, -1.000000f}, {0.303296f, 0.324830f} },
    { {0.171504f, -0.143909f, 0.037149f}, {0.000000f, 0.000000f, -1.000000f}, {0.303296f, 0.318379f} },
    { {0.143755f, -0.123940f, 0.037149f}, {0.000000f, 0.000000f, -1.000000f}, {0.303296f, 0.312624f} },
    { {0.210381f, -0.076572f, 0.037149f}, {0.000000f, 0.000000f, -1.000000f}, {0.303296f, 0.298974f} },
    { {0.176702f, -0.066875f, 0.037149f}, {0.000000f, 0.000000f, -1.000000f}, {0.303296f, 0.296180f} },
    { {0.045458f, 0.071719f, -0.073837f}, {0.776756f, 0.000000f, 0.629801f}, {0.349497f, 0.256241f} },
    { {0.085301f, 0.071718f, -0.122976f}, {0.931336f, 0.000000f, 0.364161f}, {0.369954f, 0.256241f} },
    { {0.085301f, 0.147919f, -0.122976f}, {0.856370f, 0.000000f, 0.516362f}, {0.369954f, 0.234282f} },
    { {0.045458f, 0.147919f, -0.073837f}, {0.776756f, 0.000000f, 0.629801f}, {0.349497f, 0.234282f} },
    { {0.093642f, 0.071718f, -0.170686f}, {0.983071f, 0.000000f, -0.183227f}, {0.389814f, 0.256241f} },
    { {0.093642f, 0.147919f, -0.170686f}, {0.999996f, 0.000000f, 0.002719f}, {0.389814f, 0.234282f} },
    { {0.077333f, 0.071718f, -0.211959f}, {0.766883f, 0.000000f, -0.641787f}, {0.406996f, 0.256241f} },
    { {0.077333f, 0.147919f, -0.211959f}, {0.858034f, 0.000000f, -0.513593f}, {0.406996f, 0.234282f} },
    { {0.041259f, 0.071718f, -0.244171f}, {0.370028f, 0.000000f, -0.929021f}, {0.420405f, 0.256241f} },
    { {0.041259f, 0.147919f, -0.244171f}, {0.527989f, 0.000000f, -0.849251f}, {0.420405f, 0.234282f} },
    { {-0.006398f, 0.071718f, -0.254231f}, {0.206539f, 0.000000f, -0.978438f}, {0.424593f, 0.256241f} },
    { {-0.006398f, 0.147919f, -0.254231f}, {0.206539f, 0.000000f, -0.978438f}, {0.424593f, 0.234282f} },
    { {-0.006398f, 0.071718f, -0.254231f}, {-0.328982f, 0.000000f, -0.944336f}, {0.424593f, 0.256241f} },
    { {-0.051493f, 0.071718f, -0.238521f}, {-0.666327f, 0.000000f, -0.745660f}, {0.418053f, 0.256241f} },
    { {-0.051493f, 0.147919f, -0.238521f}, {-0.603095f, 0.000000f, -0.797669f}, {0.418053f, 0.234282f} },
    { {-0.006398f, 0.147919f, -0.254231f}, {-0.328982f, -0.000000f, -0.944336f}, {0.424593f, 0.234282f} },
    { {-0.229459f, 0.071719f, -0.067196f}, {-0.746341f, 0.000000f, -0.665564f}, {0.346733f, 0.256241f} },
    { {-0.229459f, 0.147919f, -0.067196f}, {-0.708756f, 0.000000f, -0.705454f}, {0.346733f, 0.234282f} },
    { {-0.236548f, 0.071719f, -0.045127f}, {-0.988220f, -0.000000f, 0.153038f}, {0.337546f, 0.256241f} },
    { {-0.236548f, 0.147919f, -0.045127f}, {-0.996043f, 0.000000f, -0.088871f}, {0.337546f, 0.234282f} },
    { {-0.228130f, 0.071719f, -0.024697f}, {-0.725036f, -0.000000f, 0.688711f}, {0.329041f, 0.256241f} },
    { {-0.228130f, 0.147919f, -0.024697f}, {-0.832186f, -0.000000f, 0.554497f}, {0.329041f, 0.234282f} },
    { {-0.206235f, 0.071719f, -0.007431f}, {-0.298306f, -0.000000f, 0.954470f}, {0.321854f, 0.256241f} },
    { {-0.206235f, 0.147919f, -0.007431f}, {-0.427384f, -0.000000f, 0.904070f}, {0.321854f, 0.234282f} },
    { {-0.152431f, 0.071719f, 0.004173f}, {-0.016697f, -0.000000f, 0.999861f}, {0.317023f, 0.256241f} },
    { {-0.152431f, 0.147919f, 0.004173f}, {-0.055099f, -0.000000f, 0.998481f}, {0.317023f, 0.234282f} },
    { {0.157244f, 0.071719f, 0.003992f}, {0.000585f, -0.000000f, 1.000000f}, {0.317099f, 0.256241f} },
    { {0.157244f, 0.147919f, 0.003992f}, {0.000585f, -0.000000f, 1.000000f}, {0.317099f, 0.234282f} },
    { {0.157244f, 0.071719f, 0.003992f}, {0.571385f, 0.000000f, -0.820682f}, {0.317099f, 0.256241f} },
    { {0.045458f, 0.071719f, -0.073837f}, {0.571385f, 0.000000f, -0.820682f}, {0.349497f, 0.256241f} },
    { {0.045458f, 0.147919f, -0.073837f}, {0.571385f, 0.000000f, -0.820682f}, {0.349497f, 0.234282f} },
    { {0.157244f, 0.147919f, 0.003992f}, {0.571385f, 0.000000f, -0.820682f}, {0.317099f, 0.234282f} },
    { {-0.152431f, 0.071719f, 0.004173f}, {-0.000000f, -1.000000f, 0.000000f}, {0.317023f, 0.256241f} },
    { {0.045458f, 0.071719f, -0.073837f}, {-0.000000f, -1.000000f, 0.000000f}, {0.349497f, 0.256241f} },
    { {0.157244f, 0.071719f, 0.003992f}, {-0.000000f, -1.000000f, 0.000000f}, {0.317099f, 0.256241f} },
    { {-0.229459f, 0.071719f, -0.067196f}, {-0.000000f, -1.000000f, 0.000000f}, {0.346733f, 0.256241f} },
    { {-0.228130f, 0.071719f, -0.024697f}, {0.000000f, -1.000000f, 0.000000f}, {0.329041f, 0.256241f} },
    { {-0.236548f, 0.071719f, -0.045127f}, {0.000000f, -1.000000f, 0.000000f}, {0.337546f, 0.256241f} },
    { {-0.206235f, 0.071719f, -0.007431f}, {-0.000000f, -1.000000f, 0.000000f}, {0.321854f, 0.256241f} },
    { {-0.051493f, 0.071718f, -0.238521f}, {-0.000000f, -1.000000f, 0.000000f}, {0.418053f, 0.256241f} },
    { {0.085301f, 0.071718f, -0.122976f}, {-0.000000f, -1.000000f, 0.000000f}, {0.369954f, 0.256241f} },
    { {-0.006398f, 0.071718f, -0.254231f}, {-0.000000f, -1.000000f, 0.000000f}, {0.424593f, 0.256241f} },
    { {0.041259f, 0.071718f, -0.244171f}, {-0.000000f, -1.000000f, 0.000000f}, {0.420405f, 0.256241f} },
    { {0.077333f, 0.071718f, -0.211959f}, {-0.000000f, -1.000000f, 0.000000f}, {0.406996f, 0.256241f} },
    { {0.093642f, 0.071718f, -0.170686f}, {-0.000000f, -1.000000f, 0.000000f}, {0.389814f, 0.256241f} },
    { {-0.152431f, 0.147919f, 0.004173f}, {0.000000f, 1.000000f, -0.000000f}, {0.317023f, 0.234282f} },
    { {0.157244f, 0.147919f, 0.003992f}, {0.000000f, 1.000000f, -0.000000f}, {0.317099f, 0.234282f} },
    { {0.045458f, 0.147919f, -0.073837f}, {0.000000f, 1.000000f, -0.000000f}, {0.349497f, 0.234282f} },
    { {-0.229459f, 0.147919f, -0.067196f}, {0.000000f, 1.000000f, -0.000000f}, {0.346733f, 0.234282f} },
    { {-0.236548f, 0.147919f, -0.045127f}, {0.000000f, 1.000000f, 0.000000f}, {0.337546f, 0.234282f} },
    { {-0.228130f, 0.147919f, -0.024697f}, {0.000000f, 1.000000f, 0.000000f}, {0.329041f, 0.234282f} },
    { {-0.206235f, 0.147919f, -0.007431f}, {0.000000f, 1.000000f, -0.000000f}, {0.321854f, 0.234282f} },
    { {-0.051493f, 0.147919f, -0.238521f}, {0.000000f, 1.000000f, -0.000000f}, {0.418053f, 0.234282f} },
    { {0.085301f, 0.147919f, -0.122976f}, {0.000000f, 1.000000f, -0.000000f}, {0.369954f, 0.234282f} },
    { {-0.006398f, 0.147919f, -0.254231f}, {0.000000f, 1.000000f, -0.000000f}, {0.424593f, 0.234282f} },
    { {0.041259f, 0.147919f, -0.244171f}, {0.000000f, 1.000000f, -0.000000f}, {0.420405f, 0.234282f} },
    { {0.077333f, 0.147919f, -0.211959f}, {0.000000f, 1.000000f, -0.000000f}, {0.406996f, 0.234282f} },
    { {0.093642f, 0.147919f, -0.170686f}, {0.000000f, 1.000000f, -0.000000f}, {0.389814f, 0.234282f} },
    { {0.045458f, -0.135976f, -0.073837f}, {0.776756f, -0.000000f, 0.629801f}, {0.349497f, 0.316093f} },
    { {0.085301f, -0.135976f, -0.122976f}, {0.931336f, 0.000000f, 0.364161f}, {0.369954f, 0.316093f} },
    { {0.085301f, -0.059776f, -0.122976f}, {0.856370f, 0.000000f, 0.516362f}, {0.369954f, 0.294134f} },
    { {0.045458f, -0.059776f, -0.073837f}, {0.776756f, 0.000000f, 0.629801f}, {0.349497f, 0.294134f} },
    { {0.093642f, -0.135976f, -0.170686f}, {0.983071f, 0.000000f, -0.183227f}, {0.389814f, 0.316093f} },
    { {0.093642f, -0.059776f, -0.170686f}, {0.999996f, 0.000000f, 0.002719f}, {0.389814f, 0.294134f} },
    { {0.077333f, -0.135976f, -0.211959f}, {0.766882f, 0.000000f, -0.641788f}, {0.406996f, 0.316093f} },
    { {0.077333f, -0.059776f, -0.211959f}, {0.858034f, 0.000000f, -0.513594f}, {0.406996f, 0.294134f} },
    { {0.041259f, -0.135976f, -0.244171f}, {0.370029f, 0.000000f, -0.929020f}, {0.420405f, 0.316093f} },
    { {0.041259f, -0.059776f, -0.244171f}, {0.527989f, 0.000000f, -0.849251f}, {0.420405f, 0.294134f} },
    { {-0.006398f, -0.135976f, -0.254231f}, {0.206539f, 0.000000f, -0.978438f}, {0.424593f, 0.316093f} },
    { {-0.006398f, -0.059776f, -0.254231f}, {0.206539f, 0.000000f, -0.978438f}, {0.424593f, 0.294134f} },
    { {-0.006398f, -0.135976f, -0.254231f}, {-0.328982f, -0.000000f, -0.944336f}, {0.424593f, 0.316093f} },
    { {-0.051493f, -0.135976f, -0.238521f}, {-0.666327f, -0.000000f, -0.745660f}, {0.418053f, 0.316093f} },
    { {-0.051493f, -0.059776f, -0.238521f}, {-0.603095f, -0.000000f, -0.797669f}, {0.418053f, 0.294134f} },
    { {-0.006398f, -0.059776f, -0.254231f}, {-0.328982f, -0.000000f, -0.944336f}, {0.424593f, 0.294134f} },
    { {-0.229459f, -0.135976f, -0.067196f}, {-0.746340f, 0.000000f, -0.665564f}, {0.346733f, 0.316093f} },
    { {-0.229459f, -0.059776f, -0.067196f}, {-0.708756f, -0.000000f, -0.705454f}, {0.346733f, 0.294134f} },
    { {-0.236548f, -0.135976f, -0.045127f}, {-0.988220f, -0.000000f, 0.153038f}, {0.337546f, 0.316093f} },
    { {-0.236548f, -0.059776f, -0.045127f}, {-0.996043f, 0.000000f, -0.088872f}, {0.337546f, 0.294134f} },
    { {-0.228130f, -0.135976f, -0.024697f}, {-0.725036f, -0.000000f, 0.688711f}, {0.329041f, 0.316093f} },
    { {-0.228130f, -0.059776f, -0.024697f}, {-0.832186f, -0.000000f, 0.554497f}, {0.329041f, 0.294134f} },
    { {-0.206235f, -0.135976f, -0.007431f}, {-0.298306f, -0.000000f, 0.954470f}, {0.321854f, 0.316093f} },
    { {-0.206235f, -0.059776f, -0.007431f}, {-0.427384f, -0.000000f, 0.904070f}, {0.321854f, 0.294134f} },
    { {-0.152431f, -0.135976f, 0.004173f}, {-0.016697f, -0.000000f, 0.999861f}, {0.317023f, 0.316093f} },
    { {-0.152431f, -0.059776f, 0.004173f}, {-0.055099f, -0.000000f, 0.998481f}, {0.317023f, 0.294134f} },
    { {0.157244f, -0.135976f, 0.003992f}, {0.000585f, -0.000000f, 1.000000f}, {0.317099f, 0.316093f} },
    { {0.157244f, -0.059776f, 0.003992f}, {0.000585f, -0.000000f, 1.000000f}, {0.317099f, 0.294134f} },
    { {0.157244f, -0.135976f, 0.003992f}, {0.571385f, 0.000000f, -0.820682f}, {0.317099f, 0.316093f} },
    { {0.045458f, -0.135976f, -0.073837f}, {0.571385f, 0.000000f, -0.820682f}, {0.349497f, 0.316093f} },
    { {0.045458f, -0.059776f, -0.073837f}, {0.571385f, 0.000000f, -0.820682f}, {0.349497f, 0.294134f} },
    { {0.157244f, -0.059776f, 0.003992f}, {0.571385f, 0.000000f, -0.820682f}, {0.317099f, 0.294134f} },
    { {-0.152431f, -0.135976f, 0.004173f}, {-0.000000f, -1.000000f, 0.000000f}, {0.317023f, 0.316093f} },
    { {0.045458f, -0.135976f, -0.073837f}, {-0.000000f, -1.000000f, 0.000000f}, {0.349497f, 0.316093f} },
    { {0.157244f, -0.135976f, 0.003992f}, {-0.000000f, -1.000000f, -0.000000f}, {0.317099f, 0.316093f} },
    { {-0.229459f, -0.135976f, -0.067196f}, {0.000000f, -1.000000f, 0.000000f}, {0.346733f, 0.316093f} },
    { {-0.228130f, -0.135976f, -0.024697f}, {-0.000000f, -1.000000f, 0.000000f}, {0.329041f, 0.316093f} },
    { {-0.236548f, -0.135976f, -0.045127f}, {-0.000001f, -1.000000f, 0.000000f}, {0.337546f, 0.316093f} },
    { {-0.206235f, -0.135976f, -0.007431f}, {-0.000000f, -1.000000f, 0.000000f}, {0.321854f, 0.316093f} },
    { {-0.051493f, -0.135976f, -0.238521f}, {-0.000000f, -1.000000f, 0.000000f}, {0.418053f, 0.316093f} },
    { {0.085301f, -0.135976f, -0.122976f}, {-0.000000f, -1.000000f, 0.000000f}, {0.369954f, 0.316093f} },
    { {-0.006398f, -0.135976f, -0.254231f}, {0.000000f, -1.000000f, 0.000000f}, {0.424593f, 0.316093f} },
    { {0.041259f, -0.135976f, -0.244171f}, {0.000000f, -1.000000f, 0.000000f}, {0.420405f, 0.316093f} },
    { {0.077333f, -0.135976f, -0.211959f}, {0.000000f, -1.000000f, 0.000000f}, {0.406996f, 0.316093f} },
    { {0.093642f, -0.135976f, -0.170686f}, {0.000000f, -1.000000f, 0.000000f}, {0.389814f, 0.316093f} },
    { {-0.152431f, -0.059776f, 0.004173f}, {0.000000f, 1.000000f, -0.000000f}, {0.317023f, 0.294134f} },
    { {0.157244f, -0.059776f, 0.003992f}, {0.000000f, 1.000000f, -0.000000f}, {0.317099f, 0.294134f} },
    { {0.045458f, -0.059776f, -0.073837f}, {0.000000f, 1.000000f, -0.000000f}, {0.349497f, 0.294134f} },
    { {-0.229459f, -0.059776f, -0.067196f}, {0.000000f, 1.000000f, -0.000000f}, {0.346733f, 0.294134f} },
    { {-0.236548f, -0.059776f, -0.045127f}, {0.000000f, 1.000000f, -0.000000f}, {0.337546f, 0.294134f} },
    { {-0.228130f, -0.059776f, -0.024697f}, {0.000000f, 1.000000f, -0.000000f}, {0.329041f, 0.294134f} },
    { {-0.206235f, -0.059776f, -0.007431f}, {0.000000f, 1.000000f, -0.000000f}, {0.321854f, 0.294134f} },
    { {-0.051493f, -0.059776f, -0.238521f}, {0.000000f, 1.000000f, -0.000000f}, {0.418053f, 0.294134f} },
    { {0.085301f, -0.059776f, -0.122976f}, {0.000000f, 1.000000f, -0.000000f}, {0.369954f, 0.294134f} },
    { {-0.006398f, -0.059776f, -0.254231f}, {0.000000f, 1.000000f, -0.000000f}, {0.424593f, 0.294134f} },
    { {0.041259f, -0.059776f, -0.244171f}, {0.000000f, 1.000000f, -0.000000f}, {0.420405f, 0.294134f} },
    { {0.077333f, -0.059776f, -0.211959f}, {0.000000f, 1.000000f, -0.000000f}, {0.406996f, 0.294134f} },
    { {0.093642f, -0.059776f, -0.170686f}, {0.000000f, 1.000000f, -0.000000f}, {0.389814f, 0.294134f} },
};

WORD g_tind18[] = 
{
    0, 1, 2,    0, 3, 1,    0, 4, 3,    0, 5, 4,    0, 6, 5,
    0, 7, 6,    0, 8, 7,    0, 9, 8,    0, 10, 9,    0, 11, 10,
    0, 12, 11,    0, 13, 12,    0, 14, 13,    0, 15, 14,    0, 16, 15,
    0, 17, 16,    0, 18, 17,    0, 2, 18,    19, 20, 21,    19, 22, 20,
    22, 23, 20,    22, 24, 23,    24, 25, 23,    24, 26, 25,    26, 27, 25,
    26, 28, 27,    28, 29, 27,    28, 30, 29,    30, 31, 29,    30, 32, 31,
    32, 33, 31,    32, 34, 33,    34, 35, 33,    34, 36, 35,    36, 37, 35,
    36, 38, 37,    38, 39, 37,    38, 40, 39,    40, 41, 39,    40, 42, 41,
    42, 43, 41,    42, 44, 43,    44, 45, 43,    44, 46, 45,    46, 47, 45,
    46, 48, 47,    48, 49, 47,    48, 50, 49,    50, 51, 49,    50, 52, 51,
    52, 53, 51,    52, 54, 53,    54, 21, 53,    54, 19, 21,    55, 56, 57,
    55, 58, 56,    58, 59, 56,    58, 60, 59,    60, 61, 59,    60, 62, 61,
    62, 63, 61,    62, 64, 63,    64, 65, 63,    64, 66, 65,    66, 67, 65,
    66, 68, 67,    68, 69, 67,    68, 70, 69,    70, 71, 69,    70, 72, 71,
    72, 73, 71,    72, 74, 73,    74, 75, 73,    74, 76, 75,    76, 77, 75,
    76, 78, 77,    78, 79, 77,    78, 80, 79,    80, 81, 79,    80, 82, 81,
    82, 83, 81,    82, 84, 83,    84, 85, 83,    84, 86, 85,    86, 87, 85,
    86, 88, 87,    88, 89, 87,    88, 90, 89,    90, 57, 89,    90, 55, 57,
    91, 92, 93,    91, 94, 92,    94, 95, 92,    94, 96, 95,    96, 97, 95,
    96, 98, 97,    98, 99, 97,    98, 100, 99,    100, 101, 99,    100, 102, 101,
    102, 103, 101,    102, 104, 103,    104, 105, 103,    104, 106, 105,    106, 107, 105,
    106, 108, 107,    108, 109, 107,    108, 110, 109,    110, 111, 109,    110, 112, 111,
    112, 113, 111,    112, 114, 113,    114, 115, 113,    114, 116, 115,    116, 117, 115,
    116, 118, 117,    118, 119, 117,    118, 120, 119,    120, 121, 119,    120, 122, 121,
    122, 123, 121,    122, 124, 123,    124, 125, 123,    124, 126, 125,    126, 93, 125,
    126, 91, 93,    127, 128, 129,    127, 129, 130,    127, 130, 131,    127, 131, 132,
    127, 132, 133,    127, 133, 134,    127, 134, 135,    127, 135, 136,    127, 136, 137,
    127, 137, 138,    127, 138, 139,    127, 139, 140,    127, 140, 141,    127, 141, 142,
    127, 142, 143,    127, 143, 144,    127, 144, 145,    127, 145, 128,    146, 147, 148,
    148, 149, 146,    147, 150, 151,    151, 148, 147,    150, 152, 153,    153, 151, 150,
    152, 154, 155,    155, 153, 152,    154, 156, 157,    157, 155, 154,    156, 158, 159,
    159, 157, 156,    158, 160, 161,    161, 159, 158,    160, 162, 163,    163, 161, 160,
    162, 164, 165,    165, 163, 162,    164, 166, 167,    167, 165, 164,    166, 168, 169,
    169, 167, 166,    168, 170, 171,    171, 169, 168,    170, 172, 173,    173, 171, 170,
    172, 174, 175,    175, 173, 172,    174, 176, 177,    177, 175, 174,    176, 178, 179,
    179, 177, 176,    178, 180, 181,    181, 179, 178,    180, 146, 149,    149, 181, 180,
    182, 183, 184,    184, 185, 182,    186, 182, 185,    185, 187, 186,    188, 186, 187,
    187, 189, 188,    190, 188, 189,    189, 191, 190,    192, 190, 191,    191, 193, 192,
    194, 192, 193,    193, 195, 194,    196, 194, 195,    195, 197, 196,    198, 196, 197,
    197, 199, 198,    200, 198, 199,    199, 201, 200,    202, 200, 201,    201, 203, 202,
    204, 202, 203,    203, 205, 204,    206, 204, 205,    205, 207, 206,    208, 206, 207,
    207, 209, 208,    210, 208, 209,    209, 211, 210,    212, 210, 211,    211, 213, 212,
    214, 212, 213,    213, 215, 214,    216, 214, 215,    215, 217, 216,    183, 216, 217,
    217, 184, 183,    218, 219, 220,    218, 220, 221,    219, 222, 223,    219, 223, 220,
    222, 224, 225,    222, 225, 223,    224, 226, 227,    224, 227, 225,    226, 228, 229,
    226, 229, 227,    230, 231, 232,    230, 232, 233,    231, 234, 235,    231, 235, 232,
    234, 236, 237,    234, 237, 235,    236, 238, 239,    236, 239, 237,    238, 240, 241,
    238, 241, 239,    240, 242, 243,    240, 243, 241,    242, 244, 245,    242, 245, 243,
    246, 247, 248,    246, 248, 249,    250, 251, 252,    253, 254, 255,    253, 256, 254,
    257, 256, 253,    257, 250, 256,    257, 251, 250,    257, 258, 251,    259, 258, 257,
    260, 258, 259,    261, 258, 260,    261, 262, 258,    263, 264, 265,    266, 267, 268,
    266, 268, 269,    270, 266, 269,    270, 269, 263,    270, 263, 265,    270, 265, 271,
    272, 270, 271,    273, 272, 271,    274, 273, 271,    274, 271, 275,    276, 277, 278,
    276, 278, 279,    277, 280, 281,    277, 281, 278,    280, 282, 283,    280, 283, 281,
    282, 284, 285,    282, 285, 283,    284, 286, 287,    284, 287, 285,    288, 289, 290,
    288, 290, 291,    289, 292, 293,    289, 293, 290,    292, 294, 295,    292, 295, 293,
    294, 296, 297,    294, 297, 295,    296, 298, 299,    296, 299, 297,    298, 300, 301,
    298, 301, 299,    300, 302, 303,    300, 303, 301,    304, 305, 306,    304, 306, 307,
    308, 309, 310,    311, 312, 313,    311, 314, 312,    315, 314, 311,    315, 308, 314,
    315, 309, 308,    315, 316, 309,    317, 316, 315,    318, 316, 317,    319, 316, 318,
    319, 320, 316,    321, 322, 323,    324, 325, 326,    324, 326, 327,    328, 324, 327,
    328, 327, 321,    328, 321, 323,    328, 323, 329,    330, 328, 329,    331, 330, 329,
    332, 331, 329,    332, 329, 333,
};

D3DMATRIX g_tmat19 = 
{
    -0.215924f, 0.968738f, -0.122163f, 0.000000f, 
    0.350036f, -0.039999f, -0.935882f, 0.000000f, 
    -0.911511f, -0.244841f, -0.330456f, 0.000000f, 
    2.204261f, -2.470912f, 3.509590f, 1.000000f, 
};

// Mesh #19 Tris:552 Verts:570
MODELVERT g_tmesh19[] = 
{
    { {0.098451f, -0.136057f, -0.043819f}, {0.986652f, -0.125604f, 0.103637f}, {0.376461f, 0.244750f} },
    { {0.106635f, -0.061406f, -0.101291f}, {0.998385f, 0.016473f, 0.054375f}, {0.358973f, 0.262149f} },
    { {0.109781f, -0.185866f, -0.231589f}, {0.979384f, -0.188921f, 0.071521f}, {0.387960f, 0.302126f} },
    { {-0.078408f, -0.061265f, -0.273425f}, {-0.145135f, -0.254878f, 0.956019f}, {0.358811f, 0.314664f} },
    { {0.034123f, -0.120314f, -0.265627f}, {-0.120821f, -0.044345f, 0.991683f}, {0.372616f, 0.312392f} },
    { {-0.085109f, -0.158264f, -0.282015f}, {-0.134602f, -0.005008f, 0.990887f}, {0.381472f, 0.317460f} },
    { {-0.375636f, -0.160382f, 0.012754f}, {-0.049482f, -0.596739f, 0.800908f}, {0.382188f, 0.227535f} },
    { {-0.293387f, -0.077800f, 0.050854f}, {0.167286f, -0.237595f, 0.956851f}, {0.362918f, 0.215762f} },
    { {-0.287264f, -0.152150f, 0.009789f}, {0.379506f, -0.537464f, 0.753066f}, {0.380262f, 0.228425f} },
    { {-0.266527f, -0.155661f, -0.022361f}, {0.995031f, -0.066832f, 0.073808f}, {0.381059f, 0.238239f} },
    { {-0.264948f, 0.100374f, 0.001524f}, {0.989306f, 0.021115f, 0.144316f}, {0.321244f, 0.230489f} },
    { {-0.265819f, 0.004954f, -0.079340f}, {0.999907f, 0.001575f, -0.013509f}, {0.343482f, 0.255332f} },
    { {-0.068470f, -0.029841f, -0.027189f}, {-0.478099f, 0.096129f, 0.873029f}, {0.351652f, 0.239485f} },
    { {-0.015176f, 0.031654f, -0.010102f}, {-0.413144f, 0.090085f, 0.906199f}, {0.337295f, 0.234160f} },
    { {-0.042156f, -0.139436f, -0.032680f}, {-0.255181f, -0.142854f, 0.956282f}, {0.377259f, 0.241358f} },
    { {-0.003662f, -0.040742f, -0.351906f}, {0.205019f, 0.201448f, -0.957803f}, {0.353956f, 0.338570f} },
    { {0.063837f, -0.175125f, -0.340015f}, {0.278735f, -0.072180f, -0.957652f}, {0.385369f, 0.335185f} },
    { {0.088651f, -0.069994f, -0.329801f}, {0.459642f, 0.155343f, -0.874413f}, {0.360809f, 0.331879f} },
    { {-0.466169f, 0.093324f, -0.234657f}, {-0.078429f, 0.060123f, 0.995105f}, {0.322715f, 0.302556f} },
    { {-0.394551f, 0.180835f, -0.235163f}, {-0.056787f, 0.065613f, 0.996228f}, {0.302264f, 0.302553f} },
    { {-0.398571f, 0.038197f, -0.225998f}, {-0.041714f, 0.065084f, 0.997008f}, {0.335604f, 0.300015f} },
    { {-0.265566f, -0.231907f, -0.206699f}, {0.999755f, -0.009784f, -0.019860f}, {0.398738f, 0.294616f} },
    { {-0.265819f, -0.006309f, -0.234307f}, {0.999992f, -0.003027f, -0.002480f}, {0.345998f, 0.302630f} },
    { {-0.265705f, 0.084944f, -0.299629f}, {0.987567f, 0.004524f, -0.157132f}, {0.324624f, 0.322393f} },
    { {-0.508418f, -0.008313f, -0.279928f}, {-0.937702f, 0.047946f, -0.344116f}, {0.346432f, 0.316552f} },
    { {-0.481888f, -0.015222f, -0.331571f}, {-0.598906f, -0.029651f, -0.800270f}, {0.348008f, 0.332320f} },
    { {-0.460771f, 0.095901f, -0.301764f}, {-0.842378f, 0.471790f, -0.260411f}, {0.322062f, 0.323025f} },
    { {-0.267602f, -0.260976f, -0.245273f}, {0.989492f, -0.139614f, -0.037584f}, {0.405502f, 0.306437f} },
    { {-0.460082f, -0.153439f, -0.051726f}, {-0.735743f, -0.626815f, 0.256485f}, {0.380517f, 0.247194f} },
    { {-0.461268f, -0.186641f, -0.143003f}, {-0.795077f, -0.566581f, 0.216423f}, {0.388208f, 0.275101f} },
    { {-0.503247f, -0.107725f, -0.143493f}, {-0.947928f, -0.311241f, 0.067537f}, {0.369766f, 0.275108f} },
    { {-0.466172f, 0.099780f, -0.071887f}, {-0.857710f, 0.513809f, 0.018242f}, {0.321328f, 0.252887f} },
    { {-0.394551f, 0.180390f, -0.075837f}, {-0.674202f, 0.738404f, 0.014533f}, {0.302488f, 0.253946f} },
    { {-0.466198f, 0.098677f, 0.001576f}, {-0.796501f, 0.561495f, 0.224298f}, {0.321641f, 0.230476f} },
    { {0.018340f, 0.149173f, -0.215773f}, {0.844139f, 0.519242f, -0.133480f}, {0.309678f, 0.296694f} },
    { {0.067313f, 0.017694f, -0.226685f}, {0.942317f, 0.333584f, -0.027566f}, {0.340394f, 0.300261f} },
    { {0.034929f, 0.109510f, -0.080080f}, {0.922256f, 0.354829f, 0.153428f}, {0.319048f, 0.255368f} },
    { {0.016614f, 0.131486f, -0.083174f}, {-0.187666f, -0.095103f, -0.977618f}, {0.313910f, 0.256273f} },
    { {-0.065819f, 0.190063f, -0.073049f}, {-0.164364f, -0.081415f, -0.983034f}, {0.300229f, 0.253077f} },
    { {0.026983f, 0.031146f, -0.075404f}, {-0.150448f, -0.153566f, -0.976618f}, {0.337364f, 0.254084f} },
    { {0.058353f, 0.034774f, -0.068037f}, {0.930473f, 0.320292f, 0.177855f}, {0.336522f, 0.251830f} },
    { {0.111272f, -0.074991f, -0.255642f}, {0.986946f, 0.161007f, -0.003771f}, {0.362032f, 0.309263f} },
    { {-0.394551f, 0.180390f, -0.075837f}, {-0.044723f, 0.057669f, -0.997334f}, {0.302488f, 0.253946f} },
    { {-0.466172f, 0.099780f, -0.071887f}, {-0.066973f, 0.087802f, -0.993884f}, {0.321328f, 0.252887f} },
    { {-0.353906f, 0.040175f, -0.086673f}, {-0.070071f, 0.230127f, -0.970635f}, {0.335246f, 0.257505f} },
    { {-0.463499f, -0.217795f, -0.225711f}, {-0.884043f, -0.463532f, 0.060057f}, {0.395426f, 0.300391f} },
    { {-0.503388f, -0.108346f, -0.153927f}, {-0.970075f, -0.236892f, 0.053266f}, {0.369903f, 0.278292f} },
    { {-0.460814f, -0.189355f, -0.153423f}, {-0.768909f, -0.571047f, 0.287549f}, {0.388834f, 0.278285f} },
    { {-0.029480f, -0.278674f, -0.202949f}, {-0.437196f, 0.758577f, -0.483137f}, {0.409670f, 0.293556f} },
    { {0.018241f, -0.278279f, -0.245512f}, {-0.437196f, 0.758577f, -0.483137f}, {0.409545f, 0.306541f} },
    { {-0.025859f, -0.211945f, -0.101455f}, {-0.437196f, 0.758577f, -0.483137f}, {0.394152f, 0.262471f} },
    { {-0.075465f, -0.012042f, -0.047920f}, {-0.087525f, -0.152837f, -0.984368f}, {0.347478f, 0.245777f} },
    { {-0.084373f, -0.128707f, -0.046282f}, {-0.081313f, 0.113652f, -0.990188f}, {0.374742f, 0.245488f} },
    { {0.031995f, -0.026682f, -0.054915f}, {-0.085552f, -0.068712f, -0.993962f}, {0.350893f, 0.247938f} },
    { {-0.415182f, -0.016909f, -0.350689f}, {-0.037780f, -0.003966f, -0.999278f}, {0.348388f, 0.338155f} },
    { {-0.292306f, -0.016875f, -0.348616f}, {0.430625f, -0.012769f, -0.902441f}, {0.348381f, 0.337523f} },
    { {-0.281371f, 0.134797f, -0.325289f}, {0.186283f, 0.191479f, -0.963657f}, {0.312955f, 0.330132f} },
    { {-0.316404f, -0.307071f, -0.238817f}, {0.130683f, -0.894811f, 0.426890f}, {0.416279f, 0.304551f} },
    { {-0.368188f, -0.308278f, -0.241071f}, {-0.223476f, -0.930119f, 0.291442f}, {0.416559f, 0.305240f} },
    { {-0.367687f, -0.250778f, -0.153041f}, {-0.192852f, -0.826982f, 0.528118f}, {0.403188f, 0.278280f} },
    { {-0.015663f, -0.067504f, -0.357895f}, {-0.060231f, 0.034515f, -0.997588f}, {0.360206f, 0.340445f} },
    { {-0.022935f, -0.208017f, -0.356529f}, {-0.245962f, -0.098578f, -0.964254f}, {0.393043f, 0.340283f} },
    { {-0.029480f, -0.278674f, -0.202949f}, {-0.056295f, -0.836813f, 0.544586f}, {0.409670f, 0.293556f} },
    { {0.059130f, -0.179923f, -0.032660f}, {0.133715f, -0.754079f, 0.643028f}, {0.386720f, 0.241426f} },
    { {0.050682f, -0.321622f, -0.271316f}, {0.418095f, -0.790789f, 0.447046f}, {0.419655f, 0.314492f} },
    { {-0.501064f, 0.014441f, -0.211032f}, {-0.142345f, -0.034906f, -0.989201f}, {0.341166f, 0.295492f} },
    { {-0.433225f, 0.089339f, -0.217049f}, {-0.149218f, 0.070242f, -0.986306f}, {0.323659f, 0.297192f} },
    { {-0.449289f, 0.153177f, -0.210426f}, {-0.152985f, 0.136722f, -0.978725f}, {0.308746f, 0.295056f} },
    { {-0.499858f, 0.147124f, -0.128174f}, {-0.677998f, 0.678547f, 0.282655f}, {0.310222f, 0.269973f} },
    { {-0.409464f, 0.208424f, -0.127907f}, {-0.364901f, 0.905011f, 0.218637f}, {0.295897f, 0.269780f} },
    { {-0.453814f, 0.157152f, -0.102133f}, {-0.466432f, 0.566091f, 0.679693f}, {0.307898f, 0.262010f} },
    { {-0.265566f, -0.171411f, -0.076801f}, {0.149333f, 0.120966f, -0.981360f}, {0.384698f, 0.254877f} },
    { {-0.266470f, -0.092485f, -0.067209f}, {0.149333f, 0.120966f, -0.981360f}, {0.366261f, 0.251808f} },
    { {-0.377092f, -0.094560f, -0.084299f}, {0.149333f, 0.120966f, -0.981360f}, {0.366734f, 0.257025f} },
    { {-0.065303f, -0.043155f, -0.295137f}, {-0.777622f, 0.170786f, -0.605092f}, {0.354563f, 0.321255f} },
    { {-0.078408f, -0.061265f, -0.273425f}, {-0.921315f, 0.128934f, -0.366816f}, {0.358811f, 0.314664f} },
    { {-0.085109f, -0.158264f, -0.282015f}, {-0.787915f, 0.065779f, -0.612260f}, {0.381472f, 0.317460f} },
    { {-0.016585f, 0.160288f, -0.256573f}, {0.505962f, 0.434053f, -0.745386f}, {0.307050f, 0.309121f} },
    { {0.008784f, 0.018453f, -0.313848f}, {0.769350f, 0.352695f, -0.532641f}, {0.340152f, 0.326852f} },
    { {0.057942f, 0.023749f, -0.230718f}, {0.777152f, 0.329432f, -0.536199f}, {0.338977f, 0.301481f} },
    { {-0.519504f, 0.109802f, -0.180218f}, {-0.763632f, 0.440777f, -0.471786f}, {0.318905f, 0.285918f} },
    { {-0.519504f, 0.109528f, -0.117421f}, {-0.809522f, 0.399983f, 0.429753f}, {0.319016f, 0.266761f} },
    { {-0.409373f, -0.154060f, -0.144414f}, {-0.008811f, 0.001759f, -0.999960f}, {0.380593f, 0.275473f} },
    { {-0.450766f, -0.085272f, -0.143928f}, {-0.008811f, 0.001759f, -0.999960f}, {0.364518f, 0.275200f} },
    { {-0.503557f, -0.106593f, -0.143500f}, {-0.008811f, 0.001759f, -0.999960f}, {0.369501f, 0.275108f} },
    { {-0.450766f, -0.085272f, -0.143928f}, {-0.119298f, -0.078775f, 0.989728f}, {0.364518f, 0.275200f} },
    { {-0.409373f, -0.154060f, -0.144414f}, {-0.119298f, -0.078775f, 0.989728f}, {0.380593f, 0.275473f} },
    { {-0.460814f, -0.189355f, -0.153423f}, {-0.119298f, -0.078775f, 0.989728f}, {0.388834f, 0.278285f} },
    { {-0.274363f, 0.005275f, -0.233330f}, {0.111793f, 0.101854f, 0.988498f}, {0.343292f, 0.302311f} },
    { {-0.376177f, -0.206796f, -0.199964f}, {0.111793f, 0.101854f, 0.988498f}, {0.392875f, 0.292516f} },
    { {-0.377300f, -0.050645f, -0.215927f}, {0.111793f, 0.101854f, 0.988498f}, {0.356372f, 0.297103f} },
    { {-0.414456f, 0.012172f, 0.058158f}, {-0.063523f, 0.059343f, 0.996214f}, {0.341898f, 0.213371f} },
    { {-0.411788f, -0.082061f, 0.051288f}, {-0.144027f, -0.257358f, 0.955523f}, {0.363914f, 0.215637f} },
    { {-0.508991f, 0.006234f, -0.014386f}, {-0.962673f, 0.152451f, 0.223649f}, {0.343232f, 0.235513f} },
    { {-0.505838f, -0.090842f, -0.054152f}, {-0.931380f, -0.308188f, 0.193781f}, {0.365887f, 0.247821f} },
    { {-0.513250f, 0.003790f, -0.085687f}, {-0.972400f, 0.233043f, 0.011324f}, {0.343749f, 0.257270f} },
    { {0.026021f, -0.182017f, -0.073854f}, {-0.242812f, 0.850769f, -0.466083f}, {0.387179f, 0.253997f} },
    { {-0.025859f, -0.211945f, -0.101455f}, {-0.242812f, 0.850769f, -0.466083f}, {0.394152f, 0.262471f} },
    { {0.018241f, -0.278279f, -0.245512f}, {-0.242812f, 0.850769f, -0.466083f}, {0.409545f, 0.306541f} },
    { {-0.025859f, -0.211945f, -0.101455f}, {-0.114471f, -0.858794f, 0.499370f}, {0.394152f, 0.262471f} },
    { {0.025048f, -0.086901f, 0.015810f}, {0.160525f, -0.228457f, 0.960229f}, {0.365019f, 0.226470f} },
    { {0.058581f, -0.046915f, 0.008963f}, {0.457193f, -0.064920f, 0.886995f}, {0.355669f, 0.228486f} },
    { {0.096633f, -0.119593f, -0.027173f}, {0.465546f, -0.245593f, 0.850265f}, {0.372626f, 0.239642f} },
    { {-0.444130f, 0.086117f, -0.334591f}, {-0.185477f, 0.201433f, -0.961781f}, {0.324324f, 0.333058f} },
    { {-0.357520f, 0.197655f, -0.235335f}, {-0.001266f, 0.058776f, 0.998270f}, {0.298333f, 0.302574f} },
    { {-0.279270f, 0.184757f, -0.235248f}, {-0.022891f, 0.081521f, 0.996409f}, {0.301348f, 0.302571f} },
    { {0.099420f, -0.069200f, -0.020003f}, {0.928844f, 0.012366f, 0.370266f}, {0.360855f, 0.237364f} },
    { {0.019813f, 0.039497f, -0.017445f}, {0.715509f, 0.342001f, 0.609165f}, {0.335456f, 0.236386f} },
    { {-0.387948f, -0.004909f, -0.085848f}, {0.152646f, 0.001410f, -0.988280f}, {0.345782f, 0.257335f} },
    { {-0.377092f, -0.094560f, -0.084299f}, {0.152646f, 0.001410f, -0.988280f}, {0.366734f, 0.257025f} },
    { {-0.266470f, -0.092485f, -0.067209f}, {0.152646f, 0.001410f, -0.988280f}, {0.366261f, 0.251808f} },
    { {-0.440119f, 0.101869f, 0.032247f}, {-0.132958f, 0.327986f, 0.935279f}, {0.320918f, 0.221113f} },
    { {-0.285336f, 0.098083f, 0.033394f}, {0.136324f, 0.292197f, 0.946592f}, {0.321804f, 0.220770f} },
    { {-0.291366f, 0.009498f, 0.054793f}, {0.326985f, 0.134011f, 0.935479f}, {0.342521f, 0.214402f} },
    { {-0.267664f, -0.078409f, 0.011993f}, {0.913291f, -0.061424f, 0.402650f}, {0.363031f, 0.227619f} },
    { {-0.343412f, 0.199985f, -0.194906f}, {0.890776f, 0.452038f, -0.046689f}, {0.297819f, 0.290236f} },
    { {-0.332373f, 0.163879f, -0.195063f}, {0.979523f, -0.122868f, -0.159492f}, {0.306257f, 0.290349f} },
    { {-0.332373f, 0.163474f, -0.102105f}, {0.982792f, 0.178332f, 0.048137f}, {0.306421f, 0.261990f} },
    { {0.026555f, 0.021124f, -0.220277f}, {-0.160003f, -0.263339f, 0.951342f}, {0.339598f, 0.298300f} },
    { {-0.073318f, 0.032356f, -0.236096f}, {-0.187068f, -0.113789f, 0.975734f}, {0.336961f, 0.303106f} },
    { {0.016484f, 0.127873f, -0.218300f}, {-0.239979f, -0.094262f, 0.966191f}, {0.314653f, 0.297504f} },
    { {-0.265566f, -0.231907f, -0.206699f}, {0.087696f, 0.121099f, 0.988759f}, {0.398738f, 0.294616f} },
    { {-0.376177f, -0.206796f, -0.199964f}, {0.087696f, 0.121099f, 0.988759f}, {0.392875f, 0.292516f} },
    { {-0.265819f, -0.006309f, -0.234307f}, {0.087696f, 0.121099f, 0.988759f}, {0.345998f, 0.302630f} },
    { {-0.377320f, -0.294650f, -0.271576f}, {-0.325551f, -0.497748f, -0.803905f}, {0.413351f, 0.314522f} },
    { {-0.324332f, -0.297540f, -0.267728f}, {0.081795f, -0.455753f, -0.886340f}, {0.414030f, 0.313353f} },
    { {-0.410506f, -0.142523f, -0.330374f}, {-0.136159f, -0.295026f, -0.945738f}, {0.377757f, 0.332185f} },
    { {-0.502796f, -0.121022f, -0.250403f}, {-0.957409f, -0.250004f, -0.144450f}, {0.372793f, 0.307748f} },
    { {-0.515286f, 0.022401f, -0.091890f}, {-0.964730f, -0.171279f, 0.199900f}, {0.339395f, 0.259129f} },
    { {-0.515286f, 0.022902f, -0.206509f}, {-0.969773f, -0.201500f, -0.137613f}, {0.339193f, 0.294096f} },
    { {-0.530327f, 0.077158f, -0.117563f}, {-0.980057f, -0.103203f, 0.169815f}, {0.326580f, 0.266862f} },
    { {-0.477227f, 0.118444f, -0.086985f}, {-0.260584f, 0.146052f, 0.954340f}, {0.316955f, 0.257459f} },
    { {-0.385156f, 0.137648f, -0.080557f}, {-0.069971f, 0.037939f, 0.996827f}, {0.312472f, 0.255463f} },
    { {-0.449779f, 0.058554f, -0.080902f}, {-0.097092f, 0.021924f, 0.995034f}, {0.330955f, 0.255712f} },
    { {-0.030926f, -0.198541f, -0.323022f}, {-0.327856f, -0.053197f, -0.943229f}, {0.390854f, 0.330043f} },
    { {-0.059415f, -0.099260f, -0.310730f}, {-0.417033f, 0.082078f, -0.905178f}, {0.367662f, 0.326114f} },
    { {-0.083846f, -0.230636f, -0.299091f}, {-0.626206f, -0.042643f, -0.778490f}, {0.398372f, 0.322801f} },
    { {-0.092717f, -0.288354f, -0.257219f}, {-0.153229f, 0.308034f, 0.938955f}, {0.411891f, 0.310131f} },
    { {0.018241f, -0.278279f, -0.245512f}, {-0.215269f, 0.531311f, 0.819370f}, {0.409545f, 0.306541f} },
    { {-0.047374f, -0.302426f, -0.253592f}, {-0.361555f, 0.894876f, 0.261675f}, {0.415182f, 0.309050f} },
    { {-0.316133f, -0.250676f, -0.153042f}, {0.000248f, -0.118444f, 0.992961f}, {0.403164f, 0.278280f} },
    { {-0.367687f, -0.250778f, -0.153041f}, {0.000248f, -0.118444f, 0.992961f}, {0.403188f, 0.278280f} },
    { {-0.362001f, -0.178847f, -0.144462f}, {0.000248f, -0.118444f, 0.992961f}, {0.386385f, 0.275532f} },
    { {-0.367689f, -0.247792f, -0.142622f}, {0.000024f, -0.016204f, -0.999869f}, {0.402498f, 0.275096f} },
    { {-0.316134f, -0.247668f, -0.142623f}, {0.000024f, -0.016204f, -0.999869f}, {0.402469f, 0.275096f} },
    { {-0.308820f, -0.168997f, -0.143898f}, {0.000024f, -0.016204f, -0.999869f}, {0.384084f, 0.275342f} },
    { {-0.457545f, -0.014422f, -0.144990f}, {0.003796f, 0.028157f, -0.999596f}, {0.347961f, 0.275396f} },
    { {-0.393151f, -0.013386f, -0.144716f}, {0.003796f, 0.028157f, -0.999596f}, {0.347719f, 0.275310f} },
    { {-0.413178f, 0.007348f, -0.144208f}, {0.003796f, 0.028157f, -0.999596f}, {0.342874f, 0.275118f} },
    { {-0.275994f, 0.180705f, -0.075807f}, {0.012728f, 0.066692f, -0.997692f}, {0.302414f, 0.253936f} },
    { {-0.375523f, 0.177745f, 0.004182f}, {-0.154192f, 0.539937f, 0.827462f}, {0.303166f, 0.229538f} },
    { {-0.392634f, -0.013542f, -0.153635f}, {-0.001416f, 0.047472f, 0.998872f}, {0.347749f, 0.278031f} },
    { {-0.459546f, -0.017294f, -0.153551f}, {-0.001416f, 0.047472f, 0.998872f}, {0.348626f, 0.278013f} },
    { {-0.413139f, 0.007095f, -0.154644f}, {-0.001416f, 0.047472f, 0.998872f}, {0.342925f, 0.278302f} },
    { {-0.513250f, -0.001167f, -0.233522f}, {-0.898362f, 0.438772f, -0.020604f}, {0.344797f, 0.302381f} },
    { {-0.414945f, 0.006562f, -0.222337f}, {-0.091884f, 0.987902f, 0.124929f}, {0.342999f, 0.298955f} },
    { {-0.413139f, 0.007095f, -0.154644f}, {-0.071298f, 0.997357f, -0.013976f}, {0.342925f, 0.278302f} },
    { {-0.276089f, 0.010509f, -0.154666f}, {0.164972f, -0.983877f, 0.069074f}, {0.342128f, 0.278302f} },
    { {-0.274363f, 0.005275f, -0.233330f}, {0.164972f, -0.983877f, 0.069074f}, {0.343292f, 0.302311f} },
    { {-0.388453f, -0.012608f, -0.215569f}, {0.164972f, -0.983877f, 0.069074f}, {0.347484f, 0.296925f} },
    { {-0.316121f, -0.207632f, -0.076908f}, {0.140154f, -0.880935f, 0.452008f}, {0.393162f, 0.254975f} },
    { {-0.367689f, -0.247792f, -0.142622f}, {-0.149337f, -0.869419f, 0.470966f}, {0.402498f, 0.275096f} },
    { {-0.366500f, -0.186757f, -0.024277f}, {-0.192275f, -0.866603f, 0.460466f}, {0.388324f, 0.238880f} },
    { {-0.035362f, 0.170749f, -0.057702f}, {-0.344556f, 0.226567f, 0.911015f}, {0.304754f, 0.248430f} },
    { {-0.065819f, 0.190063f, -0.073049f}, {0.253464f, 0.960735f, 0.112894f}, {0.300229f, 0.253077f} },
    { {-0.011636f, 0.167009f, -0.106941f}, {0.484381f, 0.874573f, 0.022284f}, {0.305591f, 0.263459f} },
    { {0.016721f, 0.150057f, -0.081817f}, {0.697266f, 0.711261f, 0.089038f}, {0.309572f, 0.255825f} },
    { {0.076426f, -0.288975f, -0.304445f}, {0.883426f, -0.468342f, -0.014638f}, {0.412001f, 0.324540f} },
    { {0.086140f, -0.154575f, -0.031124f}, {0.839164f, -0.489166f, 0.237740f}, {0.380798f, 0.240911f} },
    { {0.098694f, -0.201288f, -0.320287f}, {0.747663f, -0.154920f, -0.645756f}, {0.391497f, 0.329214f} },
    { {0.016740f, -0.305429f, -0.323426f}, {0.259668f, -0.341509f, -0.903296f}, {0.415831f, 0.330360f} },
    { {-0.276086f, 0.010762f, -0.144230f}, {0.057371f, -0.006283f, -0.998333f}, {0.342076f, 0.275118f} },
    { {-0.276056f, 0.033297f, -0.144370f}, {0.057371f, -0.006283f, -0.998333f}, {0.336810f, 0.275120f} },
    { {-0.304953f, -0.002822f, -0.145803f}, {0.057371f, -0.006283f, -0.998333f}, {0.345250f, 0.275623f} },
    { {-0.276059f, 0.032983f, -0.154805f}, {0.017482f, 0.006192f, 0.999828f}, {0.336876f, 0.278304f} },
    { {-0.276089f, 0.010509f, -0.154666f}, {0.017482f, 0.006192f, 0.999828f}, {0.342128f, 0.278302f} },
    { {-0.306258f, 0.005393f, -0.154106f}, {0.017482f, 0.006192f, 0.999828f}, {0.343324f, 0.278141f} },
    { {-0.275030f, 0.007935f, -0.079458f}, {0.122963f, -0.991378f, -0.045277f}, {0.342786f, 0.255363f} },
    { {-0.276086f, 0.010762f, -0.144230f}, {0.122963f, -0.991378f, -0.045277f}, {0.342076f, 0.275118f} },
    { {-0.395296f, -0.004028f, -0.144138f}, {0.122963f, -0.991378f, -0.045277f}, {0.345533f, 0.275117f} },
    { {-0.353225f, 0.032670f, -0.144366f}, {-0.195453f, 0.974013f, -0.114440f}, {0.336957f, 0.275120f} },
    { {-0.420078f, 0.009663f, -0.084585f}, {-0.195047f, 0.476185f, -0.857441f}, {0.342378f, 0.256924f} },
    { {-0.460546f, 0.026444f, -0.217324f}, {-0.109038f, -0.052084f, -0.992672f}, {0.338357f, 0.297389f} },
    { {-0.502053f, 0.005414f, -0.102795f}, {-0.102926f, -0.993907f, 0.039430f}, {0.343357f, 0.262487f} },
    { {-0.463648f, 0.009391f, -0.211054f}, {0.078652f, -0.987423f, -0.137149f}, {0.342347f, 0.295507f} },
    { {-0.502053f, 0.005820f, -0.195753f}, {-0.436752f, -0.897482f, -0.061432f}, {0.343193f, 0.290846f} },
    { {0.026021f, -0.182017f, -0.073854f}, {-0.087245f, 0.252551f, -0.963642f}, {0.387179f, 0.253997f} },
    { {-0.086264f, -0.177440f, -0.063908f}, {-0.077829f, 0.208947f, -0.974825f}, {0.386117f, 0.250954f} },
    { {-0.033987f, -0.188497f, -0.063120f}, {-0.096420f, -0.516513f, -0.850833f}, {0.388701f, 0.250734f} },
    { {-0.073900f, -0.105287f, -0.030728f}, {-0.539220f, -0.092857f, 0.837030f}, {0.369280f, 0.240701f} },
    { {-0.316133f, -0.250676f, -0.153042f}, {0.236780f, -0.815421f, 0.528228f}, {0.403164f, 0.278280f} },
    { {-0.453814f, 0.157557f, -0.195091f}, {-0.737712f, 0.559697f, -0.377518f}, {0.307734f, 0.290369f} },
    { {-0.498457f, 0.080265f, -0.210744f}, {-0.512925f, 0.266778f, -0.815928f}, {0.325784f, 0.295285f} },
    { {-0.441155f, 0.195681f, -0.168927f}, {-0.407916f, 0.852988f, -0.325602f}, {0.298845f, 0.282318f} },
    { {-0.362743f, 0.209603f, -0.205694f}, {-0.179444f, 0.970640f, -0.160182f}, {0.295564f, 0.293510f} },
    { {-0.413178f, 0.007348f, -0.144208f}, {-0.065830f, 0.996756f, -0.046310f}, {0.342874f, 0.275118f} },
    { {-0.420078f, 0.009663f, -0.084585f}, {-0.064101f, 0.996739f, -0.049012f}, {0.342378f, 0.256924f} },
    { {-0.513250f, 0.000741f, -0.144167f}, {-0.546685f, 0.836334f, -0.040990f}, {0.344418f, 0.275117f} },
    { {-0.265528f, -0.207076f, -0.153313f}, {0.022840f, -0.008902f, 0.999699f}, {0.392975f, 0.278284f} },
    { {-0.284286f, -0.235418f, -0.153137f}, {0.022840f, -0.008902f, 0.999699f}, {0.399599f, 0.278281f} },
    { {-0.308440f, -0.169474f, -0.151998f}, {0.022840f, -0.008902f, 0.999699f}, {0.384189f, 0.277814f} },
    { {-0.284387f, -0.232714f, -0.142716f}, {0.007571f, -0.011269f, -0.999908f}, {0.398975f, 0.275097f} },
    { {-0.265527f, -0.204463f, -0.142892f}, {0.007571f, -0.011269f, -0.999908f}, {0.392372f, 0.275100f} },
    { {-0.296800f, -0.150129f, -0.143741f}, {0.007571f, -0.011269f, -0.999908f}, {0.379675f, 0.275260f} },
    { {-0.343412f, 0.199579f, -0.101947f}, {0.753611f, 0.634872f, 0.170319f}, {0.297984f, 0.261877f} },
    { {-0.370891f, 0.189084f, -0.080333f}, {-0.058966f, 0.119552f, 0.991075f}, {0.300453f, 0.255301f} },
    { {-0.395731f, 0.179419f, -0.273376f}, {-0.709904f, 0.689671f, -0.142792f}, {0.302567f, 0.314213f} },
    { {-0.466169f, 0.093324f, -0.234657f}, {-0.827306f, 0.560591f, -0.036096f}, {0.322715f, 0.302556f} },
    { {-0.406961f, 0.141189f, -0.323666f}, {-0.243184f, 0.517024f, -0.820699f}, {0.311463f, 0.329625f} },
    { {-0.278469f, 0.170520f, -0.304356f}, {0.134041f, 0.665978f, -0.733829f}, {0.304623f, 0.323681f} },
    { {-0.374408f, 0.182768f, -0.298486f}, {-0.120624f, 0.734690f, -0.667593f}, {0.301765f, 0.321868f} },
    { {0.015941f, -0.342816f, -0.290669f}, {0.068695f, -0.949795f, 0.305238f}, {0.424593f, 0.320434f} },
    { {-0.034968f, -0.338992f, -0.298782f}, {-0.348476f, -0.594910f, -0.724325f}, {0.423693f, 0.322903f} },
    { {-0.086401f, -0.281128f, -0.283729f}, {-0.461489f, -0.359422f, -0.811075f}, {0.410183f, 0.318205f} },
    { {-0.044053f, -0.306467f, -0.279873f}, {-0.196752f, -0.665117f, -0.720353f}, {0.416107f, 0.317075f} },
    { {-0.040475f, -0.266466f, -0.302467f}, {-0.261691f, -0.309239f, -0.914269f}, {0.406742f, 0.323896f} },
    { {-0.265527f, -0.204463f, -0.142892f}, {0.028988f, 0.894025f, -0.447079f}, {0.392372f, 0.275100f} },
    { {-0.265566f, -0.171411f, -0.076801f}, {0.028988f, 0.894025f, -0.447079f}, {0.384698f, 0.254877f} },
    { {-0.321819f, -0.202643f, -0.142903f}, {0.028988f, 0.894025f, -0.447079f}, {0.391947f, 0.275100f} },
    { {-0.316773f, -0.187095f, -0.026641f}, {0.109602f, -0.836999f, 0.536116f}, {0.388401f, 0.239602f} },
    { {-0.069312f, 0.185219f, -0.236649f}, {-0.292602f, -0.134869f, 0.946675f}, {0.301239f, 0.302998f} },
    { {-0.070290f, 0.024186f, -0.258079f}, {-0.808673f, 0.143759f, -0.570422f}, {0.338854f, 0.309827f} },
    { {-0.035450f, -0.032505f, -0.300315f}, {-0.610522f, 0.157895f, -0.776100f}, {0.352070f, 0.322815f} },
    { {-0.065768f, 0.190261f, -0.240939f}, {-0.559667f, 0.218873f, -0.799292f}, {0.300057f, 0.304297f} },
    { {-0.362001f, -0.178847f, -0.144462f}, {0.255354f, 0.047719f, 0.965669f}, {0.386385f, 0.275532f} },
    { {-0.327908f, -0.180852f, -0.153379f}, {0.255354f, 0.047719f, 0.965669f}, {0.386847f, 0.278256f} },
    { {-0.316133f, -0.250676f, -0.153042f}, {0.255354f, 0.047719f, 0.965669f}, {0.403164f, 0.278280f} },
    { {-0.308820f, -0.168997f, -0.143898f}, {0.015792f, -0.027978f, -0.999484f}, {0.384084f, 0.275342f} },
    { {-0.362001f, -0.178847f, -0.144462f}, {0.015792f, -0.027978f, -0.999484f}, {0.386385f, 0.275532f} },
    { {-0.367689f, -0.247792f, -0.142622f}, {0.015792f, -0.027978f, -0.999484f}, {0.402498f, 0.275096f} },
    { {-0.481451f, 0.010738f, 0.038678f}, {-0.610767f, -0.011781f, 0.791723f}, {0.342219f, 0.219316f} },
    { {-0.426781f, -0.122259f, 0.024586f}, {-0.474656f, -0.431497f, 0.767146f}, {0.373288f, 0.223856f} },
    { {-0.479519f, -0.082960f, 0.006203f}, {-0.760037f, -0.334964f, 0.556905f}, {0.364091f, 0.229393f} },
    { {-0.442351f, -0.145650f, -0.011577f}, {-0.537577f, -0.697613f, 0.473654f}, {0.378727f, 0.234931f} },
    { {-0.416037f, -0.194041f, -0.081805f}, {-0.389713f, -0.815169f, 0.428513f}, {0.389983f, 0.256444f} },
    { {-0.275994f, 0.180705f, -0.075807f}, {0.396391f, 0.917320f, -0.037395f}, {0.302414f, 0.253936f} },
    { {-0.279338f, 0.183937f, -0.024288f}, {0.237488f, 0.967521f, 0.086614f}, {0.301697f, 0.238212f} },
    { {-0.357520f, 0.196012f, -0.076358f}, {0.052281f, 0.998609f, -0.006859f}, {0.298837f, 0.254076f} },
    { {-0.268127f, 0.167485f, -0.075281f}, {0.998716f, 0.045948f, -0.021339f}, {0.305504f, 0.253799f} },
    { {-0.267826f, -0.136735f, -0.291581f}, {0.919296f, -0.075662f, -0.386226f}, {0.376434f, 0.320339f} },
    { {-0.291743f, -0.142391f, -0.326290f}, {0.186377f, -0.253106f, -0.949316f}, {0.377730f, 0.330939f} },
    { {-0.065217f, 0.189763f, -0.066220f}, {-0.646883f, 0.176568f, 0.741867f}, {0.300305f, 0.250995f} },
    { {-0.073562f, 0.020295f, -0.058888f}, {-0.148916f, -0.115005f, -0.982139f}, {0.339912f, 0.249065f} },
    { {0.030316f, -0.206293f, -0.267930f}, {-0.118803f, 0.198671f, 0.972839f}, {0.392706f, 0.313250f} },
    { {-0.091884f, -0.248540f, -0.276203f}, {-0.132145f, 0.110492f, 0.985053f}, {0.402573f, 0.315850f} },
    { {-0.027743f, 0.004882f, -0.305946f}, {-0.447087f, 0.268683f, -0.853184f}, {0.343329f, 0.324466f} },
    { {-0.001224f, 0.016743f, -0.320816f}, {-0.333422f, 0.375454f, -0.864791f}, {0.340546f, 0.328981f} },
    { {-0.030700f, -0.099728f, -0.316198f}, {-0.923913f, 0.046335f, -0.379786f}, {0.367767f, 0.327783f} },
    { {-0.030926f, -0.198541f, -0.323022f}, {-0.954992f, 0.029537f, -0.295157f}, {0.390854f, 0.330043f} },
    { {-0.021127f, -0.017231f, -0.329422f}, {-0.927283f, 0.096286f, -0.361768f}, {0.348479f, 0.331668f} },
    { {-0.513250f, 0.000484f, -0.154603f}, {-0.787794f, 0.615804f, -0.012877f}, {0.344470f, 0.278302f} },
    { {0.033682f, -0.020872f, -0.329845f}, {0.406115f, 0.638868f, -0.653389f}, {0.349330f, 0.331803f} },
    { {0.087708f, -0.015019f, -0.295519f}, {0.349044f, 0.748297f, -0.564109f}, {0.347988f, 0.321321f} },
    { {0.067313f, 0.017694f, -0.226685f}, {0.608830f, 0.761457f, -0.222508f}, {0.340394f, 0.300261f} },
    { {0.091520f, -0.013309f, -0.284025f}, {0.906351f, 0.414102f, -0.083947f}, {0.347596f, 0.317811f} },
    { {0.086684f, 0.009833f, -0.060512f}, {0.870675f, 0.491564f, 0.017046f}, {0.342356f, 0.249579f} },
    { {0.034067f, -0.125223f, -0.057157f}, {-0.094349f, 0.124059f, -0.987779f}, {0.373919f, 0.248800f} },
    { {-0.086127f, -0.173601f, -0.056531f}, {-0.359586f, -0.330012f, 0.872806f}, {0.385225f, 0.248697f} },
    { {-0.033660f, -0.173445f, -0.041595f}, {-0.267643f, -0.557763f, 0.785664f}, {0.385200f, 0.244140f} },
    { {-0.028753f, -0.167968f, -0.022663f}, {-0.215214f, -0.727302f, 0.651702f}, {0.383934f, 0.238354f} },
    { {0.030710f, -0.186436f, -0.037753f}, {-0.063552f, -0.872423f, 0.484601f}, {0.388239f, 0.242991f} },
    { {-0.476910f, -0.134991f, -0.300330f}, {-0.661772f, -0.325473f, -0.675371f}, {0.376020f, 0.323006f} },
    { {-0.501064f, 0.013902f, -0.087441f}, {-0.165407f, -0.094115f, 0.981724f}, {0.341385f, 0.257787f} },
    { {-0.463648f, 0.008852f, -0.087463f}, {0.053897f, -0.926849f, 0.371544f}, {0.342565f, 0.257803f} },
    { {-0.417643f, -0.230320f, -0.153169f}, {-0.103018f, -0.102416f, 0.989393f}, {0.398407f, 0.278282f} },
    { {-0.460814f, -0.189355f, -0.153423f}, {-0.103018f, -0.102416f, 0.989393f}, {0.388834f, 0.278285f} },
    { {-0.409373f, -0.154060f, -0.144414f}, {-0.103018f, -0.102416f, 0.989393f}, {0.380593f, 0.275473f} },
    { {-0.264797f, 0.044860f, -0.234535f}, {0.985797f, 0.059173f, 0.157172f}, {0.334040f, 0.302607f} },
    { {-0.279270f, 0.184757f, -0.235248f}, {0.863256f, 0.415486f, 0.286636f}, {0.301348f, 0.302571f} },
    { {-0.270527f, 0.172921f, -0.273535f}, {0.992706f, 0.118804f, -0.020492f}, {0.304085f, 0.314273f} },
    { {-0.279107f, 0.184662f, -0.272319f}, {0.232148f, 0.963270f, -0.134975f}, {0.301342f, 0.313881f} },
    { {-0.357520f, 0.197655f, -0.235335f}, {0.049312f, 0.998783f, -0.000623f}, {0.298333f, 0.302574f} },
    { {-0.411441f, 0.116002f, -0.216933f}, {-0.076989f, 0.095319f, -0.992465f}, {0.317429f, 0.297108f} },
    { {-0.355255f, 0.155313f, -0.216761f}, {-0.022036f, 0.129880f, -0.991285f}, {0.308242f, 0.296985f} },
    { {0.025869f, -0.019692f, 0.019387f}, {0.175777f, 0.247877f, 0.952712f}, {0.349316f, 0.225257f} },
    { {0.019813f, 0.039497f, -0.017445f}, {0.467510f, 0.631823f, 0.618250f}, {0.335456f, 0.236386f} },
    { {0.058987f, 0.000600f, -0.004487f}, {0.446121f, 0.722676f, 0.527935f}, {0.344556f, 0.232503f} },
    { {-0.029127f, -0.137654f, -0.023694f}, {-0.979686f, 0.039047f, 0.196700f}, {0.376849f, 0.238613f} },
    { {-0.015176f, 0.031654f, -0.010102f}, {-0.967098f, 0.142635f, 0.210657f}, {0.337295f, 0.234160f} },
    { {-0.016598f, -0.009403f, 0.011167f}, {-0.616369f, 0.068678f, 0.784457f}, {0.346905f, 0.227746f} },
    { {-0.513250f, 0.000741f, -0.144167f}, {-0.005393f, -0.006703f, -0.999963f}, {0.344418f, 0.275117f} },
    { {-0.413178f, 0.007348f, -0.144208f}, {-0.003210f, 0.042417f, -0.999095f}, {0.342874f, 0.275118f} },
    { {-0.513250f, 0.000741f, -0.144167f}, {-0.003210f, 0.042417f, -0.999095f}, {0.344418f, 0.275117f} },
    { {-0.457545f, -0.014422f, -0.144990f}, {-0.003210f, 0.042417f, -0.999095f}, {0.347961f, 0.275396f} },
    { {-0.503388f, -0.108346f, -0.153927f}, {-0.018075f, 0.004577f, 0.999826f}, {0.369903f, 0.278292f} },
    { {-0.513250f, 0.000484f, -0.154603f}, {-0.018075f, 0.004577f, 0.999826f}, {0.344470f, 0.278302f} },
    { {-0.459546f, -0.017294f, -0.153551f}, {-0.018075f, 0.004577f, 0.999826f}, {0.348626f, 0.278013f} },
    { {-0.513250f, 0.000484f, -0.154603f}, {-0.002913f, 0.050314f, 0.998729f}, {0.344470f, 0.278302f} },
    { {-0.275788f, 0.032934f, -0.219981f}, {0.141352f, 0.524227f, 0.839765f}, {0.336838f, 0.298188f} },
    { {-0.349987f, 0.033083f, -0.220156f}, {-0.132530f, 0.977408f, 0.164652f}, {0.336803f, 0.298242f} },
    { {-0.353223f, 0.032353f, -0.154801f}, {-0.164057f, 0.986296f, 0.017477f}, {0.337023f, 0.278304f} },
    { {-0.321963f, -0.204878f, -0.153327f}, {0.035158f, 0.899966f, -0.434539f}, {0.392462f, 0.278284f} },
    { {-0.321901f, -0.228611f, -0.202475f}, {0.035158f, 0.899966f, -0.434539f}, {0.397971f, 0.293321f} },
    { {-0.265528f, -0.207076f, -0.153313f}, {0.035158f, 0.899966f, -0.434539f}, {0.392975f, 0.278284f} },
    { {-0.265528f, -0.207076f, -0.153313f}, {0.838200f, -0.478540f, 0.261572f}, {0.392975f, 0.278284f} },
    { {-0.011681f, 0.165687f, -0.198050f}, {0.458799f, 0.888451f, -0.012570f}, {0.305832f, 0.291257f} },
    { {-0.042738f, 0.180397f, -0.241406f}, {0.138535f, 0.644594f, -0.751869f}, {0.302362f, 0.304458f} },
    { {-0.013678f, 0.007846f, -0.320618f}, {-0.544060f, 0.753367f, -0.369373f}, {0.342625f, 0.328936f} },
    { {-0.503557f, -0.106593f, -0.143500f}, {-0.017482f, -0.015450f, -0.999728f}, {0.369501f, 0.275108f} },
    { {-0.461268f, -0.186641f, -0.143003f}, {-0.017482f, -0.015450f, -0.999728f}, {0.388208f, 0.275101f} },
    { {-0.409373f, -0.154060f, -0.144414f}, {-0.017482f, -0.015450f, -0.999728f}, {0.380593f, 0.275473f} },
    { {-0.321819f, -0.202643f, -0.142903f}, {0.107259f, 0.860583f, -0.497888f}, {0.391947f, 0.275100f} },
    { {-0.265566f, -0.171411f, -0.076801f}, {0.107259f, 0.860583f, -0.497888f}, {0.384698f, 0.254877f} },
    { {-0.376258f, -0.165774f, -0.090904f}, {0.107259f, 0.860583f, -0.497888f}, {0.383370f, 0.259169f} },
    { {-0.276056f, 0.033297f, -0.144370f}, {-0.000282f, 0.028486f, -0.999594f}, {0.336810f, 0.275120f} },
    { {-0.353225f, 0.032670f, -0.144366f}, {-0.000282f, 0.028486f, -0.999594f}, {0.336957f, 0.275120f} },
    { {-0.351423f, 0.004119f, -0.145180f}, {-0.000282f, 0.028486f, -0.999594f}, {0.343628f, 0.275420f} },
    { {-0.353223f, 0.032353f, -0.154801f}, {-0.000157f, 0.025496f, 0.999675f}, {0.337023f, 0.278304f} },
    { {-0.276059f, 0.032983f, -0.154805f}, {-0.000157f, 0.025496f, 0.999675f}, {0.336876f, 0.278304f} },
    { {-0.306258f, 0.005393f, -0.154106f}, {-0.000157f, 0.025496f, 0.999675f}, {0.343324f, 0.278141f} },
    { {-0.395377f, 0.178312f, -0.022706f}, {-0.631789f, 0.755082f, 0.175193f}, {0.303013f, 0.237740f} },
    { {-0.358412f, 0.194756f, -0.023821f}, {-0.073204f, 0.970500f, 0.229718f}, {0.299170f, 0.238051f} },
    { {-0.265566f, -0.171411f, -0.076801f}, {0.946879f, -0.293145f, 0.132233f}, {0.384698f, 0.254877f} },
    { {-0.265527f, -0.204463f, -0.142892f}, {0.808407f, -0.527983f, 0.260214f}, {0.392372f, 0.275100f} },
    { {-0.284892f, -0.175972f, -0.024922f}, {0.559235f, -0.742187f, 0.369342f}, {0.385803f, 0.239057f} },
    { {-0.266470f, -0.092485f, -0.067209f}, {0.999993f, 0.001484f, 0.003351f}, {0.366261f, 0.251808f} },
    { {0.058353f, 0.034774f, -0.068037f}, {0.634587f, 0.753685f, 0.171050f}, {0.336522f, 0.251830f} },
    { {0.038170f, -0.334937f, -0.289697f}, {0.494855f, -0.681684f, -0.538911f}, {0.422752f, 0.320124f} },
    { {-0.504276f, 0.082320f, -0.102459f}, {-0.458707f, 0.240636f, 0.855384f}, {0.325385f, 0.262245f} },
    { {-0.284286f, -0.235418f, -0.153137f}, {0.694285f, -0.616823f, 0.370807f}, {0.399599f, 0.278281f} },
    { {-0.284934f, -0.289999f, -0.240016f}, {0.596711f, -0.759335f, 0.259514f}, {0.412288f, 0.304885f} },
    { {-0.073876f, -0.304405f, -0.272429f}, {-0.298782f, -0.948909f, -0.101489f}, {0.415631f, 0.314800f} },
    { {-0.265819f, 0.004954f, -0.079340f}, {0.518628f, -0.000057f, -0.855000f}, {0.343482f, 0.255332f} },
    { {-0.268127f, 0.167485f, -0.075281f}, {0.447546f, 0.043864f, -0.893184f}, {0.305504f, 0.253799f} },
    { {-0.275716f, 0.039985f, -0.085345f}, {0.185790f, 0.541126f, -0.820161f}, {0.335291f, 0.257101f} },
    { {-0.276056f, 0.033297f, -0.144370f}, {0.587017f, 0.803718f, -0.097201f}, {0.336810f, 0.275120f} },
    { {-0.275030f, 0.007935f, -0.079458f}, {0.995172f, -0.005239f, -0.098008f}, {0.342786f, 0.255363f} },
    { {-0.530327f, 0.077432f, -0.180359f}, {-0.962854f, 0.111548f, -0.245907f}, {0.326469f, 0.286020f} },
    { {-0.276059f, 0.032983f, -0.154805f}, {0.272481f, 0.962161f, 0.000415f}, {0.336876f, 0.278304f} },
    { {-0.034735f, -0.339763f, -0.290037f}, {-0.221603f, -0.821284f, 0.525723f}, {0.423880f, 0.320236f} },
    { {-0.027950f, -0.287236f, -0.336453f}, {-0.712717f, -0.229847f, -0.662725f}, {0.411570f, 0.334302f} },
    { {-0.039876f, -0.316658f, -0.271941f}, {-0.960237f, -0.123791f, -0.250240f}, {0.418494f, 0.314673f} },
    { {-0.439474f, -0.244538f, -0.261372f}, {-0.751559f, -0.481076f, -0.451359f}, {0.401649f, 0.311319f} },
    { {-0.418859f, -0.279594f, -0.238272f}, {-0.599393f, -0.754256f, 0.268003f}, {0.409858f, 0.304334f} },
    { {-0.376177f, -0.206796f, -0.199964f}, {0.345080f, 0.892118f, -0.291626f}, {0.392875f, 0.292516f} },
    { {-0.321901f, -0.228611f, -0.202475f}, {0.345080f, 0.892118f, -0.291626f}, {0.397971f, 0.293321f} },
    { {-0.376060f, -0.191623f, -0.153409f}, {0.345080f, 0.892118f, -0.291626f}, {0.389364f, 0.278285f} },
    { {-0.020423f, -0.131590f, 0.003915f}, {-0.245084f, -0.307874f, 0.919319f}, {0.375453f, 0.230179f} },
    { {0.001002f, 0.038346f, -0.004542f}, {0.027050f, 0.436696f, 0.899202f}, {0.335735f, 0.232452f} },
    { {-0.030700f, -0.099728f, -0.316198f}, {-0.321360f, 0.124270f, -0.938768f}, {0.367767f, 0.327783f} },
    { {-0.010037f, 0.160304f, -0.051184f}, {0.566099f, 0.491769f, 0.661586f}, {0.307200f, 0.246461f} },
    { {-0.276089f, 0.010509f, -0.154666f}, {0.122287f, -0.981556f, 0.146945f}, {0.342128f, 0.278302f} },
    { {-0.388453f, -0.012608f, -0.215569f}, {0.122287f, -0.981556f, 0.146945f}, {0.347484f, 0.296925f} },
    { {-0.395317f, -0.004332f, -0.154573f}, {0.122287f, -0.981556f, 0.146945f}, {0.345596f, 0.278301f} },
    { {-0.011681f, 0.165687f, -0.198050f}, {-0.554891f, -0.674264f, 0.487303f}, {0.305832f, 0.291257f} },
    { {-0.394551f, 0.180835f, -0.235163f}, {-0.645382f, 0.763853f, -0.003262f}, {0.302264f, 0.302553f} },
    { {-0.357939f, 0.197649f, -0.270389f}, {-0.053062f, 0.967393f, -0.247658f}, {0.298309f, 0.313269f} },
    { {-0.040475f, -0.266466f, -0.302467f}, {-0.932983f, -0.085741f, -0.349560f}, {0.406742f, 0.323896f} },
    { {-0.395296f, -0.004028f, -0.144138f}, {0.071416f, -0.996119f, 0.051446f}, {0.345533f, 0.275117f} },
    { {-0.394851f, -0.001591f, -0.097569f}, {0.071416f, -0.996119f, 0.051446f}, {0.344998f, 0.260905f} },
    { {-0.275030f, 0.007935f, -0.079458f}, {0.071416f, -0.996119f, 0.051446f}, {0.342786f, 0.255363f} },
    { {-0.440323f, -0.210388f, -0.142855f}, {-0.008608f, -0.022932f, -0.999700f}, {0.393757f, 0.275099f} },
    { {0.094749f, -0.022528f, -0.038688f}, {0.970429f, 0.237130f, 0.045121f}, {0.349935f, 0.242979f} },
    { {0.086239f, -0.002569f, -0.012701f}, {0.678519f, 0.313866f, 0.664154f}, {0.345290f, 0.235015f} },
    { {-0.351423f, 0.004119f, -0.145180f}, {-0.006675f, 0.044981f, -0.998966f}, {0.343628f, 0.275420f} },
    { {-0.304953f, -0.002822f, -0.145803f}, {-0.006675f, 0.044981f, -0.998966f}, {0.345250f, 0.275623f} },
    { {-0.276056f, 0.033297f, -0.144370f}, {-0.006675f, 0.044981f, -0.998966f}, {0.336810f, 0.275120f} },
    { {-0.351744f, 0.003720f, -0.154077f}, {-0.000278f, 0.025286f, 0.999680f}, {0.343714f, 0.278135f} },
    { {-0.348911f, 0.141345f, -0.210478f}, {0.791952f, -0.548471f, -0.268312f}, {0.311511f, 0.295093f} },
    { {-0.348911f, 0.140805f, -0.086888f}, {0.424340f, -0.898408f, 0.113134f}, {0.311730f, 0.257389f} },
    { {-0.338533f, 0.145145f, -0.091355f}, {0.869961f, -0.397029f, 0.292464f}, {0.310712f, 0.258744f} },
    { {-0.362743f, 0.209103f, -0.091076f}, {0.364595f, 0.763866f, 0.532521f}, {0.295766f, 0.258543f} },
    { {-0.355255f, 0.154718f, -0.080483f}, {0.367534f, 0.121422f, 0.922050f}, {0.308483f, 0.255409f} },
    { {0.008784f, 0.018453f, -0.313848f}, {0.494141f, 0.595944f, -0.632990f}, {0.340152f, 0.326852f} },
    { {-0.013678f, 0.007846f, -0.320618f}, {-0.263470f, 0.471073f, -0.841828f}, {0.342625f, 0.328936f} },
    { {-0.459546f, -0.017294f, -0.153551f}, {-0.230725f, 0.107106f, 0.967106f}, {0.348626f, 0.278013f} },
    { {-0.450766f, -0.085272f, -0.143928f}, {-0.230725f, 0.107106f, 0.967106f}, {0.364518f, 0.275200f} },
    { {-0.503388f, -0.108346f, -0.153927f}, {-0.230725f, 0.107106f, 0.967106f}, {0.369903f, 0.278292f} },
    { {-0.450766f, -0.085272f, -0.143928f}, {-0.019349f, -0.016841f, -0.999671f}, {0.364518f, 0.275200f} },
    { {-0.457545f, -0.014422f, -0.144990f}, {-0.019349f, -0.016841f, -0.999671f}, {0.347961f, 0.275396f} },
    { {-0.513250f, 0.000741f, -0.144167f}, {-0.019349f, -0.016841f, -0.999671f}, {0.344418f, 0.275117f} },
    { {0.111835f, -0.132687f, -0.283290f}, {0.992653f, -0.040501f, -0.114015f}, {0.375494f, 0.317803f} },
    { {0.091694f, -0.246551f, -0.309731f}, {0.963132f, -0.258220f, -0.075496f}, {0.402083f, 0.326076f} },
    { {-0.276089f, 0.010509f, -0.154666f}, {0.999618f, 0.024400f, 0.012973f}, {0.342128f, 0.278302f} },
    { {-0.274363f, 0.005275f, -0.233330f}, {0.958311f, -0.012675f, 0.285445f}, {0.343292f, 0.302311f} },
    { {-0.499858f, 0.147302f, -0.169138f}, {-0.791391f, 0.597400f, -0.129668f}, {0.310150f, 0.282470f} },
    { {-0.472732f, 0.174192f, -0.169020f}, {-0.606200f, 0.767549f, -0.208303f}, {0.303866f, 0.282385f} },
    { {-0.089172f, -0.297334f, -0.265872f}, {-0.901945f, -0.310982f, -0.299642f}, {0.413983f, 0.312787f} },
    { {-0.091884f, -0.248540f, -0.276203f}, {-0.924338f, 0.030186f, -0.380378f}, {0.402573f, 0.315850f} },
    { {-0.351597f, 0.197377f, -0.210233f}, {0.193307f, 0.167158f, -0.966794f}, {0.298417f, 0.294917f} },
    { {-0.415581f, 0.181699f, -0.210302f}, {-0.466832f, 0.709253f, -0.528232f}, {0.302081f, 0.294966f} },
    { {-0.362743f, 0.209103f, -0.091076f}, {-0.228414f, 0.934646f, 0.272514f}, {0.295766f, 0.258543f} },
    { {-0.284271f, -0.276824f, -0.269098f}, {0.647894f, -0.342693f, -0.680290f}, {0.409188f, 0.313734f} },
    { {-0.284387f, -0.232714f, -0.142716f}, {0.492446f, -0.773100f, 0.399766f}, {0.398975f, 0.275097f} },
    { {-0.029480f, -0.278674f, -0.202949f}, {-0.292385f, 0.901366f, -0.319452f}, {0.409670f, 0.293556f} },
    { {-0.047374f, -0.302426f, -0.253592f}, {-0.675663f, -0.628312f, 0.385621f}, {0.415182f, 0.309050f} },
    { {-0.073562f, 0.020295f, -0.058888f}, {-0.968200f, 0.069965f, 0.240196f}, {0.339912f, 0.249065f} },
    { {-0.075465f, -0.012042f, -0.047920f}, {-0.898568f, 0.081722f, 0.431158f}, {0.347478f, 0.245777f} },
    { {0.105096f, -0.081458f, -0.309469f}, {0.938022f, 0.113432f, -0.327488f}, {0.363503f, 0.325697f} },
    { {-0.394419f, -0.167312f, -0.152943f}, {-0.282386f, -0.091564f, 0.954921f}, {0.383683f, 0.278099f} },
    { {-0.362001f, -0.178847f, -0.144462f}, {-0.282386f, -0.091564f, 0.954921f}, {0.386385f, 0.275532f} },
    { {-0.367687f, -0.250778f, -0.153041f}, {-0.282386f, -0.091564f, 0.954921f}, {0.403188f, 0.278280f} },
    { {-0.362001f, -0.178847f, -0.144462f}, {-0.014371f, -0.025492f, -0.999572f}, {0.386385f, 0.275532f} },
    { {-0.409373f, -0.154060f, -0.144414f}, {-0.014371f, -0.025492f, -0.999572f}, {0.380593f, 0.275473f} },
    { {-0.367689f, -0.247792f, -0.142622f}, {-0.014371f, -0.025492f, -0.999572f}, {0.402498f, 0.275096f} },
    { {-0.415581f, 0.181160f, -0.086711f}, {-0.402579f, 0.541668f, 0.737920f}, {0.302300f, 0.257262f} },
    { {-0.268337f, 0.169401f, -0.022596f}, {0.967122f, 0.234127f, 0.099296f}, {0.305096f, 0.237723f} },
    { {-0.277643f, 0.171018f, 0.004401f}, {0.328437f, 0.553780f, 0.765152f}, {0.304738f, 0.229483f} },
    { {-0.011636f, 0.167009f, -0.106941f}, {-0.561575f, -0.719717f, -0.408217f}, {0.305591f, 0.263459f} },
    { {-0.065819f, 0.190063f, -0.073049f}, {-0.561575f, -0.719717f, -0.408217f}, {0.300229f, 0.253077f} },
    { {0.016614f, 0.131486f, -0.083174f}, {-0.561575f, -0.719717f, -0.408217f}, {0.313910f, 0.256273f} },
    { {-0.513250f, -0.001167f, -0.233522f}, {-0.067090f, 0.004741f, 0.997736f}, {0.344797f, 0.302381f} },
    { {-0.417629f, -0.227587f, -0.142748f}, {-0.510751f, -0.773104f, 0.376091f}, {0.397776f, 0.275098f} },
    { {0.001002f, 0.038346f, -0.004542f}, {0.014743f, 0.341650f, 0.939712f}, {0.335735f, 0.232452f} },
    { {-0.308440f, -0.169474f, -0.151998f}, {-0.210974f, -0.273597f, 0.938421f}, {0.384189f, 0.277814f} },
    { {-0.296800f, -0.150129f, -0.143741f}, {-0.210974f, -0.273597f, 0.938421f}, {0.379675f, 0.275260f} },
    { {-0.265528f, -0.207076f, -0.153313f}, {-0.210974f, -0.273597f, 0.938421f}, {0.392975f, 0.278284f} },
    { {-0.296800f, -0.150129f, -0.143741f}, {0.026321f, -0.008447f, -0.999618f}, {0.379675f, 0.275260f} },
    { {-0.308820f, -0.168997f, -0.143898f}, {0.026321f, -0.008447f, -0.999618f}, {0.384084f, 0.275342f} },
    { {-0.284387f, -0.232714f, -0.142716f}, {0.026321f, -0.008447f, -0.999618f}, {0.398975f, 0.275097f} },
    { {-0.504276f, 0.082726f, -0.195417f}, {-0.458707f, 0.248092f, -0.853251f}, {0.325221f, 0.290604f} },
    { {-0.453814f, 0.157557f, -0.195091f}, {-0.489500f, 0.470538f, -0.734155f}, {0.307734f, 0.290369f} },
    { {-0.417643f, -0.230320f, -0.153169f}, {-0.495552f, -0.748587f, 0.440506f}, {0.398407f, 0.278282f} },
    { {-0.027743f, 0.004882f, -0.305946f}, {-0.915920f, 0.129321f, -0.379956f}, {0.343329f, 0.324466f} },
    { {-0.460814f, -0.189355f, -0.153423f}, {-0.154319f, -0.074979f, 0.985172f}, {0.388834f, 0.278285f} },
    { {-0.503388f, -0.108346f, -0.153927f}, {-0.154319f, -0.074979f, 0.985172f}, {0.369903f, 0.278292f} },
    { {-0.450766f, -0.085272f, -0.143928f}, {-0.154319f, -0.074979f, 0.985172f}, {0.364518f, 0.275200f} },
    { {-0.353225f, 0.032670f, -0.144366f}, {-0.014281f, 0.027600f, -0.999517f}, {0.336957f, 0.275120f} },
    { {-0.413178f, 0.007348f, -0.144208f}, {-0.014281f, 0.027600f, -0.999517f}, {0.342874f, 0.275118f} },
    { {-0.351423f, 0.004119f, -0.145180f}, {-0.014281f, 0.027600f, -0.999517f}, {0.343628f, 0.275420f} },
    { {-0.413139f, 0.007095f, -0.154644f}, {-0.007875f, 0.024894f, 0.999659f}, {0.342925f, 0.278302f} },
    { {-0.033660f, -0.173445f, -0.041595f}, {-0.950206f, -0.129114f, 0.283617f}, {0.385200f, 0.244140f} },
    { {0.030465f, -0.049706f, -0.253229f}, {-0.141631f, -0.309112f, 0.940420f}, {0.356125f, 0.308481f} },
    { {-0.367687f, -0.250778f, -0.153041f}, {-0.003486f, -0.002296f, 0.999991f}, {0.403188f, 0.278280f} },
    { {-0.417643f, -0.230320f, -0.153169f}, {-0.003486f, -0.002296f, 0.999991f}, {0.398407f, 0.278282f} },
    { {-0.394419f, -0.167312f, -0.152943f}, {-0.003486f, -0.002296f, 0.999991f}, {0.383683f, 0.278099f} },
    { {-0.398160f, 0.017983f, -0.229726f}, {-0.391144f, 0.843391f, 0.368372f}, {0.340325f, 0.301188f} },
    { {-0.047374f, -0.302426f, -0.253592f}, {-0.179644f, -0.919603f, 0.349369f}, {0.415182f, 0.309050f} },
    { {-0.092717f, -0.288354f, -0.257219f}, {-0.611916f, -0.718593f, 0.330429f}, {0.411891f, 0.310131f} },
    { {-0.351744f, 0.003720f, -0.154077f}, {-0.006929f, 0.042006f, 0.999093f}, {0.343714f, 0.278135f} },
    { {-0.393151f, -0.013386f, -0.144716f}, {-0.015217f, 0.009798f, -0.999836f}, {0.347719f, 0.275310f} },
    { {-0.351423f, 0.004119f, -0.145180f}, {-0.015217f, 0.009798f, -0.999836f}, {0.343628f, 0.275420f} },
    { {-0.413178f, 0.007348f, -0.144208f}, {-0.015217f, 0.009798f, -0.999836f}, {0.342874f, 0.275118f} },
    { {-0.513250f, 0.003790f, -0.085687f}, {0.002825f, 0.140938f, -0.990014f}, {0.343749f, 0.257270f} },
    { {-0.275788f, 0.032934f, -0.219981f}, {0.761827f, 0.082087f, 0.642559f}, {0.336838f, 0.298188f} },
    { {-0.264797f, 0.044860f, -0.234535f}, {0.618729f, -0.125917f, 0.775448f}, {0.334040f, 0.302607f} },
    { {-0.413139f, 0.007095f, -0.154644f}, {-0.427298f, 0.902955f, 0.045695f}, {0.342925f, 0.278302f} },
    { {-0.515286f, 0.022401f, -0.091890f}, {-0.817087f, -0.358460f, 0.451525f}, {0.339395f, 0.259129f} },
    { {-0.084373f, -0.128707f, -0.046282f}, {-0.874397f, 0.029284f, 0.484328f}, {0.374742f, 0.245488f} },
    { {-0.362743f, 0.209603f, -0.205694f}, {0.411272f, 0.886973f, -0.210081f}, {0.295564f, 0.293510f} },
    { {-0.415581f, 0.181699f, -0.210302f}, {-0.187435f, 0.300955f, -0.935037f}, {0.302081f, 0.294966f} },
    { {-0.275030f, 0.007935f, -0.079458f}, {0.116372f, 0.322364f, -0.939436f}, {0.342786f, 0.255363f} },
    { {-0.394851f, -0.001591f, -0.097569f}, {0.116372f, 0.322364f, -0.939436f}, {0.344998f, 0.260905f} },
    { {-0.265819f, 0.004954f, -0.079340f}, {0.116372f, 0.322364f, -0.939436f}, {0.343482f, 0.255332f} },
    { {-0.025859f, -0.211945f, -0.101455f}, {-0.185357f, 0.820308f, -0.541052f}, {0.394152f, 0.262471f} },
    { {0.026021f, -0.182017f, -0.073854f}, {-0.185357f, 0.820308f, -0.541052f}, {0.387179f, 0.253997f} },
    { {-0.033987f, -0.188497f, -0.063120f}, {-0.185357f, 0.820308f, -0.541052f}, {0.388701f, 0.250734f} },
    { {-0.033987f, -0.188497f, -0.063120f}, {-0.412761f, -0.789595f, 0.454057f}, {0.388701f, 0.250734f} },
    { {-0.276086f, 0.010762f, -0.144230f}, {0.999865f, -0.001439f, -0.016364f}, {0.342076f, 0.275118f} },
    { {-0.515286f, 0.022902f, -0.206509f}, {-0.845582f, -0.378687f, -0.376280f}, {0.339193f, 0.294096f} },
    { {-0.069312f, 0.185219f, -0.236649f}, {-0.968282f, 0.038727f, -0.246842f}, {0.301239f, 0.302998f} },
    { {-0.065768f, 0.190261f, -0.240939f}, {-0.206064f, 0.714098f, 0.669031f}, {0.300057f, 0.304297f} },
    { {-0.011681f, 0.165687f, -0.198050f}, {-0.206064f, 0.714098f, 0.669031f}, {0.305832f, 0.291257f} },
    { {-0.069312f, 0.185219f, -0.236649f}, {-0.206064f, 0.714098f, 0.669031f}, {0.301239f, 0.302998f} },
    { {-0.316134f, -0.247668f, -0.142623f}, {0.153325f, -0.843906f, 0.514116f}, {0.402469f, 0.275096f} },
    { {0.028426f, -0.337788f, -0.282423f}, {0.285447f, -0.857939f, 0.427154f}, {0.423424f, 0.317910f} },
    { {-0.284286f, -0.235418f, -0.153137f}, {0.000618f, 0.004926f, 0.999988f}, {0.399599f, 0.278281f} },
    { {-0.316133f, -0.250676f, -0.153042f}, {0.000618f, 0.004926f, 0.999988f}, {0.403164f, 0.278280f} },
    { {-0.327908f, -0.180852f, -0.153379f}, {0.000618f, 0.004926f, 0.999988f}, {0.386847f, 0.278256f} },
    { {-0.073318f, 0.032356f, -0.236096f}, {-0.985610f, 0.059951f, -0.158044f}, {0.336961f, 0.303106f} },
    { {-0.357520f, 0.196012f, -0.076358f}, {0.000347f, -0.034128f, -0.999417f}, {0.298837f, 0.254076f} },
    { {-0.445620f, 0.022980f, -0.210994f}, {0.286386f, -0.376091f, -0.881214f}, {0.339171f, 0.295465f} },
    { {-0.265566f, -0.231907f, -0.206699f}, {0.079355f, 0.083122f, 0.993375f}, {0.398738f, 0.294616f} },
    { {-0.321901f, -0.228611f, -0.202475f}, {0.079355f, 0.083122f, 0.993375f}, {0.397971f, 0.293321f} },
    { {-0.376177f, -0.206796f, -0.199964f}, {0.079355f, 0.083122f, 0.993375f}, {0.392875f, 0.292516f} },
    { {-0.265528f, -0.207076f, -0.153313f}, {0.021414f, 0.906508f, -0.421645f}, {0.392975f, 0.278284f} },
    { {-0.321901f, -0.228611f, -0.202475f}, {0.021414f, 0.906508f, -0.421645f}, {0.397971f, 0.293321f} },
    { {-0.265566f, -0.231907f, -0.206699f}, {0.021414f, 0.906508f, -0.421645f}, {0.398738f, 0.294616f} },
    { {-0.304953f, -0.002822f, -0.145803f}, {0.116057f, 0.715127f, 0.689293f}, {0.345250f, 0.275623f} },
    { {-0.351423f, 0.004119f, -0.145180f}, {-0.088758f, 0.955099f, 0.282679f}, {0.343628f, 0.275420f} },
    { {-0.306258f, 0.005393f, -0.154106f}, {0.055094f, 0.910961f, 0.408798f}, {0.343324f, 0.278141f} },
    { {-0.304953f, -0.002822f, -0.145803f}, {-0.105338f, 0.698586f, 0.707730f}, {0.345250f, 0.275623f} },
    { {-0.306258f, 0.005393f, -0.154106f}, {-0.105338f, 0.698586f, 0.707730f}, {0.343324f, 0.278141f} },
    { {-0.276089f, 0.010509f, -0.154666f}, {-0.105338f, 0.698586f, 0.707730f}, {0.342128f, 0.278302f} },
    { {-0.413178f, 0.007348f, -0.144208f}, {-0.387990f, 0.918138f, -0.080541f}, {0.342874f, 0.275118f} },
    { {-0.327908f, -0.180852f, -0.153379f}, {-0.050017f, -0.035562f, 0.998115f}, {0.386847f, 0.278256f} },
    { {-0.308440f, -0.169474f, -0.151998f}, {-0.050017f, -0.035562f, 0.998115f}, {0.384189f, 0.277814f} },
    { {-0.284286f, -0.235418f, -0.153137f}, {-0.050017f, -0.035562f, 0.998115f}, {0.399599f, 0.278281f} },
    { {-0.308820f, -0.168997f, -0.143898f}, {0.350696f, -0.793759f, 0.496951f}, {0.384084f, 0.275342f} },
    { {-0.327908f, -0.180852f, -0.153379f}, {0.218614f, -0.799460f, 0.559528f}, {0.386847f, 0.278256f} },
    { {-0.362001f, -0.178847f, -0.144462f}, {-0.108455f, -0.783810f, 0.611457f}, {0.386385f, 0.275532f} },
    { {-0.086264f, -0.177440f, -0.063908f}, {-0.315737f, -0.791339f, 0.523539f}, {0.386117f, 0.250954f} },
    { {-0.033987f, -0.188497f, -0.063120f}, {-0.178791f, -0.805021f, 0.565663f}, {0.388701f, 0.250734f} },
    { {-0.377300f, -0.050645f, -0.215927f}, {0.148492f, 0.034244f, 0.988321f}, {0.356372f, 0.297103f} },
    { {-0.388453f, -0.012608f, -0.215569f}, {0.148492f, 0.034244f, 0.988321f}, {0.347484f, 0.296925f} },
    { {-0.274363f, 0.005275f, -0.233330f}, {0.148492f, 0.034244f, 0.988321f}, {0.343292f, 0.302311f} },
    { {-0.376057f, -0.189432f, -0.142985f}, {0.130969f, 0.961610f, -0.241151f}, {0.388860f, 0.275101f} },
    { {-0.265528f, -0.207076f, -0.153313f}, {0.130969f, 0.961610f, -0.241151f}, {0.392975f, 0.278284f} },
    { {-0.265527f, -0.204463f, -0.142892f}, {0.130969f, 0.961610f, -0.241151f}, {0.392372f, 0.275100f} },
    { {-0.265527f, -0.204463f, -0.142892f}, {-0.860855f, -0.493557f, 0.123818f}, {0.392372f, 0.275100f} },
    { {-0.265528f, -0.207076f, -0.153313f}, {-0.860855f, -0.493557f, 0.123818f}, {0.392975f, 0.278284f} },
    { {-0.296800f, -0.150129f, -0.143741f}, {-0.860855f, -0.493557f, 0.123818f}, {0.379675f, 0.275260f} },
    { {-0.409373f, -0.154060f, -0.144414f}, {0.388869f, -0.146589f, 0.909556f}, {0.380593f, 0.275473f} },
    { {-0.394419f, -0.167312f, -0.152943f}, {0.388869f, -0.146589f, 0.909556f}, {0.383683f, 0.278099f} },
    { {-0.417643f, -0.230320f, -0.153169f}, {0.388869f, -0.146589f, 0.909556f}, {0.398407f, 0.278282f} },
    { {-0.394419f, -0.167312f, -0.152943f}, {-0.403247f, -0.771646f, 0.491889f}, {0.383683f, 0.278099f} },
    { {-0.409373f, -0.154060f, -0.144414f}, {-0.403247f, -0.771646f, 0.491889f}, {0.380593f, 0.275473f} },
    { {0.057942f, 0.023749f, -0.230718f}, {0.612746f, 0.678287f, -0.405549f}, {0.338977f, 0.301481f} },
    { {-0.265819f, -0.006309f, -0.234307f}, {0.116397f, 0.002102f, 0.993201f}, {0.345998f, 0.302630f} },
    { {-0.376177f, -0.206796f, -0.199964f}, {0.194302f, 0.060757f, 0.979058f}, {0.392875f, 0.292516f} },
    { {-0.274363f, 0.005275f, -0.233330f}, {0.194302f, 0.060757f, 0.979058f}, {0.343292f, 0.302311f} },
    { {-0.265819f, -0.006309f, -0.234307f}, {0.194302f, 0.060757f, 0.979058f}, {0.345998f, 0.302630f} },
    { {-0.376060f, -0.191623f, -0.153409f}, {0.135731f, 0.969564f, -0.203770f}, {0.389364f, 0.278285f} },
    { {-0.265528f, -0.207076f, -0.153313f}, {0.135731f, 0.969564f, -0.203770f}, {0.392975f, 0.278284f} },
    { {-0.376057f, -0.189432f, -0.142985f}, {0.135731f, 0.969564f, -0.203770f}, {0.388860f, 0.275101f} },
    { {-0.377092f, -0.094560f, -0.084299f}, {0.130506f, 0.093087f, -0.987068f}, {0.366734f, 0.257025f} },
    { {-0.376258f, -0.165774f, -0.090904f}, {0.130506f, 0.093087f, -0.987068f}, {0.383370f, 0.259169f} },
    { {-0.265566f, -0.171411f, -0.076801f}, {0.130506f, 0.093087f, -0.987068f}, {0.384698f, 0.254877f} },
    { {-0.453814f, 0.157152f, -0.102133f}, {-0.680376f, 0.693625f, 0.236587f}, {0.307898f, 0.262010f} },
    { {-0.029127f, -0.137654f, -0.023694f}, {-0.558987f, -0.076403f, 0.825649f}, {0.376849f, 0.238613f} },
    { {-0.001224f, 0.016743f, -0.320816f}, {0.487420f, -0.694127f, -0.529726f}, {0.340546f, 0.328981f} },
    { {-0.351744f, 0.003720f, -0.154077f}, {-0.273723f, 0.961098f, -0.036967f}, {0.343714f, 0.278135f} },
    { {-0.393151f, -0.013386f, -0.144716f}, {-0.182260f, 0.976517f, -0.114877f}, {0.347719f, 0.275310f} },
    { {-0.276089f, 0.010509f, -0.154666f}, {-0.424720f, 0.905060f, -0.021880f}, {0.342128f, 0.278302f} },
    { {-0.276086f, 0.010762f, -0.144230f}, {-0.424720f, 0.905060f, -0.021880f}, {0.342076f, 0.275118f} },
    { {-0.304953f, -0.002822f, -0.145803f}, {-0.424720f, 0.905060f, -0.021880f}, {0.345250f, 0.275623f} },
    { {-0.276086f, 0.010762f, -0.144230f}, {0.123499f, -0.992053f, 0.024057f}, {0.342076f, 0.275118f} },
    { {-0.276089f, 0.010509f, -0.154666f}, {0.123499f, -0.992053f, 0.024057f}, {0.342128f, 0.278302f} },
    { {-0.395317f, -0.004332f, -0.154573f}, {0.123499f, -0.992053f, 0.024057f}, {0.345596f, 0.278301f} },
    { {-0.504276f, 0.082320f, -0.102459f}, {-0.793855f, 0.397156f, 0.460502f}, {0.325385f, 0.262245f} },
    { {-0.457545f, -0.014422f, -0.144990f}, {-0.780164f, 0.624976f, -0.027368f}, {0.347961f, 0.275396f} },
    { {-0.459546f, -0.017294f, -0.153551f}, {-0.512146f, 0.858481f, -0.026780f}, {0.348626f, 0.278013f} },
    { {-0.450766f, -0.085272f, -0.143928f}, {-0.962990f, -0.088332f, 0.254653f}, {0.364518f, 0.275200f} },
    { {-0.266470f, -0.092485f, -0.067209f}, {0.062762f, -0.123706f, -0.990332f}, {0.366261f, 0.251808f} },
    { {-0.265819f, 0.004954f, -0.079340f}, {0.062762f, -0.123706f, -0.990332f}, {0.343482f, 0.255332f} },
    { {-0.387948f, -0.004909f, -0.085848f}, {0.062762f, -0.123706f, -0.990332f}, {0.345782f, 0.257335f} },
    { {-0.392634f, -0.013542f, -0.153635f}, {-0.191392f, 0.981107f, -0.028263f}, {0.347749f, 0.278031f} },
    { {-0.376258f, -0.165774f, -0.090904f}, {0.217160f, 0.889055f, -0.403017f}, {0.383370f, 0.259169f} },
    { {-0.376057f, -0.189432f, -0.142985f}, {0.217160f, 0.889055f, -0.403017f}, {0.388860f, 0.275101f} },
    { {-0.321819f, -0.202643f, -0.142903f}, {0.217160f, 0.889055f, -0.403017f}, {0.391947f, 0.275100f} },
    { {-0.265819f, 0.004954f, -0.079340f}, {0.093236f, -0.942270f, -0.321611f}, {0.343482f, 0.255332f} },
    { {-0.394851f, -0.001591f, -0.097569f}, {0.093236f, -0.942270f, -0.321611f}, {0.344998f, 0.260905f} },
    { {-0.387948f, -0.004909f, -0.085848f}, {0.093236f, -0.942270f, -0.321611f}, {0.345782f, 0.257335f} },
    { {-0.376060f, -0.191623f, -0.153409f}, {0.216110f, 0.879333f, -0.424346f}, {0.389364f, 0.278285f} },
    { {-0.321901f, -0.228611f, -0.202475f}, {0.216110f, 0.879333f, -0.424346f}, {0.397971f, 0.293321f} },
    { {-0.321963f, -0.204878f, -0.153327f}, {0.216110f, 0.879333f, -0.424346f}, {0.392462f, 0.278284f} },
    { {-0.044053f, -0.306467f, -0.279873f}, {-0.530541f, -0.645293f, -0.549657f}, {0.416107f, 0.317075f} },
    { {-0.296800f, -0.150129f, -0.143741f}, {0.841013f, -0.536339f, 0.070975f}, {0.379675f, 0.275260f} },
    { {-0.308440f, -0.169474f, -0.151998f}, {0.688913f, -0.720982f, 0.074731f}, {0.384189f, 0.277814f} },
    { {-0.414945f, 0.006562f, -0.222337f}, {-0.559992f, 0.828455f, 0.008419f}, {0.342999f, 0.298955f} },
    { {-0.398160f, 0.017983f, -0.229726f}, {-0.135696f, 0.671009f, 0.728926f}, {0.340325f, 0.301188f} },
    { {-0.504276f, 0.082726f, -0.195417f}, {-0.828647f, 0.410556f, -0.380511f}, {0.325221f, 0.290604f} },
    { {0.034123f, -0.120314f, -0.265627f}, {-0.999779f, -0.021007f, -0.000761f}, {0.372616f, 0.312392f} },
    { {0.031995f, -0.026682f, -0.054915f}, {-0.999779f, -0.021007f, -0.000761f}, {0.350893f, 0.247938f} },
    { {0.034067f, -0.125223f, -0.057157f}, {-0.999779f, -0.021007f, -0.000761f}, {0.373919f, 0.248800f} },
    { {0.018241f, -0.278279f, -0.245512f}, {-0.987591f, 0.151774f, -0.040349f}, {0.409545f, 0.306541f} },
    { {0.034067f, -0.125223f, -0.057157f}, {-0.987591f, 0.151774f, -0.040349f}, {0.373919f, 0.248800f} },
    { {0.026021f, -0.182017f, -0.073854f}, {-0.987591f, 0.151774f, -0.040349f}, {0.387179f, 0.253997f} },
    { {0.030316f, -0.206293f, -0.267930f}, {-0.987397f, 0.152804f, -0.041202f}, {0.392706f, 0.313250f} },
    { {0.034123f, -0.120314f, -0.265627f}, {-0.999022f, 0.044207f, 0.000775f}, {0.372616f, 0.312392f} },
    { {0.034067f, -0.125223f, -0.057157f}, {-0.999022f, 0.044207f, 0.000775f}, {0.373919f, 0.248800f} },
    { {0.030316f, -0.206293f, -0.267930f}, {-0.999022f, 0.044207f, 0.000775f}, {0.392706f, 0.313250f} },
    { {0.030465f, -0.049706f, -0.253229f}, {-0.998433f, -0.054179f, 0.013993f}, {0.356125f, 0.308481f} },
    { {0.031995f, -0.026682f, -0.054915f}, {-0.998433f, -0.054179f, 0.013993f}, {0.350893f, 0.247938f} },
    { {0.034123f, -0.120314f, -0.265627f}, {-0.998433f, -0.054179f, 0.013993f}, {0.372616f, 0.312392f} },
    { {0.026983f, 0.031146f, -0.075404f}, {-0.996622f, -0.080346f, 0.017017f}, {0.337364f, 0.254084f} },
    { {0.031995f, -0.026682f, -0.054915f}, {-0.996622f, -0.080346f, 0.017017f}, {0.350893f, 0.247938f} },
    { {0.030465f, -0.049706f, -0.253229f}, {-0.996622f, -0.080346f, 0.017017f}, {0.356125f, 0.308481f} },
    { {0.026983f, 0.031146f, -0.075404f}, {-0.998272f, -0.058350f, 0.006983f}, {0.337364f, 0.254084f} },
    { {0.026555f, 0.021124f, -0.220277f}, {-0.998272f, -0.058350f, 0.006983f}, {0.339598f, 0.298300f} },
    { {0.026983f, 0.031146f, -0.075404f}, {-0.995518f, -0.094100f, 0.009448f}, {0.337364f, 0.254084f} },
    { {0.026555f, 0.021124f, -0.220277f}, {-0.995518f, -0.094100f, 0.009448f}, {0.339598f, 0.298300f} },
    { {0.016484f, 0.127873f, -0.218300f}, {-0.995518f, -0.094100f, 0.009448f}, {0.314653f, 0.297504f} },
    { {0.016614f, 0.131486f, -0.083174f}, {-0.797517f, -0.603060f, 0.016892f}, {0.313910f, 0.256273f} },
    { {0.016484f, 0.127873f, -0.218300f}, {-0.797517f, -0.603060f, 0.016892f}, {0.314653f, 0.297504f} },
    { {-0.011681f, 0.165687f, -0.198050f}, {-0.797517f, -0.603060f, 0.016892f}, {0.305832f, 0.291257f} },
    { {0.016614f, 0.131486f, -0.083174f}, {-0.785681f, -0.618561f, 0.009362f}, {0.313910f, 0.256273f} },
    { {-0.011681f, 0.165687f, -0.198050f}, {-0.785681f, -0.618561f, 0.009362f}, {0.305832f, 0.291257f} },
    { {-0.011636f, 0.167009f, -0.106941f}, {-0.785681f, -0.618561f, 0.009362f}, {0.305591f, 0.263459f} },
    { {0.016614f, 0.131486f, -0.083174f}, {-0.994725f, -0.102511f, 0.003697f}, {0.313910f, 0.256273f} },
};

WORD g_tind19[] = 
{
    2, 1, 0,    5, 4, 3,    8, 7, 6,    11, 10, 9,    14, 13, 12,
    17, 16, 15,    20, 19, 18,    23, 22, 21,    26, 25, 24,    27, 23, 21,
    30, 29, 28,    33, 32, 31,    36, 35, 34,    39, 38, 37,    35, 36, 40,
    41, 1, 2,    44, 43, 42,    47, 46, 45,    50, 49, 48,    53, 52, 51,
    56, 55, 54,    59, 58, 57,    61, 60, 16,    64, 63, 62,    67, 66, 65,
    70, 69, 68,    73, 72, 71,    76, 75, 74,    79, 78, 77,    81, 68, 80,
    84, 83, 82,    87, 86, 85,    90, 89, 88,    92, 7, 91,    95, 94, 93,
    98, 97, 96,    99, 62, 63,    102, 101, 100,    103, 56, 54,    20, 105, 104,
    102, 106, 101,    36, 107, 40,    110, 109, 108,    113, 112, 111,    9, 10, 114,
    117, 116, 115,    120, 119, 118,    34, 79, 77,    123, 122, 121,    126, 125, 124,
    46, 127, 45,    130, 129, 128,    133, 132, 131,    136, 135, 134,    139, 138, 137,
    142, 141, 140,    145, 144, 143,    148, 147, 146,    44, 42, 149,    111, 112, 150,
    153, 152, 151,    156, 155, 154,    159, 158, 157,    162, 161, 160,    13, 163, 12,
    166, 165, 164,    168, 167, 2,    167, 170, 169,    173, 172, 171,    176, 175, 174,
    179, 178, 177,    181, 44, 180,    66, 182, 65,    185, 184, 183,    188, 187, 186,
    189, 14, 12,    59, 57, 190,    67, 192, 191,    69, 194, 193,    197, 196, 195,
    94, 95, 30,    200, 199, 198,    203, 202, 201,    204, 117, 115,    131, 132, 205,
    207, 206, 26,    210, 209, 208,    212, 170, 211,    215, 214, 213,    218, 217, 216,
    160, 219, 162,    119, 120, 220,    223, 222, 221,    226, 225, 224,    229, 228, 227,
    232, 231, 230,    234, 162, 233,    166, 34, 165,    237, 236, 235,    11, 238, 10,
    23, 239, 55,    126, 240, 125,    12, 163, 241,    242, 38, 39,    4, 244, 243,
    77, 246, 245,    249, 248, 247,    46, 154, 127,    156, 154, 250,    253, 252, 251,
    255, 254, 253,    52, 53, 256,    258, 14, 257,    260, 259, 99,    126, 124, 261,
    24, 25, 261,    262, 133, 131,    184, 263, 183,    266, 265, 264,    44, 181, 43,
    95, 196, 197,    269, 268, 267,    271, 268, 270,    273, 272, 67,    276, 275, 274,
    279, 278, 277,    83, 84, 280,    283, 282, 281,    286, 285, 284,    152, 153, 287,
    288, 105, 20,    290, 288, 289,    293, 292, 291,    27, 21, 294,    93, 33, 31,
    91, 113, 111,    296, 295, 34,    34, 295, 165,    251, 17, 15,    246, 297, 245,
    300, 299, 298,    303, 302, 301,    306, 305, 304,    309, 308, 307,    33, 310, 32,
    237, 311, 236,    314, 313, 312,    312, 315, 9,    255, 253, 316,    276, 316, 275,
    167, 168, 64,    317, 170, 167,    70, 68, 81,    130, 128, 318,    320, 27, 319,
    125, 57, 58,    17, 251, 252,    254, 255, 41,    244, 137, 243,    214, 321, 213,
    324, 323, 322,    326, 325, 324,    67, 65, 192,    129, 130, 327,    290, 328, 288,
    211, 62, 329,    331, 330, 212,    261, 124, 332,    59, 333, 58,    336, 335, 334,
    233, 231, 232,    30, 28, 94,    296, 34, 77,    296, 77, 245,    279, 277, 337,
    337, 259, 63,    63, 102, 100,    63, 64, 168,    279, 274, 338,    100, 274, 279,
    134, 135, 339,    222, 74, 221,    340, 107, 36,    164, 340, 166,    343, 342, 341,
    220, 120, 344,    103, 25, 26,    206, 208, 26,    180, 324, 325,    207, 345, 206,
    271, 270, 346,    61, 248, 249,    347, 330, 331,    350, 349, 348,    300, 143, 351,
    352, 1, 41,    101, 106, 353,    54, 240, 126,    261, 25, 126,    356, 355, 354,
    307, 357, 309,    360, 359, 358,    362, 360, 361,    23, 269, 267,    208, 209, 56,
    15, 364, 363,    60, 61, 249,    367, 366, 365,    370, 369, 368,    169, 371, 2,
    169, 2, 372,    95, 197, 30,    23, 267, 22,    374, 288, 373,    14, 189, 257,
    186, 187, 52,    93, 230, 33,    232, 230, 93,    68, 375, 80,    68, 69, 376,
    378, 213, 377,    74, 136, 378,    379, 273, 67,    380, 193, 194,    233, 6, 231,
    6, 7, 92,    69, 70, 381,    69, 381, 194,    114, 10, 113,    91, 7, 113,
    240, 239, 382,    320, 382, 27,    46, 250, 154,    263, 133, 262,    219, 8, 6,
    314, 312, 9,    383, 313, 314,    319, 27, 294,    182, 184, 65,    138, 139, 384,
    385, 329, 62,    386, 12, 241,    12, 387, 189,    75, 221, 74,    119, 3, 118,
    17, 388, 169,    17, 254, 388,    391, 390, 389,    394, 393, 392,    127, 24, 261,
    261, 332, 127,    131, 205, 395,    81, 318, 70,    10, 238, 396,    236, 311, 397,
    64, 62, 211,    170, 317, 211,    127, 332, 45,    47, 45, 333,    56, 23, 55,
    269, 23, 56,    373, 288, 328,    353, 106, 352,    276, 255, 316,    310, 311, 32,
    150, 397, 311,    400, 399, 398,    207, 26, 154,    20, 18, 401,    132, 362, 205,
    402, 234, 28,    338, 278, 279,    163, 13, 403,    406, 405, 404,    409, 408, 407,
    360, 358, 116,    116, 358, 379,    57, 125, 320,    190, 57, 320,    80, 411, 410,
    327, 410, 129,    209, 269, 56,    346, 270, 209,    230, 111, 33,    33, 111, 150,
    412, 333, 59,    206, 210, 208,    206, 345, 346,    413, 249, 247,    222, 223, 245,
    416, 415, 414,    92, 91, 230,    230, 91, 111,    419, 418, 417,    357, 307, 420,
    277, 421, 259,    259, 337, 277,    124, 58, 333,    124, 125, 58,    3, 422, 118,
    425, 424, 423,    426, 20, 401,    290, 289, 426,    149, 324, 44,    44, 324, 180,
    214, 427, 321,    385, 331, 329,    427, 428, 321,    377, 428, 378,    15, 363, 251,
    363, 253, 251,    153, 151, 429,    432, 431, 430,    181, 433, 43,    95, 93, 31,
    61, 16, 170,    212, 330, 170,    233, 162, 6,    162, 219, 6,    54, 55, 240,
    55, 239, 240,    411, 80, 376,    69, 193, 376,    434, 267, 268,    374, 435, 288,
    436, 290, 426,    185, 183, 437,    437, 262, 131,    257, 189, 438,    189, 387, 438,
    16, 60, 15,    249, 15, 60,    113, 10, 112,    10, 396, 397,    233, 232, 94,
    94, 232, 93,    204, 115, 439,    439, 379, 440,    326, 324, 322,    443, 442, 441,
    41, 2, 371,    41, 388, 254,    358, 273, 379,    25, 54, 126,    103, 54, 25,
    446, 445, 444,    99, 259, 447,    314, 9, 8,    8, 9, 114,    168, 2, 0,
    63, 168, 102,    208, 56, 103,    208, 103, 26,    326, 448, 325,    449, 185, 437,
    192, 65, 449,    223, 221, 450,    453, 452, 451,    213, 136, 215,    213, 378, 136,
    361, 360, 204,    361, 204, 439,    7, 8, 114,    7, 114, 113,    243, 137, 138,
    160, 161, 454,    100, 279, 337,    337, 63, 100,    455, 64, 211,    317, 167, 64,
    154, 24, 127,    154, 26, 24,    458, 457, 456,    75, 459, 221,    221, 459, 450,
    145, 201, 144,    149, 42, 460,    32, 311, 237,    28, 234, 233,    28, 233, 94,
    182, 461, 184,    464, 463, 462,    467, 466, 465,    130, 81, 327,    318, 81, 130,
    470, 469, 468,    473, 472, 471,    209, 270, 269,    268, 269, 270,    474, 181, 180,
    477, 476, 475,    480, 479, 478,    51, 39, 53,    249, 364, 15,    364, 249, 413,
    164, 241, 340,    164, 386, 241,    362, 359, 360,    47, 333, 412,    482, 258, 481,
    421, 447, 259,    485, 484, 483,    190, 320, 319,    29, 402, 28,    345, 271, 346,
    20, 104, 19,    387, 12, 386,    51, 242, 39,    135, 74, 222,    135, 136, 74,
    488, 487, 486,    491, 490, 489,    257, 481, 258,    257, 438, 481,    332, 124, 333,
    332, 333, 45,    346, 210, 206,    346, 209, 210,    378, 76, 74,    4, 5, 244,
    125, 382, 320,    240, 382, 125,    170, 16, 169,    16, 17, 169,    136, 134, 215,
    347, 248, 330,    494, 493, 492,    496, 495, 480,    340, 241, 163,    403, 340, 163,
    275, 338, 274,    107, 340, 403,    397, 396, 236,    235, 236, 396,    34, 35, 79,
    253, 363, 497,    360, 117, 204,    117, 360, 116,    193, 380, 411,    411, 376, 193,
    205, 362, 361,    395, 205, 361,    330, 61, 170,    61, 330, 248,    6, 92, 231,
    231, 92, 230,    435, 374, 498,    501, 500, 499,    504, 503, 502,    323, 324, 149,
    238, 235, 396,    101, 353, 274,    101, 274, 100,    255, 352, 41,    255, 353, 352,
    454, 383, 160,    160, 383, 314,    507, 506, 505,    256, 186, 52,    150, 311, 310,
    33, 150, 310,    167, 372, 2,    372, 167, 169,    321, 377, 213,    428, 377, 321,
    183, 262, 437,    183, 263, 262,    131, 395, 508,    508, 395, 361,    300, 351, 299,
    252, 253, 254,    254, 17, 252,    65, 185, 449,    65, 184, 185,    402, 161, 234,
    234, 161, 162,    13, 14, 509,    509, 14, 258,    363, 364, 510,    78, 246, 77,
    296, 245, 223,    223, 295, 296,    469, 470, 511,    469, 511, 512,    27, 239, 23,
    239, 27, 382,    1, 106, 0,    1, 352, 106,    379, 67, 440,    440, 67, 191,
    34, 166, 36,    166, 340, 36,    515, 514, 513,    518, 517, 516,    437, 131, 519,
    519, 131, 508,    410, 327, 80,    81, 80, 327,    272, 66, 67,    512, 521, 520,
    520, 521, 522,    288, 20, 289,    20, 426, 289,    315, 11, 9,    525, 524, 523,
    512, 511, 526,    512, 526, 521,    4, 422, 3,    317, 64, 455,    317, 455, 211,
    371, 388, 41,    388, 371, 169,    529, 528, 527,    532, 531, 530,    112, 397, 150,
    397, 112, 10,    353, 276, 274,    255, 276, 353,    211, 329, 212,    329, 331, 212,
    115, 379, 439,    115, 116, 379,    222, 339, 135,    222, 245, 339,    535, 534, 533,
    536, 331, 385,    347, 331, 536,    160, 314, 219,    314, 8, 219,    478, 538, 537,
    478, 479, 538,    102, 168, 0,    106, 102, 0,    375, 376, 80,    68, 376, 375,
    436, 426, 539,    540, 154, 155,    260, 99, 63,    63, 259, 260,    541, 192, 449,
    191, 192, 541,    544, 543, 542,    547, 546, 545,    545, 546, 548,    551, 550, 549,
    554, 553, 552,    557, 556, 555,    559, 552, 558,    562, 561, 560,    565, 564, 563,
    568, 567, 566,    569, 562, 560,
};

D3DMATRIX g_tmat20 = 
{
    -0.215924f, 0.968738f, -0.122163f, 0.000000f, 
    0.350036f, -0.039999f, -0.935882f, 0.000000f, 
    -0.911511f, -0.244841f, -0.330456f, 0.000000f, 
    2.276827f, -2.612644f, 3.825330f, 1.000000f, 
};

// Mesh #20 Tris:300 Verts:372
MODELVERT g_tmesh20[] = 
{
    { {0.073760f, 0.263503f, -0.066040f}, {0.800296f, -0.000000f, -0.599605f}, {0.363763f, 0.234466f} },
    { {0.095912f, 0.263503f, -0.023833f}, {0.987277f, -0.000000f, -0.159008f}, {0.363763f, 0.261591f} },
    { {0.095912f, 0.422301f, -0.023833f}, {0.948085f, -0.000000f, -0.318016f}, {0.395114f, 0.261591f} },
    { {-0.089309f, 0.115728f, 0.000000f}, {-0.996642f, 0.000000f, -0.081884f}, {0.385569f, 0.276908f} },
    { {-0.079169f, 0.186304f, -0.041139f}, {-0.920536f, 0.000000f, -0.390659f}, {0.371635f, 0.250469f} },
    { {-0.089309f, 0.186304f, 0.000000f}, {-0.983199f, 0.064881f, -0.170617f}, {0.371635f, 0.276908f} },
    { {-0.100374f, 0.263503f, 0.000000f}, {-0.996642f, 0.000000f, -0.081884f}, {0.356394f, 0.276908f} },
    { {-0.088967f, 0.263503f, -0.046282f}, {-0.885456f, 0.000000f, -0.464723f}, {0.356394f, 0.247164f} },
    { {-0.088967f, 0.422301f, -0.046282f}, {-0.885456f, 0.000000f, -0.464723f}, {0.325043f, 0.247164f} },
    { {0.065477f, 0.115728f, 0.058703f}, {0.833447f, -0.059515f, 0.549385f}, {0.334588f, 0.314635f} },
    { {0.065477f, 0.186304f, 0.058703f}, {0.750375f, 0.123986f, 0.649280f}, {0.348522f, 0.314635f} },
    { {0.085168f, 0.186304f, 0.021185f}, {0.968446f, -0.071652f, 0.238701f}, {0.348522f, 0.290523f} },
    { {0.034531f, 0.263503f, -0.093118f}, {0.354605f, 0.000000f, -0.935016f}, {0.335913f, 0.280537f} },
    { {0.073760f, 0.422301f, -0.066040f}, {0.691698f, 0.000000f, -0.722187f}, {0.310125f, 0.311413f} },
    { {0.034531f, 0.422301f, -0.093118f}, {0.354605f, 0.000000f, -0.935016f}, {0.335913f, 0.311413f} },
    { {-0.012789f, 0.263503f, 0.098864f}, {-0.201418f, -0.000000f, 0.979505f}, {0.353138f, 0.280537f} },
    { {-0.057358f, 0.422301f, 0.081961f}, {-0.498768f, -0.000000f, 0.866735f}, {0.323841f, 0.311413f} },
    { {-0.012789f, 0.422301f, 0.098864f}, {-0.038846f, -0.000000f, 0.999245f}, {0.353138f, 0.311413f} },
    { {-0.069700f, -0.015294f, 0.043077f}, {-0.801615f, -0.334614f, 0.495426f}, {0.411436f, 0.304592f} },
    { {-0.054666f, -0.061563f, 0.013009f}, {-0.630569f, -0.770596f, 0.092546f}, {0.420571f, 0.285269f} },
    { {-0.075442f, -0.032967f, 0.013009f}, {-0.975035f, -0.215686f, -0.052790f}, {0.414925f, 0.285269f} },
    { {0.015267f, 0.046985f, -0.067134f}, {0.187592f, 0.577351f, -0.794654f}, {0.348576f, 0.238438f} },
    { {0.036084f, 0.061562f, -0.043077f}, {0.284738f, 0.776724f, -0.561804f}, {0.334892f, 0.241272f} },
    { {-0.009291f, 0.028596f, -0.077740f}, {-0.162460f, 0.500000f, -0.850651f}, {0.364719f, 0.234862f} },
    { {-0.079169f, 0.115728f, 0.041139f}, {-0.920536f, 0.000000f, 0.390658f}, {0.385569f, 0.303347f} },
    { {0.030607f, 0.115728f, -0.082772f}, {0.566516f, -0.073784f, -0.820741f}, {0.338492f, 0.251804f} },
    { {0.085168f, 0.115728f, -0.021185f}, {0.965763f, -0.103148f, -0.238039f}, {0.315570f, 0.251804f} },
    { {0.065477f, 0.186304f, -0.058703f}, {0.746587f, -0.071652f, -0.661418f}, {0.315570f, 0.265527f} },
    { {-0.057358f, 0.263503f, 0.081961f}, {-0.633546f, -0.000000f, 0.773705f}, {0.323841f, 0.280537f} },
    { {0.085168f, 0.186304f, -0.021185f}, {0.998012f, 0.026330f, 0.057268f}, {0.348522f, 0.263293f} },
    { {0.054434f, 0.195303f, 0.048919f}, {0.886093f, 0.073976f, 0.457566f}, {0.350298f, 0.308347f} },
    { {0.054434f, 0.254117f, 0.048919f}, {0.848309f, -0.021650f, 0.529058f}, {0.361910f, 0.308347f} },
    { {0.017332f, -0.053341f, 0.061660f}, {0.226265f, -0.694760f, 0.682724f}, {0.372938f, 0.218931f} },
    { {-0.036083f, -0.061563f, 0.043077f}, {-0.361890f, -0.771835f, 0.522788f}, {0.337826f, 0.217332f} },
    { {-0.015266f, -0.046985f, 0.067134f}, {-0.187592f, -0.577351f, 0.794654f}, {0.351510f, 0.220167f} },
    { {0.075443f, 0.032967f, -0.013009f}, {0.951056f, 0.309017f, -0.000000f}, {0.318249f, 0.268547f} },
    { {0.066453f, 0.048280f, 0.014164f}, {0.794654f, 0.577351f, 0.187592f}, {0.321272f, 0.286011f} },
    { {0.054666f, 0.061562f, -0.013009f}, {0.657107f, 0.736731f, -0.159493f}, {0.323894f, 0.268547f} },
    { {-0.088967f, 0.263503f, 0.046282f}, {-0.920536f, 0.000000f, 0.390658f}, {0.356394f, 0.306652f} },
    { {-0.100374f, 0.422301f, 0.000000f}, {-0.996642f, 0.000000f, 0.081883f}, {0.325043f, 0.276908f} },
    { {-0.088967f, 0.422301f, 0.046282f}, {-0.844430f, 0.000000f, 0.535667f}, {0.325043f, 0.306652f} },
    { {0.029400f, 0.432126f, -0.079588f}, {0.354188f, 0.048480f, -0.933917f}, {0.339286f, 0.313323f} },
    { {0.062929f, 0.571618f, -0.054417f}, {0.457063f, 0.593821f, -0.662170f}, {0.317245f, 0.340445f} },
    { {-0.011044f, 0.571618f, -0.082472f}, {-0.111610f, 0.377658f, -0.919194f}, {0.365872f, 0.340445f} },
    { {0.062929f, 0.432126f, -0.056445f}, {0.800265f, 0.008714f, -0.599583f}, {0.317245f, 0.313323f} },
    { {-0.011044f, 0.432126f, 0.084499f}, {-0.120512f, 0.020516f, 0.992500f}, {0.354285f, 0.313323f} },
    { {-0.049138f, 0.432126f, 0.070052f}, {-0.568024f, -0.011960f, 0.822925f}, {0.329244f, 0.313323f} },
    { {-0.049138f, 0.571618f, 0.072080f}, {-0.556278f, 0.202647f, 0.805908f}, {0.329244f, 0.340445f} },
    { {-0.057358f, 0.263503f, -0.081961f}, {-0.568065f, 0.000000f, -0.822984f}, {0.396316f, 0.280537f} },
    { {-0.012789f, 0.263503f, -0.098864f}, {-0.120537f, 0.000000f, -0.992709f}, {0.367018f, 0.280537f} },
    { {-0.012789f, 0.422301f, -0.098864f}, {-0.120537f, 0.000000f, -0.992709f}, {0.367018f, 0.311413f} },
    { {-0.011455f, 0.115728f, -0.087879f}, {-0.259534f, -0.059515f, -0.963898f}, {0.366141f, 0.251804f} },
    { {0.030607f, 0.186304f, -0.082772f}, {0.276852f, 0.000000f, -0.960913f}, {0.338492f, 0.265527f} },
    { {-0.011455f, 0.186304f, -0.087879f}, {-0.074918f, 0.139470f, -0.987388f}, {0.366141f, 0.265527f} },
    { {0.054666f, -0.061563f, -0.013009f}, {0.556558f, -0.828670f, 0.059568f}, {0.299586f, 0.268547f} },
    { {0.047399f, -0.053341f, 0.043077f}, {0.605328f, -0.637678f, 0.476387f}, {0.301209f, 0.304592f} },
    { {0.066453f, -0.048281f, 0.014164f}, {0.853535f, -0.505343f, -0.126908f}, {0.302208f, 0.286011f} },
    { {0.024325f, -0.017673f, -0.077740f}, {0.133958f, -0.137511f, -0.981400f}, {0.342621f, 0.225866f} },
    { {0.045375f, 0.032966f, -0.061660f}, {0.491606f, 0.211562f, -0.844728f}, {0.328784f, 0.235712f} },
    { {0.023215f, 0.052439f, -0.063281f}, {0.093459f, -0.950191f, -0.297326f}, {0.376805f, 0.236239f} },
    { {0.023215f, 0.052439f, 0.063281f}, {0.206823f, -0.862106f, 0.462599f}, {0.376805f, 0.317577f} },
    { {0.064928f, 0.052439f, 0.016197f}, {0.720362f, -0.631583f, 0.286673f}, {0.404226f, 0.287317f} },
    { {0.030607f, 0.115728f, 0.082772f}, {0.120208f, -0.073785f, 0.990003f}, {0.381665f, 0.251804f} },
    { {-0.051072f, 0.115728f, 0.072854f}, {-0.444919f, -0.059515f, 0.893591f}, {0.327973f, 0.251804f} },
    { {-0.011455f, 0.186304f, 0.087879f}, {-0.120227f, -0.071652f, 0.990157f}, {0.354015f, 0.265527f} },
    { {0.009292f, -0.028596f, 0.077740f}, {-0.026887f, -0.096628f, 0.994957f}, {0.367653f, 0.223742f} },
    { {-0.015266f, 0.046985f, 0.067134f}, {-0.224306f, 0.130844f, 0.965695f}, {0.351510f, 0.238438f} },
    { {0.009292f, 0.028596f, 0.077740f}, {0.158710f, 0.431695f, 0.887947f}, {0.367653f, 0.234862f} },
    { {-0.075442f, 0.032966f, 0.013009f}, {-0.976466f, 0.215468f, -0.009330f}, {0.401908f, 0.285269f} },
    { {-0.045375f, 0.032966f, 0.061660f}, {-0.638639f, 0.463998f, 0.613878f}, {0.401908f, 0.316535f} },
    { {-0.069700f, 0.015293f, 0.043077f}, {-0.832021f, 0.208140f, 0.514217f}, {0.405397f, 0.304592f} },
    { {0.030607f, 0.186304f, 0.082772f}, {0.180563f, 0.076817f, 0.980559f}, {0.381665f, 0.265527f} },
    { {-0.042691f, 0.254117f, 0.060712f}, {-0.494718f, 0.104507f, 0.862747f}, {0.333482f, 0.278712f} },
    { {0.025375f, 0.254117f, 0.068977f}, {0.332122f, 0.221817f, 0.916783f}, {0.378225f, 0.278712f} },
    { {-0.042691f, 0.254117f, -0.060712f}, {-0.539344f, 0.031936f, -0.841480f}, {0.358247f, 0.237890f} },
    { {-0.066105f, 0.254117f, -0.034283f}, {-0.969747f, 0.129642f, -0.206840f}, {0.358247f, 0.254875f} },
    { {-0.076154f, 0.432126f, 0.039557f}, {-0.885104f, 0.028183f, 0.464539f}, {0.323103f, 0.302330f} },
    { {-0.085904f, 0.432126f, 0.000000f}, {-0.996641f, 0.001190f, -0.081884f}, {0.323103f, 0.276908f} },
    { {-0.085904f, 0.571618f, 0.002027f}, {-0.453128f, 0.884421f, 0.111686f}, {0.295564f, 0.278211f} },
    { {-0.049138f, 0.571618f, 0.072080f}, {-0.556278f, 0.202647f, 0.805908f}, {0.295564f, 0.323232f} },
    { {-0.009291f, -0.028596f, -0.077740f}, {-0.233843f, -0.517312f, -0.823229f}, {0.364719f, 0.223742f} },
    { {-0.047399f, -0.053341f, -0.043077f}, {-0.430655f, -0.703202f, -0.565724f}, {0.389769f, 0.218931f} },
    { {-0.008040f, -0.081937f, -0.013009f}, {-0.267124f, -0.892032f, -0.364587f}, {0.363897f, 0.213371f} },
    { {0.036084f, -0.061563f, -0.043077f}, {0.653804f, -0.624794f, -0.426818f}, {0.299586f, 0.249224f} },
    { {-0.054666f, 0.061562f, 0.013009f}, {-0.632532f, 0.774531f, 0.002113f}, {0.396262f, 0.285269f} },
    { {-0.065377f, 0.028596f, -0.043077f}, {-0.684292f, 0.560474f, -0.466491f}, {0.402771f, 0.249224f} },
    { {-0.008040f, 0.081937f, -0.013009f}, {-0.297455f, 0.821295f, -0.486822f}, {0.392240f, 0.268547f} },
    { {0.025383f, 0.078120f, -0.014164f}, {0.234711f, 0.945393f, 0.226148f}, {0.366830f, 0.245234f} },
    { {0.047400f, 0.053341f, 0.043077f}, {0.267967f, 0.841796f, 0.468587f}, {0.392703f, 0.239674f} },
    { {-0.036083f, 0.061562f, 0.043077f}, {-0.019997f, 0.861613f, 0.507171f}, {0.337826f, 0.241272f} },
    { {-0.068464f, 0.052439f, 0.000000f}, {-0.708813f, -0.700798f, 0.080411f}, {0.398064f, 0.276908f} },
    { {-0.039231f, 0.052439f, -0.055699f}, {-0.516681f, -0.415604f, -0.748541f}, {0.398064f, 0.241112f} },
    { {-0.066105f, 0.111253f, -0.034283f}, {-0.803879f, -0.097307f, -0.586779f}, {0.386452f, 0.254875f} },
    { {0.023215f, 0.052439f, -0.063281f}, {0.093459f, -0.950191f, -0.297326f}, {0.343351f, 0.239498f} },
    { {0.064928f, 0.052439f, -0.016197f}, {0.808469f, -0.236658f, -0.538860f}, {0.325827f, 0.239498f} },
    { {0.025375f, 0.111253f, -0.068977f}, {0.640095f, -0.097307f, -0.762109f}, {0.341931f, 0.250934f} },
    { {0.070843f, 0.195303f, -0.017654f}, {0.891653f, 0.165001f, -0.421579f}, {0.350298f, 0.265562f} },
    { {0.070843f, 0.254117f, 0.017654f}, {0.983408f, 0.143336f, -0.111192f}, {0.361910f, 0.288254f} },
    { {0.054434f, 0.254117f, -0.048919f}, {0.748511f, -0.000000f, -0.663123f}, {0.361910f, 0.245469f} },
    { {-0.009676f, 0.195303f, -0.073233f}, {0.132272f, 0.073776f, -0.988464f}, {0.364972f, 0.267276f} },
    { {0.054434f, 0.195303f, -0.048919f}, {0.543418f, 0.139572f, -0.827778f}, {0.322829f, 0.267276f} },
    { {0.054434f, 0.254117f, -0.048919f}, {0.748511f, -0.000000f, -0.663123f}, {0.322829f, 0.278712f} },
    { {0.095912f, 0.422301f, 0.023834f}, {0.987277f, -0.000000f, 0.159008f}, {0.395114f, 0.292225f} },
    { {0.081862f, 0.432126f, -0.020370f}, {0.970936f, 0.003478f, -0.239314f}, {0.397054f, 0.263816f} },
    { {0.081862f, 0.432126f, 0.020371f}, {0.970461f, 0.031454f, 0.239198f}, {0.397054f, 0.290000f} },
    { {0.081862f, 0.571618f, -0.018343f}, {0.798869f, 0.596197f, -0.079730f}, {0.424593f, 0.265119f} },
    { {-0.085904f, 0.571618f, 0.002027f}, {-0.453128f, 0.884421f, 0.111686f}, {0.415081f, 0.278211f} },
    { {0.081862f, 0.571618f, -0.018343f}, {0.798869f, 0.596197f, -0.079730f}, {0.304799f, 0.265119f} },
    { {0.062929f, 0.571618f, 0.058472f}, {0.670796f, 0.652752f, 0.352062f}, {0.317245f, 0.314487f} },
    { {0.062929f, 0.571618f, 0.058472f}, {0.670796f, 0.652752f, 0.352062f}, {0.424593f, 0.314487f} },
    { {-0.042691f, 0.195303f, 0.060712f}, {-0.448198f, -0.000000f, 0.893934f}, {0.333482f, 0.267276f} },
    { {0.064928f, 0.052439f, 0.016197f}, {0.720362f, -0.631583f, 0.286673f}, {0.322093f, 0.287317f} },
    { {0.023215f, 0.052439f, 0.063281f}, {0.206823f, -0.862106f, 0.462599f}, {0.322093f, 0.305751f} },
    { {0.054434f, 0.111253f, 0.048919f}, {0.833707f, -0.097307f, 0.543566f}, {0.333705f, 0.308347f} },
    { {0.085168f, 0.115728f, -0.021185f}, {0.965763f, -0.103148f, -0.238039f}, {0.334588f, 0.263293f} },
    { {-0.074555f, 0.111253f, 0.000000f}, {-0.966070f, -0.100052f, 0.238115f}, {0.386452f, 0.276908f} },
    { {-0.042691f, 0.111253f, 0.060712f}, {-0.690900f, -0.101654f, 0.715767f}, {0.386452f, 0.315926f} },
    { {-0.039231f, 0.052439f, 0.055699f}, {-0.222072f, -0.839543f, 0.495833f}, {0.335757f, 0.239498f} },
    { {-0.042691f, 0.111253f, 0.060712f}, {-0.690900f, -0.101654f, 0.715767f}, {0.333482f, 0.250934f} },
    { {0.025375f, 0.111253f, 0.068977f}, {0.026254f, -0.097307f, 0.994908f}, {0.378225f, 0.250934f} },
    { {0.025375f, 0.254117f, -0.068977f}, {0.120537f, 0.000000f, -0.992709f}, {0.341931f, 0.278712f} },
    { {-0.042691f, 0.254117f, -0.060712f}, {-0.539344f, 0.031936f, -0.841480f}, {0.386674f, 0.278712f} },
    { {-0.042691f, 0.195303f, -0.060712f}, {-0.676910f, 0.000000f, -0.736066f}, {0.369858f, 0.237890f} },
    { {-0.066452f, -0.048281f, -0.014164f}, {-0.794654f, -0.577351f, -0.187592f}, {0.417948f, 0.267805f} },
    { {-0.066452f, 0.048280f, -0.014164f}, {-0.794654f, 0.577350f, -0.187593f}, {0.398884f, 0.267805f} },
    { {0.054434f, 0.195303f, 0.048919f}, {0.886093f, 0.073976f, 0.457566f}, {0.397327f, 0.267276f} },
    { {0.054434f, 0.254117f, 0.048919f}, {0.848309f, -0.021650f, 0.529058f}, {0.397327f, 0.278712f} },
    { {0.073760f, 0.263503f, 0.066041f}, {0.691698f, -0.000000f, 0.722187f}, {0.410031f, 0.280537f} },
    { {0.034531f, 0.263503f, 0.093118f}, {0.276852f, -0.000000f, 0.960913f}, {0.384244f, 0.280537f} },
    { {0.034531f, 0.422301f, 0.093118f}, {0.429976f, -0.000000f, 0.902840f}, {0.384244f, 0.311413f} },
    { {-0.039231f, 0.052439f, -0.055699f}, {-0.516681f, -0.415604f, -0.748541f}, {0.384400f, 0.239498f} },
    { {-0.009676f, 0.111253f, -0.073233f}, {-0.263588f, -0.097307f, -0.959715f}, {0.364972f, 0.250934f} },
    { {-0.066105f, 0.111253f, -0.034283f}, {-0.803879f, -0.097307f, -0.586779f}, {0.386674f, 0.250934f} },
    { {-0.079169f, 0.115728f, -0.041139f}, {-0.746470f, -0.073784f, -0.661315f}, {0.385569f, 0.250469f} },
    { {-0.011455f, 0.115728f, -0.087879f}, {-0.259534f, -0.059515f, -0.963898f}, {0.385569f, 0.230087f} },
    { {-0.051072f, 0.186304f, -0.072854f}, {-0.566604f, -0.071652f, -0.820869f}, {0.371635f, 0.230087f} },
    { {0.069700f, 0.015293f, -0.043077f}, {0.773488f, 0.282427f, -0.567408f}, {0.314759f, 0.249224f} },
    { {0.069700f, -0.015294f, -0.043077f}, {0.834461f, -0.412291f, -0.365637f}, {0.308721f, 0.249224f} },
    { {-0.076154f, 0.432126f, -0.039557f}, {-0.885436f, 0.006754f, -0.464713f}, {0.323103f, 0.251486f} },
    { {-0.049138f, 0.432126f, -0.070052f}, {-0.567441f, 0.046858f, -0.822080f}, {0.323103f, 0.231887f} },
    { {-0.076154f, 0.571618f, -0.037530f}, {-0.805090f, 0.117076f, -0.581483f}, {0.295564f, 0.252789f} },
    { {-0.057358f, 0.263503f, -0.081961f}, {-0.568065f, 0.000000f, -0.822984f}, {0.356394f, 0.224234f} },
    { {-0.057358f, 0.422301f, -0.081961f}, {-0.568065f, 0.000000f, -0.822984f}, {0.325043f, 0.224234f} },
    { {0.056087f, -0.000000f, 0.061660f}, {0.620598f, -0.157225f, 0.768205f}, {0.398414f, 0.229302f} },
    { {0.056087f, -0.000000f, 0.061660f}, {0.620598f, -0.157225f, 0.768205f}, {0.311740f, 0.316535f} },
    { {0.065378f, 0.028596f, 0.043077f}, {0.887470f, 0.235553f, 0.396121f}, {0.317386f, 0.304592f} },
    { {0.080412f, -0.017673f, 0.013009f}, {0.937506f, -0.091844f, 0.335628f}, {0.308251f, 0.285269f} },
    { {-0.066105f, 0.195303f, 0.034283f}, {-0.764853f, 0.165001f, 0.622715f}, {0.369858f, 0.298941f} },
    { {-0.079169f, 0.186304f, 0.041139f}, {-0.903890f, 0.117987f, 0.411170f}, {0.371635f, 0.303347f} },
    { {-0.074555f, 0.254117f, 0.000000f}, {-0.928222f, 0.143336f, 0.343306f}, {0.358247f, 0.276908f} },
    { {-0.051072f, 0.115728f, 0.072854f}, {-0.444919f, -0.059515f, 0.893591f}, {0.385569f, 0.323730f} },
    { {-0.051072f, 0.186304f, 0.072854f}, {-0.568065f, 0.000000f, 0.822984f}, {0.371635f, 0.323730f} },
    { {0.070843f, 0.111253f, -0.017654f}, {0.980850f, -0.044348f, -0.189649f}, {0.333705f, 0.265562f} },
    { {0.064928f, 0.052439f, -0.016197f}, {0.808469f, -0.236658f, -0.538860f}, {0.322093f, 0.266499f} },
    { {0.025375f, 0.111253f, -0.068977f}, {0.640095f, -0.097307f, -0.762109f}, {0.333705f, 0.245469f} },
    { {0.054434f, 0.254117f, -0.048919f}, {0.280901f, -0.953685f, -0.107613f}, {0.361910f, 0.245469f} },
    { {0.070843f, 0.254117f, 0.017654f}, {0.338540f, -0.939427f, 0.053549f}, {0.361910f, 0.288254f} },
    { {0.095912f, 0.263503f, 0.023834f}, {0.295932f, -0.955147f, 0.010863f}, {0.363763f, 0.292225f} },
    { {0.095912f, 0.263503f, 0.023834f}, {0.948085f, -0.000000f, 0.318016f}, {0.363763f, 0.292225f} },
    { {0.073760f, 0.263503f, 0.066041f}, {0.691698f, -0.000000f, 0.722187f}, {0.363763f, 0.319350f} },
    { {0.073760f, 0.422301f, 0.066041f}, {0.800296f, -0.000000f, 0.599606f}, {0.395114f, 0.319350f} },
    { {0.073760f, 0.422301f, 0.066041f}, {0.800296f, -0.000000f, 0.599606f}, {0.410031f, 0.311413f} },
    { {0.062929f, 0.432126f, 0.056445f}, {0.691660f, -0.010495f, 0.722147f}, {0.402911f, 0.313323f} },
    { {0.029400f, 0.432126f, 0.079588f}, {0.354572f, -0.013588f, 0.934930f}, {0.380871f, 0.313323f} },
    { {0.029400f, 0.571618f, 0.081616f}, {0.202249f, 0.378726f, 0.903140f}, {0.380871f, 0.340445f} },
    { {-0.065377f, -0.028596f, -0.043077f}, {-0.951475f, -0.101960f, -0.290344f}, {0.414062f, 0.249224f} },
    { {-0.056086f, -0.000000f, -0.061660f}, {-0.442250f, -0.099791f, -0.891323f}, {0.395480f, 0.229302f} },
    { {0.006994f, -0.071015f, -0.043077f}, {0.047167f, -0.726567f, -0.685475f}, {0.354014f, 0.215495f} },
    { {0.045375f, -0.032967f, -0.061660f}, {0.529377f, -0.272866f, -0.803308f}, {0.328784f, 0.222892f} },
    { {0.029400f, 0.571618f, 0.081616f}, {0.202249f, 0.378726f, 0.903140f}, {0.339286f, 0.329360f} },
    { {-0.049138f, 0.571618f, 0.072080f}, {-0.556278f, 0.202647f, 0.805908f}, {0.390912f, 0.323232f} },
    { {-0.011044f, 0.571618f, -0.082472f}, {-0.111610f, 0.377658f, -0.919194f}, {0.365872f, 0.223906f} },
    { {0.062929f, 0.571618f, -0.054417f}, {0.457063f, 0.593821f, -0.662170f}, {0.317245f, 0.241935f} },
    { {-0.049138f, 0.432126f, -0.070052f}, {-0.567441f, 0.046858f, -0.822080f}, {0.390912f, 0.313323f} },
    { {-0.076154f, 0.571618f, -0.037530f}, {-0.805090f, 0.117076f, -0.581483f}, {0.390912f, 0.340445f} },
    { {-0.008040f, -0.081937f, -0.013009f}, {-0.267124f, -0.892032f, -0.364587f}, {0.424593f, 0.268547f} },
    { {-0.047399f, -0.053341f, -0.043077f}, {-0.430655f, -0.703202f, -0.565724f}, {0.418947f, 0.249224f} },
    { {0.008040f, -0.081937f, 0.013009f}, {0.195442f, -0.925126f, 0.325490f}, {0.366830f, 0.213371f} },
    { {-0.011044f, 0.432126f, -0.084499f}, {-0.120524f, 0.014426f, -0.992606f}, {0.365872f, 0.313323f} },
    { {-0.057358f, 0.422301f, -0.081961f}, {-0.568065f, 0.000000f, -0.822984f}, {0.396316f, 0.311413f} },
    { {0.023215f, 0.052439f, 0.063281f}, {0.206823f, -0.862106f, 0.462599f}, {0.376805f, 0.239498f} },
    { {-0.039231f, 0.052439f, 0.055699f}, {-0.222072f, -0.839543f, 0.495833f}, {0.335757f, 0.312704f} },
    { {0.065477f, 0.186304f, -0.058703f}, {0.746587f, -0.071652f, -0.661418f}, {0.348522f, 0.239181f} },
    { {0.069700f, 0.015293f, -0.043077f}, {0.773488f, 0.282427f, -0.567408f}, {0.318964f, 0.237823f} },
    { {-0.042691f, 0.254117f, -0.060712f}, {-0.072970f, -0.953685f, -0.291824f}, {0.386674f, 0.278712f} },
    { {0.025375f, 0.254117f, -0.068977f}, {0.093966f, -0.939427f, -0.329618f}, {0.341931f, 0.278712f} },
    { {0.034531f, 0.263503f, -0.093118f}, {0.046455f, -0.955147f, -0.292464f}, {0.335913f, 0.280537f} },
    { {0.073760f, 0.263503f, -0.066040f}, {0.800296f, -0.000000f, -0.599605f}, {0.310125f, 0.280537f} },
    { {-0.008040f, 0.081937f, -0.013009f}, {-0.297455f, 0.821295f, -0.486822f}, {0.363897f, 0.245234f} },
    { {-0.065377f, 0.028596f, -0.043077f}, {-0.684292f, 0.560474f, -0.466491f}, {0.401588f, 0.234862f} },
    { {-0.042691f, 0.254117f, 0.060712f}, {-0.494718f, 0.104507f, 0.862747f}, {0.358247f, 0.315926f} },
    { {-0.057358f, 0.263503f, 0.081961f}, {-0.633546f, -0.000000f, 0.773705f}, {0.356394f, 0.329582f} },
    { {-0.045375f, -0.032967f, 0.061660f}, {-0.352550f, -0.177350f, 0.918834f}, {0.331718f, 0.222892f} },
    { {-0.082140f, -0.000000f, 0.014164f}, {-0.982247f, -0.000000f, 0.187592f}, {0.408416f, 0.286011f} },
    { {-0.025382f, 0.078119f, 0.014164f}, {-0.095562f, 0.949983f, 0.297320f}, {0.344860f, 0.244492f} },
    { {0.025383f, -0.078120f, -0.014164f}, {0.303531f, -0.934172f, -0.187592f}, {0.341926f, 0.214113f} },
    { {-0.025382f, -0.078120f, 0.014164f}, {-0.303531f, -0.934173f, 0.187592f}, {0.344860f, 0.214113f} },
    { {-0.051072f, 0.186304f, -0.072854f}, {-0.566604f, -0.071652f, -0.820869f}, {0.392184f, 0.265527f} },
    { {-0.042691f, 0.254117f, 0.060712f}, {-0.214590f, -0.955327f, 0.203229f}, {0.358247f, 0.315926f} },
    { {-0.074555f, 0.254117f, 0.000000f}, {-0.341517f, -0.939427f, 0.029024f}, {0.358247f, 0.276908f} },
    { {-0.100374f, 0.263503f, 0.000000f}, {-0.289930f, -0.955148f, 0.060273f}, {0.356394f, 0.276908f} },
    { {-0.088967f, 0.263503f, -0.046282f}, {-0.313023f, -0.939580f, -0.138590f}, {0.356394f, 0.247164f} },
    { {0.065477f, 0.186304f, 0.058703f}, {0.750375f, 0.123986f, 0.649280f}, {0.404587f, 0.265527f} },
    { {0.065477f, 0.115728f, 0.058703f}, {0.833447f, -0.059515f, 0.549385f}, {0.404587f, 0.251804f} },
    { {0.039968f, 0.029038f, 0.067134f}, {0.491123f, 0.356822f, 0.794654f}, {0.387818f, 0.234948f} },
    { {0.065378f, 0.028596f, 0.043077f}, {0.887470f, 0.235553f, 0.396121f}, {0.404521f, 0.234862f} },
    { {0.054434f, 0.254117f, 0.048919f}, {0.233099f, -0.939282f, 0.251820f}, {0.397327f, 0.278712f} },
    { {0.025375f, 0.254117f, 0.068977f}, {0.001012f, -0.953685f, 0.300806f}, {0.378225f, 0.278712f} },
    { {0.034531f, 0.263503f, 0.093118f}, {0.142399f, -0.939580f, 0.311308f}, {0.384244f, 0.280537f} },
    { {-0.057358f, 0.263503f, 0.081961f}, {-0.115096f, -0.955148f, 0.272848f}, {0.323841f, 0.280537f} },
    { {-0.012789f, 0.263503f, 0.098864f}, {-0.031842f, -0.964476f, 0.262243f}, {0.353138f, 0.280537f} },
    { {-0.066105f, 0.111253f, -0.034283f}, {-0.206278f, -0.951565f, -0.227977f}, {0.318091f, 0.254875f} },
    { {-0.009676f, 0.111253f, -0.073233f}, {-0.063052f, -0.956573f, -0.284591f}, {0.355184f, 0.229843f} },
    { {-0.011455f, 0.115728f, -0.087879f}, {-0.133209f, -0.952244f, -0.274749f}, {0.354015f, 0.220430f} },
    { {0.070843f, 0.111253f, -0.017654f}, {0.294987f, -0.955399f, -0.013972f}, {0.408113f, 0.288254f} },
    { {0.054434f, 0.111253f, 0.048919f}, {0.235913f, -0.956573f, 0.171208f}, {0.397327f, 0.308347f} },
    { {0.065477f, 0.115728f, 0.058703f}, {0.281901f, -0.952244f, 0.117319f}, {0.404587f, 0.314635f} },
    { {-0.039231f, 0.052439f, -0.055699f}, {-0.516681f, -0.415604f, -0.748541f}, {0.335757f, 0.241112f} },
    { {-0.068464f, 0.052439f, 0.000000f}, {-0.708813f, -0.700798f, 0.080411f}, {0.316540f, 0.276908f} },
    { {-0.039231f, 0.052439f, 0.055699f}, {-0.222072f, -0.839543f, 0.495833f}, {0.398064f, 0.312704f} },
    { {0.082140f, -0.000000f, -0.014164f}, {0.971062f, -0.142698f, -0.191511f}, {0.311740f, 0.267805f} },
    { {-0.049403f, -0.000000f, 0.067134f}, {-0.445233f, -0.000000f, 0.895415f}, {0.329070f, 0.229302f} },
    { {-0.069700f, -0.015294f, 0.043077f}, {-0.801615f, -0.334614f, 0.495426f}, {0.321897f, 0.220782f} },
    { {0.045375f, -0.032967f, -0.061660f}, {0.529377f, -0.272866f, -0.803308f}, {0.305232f, 0.237281f} },
    { {0.069700f, 0.015293f, -0.043077f}, {0.773488f, 0.282427f, -0.567408f}, {0.312794f, 0.232276f} },
    { {0.095912f, 0.263503f, -0.023833f}, {0.256494f, -0.964476f, -0.063220f}, {0.363763f, 0.261591f} },
    { {0.073760f, 0.263503f, -0.066040f}, {0.240583f, -0.939579f, -0.243537f}, {0.363763f, 0.234466f} },
    { {0.025383f, -0.078120f, -0.014164f}, {0.303531f, -0.934172f, -0.187592f}, {0.296317f, 0.267805f} },
    { {0.008040f, -0.081937f, 0.013009f}, {0.195442f, -0.925126f, 0.325490f}, {0.295564f, 0.285269f} },
    { {-0.012789f, 0.263503f, -0.098864f}, {-0.031842f, -0.964476f, -0.262244f}, {0.367018f, 0.280537f} },
    { {-0.057358f, 0.263503f, -0.081961f}, {-0.212763f, -0.939579f, -0.268184f}, {0.396316f, 0.280537f} },
    { {-0.066105f, 0.254117f, -0.034283f}, {-0.286591f, -0.939282f, -0.188719f}, {0.318091f, 0.254875f} },
    { {-0.042691f, 0.254117f, -0.060712f}, {-0.072970f, -0.953685f, -0.291824f}, {0.333482f, 0.237890f} },
    { {-0.057358f, 0.263503f, -0.081961f}, {-0.212763f, -0.939579f, -0.268184f}, {0.323841f, 0.224234f} },
    { {0.062929f, 0.432126f, 0.056445f}, {0.691660f, -0.010495f, 0.722147f}, {0.397054f, 0.313184f} },
    { {-0.056086f, -0.000000f, -0.061660f}, {-0.442250f, -0.099791f, -0.891323f}, {0.408416f, 0.237281f} },
    { {-0.039968f, 0.029038f, -0.067134f}, {-0.491123f, 0.356823f, -0.794654f}, {0.384884f, 0.234948f} },
    { {-0.036083f, -0.061563f, 0.043077f}, {-0.361890f, -0.771835f, 0.522788f}, {0.420571f, 0.304592f} },
    { {-0.025382f, -0.078120f, 0.014164f}, {-0.303531f, -0.934173f, 0.187592f}, {0.423839f, 0.286011f} },
    { {-0.036083f, 0.061562f, 0.043077f}, {-0.019997f, 0.861613f, 0.507171f}, {0.396262f, 0.304592f} },
    { {-0.025382f, 0.078119f, 0.014164f}, {-0.095562f, 0.949983f, 0.297320f}, {0.392993f, 0.286011f} },
    { {-0.042691f, 0.254117f, 0.060712f}, {-0.214590f, -0.955327f, 0.203229f}, {0.333482f, 0.315926f} },
    { {-0.088967f, 0.263503f, 0.046282f}, {-0.233911f, -0.964476f, 0.122766f}, {0.303062f, 0.306652f} },
    { {-0.057358f, 0.263503f, 0.081961f}, {-0.115096f, -0.955148f, 0.272848f}, {0.323841f, 0.329582f} },
    { {-0.042691f, 0.254117f, 0.060712f}, {-0.214590f, -0.955327f, 0.203229f}, {0.333482f, 0.278712f} },
    { {-0.057358f, 0.422301f, 0.081961f}, {-0.498768f, -0.000000f, 0.866735f}, {0.325043f, 0.329582f} },
    { {-0.049138f, 0.432126f, 0.070052f}, {-0.568024f, -0.011960f, 0.822925f}, {0.323103f, 0.321929f} },
    { {0.073760f, 0.263503f, 0.066041f}, {0.270760f, -0.939580f, 0.209473f}, {0.363763f, 0.319350f} },
    { {0.073760f, 0.263503f, 0.066041f}, {0.270760f, -0.939580f, 0.209473f}, {0.410031f, 0.280537f} },
    { {-0.088967f, 0.263503f, 0.046282f}, {-0.233911f, -0.964476f, 0.122766f}, {0.356394f, 0.306652f} },
    { {0.036084f, 0.061562f, -0.043077f}, {0.284738f, 0.776724f, -0.561804f}, {0.323894f, 0.249224f} },
    { {0.025383f, 0.078120f, -0.014164f}, {0.234711f, 0.945393f, 0.226148f}, {0.341926f, 0.244492f} },
    { {0.025375f, 0.111253f, 0.068977f}, {0.003225f, -0.951565f, 0.307431f}, {0.355184f, 0.323973f} },
    { {-0.042691f, 0.111253f, 0.060712f}, {-0.166782f, -0.972515f, 0.162473f}, {0.333482f, 0.315926f} },
    { {-0.051072f, 0.115728f, 0.072854f}, {-0.082484f, -0.952244f, 0.293987f}, {0.327973f, 0.323730f} },
    { {0.062929f, 0.432126f, -0.056445f}, {0.800265f, 0.008714f, -0.599583f}, {0.397054f, 0.240632f} },
    { {0.073760f, 0.422301f, -0.066040f}, {0.691698f, 0.000000f, -0.722187f}, {0.395114f, 0.234466f} },
    { {-0.079169f, 0.186304f, -0.041139f}, {-0.320150f, 0.932347f, -0.168028f}, {0.371635f, 0.250469f} },
    { {-0.042691f, 0.195303f, -0.060712f}, {-0.293886f, 0.923837f, -0.245268f}, {0.369858f, 0.237890f} },
    { {-0.089309f, 0.186304f, 0.000000f}, {-0.272825f, 0.959711f, -0.067245f}, {0.371635f, 0.276908f} },
    { {-0.051072f, 0.186304f, -0.072854f}, {-0.264537f, 0.853133f, -0.449649f}, {0.392184f, 0.265527f} },
    { {-0.011455f, 0.186304f, -0.087879f}, {-0.043582f, 0.932347f, -0.358929f}, {0.366141f, 0.265527f} },
    { {-0.009676f, 0.195303f, -0.073233f}, {-0.188621f, 0.846795f, -0.497353f}, {0.364972f, 0.267276f} },
    { {-0.011455f, 0.186304f, 0.087879f}, {-0.043582f, 0.932347f, 0.358929f}, {0.354015f, 0.265527f} },
    { {-0.042691f, 0.195303f, 0.060712f}, {-0.125116f, 0.923837f, 0.361761f}, {0.333482f, 0.267276f} },
    { {0.030607f, 0.186304f, 0.082772f}, {0.033869f, 0.959711f, 0.278942f}, {0.381665f, 0.265527f} },
    { {-0.051072f, 0.186304f, 0.072854f}, {-0.326623f, 0.853133f, 0.406794f}, {0.371635f, 0.323730f} },
    { {-0.079169f, 0.186304f, 0.041139f}, {-0.398147f, 0.846795f, 0.352727f}, {0.371635f, 0.303347f} },
    { {-0.066105f, 0.195303f, 0.034283f}, {-0.398147f, 0.846795f, 0.352727f}, {0.369858f, 0.298941f} },
    { {0.030607f, 0.186304f, -0.082772f}, {0.128212f, 0.932347f, -0.338069f}, {0.338492f, 0.265527f} },
    { {0.054434f, 0.195303f, -0.048919f}, {0.208055f, 0.923837f, -0.321307f}, {0.322829f, 0.267276f} },
    { {0.065477f, 0.186304f, -0.058703f}, {0.414484f, 0.853133f, -0.316807f}, {0.348522f, 0.239181f} },
    { {0.085168f, 0.186304f, -0.021185f}, {0.351058f, 0.932347f, -0.086528f}, {0.348522f, 0.263293f} },
    { {0.070843f, 0.195303f, -0.017654f}, {0.470990f, 0.846796f, -0.247195f}, {0.350298f, 0.265562f} },
    { {-0.079169f, 0.115728f, -0.041139f}, {-0.238939f, -0.956250f, -0.168803f}, {0.309503f, 0.250469f} },
    { {0.070843f, 0.111253f, -0.017654f}, {0.294987f, -0.955399f, -0.013972f}, {0.333705f, 0.265562f} },
    { {0.065477f, 0.115728f, 0.058703f}, {0.281901f, -0.952244f, 0.117319f}, {0.334588f, 0.314635f} },
    { {0.085168f, 0.115728f, -0.021185f}, {0.270805f, -0.955997f, -0.112843f}, {0.334588f, 0.263293f} },
    { {0.025375f, 0.111253f, -0.068977f}, {0.201451f, -0.951565f, -0.232254f}, {0.378225f, 0.232579f} },
    { {0.070843f, 0.111253f, -0.017654f}, {0.294987f, -0.955399f, -0.013972f}, {0.408114f, 0.265562f} },
    { {0.085168f, 0.115728f, -0.021185f}, {0.270805f, -0.955997f, -0.112843f}, {0.417530f, 0.263293f} },
    { {-0.065377f, -0.028596f, -0.043077f}, {-0.951475f, -0.101960f, -0.290344f}, {0.401588f, 0.223742f} },
    { {-0.009676f, 0.111253f, -0.073233f}, {-0.063052f, -0.956573f, -0.284591f}, {0.364972f, 0.250934f} },
    { {0.030607f, 0.115728f, -0.082772f}, {0.138773f, -0.956249f, -0.257544f}, {0.338492f, 0.251804f} },
    { {-0.011455f, 0.115728f, -0.087879f}, {-0.133209f, -0.952244f, -0.274749f}, {0.366141f, 0.251804f} },
    { {0.030607f, 0.115728f, -0.082772f}, {0.138773f, -0.956249f, -0.257544f}, {0.381665f, 0.223713f} },
    { {0.030607f, 0.115728f, 0.082772f}, {0.066911f, -0.956250f, 0.284798f}, {0.381665f, 0.330103f} },
    { {0.025375f, 0.111253f, 0.068977f}, {0.003225f, -0.951565f, 0.307431f}, {0.378225f, 0.250934f} },
    { {-0.051072f, 0.115728f, 0.072854f}, {-0.082484f, -0.952244f, 0.293987f}, {0.327973f, 0.251804f} },
    { {0.030607f, 0.115728f, 0.082772f}, {0.066911f, -0.956250f, 0.284798f}, {0.381665f, 0.251804f} },
    { {0.047399f, -0.053341f, 0.043077f}, {0.605328f, -0.637678f, 0.476387f}, {0.392703f, 0.218931f} },
    { {0.047400f, 0.053341f, 0.043077f}, {0.267967f, 0.841796f, 0.468587f}, {0.322271f, 0.304592f} },
    { {0.025383f, 0.078120f, -0.014164f}, {0.234711f, 0.945393f, 0.226148f}, {0.327163f, 0.267805f} },
    { {0.062929f, 0.571618f, -0.054417f}, {0.457063f, 0.593821f, -0.662170f}, {0.424593f, 0.241935f} },
    { {0.062929f, 0.571618f, 0.058472f}, {0.670796f, 0.652752f, 0.352062f}, {0.402911f, 0.340445f} },
    { {-0.076154f, 0.571618f, -0.037530f}, {-0.805090f, 0.117076f, -0.581483f}, {0.408672f, 0.252789f} },
    { {-0.069700f, -0.015294f, 0.043077f}, {-0.801615f, -0.334614f, 0.495426f}, {0.315728f, 0.226329f} },
    { {0.045375f, -0.032967f, -0.061660f}, {0.529377f, -0.272866f, -0.803308f}, {0.311740f, 0.233763f} },
    { {0.036084f, -0.061563f, -0.043077f}, {0.653804f, -0.624794f, -0.426818f}, {0.334892f, 0.217332f} },
    { {-0.045375f, 0.032966f, 0.061660f}, {-0.638639f, 0.463998f, 0.613878f}, {0.331718f, 0.235712f} },
    { {0.085168f, 0.186304f, 0.021185f}, {0.351058f, 0.932347f, 0.086528f}, {0.348522f, 0.290523f} },
    { {0.065477f, 0.186304f, 0.058703f}, {0.470990f, 0.846796f, 0.247195f}, {0.348522f, 0.314635f} },
    { {0.054434f, 0.195303f, 0.048919f}, {0.351058f, 0.932347f, 0.086528f}, {0.350298f, 0.308347f} },
    { {-0.051072f, 0.186304f, -0.072854f}, {-0.264537f, 0.853133f, -0.449649f}, {0.371635f, 0.230087f} },
    { {-0.051072f, 0.186304f, 0.072854f}, {-0.326623f, 0.853133f, 0.406794f}, {0.327973f, 0.265527f} },
    { {-0.051072f, 0.186304f, 0.072854f}, {-0.568065f, 0.000000f, 0.822984f}, {0.327973f, 0.265527f} },
    { {0.065477f, 0.186304f, -0.058703f}, {0.414484f, 0.853133f, -0.316807f}, {0.315570f, 0.265527f} },
    { {0.025375f, 0.111253f, -0.068977f}, {0.201451f, -0.951565f, -0.232254f}, {0.341931f, 0.250934f} },
    { {0.025375f, 0.111253f, 0.068977f}, {0.003225f, -0.951565f, 0.307431f}, {0.378225f, 0.321237f} },
    { {0.054434f, 0.111253f, 0.048919f}, {0.833707f, -0.097307f, 0.543566f}, {0.397327f, 0.250934f} },
    { {-0.042691f, 0.111253f, 0.060712f}, {-0.166782f, -0.972515f, 0.162473f}, {0.386452f, 0.315926f} },
    { {-0.089309f, 0.115728f, 0.000000f}, {-0.222126f, -0.973761f, 0.049499f}, {0.385569f, 0.276908f} },
    { {-0.079169f, 0.115728f, 0.041139f}, {-0.167663f, -0.981909f, 0.087997f}, {0.385569f, 0.303347f} },
    { {-0.079169f, 0.115728f, 0.041139f}, {-0.167663f, -0.981909f, 0.087997f}, {0.309503f, 0.303347f} },
    { {-0.074555f, 0.111253f, 0.000000f}, {-0.290116f, -0.956573f, 0.028289f}, {0.386452f, 0.276908f} },
    { {-0.066105f, 0.111253f, -0.034283f}, {-0.206278f, -0.951565f, -0.227977f}, {0.386452f, 0.254875f} },
    { {-0.079169f, 0.115728f, -0.041139f}, {-0.238939f, -0.956250f, -0.168803f}, {0.385569f, 0.250469f} },
    { {0.054434f, 0.254117f, -0.048919f}, {0.280901f, -0.953685f, -0.107613f}, {0.322829f, 0.278712f} },
    { {0.073760f, 0.263503f, -0.066040f}, {0.240583f, -0.939579f, -0.243537f}, {0.310125f, 0.280537f} },
    { {-0.008040f, 0.081937f, -0.013009f}, {-0.297455f, 0.821295f, -0.486822f}, {0.363897f, 0.268547f} },
    { {0.025383f, 0.078120f, -0.014164f}, {0.234711f, 0.945393f, 0.226148f}, {0.341926f, 0.267805f} },
    { {-0.025382f, 0.078119f, 0.014164f}, {-0.095562f, 0.949983f, 0.297320f}, {0.375297f, 0.286011f} },
    { {0.008040f, -0.081937f, 0.013009f}, {0.195442f, -0.925126f, 0.325490f}, {0.366830f, 0.285269f} },
    { {0.025383f, -0.078120f, -0.014164f}, {0.303531f, -0.934172f, -0.187592f}, {0.378230f, 0.267805f} },
    { {-0.008040f, -0.081937f, -0.013009f}, {-0.267124f, -0.892032f, -0.364587f}, {0.356260f, 0.268547f} },
    { {-0.025382f, -0.078120f, 0.014164f}, {-0.303531f, -0.934173f, 0.187592f}, {0.344860f, 0.286011f} },
    { {0.064928f, 0.052439f, -0.016197f}, {0.808469f, -0.236658f, -0.538860f}, {0.404226f, 0.266499f} },
    { {-0.042691f, 0.195303f, 0.060712f}, {-0.448198f, -0.000000f, 0.893934f}, {0.369858f, 0.315926f} },
    { {-0.042691f, 0.195303f, 0.060712f}, {-0.125116f, 0.923837f, 0.361761f}, {0.369858f, 0.315926f} },
    { {-0.042691f, 0.195303f, -0.060712f}, {-0.676910f, 0.000000f, -0.736066f}, {0.386674f, 0.267276f} },
    { {-0.042691f, 0.195303f, -0.060712f}, {-0.293886f, 0.923837f, -0.245268f}, {0.386674f, 0.267276f} },
    { {0.054434f, 0.195303f, -0.048919f}, {0.543418f, 0.139572f, -0.827778f}, {0.350298f, 0.245469f} },
    { {0.054434f, 0.195303f, -0.048919f}, {0.208055f, 0.923837f, -0.321307f}, {0.350298f, 0.245469f} },
    { {-0.088967f, 0.263503f, -0.046282f}, {-0.313023f, -0.939580f, -0.138590f}, {0.303062f, 0.247164f} },
    { {-0.088967f, 0.422301f, 0.046282f}, {-0.516209f, 0.826610f, 0.224152f}, {0.325043f, 0.306652f} },
    { {-0.085904f, 0.432126f, 0.000000f}, {-0.560999f, 0.826242f, 0.051035f}, {0.323103f, 0.276908f} },
    { {-0.076154f, 0.432126f, 0.039557f}, {-0.473022f, 0.826242f, 0.305898f}, {0.323103f, 0.302330f} },
    { {-0.057358f, 0.422301f, 0.081961f}, {-0.352912f, 0.826610f, 0.438370f}, {0.325043f, 0.329582f} },
    { {0.095912f, 0.422301f, 0.023834f}, {0.535026f, 0.826611f, 0.174529f}, {0.395114f, 0.292225f} },
    { {0.062929f, 0.432126f, 0.056445f}, {0.453754f, 0.826243f, 0.333810f}, {0.397054f, 0.313184f} },
    { {0.081862f, 0.432126f, 0.020371f}, {0.556909f, 0.826243f, 0.084704f}, {0.397054f, 0.290000f} },
    { {0.095912f, 0.422301f, -0.023833f}, {0.554851f, 0.826611f, -0.094102f}, {0.395114f, 0.261591f} },
    { {0.073760f, 0.422301f, 0.066041f}, {0.392634f, 0.826611f, 0.403177f}, {0.410031f, 0.311413f} },
    { {0.029400f, 0.432126f, 0.079588f}, {0.246650f, 0.826243f, 0.506444f}, {0.380871f, 0.313323f} },
    { {0.062929f, 0.432126f, 0.056445f}, {0.453754f, 0.826243f, 0.333810f}, {0.402911f, 0.313323f} },
    { {0.073760f, 0.422301f, 0.066041f}, {0.392634f, 0.826611f, 0.403177f}, {0.395114f, 0.319350f} },
    { {-0.049138f, 0.432126f, 0.070052f}, {-0.276683f, 0.826242f, 0.490684f}, {0.323103f, 0.321929f} },
    { {-0.012789f, 0.422301f, 0.098864f}, {-0.108767f, 0.826610f, 0.552164f}, {0.353138f, 0.311413f} },
    { {-0.057358f, 0.422301f, 0.081961f}, {-0.352912f, 0.826610f, 0.438370f}, {0.323841f, 0.311413f} },
    { {-0.049138f, 0.432126f, 0.070052f}, {-0.276683f, 0.826242f, 0.490684f}, {0.329244f, 0.313323f} },
    { {0.034531f, 0.422301f, 0.093118f}, {0.160294f, 0.826611f, 0.539463f}, {0.384244f, 0.311413f} },
    { {-0.011044f, 0.432126f, 0.084499f}, {-0.016959f, 0.826242f, 0.563059f}, {0.354285f, 0.313323f} },
    { {-0.100374f, 0.422301f, 0.000000f}, {-0.561249f, 0.826610f, -0.041418f}, {0.325043f, 0.276908f} },
    { {-0.076154f, 0.432126f, -0.039557f}, {-0.520457f, 0.826242f, -0.215520f}, {0.323103f, 0.251486f} },
    { {0.081862f, 0.432126f, -0.020370f}, {0.532483f, 0.826242f, -0.183808f}, {0.397054f, 0.263816f} },
    { {0.073760f, 0.422301f, -0.066040f}, {0.447565f, 0.826610f, -0.341175f}, {0.395114f, 0.234466f} },
    { {-0.088967f, 0.422301f, -0.046282f}, {-0.477713f, 0.826610f, -0.297499f}, {0.325043f, 0.247164f} },
    { {-0.049138f, 0.432126f, -0.070052f}, {-0.360684f, 0.826242f, -0.432702f}, {0.323103f, 0.231887f} },
    { {0.062929f, 0.432126f, -0.056445f}, {0.386071f, 0.826242f, -0.410211f}, {0.397054f, 0.240632f} },
    { {0.034531f, 0.422301f, -0.093118f}, {0.237748f, 0.826610f, -0.510090f}, {0.335913f, 0.311413f} },
    { {0.073760f, 0.422301f, -0.066040f}, {0.447565f, 0.826610f, -0.341175f}, {0.310125f, 0.311413f} },
    { {0.062929f, 0.432126f, -0.056445f}, {0.386071f, 0.826242f, -0.410211f}, {0.317245f, 0.313323f} },
    { {-0.057358f, 0.422301f, -0.081961f}, {-0.284739f, 0.826611f, -0.485426f}, {0.396316f, 0.311413f} },
    { {-0.011044f, 0.432126f, -0.084499f}, {-0.118283f, 0.826242f, -0.550756f}, {0.365872f, 0.313323f} },
    { {-0.049138f, 0.432126f, -0.070052f}, {-0.360684f, 0.826242f, -0.432702f}, {0.390912f, 0.313323f} },
    { {-0.057358f, 0.422301f, -0.081961f}, {-0.284739f, 0.826611f, -0.485426f}, {0.325043f, 0.224234f} },
    { {0.029400f, 0.432126f, -0.079588f}, {0.151214f, 0.826242f, -0.542640f}, {0.339286f, 0.313323f} },
    { {-0.012789f, 0.422301f, -0.098864f}, {-0.026535f, 0.826610f, -0.562149f}, {0.367018f, 0.311413f} },
    { {0.054434f, 0.254117f, 0.048919f}, {0.233099f, -0.939282f, 0.251820f}, {0.361910f, 0.308347f} },
    { {-0.066105f, 0.254117f, -0.034283f}, {-0.286591f, -0.939282f, -0.188719f}, {0.358247f, 0.254875f} },
    { {-0.069700f, 0.015293f, 0.043077f}, {-0.832021f, 0.208140f, 0.514217f}, {0.315728f, 0.232276f} },
    { {-0.049403f, -0.000000f, 0.067134f}, {-0.445233f, -0.000000f, 0.895415f}, {0.408416f, 0.320053f} },
};

WORD g_tind20[] = 
{
    2, 1, 0,    5, 4, 3,    8, 7, 6,    11, 10, 9,    14, 13, 12,
    17, 16, 15,    20, 19, 18,    23, 22, 21,    5, 3, 24,    27, 26, 25,
    16, 28, 15,    31, 30, 29,    34, 33, 32,    37, 36, 35,    40, 39, 38,
    43, 42, 41,    42, 44, 41,    47, 46, 45,    50, 49, 48,    53, 52, 51,
    56, 55, 54,    23, 58, 57,    61, 60, 59,    64, 63, 62,    67, 66, 65,
    70, 69, 68,    73, 72, 71,    75, 74, 5,    78, 77, 76,    79, 78, 76,
    82, 81, 80,    56, 54, 83,    86, 85, 84,    89, 88, 87,    92, 91, 90,
    95, 94, 93,    98, 97, 96,    101, 100, 99,    2, 102, 1,    105, 104, 103,
    108, 107, 106,    105, 109, 104,    72, 110, 71,    71, 64, 62,    113, 112, 111,
    11, 9, 114,    116, 115, 90,    119, 118, 117,    121, 120, 99,    74, 122, 5,
    20, 123, 19,    84, 85, 124,    126, 73, 125,    129, 128, 127,    132, 131, 130,
    135, 134, 133,    37, 35, 136,    83, 137, 56,    140, 139, 138,    142, 141, 8,
    143, 67, 65,    146, 145, 144,    149, 148, 147,    151, 148, 150,    152, 113, 111,
    154, 152, 153,    157, 156, 155,    160, 159, 158,    161, 129, 127,    164, 163, 162,
    85, 165, 68,    80, 81, 166,    168, 167, 57,    167, 82, 80,    170, 169, 106,
    164, 47, 45,    172, 171, 106,    174, 43, 173,    176, 175, 19,    33, 177, 32,
    43, 178, 173,    179, 50, 48,    119, 117, 180,    60, 181, 59,    97, 29, 96,
    182, 29, 114,    58, 168, 57,    22, 183, 58,    186, 185, 184,    13, 187, 12,
    189, 188, 23,    166, 23, 57,    190, 149, 147,    40, 38, 191,    192, 33, 34,
    66, 192, 65,    65, 32, 143,    55, 146, 144,    193, 70, 68,    20, 68, 165,
    84, 68, 69,    67, 89, 66,    188, 22, 23,    194, 89, 87,    82, 167, 195,
    177, 33, 196,    100, 53, 99,    197, 53, 51,    200, 199, 198,    200, 201, 199,
    73, 71, 202,    202, 71, 203,    143, 205, 204,    88, 89, 67,    208, 207, 206,
    210, 209, 207,    213, 212, 211,    52, 25, 51,    216, 215, 214,    71, 62, 203,
    131, 93, 130,    218, 217, 59,    116, 90, 219,    181, 218, 59,    145, 146, 35,
    146, 220, 35,    66, 221, 192,    222, 33, 192,    137, 83, 223,    58, 224, 168,
    120, 101, 99,    226, 225, 155,    227, 83, 54,    55, 228, 54,    230, 229, 184,
    233, 232, 231,    102, 160, 158,    109, 234, 104,    165, 85, 235,    166, 189, 236,
    238, 237, 19,    237, 18, 19,    69, 239, 84,    84, 239, 240,    243, 242, 241,
    209, 244, 207,    245, 40, 191,    79, 76, 246,    129, 17, 128,    164, 45, 163,
    157, 247, 156,    248, 208, 206,    39, 6, 38,    249, 200, 198,    140, 138, 77,
    39, 8, 6,    136, 250, 37,    251, 22, 188,    254, 253, 252,    148, 24, 150,
    17, 15, 128,    208, 210, 207,    102, 158, 1,    225, 157, 155,    105, 103, 255,
    256, 2, 0,    43, 41, 178,    14, 12, 50,    75, 5, 148,    148, 5, 24,
    259, 258, 257,    262, 261, 260,    265, 264, 263,    268, 267, 266,    261, 270, 269,
    273, 272, 271,    115, 92, 90,    274, 213, 211,    277, 276, 275,    280, 279, 278,
    123, 176, 19,    81, 281, 166,    284, 283, 282,    285, 280, 278,    216, 286, 215,
    289, 288, 287,    32, 290, 143,    177, 290, 32,    37, 292, 291,    37, 250, 292,
    107, 172, 106,    293, 105, 255,    169, 108, 106,    294, 164, 162,    171, 295, 106,
    78, 140, 77,    80, 166, 57,    57, 167, 80,    221, 296, 192,    18, 70, 193,
    37, 291, 36,    205, 88, 204,    220, 136, 35,    136, 137, 297,    168, 298, 167,
    167, 298, 195,    299, 221, 66,    66, 89, 299,    56, 220, 146,    146, 55, 56,
    73, 202, 125,    302, 301, 300,    272, 302, 300,    29, 11, 114,    258, 303, 257,
    4, 135, 133,    264, 304, 263,    64, 305, 63,    270, 306, 269,    52, 27, 25,
    283, 307, 282,    131, 95, 93,    286, 308, 215,    309, 119, 180,    312, 311, 310,
    254, 313, 253,    23, 21, 58,    21, 22, 58,    20, 193, 68,    20, 18, 193,
    316, 315, 314,    4, 133, 3,    124, 85, 68,    84, 124, 68,    20, 165, 123,
    165, 176, 123,    236, 189, 23,    166, 236, 23,    204, 88, 67,    143, 204, 67,
    318, 317, 185,    186, 318, 185,    84, 240, 86,    321, 320, 319,    192, 34, 65,
    34, 32, 65,    324, 323, 322,    228, 227, 54,    322, 325, 324,    175, 238, 19,
    152, 111, 153,    326, 61, 59,    190, 147, 327,    328, 268, 266,    121, 99, 329,
    330, 262, 260,    98, 96, 331,    332, 273, 271,    8, 141, 7,    333, 233, 231,
    50, 12, 49,    229, 186, 184,    336, 335, 334,    336, 334, 337,    340, 339, 338,
    340, 338, 341,    344, 343, 342,    339, 345, 338,    346, 336, 337,    349, 348, 347,
    343, 351, 350,    343, 350, 342,    351, 349, 347,    351, 347, 350,    335, 352, 334,
    335, 353, 352,    354, 340, 341,    354, 341, 355,    353, 357, 356,    353, 356, 352,
    358, 354, 355,    361, 360, 359,    364, 363, 362,    357, 365, 356,    366, 361, 359,
    366, 359, 367,    363, 366, 367,    363, 367, 362,    311, 314, 310,    311, 316, 314,
    247, 368, 156,    97, 31, 29,    201, 369, 199,    149, 75, 148,    299, 370, 221,
    70, 18, 371,    56, 137, 220,    137, 136, 220,    291, 145, 36,    36, 145, 35,

};

D3DMATRIX g_tmat21 = 
{
    -0.215924f, 0.968738f, -0.122163f, 0.000000f, 
    -0.148406f, -0.156222f, -0.976510f, 0.000000f, 
    -0.965066f, -0.192723f, 0.177499f, 0.000000f, 
    2.276704f, -2.612147f, 3.828731f, 1.000000f, 
};

// Mesh #21 Tris:80 Verts:105
MODELVERT g_tmesh21[] = 
{
    { {0.202101f, -0.069683f, 0.247057f}, {0.893983f, -0.282842f, -0.347556f}, {0.335436f, 0.340445f} },
    { {0.097769f, -0.071034f, 0.000612f}, {0.750737f, -0.505885f, -0.424822f}, {0.334929f, 0.223091f} },
    { {0.124905f, -0.175934f, 0.247057f}, {0.560736f, -0.758021f, -0.333135f}, {0.313206f, 0.340445f} },
    { {0.069556f, -0.050536f, -0.011596f}, {-0.809187f, 0.582151f, 0.079481f}, {0.338961f, 0.217278f} },
    { {0.128376f, -0.045729f, 0.247057f}, {-0.935954f, 0.299459f, 0.185242f}, {0.326925f, 0.340445f} },
    { {0.079341f, -0.113220f, 0.247057f}, {-0.488662f, 0.856536f, 0.165999f}, {0.335991f, 0.340445f} },
    { {-0.202101f, -0.069683f, 0.247057f}, {-0.868582f, -0.346029f, -0.354725f}, {0.384721f, 0.340445f} },
    { {-0.114935f, -0.037345f, 0.005536f}, {-0.892321f, -0.113707f, -0.436845f}, {0.372585f, 0.225436f} },
    { {-0.202101f, 0.061650f, 0.247057f}, {-0.903940f, 0.231690f, -0.359461f}, {0.335436f, 0.340445f} },
    { {-0.081769f, 0.026568f, 0.001319f}, {0.989158f, -0.120840f, 0.083451f}, {0.338961f, 0.247304f} },
    { {-0.128376f, 0.037696f, 0.247057f}, {0.933584f, -0.303340f, 0.190805f}, {0.326925f, 0.340445f} },
    { {-0.079341f, 0.105187f, 0.247057f}, {0.798235f, -0.556727f, 0.229945f}, {0.335991f, 0.340445f} },
    { {0.069556f, 0.050535f, 0.005334f}, {-0.758441f, -0.651641f, 0.011450f}, {0.339607f, 0.225340f} },
    { {0.128376f, 0.037695f, 0.247057f}, {-0.892141f, -0.418775f, 0.169444f}, {0.344425f, 0.340445f} },
    { {0.085976f, -0.000000f, -0.003131f}, {-0.997344f, -0.002634f, 0.072791f}, {0.358571f, 0.221309f} },
    { {0.120849f, -0.000000f, 0.011023f}, {0.902529f, 0.039193f, -0.428843f}, {0.361585f, 0.228049f} },
    { {0.124905f, -0.175934f, 0.247057f}, {0.560736f, -0.758021f, -0.333135f}, {0.397999f, 0.340445f} },
    { {0.097769f, -0.071034f, 0.000612f}, {0.750737f, -0.505885f, -0.424822f}, {0.389761f, 0.223091f} },
    { {0.037344f, -0.114935f, -0.005732f}, {0.181900f, -0.907729f, -0.378075f}, {0.371416f, 0.220070f} },
    { {0.026568f, -0.081769f, -0.016827f}, {0.069953f, 0.991102f, -0.113240f}, {0.352012f, 0.214787f} },
    { {-0.000000f, -0.067946f, 0.206446f}, {-0.184301f, 0.982650f, -0.020808f}, {0.360078f, 0.321107f} },
    { {-0.026568f, -0.081769f, -0.016827f}, {0.523705f, 0.847838f, 0.083092f}, {0.368144f, 0.214787f} },
    { {-0.079341f, -0.113220f, 0.247057f}, {0.216750f, 0.963330f, 0.158162f}, {0.384166f, 0.340445f} },
    { {0.065666f, -0.154926f, 0.217799f}, {-0.059335f, -0.983912f, -0.168512f}, {0.380014f, 0.326513f} },
    { {-0.037345f, -0.114935f, -0.005732f}, {-0.073062f, -0.959773f, -0.271105f}, {0.348741f, 0.220070f} },
    { {-0.065667f, -0.154926f, 0.217799f}, {-0.018833f, -0.978206f, -0.206782f}, {0.340142f, 0.326513f} },
    { {-0.026568f, 0.081768f, 0.010565f}, {0.299276f, -0.944099f, 0.138240f}, {0.352012f, 0.227831f} },
    { {-0.000000f, 0.130966f, 0.247057f}, {0.153744f, -0.970701f, 0.184667f}, {0.360078f, 0.340445f} },
    { {-0.000000f, 0.130966f, 0.247057f}, {-0.097386f, 0.994244f, -0.044676f}, {0.360078f, 0.340445f} },
    { {-0.079341f, 0.105187f, 0.247057f}, {-0.294374f, 0.905991f, 0.304177f}, {0.384166f, 0.340445f} },
    { {-0.037345f, 0.114934f, 0.027777f}, {-0.164910f, 0.985329f, -0.043954f}, {0.371416f, 0.236027f} },
    { {-0.124906f, 0.167901f, 0.247057f}, {-0.480596f, 0.810208f, -0.335545f}, {0.397999f, 0.340445f} },
    { {-0.114935f, 0.037344f, 0.016509f}, {-0.756718f, 0.488208f, -0.434777f}, {0.389761f, 0.233006f} },
    { {-0.037345f, 0.114934f, 0.027777f}, {-0.116064f, 0.871822f, -0.475873f}, {0.371416f, 0.236027f} },
    { {-0.071034f, -0.097770f, -0.003264f}, {-0.600591f, -0.692919f, -0.398941f}, {0.385228f, 0.223091f} },
    { {-0.026568f, -0.081769f, -0.016827f}, {0.523705f, 0.847838f, 0.083092f}, {0.342621f, 0.243013f} },
    { {-0.128376f, -0.045728f, 0.247057f}, {0.903831f, 0.350083f, 0.246030f}, {0.344425f, 0.340445f} },
    { {-0.081769f, 0.026568f, 0.001319f}, {0.989158f, -0.120840f, 0.083451f}, {0.371556f, 0.223428f} },
    { {0.041712f, 0.124360f, 0.247057f}, {-0.476862f, -0.861740f, 0.173225f}, {0.330304f, 0.340445f} },
    { {0.202101f, 0.061650f, 0.247057f}, {0.887759f, 0.296070f, -0.352457f}, {0.384721f, 0.340445f} },
    { {0.041712f, -0.081201f, 0.217799f}, {0.508735f, 0.860215f, -0.034915f}, {0.347415f, 0.326513f} },
    { {-0.000000f, -0.067946f, 0.206446f}, {0.188267f, -0.088136f, 0.978155f}, {0.360078f, 0.253281f} },
    { {0.065666f, -0.154926f, 0.217799f}, {-0.246764f, -0.041649f, 0.968180f}, {0.380014f, 0.221135f} },
    { {-0.065667f, -0.154926f, 0.217799f}, {0.150035f, 0.015750f, 0.988555f}, {0.340142f, 0.221135f} },
    { {0.041712f, 0.124360f, 0.247057f}, {-0.476862f, -0.861740f, 0.173225f}, {0.372742f, 0.340445f} },
    { {0.026568f, 0.081768f, 0.010565f}, {-0.323802f, -0.943654f, -0.068326f}, {0.368144f, 0.227831f} },
    { {0.124905f, 0.167901f, 0.247057f}, {0.681224f, 0.639430f, -0.356461f}, {0.322157f, 0.340445f} },
    { {0.037344f, 0.114934f, 0.027777f}, {0.423243f, 0.704851f, -0.569255f}, {0.348741f, 0.236027f} },
    { {0.097769f, 0.071033f, 0.021434f}, {0.718982f, 0.555654f, -0.417509f}, {0.330396f, 0.233006f} },
    { {0.041712f, 0.124360f, 0.247057f}, {-0.233615f, 0.790039f, 0.566800f}, {0.372742f, 0.324353f} },
    { {0.202101f, 0.061650f, 0.247057f}, {0.000000f, -0.000001f, 1.000000f}, {0.421435f, 0.301177f} },
    { {0.128376f, 0.037695f, 0.247057f}, {0.000000f, -0.000001f, 1.000000f}, {0.399053f, 0.292324f} },
    { {0.041712f, 0.124360f, 0.247057f}, {-0.233615f, 0.790039f, 0.566800f}, {0.347415f, 0.340445f} },
    { {0.037344f, 0.114934f, 0.027777f}, {-0.181734f, 0.982093f, -0.049666f}, {0.348741f, 0.236027f} },
    { {0.124905f, 0.167901f, 0.247057f}, {-0.403945f, 0.771812f, 0.491054f}, {0.322157f, 0.340445f} },
    { {-0.124906f, -0.175934f, 0.247057f}, {-0.548959f, -0.756949f, -0.354504f}, {0.322157f, 0.340445f} },
    { {-0.071034f, -0.097770f, -0.003264f}, {-0.600591f, -0.692919f, -0.398941f}, {0.338513f, 0.221246f} },
    { {-0.202101f, -0.069683f, 0.247057f}, {-0.868582f, -0.346029f, -0.354725f}, {0.307885f, 0.340445f} },
    { {-0.000000f, -0.067946f, 0.206446f}, {0.188267f, -0.088136f, 0.978155f}, {0.331113f, 0.326513f} },
    { {-0.124906f, -0.175934f, 0.247057f}, {0.279697f, -0.178609f, 0.943328f}, {0.295564f, 0.340445f} },
    { {-0.079341f, -0.113220f, 0.247057f}, {0.133986f, -0.097347f, 0.986190f}, {0.319098f, 0.340445f} },
    { {-0.079341f, 0.105187f, 0.247057f}, {0.798235f, -0.556727f, 0.229945f}, {0.384166f, 0.340445f} },
    { {-0.128376f, 0.037696f, 0.247057f}, {0.000000f, -0.000001f, 1.000000f}, {0.321104f, 0.292324f} },
    { {-0.124906f, 0.167901f, 0.247057f}, {0.000000f, -0.000001f, 1.000000f}, {0.322157f, 0.340445f} },
    { {-0.079341f, 0.105187f, 0.247057f}, {-0.294374f, 0.905991f, 0.304177f}, {0.335991f, 0.317267f} },
    { {-0.037345f, -0.114935f, -0.005732f}, {-0.073062f, -0.959773f, -0.271105f}, {0.371416f, 0.235915f} },
    { {0.026568f, -0.081769f, -0.016827f}, {0.069953f, 0.991102f, -0.113240f}, {0.352012f, 0.248172f} },
    { {-0.026568f, -0.081769f, -0.016827f}, {0.523705f, 0.847838f, 0.083092f}, {0.368144f, 0.248172f} },
    { {-0.079341f, -0.113220f, 0.247057f}, {0.133986f, -0.097347f, 0.986190f}, {0.335991f, 0.236549f} },
    { {-0.124906f, -0.175934f, 0.247057f}, {0.279697f, -0.178609f, 0.943328f}, {0.322157f, 0.213371f} },
    { {-0.202101f, -0.069683f, 0.247057f}, {0.000000f, -0.000000f, 1.000000f}, {0.298721f, 0.252639f} },
    { {-0.128376f, -0.045728f, 0.247057f}, {0.000000f, -0.000001f, 1.000000f}, {0.321104f, 0.261492f} },
    { {-0.202101f, 0.061650f, 0.247057f}, {0.000000f, -0.000001f, 1.000000f}, {0.298721f, 0.301177f} },
    { {-0.037345f, 0.114934f, 0.027777f}, {-0.116064f, 0.871822f, -0.475873f}, {0.371416f, 0.320870f} },
    { {0.026568f, 0.081768f, 0.010565f}, {-0.323802f, -0.943654f, -0.068326f}, {0.352012f, 0.308612f} },
    { {0.037344f, 0.114934f, 0.027777f}, {0.423243f, 0.704851f, -0.569255f}, {0.348741f, 0.320870f} },
    { {0.128376f, -0.045729f, 0.247057f}, {0.000000f, -0.000001f, 1.000000f}, {0.399053f, 0.261492f} },
    { {0.202101f, -0.069683f, 0.247057f}, {0.000000f, -0.000001f, 1.000000f}, {0.421435f, 0.252639f} },
    { {0.124905f, -0.175934f, 0.247057f}, {-0.097973f, -0.071182f, 0.992640f}, {0.397999f, 0.213371f} },
    { {-0.081769f, 0.026568f, 0.001319f}, {0.989158f, -0.120840f, 0.083451f}, {0.384903f, 0.288211f} },
    { {-0.026568f, 0.081768f, 0.010565f}, {0.299276f, -0.944099f, 0.138240f}, {0.368144f, 0.308612f} },
    { {0.037344f, -0.114935f, -0.005732f}, {0.181900f, -0.907729f, -0.378075f}, {0.348741f, 0.235915f} },
    { {0.069556f, -0.050536f, -0.011596f}, {-0.809187f, 0.582151f, 0.079481f}, {0.338961f, 0.259715f} },
    { {-0.079341f, -0.113220f, 0.247057f}, {0.216750f, 0.963330f, 0.158162f}, {0.330304f, 0.340445f} },
    { {-0.114935f, -0.037345f, 0.005536f}, {-0.892321f, -0.113707f, -0.436845f}, {0.394972f, 0.264591f} },
    { {-0.069556f, -0.050536f, -0.011596f}, {-0.238107f, 0.015239f, -0.971119f}, {0.381195f, 0.259715f} },
    { {-0.114935f, 0.037344f, 0.016509f}, {-0.756718f, 0.488208f, -0.434777f}, {0.394972f, 0.292194f} },
    { {0.120849f, -0.000000f, 0.011023f}, {0.902529f, 0.039193f, -0.428843f}, {0.323389f, 0.278392f} },
    { {0.069556f, 0.050535f, 0.005334f}, {-0.758441f, -0.651641f, 0.011450f}, {0.338961f, 0.297069f} },
    { {0.085976f, -0.000000f, -0.003131f}, {-0.997344f, -0.002634f, 0.072791f}, {0.333976f, 0.278392f} },
    { {0.097769f, 0.071033f, 0.021434f}, {0.718982f, 0.555654f, -0.417509f}, {0.330396f, 0.304645f} },
    { {-0.071034f, -0.097770f, -0.003264f}, {-0.600591f, -0.692919f, -0.398941f}, {0.381644f, 0.242259f} },
    { {0.079341f, -0.113220f, 0.247057f}, {-0.338324f, -0.172385f, 0.925105f}, {0.384166f, 0.236549f} },
    { {0.097769f, -0.071034f, 0.000612f}, {0.750737f, -0.505885f, -0.424822f}, {0.330396f, 0.252140f} },
    { {-0.114935f, 0.037344f, 0.016509f}, {-0.756718f, 0.488208f, -0.434777f}, {0.344557f, 0.230661f} },
    { {-0.124906f, 0.167901f, 0.247057f}, {-0.480596f, 0.810208f, -0.335545f}, {0.313206f, 0.340445f} },
    { {0.202101f, 0.061650f, 0.247057f}, {0.887759f, 0.296070f, -0.352457f}, {0.307885f, 0.340445f} },
    { {0.124905f, 0.167901f, 0.247057f}, {-0.403945f, 0.771812f, 0.491054f}, {0.397999f, 0.340445f} },
    { {0.041712f, -0.081201f, 0.217799f}, {-0.524261f, -0.170343f, 0.834346f}, {0.372742f, 0.248382f} },
    { {0.128376f, -0.045729f, 0.247057f}, {-0.935954f, 0.299459f, 0.185242f}, {0.375731f, 0.340445f} },
    { {0.069556f, -0.050536f, -0.011596f}, {-0.809187f, 0.582151f, 0.079481f}, {0.377535f, 0.217278f} },
    { {-0.069556f, -0.050536f, -0.011596f}, {-0.238107f, 0.015239f, -0.971119f}, {0.342621f, 0.217278f} },
    { {-0.128376f, 0.037696f, 0.247057f}, {0.933584f, -0.303340f, 0.190805f}, {0.375731f, 0.340445f} },
    { {0.069556f, 0.050535f, 0.005334f}, {-0.758441f, -0.651641f, 0.011450f}, {0.381195f, 0.225340f} },
    { {0.097769f, 0.071033f, 0.021434f}, {0.718982f, 0.555654f, -0.417509f}, {0.388242f, 0.233006f} },
};

WORD g_tind21[] = 
{
    2, 1, 0,    5, 4, 3,    8, 7, 6,    11, 10, 9,    14, 13, 12,
    1, 15, 0,    18, 17, 16,    21, 20, 19,    22, 20, 21,    25, 24, 23,
    27, 11, 26,    30, 29, 28,    26, 11, 9,    33, 32, 31,    7, 34, 6,
    37, 36, 35,    13, 38, 12,    0, 15, 39,    40, 5, 19,    43, 42, 41,
    45, 44, 26,    48, 47, 46,    51, 50, 49,    54, 53, 52,    57, 56, 55,
    60, 59, 58,    61, 33, 31,    64, 63, 62,    56, 24, 25,    67, 66, 65,
    70, 69, 68,    72, 70, 71,    53, 30, 28,    75, 74, 73,    78, 77, 76,
    77, 50, 51,    80, 79, 73,    74, 80, 73,    19, 5, 3,    66, 82, 81,
    71, 70, 68,    36, 83, 35,    79, 85, 84,    73, 79, 86,    89, 88, 87,
    90, 88, 75,    84, 85, 91,    91, 67, 65,    92, 78, 76,    23, 18, 16,
    93, 89, 87,    81, 82, 93,    63, 72, 62,    95, 94, 8,    96, 48, 46,
    50, 97, 49,    42, 78, 92,    98, 42, 92,    44, 27, 26,    52, 53, 28,
    100, 99, 14,    82, 89, 93,    37, 35, 101,    85, 67, 91,    76, 77, 51,
    99, 13, 14,    20, 40, 19,    41, 42, 98,    102, 36, 37,    62, 72, 71,
    103, 44, 45,    88, 74, 75,    65, 66, 81,    24, 18, 23,    87, 88, 90,
    15, 104, 39,    55, 56, 25,    69, 43, 41,    86, 79, 84,    94, 7, 8,

};

D3DMATRIX g_tmat22 = 
{
    -0.926124f, -0.140646f, 0.350020f, 0.000000f, 
    -0.115152f, 0.989011f, 0.092725f, 0.000000f, 
    -0.359215f, 0.045569f, -0.932142f, 0.000000f, 
    -0.508220f, -2.323931f, 3.014328f, 1.000000f, 
};

// Mesh #22 Tris:518 Verts:420
MODELVERT g_tmesh22[] = 
{
    { {0.179222f, 0.243226f, 0.492815f}, {0.381066f, 0.907097f, -0.178784f}, {0.361856f, 0.250127f} },
    { {0.113078f, 0.187273f, 0.036920f}, {0.448027f, 0.868280f, -0.212983f}, {0.419692f, 0.265343f} },
    { {-0.003281f, 0.250421f, 0.175655f}, {0.162908f, 0.974865f, -0.151986f}, {0.401839f, 0.289509f} },
    { {0.064235f, -0.273580f, 0.527082f}, {-0.345688f, -0.933844f, 0.091841f}, {0.357598f, 0.274300f} },
    { {0.145450f, -0.278733f, 0.559698f}, {0.181684f, -0.973950f, -0.135692f}, {0.353593f, 0.257074f} },
    { {0.100669f, -0.282022f, 0.654248f}, {-0.277908f, -0.960477f, 0.015857f}, {0.341509f, 0.266262f} },
    { {0.301333f, -0.151490f, 0.746868f}, {0.979034f, -0.176058f, -0.102449f}, {0.330004f, 0.223666f} },
    { {0.318896f, -0.032339f, 0.751519f}, {0.985371f, -0.097986f, -0.139434f}, {0.329377f, 0.219947f} },
    { {0.314131f, -0.097835f, 0.812849f}, {0.976413f, -0.215665f, 0.010306f}, {0.321614f, 0.220783f} },
    { {0.257179f, -0.163135f, 0.978453f}, {-0.863795f, 0.425465f, 0.269885f}, {0.300518f, 0.232343f} },
    { {0.289645f, 0.001626f, 0.986113f}, {-0.933142f, 0.001056f, 0.359506f}, {0.299508f, 0.225470f} },
    { {0.213815f, -0.000285f, 0.614902f}, {-0.971200f, 0.106045f, 0.213366f}, {0.346539f, 0.242494f} },
    { {0.097258f, 0.280375f, 0.559845f}, {-0.174174f, 0.984705f, 0.004407f}, {0.353184f, 0.267235f} },
    { {-0.115682f, 0.223095f, 0.262161f}, {-0.595661f, 0.774408f, 0.213262f}, {0.390678f, 0.312986f} },
    { {-0.013460f, 0.209421f, 0.525912f}, {-0.655481f, 0.704640f, 0.271710f}, {0.357350f, 0.290690f} },
    { {0.039611f, -0.248033f, 0.564295f}, {-0.619946f, -0.775119f, 0.121895f}, {0.352816f, 0.279392f} },
    { {0.275019f, -0.110675f, 0.511310f}, {0.990375f, -0.052266f, -0.128164f}, {0.359862f, 0.229868f} },
    { {0.277326f, 0.103176f, 0.513368f}, {0.989018f, 0.071195f, -0.129519f}, {0.359486f, 0.229374f} },
    { {0.318866f, 0.032603f, 0.751210f}, {0.986746f, 0.038107f, -0.157733f}, {0.329380f, 0.219953f} },
    { {0.086608f, 0.234596f, 0.840245f}, {0.261154f, -0.877645f, 0.401917f}, {0.317571f, 0.268708f} },
    { {0.103167f, 0.151813f, 0.537545f}, {-0.609733f, -0.718316f, 0.335033f}, {0.356098f, 0.266051f} },
    { {0.159967f, 0.266001f, 0.935382f}, {-0.584376f, -0.715493f, 0.382851f}, {0.305590f, 0.252967f} },
    { {-0.243722f, 0.081149f, 0.191827f}, {-0.980860f, 0.167589f, 0.099140f}, {0.399479f, 0.340197f} },
    { {-0.239713f, -0.094006f, 0.145502f}, {-0.985422f, -0.169998f, -0.006686f}, {0.405467f, 0.339481f} },
    { {-0.234378f, -0.001498f, 0.302609f}, {-0.937980f, 0.065509f, 0.340445f}, {0.385467f, 0.337920f} },
    { {-0.181631f, -0.004477f, 0.000022f}, {-0.056255f, -0.007525f, -0.998388f}, {0.423995f, 0.327627f} },
    { {0.000481f, -0.187504f, 0.001664f}, {0.001498f, -0.324489f, -0.945888f}, {0.424191f, 0.289201f} },
    { {-0.157354f, -0.096682f, 0.000785f}, {-0.363395f, -0.252532f, -0.896756f}, {0.423990f, 0.322504f} },
    { {0.325616f, 0.097929f, 0.233881f}, {0.963551f, 0.264392f, -0.040835f}, {0.395074f, 0.219957f} },
    { {0.318483f, 0.054752f, 0.449401f}, {0.950812f, 0.246393f, 0.187743f}, {0.367707f, 0.220867f} },
    { {0.318558f, -0.052694f, 0.449628f}, {0.990316f, -0.102233f, 0.093927f}, {0.367738f, 0.220852f} },
    { {0.128172f, -0.183500f, 0.038998f}, {0.343389f, -0.904966f, -0.251238f}, {0.419658f, 0.262157f} },
    { {0.125055f, -0.243578f, 0.391905f}, {0.564111f, -0.812543f, -0.146807f}, {0.374855f, 0.261840f} },
    { {-0.003261f, -0.254780f, 0.178100f}, {0.159252f, -0.977585f, -0.137715f}, {0.401808f, 0.289504f} },
    { {-0.168646f, 0.062578f, 0.682153f}, {0.402086f, -0.799827f, 0.445649f}, {0.337325f, 0.323002f} },
    { {0.028301f, 0.089107f, 0.480119f}, {0.542019f, -0.727312f, 0.420991f}, {0.363303f, 0.282007f} },
    { {-0.064378f, -0.136272f, 0.736941f}, {0.350573f, 0.864343f, 0.360570f}, {0.330649f, 0.300854f} },
    { {0.086614f, -0.233171f, 0.842824f}, {0.202073f, 0.889849f, 0.409066f}, {0.317503f, 0.268705f} },
    { {0.028376f, -0.090884f, 0.480898f}, {0.531165f, 0.742320f, 0.408441f}, {0.363304f, 0.281991f} },
    { {0.299007f, 0.151060f, 0.710175f}, {0.995835f, 0.081683f, -0.040501f}, {0.334494f, 0.224255f} },
    { {0.296138f, 0.238953f, 0.707743f}, {0.943929f, 0.292146f, -0.153784f}, {0.334750f, 0.224866f} },
    { {0.287354f, 0.270231f, 0.862502f}, {0.947662f, 0.253255f, 0.194418f}, {0.315058f, 0.226291f} },
    { {-0.053649f, 0.102568f, 0.808674f}, {-0.859130f, 0.174817f, 0.480972f}, {0.321422f, 0.298389f} },
    { {-0.027138f, 0.022148f, 0.848868f}, {-0.834009f, 0.000827f, 0.551750f}, {0.316404f, 0.292686f} },
    { {-0.000353f, 0.082072f, 0.890030f}, {-0.838747f, -0.021274f, 0.544105f}, {0.311187f, 0.286920f} },
    { {-0.122327f, -0.148038f, 0.626494f}, {-0.578826f, -0.810317f, -0.091362f}, {0.344590f, 0.313386f} },
    { {0.017350f, -0.228943f, 0.574206f}, {-0.541605f, -0.832437f, -0.117103f}, {0.351509f, 0.284061f} },
    { {0.026141f, -0.217419f, 0.759678f}, {-0.628094f, -0.763454f, 0.150453f}, {0.327956f, 0.281694f} },
    { {-0.164636f, -0.183652f, 0.269651f}, {-0.734387f, -0.587512f, 0.339859f}, {0.389870f, 0.323299f} },
    { {-0.068682f, -0.161295f, 0.486253f}, {-0.765951f, -0.507052f, 0.395243f}, {0.362502f, 0.302455f} },
    { {-0.217030f, -0.074870f, 0.307833f}, {-0.847550f, -0.401184f, 0.347435f}, {0.384873f, 0.334246f} },
    { {0.237025f, -0.355417f, 0.801611f}, {0.791425f, -0.604192f, 0.092730f}, {0.323056f, 0.237086f} },
    { {0.287598f, -0.268474f, 0.865200f}, {0.929730f, -0.285090f, 0.233080f}, {0.315014f, 0.226239f} },
    { {0.228107f, -0.303220f, 0.909603f}, {0.515779f, -0.505580f, 0.691636f}, {0.309294f, 0.238669f} },
    { {0.308430f, -0.086681f, 0.928340f}, {0.915571f, -0.260848f, 0.306086f}, {0.306927f, 0.221667f} },
    { {0.265598f, -0.175773f, 0.970599f}, {0.796233f, -0.341088f, 0.499672f}, {0.301537f, 0.230589f} },
    { {0.178120f, -0.003595f, 0.000021f}, {0.196710f, -0.023142f, -0.980189f}, {0.424593f, 0.251724f} },
    { {0.100372f, -0.154322f, 0.001425f}, {0.082286f, -0.092811f, -0.992278f}, {0.424369f, 0.268126f} },
    { {0.326429f, -0.095848f, 0.197092f}, {0.925098f, -0.377319f, -0.042716f}, {0.399856f, 0.219889f} },
    { {-0.194426f, -0.000181f, 0.659919f}, {0.630638f, -0.154300f, 0.760584f}, {0.340142f, 0.328504f} },
    { {-0.120641f, 0.108226f, 0.451658f}, {-0.827757f, 0.370079f, 0.421733f}, {0.366661f, 0.313510f} },
    { {-0.207000f, 0.115456f, 0.283250f}, {-0.790649f, 0.512081f, 0.335630f}, {0.387907f, 0.332196f} },
    { {0.264639f, 0.170323f, 0.974635f}, {-0.795507f, -0.434257f, 0.422598f}, {0.300831f, 0.230775f} },
    { {0.247238f, 0.347870f, 0.805583f}, {0.792052f, 0.605970f, 0.073859f}, {0.322179f, 0.234912f} },
    { {0.241920f, 0.298953f, 0.900987f}, {0.501446f, 0.494696f, 0.709808f}, {0.310077f, 0.235771f} },
    { {0.265718f, -0.119637f, 0.227038f}, {0.636144f, -0.768593f, -0.067712f}, {0.395964f, 0.232616f} },
    { {0.277007f, -0.091821f, 0.434097f}, {0.767317f, -0.636072f, -0.081466f}, {0.369664f, 0.229662f} },
    { {0.296355f, -0.239045f, 0.709974f}, {0.943898f, -0.290530f, -0.157001f}, {0.334731f, 0.224820f} },
    { {0.244751f, -0.171534f, 0.529133f}, {0.931510f, -0.186301f, -0.312378f}, {0.357581f, 0.236206f} },
    { {0.283443f, -0.150019f, 0.639518f}, {0.967620f, -0.054675f, -0.246417f}, {0.343611f, 0.227737f} },
    { {-0.053649f, -0.088421f, 0.809507f}, {-0.870000f, -0.327169f, 0.368864f}, {0.321422f, 0.298389f} },
    { {0.057215f, -0.215246f, 0.929271f}, {-0.712408f, -0.540264f, 0.447873f}, {0.306462f, 0.274669f} },
    { {0.038783f, -0.080638f, 0.953663f}, {-0.724007f, -0.184509f, 0.664657f}, {0.303258f, 0.278489f} },
    { {0.120570f, -0.089088f, 1.009108f}, {-0.575541f, -0.101111f, 0.811498f}, {0.296355f, 0.261080f} },
    { {0.079069f, -0.036981f, 0.980765f}, {-0.560879f, 0.003612f, 0.827890f}, {0.299858f, 0.269914f} },
    { {0.033480f, -0.242776f, 0.567024f}, {-0.653335f, -0.753417f, 0.074275f}, {0.352456f, 0.280678f} },
    { {0.150225f, -0.355855f, 0.737025f}, {-0.480329f, -0.876362f, -0.035683f}, {0.331117f, 0.255578f} },
    { {0.153822f, -0.348760f, 0.832157f}, {-0.325837f, -0.915129f, 0.237422f}, {0.319034f, 0.254556f} },
    { {0.099021f, -0.301222f, 0.803187f}, {-0.722763f, -0.686325f, 0.081063f}, {0.322596f, 0.266198f} },
    { {-0.159777f, 0.111390f, 0.653979f}, {-0.767077f, 0.623751f, -0.150093f}, {0.340892f, 0.321208f} },
    { {-0.116427f, 0.090895f, 0.493256f}, {-0.891656f, 0.355984f, -0.279688f}, {0.361393f, 0.312506f} },
    { {-0.180354f, 0.062428f, 0.632481f}, {-0.937319f, 0.219811f, -0.270398f}, {0.343616f, 0.325610f} },
    { {-0.119287f, -0.086448f, 0.519417f}, {-0.762385f, -0.531572f, -0.369055f}, {0.358163f, 0.313040f} },
    { {-0.180343f, -0.062737f, 0.633170f}, {-0.908439f, -0.232350f, -0.347495f}, {0.343598f, 0.325607f} },
    { {-0.153243f, -0.000321f, 0.562159f}, {-0.949678f, 0.001962f, -0.313221f}, {0.352629f, 0.320085f} },
    { {0.209975f, 0.052831f, 0.623959f}, {-0.910357f, -0.315414f, 0.267887f}, {0.345353f, 0.243279f} },
    { {-0.077422f, -0.000482f, 0.562139f}, {0.708510f, 0.132937f, 0.693067f}, {0.352758f, 0.304088f} },
    { {-0.168842f, -0.062564f, 0.683081f}, {0.549789f, 0.641722f, 0.534720f}, {0.337276f, 0.323043f} },
    { {0.150022f, 0.356274f, 0.733465f}, {-0.368679f, 0.929498f, -0.010468f}, {0.331174f, 0.255622f} },
    { {0.098916f, 0.302311f, 0.800127f}, {-0.722798f, 0.686956f, 0.075197f}, {0.322650f, 0.266221f} },
    { {0.153662f, 0.350081f, 0.828632f}, {-0.523278f, 0.770802f, 0.363380f}, {0.319094f, 0.254591f} },
    { {0.177289f, 0.266724f, 0.503205f}, {0.378995f, 0.790752f, -0.480701f}, {0.360520f, 0.250506f} },
    { {0.138181f, 0.280522f, 0.573702f}, {-0.513026f, 0.780980f, -0.356195f}, {0.351492f, 0.258563f} },
    { {0.166597f, 0.348702f, 0.682263f}, {-0.259787f, 0.893608f, -0.366026f}, {0.337710f, 0.252267f} },
    { {0.038783f, 0.084928f, 0.952940f}, {-0.744270f, 0.173143f, 0.645046f}, {0.303258f, 0.278489f} },
    { {0.056982f, 0.230438f, 0.927518f}, {-0.737280f, 0.330972f, 0.588962f}, {0.306437f, 0.274718f} },
    { {-0.000045f, 0.195560f, 0.849463f}, {-0.822797f, 0.504429f, 0.261832f}, {0.316278f, 0.286966f} },
    { {-0.195601f, 0.054308f, 0.021966f}, {-0.860316f, 0.143978f, -0.489006f}, {0.421152f, 0.330513f} },
    { {-0.243828f, -0.002604f, 0.110258f}, {-0.963595f, 0.020607f, -0.266571f}, {0.409887f, 0.340445f} },
    { {-0.239692f, 0.089536f, 0.144682f}, {-0.928262f, 0.212696f, -0.305107f}, {0.405470f, 0.339476f} },
    { {-0.085490f, 0.239986f, 0.197332f}, {-0.260692f, 0.964247f, -0.047627f}, {0.398954f, 0.306794f} },
    { {-0.058556f, -0.088973f, 0.682995f}, {-0.640830f, -0.762551f, -0.088616f}, {0.337485f, 0.299774f} },
    { {0.033197f, -0.181250f, 0.813534f}, {-0.449526f, -0.879122f, -0.158337f}, {0.321106f, 0.280056f} },
    { {-0.051241f, -0.180265f, 0.492491f}, {-0.667427f, -0.683856f, 0.294760f}, {0.361749f, 0.298758f} },
    { {-0.115608f, -0.226547f, 0.264156f}, {-0.584566f, -0.785634f, 0.202635f}, {0.390674f, 0.312970f} },
    { {-0.192480f, -0.140619f, 0.060648f}, {-0.751071f, -0.433800f, -0.497705f}, {0.416351f, 0.329750f} },
    { {-0.212862f, -0.072687f, 0.048684f}, {-0.861539f, -0.147599f, -0.485763f}, {0.417799f, 0.334083f} },
    { {0.162171f, -0.161838f, 0.039337f}, {0.602643f, -0.721182f, -0.341640f}, {0.419660f, 0.254982f} },
    { {0.237951f, -0.086572f, 0.063299f}, {0.638933f, -0.150683f, -0.754360f}, {0.416700f, 0.238927f} },
    { {0.166830f, -0.348800f, 0.685687f}, {-0.298435f, -0.893795f, -0.334765f}, {0.337662f, 0.252216f} },
    { {0.094573f, -0.292271f, 0.681512f}, {-0.646856f, -0.737078f, -0.195687f}, {0.338041f, 0.267473f} },
    { {0.153827f, -0.290312f, 0.558821f}, {-0.127994f, -0.909765f, -0.394898f}, {0.353724f, 0.255309f} },
    { {0.250080f, -0.285174f, 0.628681f}, {0.813692f, -0.468419f, -0.344222f}, {0.345007f, 0.234808f} },
    { {0.339780f, 0.067670f, 0.814326f}, {0.980778f, 0.136672f, -0.139270f}, {0.321377f, 0.215366f} },
    { {0.347887f, 0.062072f, 0.917349f}, {0.971539f, 0.236832f, -0.004729f}, {0.308306f, 0.213371f} },
    { {0.346777f, -0.078705f, 0.902125f}, {0.976881f, -0.204639f, -0.061854f}, {0.310317f, 0.213649f} },
    { {0.292838f, 0.171336f, 0.858821f}, {0.910172f, 0.386903f, 0.147962f}, {0.315589f, 0.225146f} },
    { {0.228130f, 0.234069f, 0.919247f}, {0.740673f, 0.600598f, 0.301140f}, {0.307771f, 0.238631f} },
    { {0.123553f, 0.108099f, 1.014521f}, {-0.604490f, 0.092150f, 0.791265f}, {0.295564f, 0.260434f} },
    { {0.084691f, 0.022739f, 0.984314f}, {-0.585469f, -0.013532f, 0.810582f}, {0.299384f, 0.268717f} },
    { {-0.010733f, 0.207596f, 0.581273f}, {-0.529044f, 0.843369f, -0.094025f}, {0.350323f, 0.289962f} },
    { {-0.120055f, 0.148001f, 0.661840f}, {-0.603381f, 0.794661f, 0.066677f}, {0.339939f, 0.312805f} },
    { {0.026107f, 0.218121f, 0.757499f}, {-0.647203f, 0.739436f, 0.185371f}, {0.327991f, 0.281702f} },
    { {-0.099066f, 0.112090f, 0.510745f}, {-0.613129f, 0.745097f, -0.262495f}, {0.359188f, 0.308795f} },
    { {0.073384f, -0.273931f, 0.610751f}, {-0.673471f, -0.736283f, 0.065751f}, {0.346985f, 0.272138f} },
    { {0.086196f, -0.280692f, 0.682389f}, {-0.707271f, -0.706359f, 0.028704f}, {0.337909f, 0.269237f} },
    { {0.087159f, 0.239109f, 0.889184f}, {-0.531255f, 0.826606f, -0.185715f}, {0.311353f, 0.268457f} },
    { {-0.056102f, 0.102292f, 0.745402f}, {-0.616686f, 0.759032f, -0.208732f}, {0.329456f, 0.299082f} },
    { {0.246208f, 0.105762f, 0.115843f}, {0.667620f, 0.733331f, -0.128491f}, {0.409932f, 0.237037f} },
    { {0.172217f, 0.221183f, 0.433095f}, {0.685257f, 0.713455f, -0.146303f}, {0.369443f, 0.251770f} },
    { {0.243285f, 0.143140f, 0.425406f}, {0.754681f, 0.649208f, -0.094794f}, {0.370581f, 0.236798f} },
    { {0.249836f, 0.284216f, 0.626107f}, {0.767107f, 0.520450f, -0.375072f}, {0.345018f, 0.234860f} },
    { {0.252969f, 0.181216f, 0.527356f}, {0.872935f, 0.316922f, -0.370870f}, {0.357625f, 0.234473f} },
    { {0.210018f, -0.053350f, 0.624426f}, {-0.835385f, 0.408331f, 0.367963f}, {0.345352f, 0.243270f} },
    { {0.103301f, -0.153130f, 0.538942f}, {-0.618576f, 0.721749f, 0.310551f}, {0.356090f, 0.266023f} },
    { {0.184829f, 0.043959f, 0.580271f}, {-0.725254f, -0.043101f, 0.687131f}, {0.350866f, 0.248705f} },
    { {0.101593f, 0.121970f, 0.510247f}, {-0.648324f, -0.061798f, 0.758852f}, {0.359580f, 0.266459f} },
    { {0.101712f, -0.123551f, 0.511353f}, {-0.668266f, 0.098211f, 0.737411f}, {0.359575f, 0.266434f} },
    { {0.237917f, 0.080509f, 0.062460f}, {0.692227f, 0.042671f, -0.720417f}, {0.416714f, 0.238934f} },
    { {0.076156f, 0.138782f, 0.515990f}, {0.434731f, -0.831907f, 0.344876f}, {0.358798f, 0.271810f} },
    { {0.045496f, -0.073639f, 0.467682f}, {-0.581266f, 0.131067f, 0.803089f}, {0.365002f, 0.278415f} },
    { {0.028915f, -0.001189f, 0.439564f}, {0.360300f, 0.004177f, 0.932827f}, {0.368506f, 0.281990f} },
    { {-0.014004f, -0.211140f, 0.521769f}, {-0.625116f, -0.778506f, 0.056201f}, {0.358108f, 0.290821f} },
    { {0.315506f, 0.097981f, 0.814408f}, {0.972348f, 0.231858f, -0.027967f}, {0.321310f, 0.220487f} },
    { {0.299007f, 0.151060f, 0.710175f}, {0.977832f, 0.182012f, -0.103516f}, {0.334494f, 0.224255f} },
    { {0.311119f, 0.105246f, 0.899364f}, {0.923044f, 0.339521f, 0.180871f}, {0.310506f, 0.221178f} },
    { {0.026107f, 0.218121f, 0.757499f}, {-0.685586f, 0.677314f, 0.266866f}, {0.327991f, 0.281702f} },
    { {0.073449f, 0.273479f, 0.608265f}, {-0.606942f, 0.792906f, 0.054056f}, {0.346997f, 0.272125f} },
    { {-0.010733f, 0.207596f, 0.581273f}, {-0.668387f, 0.738482f, 0.088902f}, {0.350323f, 0.289962f} },
    { {0.094418f, 0.292291f, 0.678621f}, {-0.649250f, 0.732093f, -0.206192f}, {0.338084f, 0.267506f} },
    { {0.006911f, 0.059431f, 0.898257f}, {-0.782646f, 0.002715f, 0.622461f}, {0.310166f, 0.285365f} },
    { {-0.015565f, 0.015366f, 0.870189f}, {-0.782646f, 0.002716f, 0.622461f}, {0.313719f, 0.290185f} },
    { {0.057217f, -0.040341f, 0.961943f}, {-0.770016f, 0.115034f, 0.627569f}, {0.302215f, 0.274577f} },
    { {-0.192413f, 0.135378f, 0.059439f}, {-0.733666f, 0.516516f, -0.441526f}, {0.416352f, 0.329736f} },
    { {-0.157146f, 0.090978f, 0.000161f}, {-0.313930f, 0.241578f, -0.918198f}, {0.423965f, 0.322459f} },
    { {0.000555f, 0.181629f, -0.000000f}, {-0.013594f, 0.312671f, -0.949764f}, {0.424198f, 0.289186f} },
    { {0.228262f, -0.231721f, 0.921502f}, {0.493065f, -0.143174f, 0.858130f}, {0.307743f, 0.238602f} },
    { {0.111010f, -0.288277f, 0.848110f}, {-0.576097f, -0.608849f, 0.545358f}, {0.316902f, 0.263544f} },
    { {0.207833f, -0.340828f, 0.881291f}, {-0.181943f, -0.867297f, 0.463349f}, {0.312877f, 0.243025f} },
    { {0.168934f, -0.281539f, 0.914451f}, {-0.304272f, -0.524033f, 0.795492f}, {0.308567f, 0.251140f} },
    { {0.293829f, -0.166670f, 0.860373f}, {0.943166f, -0.311219f, 0.116533f}, {0.315581f, 0.224936f} },
    { {-0.011310f, -0.227668f, 0.055473f}, {0.020305f, -0.937285f, -0.347972f}, {0.417358f, 0.291541f} },
    { {-0.111005f, -0.183967f, 0.022195f}, {-0.313898f, -0.583215f, -0.749219f}, {0.421395f, 0.312667f} },
    { {-0.219252f, -0.135316f, 0.132764f}, {-0.767371f, -0.623812f, -0.148324f}, {0.407142f, 0.335199f} },
    { {-0.154324f, -0.176027f, 0.051901f}, {-0.599954f, -0.743034f, -0.296573f}, {0.417545f, 0.321724f} },
    { {-0.152024f, -0.206205f, 0.140182f}, {-0.584329f, -0.806234f, -0.092448f}, {0.406351f, 0.320995f} },
    { {0.209636f, -0.077956f, 0.969399f}, {-0.604623f, 0.595582f, 0.528879f}, {0.301542f, 0.242398f} },
    { {0.209636f, 0.091813f, 0.968659f}, {-0.126885f, -0.399184f, 0.908049f}, {0.301542f, 0.242398f} },
    { {0.158623f, -0.078284f, 0.901158f}, {-0.713344f, 0.408958f, 0.569117f}, {0.310126f, 0.253349f} },
    { {0.158623f, 0.091485f, 0.900417f}, {-0.711557f, -0.456525f, 0.534107f}, {0.310126f, 0.253349f} },
    { {0.265598f, -0.175773f, 0.970599f}, {0.674783f, -0.686970f, 0.269703f}, {0.301537f, 0.230589f} },
    { {0.228262f, -0.231721f, 0.921502f}, {0.674783f, -0.686970f, 0.269703f}, {0.307743f, 0.238602f} },
    { {0.274284f, -0.185943f, 0.890154f}, {0.749208f, -0.642196f, 0.162086f}, {0.311776f, 0.228978f} },
    { {0.159929f, -0.263629f, 0.937995f}, {-0.573460f, 0.732429f, 0.367004f}, {0.305552f, 0.252974f} },
    { {0.246208f, 0.105762f, 0.115843f}, {0.139823f, 0.970141f, -0.198183f}, {0.409932f, 0.237037f} },
    { {0.268205f, 0.114153f, 0.274776f}, {0.009659f, 0.998167f, 0.059743f}, {0.389774f, 0.231957f} },
    { {0.237951f, -0.086572f, 0.063299f}, {0.454997f, -0.008038f, -0.890456f}, {0.416700f, 0.238927f} },
    { {0.237917f, 0.080509f, 0.062460f}, {0.552456f, 0.304338f, -0.775997f}, {0.416714f, 0.238934f} },
    { {0.304241f, 0.080884f, 0.101796f}, {0.761021f, 0.254593f, -0.596682f}, {0.411827f, 0.224832f} },
    { {0.120191f, 0.116372f, 0.980875f}, {0.606289f, 0.204266f, -0.768563f}, {0.299828f, 0.261236f} },
    { {0.067449f, 0.199010f, 0.916532f}, {0.801558f, -0.588541f, 0.105476f}, {0.307868f, 0.272540f} },
    { {0.081717f, 0.221532f, 0.933773f}, {0.863383f, 0.504536f, -0.003491f}, {0.305689f, 0.269482f} },
    { {0.087159f, 0.239109f, 0.889184f}, {0.223365f, 0.971912f, -0.074134f}, {0.311353f, 0.268457f} },
    { {0.148774f, 0.220040f, 0.844590f}, {0.422901f, 0.897512f, -0.125008f}, {0.317131f, 0.255580f} },
    { {0.074869f, 0.194830f, 0.682154f}, {0.143278f, 0.966022f, -0.215112f}, {0.337657f, 0.271622f} },
    { {-0.129558f, -0.074100f, 0.476283f}, {-0.849658f, -0.285968f, 0.443061f}, {0.363619f, 0.315326f} },
    { {-0.117428f, 0.096207f, 0.475550f}, {-0.870866f, 0.265139f, 0.413876f}, {0.363637f, 0.312766f} },
    { {0.074869f, -0.181816f, 0.683797f}, {-0.408151f, -0.904016f, -0.127155f}, {0.337657f, 0.271622f} },
    { {0.148774f, -0.205570f, 0.846447f}, {-0.164126f, -0.975770f, -0.144689f}, {0.317131f, 0.255580f} },
    { {0.134507f, -0.184155f, 0.862865f}, {0.449942f, 0.709613f, 0.542219f}, {0.315009f, 0.258545f} },
    { {0.066344f, -0.183910f, 0.919107f}, {0.449942f, 0.709614f, 0.542218f}, {0.307751f, 0.272771f} },
    { {0.080612f, -0.206280f, 0.936544f}, {0.449942f, 0.709613f, 0.542219f}, {0.305572f, 0.269713f} },
    { {0.287558f, 0.087231f, 0.418772f}, {0.790564f, 0.608778f, -0.066315f}, {0.371529f, 0.227476f} },
    { {0.100669f, -0.282022f, 0.654248f}, {-0.752979f, -0.542588f, -0.372319f}, {0.341509f, 0.266262f} },
    { {0.145450f, -0.278733f, 0.559698f}, {-0.740416f, -0.512710f, -0.434642f}, {0.353593f, 0.257074f} },
    { {0.094573f, -0.292271f, 0.681512f}, {-0.758793f, -0.532571f, -0.374967f}, {0.338041f, 0.267473f} },
    { {0.301586f, -0.074268f, 0.090249f}, {0.917061f, -0.102321f, -0.385396f}, {0.413375f, 0.225426f} },
    { {0.289472f, -0.086407f, 0.440199f}, {0.513960f, -0.842912f, 0.159203f}, {0.368906f, 0.227015f} },
    { {0.265718f, -0.119637f, 0.227038f}, {0.358419f, -0.933558f, -0.002343f}, {0.395964f, 0.232616f} },
    { {0.244751f, -0.171534f, 0.529133f}, {0.759752f, -0.582826f, -0.288255f}, {0.357581f, 0.236206f} },
    { {0.283443f, -0.150019f, 0.639518f}, {0.883233f, -0.440025f, -0.162105f}, {0.343611f, 0.227737f} },
    { {0.285367f, -0.034234f, 0.489707f}, {0.978632f, -0.078806f, 0.189918f}, {0.362581f, 0.227744f} },
    { {0.057217f, -0.040341f, 0.961943f}, {-0.823644f, 0.328791f, 0.462068f}, {0.302215f, 0.274577f} },
    { {-0.019910f, -0.055507f, 0.898524f}, {-0.536387f, 0.198426f, 0.820314f}, {0.310151f, 0.291025f} },
    { {0.011666f, -0.084790f, 0.933007f}, {-0.823681f, -0.174264f, 0.539613f}, {0.305839f, 0.284268f} },
    { {-0.000353f, -0.078330f, 0.890730f}, {-0.837706f, 0.041233f, 0.544562f}, {0.311187f, 0.286920f} },
    { {-0.023298f, -0.037530f, 0.854899f}, {-0.834791f, 0.006826f, 0.550525f}, {0.315678f, 0.291860f} },
    { {-0.110930f, 0.178328f, 0.020607f}, {-0.388879f, 0.661082f, -0.641673f}, {0.421396f, 0.312651f} },
    { {-0.151999f, 0.201705f, 0.138328f}, {-0.556870f, 0.810323f, -0.182406f}, {0.406360f, 0.320990f} },
    { {0.228130f, 0.234069f, 0.919247f}, {0.530275f, 0.123233f, 0.838822f}, {0.307771f, 0.238631f} },
    { {0.110938f, 0.289771f, 0.845251f}, {-0.637297f, 0.588546f, 0.497460f}, {0.316945f, 0.263560f} },
    { {0.168836f, 0.283720f, 0.911697f}, {-0.304428f, 0.544630f, 0.781474f}, {0.308604f, 0.251161f} },
    { {0.313166f, -0.059401f, 0.940323f}, {0.845080f, -0.071818f, 0.529794f}, {0.305397f, 0.220634f} },
    { {0.314121f, 0.063663f, 0.939642f}, {0.861233f, 0.163070f, 0.481338f}, {0.305417f, 0.220433f} },
    { {0.111010f, -0.288277f, 0.848110f}, {-0.761552f, -0.361679f, 0.537797f}, {0.316902f, 0.263544f} },
    { {0.164365f, -0.280575f, 0.924125f}, {-0.489717f, -0.582349f, 0.648881f}, {0.307330f, 0.252077f} },
    { {-0.159761f, -0.111560f, 0.655196f}, {-0.755517f, -0.623802f, 0.200163f}, {0.340861f, 0.321204f} },
    { {-0.214518f, -0.143190f, 0.204062f}, {-0.799145f, -0.588068f, 0.124674f}, {0.398097f, 0.334004f} },
    { {0.231684f, 0.356903f, 0.727607f}, {0.469408f, 0.854969f, -0.220646f}, {0.332054f, 0.238409f} },
    { {0.207635f, 0.342661f, 0.877877f}, {0.035174f, 0.940165f, 0.338898f}, {0.312932f, 0.243068f} },
    { {0.033480f, -0.242776f, 0.567024f}, {-0.631299f, -0.772393f, 0.069792f}, {0.352456f, 0.280678f} },
    { {0.017350f, -0.228943f, 0.574206f}, {-0.730134f, -0.643624f, 0.229463f}, {0.351509f, 0.284061f} },
    { {0.231957f, -0.356721f, 0.731112f}, {0.402229f, -0.888687f, -0.220108f}, {0.332004f, 0.238350f} },
    { {0.274284f, -0.185943f, 0.890154f}, {0.725204f, -0.089421f, 0.682702f}, {0.311776f, 0.228978f} },
    { {0.301333f, -0.151490f, 0.746868f}, {0.998908f, -0.046032f, -0.007970f}, {0.330004f, 0.223666f} },
    { {0.293829f, -0.166670f, 0.860373f}, {0.983519f, -0.051986f, 0.173168f}, {0.315581f, 0.224936f} },
    { {0.120570f, -0.089088f, 1.009108f}, {0.669177f, 0.734735f, 0.111205f}, {0.296355f, 0.261080f} },
    { {0.123553f, 0.108099f, 1.014521f}, {0.974458f, -0.165722f, -0.151551f}, {0.295564f, 0.260434f} },
    { {0.090896f, -0.078040f, 0.956987f}, {0.869248f, 0.215211f, -0.445075f}, {0.302921f, 0.267485f} },
    { {-0.088691f, 0.208318f, 0.055283f}, {-0.253499f, 0.929269f, -0.268695f}, {0.417012f, 0.307862f} },
    { {0.000565f, 0.221561f, 0.053018f}, {0.039332f, 0.917954f, -0.394731f}, {0.417441f, 0.289037f} },
    { {0.283332f, 0.149265f, 0.638342f}, {0.970476f, 0.044819f, -0.236996f}, {0.343594f, 0.227761f} },
    { {0.297092f, 0.003123f, 0.490962f}, {0.823502f, 0.024467f, 0.566786f}, {0.362421f, 0.225266f} },
    { {0.266295f, 0.126764f, 0.497731f}, {0.822589f, 0.565299f, -0.061511f}, {0.361441f, 0.231744f} },
    { {0.187823f, -0.257136f, 0.493392f}, {0.481468f, -0.759854f, -0.436818f}, {0.362074f, 0.248317f} },
    { {0.237407f, -0.200826f, 0.508192f}, {0.837398f, -0.402481f, -0.369830f}, {0.360246f, 0.237814f} },
    { {0.074869f, 0.194830f, 0.682154f}, {-0.565414f, 0.812793f, -0.140269f}, {0.337657f, 0.271622f} },
    { {-0.058556f, 0.102016f, 0.682162f}, {-0.605210f, 0.790105f, -0.097234f}, {0.337485f, 0.299774f} },
    { {0.090896f, 0.091728f, 0.956246f}, {0.557548f, -0.804455f, -0.204919f}, {0.302921f, 0.267485f} },
    { {0.186058f, 0.112643f, 0.025237f}, {0.521761f, 0.276073f, -0.807186f}, {0.421339f, 0.249978f} },
    { {0.092340f, 0.156881f, -0.000000f}, {0.078031f, 0.091309f, -0.992761f}, {0.424364f, 0.269821f} },
    { {0.162195f, 0.156213f, 0.037788f}, {0.583819f, 0.647571f, -0.489701f}, {0.419680f, 0.254978f} },
    { {0.076277f, -0.140271f, 0.517250f}, {0.435129f, 0.834949f, 0.336932f}, {0.358793f, 0.271784f} },
    { {0.094573f, -0.292271f, 0.681512f}, {-0.753850f, -0.656291f, -0.031500f}, {0.338041f, 0.267473f} },
    { {0.086196f, -0.280692f, 0.682389f}, {-0.766060f, -0.526233f, -0.369096f}, {0.337909f, 0.269237f} },
    { {-0.088749f, -0.213635f, 0.057201f}, {-0.308539f, -0.911990f, -0.270330f}, {0.417002f, 0.307874f} },
    { {-0.085463f, -0.244044f, 0.199591f}, {-0.254892f, -0.965071f, -0.060572f}, {0.398936f, 0.306788f} },
    { {-0.099066f, 0.112090f, 0.510745f}, {-0.783997f, 0.602541f, 0.149309f}, {0.359188f, 0.308795f} },
    { {-0.117428f, 0.096207f, 0.475550f}, {-0.794055f, 0.575187f, 0.196562f}, {0.363637f, 0.312766f} },
    { {-0.116427f, 0.090895f, 0.493256f}, {-0.910090f, 0.379952f, 0.165447f}, {0.361393f, 0.312506f} },
    { {-0.119287f, -0.086448f, 0.519417f}, {-0.768841f, -0.607305f, 0.200159f}, {0.358163f, 0.313040f} },
    { {-0.219216f, 0.130803f, 0.131569f}, {-0.802289f, 0.581487f, -0.134929f}, {0.407147f, 0.335192f} },
    { {0.110938f, 0.289771f, 0.845251f}, {-0.755069f, 0.399880f, 0.519584f}, {0.316945f, 0.263560f} },
    { {0.094418f, 0.292291f, 0.678621f}, {-0.737461f, 0.675380f, -0.003603f}, {0.338084f, 0.267506f} },
    { {0.098916f, 0.302311f, 0.800127f}, {-0.774758f, 0.626343f, 0.086285f}, {0.322650f, 0.266221f} },
    { {0.244625f, 0.169629f, 0.528409f}, {0.776785f, 0.595470f, -0.204989f}, {0.357484f, 0.236231f} },
    { {0.266295f, 0.126764f, 0.497731f}, {0.857844f, 0.484957f, -0.170061f}, {0.361441f, 0.231744f} },
    { {0.164365f, -0.280575f, 0.924125f}, {0.569003f, -0.723201f, 0.391429f}, {0.307330f, 0.252077f} },
    { {0.045428f, 0.071708f, 0.467055f}, {-0.173920f, -0.426063f, 0.887819f}, {0.365001f, 0.278429f} },
    { {0.133354f, -0.123084f, 1.000163f}, {0.678128f, -0.672031f, 0.297519f}, {0.297532f, 0.258408f} },
    { {0.080612f, -0.206280f, 0.936544f}, {0.750623f, -0.657807f, -0.062086f}, {0.305572f, 0.269713f} },
    { {0.066344f, -0.183910f, 0.919107f}, {0.771902f, -0.003210f, -0.635734f}, {0.307751f, 0.272771f} },
    { {0.187375f, 0.262309f, 0.941172f}, {0.456905f, 0.694499f, 0.555795f}, {0.304902f, 0.247168f} },
    { {-0.150369f, -0.000897f, 0.453144f}, {-0.889359f, 0.065555f, 0.452486f}, {0.366483f, 0.319779f} },
    { {-0.064378f, -0.136272f, 0.736941f}, {-0.632762f, -0.507397f, 0.584945f}, {0.330649f, 0.300854f} },
    { {-0.168842f, -0.062564f, 0.683081f}, {-0.737925f, -0.431900f, 0.518584f}, {0.337276f, 0.323043f} },
    { {0.073449f, 0.273479f, 0.608265f}, {-0.719683f, 0.693696f, 0.029016f}, {0.346997f, 0.272125f} },
    { {0.288660f, 0.066098f, 0.467843f}, {0.884916f, 0.357022f, 0.299096f}, {0.365309f, 0.227108f} },
    { {0.287558f, 0.087231f, 0.418772f}, {0.367016f, 0.904303f, 0.218027f}, {0.371529f, 0.227476f} },
    { {0.149880f, 0.221286f, 0.877532f}, {0.774245f, 0.186973f, 0.604637f}, {0.312947f, 0.255256f} },
    { {-0.082572f, 0.074891f, 0.697795f}, {-0.945011f, 0.290777f, 0.149677f}, {0.335474f, 0.304799f} },
    { {-0.079156f, 0.075319f, 0.795873f}, {-0.787246f, -0.414680f, 0.456382f}, {0.323021f, 0.303807f} },
    { {-0.053649f, 0.102568f, 0.808674f}, {-0.750428f, 0.489599f, 0.444017f}, {0.321422f, 0.298389f} },
    { {-0.053649f, -0.088421f, 0.809507f}, {-0.709350f, -0.381145f, 0.592917f}, {0.321422f, 0.298389f} },
    { {0.283332f, 0.149265f, 0.638342f}, {0.869046f, 0.458677f, -0.185403f}, {0.343594f, 0.227761f} },
    { {0.311119f, 0.105246f, 0.899364f}, {0.665629f, 0.738214f, 0.109447f}, {0.310506f, 0.221178f} },
    { {0.315506f, 0.097981f, 0.814408f}, {0.765279f, 0.627169f, -0.144938f}, {0.321310f, 0.220487f} },
    { {0.239780f, -0.100096f, 0.076736f}, {0.349722f, -0.903405f, -0.248102f}, {0.415004f, 0.238504f} },
    { {0.064838f, 0.015807f, 0.971281f}, {-0.782646f, 0.002715f, 0.622461f}, {0.301010f, 0.272942f} },
    { {-0.168646f, 0.062578f, 0.682153f}, {-0.718941f, 0.460214f, 0.520890f}, {0.337325f, 0.323002f} },
    { {0.301183f, 0.182923f, 0.857768f}, {0.953415f, 0.136430f, 0.269048f}, {0.315731f, 0.223388f} },
    { {-0.012403f, -0.028529f, 0.874356f}, {-0.729095f, 0.292147f, 0.618927f}, {0.313219f, 0.289507f} },
    { {-0.019910f, -0.055507f, 0.898524f}, {-0.562084f, 0.633139f, 0.532162f}, {0.310151f, 0.291025f} },
    { {0.006911f, 0.059431f, 0.898257f}, {-0.704059f, -0.546419f, 0.453572f}, {0.310166f, 0.285365f} },
    { {0.064838f, 0.015807f, 0.971281f}, {-0.934857f, -0.342825f, 0.092271f}, {0.301010f, 0.272942f} },
    { {0.019763f, 0.071392f, 0.947853f}, {-0.857004f, -0.278137f, 0.433802f}, {0.303880f, 0.282516f} },
    { {-0.143503f, 0.021399f, 0.474583f}, {-0.930545f, 0.365956f, -0.012735f}, {0.363758f, 0.318271f} },
    { {-0.193154f, 0.169557f, 0.180855f}, {-0.755732f, 0.644349f, 0.116977f}, {0.400907f, 0.329557f} },
    { {0.175642f, 0.116173f, 0.935165f}, {-0.818799f, 0.570138f, -0.067161f}, {0.305727f, 0.249662f} },
    { {0.134459f, 0.138894f, 0.998116f}, {0.351224f, 0.803724f, 0.480281f}, {0.297649f, 0.258177f} },
    { {-0.068959f, 0.159165f, 0.485596f}, {-0.760266f, 0.506149f, 0.407195f}, {0.362407f, 0.302511f} },
    { {0.336610f, 0.000319f, 0.767166f}, {0.963207f, -0.126635f, -0.237056f}, {0.327400f, 0.216166f} },
    { {0.119086f, -0.100714f, 0.982726f}, {0.423177f, -0.373520f, -0.825472f}, {0.299711f, 0.261466f} },
    { {0.174537f, -0.100913f, 0.937016f}, {-0.887107f, -0.424446f, 0.181345f}, {0.305610f, 0.249893f} },
    { {-0.129558f, -0.074100f, 0.476283f}, {-0.950395f, -0.298770f, -0.086515f}, {0.363619f, 0.315326f} },
    { {-0.068682f, -0.161295f, 0.486253f}, {-0.809705f, -0.581719f, 0.077340f}, {0.362502f, 0.302455f} },
    { {0.099021f, -0.301222f, 0.803187f}, {-0.774425f, -0.626026f, 0.091417f}, {0.322596f, 0.266198f} },
    { {-0.070328f, -0.154172f, 0.494126f}, {-0.753174f, -0.623167f, 0.210692f}, {0.361495f, 0.302780f} },
    { {-0.000045f, -0.181086f, 0.851107f}, {-0.728272f, -0.683488f, -0.049628f}, {0.316278f, 0.286966f} },
    { {0.168836f, 0.283720f, 0.911697f}, {0.053763f, 0.908524f, 0.414360f}, {0.308604f, 0.251161f} },
    { {0.073449f, 0.273479f, 0.608265f}, {-0.458107f, 0.883316f, -0.099453f}, {0.346997f, 0.272125f} },
    { {0.138181f, 0.280522f, 0.573702f}, {0.064958f, 0.977181f, -0.202230f}, {0.351492f, 0.258563f} },
    { {0.239780f, -0.100096f, 0.076736f}, {0.674186f, -0.693383f, -0.254349f}, {0.415004f, 0.238504f} },
    { {-0.082572f, -0.061898f, 0.698392f}, {-0.993560f, 0.061597f, 0.095106f}, {0.335474f, 0.304799f} },
    { {-0.079156f, -0.061470f, 0.796470f}, {-0.688176f, 0.089806f, -0.719965f}, {0.323021f, 0.303807f} },
    { {-0.047449f, -0.061478f, 0.794808f}, {-0.029929f, 0.817872f, -0.574621f}, {0.323284f, 0.297122f} },
    { {-0.047450f, 0.075312f, 0.794211f}, {-0.049265f, -0.341702f, -0.938516f}, {0.323284f, 0.297122f} },
    { {-0.117428f, 0.096207f, 0.475550f}, {-0.934213f, 0.323679f, 0.149925f}, {0.363637f, 0.312766f} },
    { {-0.143503f, 0.021399f, 0.474583f}, {-0.995155f, -0.019895f, -0.096284f}, {0.363758f, 0.318271f} },
    { {0.295252f, -0.063643f, 0.467933f}, {0.583062f, -0.437697f, 0.684441f}, {0.365380f, 0.225719f} },
    { {0.277326f, 0.103176f, 0.513368f}, {0.937019f, 0.125249f, 0.326050f}, {0.359486f, 0.229374f} },
    { {0.285367f, -0.034234f, 0.489707f}, {0.267664f, -0.382492f, 0.884339f}, {0.362581f, 0.227744f} },
    { {-0.051471f, 0.178218f, 0.491727f}, {-0.711340f, 0.696352f, 0.095339f}, {0.361647f, 0.298805f} },
    { {-0.068959f, 0.159165f, 0.485596f}, {-0.743177f, 0.568704f, 0.352511f}, {0.362407f, 0.302511f} },
    { {-0.070467f, 0.152673f, 0.492891f}, {-0.787955f, 0.598722f, 0.143733f}, {0.361481f, 0.302809f} },
    { {0.189910f, 0.138695f, 0.952406f}, {-0.374943f, 0.638518f, 0.672096f}, {0.303548f, 0.246604f} },
    { {-0.042496f, 0.021459f, 0.864444f}, {-0.792147f, 0.283880f, 0.540292f}, {0.314400f, 0.295883f} },
    { {-0.012403f, -0.028529f, 0.874356f}, {0.273078f, 0.342646f, 0.898900f}, {0.313219f, 0.289507f} },
    { {-0.001102f, 0.086215f, 0.916207f}, {-0.704961f, 0.054855f, 0.707121f}, {0.307858f, 0.287006f} },
    { {-0.015565f, 0.015366f, 0.870189f}, {-0.193020f, -0.372927f, 0.907562f}, {0.313719f, 0.290185f} },
    { {0.065011f, 0.002186f, 0.999701f}, {-0.512580f, -0.263735f, 0.817133f}, {0.297408f, 0.272827f} },
    { {0.054993f, -0.048354f, 0.987325f}, {-0.808697f, -0.029090f, 0.587506f}, {0.298991f, 0.274976f} },
    { {0.308430f, -0.086681f, 0.928340f}, {0.232943f, -0.953365f, 0.191919f}, {0.306927f, 0.221667f} },
    { {0.314131f, -0.097835f, 0.812849f}, {0.824347f, -0.530940f, -0.196353f}, {0.321614f, 0.220783f} },
    { {-0.014004f, -0.211140f, 0.521769f}, {-0.717367f, -0.615121f, 0.327125f}, {0.358108f, 0.290821f} },
    { {0.039611f, -0.248033f, 0.564295f}, {-0.708601f, -0.597942f, 0.374633f}, {0.352816f, 0.279392f} },
    { {-0.022805f, -0.201807f, 0.520019f}, {-0.708601f, -0.597942f, 0.374633f}, {0.358311f, 0.292683f} },
    { {-0.070328f, -0.154172f, 0.494126f}, {-0.743229f, -0.566002f, 0.356724f}, {0.361495f, 0.302780f} },
    { {-0.068682f, -0.161295f, 0.486253f}, {-0.743229f, -0.566002f, 0.356724f}, {0.362502f, 0.302455f} },
    { {-0.051241f, -0.180265f, 0.492491f}, {-0.736185f, -0.606196f, 0.300928f}, {0.361749f, 0.298758f} },
    { {0.096790f, 0.279776f, 0.642951f}, {-0.104698f, 0.994482f, 0.006572f}, {0.342626f, 0.267104f} },
    { {-0.050866f, 0.074884f, 0.696134f}, {0.042523f, -0.579325f, 0.813987f}, {0.335738f, 0.298113f} },
    { {0.148774f, -0.205570f, 0.846447f}, {0.790197f, -0.608110f, -0.076101f}, {0.317131f, 0.255580f} },
    { {0.197991f, -0.089366f, 0.945288f}, {0.997450f, -0.068700f, -0.019313f}, {0.304592f, 0.244922f} },
    { {0.188805f, -0.123284f, 0.954453f}, {0.682572f, -0.665594f, 0.301796f}, {0.303431f, 0.246835f} },
    { {-0.085933f, 0.133078f, 0.490008f}, {-0.784016f, 0.595247f, 0.176066f}, {0.361833f, 0.306081f} },
    { {0.026141f, -0.217419f, 0.759678f}, {-0.731287f, -0.527950f, 0.431844f}, {0.327956f, 0.281694f} },
    { {0.135613f, 0.198765f, 0.860290f}, {-0.647981f, -0.159618f, 0.744744f}, {0.315126f, 0.258314f} },
    { {0.148775f, -0.206526f, 0.880302f}, {0.449942f, 0.709613f, 0.542219f}, {0.312830f, 0.255486f} },
    { {0.134507f, -0.184155f, 0.862865f}, {-0.827044f, -0.095724f, 0.553926f}, {0.315009f, 0.258545f} },
    { {0.148775f, -0.206526f, 0.880302f}, {-0.293781f, -0.795351f, 0.530198f}, {0.312830f, 0.255486f} },
    { {-0.038322f, -0.036483f, 0.869945f}, {-0.884960f, -0.429050f, -0.181001f}, {0.313741f, 0.294988f} },
    { {-0.050866f, -0.061906f, 0.696731f}, {0.042523f, 0.586405f, 0.808901f}, {0.335738f, 0.298114f} },
    { {-0.086115f, 0.139362f, 0.479913f}, {-0.776381f, 0.528640f, 0.343180f}, {0.363111f, 0.306147f} },
    { {0.177289f, 0.266724f, 0.503205f}, {-0.020910f, 0.402861f, -0.915022f}, {0.360520f, 0.250506f} },
    { {0.252969f, 0.181216f, 0.527356f}, {0.641755f, -0.103547f, -0.759887f}, {0.357625f, 0.234473f} },
    { {0.179222f, 0.243226f, 0.492815f}, {0.070187f, 0.186306f, -0.979982f}, {0.361856f, 0.250127f} },
    { {0.138181f, 0.280522f, 0.573702f}, {-0.851397f, 0.151920f, -0.502039f}, {0.351492f, 0.258563f} },
    { {0.110938f, 0.289771f, 0.845251f}, {-0.788891f, 0.504802f, 0.350465f}, {0.316945f, 0.263560f} },
    { {0.179447f, -0.245557f, 0.494269f}, {0.635043f, -0.688258f, -0.350744f}, {0.361943f, 0.250082f} },
    { {-0.129558f, -0.074100f, 0.476283f}, {-0.907836f, -0.407332f, 0.099572f}, {0.363619f, 0.315326f} },
    { {-0.153243f, -0.000321f, 0.562159f}, {-0.978687f, -0.145485f, -0.144932f}, {0.352629f, 0.320085f} },
    { {-0.144636f, -0.000784f, 0.474739f}, {-0.948712f, -0.189790f, 0.252833f}, {0.363749f, 0.318510f} },
    { {0.318866f, 0.032603f, 0.751210f}, {0.771415f, 0.322733f, -0.548418f}, {0.329380f, 0.219953f} },
    { {-0.180343f, -0.062737f, 0.633170f}, {-0.929002f, -0.301128f, 0.215122f}, {0.343598f, 0.325607f} },
    { {-0.194426f, -0.000181f, 0.659919f}, {-0.959051f, 0.061899f, -0.276385f}, {0.340142f, 0.328504f} },
    { {-0.000353f, -0.078330f, 0.890730f}, {-0.527327f, -0.836611f, -0.148351f}, {0.311187f, 0.286920f} },
    { {0.057215f, -0.215246f, 0.929271f}, {-0.090711f, -0.793338f, 0.601985f}, {0.306462f, 0.274669f} },
    { {0.084691f, 0.022739f, 0.984314f}, {0.650936f, 0.319277f, 0.688727f}, {0.299384f, 0.268717f} },
    { {0.038783f, 0.084928f, 0.952940f}, {-0.000773f, 0.830159f, 0.557526f}, {0.303258f, 0.278489f} },
    { {0.059720f, 0.040260f, 0.992882f}, {-0.159389f, 0.446941f, 0.880249f}, {0.298244f, 0.273962f} },
    { {0.079069f, -0.036981f, 0.980765f}, {0.552279f, -0.385441f, 0.739204f}, {0.299858f, 0.269914f} },
    { {0.096790f, 0.279776f, 0.642951f}, {0.212090f, 0.926463f, -0.310940f}, {0.342626f, 0.267104f} },
    { {0.094418f, 0.292291f, 0.678621f}, {0.212090f, 0.926463f, -0.310940f}, {0.338084f, 0.267506f} },
    { {-0.058556f, 0.102016f, 0.682162f}, {-0.714763f, 0.258287f, -0.649924f}, {0.337485f, 0.299774f} },
    { {-0.058556f, -0.088973f, 0.682995f}, {-0.761214f, -0.373921f, -0.529846f}, {0.337485f, 0.299774f} },
    { {0.056982f, 0.230438f, 0.927518f}, {-0.046791f, 0.631444f, 0.774009f}, {0.306437f, 0.274718f} },
    { {-0.000353f, 0.082072f, 0.890030f}, {-0.543057f, 0.780560f, -0.309541f}, {0.311187f, 0.286920f} },
    { {-0.027138f, 0.022148f, 0.848868f}, {-0.703844f, 0.191319f, -0.684106f}, {0.316404f, 0.292686f} },
    { {0.197991f, 0.104702f, 0.944441f}, {0.901798f, 0.002802f, -0.432148f}, {0.304592f, 0.244922f} },
    { {-0.022805f, -0.201807f, 0.520019f}, {-0.727254f, -0.638630f, 0.251501f}, {0.358311f, 0.292683f} },
    { {-0.070467f, 0.152673f, 0.492891f}, {-0.757908f, 0.551929f, 0.347778f}, {0.361481f, 0.302809f} },
    { {-0.086115f, 0.139362f, 0.479913f}, {-0.757908f, 0.551929f, 0.347778f}, {0.363111f, 0.306147f} },
    { {-0.085933f, 0.133078f, 0.490008f}, {-0.758742f, 0.546726f, 0.354121f}, {0.361833f, 0.306081f} },
    { {-0.068959f, 0.159165f, 0.485596f}, {-0.756851f, 0.558060f, 0.340215f}, {0.362407f, 0.302511f} },
    { {0.339677f, -0.058648f, 0.937757f}, {0.960994f, -0.110365f, 0.253593f}, {0.305767f, 0.215048f} },
    { {0.325924f, -0.078992f, 0.939183f}, {0.417730f, -0.754133f, 0.506740f}, {0.305574f, 0.217946f} },
    { {0.038783f, -0.080638f, 0.953663f}, {0.139808f, -0.888664f, 0.436726f}, {0.303258f, 0.278489f} },
    { {0.186058f, 0.112643f, 0.025237f}, {0.672626f, 0.623058f, -0.399217f}, {0.421339f, 0.249978f} },
    { {0.168934f, -0.281539f, 0.914451f}, {0.299780f, -0.924916f, 0.233800f}, {0.308567f, 0.251140f} },
    { {0.228262f, -0.231721f, 0.921502f}, {0.578612f, -0.738161f, 0.346880f}, {0.307743f, 0.238602f} },
    { {0.096790f, 0.279776f, 0.642951f}, {-0.534784f, 0.785601f, -0.311186f}, {0.342626f, 0.267104f} },
    { {0.094418f, 0.292291f, 0.678621f}, {-0.534784f, 0.785601f, -0.311186f}, {0.338084f, 0.267506f} },
    { {0.138181f, 0.280522f, 0.573702f}, {-0.534784f, 0.785601f, -0.311186f}, {0.351492f, 0.258563f} },
    { {0.299007f, 0.151060f, 0.710175f}, {0.811158f, -0.574010f, 0.111960f}, {0.334494f, 0.224255f} },
    { {0.301183f, 0.182923f, 0.857768f}, {0.811158f, -0.574010f, 0.111960f}, {0.315731f, 0.223388f} },
    { {0.292838f, 0.171336f, 0.858821f}, {0.811158f, -0.574010f, 0.111960f}, {0.315589f, 0.225146f} },
    { {0.301183f, 0.182923f, 0.857768f}, {0.494743f, -0.281596f, 0.822151f}, {0.315731f, 0.223388f} },
    { {0.318896f, -0.032339f, 0.751519f}, {0.855753f, -0.246124f, -0.455094f}, {0.329377f, 0.219947f} },
    { {0.111010f, -0.288277f, 0.848110f}, {-0.788831f, -0.501672f, 0.355065f}, {0.316902f, 0.263544f} },
    { {0.244625f, 0.169629f, 0.528409f}, {0.553154f, -0.461407f, -0.693631f}, {0.357484f, 0.236231f} },
    { {0.283332f, 0.149265f, 0.638342f}, {0.739389f, -0.565677f, -0.365122f}, {0.343594f, 0.227761f} },
    { {0.179447f, -0.245557f, 0.494269f}, {-0.465415f, 0.056981f, -0.883257f}, {0.361943f, 0.250082f} },
    { {0.153827f, -0.290312f, 0.558821f}, {-0.722165f, -0.485089f, -0.493119f}, {0.353724f, 0.255309f} },
    { {0.237407f, -0.200826f, 0.508192f}, {-0.147273f, 0.462895f, -0.874093f}, {0.360246f, 0.237814f} },
    { {0.187823f, -0.257136f, 0.493392f}, {-0.354576f, -0.187144f, -0.916108f}, {0.362074f, 0.248317f} },
    { {0.313166f, -0.059401f, 0.940323f}, {-0.398748f, -0.309901f, 0.863111f}, {0.305397f, 0.220634f} },
    { {0.197991f, -0.089366f, 0.945288f}, {0.253222f, -0.915994f, 0.311182f}, {0.304592f, 0.244922f} },
    { {0.209636f, -0.077956f, 0.969399f}, {0.253222f, -0.915994f, 0.311182f}, {0.301542f, 0.242398f} },
    { {0.120570f, -0.089088f, 1.009108f}, {0.253222f, -0.915994f, 0.311182f}, {0.296355f, 0.261080f} },
    { {-0.023298f, -0.037530f, 0.854899f}, {-0.652741f, -0.433000f, -0.621643f}, {0.315678f, 0.291860f} },
    { {0.244751f, -0.171534f, 0.529133f}, {-0.287256f, 0.603684f, -0.743673f}, {0.357581f, 0.236206f} },
    { {0.314121f, 0.063663f, 0.939642f}, {-0.599979f, 0.533831f, 0.595861f}, {0.305417f, 0.220433f} },
    { {0.327872f, 0.080690f, 0.938233f}, {0.310202f, 0.858388f, 0.408590f}, {0.305610f, 0.217536f} },
    { {0.277007f, -0.091821f, 0.434097f}, {0.263622f, -0.922982f, 0.280371f}, {0.369664f, 0.229662f} },
    { {-0.056102f, 0.102292f, 0.745402f}, {0.050014f, 0.998729f, -0.006298f}, {0.329456f, 0.299082f} },
    { {0.073384f, -0.273931f, 0.610751f}, {-0.199886f, -0.978185f, -0.056573f}, {0.346985f, 0.272138f} },
    { {0.100669f, -0.282022f, 0.654248f}, {-0.199886f, -0.978185f, -0.056573f}, {0.341509f, 0.266262f} },
    { {0.086196f, -0.280692f, 0.682389f}, {-0.199886f, -0.978185f, -0.056573f}, {0.337909f, 0.269237f} },
    { {0.274284f, -0.185943f, 0.890154f}, {0.805437f, -0.570916f, 0.159146f}, {0.311776f, 0.228978f} },
    { {0.314121f, 0.063663f, 0.939642f}, {0.096240f, 0.004760f, 0.995347f}, {0.305417f, 0.220433f} },
    { {0.313166f, -0.059401f, 0.940323f}, {0.096240f, 0.004760f, 0.995347f}, {0.305397f, 0.220634f} },
    { {0.325924f, -0.078992f, 0.939183f}, {0.096240f, 0.004760f, 0.995347f}, {0.305574f, 0.217946f} },
    { {0.339677f, -0.058648f, 0.937757f}, {0.096165f, 0.004754f, 0.995354f}, {0.305767f, 0.215048f} },
    { {0.314121f, 0.063663f, 0.939642f}, {0.551433f, 0.102459f, 0.827903f}, {0.305417f, 0.220433f} },
    { {0.339677f, -0.058648f, 0.937757f}, {0.551433f, 0.102459f, 0.827903f}, {0.305767f, 0.215048f} },
    { {0.347887f, 0.062072f, 0.917349f}, {0.551433f, 0.102459f, 0.827903f}, {0.308306f, 0.213371f} },
    { {0.314121f, 0.063663f, 0.939642f}, {0.506176f, -0.343289f, 0.791163f}, {0.305417f, 0.220433f} },
    { {0.347887f, 0.062072f, 0.917349f}, {0.506176f, -0.343289f, 0.791163f}, {0.308306f, 0.213371f} },
    { {0.327872f, 0.080690f, 0.938233f}, {0.506176f, -0.343289f, 0.791163f}, {0.305610f, 0.217536f} },
};

WORD g_tind22[] = 
{
    0, 1, 2,    3, 4, 5,    6, 7, 8,    9, 10, 11,    12, 13, 14,
    3, 5, 15,    16, 17, 18,    19, 20, 21,    22, 23, 24,    25, 26, 27,
    28, 29, 30,    31, 32, 33,    19, 34, 35,    36, 37, 38,    39, 40, 41,
    12, 0, 2,    42, 43, 44,    45, 46, 47,    48, 49, 50,    51, 52, 53,
    54, 10, 55,    25, 56, 57,    28, 30, 58,    34, 59, 35,    24, 60, 61,
    21, 20, 62,    63, 64, 41,    32, 65, 66,    67, 68, 69,    70, 71, 72,
    73, 74, 72,    46, 75, 47,    76, 77, 78,    79, 80, 81,    82, 83, 84,
    20, 85, 62,    38, 86, 87,    88, 89, 90,    91, 92, 93,    94, 95, 96,
    97, 98, 99,    12, 2, 100,    70, 101, 102,    3, 103, 104,    105, 23, 106,
    72, 71, 73,    65, 32, 107,    107, 56, 108,    109, 110, 111,    67, 112, 68,
    113, 114, 115,    62, 116, 117,    94, 118, 95,    73, 118, 119,    120, 121, 122,
    123, 80, 79,    124, 125, 47,    96, 126, 127,    128, 129, 130,    91, 131, 132,
    133, 134, 9,    135, 136, 137,    108, 56, 138,    128, 1, 129,    19, 35, 139,
    140, 136, 141,    142, 3, 15,    143, 144, 116,    143, 116, 145,    146, 147, 148,
    149, 89, 88,    150, 151, 152,    94, 119, 118,    153, 154, 97,    155, 25, 154,
    52, 156, 53,    157, 158, 159,    42, 70, 43,    160, 54, 55,    6, 8, 160,
    26, 161, 162,    163, 164, 165,    166, 167, 168,    169, 168, 167,    170, 171, 172,
    173, 9, 134,    174, 175, 28,    176, 177, 178,    82, 46, 45,    179, 180, 181,
    182, 183, 184,    50, 49, 185,    24, 186, 60,    102, 187, 188,    189, 190, 191,
    192, 128, 130,    17, 144, 18,    193, 194, 195,    176, 178, 196,    197, 198, 58,
    199, 66, 200,    201, 17, 16,    202, 203, 204,    205, 206, 70,    207, 153, 208,
    61, 22, 24,    209, 41, 64,    210, 211, 90,    212, 213, 10,    145, 116, 62,
    37, 173, 134,    214, 215, 37,    59, 87, 86,    216, 83, 82,    104, 217, 165,
    217, 48, 50,    218, 91, 93,    218, 88, 219,    103, 220, 221,    222, 109, 111,
    76, 222, 77,    101, 187, 102,    52, 223, 156,    224, 225, 52,    226, 166, 168,
    227, 226, 228,    229, 100, 2,    155, 207, 230,    132, 40, 231,    30, 29, 232,
    192, 233, 17,    192, 130, 233,    81, 80, 84,    66, 199, 32,    234, 235, 112,
    93, 92, 149,    126, 236, 237,    167, 227, 238,    228, 238, 227,    1, 155, 230,
    239, 240, 241,    136, 140, 137,    242, 38, 37,    125, 243, 47,    193, 195, 244,
    33, 4, 3,    245, 161, 246,    124, 47, 75,    247, 248, 249,    8, 54, 160,
    103, 221, 250,    107, 57, 56,    26, 31, 161,    100, 13, 12,    251, 208, 153,
    21, 252, 19,    253, 122, 254,    66, 16, 200,    6, 16, 7,    255, 130, 129,
    130, 255, 256,    170, 257, 171,    159, 53, 156,    35, 59, 86,    136, 258, 141,
    259, 260, 261,    239, 56, 240,    56, 25, 240,    117, 262, 62,    211, 209, 64,
    62, 85, 10,    10, 213, 62,    263, 186, 24,    216, 47, 264,    216, 265, 83,
    253, 266, 122,    232, 29, 267,    29, 28, 268,    269, 181, 180,    270, 271, 272,
    273, 272, 271,    27, 105, 106,    164, 245, 165,    255, 274, 256,    256, 274, 17,
    275, 114, 276,    168, 228, 226,    196, 58, 277,    196, 28, 58,    152, 278, 150,
    73, 119, 74,    121, 279, 122,    79, 81, 279,    123, 121, 120,    40, 63, 41,
    131, 91, 218,    280, 41, 209,    280, 39, 41,    281, 282, 152,    43, 70, 206,
    97, 99, 153,    251, 153, 99,    58, 30, 197,    66, 201, 16,    283, 284, 285,
    42, 44, 94,    80, 286, 84,    13, 61, 14,    287, 22, 61,    288, 179, 289,
    181, 289, 179,    77, 222, 158,    158, 157, 77,    3, 246, 33,    246, 3, 104,
    60, 290, 61,    16, 18, 7,    115, 291, 113,    32, 4, 33,    111, 234, 222,
    196, 178, 28,    174, 28, 178,    292, 293, 259,    261, 292, 259,    294, 295, 250,
    76, 78, 110,    243, 296, 47,    67, 52, 51,    224, 52, 67,    95, 126, 96,
    183, 182, 181,    250, 297, 103,    297, 250, 295,    50, 23, 217,    105, 163, 23,
    64, 219, 211,    63, 219, 64,    102, 188, 71,    70, 298, 71,    117, 299, 262,
    252, 21, 299,    12, 14, 300,    0, 12, 301,    103, 3, 142,    215, 173, 37,
    215, 55, 173,    128, 239, 241,    177, 174, 178,    302, 65, 107,    277, 58, 198,
    238, 169, 167,    303, 304, 305,    306, 305, 304,    136, 139, 258,    135, 20, 136,
    249, 307, 308,    309, 197, 30,    232, 309, 30,    310, 311, 232,    310, 232, 267,
    133, 135, 137,    133, 9, 11,    312, 313, 314,    107, 32, 31,    57, 107, 31,
    289, 167, 315,    269, 315, 167,    158, 53, 159,    158, 51, 53,    96, 127, 42,
    94, 96, 42,    316, 203, 317,    318, 316, 319,    320, 285, 284,    321, 320, 284,
    322, 323, 115,    323, 291, 115,    50, 24, 23,    50, 185, 24,    324, 325, 326,
    103, 49, 48,    327, 328, 329,    51, 158, 222,    222, 67, 51,    284, 202, 321,
    204, 321, 202,    330, 12, 300,    25, 57, 26,    57, 31, 26,    271, 270, 331,
    270, 303, 331,    332, 333, 334,    259, 334, 333,    287, 61, 13,    208, 287, 13,
    285, 318, 283,    319, 283, 318,    247, 312, 314,    335, 248, 247,    36, 336, 37,
    336, 214, 37,    145, 62, 213,    155, 154, 207,    207, 154, 153,    315, 269, 337,
    180, 337, 269,    191, 338, 189,    293, 339, 340,    341, 204, 203,    203, 316, 341,
    34, 19, 146,    252, 146, 19,    137, 140, 242,    133, 137, 134,    88, 93, 149,
    93, 88, 218,    305, 342, 303,    342, 331, 303,    110, 109, 76,    109, 222, 76,
    343, 248, 335,    344, 345, 346,    347, 344, 346,    254, 122, 348,    210, 90, 89,
    32, 199, 349,    4, 32, 349,    350, 82, 84,    351, 308, 294,    63, 218, 219,
    40, 218, 63,    185, 352, 263,    263, 24, 185,    27, 26, 162,    27, 162, 105,
    175, 174, 268,    175, 268, 28,    314, 335, 247,    106, 98, 97,    27, 106, 25,
    144, 143, 18,    353, 113, 291,    354, 87, 59,    84, 83, 355,    70, 72, 205,
    204, 341, 356,    333, 226, 259,    357, 259, 226,    358, 359, 360,    361, 358, 320,
    69, 224, 67,    200, 16, 6,    135, 85, 20,    11, 10, 85,    234, 112, 222,
    112, 67, 222,    229, 2, 230,    230, 2, 1,    38, 141, 86,    141, 35, 86,
    1, 240, 155,    25, 155, 240,    131, 218, 40,    131, 40, 132,    289, 315, 288,
    337, 288, 315,    362, 147, 363,    364, 365, 303,    365, 273, 303,    258, 35, 141,
    258, 139, 35,    104, 103, 48,    217, 104, 48,    303, 270, 364,    272, 364, 270,
    340, 334, 293,    334, 259, 293,    60, 343, 290,    60, 186, 343,    246, 161, 33,
    161, 31, 33,    366, 227, 289,    227, 167, 289,    367, 368, 316,    341, 316, 368,
    333, 369, 167,    183, 167, 369,    329, 324, 370,    14, 61, 290,    371, 372, 373,
    371, 374, 372,    167, 183, 269,    181, 269, 183,    54, 212, 10,    114, 375, 115,
    115, 375, 376,    163, 165, 217,    217, 23, 163,    357, 332, 340,    334, 340, 332,
    321, 204, 377,    356, 377, 204,    331, 306, 271,    304, 271, 306,    229, 208, 100,
    208, 13, 100,    22, 98, 23,    106, 23, 98,    359, 318, 285,    360, 359, 285,
    174, 177, 378,    56, 239, 138,    245, 246, 165,    104, 165, 246,    197, 309, 311,
    309, 232, 311,    128, 241, 1,    240, 1, 241,    287, 251, 22,    251, 287, 208,
    259, 357, 260,    340, 260, 357,    216, 264, 265,    87, 36, 38,    216, 82, 45,
    45, 47, 216,    107, 108, 302,    277, 176, 196,    316, 318, 367,    359, 367, 318,
    271, 304, 273,    304, 303, 273,    219, 88, 90,    211, 219, 90,    366, 181, 182,
    289, 181, 366,    379, 215, 214,    379, 380, 215,    263, 308, 186,    134, 242, 37,
    134, 137, 242,    12, 330, 301,    381, 382, 383,    384, 385, 386,    387, 117, 116,
    388, 291, 323,    388, 353, 291,    9, 173, 55,    9, 55, 10,    157, 78, 77,
    296, 389, 47,    21, 62, 262,    262, 299, 21,    163, 105, 164,    105, 162, 164,
    390, 346, 345,    391, 390, 345,    123, 79, 121,    121, 79, 279,    279, 81, 355,
    81, 84, 355,    194, 392, 393,    393, 195, 194,    394, 395, 392,    395, 393, 392,
    207, 208, 229,    230, 207, 229,    147, 312, 148,    148, 312, 247,    376, 396, 322,
    115, 376, 322,    167, 166, 333,    397, 398, 399,    400, 356, 341,    368, 400, 341,
    320, 321, 361,    377, 361, 321,    235, 68, 112,    392, 401, 394,    275, 402, 403,
    275, 403, 114,    129, 1, 0,    255, 129, 0,    113, 353, 276,    276, 114, 113,
    39, 231, 40,    17, 274, 144,    139, 20, 19,    136, 20, 139,    38, 140, 141,
    242, 140, 38,    198, 197, 404,    311, 404, 197,    22, 99, 98,    251, 99, 22,
    152, 151, 281,    317, 319, 316,    162, 161, 245,    162, 245, 164,    268, 310, 267,
    29, 268, 267,    364, 272, 405,    126, 237, 127,    135, 133, 11,    135, 11, 85,
    406, 407, 408,    25, 106, 97,    97, 154, 25,    70, 102, 298,    298, 102, 71,
    52, 225, 223,    160, 55, 409,    285, 320, 360,    360, 320, 358,    410, 411, 412,
    410, 412, 413,    414, 415, 416,    417, 418, 419,
};

D3DMATRIX g_tmat23 = 
{
    -0.866267f, -0.050859f, -0.496986f, 0.000000f, 
    -0.486499f, -0.140297f, 0.862344f, 0.000000f, 
    -0.113583f, 0.988803f, 0.096791f, 0.000000f, 
    -0.684880f, -2.356835f, 2.259305f, 1.000000f, 
};

// Mesh #23 Tris:86 Verts:117
MODELVERT g_tmesh23[] = 
{
    { {0.048231f, -0.150766f, 0.161141f}, {0.995966f, -0.065354f, 0.061480f}, {0.334194f, 0.232142f} },
    { {0.048231f, -0.219470f, 0.018737f}, {0.979462f, -0.151365f, -0.133199f}, {0.303841f, 0.321623f} },
    { {0.061755f, -0.013359f, 0.018737f}, {0.998084f, -0.019425f, -0.058739f}, {0.394898f, 0.321623f} },
    { {-0.076963f, -0.155821f, 0.162275f}, {-0.991117f, -0.044735f, 0.125243f}, {0.388196f, 0.231429f} },
    { {-0.069884f, -0.012707f, 0.016901f}, {-0.962641f, 0.206570f, -0.175076f}, {0.324971f, 0.322777f} },
    { {-0.076977f, -0.155601f, 0.017293f}, {-0.986528f, -0.049433f, -0.155946f}, {0.388099f, 0.322531f} },
    { {0.061755f, -0.013359f, 0.161141f}, {0.978362f, 0.100482f, 0.180861f}, {0.394898f, 0.232142f} },
    { {-0.070469f, -0.014308f, 0.161727f}, {-0.961065f, 0.235191f, 0.145051f}, {0.325678f, 0.231774f} },
    { {-0.029492f, -0.238207f, 0.161141f}, {-0.143656f, -0.986975f, 0.072410f}, {0.337435f, 0.232142f} },
    { {0.029493f, -0.238207f, 0.018737f}, {0.142485f, -0.987408f, -0.068724f}, {0.393777f, 0.321623f} },
    { {0.029493f, -0.238207f, 0.161141f}, {0.325925f, -0.933931f, 0.146787f}, {0.393777f, 0.232142f} },
    { {-0.007857f, -0.151001f, 0.179758f}, {0.265223f, -0.047282f, 0.963027f}, {0.362592f, 0.302624f} },
    { {0.029493f, -0.219470f, 0.179879f}, {0.283177f, -0.068813f, 0.956596f}, {0.393777f, 0.332293f} },
    { {0.006763f, -0.013359f, 0.179879f}, {0.091471f, 0.105318f, 0.990223f}, {0.372065f, 0.242616f} },
    { {0.043018f, -0.013359f, 0.179879f}, {0.321952f, 0.059376f, 0.944892f}, {0.406695f, 0.242616f} },
    { {0.043018f, 0.005378f, 0.161141f}, {0.137790f, 0.987004f, 0.082680f}, {0.313461f, 0.232142f} },
    { {-0.040554f, 0.006684f, 0.016344f}, {-0.079003f, 0.991538f, -0.103012f}, {0.382721f, 0.321623f} },
    { {-0.036021f, 0.009814f, 0.164978f}, {-0.248503f, 0.961097f, 0.120576f}, {0.382721f, 0.232142f} },
    { {0.043018f, 0.005378f, 0.018737f}, {0.285845f, 0.949802f, -0.127156f}, {0.313461f, 0.321623f} },
    { {0.043018f, -0.013359f, -0.000000f}, {0.340387f, 0.022118f, -0.940025f}, {0.313461f, 0.242616f} },
    { {0.029493f, -0.219470f, -0.000000f}, {0.214531f, -0.142942f, -0.966201f}, {0.326380f, 0.332293f} },
    { {-0.007857f, -0.151001f, -0.000120f}, {0.073126f, -0.020361f, -0.997115f}, {0.357565f, 0.302624f} },
    { {-0.029492f, -0.238207f, 0.018737f}, {-0.303607f, -0.943568f, -0.132293f}, {0.337435f, 0.321623f} },
    { {-0.029492f, -0.219470f, -0.000000f}, {-0.075160f, -0.355282f, -0.931733f}, {0.382721f, 0.332293f} },
    { {-0.004562f, -0.015324f, -0.011254f}, {0.106600f, 0.033538f, -0.993736f}, {0.358908f, 0.243471f} },
    { {-0.047223f, -0.215465f, -0.006962f}, {-0.325073f, -0.058733f, -0.943863f}, {0.399657f, 0.330550f} },
    { {-0.044350f, -0.014198f, -0.010476f}, {-0.389880f, 0.107649f, -0.914552f}, {0.396914f, 0.242981f} },
    { {0.043018f, 0.005378f, 0.018737f}, {0.285845f, 0.949802f, -0.127156f}, {0.313461f, 0.234464f} },
    { {0.006763f, -0.013359f, -0.000000f}, {0.009124f, 0.284679f, -0.958580f}, {0.348091f, 0.242616f} },
    { {-0.040554f, 0.006684f, 0.016344f}, {-0.079003f, 0.991538f, -0.103012f}, {0.382721f, 0.234464f} },
    { {-0.044320f, -0.015142f, 0.190224f}, {-0.410873f, 0.107494f, 0.905333f}, {0.326046f, 0.213867f} },
    { {-0.052044f, -0.155416f, 0.189760f}, {-0.422483f, -0.081365f, 0.902711f}, {0.388017f, 0.214159f} },
    { {-0.037350f, -0.185353f, 0.179758f}, {-0.041562f, -0.145399f, 0.988500f}, {0.334421f, 0.317570f} },
    { {-0.029492f, -0.219470f, 0.179879f}, {-0.143266f, -0.442418f, 0.885292f}, {0.337436f, 0.332293f} },
    { {0.056531f, -0.009535f, 0.152260f}, {0.976008f, -0.022787f, 0.216539f}, {0.396587f, 0.237722f} },
    { {0.030165f, 0.053857f, 0.026749f}, {0.675225f, 0.682567f, -0.279596f}, {0.424593f, 0.316589f} },
    { {0.030165f, 0.053857f, 0.152260f}, {0.320830f, 0.905176f, 0.278792f}, {0.424593f, 0.237722f} },
    { {-0.038382f, 0.049965f, 0.152260f}, {-0.747915f, 0.602410f, 0.278792f}, {0.297283f, 0.237722f} },
    { {-0.057402f, -0.016004f, 0.026749f}, {-0.966868f, -0.134286f, -0.217104f}, {0.326427f, 0.316589f} },
    { {-0.057402f, -0.016004f, 0.152260f}, {-0.270247f, -0.931382f, 0.243916f}, {0.326427f, 0.237722f} },
    { {-0.038382f, 0.049965f, 0.026749f}, {-0.420533f, 0.863121f, -0.279595f}, {0.297283f, 0.316589f} },
    { {0.056531f, -0.009535f, 0.026749f}, {0.370909f, -0.896065f, -0.243916f}, {0.396587f, 0.316589f} },
    { {-0.044320f, -0.015142f, 0.190224f}, {-0.410873f, 0.107494f, 0.905333f}, {0.323272f, 0.243392f} },
    { {-0.014733f, -0.150586f, 0.190894f}, {0.129358f, -0.062892f, 0.989601f}, {0.357703f, 0.274128f} },
    { {-0.004591f, -0.014433f, 0.190665f}, {0.310749f, 0.080017f, 0.947118f}, {0.361220f, 0.243083f} },
    { {0.043018f, 0.005378f, 0.161141f}, {0.137790f, 0.987004f, 0.082680f}, {0.406695f, 0.234464f} },
    { {-0.036021f, 0.009814f, 0.164978f}, {-0.248503f, 0.961097f, 0.120576f}, {0.337436f, 0.234464f} },
    { {-0.036021f, 0.009814f, 0.164978f}, {-0.248503f, 0.961097f, 0.120576f}, {0.315021f, 0.229731f} },
    { {-0.040554f, 0.006684f, 0.016344f}, {-0.079003f, 0.991538f, -0.103012f}, {0.316404f, 0.323127f} },
    { {-0.040554f, 0.006684f, 0.016344f}, {-0.079003f, 0.991538f, -0.103012f}, {0.393288f, 0.233895f} },
    { {-0.001363f, 0.003565f, 0.163563f}, {-0.030680f, -0.915610f, 0.400895f}, {0.364303f, 0.235252f} },
    { {0.056531f, -0.009535f, 0.152260f}, {0.976008f, -0.022787f, 0.216539f}, {0.402488f, 0.239188f} },
    { {0.030165f, 0.053857f, 0.152260f}, {0.320830f, 0.905176f, 0.278792f}, {0.394418f, 0.213371f} },
    { {-0.001363f, 0.003565f, 0.163563f}, {-0.030680f, -0.915610f, 0.400895f}, {0.364303f, 0.230620f} },
    { {0.056531f, -0.009535f, 0.026749f}, {0.370909f, -0.896065f, -0.243916f}, {0.419603f, 0.316589f} },
    { {0.056531f, -0.009535f, 0.152260f}, {0.976008f, -0.022787f, 0.216539f}, {0.419602f, 0.237722f} },
    { {-0.038382f, 0.049965f, 0.026749f}, {-0.420533f, 0.863121f, -0.279595f}, {0.391213f, 0.215064f} },
    { {-0.001363f, 0.003565f, 0.016099f}, {0.133937f, -0.906763f, -0.399802f}, {0.355853f, 0.235252f} },
    { {-0.057402f, -0.016004f, 0.026749f}, {-0.966868f, -0.134286f, -0.217104f}, {0.392814f, 0.241132f} },
    { {-0.057402f, -0.016004f, 0.152260f}, {-0.270247f, -0.931382f, 0.243916f}, {0.310776f, 0.237722f} },
    { {-0.057402f, -0.016004f, 0.026749f}, {-0.966868f, -0.134286f, -0.217104f}, {0.310776f, 0.316589f} },
    { {-0.001363f, 0.003565f, 0.016099f}, {0.133937f, -0.906763f, -0.399802f}, {0.364303f, 0.323281f} },
    { {-0.038382f, 0.049965f, 0.152260f}, {-0.747915f, 0.602410f, 0.278792f}, {0.328944f, 0.215064f} },
    { {0.030165f, 0.053857f, 0.152260f}, {0.320830f, 0.905176f, 0.278792f}, {0.325738f, 0.237722f} },
    { {-0.038382f, 0.049965f, 0.026749f}, {-0.420533f, 0.863121f, -0.279595f}, {0.391213f, 0.316589f} },
    { {-0.038382f, 0.049965f, 0.152260f}, {-0.747915f, 0.602410f, 0.278792f}, {0.391213f, 0.237722f} },
    { {0.030165f, 0.053857f, 0.026749f}, {0.675225f, 0.682567f, -0.279596f}, {0.325738f, 0.213371f} },
    { {0.030165f, 0.053857f, 0.026749f}, {0.675225f, 0.682567f, -0.279596f}, {0.325738f, 0.316589f} },
    { {-0.007857f, -0.151001f, -0.000120f}, {0.088768f, -0.025550f, -0.995725f}, {0.368596f, 0.302326f} },
    { {-0.052044f, -0.155416f, 0.189760f}, {-0.422483f, -0.081365f, 0.902711f}, {0.315895f, 0.304423f} },
    { {-0.014733f, -0.150586f, 0.190894f}, {0.129358f, -0.062892f, 0.989601f}, {0.351533f, 0.302322f} },
    { {-0.059797f, -0.217122f, 0.017889f}, {-0.901064f, -0.429899f, -0.057197f}, {0.415278f, 0.322156f} },
    { {-0.059621f, -0.217453f, 0.162832f}, {-0.795861f, -0.574656f, 0.190724f}, {0.415424f, 0.231079f} },
    { {-0.036021f, 0.009814f, 0.164978f}, {-0.248503f, 0.961097f, 0.120576f}, {0.331199f, 0.232534f} },
    { {0.043018f, 0.005378f, 0.018737f}, {0.285845f, 0.949802f, -0.127156f}, {0.403176f, 0.321623f} },
    { {0.043018f, -0.013359f, -0.000000f}, {0.340387f, 0.022118f, -0.940025f}, {0.394898f, 0.333397f} },
    { {-0.044350f, -0.014198f, -0.010476f}, {-0.389880f, 0.107649f, -0.914552f}, {0.325629f, 0.339979f} },
    { {-0.047223f, -0.215465f, -0.006962f}, {-0.325073f, -0.058733f, -0.943863f}, {0.414546f, 0.337772f} },
    { {-0.059621f, -0.217453f, 0.162832f}, {-0.795861f, -0.574656f, 0.190724f}, {0.416315f, 0.232142f} },
    { {-0.059797f, -0.217122f, 0.017889f}, {-0.901064f, -0.429899f, -0.057197f}, {0.416315f, 0.321623f} },
    { {-0.029492f, -0.238207f, 0.018737f}, {-0.303607f, -0.943568f, -0.132293f}, {0.424593f, 0.321623f} },
    { {-0.057402f, -0.016004f, 0.152260f}, {-0.270247f, -0.931382f, 0.243916f}, {0.327342f, 0.241132f} },
    { {0.043018f, 0.005378f, 0.161141f}, {0.137790f, 0.987004f, 0.082680f}, {0.403176f, 0.232142f} },
    { {0.029493f, -0.219470f, 0.179879f}, {0.283177f, -0.068813f, 0.956596f}, {0.303841f, 0.220368f} },
    { {0.043018f, -0.013359f, 0.179879f}, {0.321952f, 0.059376f, 0.944892f}, {0.394898f, 0.220368f} },
    { {0.056531f, -0.009535f, 0.026749f}, {0.370909f, -0.896065f, -0.243916f}, {0.300554f, 0.240952f} },
    { {0.029493f, -0.238207f, 0.161141f}, {0.325925f, -0.933931f, 0.146787f}, {0.295564f, 0.232142f} },
    { {0.029493f, -0.238207f, 0.018737f}, {0.142485f, -0.987408f, -0.068724f}, {0.295564f, 0.321623f} },
    { {0.029493f, -0.219470f, -0.000000f}, {0.214531f, -0.142942f, -0.966201f}, {0.303841f, 0.333397f} },
    { {-0.037350f, -0.185353f, 0.179758f}, {-0.041562f, -0.145399f, 0.988500f}, {0.329930f, 0.317449f} },
    { {-0.037350f, -0.185353f, 0.179758f}, {-0.041562f, -0.145399f, 0.988500f}, {0.401605f, 0.216678f} },
    { {0.048231f, -0.219470f, 0.161141f}, {0.971543f, -0.208189f, 0.112971f}, {0.303841f, 0.232142f} },
    { {-0.037350f, -0.185353f, 0.179758f}, {-0.041562f, -0.145399f, 0.988500f}, {0.401365f, 0.220368f} },
    { {-0.029492f, -0.219470f, 0.179879f}, {-0.143266f, -0.442418f, 0.885292f}, {0.416315f, 0.220368f} },
    { {-0.029492f, -0.238207f, 0.161141f}, {-0.143656f, -0.986975f, 0.072410f}, {0.424593f, 0.232142f} },
    { {-0.004591f, -0.014433f, 0.190665f}, {0.310749f, 0.080017f, 0.947118f}, {0.394423f, 0.213590f} },
    { {-0.014733f, -0.150586f, 0.190894f}, {0.129358f, -0.062892f, 0.989601f}, {0.334273f, 0.213446f} },
    { {-0.007857f, -0.151001f, 0.179758f}, {0.265223f, -0.047282f, 0.963027f}, {0.334090f, 0.220443f} },
    { {-0.037350f, -0.185353f, 0.179758f}, {-0.041562f, -0.145399f, 0.988500f}, {0.318914f, 0.220443f} },
    { {-0.029492f, -0.238207f, 0.018737f}, {-0.303607f, -0.943568f, -0.132293f}, {0.382721f, 0.340445f} },
    { {-0.029492f, -0.219470f, -0.000000f}, {-0.075160f, -0.355282f, -0.931733f}, {0.416315f, 0.333397f} },
    { {0.029493f, -0.238207f, 0.018737f}, {0.142485f, -0.987408f, -0.068724f}, {0.326380f, 0.340445f} },
    { {0.029493f, -0.238207f, 0.161141f}, {0.325925f, -0.933931f, 0.146787f}, {0.393777f, 0.340445f} },
    { {-0.007857f, -0.151001f, -0.000120f}, {0.709423f, -0.074742f, -0.700809f}, {0.362056f, 0.302503f} },
    { {-0.004562f, -0.015324f, -0.011254f}, {0.669844f, 0.213159f, -0.711247f}, {0.352583f, 0.242495f} },
    { {0.006763f, -0.013359f, -0.000000f}, {0.669844f, 0.213159f, -0.711247f}, {0.348091f, 0.242616f} },
    { {-0.040554f, 0.006684f, 0.016344f}, {0.239083f, 0.886844f, -0.395408f}, {0.387213f, 0.234343f} },
    { {-0.029492f, -0.238207f, 0.161141f}, {-0.143656f, -0.986975f, 0.072410f}, {0.337435f, 0.340445f} },
    { {-0.007857f, -0.151001f, -0.000120f}, {0.312161f, -0.090259f, -0.945732f}, {0.362056f, 0.302503f} },
    { {-0.029492f, -0.219470f, -0.000000f}, {0.244542f, -0.428953f, -0.869597f}, {0.387213f, 0.332172f} },
    { {-0.059797f, -0.217122f, 0.017889f}, {-0.901064f, -0.429899f, -0.057197f}, {0.308488f, 0.322156f} },
    { {-0.047223f, -0.215465f, -0.006962f}, {-0.325073f, -0.058733f, -0.943863f}, {0.320499f, 0.337772f} },
    { {-0.029492f, -0.219470f, -0.000000f}, {0.001204f, -0.315875f, -0.948800f}, {0.332944f, 0.333473f} },
    { {0.006763f, -0.013359f, 0.179879f}, {0.091471f, 0.105318f, 0.990223f}, {0.396632f, 0.218796f} },
    { {-0.036021f, 0.009814f, 0.164978f}, {0.316025f, 0.851949f, 0.417506f}, {0.389661f, 0.231303f} },
    { {-0.004591f, -0.014433f, 0.190665f}, {0.316025f, 0.851949f, 0.417506f}, {0.354445f, 0.213514f} },
    { {0.006763f, -0.013359f, 0.179879f}, {0.316025f, 0.851949f, 0.417506f}, {0.348091f, 0.220368f} },
};

WORD g_tind23[] = 
{
    0, 1, 2,    3, 4, 5,    0, 2, 6,    7, 4, 3,    8, 9, 10,
    11, 12, 13,    13, 12, 14,    15, 16, 17,    15, 18, 16,    19, 20, 21,
    8, 22, 9,    20, 23, 21,    24, 25, 26,    27, 28, 29,    30, 3, 31,
    32, 33, 12,    34, 35, 36,    37, 38, 39,    37, 40, 38,    34, 41, 35,
    42, 43, 44,    45, 46, 13,    47, 48, 4,    24, 26, 49,    50, 51, 52,
    53, 54, 55,    56, 57, 58,    59, 60, 61,    50, 52, 62,    63, 64, 65,
    66, 57, 56,    63, 67, 64,    19, 21, 28,    68, 25, 24,    42, 69, 70,
    32, 12, 11,    3, 71, 72,    31, 3, 72,    47, 4, 7,    44, 73, 42,
    6, 2, 74,    1, 75, 2,    4, 76, 77,    48, 76, 4,    78, 79, 80,
    4, 77, 5,    50, 62, 81,    59, 61, 53,    6, 74, 82,    83, 6, 84,
    85, 57, 66,    53, 61, 54,    86, 87, 1,    1, 88, 75,    69, 89, 70,
    31, 72, 90,    86, 1, 91,    83, 0, 6,    92, 78, 93,    78, 80, 94,
    95, 96, 97,    98, 97, 96,    30, 7, 3,    30, 47, 7,    99, 23, 20,
    79, 100, 80,    87, 88, 1,    99, 20, 101,    14, 45, 13,    84, 6, 82,
    83, 86, 91,    33, 102, 12,    27, 19, 28,    2, 75, 74,    5, 77, 71,
    3, 5, 71,    103, 104, 105,    106, 105, 104,    33, 107, 102,    93, 78, 94,
    108, 109, 25,    110, 111, 112,    97, 113, 95,    114, 115, 116,    91, 1, 0,
    83, 91, 0,
};

D3DMATRIX g_tmat24 = 
{
    -0.953117f, -0.135948f, 0.270346f, 0.000000f, 
    0.280477f, -0.061547f, 0.957886f, 0.000000f, 
    -0.113583f, 0.988803f, 0.096791f, 0.000000f, 
    -0.568672f, -2.303604f, 2.051301f, 1.000000f, 
};

// Mesh #24 Tris:96 Verts:126
MODELVERT g_tmesh24[] = 
{
    { {-0.047790f, -0.023048f, 0.133575f}, {-0.992428f, 0.059512f, 0.107446f}, {0.324198f, 0.227597f} },
    { {-0.047807f, -0.130240f, 0.014095f}, {-0.994373f, -0.041688f, -0.097389f}, {0.391531f, 0.319903f} },
    { {-0.043033f, -0.168836f, 0.125763f}, {-0.956423f, -0.238993f, 0.167741f}, {0.415776f, 0.233632f} },
    { {0.037649f, -0.169679f, 0.124916f}, {0.987881f, -0.132021f, 0.081620f}, {0.303851f, 0.234286f} },
    { {0.044908f, -0.076245f, 0.006147f}, {0.992219f, -0.074699f, -0.099609f}, {0.362543f, 0.326044f} },
    { {0.044998f, -0.077181f, 0.133336f}, {0.996216f, -0.042230f, 0.075969f}, {0.361955f, 0.227781f} },
    { {0.037387f, -0.130414f, 0.014525f}, {0.975095f, -0.101427f, -0.197237f}, {0.328516f, 0.319571f} },
    { {-0.047689f, -0.021380f, 0.005583f}, {-0.959435f, 0.246516f, -0.136803f}, {0.323149f, 0.326479f} },
    { {0.030383f, -0.022986f, -0.008378f}, {0.317084f, 0.107926f, -0.942237f}, {0.316933f, 0.241533f} },
    { {-0.000932f, -0.075979f, -0.008391f}, {-0.000148f, -0.075150f, -0.997172f}, {0.355923f, 0.274481f} },
    { {0.003716f, -0.022986f, -0.008378f}, {0.036191f, 0.315818f, -0.948129f}, {0.355923f, 0.241533f} },
    { {0.030473f, -0.009397f, 0.133336f}, {0.154204f, 0.985914f, 0.064765f}, {0.316801f, 0.227781f} },
    { {0.030383f, -0.008461f, 0.006147f}, {0.441924f, 0.890138f, -0.111164f}, {0.316933f, 0.326044f} },
    { {-0.002588f, -0.005169f, 0.003219f}, {0.015712f, 0.999013f, -0.041535f}, {0.355923f, 0.326044f} },
    { {-0.002501f, -0.022255f, 0.151770f}, {0.126351f, 0.144826f, 0.981357f}, {0.364365f, 0.242112f} },
    { {0.030473f, -0.077181f, 0.147861f}, {0.307433f, -0.122357f, 0.943670f}, {0.403355f, 0.275060f} },
    { {0.030473f, -0.023923f, 0.147861f}, {0.321364f, 0.298091f, 0.898814f}, {0.403355f, 0.242112f} },
    { {-0.027509f, -0.009131f, 0.133324f}, {-0.485355f, 0.862755f, 0.141721f}, {0.313391f, 0.227281f} },
    { {0.030383f, -0.076245f, -0.008378f}, {0.377300f, -0.116479f, -0.918737f}, {0.316933f, 0.274481f} },
    { {0.022862f, -0.130414f, 0.000000f}, {0.203149f, -0.192207f, -0.960097f}, {0.327930f, 0.307992f} },
    { {-0.018244f, -0.182873f, 0.124916f}, {-0.130234f, -0.989208f, 0.067125f}, {0.332125f, 0.234286f} },
    { {-0.018244f, -0.182873f, 0.014525f}, {-0.451395f, -0.887465f, -0.092996f}, {0.332125f, 0.319571f} },
    { {0.027481f, -0.182873f, 0.014525f}, {0.141729f, -0.945723f, -0.292439f}, {0.398980f, 0.319571f} },
    { {-0.004649f, -0.130148f, 0.139429f}, {0.102071f, -0.214895f, 0.971289f}, {0.358799f, 0.307992f} },
    { {-0.002505f, -0.077052f, 0.151976f}, {0.122551f, -0.115201f, 0.985754f}, {0.364365f, 0.275060f} },
    { {0.027481f, -0.182873f, 0.124916f}, {0.308693f, -0.745445f, 0.590780f}, {0.398980f, 0.234286f} },
    { {0.030473f, -0.077181f, 0.147861f}, {0.307433f, -0.122357f, 0.943670f}, {0.361955f, 0.216560f} },
    { {0.044998f, -0.023923f, 0.133336f}, {0.943568f, 0.301420f, 0.137205f}, {0.395410f, 0.227781f} },
    { {0.030473f, -0.023923f, 0.147861f}, {0.321364f, 0.298091f, 0.898814f}, {0.395410f, 0.216560f} },
    { {0.030383f, -0.008461f, 0.006147f}, {0.441924f, 0.890138f, -0.111164f}, {0.405122f, 0.326044f} },
    { {0.030473f, -0.009397f, 0.133336f}, {0.154204f, 0.985914f, 0.064765f}, {0.404534f, 0.227781f} },
    { {-0.022893f, -0.168081f, 0.006326f}, {-0.352744f, -0.379368f, -0.855366f}, {0.388032f, 0.331459f} },
    { {-0.000000f, -0.130414f, 0.000000f}, {-0.000000f, -0.157783f, -0.987474f}, {0.361357f, 0.307992f} },
    { {-0.000000f, -0.130414f, 0.000000f}, {0.155677f, -0.169445f, -0.973167f}, {0.370588f, 0.308172f} },
    { {-0.026105f, -0.168664f, 0.002552f}, {-0.290662f, -0.188292f, -0.938116f}, {0.399525f, 0.331655f} },
    { {-0.030633f, -0.076089f, -0.012287f}, {-0.312576f, -0.090140f, -0.945606f}, {0.406147f, 0.274384f} },
    { {-0.000932f, -0.075979f, -0.008391f}, {0.129919f, -0.081563f, -0.988164f}, {0.365149f, 0.274508f} },
    { {0.003716f, -0.022986f, -0.008378f}, {0.122219f, 0.099080f, -0.987545f}, {0.365143f, 0.240982f} },
    { {-0.027599f, -0.008195f, 0.006134f}, {-0.504856f, 0.852753f, -0.133910f}, {0.312718f, 0.326572f} },
    { {-0.030577f, -0.077223f, 0.151715f}, {-0.463515f, -0.098009f, 0.880652f}, {0.314093f, 0.275086f} },
    { {-0.006312f, -0.130709f, 0.143510f}, {0.092174f, -0.176041f, 0.980058f}, {0.349571f, 0.308174f} },
    { {-0.002505f, -0.077052f, 0.151976f}, {0.041693f, -0.055951f, 0.997563f}, {0.355138f, 0.274980f} },
    { {-0.002501f, -0.022255f, 0.151770f}, {-0.005520f, 0.426688f, 0.904382f}, {0.355143f, 0.241080f} },
    { {-0.027509f, -0.009131f, 0.133324f}, {-0.485355f, 0.862755f, 0.141721f}, {0.312433f, 0.230928f} },
    { {-0.030536f, -0.023098f, 0.151723f}, {-0.260172f, 0.183559f, 0.947954f}, {0.314152f, 0.241602f} },
    { {0.040393f, -0.020009f, 0.117522f}, {0.977898f, -0.099048f, 0.184134f}, {0.397868f, 0.239999f} },
    { {0.026550f, 0.021768f, 0.021530f}, {0.733362f, 0.636451f, -0.238977f}, {0.424111f, 0.314159f} },
    { {0.026550f, 0.021768f, 0.117522f}, {0.389644f, 0.889579f, 0.238384f}, {0.424111f, 0.239999f} },
    { {-0.017454f, 0.022536f, 0.117522f}, {-0.710417f, 0.662179f, 0.238384f}, {0.295564f, 0.239999f} },
    { {-0.032747f, -0.018733f, 0.021530f}, {-0.980614f, -0.065870f, -0.184544f}, {0.321487f, 0.314159f} },
    { {-0.032747f, -0.018733f, 0.117522f}, {-0.341137f, -0.916514f, 0.208874f}, {0.321487f, 0.239999f} },
    { {-0.017454f, 0.022536f, 0.021530f}, {-0.357770f, 0.902713f, -0.238978f}, {0.295564f, 0.314159f} },
    { {0.040393f, -0.020009f, 0.021530f}, {0.306269f, -0.928747f, -0.208875f}, {0.397868f, 0.314159f} },
    { {0.003806f, -0.009397f, 0.133336f}, {0.006737f, 0.819098f, 0.573614f}, {0.355166f, 0.231090f} },
    { {0.003806f, -0.009397f, 0.133336f}, {0.013685f, 0.994354f, 0.105229f}, {0.355791f, 0.227781f} },
    { {-0.027599f, -0.008195f, 0.006134f}, {-0.032382f, 0.999166f, 0.024889f}, {0.394913f, 0.326044f} },
    { {-0.027509f, -0.009131f, 0.133324f}, {0.008499f, 0.999937f, 0.007354f}, {0.394781f, 0.227781f} },
    { {-0.030433f, -0.021453f, -0.012179f}, {-0.235140f, 0.294928f, -0.926135f}, {0.405853f, 0.240584f} },
    { {-0.002588f, -0.005169f, 0.003219f}, {-0.006702f, 0.693070f, -0.720839f}, {0.365141f, 0.230510f} },
    { {0.030383f, -0.008461f, 0.006147f}, {0.441924f, 0.890138f, -0.111164f}, {0.316933f, 0.232547f} },
    { {-0.002588f, -0.005169f, 0.003219f}, {0.015712f, 0.999013f, -0.041535f}, {0.355923f, 0.232547f} },
    { {-0.043033f, -0.168836f, 0.125763f}, {-0.956423f, -0.238993f, 0.167741f}, {0.295880f, 0.233632f} },
    { {-0.043162f, -0.168583f, 0.014252f}, {-0.840360f, -0.529427f, -0.116197f}, {0.295691f, 0.319782f} },
    { {-0.022893f, -0.168081f, 0.006326f}, {0.045010f, -0.998697f, -0.024036f}, {0.325328f, 0.325905f} },
    { {-0.030633f, -0.076089f, -0.012287f}, {-0.312576f, -0.090140f, -0.945606f}, {0.357516f, 0.340285f} },
    { {-0.026105f, -0.168664f, 0.002552f}, {-0.290662f, -0.188292f, -0.938116f}, {0.415668f, 0.328821f} },
    { {0.004006f, -0.008885f, 0.124768f}, {-0.101520f, -0.932365f, 0.346971f}, {0.364658f, 0.232809f} },
    { {0.040393f, -0.020009f, 0.117522f}, {0.977898f, -0.099048f, 0.184134f}, {0.401394f, 0.237561f} },
    { {0.026550f, 0.021768f, 0.117522f}, {0.389644f, 0.889579f, 0.238384f}, {0.397619f, 0.213846f} },
    { {0.004006f, -0.008885f, 0.124768f}, {-0.101520f, -0.932365f, 0.346971f}, {0.364658f, 0.234401f} },
    { {0.040393f, -0.020009f, 0.021530f}, {0.306269f, -0.928747f, -0.208875f}, {0.417860f, 0.314159f} },
    { {0.040393f, -0.020009f, 0.117522f}, {0.977898f, -0.099048f, 0.184134f}, {0.417860f, 0.239999f} },
    { {-0.017454f, 0.022536f, 0.021530f}, {-0.357770f, 0.902713f, -0.238978f}, {0.386877f, 0.213371f} },
    { {0.004006f, -0.008885f, 0.014703f}, {0.068706f, -0.935666f, -0.346133f}, {0.355499f, 0.232809f} },
    { {-0.032747f, -0.018733f, 0.021530f}, {-0.980614f, -0.065870f, -0.184544f}, {0.392605f, 0.237016f} },
    { {-0.032747f, -0.018733f, 0.117522f}, {-0.341137f, -0.916514f, 0.208874f}, {0.310920f, 0.239999f} },
    { {-0.032747f, -0.018733f, 0.021530f}, {-0.980614f, -0.065870f, -0.184544f}, {0.310920f, 0.314159f} },
    { {0.004006f, -0.008885f, 0.014703f}, {0.068706f, -0.935666f, -0.346133f}, {0.364658f, 0.319433f} },
    { {-0.017454f, 0.022536f, 0.117522f}, {-0.710417f, 0.662179f, 0.238384f}, {0.333280f, 0.213371f} },
    { {0.026550f, 0.021768f, 0.117522f}, {0.389644f, 0.889579f, 0.238384f}, {0.322537f, 0.239999f} },
    { {-0.017454f, 0.022536f, 0.021530f}, {-0.357770f, 0.902713f, -0.238978f}, {0.386877f, 0.314159f} },
    { {-0.017454f, 0.022536f, 0.117522f}, {-0.710417f, 0.662179f, 0.238384f}, {0.386877f, 0.239999f} },
    { {0.026550f, 0.021768f, 0.021530f}, {0.733362f, 0.636451f, -0.238977f}, {0.322537f, 0.213846f} },
    { {0.026550f, 0.021768f, 0.021530f}, {0.733362f, 0.636451f, -0.238977f}, {0.322537f, 0.314159f} },
    { {-0.025388f, -0.168821f, 0.137052f}, {-0.222696f, -0.625153f, 0.748058f}, {0.321680f, 0.224910f} },
    { {-0.030577f, -0.077223f, 0.151715f}, {-0.463515f, -0.098009f, 0.880652f}, {0.358228f, 0.213582f} },
    { {-0.025388f, -0.168821f, 0.137052f}, {-0.222696f, -0.625153f, 0.748058f}, {0.415767f, 0.224910f} },
    { {0.044908f, -0.022986f, 0.006147f}, {0.990446f, 0.124468f, -0.059371f}, {0.395998f, 0.326044f} },
    { {0.030383f, -0.076245f, -0.008378f}, {0.377300f, -0.116479f, -0.918737f}, {0.362543f, 0.337265f} },
    { {0.027481f, -0.182873f, 0.124916f}, {0.308693f, -0.745445f, 0.590780f}, {0.398980f, 0.340445f} },
    { {-0.030536f, -0.023098f, 0.151723f}, {-0.260172f, 0.183559f, 0.947954f}, {0.324229f, 0.213576f} },
    { {0.003806f, -0.009397f, 0.133336f}, {0.013685f, 0.994354f, 0.105229f}, {0.364365f, 0.233126f} },
    { {-0.027599f, -0.008195f, 0.006134f}, {-0.504856f, 0.852753f, -0.133910f}, {0.407590f, 0.230266f} },
    { {-0.018244f, -0.168348f, 0.133103f}, {0.098942f, -0.292287f, 0.951199f}, {0.332125f, 0.331459f} },
    { {-0.025388f, -0.168821f, 0.137052f}, {-0.222696f, -0.625153f, 0.748058f}, {0.321680f, 0.331753f} },
    { {-0.032747f, -0.018733f, 0.117522f}, {-0.341137f, -0.916514f, 0.208874f}, {0.327551f, 0.237016f} },
    { {0.040393f, -0.020009f, 0.021530f}, {0.306269f, -0.928747f, -0.208875f}, {0.318762f, 0.237561f} },
    { {-0.018244f, -0.182873f, 0.124916f}, {-0.130234f, -0.989208f, 0.067125f}, {0.332125f, 0.340445f} },
    { {-0.025388f, -0.168821f, 0.137052f}, {-0.917975f, -0.396273f, 0.017035f}, {0.415469f, 0.234286f} },
    { {-0.018244f, -0.182873f, 0.014525f}, {-0.451395f, -0.887465f, -0.092996f}, {0.424593f, 0.319571f} },
    { {-0.018244f, -0.182873f, 0.124916f}, {-0.130234f, -0.989208f, 0.067125f}, {0.424593f, 0.234286f} },
    { {0.030383f, -0.022986f, -0.008378f}, {0.317084f, 0.107926f, -0.942237f}, {0.395998f, 0.337265f} },
    { {0.022862f, -0.130414f, 0.000000f}, {0.203149f, -0.192207f, -0.960097f}, {0.328516f, 0.330792f} },
    { {0.027481f, -0.182873f, 0.124916f}, {0.308693f, -0.745445f, 0.590780f}, {0.295564f, 0.234286f} },
    { {0.027481f, -0.182873f, 0.014525f}, {0.141729f, -0.945723f, -0.292439f}, {0.295564f, 0.319571f} },
    { {0.037649f, -0.169679f, 0.014525f}, {0.950033f, -0.279916f, -0.138146f}, {0.303851f, 0.319571f} },
    { {-0.030433f, -0.021453f, -0.012179f}, {-0.235140f, 0.294928f, -0.926135f}, {0.323195f, 0.340202f} },
    { {0.027481f, -0.182873f, 0.124916f}, {0.308693f, -0.745445f, 0.590780f}, {0.304407f, 0.227962f} },
    { {-0.022893f, -0.168081f, 0.006326f}, {-0.352744f, -0.379368f, -0.855366f}, {0.415469f, 0.325896f} },
    { {-0.018244f, -0.182873f, 0.014525f}, {-0.451395f, -0.887465f, -0.092996f}, {0.388032f, 0.340445f} },
    { {0.027481f, -0.182873f, 0.014525f}, {0.141729f, -0.945723f, -0.292439f}, {0.321176f, 0.340445f} },
    { {0.030473f, -0.009397f, 0.133336f}, {0.154204f, 0.985914f, 0.064765f}, {0.403355f, 0.233126f} },
    { {-0.018244f, -0.168348f, 0.133103f}, {0.098942f, -0.292287f, 0.951199f}, {0.415469f, 0.227962f} },
    { {-0.006312f, -0.130709f, 0.143510f}, {0.468159f, -0.370263f, 0.802330f}, {0.328164f, 0.219911f} },
    { {-0.025388f, -0.168821f, 0.137052f}, {0.468159f, -0.370263f, 0.802330f}, {0.304223f, 0.224901f} },
    { {-0.018244f, -0.168348f, 0.133103f}, {0.468159f, -0.370263f, 0.802330f}, {0.304688f, 0.227962f} },
    { {0.037649f, -0.169679f, 0.014525f}, {0.950033f, -0.279916f, -0.138146f}, {0.306310f, 0.332283f} },
    { {-0.000000f, -0.130414f, 0.000000f}, {0.155677f, -0.169445f, -0.973167f}, {0.328683f, 0.330802f} },
    { {-0.022893f, -0.168081f, 0.006326f}, {0.045010f, -0.998697f, -0.024036f}, {0.304855f, 0.325905f} },
    { {-0.026105f, -0.168664f, 0.002552f}, {-0.290662f, -0.188292f, -0.938116f}, {0.304489f, 0.328821f} },
    { {-0.026105f, -0.168664f, 0.002552f}, {-0.290662f, -0.188292f, -0.938116f}, {0.320631f, 0.328821f} },
    { {-0.043162f, -0.168583f, 0.014252f}, {-0.840360f, -0.529427f, -0.116197f}, {0.415617f, 0.319782f} },
    { {-0.018244f, -0.168348f, 0.133103f}, {0.879012f, -0.363857f, 0.308134f}, {0.304855f, 0.227971f} },
    { {-0.004649f, -0.130148f, 0.139429f}, {0.912295f, -0.227655f, 0.340427f}, {0.328683f, 0.223074f} },
    { {-0.006312f, -0.130709f, 0.143510f}, {0.092174f, -0.176041f, 0.980058f}, {0.328331f, 0.219921f} },
    { {-0.002505f, -0.077052f, 0.151976f}, {0.041693f, -0.055951f, 0.997563f}, {0.362036f, 0.213380f} },
};

WORD g_tind24[] = 
{
    0, 1, 2,    3, 4, 5,    3, 6, 4,    0, 7, 1,    8, 9, 10,
    11, 12, 13,    14, 15, 16,    17, 7, 0,    18, 19, 9,    20, 21, 22,
    23, 15, 24,    20, 22, 25,    26, 27, 28,    27, 29, 30,    19, 31, 32,
    33, 34, 35,    36, 35, 37,    17, 38, 7,    39, 40, 41,    42, 43, 44,
    45, 46, 47,    48, 49, 50,    48, 51, 49,    45, 52, 46,    53, 43, 42,
    54, 55, 56,    37, 57, 58,    59, 10, 60,    61, 62, 63,    1, 64, 65,
    66, 67, 68,    69, 70, 71,    72, 73, 74,    75, 76, 77,    66, 68, 78,
    79, 80, 81,    82, 73, 72,    79, 83, 80,    63, 84, 61,    85, 2, 86,
    27, 87, 29,    6, 88, 4,    26, 3, 5,    23, 89, 15,    85, 0, 2,
    90, 17, 0,    16, 91, 14,    11, 55, 54,    11, 13, 55,    58, 57, 92,
    93, 89, 23,    39, 94, 40,    66, 78, 95,    75, 77, 69,    96, 73, 82,
    69, 77, 70,    7, 64, 1,    37, 35, 57,    93, 97, 89,    98, 99, 100,
    33, 35, 36,    19, 32, 9,    59, 8, 10,    87, 101, 29,    6, 102, 88,
    103, 104, 105,    44, 39, 41,    90, 0, 85,    7, 106, 64,    38, 106, 7,
    107, 3, 26,    103, 105, 3,    24, 15, 14,    44, 41, 42,    98, 108, 99,
    109, 31, 110,    16, 111, 91,    28, 27, 30,    112, 98, 100,    113, 114, 115,
    5, 87, 27,    26, 5, 27,    8, 18, 9,    4, 88, 101,    19, 110, 31,
    116, 110, 19,    4, 101, 87,    5, 4, 87,    117, 118, 119,    62, 120, 63,
    1, 65, 121,    2, 1, 121,    122, 123, 124,    125, 124, 123,    105, 102, 6,
    3, 105, 6,
};

D3DMATRIX g_tmat25 = 
{
    -0.674250f, -0.148269f, 0.723466f, 0.000000f, 
    0.729716f, 0.016912f, 0.683541f, 0.000000f, 
    -0.113583f, 0.988803f, 0.096791f, 0.000000f, 
    -0.622303f, -2.276153f, 1.876026f, 1.000000f, 
};

// Mesh #25 Tris:74 Verts:98
MODELVERT g_tmesh25[] = 
{
    { {0.028660f, -0.022378f, 0.099933f}, {0.954250f, 0.257611f, 0.151803f}, {0.399661f, 0.228668f} },
    { {0.038275f, -0.106688f, 0.021795f}, {0.991157f, 0.034085f, -0.128240f}, {0.330727f, 0.313958f} },
    { {0.028660f, -0.022378f, 0.011620f}, {0.960957f, 0.253132f, -0.111739f}, {0.399661f, 0.325064f} },
    { {-0.038583f, -0.022115f, 0.100090f}, {-0.992702f, -0.054489f, 0.107582f}, {0.320281f, 0.228497f} },
    { {-0.038500f, -0.021590f, 0.011201f}, {-0.984197f, 0.087556f, -0.153917f}, {0.319851f, 0.325521f} },
    { {-0.026559f, -0.107000f, 0.020047f}, {-0.966262f, -0.233486f, -0.108728f}, {0.389685f, 0.315865f} },
    { {0.038374f, -0.107393f, 0.094738f}, {0.977200f, 0.010134f, 0.212080f}, {0.330150f, 0.234339f} },
    { {-0.026397f, -0.107692f, 0.096050f}, {-0.900214f, -0.381837f, 0.209322f}, {0.390251f, 0.232906f} },
    { {-0.017843f, -0.107867f, 0.095510f}, {-0.999689f, -0.009694f, 0.022995f}, {0.390394f, 0.233495f} },
    { {-0.009442f, -0.108574f, 0.009203f}, {-0.671312f, -0.115472f, -0.732125f}, {0.391887f, 0.327691f} },
    { {-0.014326f, -0.136947f, 0.026711f}, {-0.976126f, -0.179467f, -0.122350f}, {0.414170f, 0.308592f} },
    { {0.024591f, -0.109598f, 0.010116f}, {0.276907f, -0.185007f, -0.942918f}, {0.319766f, 0.308158f} },
    { {-0.002368f, -0.139352f, 0.015699f}, {0.020322f, -0.485891f, -0.873783f}, {0.367105f, 0.332117f} },
    { {-0.009442f, -0.108574f, 0.009203f}, {-0.671312f, -0.115472f, -0.732125f}, {0.373424f, 0.308235f} },
    { {-0.014171f, -0.138049f, 0.092315f}, {-0.846282f, -0.450437f, 0.284451f}, {0.415071f, 0.236982f} },
    { {-0.019169f, -0.066195f, 0.113669f}, {0.072613f, -0.093202f, 0.992996f}, {0.336170f, 0.273605f} },
    { {0.024513f, -0.109038f, 0.106453f}, {0.320578f, -0.065624f, 0.944946f}, {0.400252f, 0.307707f} },
    { {0.010878f, -0.020878f, 0.113937f}, {0.326765f, 0.014165f, 0.944999f}, {0.387131f, 0.237925f} },
    { {0.010876f, -0.007517f, 0.100084f}, {-0.014909f, 0.997409f, 0.070374f}, {0.343850f, 0.228503f} },
    { {-0.024845f, -0.008013f, 0.011432f}, {-0.177256f, 0.981035f, -0.078432f}, {0.406575f, 0.325269f} },
    { {-0.025304f, -0.008153f, 0.100283f}, {-0.367146f, 0.916727f, 0.157528f}, {0.407381f, 0.228285f} },
    { {-0.025308f, -0.021816f, 0.113888f}, {-0.269107f, 0.189331f, 0.944317f}, {0.312768f, 0.237472f} },
    { {-0.019169f, -0.066195f, 0.113669f}, {-0.498220f, -0.127136f, 0.857679f}, {0.323548f, 0.273208f} },
    { {0.010878f, -0.020878f, 0.113937f}, {-0.007773f, 0.355599f, 0.934606f}, {0.376311f, 0.236717f} },
    { {0.010921f, -0.007559f, 0.011119f}, {-0.001179f, 0.966827f, -0.255431f}, {0.343770f, 0.325611f} },
    { {0.017040f, -0.022378f, -0.000000f}, {0.059918f, 0.188262f, -0.980289f}, {0.343820f, 0.236925f} },
    { {-0.018954f, -0.067556f, -0.002229f}, {-0.497141f, -0.138989f, -0.856465f}, {0.396230f, 0.274304f} },
    { {-0.024965f, -0.021441f, -0.002388f}, {-0.164742f, 0.269310f, -0.948858f}, {0.406785f, 0.237170f} },
    { {-0.002561f, -0.149597f, 0.090944f}, {0.124892f, -0.990559f, 0.056532f}, {0.295564f, 0.238739f} },
    { {-0.002747f, -0.148271f, 0.029496f}, {-0.165146f, -0.979830f, -0.112520f}, {0.296680f, 0.305025f} },
    { {0.033380f, -0.136797f, 0.028120f}, {0.560508f, -0.792602f, -0.240028f}, {0.306109f, 0.307053f} },
    { {-0.002368f, -0.139352f, 0.015699f}, {0.020322f, -0.485891f, -0.873783f}, {0.303181f, 0.319853f} },
    { {0.024591f, -0.109598f, 0.010116f}, {0.276907f, -0.185007f, -0.942918f}, {0.328348f, 0.326706f} },
    { {0.027666f, -0.023067f, 0.092013f}, {0.983332f, -0.071758f, 0.167061f}, {0.399098f, 0.237312f} },
    { {0.016930f, 0.007958f, 0.015460f}, {0.719474f, 0.640292f, -0.269043f}, {0.424465f, 0.320873f} },
    { {0.016928f, 0.007971f, 0.092013f}, {0.374339f, 0.887654f, 0.268218f}, {0.424476f, 0.237312f} },
    { {-0.015916f, 0.008115f, 0.092013f}, {-0.712974f, 0.646470f, 0.271558f}, {0.295564f, 0.237312f} },
    { {-0.026922f, -0.022842f, 0.015460f}, {-0.982153f, -0.076093f, -0.172003f}, {0.320875f, 0.320873f} },
    { {-0.026924f, -0.022829f, 0.092013f}, {-0.558919f, -0.807074f, 0.190368f}, {0.320864f, 0.237312f} },
    { {0.027668f, -0.023081f, 0.015460f}, {0.563894f, -0.803843f, -0.189369f}, {0.399087f, 0.320873f} },
    { {-0.015914f, 0.008102f, 0.015460f}, {-0.365630f, 0.889996f, -0.272435f}, {0.295574f, 0.320873f} },
    { {0.033550f, -0.138013f, 0.091621f}, {0.832409f, -0.543602f, 0.107663f}, {0.305115f, 0.237740f} },
    { {0.024513f, -0.109038f, 0.106453f}, {0.320578f, -0.065624f, 0.944946f}, {0.328805f, 0.221551f} },
    { {0.010921f, -0.007559f, 0.011119f}, {0.641339f, 0.766245f, -0.039416f}, {0.409162f, 0.325064f} },
    { {0.010921f, -0.007559f, 0.011119f}, {-0.001179f, 0.966827f, -0.255431f}, {0.343770f, 0.225992f} },
    { {0.016930f, 0.007958f, 0.015460f}, {0.719474f, 0.640292f, -0.269043f}, {0.333220f, 0.213497f} },
    { {0.000771f, -0.022700f, 0.010365f}, {-0.001219f, -0.925712f, -0.378228f}, {0.361595f, 0.238184f} },
    { {-0.015914f, 0.008102f, 0.015460f}, {-0.365630f, 0.889996f, -0.272435f}, {0.390892f, 0.213381f} },
    { {0.016928f, 0.007971f, 0.092013f}, {0.374339f, 0.887654f, 0.268218f}, {0.333223f, 0.237312f} },
    { {0.016930f, 0.007958f, 0.015460f}, {0.719474f, 0.640292f, -0.269043f}, {0.333220f, 0.320873f} },
    { {-0.015914f, 0.008102f, 0.015460f}, {-0.365630f, 0.889996f, -0.272435f}, {0.390892f, 0.320873f} },
    { {-0.006055f, -0.109061f, 0.106898f}, {-0.187267f, -0.193895f, 0.962983f}, {0.391370f, 0.221065f} },
    { {0.013316f, -0.140325f, 0.103361f}, {0.115457f, -0.372149f, 0.920964f}, {0.416047f, 0.224553f} },
    { {0.013316f, -0.140325f, 0.103361f}, {0.115457f, -0.372149f, 0.920964f}, {0.303224f, 0.224926f} },
    { {-0.018954f, -0.067556f, -0.002229f}, {-0.497141f, -0.138989f, -0.856465f}, {0.357434f, 0.340181f} },
    { {-0.026397f, -0.107692f, 0.096050f}, {-0.900214f, -0.381837f, 0.209322f}, {0.310857f, 0.232906f} },
    { {-0.026559f, -0.107000f, 0.020047f}, {-0.966262f, -0.233486f, -0.108728f}, {0.310572f, 0.315865f} },
    { {-0.009442f, -0.108574f, 0.009203f}, {-0.240882f, -0.930326f, -0.276530f}, {0.340628f, 0.327702f} },
    { {0.010876f, -0.007517f, 0.100084f}, {0.638576f, 0.763147f, 0.099128f}, {0.409162f, 0.228668f} },
    { {0.010876f, -0.007517f, 0.100084f}, {-0.014909f, 0.997409f, 0.070374f}, {0.376307f, 0.225958f} },
    { {-0.025304f, -0.008153f, 0.100283f}, {-0.367146f, 0.916727f, 0.157528f}, {0.312776f, 0.226470f} },
    { {0.000769f, -0.022687f, 0.097421f}, {-0.006901f, -0.923993f, 0.382347f}, {0.358559f, 0.238173f} },
    { {0.027666f, -0.023067f, 0.092013f}, {0.983332f, -0.071758f, 0.167061f}, {0.390974f, 0.236500f} },
    { {0.016928f, 0.007971f, 0.092013f}, {0.374339f, 0.887654f, 0.268218f}, {0.386934f, 0.213486f} },
    { {0.000769f, -0.022687f, 0.097421f}, {-0.006901f, -0.923993f, 0.382347f}, {0.358559f, 0.231410f} },
    { {0.027668f, -0.023081f, 0.015460f}, {0.563894f, -0.803843f, -0.189369f}, {0.405793f, 0.320873f} },
    { {0.027666f, -0.023067f, 0.092013f}, {0.983332f, -0.071758f, 0.167061f}, {0.405790f, 0.237312f} },
    { {-0.015914f, 0.008102f, 0.015460f}, {-0.365630f, 0.889996f, -0.272435f}, {0.382023f, 0.219172f} },
    { {-0.026922f, -0.022842f, 0.015460f}, {-0.982153f, -0.076093f, -0.172003f}, {0.395371f, 0.236378f} },
    { {-0.026924f, -0.022829f, 0.092013f}, {-0.558919f, -0.807074f, 0.190368f}, {0.309930f, 0.237312f} },
    { {-0.026922f, -0.022842f, 0.015460f}, {-0.982153f, -0.076093f, -0.172003f}, {0.309933f, 0.320873f} },
    { {0.000771f, -0.022700f, 0.010365f}, {-0.001219f, -0.925712f, -0.378228f}, {0.358562f, 0.326434f} },
    { {-0.019169f, -0.066195f, 0.113669f}, {-0.498220f, -0.127136f, 0.857679f}, {0.356322f, 0.213675f} },
    { {-0.006055f, -0.109061f, 0.106898f}, {-0.187267f, -0.193895f, 0.962983f}, {0.346577f, 0.307726f} },
    { {-0.015916f, 0.008115f, 0.092013f}, {-0.712974f, 0.646470f, 0.271558f}, {0.329261f, 0.213371f} },
    { {-0.015916f, 0.008115f, 0.092013f}, {-0.712974f, 0.646470f, 0.271558f}, {0.390896f, 0.237312f} },
    { {-0.025308f, -0.021816f, 0.113888f}, {-0.269107f, 0.189331f, 0.944317f}, {0.320036f, 0.213435f} },
    { {-0.025304f, -0.008153f, 0.100283f}, {-0.367146f, 0.916727f, 0.157528f}, {0.308865f, 0.228285f} },
    { {0.017040f, -0.022378f, -0.000000f}, {0.438055f, -0.031296f, -0.898403f}, {0.333026f, 0.237925f} },
    { {-0.018954f, -0.067556f, -0.002229f}, {0.136332f, -0.146493f, -0.979772f}, {0.383649f, 0.274708f} },
    { {0.017040f, -0.022378f, -0.000000f}, {0.438055f, -0.031296f, -0.898403f}, {0.399661f, 0.337748f} },
    { {0.010878f, -0.020878f, 0.113937f}, {0.326765f, 0.014165f, 0.944999f}, {0.399661f, 0.215984f} },
    { {-0.009442f, -0.108574f, 0.009203f}, {-0.240882f, -0.930326f, -0.276530f}, {0.391829f, 0.329704f} },
    { {-0.015916f, 0.008115f, 0.092013f}, {-0.712974f, 0.646470f, 0.271558f}, {0.338131f, 0.219162f} },
    { {-0.026924f, -0.022829f, 0.092013f}, {-0.558919f, -0.807074f, 0.190368f}, {0.324783f, 0.236367f} },
    { {-0.002368f, -0.139352f, 0.015699f}, {0.020322f, -0.485891f, -0.873783f}, {0.416136f, 0.320612f} },
    { {0.027668f, -0.023081f, 0.015460f}, {0.563894f, -0.803843f, -0.189369f}, {0.329179f, 0.236510f} },
    { {-0.006055f, -0.109061f, 0.106898f}, {-0.456754f, -0.367538f, 0.810118f}, {0.391223f, 0.219061f} },
    { {-0.024965f, -0.021441f, -0.002388f}, {-0.164742f, 0.269310f, -0.948858f}, {0.319729f, 0.340354f} },
    { {-0.024845f, -0.008013f, 0.011432f}, {-0.177256f, 0.981035f, -0.078432f}, {0.308750f, 0.325269f} },
    { {0.013316f, -0.140325f, 0.103361f}, {0.115457f, -0.372149f, 0.920964f}, {0.380591f, 0.332901f} },
    { {-0.002747f, -0.148271f, 0.029496f}, {-0.165146f, -0.979830f, -0.112520f}, {0.423429f, 0.305552f} },
    { {-0.002561f, -0.149597f, 0.090944f}, {0.124892f, -0.990559f, 0.056532f}, {0.424513f, 0.238480f} },
    { {0.033550f, -0.138013f, 0.091621f}, {0.832409f, -0.543602f, 0.107663f}, {0.416123f, 0.331038f} },
    { {0.038374f, -0.107393f, 0.094738f}, {0.977200f, 0.010134f, 0.212080f}, {0.424593f, 0.306382f} },
    { {-0.024845f, -0.008013f, 0.011432f}, {-0.177256f, 0.981035f, -0.078432f}, {0.406575f, 0.226357f} },
    { {-0.017843f, -0.107867f, 0.095510f}, {-0.020710f, -0.999776f, -0.004268f}, {0.319772f, 0.233506f} },
    { {-0.006055f, -0.109061f, 0.106898f}, {-0.456754f, -0.367538f, 0.810118f}, {0.332916f, 0.219061f} },
};

WORD g_tind25[] = 
{
    0, 1, 2,    3, 4, 5,    6, 1, 0,    3, 5, 7,    8, 9, 10,
    11, 12, 13,    8, 10, 14,    15, 16, 17,    18, 19, 20,    21, 22, 23,
    18, 24, 19,    25, 26, 27,    28, 29, 30,    30, 31, 32,    33, 34, 35,
    36, 37, 38,    33, 39, 34,    36, 40, 37,    28, 30, 41,    42, 6, 0,
    0, 2, 43,    44, 25, 27,    45, 46, 47,    48, 49, 50,    51, 14, 52,
    53, 28, 41,    4, 54, 5,    55, 56, 57,    0, 43, 58,    23, 59, 60,
    61, 62, 63,    64, 65, 66,    67, 46, 68,    69, 70, 71,    72, 3, 7,
    15, 73, 16,    61, 63, 74,    48, 50, 75,    76, 3, 72,    77, 4, 3,
    78, 11, 79,    1, 32, 80,    42, 0, 81,    81, 0, 58,    5, 54, 82,
    11, 13, 79,    61, 83, 84,    69, 71, 64,    9, 85, 10,    29, 31, 30,
    86, 46, 45,    64, 71, 65,    51, 8, 14,    72, 7, 87,    4, 88, 54,
    77, 89, 4,    30, 32, 1,    41, 30, 1,    53, 6, 42,    73, 90, 16,
    23, 60, 21,    76, 77, 3,    2, 80, 43,    1, 80, 2,    14, 91, 92,
    52, 14, 92,    10, 85, 91,    14, 10, 91,    41, 1, 6,    90, 93, 94,
    44, 27, 95,    89, 88, 4,    57, 96, 55,    97, 55, 96,
};

D3DMATRIX g_tmat26 = 
{
    0.592679f, 0.779629f, 0.202266f, 0.000000f, 
    -0.382223f, 0.051196f, 0.922651f, 0.000000f, 
    0.708970f, -0.624146f, 0.328335f, 0.000000f, 
    -1.018899f, -2.428339f, 2.123934f, 1.000000f, 
};

// Mesh #26 Tris:86 Verts:117
MODELVERT g_tmesh26[] = 
{
    { {-0.079072f, -0.155685f, 0.162306f}, {-0.988601f, -0.045595f, 0.143491f}, {0.388136f, 0.231410f} },
    { {-0.071992f, -0.012571f, 0.016932f}, {-0.961662f, 0.211914f, -0.174066f}, {0.324910f, 0.322758f} },
    { {-0.079085f, -0.155464f, 0.017324f}, {-0.986528f, -0.049434f, -0.155946f}, {0.388038f, 0.322511f} },
    { {0.048230f, -0.150767f, 0.161142f}, {0.995966f, -0.065353f, 0.061480f}, {0.334194f, 0.232142f} },
    { {0.048231f, -0.219470f, 0.018738f}, {0.979462f, -0.151365f, -0.133199f}, {0.303841f, 0.321623f} },
    { {0.061755f, -0.013360f, 0.018738f}, {0.998084f, -0.019424f, -0.058738f}, {0.394898f, 0.321623f} },
    { {0.061755f, -0.013360f, 0.161142f}, {0.978362f, 0.100482f, 0.180861f}, {0.394898f, 0.232142f} },
    { {-0.072577f, -0.014171f, 0.161758f}, {-0.958562f, 0.245327f, 0.144824f}, {0.325617f, 0.231754f} },
    { {-0.009966f, -0.150865f, 0.179789f}, {0.174909f, -0.040014f, 0.983771f}, {0.362592f, 0.302623f} },
    { {0.029493f, -0.219470f, 0.179879f}, {0.283223f, -0.068863f, 0.956579f}, {0.393777f, 0.332293f} },
    { {0.006763f, -0.013360f, 0.179879f}, {0.163492f, 0.085934f, 0.982795f}, {0.372065f, 0.242616f} },
    { {-0.029492f, -0.238208f, 0.161142f}, {-0.142482f, -0.987099f, 0.073042f}, {0.337435f, 0.232142f} },
    { {0.029493f, -0.238208f, 0.018738f}, {0.142484f, -0.987408f, -0.068724f}, {0.393777f, 0.321623f} },
    { {0.029493f, -0.238208f, 0.161142f}, {0.325925f, -0.933931f, 0.146787f}, {0.393777f, 0.232142f} },
    { {0.043018f, 0.005378f, 0.161142f}, {0.147403f, 0.985950f, 0.078588f}, {0.313461f, 0.232142f} },
    { {0.043018f, 0.005378f, 0.018738f}, {0.281015f, 0.950684f, -0.131265f}, {0.313461f, 0.321623f} },
    { {-0.042663f, 0.006821f, 0.016375f}, {-0.063136f, 0.991707f, -0.111944f}, {0.382721f, 0.321623f} },
    { {-0.006670f, -0.015187f, -0.011224f}, {0.167180f, 0.089859f, -0.981823f}, {0.360922f, 0.243411f} },
    { {-0.049331f, -0.215328f, -0.006931f}, {-0.329310f, -0.099933f, -0.938919f}, {0.405109f, 0.304298f} },
    { {-0.046459f, -0.014062f, -0.010445f}, {-0.389880f, 0.107649f, -0.914552f}, {0.398927f, 0.242921f} },
    { {0.030164f, 0.053857f, 0.152260f}, {0.320831f, 0.905176f, 0.278792f}, {0.325738f, 0.237722f} },
    { {-0.038382f, 0.049964f, 0.026749f}, {-0.420533f, 0.863121f, -0.279596f}, {0.391213f, 0.316589f} },
    { {-0.038382f, 0.049964f, 0.152260f}, {-0.747916f, 0.602410f, 0.278792f}, {0.391213f, 0.237722f} },
    { {-0.057403f, -0.016005f, 0.152260f}, {-0.270247f, -0.931382f, 0.243916f}, {0.310776f, 0.237722f} },
    { {-0.001364f, 0.003564f, 0.016099f}, {0.053786f, -0.947201f, -0.316096f}, {0.364303f, 0.323281f} },
    { {-0.001364f, 0.003564f, 0.163563f}, {0.047710f, -0.840193f, 0.540184f}, {0.364303f, 0.230620f} },
    { {-0.029492f, -0.238208f, 0.018738f}, {-0.287630f, -0.947595f, -0.139043f}, {0.337435f, 0.321623f} },
    { {0.029493f, -0.219470f, 0.000000f}, {0.215137f, -0.150552f, -0.964909f}, {0.326380f, 0.332293f} },
    { {-0.049331f, -0.215328f, -0.006931f}, {-0.329310f, -0.099933f, -0.938919f}, {0.382721f, 0.332293f} },
    { {-0.009966f, -0.150865f, -0.000090f}, {0.186834f, -0.015437f, -0.982270f}, {0.357565f, 0.302623f} },
    { {-0.035692f, 0.011572f, 0.166099f}, {-0.244655f, 0.962220f, 0.119489f}, {0.382721f, 0.232142f} },
    { {-0.046429f, -0.015005f, 0.190255f}, {-0.411618f, 0.092375f, 0.906663f}, {0.321258f, 0.243332f} },
    { {-0.016841f, -0.150449f, 0.190924f}, {0.241869f, -0.058560f, 0.968540f}, {0.349520f, 0.302262f} },
    { {-0.006700f, -0.014297f, 0.190696f}, {0.164046f, 0.103318f, 0.981027f}, {0.359207f, 0.243024f} },
    { {0.043018f, -0.013360f, 0.000000f}, {0.321587f, 0.025721f, -0.946531f}, {0.313461f, 0.242616f} },
    { {0.043018f, 0.005378f, 0.018738f}, {0.281015f, 0.950684f, -0.131265f}, {0.313461f, 0.234463f} },
    { {-0.000047f, -0.012945f, -0.000090f}, {0.179923f, 0.277225f, -0.943808f}, {0.348091f, 0.242616f} },
    { {-0.042663f, 0.006821f, 0.016375f}, {-0.063136f, 0.991707f, -0.111944f}, {0.382721f, 0.234463f} },
    { {-0.049617f, -0.189506f, 0.190334f}, {-0.410402f, -0.091825f, 0.907270f}, {0.318213f, 0.319256f} },
    { {-0.032648f, -0.185631f, 0.179879f}, {0.084656f, -0.169456f, 0.981895f}, {0.334421f, 0.317570f} },
    { {-0.029492f, -0.219470f, 0.179879f}, {-0.141203f, -0.433151f, 0.890192f}, {0.337435f, 0.332293f} },
    { {0.043018f, 0.005378f, 0.161142f}, {0.147403f, 0.985950f, 0.078588f}, {0.406695f, 0.234463f} },
    { {-0.035692f, 0.011572f, 0.166099f}, {-0.244655f, 0.962220f, 0.119489f}, {0.337436f, 0.234463f} },
    { {0.043018f, -0.013360f, 0.179879f}, {0.321952f, 0.059376f, 0.944892f}, {0.406695f, 0.242616f} },
    { {-0.038382f, 0.049964f, 0.152260f}, {-0.747916f, 0.602410f, 0.278792f}, {0.297283f, 0.237722f} },
    { {-0.038382f, 0.049964f, 0.026749f}, {-0.420533f, 0.863121f, -0.279596f}, {0.297283f, 0.316589f} },
    { {-0.057403f, -0.016005f, 0.026749f}, {-0.966868f, -0.134286f, -0.217104f}, {0.326427f, 0.316589f} },
    { {0.056530f, -0.009536f, 0.152260f}, {0.808875f, -0.550707f, 0.206017f}, {0.396587f, 0.237722f} },
    { {0.056530f, -0.009536f, 0.026749f}, {0.815625f, -0.429128f, -0.388079f}, {0.396587f, 0.316589f} },
    { {0.030164f, 0.053857f, 0.026749f}, {0.675225f, 0.682567f, -0.279595f}, {0.424593f, 0.316589f} },
    { {-0.001364f, 0.003564f, 0.163563f}, {0.047710f, -0.840193f, 0.540184f}, {0.364303f, 0.235252f} },
    { {0.030164f, 0.053857f, 0.152260f}, {0.320831f, 0.905176f, 0.278792f}, {0.394418f, 0.213371f} },
    { {-0.038382f, 0.049964f, 0.152260f}, {-0.747916f, 0.602410f, 0.278792f}, {0.328944f, 0.215064f} },
    { {0.030164f, 0.053857f, 0.152260f}, {0.320831f, 0.905176f, 0.278792f}, {0.424593f, 0.237722f} },
    { {-0.035692f, 0.011572f, 0.166099f}, {-0.244655f, 0.962220f, 0.119489f}, {0.314244f, 0.229027f} },
    { {-0.042663f, 0.006821f, 0.016375f}, {-0.063136f, 0.991707f, -0.111944f}, {0.316343f, 0.323108f} },
    { {-0.042663f, 0.006821f, 0.016375f}, {-0.063136f, 0.991707f, -0.111944f}, {0.395301f, 0.233836f} },
    { {-0.035692f, 0.011572f, 0.166099f}, {-0.244655f, 0.962220f, 0.119489f}, {0.331513f, 0.231768f} },
    { {-0.038382f, 0.049964f, 0.026749f}, {-0.420533f, 0.863121f, -0.279596f}, {0.391213f, 0.215064f} },
    { {-0.001364f, 0.003564f, 0.016099f}, {0.053786f, -0.947201f, -0.316096f}, {0.355853f, 0.235252f} },
    { {-0.057403f, -0.016005f, 0.026749f}, {-0.966868f, -0.134286f, -0.217104f}, {0.392814f, 0.241132f} },
    { {-0.057403f, -0.016005f, 0.026749f}, {-0.966868f, -0.134286f, -0.217104f}, {0.310776f, 0.316589f} },
    { {-0.057403f, -0.016005f, 0.152260f}, {-0.270247f, -0.931382f, 0.243916f}, {0.327342f, 0.241132f} },
    { {-0.057403f, -0.016005f, 0.152260f}, {-0.270247f, -0.931382f, 0.243916f}, {0.326427f, 0.237722f} },
    { {0.030164f, 0.053857f, 0.026749f}, {0.675225f, 0.682567f, -0.279595f}, {0.325738f, 0.213371f} },
    { {0.030164f, 0.053857f, 0.026749f}, {0.675225f, 0.682567f, -0.279595f}, {0.325738f, 0.316589f} },
    { {-0.046429f, -0.015005f, 0.190255f}, {-0.411618f, 0.092375f, 0.906663f}, {0.325986f, 0.213848f} },
    { {-0.049617f, -0.189506f, 0.190334f}, {-0.410402f, -0.091825f, 0.907270f}, {0.403077f, 0.213798f} },
    { {-0.061905f, -0.216986f, 0.017920f}, {-0.901844f, -0.429790f, -0.044244f}, {0.415217f, 0.322137f} },
    { {-0.061730f, -0.217316f, 0.162863f}, {-0.777671f, -0.610329f, 0.150752f}, {0.415363f, 0.231060f} },
    { {-0.016812f, -0.150458f, -0.011307f}, {0.304471f, -0.085248f, -0.948699f}, {0.370609f, 0.302266f} },
    { {-0.049331f, -0.215328f, -0.006931f}, {-0.329310f, -0.099933f, -0.938919f}, {0.401671f, 0.330491f} },
    { {-0.006670f, -0.015187f, -0.011224f}, {0.167180f, 0.089859f, -0.981823f}, {0.364445f, 0.274069f} },
    { {-0.061730f, -0.217316f, 0.162863f}, {-0.777671f, -0.610329f, 0.150752f}, {0.304025f, 0.232198f} },
    { {-0.032648f, -0.185631f, 0.179879f}, {0.084656f, -0.169456f, 0.981895f}, {0.318974f, 0.220424f} },
    { {-0.049617f, -0.189506f, 0.190334f}, {-0.410402f, -0.091825f, 0.907270f}, {0.317079f, 0.213798f} },
    { {0.043018f, 0.005378f, 0.018738f}, {0.281015f, 0.950684f, -0.131265f}, {0.403176f, 0.321623f} },
    { {0.043018f, -0.013360f, 0.000000f}, {0.321587f, 0.025721f, -0.946531f}, {0.394898f, 0.333397f} },
    { {-0.046459f, -0.014062f, -0.010445f}, {-0.389880f, 0.107649f, -0.914552f}, {0.325569f, 0.339960f} },
    { {-0.049331f, -0.215328f, -0.006931f}, {-0.329310f, -0.099933f, -0.938919f}, {0.414485f, 0.337752f} },
    { {-0.061730f, -0.217316f, 0.162863f}, {-0.777671f, -0.610329f, 0.150752f}, {0.416315f, 0.232142f} },
    { {-0.061905f, -0.216986f, 0.017920f}, {-0.901844f, -0.429790f, -0.044244f}, {0.416315f, 0.321623f} },
    { {-0.029492f, -0.238208f, 0.018738f}, {-0.287630f, -0.947595f, -0.139043f}, {0.424593f, 0.321623f} },
    { {0.043018f, 0.005378f, 0.161142f}, {0.147403f, 0.985950f, 0.078588f}, {0.403176f, 0.232142f} },
    { {0.029493f, -0.219470f, 0.179879f}, {0.283223f, -0.068863f, 0.956579f}, {0.303841f, 0.220368f} },
    { {0.043018f, -0.013360f, 0.179879f}, {0.321952f, 0.059376f, 0.944892f}, {0.394898f, 0.220368f} },
    { {0.056530f, -0.009536f, 0.026749f}, {0.815625f, -0.429128f, -0.388079f}, {0.300554f, 0.240952f} },
    { {0.056530f, -0.009536f, 0.026749f}, {0.815625f, -0.429128f, -0.388079f}, {0.419602f, 0.316589f} },
    { {0.056530f, -0.009536f, 0.152260f}, {0.808875f, -0.550707f, 0.206017f}, {0.419602f, 0.237722f} },
    { {-0.009966f, -0.150865f, 0.179789f}, {0.174909f, -0.040014f, 0.983771f}, {0.334150f, 0.220424f} },
    { {0.006763f, -0.013360f, 0.179879f}, {0.163492f, 0.085934f, 0.982795f}, {0.364552f, 0.220424f} },
    { {-0.016841f, -0.150449f, 0.190924f}, {0.241869f, -0.058560f, 0.968540f}, {0.334334f, 0.213427f} },
    { {0.029493f, -0.238208f, 0.161142f}, {0.325925f, -0.933931f, 0.146787f}, {0.295564f, 0.232142f} },
    { {0.029493f, -0.238208f, 0.018738f}, {0.142484f, -0.987408f, -0.068724f}, {0.295564f, 0.321623f} },
    { {0.029493f, -0.219470f, 0.000000f}, {0.215137f, -0.150552f, -0.964909f}, {0.303841f, 0.333397f} },
    { {-0.032648f, -0.185631f, 0.179879f}, {0.084656f, -0.169456f, 0.981895f}, {0.401365f, 0.220368f} },
    { {-0.029492f, -0.219470f, 0.179879f}, {-0.141203f, -0.433151f, 0.890192f}, {0.416315f, 0.220368f} },
    { {-0.029492f, -0.238208f, 0.161142f}, {-0.142482f, -0.987099f, 0.073042f}, {0.424593f, 0.232142f} },
    { {-0.016812f, -0.150458f, -0.011307f}, {0.304471f, -0.085248f, -0.948699f}, {0.334330f, 0.340502f} },
    { {-0.006670f, -0.015187f, -0.011224f}, {0.167180f, 0.089859f, -0.981823f}, {0.394090f, 0.340450f} },
    { {-0.009966f, -0.150865f, -0.000090f}, {0.186834f, -0.015437f, -0.982270f}, {0.334150f, 0.333454f} },
    { {-0.049331f, -0.215328f, -0.006931f}, {-0.329310f, -0.099933f, -0.938919f}, {0.305671f, 0.337752f} },
    { {0.048230f, -0.219470f, 0.161142f}, {0.971543f, -0.208189f, 0.112971f}, {0.303841f, 0.232142f} },
    { {0.056530f, -0.009536f, 0.152260f}, {0.808875f, -0.550707f, 0.206017f}, {0.402488f, 0.239188f} },
    { {-0.029492f, -0.238208f, 0.018738f}, {-0.287630f, -0.947595f, -0.139043f}, {0.382721f, 0.340445f} },
    { {-0.049331f, -0.215328f, -0.006931f}, {-0.329310f, -0.099933f, -0.938919f}, {0.416315f, 0.333397f} },
    { {0.029493f, -0.238208f, 0.018738f}, {0.142484f, -0.987408f, -0.068724f}, {0.326380f, 0.340445f} },
    { {0.029493f, -0.238208f, 0.161142f}, {0.325925f, -0.933931f, 0.146787f}, {0.393777f, 0.340445f} },
    { {-0.000047f, -0.012945f, -0.000090f}, {0.179923f, 0.277225f, -0.943808f}, {0.395081f, 0.333454f} },
    { {-0.042663f, 0.006821f, 0.016375f}, {-0.063136f, 0.991707f, -0.111944f}, {0.395301f, 0.323108f} },
    { {-0.000047f, -0.012945f, -0.000090f}, {0.179923f, 0.277225f, -0.943808f}, {0.354596f, 0.333454f} },
    { {-0.006670f, -0.015187f, -0.011224f}, {0.167180f, 0.089859f, -0.981823f}, {0.360922f, 0.340450f} },
    { {-0.006700f, -0.014297f, 0.190696f}, {0.164046f, 0.103318f, 0.981027f}, {0.394484f, 0.213571f} },
    { {-0.035692f, 0.011572f, 0.166099f}, {0.325430f, 0.817136f, 0.475798f}, {0.389661f, 0.231303f} },
    { {-0.006700f, -0.014297f, 0.190696f}, {0.325430f, 0.817136f, 0.475798f}, {0.354445f, 0.213514f} },
    { {0.006763f, -0.013360f, 0.179879f}, {0.325430f, 0.817136f, 0.475798f}, {0.348091f, 0.220368f} },
    { {-0.029492f, -0.238208f, 0.161142f}, {-0.142482f, -0.987099f, 0.073042f}, {0.337435f, 0.340445f} },
};

WORD g_tind26[] = 
{
    0, 1, 2,    3, 4, 5,    3, 5, 6,    7, 1, 0,    8, 9, 10,
    11, 12, 13,    14, 15, 16,    17, 18, 19,    20, 21, 22,    23, 24, 25,
    11, 26, 12,    27, 28, 29,    14, 16, 30,    31, 32, 33,    34, 27, 29,
    35, 36, 37,    31, 38, 32,    39, 40, 9,    41, 42, 10,    10, 9, 43,
    44, 45, 46,    47, 48, 49,    50, 51, 52,    47, 49, 53,    54, 55, 1,
    17, 19, 56,    54, 1, 7,    33, 57, 31,    58, 59, 60,    23, 61, 24,
    50, 52, 62,    44, 46, 63,    64, 59, 58,    20, 65, 21,    66, 0, 67,
    0, 68, 69,    34, 29, 36,    70, 71, 72,    73, 74, 75,    67, 0, 69,
    6, 5, 76,    4, 77, 5,    1, 78, 79,    55, 78, 1,    80, 81, 82,
    1, 79, 2,    6, 76, 83,    84, 6, 85,    86, 59, 64,    24, 87, 88,
    89, 90, 91,    91, 75, 74,    92, 93, 4,    4, 94, 77,    95, 80, 96,
    80, 82, 97,    98, 99, 100,    101, 98, 100,    92, 4, 102,    84, 3, 6,
    66, 7, 0,    66, 54, 7,    25, 24, 88,    50, 103, 51,    104, 28, 27,
    81, 105, 82,    93, 94, 4,    104, 27, 106,    43, 41, 10,    85, 6, 83,
    84, 92, 102,    40, 107, 9,    35, 34, 36,    5, 77, 76,    2, 79, 68,
    0, 2, 68,    108, 100, 99,    109, 110, 111,    74, 89, 91,    39, 9, 8,
    112, 91, 90,    113, 114, 115,    40, 116, 107,    96, 80, 97,    102, 4, 3,
    84, 102, 3,
};

D3DMATRIX g_tmat27 = 
{
    0.088167f, 0.540354f, 0.836806f, 0.000000f, 
    -0.699706f, -0.564323f, 0.438124f, 0.000000f, 
    0.708970f, -0.624146f, 0.328334f, 0.000000f, 
    -0.931946f, -2.435455f, 1.896574f, 1.000000f, 
};

// Mesh #27 Tris:96 Verts:128
MODELVERT g_tmesh27[] = 
{
    { {0.037388f, -0.130415f, 0.124917f}, {0.987603f, -0.115429f, 0.106376f}, {0.328516f, 0.234286f} },
    { {0.037388f, -0.130415f, 0.014526f}, {0.989338f, -0.072500f, -0.126311f}, {0.328516f, 0.319571f} },
    { {0.044909f, -0.076246f, 0.006148f}, {0.990068f, -0.091846f, -0.106437f}, {0.362543f, 0.326044f} },
    { {-0.046677f, -0.023113f, 0.133579f}, {-0.993320f, 0.042028f, 0.107463f}, {0.324238f, 0.227594f} },
    { {-0.046694f, -0.130305f, 0.014099f}, {-0.994373f, -0.041689f, -0.097389f}, {0.391571f, 0.319901f} },
    { {-0.041920f, -0.168901f, 0.125767f}, {-0.975199f, -0.140323f, 0.171162f}, {0.415816f, 0.233630f} },
    { {-0.046576f, -0.021444f, 0.005587f}, {-0.972365f, 0.189884f, -0.135830f}, {0.323189f, 0.326477f} },
    { {0.044999f, -0.077182f, 0.133337f}, {0.996087f, -0.054653f, 0.069460f}, {0.361955f, 0.227781f} },
    { {0.003807f, -0.009398f, 0.133337f}, {0.051932f, 0.992013f, 0.114947f}, {0.355791f, 0.227781f} },
    { {0.002061f, -0.005436f, 0.003232f}, {0.077622f, 0.996788f, -0.019722f}, {0.394913f, 0.326044f} },
    { {-0.030599f, -0.005909f, 0.133987f}, {0.101403f, 0.994425f, 0.028927f}, {0.399951f, 0.227788f} },
    { {-0.029423f, -0.023163f, 0.151726f}, {-0.150623f, 0.162858f, 0.975084f}, {0.315779f, 0.241641f} },
    { {0.000271f, -0.076980f, 0.147853f}, {0.164733f, -0.037804f, 0.985613f}, {0.356765f, 0.275019f} },
    { {0.003807f, -0.023924f, 0.147862f}, {0.112999f, 0.353336f, 0.928647f}, {0.356770f, 0.241120f} },
    { {0.030383f, -0.076246f, -0.008378f}, {0.384200f, -0.117068f, -0.915798f}, {0.316933f, 0.274481f} },
    { {0.022863f, -0.130415f, 0.000001f}, {0.224694f, -0.180775f, -0.957514f}, {0.327930f, 0.307992f} },
    { {0.000181f, -0.076044f, -0.008387f}, {-0.000029f, -0.072766f, -0.997349f}, {0.355923f, 0.274481f} },
    { {-0.018244f, -0.182874f, 0.124917f}, {-0.131090f, -0.989139f, 0.066483f}, {0.332125f, 0.234286f} },
    { {-0.018244f, -0.182874f, 0.014526f}, {-0.342506f, -0.937372f, -0.063430f}, {0.332125f, 0.319571f} },
    { {0.027481f, -0.182874f, 0.014526f}, {0.154776f, -0.943301f, -0.293646f}, {0.398980f, 0.319571f} },
    { {0.000271f, -0.076980f, 0.147853f}, {-0.000842f, -0.079004f, 0.996874f}, {0.364365f, 0.275060f} },
    { {0.030474f, -0.077182f, 0.147862f}, {0.320426f, -0.122418f, 0.939330f}, {0.403355f, 0.275060f} },
    { {0.003807f, -0.023924f, 0.147862f}, {-0.000147f, 0.112768f, 0.993621f}, {0.364365f, 0.242112f} },
    { {0.027481f, -0.182874f, 0.124917f}, {0.371149f, -0.721082f, 0.585055f}, {0.398980f, 0.234286f} },
    { {0.030383f, -0.022987f, -0.008378f}, {0.307522f, 0.113372f, -0.944763f}, {0.316933f, 0.241533f} },
    { {0.000181f, -0.022785f, -0.008387f}, {0.033614f, 0.286842f, -0.957388f}, {0.355923f, 0.241533f} },
    { {0.030474f, -0.009398f, 0.133337f}, {0.247698f, 0.965902f, 0.075357f}, {0.316801f, 0.227781f} },
    { {0.030383f, -0.008462f, 0.006147f}, {0.464591f, 0.877852f, -0.116327f}, {0.316933f, 0.326044f} },
    { {0.002061f, -0.005436f, 0.003232f}, {0.077622f, 0.996788f, -0.019722f}, {0.355923f, 0.326044f} },
    { {0.030474f, -0.077182f, 0.147862f}, {0.320426f, -0.122418f, 0.939330f}, {0.361955f, 0.216559f} },
    { {0.044999f, -0.023924f, 0.133337f}, {0.943568f, 0.301420f, 0.137205f}, {0.395410f, 0.227781f} },
    { {0.030474f, -0.023924f, 0.147862f}, {0.283630f, 0.283944f, 0.915931f}, {0.395410f, 0.216559f} },
    { {0.030383f, -0.008462f, 0.006147f}, {0.464591f, 0.877852f, -0.116327f}, {0.405122f, 0.326044f} },
    { {0.030474f, -0.009398f, 0.133337f}, {0.247698f, 0.965902f, 0.075357f}, {0.404534f, 0.227781f} },
    { {0.004007f, -0.008886f, 0.124768f}, {-0.015326f, -0.877965f, 0.478479f}, {0.364658f, 0.234401f} },
    { {0.004007f, -0.008886f, 0.014704f}, {-0.016801f, -0.962513f, -0.270715f}, {0.364658f, 0.319433f} },
    { {0.040394f, -0.020010f, 0.117523f}, {0.774058f, -0.608349f, 0.175343f}, {0.417860f, 0.239999f} },
    { {-0.017454f, 0.022535f, 0.117523f}, {-0.710417f, 0.662178f, 0.238384f}, {0.295564f, 0.239999f} },
    { {-0.032747f, -0.018734f, 0.021531f}, {-0.980614f, -0.065870f, -0.184544f}, {0.321487f, 0.314159f} },
    { {-0.032747f, -0.018734f, 0.117523f}, {-0.341137f, -0.916514f, 0.208874f}, {0.321487f, 0.239999f} },
    { {0.000181f, -0.076044f, -0.008387f}, {0.129948f, -0.077255f, -0.988506f}, {0.363522f, 0.274548f} },
    { {-0.029520f, -0.076154f, -0.012283f}, {-0.320756f, -0.090187f, -0.942858f}, {0.404519f, 0.274424f} },
    { {0.000181f, -0.022785f, -0.008387f}, {0.131796f, 0.089999f, -0.987183f}, {0.363516f, 0.241021f} },
    { {-0.024991f, -0.168729f, 0.002556f}, {0.054071f, -0.337005f, -0.939949f}, {0.388032f, 0.331459f} },
    { {0.000000f, -0.130415f, 0.000001f}, {0.000000f, -0.117250f, -0.993102f}, {0.361357f, 0.307992f} },
    { {-0.029319f, -0.021517f, -0.012175f}, {-0.239115f, 0.285324f, -0.928124f}, {0.404226f, 0.240623f} },
    { {-0.030599f, -0.005909f, 0.133987f}, {0.018911f, 0.999786f, 0.008341f}, {0.399951f, 0.227788f} },
    { {0.002061f, -0.005436f, 0.003232f}, {0.018911f, 0.999786f, 0.008341f}, {0.394913f, 0.326044f} },
    { {-0.030507f, -0.004838f, 0.005467f}, {0.018911f, 0.999786f, 0.008341f}, {0.400083f, 0.326051f} },
    { {0.004007f, -0.008886f, 0.124768f}, {-0.015326f, -0.877965f, 0.478479f}, {0.364658f, 0.232809f} },
    { {0.040394f, -0.020010f, 0.117523f}, {0.774058f, -0.608349f, 0.175343f}, {0.401394f, 0.237561f} },
    { {0.026550f, 0.021767f, 0.117523f}, {0.389644f, 0.889579f, 0.238384f}, {0.397619f, 0.213846f} },
    { {0.040394f, -0.020010f, 0.117523f}, {0.774058f, -0.608349f, 0.175343f}, {0.397868f, 0.239999f} },
    { {0.026550f, 0.021767f, 0.021531f}, {0.733362f, 0.636451f, -0.238977f}, {0.424111f, 0.314159f} },
    { {0.026550f, 0.021767f, 0.117523f}, {0.389644f, 0.889579f, 0.238384f}, {0.424111f, 0.239999f} },
    { {-0.017454f, 0.022535f, 0.021531f}, {-0.357770f, 0.902713f, -0.238978f}, {0.295564f, 0.314159f} },
    { {0.040394f, -0.020010f, 0.021531f}, {0.792979f, -0.508455f, -0.335645f}, {0.397868f, 0.314159f} },
    { {-0.018244f, -0.168349f, 0.133103f}, {0.099037f, -0.292615f, 0.951088f}, {0.332125f, 0.331459f} },
    { {0.027481f, -0.182874f, 0.124917f}, {0.371149f, -0.721082f, 0.585055f}, {0.398980f, 0.340445f} },
    { {-0.003536f, -0.130212f, 0.139432f}, {0.075916f, -0.198080f, 0.977242f}, {0.358799f, 0.307992f} },
    { {-0.029463f, -0.077287f, 0.151719f}, {-0.425062f, -0.090586f, 0.900620f}, {0.315720f, 0.275125f} },
    { {-0.024274f, -0.168886f, 0.137056f}, {-0.234455f, -0.573196f, 0.785161f}, {0.323307f, 0.331792f} },
    { {-0.005199f, -0.130774f, 0.143514f}, {0.148016f, -0.149507f, 0.977619f}, {0.351198f, 0.308214f} },
    { {-0.029463f, -0.077287f, 0.151719f}, {-0.425062f, -0.090586f, 0.900620f}, {0.358268f, 0.213580f} },
    { {-0.030599f, -0.005909f, 0.133987f}, {-0.621758f, 0.758668f, 0.194524f}, {0.314060f, 0.230967f} },
    { {0.030474f, -0.023924f, 0.147862f}, {0.283630f, 0.283944f, 0.915931f}, {0.403355f, 0.242112f} },
    { {0.003807f, -0.009398f, 0.133337f}, {0.084773f, 0.704562f, 0.704561f}, {0.356794f, 0.231129f} },
    { {-0.029520f, -0.076154f, -0.012283f}, {-0.320756f, -0.090187f, -0.942858f}, {0.357556f, 0.340282f} },
    { {-0.024274f, -0.168886f, 0.137056f}, {-0.662712f, -0.745716f, 0.068707f}, {0.415469f, 0.234286f} },
    { {-0.042049f, -0.168648f, 0.014255f}, {-0.512986f, -0.858395f, 0.001732f}, {0.415469f, 0.319571f} },
    { {-0.018244f, -0.182874f, 0.014526f}, {-0.342506f, -0.937372f, -0.063430f}, {0.424593f, 0.319571f} },
    { {-0.017454f, 0.022535f, 0.021531f}, {-0.357770f, 0.902713f, -0.238978f}, {0.386877f, 0.213371f} },
    { {0.004007f, -0.008886f, 0.014704f}, {-0.016801f, -0.962513f, -0.270715f}, {0.355499f, 0.232809f} },
    { {-0.032747f, -0.018734f, 0.021531f}, {-0.980614f, -0.065870f, -0.184544f}, {0.392605f, 0.237016f} },
    { {-0.032747f, -0.018734f, 0.117523f}, {-0.341137f, -0.916514f, 0.208874f}, {0.310920f, 0.239999f} },
    { {-0.032747f, -0.018734f, 0.021531f}, {-0.980614f, -0.065870f, -0.184544f}, {0.310920f, 0.314159f} },
    { {-0.017454f, 0.022535f, 0.117523f}, {-0.710417f, 0.662178f, 0.238384f}, {0.333280f, 0.213371f} },
    { {0.026550f, 0.021767f, 0.117523f}, {0.389644f, 0.889579f, 0.238384f}, {0.322537f, 0.239999f} },
    { {-0.017454f, 0.022535f, 0.021531f}, {-0.357770f, 0.902713f, -0.238978f}, {0.386877f, 0.314159f} },
    { {-0.017454f, 0.022535f, 0.117523f}, {-0.710417f, 0.662178f, 0.238384f}, {0.386877f, 0.239999f} },
    { {0.026550f, 0.021767f, 0.021531f}, {0.733362f, 0.636451f, -0.238977f}, {0.322537f, 0.213846f} },
    { {0.026550f, 0.021767f, 0.021531f}, {0.733362f, 0.636451f, -0.238977f}, {0.322537f, 0.314159f} },
    { {0.002061f, -0.005436f, 0.003232f}, {0.038537f, 0.651064f, -0.758044f}, {0.363514f, 0.230549f} },
    { {0.030383f, -0.008462f, 0.006147f}, {0.464591f, 0.877852f, -0.116327f}, {0.316933f, 0.232547f} },
    { {0.002061f, -0.005436f, 0.003232f}, {0.077622f, 0.996788f, -0.019722f}, {0.355923f, 0.232547f} },
    { {0.044909f, -0.022987f, 0.006147f}, {0.990446f, 0.124468f, -0.059372f}, {0.395998f, 0.326044f} },
    { {0.030383f, -0.076246f, -0.008378f}, {0.384200f, -0.117068f, -0.915798f}, {0.362543f, 0.337265f} },
    { {-0.042049f, -0.168648f, 0.014255f}, {-0.874007f, -0.470563f, -0.121170f}, {0.297319f, 0.319780f} },
    { {-0.024274f, -0.168886f, 0.137056f}, {-0.234455f, -0.573196f, 0.785161f}, {0.323307f, 0.224908f} },
    { {-0.041920f, -0.168901f, 0.125767f}, {-0.975199f, -0.140323f, 0.171162f}, {0.297507f, 0.233630f} },
    { {-0.024274f, -0.168886f, 0.137056f}, {-0.234455f, -0.573196f, 0.785161f}, {0.415807f, 0.224908f} },
    { {-0.030599f, -0.005909f, 0.133987f}, {-0.621758f, 0.758668f, 0.194524f}, {0.313431f, 0.227279f} },
    { {-0.029423f, -0.023163f, 0.151726f}, {-0.150623f, 0.162858f, 0.975084f}, {0.324269f, 0.213574f} },
    { {0.003807f, -0.009398f, 0.133337f}, {0.051932f, 0.992013f, 0.114947f}, {0.364365f, 0.233126f} },
    { {0.040394f, -0.020010f, 0.021531f}, {0.792979f, -0.508455f, -0.335645f}, {0.318762f, 0.237561f} },
    { {0.040394f, -0.020010f, 0.021531f}, {0.792979f, -0.508455f, -0.335645f}, {0.417860f, 0.314159f} },
    { {0.000000f, -0.130415f, 0.000001f}, {0.130137f, -0.151037f, -0.979925f}, {0.368960f, 0.308212f} },
    { {-0.024991f, -0.168729f, 0.002556f}, {-0.328801f, -0.152419f, -0.932018f}, {0.397898f, 0.331695f} },
    { {-0.024991f, -0.168729f, 0.002556f}, {-0.328801f, -0.152419f, -0.932018f}, {0.415708f, 0.328819f} },
    { {-0.029319f, -0.021517f, -0.012175f}, {-0.239115f, 0.285324f, -0.928124f}, {0.323235f, 0.340199f} },
    { {-0.030507f, -0.004838f, 0.005467f}, {-0.629426f, 0.748491f, -0.208769f}, {0.312758f, 0.326570f} },
    { {-0.018244f, -0.182874f, 0.124917f}, {-0.131090f, -0.989139f, 0.066483f}, {0.332125f, 0.340445f} },
    { {-0.018244f, -0.182874f, 0.124917f}, {-0.131090f, -0.989139f, 0.066483f}, {0.424593f, 0.234286f} },
    { {0.030383f, -0.022987f, -0.008378f}, {0.307522f, 0.113372f, -0.944763f}, {0.395998f, 0.337265f} },
    { {0.022863f, -0.130415f, 0.000001f}, {0.224694f, -0.180775f, -0.957514f}, {0.328516f, 0.330792f} },
    { {0.027481f, -0.182874f, 0.124917f}, {0.371149f, -0.721082f, 0.585055f}, {0.295564f, 0.234286f} },
    { {0.027481f, -0.182874f, 0.014526f}, {0.154776f, -0.943301f, -0.293646f}, {0.295564f, 0.319571f} },
    { {0.037649f, -0.169680f, 0.014526f}, {0.950033f, -0.279916f, -0.138146f}, {0.303851f, 0.319571f} },
    { {-0.032747f, -0.018734f, 0.117523f}, {-0.341137f, -0.916514f, 0.208874f}, {0.327551f, 0.237016f} },
    { {0.027481f, -0.182874f, 0.124917f}, {0.371149f, -0.721082f, 0.585055f}, {0.304407f, 0.227962f} },
    { {0.037649f, -0.169680f, 0.124917f}, {0.993740f, -0.104492f, 0.039521f}, {0.303851f, 0.234286f} },
    { {-0.030507f, -0.004838f, 0.005467f}, {-0.629426f, 0.748491f, -0.208769f}, {0.405963f, 0.230305f} },
    { {-0.018244f, -0.182874f, 0.014526f}, {-0.342506f, -0.937372f, -0.063430f}, {0.388032f, 0.340445f} },
    { {0.027481f, -0.182874f, 0.014526f}, {0.154776f, -0.943301f, -0.293646f}, {0.321176f, 0.340445f} },
    { {-0.024991f, -0.168729f, 0.002556f}, {0.054071f, -0.337005f, -0.939949f}, {0.415469f, 0.325896f} },
    { {0.030474f, -0.009398f, 0.133337f}, {0.247698f, 0.965902f, 0.075357f}, {0.403355f, 0.233126f} },
    { {-0.018244f, -0.168349f, 0.133103f}, {0.099037f, -0.292615f, 0.951088f}, {0.415469f, 0.227962f} },
    { {-0.005199f, -0.130774f, 0.143514f}, {0.528470f, -0.392088f, 0.752985f}, {0.328164f, 0.219911f} },
    { {-0.024274f, -0.168886f, 0.137056f}, {0.528470f, -0.392088f, 0.752985f}, {0.304223f, 0.224900f} },
    { {-0.018244f, -0.168349f, 0.133103f}, {0.528470f, -0.392088f, 0.752985f}, {0.304688f, 0.227962f} },
    { {-0.042049f, -0.168648f, 0.014255f}, {-0.874007f, -0.470563f, -0.121170f}, {0.415657f, 0.319780f} },
    { {0.037649f, -0.169680f, 0.014526f}, {0.950033f, -0.279916f, -0.138146f}, {0.306310f, 0.332283f} },
    { {-0.018244f, -0.168349f, 0.133103f}, {0.871550f, -0.386249f, 0.302014f}, {0.304815f, 0.227969f} },
    { {-0.003536f, -0.130212f, 0.139432f}, {0.910273f, -0.239023f, 0.338040f}, {0.328643f, 0.223072f} },
    { {-0.005199f, -0.130774f, 0.143514f}, {0.148016f, -0.149507f, 0.977619f}, {0.328291f, 0.219919f} },
    { {0.000271f, -0.076980f, 0.147853f}, {0.164733f, -0.037804f, 0.985613f}, {0.362082f, 0.216567f} },
    { {0.037649f, -0.169680f, 0.124917f}, {0.993740f, -0.104492f, 0.039521f}, {0.413847f, 0.332283f} },
    { {0.037388f, -0.130415f, 0.124917f}, {0.987603f, -0.115429f, 0.106376f}, {0.413465f, 0.307992f} },
};

WORD g_tind27[] = 
{
    0, 1, 2,    3, 4, 5,    3, 6, 4,    0, 2, 7,    8, 9, 10,
    11, 12, 13,    14, 15, 16,    17, 18, 19,    20, 21, 22,    17, 19, 23,
    24, 16, 25,    26, 27, 28,    29, 30, 31,    30, 32, 33,    34, 35, 36,
    37, 38, 39,    40, 41, 42,    15, 43, 44,    42, 41, 45,    46, 47, 48,
    49, 50, 51,    52, 53, 54,    37, 55, 38,    52, 56, 53,    57, 58, 59,
    60, 61, 62,    63, 3, 5,    13, 64, 11,    22, 21, 65,    66, 64, 13,
    6, 67, 4,    68, 69, 70,    71, 72, 73,    74, 75, 35,    49, 51, 76,
    77, 78, 79,    80, 72, 71,    77, 81, 78,    42, 45, 82,    83, 25, 84,
    30, 85, 32,    1, 86, 2,    29, 0, 7,    59, 58, 21,    87, 88, 89,
    63, 5, 90,    91, 6, 3,    92, 91, 3,    65, 93, 22,    26, 28, 8,
    94, 72, 80,    35, 95, 36,    96, 97, 41,    4, 67, 98,    6, 99, 67,
    91, 100, 6,    57, 101, 58,    68, 70, 102,    96, 41, 40,    15, 44, 16,
    83, 24, 25,    85, 103, 32,    1, 104, 86,    105, 106, 107,    11, 60, 12,
    92, 3, 63,    59, 21, 20,    60, 62, 12,    74, 35, 34,    49, 76, 108,
    109, 0, 29,    105, 107, 110,    82, 45, 111,    100, 99, 6,    112, 43, 113,
    69, 114, 70,    65, 115, 93,    31, 30, 33,    7, 85, 30,    29, 7, 30,
    116, 68, 102,    117, 118, 119,    24, 14, 16,    2, 86, 103,    4, 98, 120,
    5, 4, 120,    15, 113, 43,    121, 113, 15,    2, 103, 85,    7, 2, 85,
    122, 123, 124,    125, 124, 123,    107, 104, 1,    110, 107, 1,    110, 1, 0,
    58, 126, 127,
};

D3DMATRIX g_tmat28 = 
{
    -0.425655f, -0.007501f, 0.904855f, 0.000000f, 
    -0.562299f, -0.781272f, -0.270989f, 0.000000f, 
    0.708970f, -0.624146f, 0.328334f, 0.000000f, 
    -0.799053f, -2.334533f, 1.817404f, 1.000000f, 
};

// Mesh #28 Tris:74 Verts:95
MODELVERT g_tmesh28[] = 
{
    { {0.028660f, -0.022378f, 0.099933f}, {0.959203f, 0.254395f, 0.123342f}, {0.399661f, 0.228668f} },
    { {0.038275f, -0.106688f, 0.021795f}, {0.991157f, 0.034084f, -0.128239f}, {0.330727f, 0.313958f} },
    { {0.028660f, -0.022377f, 0.011620f}, {0.961998f, 0.249093f, -0.111860f}, {0.399661f, 0.325064f} },
    { {-0.038098f, -0.022271f, 0.100091f}, {-0.992864f, -0.056485f, 0.105030f}, {0.320408f, 0.228495f} },
    { {-0.038015f, -0.021746f, 0.011203f}, {-0.957103f, 0.233256f, -0.171885f}, {0.319979f, 0.325520f} },
    { {-0.031893f, -0.065474f, 0.010799f}, {-0.968061f, -0.170779f, -0.183555f}, {0.355732f, 0.325960f} },
    { {0.038374f, -0.107393f, 0.094738f}, {0.977200f, 0.010134f, 0.212081f}, {0.330150f, 0.234339f} },
    { {-0.026074f, -0.107156f, 0.020049f}, {-0.976585f, -0.205814f, -0.062628f}, {0.389813f, 0.315864f} },
    { {-0.025912f, -0.107848f, 0.096052f}, {-0.944168f, -0.244382f, 0.220964f}, {0.390378f, 0.232904f} },
    { {-0.017843f, -0.107867f, 0.095511f}, {-0.962227f, -0.242438f, 0.123870f}, {0.390394f, 0.233495f} },
    { {-0.026074f, -0.107156f, 0.020049f}, {-0.906475f, -0.378517f, -0.187157f}, {0.389921f, 0.315671f} },
    { {-0.014326f, -0.136946f, 0.026712f}, {-0.926402f, -0.374851f, -0.035590f}, {0.414170f, 0.308592f} },
    { {0.024591f, -0.109598f, 0.010116f}, {0.279673f, -0.185086f, -0.942086f}, {0.319766f, 0.308158f} },
    { {-0.002368f, -0.139352f, 0.015699f}, {-0.070784f, -0.478823f, -0.875053f}, {0.367105f, 0.332117f} },
    { {-0.008958f, -0.108730f, 0.009205f}, {-0.096943f, -0.254954f, -0.962081f}, {0.373424f, 0.308235f} },
    { {-0.014171f, -0.138048f, 0.092316f}, {-0.890795f, -0.422420f, 0.167466f}, {0.415071f, 0.236982f} },
    { {-0.018684f, -0.066351f, 0.113671f}, {0.089613f, -0.077195f, 0.992981f}, {0.336170f, 0.273605f} },
    { {0.024513f, -0.109038f, 0.106454f}, {0.321326f, -0.065073f, 0.944730f}, {0.400252f, 0.307707f} },
    { {0.017040f, -0.022378f, 0.111553f}, {0.325711f, 0.012422f, 0.945388f}, {0.387131f, 0.237925f} },
    { {0.011361f, -0.007672f, 0.100086f}, {-0.014825f, 0.996776f, 0.078854f}, {0.342998f, 0.228501f} },
    { {-0.024360f, -0.008168f, 0.011434f}, {-0.177256f, 0.981035f, -0.078431f}, {0.405723f, 0.325268f} },
    { {-0.024819f, -0.008309f, 0.100285f}, {-0.360264f, 0.916252f, 0.175189f}, {0.406529f, 0.228284f} },
    { {-0.024823f, -0.021972f, 0.113890f}, {-0.199032f, 0.200200f, 0.959326f}, {0.313620f, 0.237598f} },
    { {-0.018684f, -0.066351f, 0.113671f}, {-0.462851f, -0.119250f, 0.878378f}, {0.324400f, 0.273334f} },
    { {0.017040f, -0.022378f, 0.111553f}, {0.043710f, 0.316802f, 0.947484f}, {0.377162f, 0.236843f} },
    { {0.016928f, 0.007972f, 0.092014f}, {0.374450f, 0.913549f, 0.158793f}, {0.333222f, 0.237312f} },
    { {-0.015914f, 0.008102f, 0.015460f}, {-0.341144f, 0.853439f, -0.394033f}, {0.390892f, 0.320873f} },
    { {-0.015916f, 0.008115f, 0.092014f}, {-0.687145f, 0.610533f, 0.393803f}, {0.390895f, 0.237312f} },
    { {-0.026924f, -0.022829f, 0.092014f}, {-0.298041f, -0.931215f, 0.209784f}, {0.309931f, 0.237312f} },
    { {0.027668f, -0.023080f, 0.015460f}, {0.280441f, -0.903306f, -0.324641f}, {0.405793f, 0.320873f} },
    { {0.027666f, -0.023067f, 0.092014f}, {0.787010f, -0.421428f, 0.450570f}, {0.405790f, 0.237312f} },
    { {0.027666f, -0.023067f, 0.092014f}, {0.787010f, -0.421428f, 0.450570f}, {0.399098f, 0.237312f} },
    { {0.027668f, -0.023080f, 0.015460f}, {0.280441f, -0.903306f, -0.324641f}, {0.399087f, 0.320873f} },
    { {0.016930f, 0.007959f, 0.015460f}, {0.743733f, 0.649286f, -0.159024f}, {0.424465f, 0.320873f} },
    { {-0.015916f, 0.008115f, 0.092014f}, {-0.687145f, 0.610533f, 0.393803f}, {0.295564f, 0.237312f} },
    { {-0.015914f, 0.008102f, 0.015460f}, {-0.341144f, 0.853439f, -0.394033f}, {0.295574f, 0.320873f} },
    { {-0.026922f, -0.022842f, 0.015460f}, {-0.844733f, -0.442898f, -0.300444f}, {0.320875f, 0.320873f} },
    { {0.011406f, -0.007714f, 0.011121f}, {-0.001679f, 0.967435f, -0.253115f}, {0.342918f, 0.325609f} },
    { {0.017040f, -0.022377f, 0.000000f}, {0.059875f, 0.188282f, -0.980288f}, {0.342968f, 0.237051f} },
    { {-0.018469f, -0.067712f, -0.002227f}, {-0.409763f, -0.106529f, -0.905950f}, {0.395379f, 0.274430f} },
    { {-0.024480f, -0.021596f, -0.002386f}, {-0.166658f, 0.269949f, -0.948342f}, {0.405934f, 0.237296f} },
    { {-0.002561f, -0.149597f, 0.090944f}, {0.119101f, -0.991420f, 0.053873f}, {0.295564f, 0.238739f} },
    { {-0.002747f, -0.148271f, 0.029496f}, {-0.165145f, -0.979830f, -0.112521f}, {0.296680f, 0.305025f} },
    { {0.033380f, -0.136797f, 0.028121f}, {0.560508f, -0.792601f, -0.240029f}, {0.306109f, 0.307053f} },
    { {-0.002368f, -0.139352f, 0.015699f}, {-0.070784f, -0.478823f, -0.875053f}, {0.303181f, 0.319853f} },
    { {0.024591f, -0.109598f, 0.010116f}, {0.279673f, -0.185086f, -0.942086f}, {0.328348f, 0.326706f} },
    { {0.033550f, -0.138012f, 0.091622f}, {0.832410f, -0.543602f, 0.107662f}, {0.305115f, 0.237740f} },
    { {0.024513f, -0.109038f, 0.106454f}, {0.321326f, -0.065073f, 0.944730f}, {0.328805f, 0.221551f} },
    { {-0.015914f, 0.008102f, 0.015460f}, {-0.341144f, 0.853439f, -0.394033f}, {0.390892f, 0.213381f} },
    { {0.027668f, -0.023080f, 0.015460f}, {0.280441f, -0.903306f, -0.324641f}, {0.329179f, 0.236510f} },
    { {-0.026922f, -0.022842f, 0.015460f}, {-0.844733f, -0.442898f, -0.300444f}, {0.395370f, 0.236378f} },
    { {-0.026922f, -0.022842f, 0.015460f}, {-0.844733f, -0.442898f, -0.300444f}, {0.309934f, 0.320873f} },
    { {0.011406f, -0.007714f, 0.011121f}, {0.647783f, 0.760784f, -0.039808f}, {0.409162f, 0.325064f} },
    { {0.011406f, -0.007714f, 0.011121f}, {-0.001679f, 0.967435f, -0.253115f}, {0.342918f, 0.226117f} },
    { {0.027666f, -0.023067f, 0.092014f}, {0.787010f, -0.421428f, 0.450570f}, {0.390975f, 0.236500f} },
    { {0.016928f, 0.007972f, 0.092014f}, {0.374450f, 0.913549f, 0.158793f}, {0.386934f, 0.213486f} },
    { {-0.015916f, 0.008115f, 0.092014f}, {-0.687145f, 0.610533f, 0.393803f}, {0.329261f, 0.213371f} },
    { {0.016928f, 0.007972f, 0.092014f}, {0.374450f, 0.913549f, 0.158793f}, {0.424476f, 0.237312f} },
    { {-0.006055f, -0.109061f, 0.106898f}, {-0.185380f, -0.143988f, 0.972060f}, {0.391370f, 0.221065f} },
    { {-0.002383f, -0.139242f, 0.103703f}, {-0.372815f, -0.367479f, 0.852037f}, {0.416047f, 0.224553f} },
    { {0.013316f, -0.140325f, 0.103361f}, {0.286278f, -0.348829f, 0.892392f}, {0.303224f, 0.224926f} },
    { {-0.018469f, -0.067712f, -0.002227f}, {0.138630f, -0.146143f, -0.979502f}, {0.383649f, 0.274707f} },
    { {-0.026924f, -0.022829f, 0.092014f}, {-0.298041f, -0.931215f, 0.209784f}, {0.324783f, 0.236367f} },
    { {-0.026924f, -0.022829f, 0.092014f}, {-0.298041f, -0.931215f, 0.209784f}, {0.320864f, 0.237312f} },
    { {-0.018684f, -0.066351f, 0.113671f}, {-0.462851f, -0.119250f, 0.878378f}, {0.356449f, 0.213673f} },
    { {-0.006055f, -0.109061f, 0.106898f}, {-0.185380f, -0.143988f, 0.972060f}, {0.346577f, 0.307726f} },
    { {0.016930f, 0.007959f, 0.015460f}, {0.743733f, 0.649286f, -0.159024f}, {0.333219f, 0.213497f} },
    { {0.016930f, 0.007959f, 0.015460f}, {0.743733f, 0.649286f, -0.159024f}, {0.333219f, 0.320873f} },
    { {0.011361f, -0.007672f, 0.100086f}, {0.646251f, 0.759467f, 0.074634f}, {0.409162f, 0.228668f} },
    { {0.011361f, -0.007672f, 0.100086f}, {-0.014825f, 0.996776f, 0.078854f}, {0.377158f, 0.226083f} },
    { {-0.024819f, -0.008309f, 0.100285f}, {-0.360264f, 0.916252f, 0.175189f}, {0.313627f, 0.226596f} },
    { {0.017040f, -0.022377f, 0.000000f}, {0.440618f, -0.031597f, -0.897138f}, {0.333026f, 0.237925f} },
    { {0.017040f, -0.022377f, 0.000000f}, {0.440618f, -0.031597f, -0.897138f}, {0.399661f, 0.337748f} },
    { {-0.024819f, -0.008309f, 0.100285f}, {-0.360264f, 0.916252f, 0.175189f}, {0.308992f, 0.228284f} },
    { {-0.024823f, -0.021972f, 0.113890f}, {-0.199032f, 0.200200f, 0.959326f}, {0.320163f, 0.213434f} },
    { {-0.002368f, -0.139352f, 0.015699f}, {-0.070784f, -0.478823f, -0.875053f}, {0.416136f, 0.320612f} },
    { {-0.006055f, -0.109061f, 0.106898f}, {-0.463665f, -0.362940f, 0.808263f}, {0.391350f, 0.219060f} },
    { {-0.024480f, -0.021596f, -0.002386f}, {-0.166658f, 0.269949f, -0.948342f}, {0.319857f, 0.340352f} },
    { {-0.018469f, -0.067712f, -0.002227f}, {-0.409763f, -0.106529f, -0.905950f}, {0.357562f, 0.340179f} },
    { {-0.024360f, -0.008168f, 0.011434f}, {-0.177256f, 0.981035f, -0.078431f}, {0.308877f, 0.325268f} },
    { {-0.008958f, -0.108730f, 0.009205f}, {-0.096943f, -0.254954f, -0.962081f}, {0.391887f, 0.327691f} },
    { {-0.008958f, -0.108730f, 0.009205f}, {-0.610798f, -0.296801f, -0.734054f}, {0.391957f, 0.329702f} },
    { {0.017040f, -0.022378f, 0.111553f}, {0.325711f, 0.012422f, 0.945388f}, {0.399661f, 0.215984f} },
    { {0.013316f, -0.140325f, 0.103361f}, {0.286278f, -0.348829f, 0.892392f}, {0.380591f, 0.332901f} },
    { {-0.002747f, -0.148271f, 0.029496f}, {-0.165145f, -0.979830f, -0.112521f}, {0.423429f, 0.305552f} },
    { {-0.002561f, -0.149597f, 0.090944f}, {0.119101f, -0.991420f, 0.053873f}, {0.424513f, 0.238480f} },
    { {0.033550f, -0.138012f, 0.091622f}, {0.832410f, -0.543602f, 0.107662f}, {0.416123f, 0.331038f} },
    { {0.038374f, -0.107393f, 0.094738f}, {0.977200f, 0.010134f, 0.212081f}, {0.424593f, 0.306382f} },
    { {-0.024360f, -0.008168f, 0.011434f}, {-0.177256f, 0.981035f, -0.078431f}, {0.405723f, 0.226483f} },
    { {-0.026074f, -0.107156f, 0.020049f}, {-0.976585f, -0.205814f, -0.062628f}, {0.311424f, 0.315864f} },
    { {-0.017843f, -0.107867f, 0.095511f}, {-0.003723f, -0.999771f, -0.021068f}, {0.320624f, 0.233505f} },
    { {-0.025912f, -0.107848f, 0.096052f}, {-0.944168f, -0.244382f, 0.220964f}, {0.311708f, 0.232904f} },
    { {-0.006055f, -0.109061f, 0.106898f}, {-0.463665f, -0.362940f, 0.808263f}, {0.333767f, 0.219060f} },
    { {-0.002383f, -0.139242f, 0.103703f}, {-0.372815f, -0.367479f, 0.852037f}, {0.353024f, 0.332029f} },
    { {-0.002561f, -0.149597f, 0.090944f}, {0.119101f, -0.991420f, 0.053873f}, {0.352712f, 0.340367f} },
};

WORD g_tind28[] = 
{
    0, 1, 2,    3, 4, 5,    6, 1, 0,    3, 7, 8,    9, 10, 11,
    12, 13, 14,    9, 11, 15,    16, 17, 18,    19, 20, 21,    22, 23, 24,
    25, 26, 27,    28, 29, 30,    31, 32, 33,    34, 35, 36,    19, 37, 20,
    38, 39, 40,    41, 42, 43,    43, 44, 45,    41, 43, 46,    47, 6, 0,
    48, 49, 50,    28, 51, 29,    0, 2, 52,    53, 38, 40,    54, 55, 56,
    31, 33, 57,    58, 15, 59,    60, 41, 46,    3, 5, 7,    12, 14, 61,
    54, 56, 62,    34, 36, 63,    64, 3, 8,    16, 65, 17,    66, 49, 48,
    25, 67, 26,    0, 52, 68,    24, 69, 70,    71, 12, 61,    1, 45, 72,
    73, 4, 3,    74, 3, 64,    10, 75, 11,    42, 44, 43,    58, 9, 15,
    64, 8, 76,    4, 77, 78,    73, 79, 4,    10, 80, 75,    5, 81, 7,
    47, 0, 82,    82, 0, 68,    43, 45, 1,    46, 43, 1,    5, 78, 81,
    4, 78, 5,    60, 6, 47,    65, 83, 17,    24, 70, 22,    74, 73, 3,
    2, 72, 52,    1, 72, 2,    15, 84, 85,    59, 15, 85,    11, 75, 84,
    15, 11, 84,    46, 1, 6,    83, 86, 87,    53, 40, 88,    79, 77, 4,
    89, 90, 91,    92, 91, 90,    93, 94, 83,    65, 93, 83,
};

D3DMATRIX g_tmat29 = 
{
    0.988916f, 0.103142f, 0.106808f, 0.000000f, 
    -0.095628f, -0.107850f, 0.989558f, 0.000000f, 
    0.113584f, -0.988803f, -0.096791f, 0.000000f, 
    -1.050370f, -2.207942f, 2.136500f, 1.000000f, 
};

// Mesh #29 Tris:86 Verts:117
MODELVERT g_tmesh29[] = 
{
    { {0.048229f, -0.150766f, 0.161141f}, {0.995966f, -0.065353f, 0.061480f}, {0.334194f, 0.232142f} },
    { {0.048229f, -0.219470f, 0.018737f}, {0.979462f, -0.151365f, -0.133199f}, {0.303841f, 0.321623f} },
    { {0.061754f, -0.013359f, 0.018737f}, {0.998084f, -0.019424f, -0.058738f}, {0.394898f, 0.321623f} },
    { {-0.078141f, -0.155741f, 0.162318f}, {-0.991117f, -0.044735f, 0.125243f}, {0.388161f, 0.231402f} },
    { {-0.071062f, -0.012627f, 0.016944f}, {-0.962098f, 0.209552f, -0.174513f}, {0.324935f, 0.322750f} },
    { {-0.078155f, -0.155520f, 0.017336f}, {-0.986528f, -0.049433f, -0.155946f}, {0.388063f, 0.322504f} },
    { {0.061754f, -0.013359f, 0.161141f}, {0.978362f, 0.100482f, 0.180861f}, {0.394898f, 0.232142f} },
    { {-0.071647f, -0.014228f, 0.161770f}, {-0.959667f, 0.240908f, 0.144924f}, {0.325642f, 0.231747f} },
    { {-0.009035f, -0.150921f, 0.179801f}, {0.170725f, -0.045420f, 0.984271f}, {0.362592f, 0.302624f} },
    { {0.029492f, -0.219470f, 0.179879f}, {0.280784f, -0.068242f, 0.957342f}, {0.393777f, 0.332293f} },
    { {0.006762f, -0.013359f, 0.179879f}, {0.165380f, 0.089067f, 0.982200f}, {0.372065f, 0.242616f} },
    { {-0.029493f, -0.238207f, 0.161141f}, {-0.143003f, -0.987044f, 0.072764f}, {0.337435f, 0.232142f} },
    { {0.029492f, -0.238207f, 0.018737f}, {0.142485f, -0.987408f, -0.068724f}, {0.393777f, 0.321623f} },
    { {0.029492f, -0.238207f, 0.161141f}, {0.325925f, -0.933931f, 0.146787f}, {0.393777f, 0.232142f} },
    { {0.043016f, 0.005378f, 0.161141f}, {0.143209f, 0.986418f, 0.080435f}, {0.313461f, 0.232142f} },
    { {0.043016f, 0.005378f, 0.018737f}, {0.282715f, 0.950257f, -0.130706f}, {0.313461f, 0.321623f} },
    { {-0.041732f, 0.006765f, 0.016387f}, {-0.066977f, 0.991670f, -0.110025f}, {0.382721f, 0.321623f} },
    { {0.043016f, -0.013359f, -0.000000f}, {0.325536f, 0.025365f, -0.945189f}, {0.313461f, 0.242616f} },
    { {-0.009035f, -0.150921f, -0.000078f}, {0.189726f, -0.015944f, -0.981708f}, {0.357565f, 0.302624f} },
    { {0.000883f, -0.013001f, -0.000078f}, {0.182469f, 0.278443f, -0.942960f}, {0.348091f, 0.242616f} },
    { {0.029492f, -0.219470f, -0.000000f}, {0.217649f, -0.151833f, -0.964145f}, {0.326380f, 0.332293f} },
    { {-0.029493f, -0.238207f, 0.018737f}, {-0.290677f, -0.946542f, -0.139873f}, {0.337435f, 0.321623f} },
    { {-0.035839f, 0.010795f, 0.165603f}, {-0.246317f, 0.961730f, 0.120017f}, {0.382721f, 0.232142f} },
    { {-0.045498f, -0.015061f, 0.190267f}, {-0.410852f, 0.107217f, 0.905376f}, {0.322148f, 0.243357f} },
    { {-0.015911f, -0.150506f, 0.190936f}, {0.211573f, -0.066188f, 0.975118f}, {0.350410f, 0.302287f} },
    { {-0.005769f, -0.014353f, 0.190708f}, {0.167212f, 0.107527f, 0.980040f}, {0.360097f, 0.243048f} },
    { {-0.035839f, 0.010795f, 0.165603f}, {-0.246317f, 0.961730f, 0.120017f}, {0.314588f, 0.229338f} },
    { {-0.041732f, 0.006765f, 0.016387f}, {-0.066977f, 0.991670f, -0.110025f}, {0.316368f, 0.323100f} },
    { {-0.005739f, -0.015243f, -0.011212f}, {0.167180f, 0.089859f, -0.981823f}, {0.360032f, 0.243436f} },
    { {-0.048400f, -0.215385f, -0.006919f}, {-0.330143f, -0.099083f, -0.938716f}, {0.404219f, 0.304322f} },
    { {-0.045528f, -0.014118f, -0.010433f}, {-0.389880f, 0.107649f, -0.914552f}, {0.398037f, 0.242946f} },
    { {-0.045498f, -0.015061f, 0.190267f}, {-0.410852f, 0.107217f, 0.905376f}, {0.326011f, 0.213840f} },
    { {-0.053221f, -0.155335f, 0.189803f}, {-0.422483f, -0.081365f, 0.902711f}, {0.387981f, 0.214132f} },
    { {-0.038528f, -0.185273f, 0.179801f}, {-0.040989f, -0.146677f, 0.988335f}, {0.334421f, 0.317570f} },
    { {-0.029493f, -0.219470f, 0.179879f}, {-0.141665f, -0.444002f, 0.884756f}, {0.337436f, 0.332293f} },
    { {0.056529f, -0.009535f, 0.152260f}, {0.976008f, -0.022787f, 0.216539f}, {0.396587f, 0.237722f} },
    { {0.030163f, 0.053857f, 0.026749f}, {0.675225f, 0.682567f, -0.279595f}, {0.424593f, 0.316589f} },
    { {0.030163f, 0.053857f, 0.152260f}, {0.320831f, 0.905176f, 0.278792f}, {0.424593f, 0.237722f} },
    { {-0.038383f, 0.049965f, 0.152260f}, {-0.747916f, 0.602410f, 0.278792f}, {0.297283f, 0.237722f} },
    { {-0.057404f, -0.016005f, 0.026749f}, {-0.966868f, -0.134286f, -0.217104f}, {0.326427f, 0.316589f} },
    { {-0.057404f, -0.016005f, 0.152260f}, {-0.270247f, -0.931382f, 0.243916f}, {0.326427f, 0.237722f} },
    { {0.043016f, 0.005378f, 0.161141f}, {0.143209f, 0.986418f, 0.080435f}, {0.406695f, 0.234464f} },
    { {-0.035839f, 0.010795f, 0.165603f}, {-0.246317f, 0.961730f, 0.120017f}, {0.337436f, 0.234464f} },
    { {0.043016f, -0.013359f, 0.179879f}, {0.321952f, 0.059376f, 0.944892f}, {0.406695f, 0.242616f} },
    { {-0.038383f, 0.049965f, 0.026749f}, {-0.420533f, 0.863121f, -0.279596f}, {0.297283f, 0.316589f} },
    { {0.056529f, -0.009535f, 0.026749f}, {0.370909f, -0.896065f, -0.243916f}, {0.396587f, 0.316589f} },
    { {0.043016f, 0.005378f, 0.018737f}, {0.282715f, 0.950257f, -0.130706f}, {0.313461f, 0.234464f} },
    { {-0.041732f, 0.006765f, 0.016387f}, {-0.066977f, 0.991670f, -0.110025f}, {0.382721f, 0.234464f} },
    { {-0.041732f, 0.006765f, 0.016387f}, {-0.066977f, 0.991670f, -0.110025f}, {0.394411f, 0.233860f} },
    { {-0.001365f, 0.003565f, 0.163563f}, {-0.030680f, -0.915610f, 0.400895f}, {0.364303f, 0.235252f} },
    { {0.056529f, -0.009535f, 0.152260f}, {0.976008f, -0.022787f, 0.216539f}, {0.402488f, 0.239188f} },
    { {0.030163f, 0.053857f, 0.152260f}, {0.320831f, 0.905176f, 0.278792f}, {0.394418f, 0.213371f} },
    { {-0.001365f, 0.003565f, 0.163563f}, {-0.030680f, -0.915610f, 0.400895f}, {0.364303f, 0.230620f} },
    { {0.056529f, -0.009535f, 0.026749f}, {0.370909f, -0.896065f, -0.243916f}, {0.419603f, 0.316589f} },
    { {0.056529f, -0.009535f, 0.152260f}, {0.976008f, -0.022787f, 0.216539f}, {0.419602f, 0.237722f} },
    { {-0.038383f, 0.049965f, 0.026749f}, {-0.420533f, 0.863121f, -0.279596f}, {0.391213f, 0.215064f} },
    { {-0.001365f, 0.003565f, 0.016099f}, {0.133937f, -0.906763f, -0.399802f}, {0.355853f, 0.235252f} },
    { {-0.057404f, -0.016005f, 0.026749f}, {-0.966868f, -0.134286f, -0.217104f}, {0.392814f, 0.241132f} },
    { {-0.057404f, -0.016005f, 0.152260f}, {-0.270247f, -0.931382f, 0.243916f}, {0.310776f, 0.237722f} },
    { {-0.057404f, -0.016005f, 0.026749f}, {-0.966868f, -0.134286f, -0.217104f}, {0.310776f, 0.316589f} },
    { {-0.001365f, 0.003565f, 0.016099f}, {0.133937f, -0.906763f, -0.399802f}, {0.364303f, 0.323281f} },
    { {-0.038383f, 0.049965f, 0.152260f}, {-0.747916f, 0.602410f, 0.278792f}, {0.328944f, 0.215064f} },
    { {0.030163f, 0.053857f, 0.152260f}, {0.320831f, 0.905176f, 0.278792f}, {0.325738f, 0.237722f} },
    { {-0.038383f, 0.049965f, 0.026749f}, {-0.420533f, 0.863121f, -0.279596f}, {0.391213f, 0.316589f} },
    { {-0.038383f, 0.049965f, 0.152260f}, {-0.747916f, 0.602410f, 0.278792f}, {0.391213f, 0.237722f} },
    { {0.030163f, 0.053857f, 0.026749f}, {0.675225f, 0.682567f, -0.279595f}, {0.325738f, 0.213371f} },
    { {0.030163f, 0.053857f, 0.026749f}, {0.675225f, 0.682567f, -0.279595f}, {0.325738f, 0.316589f} },
    { {-0.048400f, -0.215385f, -0.006919f}, {-0.330143f, -0.099083f, -0.938716f}, {0.382721f, 0.332293f} },
    { {-0.015881f, -0.150514f, -0.011294f}, {0.304471f, -0.085248f, -0.948699f}, {0.369719f, 0.302291f} },
    { {-0.048400f, -0.215385f, -0.006919f}, {-0.330143f, -0.099083f, -0.938716f}, {0.400781f, 0.330515f} },
    { {-0.005739f, -0.015243f, -0.011212f}, {0.167180f, 0.089859f, -0.981823f}, {0.363555f, 0.274093f} },
    { {-0.053221f, -0.155335f, 0.189803f}, {-0.422483f, -0.081365f, 0.902711f}, {0.314771f, 0.304388f} },
    { {-0.060975f, -0.217042f, 0.017932f}, {-0.904180f, -0.424850f, -0.044277f}, {0.415242f, 0.322129f} },
    { {-0.060799f, -0.217372f, 0.162875f}, {-0.788050f, -0.585130f, 0.191311f}, {0.415388f, 0.231052f} },
    { {-0.035839f, 0.010795f, 0.165603f}, {-0.246317f, 0.961730f, 0.120017f}, {0.331374f, 0.232107f} },
    { {0.043016f, 0.005378f, 0.018737f}, {0.282715f, 0.950257f, -0.130706f}, {0.403176f, 0.321623f} },
    { {0.043016f, -0.013359f, -0.000000f}, {0.325536f, 0.025365f, -0.945189f}, {0.394898f, 0.333397f} },
    { {-0.045528f, -0.014118f, -0.010433f}, {-0.389880f, 0.107649f, -0.914552f}, {0.325594f, 0.339953f} },
    { {-0.048400f, -0.215385f, -0.006919f}, {-0.330143f, -0.099083f, -0.938716f}, {0.414510f, 0.337745f} },
    { {-0.057404f, -0.016005f, 0.152260f}, {-0.270247f, -0.931382f, 0.243916f}, {0.327342f, 0.241132f} },
    { {0.043016f, 0.005378f, 0.161141f}, {0.143209f, 0.986418f, 0.080435f}, {0.403176f, 0.232142f} },
    { {0.029492f, -0.219470f, 0.179879f}, {0.280784f, -0.068242f, 0.957342f}, {0.303841f, 0.220368f} },
    { {0.043016f, -0.013359f, 0.179879f}, {0.321952f, 0.059376f, 0.944892f}, {0.394898f, 0.220368f} },
    { {-0.060799f, -0.217372f, 0.162875f}, {-0.788050f, -0.585130f, 0.191311f}, {0.416315f, 0.232142f} },
    { {-0.060975f, -0.217042f, 0.017932f}, {-0.904180f, -0.424850f, -0.044277f}, {0.416315f, 0.321623f} },
    { {-0.029493f, -0.238207f, 0.018737f}, {-0.290677f, -0.946542f, -0.139873f}, {0.424593f, 0.321623f} },
    { {0.056529f, -0.009535f, 0.026749f}, {0.370909f, -0.896065f, -0.243916f}, {0.300554f, 0.240952f} },
    { {0.029492f, -0.238207f, 0.161141f}, {0.325925f, -0.933931f, 0.146787f}, {0.295564f, 0.232142f} },
    { {0.029492f, -0.238207f, 0.018737f}, {0.142485f, -0.987408f, -0.068724f}, {0.295564f, 0.321623f} },
    { {0.029492f, -0.219470f, -0.000000f}, {0.217649f, -0.151833f, -0.964145f}, {0.303841f, 0.333397f} },
    { {-0.038528f, -0.185273f, 0.179801f}, {-0.040989f, -0.146677f, 0.988335f}, {0.318915f, 0.317771f} },
    { {-0.038528f, -0.185273f, 0.179801f}, {-0.040989f, -0.146677f, 0.988335f}, {0.401570f, 0.216651f} },
    { {-0.015881f, -0.150514f, -0.011294f}, {0.304471f, -0.085248f, -0.948699f}, {0.334305f, 0.340494f} },
    { {-0.005739f, -0.015243f, -0.011212f}, {0.167180f, 0.089859f, -0.981823f}, {0.394065f, 0.340442f} },
    { {-0.009035f, -0.150921f, -0.000078f}, {0.189726f, -0.015944f, -0.981708f}, {0.334125f, 0.333446f} },
    { {-0.048400f, -0.215385f, -0.006919f}, {-0.330143f, -0.099083f, -0.938716f}, {0.305646f, 0.337745f} },
    { {0.048229f, -0.219470f, 0.161141f}, {0.971543f, -0.208189f, 0.112971f}, {0.303841f, 0.232142f} },
    { {-0.038528f, -0.185273f, 0.179801f}, {-0.040989f, -0.146677f, 0.988335f}, {0.401365f, 0.220368f} },
    { {-0.029493f, -0.219470f, 0.179879f}, {-0.141665f, -0.444002f, 0.884756f}, {0.416315f, 0.220368f} },
    { {-0.029493f, -0.238207f, 0.161141f}, {-0.143003f, -0.987044f, 0.072764f}, {0.424593f, 0.232142f} },
    { {-0.009035f, -0.150921f, 0.179801f}, {0.170725f, -0.045420f, 0.984271f}, {0.334125f, 0.220417f} },
    { {0.006762f, -0.013359f, 0.179879f}, {0.165380f, 0.089067f, 0.982200f}, {0.364527f, 0.220417f} },
    { {-0.015911f, -0.150506f, 0.190936f}, {0.211573f, -0.066188f, 0.975118f}, {0.334309f, 0.213420f} },
    { {-0.038528f, -0.185273f, 0.179801f}, {-0.040989f, -0.146677f, 0.988335f}, {0.318949f, 0.220417f} },
    { {-0.029493f, -0.238207f, 0.018737f}, {-0.290677f, -0.946542f, -0.139873f}, {0.382721f, 0.340445f} },
    { {-0.048400f, -0.215385f, -0.006919f}, {-0.330143f, -0.099083f, -0.938716f}, {0.416315f, 0.333397f} },
    { {0.029492f, -0.238207f, 0.018737f}, {0.142485f, -0.987408f, -0.068724f}, {0.326380f, 0.340445f} },
    { {0.029492f, -0.238207f, 0.161141f}, {0.325925f, -0.933931f, 0.146787f}, {0.393777f, 0.340445f} },
    { {0.000883f, -0.013001f, -0.000078f}, {0.182469f, 0.278443f, -0.942960f}, {0.395056f, 0.333446f} },
    { {-0.041732f, 0.006765f, 0.016387f}, {-0.066977f, 0.991670f, -0.110025f}, {0.394411f, 0.323100f} },
    { {0.000883f, -0.013001f, -0.000078f}, {0.182469f, 0.278443f, -0.942960f}, {0.353706f, 0.333446f} },
    { {-0.005739f, -0.015243f, -0.011212f}, {0.167180f, 0.089859f, -0.981823f}, {0.360032f, 0.340442f} },
    { {-0.005769f, -0.014353f, 0.190708f}, {0.167212f, 0.107527f, 0.980040f}, {0.394459f, 0.213563f} },
    { {-0.035839f, 0.010795f, 0.165603f}, {0.322042f, 0.833418f, 0.449113f}, {0.389661f, 0.231303f} },
    { {-0.005769f, -0.014353f, 0.190708f}, {0.322042f, 0.833418f, 0.449113f}, {0.354445f, 0.213514f} },
    { {0.006762f, -0.013359f, 0.179879f}, {0.322042f, 0.833418f, 0.449113f}, {0.348091f, 0.220368f} },
    { {-0.029493f, -0.238207f, 0.161141f}, {-0.143003f, -0.987044f, 0.072764f}, {0.337435f, 0.340445f} },
};

WORD g_tind29[] = 
{
    0, 1, 2,    3, 4, 5,    0, 2, 6,    7, 4, 3,    8, 9, 10,
    11, 12, 13,    14, 15, 16,    17, 18, 19,    17, 20, 18,    11, 21, 12,
    14, 16, 22,    23, 24, 25,    26, 27, 4,    28, 29, 30,    31, 3, 32,
    33, 34, 9,    35, 36, 37,    38, 39, 40,    41, 42, 10,    10, 9, 43,
    38, 44, 39,    35, 45, 36,    46, 19, 47,    28, 30, 48,    49, 50, 51,
    52, 53, 54,    55, 56, 57,    58, 59, 60,    49, 51, 61,    62, 63, 64,
    65, 56, 55,    62, 66, 63,    20, 67, 18,    68, 69, 70,    23, 71, 24,
    33, 9, 8,    3, 72, 73,    32, 3, 73,    26, 4, 7,    25, 74, 23,
    6, 2, 75,    1, 76, 2,    4, 77, 78,    27, 77, 4,    49, 61, 79,
    58, 60, 52,    6, 75, 80,    81, 6, 82,    83, 84, 85,    4, 78, 5,
    86, 56, 65,    52, 60, 53,    87, 88, 1,    1, 89, 76,    71, 90, 24,
    32, 73, 91,    92, 93, 94,    95, 92, 94,    87, 1, 96,    81, 0, 6,
    97, 83, 98,    83, 85, 99,    31, 7, 3,    31, 26, 7,    100, 101, 102,
    103, 100, 102,    104, 67, 20,    84, 105, 85,    88, 89, 1,    104, 20, 106,
    43, 41, 10,    82, 6, 80,    81, 87, 96,    34, 107, 9,    46, 17, 19,
    2, 76, 75,    5, 78, 72,    3, 5, 72,    108, 94, 93,    109, 110, 111,
    112, 102, 101,    113, 114, 115,    34, 116, 107,    98, 83, 99,    96, 1, 0,
    81, 96, 0,
};

D3DMATRIX g_tmat30 = 
{
    0.562407f, -0.016320f, 0.826700f, 0.000000f, 
    -0.819022f, -0.148336f, 0.554256f, 0.000000f, 
    0.113583f, -0.988803f, -0.096791f, 0.000000f, 
    -1.027629f, -2.177059f, 1.896122f, 1.000000f, 
};

// Mesh #30 Tris:96 Verts:130
MODELVERT g_tmesh30[] = 
{
    { {0.037649f, -0.169680f, 0.124916f}, {0.987881f, -0.132022f, 0.081620f}, {0.303851f, 0.234286f} },
    { {0.037388f, -0.130415f, 0.014525f}, {0.975095f, -0.101427f, -0.197236f}, {0.328516f, 0.319571f} },
    { {0.044909f, -0.076246f, 0.006147f}, {0.992219f, -0.074699f, -0.099609f}, {0.362543f, 0.326044f} },
    { {-0.047218f, -0.023082f, 0.133577f}, {-0.993320f, 0.042028f, 0.107463f}, {0.324218f, 0.227595f} },
    { {-0.047235f, -0.130273f, 0.014097f}, {-0.994373f, -0.041688f, -0.097389f}, {0.391552f, 0.319902f} },
    { {-0.042461f, -0.168869f, 0.125764f}, {-0.956423f, -0.238993f, 0.167741f}, {0.415796f, 0.233631f} },
    { {0.044999f, -0.077182f, 0.133336f}, {0.996216f, -0.042230f, 0.075969f}, {0.361955f, 0.227781f} },
    { {-0.047117f, -0.021413f, 0.005585f}, {-0.972365f, 0.189884f, -0.135831f}, {0.323170f, 0.326478f} },
    { {0.030473f, -0.009398f, 0.133336f}, {0.181494f, 0.982128f, 0.049840f}, {0.316801f, 0.227781f} },
    { {0.030383f, -0.008462f, 0.006147f}, {0.433200f, 0.895298f, -0.103825f}, {0.316933f, 0.326044f} },
    { {0.003717f, -0.008462f, 0.006147f}, {0.056565f, 0.997038f, -0.052105f}, {0.355923f, 0.326044f} },
    { {0.030383f, -0.022987f, -0.008378f}, {0.318671f, 0.108464f, -0.941639f}, {0.316933f, 0.241533f} },
    { {-0.000361f, -0.076012f, -0.008389f}, {-0.000132f, -0.075123f, -0.997174f}, {0.355923f, 0.274481f} },
    { {0.003717f, -0.022987f, -0.008378f}, {-0.000000f, 0.333774f, -0.942653f}, {0.355923f, 0.241533f} },
    { {-0.029964f, -0.023131f, 0.151724f}, {-0.149499f, 0.163104f, 0.975217f}, {0.314988f, 0.241622f} },
    { {-0.000270f, -0.076948f, 0.147850f}, {0.163806f, -0.038015f, 0.985760f}, {0.355973f, 0.275000f} },
    { {0.003807f, -0.023923f, 0.147861f}, {0.115883f, 0.238447f, 0.964217f}, {0.355979f, 0.241101f} },
    { {0.003807f, -0.009398f, 0.133336f}, {0.051860f, 0.992907f, 0.106986f}, {0.355791f, 0.227781f} },
    { {-0.031049f, -0.004807f, 0.005464f}, {0.074345f, 0.997203f, 0.007692f}, {0.394913f, 0.326044f} },
    { {-0.031140f, -0.005878f, 0.133985f}, {0.100380f, 0.994914f, 0.008358f}, {0.394781f, 0.227781f} },
    { {0.030383f, -0.076246f, -0.008378f}, {0.380814f, -0.116779f, -0.917248f}, {0.316933f, 0.274481f} },
    { {0.022862f, -0.130415f, -0.000000f}, {0.204656f, -0.192047f, -0.959809f}, {0.327930f, 0.307992f} },
    { {-0.018244f, -0.182873f, 0.124916f}, {-0.130670f, -0.989173f, 0.066798f}, {0.332125f, 0.234286f} },
    { {-0.018244f, -0.182873f, 0.014525f}, {-0.457851f, -0.884016f, -0.094277f}, {0.332125f, 0.319571f} },
    { {0.027481f, -0.182873f, 0.014525f}, {0.141942f, -0.946310f, -0.290431f}, {0.398980f, 0.319571f} },
    { {-0.000270f, -0.076948f, 0.147850f}, {-0.000953f, -0.079029f, 0.996872f}, {0.364365f, 0.275060f} },
    { {0.030474f, -0.077182f, 0.147861f}, {0.276895f, -0.117290f, 0.953715f}, {0.403355f, 0.275060f} },
    { {0.003807f, -0.023923f, 0.147861f}, {-0.000167f, 0.111849f, 0.993725f}, {0.364365f, 0.242112f} },
    { {0.027481f, -0.182873f, 0.124916f}, {0.309703f, -0.747071f, 0.588192f}, {0.398980f, 0.234286f} },
    { {0.030474f, -0.077182f, 0.147861f}, {0.276895f, -0.117290f, 0.953715f}, {0.361955f, 0.216560f} },
    { {0.044999f, -0.023923f, 0.133336f}, {0.943568f, 0.301420f, 0.137205f}, {0.395410f, 0.227781f} },
    { {0.030473f, -0.023923f, 0.147861f}, {0.283631f, 0.283944f, 0.915931f}, {0.395410f, 0.216560f} },
    { {0.030383f, -0.008462f, 0.006147f}, {0.433200f, 0.895298f, -0.103825f}, {0.405122f, 0.326044f} },
    { {0.030473f, -0.009398f, 0.133336f}, {0.181494f, 0.982128f, 0.049840f}, {0.404534f, 0.227781f} },
    { {-0.000361f, -0.076012f, -0.008389f}, {0.129919f, -0.081563f, -0.988164f}, {0.364314f, 0.274528f} },
    { {-0.030062f, -0.076123f, -0.012285f}, {-0.314498f, -0.090049f, -0.944977f}, {0.405311f, 0.274405f} },
    { {0.003717f, -0.022987f, -0.008378f}, {0.124733f, 0.144530f, -0.981607f}, {0.364308f, 0.241002f} },
    { {-0.022321f, -0.168115f, 0.006327f}, {-0.356132f, -0.366739f, -0.859461f}, {0.388032f, 0.331459f} },
    { {-0.000000f, -0.130415f, -0.000000f}, {-0.000000f, -0.157783f, -0.987474f}, {0.361357f, 0.307992f} },
    { {-0.029861f, -0.021486f, -0.012178f}, {-0.251093f, 0.230507f, -0.940116f}, {0.405018f, 0.240604f} },
    { {0.040394f, -0.020010f, 0.117522f}, {0.977898f, -0.099048f, 0.184134f}, {0.397868f, 0.239999f} },
    { {0.026550f, 0.021767f, 0.021530f}, {0.733362f, 0.636451f, -0.238977f}, {0.424111f, 0.314159f} },
    { {0.026550f, 0.021767f, 0.117522f}, {0.389644f, 0.889579f, 0.238384f}, {0.424111f, 0.239999f} },
    { {-0.017454f, 0.022535f, 0.117522f}, {-0.710417f, 0.662179f, 0.238384f}, {0.295564f, 0.239999f} },
    { {-0.032747f, -0.018733f, 0.021530f}, {-0.980614f, -0.065869f, -0.184545f}, {0.321487f, 0.314159f} },
    { {-0.032747f, -0.018733f, 0.117522f}, {-0.341136f, -0.916514f, 0.208875f}, {0.321487f, 0.239999f} },
    { {-0.017454f, 0.022535f, 0.021530f}, {-0.357770f, 0.902713f, -0.238978f}, {0.295564f, 0.314159f} },
    { {0.040394f, -0.020010f, 0.021530f}, {0.306270f, -0.928747f, -0.208874f}, {0.397868f, 0.314159f} },
    { {-0.030005f, -0.077256f, 0.151717f}, {-0.425061f, -0.090586f, 0.900620f}, {0.358248f, 0.213581f} },
    { {-0.031140f, -0.005878f, 0.133985f}, {-0.667565f, 0.732309f, 0.134462f}, {0.313269f, 0.230948f} },
    { {-0.018244f, -0.168348f, 0.133103f}, {0.098991f, -0.292456f, 0.951142f}, {0.332125f, 0.331459f} },
    { {0.027481f, -0.182873f, 0.124916f}, {0.309703f, -0.747071f, 0.588192f}, {0.398980f, 0.340445f} },
    { {-0.004077f, -0.130181f, 0.139430f}, {0.074946f, -0.197604f, 0.977413f}, {0.358799f, 0.307992f} },
    { {-0.030005f, -0.077256f, 0.151717f}, {-0.425061f, -0.090586f, 0.900620f}, {0.314928f, 0.275106f} },
    { {-0.024816f, -0.168855f, 0.137054f}, {-0.222696f, -0.625153f, 0.748058f}, {0.322515f, 0.331773f} },
    { {-0.005740f, -0.130742f, 0.143512f}, {0.148048f, -0.148919f, 0.977704f}, {0.350406f, 0.308195f} },
    { {0.030473f, -0.023923f, 0.147861f}, {0.283631f, 0.283944f, 0.915931f}, {0.403355f, 0.242112f} },
    { {0.003807f, -0.023923f, 0.147861f}, {0.084060f, 0.704605f, 0.704604f}, {0.355979f, 0.241101f} },
    { {0.003807f, -0.009398f, 0.133336f}, {0.084060f, 0.704605f, 0.704604f}, {0.361963f, 0.231254f} },
    { {-0.031140f, -0.005878f, 0.133985f}, {0.084060f, 0.704605f, 0.704604f}, {0.356002f, 0.231110f} },
    { {-0.030062f, -0.076123f, -0.012285f}, {-0.314498f, -0.090049f, -0.944977f}, {0.357536f, 0.340283f} },
    { {-0.042461f, -0.168869f, 0.125764f}, {-0.956423f, -0.238993f, 0.167741f}, {0.296716f, 0.233631f} },
    { {-0.042590f, -0.168617f, 0.014253f}, {-0.840361f, -0.529427f, -0.116197f}, {0.296527f, 0.319781f} },
    { {-0.022321f, -0.168115f, 0.006327f}, {0.045056f, -0.998693f, -0.024138f}, {0.326163f, 0.325904f} },
    { {0.004007f, -0.008885f, 0.124768f}, {-0.101519f, -0.932365f, 0.346971f}, {0.364658f, 0.232809f} },
    { {0.040394f, -0.020010f, 0.117522f}, {0.977898f, -0.099048f, 0.184134f}, {0.401394f, 0.237561f} },
    { {0.026550f, 0.021767f, 0.117522f}, {0.389644f, 0.889579f, 0.238384f}, {0.397619f, 0.213846f} },
    { {0.004007f, -0.008885f, 0.124768f}, {-0.101519f, -0.932365f, 0.346971f}, {0.364658f, 0.234401f} },
    { {0.040394f, -0.020010f, 0.021530f}, {0.306270f, -0.928747f, -0.208874f}, {0.417860f, 0.314159f} },
    { {0.040394f, -0.020010f, 0.117522f}, {0.977898f, -0.099048f, 0.184134f}, {0.417860f, 0.239999f} },
    { {-0.017454f, 0.022535f, 0.021530f}, {-0.357770f, 0.902713f, -0.238978f}, {0.386877f, 0.213371f} },
    { {0.004007f, -0.008885f, 0.014703f}, {0.068706f, -0.935666f, -0.346133f}, {0.355499f, 0.232809f} },
    { {-0.032747f, -0.018733f, 0.021530f}, {-0.980614f, -0.065869f, -0.184545f}, {0.392605f, 0.237016f} },
    { {-0.032747f, -0.018733f, 0.117522f}, {-0.341136f, -0.916514f, 0.208875f}, {0.310920f, 0.239999f} },
    { {-0.032747f, -0.018733f, 0.021530f}, {-0.980614f, -0.065869f, -0.184545f}, {0.310920f, 0.314159f} },
    { {0.004007f, -0.008885f, 0.014703f}, {0.068706f, -0.935666f, -0.346133f}, {0.364658f, 0.319433f} },
    { {-0.017454f, 0.022535f, 0.117522f}, {-0.710417f, 0.662179f, 0.238384f}, {0.333280f, 0.213371f} },
    { {0.026550f, 0.021767f, 0.117522f}, {0.389644f, 0.889579f, 0.238384f}, {0.322537f, 0.239999f} },
    { {-0.017454f, 0.022535f, 0.021530f}, {-0.357770f, 0.902713f, -0.238978f}, {0.386877f, 0.314159f} },
    { {-0.017454f, 0.022535f, 0.117522f}, {-0.710417f, 0.662179f, 0.238384f}, {0.386877f, 0.239999f} },
    { {0.026550f, 0.021767f, 0.021530f}, {0.733362f, 0.636451f, -0.238977f}, {0.322537f, 0.213846f} },
    { {0.026550f, 0.021767f, 0.021530f}, {0.733362f, 0.636451f, -0.238977f}, {0.322537f, 0.314159f} },
    { {0.044909f, -0.022987f, 0.006147f}, {0.990446f, 0.124467f, -0.059371f}, {0.395998f, 0.326044f} },
    { {0.030383f, -0.076246f, -0.008378f}, {0.380814f, -0.116779f, -0.917248f}, {0.362543f, 0.337265f} },
    { {-0.024816f, -0.168855f, 0.137054f}, {-0.222696f, -0.625153f, 0.748058f}, {0.322515f, 0.224909f} },
    { {-0.024816f, -0.168855f, 0.137054f}, {-0.222696f, -0.625153f, 0.748058f}, {0.415787f, 0.224909f} },
    { {-0.031140f, -0.005878f, 0.133985f}, {-0.667565f, 0.732309f, 0.134462f}, {0.313411f, 0.227280f} },
    { {-0.029964f, -0.023131f, 0.151724f}, {-0.149499f, 0.163104f, 0.975217f}, {0.324249f, 0.213575f} },
    { {0.003807f, -0.009398f, 0.133336f}, {0.051860f, 0.992907f, 0.106986f}, {0.364365f, 0.233126f} },
    { {0.003717f, -0.022987f, -0.008378f}, {0.087875f, 0.704372f, -0.704371f}, {0.358346f, 0.241146f} },
    { {-0.031049f, -0.004807f, 0.005464f}, {0.087875f, 0.704372f, -0.704371f}, {0.364305f, 0.230530f} },
    { {0.003717f, -0.008462f, 0.006147f}, {0.087875f, 0.704372f, -0.704371f}, {0.358344f, 0.230675f} },
    { {0.030383f, -0.008462f, 0.006147f}, {0.433200f, 0.895298f, -0.103825f}, {0.316933f, 0.232547f} },
    { {0.003717f, -0.008462f, 0.006147f}, {0.056565f, 0.997038f, -0.052105f}, {0.355923f, 0.232547f} },
    { {-0.032747f, -0.018733f, 0.117522f}, {-0.341136f, -0.916514f, 0.208875f}, {0.327551f, 0.237016f} },
    { {0.040394f, -0.020010f, 0.021530f}, {0.306270f, -0.928747f, -0.208874f}, {0.318762f, 0.237561f} },
    { {-0.000000f, -0.130415f, -0.000000f}, {0.157649f, -0.169579f, -0.972826f}, {0.369752f, 0.308192f} },
    { {-0.025533f, -0.168698f, 0.002553f}, {-0.293299f, -0.188111f, -0.937331f}, {0.398689f, 0.331676f} },
    { {-0.025533f, -0.168698f, 0.002553f}, {-0.293299f, -0.188111f, -0.937331f}, {0.415688f, 0.328820f} },
    { {-0.029861f, -0.021486f, -0.012178f}, {-0.251093f, 0.230507f, -0.940116f}, {0.323216f, 0.340200f} },
    { {-0.031049f, -0.004807f, 0.005464f}, {-0.607306f, 0.764664f, -0.215563f}, {0.312739f, 0.326571f} },
    { {-0.018244f, -0.182873f, 0.124916f}, {-0.130670f, -0.989173f, 0.066798f}, {0.332125f, 0.340445f} },
    { {-0.024816f, -0.168855f, 0.137054f}, {-0.931255f, -0.364050f, 0.015193f}, {0.415469f, 0.234286f} },
    { {-0.018244f, -0.182873f, 0.014525f}, {-0.457851f, -0.884016f, -0.094277f}, {0.424593f, 0.319571f} },
    { {-0.018244f, -0.182873f, 0.124916f}, {-0.130670f, -0.989173f, 0.066798f}, {0.424593f, 0.234286f} },
    { {0.030383f, -0.022987f, -0.008378f}, {0.318671f, 0.108464f, -0.941639f}, {0.395998f, 0.337265f} },
    { {0.022862f, -0.130415f, -0.000000f}, {0.204656f, -0.192047f, -0.959809f}, {0.328516f, 0.330792f} },
    { {0.027481f, -0.182873f, 0.124916f}, {0.309703f, -0.747071f, 0.588192f}, {0.295564f, 0.234286f} },
    { {0.027481f, -0.182873f, 0.014525f}, {0.141942f, -0.946310f, -0.290431f}, {0.295564f, 0.319571f} },
    { {0.037649f, -0.169680f, 0.014525f}, {0.950033f, -0.279916f, -0.138145f}, {0.303851f, 0.319571f} },
    { {0.027481f, -0.182873f, 0.124916f}, {0.309703f, -0.747071f, 0.588192f}, {0.304407f, 0.227962f} },
    { {-0.031049f, -0.004807f, 0.005464f}, {-0.607306f, 0.764664f, -0.215563f}, {0.406754f, 0.230286f} },
    { {-0.022321f, -0.168115f, 0.006327f}, {-0.356132f, -0.366739f, -0.859461f}, {0.415469f, 0.325896f} },
    { {-0.018244f, -0.182873f, 0.014525f}, {-0.457851f, -0.884016f, -0.094277f}, {0.388032f, 0.340445f} },
    { {0.027481f, -0.182873f, 0.014525f}, {0.141942f, -0.946310f, -0.290431f}, {0.321176f, 0.340445f} },
    { {0.030473f, -0.009398f, 0.133336f}, {0.181494f, 0.982128f, 0.049840f}, {0.403355f, 0.233126f} },
    { {-0.018244f, -0.168348f, 0.133103f}, {0.098991f, -0.292456f, 0.951142f}, {0.415469f, 0.227962f} },
    { {-0.005740f, -0.130742f, 0.143512f}, {0.497760f, -0.381139f, 0.779081f}, {0.328164f, 0.219911f} },
    { {-0.024816f, -0.168855f, 0.137054f}, {0.497760f, -0.381139f, 0.779081f}, {0.304223f, 0.224901f} },
    { {-0.018244f, -0.168348f, 0.133103f}, {0.497760f, -0.381139f, 0.779081f}, {0.304688f, 0.227962f} },
    { {0.037649f, -0.169680f, 0.014525f}, {0.950033f, -0.279916f, -0.138145f}, {0.306310f, 0.332283f} },
    { {-0.042590f, -0.168617f, 0.014253f}, {-0.840361f, -0.529427f, -0.116197f}, {0.415637f, 0.319781f} },
    { {-0.000000f, -0.130415f, -0.000000f}, {0.157649f, -0.169579f, -0.972826f}, {0.328663f, 0.330801f} },
    { {-0.022321f, -0.168115f, 0.006327f}, {0.045056f, -0.998693f, -0.024138f}, {0.304834f, 0.325904f} },
    { {-0.025533f, -0.168698f, 0.002553f}, {-0.293299f, -0.188111f, -0.937331f}, {0.304468f, 0.328820f} },
    { {-0.025533f, -0.168698f, 0.002553f}, {-0.293299f, -0.188111f, -0.937331f}, {0.321467f, 0.328820f} },
    { {-0.018244f, -0.168348f, 0.133103f}, {0.875232f, -0.375422f, 0.305003f}, {0.304834f, 0.227970f} },
    { {-0.004077f, -0.130181f, 0.139430f}, {0.911200f, -0.233901f, 0.339123f}, {0.328663f, 0.223073f} },
    { {-0.005740f, -0.130742f, 0.143512f}, {0.148048f, -0.148919f, 0.977704f}, {0.328310f, 0.219920f} },
    { {-0.000270f, -0.076948f, 0.147850f}, {0.163806f, -0.038015f, 0.985760f}, {0.362102f, 0.216568f} },
};

WORD g_tind30[] = 
{
    0, 1, 2,    3, 4, 5,    0, 2, 6,    3, 7, 4,    8, 9, 10,
    11, 12, 13,    14, 15, 16,    17, 18, 19,    20, 21, 12,    22, 23, 24,
    25, 26, 27,    22, 24, 28,    29, 30, 31,    30, 32, 33,    34, 35, 36,
    21, 37, 38,    8, 10, 18,    36, 35, 39,    40, 41, 42,    43, 44, 45,
    43, 46, 44,    40, 47, 41,    48, 3, 5,    16, 49, 14,    50, 51, 52,
    53, 54, 55,    27, 26, 56,    57, 58, 59,    7, 60, 4,    61, 62, 63,
    64, 65, 66,    67, 68, 69,    70, 71, 72,    73, 74, 75,    64, 66, 76,
    77, 78, 79,    80, 71, 70,    77, 81, 78,    30, 82, 32,    1, 83, 2,
    29, 0, 6,    52, 51, 26,    63, 84, 61,    48, 5, 85,    86, 7, 3,
    87, 86, 3,    56, 88, 27,    8, 18, 17,    89, 90, 91,    92, 13, 93,
    64, 76, 94,    73, 75, 67,    95, 71, 80,    67, 75, 68,    96, 97, 35,
    4, 60, 98,    7, 99, 60,    86, 100, 7,    50, 101, 51,    102, 103, 104,
    96, 35, 34,    21, 38, 12,    92, 11, 13,    82, 105, 32,    1, 106, 83,
    107, 108, 109,    14, 53, 15,    87, 3, 48,    52, 26, 25,    53, 55, 15,
    110, 0, 29,    107, 109, 0,    36, 39, 111,    100, 99, 7,    102, 112, 103,
    113, 37, 114,    56, 115, 88,    31, 30, 33,    116, 102, 104,    117, 118, 119,
    6, 82, 30,    29, 6, 30,    11, 20, 12,    2, 83, 105,    21, 114, 37,
    120, 114, 21,    2, 105, 82,    6, 2, 82,    4, 98, 121,    5, 4, 121,
    122, 123, 124,    62, 125, 63,    126, 127, 128,    129, 128, 127,    109, 106, 1,
    0, 109, 1,
};

D3DMATRIX g_tmat31 = 
{
    -0.428091f, -0.136623f, 0.893350f, 0.000000f, 
    -0.896570f, -0.060034f, -0.438815f, 0.000000f, 
    0.113583f, -0.988803f, -0.096791f, 0.000000f, 
    -0.876056f, -2.152813f, 1.793485f, 1.000000f, 
};

// Mesh #31 Tris:74 Verts:96
MODELVERT g_tmesh31[] = 
{
    { {0.028660f, -0.022377f, 0.099933f}, {0.956482f, 0.264725f, 0.122729f}, {0.399661f, 0.228668f} },
    { {0.038275f, -0.106688f, 0.021795f}, {0.987222f, 0.033598f, -0.155765f}, {0.330727f, 0.313958f} },
    { {0.028660f, -0.022377f, 0.011620f}, {0.953058f, 0.251438f, -0.168698f}, {0.399661f, 0.325064f} },
    { {-0.039335f, -0.021872f, 0.100087f}, {-0.992702f, -0.054489f, 0.107582f}, {0.320082f, 0.228499f} },
    { {-0.039252f, -0.021347f, 0.011199f}, {-0.984197f, 0.087556f, -0.153917f}, {0.319653f, 0.325524f} },
    { {-0.027311f, -0.106757f, 0.020045f}, {-0.966262f, -0.233485f, -0.108728f}, {0.389487f, 0.315868f} },
    { {0.038374f, -0.107392f, 0.094738f}, {0.977200f, 0.010133f, 0.212080f}, {0.330150f, 0.234339f} },
    { {-0.027149f, -0.107449f, 0.096048f}, {-0.896960f, -0.388404f, 0.211200f}, {0.390052f, 0.232908f} },
    { {-0.017843f, -0.107867f, 0.095511f}, {-0.999419f, -0.020424f, 0.027282f}, {0.390394f, 0.233495f} },
    { {-0.010195f, -0.108331f, 0.009201f}, {-0.668525f, -0.131503f, -0.731971f}, {0.391887f, 0.327691f} },
    { {-0.014326f, -0.136946f, 0.026711f}, {-0.974835f, -0.188918f, -0.118353f}, {0.414170f, 0.308592f} },
    { {0.024591f, -0.109597f, 0.010116f}, {0.271731f, -0.186508f, -0.944127f}, {0.319766f, 0.308158f} },
    { {-0.002367f, -0.139351f, 0.015699f}, {0.018900f, -0.484937f, -0.874345f}, {0.367105f, 0.332117f} },
    { {-0.010195f, -0.108331f, 0.009201f}, {-0.668525f, -0.131503f, -0.731971f}, {0.373424f, 0.308235f} },
    { {-0.014171f, -0.138048f, 0.092316f}, {-0.890795f, -0.422420f, 0.167467f}, {0.415071f, 0.236982f} },
    { {-0.019922f, -0.065952f, 0.113666f}, {0.087037f, -0.076526f, 0.993262f}, {0.336170f, 0.273605f} },
    { {0.024513f, -0.109038f, 0.106453f}, {0.317115f, -0.064909f, 0.946163f}, {0.400252f, 0.307707f} },
    { {0.017040f, -0.022377f, 0.111553f}, {0.319360f, 0.013788f, 0.947533f}, {0.387131f, 0.237925f} },
    { {0.010123f, -0.007273f, 0.100082f}, {-0.014810f, 0.996599f, 0.081059f}, {0.345172f, 0.228505f} },
    { {-0.025598f, -0.007769f, 0.011430f}, {-0.177256f, 0.981034f, -0.078433f}, {0.407897f, 0.325272f} },
    { {-0.026057f, -0.007910f, 0.100281f}, {-0.358581f, 0.916164f, 0.179060f}, {0.408703f, 0.228288f} },
    { {-0.026061f, -0.021572f, 0.113886f}, {-0.193498f, 0.201005f, 0.960289f}, {0.311446f, 0.237277f} },
    { {-0.019922f, -0.065952f, 0.113666f}, {-0.455250f, -0.121237f, 0.882071f}, {0.322226f, 0.273013f} },
    { {0.017040f, -0.022377f, 0.111553f}, {0.044160f, 0.313611f, 0.948524f}, {0.374989f, 0.236521f} },
    { {0.016928f, 0.007972f, 0.092014f}, {0.374340f, 0.887654f, 0.268218f}, {0.333223f, 0.237312f} },
    { {-0.015914f, 0.008103f, 0.015460f}, {-0.341144f, 0.853439f, -0.394034f}, {0.390892f, 0.320873f} },
    { {-0.015916f, 0.008116f, 0.092014f}, {-0.712975f, 0.646470f, 0.271557f}, {0.390896f, 0.237312f} },
    { {-0.026924f, -0.022828f, 0.092014f}, {-0.404238f, -0.904139f, 0.138292f}, {0.309930f, 0.237312f} },
    { {0.027668f, -0.023080f, 0.015460f}, {0.271731f, -0.910031f, -0.313058f}, {0.405793f, 0.320873f} },
    { {0.000769f, -0.022686f, 0.097421f}, {-0.003661f, -0.838983f, 0.544146f}, {0.358559f, 0.231410f} },
    { {0.027666f, -0.023067f, 0.092014f}, {0.983332f, -0.071758f, 0.167061f}, {0.399098f, 0.237312f} },
    { {0.027668f, -0.023080f, 0.015460f}, {0.271731f, -0.910031f, -0.313058f}, {0.399087f, 0.320873f} },
    { {0.016930f, 0.007959f, 0.015460f}, {0.743733f, 0.649286f, -0.159025f}, {0.424465f, 0.320873f} },
    { {-0.015916f, 0.008116f, 0.092014f}, {-0.712975f, 0.646470f, 0.271557f}, {0.295564f, 0.237312f} },
    { {-0.015914f, 0.008103f, 0.015460f}, {-0.341144f, 0.853439f, -0.394034f}, {0.295574f, 0.320873f} },
    { {-0.026922f, -0.022842f, 0.015460f}, {-0.844734f, -0.442898f, -0.300443f}, {0.320875f, 0.320873f} },
    { {0.010169f, -0.007315f, 0.011117f}, {-0.013167f, 0.973910f, -0.226551f}, {0.345092f, 0.325613f} },
    { {0.010140f, -0.020893f, -0.002484f}, {-0.004430f, 0.219273f, -0.975653f}, {0.345142f, 0.236730f} },
    { {-0.019707f, -0.067313f, -0.002231f}, {-0.537691f, -0.146669f, -0.830287f}, {0.397552f, 0.274109f} },
    { {-0.025717f, -0.021197f, -0.002390f}, {-0.225275f, 0.292821f, -0.929251f}, {0.408107f, 0.236975f} },
    { {-0.002561f, -0.149597f, 0.090944f}, {0.119101f, -0.991419f, 0.053875f}, {0.295564f, 0.238739f} },
    { {-0.002747f, -0.148270f, 0.029496f}, {-0.165145f, -0.979830f, -0.112519f}, {0.296680f, 0.305025f} },
    { {0.033380f, -0.136796f, 0.028120f}, {0.560508f, -0.792601f, -0.240028f}, {0.306109f, 0.307053f} },
    { {-0.002367f, -0.139351f, 0.015699f}, {0.018900f, -0.484937f, -0.874345f}, {0.303181f, 0.319853f} },
    { {0.024591f, -0.109597f, 0.010116f}, {0.271731f, -0.186508f, -0.944127f}, {0.328348f, 0.326706f} },
    { {0.033550f, -0.138012f, 0.091621f}, {0.832410f, -0.543602f, 0.107663f}, {0.305115f, 0.237740f} },
    { {0.024513f, -0.109038f, 0.106453f}, {0.317115f, -0.064909f, 0.946163f}, {0.328805f, 0.221551f} },
    { {0.010140f, -0.020893f, -0.002484f}, {0.428182f, -0.026180f, -0.903313f}, {0.399661f, 0.337748f} },
    { {0.010169f, -0.007315f, 0.011117f}, {-0.013167f, 0.973910f, -0.226551f}, {0.345092f, 0.225796f} },
    { {-0.015914f, 0.008103f, 0.015460f}, {-0.341144f, 0.853439f, -0.394034f}, {0.390892f, 0.213381f} },
    { {0.027668f, -0.023080f, 0.015460f}, {0.271731f, -0.910031f, -0.313058f}, {0.329179f, 0.236510f} },
    { {-0.026922f, -0.022842f, 0.015460f}, {-0.844734f, -0.442898f, -0.300443f}, {0.395371f, 0.236378f} },
    { {-0.026922f, -0.022842f, 0.015460f}, {-0.844734f, -0.442898f, -0.300443f}, {0.309933f, 0.320873f} },
    { {0.000769f, -0.022686f, 0.097421f}, {-0.003661f, -0.838983f, 0.544146f}, {0.358559f, 0.238173f} },
    { {0.016928f, 0.007972f, 0.092014f}, {0.374340f, 0.887654f, 0.268218f}, {0.386934f, 0.213486f} },
    { {-0.015916f, 0.008116f, 0.092014f}, {-0.712975f, 0.646470f, 0.271557f}, {0.329261f, 0.213371f} },
    { {0.016928f, 0.007972f, 0.092014f}, {0.374340f, 0.887654f, 0.268218f}, {0.424476f, 0.237312f} },
    { {-0.006055f, -0.109061f, 0.106898f}, {-0.184716f, -0.143326f, 0.972285f}, {0.391370f, 0.221065f} },
    { {-0.002383f, -0.139242f, 0.103703f}, {-0.372816f, -0.367481f, 0.852037f}, {0.416047f, 0.224553f} },
    { {0.013316f, -0.140324f, 0.103361f}, {0.286278f, -0.348831f, 0.892391f}, {0.303224f, 0.224926f} },
    { {-0.019707f, -0.067313f, -0.002231f}, {-0.537691f, -0.146669f, -0.830287f}, {0.357236f, 0.340183f} },
    { {-0.027149f, -0.107449f, 0.096048f}, {-0.896960f, -0.388404f, 0.211200f}, {0.309534f, 0.232908f} },
    { {-0.027311f, -0.106757f, 0.020045f}, {-0.966262f, -0.233485f, -0.108728f}, {0.309250f, 0.315868f} },
    { {-0.010195f, -0.108331f, 0.009201f}, {-0.242799f, -0.931546f, -0.270685f}, {0.339306f, 0.327705f} },
    { {-0.019922f, -0.065952f, 0.113666f}, {-0.455250f, -0.121237f, 0.882071f}, {0.356123f, 0.213677f} },
    { {-0.006055f, -0.109061f, 0.106898f}, {-0.184716f, -0.143326f, 0.972285f}, {0.346577f, 0.307726f} },
    { {-0.026061f, -0.021572f, 0.113886f}, {-0.193498f, 0.201005f, 0.960289f}, {0.319837f, 0.213438f} },
    { {-0.026057f, -0.007910f, 0.100281f}, {-0.358581f, 0.916164f, 0.179060f}, {0.308666f, 0.228288f} },
    { {-0.026924f, -0.022828f, 0.092014f}, {-0.404238f, -0.904139f, 0.138292f}, {0.324783f, 0.236367f} },
    { {-0.026924f, -0.022828f, 0.092014f}, {-0.404238f, -0.904139f, 0.138292f}, {0.320864f, 0.237312f} },
    { {0.016930f, 0.007959f, 0.015460f}, {0.743733f, 0.649286f, -0.159025f}, {0.333220f, 0.213497f} },
    { {0.016930f, 0.007959f, 0.015460f}, {0.743733f, 0.649286f, -0.159025f}, {0.333220f, 0.320873f} },
    { {0.010169f, -0.007315f, 0.011117f}, {0.631541f, 0.773385f, -0.055066f}, {0.409162f, 0.325064f} },
    { {0.010123f, -0.007273f, 0.100082f}, {0.630345f, 0.772896f, 0.072782f}, {0.409162f, 0.228668f} },
    { {0.010123f, -0.007273f, 0.100082f}, {-0.014810f, 0.996599f, 0.081059f}, {0.374985f, 0.225762f} },
    { {-0.026057f, -0.007910f, 0.100281f}, {-0.358581f, 0.916164f, 0.179060f}, {0.311454f, 0.226275f} },
    { {0.010140f, -0.020893f, -0.002484f}, {0.428182f, -0.026180f, -0.903313f}, {0.333026f, 0.237925f} },
    { {-0.019707f, -0.067313f, -0.002231f}, {0.121210f, -0.159124f, -0.979790f}, {0.383649f, 0.274708f} },
    { {-0.010195f, -0.108331f, 0.009201f}, {-0.242799f, -0.931546f, -0.270685f}, {0.391631f, 0.329706f} },
    { {-0.006055f, -0.109061f, 0.106898f}, {-0.446612f, -0.374196f, 0.812721f}, {0.391024f, 0.219064f} },
    { {-0.002367f, -0.139351f, 0.015699f}, {0.018900f, -0.484937f, -0.874345f}, {0.416136f, 0.320612f} },
    { {-0.025717f, -0.021197f, -0.002390f}, {-0.225275f, 0.292821f, -0.929251f}, {0.319531f, 0.340356f} },
    { {-0.025598f, -0.007769f, 0.011430f}, {-0.177256f, 0.981034f, -0.078433f}, {0.308551f, 0.325272f} },
    { {0.017040f, -0.022377f, 0.111553f}, {0.319360f, 0.013788f, 0.947533f}, {0.399661f, 0.215984f} },
    { {0.013316f, -0.140324f, 0.103361f}, {0.286278f, -0.348831f, 0.892391f}, {0.380591f, 0.332901f} },
    { {-0.002747f, -0.148270f, 0.029496f}, {-0.165145f, -0.979830f, -0.112519f}, {0.423429f, 0.305552f} },
    { {-0.002561f, -0.149597f, 0.090944f}, {0.119101f, -0.991419f, 0.053875f}, {0.424513f, 0.238480f} },
    { {0.033550f, -0.138012f, 0.091621f}, {0.832410f, -0.543602f, 0.107663f}, {0.416123f, 0.331038f} },
    { {0.038374f, -0.107392f, 0.094738f}, {0.977200f, 0.010133f, 0.212080f}, {0.424593f, 0.306382f} },
    { {-0.025598f, -0.007769f, 0.011430f}, {-0.177256f, 0.981034f, -0.078433f}, {0.407897f, 0.226162f} },
    { {-0.017843f, -0.107867f, 0.095511f}, {-0.045125f, -0.998966f, -0.005549f}, {0.318450f, 0.233509f} },
    { {-0.006055f, -0.109061f, 0.106898f}, {-0.446612f, -0.374196f, 0.812721f}, {0.331594f, 0.219064f} },
    { {-0.002383f, -0.139242f, 0.103703f}, {-0.372816f, -0.367481f, 0.852037f}, {0.353024f, 0.332029f} },
    { {-0.002561f, -0.149597f, 0.090944f}, {0.119101f, -0.991419f, 0.053875f}, {0.352712f, 0.340367f} },
    { {0.027666f, -0.023067f, 0.092014f}, {0.983332f, -0.071758f, 0.167061f}, {0.390974f, 0.236500f} },
    { {0.027666f, -0.023067f, 0.092014f}, {0.983332f, -0.071758f, 0.167061f}, {0.405790f, 0.237312f} },
};

WORD g_tind31[] = 
{
    0, 1, 2,    3, 4, 5,    6, 1, 0,    3, 5, 7,    8, 9, 10,
    11, 12, 13,    8, 10, 14,    15, 16, 17,    18, 19, 20,    21, 22, 23,
    24, 25, 26,    27, 28, 29,    30, 31, 32,    33, 34, 35,    18, 36, 19,
    37, 38, 39,    40, 41, 42,    42, 43, 44,    40, 42, 45,    46, 6, 0,
    1, 47, 2,    48, 37, 39,    49, 50, 51,    27, 52, 28,    53, 54, 55,
    30, 32, 56,    57, 14, 58,    59, 40, 45,    4, 60, 5,    61, 62, 63,
    64, 3, 7,    15, 65, 16,    66, 3, 64,    67, 4, 3,    53, 55, 68,
    33, 35, 69,    70, 50, 49,    24, 71, 25,    0, 72, 73,    23, 74, 75,
    76, 11, 77,    1, 44, 47,    5, 60, 78,    11, 13, 77,    64, 7, 79,
    57, 8, 14,    9, 80, 10,    41, 43, 42,    2, 47, 72,    0, 2, 72,
    4, 81, 60,    67, 82, 4,    83, 0, 73,    46, 0, 83,    59, 6, 46,
    65, 84, 16,    42, 44, 1,    45, 42, 1,    23, 75, 21,    66, 67, 3,
    14, 85, 86,    58, 14, 86,    10, 80, 85,    14, 10, 85,    45, 1, 6,
    84, 87, 88,    48, 39, 89,    82, 81, 4,    63, 90, 61,    91, 61, 90,
    92, 93, 84,    65, 92, 84,    53, 94, 54,    29, 28, 95,
};

D3DMATRIX g_tmat32 = 
{
    0.857582f, -0.508448f, -0.077685f, 0.000000f, 
    -0.144018f, -0.382363f, 0.912720f, 0.000000f, 
    -0.493774f, -0.771544f, -0.401133f, 0.000000f, 
    -0.961970f, -2.046077f, 2.226597f, 1.000000f, 
};

// Mesh #32 Tris:86 Verts:114
MODELVERT g_tmesh32[] = 
{
    { {-0.080576f, -0.155593f, 0.162286f}, {-0.988601f, -0.045595f, 0.143492f}, {0.388095f, 0.231422f} },
    { {-0.073496f, -0.012479f, 0.016912f}, {-0.961158f, 0.214486f, -0.173697f}, {0.324870f, 0.322770f} },
    { {-0.080589f, -0.155372f, 0.017305f}, {-0.986528f, -0.049433f, -0.155945f}, {0.387998f, 0.322524f} },
    { {0.048230f, -0.150766f, 0.161142f}, {0.992931f, -0.077232f, 0.090134f}, {0.334194f, 0.232142f} },
    { {0.048230f, -0.219470f, 0.018738f}, {0.968950f, -0.189711f, -0.158576f}, {0.303841f, 0.321623f} },
    { {0.061754f, -0.082063f, 0.018738f}, {0.995462f, -0.077429f, -0.055315f}, {0.364546f, 0.321623f} },
    { {0.061754f, -0.013359f, 0.161142f}, {0.983925f, 0.077215f, 0.161026f}, {0.394898f, 0.232142f} },
    { {-0.074082f, -0.014079f, 0.161738f}, {-0.955016f, 0.258971f, 0.144493f}, {0.325577f, 0.231767f} },
    { {-0.011470f, -0.150773f, 0.179770f}, {0.170552f, -0.039018f, 0.984576f}, {0.362592f, 0.302624f} },
    { {0.029492f, -0.219470f, 0.179879f}, {0.280634f, -0.068236f, 0.957386f}, {0.393777f, 0.332293f} },
    { {0.006762f, -0.013359f, 0.179879f}, {0.151796f, 0.091391f, 0.984178f}, {0.372065f, 0.242616f} },
    { {-0.029493f, -0.238207f, 0.161142f}, {-0.141654f, -0.987185f, 0.073482f}, {0.337435f, 0.232142f} },
    { {0.029492f, -0.238207f, 0.018738f}, {0.142485f, -0.987408f, -0.068723f}, {0.393777f, 0.321623f} },
    { {0.029492f, -0.238207f, 0.161142f}, {0.325925f, -0.933930f, 0.146787f}, {0.393777f, 0.232142f} },
    { {0.043017f, 0.005378f, 0.161142f}, {0.113375f, 0.989579f, 0.088762f}, {0.313461f, 0.232142f} },
    { {0.043017f, 0.005378f, 0.018738f}, {0.278324f, 0.951353f, -0.132148f}, {0.313461f, 0.321623f} },
    { {-0.044167f, 0.006913f, 0.016355f}, {-0.085880f, 0.992030f, -0.092202f}, {0.382721f, 0.321623f} },
    { {-0.008174f, -0.015095f, -0.011243f}, {0.208132f, 0.061106f, -0.976190f}, {0.362358f, 0.243371f} },
    { {-0.050835f, -0.215236f, -0.006951f}, {-0.277137f, -0.103416f, -0.955249f}, {0.403107f, 0.330451f} },
    { {-0.047963f, -0.013970f, -0.010464f}, {-0.389879f, 0.107650f, -0.914552f}, {0.400363f, 0.242882f} },
    { {0.030164f, 0.053858f, 0.152261f}, {0.320830f, 0.905176f, 0.278792f}, {0.325738f, 0.237722f} },
    { {0.030164f, 0.053857f, 0.026750f}, {0.675225f, 0.682567f, -0.279597f}, {0.325738f, 0.316589f} },
    { {-0.038383f, 0.049965f, 0.026750f}, {-0.420533f, 0.863121f, -0.279596f}, {0.391212f, 0.316589f} },
    { {0.056530f, -0.009535f, 0.026750f}, {0.370909f, -0.896064f, -0.243915f}, {0.419603f, 0.316589f} },
    { {-0.001364f, 0.003565f, 0.163564f}, {0.053773f, -0.946965f, 0.316806f}, {0.364303f, 0.230620f} },
    { {-0.001364f, 0.003565f, 0.016099f}, {0.047777f, -0.841363f, -0.538355f}, {0.364303f, 0.323281f} },
    { {-0.029493f, -0.238207f, 0.018738f}, {-0.282875f, -0.949214f, -0.137748f}, {0.337435f, 0.321623f} },
    { {0.029492f, -0.219470f, 0.000001f}, {0.211206f, -0.148547f, -0.966088f}, {0.326380f, 0.332293f} },
    { {-0.050835f, -0.215236f, -0.006951f}, {-0.277137f, -0.103416f, -0.955249f}, {0.382721f, 0.332293f} },
    { {-0.011470f, -0.150773f, -0.000109f}, {0.136182f, -0.010976f, -0.990623f}, {0.357565f, 0.302624f} },
    { {-0.036758f, 0.005889f, 0.162477f}, {-0.239747f, 0.963029f, 0.122872f}, {0.382721f, 0.232142f} },
    { {-0.047933f, -0.014913f, 0.190236f}, {-0.411302f, 0.104518f, 0.905487f}, {0.319822f, 0.243292f} },
    { {-0.018345f, -0.150357f, 0.190905f}, {0.237554f, -0.057551f, 0.969668f}, {0.348084f, 0.302223f} },
    { {-0.008204f, -0.014204f, 0.190676f}, {0.163882f, 0.120490f, 0.979094f}, {0.357771f, 0.242984f} },
    { {0.043017f, -0.013359f, 0.000001f}, {0.304957f, 0.025404f, -0.952027f}, {0.313461f, 0.242616f} },
    { {0.043017f, 0.005378f, 0.018738f}, {0.278324f, 0.951353f, -0.132148f}, {0.313461f, 0.234464f} },
    { {-0.001552f, -0.012853f, -0.000109f}, {0.175981f, 0.275335f, -0.945104f}, {0.348091f, 0.242616f} },
    { {-0.044167f, 0.006913f, 0.016355f}, {-0.085880f, 0.992030f, -0.092202f}, {0.382721f, 0.234464f} },
    { {-0.047933f, -0.014913f, 0.190236f}, {-0.411302f, 0.104518f, 0.905487f}, {0.325945f, 0.213860f} },
    { {-0.051121f, -0.189414f, 0.190315f}, {-0.407822f, -0.094043f, 0.908205f}, {0.403037f, 0.213811f} },
    { {-0.032649f, -0.185631f, 0.179879f}, {0.083004f, -0.170034f, 0.981936f}, {0.334421f, 0.317570f} },
    { {-0.029493f, -0.219470f, 0.179879f}, {-0.139872f, -0.432016f, 0.890954f}, {0.337436f, 0.332293f} },
    { {0.043017f, 0.005378f, 0.161142f}, {0.113375f, 0.989579f, 0.088762f}, {0.406695f, 0.234464f} },
    { {-0.036758f, 0.005889f, 0.162477f}, {-0.239747f, 0.963029f, 0.122872f}, {0.337436f, 0.234464f} },
    { {0.043017f, -0.013359f, 0.179879f}, {0.321951f, 0.059375f, 0.944893f}, {0.406695f, 0.242616f} },
    { {0.056530f, -0.009535f, 0.152261f}, {0.976008f, -0.022787f, 0.216538f}, {0.396587f, 0.237722f} },
    { {0.030164f, 0.053857f, 0.026750f}, {0.675225f, 0.682567f, -0.279597f}, {0.424593f, 0.316589f} },
    { {0.030164f, 0.053858f, 0.152261f}, {0.320830f, 0.905176f, 0.278792f}, {0.424593f, 0.237722f} },
    { {-0.038383f, 0.049965f, 0.152261f}, {-0.747916f, 0.602409f, 0.278792f}, {0.297283f, 0.237722f} },
    { {-0.057403f, -0.016005f, 0.026750f}, {-0.739764f, -0.640454f, -0.206322f}, {0.326427f, 0.316589f} },
    { {-0.057403f, -0.016004f, 0.152261f}, {-0.764470f, -0.515659f, 0.386886f}, {0.326427f, 0.237722f} },
    { {0.030164f, 0.053857f, 0.026750f}, {0.675225f, 0.682567f, -0.279597f}, {0.325738f, 0.213371f} },
    { {-0.001364f, 0.003565f, 0.016099f}, {0.047777f, -0.841363f, -0.538355f}, {0.355853f, 0.235252f} },
    { {-0.038383f, 0.049965f, 0.026750f}, {-0.420533f, 0.863121f, -0.279596f}, {0.391212f, 0.215064f} },
    { {-0.038383f, 0.049965f, 0.026750f}, {-0.420533f, 0.863121f, -0.279596f}, {0.297283f, 0.316589f} },
    { {-0.036758f, 0.005889f, 0.162477f}, {-0.239747f, 0.963029f, 0.122872f}, {0.313690f, 0.228524f} },
    { {-0.036758f, 0.005889f, 0.162477f}, {-0.239747f, 0.963029f, 0.122872f}, {0.331738f, 0.231223f} },
    { {-0.044167f, 0.006913f, 0.016355f}, {-0.085880f, 0.992030f, -0.092202f}, {0.316303f, 0.323120f} },
    { {-0.044167f, 0.006913f, 0.016355f}, {-0.085880f, 0.992030f, -0.092202f}, {0.396737f, 0.233796f} },
    { {-0.001364f, 0.003565f, 0.163564f}, {0.053773f, -0.946965f, 0.316806f}, {0.364303f, 0.235252f} },
    { {0.056530f, -0.009535f, 0.152261f}, {0.976008f, -0.022787f, 0.216538f}, {0.402488f, 0.239188f} },
    { {0.030164f, 0.053858f, 0.152261f}, {0.320830f, 0.905176f, 0.278792f}, {0.394418f, 0.213371f} },
    { {0.056530f, -0.009535f, 0.152261f}, {0.976008f, -0.022787f, 0.216538f}, {0.419603f, 0.237722f} },
    { {-0.038383f, 0.049965f, 0.152261f}, {-0.747916f, 0.602409f, 0.278792f}, {0.328944f, 0.215064f} },
    { {-0.038383f, 0.049965f, 0.152261f}, {-0.747916f, 0.602409f, 0.278792f}, {0.391212f, 0.237722f} },
    { {0.056530f, -0.009535f, 0.026750f}, {0.370909f, -0.896064f, -0.243915f}, {0.300554f, 0.240952f} },
    { {0.056530f, -0.009535f, 0.026750f}, {0.370909f, -0.896064f, -0.243915f}, {0.396587f, 0.316589f} },
    { {-0.011470f, -0.150773f, -0.000109f}, {0.136182f, -0.010976f, -0.990623f}, {0.372045f, 0.302226f} },
    { {-0.063410f, -0.216894f, 0.017900f}, {-0.898049f, -0.437670f, -0.044189f}, {0.415177f, 0.322149f} },
    { {-0.063234f, -0.217224f, 0.162843f}, {-0.766922f, -0.623043f, 0.153777f}, {0.415323f, 0.231072f} },
    { {-0.051121f, -0.189414f, 0.190315f}, {-0.407822f, -0.094043f, 0.908205f}, {0.316777f, 0.319216f} },
    { {-0.063234f, -0.217224f, 0.162843f}, {-0.766922f, -0.623043f, 0.153777f}, {0.304065f, 0.232211f} },
    { {-0.032649f, -0.185631f, 0.179879f}, {0.083004f, -0.170034f, 0.981936f}, {0.319015f, 0.220437f} },
    { {-0.051121f, -0.189414f, 0.190315f}, {-0.407822f, -0.094043f, 0.908205f}, {0.317120f, 0.213811f} },
    { {0.061754f, -0.013359f, 0.018738f}, {0.971543f, 0.208188f, -0.112971f}, {0.394898f, 0.321623f} },
    { {0.043017f, 0.005378f, 0.018738f}, {0.278324f, 0.951353f, -0.132148f}, {0.403176f, 0.321623f} },
    { {0.043017f, -0.013359f, 0.000001f}, {0.304957f, 0.025404f, -0.952027f}, {0.394898f, 0.333397f} },
    { {-0.047963f, -0.013970f, -0.010464f}, {-0.389879f, 0.107650f, -0.914552f}, {0.325528f, 0.339973f} },
    { {-0.050835f, -0.215236f, -0.006951f}, {-0.277137f, -0.103416f, -0.955249f}, {0.414445f, 0.337765f} },
    { {-0.063234f, -0.217224f, 0.162843f}, {-0.766922f, -0.623043f, 0.153777f}, {0.416315f, 0.232142f} },
    { {-0.063410f, -0.216894f, 0.017900f}, {-0.898049f, -0.437670f, -0.044189f}, {0.416315f, 0.321623f} },
    { {-0.029493f, -0.238207f, 0.018738f}, {-0.282875f, -0.949214f, -0.137748f}, {0.424593f, 0.321623f} },
    { {-0.057403f, -0.016004f, 0.152261f}, {-0.764470f, -0.515659f, 0.386886f}, {0.327342f, 0.241132f} },
    { {-0.057403f, -0.016004f, 0.152261f}, {-0.764470f, -0.515659f, 0.386886f}, {0.310776f, 0.237722f} },
    { {-0.057403f, -0.016005f, 0.026750f}, {-0.739764f, -0.640454f, -0.206322f}, {0.310776f, 0.316589f} },
    { {0.043017f, 0.005378f, 0.161142f}, {0.113375f, 0.989579f, 0.088762f}, {0.403176f, 0.232142f} },
    { {0.029492f, -0.219470f, 0.179879f}, {0.280634f, -0.068236f, 0.957386f}, {0.303841f, 0.220368f} },
    { {0.043017f, -0.013359f, 0.179879f}, {0.321951f, 0.059375f, 0.944893f}, {0.394898f, 0.220368f} },
    { {0.029492f, -0.238207f, 0.161142f}, {0.325925f, -0.933930f, 0.146787f}, {0.295564f, 0.232142f} },
    { {0.029492f, -0.238207f, 0.018738f}, {0.142485f, -0.987408f, -0.068723f}, {0.295564f, 0.321623f} },
    { {0.029492f, -0.219470f, 0.000001f}, {0.211206f, -0.148547f, -0.966088f}, {0.303841f, 0.333397f} },
    { {-0.032649f, -0.185631f, 0.179879f}, {0.083004f, -0.170034f, 0.981936f}, {0.401365f, 0.220368f} },
    { {-0.029493f, -0.219470f, 0.179879f}, {-0.139872f, -0.432016f, 0.890954f}, {0.416315f, 0.220368f} },
    { {-0.029493f, -0.238207f, 0.161142f}, {-0.141654f, -0.987185f, 0.073482f}, {0.424593f, 0.232142f} },
    { {-0.011470f, -0.150773f, 0.179770f}, {0.170552f, -0.039018f, 0.984576f}, {0.334191f, 0.220437f} },
    { {0.006762f, -0.013359f, 0.179879f}, {0.151796f, 0.091391f, 0.984178f}, {0.364592f, 0.220437f} },
    { {-0.018345f, -0.150357f, 0.190905f}, {0.237554f, -0.057551f, 0.969668f}, {0.334374f, 0.213440f} },
    { {0.048230f, -0.219470f, 0.161142f}, {0.971543f, -0.208189f, 0.112970f}, {0.303841f, 0.232142f} },
    { {-0.057403f, -0.016005f, 0.026750f}, {-0.739764f, -0.640454f, -0.206322f}, {0.392814f, 0.241132f} },
    { {-0.029493f, -0.238207f, 0.018738f}, {-0.282875f, -0.949214f, -0.137748f}, {0.382721f, 0.340445f} },
    { {-0.050835f, -0.215236f, -0.006951f}, {-0.277137f, -0.103416f, -0.955249f}, {0.416315f, 0.333397f} },
    { {0.029492f, -0.238207f, 0.018738f}, {0.142485f, -0.987408f, -0.068723f}, {0.326380f, 0.340445f} },
    { {0.029492f, -0.238207f, 0.161142f}, {0.325925f, -0.933930f, 0.146787f}, {0.393777f, 0.340445f} },
    { {-0.008204f, -0.014204f, 0.190676f}, {0.163882f, 0.120490f, 0.979094f}, {0.394524f, 0.213583f} },
    { {-0.036758f, 0.005889f, 0.162477f}, {0.234837f, 0.888136f, 0.395052f}, {0.389661f, 0.231303f} },
    { {-0.008204f, -0.014204f, 0.190676f}, {0.234837f, 0.888136f, 0.395052f}, {0.354445f, 0.213514f} },
    { {0.006762f, -0.013359f, 0.179879f}, {0.234837f, 0.888136f, 0.395052f}, {0.348091f, 0.220368f} },
    { {-0.001552f, -0.012853f, -0.000109f}, {0.175981f, 0.275335f, -0.945104f}, {0.395121f, 0.333466f} },
    { {-0.011470f, -0.150773f, -0.000109f}, {0.136182f, -0.010976f, -0.990623f}, {0.334191f, 0.333466f} },
    { {-0.008174f, -0.015095f, -0.011243f}, {0.208132f, 0.061106f, -0.976190f}, {0.394131f, 0.340462f} },
    { {-0.044167f, 0.006913f, 0.016355f}, {-0.085880f, 0.992030f, -0.092202f}, {0.396737f, 0.323120f} },
    { {-0.001552f, -0.012853f, -0.000109f}, {0.175981f, 0.275335f, -0.945104f}, {0.356032f, 0.333466f} },
    { {-0.008174f, -0.015095f, -0.011243f}, {0.208132f, 0.061106f, -0.976190f}, {0.362358f, 0.340462f} },
    { {-0.029493f, -0.238207f, 0.161142f}, {-0.141654f, -0.987185f, 0.073482f}, {0.337435f, 0.340445f} },
};

WORD g_tind32[] = 
{
    0, 1, 2,    3, 4, 5,    3, 5, 6,    7, 1, 0,    8, 9, 10,
    11, 12, 13,    14, 15, 16,    17, 18, 19,    20, 21, 22,    23, 24, 25,
    11, 26, 12,    27, 28, 29,    14, 16, 30,    31, 32, 33,    34, 27, 29,
    35, 36, 37,    38, 0, 39,    40, 41, 9,    42, 43, 10,    10, 9, 44,
    45, 46, 47,    48, 49, 50,    51, 52, 53,    48, 54, 49,    55, 1, 7,
    33, 56, 31,    55, 57, 1,    17, 19, 58,    59, 60, 61,    24, 23, 62,
    59, 61, 63,    20, 22, 64,    65, 52, 51,    45, 66, 46,    67, 18, 17,
    34, 29, 36,    0, 68, 69,    39, 0, 69,    31, 70, 32,    71, 72, 73,
    6, 74, 75,    4, 76, 5,    1, 77, 78,    57, 77, 1,    79, 80, 81,
    1, 78, 2,    59, 63, 82,    83, 84, 24,    6, 75, 85,    86, 6, 87,
    88, 89, 4,    4, 90, 76,    91, 79, 92,    79, 81, 93,    94, 95, 96,
    96, 73, 72,    88, 4, 97,    86, 3, 6,    38, 7, 0,    38, 55, 7,
    25, 24, 84,    53, 52, 98,    99, 28, 27,    80, 100, 81,    89, 90, 4,
    99, 27, 101,    44, 42, 10,    87, 6, 85,    2, 78, 68,    0, 2, 68,
    86, 88, 97,    41, 102, 9,    35, 34, 36,    74, 76, 75,    103, 96, 95,
    104, 105, 106,    107, 108, 109,    110, 111, 112,    72, 94, 96,    40, 9, 8,
    41, 113, 102,    92, 79, 93,    97, 4, 3,    86, 97, 3,    5, 76, 74,
    6, 5, 74,
};

D3DMATRIX g_tmat33 = 
{
    0.440918f, -0.619731f, 0.649249f, 0.000000f, 
    -0.749519f, 0.143716f, 0.646195f, 0.000000f, 
    -0.493775f, -0.771544f, -0.401133f, 0.000000f, 
    -0.936145f, -1.967434f, 1.996971f, 1.000000f, 
};

// Mesh #33 Tris:96 Verts:126
MODELVERT g_tmesh33[] = 
{
    { {0.037650f, -0.169680f, 0.124915f}, {0.987881f, -0.132022f, 0.081619f}, {0.303851f, 0.234286f} },
    { {0.037388f, -0.130415f, 0.014524f}, {0.975095f, -0.101427f, -0.197237f}, {0.328516f, 0.319571f} },
    { {0.044909f, -0.076246f, 0.006146f}, {0.992219f, -0.074699f, -0.099610f}, {0.362543f, 0.326044f} },
    { {-0.047699f, -0.023054f, 0.133574f}, {-0.993320f, 0.042028f, 0.107464f}, {0.324201f, 0.227596f} },
    { {-0.047598f, -0.021386f, 0.005582f}, {-0.965402f, 0.219547f, -0.140703f}, {0.323153f, 0.326479f} },
    { {-0.047716f, -0.130246f, 0.014094f}, {-0.994373f, -0.041688f, -0.097388f}, {0.391534f, 0.319903f} },
    { {-0.042942f, -0.168842f, 0.125762f}, {-0.956423f, -0.238993f, 0.167742f}, {0.415779f, 0.233632f} },
    { {0.044999f, -0.077182f, 0.133335f}, {0.996216f, -0.042230f, 0.075968f}, {0.361955f, 0.227781f} },
    { {0.030384f, -0.022987f, -0.008379f}, {0.317334f, 0.108011f, -0.942143f}, {0.316933f, 0.241533f} },
    { {-0.000841f, -0.075985f, -0.008392f}, {-0.000145f, -0.075145f, -0.997173f}, {0.355923f, 0.274481f} },
    { {0.003717f, -0.022987f, -0.008379f}, {0.035888f, 0.299913f, -0.953291f}, {0.355923f, 0.241533f} },
    { {0.030474f, -0.009398f, 0.133335f}, {0.154305f, 0.985964f, 0.063755f}, {0.316801f, 0.227781f} },
    { {0.030384f, -0.008462f, 0.006146f}, {0.466494f, 0.877549f, -0.110866f}, {0.316933f, 0.326044f} },
    { {0.002061f, -0.005436f, 0.003230f}, {0.015275f, 0.999294f, -0.034318f}, {0.355923f, 0.326044f} },
    { {0.030384f, -0.076246f, -0.008379f}, {0.377851f, -0.116526f, -0.918504f}, {0.316933f, 0.274481f} },
    { {0.022863f, -0.130415f, -0.000001f}, {0.203387f, -0.192181f, -0.960052f}, {0.327930f, 0.307992f} },
    { {-0.018243f, -0.182874f, 0.124915f}, {-0.130303f, -0.989203f, 0.067074f}, {0.332125f, 0.234286f} },
    { {-0.018243f, -0.182874f, 0.014524f}, {-0.452403f, -0.886931f, -0.093196f}, {0.332125f, 0.319571f} },
    { {0.027482f, -0.182874f, 0.014524f}, {0.141763f, -0.945816f, -0.292122f}, {0.398980f, 0.319571f} },
    { {0.003807f, -0.009398f, 0.133335f}, {0.059632f, 0.994361f, 0.087697f}, {0.355791f, 0.227781f} },
    { {-0.027508f, -0.008201f, 0.006134f}, {0.008759f, 0.999872f, 0.013416f}, {0.401578f, 0.326053f} },
    { {-0.031621f, -0.005850f, 0.133983f}, {0.099364f, 0.994937f, -0.015098f}, {0.401446f, 0.227791f} },
    { {-0.030486f, -0.077229f, 0.151714f}, {-0.425062f, -0.090586f, 0.900620f}, {0.358231f, 0.213582f} },
    { {-0.004558f, -0.130154f, 0.139428f}, {0.074100f, -0.197189f, 0.977561f}, {0.358799f, 0.307992f} },
    { {0.030474f, -0.077182f, 0.147860f}, {0.281288f, -0.122930f, 0.951717f}, {0.403355f, 0.275060f} },
    { {-0.000751f, -0.076921f, 0.147848f}, {-0.001338f, -0.113624f, 0.993523f}, {0.364365f, 0.275060f} },
    { {0.027482f, -0.182874f, 0.124915f}, {0.308852f, -0.745702f, 0.590372f}, {0.398980f, 0.234286f} },
    { {0.026551f, 0.021767f, 0.117521f}, {0.389644f, 0.889579f, 0.238384f}, {0.322538f, 0.239999f} },
    { {0.026551f, 0.021767f, 0.021529f}, {0.733362f, 0.636450f, -0.238978f}, {0.322538f, 0.314159f} },
    { {-0.017453f, 0.022535f, 0.021529f}, {-0.357770f, 0.902713f, -0.238978f}, {0.386877f, 0.314159f} },
    { {0.040394f, -0.020010f, 0.021529f}, {0.306269f, -0.928747f, -0.208875f}, {0.417860f, 0.314159f} },
    { {0.004007f, -0.008885f, 0.124767f}, {-0.016798f, -0.962364f, 0.271243f}, {0.364657f, 0.234401f} },
    { {0.004007f, -0.008885f, 0.014702f}, {-0.015339f, -0.878779f, -0.476982f}, {0.364657f, 0.319433f} },
    { {0.030474f, -0.077182f, 0.147860f}, {0.281288f, -0.122930f, 0.951717f}, {0.361955f, 0.216559f} },
    { {0.044999f, -0.023923f, 0.133335f}, {0.943568f, 0.301420f, 0.137204f}, {0.395410f, 0.227781f} },
    { {0.030474f, -0.023923f, 0.147860f}, {0.321818f, 0.298197f, 0.898617f}, {0.395410f, 0.216559f} },
    { {0.030384f, -0.008462f, 0.006146f}, {0.466494f, 0.877549f, -0.110866f}, {0.405122f, 0.326044f} },
    { {0.030474f, -0.009398f, 0.133335f}, {0.154305f, 0.985964f, 0.063755f}, {0.404534f, 0.227781f} },
    { {-0.000841f, -0.075985f, -0.008392f}, {0.129920f, -0.081562f, -0.988164f}, {0.365017f, 0.274511f} },
    { {-0.030542f, -0.076095f, -0.012287f}, {-0.312877f, -0.090125f, -0.945508f}, {0.406015f, 0.274388f} },
    { {0.003717f, -0.022987f, -0.008379f}, {0.122264f, 0.094923f, -0.987948f}, {0.365011f, 0.240985f} },
    { {-0.031621f, -0.005850f, 0.133983f}, {-0.557038f, 0.815081f, 0.159222f}, {0.313394f, 0.227281f} },
    { {-0.027508f, -0.008201f, 0.006134f}, {-0.491288f, 0.853262f, -0.174874f}, {0.312721f, 0.326572f} },
    { {-0.022802f, -0.168087f, 0.006325f}, {-0.353278f, -0.377398f, -0.856017f}, {0.388032f, 0.331459f} },
    { {0.000000f, -0.130415f, -0.000001f}, {0.000001f, -0.157783f, -0.987474f}, {0.361357f, 0.307992f} },
    { {0.000000f, -0.130415f, -0.000001f}, {0.155986f, -0.169465f, -0.973113f}, {0.370456f, 0.308175f} },
    { {-0.026014f, -0.168671f, 0.002551f}, {-0.291075f, -0.188263f, -0.937994f}, {0.399393f, 0.331659f} },
    { {-0.002410f, -0.022261f, 0.151770f}, {0.073168f, 0.116944f, 0.990440f}, {0.364365f, 0.242112f} },
    { {0.030474f, -0.023923f, 0.147860f}, {0.321818f, 0.298197f, 0.898617f}, {0.403355f, 0.242112f} },
    { {0.003807f, -0.009398f, 0.133335f}, {0.091106f, 0.802004f, 0.590330f}, {0.355298f, 0.231093f} },
    { {-0.031621f, -0.005850f, 0.133983f}, {-0.557038f, 0.815081f, 0.159222f}, {0.312565f, 0.230931f} },
    { {-0.002410f, -0.022261f, 0.151770f}, {0.021694f, 0.383331f, 0.923356f}, {0.355275f, 0.241083f} },
    { {0.040394f, -0.020010f, 0.117521f}, {0.977898f, -0.099048f, 0.184133f}, {0.397868f, 0.239999f} },
    { {0.026551f, 0.021767f, 0.021529f}, {0.733362f, 0.636450f, -0.238978f}, {0.424111f, 0.314159f} },
    { {0.026551f, 0.021767f, 0.117521f}, {0.389644f, 0.889579f, 0.238384f}, {0.424111f, 0.239999f} },
    { {-0.017453f, 0.022535f, 0.117521f}, {-0.710417f, 0.662178f, 0.238385f}, {0.295564f, 0.239999f} },
    { {-0.032746f, -0.018733f, 0.021529f}, {-0.793619f, -0.582533f, -0.175567f}, {0.321487f, 0.314159f} },
    { {-0.032746f, -0.018733f, 0.117521f}, {-0.812299f, -0.477614f, 0.334745f}, {0.321487f, 0.239999f} },
    { {0.026551f, 0.021767f, 0.021529f}, {0.733362f, 0.636450f, -0.238978f}, {0.322538f, 0.213846f} },
    { {0.004007f, -0.008885f, 0.014702f}, {-0.015339f, -0.878779f, -0.476982f}, {0.355499f, 0.232809f} },
    { {-0.017453f, 0.022535f, 0.021529f}, {-0.357770f, 0.902713f, -0.238978f}, {0.386877f, 0.213371f} },
    { {-0.017453f, 0.022535f, 0.021529f}, {-0.357770f, 0.902713f, -0.238978f}, {0.295564f, 0.314159f} },
    { {-0.030486f, -0.077229f, 0.151714f}, {-0.425062f, -0.090586f, 0.900620f}, {0.314225f, 0.275089f} },
    { {-0.006221f, -0.130715f, 0.143509f}, {0.148076f, -0.148396f, 0.977779f}, {0.349703f, 0.308178f} },
    { {-0.000751f, -0.076921f, 0.147848f}, {0.131451f, -0.059466f, 0.989537f}, {0.355270f, 0.274983f} },
    { {-0.030445f, -0.023104f, 0.151722f}, {-0.218854f, 0.133706f, 0.966553f}, {0.314284f, 0.241605f} },
    { {-0.030342f, -0.021459f, -0.012180f}, {-0.230599f, 0.305351f, -0.923897f}, {0.405721f, 0.240587f} },
    { {0.002061f, -0.005436f, 0.003230f}, {-0.003431f, 0.696778f, -0.717279f}, {0.365009f, 0.230513f} },
    { {0.030384f, -0.008462f, 0.006146f}, {0.466494f, 0.877549f, -0.110866f}, {0.316933f, 0.232547f} },
    { {0.002061f, -0.005436f, 0.003230f}, {0.015275f, 0.999294f, -0.034318f}, {0.355923f, 0.232547f} },
    { {-0.042942f, -0.168842f, 0.125762f}, {-0.956423f, -0.238993f, 0.167742f}, {0.296012f, 0.233632f} },
    { {-0.043071f, -0.168589f, 0.014251f}, {-0.840361f, -0.529426f, -0.116196f}, {0.295823f, 0.319782f} },
    { {-0.022802f, -0.168087f, 0.006325f}, {0.045017f, -0.998697f, -0.024052f}, {0.325460f, 0.325905f} },
    { {-0.030542f, -0.076095f, -0.012287f}, {-0.312877f, -0.090125f, -0.945508f}, {0.357519f, 0.340284f} },
    { {-0.026014f, -0.168671f, 0.002551f}, {-0.291075f, -0.188263f, -0.937994f}, {0.415671f, 0.328821f} },
    { {0.004007f, -0.008885f, 0.124767f}, {-0.016798f, -0.962364f, 0.271243f}, {0.364657f, 0.232809f} },
    { {0.040394f, -0.020010f, 0.117521f}, {0.977898f, -0.099048f, 0.184133f}, {0.401394f, 0.237561f} },
    { {0.026551f, 0.021767f, 0.117521f}, {0.389644f, 0.889579f, 0.238384f}, {0.397619f, 0.213846f} },
    { {0.040394f, -0.020010f, 0.117521f}, {0.977898f, -0.099048f, 0.184133f}, {0.417860f, 0.239999f} },
    { {-0.017453f, 0.022535f, 0.117521f}, {-0.710417f, 0.662178f, 0.238385f}, {0.333280f, 0.213371f} },
    { {-0.017453f, 0.022535f, 0.117521f}, {-0.710417f, 0.662178f, 0.238385f}, {0.386877f, 0.239999f} },
    { {0.040394f, -0.020010f, 0.021529f}, {0.306269f, -0.928747f, -0.208875f}, {0.318763f, 0.237561f} },
    { {0.040394f, -0.020010f, 0.021529f}, {0.306269f, -0.928747f, -0.208875f}, {0.397868f, 0.314159f} },
    { {-0.025297f, -0.168827f, 0.137052f}, {-0.222696f, -0.625152f, 0.748058f}, {0.321812f, 0.224910f} },
    { {-0.025297f, -0.168827f, 0.137052f}, {-0.222696f, -0.625152f, 0.748058f}, {0.415770f, 0.224910f} },
    { {0.044909f, -0.022987f, 0.006146f}, {0.990446f, 0.124467f, -0.059372f}, {0.395998f, 0.326044f} },
    { {0.030384f, -0.076246f, -0.008379f}, {0.377851f, -0.116526f, -0.918504f}, {0.362543f, 0.337265f} },
    { {0.027482f, -0.182874f, 0.124915f}, {0.308852f, -0.745702f, 0.590372f}, {0.398980f, 0.340445f} },
    { {-0.027508f, -0.008201f, 0.006134f}, {-0.491288f, 0.853262f, -0.174874f}, {0.407458f, 0.230269f} },
    { {-0.030445f, -0.023104f, 0.151722f}, {-0.218854f, 0.133706f, 0.966553f}, {0.324232f, 0.213576f} },
    { {0.003807f, -0.009398f, 0.133335f}, {0.059632f, 0.994361f, 0.087697f}, {0.364365f, 0.233126f} },
    { {-0.018243f, -0.168348f, 0.133102f}, {0.098949f, -0.292314f, 0.951190f}, {0.332125f, 0.331459f} },
    { {-0.025297f, -0.168827f, 0.137052f}, {-0.222696f, -0.625152f, 0.748058f}, {0.321812f, 0.331756f} },
    { {-0.032746f, -0.018733f, 0.117521f}, {-0.812299f, -0.477614f, 0.334745f}, {0.327551f, 0.237016f} },
    { {-0.032746f, -0.018733f, 0.117521f}, {-0.812299f, -0.477614f, 0.334745f}, {0.310919f, 0.239999f} },
    { {-0.032746f, -0.018733f, 0.021529f}, {-0.793619f, -0.582533f, -0.175567f}, {0.310919f, 0.314159f} },
    { {-0.018243f, -0.182874f, 0.124915f}, {-0.130303f, -0.989203f, 0.067074f}, {0.332125f, 0.340445f} },
    { {-0.025297f, -0.168827f, 0.137052f}, {-0.920117f, -0.391285f, 0.016750f}, {0.415469f, 0.234286f} },
    { {-0.018243f, -0.182874f, 0.014524f}, {-0.452403f, -0.886931f, -0.093196f}, {0.424593f, 0.319571f} },
    { {-0.018243f, -0.182874f, 0.124915f}, {-0.130303f, -0.989203f, 0.067074f}, {0.424593f, 0.234286f} },
    { {0.030384f, -0.022987f, -0.008379f}, {0.317334f, 0.108011f, -0.942143f}, {0.395998f, 0.337265f} },
    { {0.022863f, -0.130415f, -0.000001f}, {0.203387f, -0.192181f, -0.960052f}, {0.328516f, 0.330792f} },
    { {0.027482f, -0.182874f, 0.124915f}, {0.308852f, -0.745702f, 0.590372f}, {0.295564f, 0.234286f} },
    { {0.027482f, -0.182874f, 0.014524f}, {0.141763f, -0.945816f, -0.292122f}, {0.295564f, 0.319571f} },
    { {0.037650f, -0.169680f, 0.014524f}, {0.950033f, -0.279916f, -0.138146f}, {0.303851f, 0.319571f} },
    { {-0.030342f, -0.021459f, -0.012180f}, {-0.230599f, 0.305351f, -0.923897f}, {0.323199f, 0.340201f} },
    { {-0.032746f, -0.018733f, 0.021529f}, {-0.793619f, -0.582533f, -0.175567f}, {0.392606f, 0.237016f} },
    { {0.027482f, -0.182874f, 0.124915f}, {0.308852f, -0.745702f, 0.590372f}, {0.304407f, 0.227962f} },
    { {-0.022802f, -0.168087f, 0.006325f}, {-0.353278f, -0.377398f, -0.856017f}, {0.415469f, 0.325896f} },
    { {-0.018243f, -0.182874f, 0.014524f}, {-0.452403f, -0.886931f, -0.093196f}, {0.388032f, 0.340445f} },
    { {0.027482f, -0.182874f, 0.014524f}, {0.141763f, -0.945816f, -0.292122f}, {0.321176f, 0.340445f} },
    { {0.030474f, -0.009398f, 0.133335f}, {0.154305f, 0.985964f, 0.063755f}, {0.403355f, 0.233126f} },
    { {-0.018243f, -0.168348f, 0.133102f}, {0.098949f, -0.292314f, 0.951190f}, {0.415469f, 0.227962f} },
    { {-0.006221f, -0.130715f, 0.143509f}, {0.472650f, -0.371933f, 0.798917f}, {0.328164f, 0.219911f} },
    { {-0.025297f, -0.168827f, 0.137052f}, {0.472650f, -0.371933f, 0.798917f}, {0.304223f, 0.224900f} },
    { {-0.018243f, -0.168348f, 0.133102f}, {0.472650f, -0.371933f, 0.798917f}, {0.304688f, 0.227962f} },
    { {0.037650f, -0.169680f, 0.014524f}, {0.950033f, -0.279916f, -0.138146f}, {0.306310f, 0.332283f} },
    { {0.000000f, -0.130415f, -0.000001f}, {0.155986f, -0.169465f, -0.973113f}, {0.328680f, 0.330802f} },
    { {-0.022802f, -0.168087f, 0.006325f}, {0.045017f, -0.998697f, -0.024052f}, {0.304852f, 0.325905f} },
    { {-0.026014f, -0.168671f, 0.002551f}, {-0.291075f, -0.188263f, -0.937994f}, {0.304485f, 0.328821f} },
    { {-0.026014f, -0.168671f, 0.002551f}, {-0.291075f, -0.188263f, -0.937994f}, {0.320763f, 0.328821f} },
    { {-0.043071f, -0.168589f, 0.014251f}, {-0.840361f, -0.529426f, -0.116196f}, {0.415620f, 0.319782f} },
    { {-0.018243f, -0.168348f, 0.133102f}, {0.878422f, -0.365694f, 0.307640f}, {0.304852f, 0.227971f} },
    { {-0.004558f, -0.130154f, 0.139428f}, {0.912004f, -0.229338f, 0.340077f}, {0.328680f, 0.223074f} },
    { {-0.006221f, -0.130715f, 0.143509f}, {0.148076f, -0.148396f, 0.977779f}, {0.328328f, 0.219921f} },
    { {-0.000751f, -0.076921f, 0.147848f}, {0.131451f, -0.059466f, 0.989537f}, {0.362119f, 0.216569f} },
};

WORD g_tind33[] = 
{
    0, 1, 2,    3, 4, 5,    3, 5, 6,    0, 2, 7,    8, 9, 10,
    11, 12, 13,    14, 15, 9,    16, 17, 18,    19, 20, 21,    22, 3, 6,
    23, 24, 25,    16, 18, 26,    27, 28, 29,    30, 31, 32,    33, 34, 35,
    34, 36, 37,    38, 39, 40,    41, 42, 4,    15, 43, 44,    45, 46, 39,
    47, 24, 48,    49, 50, 51,    52, 53, 54,    55, 56, 57,    58, 59, 60,
    55, 61, 56,    62, 63, 64,    51, 50, 65,    40, 66, 67,    68, 10, 69,
    70, 71, 72,    5, 73, 74,    75, 76, 77,    31, 30, 78,    75, 77, 79,
    27, 29, 80,    81, 59, 58,    52, 82, 53,    72, 83, 70,    22, 6, 84,
    34, 85, 36,    1, 86, 2,    33, 0, 7,    23, 87, 24,    67, 66, 88,
    11, 13, 20,    41, 4, 3,    89, 41, 3,    48, 90, 47,    11, 20, 19,
    91, 87, 23,    62, 92, 63,    75, 79, 93,    94, 95, 31,    4, 73, 5,
    40, 39, 66,    91, 96, 87,    97, 98, 99,    45, 39, 38,    15, 44, 9,
    68, 8, 10,    85, 100, 36,    1, 101, 86,    102, 103, 104,    65, 62, 64,
    89, 3, 22,    4, 105, 73,    42, 105, 4,    32, 31, 95,    60, 59, 106,
    107, 0, 33,    102, 104, 0,    25, 24, 47,    65, 64, 51,    97, 108, 98,
    109, 43, 110,    48, 111, 90,    35, 34, 37,    112, 97, 99,    113, 114, 115,
    7, 85, 34,    33, 7, 34,    8, 14, 9,    2, 86, 100,    15, 110, 43,
    116, 110, 15,    2, 100, 85,    7, 2, 85,    117, 118, 119,    71, 120, 72,
    5, 74, 121,    6, 5, 121,    122, 123, 124,    125, 124, 123,    104, 101, 1,
    0, 104, 1,
};

D3DMATRIX g_tmat34 = 
{
    -0.428643f, -0.185405f, 0.884246f, 0.000000f, 
    -0.756606f, 0.608561f, -0.239169f, 0.000000f, 
    -0.493775f, -0.771543f, -0.401133f, 0.000000f, 
    -0.800250f, -1.997850f, 1.875649f, 1.000000f, 
};

// Mesh #34 Tris:74 Verts:96
MODELVERT g_tmesh34[] = 
{
    { {0.028660f, -0.022377f, 0.099933f}, {0.956107f, 0.266115f, 0.122645f}, {0.399661f, 0.228668f} },
    { {0.038275f, -0.106688f, 0.021795f}, {0.991157f, 0.034084f, -0.128240f}, {0.330727f, 0.313958f} },
    { {0.028660f, -0.022377f, 0.011621f}, {0.958951f, 0.260729f, -0.111507f}, {0.399661f, 0.325064f} },
    { {-0.039503f, -0.021818f, 0.100087f}, {-0.992702f, -0.054488f, 0.107583f}, {0.320038f, 0.228500f} },
    { {-0.039421f, -0.021293f, 0.011199f}, {-0.984197f, 0.087556f, -0.153916f}, {0.319608f, 0.325524f} },
    { {-0.027479f, -0.106703f, 0.020045f}, {-0.966262f, -0.233486f, -0.108728f}, {0.389442f, 0.315868f} },
    { {0.038374f, -0.107393f, 0.094738f}, {0.977200f, 0.010134f, 0.212080f}, {0.330151f, 0.234339f} },
    { {-0.027318f, -0.107395f, 0.096048f}, {-0.896232f, -0.389855f, 0.211615f}, {0.390008f, 0.232909f} },
    { {-0.017842f, -0.107867f, 0.095511f}, {-0.999341f, -0.022808f, 0.028235f}, {0.390394f, 0.233495f} },
    { {-0.010363f, -0.108277f, 0.009201f}, {-0.667888f, -0.135024f, -0.731911f}, {0.391887f, 0.327691f} },
    { {-0.014326f, -0.136946f, 0.026712f}, {-0.974534f, -0.191014f, -0.117463f}, {0.414170f, 0.308592f} },
    { {0.024591f, -0.109598f, 0.010117f}, {0.271772f, -0.184858f, -0.944440f}, {0.319766f, 0.308158f} },
    { {-0.002367f, -0.139351f, 0.015699f}, {0.018588f, -0.484726f, -0.874468f}, {0.367105f, 0.332117f} },
    { {-0.010363f, -0.108277f, 0.009201f}, {-0.667888f, -0.135024f, -0.731911f}, {0.373424f, 0.308235f} },
    { {-0.014171f, -0.138048f, 0.092316f}, {-0.890795f, -0.422420f, 0.167467f}, {0.415071f, 0.236982f} },
    { {-0.020090f, -0.065898f, 0.113666f}, {0.086695f, -0.076436f, 0.993298f}, {0.336170f, 0.273605f} },
    { {0.024513f, -0.109038f, 0.106454f}, {0.316550f, -0.064886f, 0.946354f}, {0.400252f, 0.307707f} },
    { {0.017040f, -0.022377f, 0.111553f}, {0.318516f, 0.013970f, 0.947815f}, {0.387131f, 0.237925f} },
    { {0.009955f, -0.007219f, 0.100082f}, {-0.014809f, 0.996575f, 0.081360f}, {0.345467f, 0.228506f} },
    { {-0.025766f, -0.007715f, 0.011430f}, {-0.177256f, 0.981035f, -0.078431f}, {0.408192f, 0.325272f} },
    { {-0.026225f, -0.007856f, 0.100281f}, {-0.358353f, 0.916151f, 0.179586f}, {0.408998f, 0.228288f} },
    { {-0.026229f, -0.021518f, 0.113886f}, {-0.192763f, 0.201113f, 0.960414f}, {0.311151f, 0.237233f} },
    { {-0.020090f, -0.065898f, 0.113666f}, {-0.454238f, -0.121498f, 0.882556f}, {0.321931f, 0.272969f} },
    { {0.017040f, -0.022377f, 0.111553f}, {0.044219f, 0.313191f, 0.948660f}, {0.374693f, 0.236478f} },
    { {0.016928f, 0.007972f, 0.092014f}, {0.374339f, 0.887654f, 0.268219f}, {0.333223f, 0.237312f} },
    { {-0.015914f, 0.008102f, 0.015460f}, {-0.341144f, 0.853439f, -0.394034f}, {0.390892f, 0.320873f} },
    { {-0.015915f, 0.008115f, 0.092014f}, {-0.712975f, 0.646470f, 0.271559f}, {0.390895f, 0.237312f} },
    { {-0.026924f, -0.022829f, 0.092014f}, {-0.404238f, -0.904139f, 0.138292f}, {0.309930f, 0.237312f} },
    { {0.027668f, -0.023080f, 0.015460f}, {0.271731f, -0.910031f, -0.313059f}, {0.405793f, 0.320873f} },
    { {0.000769f, -0.022686f, 0.097421f}, {-0.003661f, -0.838983f, 0.544146f}, {0.358559f, 0.231410f} },
    { {0.027666f, -0.023067f, 0.092014f}, {0.983332f, -0.071758f, 0.167060f}, {0.399098f, 0.237312f} },
    { {0.027668f, -0.023080f, 0.015460f}, {0.271731f, -0.910031f, -0.313059f}, {0.399087f, 0.320873f} },
    { {0.016930f, 0.007959f, 0.015460f}, {0.743733f, 0.649286f, -0.159025f}, {0.424465f, 0.320873f} },
    { {-0.015915f, 0.008115f, 0.092014f}, {-0.712975f, 0.646470f, 0.271559f}, {0.295564f, 0.237312f} },
    { {-0.015914f, 0.008102f, 0.015460f}, {-0.341144f, 0.853439f, -0.394034f}, {0.295574f, 0.320873f} },
    { {-0.026922f, -0.022842f, 0.015460f}, {-0.844734f, -0.442898f, -0.300443f}, {0.320875f, 0.320873f} },
    { {0.010000f, -0.007261f, 0.011117f}, {-0.000238f, 0.965664f, -0.259794f}, {0.345387f, 0.325614f} },
    { {0.017040f, -0.022377f, 0.000000f}, {0.059997f, 0.188223f, -0.980292f}, {0.345437f, 0.236686f} },
    { {-0.019875f, -0.067259f, -0.002231f}, {-0.493746f, -0.138069f, -0.858575f}, {0.397848f, 0.274065f} },
    { {-0.025886f, -0.021143f, -0.002390f}, {-0.161189f, 0.268120f, -0.949805f}, {0.408403f, 0.236931f} },
    { {-0.002561f, -0.149597f, 0.090944f}, {0.119101f, -0.991419f, 0.053873f}, {0.295564f, 0.238739f} },
    { {-0.002747f, -0.148271f, 0.029496f}, {-0.165145f, -0.979830f, -0.112520f}, {0.296680f, 0.305025f} },
    { {0.033380f, -0.136797f, 0.028121f}, {0.560508f, -0.792601f, -0.240029f}, {0.306109f, 0.307053f} },
    { {-0.002367f, -0.139351f, 0.015699f}, {0.018588f, -0.484726f, -0.874468f}, {0.303181f, 0.319853f} },
    { {0.024591f, -0.109598f, 0.010117f}, {0.271772f, -0.184858f, -0.944440f}, {0.328348f, 0.326706f} },
    { {0.033551f, -0.138012f, 0.091622f}, {0.832410f, -0.543602f, 0.107662f}, {0.305115f, 0.237740f} },
    { {0.024513f, -0.109038f, 0.106454f}, {0.316550f, -0.064886f, 0.946354f}, {0.328805f, 0.221551f} },
    { {-0.015914f, 0.008102f, 0.015460f}, {-0.341144f, 0.853439f, -0.394034f}, {0.390892f, 0.213381f} },
    { {0.027668f, -0.023080f, 0.015460f}, {0.271731f, -0.910031f, -0.313059f}, {0.329179f, 0.236510f} },
    { {-0.026922f, -0.022842f, 0.015460f}, {-0.844734f, -0.442898f, -0.300443f}, {0.395370f, 0.236378f} },
    { {-0.026922f, -0.022842f, 0.015460f}, {-0.844734f, -0.442898f, -0.300443f}, {0.309934f, 0.320873f} },
    { {0.010000f, -0.007261f, 0.011117f}, {0.629686f, 0.775885f, -0.038706f}, {0.409162f, 0.325064f} },
    { {0.010000f, -0.007261f, 0.011117f}, {-0.000238f, 0.965664f, -0.259794f}, {0.345387f, 0.225753f} },
    { {0.000769f, -0.022686f, 0.097421f}, {-0.003661f, -0.838983f, 0.544146f}, {0.358559f, 0.238173f} },
    { {0.016928f, 0.007972f, 0.092014f}, {0.374339f, 0.887654f, 0.268219f}, {0.386934f, 0.213486f} },
    { {-0.015915f, 0.008115f, 0.092014f}, {-0.712975f, 0.646470f, 0.271559f}, {0.329261f, 0.213371f} },
    { {0.016928f, 0.007972f, 0.092014f}, {0.374339f, 0.887654f, 0.268219f}, {0.424476f, 0.237312f} },
    { {-0.006055f, -0.109061f, 0.106899f}, {-0.184627f, -0.143234f, 0.972315f}, {0.391370f, 0.221065f} },
    { {-0.002383f, -0.139242f, 0.103704f}, {-0.372816f, -0.367480f, 0.852037f}, {0.416047f, 0.224553f} },
    { {0.013316f, -0.140325f, 0.103361f}, {0.286278f, -0.348830f, 0.892392f}, {0.303224f, 0.224926f} },
    { {-0.019875f, -0.067259f, -0.002231f}, {-0.493746f, -0.138069f, -0.858575f}, {0.357191f, 0.340184f} },
    { {-0.027318f, -0.107395f, 0.096048f}, {-0.896232f, -0.389855f, 0.211615f}, {0.309239f, 0.232909f} },
    { {-0.027479f, -0.106703f, 0.020045f}, {-0.966262f, -0.233486f, -0.108728f}, {0.308955f, 0.315868f} },
    { {-0.010363f, -0.108277f, 0.009201f}, {-0.243211f, -0.931805f, -0.269420f}, {0.339010f, 0.327705f} },
    { {-0.020090f, -0.065898f, 0.113666f}, {-0.454238f, -0.121498f, 0.882556f}, {0.356079f, 0.213678f} },
    { {-0.006055f, -0.109061f, 0.106899f}, {-0.184627f, -0.143234f, 0.972315f}, {0.346577f, 0.307726f} },
    { {-0.026924f, -0.022829f, 0.092014f}, {-0.404238f, -0.904139f, 0.138292f}, {0.324783f, 0.236367f} },
    { {-0.026924f, -0.022829f, 0.092014f}, {-0.404238f, -0.904139f, 0.138292f}, {0.320864f, 0.237312f} },
    { {0.016930f, 0.007959f, 0.015460f}, {0.743733f, 0.649286f, -0.159025f}, {0.333219f, 0.213497f} },
    { {0.016930f, 0.007959f, 0.015460f}, {0.743733f, 0.649286f, -0.159025f}, {0.333219f, 0.320873f} },
    { {0.009955f, -0.007219f, 0.100082f}, {0.628287f, 0.774592f, 0.072543f}, {0.409162f, 0.228668f} },
    { {0.009955f, -0.007219f, 0.100082f}, {-0.014809f, 0.996575f, 0.081360f}, {0.374689f, 0.225719f} },
    { {-0.026225f, -0.007856f, 0.100281f}, {-0.358353f, 0.916151f, 0.179586f}, {0.311158f, 0.226231f} },
    { {0.017040f, -0.022377f, 0.000000f}, {0.433262f, -0.030738f, -0.900744f}, {0.333026f, 0.237925f} },
    { {-0.019875f, -0.067259f, -0.002231f}, {0.132115f, -0.147135f, -0.980253f}, {0.383649f, 0.274707f} },
    { {0.017040f, -0.022377f, 0.000000f}, {0.433262f, -0.030738f, -0.900744f}, {0.399661f, 0.337748f} },
    { {-0.026225f, -0.007856f, 0.100281f}, {-0.358353f, 0.916151f, 0.179586f}, {0.308622f, 0.228288f} },
    { {-0.026229f, -0.021518f, 0.113886f}, {-0.192763f, 0.201113f, 0.960414f}, {0.319793f, 0.213438f} },
    { {-0.010363f, -0.108277f, 0.009201f}, {-0.243211f, -0.931805f, -0.269420f}, {0.391587f, 0.329707f} },
    { {-0.006055f, -0.109061f, 0.106899f}, {-0.444439f, -0.375608f, 0.813260f}, {0.390980f, 0.219064f} },
    { {-0.002367f, -0.139351f, 0.015699f}, {0.018588f, -0.484726f, -0.874468f}, {0.416136f, 0.320612f} },
    { {-0.025886f, -0.021143f, -0.002390f}, {-0.161189f, 0.268120f, -0.949805f}, {0.319486f, 0.340357f} },
    { {-0.025766f, -0.007715f, 0.011430f}, {-0.177256f, 0.981035f, -0.078431f}, {0.308507f, 0.325272f} },
    { {0.017040f, -0.022377f, 0.111553f}, {0.318516f, 0.013970f, 0.947815f}, {0.399661f, 0.215984f} },
    { {0.013316f, -0.140325f, 0.103361f}, {0.286278f, -0.348830f, 0.892392f}, {0.380591f, 0.332901f} },
    { {-0.002747f, -0.148271f, 0.029496f}, {-0.165145f, -0.979830f, -0.112520f}, {0.423429f, 0.305552f} },
    { {-0.002561f, -0.149597f, 0.090944f}, {0.119101f, -0.991419f, 0.053873f}, {0.424513f, 0.238480f} },
    { {0.033551f, -0.138012f, 0.091622f}, {0.832410f, -0.543602f, 0.107662f}, {0.416123f, 0.331038f} },
    { {0.038374f, -0.107393f, 0.094738f}, {0.977200f, 0.010134f, 0.212080f}, {0.424593f, 0.306382f} },
    { {-0.025766f, -0.007715f, 0.011430f}, {-0.177256f, 0.981035f, -0.078431f}, {0.408192f, 0.226118f} },
    { {-0.017842f, -0.107867f, 0.095511f}, {-0.050036f, -0.998731f, -0.005807f}, {0.318155f, 0.233509f} },
    { {-0.006055f, -0.109061f, 0.106899f}, {-0.444439f, -0.375608f, 0.813260f}, {0.331298f, 0.219064f} },
    { {-0.002383f, -0.139242f, 0.103704f}, {-0.372816f, -0.367480f, 0.852037f}, {0.353024f, 0.332029f} },
    { {-0.002561f, -0.149597f, 0.090944f}, {0.119101f, -0.991419f, 0.053873f}, {0.352712f, 0.340367f} },
    { {0.027666f, -0.023067f, 0.092014f}, {0.983332f, -0.071758f, 0.167060f}, {0.390975f, 0.236500f} },
    { {0.027666f, -0.023067f, 0.092014f}, {0.983332f, -0.071758f, 0.167060f}, {0.405790f, 0.237312f} },
};

WORD g_tind34[] = 
{
    0, 1, 2,    3, 4, 5,    6, 1, 0,    3, 5, 7,    8, 9, 10,
    11, 12, 13,    8, 10, 14,    15, 16, 17,    18, 19, 20,    21, 22, 23,
    24, 25, 26,    27, 28, 29,    30, 31, 32,    33, 34, 35,    18, 36, 19,
    37, 38, 39,    40, 41, 42,    42, 43, 44,    40, 42, 45,    46, 6, 0,
    47, 48, 49,    27, 50, 28,    0, 2, 51,    52, 37, 39,    53, 54, 55,
    30, 32, 56,    57, 14, 58,    59, 40, 45,    4, 60, 5,    61, 62, 63,
    64, 3, 7,    15, 65, 16,    53, 55, 66,    33, 35, 67,    68, 48, 47,
    24, 69, 25,    0, 51, 70,    23, 71, 72,    73, 11, 74,    1, 44, 75,
    76, 4, 3,    77, 3, 64,    5, 60, 78,    11, 13, 74,    57, 8, 14,
    64, 7, 79,    9, 80, 10,    41, 43, 42,    4, 81, 60,    76, 82, 4,
    83, 0, 70,    46, 0, 83,    59, 6, 46,    65, 84, 16,    42, 44, 1,
    45, 42, 1,    2, 75, 51,    1, 75, 2,    23, 72, 21,    77, 76, 3,
    14, 85, 86,    58, 14, 86,    10, 80, 85,    14, 10, 85,    45, 1, 6,
    84, 87, 88,    52, 39, 89,    82, 81, 4,    63, 90, 61,    91, 61, 90,
    92, 93, 84,    65, 92, 84,    53, 94, 54,    29, 28, 95,
};

D3DMATRIX g_tmat35 = 
{
    -0.113584f, 0.988803f, 0.096792f, 0.000000f, 
    0.930753f, 0.139981f, -0.337794f, 0.000000f, 
    -0.347561f, 0.051721f, -0.936230f, 0.000000f, 
    -0.516232f, -2.325130f, 3.017099f, 1.000000f, 
};

// Mesh #35 Tris:216 Verts:218
MODELVERT g_tmesh35[] = 
{
    { {-0.000000f, 0.000000f, 0.000000f}, {-0.000000f, 0.000000f, 1.000000f}, {0.424593f, 0.276908f} },
    { {-0.210381f, -0.076572f, 0.000000f}, {-0.000000f, 0.000000f, 1.000000f}, {0.424593f, 0.298974f} },
    { {-0.223883f, 0.000000f, 0.000000f}, {-0.000000f, 0.000000f, 1.000000f}, {0.424593f, 0.276908f} },
    { {-0.171504f, -0.143909f, 0.000000f}, {-0.000000f, 0.000000f, 1.000000f}, {0.424593f, 0.318379f} },
    { {-0.111941f, -0.193888f, 0.000000f}, {-0.000000f, 0.000000f, 1.000000f}, {0.424593f, 0.332782f} },
    { {-0.038877f, -0.220481f, 0.000000f}, {-0.000000f, 0.000000f, 1.000000f}, {0.424593f, 0.340445f} },
    { {0.038877f, -0.220481f, 0.000000f}, {-0.000000f, 0.000000f, 1.000000f}, {0.424593f, 0.340445f} },
    { {0.111941f, -0.193888f, 0.000000f}, {-0.000000f, 0.000000f, 1.000000f}, {0.424593f, 0.332782f} },
    { {0.171504f, -0.143909f, 0.000000f}, {-0.000000f, 0.000000f, 1.000000f}, {0.424593f, 0.318379f} },
    { {0.210381f, -0.076572f, 0.000000f}, {-0.000000f, 0.000000f, 1.000000f}, {0.424593f, 0.298974f} },
    { {0.223883f, 0.000000f, 0.000000f}, {-0.000000f, 0.000000f, 1.000000f}, {0.424593f, 0.276908f} },
    { {0.210381f, 0.076572f, 0.000000f}, {-0.000000f, 0.000000f, 1.000000f}, {0.424593f, 0.254842f} },
    { {0.171504f, 0.143909f, 0.000000f}, {-0.000000f, 0.000000f, 1.000000f}, {0.424593f, 0.235437f} },
    { {0.111941f, 0.193888f, 0.000000f}, {-0.000000f, 0.000000f, 1.000000f}, {0.424593f, 0.221034f} },
    { {0.038877f, 0.220481f, 0.000000f}, {-0.000000f, 0.000000f, 1.000000f}, {0.424593f, 0.213371f} },
    { {-0.038877f, 0.220481f, 0.000000f}, {-0.000000f, 0.000000f, 1.000000f}, {0.424593f, 0.213371f} },
    { {-0.111941f, 0.193888f, 0.000000f}, {-0.000000f, 0.000000f, 1.000000f}, {0.424593f, 0.221034f} },
    { {-0.171504f, 0.143909f, 0.000000f}, {-0.000000f, 0.000000f, 1.000000f}, {0.424593f, 0.235437f} },
    { {-0.210381f, 0.076572f, 0.000000f}, {-0.000000f, 0.000000f, 1.000000f}, {0.424593f, 0.254842f} },
    { {-0.223883f, 0.000000f, 0.000000f}, {-0.998277f, -0.058674f, 0.000000f}, {0.424593f, 0.276908f} },
    { {-0.210381f, -0.076572f, -0.018574f}, {-0.958142f, -0.286295f, 0.000000f}, {0.381583f, 0.298974f} },
    { {-0.223883f, 0.000000f, -0.018574f}, {-0.998277f, 0.058674f, -0.000000f}, {0.381583f, 0.276908f} },
    { {-0.210381f, -0.076572f, 0.000000f}, {-0.918006f, -0.396567f, 0.000000f}, {0.424593f, 0.298974f} },
    { {-0.171504f, -0.143909f, -0.018574f}, {-0.802440f, -0.596733f, 0.000000f}, {0.381583f, 0.318379f} },
    { {-0.171504f, -0.143909f, 0.000000f}, {-0.727009f, -0.686628f, 0.000000f}, {0.424593f, 0.318379f} },
    { {-0.111941f, -0.193888f, -0.018574f}, {-0.549952f, -0.835196f, 0.000000f}, {0.381583f, 0.332782f} },
    { {-0.111941f, -0.193888f, 0.000000f}, {-0.448325f, -0.893871f, 0.000000f}, {0.424593f, 0.332782f} },
    { {-0.038877f, -0.220481f, -0.018574f}, {-0.231132f, -0.972922f, 0.000001f}, {0.381583f, 0.340445f} },
    { {-0.038877f, -0.220481f, 0.000000f}, {-0.115566f, -0.993300f, 0.000001f}, {0.424593f, 0.340445f} },
    { {0.038877f, -0.220481f, -0.018574f}, {0.115566f, -0.993300f, 0.000000f}, {0.381583f, 0.340445f} },
    { {0.038877f, -0.220481f, 0.000000f}, {0.231132f, -0.972922f, 0.000000f}, {0.424593f, 0.340445f} },
    { {0.111941f, -0.193888f, -0.018574f}, {0.448325f, -0.893871f, 0.000000f}, {0.381583f, 0.332782f} },
    { {0.111941f, -0.193888f, 0.000000f}, {0.549952f, -0.835196f, 0.000000f}, {0.424593f, 0.332782f} },
    { {0.171504f, -0.143909f, -0.018574f}, {0.727010f, -0.686627f, 0.000000f}, {0.381583f, 0.318379f} },
    { {0.171504f, -0.143909f, 0.000000f}, {0.802440f, -0.596733f, 0.000000f}, {0.424593f, 0.318379f} },
    { {0.210381f, -0.076572f, -0.018574f}, {0.918006f, -0.396567f, 0.000000f}, {0.381583f, 0.298974f} },
    { {0.210381f, -0.076572f, 0.000000f}, {0.958142f, -0.286295f, 0.000000f}, {0.424593f, 0.298974f} },
    { {0.223883f, 0.000000f, -0.018574f}, {0.998277f, -0.058674f, 0.000000f}, {0.381583f, 0.276908f} },
    { {0.223883f, 0.000000f, 0.000000f}, {0.998277f, 0.058675f, -0.000000f}, {0.424593f, 0.276908f} },
    { {0.210381f, 0.076572f, -0.018574f}, {0.958142f, 0.286295f, -0.000000f}, {0.381583f, 0.254842f} },
    { {0.210381f, 0.076572f, 0.000000f}, {0.918006f, 0.396567f, -0.000000f}, {0.424593f, 0.254842f} },
    { {0.171504f, 0.143909f, -0.018574f}, {0.802440f, 0.596733f, -0.000000f}, {0.381583f, 0.235437f} },
    { {0.171504f, 0.143909f, 0.000000f}, {0.727009f, 0.686628f, -0.000000f}, {0.424593f, 0.235437f} },
    { {0.111941f, 0.193888f, -0.018574f}, {0.549952f, 0.835196f, -0.000000f}, {0.381583f, 0.221034f} },
    { {0.111941f, 0.193888f, 0.000000f}, {0.448325f, 0.893871f, -0.000000f}, {0.424593f, 0.221034f} },
    { {0.038877f, 0.220481f, -0.018574f}, {0.231132f, 0.972923f, -0.000000f}, {0.381583f, 0.213371f} },
    { {0.038877f, 0.220481f, 0.000000f}, {0.115566f, 0.993300f, -0.000000f}, {0.424593f, 0.213371f} },
    { {-0.038877f, 0.220481f, -0.018574f}, {-0.115566f, 0.993300f, -0.000001f}, {0.381583f, 0.213371f} },
    { {-0.038877f, 0.220481f, 0.000000f}, {-0.231132f, 0.972922f, -0.000001f}, {0.424593f, 0.213371f} },
    { {-0.111941f, 0.193888f, -0.018574f}, {-0.448325f, 0.893870f, -0.000000f}, {0.381583f, 0.221034f} },
    { {-0.111941f, 0.193888f, 0.000000f}, {-0.549952f, 0.835196f, -0.000000f}, {0.424593f, 0.221034f} },
    { {-0.171504f, 0.143909f, -0.018574f}, {-0.727010f, 0.686627f, -0.000000f}, {0.381583f, 0.235437f} },
    { {-0.171504f, 0.143909f, 0.000000f}, {-0.802440f, 0.596733f, -0.000000f}, {0.424593f, 0.235437f} },
    { {-0.210381f, 0.076572f, -0.018574f}, {-0.918006f, 0.396567f, -0.000000f}, {0.381583f, 0.254842f} },
    { {-0.210381f, 0.076572f, 0.000000f}, {-0.958142f, 0.286295f, -0.000000f}, {0.424593f, 0.254842f} },
    { {-0.188144f, 0.001983f, -0.018574f}, {-0.998277f, -0.058674f, 0.000000f}, {0.381583f, 0.276336f} },
    { {-0.176702f, -0.062908f, -0.037149f}, {-0.958142f, -0.286295f, 0.000000f}, {0.338573f, 0.295037f} },
    { {-0.188144f, 0.001983f, -0.037149f}, {-0.998277f, 0.058674f, -0.000000f}, {0.338573f, 0.276336f} },
    { {-0.176702f, -0.062908f, -0.018574f}, {-0.918006f, -0.396567f, 0.000000f}, {0.381583f, 0.295037f} },
    { {-0.143756f, -0.119973f, -0.037149f}, {-0.802440f, -0.596733f, 0.000000f}, {0.338573f, 0.311481f} },
    { {-0.143756f, -0.119973f, -0.018574f}, {-0.727009f, -0.686628f, 0.000000f}, {0.381583f, 0.311481f} },
    { {-0.093279f, -0.162329f, -0.037149f}, {-0.549952f, -0.835196f, 0.000000f}, {0.338573f, 0.323687f} },
    { {-0.093279f, -0.162328f, -0.018574f}, {-0.448325f, -0.893871f, 0.000001f}, {0.381583f, 0.323687f} },
    { {-0.031360f, -0.184865f, -0.037149f}, {-0.231132f, -0.972922f, 0.000001f}, {0.338573f, 0.330182f} },
    { {-0.031360f, -0.184865f, -0.018574f}, {-0.115566f, -0.993300f, 0.000000f}, {0.381583f, 0.330182f} },
    { {0.034533f, -0.184865f, -0.037149f}, {0.115566f, -0.993300f, 0.000000f}, {0.338573f, 0.330182f} },
    { {0.034533f, -0.184865f, -0.018574f}, {0.231132f, -0.972922f, 0.000000f}, {0.381583f, 0.330182f} },
    { {0.096452f, -0.162328f, -0.037149f}, {0.448325f, -0.893871f, 0.000000f}, {0.338573f, 0.323687f} },
    { {0.096452f, -0.162328f, -0.018574f}, {0.549952f, -0.835196f, 0.000000f}, {0.381583f, 0.323687f} },
    { {0.146929f, -0.119973f, -0.037149f}, {0.727009f, -0.686627f, 0.000000f}, {0.338573f, 0.311481f} },
    { {0.146929f, -0.119973f, -0.018574f}, {0.802440f, -0.596733f, 0.000000f}, {0.381583f, 0.311481f} },
    { {0.179876f, -0.062908f, -0.037149f}, {0.918006f, -0.396567f, 0.000000f}, {0.338573f, 0.295037f} },
    { {0.179876f, -0.062908f, -0.018574f}, {0.958142f, -0.286295f, 0.000000f}, {0.381583f, 0.295037f} },
    { {0.191318f, 0.001983f, -0.037149f}, {0.998277f, -0.058674f, 0.000000f}, {0.338573f, 0.276336f} },
    { {0.191318f, 0.001983f, -0.018574f}, {0.998277f, 0.058675f, -0.000000f}, {0.381583f, 0.276336f} },
    { {0.179876f, 0.066875f, -0.037149f}, {0.958142f, 0.286295f, -0.000000f}, {0.338573f, 0.257636f} },
    { {0.179876f, 0.066875f, -0.018574f}, {0.918006f, 0.396567f, -0.000000f}, {0.381583f, 0.257636f} },
    { {0.146929f, 0.123940f, -0.037149f}, {0.802440f, 0.596733f, -0.000000f}, {0.338573f, 0.241192f} },
    { {0.146929f, 0.123940f, -0.018574f}, {0.727009f, 0.686628f, 0.000000f}, {0.381583f, 0.241192f} },
    { {0.096452f, 0.166295f, -0.037149f}, {0.549952f, 0.835196f, 0.000000f}, {0.338573f, 0.228986f} },
    { {0.096452f, 0.166295f, -0.018574f}, {0.448325f, 0.893871f, 0.000000f}, {0.381583f, 0.228986f} },
    { {0.034533f, 0.188832f, -0.037149f}, {0.231132f, 0.972922f, 0.000000f}, {0.338573f, 0.222491f} },
    { {0.034533f, 0.188832f, -0.018574f}, {0.115566f, 0.993300f, -0.000000f}, {0.381583f, 0.222491f} },
    { {-0.031360f, 0.188832f, -0.037149f}, {-0.115566f, 0.993300f, -0.000000f}, {0.338573f, 0.222491f} },
    { {-0.031360f, 0.188832f, -0.018574f}, {-0.231132f, 0.972922f, -0.000001f}, {0.381583f, 0.222491f} },
    { {-0.093279f, 0.166295f, -0.037149f}, {-0.448325f, 0.893870f, -0.000001f}, {0.338573f, 0.228986f} },
    { {-0.093279f, 0.166295f, -0.018574f}, {-0.549952f, 0.835196f, -0.000000f}, {0.381583f, 0.228986f} },
    { {-0.143756f, 0.123940f, -0.037149f}, {-0.727010f, 0.686627f, -0.000000f}, {0.338573f, 0.241192f} },
    { {-0.143756f, 0.123940f, -0.018574f}, {-0.802440f, 0.596733f, -0.000000f}, {0.381583f, 0.241192f} },
    { {-0.176702f, 0.066875f, -0.037149f}, {-0.918006f, 0.396567f, -0.000000f}, {0.338573f, 0.257636f} },
    { {-0.176702f, 0.066875f, -0.018574f}, {-0.958142f, 0.286295f, -0.000000f}, {0.381583f, 0.257636f} },
    { {-0.223883f, 0.000000f, -0.037149f}, {-0.998277f, -0.058674f, 0.000000f}, {0.338573f, 0.276908f} },
    { {-0.210381f, -0.076572f, -0.055723f}, {-0.958142f, -0.286295f, 0.000000f}, {0.295564f, 0.298974f} },
    { {-0.223883f, 0.000000f, -0.055723f}, {-0.998277f, 0.058674f, -0.000000f}, {0.295564f, 0.276908f} },
    { {-0.210381f, -0.076572f, -0.037149f}, {-0.918006f, -0.396567f, 0.000000f}, {0.338573f, 0.298974f} },
    { {-0.171504f, -0.143909f, -0.055723f}, {-0.802440f, -0.596733f, 0.000000f}, {0.295564f, 0.318379f} },
    { {-0.171504f, -0.143909f, -0.037149f}, {-0.727009f, -0.686628f, 0.000000f}, {0.338573f, 0.318379f} },
    { {-0.111941f, -0.193888f, -0.055723f}, {-0.549952f, -0.835196f, 0.000000f}, {0.295564f, 0.332782f} },
    { {-0.111941f, -0.193888f, -0.037149f}, {-0.448325f, -0.893871f, 0.000000f}, {0.338573f, 0.332782f} },
    { {-0.038877f, -0.220481f, -0.055723f}, {-0.231132f, -0.972922f, 0.000000f}, {0.295564f, 0.340445f} },
    { {-0.038877f, -0.220481f, -0.037149f}, {-0.115566f, -0.993300f, 0.000000f}, {0.338573f, 0.340445f} },
    { {0.038877f, -0.220481f, -0.055723f}, {0.115566f, -0.993300f, 0.000000f}, {0.295564f, 0.340445f} },
    { {0.038877f, -0.220481f, -0.037149f}, {0.231132f, -0.972922f, 0.000000f}, {0.338573f, 0.340445f} },
    { {0.111941f, -0.193888f, -0.055723f}, {0.448325f, -0.893871f, 0.000000f}, {0.295564f, 0.332782f} },
    { {0.111941f, -0.193888f, -0.037149f}, {0.549952f, -0.835196f, 0.000000f}, {0.338573f, 0.332782f} },
    { {0.171504f, -0.143909f, -0.055723f}, {0.727010f, -0.686627f, 0.000000f}, {0.295564f, 0.318379f} },
    { {0.171504f, -0.143909f, -0.037149f}, {0.802440f, -0.596733f, 0.000000f}, {0.338573f, 0.318379f} },
    { {0.210381f, -0.076572f, -0.055723f}, {0.918006f, -0.396567f, 0.000000f}, {0.295564f, 0.298974f} },
    { {0.210381f, -0.076572f, -0.037149f}, {0.958142f, -0.286295f, 0.000000f}, {0.338573f, 0.298974f} },
    { {0.223883f, 0.000000f, -0.055723f}, {0.998277f, -0.058674f, 0.000000f}, {0.295564f, 0.276908f} },
    { {0.223883f, 0.000000f, -0.037149f}, {0.998277f, 0.058675f, -0.000000f}, {0.338573f, 0.276908f} },
    { {0.210381f, 0.076572f, -0.055723f}, {0.958142f, 0.286295f, -0.000000f}, {0.295564f, 0.254842f} },
    { {0.210381f, 0.076572f, -0.037149f}, {0.918006f, 0.396567f, -0.000000f}, {0.338573f, 0.254842f} },
    { {0.171504f, 0.143909f, -0.055723f}, {0.802440f, 0.596733f, -0.000000f}, {0.295564f, 0.235437f} },
    { {0.171504f, 0.143909f, -0.037149f}, {0.727009f, 0.686628f, 0.000000f}, {0.338573f, 0.235437f} },
    { {0.111941f, 0.193888f, -0.055723f}, {0.549952f, 0.835196f, 0.000000f}, {0.295564f, 0.221034f} },
    { {0.111941f, 0.193888f, -0.037149f}, {0.448325f, 0.893871f, 0.000000f}, {0.338573f, 0.221034f} },
    { {0.038877f, 0.220481f, -0.055723f}, {0.231132f, 0.972923f, 0.000000f}, {0.295564f, 0.213371f} },
    { {0.038877f, 0.220481f, -0.037149f}, {0.115566f, 0.993300f, 0.000000f}, {0.338573f, 0.213371f} },
    { {-0.038877f, 0.220481f, -0.055723f}, {-0.115566f, 0.993300f, 0.000000f}, {0.295564f, 0.213371f} },
    { {-0.038877f, 0.220481f, -0.037149f}, {-0.231132f, 0.972922f, 0.000000f}, {0.338573f, 0.213371f} },
    { {-0.111941f, 0.193888f, -0.055723f}, {-0.448325f, 0.893870f, 0.000000f}, {0.295564f, 0.221034f} },
    { {-0.111941f, 0.193888f, -0.037149f}, {-0.549952f, 0.835196f, 0.000000f}, {0.338573f, 0.221034f} },
    { {-0.171504f, 0.143909f, -0.055723f}, {-0.727010f, 0.686627f, 0.000000f}, {0.295564f, 0.235437f} },
    { {-0.171504f, 0.143909f, -0.037149f}, {-0.802440f, 0.596733f, -0.000000f}, {0.338573f, 0.235437f} },
    { {-0.210381f, 0.076572f, -0.055723f}, {-0.918006f, 0.396567f, -0.000000f}, {0.295564f, 0.254842f} },
    { {-0.210381f, 0.076572f, -0.037149f}, {-0.958142f, 0.286295f, -0.000000f}, {0.338573f, 0.254842f} },
    { {-0.000000f, 0.000000f, -0.055723f}, {0.000000f, -0.000000f, -1.000000f}, {0.295564f, 0.276908f} },
    { {-0.223883f, 0.000000f, -0.055723f}, {0.000000f, -0.000000f, -1.000000f}, {0.295564f, 0.276908f} },
    { {-0.210381f, -0.076572f, -0.055723f}, {0.000000f, -0.000000f, -1.000000f}, {0.295564f, 0.298974f} },
    { {-0.171504f, -0.143909f, -0.055723f}, {0.000000f, -0.000000f, -1.000000f}, {0.295564f, 0.318379f} },
    { {-0.111941f, -0.193888f, -0.055723f}, {0.000000f, -0.000000f, -1.000000f}, {0.295564f, 0.332782f} },
    { {-0.038877f, -0.220481f, -0.055723f}, {0.000000f, -0.000000f, -1.000000f}, {0.295564f, 0.340445f} },
    { {0.038877f, -0.220481f, -0.055723f}, {0.000000f, -0.000000f, -1.000000f}, {0.295564f, 0.340445f} },
    { {0.111941f, -0.193888f, -0.055723f}, {0.000000f, -0.000000f, -1.000000f}, {0.295564f, 0.332782f} },
    { {0.171504f, -0.143909f, -0.055723f}, {0.000000f, -0.000000f, -1.000000f}, {0.295564f, 0.318379f} },
    { {0.210381f, -0.076572f, -0.055723f}, {0.000000f, -0.000000f, -1.000000f}, {0.295564f, 0.298974f} },
    { {0.223883f, 0.000000f, -0.055723f}, {0.000000f, -0.000000f, -1.000000f}, {0.295564f, 0.276908f} },
    { {0.210381f, 0.076572f, -0.055723f}, {0.000000f, -0.000000f, -1.000000f}, {0.295564f, 0.254842f} },
    { {0.171504f, 0.143909f, -0.055723f}, {0.000000f, -0.000000f, -1.000000f}, {0.295564f, 0.235437f} },
    { {0.111941f, 0.193888f, -0.055723f}, {0.000000f, -0.000000f, -1.000000f}, {0.295564f, 0.221034f} },
    { {0.038877f, 0.220481f, -0.055723f}, {0.000000f, -0.000000f, -1.000000f}, {0.295564f, 0.213371f} },
    { {-0.038877f, 0.220481f, -0.055723f}, {0.000000f, -0.000000f, -1.000000f}, {0.295564f, 0.213371f} },
    { {-0.111941f, 0.193888f, -0.055723f}, {0.000000f, -0.000000f, -1.000000f}, {0.295564f, 0.221034f} },
    { {-0.171504f, 0.143909f, -0.055723f}, {0.000000f, -0.000000f, -1.000000f}, {0.295564f, 0.235437f} },
    { {-0.210381f, 0.076572f, -0.055723f}, {0.000000f, -0.000000f, -1.000000f}, {0.295564f, 0.254842f} },
    { {-0.223883f, 0.000000f, -0.018574f}, {0.000000f, -0.000000f, -1.000000f}, {0.381583f, 0.276908f} },
    { {-0.210381f, -0.076572f, -0.018574f}, {0.000000f, -0.000000f, -1.000000f}, {0.381583f, 0.298974f} },
    { {-0.176702f, -0.062908f, -0.018574f}, {0.000000f, -0.000000f, -1.000000f}, {0.381583f, 0.295037f} },
    { {-0.188144f, 0.001983f, -0.018574f}, {0.000000f, -0.000000f, -1.000000f}, {0.381583f, 0.276336f} },
    { {-0.171504f, -0.143909f, -0.018574f}, {0.000000f, -0.000000f, -1.000000f}, {0.381583f, 0.318379f} },
    { {-0.143756f, -0.119973f, -0.018574f}, {0.000000f, -0.000000f, -1.000000f}, {0.381583f, 0.311481f} },
    { {-0.111941f, -0.193888f, -0.018574f}, {0.000000f, -0.000000f, -1.000000f}, {0.381583f, 0.332782f} },
    { {-0.093279f, -0.162328f, -0.018574f}, {0.000000f, -0.000000f, -1.000000f}, {0.381583f, 0.323687f} },
    { {-0.038877f, -0.220481f, -0.018574f}, {0.000000f, -0.000000f, -1.000000f}, {0.381583f, 0.340445f} },
    { {-0.031360f, -0.184865f, -0.018574f}, {0.000000f, -0.000000f, -1.000000f}, {0.381583f, 0.330182f} },
    { {0.038877f, -0.220481f, -0.018574f}, {0.000000f, -0.000000f, -1.000000f}, {0.381583f, 0.340445f} },
    { {0.034533f, -0.184865f, -0.018574f}, {0.000000f, -0.000000f, -1.000000f}, {0.381583f, 0.330182f} },
    { {0.111941f, -0.193888f, -0.018574f}, {0.000000f, -0.000000f, -1.000000f}, {0.381583f, 0.332782f} },
    { {0.096452f, -0.162328f, -0.018574f}, {0.000000f, -0.000000f, -1.000000f}, {0.381583f, 0.323687f} },
    { {0.171504f, -0.143909f, -0.018574f}, {0.000000f, -0.000000f, -1.000000f}, {0.381583f, 0.318379f} },
    { {0.146929f, -0.119973f, -0.018574f}, {0.000000f, -0.000000f, -1.000000f}, {0.381583f, 0.311481f} },
    { {0.210381f, -0.076572f, -0.018574f}, {0.000000f, -0.000000f, -1.000000f}, {0.381583f, 0.298974f} },
    { {0.179876f, -0.062908f, -0.018574f}, {0.000000f, -0.000000f, -1.000000f}, {0.381583f, 0.295037f} },
    { {0.223883f, 0.000000f, -0.018574f}, {0.000000f, -0.000000f, -1.000000f}, {0.381583f, 0.276908f} },
    { {0.191318f, 0.001983f, -0.018574f}, {0.000000f, -0.000000f, -1.000000f}, {0.381583f, 0.276336f} },
    { {0.210381f, 0.076572f, -0.018574f}, {0.000000f, -0.000000f, -1.000000f}, {0.381583f, 0.254842f} },
    { {0.179876f, 0.066875f, -0.018574f}, {0.000000f, -0.000000f, -1.000000f}, {0.381583f, 0.257636f} },
    { {0.171504f, 0.143909f, -0.018574f}, {0.000000f, -0.000000f, -1.000000f}, {0.381583f, 0.235437f} },
    { {0.146929f, 0.123940f, -0.018574f}, {0.000000f, -0.000000f, -1.000000f}, {0.381583f, 0.241192f} },
    { {0.111941f, 0.193888f, -0.018574f}, {0.000000f, -0.000000f, -1.000000f}, {0.381583f, 0.221034f} },
    { {0.096452f, 0.166295f, -0.018574f}, {0.000000f, -0.000000f, -1.000000f}, {0.381583f, 0.228986f} },
    { {0.038877f, 0.220481f, -0.018574f}, {0.000000f, -0.000000f, -1.000000f}, {0.381583f, 0.213371f} },
    { {0.034533f, 0.188832f, -0.018574f}, {0.000000f, -0.000000f, -1.000000f}, {0.381583f, 0.222491f} },
    { {-0.038877f, 0.220481f, -0.018574f}, {0.000000f, -0.000000f, -1.000000f}, {0.381583f, 0.213371f} },
    { {-0.031360f, 0.188832f, -0.018574f}, {0.000000f, -0.000000f, -1.000000f}, {0.381583f, 0.222491f} },
    { {-0.111941f, 0.193888f, -0.018574f}, {0.000000f, -0.000000f, -1.000000f}, {0.381583f, 0.221034f} },
    { {-0.093279f, 0.166295f, -0.018574f}, {0.000000f, -0.000000f, -1.000000f}, {0.381583f, 0.228986f} },
    { {-0.171504f, 0.143909f, -0.018574f}, {0.000000f, -0.000000f, -1.000000f}, {0.381583f, 0.235437f} },
    { {-0.143756f, 0.123940f, -0.018574f}, {0.000000f, -0.000000f, -1.000000f}, {0.381583f, 0.241192f} },
    { {-0.210381f, 0.076572f, -0.018574f}, {0.000000f, -0.000000f, -1.000000f}, {0.381583f, 0.254842f} },
    { {-0.176702f, 0.066875f, -0.018574f}, {0.000000f, -0.000000f, -1.000000f}, {0.381583f, 0.257636f} },
    { {-0.210381f, -0.076572f, -0.037149f}, {-0.000000f, 0.000000f, 1.000000f}, {0.338573f, 0.298974f} },
    { {-0.223883f, 0.000000f, -0.037149f}, {-0.000000f, 0.000000f, 1.000000f}, {0.338573f, 0.276908f} },
    { {-0.188144f, 0.001983f, -0.037149f}, {-0.000000f, 0.000000f, 1.000000f}, {0.338573f, 0.276336f} },
    { {-0.176702f, -0.062908f, -0.037149f}, {-0.000000f, 0.000000f, 1.000000f}, {0.338573f, 0.295037f} },
    { {-0.171504f, -0.143909f, -0.037149f}, {-0.000000f, 0.000000f, 1.000000f}, {0.338573f, 0.318379f} },
    { {-0.143756f, -0.119973f, -0.037149f}, {-0.000000f, 0.000000f, 1.000000f}, {0.338573f, 0.311481f} },
    { {-0.111941f, -0.193888f, -0.037149f}, {-0.000000f, 0.000000f, 1.000000f}, {0.338573f, 0.332782f} },
    { {-0.093279f, -0.162329f, -0.037149f}, {-0.000000f, 0.000000f, 1.000000f}, {0.338573f, 0.323687f} },
    { {-0.038877f, -0.220481f, -0.037149f}, {-0.000000f, 0.000000f, 1.000000f}, {0.338573f, 0.340445f} },
    { {-0.031360f, -0.184865f, -0.037149f}, {-0.000000f, 0.000000f, 1.000000f}, {0.338573f, 0.330182f} },
    { {0.038877f, -0.220481f, -0.037149f}, {-0.000000f, 0.000000f, 1.000000f}, {0.338573f, 0.340445f} },
    { {0.034533f, -0.184865f, -0.037149f}, {-0.000000f, 0.000000f, 1.000000f}, {0.338573f, 0.330182f} },
    { {0.111941f, -0.193888f, -0.037149f}, {-0.000000f, 0.000000f, 1.000000f}, {0.338573f, 0.332782f} },
    { {0.096452f, -0.162328f, -0.037149f}, {-0.000000f, 0.000000f, 1.000000f}, {0.338573f, 0.323687f} },
    { {0.171504f, -0.143909f, -0.037149f}, {-0.000000f, 0.000000f, 1.000000f}, {0.338573f, 0.318379f} },
    { {0.146929f, -0.119973f, -0.037149f}, {-0.000000f, 0.000000f, 1.000000f}, {0.338573f, 0.311481f} },
    { {0.210381f, -0.076572f, -0.037149f}, {-0.000000f, 0.000000f, 1.000000f}, {0.338573f, 0.298974f} },
    { {0.179876f, -0.062908f, -0.037149f}, {-0.000000f, 0.000000f, 1.000000f}, {0.338573f, 0.295037f} },
    { {0.223883f, 0.000000f, -0.037149f}, {-0.000000f, 0.000000f, 1.000000f}, {0.338573f, 0.276908f} },
    { {0.191318f, 0.001983f, -0.037149f}, {-0.000000f, 0.000000f, 1.000000f}, {0.338573f, 0.276336f} },
    { {0.210381f, 0.076572f, -0.037149f}, {-0.000000f, 0.000000f, 1.000000f}, {0.338573f, 0.254842f} },
    { {0.179876f, 0.066875f, -0.037149f}, {-0.000000f, 0.000000f, 1.000000f}, {0.338573f, 0.257636f} },
    { {0.171504f, 0.143909f, -0.037149f}, {-0.000000f, 0.000000f, 1.000000f}, {0.338573f, 0.235437f} },
    { {0.146929f, 0.123940f, -0.037149f}, {-0.000000f, 0.000000f, 1.000000f}, {0.338573f, 0.241192f} },
    { {0.111941f, 0.193888f, -0.037149f}, {-0.000000f, 0.000000f, 1.000000f}, {0.338573f, 0.221034f} },
    { {0.096452f, 0.166295f, -0.037149f}, {-0.000000f, 0.000000f, 1.000000f}, {0.338573f, 0.228986f} },
    { {0.038877f, 0.220481f, -0.037149f}, {-0.000000f, 0.000000f, 1.000000f}, {0.338573f, 0.213371f} },
    { {0.034533f, 0.188832f, -0.037149f}, {-0.000000f, 0.000000f, 1.000000f}, {0.338573f, 0.222491f} },
    { {-0.038877f, 0.220481f, -0.037149f}, {-0.000000f, 0.000000f, 1.000000f}, {0.338573f, 0.213371f} },
    { {-0.031360f, 0.188832f, -0.037149f}, {-0.000000f, 0.000000f, 1.000000f}, {0.338573f, 0.222491f} },
    { {-0.111941f, 0.193888f, -0.037149f}, {-0.000000f, 0.000000f, 1.000000f}, {0.338573f, 0.221034f} },
    { {-0.093279f, 0.166295f, -0.037149f}, {-0.000000f, 0.000000f, 1.000000f}, {0.338573f, 0.228986f} },
    { {-0.171504f, 0.143909f, -0.037149f}, {-0.000000f, 0.000000f, 1.000000f}, {0.338573f, 0.235437f} },
    { {-0.143756f, 0.123940f, -0.037149f}, {-0.000000f, 0.000000f, 1.000000f}, {0.338573f, 0.241192f} },
    { {-0.210381f, 0.076572f, -0.037149f}, {-0.000000f, 0.000000f, 1.000000f}, {0.338573f, 0.254842f} },
    { {-0.176702f, 0.066875f, -0.037149f}, {-0.000000f, 0.000000f, 1.000000f}, {0.338573f, 0.257636f} },
};

WORD g_tind35[] = 
{
    2, 1, 0,    1, 3, 0,    3, 4, 0,    4, 5, 0,    5, 6, 0,
    6, 7, 0,    7, 8, 0,    8, 9, 0,    9, 10, 0,    10, 11, 0,
    11, 12, 0,    12, 13, 0,    13, 14, 0,    14, 15, 0,    15, 16, 0,
    16, 17, 0,    17, 18, 0,    18, 2, 0,    21, 20, 19,    20, 22, 19,
    20, 23, 22,    23, 24, 22,    23, 25, 24,    25, 26, 24,    25, 27, 26,
    27, 28, 26,    27, 29, 28,    29, 30, 28,    29, 31, 30,    31, 32, 30,
    31, 33, 32,    33, 34, 32,    33, 35, 34,    35, 36, 34,    35, 37, 36,
    37, 38, 36,    37, 39, 38,    39, 40, 38,    39, 41, 40,    41, 42, 40,
    41, 43, 42,    43, 44, 42,    43, 45, 44,    45, 46, 44,    45, 47, 46,
    47, 48, 46,    47, 49, 48,    49, 50, 48,    49, 51, 50,    51, 52, 50,
    51, 53, 52,    53, 54, 52,    53, 21, 54,    21, 19, 54,    57, 56, 55,
    56, 58, 55,    56, 59, 58,    59, 60, 58,    59, 61, 60,    61, 62, 60,
    61, 63, 62,    63, 64, 62,    63, 65, 64,    65, 66, 64,    65, 67, 66,
    67, 68, 66,    67, 69, 68,    69, 70, 68,    69, 71, 70,    71, 72, 70,
    71, 73, 72,    73, 74, 72,    73, 75, 74,    75, 76, 74,    75, 77, 76,
    77, 78, 76,    77, 79, 78,    79, 80, 78,    79, 81, 80,    81, 82, 80,
    81, 83, 82,    83, 84, 82,    83, 85, 84,    85, 86, 84,    85, 87, 86,
    87, 88, 86,    87, 89, 88,    89, 90, 88,    89, 57, 90,    57, 55, 90,
    93, 92, 91,    92, 94, 91,    92, 95, 94,    95, 96, 94,    95, 97, 96,
    97, 98, 96,    97, 99, 98,    99, 100, 98,    99, 101, 100,    101, 102, 100,
    101, 103, 102,    103, 104, 102,    103, 105, 104,    105, 106, 104,    105, 107, 106,
    107, 108, 106,    107, 109, 108,    109, 110, 108,    109, 111, 110,    111, 112, 110,
    111, 113, 112,    113, 114, 112,    113, 115, 114,    115, 116, 114,    115, 117, 116,
    117, 118, 116,    117, 119, 118,    119, 120, 118,    119, 121, 120,    121, 122, 120,
    121, 123, 122,    123, 124, 122,    123, 125, 124,    125, 126, 124,    125, 93, 126,
    93, 91, 126,    129, 128, 127,    130, 129, 127,    131, 130, 127,    132, 131, 127,
    133, 132, 127,    134, 133, 127,    135, 134, 127,    136, 135, 127,    137, 136, 127,
    138, 137, 127,    139, 138, 127,    140, 139, 127,    141, 140, 127,    142, 141, 127,
    143, 142, 127,    144, 143, 127,    145, 144, 127,    128, 145, 127,    148, 147, 146,
    146, 149, 148,    151, 150, 147,    147, 148, 151,    153, 152, 150,    150, 151, 153,
    155, 154, 152,    152, 153, 155,    157, 156, 154,    154, 155, 157,    159, 158, 156,
    156, 157, 159,    161, 160, 158,    158, 159, 161,    163, 162, 160,    160, 161, 163,
    165, 164, 162,    162, 163, 165,    167, 166, 164,    164, 165, 167,    169, 168, 166,
    166, 167, 169,    171, 170, 168,    168, 169, 171,    173, 172, 170,    170, 171, 173,
    175, 174, 172,    172, 173, 175,    177, 176, 174,    174, 175, 177,    179, 178, 176,
    176, 177, 179,    181, 180, 178,    178, 179, 181,    149, 146, 180,    180, 181, 149,
    184, 183, 182,    182, 185, 184,    185, 182, 186,    186, 187, 185,    187, 186, 188,
    188, 189, 187,    189, 188, 190,    190, 191, 189,    191, 190, 192,    192, 193, 191,
    193, 192, 194,    194, 195, 193,    195, 194, 196,    196, 197, 195,    197, 196, 198,
    198, 199, 197,    199, 198, 200,    200, 201, 199,    201, 200, 202,    202, 203, 201,
    203, 202, 204,    204, 205, 203,    205, 204, 206,    206, 207, 205,    207, 206, 208,
    208, 209, 207,    209, 208, 210,    210, 211, 209,    211, 210, 212,    212, 213, 211,
    213, 212, 214,    214, 215, 213,    215, 214, 216,    216, 217, 215,    217, 216, 183,
    183, 184, 217,
};

D3DMATRIX g_tmat36 = 
{
    0.927684f, 0.140427f, -0.345951f, 0.000000f, 
    -0.113584f, 0.988802f, 0.096792f, 0.000000f, 
    0.355670f, -0.050498f, 0.933247f, 0.000000f, 
    -0.513299f, -2.224746f, 3.083037f, 1.000000f, 
};

// Mesh #36 Tris:108 Verts:129
MODELVERT g_tmesh36[] = 
{
    { {-0.189369f, -0.074403f, 0.066567f}, {0.165934f, -0.255192f, -0.952546f}, {0.417168f, 0.337846f} },
    { {-0.189575f, 0.112498f, 0.019951f}, {0.032158f, -0.214955f, -0.976094f}, {0.417232f, 0.259504f} },
    { {-0.184071f, 0.108596f, 0.026891f}, {0.938285f, -0.343806f, -0.037656f}, {0.415514f, 0.261140f} },
    { {-0.184157f, -0.079180f, 0.072246f}, {0.997346f, -0.070282f, -0.019020f}, {0.415541f, 0.339848f} },
    { {-0.135685f, 0.166681f, 0.017822f}, {0.016664f, -0.203588f, -0.978915f}, {0.400408f, 0.236793f} },
    { {-0.131751f, 0.160875f, 0.024836f}, {0.097863f, -0.994907f, -0.024142f}, {0.399180f, 0.239226f} },
    { {-0.135685f, 0.166681f, 0.017822f}, {0.016664f, -0.203588f, -0.978915f}, {0.319749f, 0.340445f} },
    { {0.122455f, 0.165973f, 0.017850f}, {-0.074515f, -0.243741f, -0.966974f}, {0.400340f, 0.340430f} },
    { {0.118740f, 0.160875f, 0.024837f}, {-0.266357f, -0.962970f, -0.041741f}, {0.399180f, 0.336670f} },
    { {0.118740f, 0.160875f, 0.024837f}, {-0.266357f, -0.962970f, -0.041741f}, {0.320977f, 0.239226f} },
    { {0.122455f, 0.165973f, 0.017850f}, {-0.074515f, -0.243741f, -0.966974f}, {0.319817f, 0.237089f} },
    { {0.176562f, 0.113620f, 0.019907f}, {-0.064847f, -0.194615f, -0.978734f}, {0.302925f, 0.259034f} },
    { {0.171060f, 0.108596f, 0.026891f}, {-0.987364f, -0.156145f, -0.027042f}, {0.304642f, 0.261140f} },
    { {0.174977f, -0.077051f, 0.066567f}, {0.094817f, -0.284222f, -0.954058f}, {0.303420f, 0.338956f} },
    { {0.170972f, -0.079347f, 0.072364f}, {-0.881094f, -0.462394f, -0.099321f}, {0.304670f, 0.339918f} },
    { {0.193822f, -0.041549f, 0.063374f}, {0.385224f, -0.234918f, -0.892421f}, {0.297536f, 0.324075f} },
    { {0.200140f, -0.043878f, 0.069170f}, {0.997454f, -0.068670f, -0.019214f}, {0.295564f, 0.325051f} },
    { {0.174977f, -0.077051f, 0.066567f}, {0.094817f, -0.284222f, -0.954058f}, {0.416737f, 0.314209f} },
    { {0.200140f, -0.043878f, 0.069170f}, {0.997454f, -0.068670f, -0.019214f}, {0.424593f, 0.312807f} },
    { {0.170972f, -0.079347f, 0.072364f}, {-0.881094f, -0.462394f, -0.099321f}, {0.415487f, 0.311088f} },
    { {0.195350f, 0.126009f, 0.019420f}, {0.307879f, -0.062799f, -0.949351f}, {0.297059f, 0.253841f} },
    { {0.200140f, 0.127771f, 0.026137f}, {0.925300f, 0.378001f, -0.030595f}, {0.295564f, 0.253102f} },
    { {0.135497f, 0.179319f, 0.020344f}, {0.017751f, 0.214180f, -0.976633f}, {0.315745f, 0.231495f} },
    { {0.138926f, 0.188938f, 0.023734f}, {0.671562f, 0.718889f, -0.179451f}, {0.314675f, 0.227463f} },
    { {-0.148726f, 0.180027f, 0.020316f}, {-0.065343f, 0.216608f, -0.974069f}, {0.404480f, 0.231199f} },
    { {-0.151937f, 0.188938f, 0.023734f}, {-0.671329f, 0.726075f, -0.148766f}, {0.405482f, 0.227463f} },
    { {-0.208363f, 0.124887f, 0.019464f}, {-0.390222f, -0.112355f, -0.913840f}, {0.423098f, 0.254311f} },
    { {-0.213151f, 0.127771f, 0.026137f}, {-0.983925f, 0.176673f, -0.026042f}, {0.424593f, 0.253102f} },
    { {-0.208102f, -0.043211f, 0.063374f}, {-0.314588f, -0.262537f, -0.912200f}, {0.423016f, 0.324771f} },
    { {-0.213151f, -0.043878f, 0.069170f}, {-0.972806f, -0.225745f, -0.051848f}, {0.424593f, 0.325051f} },
    { {-0.208102f, -0.043211f, 0.063374f}, {-0.314588f, -0.262537f, -0.912200f}, {0.408678f, 0.315927f} },
    { {-0.189369f, -0.074403f, 0.066567f}, {0.165934f, -0.255192f, -0.952546f}, {0.421954f, 0.314209f} },
    { {-0.184157f, -0.079180f, 0.072246f}, {0.997346f, -0.070282f, -0.019020f}, {0.423987f, 0.311151f} },
    { {-0.184157f, -0.079180f, 0.072246f}, {0.997346f, -0.070282f, -0.019020f}, {0.296170f, 0.311151f} },
    { {-0.184071f, 0.108596f, 0.026891f}, {0.938285f, -0.343806f, -0.037656f}, {0.376089f, 0.335564f} },
    { {-0.184071f, 0.108572f, 0.234969f}, {0.986991f, -0.158801f, 0.025106f}, {0.376079f, 0.223566f} },
    { {-0.184157f, -0.079555f, 0.195697f}, {0.887552f, -0.447645f, 0.108927f}, {0.296010f, 0.244704f} },
    { {-0.184071f, 0.108596f, 0.026891f}, {0.938285f, -0.343806f, -0.037656f}, {0.304642f, 0.335564f} },
    { {-0.131751f, 0.160875f, 0.024836f}, {0.097863f, -0.994907f, -0.024142f}, {0.320977f, 0.336670f} },
    { {-0.131752f, 0.159886f, 0.245177f}, {0.264490f, -0.964020f, 0.026672f}, {0.320977f, 0.218072f} },
    { {-0.184071f, 0.108572f, 0.234969f}, {0.986991f, -0.158801f, 0.025106f}, {0.304642f, 0.223566f} },
    { {0.118740f, 0.159886f, 0.245177f}, {-0.096205f, -0.995308f, 0.010340f}, {0.399180f, 0.218072f} },
    { {0.171060f, 0.108596f, 0.026891f}, {-0.987364f, -0.156145f, -0.027042f}, {0.415514f, 0.335564f} },
    { {0.171060f, 0.108572f, 0.234970f}, {-0.939782f, -0.340231f, 0.032447f}, {0.415514f, 0.223566f} },
    { {0.171060f, 0.108596f, 0.026891f}, {-0.987364f, -0.156145f, -0.027042f}, {0.344067f, 0.335564f} },
    { {0.170972f, -0.079347f, 0.072364f}, {-0.881094f, -0.462394f, -0.099321f}, {0.424058f, 0.311088f} },
    { {0.170972f, -0.080604f, 0.195140f}, {-0.997501f, -0.068892f, 0.015702f}, {0.424593f, 0.245004f} },
    { {0.171060f, 0.108572f, 0.234970f}, {-0.939782f, -0.340231f, 0.032447f}, {0.344078f, 0.223566f} },
    { {0.200140f, -0.043628f, 0.205717f}, {0.972427f, -0.225879f, 0.058009f}, {0.424593f, 0.239311f} },
    { {0.170972f, -0.080604f, 0.195140f}, {-0.997501f, -0.068892f, 0.015702f}, {0.415487f, 0.245004f} },
    { {0.200140f, -0.043878f, 0.069170f}, {0.997454f, -0.068670f, -0.019214f}, {0.311195f, 0.312807f} },
    { {0.200140f, 0.127771f, 0.026137f}, {0.925300f, 0.378001f, -0.030595f}, {0.384250f, 0.335970f} },
    { {0.200140f, 0.127393f, 0.238713f}, {0.983939f, 0.176550f, 0.026360f}, {0.384089f, 0.221551f} },
    { {0.200140f, -0.043628f, 0.205717f}, {0.972427f, -0.225879f, 0.058009f}, {0.311301f, 0.239311f} },
    { {0.200140f, 0.127771f, 0.026137f}, {0.925300f, 0.378001f, -0.030595f}, {0.295564f, 0.335970f} },
    { {0.138926f, 0.188938f, 0.023734f}, {0.671562f, 0.718889f, -0.179451f}, {0.314675f, 0.337263f} },
    { {0.138926f, 0.187431f, 0.250656f}, {0.675522f, 0.724451f, 0.137263f}, {0.314675f, 0.215123f} },
    { {0.200140f, 0.127393f, 0.238713f}, {0.983939f, 0.176550f, 0.026360f}, {0.295564f, 0.221551f} },
    { {0.103622f, 0.222432f, 0.053278f}, {0.081016f, 0.995615f, -0.046770f}, {0.325696f, 0.321361f} },
    { {-0.116633f, 0.222432f, 0.053278f}, {-0.061567f, 0.982676f, -0.174808f}, {0.394460f, 0.321361f} },
    { {-0.116633f, 0.222558f, 0.225927f}, {-0.081497f, 0.995580f, 0.046668f}, {0.394460f, 0.228433f} },
    { {0.103622f, 0.222559f, 0.225927f}, {0.064130f, 0.981462f, 0.180610f}, {0.325696f, 0.228433f} },
    { {-0.151937f, 0.188938f, 0.023734f}, {-0.671329f, 0.726075f, -0.148766f}, {0.405482f, 0.337263f} },
    { {-0.213151f, 0.127771f, 0.026137f}, {-0.983925f, 0.176673f, -0.026042f}, {0.424593f, 0.335970f} },
    { {-0.213151f, 0.127393f, 0.238713f}, {-0.924988f, 0.378602f, 0.032525f}, {0.424593f, 0.221551f} },
    { {-0.151937f, 0.187431f, 0.250655f}, {-0.673192f, 0.720876f, 0.164773f}, {0.405482f, 0.215123f} },
    { {-0.213151f, 0.127771f, 0.026137f}, {-0.983925f, 0.176673f, -0.026042f}, {0.335906f, 0.335970f} },
    { {-0.213151f, -0.043878f, 0.069170f}, {-0.972806f, -0.225745f, -0.051848f}, {0.408962f, 0.312807f} },
    { {-0.213151f, -0.043628f, 0.205717f}, {-0.997677f, -0.066510f, 0.014766f}, {0.408855f, 0.239311f} },
    { {-0.213151f, 0.127393f, 0.238713f}, {-0.924988f, 0.378602f, 0.032525f}, {0.336067f, 0.221551f} },
    { {-0.213151f, -0.043878f, 0.069170f}, {-0.972806f, -0.225745f, -0.051848f}, {0.295564f, 0.312807f} },
    { {-0.184157f, -0.079180f, 0.072246f}, {0.997346f, -0.070282f, -0.019020f}, {0.304615f, 0.311151f} },
    { {-0.184157f, -0.079555f, 0.195697f}, {0.887552f, -0.447645f, 0.108927f}, {0.304615f, 0.244704f} },
    { {-0.213151f, -0.043628f, 0.205717f}, {-0.997677f, -0.066510f, 0.014766f}, {0.295564f, 0.239311f} },
    { {-0.184157f, -0.079555f, 0.195697f}, {0.887552f, -0.447645f, 0.108927f}, {0.304615f, 0.340005f} },
    { {-0.184071f, 0.108572f, 0.234969f}, {0.986991f, -0.158801f, 0.025106f}, {0.304642f, 0.261150f} },
    { {-0.189575f, 0.111252f, 0.242876f}, {0.245943f, -0.213160f, 0.945555f}, {0.302924f, 0.260026f} },
    { {-0.189369f, -0.074006f, 0.201492f}, {0.247092f, -0.261473f, 0.933048f}, {0.302988f, 0.337680f} },
    { {-0.131752f, 0.159886f, 0.245177f}, {0.264490f, -0.964020f, 0.026672f}, {0.320977f, 0.239641f} },
    { {-0.135685f, 0.164434f, 0.253455f}, {0.051030f, -0.283085f, 0.957736f}, {0.319749f, 0.237734f} },
    { {0.122455f, 0.163740f, 0.253317f}, {-0.026565f, -0.525165f, 0.850585f}, {0.400340f, 0.213690f} },
    { {-0.135685f, 0.164434f, 0.253455f}, {0.051030f, -0.283085f, 0.957736f}, {0.319749f, 0.213616f} },
    { {0.118740f, 0.159886f, 0.245177f}, {-0.096205f, -0.995308f, 0.010340f}, {0.399180f, 0.239641f} },
    { {0.171060f, 0.108572f, 0.234970f}, {-0.939782f, -0.340231f, 0.032447f}, {0.415514f, 0.261150f} },
    { {0.176562f, 0.112353f, 0.243095f}, {-0.220975f, -0.243091f, 0.944498f}, {0.417232f, 0.259565f} },
    { {0.122455f, 0.163740f, 0.253317f}, {-0.026565f, -0.525165f, 0.850585f}, {0.400340f, 0.238025f} },
    { {0.170972f, -0.080604f, 0.195140f}, {-0.997501f, -0.068892f, 0.015702f}, {0.415487f, 0.340445f} },
    { {0.174977f, -0.076581f, 0.200874f}, {-0.472026f, -0.199727f, 0.858662f}, {0.416737f, 0.338759f} },
    { {0.200140f, -0.043628f, 0.205717f}, {0.972427f, -0.225879f, 0.058009f}, {0.424593f, 0.324946f} },
    { {0.193822f, -0.042807f, 0.212271f}, {0.088645f, -0.237748f, 0.967273f}, {0.422620f, 0.324602f} },
    { {0.170972f, -0.080604f, 0.195140f}, {-0.997501f, -0.068892f, 0.015702f}, {0.295564f, 0.245004f} },
    { {0.193822f, -0.042807f, 0.212271f}, {0.088645f, -0.237748f, 0.967273f}, {0.311651f, 0.235783f} },
    { {0.174977f, -0.076581f, 0.200874f}, {-0.472026f, -0.199727f, 0.858662f}, {0.297276f, 0.241918f} },
    { {0.200140f, 0.127393f, 0.238713f}, {0.983939f, 0.176550f, 0.026360f}, {0.424593f, 0.253261f} },
    { {0.195350f, 0.124513f, 0.245514f}, {0.347937f, -0.120476f, 0.929745f}, {0.423098f, 0.254468f} },
    { {0.138926f, 0.187431f, 0.250656f}, {0.675522f, 0.724451f, 0.137263f}, {0.405482f, 0.228095f} },
    { {0.135497f, 0.179021f, 0.253772f}, {0.052269f, 0.046153f, 0.997566f}, {0.404411f, 0.231620f} },
    { {-0.151937f, 0.187431f, 0.250655f}, {-0.673192f, 0.720876f, 0.164773f}, {0.314675f, 0.228095f} },
    { {-0.148726f, 0.179715f, 0.253910f}, {-0.026986f, 0.107927f, 0.993793f}, {0.315677f, 0.231329f} },
    { {-0.213151f, 0.127393f, 0.238713f}, {-0.924988f, 0.378602f, 0.032525f}, {0.295564f, 0.253261f} },
    { {-0.208363f, 0.123412f, 0.245295f}, {-0.264199f, -0.081079f, 0.961054f}, {0.297058f, 0.254929f} },
    { {-0.213151f, -0.043628f, 0.205717f}, {-0.997677f, -0.066510f, 0.014766f}, {0.295564f, 0.324946f} },
    { {-0.208102f, -0.044422f, 0.211883f}, {-0.205207f, -0.215178f, 0.954771f}, {0.297140f, 0.325279f} },
    { {-0.189369f, -0.074006f, 0.201492f}, {0.247092f, -0.261473f, 0.933048f}, {0.302988f, 0.241585f} },
    { {0.138926f, 0.188938f, 0.023734f}, {0.281922f, 0.666865f, -0.689791f}, {0.314675f, 0.227463f} },
    { {-0.151937f, 0.188938f, 0.023734f}, {-0.602808f, 0.700512f, -0.381976f}, {0.405482f, 0.227463f} },
    { {-0.140466f, 0.203565f, 0.033186f}, {-0.372401f, 0.797415f, -0.474813f}, {0.401901f, 0.221332f} },
    { {0.127455f, 0.203565f, 0.033186f}, {0.380167f, 0.798086f, -0.467474f}, {0.318256f, 0.221332f} },
    { {0.138926f, 0.187431f, 0.250656f}, {0.619856f, 0.655453f, 0.431463f}, {0.314675f, 0.215123f} },
    { {0.138926f, 0.188938f, 0.023734f}, {0.281922f, 0.666865f, -0.689791f}, {0.314675f, 0.337263f} },
    { {0.127455f, 0.203565f, 0.033186f}, {0.380167f, 0.798086f, -0.467474f}, {0.318256f, 0.332175f} },
    { {0.127455f, 0.203565f, 0.033186f}, {0.380167f, 0.798086f, -0.467474f}, {0.416509f, 0.332175f} },
    { {0.127455f, 0.203356f, 0.243608f}, {0.396750f, 0.753831f, 0.523763f}, {0.416420f, 0.218916f} },
    { {0.138926f, 0.187431f, 0.250656f}, {0.619856f, 0.655453f, 0.431463f}, {0.409642f, 0.215123f} },
    { {-0.151937f, 0.188938f, 0.023734f}, {-0.602808f, 0.700512f, -0.381976f}, {0.309873f, 0.337263f} },
    { {-0.151937f, 0.187431f, 0.250655f}, {-0.309805f, 0.562422f, 0.766617f}, {0.310514f, 0.215123f} },
    { {-0.140466f, 0.203356f, 0.243608f}, {-0.398396f, 0.763770f, 0.507874f}, {0.303736f, 0.218916f} },
    { {-0.140466f, 0.203356f, 0.243608f}, {-0.398396f, 0.763770f, 0.507874f}, {0.401901f, 0.218916f} },
    { {-0.140466f, 0.203565f, 0.033186f}, {-0.372401f, 0.797415f, -0.474813f}, {0.401901f, 0.332175f} },
    { {-0.151937f, 0.188938f, 0.023734f}, {-0.602808f, 0.700512f, -0.381976f}, {0.405482f, 0.337263f} },
    { {-0.151937f, 0.187431f, 0.250655f}, {-0.309805f, 0.562422f, 0.766617f}, {0.314675f, 0.228095f} },
    { {0.138926f, 0.187431f, 0.250656f}, {0.619856f, 0.655453f, 0.431463f}, {0.405482f, 0.228095f} },
    { {0.127455f, 0.203356f, 0.243608f}, {0.396750f, 0.753831f, 0.523763f}, {0.401901f, 0.221420f} },
    { {-0.140466f, 0.203356f, 0.243608f}, {-0.398396f, 0.763770f, 0.507874f}, {0.318256f, 0.221420f} },
    { {-0.116633f, 0.222432f, 0.053278f}, {-0.061567f, 0.982676f, -0.174808f}, {0.394460f, 0.213424f} },
    { {0.103622f, 0.222432f, 0.053278f}, {0.081016f, 0.995615f, -0.046770f}, {0.325696f, 0.213424f} },
    { {0.103622f, 0.222559f, 0.225927f}, {0.064130f, 0.981462f, 0.180610f}, {0.394460f, 0.213371f} },
    { {-0.116633f, 0.222558f, 0.225927f}, {-0.081497f, 0.995580f, 0.046668f}, {0.325696f, 0.213371f} },
    { {0.127455f, 0.203356f, 0.243608f}, {0.396750f, 0.753831f, 0.523763f}, {0.318256f, 0.218916f} },
};

WORD g_tind36[] = 
{
    0, 1, 2,    0, 2, 3,    1, 4, 5,    1, 5, 2,    6, 7, 8,
    4, 9, 5,    10, 11, 12,    10, 12, 9,    11, 13, 14,    11, 14, 12,
    13, 15, 16,    17, 18, 19,    15, 20, 21,    15, 21, 16,    20, 22, 23,
    20, 23, 21,    22, 24, 25,    22, 25, 23,    24, 26, 27,    24, 27, 25,
    26, 28, 29,    26, 29, 27,    30, 31, 32,    28, 3, 29,    33, 34, 35,
    33, 35, 36,    37, 38, 39,    37, 39, 40,    38, 8, 41,    38, 41, 39,
    8, 42, 43,    8, 43, 41,    44, 45, 46,    44, 46, 47,    19, 18, 48,
    19, 48, 49,    50, 51, 52,    50, 52, 53,    54, 55, 56,    54, 56, 57,
    58, 59, 60,    58, 60, 61,    62, 63, 64,    62, 64, 65,    66, 67, 68,
    66, 68, 69,    70, 71, 72,    70, 72, 73,    74, 75, 76,    74, 76, 77,
    75, 78, 79,    75, 79, 76,    39, 41, 80,    39, 80, 81,    82, 83, 84,
    82, 84, 85,    83, 86, 87,    83, 87, 84,    86, 88, 89,    90, 91, 92,
    88, 93, 94,    88, 94, 89,    93, 95, 96,    93, 96, 94,    95, 97, 98,
    95, 98, 96,    97, 99, 100,    97, 100, 98,    99, 101, 102,    99, 102, 100,
    73, 72, 103,    101, 77, 102,    11, 15, 13,    11, 20, 15,    28, 1, 0,
    26, 1, 28,    24, 1, 26,    24, 4, 1,    22, 4, 24,    22, 10, 4,
    11, 22, 20,    10, 22, 11,    84, 87, 89,    84, 89, 94,    102, 77, 76,
    100, 102, 76,    98, 100, 76,    98, 76, 79,    96, 98, 79,    96, 79, 85,
    84, 94, 96,    85, 84, 96,    104, 105, 106,    106, 107, 104,    108, 109, 110,
    111, 112, 113,    114, 115, 116,    117, 118, 119,    120, 121, 122,    122, 123, 120,
    107, 106, 124,    124, 125, 107,    118, 117, 60,    60, 59, 118,    123, 122, 126,
    126, 127, 123,    128, 110, 58,    58, 61, 128,
};

D3DMATRIX g_tmat37 = 
{
    0.113584f, -0.988802f, -0.096791f, 0.000000f, 
    0.347561f, -0.051721f, 0.936230f, 0.000000f, 
    -0.930753f, -0.139981f, 0.337794f, 0.000000f, 
    -0.460584f, -2.335629f, 3.199513f, 1.000000f, 
};

// Mesh #37 Tris:240 Verts:268
MODELVERT g_tmesh37[] = 
{
    { {0.175005f, -0.161276f, -0.060014f}, {0.540195f, 0.187847f, -0.820306f}, {0.299864f, 0.340445f} },
    { {0.111651f, 0.027069f, -0.060014f}, {0.624256f, 0.211734f, -0.751980f}, {0.321800f, 0.255821f} },
    { {0.119107f, 0.029547f, -0.053127f}, {0.932604f, 0.332628f, -0.140031f}, {0.319219f, 0.254707f} },
    { {0.187426f, -0.160765f, -0.053127f}, {0.860278f, -0.507417f, -0.049498f}, {0.295564f, 0.340216f} },
    { {0.104445f, 0.047558f, -0.060014f}, {0.585513f, 0.294121f, -0.755425f}, {0.324295f, 0.246615f} },
    { {0.111468f, 0.051266f, -0.053127f}, {0.893692f, 0.443361f, -0.068891f}, {0.321863f, 0.244949f} },
    { {0.093655f, 0.066056f, -0.060014f}, {0.518354f, 0.396886f, -0.757490f}, {0.328031f, 0.238304f} },
    { {0.100031f, 0.070873f, -0.053127f}, {0.795036f, 0.602594f, -0.069273f}, {0.325824f, 0.236139f} },
    { {0.079704f, 0.082138f, -0.060014f}, {0.435631f, 0.485499f, -0.757968f}, {0.332862f, 0.231078f} },
    { {0.085242f, 0.087921f, -0.053127f}, {0.669831f, 0.739269f, -0.069348f}, {0.330944f, 0.228480f} },
    { {0.063014f, 0.095383f, -0.060014f}, {0.338514f, 0.559035f, -0.756894f}, {0.338640f, 0.225127f} },
    { {0.067552f, 0.101960f, -0.053127f}, {0.520892f, 0.850822f, -0.069088f}, {0.337069f, 0.222172f} },
    { {0.044010f, 0.105367f, -0.060014f}, {0.227916f, 0.615881f, -0.754152f}, {0.345220f, 0.220641f} },
    { {0.047407f, 0.112543f, -0.053127f}, {0.350890f, 0.933912f, -0.068442f}, {0.344044f, 0.217417f} },
    { {0.023113f, 0.111668f, -0.060014f}, {0.105574f, 0.653436f, -0.749584f}, {0.352456f, 0.217810f} },
    { {0.025256f, 0.119222f, -0.053127f}, {0.164112f, 0.984139f, -0.067360f}, {0.351714f, 0.214416f} },
    { {0.000746f, 0.113862f, -0.060014f}, {-0.035312f, 0.668971f, -0.742449f}, {0.360200f, 0.216824f} },
    { {0.001548f, 0.121548f, -0.053127f}, {-0.047368f, 0.996855f, -0.063537f}, {0.359922f, 0.213371f} },
    { {-0.025427f, 0.110842f, -0.060014f}, {-0.179485f, 0.655114f, -0.733901f}, {0.369262f, 0.218181f} },
    { {-0.026197f, 0.118347f, -0.053127f}, {-0.257841f, 0.963945f, -0.065784f}, {0.369529f, 0.214809f} },
    { {-0.049464f, 0.102242f, -0.060014f}, {-0.327122f, 0.608764f, -0.722770f}, {0.377585f, 0.222045f} },
    { {-0.051675f, 0.109230f, -0.053127f}, {-0.467227f, 0.881857f, -0.063459f}, {0.378350f, 0.218905f} },
    { {-0.070674f, 0.088749f, -0.060014f}, {-0.460787f, 0.531991f, -0.710395f}, {0.384929f, 0.228107f} },
    { {-0.074158f, 0.094928f, -0.053127f}, {-0.649150f, 0.758203f, -0.061100f}, {0.386135f, 0.225331f} },
    { {-0.088370f, 0.071053f, -0.060014f}, {-0.575940f, 0.426779f, -0.697247f}, {0.391056f, 0.236058f} },
    { {-0.092915f, 0.076171f, -0.053127f}, {-0.798653f, 0.598917f, -0.058752f}, {0.392629f, 0.233759f} },
    { {-0.101862f, 0.049843f, -0.060014f}, {-0.667687f, 0.294634f, -0.683655f}, {0.395727f, 0.245588f} },
    { {-0.107217f, 0.053688f, -0.053127f}, {-0.911072f, 0.408369f, -0.056410f}, {0.397581f, 0.243861f} },
    { {-0.110463f, 0.025807f, -0.060014f}, {-0.729249f, 0.138651f, -0.670053f}, {0.398705f, 0.256388f} },
    { {-0.116334f, 0.028209f, -0.053127f}, {-0.979842f, 0.192318f, -0.054077f}, {0.400738f, 0.255308f} },
    { {-0.113483f, -0.000367f, -0.060014f}, {-0.749898f, 0.018783f, -0.661287f}, {0.399751f, 0.268148f} },
    { {-0.119535f, 0.000465f, -0.053127f}, {-0.997476f, 0.030048f, -0.064334f}, {0.401846f, 0.267774f} },
    { {-0.112676f, -0.013993f, -0.060014f}, {-0.749776f, -0.104265f, -0.653425f}, {0.399471f, 0.274270f} },
    { {-0.118680f, -0.013978f, -0.053127f}, {-0.989543f, -0.134474f, -0.052161f}, {0.401550f, 0.274264f} },
    { {-0.110319f, -0.027146f, -0.060014f}, {-0.736428f, -0.192534f, -0.648540f}, {0.398655f, 0.280180f} },
    { {-0.116181f, -0.027921f, -0.053127f}, {-0.966976f, -0.249639f, -0.051366f}, {0.400685f, 0.280528f} },
    { {-0.106502f, -0.039735f, -0.060014f}, {-0.712403f, -0.277771f, -0.644457f}, {0.397334f, 0.285836f} },
    { {-0.112136f, -0.041265f, -0.053127f}, {-0.931579f, -0.359986f, -0.050704f}, {0.399284f, 0.286524f} },
    { {-0.101320f, -0.051667f, -0.060014f}, {-0.678402f, -0.358581f, -0.641241f}, {0.395539f, 0.291197f} },
    { {-0.106642f, -0.053913f, -0.053127f}, {-0.884370f, -0.464082f, -0.050178f}, {0.397382f, 0.292207f} },
    { {-0.094864f, -0.062849f, -0.060014f}, {-0.635186f, -0.433911f, -0.638952f}, {0.393304f, 0.296222f} },
    { {-0.099799f, -0.065766f, -0.053127f}, {-0.826356f, -0.560943f, -0.049789f}, {0.395013f, 0.297532f} },
    { {-0.087226f, -0.073190f, -0.060014f}, {-0.588163f, -0.506545f, -0.630458f}, {0.390659f, 0.300868f} },
    { {-0.091703f, -0.076727f, -0.053127f}, {-0.758416f, -0.649885f, -0.049535f}, {0.392210f, 0.302457f} },
    { {-0.071969f, -0.090203f, -0.060014f}, {-0.349907f, 0.577540f, -0.737572f}, {0.385377f, 0.308512f} },
    { {-0.082453f, -0.086697f, -0.053127f}, {-0.483298f, 0.874092f, -0.048844f}, {0.389007f, 0.306937f} },
    { {-0.136078f, -0.114535f, -0.060014f}, {-0.310459f, 0.715533f, -0.625802f}, {0.407574f, 0.319444f} },
    { {-0.142321f, -0.111221f, -0.053127f}, {-0.412098f, 0.907365f, -0.082852f}, {0.409736f, 0.317955f} },
    { {-0.148487f, -0.121610f, -0.060014f}, {-0.411076f, 0.613300f, -0.674448f}, {0.411871f, 0.322623f} },
    { {-0.155475f, -0.118720f, -0.053127f}, {-0.553226f, 0.831104f, -0.056632f}, {0.414290f, 0.321325f} },
    { {-0.157838f, -0.128481f, -0.060014f}, {-0.469567f, 0.530679f, -0.705611f}, {0.415108f, 0.325710f} },
    { {-0.165387f, -0.126003f, -0.053127f}, {-0.658446f, 0.750128f, -0.061301f}, {0.417722f, 0.324597f} },
    { {-0.164640f, -0.135181f, -0.060014f}, {-0.523891f, 0.430452f, -0.735016f}, {0.417464f, 0.328721f} },
    { {-0.172597f, -0.133105f, -0.053127f}, {-0.768075f, 0.636926f, -0.066225f}, {0.420219f, 0.327788f} },
    { {-0.169404f, -0.141745f, -0.060014f}, {-0.566247f, 0.325551f, -0.757219f}, {0.419113f, 0.331670f} },
    { {-0.177647f, -0.140063f, -0.053127f}, {-0.862579f, 0.501015f, -0.070295f}, {0.421967f, 0.330914f} },
    { {-0.172638f, -0.148207f, -0.060014f}, {-0.592671f, 0.235401f, -0.770278f}, {0.420233f, 0.334573f} },
    { {-0.181075f, -0.146913f, -0.053127f}, {-0.925626f, 0.371381f, -0.072744f}, {0.423154f, 0.333992f} },
    { {-0.174854f, -0.154601f, -0.060014f}, {-0.604905f, 0.177752f, -0.776205f}, {0.421000f, 0.337446f} },
    { {-0.183423f, -0.153690f, -0.053127f}, {-0.956292f, 0.282964f, -0.073732f}, {0.423967f, 0.337037f} },
    { {-0.176559f, -0.160960f, -0.060014f}, {-0.607481f, 0.162911f, -0.777449f}, {0.421590f, 0.340304f} },
    { {-0.185231f, -0.160431f, -0.053127f}, {-0.011111f, -0.999937f, -0.001463f}, {0.424593f, 0.340066f} },
    { {0.187426f, -0.160765f, -0.053127f}, {0.860278f, -0.507417f, -0.049498f}, {0.295796f, 0.333161f} },
    { {0.119107f, 0.029547f, -0.053127f}, {0.932604f, 0.332628f, -0.140031f}, {0.382620f, 0.333161f} },
    { {0.119107f, 0.029547f, 0.053059f}, {0.940523f, 0.337234f, 0.041119f}, {0.382620f, 0.220845f} },
    { {0.187426f, -0.160765f, 0.053059f}, {0.305647f, -0.950665f, 0.053056f}, {0.295796f, 0.220845f} },
    { {0.111468f, 0.051266f, -0.053127f}, {0.893692f, 0.443361f, -0.068891f}, {0.392529f, 0.333161f} },
    { {0.111468f, 0.051266f, 0.053059f}, {0.917108f, 0.392726f, 0.068408f}, {0.392529f, 0.220845f} },
    { {0.100031f, 0.070873f, -0.053127f}, {0.795036f, 0.602594f, -0.069273f}, {0.401474f, 0.333161f} },
    { {0.100031f, 0.070873f, 0.053059f}, {0.826930f, 0.558053f, 0.069025f}, {0.401474f, 0.220845f} },
    { {0.100031f, 0.070873f, -0.053127f}, {0.795036f, 0.602594f, -0.069273f}, {0.325824f, 0.333161f} },
    { {0.085242f, 0.087921f, -0.053127f}, {0.669831f, 0.739269f, -0.069348f}, {0.330944f, 0.333161f} },
    { {0.085242f, 0.087921f, 0.053059f}, {0.709185f, 0.701611f, 0.069271f}, {0.330944f, 0.220845f} },
    { {0.100031f, 0.070873f, 0.053059f}, {0.826930f, 0.558053f, 0.069025f}, {0.325824f, 0.220845f} },
    { {0.067552f, 0.101960f, -0.053127f}, {0.520892f, 0.850822f, -0.069088f}, {0.337069f, 0.333161f} },
    { {0.067552f, 0.101960f, 0.053059f}, {0.566959f, 0.820835f, 0.069191f}, {0.337069f, 0.220845f} },
    { {0.047407f, 0.112543f, -0.053127f}, {0.350890f, 0.933912f, -0.068442f}, {0.344044f, 0.333161f} },
    { {0.047407f, 0.112543f, 0.053059f}, {0.402805f, 0.912696f, 0.068807f}, {0.344044f, 0.220845f} },
    { {0.025256f, 0.119222f, -0.053127f}, {0.164112f, 0.984139f, -0.067360f}, {0.351714f, 0.333161f} },
    { {0.025256f, 0.119222f, 0.053059f}, {0.220336f, 0.973042f, 0.068128f}, {0.351714f, 0.220845f} },
    { {0.001548f, 0.121548f, -0.053127f}, {-0.047368f, 0.996855f, -0.063537f}, {0.359922f, 0.333161f} },
    { {0.001548f, 0.121548f, 0.053059f}, {0.014794f, 0.997479f, 0.069405f}, {0.359922f, 0.220845f} },
    { {-0.026197f, 0.118347f, -0.053127f}, {-0.257841f, 0.963945f, -0.065784f}, {0.369529f, 0.333161f} },
    { {-0.026197f, 0.118347f, 0.053059f}, {-0.192314f, 0.979256f, 0.063818f}, {0.369529f, 0.220845f} },
    { {-0.051675f, 0.109230f, -0.053127f}, {-0.467227f, 0.881857f, -0.063459f}, {0.378350f, 0.333161f} },
    { {-0.051675f, 0.109230f, 0.053059f}, {-0.408329f, 0.910721f, 0.062095f}, {0.378350f, 0.220845f} },
    { {-0.074158f, 0.094928f, -0.053127f}, {-0.649150f, 0.758203f, -0.061100f}, {0.386135f, 0.333161f} },
    { {-0.074158f, 0.094928f, 0.053059f}, {-0.598951f, 0.798524f, 0.060141f}, {0.386135f, 0.220845f} },
    { {-0.092915f, 0.076171f, -0.053127f}, {-0.798653f, 0.598917f, -0.058752f}, {0.392629f, 0.333161f} },
    { {-0.092915f, 0.076171f, 0.053059f}, {-0.758407f, 0.649185f, 0.058125f}, {0.392629f, 0.220845f} },
    { {-0.092915f, 0.076171f, -0.053127f}, {-0.798653f, 0.598917f, -0.058752f}, {0.316265f, 0.333161f} },
    { {-0.107217f, 0.053688f, -0.053127f}, {-0.911072f, 0.408369f, -0.056410f}, {0.326523f, 0.333161f} },
    { {-0.107217f, 0.053688f, 0.053059f}, {-0.882293f, 0.467337f, 0.056176f}, {0.326523f, 0.220845f} },
    { {-0.092915f, 0.076171f, 0.053059f}, {-0.758407f, 0.649185f, 0.058125f}, {0.316265f, 0.220845f} },
    { {-0.116334f, 0.028209f, -0.053127f}, {-0.979842f, 0.192318f, -0.054077f}, {0.338146f, 0.333161f} },
    { {-0.116334f, 0.028209f, 0.053059f}, {-0.964636f, 0.257910f, 0.054408f}, {0.338146f, 0.220845f} },
    { {-0.119535f, 0.000465f, -0.053127f}, {-0.997476f, 0.030048f, -0.064334f}, {0.350804f, 0.333161f} },
    { {-0.119535f, 0.000465f, 0.053059f}, {-0.996140f, 0.076419f, 0.043193f}, {0.350804f, 0.220845f} },
    { {-0.118680f, -0.013978f, -0.053127f}, {-0.989543f, -0.134474f, -0.052161f}, {0.357393f, 0.333161f} },
    { {-0.118680f, -0.013978f, 0.053059f}, {-0.993670f, -0.100004f, 0.051172f}, {0.357393f, 0.220845f} },
    { {-0.116181f, -0.027921f, -0.053127f}, {-0.966976f, -0.249639f, -0.051366f}, {0.363754f, 0.333161f} },
    { {-0.116181f, -0.027921f, 0.053059f}, {-0.975027f, -0.216245f, 0.050595f}, {0.363754f, 0.220845f} },
    { {-0.112136f, -0.041265f, -0.053127f}, {-0.931579f, -0.359986f, -0.050704f}, {0.369842f, 0.333161f} },
    { {-0.112136f, -0.041265f, 0.053059f}, {-0.943285f, -0.328179f, 0.050119f}, {0.369842f, 0.220845f} },
    { {-0.106642f, -0.053913f, -0.053127f}, {-0.884370f, -0.464082f, -0.050178f}, {0.375612f, 0.333161f} },
    { {-0.106642f, -0.053913f, 0.053059f}, {-0.899427f, -0.434231f, 0.049750f}, {0.375612f, 0.220845f} },
    { {-0.099799f, -0.065766f, -0.053127f}, {-0.826356f, -0.560943f, -0.049789f}, {0.381020f, 0.333161f} },
    { {-0.099799f, -0.065766f, 0.053059f}, {-0.844480f, -0.533296f, 0.049494f}, {0.381020f, 0.220845f} },
    { {-0.091703f, -0.076727f, -0.053127f}, {-0.758416f, -0.649885f, -0.049535f}, {0.386020f, 0.333161f} },
    { {-0.091703f, -0.076727f, 0.053059f}, {-0.778611f, -0.624667f, 0.059640f}, {0.386020f, 0.220845f} },
    { {-0.091703f, -0.076727f, -0.053127f}, {-0.758416f, -0.649885f, -0.049535f}, {0.327947f, 0.333161f} },
    { {-0.082453f, -0.086697f, -0.053127f}, {-0.483298f, 0.874092f, -0.048844f}, {0.331150f, 0.333161f} },
    { {-0.082453f, -0.086697f, 0.053059f}, {-0.697257f, 0.706254f, 0.122625f}, {0.331150f, 0.220845f} },
    { {-0.091703f, -0.076727f, 0.053059f}, {-0.778611f, -0.624667f, 0.059640f}, {0.327947f, 0.220845f} },
    { {-0.082453f, -0.086697f, -0.053127f}, {-0.483298f, 0.874092f, -0.048844f}, {0.389007f, 0.333161f} },
    { {-0.142321f, -0.111221f, -0.053127f}, {-0.412098f, 0.907365f, -0.082852f}, {0.409736f, 0.333161f} },
    { {-0.142321f, -0.111221f, 0.053059f}, {-0.392354f, 0.919224f, 0.032938f}, {0.409736f, 0.220845f} },
    { {-0.082453f, -0.086697f, 0.053059f}, {-0.697257f, 0.706254f, 0.122625f}, {0.389007f, 0.220845f} },
    { {-0.155475f, -0.118720f, -0.053127f}, {-0.553226f, 0.831104f, -0.056632f}, {0.414290f, 0.333161f} },
    { {-0.155475f, -0.118720f, 0.053059f}, {-0.525129f, 0.849489f, 0.051071f}, {0.414290f, 0.220845f} },
    { {-0.165387f, -0.126003f, -0.053127f}, {-0.658446f, 0.750128f, -0.061301f}, {0.417722f, 0.333161f} },
    { {-0.165387f, -0.126003f, 0.053059f}, {-0.626532f, 0.777391f, 0.055867f}, {0.417722f, 0.220845f} },
    { {-0.172597f, -0.133105f, -0.053127f}, {-0.768075f, 0.636926f, -0.066225f}, {0.420219f, 0.333161f} },
    { {-0.172597f, -0.133105f, 0.053059f}, {-0.736637f, 0.673496f, 0.061397f}, {0.420219f, 0.220845f} },
    { {-0.172597f, -0.133105f, -0.053127f}, {-0.768075f, 0.636926f, -0.066225f}, {0.411741f, 0.333161f} },
    { {-0.177647f, -0.140063f, -0.053127f}, {-0.862579f, 0.501015f, -0.070295f}, {0.414916f, 0.333161f} },
    { {-0.177647f, -0.140063f, 0.053059f}, {-0.837741f, 0.541988f, 0.066633f}, {0.414916f, 0.220845f} },
    { {-0.172597f, -0.133105f, 0.053059f}, {-0.736637f, 0.673496f, 0.061397f}, {0.411741f, 0.220845f} },
    { {-0.181075f, -0.146913f, -0.053127f}, {-0.925626f, 0.371381f, -0.072744f}, {0.418040f, 0.333161f} },
    { {-0.181075f, -0.146913f, 0.053059f}, {-0.910845f, 0.406682f, 0.070504f}, {0.418040f, 0.220845f} },
    { {-0.183423f, -0.153690f, -0.053127f}, {-0.956292f, 0.282964f, -0.073732f}, {0.421132f, 0.333161f} },
    { {-0.183423f, -0.153690f, 0.053059f}, {-0.950207f, 0.303015f, 0.072722f}, {0.421132f, 0.220845f} },
    { {-0.185231f, -0.160431f, -0.053127f}, {-0.011111f, -0.999937f, -0.001463f}, {0.424208f, 0.333161f} },
    { {-0.185231f, -0.160431f, 0.053059f}, {-0.038638f, -0.999252f, 0.001516f}, {0.424208f, 0.220845f} },
    { {-0.185231f, -0.160431f, -0.053127f}, {-0.011111f, -0.999937f, -0.001463f}, {0.295564f, 0.333161f} },
    { {0.187426f, -0.160765f, -0.053127f}, {0.860278f, -0.507417f, -0.049498f}, {0.424593f, 0.333161f} },
    { {0.187426f, -0.160765f, 0.053059f}, {0.305647f, -0.950665f, 0.053056f}, {0.424593f, 0.220845f} },
    { {-0.185231f, -0.160431f, 0.053059f}, {-0.038638f, -0.999252f, 0.001516f}, {0.295564f, 0.220845f} },
    { {0.187426f, -0.160765f, 0.053059f}, {0.305647f, -0.950665f, 0.053056f}, {0.424593f, 0.340216f} },
    { {0.119107f, 0.029547f, 0.053059f}, {0.940523f, 0.337234f, 0.041119f}, {0.400938f, 0.254707f} },
    { {0.111651f, 0.027069f, 0.060126f}, {0.553356f, 0.192535f, 0.810387f}, {0.398356f, 0.255821f} },
    { {0.175005f, -0.161276f, 0.060126f}, {0.482855f, 0.162418f, 0.860506f}, {0.420292f, 0.340445f} },
    { {0.111468f, 0.051266f, 0.053059f}, {0.917108f, 0.392726f, 0.068408f}, {0.398293f, 0.244949f} },
    { {0.104445f, 0.047558f, 0.060126f}, {0.613648f, 0.259130f, 0.745847f}, {0.395861f, 0.246615f} },
    { {0.100031f, 0.070873f, 0.053059f}, {0.826930f, 0.558053f, 0.069025f}, {0.394333f, 0.236139f} },
    { {0.093655f, 0.066056f, 0.060126f}, {0.551456f, 0.368185f, 0.748556f}, {0.392125f, 0.238304f} },
    { {0.085242f, 0.087921f, 0.053059f}, {0.709185f, 0.701611f, 0.069271f}, {0.389213f, 0.228480f} },
    { {0.079704f, 0.082138f, 0.060126f}, {0.472822f, 0.463175f, 0.749605f}, {0.387295f, 0.231078f} },
    { {0.067552f, 0.101960f, 0.053059f}, {0.566959f, 0.820835f, 0.069191f}, {0.383087f, 0.222172f} },
    { {0.063014f, 0.095383f, 0.060126f}, {0.379219f, 0.543207f, 0.749079f}, {0.381516f, 0.225127f} },
    { {0.047407f, 0.112543f, 0.053059f}, {0.402805f, 0.912696f, 0.068807f}, {0.376112f, 0.217417f} },
    { {0.044010f, 0.105367f, 0.060126f}, {0.271577f, 0.606937f, 0.746909f}, {0.374936f, 0.220641f} },
    { {0.025256f, 0.119222f, 0.053059f}, {0.220336f, 0.973042f, 0.068128f}, {0.368443f, 0.214416f} },
    { {0.023113f, 0.111668f, 0.060126f}, {0.151250f, 0.652057f, 0.742930f}, {0.367701f, 0.217810f} },
    { {0.001548f, 0.121548f, 0.053059f}, {0.014794f, 0.997479f, 0.069405f}, {0.360234f, 0.213371f} },
    { {0.000746f, 0.113862f, 0.060126f}, {0.014035f, 0.675966f, 0.736799f}, {0.359957f, 0.216824f} },
    { {-0.026197f, 0.118347f, 0.053059f}, {-0.192314f, 0.979256f, 0.063818f}, {0.350628f, 0.214809f} },
    { {-0.025427f, 0.110842f, 0.060126f}, {-0.127942f, 0.672921f, 0.728566f}, {0.350894f, 0.218181f} },
    { {-0.051675f, 0.109230f, 0.053059f}, {-0.408329f, 0.910721f, 0.062095f}, {0.341806f, 0.218905f} },
    { {-0.049464f, 0.102242f, 0.060126f}, {-0.281063f, 0.636931f, 0.717860f}, {0.342572f, 0.222045f} },
    { {-0.074158f, 0.094928f, 0.053059f}, {-0.598951f, 0.798524f, 0.060141f}, {0.334022f, 0.225331f} },
    { {-0.070674f, 0.088749f, 0.060126f}, {-0.421816f, 0.569243f, 0.705715f}, {0.335228f, 0.228107f} },
    { {-0.092915f, 0.076171f, 0.053059f}, {-0.758407f, 0.649185f, 0.058125f}, {0.327527f, 0.233759f} },
    { {-0.088370f, 0.071053f, 0.060126f}, {-0.545188f, 0.472217f, 0.692662f}, {0.329101f, 0.236058f} },
    { {-0.107217f, 0.053688f, 0.053059f}, {-0.882293f, 0.467337f, 0.056176f}, {0.322575f, 0.243861f} },
    { {-0.101862f, 0.049843f, 0.060126f}, {-0.646624f, 0.347466f, 0.679076f}, {0.324429f, 0.245588f} },
    { {-0.116334f, 0.028209f, 0.053059f}, {-0.964636f, 0.257910f, 0.054408f}, {0.319419f, 0.255308f} },
    { {-0.110463f, 0.025807f, 0.060126f}, {-0.720033f, 0.197271f, 0.665310f}, {0.321452f, 0.256388f} },
    { {-0.119535f, 0.000465f, 0.053059f}, {-0.996140f, 0.076419f, 0.043193f}, {0.318310f, 0.267774f} },
    { {-0.113483f, -0.000367f, 0.060126f}, {-0.754579f, 0.060489f, 0.653415f}, {0.320406f, 0.268148f} },
    { {-0.118680f, -0.013978f, 0.053059f}, {-0.993670f, -0.100004f, 0.051172f}, {0.318606f, 0.274264f} },
    { {-0.112676f, -0.013993f, 0.060126f}, {-0.760052f, -0.074096f, 0.645625f}, {0.320685f, 0.274270f} },
    { {-0.116181f, -0.027921f, 0.053059f}, {-0.975027f, -0.216245f, 0.050595f}, {0.319472f, 0.280528f} },
    { {-0.110319f, -0.027146f, 0.060126f}, {-0.750296f, -0.163968f, 0.640445f}, {0.321501f, 0.280180f} },
    { {-0.112136f, -0.041265f, 0.053059f}, {-0.943285f, -0.328179f, 0.050119f}, {0.320872f, 0.286524f} },
    { {-0.106502f, -0.039735f, 0.060126f}, {-0.729570f, -0.251327f, 0.636053f}, {0.322823f, 0.285836f} },
    { {-0.106642f, -0.053913f, 0.053059f}, {-0.899427f, -0.434231f, 0.049750f}, {0.322774f, 0.292207f} },
    { {-0.101320f, -0.051667f, 0.060126f}, {-0.698529f, -0.334643f, 0.632512f}, {0.324617f, 0.291197f} },
    { {-0.099799f, -0.065766f, 0.053059f}, {-0.844480f, -0.533296f, 0.049494f}, {0.325144f, 0.297532f} },
    { {-0.094864f, -0.062849f, 0.060126f}, {-0.657940f, -0.412748f, 0.629884f}, {0.326853f, 0.296222f} },
    { {-0.091703f, -0.076727f, 0.053059f}, {-0.778611f, -0.624667f, 0.059640f}, {0.327947f, 0.302457f} },
    { {-0.087226f, -0.073190f, 0.060126f}, {-0.604941f, -0.489301f, 0.628196f}, {0.329497f, 0.300868f} },
    { {-0.082453f, -0.086697f, 0.053059f}, {-0.697257f, 0.706254f, 0.122625f}, {0.331150f, 0.306937f} },
    { {-0.071969f, -0.090203f, 0.060126f}, {-0.441367f, 0.340616f, 0.830167f}, {0.334779f, 0.308512f} },
    { {-0.142321f, -0.111221f, 0.053059f}, {-0.392354f, 0.919224f, 0.032938f}, {0.310421f, 0.317955f} },
    { {-0.136078f, -0.114535f, 0.060126f}, {-0.284839f, 0.694573f, 0.660632f}, {0.312582f, 0.319444f} },
    { {-0.155475f, -0.118720f, 0.053059f}, {-0.525129f, 0.849489f, 0.051071f}, {0.305866f, 0.321325f} },
    { {-0.148487f, -0.121610f, 0.060126f}, {-0.395643f, 0.644115f, 0.654662f}, {0.308286f, 0.322623f} },
    { {-0.165387f, -0.126003f, 0.053059f}, {-0.626532f, 0.777391f, 0.055867f}, {0.302435f, 0.324597f} },
    { {-0.157838f, -0.128481f, 0.060126f}, {-0.454929f, 0.568615f, 0.685359f}, {0.305048f, 0.325710f} },
    { {-0.172597f, -0.133105f, 0.053059f}, {-0.736637f, 0.673496f, 0.061397f}, {0.299938f, 0.327788f} },
    { {-0.164640f, -0.135181f, 0.060126f}, {-0.512917f, 0.472872f, 0.716456f}, {0.302693f, 0.328721f} },
    { {-0.177647f, -0.140063f, 0.053059f}, {-0.837741f, 0.541988f, 0.066633f}, {0.298190f, 0.330914f} },
    { {-0.169404f, -0.141745f, 0.060126f}, {-0.561336f, 0.366504f, 0.742009f}, {0.301044f, 0.331670f} },
    { {-0.181075f, -0.146913f, 0.053059f}, {-0.910845f, 0.406682f, 0.070504f}, {0.297002f, 0.333992f} },
    { {-0.172638f, -0.148207f, 0.060126f}, {-0.594194f, 0.267726f, 0.758457f}, {0.299924f, 0.334573f} },
    { {-0.183423f, -0.153690f, 0.053059f}, {-0.950207f, 0.303015f, 0.072722f}, {0.296189f, 0.337037f} },
    { {-0.174854f, -0.154601f, 0.060126f}, {-0.611329f, 0.196219f, 0.766665f}, {0.299157f, 0.337446f} },
    { {-0.185231f, -0.160431f, 0.053059f}, {-0.038638f, -0.999252f, 0.001516f}, {0.295564f, 0.340066f} },
    { {-0.176559f, -0.160960f, 0.060126f}, {-0.616902f, 0.165436f, 0.769456f}, {0.298566f, 0.340304f} },
    { {-0.176559f, -0.160960f, -0.060014f}, {0.000000f, 0.000000f, -1.000000f}, {0.421590f, 0.340304f} },
    { {0.111651f, 0.027069f, -0.060014f}, {0.000000f, 0.000000f, -1.000000f}, {0.321800f, 0.255821f} },
    { {0.175005f, -0.161276f, -0.060014f}, {0.000000f, 0.000000f, -1.000000f}, {0.299864f, 0.340445f} },
    { {-0.174854f, -0.154601f, -0.060014f}, {0.000000f, -0.000000f, -1.000000f}, {0.421000f, 0.337446f} },
    { {-0.172638f, -0.148207f, -0.060014f}, {-0.000000f, 0.000000f, -1.000000f}, {0.420233f, 0.334573f} },
    { {0.000746f, 0.113862f, -0.060014f}, {-0.000000f, 0.000000f, -1.000000f}, {0.360200f, 0.216824f} },
    { {-0.049464f, 0.102242f, -0.060014f}, {0.000000f, 0.000000f, -1.000000f}, {0.377585f, 0.222045f} },
    { {-0.025427f, 0.110842f, -0.060014f}, {-0.000000f, 0.000001f, -1.000000f}, {0.369262f, 0.218181f} },
    { {-0.070674f, 0.088749f, -0.060014f}, {0.000000f, -0.000000f, -1.000000f}, {0.384929f, 0.228107f} },
    { {-0.088370f, 0.071053f, -0.060014f}, {0.000000f, -0.000000f, -1.000000f}, {0.391056f, 0.236058f} },
    { {-0.101862f, 0.049843f, -0.060014f}, {-0.000000f, 0.000000f, -1.000000f}, {0.395727f, 0.245588f} },
    { {-0.110463f, 0.025807f, -0.060014f}, {0.000000f, 0.000000f, -1.000000f}, {0.398705f, 0.256388f} },
    { {-0.113483f, -0.000367f, -0.060014f}, {0.000000f, 0.000000f, -1.000000f}, {0.399751f, 0.268148f} },
    { {0.023113f, 0.111668f, -0.060014f}, {-0.000000f, 0.000000f, -1.000000f}, {0.352456f, 0.217810f} },
    { {0.044010f, 0.105367f, -0.060014f}, {0.000000f, 0.000000f, -1.000000f}, {0.345220f, 0.220641f} },
    { {0.063014f, 0.095383f, -0.060014f}, {0.000000f, 0.000000f, -1.000000f}, {0.338640f, 0.225127f} },
    { {0.079704f, 0.082138f, -0.060014f}, {0.000000f, 0.000000f, -1.000000f}, {0.332862f, 0.231078f} },
    { {0.093655f, 0.066056f, -0.060014f}, {0.000000f, 0.000000f, -1.000000f}, {0.328031f, 0.238304f} },
    { {0.104445f, 0.047558f, -0.060014f}, {0.000000f, 0.000000f, -1.000000f}, {0.324295f, 0.246615f} },
    { {-0.112676f, -0.013993f, -0.060014f}, {0.000000f, 0.000000f, -1.000000f}, {0.399471f, 0.274270f} },
    { {-0.110319f, -0.027146f, -0.060014f}, {0.000000f, 0.000000f, -1.000000f}, {0.398655f, 0.280180f} },
    { {-0.106502f, -0.039735f, -0.060014f}, {0.000000f, 0.000000f, -1.000000f}, {0.397334f, 0.285836f} },
    { {-0.101320f, -0.051667f, -0.060014f}, {0.000000f, 0.000000f, -1.000000f}, {0.395539f, 0.291197f} },
    { {-0.094864f, -0.062849f, -0.060014f}, {0.000000f, 0.000000f, -1.000000f}, {0.393304f, 0.296222f} },
    { {-0.087226f, -0.073190f, -0.060014f}, {-0.000000f, 0.000000f, -1.000000f}, {0.390659f, 0.300868f} },
    { {-0.071969f, -0.090203f, -0.060014f}, {-0.000000f, 0.000000f, -1.000000f}, {0.385377f, 0.308512f} },
    { {-0.172638f, -0.148207f, -0.060014f}, {0.000000f, -0.000001f, 1.000000f}, {0.299924f, 0.334573f} },
    { {-0.071969f, -0.090203f, -0.060014f}, {0.000000f, -0.000001f, 1.000000f}, {0.334779f, 0.308512f} },
    { {0.111651f, 0.027069f, -0.060014f}, {0.000000f, -0.000001f, 1.000000f}, {0.398356f, 0.255821f} },
    { {-0.136078f, -0.114535f, -0.060014f}, {-0.000000f, 0.000001f, -1.000000f}, {0.407574f, 0.319444f} },
    { {-0.148487f, -0.121610f, -0.060014f}, {0.000001f, -0.000000f, -1.000000f}, {0.411871f, 0.322623f} },
    { {-0.157838f, -0.128481f, -0.060014f}, {0.000002f, -0.000002f, -1.000000f}, {0.415108f, 0.325710f} },
    { {-0.164640f, -0.135181f, -0.060014f}, {0.000000f, 0.000000f, -1.000000f}, {0.417464f, 0.328721f} },
    { {-0.169404f, -0.141745f, -0.060014f}, {0.000000f, 0.000000f, -1.000000f}, {0.419113f, 0.331670f} },
    { {-0.176559f, -0.160960f, 0.060126f}, {0.000000f, -0.000000f, 1.000000f}, {0.298566f, 0.340304f} },
    { {0.175005f, -0.161276f, 0.060126f}, {0.000000f, -0.000000f, 1.000000f}, {0.420292f, 0.340445f} },
    { {0.111651f, 0.027069f, 0.060126f}, {0.000000f, -0.000000f, 1.000000f}, {0.398356f, 0.255821f} },
    { {-0.174854f, -0.154601f, 0.060126f}, {0.000000f, -0.000001f, 1.000000f}, {0.299157f, 0.337446f} },
    { {-0.172638f, -0.148207f, 0.060126f}, {-0.000000f, 0.000000f, 1.000000f}, {0.299924f, 0.334573f} },
    { {0.000746f, 0.113862f, 0.060126f}, {0.000000f, -0.000000f, 1.000000f}, {0.359957f, 0.216824f} },
    { {-0.025427f, 0.110842f, 0.060126f}, {0.000001f, -0.000002f, 1.000000f}, {0.350894f, 0.218181f} },
    { {-0.049464f, 0.102242f, 0.060126f}, {0.000000f, -0.000001f, 1.000000f}, {0.342572f, 0.222045f} },
    { {-0.070674f, 0.088749f, 0.060126f}, {0.000000f, -0.000000f, 1.000000f}, {0.335228f, 0.228107f} },
    { {-0.088370f, 0.071053f, 0.060126f}, {0.000000f, -0.000000f, 1.000000f}, {0.329101f, 0.236058f} },
    { {-0.101862f, 0.049843f, 0.060126f}, {0.000000f, -0.000000f, 1.000000f}, {0.324429f, 0.245588f} },
    { {-0.110463f, 0.025807f, 0.060126f}, {0.000000f, -0.000000f, 1.000000f}, {0.321452f, 0.256388f} },
    { {-0.113483f, -0.000367f, 0.060126f}, {-0.000000f, -0.000000f, 1.000000f}, {0.320406f, 0.268148f} },
    { {0.023113f, 0.111668f, 0.060126f}, {-0.000000f, -0.000000f, 1.000000f}, {0.367701f, 0.217810f} },
    { {0.044010f, 0.105367f, 0.060126f}, {-0.000000f, 0.000000f, 1.000000f}, {0.374936f, 0.220641f} },
    { {0.063014f, 0.095383f, 0.060126f}, {-0.000000f, 0.000000f, 1.000000f}, {0.381516f, 0.225127f} },
    { {0.079704f, 0.082138f, 0.060126f}, {-0.000000f, -0.000000f, 1.000000f}, {0.387295f, 0.231078f} },
    { {0.093655f, 0.066056f, 0.060126f}, {-0.000000f, -0.000000f, 1.000000f}, {0.392125f, 0.238304f} },
    { {0.104445f, 0.047558f, 0.060126f}, {0.000000f, -0.000000f, 1.000000f}, {0.395861f, 0.246615f} },
    { {-0.112676f, -0.013993f, 0.060126f}, {0.000000f, -0.000000f, 1.000000f}, {0.320685f, 0.274270f} },
    { {-0.110319f, -0.027146f, 0.060126f}, {-0.000000f, -0.000000f, 1.000000f}, {0.321501f, 0.280180f} },
    { {-0.106502f, -0.039735f, 0.060126f}, {-0.000000f, -0.000000f, 1.000000f}, {0.322823f, 0.285836f} },
    { {-0.101320f, -0.051667f, 0.060126f}, {-0.000000f, 0.000000f, 1.000000f}, {0.324617f, 0.291197f} },
    { {-0.094864f, -0.062849f, 0.060126f}, {-0.000000f, 0.000000f, 1.000000f}, {0.326853f, 0.296222f} },
    { {-0.087226f, -0.073190f, 0.060126f}, {0.000000f, 0.000000f, 1.000000f}, {0.329497f, 0.300868f} },
    { {-0.071969f, -0.090203f, 0.060126f}, {-0.000000f, 0.000000f, 1.000000f}, {0.334779f, 0.308512f} },
    { {-0.172638f, -0.148207f, 0.060126f}, {0.000001f, -0.000001f, -1.000000f}, {0.420233f, 0.334573f} },
    { {0.111651f, 0.027069f, 0.060126f}, {0.000001f, -0.000001f, -1.000000f}, {0.321800f, 0.255821f} },
    { {-0.071969f, -0.090203f, 0.060126f}, {0.000001f, -0.000001f, -1.000000f}, {0.385377f, 0.308512f} },
    { {-0.136078f, -0.114535f, 0.060126f}, {-0.000000f, 0.000000f, 1.000000f}, {0.312582f, 0.319444f} },
    { {-0.148487f, -0.121610f, 0.060126f}, {0.000000f, 0.000000f, 1.000000f}, {0.308286f, 0.322623f} },
    { {-0.157838f, -0.128481f, 0.060126f}, {0.000000f, 0.000000f, 1.000000f}, {0.305048f, 0.325710f} },
    { {-0.164640f, -0.135181f, 0.060126f}, {0.000000f, 0.000000f, 1.000000f}, {0.302693f, 0.328721f} },
    { {-0.169404f, -0.141745f, 0.060126f}, {0.000000f, 0.000000f, 1.000000f}, {0.301044f, 0.331670f} },
};

WORD g_tind37[] = 
{
    0, 1, 2,    0, 2, 3,    1, 4, 5,    1, 5, 2,    4, 6, 7,
    4, 7, 5,    6, 8, 9,    6, 9, 7,    8, 10, 11,    8, 11, 9,
    10, 12, 13,    10, 13, 11,    12, 14, 15,    12, 15, 13,    14, 16, 17,
    14, 17, 15,    16, 18, 19,    16, 19, 17,    18, 20, 21,    18, 21, 19,
    20, 22, 23,    20, 23, 21,    22, 24, 25,    22, 25, 23,    24, 26, 27,
    24, 27, 25,    26, 28, 29,    26, 29, 27,    28, 30, 31,    28, 31, 29,
    30, 32, 33,    30, 33, 31,    32, 34, 35,    32, 35, 33,    34, 36, 37,
    34, 37, 35,    36, 38, 39,    36, 39, 37,    38, 40, 41,    38, 41, 39,
    40, 42, 43,    40, 43, 41,    42, 44, 45,    42, 45, 43,    44, 46, 47,
    44, 47, 45,    46, 48, 49,    46, 49, 47,    48, 50, 51,    48, 51, 49,
    50, 52, 53,    50, 53, 51,    52, 54, 55,    52, 55, 53,    54, 56, 57,
    54, 57, 55,    56, 58, 59,    56, 59, 57,    58, 60, 61,    58, 61, 59,
    62, 63, 64,    62, 64, 65,    63, 66, 67,    63, 67, 64,    66, 68, 69,
    66, 69, 67,    70, 71, 72,    70, 72, 73,    71, 74, 75,    71, 75, 72,
    74, 76, 77,    74, 77, 75,    76, 78, 79,    76, 79, 77,    78, 80, 81,
    78, 81, 79,    80, 82, 83,    80, 83, 81,    82, 84, 85,    82, 85, 83,
    84, 86, 87,    84, 87, 85,    86, 88, 89,    86, 89, 87,    90, 91, 92,
    90, 92, 93,    91, 94, 95,    91, 95, 92,    94, 96, 97,    94, 97, 95,
    96, 98, 99,    96, 99, 97,    98, 100, 101,    98, 101, 99,    100, 102, 103,
    100, 103, 101,    102, 104, 105,    102, 105, 103,    104, 106, 107,    104, 107, 105,
    106, 108, 109,    106, 109, 107,    110, 111, 112,    110, 112, 113,    114, 115, 116,
    114, 116, 117,    115, 118, 119,    115, 119, 116,    118, 120, 121,    118, 121, 119,
    120, 122, 123,    120, 123, 121,    124, 125, 126,    124, 126, 127,    125, 128, 129,
    125, 129, 126,    128, 130, 131,    128, 131, 129,    130, 132, 133,    130, 133, 131,
    134, 135, 136,    134, 136, 137,    138, 139, 140,    138, 140, 141,    139, 142, 143,
    139, 143, 140,    142, 144, 145,    142, 145, 143,    144, 146, 147,    144, 147, 145,
    146, 148, 149,    146, 149, 147,    148, 150, 151,    148, 151, 149,    150, 152, 153,
    150, 153, 151,    152, 154, 155,    152, 155, 153,    154, 156, 157,    154, 157, 155,
    156, 158, 159,    156, 159, 157,    158, 160, 161,    158, 161, 159,    160, 162, 163,
    160, 163, 161,    162, 164, 165,    162, 165, 163,    164, 166, 167,    164, 167, 165,
    166, 168, 169,    166, 169, 167,    168, 170, 171,    168, 171, 169,    170, 172, 173,
    170, 173, 171,    172, 174, 175,    172, 175, 173,    174, 176, 177,    174, 177, 175,
    176, 178, 179,    176, 179, 177,    178, 180, 181,    178, 181, 179,    180, 182, 183,
    180, 183, 181,    182, 184, 185,    182, 185, 183,    184, 186, 187,    184, 187, 185,
    186, 188, 189,    186, 189, 187,    188, 190, 191,    188, 191, 189,    190, 192, 193,
    190, 193, 191,    192, 194, 195,    192, 195, 193,    194, 196, 197,    194, 197, 195,
    196, 198, 199,    196, 199, 197,    200, 201, 202,    203, 201, 200,    204, 201, 203,
    205, 206, 207,    205, 208, 206,    205, 209, 208,    205, 210, 209,    205, 211, 210,
    205, 212, 211,    213, 212, 205,    214, 212, 213,    215, 212, 214,    216, 212, 215,
    217, 212, 216,    218, 212, 217,    201, 212, 218,    201, 219, 212,    201, 220, 219,
    201, 221, 220,    201, 222, 221,    201, 223, 222,    201, 224, 223,    201, 225, 224,
    226, 227, 228,    204, 229, 225,    204, 230, 229,    204, 231, 230,    204, 232, 231,
    204, 233, 232,    234, 235, 236,    237, 234, 236,    238, 237, 236,    239, 240, 241,
    239, 241, 242,    239, 242, 243,    239, 243, 244,    239, 244, 245,    239, 245, 246,
    247, 239, 246,    248, 247, 246,    249, 248, 246,    250, 249, 246,    251, 250, 246,
    252, 251, 246,    236, 252, 246,    236, 246, 253,    236, 253, 254,    236, 254, 255,
    236, 255, 256,    236, 256, 257,    236, 257, 258,    236, 258, 259,    260, 261, 262,
    238, 259, 263,    238, 263, 264,    238, 264, 265,    238, 265, 266,    238, 266, 267,

};

D3DMATRIX g_tmat38 = 
{
    0.352283f, -0.095815f, 0.930976f, 0.000000f, 
    0.930771f, 0.139804f, -0.337817f, 0.000000f, 
    -0.097786f, 0.985532f, 0.138433f, 0.000000f, 
    0.043753f, -2.415836f, 4.007970f, 1.000000f, 
};

// Mesh #38 Tris:200 Verts:138
MODELVERT g_tmesh38[] = 
{
    { {0.000000f, 0.000000f, -0.346479f}, {-0.000000f, -0.000000f, -1.000000f}, {0.360078f, 0.276908f} },
    { {0.000000f, -0.150331f, -0.312166f}, {0.045174f, -0.495998f, -0.867148f}, {0.360078f, 0.305185f} },
    { {0.065227f, -0.135444f, -0.312166f}, {0.255906f, -0.427278f, -0.867148f}, {0.347300f, 0.302384f} },
    { {0.117534f, -0.093730f, -0.312166f}, {0.415952f, -0.273931f, -0.867148f}, {0.337053f, 0.294538f} },
    { {0.146563f, -0.033452f, -0.312166f}, {0.493614f, -0.066328f, -0.867148f}, {0.331367f, 0.283200f} },
    { {0.146563f, 0.033452f, -0.312166f}, {0.473509f, 0.154412f, -0.867148f}, {0.331367f, 0.270616f} },
    { {0.117534f, 0.093730f, -0.312166f}, {0.359621f, 0.344568f, -0.867148f}, {0.337053f, 0.259278f} },
    { {0.065227f, 0.135444f, -0.312166f}, {0.174505f, 0.466479f, -0.867148f}, {0.347300f, 0.251432f} },
    { {0.000000f, 0.150331f, -0.312166f}, {-0.045174f, 0.495998f, -0.867148f}, {0.360078f, 0.248631f} },
    { {-0.065226f, 0.135444f, -0.312166f}, {-0.255906f, 0.427278f, -0.867148f}, {0.372856f, 0.251432f} },
    { {-0.117534f, 0.093730f, -0.312166f}, {-0.415952f, 0.273931f, -0.867148f}, {0.383103f, 0.259278f} },
    { {-0.146562f, 0.033452f, -0.312166f}, {-0.423005f, 0.096548f, -0.900969f}, {0.388790f, 0.270616f} },
    { {-0.146562f, -0.033452f, -0.312166f}, {-0.489136f, -0.092383f, -0.867301f}, {0.388790f, 0.283200f} },
    { {-0.117534f, -0.093730f, -0.312166f}, {-0.288036f, -0.229702f, -0.929663f}, {0.383103f, 0.294538f} },
    { {-0.065226f, -0.135444f, -0.312166f}, {-0.198610f, -0.455712f, -0.867687f}, {0.372856f, 0.302384f} },
    { {0.000000f, -0.270888f, -0.216026f}, {0.053692f, -0.791678f, -0.608574f}, {0.360078f, 0.327861f} },
    { {0.117534f, -0.244062f, -0.216026f}, {0.374530f, -0.705478f, -0.601687f}, {0.337053f, 0.322815f} },
    { {0.211789f, -0.168896f, -0.216026f}, {0.643536f, -0.473112f, -0.601687f}, {0.318589f, 0.308677f} },
    { {0.264097f, -0.060278f, -0.216026f}, {0.785081f, -0.147039f, -0.601687f}, {0.308341f, 0.288246f} },
    { {0.264097f, 0.060278f, -0.216026f}, {0.771131f, 0.208157f, -0.601687f}, {0.308341f, 0.265570f} },
    { {0.211789f, 0.168896f, -0.216026f}, {0.604449f, 0.522124f, -0.601687f}, {0.318589f, 0.245139f} },
    { {0.117534f, 0.244062f, -0.216026f}, {0.318049f, 0.732679f, -0.601687f}, {0.337053f, 0.231001f} },
    { {0.000000f, 0.270888f, -0.216026f}, {-0.031345f, 0.798117f, -0.601687f}, {0.360078f, 0.225955f} },
    { {-0.117534f, 0.244062f, -0.216026f}, {-0.374530f, 0.705478f, -0.601687f}, {0.383103f, 0.231001f} },
    { {-0.211789f, 0.168896f, -0.216026f}, {-0.643536f, 0.473111f, -0.601687f}, {0.401568f, 0.245139f} },
    { {-0.264096f, 0.060278f, -0.216026f}, {-0.716116f, 0.183133f, -0.673528f}, {0.411815f, 0.265570f} },
    { {-0.264096f, -0.012128f, -0.216026f}, {-0.860799f, -0.000000f, -0.508945f}, {0.411815f, 0.279189f} },
    { {-0.231341f, -0.052802f, -0.242819f}, {-0.614528f, -0.108139f, -0.781448f}, {0.405398f, 0.286840f} },
    { {-0.166764f, -0.132990f, -0.261951f}, {-0.487832f, -0.388277f, -0.781832f}, {0.392748f, 0.301923f} },
    { {-0.102484f, -0.212811f, -0.243687f}, {-0.242046f, -0.575115f, -0.781445f}, {0.380155f, 0.316937f} },
    { {0.000000f, -0.337792f, -0.077099f}, {0.215990f, -0.965544f, -0.145168f}, {0.360078f, 0.340445f} },
    { {0.146563f, -0.304340f, -0.077099f}, {0.433805f, -0.875003f, -0.214905f}, {0.331367f, 0.334153f} },
    { {0.264097f, -0.210610f, -0.077099f}, {0.770494f, -0.600129f, -0.214905f}, {0.308341f, 0.316523f} },
    { {0.329323f, -0.075166f, -0.077099f}, {0.954577f, -0.206393f, -0.214905f}, {0.295564f, 0.291046f} },
    { {0.329323f, 0.075166f, -0.077099f}, {0.949595f, 0.228223f, -0.214905f}, {0.295564f, 0.262770f} },
    { {0.264096f, 0.210610f, -0.077099f}, {0.756533f, 0.617635f, -0.214905f}, {0.308342f, 0.237293f} },
    { {0.146563f, 0.304340f, -0.077099f}, {0.413631f, 0.884718f, -0.214905f}, {0.331367f, 0.219663f} },
    { {0.000000f, 0.337792f, -0.077099f}, {-0.011195f, 0.976571f, -0.214905f}, {0.360078f, 0.213371f} },
    { {-0.146562f, 0.304340f, -0.077099f}, {-0.433805f, 0.875003f, -0.214905f}, {0.388790f, 0.219663f} },
    { {-0.264096f, 0.210610f, -0.077099f}, {-0.770494f, 0.600129f, -0.214905f}, {0.411815f, 0.237293f} },
    { {-0.329323f, 0.075166f, -0.077099f}, {-0.870737f, 0.405657f, -0.277955f}, {0.424593f, 0.262770f} },
    { {-0.002249f, -0.337278f, -0.077099f}, {-0.203182f, -0.892875f, -0.401859f}, {0.360519f, 0.340349f} },
    { {-0.068261f, -0.255308f, -0.216026f}, {-0.191269f, -0.838007f, -0.511038f}, {0.373451f, 0.324930f} },
    { {0.000000f, -0.337792f, 0.077099f}, {0.206955f, -0.938231f, 0.277296f}, {0.360078f, 0.340445f} },
    { {0.146563f, -0.304340f, 0.077099f}, {0.413631f, -0.884718f, 0.214905f}, {0.331367f, 0.334153f} },
    { {0.264097f, -0.210610f, 0.077099f}, {0.756533f, -0.617635f, 0.214905f}, {0.308341f, 0.316523f} },
    { {0.329323f, -0.075166f, 0.077099f}, {0.949595f, -0.228222f, 0.214905f}, {0.295564f, 0.291046f} },
    { {0.329323f, 0.075166f, 0.077099f}, {0.954577f, 0.206393f, 0.214905f}, {0.295564f, 0.262770f} },
    { {0.264096f, 0.210610f, 0.077099f}, {0.770494f, 0.600129f, 0.214905f}, {0.308342f, 0.237293f} },
    { {0.146563f, 0.304340f, 0.077099f}, {0.433805f, 0.875003f, 0.214905f}, {0.331367f, 0.219663f} },
    { {0.000000f, 0.337792f, 0.077099f}, {0.011195f, 0.976571f, 0.214905f}, {0.360078f, 0.213371f} },
    { {-0.146562f, 0.304340f, 0.077099f}, {-0.413631f, 0.884718f, 0.214905f}, {0.388790f, 0.219663f} },
    { {-0.264096f, 0.210610f, 0.077099f}, {-0.756533f, 0.617635f, 0.214905f}, {0.411815f, 0.237293f} },
    { {-0.329323f, 0.075166f, 0.077099f}, {-0.898851f, 0.413630f, 0.144832f}, {0.424593f, 0.262770f} },
    { {-0.329323f, 0.068868f, -0.077099f}, {-0.928899f, 0.000000f, -0.370334f}, {0.424593f, 0.263954f} },
    { {-0.329323f, 0.068868f, 0.077099f}, {-0.918268f, 0.000001f, 0.395960f}, {0.424593f, 0.263954f} },
    { {0.000000f, -0.270888f, 0.216026f}, {0.060198f, -0.759738f, 0.647437f}, {0.360078f, 0.327861f} },
    { {0.117534f, -0.244062f, 0.216026f}, {0.318049f, -0.732679f, 0.601687f}, {0.337053f, 0.322815f} },
    { {0.211789f, -0.168896f, 0.216026f}, {0.604449f, -0.522124f, 0.601687f}, {0.318589f, 0.308677f} },
    { {0.264097f, -0.060278f, 0.216026f}, {0.771131f, -0.208157f, 0.601687f}, {0.308341f, 0.288246f} },
    { {0.264097f, 0.060278f, 0.216026f}, {0.785081f, 0.147039f, 0.601687f}, {0.308341f, 0.265570f} },
    { {0.211789f, 0.168896f, 0.216026f}, {0.643536f, 0.473112f, 0.601687f}, {0.318589f, 0.245139f} },
    { {0.117534f, 0.244062f, 0.216026f}, {0.374530f, 0.705478f, 0.601687f}, {0.337053f, 0.231001f} },
    { {0.000000f, 0.270888f, 0.216026f}, {0.031345f, 0.798117f, 0.601687f}, {0.360078f, 0.225955f} },
    { {-0.117534f, 0.244062f, 0.216026f}, {-0.318049f, 0.732679f, 0.601687f}, {0.383103f, 0.231001f} },
    { {-0.211789f, 0.168896f, 0.216026f}, {-0.604449f, 0.522124f, 0.601687f}, {0.401568f, 0.245139f} },
    { {-0.264096f, 0.060278f, 0.216026f}, {-0.766948f, 0.238510f, 0.595738f}, {0.411815f, 0.265570f} },
    { {-0.264096f, -0.012128f, 0.216026f}, {-0.761762f, 0.000000f, 0.647856f}, {0.411815f, 0.279189f} },
    { {-0.068261f, -0.255308f, 0.216026f}, {-0.161825f, -0.709003f, 0.686387f}, {0.373451f, 0.324930f} },
    { {-0.002203f, -0.337335f, 0.076760f}, {-0.203451f, -0.887900f, 0.412603f}, {0.360510f, 0.340359f} },
    { {0.000000f, -0.150331f, 0.312166f}, {-0.030222f, -0.475778f, 0.879046f}, {0.360078f, 0.305185f} },
    { {0.065227f, -0.135444f, 0.312166f}, {0.174505f, -0.466479f, 0.867148f}, {0.347300f, 0.302384f} },
    { {0.117534f, -0.093730f, 0.312166f}, {0.359621f, -0.344568f, 0.867148f}, {0.337053f, 0.294538f} },
    { {0.146563f, -0.033452f, 0.312166f}, {0.473509f, -0.154411f, 0.867148f}, {0.331367f, 0.283200f} },
    { {0.146563f, 0.033452f, 0.312166f}, {0.493614f, 0.066328f, 0.867148f}, {0.331367f, 0.270616f} },
    { {0.117534f, 0.093730f, 0.312166f}, {0.415952f, 0.273931f, 0.867148f}, {0.337053f, 0.259278f} },
    { {0.065227f, 0.135444f, 0.312166f}, {0.255906f, 0.427278f, 0.867148f}, {0.347300f, 0.251432f} },
    { {0.000000f, 0.150331f, 0.312166f}, {0.045174f, 0.495998f, 0.867148f}, {0.360078f, 0.248631f} },
    { {-0.065226f, 0.135444f, 0.312166f}, {-0.174505f, 0.466479f, 0.867148f}, {0.372856f, 0.251432f} },
    { {-0.117534f, 0.093730f, 0.312166f}, {-0.359621f, 0.344568f, 0.867148f}, {0.383103f, 0.259278f} },
    { {-0.146562f, 0.033452f, 0.312166f}, {-0.473509f, 0.154412f, 0.867148f}, {0.388790f, 0.270616f} },
    { {-0.146562f, -0.033452f, 0.312166f}, {-0.482881f, -0.057485f, 0.873797f}, {0.388790f, 0.283200f} },
    { {-0.231341f, -0.052802f, 0.242819f}, {-0.590637f, -0.207201f, 0.779882f}, {0.405398f, 0.286840f} },
    { {-0.166765f, -0.132990f, 0.261951f}, {-0.460376f, -0.421793f, 0.781117f}, {0.392748f, 0.301923f} },
    { {-0.117534f, -0.093730f, 0.312166f}, {-0.364562f, -0.243791f, 0.898700f}, {0.383103f, 0.294538f} },
    { {-0.065226f, -0.135444f, 0.312166f}, {-0.206727f, -0.429612f, 0.879032f}, {0.372856f, 0.302384f} },
    { {-0.102484f, -0.212811f, 0.243687f}, {-0.309353f, -0.542393f, 0.781096f}, {0.380155f, 0.316937f} },
    { {0.000000f, 0.000000f, 0.346479f}, {0.000000f, 0.000000f, 1.000000f}, {0.360078f, 0.276908f} },
    { {-0.097665f, 0.114897f, -0.035824f}, {-0.778847f, -0.627214f, 0.000000f}, {0.382545f, 0.423575f} },
    { {-0.097665f, 0.114897f, 0.055568f}, {-0.778847f, -0.627214f, -0.000000f}, {0.382545f, 0.423575f} },
    { {-0.059006f, 0.066891f, -0.118166f}, {-0.778847f, -0.627214f, 0.000000f}, {0.375201f, 0.433021f} },
    { {0.036781f, -0.052053f, -0.134561f}, {-0.778847f, -0.627214f, -0.000000f}, {0.357005f, 0.456427f} },
    { {-0.001317f, -0.004744f, -0.145386f}, {-0.778847f, -0.627214f, 0.000000f}, {0.364242f, 0.447117f} },
    { {0.096218f, -0.125859f, 0.055367f}, {-0.778847f, -0.627214f, -0.000000f}, {0.345714f, 0.470950f} },
    { {0.057065f, -0.077241f, -0.118166f}, {-0.778847f, -0.627213f, 0.000000f}, {0.353152f, 0.461383f} },
    { {0.096190f, -0.125825f, -0.035824f}, {-0.778848f, -0.627213f, 0.000000f}, {0.345719f, 0.470943f} },
    { {-0.059006f, 0.066891f, 0.137910f}, {-0.778847f, -0.627214f, -0.000000f}, {0.375201f, 0.433021f} },
    { {0.057065f, -0.077241f, 0.137910f}, {-0.778847f, -0.627214f, -0.000000f}, {0.353152f, 0.461383f} },
    { {-0.039592f, 0.042784f, -0.134046f}, {-0.778847f, -0.627214f, 0.000000f}, {0.371513f, 0.437765f} },
    { {-0.001317f, -0.004744f, 0.165130f}, {-0.778847f, -0.627214f, -0.000000f}, {0.364242f, 0.447117f} },
    { {-0.039592f, 0.042784f, 0.153790f}, {-0.778847f, -0.627214f, 0.000001f}, {0.371513f, 0.437765f} },
    { {0.036781f, -0.052053f, 0.154305f}, {-0.778847f, -0.627214f, -0.000001f}, {0.357005f, 0.456427f} },
    { {-0.231341f, -0.052802f, -0.242819f}, {-0.209403f, -0.521325f, 0.827267f}, {0.407939f, 0.456574f} },
    { {-0.264096f, -0.012128f, -0.216026f}, {0.038017f, -0.814909f, 0.578341f}, {0.414161f, 0.448570f} },
    { {-0.059006f, 0.066891f, -0.118166f}, {-0.025214f, -0.751292f, 0.659488f}, {0.375201f, 0.433021f} },
    { {-0.039592f, 0.042784f, -0.134046f}, {-0.251809f, -0.462347f, 0.850193f}, {0.371513f, 0.437765f} },
    { {-0.166764f, -0.132990f, -0.261951f}, {-0.354026f, -0.336428f, 0.872630f}, {0.395672f, 0.472353f} },
    { {-0.001317f, -0.004744f, -0.145386f}, {-0.420590f, -0.250077f, 0.872104f}, {0.364242f, 0.447117f} },
    { {-0.102484f, -0.212811f, -0.243687f}, {-0.513989f, -0.130267f, 0.847848f}, {0.383461f, 0.488060f} },
    { {0.036781f, -0.052053f, -0.134561f}, {-0.567592f, -0.065408f, 0.820708f}, {0.357005f, 0.456427f} },
    { {-0.002249f, -0.337278f, -0.077099f}, {-0.799651f, 0.267316f, 0.537680f}, {0.364419f, 0.512553f} },
    { {-0.068261f, -0.255308f, -0.216026f}, {-0.749380f, 0.176738f, 0.638117f}, {0.376959f, 0.496423f} },
    { {0.057065f, -0.077241f, -0.118166f}, {-0.785380f, 0.238938f, 0.571041f}, {0.353152f, 0.461383f} },
    { {0.096190f, -0.125825f, -0.035824f}, {-0.799651f, 0.267316f, 0.537680f}, {0.345719f, 0.470943f} },
    { {-0.329323f, 0.068868f, -0.077099f}, {0.194886f, -0.980826f, 0.000000f}, {0.426552f, 0.432632f} },
    { {-0.329323f, 0.068868f, 0.077099f}, {0.194886f, -0.980826f, 0.000000f}, {0.426552f, 0.432632f} },
    { {-0.097665f, 0.114897f, 0.055568f}, {0.194886f, -0.980826f, 0.000000f}, {0.382545f, 0.423575f} },
    { {-0.097665f, 0.114897f, -0.035824f}, {0.194886f, -0.980826f, 0.000000f}, {0.382545f, 0.423575f} },
    { {-0.329323f, 0.068868f, 0.077099f}, {0.115427f, -0.833594f, -0.540184f}, {0.426552f, 0.432632f} },
    { {-0.264096f, -0.012128f, 0.216026f}, {0.048717f, -0.763292f, -0.644214f}, {0.414161f, 0.448570f} },
    { {-0.059006f, 0.066891f, 0.137910f}, {0.094611f, -0.813215f, -0.574221f}, {0.375201f, 0.433021f} },
    { {-0.097665f, 0.114897f, 0.055568f}, {0.115427f, -0.833593f, -0.540184f}, {0.382545f, 0.423575f} },
    { {-0.068261f, -0.255308f, 0.216026f}, {-0.752007f, 0.264392f, -0.603807f}, {0.376959f, 0.496423f} },
    { {-0.002203f, -0.337335f, 0.076760f}, {-0.777525f, 0.306303f, -0.549211f}, {0.364411f, 0.512564f} },
    { {0.096218f, -0.125859f, 0.055367f}, {-0.777525f, 0.306303f, -0.549211f}, {0.345714f, 0.470950f} },
    { {0.057065f, -0.077241f, 0.137910f}, {-0.698511f, 0.188825f, -0.690237f}, {0.353152f, 0.461383f} },
    { {-0.231341f, -0.052802f, 0.242819f}, {-0.184210f, -0.446173f, -0.875783f}, {0.407939f, 0.456574f} },
    { {-0.039592f, 0.042784f, 0.153790f}, {-0.135531f, -0.515934f, -0.845839f}, {0.371513f, 0.437765f} },
    { {-0.166765f, -0.132990f, 0.261951f}, {-0.347698f, -0.236427f, -0.907308f}, {0.395672f, 0.472353f} },
    { {-0.102484f, -0.212811f, 0.243687f}, {-0.504725f, -0.042168f, -0.862250f}, {0.383461f, 0.488060f} },
    { {0.036781f, -0.052053f, 0.154305f}, {-0.452918f, -0.100200f, -0.885903f}, {0.357005f, 0.456427f} },
    { {-0.001317f, -0.004744f, 0.165130f}, {-0.277342f, -0.324838f, -0.904191f}, {0.364242f, 0.447117f} },
    { {-0.329323f, 0.068868f, -0.077099f}, {0.074028f, -0.846018f, 0.527990f}, {0.426552f, 0.432632f} },
    { {-0.097665f, 0.114897f, -0.035824f}, {0.074028f, -0.846018f, 0.527990f}, {0.382545f, 0.423575f} },
    { {-0.002203f, -0.337335f, 0.076760f}, {-0.906607f, 0.421977f, 0.000426f}, {0.364411f, 0.512564f} },
    { {-0.002249f, -0.337278f, -0.077099f}, {-0.906607f, 0.421977f, 0.000426f}, {0.364419f, 0.512553f} },
    { {0.096190f, -0.125825f, -0.035824f}, {-0.906607f, 0.421977f, 0.000426f}, {0.345719f, 0.470943f} },
    { {0.096218f, -0.125859f, 0.055367f}, {-0.906607f, 0.421977f, 0.000426f}, {0.345714f, 0.470950f} },
};

WORD g_tind38[] = 
{
    2, 1, 0,    3, 2, 0,    4, 3, 0,    5, 4, 0,    6, 5, 0,
    7, 6, 0,    8, 7, 0,    9, 8, 0,    10, 9, 0,    11, 10, 0,
    12, 11, 0,    13, 12, 0,    14, 13, 0,    1, 14, 0,    16, 15, 1,
    2, 16, 1,    17, 16, 2,    3, 17, 2,    18, 17, 3,    4, 18, 3,
    19, 18, 4,    5, 19, 4,    20, 19, 5,    6, 20, 5,    21, 20, 6,
    7, 21, 6,    22, 21, 7,    8, 22, 7,    23, 22, 8,    9, 23, 8,
    24, 23