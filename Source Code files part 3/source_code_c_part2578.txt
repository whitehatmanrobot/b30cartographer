  STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundSynthSink methods
    STDMETHOD(GetLatencyClock)      (THIS_ IReferenceClock **ppClock) PURE;
    STDMETHOD(Activate)             (THIS_ BOOL fEnable) PURE;
    STDMETHOD(SampleToRefTime)      (THIS_ LONGLONG llSampleTime, REFERENCE_TIME *prtTime) PURE;
    STDMETHOD(RefToSampleTime)      (THIS_ REFERENCE_TIME rtTime, LONGLONG *pllSampleTime) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten) PURE;
};

#define IDirectSoundSynthSink_QueryInterface(p,a,b)     IUnknown_QueryInterface(p,a,b)
#define IDirectSoundSynthSink_AddRef(p)                 IUnknown_AddRef(p)
#define IDirectSoundSynthSink_Release(p)                IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundSynthSink_GetLatencyClock(p,a)      (p)->lpVtbl->GetLatencyClock(p,a)
#define IDirectSoundSynthSink_Activate(p,a)             (p)->lpVtbl->Activate(p,a)
#define IDirectSoundSynthSink_SampleToRefTime(p,a,b)    (p)->lpVtbl->SampleToRefTime(p,a,b)
#define IDirectSoundSynthSink_RefToSampleTime(p,a,b)    (p)->lpVtbl->RefToSampleTime(p,a,b)
#define IDirectSoundSynthSink_GetFormat(p,a,b)          (p)->lpVtbl->GetFormat(p,a,b)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundSynthSink_GetLatencyClock(p,a)      (p)->GetLatencyClock(a)
#define IDirectSoundSynthSink_Activate(p,a)             (p)->Activate(a)
#define IDirectSoundSynthSink_SampleToRefTime(p,a,b)    (p)->SampleToRefTime(a,b)
#define IDirectSoundSynthSink_RefToSampleTime(p,a,b)    (p)->RefToSampleTime(a,b)
#define IDirectSoundSynthSink_GetFormat(p,a,b)          (p)->GetFormat(a,b)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundConnect: used by DirectMusic to implement
// audio paths and connect the synthesiser to the sink
//

DEFINE_GUID(IID_IDirectSoundConnect, 0x5bee1fe0, 0x60d5, 0x4ef9, 0x88, 0xbc, 0x33, 0x67, 0xb9, 0x75, 0xc6, 0x11);

#undef INTERFACE
#define INTERFACE IDirectSoundConnect

DECLARE_INTERFACE_(IDirectSoundConnect, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundConnect methods
    STDMETHOD(AddSource)            (THIS_ LPDIRECTSOUNDSOURCE pDSSource) PURE;
    STDMETHOD(RemoveSource)         (THIS_ LPDIRECTSOUNDSOURCE pDSSource) PURE;
    STDMETHOD(SetMasterClock)       (THIS_ IReferenceClock *pClock) PURE;
    STDMETHOD(CreateSoundBuffer)    (THIS_ LPCDSBUFFERDESC pcDSBufferDesc, LPDWORD pdwFuncID, DWORD dwBusIDCount,
                                           REFGUID guidBufferID, LPDIRECTSOUNDBUFFER *ppDSBuffer) PURE;
    STDMETHOD(CreateSoundBufferFromConfig) (THIS_ LPUNKNOWN pConfig, LPDIRECTSOUNDBUFFER *ppDSBuffer) PURE;
    STDMETHOD(GetSoundBuffer)       (THIS_ DWORD dwBusID, LPDIRECTSOUNDBUFFER *ppDSBuffer) PURE;
    STDMETHOD(GetBusCount)          (THIS_ LPDWORD pdwCount) PURE;
    STDMETHOD(GetBusIDs)            (THIS_ LPDWORD pdwBusIDs, LPDWORD pdwFuncIDs, DWORD dwBusCount) PURE;
    STDMETHOD(GetFunctionalID)      (THIS_ DWORD dwBusID, LPDWORD pdwFuncID) PURE;
    STDMETHOD(GetSoundBufferBusIDs) (THIS_ LPDIRECTSOUNDBUFFER pDSBuffer, LPDWORD pdwBusIDs, LPDWORD pdwFuncIDs, LPDWORD pdwBusCount) PURE;
};

#define IDirectSoundConnect_QueryInterface(p,a,b)               IUnknown_QueryInterface(p,a,b)
#define IDirectSoundConnect_AddRef(p)                           IUnknown_AddRef(p)
#define IDirectSoundConnect_Release(p)                          IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundConnect_AddSource(p,a)                      (p)->lpVtbl->AddSource(p,a)
#define IDirectSoundConnect_RemoveSource(p,a)                   (p)->lpVtbl->RemoveSource(p,a)
#define IDirectSoundConnect_SetMasterClock(p,a)                 (p)->lpVtbl->SetMasterClock(p,a)
#define IDirectSoundConnect_CreateSoundBuffer(p,a,b,c,d)        (p)->lpVtbl->CreateSoundBuffer(p,a,b,c,d)
#define IDirectSoundConnect_CreateSoundBufferFromConfig(p,a,b)  (p)->lpVtbl->CreateSoundBufferFromConfig(p,a,b)
#define IDirectSoundConnect_GetSoundBuffer(p,a,b)               (p)->lpVtbl->GetSoundBuffer(p,a,b)
#define IDirectSoundConnect_GetBusCount(p,a)                    (p)->lpVtbl->GetBusCount(p,a)
#define IDirectSoundConnect_GetBusIDs(p,a,b,c)                  (p)->lpVtbl->GetBusIDs(p,a,b,c)
#define IDirectSoundConnect_GetFunctionalID(p,a,b)              (p)->lpVtbl->GetFunctionalID(p,a,b)
#define IDirectSoundConnect_GetSoundBufferBusIDs(p,a,b,c,d)     (p)->lpVtbl->GetSoundBufferBusIDs(p,a,b,c,d)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundConnect_AddSource(p,a)                      (p)->AddSource(a)
#define IDirectSoundConnect_RemoveSource(p,a)                   (p)->RemoveSource(a)
#define IDirectSoundConnect_SetMasterClock(p,a)                 (p)->SetMasterClock(a)
#define IDirectSoundConnect_CreateSoundBuffer(p,a,b,c,d)        (p)->CreateSoundBuffer(a,b,c,d)
#define IDirectSoundConnect_CreateSoundBufferFromConfig(p,a,b)  (p)->CreateSoundBufferFromConfig(a,b)
#define IDirectSoundConnect_GetSoundBuffer(p,a,b)               (p)->GetSoundBuffer(a,b)
#define IDirectSoundConnect_GetBusCount(p,a)                    (p)->GetBusCount(a)
#define IDirectSoundConnect_GetBusIDs(p,a,b,c)                  (p)->GetBusIDs(a,b,c)
#define IDirectSoundConnect_GetFunctionalID(p,a,b)              (p)->GetFunctionalID(a,b)
#define IDirectSoundConnect_GetSoundBufferBusIDs(p,a,b,c,d)     (p)->GetSoundBufferBusIDs(a,b,c,d)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundSinkSync: provided by the DirectMusic master clock
// to allow DirectSound to synchronize with it
//

DEFINE_GUID(IID_IDirectSoundSinkSync, 0xd28de0d0, 0x2794, 0x492f, 0xa3, 0xff, 0xe2, 0x41, 0x80, 0xd5, 0x43, 0x79);

#undef INTERFACE
#define INTERFACE IDirectSoundSinkSync

DECLARE_INTERFACE_(IDirectSoundSinkSync, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundSinkSync methods
    STDMETHOD(SetClockOffset)       (THIS_ LONGLONG llOffset) PURE;
};

#define IDirectSoundSinkSync_QueryInterface(p,a,b)  IUnknown_QueryInterface(p,a,b)
#define IDirectSoundSinkSync_AddRef(p)              IUnknown_AddRef(p)
#define IDirectSoundSinkSync_Release(p)             IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundSinkSync_SetClockOffset(p,a)    (p)->lpVtbl->SetClockOffset(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundSinkSync_SetClockOffset(p,a)    (p)->SetClockOffset(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundSource (currently private)
//

DEFINE_GUID(IID_IDirectSoundSource, 0x536f7af3, 0xdb03, 0x4888, 0x93, 0x66, 0x54, 0x48, 0xb1, 0x1d, 0x4a, 0x19);

#undef INTERFACE
#define INTERFACE IDirectSoundSource

DECLARE_INTERFACE_(IDirectSoundSource, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundSource methods
    STDMETHOD(SetSink)              (THIS_ LPDIRECTSOUNDCONNECT pSinkConnect) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten) PURE;
    STDMETHOD(Seek)                 (THIS_ ULONGLONG ullPosition) PURE;
    STDMETHOD(Read)                 (THIS_ LPVOID *ppvBusBuffers, LPDWORD pdwIDs, LPDWORD pdwFuncIDs, LPLONG plPitchAdjust, DWORD dwBufferCount, ULONGLONG *ullLength) PURE;
    STDMETHOD(GetSize)              (THIS_ ULONGLONG *pullStreamSize) PURE;
};

#define IDirectSoundSource_QueryInterface(p,a,b)    IUnknown_QueryInterface(p,a,b)
#define IDirectSoundSource_AddRef(p)                IUnknown_AddRef(p)
#define IDirectSoundSource_Release(p)               IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundSource_SetSink(p,a)             (p)->lpVtbl->SetSink(p,a)
#define IDirectSoundSource_GetFormat(p,a,b)         (p)->lpVtbl->GetFormat(p,a,b)
#define IDirectSoundSource_Seek(p,a)                (p)->lpVtbl->Seek(p,a)
#define IDirectSoundSource_Read(p,a,b,c,d,e)        (p)->lpVtbl->Read(p,a,b,c,d,e)
#define IDirectSoundSource_GetSize(p,a)             (p)->lpVtbl->GetSize(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundSource_SetSink(p,a)             (p)->SetSink(a)
#define IDirectSoundSource_GetFormat(p,a,b)         (p)->GetFormat(a,b)
#define IDirectSoundSource_Seek(p,a)                (p)->Seek(a)
#define IDirectSoundSource_Read(p,a,b,c,d,e)        (p)->Read(a,b,c,d,e)
#define IDirectSoundSource_GetSize(p,a)             (p)->GetSize(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundWave (currently private)
//

DEFINE_GUID(IID_IDirectSoundWave, 0x69e934e4, 0x97f1, 0x4f1d, 0x88, 0xe8, 0xf2, 0xac, 0x88, 0x67, 0x13, 0x27);

#define DSWCS_F_DEINTERLEAVED   0x00000001
#define DSWCS_F_TOGGLE_8BIT     0x00000002

#undef INTERFACE
#define INTERFACE IDirectSoundWave

DECLARE_INTERFACE_(IDirectSoundWave, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundWave methods
    STDMETHOD(CreateSource)         (THIS_ LPDIRECTSOUNDSOURCE *ppDSSource, LPWAVEFORMATEX pwfxFormat, DWORD dwFlags) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten) PURE;
    STDMETHOD(GetStreamingParms)    (THIS_ LPDWORD pdwFlags, REFERENCE_TIME *prtReadAhead) PURE;
};

#define IDirectSoundWave_QueryInterface(p,a,b)      IUnknown_QueryInterface(p,a,b)
#define IDirectSoundWave_AddRef(p)                  IUnknown_AddRef(p)
#define IDirectSoundWave_Release(p)                 IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundWave_CreateSource(p,a,b,c)      (p)->lpVtbl->CreateSource(p,a,b,c)
#define IDirectSoundWave_GetFormat(p,a,b)           (p)->lpVtbl->GetFormat(p,a,b)
#define IDirectSoundWave_GetStreamingParms(p,a,b)   (p)->lpVtbl->GetStreamingParms(p,a,b)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundWave_CreateSource(p,a,b,c)      (p)->CreateSource(a,b,c)
#define IDirectSoundWave_GetFormat(p,a,b)           (p)->GetFormat(a,b)
#define IDirectSoundWave_GetStreamingParms(p,a,b)   (p)->GetStreamingParms(a,b)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#endif // DIRECTSOUND_VERSION >= 0x0800

#endif // __DSOUNDP_INCLUDED__

//@@END_MSINTERNAL

#ifdef __cplusplus
};
#endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\filter.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1999-1999 Microsoft Corporation
//
//  File:       filter.h
//
//--------------------------------------------------------------------------

//
// filter.h
//
#ifndef __FILTER_H__
#define __FILTER_H__

struct CDirectMusicPattern;
struct StyleTrackState;
struct DMStyleStruct;

enum enumPatternFilter
{
	DISPATCH_RESET				= 0,
	MATCH_COMMAND_AND_RHYTHM	= 1,
	MATCH_COMMAND_FULL			= 2,
	MATCH_COMMAND_PARTIAL		= 3,
	MATCH_EMBELLISHMENT			= 4,
	MATCH_GROOVE_LEVEL			= 5,
	MATCH_RHYTHM_BITS			= 6,
	MATCH_NEXT_COMMAND			= 7,
	FIND_LONGEST_PATTERN		= 8,
	FIND_LONGEST_TIMESIG		= 9,
	COLLECT_LONGEST_PATTERN		= 10,
	COLLECT_LONGEST_TIMESIG		= 11,
	RANDOM_ROW					= 12,
	REMOVED						= 0xffffffff
};

struct TaggedPattern
{
	CDirectMusicPattern* pPattern;
	DWORD dwTag;
};

struct PatternDispatcher
{
	PatternDispatcher() :
		m_aPatterns(NULL),
		m_fIsEmpty(false),
		m_nPatternCount(0),
		m_pRhythms(NULL),
		m_pCommands(NULL),
		m_nPatternLength(0),
		m_nNextCommand(0),
		m_mtNextCommand(0),
		m_mtNow(0),
		m_mtOffset(0),
		m_mtMeasureTime(0),
		m_pStyleTrackState(NULL),
		m_pPerformance(NULL),
		m_pStyle(NULL),
		m_nWinBits(0),
		m_MaxBars(0), m_MaxNum(0), m_MaxDenom(0)
	{}

	PatternDispatcher(
		TList<CDirectMusicPattern*>& InList,
		MUSIC_TIME mtNextCommand, 
		MUSIC_TIME mtNow, 
		MUSIC_TIME mtOffset, 
		StyleTrackState* pStyleTrackState,
		IDirectMusicPerformance* pPerformance,
		DMStyleStruct* pStyle) :
		m_aPatterns(NULL),
		m_fIsEmpty(false),
		m_nPatternCount(0),
		m_pRhythms(NULL),
		m_pCommands(NULL),
		m_nPatternLength(0),
		m_mtNextCommand(mtNextCommand),
		m_nNextCommand(0),
		m_mtNow(mtNow),
		m_mtOffset(mtOffset),
		m_mtMeasureTime(0),
		m_pStyleTrackState(pStyleTrackState),
		m_pPerformance(pPerformance),
		m_pStyle(pStyle),
		m_nWinBits(0),
		m_MaxBars(0), m_MaxNum(0), m_MaxDenom(0)
	{
		m_nPatternCount = InList.GetCount();
		if (m_nPatternCount)
		{
			m_aPatterns = new TaggedPattern [m_nPatternCount];
		}
		if (m_aPatterns)
		{
			TListItem<CDirectMusicPattern*>* pScan = InList.GetHead();
			for (int i = 0; pScan && i < m_nPatternCount; pScan = pScan->GetNext(), i++)
			{
				m_aPatterns[i].pPattern = pScan->GetItemValue();
				m_aPatterns[i].dwTag = 0;
			}
		}
		else
		{
			m_nPatternCount = 0;
		}
	}

	~PatternDispatcher()
	{
		if (m_aPatterns) delete [] m_aPatterns;
	}

	bool IsEmpty()
	{
		if (m_fIsEmpty) return true;
		bool fResult = true;
		for (int i = 0; i < m_nPatternCount; i++)
		{
			if (!m_aPatterns[i].dwTag)
			{
				fResult = false;
				break;
			}
		}
		if (fResult) m_fIsEmpty = true;
		return fResult;
	}

	HRESULT RestoreAllPatterns()
	{
		for (int i = 0; i < m_nPatternCount; i++)
		{
			m_aPatterns[i].dwTag = 0;
		}
		m_fIsEmpty = false;
		return S_OK;
	}

	HRESULT RestorePatterns(DWORD dwType)
	{
		for (int i = 0; i < m_nPatternCount; i++)
		{
			if (dwType == m_aPatterns[i].dwTag)
			{
				m_aPatterns[i].dwTag = 0;
			}
		}
		m_fIsEmpty = false;
		return S_OK;
	}

	HRESULT SetTag(int nIndex, DWORD dwType)
	{
		if (nIndex < m_nPatternCount)
		{
			m_aPatterns[nIndex].dwTag = dwType;
		}
		if (!dwType) m_fIsEmpty = false;
		return S_OK;
	}

	HRESULT ReplacePatterns(DWORD dwType, DWORD dwRemoveType)
	{
		for (int i = 0; i < m_nPatternCount; i++)
		{
			if (dwType == m_aPatterns[i].dwTag)
			{
				m_aPatterns[i].dwTag = 0;
			}
			else if (!m_aPatterns[i].dwTag)
			{
				m_aPatterns[i].dwTag = dwRemoveType;
			}
		}
		m_fIsEmpty = false;
		return S_OK;
	}

	CDirectMusicPattern* GetItem(int n)
	{
		for (int i = 0; i < m_nPatternCount; i++)
		{
			if (!m_aPatterns[i].dwTag)
			{
				if (n == 0) break;
				n--;
			}
		}
		if (i >= m_nPatternCount || m_aPatterns[i].dwTag) return NULL;
		return m_aPatterns[i].pPattern;
	}

	HRESULT Filter(DWORD dwType);

	HRESULT Scan(DWORD dwType);

	bool Test(CDirectMusicPattern*& rValue, DWORD dwType);

	CDirectMusicPattern* RandomSelect();

	HRESULT FindPattern(CDirectMusicPattern* pSearchPattern, int& rResult);

	void ResetRhythms()
	{
		m_nWinBits = 0;
	}

	void ResetMeasures()
	{
		m_MaxBars = 0;
	}

	void ResetTimeSig()
	{
		m_MaxNum = 0;
		m_MaxDenom = 0;
	}

	void SetPatternLength(int nPatternLength)
	{
		m_nPatternLength = nPatternLength;
	}

	void SetMeasureTime(MUSIC_TIME mtMeasureTime);

	void SetCommands(DMUS_COMMAND_PARAM_2* pCommands, DWORD* pRhythms)
	{
		m_pRhythms = pRhythms;
		m_pCommands = pCommands;
	}


	TaggedPattern* m_aPatterns;
	int m_nPatternCount;
	bool m_fIsEmpty;
	DWORD* m_pRhythms;
	DMUS_COMMAND_PARAM_2* m_pCommands;
	int m_nNextCommand;
	MUSIC_TIME m_mtNextCommand;
	MUSIC_TIME m_mtNow;
	MUSIC_TIME m_mtOffset;
	MUSIC_TIME m_mtMeasureTime;
	DMStyleStruct* m_pStyle;
	StyleTrackState* m_pStyleTrackState;
	IDirectMusicPerformance* m_pPerformance;
	int m_nPatternLength;
	int m_nWinBits;
	int m_MaxBars;
	int m_MaxNum;
	int m_MaxDenom;
};

#endif // __FILTER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\dswave.h ===
// dswave.h
// (c) 1999-2000 Microsoft Corp.

#ifndef _DSWAVE_H_
#define _DSWAVE_H_

#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>
#include "dsoundp.h"    // For IDirectSoundWave and IDirectSoundSource
#include "dmusicc.h"
#include "dmusici.h"
#include "riff.h"

extern long g_cComponent;

#define REF_PER_MIL     10000   // For converting from reference time to mils 
#define CONVERTLENGTH   250

// #define DSWCS_F_DEINTERLEAVED 0x00000001    // Multi-channel data as multiple buffers
// FIXME: unimplemented so far?

typedef struct tCREATEVIEWPORT
{
    IStream            *pStream;
    DWORD               cSamples;
    DWORD               dwDecompressedStart;
    DWORD               cbStream;
    LPWAVEFORMATEX      pwfxSource;
    LPWAVEFORMATEX      pwfxTarget;
    DWORD               fdwOptions;
} CREATEVIEWPORT, *PCREATEVIEWPORT;


// Private interface for getting the length of a wave
interface IPrivateWave : IUnknown
{
    virtual HRESULT STDMETHODCALLTYPE GetLength(REFERENCE_TIME *prtLength)=0;
};

DEFINE_GUID(IID_IPrivateWave, 0xce6ae366, 0x9d61, 0x420a, 0xad, 0x53, 0xe5, 0xe5, 0xf6, 0xa8, 0x4a, 0xe4);

// Flags for SetWaveBehavior()

#define DSOUND_WAVEF_ONESHOT        1           /* The wave will be played as a one shot */
#define DSOUND_WAVEF_PORT           2           /* The wave will be played via a DMusic port. */
#define DSOUND_WAVEF_SINK           4           /* The wave will be played via a streamed sink interface. */
#define DSOUND_WAVEF_CREATEMASK     0x00000001  /*  Currently only ONESHOT is define for CreateSource  */

#define DSOUND_WVP_NOCONVERT        0x80000000  /*  The viewport data is the same format as the wave  */
#define DSOUND_WVP_STREAMEND        0x40000000  /*  The viewport data is the same format as the wave  */
#define DSOUND_WVP_CONVERTSTATE_01  0x01000000
#define DSOUND_WVP_CONVERTSTATE_02  0x02000000
#define DSOUND_WVP_CONVERTSTATE_03  0x04000000

#define DSOUND_WVP_CONVERTMASK      0x0f000000

/*  The CWaveViewPort structure represents one instance, or "view", of the
    wave object. It manages the reading of the wave data, ACM decompression,
    and demultiplexing into mono buffers. If a wave object is being
    streamed, each playback instance gets a unique CWaveViewPort. 
    However, in the more typical case where the wave object is being
    played as a one shot, each playback instance uses the same
    CWaveViewPort.
    Each additional CWaveViewPort owns a cloned instance of the IStream.
*/

class CWaveViewPort :
    public IDirectSoundSource   // Used by a port or sink to pull data. 
{
public:
    CWaveViewPort();            // Constructor receives stream.
    ~CWaveViewPort();           //  Destructor releases memory, streams, etc.

    // IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDirectSoundSource
    STDMETHODIMP SetSink(IDirectSoundConnect *pSinkConnect);
    STDMETHODIMP GetFormat(LPWAVEFORMATEX pwfx, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten);
    STDMETHODIMP Seek(ULONGLONG sp);
    STDMETHODIMP Read(LPVOID *ppvBuffer, LPDWORD pdwBusIds, LPDWORD pdwFuncIds, LPLONG plPitchShifts, DWORD cpvBuffer, ULONGLONG *pcb);
    STDMETHODIMP GetSize(ULONGLONG *pcb);

    // Misc
    HRESULT Create(PCREATEVIEWPORT pCreate);

private:

    HRESULT acmRead();

    //  General stuff...
    CRITICAL_SECTION    m_CriticalSection;  //  Used to ensure thread safe
    long                m_cRef;             //  COM reference counter.

    //  Details about original data stream...
    IStream *           m_pStream;          //  IStream pointer which is connected to IPersistStream
                                            //  interface to pull data from file. 
    DWORD               m_cSamples;         //  Number of samples (if available)
    DWORD               m_cbStream;         //  Number of bytes in stream.
    DWORD               m_dwStart;          //  Offset into stream where data starts
    //LPWAVEFORMATEX      m_pwfxSource;       //  Do we need to hold on to this?

    //  Details needed for this viewport.
    DWORD               m_dwOffset;   //  Current byte offset into data stream
    DWORD               m_dwStartPos; //  Initial Start Offset
    LPWAVEFORMATEX      m_pwfxTarget; //  Target destination format.
    ACMSTREAMHEADER     m_ash;        //  ACM Stream header (used for conversion)
    HACMSTREAM          m_hStream;    //  ACM Stream handle for conversion
    LPBYTE              m_pDst;       //  Pointer to (decompressed) destination  
    LPBYTE              m_pRaw;       //  Pointer to compressed source buffer
    DWORD               m_fdwOptions; //  Options for viewport

    DWORD               m_dwDecompressedStart;  // Actual start for the data after decompression in Samples
                                                // This is important for MP3 and WMA codecs that 
                                                // insert some amount of silence in the beginning
    
    DWORD               m_dwDecompStartOffset;  // Byte Offset in the compressed stream to the block which
                                                // needs to be decompressed to get to the right start value
    
    DWORD               m_dwDecompStartOffsetPCM;// Byte offset in the decompressed stream...corresponds to
                                                // m_dwDecompressedStart samples

    DWORD               m_dwDecompStartDelta;   // The delta (in bytes) to add when we decompress the block starting
                                                // from m_dwDecompStartOffset

    // Only used to accurately get data after precached data for DirectSoundWave in DMusic
    DWORD               m_dwPreCacheFilePos;
    DWORD               m_dwFirstPCMSample;
    DWORD               m_dwPCMSampleOut;
};

/*  The CWave class represents one instance of a wave object. It
    supports the IDirectSoundWave interface, which the application
    uses to access the wave. It also support IPersistStream and
    IDirectMusicObject, which are used by the loader to load the 
    wave data from a stream into the wave object.
    And, the IDirectSoundSource interface manages the direct 
    transfer of the wave data from the object to the
    synth or DirectSound. This is for internal use, not by the
    application (though it represents an easy way for an app 
    to load wave data and then extract it.) 
    CWave maintains a list of CWaveViewPorts, though typically
    there is only one.
*/

class CWave : 
    public IDirectSoundWave,    // Standard interface.
    public IPersistStream,      // For file io
    public IDirectMusicObject,  // For DirectMusic loader
    public IPrivateWave         // For GetLength
{
public:
    CWave();
    ~CWave();

    // IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDirectSoundWave
    STDMETHODIMP GetFormat(LPWAVEFORMATEX pWaveFormatEx, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten);
    STDMETHODIMP CreateSource(IDirectSoundSource **ppSource, LPWAVEFORMATEX pwfx, DWORD dwFlags);
    STDMETHODIMP GetStreamingParms(LPDWORD pdwFlags, LPREFERENCE_TIME prtReadahread);

    // IPersist functions (base class for IPersistStream)
    STDMETHODIMP GetClassID( CLSID* pClsId );

    // IPersistStream functions
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load( IStream* pIStream );
    STDMETHODIMP Save( IStream* pIStream, BOOL fClearDirty );
    STDMETHODIMP GetSizeMax( ULARGE_INTEGER FAR* pcbSize );

    // IDirectMusicObject 
    STDMETHODIMP GetDescriptor(LPDMUS_OBJECTDESC pDesc);
    STDMETHODIMP SetDescriptor(LPDMUS_OBJECTDESC pDesc);
    STDMETHODIMP ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc);

    // IPrivateWave
    STDMETHODIMP GetLength(REFERENCE_TIME *prtLength);

private:
    
    // Internal methods.

    BOOL ParseHeader(IStream *pIStream, IRIFFStream* pIRiffStream, LPMMCKINFO pckMain);

    void FallbackStreamingBehavior()
    {
        REFERENCE_TIME rtLength = 0;
        if (SUCCEEDED(GetLength(&rtLength)))
        {
            // if > 5000 milliseconds, set to streaming with a 500 ms readahead
            if (rtLength > 5000)
            {
                m_rtReadAheadTime = 500 * REF_PER_MIL;
                m_fdwFlags &= ~DSOUND_WAVEF_ONESHOT;
            }
            else
            {
                m_rtReadAheadTime = 0;
                m_fdwFlags |= DSOUND_WAVEF_ONESHOT;
            }
        }
    }

    CRITICAL_SECTION    m_CriticalSection;      //  Used to ensure thread safe
    LPWAVEFORMATEX      m_pwfxDst;              //  Destination format, if compressed 
    REFERENCE_TIME      m_rtReadAheadTime;      //  Readahead for streaming.
    DWORD               m_fdwFlags;             //  Various flags, including whether this is a one-shot.
    long                m_cRef;                 //  COM reference counter.
    IStream *           m_pStream;              //  IStream pointer which is connected to IPersistStream
    DWORD               m_fdwOptions;           //  Flags set by call to SetWaveBehavior().
    LPWAVEFORMATEX      m_pwfx;                 //  File's format
    DWORD               m_cbStream;
    DWORD               m_cSamples;
    GUID                m_guid;
    FILETIME            m_ftDate;
    DMUS_VERSION        m_vVersion;
    WCHAR               m_wszFilename[DMUS_MAX_FILENAME];
    DWORD               m_dwDecompressedStart;
};

class CDirectSoundWaveFactory : public IClassFactory
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // Interface IClassFactory
    //
    virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
    virtual STDMETHODIMP LockServer(BOOL bLock); 

    // Constructor
    //
    CDirectSoundWaveFactory();

    // Destructor
    ~CDirectSoundWaveFactory(); 

private:
    long m_cRef;
};

#endif // _DSWAVE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\miscutil.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Misc tiny helper functions.
//

#pragma once

// Releases a COM pointer and then sets it to NULL.  No effect if pointer already was NULL.
template<class T>
void SafeRelease(T *&t) { if (t) t->Release(); t = NULL; }

// Returns the number of elements in an array determined at compile time.
// Note: Only works for variables actually declared as arrays.  Don't try this with a pointer to an array.  There's no way to determine the size at that point.
#define ARRAY_SIZE(array) (sizeof(array) / sizeof(*(array)))

// Zeros memory of struct pointed to.
// Note: This is statically typed.  Don't use it with a pointer to void, pointer to an array, or a pointer to a base class because the size will be too small.
template<class T> void Zero(T *pT) { ZeroMemory(pT, sizeof(*pT)); }

// Zeros memory of the struct pointed to and sets its dwSize field.
template<class T> void ZeroAndSize(T *pT) { Zero(pT); pT->dwSize = sizeof(*pT); }

// Copies one dwSize struct to another dwSize struct without reading/writing beyond either struct
template<class T> void CopySizedStruct(T *ptDest, const T *ptSrc)
{
	assert(ptDest && ptSrc);
	DWORD dwDestSize = ptDest->dwSize;
	memcpy(ptDest, ptSrc, std::_cpp_min(ptDest->dwSize, ptSrc->dwSize));
	ptDest->dwSize = dwDestSize;
}

// Copy pwszSource to pwszDest where pwszDest is a buffer of size uiBufferSize.
// Returns S_OK if successful or DMUS_S_STRING_TRUNCATED if the string had to be truncated.
// Faster then wcsncpy for short strings because the entire buffer isn't padded with nulls.
inline HRESULT wcsTruncatedCopy(WCHAR *pwszDest, const WCHAR *pwszSource, UINT uiBufferSize)
{
    for (UINT i = 0; i < uiBufferSize; ++i)
    {
        if (!(pwszDest[i] = pwszSource[i])) // assign and check for null
            return S_OK; // the whole string copied
    }

    // string needs to be truncated
    pwszDest[uiBufferSize - 1] = L'\0';
    return DMUS_S_STRING_TRUNCATED;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\lyrictrk.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of CLyricTrack.
//

// This track type holds events that send DMUS_LYRIC_PMSG notifications at
// specific points during playback of a segment.

#pragma once

#include "trackhelp.h"
#include "tlist.h"
#include "smartref.h"
#include "dmusicf.h"

//////////////////////////////////////////////////////////////////////
// Types

// Items in list of events
struct LyricInfo
{
	LyricInfo() : dwFlags(0), dwTimingFlags(0), lTriggerTime(0), lTimePhysical(0) {}

	HRESULT Clone(const LyricInfo &o, MUSIC_TIME mtStart)
	{
		*this = o;
		lTriggerTime -= mtStart;
		lTimePhysical -= mtStart;
		return S_OK;
	}

	DWORD dwFlags;
	DWORD dwTimingFlags;
	MUSIC_TIME lTriggerTime; // Logical time
	MUSIC_TIME lTimePhysical;
	SmartRef::WString wstrText;
};

//////////////////////////////////////////////////////////////////////
// CLyricsTrack

class CLyricsTrack;
typedef CPlayingTrack<CLyricsTrack, LyricInfo> CLyricsTrackBase;

class CLyricsTrack
  : public CLyricsTrackBase
{
public:
	// When the lyric track plays one of its items, it sends a Lyric PMsg through its segment state.  If an invalidation occurs,
	// the PMsg is retracted by the performance.  Then the track is played again (with the FLUSH bit set).  The last pameter to
	// the CSegTriggerTrackBase is true, which instructs it to play the item a second time--to replace the retracted lyric.
	CLyricsTrack(HRESULT *pHr) : CLyricsTrackBase(&g_cComponent, CLSID_DirectMusicLyricsTrack, false, true) {}

protected:
	HRESULT PlayItem(
		const LyricInfo &item,
		statedata &state,
		IDirectMusicPerformance *pPerf,
		IDirectMusicSegmentState* pSegSt,
		DWORD dwVirtualID,
		MUSIC_TIME mtOffset,
		REFERENCE_TIME rtOffset,
		bool fClockTime);
	HRESULT LoadRiff(SmartRef::RiffIter &ri, IDirectMusicLoader *pIDMLoader);

private:
	HRESULT LoadLyric(SmartRef::RiffIter ri);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\marktrk.h ===
//MarkTrk.h : Declaration of the marker track

#ifndef __MARKTRK_H_
#define __MARKTRK_H_

#include "dmusici.h"
#include "dmusicf.h"
#include "alist.h"

class CValidStartItem : public AListItem
{
public:
    CValidStartItem* GetNext(){ return (CValidStartItem*)AListItem::GetNext(); };
    DMUS_IO_VALID_START  m_ValidStart;
};
   
class CValidStartList : public AList
{
public:
    CValidStartItem* GetHead() {return (CValidStartItem*)AList::GetHead();};
    CValidStartItem* RemoveHead() {return (CValidStartItem*)AList::RemoveHead();};
    CValidStartItem* GetItem(LONG lIndex) { return (CValidStartItem*) AList::GetItem(lIndex);};
};

class CPlayMarkerItem : public AListItem
{
public:
    CPlayMarkerItem* GetNext(){ return (CPlayMarkerItem*)AListItem::GetNext(); };
    DMUS_IO_PLAY_MARKER  m_PlayMarker;
};
   
class CPlayMarkerList : public AList
{
public:
    CPlayMarkerItem* GetHead() {return (CPlayMarkerItem*)AList::GetHead();};
    CPlayMarkerItem* RemoveHead() {return (CPlayMarkerItem*)AList::RemoveHead();};
    CPlayMarkerItem* GetItem(LONG lIndex) { return (CPlayMarkerItem*) AList::GetItem(lIndex);};
};

/////////////////////////////////////////////////////////////////////////////
// CMarkerTrack
class CMarkerTrack : 
	public IPersistStream,
	public IDirectMusicTrack
{
public:
	CMarkerTrack();
	CMarkerTrack(CMarkerTrack *pTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd);
	~CMarkerTrack();

// member variables
protected:
    CValidStartList     m_ValidStartList;
    CPlayMarkerList     m_PlayMarkerList;
	long		        m_cRef;
	DWORD		        m_dwValidate; // used to validate state data.
	CRITICAL_SECTION	m_CrSec;
    BOOL                m_fCSInitialized;

public:
// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

// IDirectMusicTrack methods
    STDMETHODIMP IsParamSupported(REFGUID rguid);
    STDMETHODIMP Init(IDirectMusicSegment *pSegment);
    STDMETHODIMP InitPlay(IDirectMusicSegmentState *pSegmentState,
                IDirectMusicPerformance *pPerformance,
                void **ppStateData,
                DWORD dwTrackID,
                DWORD dwFlags);
    STDMETHODIMP EndPlay(void *pStateData);
    STDMETHODIMP Play(void *pStateData,MUSIC_TIME mtStart,
                MUSIC_TIME mtEnd,MUSIC_TIME mtOffset,
		        DWORD dwFlags,IDirectMusicPerformance* pPerf,
		        IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID);
    STDMETHODIMP GetParam(REFGUID rguid,MUSIC_TIME mtTime,MUSIC_TIME* pmtNext,void *pData);
    STDMETHODIMP SetParam(REFGUID rguid,MUSIC_TIME mtTime,void *pData);
    STDMETHODIMP AddNotificationType(REFGUID rguidNotification);
    STDMETHODIMP RemoveNotificationType(REFGUID rguidNotification);
    STDMETHODIMP Clone(MUSIC_TIME mtStart,MUSIC_TIME mtEnd,IDirectMusicTrack** ppTrack);

// IPersist functions
    STDMETHODIMP GetClassID( CLSID* pClsId );
// IPersistStream functions
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load( IStream* pIStream );
    STDMETHODIMP Save( IStream* pIStream, BOOL fClearDirty );
    STDMETHODIMP GetSizeMax( ULARGE_INTEGER FAR* pcbSize );
protected:
	void Construct(void);
    void Clear();
    HRESULT LoadValidStartList( CRiffParser *pParser, long lChunkSize );
    HRESULT LoadPlayMarkerList( CRiffParser *pParser, long lChunkSize );
protected:
};

#endif //__MARKTRK_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\marktrk.cpp ===
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)
// MarkTrk.cpp : Implementation of CMarkerTrack

#include "dmime.h"
#include "dmstrm.h"
#include "MarkTrk.h"
#include "dmusici.h"
#include "dmusicf.h"
#include "debug.h"
#include "Validate.h"
#include "debug.h"
#define ASSERT	assert

/////////////////////////////////////////////////////////////////////////////
// CMarkerTrack

void CMarkerTrack::Construct()
{
	InterlockedIncrement(&g_cComponent);

	m_cRef = 1;
    m_fCSInitialized = FALSE;
	InitializeCriticalSection(&m_CrSec);
    m_fCSInitialized = TRUE;
	m_dwValidate = 0;
}

CMarkerTrack::CMarkerTrack()
{
	Construct();
}

CMarkerTrack::CMarkerTrack(
		CMarkerTrack *pSourceTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd)
{
	Construct();
    // Clone the valid start point list.
	CValidStartItem* pVScan = pSourceTrack->m_ValidStartList.GetHead();
	CValidStartItem* pVPrevious = NULL;
	for(; pVScan; pVScan = pVScan->GetNext())
	{
		if (pVScan->m_ValidStart.mtTime < mtStart)
		{
			pVPrevious = pVScan;
		}
		else if (pVScan->m_ValidStart.mtTime < mtEnd)
		{
			if (pVScan->m_ValidStart.mtTime == mtStart)
			{
				pVPrevious = NULL;
			}
			CValidStartItem* pNew = new CValidStartItem;
			if (pNew)
			{
				pNew->m_ValidStart.mtTime = pVScan->m_ValidStart.mtTime - mtStart;
				m_ValidStartList.AddHead(pNew); // instead of AddTail, which is n^2. We reverse below.
			}
		}
		else break;
	}
	m_ValidStartList.Reverse(); // Now, put list in order.
    // Then, install the time signature that precedes the clone.
	if (pVPrevious)
	{
		CValidStartItem* pNew = new CValidStartItem;
		if (pNew)
		{
			pNew->m_ValidStart.mtTime = 0;
			m_ValidStartList.AddHead(pNew);
		}
	}
    // Clone the play marker list. Gee, this is identical code...
	CPlayMarkerItem* pPScan = pSourceTrack->m_PlayMarkerList.GetHead();
	CPlayMarkerItem* pPPrevious = NULL;
	for(; pPScan; pPScan = pPScan->GetNext())
	{
		if (pPScan->m_PlayMarker.mtTime < mtStart)
		{
			pPPrevious = pPScan;
		}
		else if (pPScan->m_PlayMarker.mtTime < mtEnd)
		{
			if (pPScan->m_PlayMarker.mtTime == mtStart)
			{
				pPPrevious = NULL;
			}
			CPlayMarkerItem* pNew = new CPlayMarkerItem;
			if (pNew)
			{
				pNew->m_PlayMarker.mtTime = pPScan->m_PlayMarker.mtTime - mtStart;
				m_PlayMarkerList.AddHead(pNew); // instead of AddTail, which is n^2. We reverse below.
			}
		}
		else break;
	}
	m_PlayMarkerList.Reverse(); // Now, put list in order.
    // Then, install the time signature that precedes the clone.
	if (pPPrevious)
	{
		CPlayMarkerItem* pNew = new CPlayMarkerItem;
		if (pNew)
		{
			pNew->m_PlayMarker.mtTime = 0;
			m_PlayMarkerList.AddHead(pNew);
		}
	}
}

void CMarkerTrack::Clear()

{
	CValidStartItem* pStart;
	while( pStart = m_ValidStartList.RemoveHead() )
	{
		delete pStart;
	}
	CPlayMarkerItem* pPlay;
	while( pPlay = m_PlayMarkerList.RemoveHead() )
	{
		delete pPlay;
	}
}

CMarkerTrack::~CMarkerTrack()
{
    Clear();
    if (m_fCSInitialized)
    {
	    DeleteCriticalSection(&m_CrSec);
    }
	InterlockedDecrement(&g_cComponent);
}

STDMETHODIMP CMarkerTrack::QueryInterface(
    const IID &iid,   // @parm Interface to query for
    void **ppv)       // @parm The requested interface will be returned here
{
	V_INAME(CMarkerTrack::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

   if (iid == IID_IUnknown || iid == IID_IDirectMusicTrack)
    {
        *ppv = static_cast<IDirectMusicTrack*>(this);
    } else
	if (iid == IID_IPersistStream)
	{
        *ppv = static_cast<IPersistStream*>(this);
	} else
    {
        *ppv = NULL;
        Trace(4,"Warning: Request to query unknown interface on Marker Track\n");
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG) CMarkerTrack::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) CMarkerTrack::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

/////////////////////////////////////////////////////////////////////////////
// IPersist

HRESULT CMarkerTrack::GetClassID( CLSID* pClassID )
{
	V_INAME(CMarkerTrack::GetClassID);
	V_PTR_WRITE(pClassID, CLSID); 
	*pClassID = CLSID_DirectMusicMarkerTrack;
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IPersistStream functions

HRESULT CMarkerTrack::IsDirty()
{
	return S_FALSE;
}

HRESULT CMarkerTrack::Load( IStream* pIStream )
{
	V_INAME(CMarkerTrack::Load);
	V_INTERFACE(pIStream);

    CRiffParser Parser(pIStream);
	EnterCriticalSection(&m_CrSec);
	m_dwValidate++; // used to validate state data that's out there
    RIFFIO ckMain;

    HRESULT hr = S_OK;

    Parser.EnterList(&ckMain);  
    if (Parser.NextChunk(&hr) && (ckMain.fccType == DMUS_FOURCC_MARKERTRACK_LIST))
    {
        Clear();
	    RIFFIO ckNext;    // Descends into the children chunks.
        Parser.EnterList(&ckNext);
        while (Parser.NextChunk(&hr))
        {
		    switch(ckNext.ckid)
		    {
            case DMUS_FOURCC_VALIDSTART_CHUNK :
                hr = LoadValidStartList(&Parser,ckNext.cksize);
                break;
            case DMUS_FOURCC_PLAYMARKER_CHUNK :
                hr = LoadPlayMarkerList(&Parser,ckNext.cksize);
                break;
            }    
        }
        Parser.LeaveList();
    }
    else
    {
        Trace(1,"Error: Invalid Marker Track.\n");
        hr = DMUS_E_CHUNKNOTFOUND;
    }
    Parser.LeaveList();
	LeaveCriticalSection(&m_CrSec);
	return hr;
}

HRESULT CMarkerTrack::LoadPlayMarkerList( CRiffParser *pParser, long lChunkSize )
{
	HRESULT hr;
	// copy contents of the stream into the list.
	DWORD dwSubSize;
	// read in the size of the data structures
	hr = pParser->Read( &dwSubSize, sizeof(DWORD));
    if (SUCCEEDED(hr))
    {
	    lChunkSize -= sizeof(DWORD);

	    DWORD dwRead, dwSeek;
	    if( dwSubSize > sizeof(DMUS_IO_PLAY_MARKER) )
	    {
		    dwRead = sizeof(DMUS_IO_PLAY_MARKER);
		    dwSeek = dwSubSize - dwRead;
	    }
	    else
	    {
		    dwRead = dwSubSize;
		    dwSeek = 0;
	    }
	    if( 0 == dwRead )
	    {
            Trace(1,"Error: Invalid Marker Track.\n");
		    hr = DMUS_E_CANNOTREAD;
	    }
        else
        {
	        while( lChunkSize > 0 )
	        {
                CPlayMarkerItem *pNew = new CPlayMarkerItem;
                if (pNew)
                {
		            if( FAILED( pParser->Read( &pNew->m_PlayMarker, dwRead)))
		            {
                        delete pNew;
			            hr = DMUS_E_CANNOTREAD;
			            break;
		            }
                    m_PlayMarkerList.AddHead(pNew); // Insert in reverse order for speed.
		            lChunkSize -= dwRead;
		            if( dwSeek )
		            {
			            if( FAILED( pParser->Skip(dwSeek)))
			            {
				            hr = DMUS_E_CANNOTSEEK;
				            break;
			            }
			            lChunkSize -= dwSeek;
		            }
		        }
	        }
            m_PlayMarkerList.Reverse(); // Reverse to put in time order.
        }
    }
	return hr;
}

HRESULT CMarkerTrack::LoadValidStartList( CRiffParser *pParser, long lChunkSize )
{
    HRESULT hr;
	// copy contents of the stream into the list.
	DWORD dwSubSize;
	// read in the size of the data structures
	hr = pParser->Read( &dwSubSize, sizeof(DWORD));
    if (SUCCEEDED(hr))
    {	
	    lChunkSize -= sizeof(DWORD);

	    DWORD dwRead, dwSeek;
	    if( dwSubSize > sizeof(DMUS_IO_VALID_START) )
	    {
		    dwRead = sizeof(DMUS_IO_VALID_START);
		    dwSeek = dwSubSize - dwRead;
	    }
	    else
	    {
		    dwRead = dwSubSize;
		    dwSeek = 0;
	    }
	    if( 0 == dwRead )
	    {
		    hr = DMUS_E_CANNOTREAD;
	    }
        else
        {
	        while( lChunkSize > 0 )
	        {
                CValidStartItem *pNew = new CValidStartItem;
                if (pNew)
                {
		            if( FAILED( pParser->Read( &pNew->m_ValidStart, dwRead)))
		            {
                        delete pNew;
			            hr = DMUS_E_CANNOTREAD;
			            break;
		            }
                    m_ValidStartList.AddHead(pNew); // Insert in reverse order for speed.
		            lChunkSize -= dwRead;
		            if( dwSeek )
		            {
			            if( FAILED( pParser->Skip(dwSeek)))
			            {
				            hr = DMUS_E_CANNOTSEEK;
				            break;
			            }
			            lChunkSize -= dwSeek;
		            }
		        }
	        }
            m_ValidStartList.Reverse(); // Reverse to put in time order.
        }
    }
	return hr;
}

HRESULT CMarkerTrack::Save( IStream* pIStream, BOOL fClearDirty )
{
	return E_NOTIMPL;
}

HRESULT CMarkerTrack::GetSizeMax( ULARGE_INTEGER FAR* pcbSize )
{
	return E_NOTIMPL;
}

// IDirectMusicTrack

HRESULT STDMETHODCALLTYPE CMarkerTrack::IsParamSupported( 
    /* [in] */ REFGUID rguid)
{
	V_INAME(CMarkerTrack::IsParamSupported);
	V_REFGUID(rguid);

    if ((rguid == GUID_Valid_Start_Time) || 
        (rguid == GUID_Play_Marker))
        return S_OK;
	return DMUS_E_TYPE_UNSUPPORTED;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicTrack::Init
HRESULT CMarkerTrack::Init( 
    /* [in] */ IDirectMusicSegment *pSegment)
{
	return S_OK;
}

HRESULT CMarkerTrack::InitPlay( 
    /* [in] */ IDirectMusicSegmentState *pSegmentState,
    /* [in] */ IDirectMusicPerformance *pPerformance,
    /* [out] */ void **ppStateData,
    /* [in] */ DWORD dwTrackID,
    /* [in] */ DWORD dwFlags)
{
	return S_OK;
}

HRESULT CMarkerTrack::EndPlay( 
    /* [in] */ void *pStateData)
{
	return S_OK;
}

HRESULT CMarkerTrack::Play( 
    /* [in] */ void *pStateData,
    /* [in] */ MUSIC_TIME mtStart,
    /* [in] */ MUSIC_TIME mtEnd,
    /* [in] */ MUSIC_TIME mtOffset,
	DWORD dwFlags,
	IDirectMusicPerformance* pPerf,
	IDirectMusicSegmentState* pSegSt,
	DWORD dwVirtualID
	)
{
	return S_OK;
}

HRESULT CMarkerTrack::GetParam( 
	REFGUID rguid,
    MUSIC_TIME mtTime,
	MUSIC_TIME* pmtNext,
    void *pData)
{
	V_INAME(CMarkerTrack::GetParam);
	V_PTR_WRITE_OPT(pmtNext,MUSIC_TIME);
	V_REFGUID(rguid);

	HRESULT hr = DMUS_E_GET_UNSUPPORTED;
    EnterCriticalSection(&m_CrSec);
	if( NULL == pData )
	{
		hr = E_POINTER;
	}
	else if( GUID_Valid_Start_Time == rguid )
	{
        DMUS_VALID_START_PARAM* pValidStartData = (DMUS_VALID_START_PARAM*)pData;
		CValidStartItem* pScan = m_ValidStartList.GetHead();
		for (; pScan; pScan = pScan->GetNext())
		{
			if (pScan->m_ValidStart.mtTime >= mtTime)
			{
        		pValidStartData->mtTime = pScan->m_ValidStart.mtTime - mtTime;
				break;
			}
		}
        if (pScan)
        {
 		    if (pmtNext)
		    {
		        if (pScan && (pScan = pScan->GetNext()))
		        {
                    *pmtNext = pScan->m_ValidStart.mtTime - mtTime;
			    }
                else
                {
        		    *pmtNext = 0;
                }
            }
		    hr = S_OK;
        }
        else
        {
            hr = DMUS_E_NOT_FOUND;
        }
    }
	else if( GUID_Play_Marker == rguid )
	{
        // This is a little different. The marker should be the one in existence
        // BEFORE, not after the requested time. 
        DMUS_PLAY_MARKER_PARAM* pPlayMarkerData = (DMUS_PLAY_MARKER_PARAM*)pData;
		CPlayMarkerItem* pScan = m_PlayMarkerList.GetHead();
        CPlayMarkerItem* pNext;
        // For fallback, treat it as if there were a marker at the start of the segment, but return S_FALSE.
        hr = S_FALSE;
        pPlayMarkerData->mtTime = -mtTime;
		for (; pScan; pScan = pNext)
		{
            pNext = pScan->GetNext();
            if (pScan->m_PlayMarker.mtTime <= mtTime) 
            {
                if (!pNext || (pNext->m_PlayMarker.mtTime > mtTime))
                {
        		    pPlayMarkerData->mtTime = pScan->m_PlayMarker.mtTime - mtTime;
                    if (pmtNext && pNext)
                    {
                        *pmtNext = pNext->m_PlayMarker.mtTime - mtTime;
                    }
                    hr = S_OK;
				    break;
                }
			}
            else
            {
                // Didn't find a marker before the requested time.
                if (pmtNext)
                {
                    *pmtNext = pScan->m_PlayMarker.mtTime - mtTime;
                }
                break;
            }
		}
    }
#ifdef DBG
    if (hr == DMUS_E_GET_UNSUPPORTED)
    {
        Trace(1,"Error: MarkerTrack does not support requested GetParam call.\n");
    }
#endif
    LeaveCriticalSection(&m_CrSec);
	return hr;
}

HRESULT CMarkerTrack::SetParam( 
	REFGUID rguid,
    MUSIC_TIME mtTime,
    void *pData)
{
	return DMUS_E_SET_UNSUPPORTED;
}

HRESULT STDMETHODCALLTYPE CMarkerTrack::AddNotificationType(
	/* [in] */  REFGUID rguidNotification)
{
	return S_FALSE;
}

HRESULT STDMETHODCALLTYPE CMarkerTrack::RemoveNotificationType(
	/* [in] */  REFGUID rguidNotification)
{
	return S_FALSE;
}

HRESULT STDMETHODCALLTYPE CMarkerTrack::Clone(
	MUSIC_TIME mtStart,
	MUSIC_TIME mtEnd,
	IDirectMusicTrack** ppTrack)
{
	V_INAME(IDirectMusicTrack::Clone);
	V_PTRPTR_WRITE(ppTrack);

	HRESULT hr = S_OK;

	if(mtStart < 0 )
	{
        Trace(1,"Error: Unable to clone marker track because the start point is less than 0.\n");
		return E_INVALIDARG;
	}
	if(mtStart > mtEnd)
	{
        Trace(1,"Error: Unable to clone marker track because the start point is greater than the length.\n");
		return E_INVALIDARG;
	}

	EnterCriticalSection(&m_CrSec);
    CMarkerTrack *pDM;
    
    try
    {
        pDM = new CMarkerTrack(this, mtStart, mtEnd);
    }
    catch( ... )
    {
        pDM = NULL;
    }

	LeaveCriticalSection(&m_CrSec);
    if (pDM == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = pDM->QueryInterface(IID_IDirectMusicTrack, (void**)ppTrack);
    pDM->Release();

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\lyrictrk.cpp ===
//
// Copyright (c) 1999-2001 Microsoft Corporation. All rights reserved.
//
// Declaration of CLyricsTrack.
//

#include "dmime.h"
#include "lyrictrk.h"
#include "Validate.h"
#include "dmperf.h"
#include "miscutil.h"

//////////////////////////////////////////////////////////////////////
// Load

HRESULT
CLyricsTrack::LoadRiff(SmartRef::RiffIter &ri, IDirectMusicLoader *pIDMLoader)
{
    struct LocalFunction
    {
        // Helper used by the LoadRiff function when we expected to find something
        // but a RiffIter becomes false.  In this case, if it has a success HR
        // indicating there were no more items then we return DMUS_E_INVALID_LYRICSTRACK
        // because the stream didn't contain the data we expected.  If it has a
        // failure hr, it was unable to read from the stream and we return its HR.
        static HRESULT HrFailOK(const SmartRef::RiffIter &ri)
        {
            HRESULT hr = ri.hr();
            return SUCCEEDED(hr) ? DMUS_E_INVALID_LYRICSTRACK : hr;
        }
    };

    // find <lyrt>
    if (!ri.Find(SmartRef::RiffIter::List, DMUS_FOURCC_LYRICSTRACK_LIST))
    {
#ifdef DBG
        if (SUCCEEDED(ri.hr()))
        {
            Trace(1, "Error: Unable to load lyric track: List 'lyrt' not found.\n");
        }
#endif
        return LocalFunction::HrFailOK(ri);
    }

    // find <lyrl>
    SmartRef::RiffIter riTrackForm = ri.Descend();
    if (!riTrackForm)
        return riTrackForm.hr();
    if (!riTrackForm.Find(SmartRef::RiffIter::List, DMUS_FOURCC_LYRICSTRACKEVENTS_LIST))
    {
#ifdef DBG
        if (SUCCEEDED(riTrackForm.hr()))
        {
            Trace(1, "Error: Unable to load lyric track: List 'lyrl' not found.\n");
        }
#endif
        return LocalFunction::HrFailOK(riTrackForm);
    }

    // process each event <lyre>
    SmartRef::RiffIter riEvent = riTrackForm.Descend();
    if (!riEvent)
        return riEvent.hr();

    for ( ; riEvent; ++riEvent)
    {
        if (riEvent.type() == SmartRef::RiffIter::List && riEvent.id() == DMUS_FOURCC_LYRICSTRACKEVENT_LIST)
        {
            HRESULT hr = this->LoadLyric(riEvent.Descend());
            if (FAILED(hr))
                return hr;
        }
    }
    return riEvent.hr();
}

//////////////////////////////////////////////////////////////////////
// other methods

HRESULT
CLyricsTrack::PlayItem(
        const LyricInfo &item,
        statedata &state,
        IDirectMusicPerformance *pPerf,
        IDirectMusicSegmentState* pSegSt,
        DWORD dwVirtualID,
        MUSIC_TIME mtOffset,
        REFERENCE_TIME rtOffset,
        bool fClockTime)
{
    // get the graph from the segment state
    IDirectMusicGraph *pGraph = NULL;
    HRESULT hrG = pSegSt->QueryInterface(IID_IDirectMusicGraph, reinterpret_cast<void**>(&pGraph));
    if (FAILED(hrG))
        return hrG;

    SmartRef::PMsg<DMUS_LYRIC_PMSG> pmsg(pPerf, 2 * wcslen(item.wstrText));
    if (FAILED(pmsg.hr())) {
        pGraph->Release();
        return pmsg.hr();
    }

    assert(((char*)&pmsg.p->wszString[wcslen(item.wstrText)]) + 1 < (((char*)(pmsg.p)) + pmsg.p->dwSize)); // just to make sure we haven't miscalculated.  the last byte of the null of the string should fall before the byte just beyond the extent of the struct (and it could be several bytes before if the DMUS_LYRIC_PMSG struct ended up being padded to come out to an even multiple of bytes.
    wcscpy(pmsg.p->wszString, item.wstrText);
    if (fClockTime)
    {
        pmsg.p->rtTime = item.lTimePhysical * gc_RefPerMil + rtOffset;
        pmsg.p->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME | item.dwTimingFlags;
    }
    else
    {
        pmsg.p->mtTime = item.lTimePhysical + mtOffset;
        pmsg.p->dwFlags = DMUS_PMSGF_MUSICTIME | item.dwTimingFlags;
    }
    pmsg.p->dwVirtualTrackID = dwVirtualID;
    pmsg.p->dwType = DMUS_PMSGT_LYRIC;
    pmsg.p->dwGroupID = 0xffffffff;

    pmsg.StampAndSend(pGraph);
    pGraph->Release();

    return pmsg.hr();
}

HRESULT
CLyricsTrack::LoadLyric(SmartRef::RiffIter ri)
{
    HRESULT hr = S_OK;

    if (!ri)
        return ri.hr();

    // Create an event
    TListItem<LyricInfo> *pItem = new TListItem<LyricInfo>;
    if (!pItem)
        return E_OUTOFMEMORY;
    LyricInfo &rinfo = pItem->GetItemValue();

    bool fFoundEventHeader = false;

    for ( ; ri; ++ri)
    {
        if (ri.type() != SmartRef::RiffIter::Chunk)
            continue;

        switch(ri.id())
        {
            case DMUS_FOURCC_LYRICSTRACKEVENTHEADER_CHUNK:
                // Read an event chunk
                DMUS_IO_LYRICSTRACK_EVENTHEADER ioItem;
                hr = SmartRef::RiffIterReadChunk(ri, &ioItem);
                if (FAILED(hr))
                {
                    delete pItem;
                    return hr;
                }

                // Don't allow ref/music timing flags because these are controlled by whether
                // the overall track is playing music or clock time and can't be set in individual
                // events.  Similarly, the tool flush flag isn't appropriate for an event to be played.
                if (ioItem.dwTimingFlags & (DMUS_PMSGF_REFTIME | DMUS_PMSGF_MUSICTIME | DMUS_PMSGF_TOOL_FLUSH | DMUS_PMSGF_LOCKTOREFTIME))
                {
                    Trace(1, "Error: Unable to load lyric track: DMUS_PMSGF_REFTIME, DMUS_PMSGF_MUSICTIME, DMUS_PMSGF_TOOL_FLUSH, and DMUS_PMSGF_LOCKTOREFTIME are not allowed as dwTimingFlags in chunk 'lyrh'.\n");
                    delete pItem;
                    return DMUS_E_INVALID_LYRICSTRACK;
                }

                fFoundEventHeader = true;
                rinfo.dwFlags = ioItem.dwFlags;
                rinfo.dwTimingFlags = ioItem.dwTimingFlags;
                rinfo.lTriggerTime = ioItem.lTimeLogical;
                rinfo.lTimePhysical = ioItem.lTimePhysical;
                break;

            case DMUS_FOURCC_LYRICSTRACKEVENTTEXT_CHUNK:
                {
                    hr = ri.ReadText(&rinfo.wstrText);
                    if (FAILED(hr))
                    {
#ifdef DBG
                        if (hr == E_FAIL)
                        {
                            Trace(1, "Error: Unable to load lyric track: Problem reading 'lyrn' chunk.\n");
                        }
#endif
                        delete pItem;
                        return hr == E_FAIL ? DMUS_E_INVALID_LYRICSTRACK : hr;
                    }
                }
                break;

            default:
                break;
        }
    }
    hr = ri.hr();

    if (SUCCEEDED(hr) && (!fFoundEventHeader || !rinfo.wstrText))
    {
#ifdef DBG
        if (!fFoundEventHeader)
        {
            Trace(1, "Error: Unable to load lyric track: Chunk 'lyrh' not found.\n");
        }
        else
        {
            Trace(1, "Error: Unable to load lyric track: Chunk 'lyrn' not found.\n");
        }
#endif
        hr = DMUS_E_INVALID_LYRICSTRACK;
    }

    if (SUCCEEDED(hr))
    {
        m_EventList.AddHead(pItem);
    }
    else
    {
        delete pItem;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\midifile.h ===
//
// midifile.h
// 
// Copyright (c) 1997-1998 Microsoft Corporation
//
// Note: 
//

#ifndef MIDIFILE_H
#define MIDIFILE_H

HRESULT CreateSegmentFromMIDIStream(LPSTREAM pStream, 
									IDirectMusicSegment* pSegment);
#endif // #ifndef MIDIFILE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\iostru.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1998 Microsoft Corporation
//
//  File:       iostru.h
//
//--------------------------------------------------------------------------

// ioStructs.h
//

#ifndef __IOSTRUCTS_H__
#define __IOSTRUCTS_H__

#pragma pack(2)

#define FOURCC_BAND_FORM        mmioFOURCC('A','A','B','N')
#define FOURCC_CLICK_LIST       mmioFOURCC('A','A','C','L')
#define FOURCC_KEYBOARD_FORM    mmioFOURCC('S','J','K','B')
#define FOURCC_PATTERN_FORM     mmioFOURCC('A','A','P','T')
#define FOURCC_SECTION_FORM     mmioFOURCC('A','A','S','E')
#define FOURCC_SONG_FORM        mmioFOURCC('A','A','S','O')
#define FOURCC_STYLE_FORM       mmioFOURCC('A','A','S','Y')

#define FOURCC_AUTHOR           mmioFOURCC('a','u','t','h')
#define FOURCC_BAND             mmioFOURCC('b','a','n','d')
#define FOURCC_CHORD            mmioFOURCC('c','h','r','d')
#define FOURCC_CLICK            mmioFOURCC('c','l','i','k')
#define FOURCC_COMMAND          mmioFOURCC('c','m','n','d')
#define FOURCC_COPYRIGHT        mmioFOURCC('c','p','y','r')
#define FOURCC_CURVE            mmioFOURCC('c','u','r','v')
#define FOURCC_KEYBOARD         mmioFOURCC('k','y','b','d')
#define FOURCC_LYRIC            mmioFOURCC('l','y','r','c')
#define FOURCC_MUTE             mmioFOURCC('m','u','t','e')
#define FOURCC_NOTE             mmioFOURCC('n','o','t','e')
#define FOURCC_PATTERN          mmioFOURCC('p','a','t','t')
#define FOURCC_PERSONALITYNAME  mmioFOURCC('p','r','n','m')
#define FOURCC_PERSONALITYREF   mmioFOURCC('p','r','e','f')
#define FOURCC_PHRASE           mmioFOURCC('p','h','r','s')
#define FOURCC_PPQN             mmioFOURCC('p','p','q','n')
#define FOURCC_SECTION          mmioFOURCC('s','e','c','n')
#define FOURCC_SECTIONUI        mmioFOURCC('s','c','u','i')
#define FOURCC_STYLE            mmioFOURCC('s','t','y','l')
#define FOURCC_STYLEINFO        mmioFOURCC('i','n','f','o')
#define FOURCC_STYLEREF         mmioFOURCC('s','r','e','f')
#define FOURCC_TITLE            mmioFOURCC('t','i','t','l')

typedef struct ioNoteEvent
{
    long    lTime;           // When this event occurs.
    BYTE    bStatus;         // MIDI status.
    BYTE    bNote;           // Note value.
    BYTE    bVelocity;       // Note velocity.
    BYTE    bVoiceID;        // Band member who will play note
    WORD    wDuration;       // Lead line note duration. (Song)
    BYTE    bEventType;      // Type of event
} ioNoteEvent;

typedef struct ioNote
{
    BYTE    bEventType;           // Type of event
    BYTE    bVoiceID;             // Instrument identifier.
    short   nTime;                // Time from center of beat.
    WORD    wVariation;           // 16 variation bits.
    BYTE    bScaleValue;          // Position in scale.
    BYTE    bBits;                // Various bits.
    BYTE    bValue;               // Note value.
    BYTE    bVelocity;            // Note velocity.
    WORD    nMusicValue;  // Description of note in chord and key.
    short   nDuration;            // Duration
    BYTE    bTimeRange;           // Range to randomize time.
    BYTE    bDurRange;            // Range to randomize duration.
    BYTE    bVelRange;            // Range to randomize velocity.
    BYTE    bPlayMode;
} ioNote;

typedef struct ioCurveEvent
{
    long    lTime;
    WORD    wVariation;
    BYTE    bVoiceID;
    BYTE    bVelocity;
    BYTE    bEventType;
} ioCurveEvent;

typedef struct ioCurve
{
    BYTE    bEventType;
    BYTE    bVoiceID;
    short   nTime;
    WORD    wVariation;
    BYTE    bCCData;
} ioCurve;

typedef struct ioSubCurve
{
    BYTE    bCurveType; // defines the shape of the curve
    char    fFlipped;  // flaggs defining the flipped state: not, vertical, or horizontal
    short   nMinTime;   // left lower corner of bounding box.
    short   nMinValue;  // also used by the ECT_INSTANT curve type.
    short   nMaxTime;   // right upper corner of bounding box.
    short   nMaxValue;
} ioSubCurve;

typedef struct ioMute
{
    long    lTime;           // Time in clocks.
    WORD    wMuteBits;       // Which instruments to mute.
    WORD    wLock;          // Lock flag
} ioMute;

typedef struct ioCommand
{
    long    lTime;       // Time, in clocks.
    DWORD   dwCommand;    // Command type.
} ioCommand;

typedef struct ioChord
{
	long	lChordPattern;	// pattern that defines chord
	long	lScalePattern;	// scale pattern for the chord
	long	lInvertPattern;	// inversion pattern
    BYTE    bRoot;         // root note of chord
    BYTE    bReserved;     // expansion room
    WORD    wCFlags;        // bit flags
	long	lReserved;		// expansion room
} ioChord;

enum
{
	CSF_KEYDOWN = 	1,	// key currently held down in sjam kybd
	CSF_INSCALE = 	2,	// member of scale
	CSF_FLAT =		4,	// display with flat
	CSF_SIMPLE =	8,	// simple chord, display at top of sjam list
};

typedef struct ioChordSelection
{
    wchar_t wstrName[16];   // text for display
    BYTE    fCSFlags;      // ChordSelection flags
    BYTE    bBeat;         // beat this falls on
    WORD    wMeasure;       // measure this falls on
    ioChord aChord[4];      // array of chords: levels
    BYTE    bClick;        // click this falls on
} ioChordSelection;

#define KEY_FLAT 0x80
typedef struct ioSect
{
    long    lTime;           // Time this section starts.
    wchar_t wstrName[16];       // Each section has a name.
    WORD    wTempo;             // Tempo.
    WORD    wRepeats;           // Number of repeats.
    WORD    wMeasureLength;     // Length, in measures.
    WORD    wClocksPerMeasure;  // Length of each measure.
    WORD    wClocksPerBeat;     // Length of each beat.
    WORD    wTempoFract;        // Tempo fraction.  (0-65536) (Score only)
    DWORD   dwFlags;           // Currently not used in SuperJAM!
    char    chKey;          // key sig. High bit is flat bit, the rest is root.
    char    chPad[3];
    GUID    guidStyle;
    GUID    guidPersonality;
    wchar_t wstrCategory[16];
} ioSection;

typedef struct ioBand
{
    wchar_t wstrName[20]; // Band name
    BYTE    abPatch[16];
    BYTE    abVolume[16];
    BYTE    abPan[16];
    signed char achOctave[16];
    char    fDefault;    // This band is the style's default band
    char    chPad;
    WORD    awDLSBank[16];
    BYTE    abDLSPatch[16];
    GUID    guidCollection;
//    wchar_t wstrCollection[16];
    char    szCollection[32];           // this only needs to be single-wide chars
} ioBand;

typedef struct ioLyric
{
    long    lTime;       // Time, in clocks
} ioLyric;

typedef struct ioPhrase
{
    long    lTime;
    BYTE    bID;    // which phrase it is. Index starting at 0.
} ioPhrase;

typedef struct ioClick
{
    short   lTime;               // Index into grid.
} ioClick;

typedef struct ioPattern
{
    long    lTime;             // Time this starts.
    DWORD   dwLength;           // Pattern length in clocks.
    DWORD   fFlags;            // Various flags.
    WORD    wClocksPerClick;   // Size of each click.
    WORD    wBeat;             // What note gets the beat.
    WORD    wClocksPerBeat;    // Size of each beat.
    WORD    wMeasures;         // Number of measures.
    wchar_t wstrName[16];         // Name of pattern.
    DWORD   dwKeyPattern;       // Key for defining in.
    DWORD   dwChordPattern;     // Defining chord.
    BYTE    abInvertUpper[16];   // Inversion upper limit.
    BYTE    abInvertLower[16];   // Inversion upper limit.
    WORD    wInvert;     // Activate inversion flags.
    WORD    awVarFlags[16][16]; // Var flags for all musicians.
    WORD    wAutoInvert;    // Automatically set inversion limits
    BYTE    bRoot;             // Root for defining.
    char    achChordChoice[16];
} ioPattern;

typedef struct ioStyle
{
    wchar_t wstrName[16];         // Each style has a name.
    WORD    wBPM;              // Beats per measure.
    WORD    wBeat;             // Beat note.
    WORD    wClocksPerClick;   // Clocks per click in patterns.
    WORD    wClocksPerBeat;    // Clocks per beat.
    WORD    wClocksPerMeasure; // Clocks per measure.
    WORD    wTempo;            // Tempo.
    WORD    wTempoFract;
    GUID    guid;
    wchar_t wstrCategory[16];
} ioStyle;

typedef struct ioPersonalityRef
{
    wchar_t wstrName[20];       // Internal name stored in personality
    char    fDefault;           // 1=Default personality
    char    achPad[3];
    GUID    guid;
} ioPersonalityRef;

#pragma pack()

#endif// __IOSTRUCTS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\midifile.cpp ===
// Copyright (c) 1998-2001 Microsoft Corporation
//
// midifile.cpp
//
// original author: Dave Miller
// original project: AudioActive
// modified by: Mark Burton
// project: DirectMusic
//

#include <windows.h>
#include <mmsystem.h>
#include <dsoundp.h>
#include "debug.h"
#define ASSERT assert
#include "Template.h"
#include "dmusici.h"
#include "dmperf.h"
#include "dmusicf.h"
//#include "..\dmusic\dmcollec.h"
#include "alist.h"
#include "tlist.h"
#include "dmime.h"
#include "dmbndtrk.h"
#include "bandinst.h"
#include <Ole2.h>

typedef struct _DMUS_IO_BANKSELECT_ITEM
{
    BYTE    byLSB;
    BYTE    byMSB;
    BYTE    byPad[2];
} DMUS_IO_BANKSELECT_ITEM;

#define EVENT_VOICE     1       // Performance event
#define EVENT_REALTIME  2       // qevent() must invoke interrupt
#define EVENT_ONTIME    3       // event should be handled on time

/*  MIDI status bytes ==================================================*/

#define MIDI_NOTEOFF    0x80
#define MIDI_NOTEON     0x90
#define MIDI_PTOUCH     0xA0
#define MIDI_CCHANGE    0xB0
#define MIDI_PCHANGE    0xC0
#define MIDI_MTOUCH     0xD0
#define MIDI_PBEND      0xE0
#define MIDI_SYSX       0xF0
#define MIDI_MTC        0xF1
#define MIDI_SONGPP     0xF2
#define MIDI_SONGS      0xF3
#define MIDI_EOX        0xF7
#define MIDI_CLOCK      0xF8
#define MIDI_START      0xFA
#define MIDI_CONTINUE   0xFB
#define MIDI_STOP       0xFC
#define MIDI_SENSE      0xFE
#define ET_NOTEOFF      ( MIDI_NOTEOFF >> 4 )  // 0x08
#define ET_NOTEON       ( MIDI_NOTEON >> 4 )   // 0x09
#define ET_PTOUCH       ( MIDI_PTOUCH >> 4 )   // 0x0A
#define ET_CCHANGE      ( MIDI_CCHANGE >> 4 )  // 0x0B
#define ET_PCHANGE      ( MIDI_PCHANGE >> 4 )  // 0x0C
#define ET_MTOUCH       ( MIDI_MTOUCH >> 4 )   // 0x0D
#define ET_PBEND        ( MIDI_PBEND >> 4 )    // 0x0E
#define ET_SYSX         ( MIDI_SYSX >> 4 )     // 0x0F
#define ET_PBCURVE      0x03
#define ET_CCCURVE      0x04
#define ET_MATCURVE     0x05
#define ET_PATCURVE     0x06
#define ET_TEMPOEVENT   0x01
#define ET_NOTDEFINED   0

#define NUM_MIDI_CHANNELS 16

struct FSEBlock;

/* FullSeqEvent is SeqEvent plus next pointers*/
typedef struct FullSeqEvent : DMUS_IO_SEQ_ITEM
{
    struct FullSeqEvent* pNext;
    struct FullSeqEvent* pTempNext; /* used in the compresseventlist routine */
    long pos;    /* used to keep track of the order of events in the file */

private:
    DWORD dwPosInBlock;
    static FSEBlock* sm_pBlockList;
public:
    static void CleanUp();
    void* operator new(size_t n);
    void operator delete(void* p);
} FullSeqEvent;

#define BITMAPSPERBLOCK 8
struct FSEBlock
{
    FSEBlock()
    {
        for(int i = 0 ; i < BITMAPSPERBLOCK ; ++i)
        {
            m_dwBitMap[i] = 0;
        }
    };
    FSEBlock* m_pNext;
    DWORD m_dwBitMap[BITMAPSPERBLOCK];
    FullSeqEvent m_Event[BITMAPSPERBLOCK][32];
};

FSEBlock* FullSeqEvent::sm_pBlockList;

void FullSeqEvent::CleanUp()
{
    FSEBlock* pBlock;
    FSEBlock* pNext;

    for(pBlock = sm_pBlockList ; pBlock != NULL ; pBlock = pNext)
    {
#ifdef DEBUG
        for(int i = 0 ; i < BITMAPSPERBLOCK ; ++i)
        {
            if(pBlock->m_dwBitMap[i] != 0)
            {
                DebugBreak();
            }
        }
#endif
        pNext = pBlock->m_pNext;
        delete pBlock;
    }
    sm_pBlockList = NULL;
}

void* FullSeqEvent::operator new(size_t n)
{
    if(sm_pBlockList == NULL)
    {
        sm_pBlockList = new FSEBlock;
        if(sm_pBlockList == NULL)
        {
            return NULL;
        }
        sm_pBlockList->m_pNext = NULL;
        sm_pBlockList->m_dwBitMap[0] = 1;
        sm_pBlockList->m_Event[0][0].dwPosInBlock = 0;
        return &sm_pBlockList->m_Event[0][0];
    }

    FSEBlock* pBlock;
    int i;
    DWORD dw;

    for(pBlock = sm_pBlockList ; pBlock != NULL ; pBlock = pBlock->m_pNext)
    {
        for(i = 0 ; i < BITMAPSPERBLOCK ; ++i)
        {
            if(pBlock->m_dwBitMap[i] != 0xffff)
            {
                break;
            }
        }
        if(i < BITMAPSPERBLOCK)
        {
            break;
        }
    }
    if(pBlock == NULL)
    {
        pBlock = new FSEBlock;
        if(pBlock == NULL)
        {
            return NULL;
        }
        pBlock->m_pNext = sm_pBlockList;
        sm_pBlockList = pBlock;
        pBlock->m_dwBitMap[0] = 1;
        pBlock->m_Event[0][0].dwPosInBlock = 0;
        return &pBlock->m_Event[0][0];
    }

    for(dw = 0 ; (pBlock->m_dwBitMap[i] & (1 << dw)) != 0 ; ++dw);
    pBlock->m_dwBitMap[i] |= (1 << dw);
    pBlock->m_Event[i][dw].dwPosInBlock = (i << 6) | dw;
    return &pBlock->m_Event[i][dw];
}

void FullSeqEvent::operator delete(void* p)
{
    FSEBlock* pBlock;
    int i;
    DWORD dw;
    FullSeqEvent* pEvent = (FullSeqEvent*)p;

    dw = pEvent->dwPosInBlock & 0x1f;
    i = pEvent->dwPosInBlock >> 6;
    for(pBlock = sm_pBlockList ; pBlock != NULL ; pBlock = pBlock->m_pNext)
    {
        if(p == &pBlock->m_Event[i][dw])
        {
            pBlock->m_dwBitMap[i] &= ~(1 << dw);
            return;
        }
    }
}

TList<StampedGMGSXG> gMidiModeList;

// One for each MIDI channel 0-15    
DMUS_IO_BANKSELECT_ITEM gBankSelect[NUM_MIDI_CHANNELS];
DWORD gPatchTable[NUM_MIDI_CHANNELS];
long gPos;                                          // Keeps track of order of events in the file
DWORD gdwLastControllerTime[NUM_MIDI_CHANNELS];     // Holds the time of the last CC event.
DWORD gdwControlCollisionOffset[NUM_MIDI_CHANNELS]; // Holds the index of the last CC.
DWORD gdwLastPitchBendValue[NUM_MIDI_CHANNELS];     // Holds the value of the last pbend event.
long glLastSysexTime;

void CreateChordFromKey(char cSharpsFlats, BYTE bMode, DWORD dwTime, DMUS_CHORD_PARAM& rChord);


void InsertMidiMode( TListItem<StampedGMGSXG>* pPair )
{
    TListItem<StampedGMGSXG>* pScan = gMidiModeList.GetHead();
    if( NULL == pScan )
    {
        gMidiModeList.AddHead(pPair);
    }
    else
    {
        if( pPair->GetItemValue().mtTime < pScan->GetItemValue().mtTime )
        {
            gMidiModeList.AddHead(pPair);
        }
        else
        {
            pScan = pScan->GetNext();
            while( pScan )
            {
                if( pPair->GetItemValue().mtTime < pScan->GetItemValue().mtTime )
                {
                    gMidiModeList.InsertBefore( pScan, pPair );
                    break;
                }
                pScan = pScan->GetNext();
            }
            if( NULL == pScan )
            {
                gMidiModeList.AddTail(pPair);
            }
        }
    }
}

HRESULT LoadCollection(IDirectMusicCollection** ppIDMCollection,
                       IDirectMusicLoader* pIDMLoader)
{
    // Any changes made to this function should also be made to CDirectMusicBand::LoadCollection
    // in dmband.dll

    assert(ppIDMCollection);
    assert(pIDMLoader);

    DMUS_OBJECTDESC desc;
    memset(&desc, 0, sizeof(desc));
    desc.dwSize = sizeof(desc);

    desc.guidClass = CLSID_DirectMusicCollection;
    desc.guidObject = GUID_DefaultGMCollection;
    desc.dwValidData |= (DMUS_OBJ_CLASS | DMUS_OBJ_OBJECT);
    
    HRESULT hr = pIDMLoader->GetObject(&desc,IID_IDirectMusicCollection, (void**)ppIDMCollection);

    return hr;
}

// seeks to a 32-bit position in a stream.
HRESULT __inline StreamSeek( LPSTREAM pStream, long lSeekTo, DWORD dwOrigin )
{
    LARGE_INTEGER li;

    if( lSeekTo < 0 )
    {
        li.HighPart = -1;
    }
    else
    {
    li.HighPart = 0;
    }
    li.LowPart = lSeekTo;
    return pStream->Seek( li, dwOrigin, NULL );
}

// this function gets a long that is formatted the correct way
// i.e. the motorola way as opposed to the intel way
BOOL __inline GetMLong( LPSTREAM pStream, DWORD& dw )
{
    union uLong
    {
        unsigned char buf[4];
    DWORD dw;
    } u;
    unsigned char ch;

    if( S_OK != pStream->Read( u.buf, 4, NULL ) )
    {
    return FALSE;
    }

#ifndef _MAC
    // swap bytes
    ch = u.buf[0];
    u.buf[0] = u.buf[3];
    u.buf[3] = ch;

    ch = u.buf[1];
    u.buf[1] = u.buf[2];
    u.buf[2] = ch;
#endif

    dw = u.dw;
    return TRUE;
}

// this function gets a short that is formatted the correct way
// i.e. the motorola way as opposed to the intel way
BOOL __inline GetMShort( LPSTREAM pStream, short& n )
{
    union uShort
    {
    unsigned char buf[2];
    short n;
    } u;
    unsigned char ch;

    if( S_OK != pStream->Read( u.buf, 2, NULL ) )
    {
    return FALSE;
    }

#ifndef _MAC
    // swap bytes
    ch = u.buf[0];
    u.buf[0] = u.buf[1];
    u.buf[1] = ch;
#endif

    n = u.n;
    return TRUE;
}

static short snPPQN;
static IStream* gpTempoStream = NULL;
static IStream* gpSysExStream = NULL;
static IStream* gpTimeSigStream = NULL;
static DWORD gdwSizeTimeSigStream = 0;
static DWORD gdwSizeSysExStream = 0;
static DWORD gdwSizeTempoStream = 0;
static DMUS_IO_TIMESIGNATURE_ITEM gTimeSig; // holds the latest time sig
long    glTimeSig = 1; // flag to see if we should be paying attention to time sigs.
    // this is needed because we only care about the time sigs on the first track to
    // contain them that we read
static IDirectMusicTrack* g_pChordTrack = NULL;
static DMUS_CHORD_PARAM g_Chord; // Holds the latest chord
static DMUS_CHORD_PARAM g_DefaultChord; // in case no chords are extracted from the track

static WORD GetVarLength( LPSTREAM pStream, DWORD& rfdwValue )
{
    BYTE b;
    WORD wBytes;

    if( S_OK != pStream->Read( &b, 1, NULL ) )
    {
        rfdwValue = 0;
        return 0;
    }
    wBytes = 1;
    rfdwValue = b & 0x7f;
    while( ( b & 0x80 ) != 0 )
    {
        if( S_OK != pStream->Read( &b, 1, NULL ) )
        {
            break;
        }
        ++wBytes;
        rfdwValue = ( rfdwValue << 7 ) + ( b & 0x7f );
    }
    return wBytes;
}

#ifdef _MAC
static DWORD ConvertTime( DWORD dwTime )
{
    wide d;
    long l;  // storage for the remainder

    if( snPPQN == DMUS_PPQ )  {
        return dwTime;
    }
    WideMultiply( dwTime, DMUS_PPQ, &d );
    return WideDivide( &d, snPPQN, &l );
}
#else
static DWORD ConvertTime( DWORD dwTime )
{
    __int64 d;

    if( snPPQN == DMUS_PPQ )
    {
        return dwTime;
    }
    d = dwTime;
    d *= DMUS_PPQ;
    d /= snPPQN;
    return (DWORD)d;
}
#endif

static FullSeqEvent* ScanForDuplicatePBends( FullSeqEvent* lstEvent )
{
    FullSeqEvent* pEvent;
    FullSeqEvent* pNextEvent;
    MUSIC_TIME mtCurrentTime = 0x7FFFFFFF;  // We are scanning backwards in time, so start way in the future.
    WORD wDupeBits = 0;     // Keep a bit array of all channels that have active PBends at mtCurrentTime. 

    if( NULL == lstEvent ) return NULL;

    // Scan through the list of events. This list is in backwards order, with the first item read at the end
    // of the list. This makes it very easy to scan through and remove pitch bends that occur at the same time, since
    // we can remove the latter events (which occured earlier in the midi file.)
    for( pEvent = lstEvent ; pEvent ; pEvent = pNextEvent )
    {
        pNextEvent = pEvent->pNext;
        if( pNextEvent )
        {
            // If the time is not the same as the last, reset. 
            if (pNextEvent->mtTime != mtCurrentTime)
            {
                // Reset the time.
                mtCurrentTime = pNextEvent->mtTime;
                // No duplicate pbends at this time.
                wDupeBits = 0;
            }
            if ((pNextEvent->bStatus & 0xf0) == MIDI_PBEND)
            {
                DWORD dwChannel = pNextEvent->dwPChannel;
                if (wDupeBits & (1 << dwChannel))
                {
                    // There was a previous (therefore later in the file) pbend at this time. Delete this one.
                    pEvent->pNext = pNextEvent->pNext;
                    delete pNextEvent;
                    pNextEvent = pEvent;
                }
                else
                {
                    // This is the last instance of a pbend on this channel at this time, so hang on to it.
                    wDupeBits |= (1 << dwChannel);
                }
            }
        }
    }
    return lstEvent;
}


static FullSeqEvent* CompressEventList( FullSeqEvent* lstEvent )
{
    static FullSeqEvent* paNoteOnEvent[16][128];
    FullSeqEvent* pEvent;
    FullSeqEvent* pPrevEvent;
    FullSeqEvent* pNextEvent;
    FullSeqEvent* pHoldEvent;
    FullSeqEvent tempEvent;
    int nChannel;

    if( NULL == lstEvent ) return NULL;

    memset( paNoteOnEvent, 0, sizeof( paNoteOnEvent ) );
    pPrevEvent = NULL;

    // add an event to the beginning of the list as a place holder
    memset( &tempEvent, 0, sizeof(FullSeqEvent) );
    tempEvent.mtTime = -1;
    tempEvent.pNext = lstEvent;
    lstEvent = &tempEvent;
    // make sure that any events with the same time are sorted in order
    // they were read
    for( pEvent = lstEvent ; pEvent != NULL ; pEvent = pNextEvent )
    {
        pNextEvent = pEvent->pNext;
        if( pNextEvent )
        {
            BOOL fSwap = TRUE;
            // bubble sort
            while( fSwap )
            {
                fSwap = FALSE;
                pPrevEvent = pEvent;
                pNextEvent = pEvent->pNext;
                while( pNextEvent->pNext && ( pNextEvent->mtTime == pNextEvent->pNext->mtTime ))
                {
                    if( pNextEvent->pNext->pos < pNextEvent->pos )
                    {
                        fSwap = TRUE;
                        pHoldEvent = pNextEvent->pNext;
                        pPrevEvent->pNext = pHoldEvent;
                        pNextEvent->pNext = pHoldEvent->pNext;
                        pHoldEvent->pNext = pNextEvent;
                        pPrevEvent = pHoldEvent;
                        continue;
                    }
                    pPrevEvent = pNextEvent;
                    pNextEvent = pNextEvent->pNext;
                }
            }
        }
    }
    // remove the first, temporary event, added above
    lstEvent = lstEvent->pNext;

    pPrevEvent = NULL;
    // combine note on and note offs
    for( pEvent = lstEvent ; pEvent != NULL ; pEvent = pNextEvent )
    {
        pEvent->pTempNext = NULL;
        pNextEvent = pEvent->pNext;
        //nChannel = pEvent->bStatus & 0xf;
        nChannel = pEvent->dwPChannel;
        if( ( pEvent->bStatus & 0xf0 ) == MIDI_NOTEON )
        {
            // add this event to the end of the list of events based
            // on the event's pitch. Keeping track of multiple events
            // of the same pitch allows us to have overlapping notes
            // of the same pitch, choosing that note on's and note off's
            // follow in the same order.
            if( NULL == paNoteOnEvent[nChannel][pEvent->bByte1] )
            {
                paNoteOnEvent[nChannel][pEvent->bByte1] = pEvent;
            }
            else
            {
                FullSeqEvent* pScan;
                for( pScan = paNoteOnEvent[nChannel][pEvent->bByte1];
                     pScan->pTempNext != NULL; pScan = pScan->pTempNext );
                pScan->pTempNext = pEvent;
            }
        }
        else if( ( pEvent->bStatus & 0xf0 ) == MIDI_NOTEOFF )
        {
            if( paNoteOnEvent[nChannel][pEvent->bByte1] != NULL )
            {
                paNoteOnEvent[nChannel][pEvent->bByte1]->mtDuration =
                    pEvent->mtTime - paNoteOnEvent[nChannel][pEvent->bByte1]->mtTime;
                paNoteOnEvent[nChannel][pEvent->bByte1] =
                    paNoteOnEvent[nChannel][pEvent->bByte1]->pTempNext;
            }
            if( pPrevEvent == NULL )
            {
                lstEvent = pNextEvent;
            }
            else
            {
                pPrevEvent->pNext = pNextEvent;
            }
            delete pEvent;
            continue;
        }
        pPrevEvent = pEvent;
    }

    for( pEvent = lstEvent ; pEvent != NULL ; pEvent = pEvent->pNext )
    {
        pEvent->mtTime = pEvent->mtTime;
        if( ( pEvent->bStatus & 0xf0 ) == MIDI_NOTEON )
        {
            pEvent->mtDuration = pEvent->mtDuration;
            if( pEvent->mtDuration == 0 ) pEvent->mtDuration = 1;
        }
    }

    return lstEvent;
}

static int CompareEvents( FullSeqEvent* pEvent1, FullSeqEvent* pEvent2 )
{
    BYTE bEventType1 = static_cast<BYTE>( pEvent1->bStatus >> 4 );
    BYTE bEventType2 = static_cast<BYTE>( pEvent2->bStatus >> 4 );

    if( pEvent1->mtTime < pEvent2->mtTime )
    {
        return -1;
    }
    else if( pEvent1->mtTime > pEvent2->mtTime )
    {
        return 1;
    }
    else if( bEventType1 != ET_SYSX && bEventType2 != ET_SYSX )
    {
        BYTE bStatus1;
        BYTE bStatus2;

        bStatus1 = (BYTE)( pEvent1->bStatus & 0xf0 );
        bStatus2 = (BYTE)( pEvent2->bStatus & 0xf0 );
        if( bStatus1 == bStatus2 )
        {
            return 0;
        }
        else if( bStatus1 == MIDI_NOTEON )
        {
            return -1;
        }
        else if( bStatus2 == MIDI_NOTEON )
        {
            return 1;
        }
        else if( bStatus1 > bStatus2 )
        {
            return 1;
        }
        else if( bStatus1 < bStatus2 )
        {
            return -1;
        }
    }
    return 0;
}

static FullSeqEvent* MergeEvents( FullSeqEvent* lstLeftEvent, FullSeqEvent* lstRightEvent )
{
    FullSeqEvent  anchorEvent;
    FullSeqEvent* pEvent;

    anchorEvent.pNext = NULL;
    pEvent = &anchorEvent;

    do
    {
    if( CompareEvents( lstLeftEvent, lstRightEvent ) < 0 )
    {
        pEvent->pNext = lstLeftEvent;
        pEvent = lstLeftEvent;
        lstLeftEvent = lstLeftEvent->pNext;
        if( lstLeftEvent == NULL )
        {
        pEvent->pNext = lstRightEvent;
        }
    }
    else
    {
        pEvent->pNext = lstRightEvent;
        pEvent = lstRightEvent;
        lstRightEvent = lstRightEvent->pNext;
        if( lstRightEvent == NULL )
        {
        pEvent->pNext = lstLeftEvent;
        lstLeftEvent = NULL;
        }
    }
    } while( lstLeftEvent != NULL );

    return anchorEvent.pNext;
}

static FullSeqEvent* SortEventList( FullSeqEvent* lstEvent )
{
    FullSeqEvent* pMidEvent;
    FullSeqEvent* pRightEvent;

    if( lstEvent != NULL && lstEvent->pNext != NULL )
    {
    pMidEvent = lstEvent;
    pRightEvent = pMidEvent->pNext->pNext;
    if( pRightEvent != NULL )
    {
        pRightEvent = pRightEvent->pNext;
    }
    while( pRightEvent != NULL )
    {
        pMidEvent = pMidEvent->pNext;
        pRightEvent = pRightEvent->pNext;
        if( pRightEvent != NULL )
        {
        pRightEvent = pRightEvent->pNext;
        }
    }
    pRightEvent = pMidEvent->pNext;
    pMidEvent->pNext = NULL;
    return MergeEvents( SortEventList( lstEvent ),
                SortEventList( pRightEvent ) );
    }
    return lstEvent;
}

static DWORD ReadEvent( LPSTREAM pStream, DWORD dwTime, FullSeqEvent** plstEvent, DMUS_IO_PATCH_ITEM** pplstPatchEvent )
{
    static BYTE bRunningStatus;

    gPos++;
    dwTime = ConvertTime(dwTime);

    DWORD dwBytes;
    DWORD dwLen;
    FullSeqEvent* pEvent;
    DMUS_IO_PATCH_ITEM* pPatchEvent;
    DMUS_IO_SYSEX_ITEM* pSysEx;
    BYTE b;

    BYTE* pbSysExData = NULL;

    if( FAILED( pStream->Read( &b, 1, NULL ) ) )
    {
        return 0;
    }

    if( b < 0x80 )
    {
        StreamSeek( pStream, -1, STREAM_SEEK_CUR );
        b = bRunningStatus;
        dwBytes = 0;
    }
    else
    {
        dwBytes = 1;
    }

    if( b < 0xf0 )
    {
        bRunningStatus = (BYTE)b;

        switch( b & 0xf0 )
        {
        case MIDI_CCHANGE:
        case MIDI_PTOUCH:
        case MIDI_PBEND:
        case MIDI_NOTEOFF:
        case MIDI_NOTEON:
            if( FAILED( pStream->Read( &b, 1, NULL ) ) )
            {
                return dwBytes;
            }
            ++dwBytes;

            pEvent = new FullSeqEvent;
            if( pEvent == NULL )
            {
                return 0;
            }

            pEvent->mtTime = dwTime;
            pEvent->nOffset = 0;
            pEvent->pos = gPos;
            pEvent->mtDuration = 0;
            pEvent->bStatus = bRunningStatus & 0xf0;
            pEvent->dwPChannel = bRunningStatus & 0xf;
            pEvent->bByte1 = b;
            if( FAILED( pStream->Read( &b, 1, NULL ) ) )
            {
                delete pEvent;
                return dwBytes;
            }
            ++dwBytes;
            pEvent->bByte2 = b;

            if( ( pEvent->bStatus & 0xf0 ) == MIDI_NOTEON &&
                pEvent->bByte2 == 0 )
            {
                pEvent->bStatus = (BYTE)( MIDI_NOTEOFF );
            }

            /*  If there are multiple controller events at the same time, seperate
                them by clock ticks. 
                gdwLastControllerTime holds the time of the last CC event.
                gdwControlCollisionOffset holds the number of colliding CCs.
            */

            if ((pEvent->bStatus & 0xf0) == MIDI_CCHANGE)
            {
                DWORD dwChannel = pEvent->dwPChannel;
                if (dwTime == gdwLastControllerTime[dwChannel])
                {
                    pEvent->mtTime += ++gdwControlCollisionOffset[dwChannel];
                }
                else
                {
                    gdwControlCollisionOffset[dwChannel] = 0;
                    gdwLastControllerTime[dwChannel] = dwTime;
                }
            }

            if(((pEvent->bStatus & 0xf0) == MIDI_CCHANGE) && (pEvent->bByte1 == 0 || pEvent->bByte1 == 0x20))
            {
                // We have a bank select or its LSB either of which are not added to event list
                if(pEvent->bByte1 == 0x20)
                {
                    gBankSelect[pEvent->dwPChannel].byLSB = pEvent->bByte2;
                }
                else // pEvent->bByte1 == 0
                {
                    gBankSelect[pEvent->dwPChannel].byMSB = pEvent->bByte2;
                }
                // We no longer need the event so we can free it
                delete pEvent;
            }
            else // Add to event list
            {
                pEvent->pNext = *plstEvent;
                *plstEvent = pEvent;
            }
            break;

        case MIDI_PCHANGE:
            if(FAILED(pStream->Read(&b, 1, NULL)))
            {
                return dwBytes;
            }
            
            ++dwBytes;

            pPatchEvent = new DMUS_IO_PATCH_ITEM;

            if(pPatchEvent == NULL)
            {
                return 0;
            }
            memset(pPatchEvent, 0, sizeof(DMUS_IO_PATCH_ITEM));
            pPatchEvent->lTime = dwTime - 1;
            pPatchEvent->byStatus = bRunningStatus;
            pPatchEvent->byPChange = b;
            pPatchEvent->byMSB = gBankSelect[bRunningStatus & 0xF].byMSB;
            pPatchEvent->byLSB = gBankSelect[bRunningStatus & 0xF].byLSB;
            pPatchEvent->dwFlags |= DMUS_IO_INST_PATCH;

            if((pPatchEvent->byMSB != 0xFF) && (pPatchEvent->byLSB != 0xFF))
            {
                pPatchEvent->dwFlags |= DMUS_IO_INST_BANKSELECT;                        
            }

            gPatchTable[bRunningStatus & 0xF] = 1;

            pPatchEvent->pNext = *pplstPatchEvent;
            pPatchEvent->pIDMCollection = NULL;

            *pplstPatchEvent = pPatchEvent;

            break;

        case MIDI_MTOUCH:
            if( FAILED( pStream->Read( &b, 1, NULL ) ) )
            {
                return dwBytes;
            }
            ++dwBytes;
            pEvent = new FullSeqEvent;
            if( pEvent == NULL )
            {
                return 0;
            }


            pEvent->mtTime = dwTime;
            pEvent->nOffset = 0;
            pEvent->pos = gPos;
            pEvent->mtDuration = 0;
            pEvent->bStatus = bRunningStatus & 0xf0;
            pEvent->dwPChannel = bRunningStatus & 0xf;
            pEvent->bByte1 = b;
            pEvent->pNext = *plstEvent;
            *plstEvent = pEvent;
            break;
        default:
            // this should NOT be possible - unknown midi note event type
            ASSERT(FALSE);
            break;
        }
    }
    else
    {
        switch( b )
        {
        case 0xf0:
            dwBytes += GetVarLength( pStream, dwLen );
            pSysEx = new DMUS_IO_SYSEX_ITEM;
            if( pSysEx != NULL )
            {
                pbSysExData = new BYTE[dwLen + 1];
                if( pbSysExData != NULL )
                {
                    MUSIC_TIME mt = dwTime;
                    if (mt == 0)
                    {
                        mt = glLastSysexTime++;
                        if (mt > 0) mt = 0;
                    }
                    pbSysExData[0] = 0xf0;
                    if( FAILED( pStream->Read( pbSysExData + 1, dwLen, NULL ) ) )
                    {
                        delete [] pbSysExData;
                        delete pSysEx;
                        return dwBytes;
                    }

                    if( pbSysExData[1] == 0x43 )
                    {
                        // check for XG files
                        BYTE abXG[] = { 0xF0, 0x43, 0x10, 0x4C, 0x00, 0x00, 0x7E, 0x00, 0xF7 };
                        int i;
                        for( i = 0; i < 8; i++ )
                        {
                            if( i == 2 )
                            {
                                if( ( pbSysExData[i] & 0xF0 ) != abXG[i] )
                                    break;
                            }
                            else
                            {
                                if( pbSysExData[i] != abXG[i] )
                                    break;
                            }
                        }
                        if( i == 8 ) // we have an XG!
                        {
                            TListItem<StampedGMGSXG>* pPair = new TListItem<StampedGMGSXG>;
                            if (!pPair) return dwBytes;
                            pPair->GetItemValue().mtTime = mt;
                            pPair->GetItemValue().dwMidiMode = DMUS_MIDIMODEF_XG;
                            InsertMidiMode(pPair);
                        }
                    }
                    else if( pbSysExData[1] == 0x41 )
                    {
                        // check for GS files
                        BYTE abGS[] = { 0xF0,0x41,0x00,0x42,0x12,0x40,0x00,0x7F,0x00,0x41,0xF7 };
                        int i;
                        for( i = 0; i < 10; i++ )
                        {
                            if( i != 2 )
                            {
                                if( pbSysExData[i] != abGS[i] )
                                    break;
                            }
                        }
                        if( i == 10 ) // we have a GS!
                        {
                            TListItem<StampedGMGSXG>* pPair = new TListItem<StampedGMGSXG>;
                            if (!pPair) return dwBytes;
                            pPair->GetItemValue().mtTime = mt;
                            pPair->GetItemValue().dwMidiMode = DMUS_MIDIMODEF_GS;
                            InsertMidiMode(pPair);
                        }
                    }
                    else if (( pbSysExData[1] == 0x7E ) && (pbSysExData[3] == 0x09))
                    {
                        TListItem<StampedGMGSXG>* pPair = new TListItem<StampedGMGSXG>;
                        if (!pPair) return dwBytes;
                        pPair->GetItemValue().mtTime = mt;
                        pPair->GetItemValue().dwMidiMode = DMUS_MIDIMODEF_GM;
                        InsertMidiMode(pPair);
                    }
                    pSysEx->mtTime = mt;
                    pSysEx->dwPChannel = 0;
                    DWORD dwTempLen = dwLen + 1;
                    pSysEx->dwSysExLength = dwTempLen;
                    if( NULL == gpSysExStream )
                    {
                        // create a stream to hold sysex events
                        CreateStreamOnHGlobal( NULL, TRUE, &gpSysExStream );
                        if( gpSysExStream )
                        {
                            DWORD dwTemp;
                            // write the chunk header
                            dwTemp = DMUS_FOURCC_SYSEX_TRACK;
                            gpSysExStream->Write( &dwTemp, sizeof(DWORD), NULL );
                            // write the overall size. (Replace this later with the
                            // true overall size.)
                            dwTemp = sizeof(DMUS_IO_TIMESIGNATURE_ITEM);
                            // overall size (to be replaced later)
                            gpSysExStream->Write( &dwTemp, sizeof(DWORD), NULL );
                        }
                    }
                    if( gpSysExStream )
                    {
                        gpSysExStream->Write( &pSysEx->mtTime, sizeof(MUSIC_TIME), NULL );
                        gpSysExStream->Write( &pSysEx->dwPChannel, sizeof(DWORD), NULL );
                        gpSysExStream->Write( &pSysEx->dwSysExLength, sizeof(DWORD), NULL );
                        gpSysExStream->Write( pbSysExData, dwTempLen, NULL );
                        gdwSizeSysExStream += (sizeof(long) + sizeof(DWORD) + dwTempLen);
                    }
                    delete [] pbSysExData;
                    delete pSysEx;
                }
                else
                {
                    StreamSeek( pStream, dwLen, STREAM_SEEK_CUR );
                }
            }
            else
            {
                StreamSeek( pStream, dwLen, STREAM_SEEK_CUR );
            }
            dwBytes += dwLen;
            break;
        case 0xf7:
            // ignore sysex f7 chunks
            dwBytes += GetVarLength( pStream, dwLen );
            StreamSeek( pStream, dwLen, STREAM_SEEK_CUR );
            dwBytes += dwLen;
            break;
        case 0xff:
            if( FAILED( pStream->Read( &b, 1, NULL ) ) )
            {
                return dwBytes;
            }
            ++dwBytes;
            dwBytes += GetVarLength( pStream, dwLen );
            if( b == 0x51 ) // tempo change
            {
                DWORD dw = 0;
                DMUS_IO_TEMPO_ITEM tempo;

                while( dwLen > 0 )
                {
                    if( FAILED( pStream->Read( &b, 1, NULL ) ) )
                    {
                        return dwBytes;
                    }
                    ++dwBytes;
                    --dwLen;
                    dw <<= 8;
                    dw += b;
                }
                if (dw < 1) dw = 1;
                tempo.dblTempo = 60000000.0 / ((double)dw);
                tempo.lTime = dwTime;
                if( NULL == gpTempoStream )
                {
                    // create a stream to hold tempo events
                    CreateStreamOnHGlobal( NULL, TRUE, &gpTempoStream );
                    if( gpTempoStream )
                    {
                        DWORD dwTemp;
                        // write the chunk header
                        dwTemp = DMUS_FOURCC_TEMPO_TRACK;
                        gpTempoStream->Write( &dwTemp, sizeof(DWORD), NULL );
                        // write the overall size. (Replace this later with the
                        // true overall size.) Also write the size of the individual
                        // structure.
                        dwTemp = sizeof(DMUS_IO_TEMPO_ITEM);
                        // overall size (to be replaced later)
                        gpTempoStream->Write( &dwTemp, sizeof(DWORD), NULL );
                        // individual structure.
                        gpTempoStream->Write( &dwTemp, sizeof(DWORD), NULL );
                    }
                }
                if( gpTempoStream )
                {
                    gpTempoStream->Write( &tempo, sizeof(DMUS_IO_TEMPO_ITEM), NULL );
                    gdwSizeTempoStream += sizeof(DMUS_IO_TEMPO_ITEM);
                }
            }
            else if( b == 0x58 && glTimeSig )
            {
                // glTimeSig will be set to 0 inside the main calling function
                // once we no longer care about time sigs.
                DMUS_IO_TIMESIGNATURE_ITEM timesig;
                if( FAILED( pStream->Read( &b, 1, NULL ) ) )
                {
                    return dwBytes;
                }
                // set glTimeSig to 2 to signal to the main function that we've
                // read a time sig on this track
                glTimeSig = 2;
                gTimeSig.lTime = timesig.lTime = dwTime;
                gTimeSig.bBeatsPerMeasure = timesig.bBeatsPerMeasure = b;
                ++dwBytes;
                if( FAILED( pStream->Read( &b, 1, NULL ) ) )
                {
                    return dwBytes;
                }
                gTimeSig.bBeat = timesig.bBeat = (BYTE)( 1 << b ); // 0 means 256th note
                gTimeSig.wGridsPerBeat = timesig.wGridsPerBeat = 4; // this is irrelavent for MIDI files
                
                if( NULL == gpTimeSigStream )
                {
                    CreateStreamOnHGlobal( NULL, TRUE, &gpTimeSigStream );
                    if( gpTimeSigStream )
                    {
                        DWORD dwTemp;
                        // write the chunk header
                        dwTemp = DMUS_FOURCC_TIMESIGNATURE_TRACK;
                        gpTimeSigStream->Write( &dwTemp, sizeof(DWORD), NULL );
                        // write the overall size. (Replace this later with the
                        // true overall size.) Also write the size of the individual
                        // structure.
                        dwTemp = sizeof(DMUS_IO_TIMESIGNATURE_ITEM);
                        // overall size (to be replaced later)
                        gpTimeSigStream->Write( &dwTemp, sizeof(DWORD), NULL );
                        // individual structure.
                        gpTimeSigStream->Write( &dwTemp, sizeof(DWORD), NULL );
                        gdwSizeTimeSigStream += sizeof(DWORD);
                    }
                }
                if( gpTimeSigStream )
                {
                    gpTimeSigStream->Write( &timesig, sizeof(DMUS_IO_TIMESIGNATURE_ITEM), NULL );
                    gdwSizeTimeSigStream += sizeof(DMUS_IO_TIMESIGNATURE_ITEM);
                }
                ++dwBytes;
                StreamSeek( pStream, dwLen - 2, STREAM_SEEK_CUR );
                dwBytes += ( dwLen - 2 );
            }
            else if( b == 0x59 )
            {
                // Read sharps/flats and major/minor bytes
                if( FAILED( pStream->Read( &b, 1, NULL ) ) )
                {
                    return dwBytes;
                }
                char cSharpsFlats = b;
                ++dwBytes;
                if( FAILED( pStream->Read( &b, 1, NULL ) ) )
                {
                    return dwBytes;
                }
                BYTE bMode = b;
                ++dwBytes;

                // Create a chord (with one subchord) from the key info
                CreateChordFromKey(cSharpsFlats, bMode, dwTime, g_Chord);

                // If the chord track is empty, create it.
                if (!g_pChordTrack)
                {
                    HRESULT hr = CoCreateInstance( 
                            CLSID_DirectMusicChordTrack, NULL, CLSCTX_INPROC,
                            IID_IDirectMusicTrack,
                            (void**)&g_pChordTrack );
                    if (!SUCCEEDED(hr)) return dwBytes;

                    // If dwTime > 0, use SetParam to insert the default chord at time 0
                    if (dwTime > 0)
                    {
                        g_pChordTrack->SetParam(GUID_ChordParam, 0, &g_DefaultChord);
                    }
                }

                // Use SetParam to insert the new chord into the chord track
                g_pChordTrack->SetParam(GUID_ChordParam, dwTime, &g_Chord);

            }
            else
            {
                StreamSeek( pStream, dwLen, STREAM_SEEK_CUR );
                dwBytes += dwLen;
            }
            break;
        default:
            break;
        }
    }
    return dwBytes;
}

static void AddOffsets(FullSeqEvent* lstEvent, IDirectMusicTrack* pTimeSigTrack)
{
    HRESULT hr;
    MUSIC_TIME mtNext = 0;
    DMUS_IO_TIMESIGNATURE_ITEM timesig;
    timesig.bBeat = gTimeSig.bBeat ? gTimeSig.bBeat : 4;
    timesig.bBeatsPerMeasure = gTimeSig.bBeatsPerMeasure ? gTimeSig.bBeatsPerMeasure : 4;
    timesig.wGridsPerBeat = gTimeSig.wGridsPerBeat ? gTimeSig.wGridsPerBeat : 4;
    timesig.lTime = 0;
    short nClocksPerGrid = ((DMUS_PPQ * 4) / timesig.bBeat) / timesig.wGridsPerBeat;

    if (pTimeSigTrack)
    {
        hr = pTimeSigTrack->GetParam(GUID_TimeSignature, 0, &mtNext, (void*)&timesig);
        if (FAILED(hr))
        {
            mtNext = 0;
        }
        else
        {
            nClocksPerGrid = ((DMUS_PPQ * 4) / timesig.bBeat) / timesig.wGridsPerBeat;
        }
    }

    for( FullSeqEvent* pEvent = lstEvent; pEvent; pEvent = pEvent->pNext )
    {
        if ( ( pEvent->bStatus & 0xf0 ) == MIDI_NOTEON )
        {
            if (mtNext && pTimeSigTrack && mtNext < pEvent->mtTime)
            {
                hr = pTimeSigTrack->GetParam(GUID_TimeSignature, mtNext, &mtNext, (void*)&timesig);
                if (FAILED(hr))
                {
                    mtNext = 0;
                }
                else
                {
                    nClocksPerGrid = ((DMUS_PPQ * 4) / timesig.bBeat) / timesig.wGridsPerBeat;
                }
            }
            ASSERT(nClocksPerGrid);
            if( 0 == nClocksPerGrid ) nClocksPerGrid = 1; // this should never happen, but just in case.
            pEvent->nOffset = (short) ((pEvent->mtTime - timesig.lTime) % nClocksPerGrid);
            pEvent->mtTime -= pEvent->nOffset;
            if (pEvent->nOffset > (nClocksPerGrid / 2))
            {
                // make it a negative offset and bump the time a corresponding amount
                pEvent->nOffset -= nClocksPerGrid;
                pEvent->mtTime += nClocksPerGrid;
            }
        }
    }

}

/*

  @method HRESULT | IDirectMusicPerformance | CreateSegmentFromMIDIStream |
  Given a MIDI stream, creates a Segment that can be played via
  <im IDirectMusicPerformance.PlaySegment>.

  @parm LPSTREAM | pStream |
  [in] The MIDI stream. It should be set to the correct seek to begin reading.
  @parm IDirectMusicSegment* | pSegment |
  [out] A pointer to contain the created Segment.

  @rvalue DMUS_E_CANNOTREAD | There was an error attempting to read the MIDI file.
  @rvalue S_OK

*/
HRESULT CreateSegmentFromMIDIStream(LPSTREAM pStream,
                                    IDirectMusicSegment* pSegment)
{
    if(pSegment == NULL || pStream == NULL)
    {
        return E_POINTER;
    }

    HRESULT hr = DMUS_E_CANNOTREAD;
    DWORD dwID;
    DWORD dwCurTime;
    DWORD dwLength;
    DWORD dwSize;
    short nFormat;
    short nNumTracks;
    short nTracksRead;
     FullSeqEvent* lstEvent;
    DMUS_IO_PATCH_ITEM* lstPatchEvent;
    FullSeqEvent* lstTrackEvent;
    HRESULT hrGM = S_OK;


    EnterCriticalSection(&g_CritSec);
    gpTempoStream = NULL;
    gpSysExStream = NULL;
    gpTimeSigStream = NULL;
    gdwSizeTimeSigStream = 0;
    gdwSizeSysExStream = 0;
    gdwSizeTempoStream = 0;
    glTimeSig = 1; // flag to see if we should be paying attention to time sigs.
    // this is needed because we only care about the time sigs on the first track to
    // contain them that we read
    g_pChordTrack = NULL;

    lstEvent = NULL;
    lstPatchEvent = NULL;
    nNumTracks = nTracksRead = 0;
    dwLength = 0;
    gPos = 0;
    gMidiModeList.CleanUp();
    if (g_pChordTrack)
    {
        g_pChordTrack->Release();
        g_pChordTrack = NULL;
    }
    CreateChordFromKey(0, 0, 0, g_Chord);
    CreateChordFromKey(0, 0, 0, g_DefaultChord);

    memset(&gBankSelect, 0xFF, (sizeof(DMUS_IO_BANKSELECT_ITEM) * NUM_MIDI_CHANNELS));
    memset(&gPatchTable, 0, (sizeof(DWORD) * NUM_MIDI_CHANNELS));
    memset(&gTimeSig, 0, sizeof(DMUS_IO_TIMESIGNATURE_ITEM));
    memset(&gdwLastControllerTime, 0xFF, (sizeof(DWORD) * NUM_MIDI_CHANNELS)); 
    memset(&gdwControlCollisionOffset, 0, (sizeof(DWORD) * NUM_MIDI_CHANNELS)); 
    glLastSysexTime = -5;

    if( ( S_OK != pStream->Read( &dwID, sizeof( FOURCC ), NULL ) ) ||
        !GetMLong( pStream, dwSize ) )
    {
        Trace(1,"Error: Failure parsing MIDI file.\n");
        LeaveCriticalSection(&g_CritSec);
        return DMUS_E_CANNOTREAD;
    }
// check for RIFF MIDI files
    if( dwID == mmioFOURCC( 'R', 'I', 'F', 'F' ) )
    {
        StreamSeek( pStream, 12, STREAM_SEEK_CUR );
        if( ( S_OK != pStream->Read( &dwID, sizeof( FOURCC ), NULL ) ) ||
            !GetMLong( pStream, dwSize ) )
        {
            Trace(1,"Error: Failure parsing MIDI file.\n");
            LeaveCriticalSection(&g_CritSec);
            return DMUS_E_CANNOTREAD;
        }
    }
// check for normal MIDI files
    if( dwID != mmioFOURCC( 'M', 'T', 'h', 'd' ) )
    {
        LeaveCriticalSection(&g_CritSec);
        Trace(1,"Error: Failure parsing MIDI file - can't find a valid header.\n");
        return DMUS_E_CANNOTREAD;
    }

    GetMShort( pStream, nFormat );
    GetMShort( pStream, nNumTracks );
    GetMShort( pStream, snPPQN );
    if( dwSize > 6 )
    {
        StreamSeek( pStream, dwSize - 6, STREAM_SEEK_CUR );
    }
    pStream->Read( &dwID, sizeof( FOURCC ), NULL );
    while( dwID == mmioFOURCC( 'M', 'T', 'r', 'k' ) )
    {
        GetMLong( pStream, dwSize );
        dwCurTime = 0;
        lstTrackEvent = NULL;

        long lSize = (long)dwSize;
        while( lSize > 0 )
        {
            long lReturn;
            lSize -= GetVarLength( pStream, dwID );
            dwCurTime += dwID;
            if (lSize > 0)
            {
                lReturn = ReadEvent( pStream, dwCurTime, &lstTrackEvent, &lstPatchEvent );
                if( lReturn )
                {
                    lSize -= lReturn;
                }
                else
                {
                    Trace(1,"Error: Failure parsing MIDI file.\n");
                    hr = DMUS_E_CANNOTREAD;
                    goto END;
                }
            }
        }
        dwSize = lSize;
        if( glTimeSig > 1 )
        {
            // if glTimeSig is greater than 1, it means we've read some time sigs
            // from this track (it was set to 2 inside ReadEvent.) This means that
            // we no longer want ReadEvent to pay any attention to time sigs, so
            // we set this to 0.
            glTimeSig = 0;
        }
        if( dwCurTime > dwLength )
        {
            dwLength = dwCurTime;
        }
        lstTrackEvent = ScanForDuplicatePBends( lstTrackEvent );
        lstTrackEvent = SortEventList( lstTrackEvent );
        lstTrackEvent = CompressEventList( lstTrackEvent );
        lstEvent = List_Cat( lstEvent, lstTrackEvent );
        if( FAILED( pStream->Read( &dwID, sizeof( FOURCC ), NULL ) ) )
        {
            break;
        }
    }
    dwLength = ConvertTime(dwLength);

    lstEvent = SortEventList( lstEvent );

//    if( lstEvent ) Removed: this might be just a band, or sysex data, or whatever.
    {
        if(pSegment)
        {
            IPersistStream* pIPSTrack;
            IDirectMusicTrack*    pDMTrack;

            hr = S_OK;

            if (!g_pChordTrack)
            {
                hr = CoCreateInstance( 
                        CLSID_DirectMusicChordTrack, NULL, CLSCTX_INPROC,
                        IID_IDirectMusicTrack,
                        (void**)&g_pChordTrack );
                if (SUCCEEDED(hr))
                {
                    g_pChordTrack->SetParam(GUID_ChordParam, 0, &g_DefaultChord);
                }
            }
            if (SUCCEEDED(hr))
            {
                pSegment->InsertTrack( g_pChordTrack, 1 );
                g_pChordTrack->Release();
                g_pChordTrack = NULL;
            }

            // Note: We could be checking to see if there are actually tempo events,
            // sysex events, etc. to see if it's really necessary to create these
            // tracks...
            // Create a Tempo Track in which to store the tempo events
            if( gpTempoStream )
            {
                if( SUCCEEDED( CoCreateInstance( CLSID_DirectMusicTempoTrack,
                    NULL, CLSCTX_INPROC, IID_IPersistStream,
                    (void**)&pIPSTrack )))
                {
                    StreamSeek( gpTempoStream, sizeof(DWORD), STREAM_SEEK_SET );
                    gpTempoStream->Write( &gdwSizeTempoStream, sizeof(DWORD), NULL );
                    StreamSeek( gpTempoStream, 0, STREAM_SEEK_SET );
                    pIPSTrack->Load( gpTempoStream );

                    if( SUCCEEDED( pIPSTrack->QueryInterface( IID_IDirectMusicTrack, 
                        (void**)&pDMTrack ) ) )
                    {
                        pSegment->InsertTrack( pDMTrack, 1 );
                        pDMTrack->Release();
                    }
                    pIPSTrack->Release();
                }
            }

            // Add a patch event for each MIDI channel that does not have one
            DMUS_IO_PATCH_ITEM* pPatchEvent = NULL;
            for(DWORD i = 0; i < 16; i++)
            {
                if(gPatchTable[i] == 0)
                {
                    pPatchEvent = new DMUS_IO_PATCH_ITEM;

                    if(pPatchEvent == NULL)
                    {
                        continue;
                    }
                    
                    memset(pPatchEvent, 0, sizeof(DMUS_IO_PATCH_ITEM));
                    pPatchEvent->lTime = ConvertTime(0);
                    pPatchEvent->byStatus = 0xC0 + (BYTE)(i & 0xf);
                    pPatchEvent->dwFlags |= (DMUS_IO_INST_PATCH);
                    pPatchEvent->pIDMCollection = NULL;
                    pPatchEvent->fNotInFile = TRUE;

                    pPatchEvent->pNext = lstPatchEvent;
                    lstPatchEvent = pPatchEvent;
                }
            }

            if(lstPatchEvent)
            {
                // Create Band Track in which to store patch change events
                IDirectMusicBandTrk* pBandTrack;

                if(SUCCEEDED(CoCreateInstance(CLSID_DirectMusicBandTrack,
                                              NULL, 
                                              CLSCTX_INPROC, 
                                              IID_IDirectMusicBandTrk,
                                              (void**)&pBandTrack)))
                {
                    // Get the loader from stream so we can open a required collections
                    IDirectMusicGetLoader* pIDMGetLoader = NULL;
                    IDirectMusicLoader* pIDMLoader = NULL;
    
                    hr = pStream->QueryInterface(IID_IDirectMusicGetLoader, (void**)&pIDMGetLoader);
                    if( SUCCEEDED(hr) )
                    {
                        hr = pIDMGetLoader->GetLoader(&pIDMLoader);
                        pIDMGetLoader->Release();
                    }
                    // IStream needs a loader attached
                    assert(SUCCEEDED(hr));

                    // Populate the the Band Track with patch change events
                    for(DMUS_IO_PATCH_ITEM* pEvent = lstPatchEvent; pEvent; pEvent = lstPatchEvent)
                    {
                        // Remove instrument from head of list and give to band
                        DMUS_IO_PATCH_ITEM* temp = pEvent->pNext;
                        pEvent->pNext = NULL;
                        lstPatchEvent = temp;

                        // We will try to load the collection but if we can not we will continure
                        // and use the default GM on the card
                        if(pIDMLoader)
                        {
                            HRESULT hrTemp = LoadCollection(&pEvent->pIDMCollection, pIDMLoader);
                            if (FAILED(hrTemp))
                            {
                                hrGM = hrTemp;
                            }
                        }

                        hr = pBandTrack->AddBand(pEvent);

                        // Release reference to collection
                        if(pEvent->pIDMCollection)
                        {
                            (pEvent->pIDMCollection)->Release();
                            pEvent->pIDMCollection = NULL;
                        }
                        delete pEvent;

                        if(FAILED(hr))
                        {
                            break;                        
                        }
                    }

                    if(SUCCEEDED(hr))
                    {
        
                        TListItem<StampedGMGSXG>* pPair = gMidiModeList.GetHead();
                        if( NULL == pPair )
                        {
                            // if we had nothing, generate a GM one so the band knows
                            // it was loaded from a midi file
                            // since the first band is set to play at -1,
                            // this is when the default midi mode must occur.
                            pBandTrack->SetGMGSXGMode(-1, DMUS_MIDIMODEF_GM);
                        }
                        for ( ; pPair; pPair = pPair->GetNext() )
                        {
                            StampedGMGSXG& rPair = pPair->GetItemValue();
                            pBandTrack->SetGMGSXGMode(rPair.mtTime, rPair.dwMidiMode);
                        }
                        gMidiModeList.CleanUp();

                        if(SUCCEEDED(pBandTrack->QueryInterface(IID_IDirectMusicTrack, 
                                                                (void**)&pDMTrack)))
                        {
                            pSegment->InsertTrack(pDMTrack, 1);
                            pDMTrack->Release();
                        }
                    }
                    
                    if(pBandTrack)
                    {
                        pBandTrack->Release();
                    }

                    if(pIDMLoader)
                    {
                        pIDMLoader->Release();
                    }
                }

            }

            if( gpTimeSigStream )
            {
                // Create a TimeSig Track to store the TimeSig events
                if( SUCCEEDED( CoCreateInstance( CLSID_DirectMusicTimeSigTrack,
                    NULL, CLSCTX_INPROC, IID_IPersistStream,
                    (void**)&pIPSTrack )))
                {
                    // set the overall size to the correct size
                    StreamSeek( gpTimeSigStream, sizeof(DWORD), STREAM_SEEK_SET );
                    gpTimeSigStream->Write( &gdwSizeTimeSigStream, sizeof(DWORD), NULL );
                    // reset to beginning and persist to track.
                    StreamSeek( gpTimeSigStream, 0, STREAM_SEEK_SET );
                    pIPSTrack->Load( gpTimeSigStream );

                    if( SUCCEEDED( pIPSTrack->QueryInterface( IID_IDirectMusicTrack, 
                        (void**)&pDMTrack ) ) )
                    {
                        pSegment->InsertTrack( pDMTrack, 1 );
                        AddOffsets(lstEvent, pDMTrack);
                        pDMTrack->Release();
                    }
                    pIPSTrack->Release();
                }
            }
            else
            {
                AddOffsets(lstEvent, NULL);
            }

            lstEvent = SortEventList( lstEvent );

            // Create a Sequence Track in which to store the notes, curves,
            // and SysEx events.
            //
            if( SUCCEEDED( CoCreateInstance( CLSID_DirectMusicSeqTrack,
                NULL, CLSCTX_INPROC, IID_IPersistStream,
                (void**)&pIPSTrack )))
            {
                // Create a stream in which to place the events so we can
                // give it to the SeqTrack.Load.
                IStream* pEventStream;

                if( S_OK == CreateStreamOnHGlobal( NULL, TRUE, &pEventStream ) )
                {
                    // angusg: The implementation of memory IStream interface on
                    // CE can be inefficient if the stream memory isn't allocated
                    // before. It will call LocalRealloc on every IStream->Write
                    // for the amount that is written (in this case a small amount)
                    // this is incredible inefficient here as Realloc can be called
                    // thousands of times....
                    // The solution is to pre calculate the size of the stream and
                    // call ISteam->SetSize(), which calls LocalAlloc, to alloc the
                    // memory in one call.

                    // calculate the size of the stream storage
                    DWORD   dwStreamStorageSize;
                    FullSeqEvent* pEvent;

                    // add the size of the chunk id's written below
                    dwStreamStorageSize = 5 * sizeof(DWORD);
                    // now count how many events need to be stored in the stream
                    for( pEvent = lstEvent; pEvent; pEvent = pEvent->pNext )
                    {
                        dwStreamStorageSize += sizeof(DMUS_IO_SEQ_ITEM);
                    }

                    ULARGE_INTEGER liSize;

                    liSize.QuadPart = dwStreamStorageSize;
                    // make the stream allocate the complete amount of memory
                    pEventStream->SetSize(liSize);

                    // Save the events into the stream
                    ULONG    cb, cbWritten;

                    // Save the chunk id
                    DWORD dwTemp = DMUS_FOURCC_SEQ_TRACK;
                    pEventStream->Write( &dwTemp, sizeof(DWORD), NULL );
                    // Save the overall size. Count the number of events to determine.
                    dwSize = 0;
                    for( pEvent = lstEvent; pEvent; pEvent = pEvent->pNext )
                    {
                        dwSize++;
                    }
                    dwSize *= sizeof(DMUS_IO_SEQ_ITEM);
                    // add 8 for the subchunk
                    dwSize += 8;
                    pEventStream->Write( &dwSize, sizeof(DWORD), NULL );
                    // Save the subchunk id
                    dwTemp = DMUS_FOURCC_SEQ_LIST;
                    pEventStream->Write( &dwTemp, sizeof(DWORD), NULL );
                    // Subtract the previously added 8
                    dwSize -= 8;
                    // Save the size of the subchunk
                    pEventStream->Write( &dwSize, sizeof(DWORD), NULL );
                    // Save the structure size.
                    dwTemp = sizeof(DMUS_IO_SEQ_ITEM);
                    pEventStream->Write( &dwTemp, sizeof(DWORD), NULL );
                    // Save the events.
                    cb = sizeof(DMUS_IO_SEQ_ITEM); // doesn't have the next pointers
                    for( pEvent = lstEvent; pEvent; pEvent = pEvent->pNext )
                    {
                        if( dwLength < (DWORD)(pEvent->mtTime + pEvent->mtDuration) )
                        {
                            dwLength = pEvent->mtTime + pEvent->mtDuration;
                        }
                        pEventStream->Write( pEvent, cb, &cbWritten );
                        if( cb != cbWritten ) // error!
                        {
                            pEventStream->Release();
                            pEventStream = NULL;
                            hr = DMUS_E_CANNOTREAD;
                            break;
                        }
                    }

                    if( pEventStream ) // may be NULL
                    {
                        StreamSeek( pEventStream, 0, STREAM_SEEK_SET );
                        pIPSTrack->Load( pEventStream );
                        pEventStream->Release();
                    }
                }

                if( SUCCEEDED( pIPSTrack->QueryInterface( IID_IDirectMusicTrack, 
                    (void**)&pDMTrack ) ) )
                {
                    pSegment->InsertTrack( pDMTrack, 1 );
                    pDMTrack->Release();
                }
                pIPSTrack->Release();
            }
            // set the length of the segment. Set it to the measure boundary
            // past the last note.
            DWORD dwResolvedLength = gTimeSig.lTime;
            if( 0 == gTimeSig.bBeat ) gTimeSig.bBeat = 4;
            if( 0 == gTimeSig.bBeatsPerMeasure ) gTimeSig.bBeatsPerMeasure = 4;
            if( 0 == gTimeSig.wGridsPerBeat ) gTimeSig.wGridsPerBeat = 4;
            while( dwResolvedLength < dwLength )
            {
                dwResolvedLength += (((DMUS_PPQ * 4) / gTimeSig.bBeat) * gTimeSig.bBeatsPerMeasure);
            }
            pSegment->SetLength( dwResolvedLength );

            if( gpSysExStream )
            {
                // Create a SysEx Track in which to store the SysEx events
                if( SUCCEEDED( CoCreateInstance( CLSID_DirectMusicSysExTrack,
                    NULL, CLSCTX_INPROC, IID_IPersistStream,
                    (void**)&pIPSTrack )))
                {
                    // write overall length
                    StreamSeek( gpSysExStream, sizeof(DWORD), STREAM_SEEK_SET );
                    gpSysExStream->Write( &gdwSizeSysExStream, sizeof(DWORD), NULL );
                    // seek to beginning and persist to track
                    StreamSeek( gpSysExStream, 0, STREAM_SEEK_SET );
                    pIPSTrack->Load( gpSysExStream );

                    if( SUCCEEDED( pIPSTrack->QueryInterface( IID_IDirectMusicTrack, 
                        (void**)&pDMTrack ) ) )
                    {
                        pSegment->InsertTrack( pDMTrack, 1 );
                        pDMTrack->Release();
                    }
                    pIPSTrack->Release();
                }
            }

        }
        else
        {
            hr = E_POINTER;
        }
    }
END:
    List_Free( lstEvent );
    List_Free( lstPatchEvent );

    FullSeqEvent::CleanUp();

    // release our hold on the streams
    RELEASE( gpTempoStream );
    RELEASE( gpSysExStream );
    RELEASE( gpTimeSigStream );
    gpTempoStream = NULL;
    gpSysExStream = NULL;
    gpTimeSigStream = NULL;
    gdwSizeTimeSigStream = 0;
    gdwSizeSysExStream = 0;
    gdwSizeTempoStream = 0;
    LeaveCriticalSection(&g_CritSec);

    if (SUCCEEDED(hrGM) || hr != S_OK )
    {
        return hr;
    }
    else
    {
        return DMUS_S_PARTIALLOAD;
    }
}

// Creates and returns (in rChord) a DMUS_CHORD_PARAM given the three input params.
// the new chord will have one subchord containing the root, third, fifth, and seventh
// of the key (as indicated by the sharps/flats and mode).  Scale will be either
// major or minor, depending on the mode (mode is 0 if major, 1 if minor).
void CreateChordFromKey(char cSharpsFlats, BYTE bMode, DWORD dwTime, DMUS_CHORD_PARAM& rChord)
{
    static DWORD dwMajorScale = 0xab5ab5;    // 1010 1011 0101 1010 1011 0101
    static DWORD dwMinorScale = 0x5ad5ad;    // 0101 1010 1101 0101 1010 1101
    static DWORD dwMajor7Chord = 0x891;        // 1000 1001 0001
    static DWORD dwMinor7Chord = 0x489;        // 0100 1000 1001
    BYTE bScaleRoot = 0;
    switch (cSharpsFlats)
    {
    case  0: bScaleRoot = bMode ?  9 :  0; break;
    case  1: bScaleRoot = bMode ?  4 :  7; break;
    case  2: bScaleRoot = bMode ? 11 :  2; break;
    case  3: bScaleRoot = bMode ?  6 :  9; break;
    case  4: bScaleRoot = bMode ?  1 :  4; break;
    case  5: bScaleRoot = bMode ?  8 : 11; break;
    case  6: bScaleRoot = bMode ?  3 :  6; break;
    case  7: bScaleRoot = bMode ? 10 :  1; break;
    case -1: bScaleRoot = bMode ?  2 :  5; break;
    case -2: bScaleRoot = bMode ?  7 : 10; break;
    case -3: bScaleRoot = bMode ?  0 :  3; break;
    case -4: bScaleRoot = bMode ?  5 :  8; break;
    case -5: bScaleRoot = bMode ? 10 :  1; break;
    case -6: bScaleRoot = bMode ?  3 :  6; break;
    case -7: bScaleRoot = bMode ?  8 : 11; break;
    }
    if (bMode)
    {
        wcscpy(rChord.wszName, L"m7");
    }
    else
    {
        wcscpy(rChord.wszName, L"M7");
    }
    DMUS_IO_TIMESIGNATURE_ITEM timesig;
    timesig.bBeat = gTimeSig.bBeat ? gTimeSig.bBeat : 4;
    timesig.bBeatsPerMeasure = gTimeSig.bBeatsPerMeasure ? gTimeSig.bBeatsPerMeasure : 4;
    timesig.wGridsPerBeat = gTimeSig.wGridsPerBeat ? gTimeSig.wGridsPerBeat : 4;
    DWORD dwAbsBeat = dwTime / ((DMUS_PPQ * 4) / timesig.bBeat);
    rChord.wMeasure = (WORD)(dwAbsBeat / timesig.bBeatsPerMeasure);
    rChord.bBeat = (BYTE)(dwAbsBeat % timesig.bBeatsPerMeasure);
    rChord.bSubChordCount = 1;
    rChord.SubChordList[0].dwChordPattern = bMode ? dwMinor7Chord : dwMajor7Chord;
    rChord.SubChordList[0].dwScalePattern = bMode ? dwMinorScale : dwMajorScale;
    rChord.SubChordList[0].dwInversionPoints = 0xffffff;    // inversions allowed everywhere
    rChord.SubChordList[0].dwLevels = 0xffffffff;            // supports all levels
    rChord.SubChordList[0].bChordRoot = bScaleRoot;
    rChord.SubChordList[0].bScaleRoot = bScaleRoot;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\oledll.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
//
//
//
#ifndef _OLEDLL_
#define _OLEDLL_

STDAPI
RegisterServer(HMODULE hModule,
               const CLSID &clsid,
               const TCHAR *szFriendlyName,
               const TCHAR *szVerIndProgID,
               const TCHAR *szProgID);

STDAPI
UnregisterServer(const CLSID &clsid,
                 const TCHAR *szFriendlyName,
                 const TCHAR *szVerIndProgID,
                 const TCHAR *szProgID);

BOOL
GetCLSIDRegValue(const CLSID &clsid,
				 const TCHAR *szKey,
				 LPVOID pValue,
				 LPDWORD pcbValue);
				 
HRESULT CLSIDToStr(const CLSID &clsid,
				   TCHAR *szStr,
				   int cbStr);

HRESULT StrToCLSID(TCHAR *szStr,
				   CLSID &clsid,
				   int cbStr);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\opnew.cpp ===
// Copyright (c) 1999 Microsoft Corporation
// OpNew.cpp
//
// Override operator new[] so that we ignore the new_handler mechanism.
//
//
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

#include "Debug.h"

LPVOID __cdecl operator new(size_t cbBuffer)
{
    LPVOID p;

    p = malloc(cbBuffer ? cbBuffer : 1);
    return p;
}

void __cdecl operator delete(LPVOID p)
{
    free(p);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\mutx.cpp ===
// Copyright (c) 1998 Microsoft Corporation
/* No longer used */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\ntfylist.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
//////////////////////////////////////////////////////////////////////
// NtfyList.h

#include "alist.h"
#include "dmusici.h"
#include "debug.h"

#ifndef __NTFYLIST_H_
#define __NTFYLIST_H_

class CNotificationItem : public AListItem
{
public:
	CNotificationItem* GetNext()
	{
		return (CNotificationItem*)AListItem::GetNext();
	};
public:
	GUID	guidNotificationType;
    BOOL    fFromPerformance;
};

class CNotificationList : public AList
{
public:
    CNotificationItem* GetHead() 
	{
		return (CNotificationItem*)AList::GetHead();
	};
    CNotificationItem* RemoveHead() 
	{
		return (CNotificationItem*)AList::RemoveHead();
	};
    CNotificationItem* GetItem(LONG lIndex) 
	{
		return (CNotificationItem*) AList::GetItem(lIndex);
	};
	void Clear(void)
	{
		CNotificationItem* pTrack;
		while( pTrack = RemoveHead() )
		{
			delete pTrack;
		}
	}
};

#endif // __NTFYLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\mutx.h ===
// Copyright (c) 1998 Microsoft Corporation
/* No longer used */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\oledll.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
// oledll.cpp
//
// Handle standard stuff for OLE server DLL
//
#include <objbase.h>
#include "debug.h"
#include <iostream.h>

#include "oledll.h"

#ifdef UNICODE
#ifndef UNDER_CE
#error DirectMusic Win NT/9x must be compiled without UNICODE
#endif
#endif

static const TCHAR g_szCLSID[]           = TEXT("CLSID");
static const TCHAR g_szCLSIDSlash[]      = TEXT("CLSID\\");
static const TCHAR g_szInProc32[]        = TEXT("InProcServer32");
static const TCHAR g_szProgIDKey[]       = TEXT("ProgID");
static const TCHAR g_szVerIndProgIDKey[] = TEXT("VersionIndependentProgID");
static const TCHAR g_szCurVer[]          = TEXT("CurVer"); 
static const TCHAR g_szThreadingModel[]	= TEXT("ThreadingModel");
static const TCHAR g_szBoth[]		    = TEXT("Both");

static const int CLSID_STRING_SIZE = 39;

static LONG RegSetDefValue(LPCTSTR pstrKey, LPCTSTR pstrSubkey, LPCTSTR pstrValueName, LPCTSTR pstrValue);
static void RegRemoveSubtree(HKEY hk, LPCTSTR pstrChild);

STDAPI
RegisterServer(HMODULE hModule,
               const CLSID &clsid,
               const TCHAR *szFriendlyName,
               const TCHAR *szVerIndProgID,
               const TCHAR *szProgID)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;
    LONG lr;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return hr;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);

    TCHAR szModule[512];
    lr = ::GetModuleFileName(hModule, szModule, sizeof(szModule));
    assert(lr);

    lr = 0;

    lr |= RegSetDefValue(szClsKey, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szClsKey, g_szInProc32, NULL, szModule);
	lr |= RegSetDefValue(szClsKey, g_szInProc32, g_szThreadingModel, g_szBoth);
    lr |= RegSetDefValue(szClsKey, g_szProgIDKey, NULL, szProgID);
    lr |= RegSetDefValue(szClsKey, g_szVerIndProgIDKey, NULL, szVerIndProgID);

    lr |= RegSetDefValue(szVerIndProgID, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szVerIndProgID, g_szCLSID, NULL, szCLSID);
    lr |= RegSetDefValue(szVerIndProgID, g_szCurVer, NULL, szProgID);
    
	lr |= RegSetDefValue(szProgID, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szProgID, g_szCLSID, NULL, szCLSID);

#if 0 
    if (lr) {
        UnregisterServer(clsid,
                         szFriendlyName,
                         szVerIndProgID,
                         szProgID);
        // ???
        //
        return S_OK;
    }
#endif

    return S_OK;
}

STDAPI
UnregisterServer(const CLSID &clsid,
                 const TCHAR *szFriendlyName,
                 const TCHAR *szVerIndProgID,
                 const TCHAR *szProgID)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return hr;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);

    RegRemoveSubtree(HKEY_CLASSES_ROOT, szClsKey);
    RegRemoveSubtree(HKEY_CLASSES_ROOT, szVerIndProgID);
    RegRemoveSubtree(HKEY_CLASSES_ROOT, szProgID);

    return S_OK;
}

BOOL
GetCLSIDRegValue(const CLSID &clsid,
				 const TCHAR *szKey,
				 LPVOID pValue,
				 LPDWORD pcbValue)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;
    HKEY hk;
	DWORD dw;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return FALSE;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);
	lstrcat(szClsKey, TEXT("\\"));
    if (szKey)
    {
	    lstrcat(szClsKey, szKey);
    }

	if (RegOpenKeyEx(HKEY_CLASSES_ROOT,
					 szClsKey,
					 0,
					 KEY_READ,
					 &hk)) {
		return FALSE;
	}

	if (RegQueryValueEx(hk,
						NULL,
						NULL,
						&dw,
						(LPBYTE)pValue,
						pcbValue)) {
		RegCloseKey(hk);
		return FALSE;
	}

	RegCloseKey(hk);
	
	return TRUE;
}

HRESULT
CLSIDToStr(const CLSID &clsid,
           TCHAR *szStr,
           int cbStr)
{
    // XXX What to return here?
    //
    assert(cbStr >= CLSID_STRING_SIZE);
    
	LPOLESTR wszCLSID = NULL;
	HRESULT hr = StringFromCLSID(clsid, &wszCLSID);
    if (!SUCCEEDED(hr)) {
        return hr;
    }

#ifdef UNICODE
    lstrcpy(szStr, wszCLSID);
#else
	// Covert from wide characters to non-wide.
	wcstombs(szStr, wszCLSID, cbStr);
#endif

	// Free memory.
    CoTaskMemFree(wszCLSID);

    return S_OK;
}

HRESULT
StrToCLSID(TCHAR *szStr,
		   CLSID &clsid,
		   int cbStr)
{
#ifdef UNICODE
    return CLSIDFromString(szStr, &clsid);
#else    
	WCHAR wsz[512];
    if (cbStr > 512)
    {
        cbStr = 512;
    }

	mbstowcs(wsz, szStr, cbStr);

	return CLSIDFromString(wsz, &clsid);
#endif
}
   

static LONG
RegSetDefValue(LPCTSTR pstrKey,
               LPCTSTR pstrSubkey,
			   LPCTSTR pstrValueName,
               LPCTSTR pstrValue)
{
    HKEY hk;
    LONG lr;
    TCHAR sz[1024];
    LPCTSTR pstr;

    if (!pstrSubkey) {
        pstr = pstrKey;
    } else {
        lstrcpy(sz, pstrKey);
        lstrcat(sz, TEXT("\\"));
        lstrcat(sz, pstrSubkey);
        pstr = sz;
    }

    lr = RegCreateKeyEx(HKEY_CLASSES_ROOT,
                        pstr,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hk,
                        NULL);
    if (lr) {
        return lr;
    }

    lr = RegSetValueEx(hk,
                       pstrValueName,
                       0,
                       REG_SZ,
                       (CONST BYTE*)pstrValue,
                       1+lstrlen(pstrValue));
    RegCloseKey(hk);

    return lr;
}

static void
RegRemoveSubtree(HKEY hk,
                 LPCTSTR pstrChild)
{
    LONG lResult;
    HKEY hkChild;

    lResult = RegOpenKeyEx(hk,
                           pstrChild,
                           0,
                           KEY_ALL_ACCESS,
                           &hkChild);
    if (lResult) {
        return;
    }

#ifndef UNDER_CE    // CE doesn't support RegEnumKey()
    TCHAR szSubkey[256];

    // NOTE: Unlike regular enumeration, we always grab the 0th item
    // and delete it.
    //
    while (!RegEnumKey(hkChild, 0, szSubkey, sizeof(szSubkey))) {
        RegRemoveSubtree(hkChild, szSubkey);
    }
#endif    

    RegCloseKey(hkChild);
    RegDeleteKey(hk, pstrChild);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\paramtrk.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of CParamControlTrack.
//

#include "dmime.h"
#include "ParamTrk.h"
#include "Validate.h"
#include "miscutil.h"
#include "limits.h"
#include "math.h"


STDMETHODIMP 
CParamControlTrack::QueryInterface(const IID &iid, void **ppv)
{
	V_INAME(CParamControlTrack::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

	if (iid == IID_IUnknown || iid == IID_IDirectMusicTrack || iid == IID_IDirectMusicTrack8)
		*ppv = static_cast<IDirectMusicTrack8*>(this);
	else if (iid == IID_IPersistStream)
		*ppv = static_cast<IPersistStream*>(this);
	else if (iid == IID_IPersist)
		*ppv = static_cast<IPersist*>(this);
    else if (iid == IID_CParamControlTrack)
    {
        *ppv = static_cast<CParamControlTrack*>(this);
    }
	else
	{
		*ppv = NULL;
        Trace(4,"Warning: Request to query unknown interface on Track\n");
		return E_NOINTERFACE;
	}
	
	reinterpret_cast<IUnknown*>(this)->AddRef();
	return S_OK;
}

STDMETHODIMP
CParamControlTrack::Init(IDirectMusicSegment *pSegment)
{
    V_INAME(CBasicTrack::Init);
    V_INTERFACE(pSegment);

    return S_OK;
}

STDMETHODIMP
CParamControlTrack::Load(IStream* pIStream)
{
    V_INAME(CPlayingTrack::Load);
    V_INTERFACE(pIStream);
    HRESULT hr = S_OK;

    SmartRef::CritSec CS(&m_CriticalSection);

    // Increment counter so the next play will update state data with the new list.
    ++m_dwValidate;
    // Clear the objects/params/curves in case we're being reloaded.
    m_listObjects.CleanUp();
    m_cObjects = 0;
    m_cParams = 0;

    SmartRef::RiffIter ri(pIStream);
    if (!ri)
        return ri.hr();

    // find <prmt>
    hr = ri.FindRequired(SmartRef::RiffIter::List, DMUS_FOURCC_PARAMCONTROLTRACK_TRACK_LIST, DMUS_E_INVALID_PARAMCONTROLTRACK);
    if (FAILED(hr))
    {
#ifdef DBG
        if (hr == DMUS_E_INVALID_PARAMCONTROLTRACK)
        {
            Trace(1, "Error: Unable to load parameter control track: List 'prmt' not found.\n");
        }
#endif
        return hr;
    }
    SmartRef::RiffIter riTrack = ri.Descend();

    // for each <prol>
    while (riTrack && riTrack.Find(SmartRef::RiffIter::List, DMUS_FOURCC_PARAMCONTROLTRACK_OBJECT_LIST))
    {
        hr = this->LoadObject(riTrack.Descend());
        if (FAILED(hr))
            return hr;
        ++riTrack;
    }
    hr = riTrack.hr();

    return hr;
}

STDMETHODIMP
CParamControlTrack::InitPlay(
    IDirectMusicSegmentState *pSegmentState,
    IDirectMusicPerformance *pPerformance,
    void **ppStateData,
    DWORD dwTrackID,
    DWORD dwFlags)
{
    V_INAME(CParamControlTrack::InitPlay);
    V_PTRPTR_WRITE(ppStateData);
    V_INTERFACE(pSegmentState);
    V_INTERFACE(pPerformance);

    SmartRef::CritSec CS(&m_CriticalSection);

    // Set up state data
    StateData *pStateData = new StateData;
    if (!pStateData)
        return E_OUTOFMEMORY;

    HRESULT hr = InitStateData(pStateData, pSegmentState);
    if (FAILED(hr))
    {
        delete pStateData;
    }
    else
    {
        pStateData->dwValidate = m_dwValidate;
        *ppStateData = pStateData;
    }

    return hr;
}

STDMETHODIMP
CParamControlTrack::EndPlay(void *pStateData)
{
    V_INAME(CParamControlTrack::EndPlay);
    V_BUFPTR_WRITE(pStateData, sizeof(StateData));

    SmartRef::CritSec CS(&m_CriticalSection);

    StateData *pSD = static_cast<StateData *>(pStateData);

    if (!pSD->fFlushInAbort)
    {
        // For each object, flush all curves on each parameter up to the start time of the last one we sent.
        //    (This allows the DMO being controlled to free up memory associated with any previous curves
        //     while still keeping the last one around so that the next thing played picks up that parameter
        //     value how it was left.)
        // Then release the object's params interface.
        int iObj = 0;
        for (TListItem<ObjectInfo> *pObject = m_listObjects.GetHead();
                pObject && iObj < m_cObjects;
                pObject = pObject->GetNext(), ++iObj)
        {
            IMediaParams *pIMediaParams = pSD->prgpIMediaParams[iObj];
            if (pIMediaParams)
            {
                ObjectInfo &obj = pObject->GetItemValue();
                int iParam = 0;
                for (TListItem<ParamInfo> *pParam = obj.listParams.GetHead();
                        pParam && iParam < m_cParams;
                        pParam = pParam->GetNext(), ++iParam)
                {
                    ParamInfo &param = pParam->GetItemValue();
                    ParamState &paramstate = pSD->prgParam[iParam];
                    if (paramstate.fLast)
                    {
                        HRESULT hrFlush = pIMediaParams->FlushEnvelope(param.header.dwIndex, _I64_MIN, paramstate.rtStartPointOfLastCurve);
                        if (FAILED(hrFlush))
                        {
                            assert(false);
                            TraceI(1, "Unable to flush envelope information from an audio path object in parameter control track, HRESULT 0x%08x.\n", hrFlush);
                        }
                    }
                }
            }
            SafeRelease(pIMediaParams);
        }
    }
    delete[] pSD->prgpIMediaParams;
    delete[] pSD->prgParam;
    delete pSD;

    return S_OK;
}

HRESULT CParamControlTrack::OnSegmentEnd(REFERENCE_TIME rtEnd, void *pStateData)
{
    SmartRef::CritSec CS(&m_CriticalSection);

    StateData *pSD = static_cast<StateData *>(pStateData);

    // For each object, flush all curves on each parameter up to the start time of the last one we sent
    // (if that started before segment end) or flush everything up to the last one to start before
    // segment end, and flush everything after segment end (if the start time was after segment end).
    //    (This allows the DMO being controlled to free up memory associated with any previous curves
    //     while still keeping the last one around so that the next thing played picks up that parameter
    //     value how it was left.)
    // Then release the object's params interface.
    int iObj = 0;
    for (TListItem<ObjectInfo> *pObject = m_listObjects.GetHead();
            pObject && iObj < m_cObjects;
            pObject = pObject->GetNext(), ++iObj)
    {
        IMediaParams *pIMediaParams = pSD->prgpIMediaParams[iObj];
        if (pIMediaParams)
        {
            ObjectInfo &obj = pObject->GetItemValue();
            int iParam = 0;
            for (TListItem<ParamInfo> *pParam = obj.listParams.GetHead();
                    pParam && iParam < m_cParams;
                    pParam = pParam->GetNext(), ++iParam)
            {
                ParamInfo &param = pParam->GetItemValue();
                ParamState &paramstate = pSD->prgParam[iParam];
                if (paramstate.fLast)
                {
                    HRESULT hrFlush = S_OK;
                    if (paramstate.rtStartPointOfLastCurve < rtEnd)
                    {
                        hrFlush = pIMediaParams->FlushEnvelope(param.header.dwIndex, _I64_MIN, paramstate.rtStartPointOfLastCurve);
                    }
                    else
                    {
                        // first, look for the largest start time less than rtEnd and
                        // flush up to there.  The loop assumes the list is ordered largest to smallest.
                        TListItem<REFERENCE_TIME>* pStartTime = paramstate.listStartTimes.GetHead();
                        for (; pStartTime; pStartTime = pStartTime->GetNext())
                        {
                            if (pStartTime->GetItemValue() < rtEnd)
                            {
                                hrFlush = pIMediaParams->FlushEnvelope(param.header.dwIndex, _I64_MIN, pStartTime->GetItemValue());
                                break;
                            }
                        }
                        // Then, flush from rtEnd on.
                        if (SUCCEEDED(hrFlush))
                        {
                            hrFlush = pIMediaParams->FlushEnvelope(param.header.dwIndex, rtEnd, _I64_MAX);
                        }
                    }
                    if (FAILED(hrFlush))
                    {
                        assert(false);
                        TraceI(1, "Unable to flush envelope information from an audio path object in parameter control track, HRESULT 0x%08x.\n", hrFlush);
                    }
                }
            }
        }
        SafeRelease(pIMediaParams);
        pSD->prgpIMediaParams[iObj] = NULL;
    }

    pSD->fFlushInAbort = true;

    return S_OK;
}

STDMETHODIMP
CParamControlTrack::Clone(MUSIC_TIME mtStart, MUSIC_TIME mtEnd, IDirectMusicTrack** ppTrack)
{
    //  Test more thoroughly when we have multiple working params/objects.

    V_INAME(CParamControlTrack::Clone);
    V_PTRPTR_WRITE(ppTrack);

    SmartRef::CritSec CS(&m_CriticalSection);

    HRESULT hr = S_OK;

    SmartRef::ComPtr<CParamControlTrack> scomTrack = new CParamControlTrack(&hr);
    if (FAILED(hr))
        return hr;
    if (!scomTrack)
        return E_OUTOFMEMORY;
    scomTrack->AddRef();

    // Copy each object
    for (TListItem<ObjectInfo> *pObject = m_listObjects.GetHead();
            pObject;
            pObject = pObject->GetNext())
    {
        ObjectInfo &obj = pObject->GetItemValue();
        TListItem<ObjectInfo> *pNewObject = new TListItem<ObjectInfo>;
        if (!pNewObject)
            return E_OUTOFMEMORY;
        ObjectInfo &newobj = pNewObject->GetItemValue();
        newobj.header = obj.header;

        // Copy each parameter
        for (TListItem<ParamInfo> *pParam = obj.listParams.GetHead();
                pParam;
                pParam = pParam->GetNext())
        {
            ParamInfo &param = pParam->GetItemValue();
            TListItem<ParamInfo> *pNewParam = new TListItem<ParamInfo>;
            if (!pNewParam)
                return E_OUTOFMEMORY;
            ParamInfo &newparam = pNewParam->GetItemValue();
            newparam.header = param.header;

            // Copy the curves from mtStart to mtEnd
            // These should include curves that overlap the start and end, though this
            // leave some issues we still need to work out (what happens with overlapping curves?)
            // So, first find the first curve whose end time is at or after mtStart...
            for (DMUS_IO_PARAMCONTROLTRACK_CURVEINFO *pCurveStart = param.curves;
                    (pCurveStart < param.curvesEnd) && (pCurveStart->mtEndTime < mtStart);
                    ++pCurveStart)
            {}
            // Then, find the curve whose start time is after mtEnd.
            for (DMUS_IO_PARAMCONTROLTRACK_CURVEINFO *pCurveEnd = pCurveStart;
                    (pCurveEnd < param.curvesEnd) && (pCurveEnd->mtStartTime < mtEnd);
                    ++pCurveEnd)
            {}
            int cCurves = (int)(pCurveEnd - pCurveStart);
            newparam.curves = new DMUS_IO_PARAMCONTROLTRACK_CURVEINFO[cCurves];
            if (!newparam.curves)
                return E_OUTOFMEMORY;
            memcpy(newparam.curves, pCurveStart, cCurves * sizeof(DMUS_IO_PARAMCONTROLTRACK_CURVEINFO));
            newparam.curvesEnd = newparam.curves + cCurves;
            // Now, scan through the new curve array and adjust the times by subtracting mtStart from everything.
            for (pCurveStart = newparam.curves; pCurveStart < newparam.curvesEnd; pCurveStart++)
            {
                pCurveStart->mtStartTime -= mtStart;
                pCurveStart->mtEndTime -= mtStart;
            }

            newobj.listParams.AddHead(pNewParam);
        }

        newobj.listParams.Reverse(); // Technically, the order shouldn't matter.  But this ensures that the cloned track will send curves to different parameters in the exact same order just in case.
        scomTrack->m_listObjects.AddHead(pNewObject);
    }
    scomTrack->m_listObjects.Reverse(); // Technically, the order shouldn't matter.  But this ensures that the cloned track will send curves to different objects in the exact same order just in case.
    ++scomTrack->m_dwValidate;

    scomTrack->m_cObjects = m_cObjects;
    scomTrack->m_cParams = m_cParams;

    *ppTrack = scomTrack.disown();
    return hr;
}

HRESULT
CParamControlTrack::PlayMusicOrClock(
    void *pStateData,
    MUSIC_TIME mtStart,
    MUSIC_TIME mtEnd,
    MUSIC_TIME mtOffset,
    REFERENCE_TIME rtOffset,
    DWORD dwFlags,
    IDirectMusicPerformance* pPerf,
    IDirectMusicSegmentState* pSegSt,
    DWORD dwVirtualID,
    bool fClockTime)
{
    V_INAME(CParamControlTrack::Play);
    V_BUFPTR_WRITE( pStateData, sizeof(StateData));
    V_INTERFACE(pPerf);
    V_INTERFACE(pSegSt);

    if (dwFlags & DMUS_TRACKF_PLAY_OFF)
        return S_OK;

    SmartRef::CritSec CS(&m_CriticalSection);

    StateData *pSD = static_cast<StateData *>(pStateData);

    if (m_dwValidate != pSD->dwValidate)
    {
        HRESULT hr = InitStateData(pSD, pSegSt);
        if (FAILED(hr))
        {
            return hr;
        }
    }

    // envelope structure we'll fill for sending each envelope segment.
    MP_ENVELOPE_SEGMENT envCurve;
    Zero(&envCurve);
    MP_ENVELOPE_SEGMENT *const penvCurve = &envCurve;

    bool fMoreCurves = false; // set to true by any parameter that has more curves to play

    // for each parameter...
    int iParam = 0;
    int iObject = 0;
    for (TListItem<ObjectInfo> *pObject = m_listObjects.GetHead();
            pObject && iObject < m_cObjects;
            pObject = pObject->GetNext(), ++iObject)
    {
        ObjectInfo &obj = pObject->GetItemValue();
        IMediaParams *pIMediaParams = pSD->prgpIMediaParams[iObject];

        bool fObjClockTime = !!(obj.header.guidTimeFormat == GUID_TIME_REFERENCE);
        if (!fObjClockTime && obj.header.guidTimeFormat != GUID_TIME_MUSIC)
        {
            // track can only handle music and clock time
            assert(false);
            // Only log this once at warning level one.  Rest go to warning level three to avoid tons of identical trace messages during playback).
            TraceI(
                obj.fAlreadyTracedPlaybackError ? 3 : 1,
                "Parameter control track unable to control object -- unknown time format (must be GUID_TIME_MUSIC or GUID_TIME_REFERENCE).\n");
            obj.fAlreadyTracedPlaybackError = true;
            continue;
        }

        for (TListItem<ParamInfo> *pParam = obj.listParams.GetHead();
                pParam && iParam < m_cParams;
                pParam = pParam->GetNext(), ++iParam)
        {
            ParamInfo &param = pParam->GetItemValue();
            ParamState &paramstate = pSD->prgParam[iParam];

            DMUS_IO_PARAMCONTROLTRACK_CURVEINFO *&pCurrentCurve = paramstate.pCurrentCurve;

            // We're going to seek through the event list to find the proper next control curve for each parameter if
            // the track's data has been reloaded or if playback has made a jump to a different position in the track.
            if (m_dwValidate != pSD->dwValidate || dwFlags & (DMUS_TRACKF_SEEK | DMUS_TRACKF_LOOP | DMUS_TRACKF_FLUSH | DMUS_TRACKF_START))
            {
                assert(m_dwValidate != pSD->dwValidate || dwFlags & DMUS_TRACKF_SEEK); // by contract SEEK should be set whenever the other dwFlags are

                // find first curve that begins at or after the start time we're currently playing
                for (pCurrentCurve = param.curves; pCurrentCurve < param.curvesEnd && pCurrentCurve->mtStartTime < mtStart; ++pCurrentCurve)
                {}

                if (pIMediaParams && pCurrentCurve > param.curves)
                {
                    // check the previous curve to see if we ended up in the middle of it
                    DMUS_IO_PARAMCONTROLTRACK_CURVEINFO *pPrevCurve = pCurrentCurve - 1;
                    // Send a curve chopped off at the start time we're currently playing.
                    // We can't send the whole curve because it would take effect too early.
                    HRESULT hrEnv = this->PlayTruncatedEnvelope(mtStart, pIMediaParams, penvCurve, pPrevCurve, obj, param, paramstate, mtOffset, rtOffset, pPerf, fClockTime, fObjClockTime, dwFlags);
                    if (FAILED(hrEnv))
                    {
                        // Can't fail from Play.  Just assert and print trace information.
                        assert(false);
                        // Only log this once at warning level one.  Rest go to warning level three to avoid tons of identical trace messages during playback).
                        TraceI(
                            param.fAlreadyTracedPlaybackError ? 3 : 1,
                            "Unable to send envelope information to an audio path object in parameter control track, HRESULT 0x%08x.\n", hrEnv);
                        param.fAlreadyTracedPlaybackError = true;
                    }
                }
            }

            // Send curves until the next curve is after mtEnd
            for ( ; pCurrentCurve < param.curvesEnd; ++pCurrentCurve )
            {
                if (pCurrentCurve->mtStartTime < mtStart) // this can happen if DMUS_TRACKF_PLAY_OFF was set and the seek pointer remains at events from the past
                    continue;
                if (pCurrentCurve->mtStartTime >= mtEnd)
                    break;

                // send this curve
                if (pIMediaParams)
                {
                    HRESULT hrEnv = this->PlayEnvelope(pIMediaParams, penvCurve, pCurrentCurve, obj, param, paramstate, mtOffset, rtOffset, pPerf, fClockTime, fObjClockTime);
                    if (FAILED(hrEnv))
                    {
                        // Can't fail from Play.  Just assert and print trace information.
                        assert(false);
                        // Only log this once at warning level one.  Rest go to warning level three to avoid tons of identical trace messages during playback).
                        TraceI(
                            param.fAlreadyTracedPlaybackError ? 3 : 1,
                            "Unable to send envelope information to an audio path object in parameter control track, HRESULT 0x%08x.\n", hrEnv);
                        param.fAlreadyTracedPlaybackError = true;
                    }
                }
            }

            if (pCurrentCurve < param.curvesEnd)
                fMoreCurves = true;
        }
        assert(!pParam); // we should have gotten all the way through this param list
    }
    assert(!pObject && iParam == m_cParams && iObject == m_cObjects); // we should have gotten all the way through the object list and done the expected number of objects and parameters

    pSD->dwValidate = m_dwValidate; // if we weren't in sync with new track data before, we are now
    return fMoreCurves ? S_OK : DMUS_S_END;
}

HRESULT CParamControlTrack::LoadObject(SmartRef::RiffIter ri)
{
    if (!ri)
        return ri.hr();

    HRESULT hr = S_OK;

    SmartRef::Ptr<TListItem<ObjectInfo> > spItem = new TListItem<ObjectInfo>;
    if (!spItem)
        return E_OUTOFMEMORY;
    ObjectInfo &ritem = spItem->GetItemValue();

    // find <proh>
    hr = ri.FindRequired(SmartRef::RiffIter::Chunk, DMUS_FOURCC_PARAMCONTROLTRACK_OBJECT_CHUNK, DMUS_E_INVALID_PARAMCONTROLTRACK);
    if (FAILED(hr))
    {
#ifdef DBG
        if (hr == DMUS_E_INVALID_PARAMCONTROLTRACK)
        {
            Trace(1, "Error: Unable to load parameter control track: Chunk 'proh' not found.\n");
        }
#endif
        return hr;
    }

    hr = SmartRef::RiffIterReadChunk(ri, &ritem.header);
    if (FAILED(hr))
        return hr;
    if (!(ritem.header.guidTimeFormat == GUID_TIME_MUSIC || ritem.header.guidTimeFormat == GUID_TIME_REFERENCE))
    {
        Trace(1, "Error: Unable to load parameter control track: guidTimeFormat in chunk 'proh' must be either GUID_TIME_MUSIC or GUID_TIME_REFERENCE.\n");
        return DMUS_E_INVALID_PARAMCONTROLTRACK;
    }

    // for each <prpl>
    while (ri && ri.Find(SmartRef::RiffIter::List, DMUS_FOURCC_PARAMCONTROLTRACK_PARAM_LIST))
    {
        hr = this->LoadParam(ri.Descend(), ritem.listParams);
        if (FAILED(hr))
            return hr;
        ++ri;
    }
    hr = ri.hr();

    if (SUCCEEDED(hr))
    {
        m_listObjects.AddHead(spItem.disown());
        ++m_cObjects;
    }
    return hr;
}

HRESULT CParamControlTrack::LoadParam(SmartRef::RiffIter ri, TList<ParamInfo> &listParams)
{
    if (!ri)
        return ri.hr();

    HRESULT hr = S_OK;

    SmartRef::Ptr<TListItem<ParamInfo> > spItem = new TListItem<ParamInfo>;
    if (!spItem)
        return E_OUTOFMEMORY;
    ParamInfo &ritem = spItem->GetItemValue();

    // find <prph>
    hr = ri.FindRequired(SmartRef::RiffIter::Chunk, DMUS_FOURCC_PARAMCONTROLTRACK_PARAM_CHUNK, DMUS_E_INVALID_PARAMCONTROLTRACK);
    if (FAILED(hr))
    {
#ifdef DBG
        if (hr == DMUS_E_INVALID_PARAMCONTROLTRACK)
        {
            Trace(1, "Error: Unable to load parameter control track: Chunk 'prph' not found.\n");
        }
#endif
        return hr;
    }

    hr = SmartRef::RiffIterReadChunk(ri, &ritem.header);
    if (FAILED(hr))
        return hr;

    // find <prcc>
    if (!ri.Find(SmartRef::RiffIter::Chunk, DMUS_FOURCC_PARAMCONTROLTRACK_CURVES_CHUNK))
    {
        // It is OK if we read to the end without finding the chunk--we succeed without finding any curves.
        // Or it could be a failure because there was a problem reading from the stream.
        // The RiffIter's hr method reflects this.
        return ri.hr();
    }

    // read the array of control curves
    int cRecords;
    hr = SmartRef::RiffIterReadArrayChunk(ri, &ritem.curves, &cRecords);
    if (FAILED(hr))
        return hr;
    ritem.curvesEnd = ritem.curves + cRecords;

    listParams.AddHead(spItem.disown());
    ++m_cParams;
    return hr;
}

HRESULT CParamControlTrack::TrackToObjectTime(
        MUSIC_TIME mtOffset,
        REFERENCE_TIME rtOffset,
        IDirectMusicPerformance* pPerf,
        bool fTrkClockTime,
        bool fObjClockTime,
        MUSIC_TIME mt,
        REFERENCE_TIME *rt)
{
    HRESULT hr = S_OK;

    // set the time (reference time variable is used to hold either music or reference time in different contexts)
    REFERENCE_TIME rtEnv = mt;

    // add the correct offset and if necessary convert from millisecond time 
    rtEnv = fTrkClockTime
                ? rtEnv * gc_RefPerMil + rtOffset
                : rtEnv = rtEnv + mtOffset;

    if (fTrkClockTime != fObjClockTime)
    {
        // need to convert between out track's time format and the audio object's time format
        if (fObjClockTime)
        {
            MUSIC_TIME mtEnv = static_cast<MUSIC_TIME>(rtEnv);
            hr = pPerf->MusicToReferenceTime(mtEnv, &rtEnv);
            if (FAILED(hr))
                return hr;
        }
        else
        {
            MUSIC_TIME mtEnv = 0;
            hr = pPerf->ReferenceToMusicTime(rtEnv, &mtEnv);
            rtEnv = mtEnv;
            if (FAILED(hr))
                return hr;
        }
    }

    *rt = rtEnv;
    return hr;
}

HRESULT
CParamControlTrack::PlayEnvelope(
    IMediaParams *pIMediaParams,
    MP_ENVELOPE_SEGMENT *pEnv,
    DMUS_IO_PARAMCONTROLTRACK_CURVEINFO *pPt,
    const ObjectInfo &obj,
    const ParamInfo &param,
    ParamState &paramstate,
    MUSIC_TIME mtOffset,
    REFERENCE_TIME rtOffset,
    IDirectMusicPerformance* pPerf,
    bool fTrkClockTime,
    bool fObjClockTime)
{
    HRESULT hr = S_OK;

    // set the curve type and flags
    pEnv->iCurve = static_cast<MP_CURVE_TYPE>(pPt->dwCurveType);
    pEnv->flags = pPt->dwFlags;

    pEnv->valEnd = pPt->fltEndValue;
    pEnv->valStart = pPt->fltStartValue;

    // set the time (used to hold either music or reference time in different contexts)

    REFERENCE_TIME &rtEnvStart = pEnv->rtStart;
    hr = this->TrackToObjectTime(mtOffset, rtOffset, pPerf, fTrkClockTime, fObjClockTime, pPt->mtStartTime, &rtEnvStart);
    if (FAILED(hr))
        return hr;

    REFERENCE_TIME &rtEnvEnd = pEnv->rtEnd;
    hr = this->TrackToObjectTime(mtOffset, rtOffset, pPerf, fTrkClockTime, fObjClockTime, pPt->mtEndTime, &rtEnvEnd);
    if (FAILED(hr))
        return hr;

    hr = pIMediaParams->AddEnvelope(param.header.dwIndex, 1, pEnv);
    if (SUCCEEDED(hr))
    {
        paramstate.rtStartPointOfLastCurve = rtEnvStart;
        TListItem<REFERENCE_TIME>* pStartTime = new TListItem<REFERENCE_TIME>;
        if (pStartTime)
        {
            pStartTime->GetItemValue() = rtEnvStart;
            // Adding to the head maintains a largest-to-smallest ordering.
            paramstate.listStartTimes.AddHead(pStartTime);
        }
        paramstate.fLast = true;
    }

    return hr;
}

HRESULT
CParamControlTrack::PlayTruncatedEnvelope(
    MUSIC_TIME mtTruncStart,
    IMediaParams *pIMediaParams,
    MP_ENVELOPE_SEGMENT *pEnv,
    DMUS_IO_PARAMCONTROLTRACK_CURVEINFO *pPt,
    const ObjectInfo &obj,
    const ParamInfo &param,
    ParamState &paramstate,
    MUSIC_TIME mtOffset,
    REFERENCE_TIME rtOffset,
    IDirectMusicPerformance* pPerf,
    bool fTrkClockTime,
    bool fObjClockTime,
    DWORD dwFlags)
{
    // Copy info from the curve
    DMUS_IO_PARAMCONTROLTRACK_CURVEINFO curveinfo = *pPt;
    // Cut the start to the designated time
    curveinfo.mtStartTime = mtTruncStart;
    bool fSkip = false;

    if (mtTruncStart >= curveinfo.mtEndTime)
    {
        // Curve happened in the past.  Send a jump curve right at the current (truncate) time picking up with
        // that value.
        // if we're looping and we passed the end of this curve, just skip it.
        if ( (dwFlags & DMUS_TRACKF_LOOP) )
        {
            fSkip = true;
        }
        else
        {
            curveinfo.mtEndTime = mtTruncStart;
            curveinfo.dwCurveType = MP_CURVE_JUMP;
        }
    }
    else if (pPt->dwCurveType != MP_CURVE_JUMP)
    {
        // Find the point at that time and pick up with a linear curve from there.
        // (For the nonlinear curves, there's no way to pick them up part-way along.)
        curveinfo.dwCurveType = MP_CURVE_LINEAR;

        MUSIC_TIME mtTimeChange = pPt->mtEndTime - pPt->mtStartTime;
        MUSIC_TIME mtTimeIntermediate = mtTruncStart - pPt->mtStartTime;

        float fltScalingX = static_cast<float>(mtTimeIntermediate) / mtTimeChange; // horizontal distance along curve between 0 and 1
        float fltScalingY; // height of curve at that point between 0 and 1 based on curve function
        switch (pPt->dwCurveType)
        {
        case MP_CURVE_SQUARE:
            fltScalingY = fltScalingX * fltScalingX;
            break;
        case MP_CURVE_INVSQUARE:
            fltScalingY = (float) sqrt(fltScalingX);
            break;
        case MP_CURVE_SINE:
            //  Maybe we should have a lookup table here?
            fltScalingY = (float) (sin(fltScalingX * 3.1415926535 - (3.1415926535/2)) + 1) / 2;
            break;
        case MP_CURVE_LINEAR:
        default:
            fltScalingY = fltScalingX;
        }

        // Apply that scaling to the range of the actual points
        curveinfo.fltStartValue = (pPt->fltEndValue - pPt->fltStartValue) * fltScalingY + pPt->fltStartValue;
    }

    if (fSkip) return S_OK;

    return this->PlayEnvelope(pIMediaParams, pEnv, &curveinfo, obj, param, paramstate, mtOffset, rtOffset, pPerf, fTrkClockTime, fObjClockTime);
}

HRESULT CParamControlTrack::InitStateData(StateData *pStateData,
                                          IDirectMusicSegmentState *pSegmentState)
{
    if (pStateData->prgpIMediaParams)
    {
        delete [] pStateData->prgpIMediaParams;
        pStateData->prgpIMediaParams = NULL;
    }
    if (pStateData->prgParam)
    {
        delete [] pStateData->prgParam;
        pStateData->prgParam = NULL;
    }

    pStateData->prgpIMediaParams = new IMediaParams *[m_cObjects];
    if (!pStateData->prgpIMediaParams)
    {
        return E_OUTOFMEMORY;
    }
    pStateData->prgParam = new ParamState[m_cParams];
    if (!pStateData->prgParam)
    {
        delete [] pStateData->prgpIMediaParams;
        return E_OUTOFMEMORY;
    }

    // Get the IMediaParams interface for each object
    SmartRef::ComPtr<IDirectMusicSegmentState8> scomSegSt8;
    HRESULT hr = pSegmentState->QueryInterface(IID_IDirectMusicSegmentState8, reinterpret_cast<void**>(&scomSegSt8));
    if (FAILED(hr))
    {      
        delete [] pStateData->prgParam;
        delete [] pStateData->prgpIMediaParams;
        return hr;
    }

    int iObject = 0;
    for (TListItem<ObjectInfo> *pObject = m_listObjects.GetHead();
            pObject;
            pObject = pObject->GetNext(), ++iObject)
    {
        IMediaParams *pIMediaParams = NULL;
        ObjectInfo &rinfo = pObject->GetItemValue();
        HRESULT hrObject = scomSegSt8->GetObjectInPath(
                                rinfo.header.dwPChannel,
                                rinfo.header.dwStage,
                                rinfo.header.dwBuffer,
                                rinfo.header.guidObject,
                                rinfo.header.dwIndex,
                                IID_IMediaParams,
                                reinterpret_cast<void**>(&pIMediaParams));
        if (FAILED(hrObject))
        {
            // Can't fail from InitPlay (and this is called from there).
            // Just print trace information.
            TraceI(1, "Parameter control track was unable to find audio path object, HRESULT 0x%08x.\n", hrObject);
        }
        else
        {
            hrObject = pIMediaParams->SetTimeFormat(rinfo.header.guidTimeFormat, rinfo.header.guidTimeFormat == GUID_TIME_MUSIC ? 768 : 0);
        }
        if (FAILED(hrObject))
        {
            // Can't fail from InitPlay (and this is called from there).
            // Just print trace information.
            Trace(1, "Unable to set time format of object in parameter control track, HRESULT 0x%08x.\n", hrObject);
        }
        if (FAILED(hrObject))
        {
            SafeRelease(pIMediaParams);
        }
        pStateData->prgpIMediaParams[iObject] = pIMediaParams;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\pchmap.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
/* This is a class to manage tracking mutes for the SeqTrack and BandTrack. */

#ifndef _PCHMAP__
#define _PCHMAP__
#include "dmusici.h"
#include "tlist.h"

struct PCHMAP_ITEM
{
	MUSIC_TIME	mtNext;
	DWORD		dwPChannel;
	DWORD		dwPChMap;
	BOOL		fMute;
};

class CPChMap
{
public:
	CPChMap();
	~CPChMap();
	void Reset(void);
	void GetInfo( DWORD dwPCh, MUSIC_TIME mtTime, MUSIC_TIME mtOffset, DWORD dwGroupBits,
				  IDirectMusicPerformance* pPerf, BOOL* pfMute, DWORD* pdwNewPCh , BOOL fClockTime);
private:
	TList<PCHMAP_ITEM>	m_PChMapList;
};
#endif // _PCHMAP__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\paramtrk.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of CParamControlTrack.
//

// This track holds curve information for automation (like automating sliders on a mixing board -- not OLE automation)
// of effects and tools in the audio path.

#pragma once

#include "trackhelp.h"
//#include "imediaobjectparams.h"
//#include "mediaobj.h" //  need to get this from public\sdk\inc
#include "medparam.h"
#include "dmusicf.h"

// {827F0437-9ED6-4107-8494-49976FF5B642}
DEFINE_GUID(IID_CParamControlTrack, 0x827f0437, 0x9ed6, 0x4107, 0x84, 0x94, 0x49, 0x97, 0x6f, 0xf5, 0xb6, 0x42);

class CParamControlTrack
  : public CBasicTrack
{
    // types for track data...

    struct ParamInfo
    {
        ParamInfo() : curves(NULL), curvesEnd(NULL), fAlreadyTracedPlaybackError(false) { Zero(&header); }
        ~ParamInfo() { delete[] curves; }

        DMUS_IO_PARAMCONTROLTRACK_PARAMHEADER header;
        DMUS_IO_PARAMCONTROLTRACK_CURVEINFO *curves; // pointer to first curve
        DMUS_IO_PARAMCONTROLTRACK_CURVEINFO *curvesEnd; // pointer one past last curve
        bool fAlreadyTracedPlaybackError;
    };

    struct ObjectInfo
    {
        ObjectInfo() : fAlreadyTracedPlaybackError(false) { Zero(&header); }

        DMUS_IO_PARAMCONTROLTRACK_OBJECTHEADER header;
        TList<ParamInfo> listParams;
        bool fAlreadyTracedPlaybackError;
    };

    struct ParamState // the state data we need to keep track of for each parameter we're controlling
    {
        ParamState() : pCurrentCurve(NULL), fLast(false), rtStartPointOfLastCurve(0) {}

        DMUS_IO_PARAMCONTROLTRACK_CURVEINFO *pCurrentCurve; // current seek pointer in the array of control points
        bool fLast; // true if the last envelope was sent successfully
        REFERENCE_TIME rtStartPointOfLastCurve; // time (in the object's time) of the start point of the last envelope we sent
        TList<REFERENCE_TIME> listStartTimes; // start times of all envelopes that have been sent 
    };

    struct StateData
    {
        StateData() : prgpIMediaParams(NULL), prgParam(NULL), fFlushInAbort(false) {}

        IMediaParams **prgpIMediaParams; // Array of size m_cObjects.
        ParamState *prgParam; // Array of size m_cParams.
        DWORD dwValidate;
        bool fFlushInAbort;
    };

public:
    CParamControlTrack(HRESULT *pHr) : m_dwValidate(0), m_cObjects(0), m_cParams(0), CBasicTrack(&g_cComponent, CLSID_DirectMusicParamControlTrack) {}

    STDMETHOD(QueryInterface)(const IID &iid, void **ppv);

    STDMETHOD(Init)(IDirectMusicSegment *pSegment);
    STDMETHOD(Load)(IStream* pIStream);
    STDMETHOD(InitPlay)(
        IDirectMusicSegmentState *pSegmentState,
        IDirectMusicPerformance *pPerformance,
        void **ppStateData,
        DWORD dwTrackID,
        DWORD dwFlags);
    STDMETHOD(EndPlay)(void *pStateData);
    STDMETHOD(Clone)(MUSIC_TIME mtStart,MUSIC_TIME mtEnd,IDirectMusicTrack** ppTrack);
    virtual HRESULT PlayMusicOrClock(
        void *pStateData,
        MUSIC_TIME mtStart,
        MUSIC_TIME mtEnd,
        MUSIC_TIME mtOffset,
        REFERENCE_TIME rtOffset,
        DWORD dwFlags,
        IDirectMusicPerformance* pPerf,
        IDirectMusicSegmentState* pSegSt,
        DWORD dwVirtualID,
        bool fClockTime);

    virtual HRESULT OnSegmentEnd(REFERENCE_TIME rtEnd, void *pStateData);

private:
    HRESULT LoadObject(SmartRef::RiffIter ri);
    HRESULT LoadParam(SmartRef::RiffIter ri, TList<ParamInfo> &listParams);
    HRESULT TrackToObjectTime(
        MUSIC_TIME mtOffset,
        REFERENCE_TIME rtOffset,
        IDirectMusicPerformance* pPerf,
        bool fTrkClockTime,
        bool fObjClockTime,
        MUSIC_TIME mt,
        REFERENCE_TIME *rt);
    HRESULT PlayEnvelope(
        IMediaParams *pIMediaParams,
        MP_ENVELOPE_SEGMENT *pEnv,
        DMUS_IO_PARAMCONTROLTRACK_CURVEINFO *pPt,
        const ObjectInfo &obj,
        const ParamInfo &param,
        ParamState &paramstate,
        MUSIC_TIME mtOffset,
        REFERENCE_TIME rtOffset,
        IDirectMusicPerformance* pPerf,
        bool fTrkClockTime,
        bool fObjClockTime);
    HRESULT PlayTruncatedEnvelope(
        MUSIC_TIME mtTruncStart,
        IMediaParams *pIMediaParams,
        MP_ENVELOPE_SEGMENT *pEnv,
        DMUS_IO_PARAMCONTROLTRACK_CURVEINFO *pPt,
        const ObjectInfo &obj,
        const ParamInfo &param,
        ParamState &paramstate,
        MUSIC_TIME mtOffset,
        REFERENCE_TIME rtOffset,
        IDirectMusicPerformance* pPerf,
        bool fTrkClockTime,
        bool fObjClockTime,
        DWORD dwFlags);
        HRESULT InitStateData(
            StateData *pStateData,
            IDirectMusicSegmentState *pSegmentState);

    DWORD m_dwValidate; // Increment this counter in Load, causing the state data to synchonize with the new events
    TList<ObjectInfo> m_listObjects;
    int m_cObjects;
    int m_cParams;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\queue.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
// queue.cpp
#include "debug.h"
#define ASSERT	assert
#include "dmime.h"
#include "dmperf.h"

CPMsgQueue::CPMsgQueue()

{
    m_pTop = NULL;
    m_pLastAccessed = NULL;
}

CPMsgQueue::~CPMsgQueue()

{
}

static PRIV_PMSG * sortevents( PRIV_PMSG * pEvents, long lLen )

{
    PRIV_PMSG * pLeft;
    PRIV_PMSG * pRight ;
    long        lLeft;
    long        lRight ;
    PRIV_PMSG * pTop ;

    if( lLen < 3 )
    {
        if( !pEvents )
            return( 0 ) ;
        if( lLen == 1 )
            return( pEvents ) ;
        pLeft  = pEvents ;
        pRight = pEvents->pNext ;
        if( !pRight )
            return( pLeft ) ;
        if( pLeft->rtTime > pRight->rtTime )
        {
            pLeft->pNext = NULL ;
            pRight->pNext = pLeft ;
            return( pRight ) ;
        }
        return( pLeft ) ;
    }

    lLeft = lLen >> 1 ;
    lRight = lLen - lLeft;
    pLeft = pEvents ;
    for (;lLeft > 1;pEvents = pEvents->pNext) lLeft--;
    pRight = sortevents( pEvents->pNext, lRight ) ;
    pEvents->pNext = NULL ;
    pLeft = sortevents( pLeft, lLen - lRight ) ;
    pTop = NULL ;

    for( ;  pLeft && pRight ;  )
    {
        if( pLeft->rtTime < pRight->rtTime )
        {
            if( !pTop )
                pTop = pLeft ;
            else
                pEvents->pNext = pLeft ;
            pEvents = pLeft ;
            pLeft   = pEvents->pNext ;
        }
        else
        {
            if( !pTop )
                pTop = pRight ;
            else
                pEvents->pNext = pRight ;
            pEvents = pRight ;
            pRight  = pEvents->pNext ;
        }
    }

    if( pLeft )
        pEvents->pNext = pLeft ;
    else
        pEvents->pNext = pRight ;

    return( pTop ) ;

}   

void CPMsgQueue::Sort() 

{
    m_pTop = sortevents(m_pTop, GetCount()) ;
    m_pLastAccessed = NULL;
}  

long CPMsgQueue::GetCount()

{
    long lCount = 0;
    PRIV_PMSG *pScan = GetHead();
    for (;pScan;pScan = pScan->pNext)
    {
        lCount++;
    }
    return lCount;
}

void CPMsgQueue::Enqueue(PRIV_PMSG *pItem)

{
    if (!pItem)
    {
        TraceI(0, "ENQUEUE: Attempt to enqueue a NULL pItem!\n");
        return;
    }
    // Ensure not already queued...
    if (pItem->dwPrivFlags & PRIV_FLAG_QUEUED)
    {
        TraceI(0,"ENQUEUE: Item thinks it is still in a queue!\n");
        return;
    }
	pItem->dwPrivFlags |= PRIV_FLAG_QUEUED;
    PRIV_PMSG *pScan; 
#ifdef DBG
    // Verify robustness of list. Check that the event is not already in the list
    // and that the time stamps are all in order.
    REFERENCE_TIME rtTime = 0;
    for (pScan = m_pTop;pScan;pScan = pScan->pNext)
    {
        if (pScan == pItem)
        {
            TraceI(0,"ENQUEUE: Item is already in the queue!\n"); 
            return;
        }
    	// this must queue events in time sorted order
        if (pScan->rtTime < rtTime)
        {
            TraceI(0,"ENQUEUE: Queue is not in time order!\n");
            pScan->rtTime = rtTime;
        }
        else if (pScan->rtTime > rtTime)
        {
            rtTime = pScan->rtTime;
        }
    }
#endif
    if ( !(pItem->dwFlags & DMUS_PMSGF_REFTIME) ) // sorting on reftime, so this must be valid 
    {
        TraceI(0, "ENQUEUE: Attempt to enqueue a pItem with a bogus RefTime!\n");
        return;
    }
    if (m_pLastAccessed && (m_pLastAccessed->rtTime <= pItem->rtTime))
    {
        pScan = m_pLastAccessed;
    }
    else
    {
        pScan = m_pTop;
    }
    if ( pScan && ( pScan->rtTime <= pItem->rtTime ) )
	{
		for (;pScan->pNext; pScan = pScan->pNext )
		{
			if( pScan->pNext->rtTime > pItem->rtTime )
			{
				break;
			}
		}
		pItem->pNext = pScan->pNext;
		pScan->pNext = pItem;
    }
	else 
	{
		pItem->pNext = m_pTop;
		m_pTop = pItem;
	}
    m_pLastAccessed = pItem;
}

/*  Remove the oldest event before time rtTime, making sure that there is still
    at minimum one event prior to that time stamp. 
    This ensures that there is a sufficiently old event, but gets rid of old
    stale events. This is used by the timesig and tempomap lists.
*/

PRIV_PMSG *CPMsgQueue::FlushOldest(REFERENCE_TIME rtTime)

{
    PRIV_PMSG *pNext;
    if (m_pTop && (pNext = m_pTop->pNext))
    {
        if (pNext->rtTime < rtTime)
        {
            PRIV_PMSG *pDelete = m_pTop;
            if (m_pLastAccessed == m_pTop)
            {
                m_pLastAccessed = pNext;
            }
            m_pTop = pNext;
			pDelete->dwPrivFlags &= ~PRIV_FLAG_QUEUED;
			pDelete->pNext = NULL;
            return pDelete;
        }
    }
    return NULL;
}

PRIV_PMSG *CPMsgQueue::Dequeue()

{
    PRIV_PMSG *pItem = m_pTop;

    if (pItem != NULL)
	{
        m_pTop = pItem->pNext;
		pItem->dwPrivFlags &= ~PRIV_FLAG_QUEUED;
        pItem->pNext = NULL;
        if (m_pLastAccessed == pItem)
        {
            m_pLastAccessed = m_pTop;
        }
    }

    return pItem;
}

PRIV_PMSG *CPMsgQueue::Dequeue(PRIV_PMSG *pItem)

{
    ASSERT(pItem);

    if (pItem == m_pTop)
    {
        return Dequeue();
    }
    PRIV_PMSG *pScan;
    PRIV_PMSG *pNext;
    if (m_pLastAccessed && 
        (m_pLastAccessed->rtTime < pItem->rtTime))
    {
        pScan = m_pLastAccessed;
    }
    else
    {
        pScan = m_pTop;
    }
    for (;pScan;pScan = pNext)
    {
        pNext = pScan->pNext;
        if (pNext == pItem)
        {
            pScan->pNext = pItem->pNext;
            pItem->pNext = NULL;
            pItem->dwPrivFlags &= ~PRIV_FLAG_QUEUED;
            if (m_pLastAccessed == pItem)
            {
                m_pLastAccessed = pScan;
            }
            return pItem;
        }
    }
    if (m_pLastAccessed)
    {
        // This happens every now and then as a result of a curve setting rtTime to 0
        // in the middle of FlushEventQueue. 
        // This should be fixed, but this patch will work for now.
        m_pLastAccessed = NULL;
        return Dequeue(pItem);
    }
    return NULL;
}

// queue Segment nodes in time order. pItem must be in the same
// time base as all items in ppList (RefTime or Music Time.)

void CSegStateList::Insert(CSegState* pItem)

{
    CSegState *pScan = GetHead();
    CSegState *pNext;
    pItem->SetNext(NULL);
    if (pScan)
	{
		if( pItem->m_dwPlaySegFlags & DMUS_SEGF_REFTIME )
		{
			ASSERT( pScan->m_dwPlaySegFlags & DMUS_SEGF_REFTIME );
			// Avoid putting circularities in the list
			if (pItem == pScan)
			{
				TraceI(0, "ENQUEUE (SEGMENT RT): NODE IS ALREADY IN AT THE HEAD OF LIST\n");
			}
			else if( pItem->m_rtGivenStart < pScan->m_rtGivenStart )
			{
                AddHead(pItem);
			}
			else
			{
				while( pNext = pScan->GetNext() )
				{
					ASSERT( pScan->m_dwPlaySegFlags & DMUS_SEGF_REFTIME );
					// Am I trying to insert something that's already in the list?
					if (pItem == pScan)
					{
						break;
					}
					// Check for the queue getting corrupted (happens on multiproc machines at 400mhz)
					if ( ( pNext->m_dwPlaySegFlags & DMUS_SEGF_REFTIME ) && 
						 pScan->m_rtGivenStart > pNext->m_rtGivenStart )
					{
						TraceI(0, "ENQUEUE (SEGMENT RT): LOOP CONDITION VIOLATED\n");
						// get rid of the potential circularity in the list.  Note that this
						// (or actually the creation of the circularity) could cause memory leaks.
						pScan->SetNext(NULL);
						break;
					}
					if( pItem->m_rtGivenStart < pNext->m_rtGivenStart )
					{
						break;
					}
					pScan = pNext;
				}
				if (pItem != pScan)
				{
					pItem->SetNext(pScan->GetNext());
					pScan->SetNext(pItem);
				}
				else
				{
					TraceI(0, "ENQUEUE (SEGMENT RT): NODE IS ALREADY IN LIST\n");
				}
			}
		}
		else
		{
			ASSERT( !( pScan->m_dwPlaySegFlags & DMUS_SEGF_REFTIME ) );
			// Avoid putting circularities in the list
			if (pItem == pScan)
			{
				TraceI(0, "ENQUEUE (SEGMENT MT): NODE IS ALREADY IN AT THE HEAD OF LIST\n");
			}
			else if( pItem->m_mtResolvedStart < pScan->m_mtResolvedStart )
			{
				AddHead(pItem);
			}
			else
			{
				while( pNext = pScan->GetNext() )
				{
					ASSERT( !( pScan->m_dwPlaySegFlags & DMUS_SEGF_REFTIME ) );
					// Am I trying to insert something that's already in the list?
					if (pItem == pScan)
					{
						break;
					}
					// Check for the queue getting corrupted (happens on multiproc machines at 400mhz)
					if ( !( pNext->m_dwPlaySegFlags & DMUS_SEGF_REFTIME ) && 
						 pScan->m_mtResolvedStart > pNext->m_mtResolvedStart )
					{
						TraceI(0, "ENQUEUE (SEGMENT MT): LOOP CONDITION VIOLATED\n");
						// get rid of the potential circularity in the list.  Note that this
						// (or actually the creation of the circularity) could cause memory leaks.
						pScan->SetNext(NULL);
						break;
					}
					if( pItem->m_mtResolvedStart < pNext->m_mtResolvedStart )
					{
						break;
					}
					pScan = pNext;
				}
                if (pItem != pScan)
				{
					pItem->SetNext(pScan->GetNext());
					pScan->SetNext(pItem);
				}
				else
				{
					TraceI(0, "ENQUEUE (SEGMENT MT): NODE IS ALREADY IN LIST\n");
				}
			}
		}
    }
	else
	{
		m_pHead = pItem;
	}
}

/*


void enqueue(CSegState **ppList, CSegState *pItem)
{
    CSegState *li = *ppList;

    if (li)
	{
		if( pItem->m_dwPlaySegFlags & DMUS_SEGF_REFTIME )
		{
			ASSERT( li->m_dwPlaySegFlags & DMUS_SEGF_REFTIME );
			// Avoid putting circularities in the list
			if (pItem == *ppList)
			{
				TraceI(0, "ENQUEUE (SEGMENT RT): NODE IS ALREADY IN AT THE HEAD OF LIST\n");
			}
			else if( pItem->m_rtGivenStart < li->m_rtGivenStart )
			{
				pItem->pNext = li;
				*ppList = pItem;
			}
			else
			{
				while( li->pNext )
				{
					ASSERT( li->m_dwPlaySegFlags & DMUS_SEGF_REFTIME );
					// Am I trying to insert something that's already in the list?
					if (pItem == li)
					{
						break;
					}
					// Check for the queue getting corrupted (happens on multiproc machines at 400mhz)
					if ( ( li->pNext->m_dwPlaySegFlags & DMUS_SEGF_REFTIME ) && 
						 li->m_rtGivenStart > li->pNext->m_rtGivenStart )
					{
						TraceI(0, "ENQUEUE (SEGMENT RT): LOOP CONDITION VIOLATED\n");
						// get rid of the potential circularity in the list.  Note that this
						// (or actually the creation of the circularity) could cause memory leaks.
						li->pNext = NULL;
						break;
					}
					if( pItem->m_rtGivenStart < li->pNext->m_rtGivenStart )
					{
						break;
					}
					li = li->pNext;
				}
				if (pItem != li)
				{
					pItem->pNext = li->pNext;
					li->pNext = pItem;
				}
				else
				{
					TraceI(0, "ENQUEUE (SEGMENT RT): NODE IS ALREADY IN LIST\n");
				}
			}
		}
		else
		{
			ASSERT( !( li->m_dwPlaySegFlags & DMUS_SEGF_REFTIME ) );
			// Avoid putting circularities in the list
			if (pItem == *ppList)
			{
				TraceI(0, "ENQUEUE (SEGMENT MT): NODE IS ALREADY IN AT THE HEAD OF LIST\n");
			}
			else if( pItem->m_mtResolvedStart < li->m_mtResolvedStart )
			{
				pItem->pNext = li;
				*ppList = pItem;
			}
			else
			{
				while( li->pNext )
				{
					ASSERT( !( li->m_dwPlaySegFlags & DMUS_SEGF_REFTIME ) );
					// Am I trying to insert something that's already in the list?
					if (pItem == li)
					{
						break;
					}
					// Check for the queue getting corrupted (happens on multiproc machines at 400mhz)
					if ( !( li->pNext->m_dwPlaySegFlags & DMUS_SEGF_REFTIME ) && 
						 li->m_mtResolvedStart > li->pNext->m_mtResolvedStart )
					{
						TraceI(0, "ENQUEUE (SEGMENT MT): LOOP CONDITION VIOLATED\n");
						// get rid of the potential circularity in the list.  Note that this
						// (or actually the creation of the circularity) could cause memory leaks.
						li->pNext = NULL;
						break;
					}
					if( pItem->m_mtResolvedStart < li->pNext->m_mtResolvedStart )
					{
						break;
					}
					li = li->pNext;
				}
				if (pItem != li)
				{
					pItem->pNext = li->pNext;
					li->pNext = pItem;
				}
				else
				{
					TraceI(0, "ENQUEUE (SEGMENT MT): NODE IS ALREADY IN LIST\n");
				}
			}
		}
    }
	else
	{
		*ppList = pItem;
	}
}*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\pchmap.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
/* This is a class to manage tracking mutes for the SeqTrack and BandTrack. */
#include "PChMap.h"
#include "dmusicf.h"

CPChMap::CPChMap()
{
}

CPChMap::~CPChMap()
{
}

// Reset sets all item's mtNext time values to -1, so they are gotten again.
void CPChMap::Reset(void)
{
	TListItem<PCHMAP_ITEM>* pItem;
	
	for( pItem = m_PChMapList.GetHead(); pItem; pItem = pItem->GetNext() )
	{
		PCHMAP_ITEM& rItem = pItem->GetItemValue();
		rItem.mtNext = -1;
		rItem.dwPChMap = rItem.dwPChannel;
        rItem.fMute = 0;
	}
}

// GetInfo calls the performance's GetData to get the current Mute Track information.
// Reset() will be called upon any invalidation or seek, which will set the
// internal times to -1 so this will be accurate in case of a new controlling segment.
// You must provide the pfMute and pdwNewPCh parameters to this function, or
// it will crash.
void CPChMap::GetInfo( DWORD dwPCh, MUSIC_TIME mtTime, MUSIC_TIME mtOffset, DWORD dwGroupBits,
					   IDirectMusicPerformance* pPerf, BOOL* pfMute, DWORD* pdwNewPCh, BOOL fClockTime )
{
	TListItem<PCHMAP_ITEM>* pItem;
	
	for( pItem = m_PChMapList.GetHead(); pItem; pItem = pItem->GetNext() )
	{
		PCHMAP_ITEM& rCheck = pItem->GetItemValue();
		if( rCheck.dwPChannel == dwPCh ) break;
	}
	if( NULL == pItem )
	{
		PCHMAP_ITEM item;
		item.mtNext = -1;
		item.dwPChannel = item.dwPChMap = dwPCh;
		item.fMute = FALSE;
		pItem = new TListItem<PCHMAP_ITEM>(item);
		if( NULL == pItem )
		{
			// error, out of memory.
			*pfMute = FALSE;
			*pdwNewPCh = dwPCh;
			return;
		}
		m_PChMapList.AddHead(pItem);
	}
	PCHMAP_ITEM& rItem = pItem->GetItemValue();
	if( mtTime >= rItem.mtNext )
	{
		DMUS_MUTE_PARAM muteParam;
		MUSIC_TIME mtNext;
		muteParam.dwPChannel = dwPCh;
        if (fClockTime)
        {
            MUSIC_TIME mtMusic;
            REFERENCE_TIME rtTime = (mtTime + mtOffset) * 10000;
            pPerf->ReferenceToMusicTime(rtTime,&mtMusic);
		    if( SUCCEEDED(pPerf->GetParam( GUID_MuteParam, dwGroupBits, 0, mtMusic, 
			    &mtNext, (void*)&muteParam )))
		    {
                REFERENCE_TIME rtNext;
                // Convert to absolute reference time.
                pPerf->MusicToReferenceTime(mtNext + mtMusic,&rtNext);
                rtNext -= rtTime;   // Subtract out to get the delta.
			    rItem.mtNext = (MUSIC_TIME)(rtNext / 10000);  // Convert to delta in milliseconds. BUGBUG What if there's a tempo change?
			    rItem.dwPChMap = muteParam.dwPChannelMap;
			    rItem.fMute = muteParam.fMute;
		    }
		    else
		    {
			    // no mute track, or no mute on this pchannel.
			    // keep the current mapping.
			    rItem.mtNext = 0x7fffffff;
		    }

        }
        else
        {
		    if( SUCCEEDED(pPerf->GetParam( GUID_MuteParam, dwGroupBits, 0, mtTime + mtOffset, 
			    &mtNext, (void*)&muteParam )))
		    {
			    rItem.mtNext = mtNext;
			    rItem.dwPChMap = muteParam.dwPChannelMap;
			    rItem.fMute = muteParam.fMute;
		    }
		    else
		    {
			    // no mute track, or no mute on this pchannel.
			    // keep the current mapping.
			    rItem.mtNext = 0x7fffffff;
		    }
        }
	}
	*pfMute = rItem.fMute;
	*pdwNewPCh = rItem.dwPChMap;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\sjdefs.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1998 Microsoft Corporation
//
//  File:       sjdefs.h
//
//--------------------------------------------------------------------------

#ifndef __SJ_DEFINES_H__
#define __SJ_DEFINES_H__

//#define DEFAULT_STYLE_PATH "\\multim~1\\music\\intera~1\\"

// Score defines

#define VNUM        16  // Total number of variations
#define LAST_INSTR  5   // Total number of displayed instr minus 1
#define MAX_OUTS    6   // Max MIDI out devices supported

#define EDITMODES           3
#define MODE_ALLCHORDS      4
#define MODE_FATCHORDS      8

#define BAND_NAME_SIZE      15
#define SECTION_NAME_SIZE   15
#define SONG_NAME_SIZE      20
#define FILTER_SIZE         40
#define TITLE_SIZE          60
#define SMALLEST_OFFSET     96
#define ERRORTEXT_SIZE      100
#define FILENAME_SIZE       256
#define FILENAMES_SIZE      512

#define BUFFER_SIZE     400

#define EVENT_FREED     0x35
#define EVENT_REMOVE    0x5A
#define EVENT_VOICE     1       // Performance event
#define EVENT_REALTIME  2       // qevent() must invoke interrupt
#define EVENT_ONTIME    3       // event should be handled on time

#define FROM_MIDIINPUT  2       // MIDI input
#define DEST_MSG        3       // Post message to app
#define DEST_MIDIOUT    4       // Routed to MIDI mapper
#define DEST_COMPOSER   5       // Routed to composition code
#define DEST_TEMPO      6       // Routed to tempo change code
#define DEST_VOLUME     7       // Routed to volume change code
#define DEST_RTEMPO     8       // Routed to relative tempo change code
#define DEST_RVOLUME    9       // Routed to relative volume change code
#define DEST_REMOVE     10      // Routed to remove code (freeevent)
#define DEST_METRONOME  11      // Routed to metronome code
#define DEST_ENDMOTIF   12      // ends a motif and frees its channels in use
#define DEST_MIDIFILE   13      // Source was a MIDI file, convert to DEST_MIDIOUT

#define NB_OFFSET   0x3     // Offset note up to 7 clicks early

#define PF_FILL     0x0001      // Fill pattern
#define PF_START    0x0002      // May be starting pattern
#define PF_INTRO    0x0002
#define PF_WHOLE    0x0004      // Handles chords on measures
#define PF_HALF     0x0008      // Chords every two beats
#define PF_QUARTER  0x0010      // Chords on beats
#define PF_BREAK    0x0020
#define PF_END      0x0040
#define PF_A        0x0080
#define PF_B        0x0100
#define PF_C        0x0200
#define PF_D        0x0400
#define PF_E        0x0800
#define PF_F        0x1000
#define PF_G        0x2000
#define PF_H        0x10000
#define PF_STOPNOW  0x4000
#define PF_INRIFF   0x8000
#define PF_MOTIF    0x20000     // this pattern is a motif, not a regular pattern
#define PF_BEATS    ( PF_WHOLE | PF_HALF | PF_QUARTER )
#define PF_RIFF     ( PF_INTRO | PF_BREAK | PF_FILL | PF_END )
#define PF_GROOVE   ( PF_A | PF_B | PF_C | PF_D | PF_E | PF_F | PF_G | PF_H )


#define C_FILL      1       // Do a fill
#define C_INTRO     2       // Do an intro
#define C_BREAK     3       // Do a drum break
#define C_END       4       // End the song

//#define NEXTCHORD_SIZE  (sizeof(NextChrd)-sizeof(LPNEXTCHRD)-sizeof(LPCHRDENTRY))
//#define CHORDENTRY_SIZE (sizeof(ChordExt)-sizeof(LPCHORDEXT)+sizeof(unsigned long)+sizeof(short))

#define CE_SELECTED 1               // This is the active chord.
#define CE_START    2
#define CE_END      4
#define CE_MEASURE  8
#define CE_PATH     16
#define CE_TREE     32


// Section Flags
#define SECF_STOPPED_EARLY  0x0001
#define SECF_IS_TRANSITION  0x0002

// chord types for use by each instrument in a pattern
// Chord types for use by each instrument in a pattern
enum
{ 
	CHTYPE_NOTINITIALIZED = 0,
	CHTYPE_DRUM,		// superceded by CHTYPE_FIXED
					// no longer in Note Dialog's combo box selections
					// no longer in Pattern Dialog's combo box selections
	CHTYPE_BASS,		// scale + lower chord
	CHTYPE_UPPER,		// scale + upper chord
	CHTYPE_SCALEONLY, 	// scale, no chord
	CHTYPE_BASSMELODIC,
	CHTYPE_UPPERMELODIC,
	CHTYPE_NONE,		// Ignored on Pattern Dialog's menu selections.
	CHTYPE_FIXED
};

#define VF_SCALE        0x7F    // Seven positions in the scale
#define VF_ACCIDENTAL   0x80    // Handles chords outside of scale
#define VF_MAJOR        0x100   // Handles major chords
#define VF_MINOR        0x200   // Handles minor chords
#define VF_ALL          0x400   // Handles all chord types
#define VF_TO1          0x800   // Handles transitions to 1 chord
#define VF_TO5          0x1000  // Handles transitions to 5 chord
#define VF_SIMPLE       0x2000  // handles simple chords
#define VF_COMPLEX      0x4000  // handles complex chords

// this expects a voiceid from 1-16
#define VOICEID_TO_CHANNEL( id ) ((DWORD) ( ( id + 3 ) & 0xf ))

#pragma pack()

#endif // __SJ_DEFINES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\riff.h ===
//
// riff.h
//

#include <objbase.h>

#ifndef __RIFF__
#define __RIFF__
#include <windows.h>
#include <mmsystem.h>
#define FixBytes(a1,a2)

// {0D5057E1-8889-11CF-B9DA-00AA00C08146}
DEFINE_GUID( IID_IRIFFStream, 0xd5057e1, 0x8889, 0x11cf, 0xb9, 0xda, 0x0, 0xaa, 0x0, 0xc0, 0x81, 0x46 );
#undef INTERFACE
#define INTERFACE IRIFFStream
DECLARE_INTERFACE_(IRIFFStream, IUnknown)
{
    // IUnknown members
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // IMKRIFFStream members
    STDMETHOD_(UINT, Descend)(LPMMCKINFO lpck, LPMMCKINFO lpckParent, UINT wFlags) PURE;
    STDMETHOD_(UINT, Ascend)(LPMMCKINFO lpck, UINT wFlags) PURE;
    STDMETHOD_(UINT, CreateChunk)(LPMMCKINFO lpck, UINT wFlags) PURE;
    STDMETHOD(SetStream)(LPSTREAM pStream) PURE;
    STDMETHOD_(LPSTREAM, GetStream)() PURE;
};



struct CRIFFStream : IRIFFStream
{
///// object state
    ULONG       m_cRef;         // object reference count
    IStream*    m_pStream;      // stream to operate on

///// construction and destruction
    CRIFFStream(IStream* pStream)
    {
        m_cRef = 1;
		// replaced a call to SetStream with the following to avoid releasing an
		// unallocated stream
        m_pStream = pStream;
        if( m_pStream != NULL )
        {
            m_pStream->AddRef();
        }
    }
    ~CRIFFStream()
    {
        if( m_pStream != NULL )
        {
            m_pStream->Release();
        }
    }

///// IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj)
    {
        if( IsEqualIID( riid, IID_IUnknown ) ||
            IsEqualIID( riid, IID_IRIFFStream ) )
        {
            *ppvObj = (IRIFFStream*)this;
            AddRef();
            return NOERROR;
        }
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    STDMETHODIMP_(ULONG) AddRef()
    {
        return ++m_cRef;
    }
    STDMETHODIMP_(ULONG) Release()
    {
        if( --m_cRef == 0L )
        {
            delete this;
            return 0;
        }
        return m_cRef;
    }

// IAARIFFStream methods
    STDMETHODIMP_(UINT) Descend( LPMMCKINFO lpck, LPMMCKINFO lpckParent, UINT wFlags );
    STDMETHODIMP_(UINT) Ascend( LPMMCKINFO lpck, UINT wFlags );
    STDMETHODIMP_(UINT) CreateChunk( LPMMCKINFO lpck, UINT wFlags );
    STDMETHOD(SetStream)(LPSTREAM pStream)
    {
        if( m_pStream != NULL )
        {
            m_pStream->Release();
        }
        m_pStream = pStream;
        if( m_pStream != NULL )
        {
            m_pStream->AddRef();
        }
        return S_OK;
    }
    STDMETHOD_(LPSTREAM, GetStream)()
    {
        if( m_pStream != NULL )
        {
            m_pStream->AddRef();
        }
        return m_pStream;
    }

// private methods
    long MyRead( void *pv, long cb );
    long MyWrite( const void *pv, long cb );
    long MySeek( long lOffset, int iOrigin );
};
/*
// seeks to a 32-bit position in a stream.
HRESULT __inline StreamSeek( LPSTREAM pStream, long lSeekTo, DWORD dwOrigin )
{
	LARGE_INTEGER li;

	if( lSeekTo < 0 )
	{
		li.HighPart = -1;
	}
	else
	{
        li.HighPart = 0;
	}
	li.LowPart = lSeekTo;
	return pStream->Seek( li, dwOrigin, NULL );
}

// returns the current 32-bit position in a stream.
DWORD __inline StreamTell( LPSTREAM pStream )
{
	LARGE_INTEGER li;
    ULARGE_INTEGER ul;
#ifdef DBG
    HRESULT hr;
#endif

    li.HighPart = 0;
    li.LowPart = 0;
#ifdef DBG
    hr = pStream->Seek( li, STREAM_SEEK_CUR, &ul );
    if( FAILED( hr ) )
#else
    if( FAILED( pStream->Seek( li, STREAM_SEEK_CUR, &ul ) ) )
#endif
    {
        return 0;
    }
    return ul.LowPart;
}

// this function gets a long that is formatted the correct way
// i.e. the motorola way as opposed to the intel way
BOOL __inline GetMLong( LPSTREAM pStream, DWORD& dw )
{
    union uLong
	{
		unsigned char buf[4];
        DWORD dw;
	} u;
    unsigned char ch;

    if( FAILED( pStream->Read( u.buf, 4, NULL ) ) )
    {
        return FALSE;
    }

#ifndef _MAC
    // swap bytes
    ch = u.buf[0];
    u.buf[0] = u.buf[3];
    u.buf[3] = ch;

    ch = u.buf[1];
    u.buf[1] = u.buf[2];
    u.buf[2] = ch;
#endif

    dw = u.dw;
    return TRUE;
}

BOOL __inline IsGUIDZero( REFGUID guid )
{
    GUID g;

    memset( &g, 0, sizeof( g ) );
    return IsEqualGUID( g, guid );
}

// misc function prototypes

STDAPI AllocFileStream( LPCSTR szFileName, DWORD dwDesiredAccess, IStream **ppstream );
*/
STDAPI AllocRIFFStream( IStream* pStream, IRIFFStream** ppRiff );

#endif  // __RIFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\score.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1998 Microsoft Corporation
//
//  File:       score.h
//
//--------------------------------------------------------------------------

#ifndef __SCORE_H__
#define __SCORE_H__

/*  Defines ============================================================*/

#define INUM                16  // Number of band members
#define PPQN                192 // Pulses per quarter note
#define PPQNx4              ( PPQN << 2 )
#define PPQN_2              ( PPQN >> 1 )

#define ROOT_MIN            0   // Scale (or chord) root min and max
#define ROOT_MAX            23

// Section Flags, WPARAM of SECTION_STARTED/ENDED
#define SECF_STOPPED_EARLY  0x0001
#define SECF_IS_TRANSITION  0x0002

/*  Section Commands ===================================================*/

#define SCTSEC_PLAY_SECTION         2
#define SCTSEC_SET_ROOT             4
//#define SCTSEC_SET_STYLE            6
#define SCTSEC_SET_LENGTH           8
#define SCTSEC_SET_REPEATS          9
//#define SCTSEC_SET_PERSONALITY      15

#define BAND_MELODY   0     // Use BAND flags with RTC_SET_VOLUME,
#define BAND_STRING   1     // RTC_SET_PAN, RTC_SET_PATCH, SCTSEC_SET_VOLUME,
#define BAND_GUITAR   2     // SCTSEC_SET_PAN and SCTSEC_SET_PATCH
#define BAND_PIANO    3
#define BAND_BASS     4     // These are the default SCT band members
#define BAND_DRUM     5

#define BAND_ALL      50
#define BAND_NONE     51

#define SP_A        1       // Use SP flags for templates
#define SP_B        2
#define SP_C        4
#define SP_D        8
#define SP_E        0x10
#define SP_F        0x20
#define SP_LETTER   (SP_A | SP_B | SP_C | SP_D | SP_E | SP_F)
#define SP_1        0x100
#define SP_2        0x200
#define SP_3        0x400
#define SP_4        0x800
#define SP_5        0x1000
#define SP_6        0x2000
#define SP_7        0x4000
#define SP_ROOT     (SP_1 | SP_2 | SP_3 | SP_4 | SP_5 | SP_6 | SP_7)
#define SP_CADENCE  0x8000

/*  Band member mute flags =============================================*/

#define MUTE_MELODY   0x0001   // Use MUTE flags with sctSetMutes()
#define MUTE_STRING   0x0002
#define MUTE_GUITAR   0x0004
#define MUTE_PIANO    0x0008
#define MUTE_BASS     0x0010
#define MUTE_DRUM     0x0020
#define MUTE_ALL      0xFFFF

/*  SCTchord bBits flags ===============================================*/

#define CHORD_INVERT  0x10      /* This chord may be inverted           */
#define CHORD_FOUR    0x20      /* This should be a 4 note chord        */
#define CHORD_UPPER   0x40      /* Shift upper octave down              */
#define CHORD_SIMPLE  0x80      /* This is a simple chord               */
#define CHORD_COUNT   0x0F      /* Number of notes in chord (up to 15)  */

/*  MIDI status bytes ==================================================*/

#define MIDI_NOTEOFF    0x80
#define MIDI_NOTEON     0x90
#define MIDI_PTOUCH     0xA0
#define MIDI_CCHANGE    0xB0
#define MIDI_PCHANGE    0xC0
#define MIDI_MTOUCH     0xD0
#define MIDI_PBEND      0xE0
#define MIDI_SYSX       0xF0
#define MIDI_MTC        0xF1
#define MIDI_SONGPP     0xF2
#define MIDI_SONGS      0xF3
#define MIDI_EOX        0xF7
#define MIDI_CLOCK      0xF8
#define MIDI_START      0xFA
#define MIDI_CONTINUE   0xFB
#define MIDI_STOP       0xFC
#define MIDI_SENSE      0xFE

// Options for sctComposeTransitionEx

#define TRANS_CHANGE    1   // Chord transitions to next section instead of resolving
#define TRANS_LONG      2   // Transition lasts two measures, not one

/*  Structures maintained by SuperJAM! Technology Engine ==============*/

#pragma pack(1)

typedef struct SCTchord     FAR *LPSCTCHORD ;
typedef struct SCTchord
{
    LPSCTCHORD      pNext;         /* The next chord in the list.      */
    long            lDLL1;          /*   Reserved for use by score.dll  */
    long            lPattern;       /* Pattern that defines chord.      */
    char            achName[12];    /* Chord name.                      */
    char            chDLL2;         /*   Reserved for use by score.dll  */
    char            chRoot;         /* Root note of chord.              */
    char            chDLL3;         /*   Reserved for use by score.dll  */
    char            chFlat;         /* Indicates root is flat.          */
    short           nDLL4;          /*   Reserved for use by score.dll  */
    short           nMeasure;       /* Measure this chord occurs.       */
    char            chBeat;         /* Beat this chord falls on.        */
    BYTE            bBits;          /* Flags used when playing chord    */
    long            lScalePattern;  /* Scale Pattern for the chord.     */
    long            lMelodyPattern; /* Melody Pattern for the chord.    */
} SCTchord ;

typedef struct SCTpersonality FAR *LPSCTPERSONALITY ;
typedef struct SCTpersonality
{
    LPSCTPERSONALITY pNext ;       /* Next SCTpersonality in the list. */
    char        achName[20] ;       /* Name of composition personality. */
    char        achDescription[80];/* Description of personality.      */
    char        achUserName[20];/* Description of personality.      */
    LPVOID      lpDLL1 ;            /*   Reserved for use by score.dll  */
    long        lScalePattern ;     /* Scale pattern used by personality*/
    SCTchord    chord[24] ;         /* 24 note chord palette.           */
    char        chDefault ;         /* 0=Not default. 1=Default.        */
    char        chDLL1 ;            /*  Reserved for use by score.dll   */
} SCTpersonality ;

typedef struct SCTstyle     FAR *LPSCTSTYLE ;
typedef struct SCTstyle
{
    LPSCTSTYLE   pNext ;           /* Pointer to next SCTstyle.        */
    LPSTR        lpszFileName ;     /* File name of style.              */
    LPSTR        lpszName ;         /* Style name.                      */
    LPVOID       lpDLL1 ;           /*   Reserved for use by score.dll  */
    LPSCTPERSONALITY lpSCTpersonalityList ;  /* Available personalities.*/
    short        nBeatNote ;        /* Note receiving one beat.         */
    short        nBeatsPerMeasure ; /* Beats per measure.               */
    short        nMusicTimePerBeat ;/* Music time per beat.             */
    short        nClicksPerMeasure ;/* Clicks per measure.              */
    short        nMusicTimePerClick;/* Music time per click.            */
    short        nClicksPerBeat ;   /* Clicks per beat.                 */
    short        nDefaultTempo ;    /* Style's default tempo.           */
    void*        pIStyle;           // pointer to interface, used by AA 2.0+
} SCTstyle ;

typedef struct SCTrealtime  FAR *LPSCTREALTIME ;
typedef struct SCTrealtime
{
    short         nSizeofStruct ;   /* sizeof(struct SCTrealtime)       */
    LPSCTSTYLE    lpSCTstyle ;      /* Style played by house band       */
    LPSCTPERSONALITY lpSCTpersonality ;  /* Active personality          */
    short         nTempo ;          /* Current tempo                    */
    WORD          wTempoFract ;     /* Current tempo fraction (0-65535) */
    DWORD         dwGroove ;        /* Current groove                   */
    char          chRoot ;          /* Root note of key                 */
    char          chFlat ;          /* Indicates whether key is flat    */
    char          chAutoChord ;     /* 0=Off, 1=On                      */
    char          chAutoChordActivity ;  /* Amount of chord activity    */
} SCTrealtime ;

typedef struct SCTsectionInfo FAR *LPSCTSECTIONINFO ;
typedef struct SCTsectionInfo
{
    short         nSizeofStruct ;   /* sizeof(struct SCTsectionInfo)    */
    char          achName[16] ;     /* Section name.                    */
    LPSCTSTYLE    lpSCTstyle ;      /* Style played by the section.     */
    LPSCTPERSONALITY lpSCTpersonality ;  /* Active personality.         */
    short         nTempo ;          /* Section tempo.                   */
    WORD          wTempoFract ;     /* Section tempo fraction (0-65535) */
    short         nNbrMeasures ;    /* Nbr of measures in section.      */
    WORD          nNbrRepeats ;     /* Nbr of times section repeats.    */
    char          chRoot ;          /* Root note of section key.        */
    char          chFlat ;          /* Indicates whether key is flat.   */
} SCTsectionInfo ;

typedef struct SCTperformance FAR *LPSCTPERFORMANCE ;

typedef struct SCTsection     FAR *LPSCTSECTION ;
typedef struct SCTsection
{
    LPSCTSECTION     pNext ;          /* Pointer to next SCTsection      */
    LPSTR            lpszName ;        /* Section name.                   */
    LPVOID           lpDLL1 ;          /*   Reserved for use by score.dll */
    LPSCTPERFORMANCE lpSCTperf ;       /* Section belongs to this perf.   */
    LPSCTSTYLE       lpSCTstyle ;      /* Style played by the section.    */
    LPSCTPERSONALITY lpSCTpersonality ;/* Active personality.             */
    short            nTempo ;          /* Section tempo.                  */
    WORD             wTempoFract ;     /* Section tempo fraction (0-65535)*/
    short            nStartingMeasure ;/* Starting measure of section.    */
    short            nNbrMeasures ;    /* Nbr of measures in section.     */
    WORD             nNbrRepeats ;     /* Nbr of times section repeats.   */
    char             chRoot ;          /* Root note of section key.       */
    char             chFlat ;          /* Indicates whether key is flat   */
    long             lStartTime ;      /* Music start time of section.    */
    void*            pISection;        // pointer to interface, used by AA 2.0+
} SCTsection ;

//DM
typedef struct SCTmotif* LPSCTMOTIF;
typedef struct SCTmotif
{
    LPSCTMOTIF  pNext;
    LPVOID      lpDLL1;
    LPCSTR      lpszName;
    short       nMeasures;
    short       nBeatsPerMeasure;
    short       nClicksPerBeat;
} SCTmotif;
//DM - END

typedef struct SCTperformance
{
    LPSCTPERFORMANCE pNext ;          /* Pointer to next SCTperformance.*/
//    char             achSongName[20] ; /* Name of song.                  */
    LPSCTREALTIME    lpSCTrealtime ;   /* RealTime information.          */
    LPVOID           lpDLL1 ;          /*   Reserved for use by score.dll*/
//    short            nRelVolume ;      /* Relative volume.               */
//    short            nRelTempo ;       /* Relative tempo.                */
//    LPSTR            lpszSongTitle;
//    LPSTR            lpszSongAuthor;
//    LPSTR            lpszSongCopyright;
} SCTperformance ;

typedef struct SCTdata      FAR *LPSCTDATA ;
typedef struct SCTdata
{
    LPSCTSTYLE       lpSCTstyleList ;  /* List of opened styles.       */
    LPSCTPERFORMANCE lpSCTperformanceList ; /* List of performances.   */
//DM
    LPSCTMOTIF  lpSCTmotif;            // pointer to list of motifs
// DM - END
} SCTdata ;

typedef struct SCTcommand   FAR *LPSCTCOMMAND ;
typedef struct SCTcommand
{
    LPSCTCOMMAND  pNext ;    /* The next command in the list.    */
    long          lDLL1 ;     /*   Reserved for use by score.dll. */
    short         nMeasure ;  /* Measure this command occurs.     */
    DWORD         dwCommand ; /* Command type.                    */
    DWORD         dwChord ;   /* Signpost chord.                  */
} SCTcommand ;

typedef struct SCTtemplate  FAR *LPSCTTEMPLATE ;
typedef struct SCTtemplate
{
    LPSCTTEMPLATE pNext ;           /* The next template in the list.  */
    char          achName[20] ;      /* Template name.                  */
    char          achType[20] ;      /* Template type.                  */
    short         nMeasures ;
    LPSCTCOMMAND  lpSCTcommandList ; /* Template commands.              */
} SCTtemplate ;

#pragma pack()

/*  Function prototypes ============================================*/

LPSCTDATA WINAPI sctRegisterApplication(HWND,HWND,HINSTANCE,LPCSTR,LPDWORD,short);
void WINAPI sctUnregisterApplication(LPSCTDATA);

LPSCTSECTIONINFO WINAPI sctAllocSectionInfo(LPSCTPERFORMANCE,short);
void WINAPI sctFreeSectionInfo(LPSCTDATA,LPSCTSECTIONINFO);

DWORD WINAPI sctTimeToMeasure(LPSCTDATA,LPSCTSTYLE,DWORD);
DWORD WINAPI sctTimeToMils(LPSCTDATA,DWORD,short,unsigned short);

LPSCTCHORD WINAPI sctAllocChord(LPSCTDATA);
void WINAPI sctFreeChord(LPSCTDATA,LPSCTCHORD);
void WINAPI sctFreeChordList(LPSCTDATA,LPSCTCHORD);

LPSCTCHORD WINAPI sctGetChordListCopy(LPSCTDATA,LPSCTSECTION);
BOOL WINAPI sctSetChordList(LPSCTDATA,LPSCTSECTION,LPSCTCHORD);

void WINAPI sctFreeCommandList(LPSCTDATA,LPSCTCOMMAND);

LPSCTCOMMAND WINAPI sctGetCommandListCopy(LPSCTDATA,LPSCTSECTION);
BOOL WINAPI sctSetCommandList(LPSCTDATA,LPSCTSECTION,LPSCTCOMMAND);

LPSCTTEMPLATE WINAPI sctAllocTemplate(LPSCTDATA);
void WINAPI sctFreeTemplate(LPSCTDATA,LPSCTTEMPLATE);
BOOL WINAPI sctCreateTemplateSignPosts(LPSCTDATA,LPSCTTEMPLATE);
BOOL WINAPI sctCreateTemplateEmbellishments(LPSCTDATA,LPSCTTEMPLATE,short);

BOOL WINAPI sctBuildSection(LPSCTDATA,LPSCTSECTION,LPSCTPERSONALITY,short,short,short,DWORD);
BOOL WINAPI sctComposeSection(LPSCTDATA,LPSCTSECTION,LPSCTTEMPLATE,LPSCTPERSONALITY,short);
BOOL WINAPI sctComposeTransition(LPSCTDATA,LPSCTSECTION,LPSCTPERSONALITY,LPSCTCHORD,short,DWORD);
LPSCTSECTION WINAPI sctComposeTransitionEx( LPSCTDATA, LPSCTSECTION, LPSCTSECTION, short, DWORD, DWORD );

LPSCTSECTION WINAPI sctCreateSection(LPSCTPERFORMANCE,LPSCTSECTIONINFO);
void WINAPI sctDeleteSection(LPSCTDATA,LPSCTSECTION, BOOL fStop = TRUE);
LPSCTSECTION WINAPI sctDuplicateSection(LPSCTDATA,LPSCTSECTION);
BOOL WINAPI sctQueueSectionEx( LPSCTDATA lpSCTdata, LPSCTSECTION lpSCTsection, DWORD dwStartTime );
BOOL WINAPI sctSectionCommand(LPSCTDATA,LPSCTSECTION,WORD,WORD,LONG,LONG);
BOOL WINAPI sctStopCurSectionASAP(LPSCTDATA);
BOOL WINAPI sctStopCurSection(LPSCTDATA,short);

LPSCTPERFORMANCE WINAPI sctCreatePerformance(LPSCTDATA,LPVOID);

//DM
BOOL WINAPI sctFreeMotif( LPSCTDATA, LPSCTMOTIF );

BOOL WINAPI sctSwitchPersonality( LPSCTDATA, LPSCTSECTION, LPSCTPERSONALITY, BOOL );

BOOL WINAPI sctSetQueuePrepareTime( WORD wPrepareTime );
//DM - END

#endif // __SCORE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\segtrtrk.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of CSegTriggerTrack.
//

#include "dmime.h"
#include "segtrtrk.h"
#include "Validate.h"
#include "dmperf.h"
#include "miscutil.h"

//////////////////////////////////////////////////////////////////////
// SetParam

STDMETHODIMP
CSegTriggerTrack::SetParam(REFGUID rguid, MUSIC_TIME mtTime, void *pData)
{
	HRESULT hr = S_OK;
    // Allow a certain amount of recursion. If it gets to 10, something is obviously broken.
    if (m_dwRecursionCount < 10)
    {
        m_dwRecursionCount++;
	    TListItem<TriggerInfo> *li = m_EventList.GetHead();
	    for (; li; li = li->GetNext())
	    {
		    TriggerInfo &rinfo = li->GetItemValue();
		    rinfo.pIDMSegment->SetParam(rguid, 0xFFFFFFFF, DMUS_SEG_ALLTRACKS, mtTime - rinfo.lTimePhysical, pData);
	    }
        m_dwRecursionCount--;
    }

	return hr;
}

STDMETHODIMP
CSegTriggerTrack::InitPlay(
		IDirectMusicSegmentState *pSegmentState,
		IDirectMusicPerformance *pPerformance,
		void **ppStateData,
		DWORD dwTrackID,
		DWORD dwFlags)
{
	// Call PlayingTrack base class, which sets up our state data.
	HRESULT hr = CSegTriggerTrackBase::InitPlay(pSegmentState, pPerformance, ppStateData, dwTrackID, dwFlags);
	if (SUCCEEDED(hr))
	{
		// Get the audiopath being used by our segment state and save it in our state data.
		assert(*ppStateData); // base class should have created state data
		assert(pSegmentState); // base class should have returned E_POINTER if it wasn't given a segment state

		CSegTriggerTrackState *pState = static_cast<CSegTriggerTrackState *>(*ppStateData);

		IDirectMusicSegmentState8 *pSegSt8 = NULL;
		hr = pSegmentState->QueryInterface(IID_IDirectMusicSegmentState8, reinterpret_cast<void**>(&pSegSt8));
		if (SUCCEEDED(hr))
		{
			hr = pSegSt8->GetObjectInPath(
							0,							// pchannel doesn't apply
							DMUS_PATH_AUDIOPATH,		// get the audiopath
							0,							// buffer index doesn't apply
							CLSID_NULL,					// clsid doesn't apply
							0,							// there should be only one audiopath
							IID_IDirectMusicAudioPath,
							reinterpret_cast<void**>(&pState->pAudioPath));

        	pSegSt8->Release();

			// If this doesn't find an audiopath that's OK.  If we're not playing on an audiopath then
			// pAudioPath stays NULL and we'll play our triggered segments on the general performance.
			if (hr == DMUS_E_NOT_FOUND)
				hr = S_OK;
		}
	}
	return hr;
}

//////////////////////////////////////////////////////////////////////
// Load

// Helper used by the Load functions when we expected to find something
// but a RiffIter becomes false.  In this case, if it has a success HR
// indicating there were no more items then we return DMUS_E_INVALID_SEGMENTTRIGGERTRACK
// because the stream didn't contain the data we expected.  If it has a
// failure hr, it was unable to read from the stream and we return its HR.
HRESULT LoadHrFailOK(const SmartRef::RiffIter &ri)
{
	HRESULT hr = ri.hr();
	return SUCCEEDED(hr) ? DMUS_E_INVALID_SEGMENTTRIGGERTRACK : hr;
};

HRESULT
CSegTriggerTrack::LoadRiff(SmartRef::RiffIter &ri, IDirectMusicLoader *pIDMLoader)
{
	HRESULT hr = S_OK;

	if (!ri.Find(SmartRef::RiffIter::List, DMUS_FOURCC_SEGTRACK_LIST))
	{
#ifdef DBG
		if (SUCCEEDED(ri.hr()))
		{
			Trace(1, "Error: Unable to load segment trigger track: List 'segt' not found.\n");
		}
#endif
		return LoadHrFailOK(ri);
	}

	SmartRef::RiffIter riTrackForm = ri.Descend();
	if (!riTrackForm)
		return riTrackForm.hr();

	for ( ; riTrackForm; ++riTrackForm)
	{
		if (riTrackForm.type() == SmartRef::RiffIter::Chunk)
		{
			if (riTrackForm.id() == DMUS_FOURCC_SEGTRACK_CHUNK)
			{
				DMUS_IO_SEGMENT_TRACK_HEADER ioItem;
				hr = SmartRef::RiffIterReadChunk(riTrackForm, &ioItem);
				if (FAILED(hr))
					return hr;

				m_dwFlags = ioItem.dwFlags;
			}
		}
		else if (riTrackForm.type() == SmartRef::RiffIter::List)
		{
			if (riTrackForm.id() == DMUS_FOURCC_SEGMENTS_LIST)
			{
				SmartRef::RiffIter riSegList = riTrackForm.Descend();
				while (riSegList && riSegList.Find(SmartRef::RiffIter::List, DMUS_FOURCC_SEGMENT_LIST))
				{
					hr = LoadTrigger(riSegList.Descend(), pIDMLoader);
					if (FAILED(hr))
						return hr;
					++riSegList;
				}
				hr = riSegList.hr();
				if (FAILED(hr))
					return hr;
			}
		}
	}
	return riTrackForm.hr();
}

//////////////////////////////////////////////////////////////////////
// other methods

HRESULT
CSegTriggerTrack::PlayItem(
		const TriggerInfo &item,
		statedata &state,
		IDirectMusicPerformance *pPerf,
		IDirectMusicSegmentState* pSegSt,
		DWORD dwVirtualID,
		MUSIC_TIME mtOffset,
		REFERENCE_TIME rtOffset,
		bool fClockTime)
{
	IDirectMusicPerformance8 *pPerf8 = NULL;
	HRESULT hr = pPerf->QueryInterface(IID_IDirectMusicPerformance8, reinterpret_cast<void**>(&pPerf8));
	if (FAILED(hr))
		return hr;

	hr = pPerf8->PlaySegmentEx(
					item.pIDMSegment,
					NULL,														// not a song
					NULL,														// no transition
					item.dwPlayFlags | (fClockTime ? DMUS_SEGF_REFTIME : 0),	// flags
					fClockTime
						? item.lTimePhysical * REF_PER_MIL + rtOffset
						: item.lTimePhysical + mtOffset,						// time
					NULL,														// ignore returned segment state
					NULL,														// no replacement
					state.pAudioPath											// audio path to use (may be NULL indicating defualt)
					);
	pPerf8->Release();
    if (FAILED(hr))
    {
        Trace(0,"Segment Trigger Track failed segment playback\n");
        hr = S_OK; // Avoid an assert.
    }
	return hr;
}

HRESULT
CSegTriggerTrack::LoadTrigger(
		SmartRef::RiffIter ri,
		IDirectMusicLoader *pIDMLoader)
{
	HRESULT hr = S_OK;

	if (!ri)
		return ri.hr();

	// Create an event
	TListItem<TriggerInfo> *pItem = new TListItem<TriggerInfo>;
	if (!pItem)
		return E_OUTOFMEMORY;
	TriggerInfo &rinfo = pItem->GetItemValue();

	// find the item header (we can't interpret the other chunks until we've found it)
	if (!ri.Find(SmartRef::RiffIter::Chunk, DMUS_FOURCC_SEGMENTITEM_CHUNK))
    {
        delete pItem;
#ifdef DBG
		if (SUCCEEDED(ri.hr()))
		{
			Trace(1, "Error: Unable to load segment trigger track: Chunk 'sgih' not found.\n");
		}
#endif
		return LoadHrFailOK(ri);
    }

	// read the header
	DMUS_IO_SEGMENT_ITEM_HEADER ioItem;
	hr = SmartRef::RiffIterReadChunk(ri, &ioItem);
	if (FAILED(hr))
    {
        delete pItem;
		return hr;
    }
	rinfo.lTriggerTime = ioItem.lTimeLogical;
	rinfo.lTimePhysical = ioItem.lTimePhysical;
	rinfo.dwPlayFlags = ioItem.dwPlayFlags;
	rinfo.dwFlags = ioItem.dwFlags;
	++ri;
	if (!ri)
	{
		// If there's nothing more then this is an empty trigger we should ignore because the user hasn't specified
		// the style or segment to play from.
		delete pItem;
		return ri.hr();
	}

	if (!(rinfo.dwFlags & DMUS_SEGMENTTRACKF_MOTIF))
	{
		// find the referenced segment
		if (!ri.Find(SmartRef::RiffIter::List, DMUS_FOURCC_REF_LIST))
		{
			// If there's no DMRF then we should ignore this trigger because the user hasn't specified a segment.
			delete pItem;
			return ri.hr();
        }

		hr = ri.LoadReference(pIDMLoader, IID_IDirectMusicSegment, reinterpret_cast<void**>(&rinfo.pIDMSegment));
		if (FAILED(hr))
        {
            delete pItem;
			return hr;
        }
	}
	else
	{
		// find the segment from the referenced style and motif name
		SmartRef::ComPtr<IDirectMusicStyle> scomStyle;
		SmartRef::Buffer<WCHAR> wbufMotifName;
		for ( ; ri; ++ri)
		{
			if (ri.type() == SmartRef::RiffIter::List)
			{
				if (ri.id() == DMUS_FOURCC_REF_LIST)
				{
					hr = ri.LoadReference(pIDMLoader, IID_IDirectMusicStyle, reinterpret_cast<void**>(&scomStyle));
					if (FAILED(hr))
                    {
                        delete pItem;
						return hr;
                    }
				}
			}
			else if (ri.type() == SmartRef::RiffIter::Chunk)
			{
				if (ri.id() == DMUS_FOURCC_SEGMENTITEMNAME_CHUNK)
				{
					hr = ri.ReadText(&wbufMotifName);
					if (FAILED(hr))
                    {
                        delete pItem;
#ifdef DBG
						if (hr == E_FAIL)
						{
							Trace(1, "Error: Unable to load segment trigger track: Problem reading 'snam' chunk.\n");
						}
#endif
						return hr == E_FAIL ? DMUS_E_INVALID_SEGMENTTRIGGERTRACK : hr;
                    }
				}
			}
		}
		hr = ri.hr();
		if (FAILED(hr))
        {
            delete pItem;
			return hr;
        }

		if (!(scomStyle && wbufMotifName))
		{
			// This happens if the track didn't contain a DMRF list or snam chunk.	We allow
			// this as a means of representing an empty trigger track item or where the
			// motif to play hasn't been specified.  When loading we'll simply ignore
			// this item and continue reading the track.
			delete pItem;
			return S_OK;
		}

		hr = scomStyle->GetMotif(wbufMotifName, &rinfo.pIDMSegment);
		if (hr == S_FALSE)
		{
			Trace(1, "Error: The segment trigger track couldn't load because the motif %S was not found in the style.\n", wbufMotifName);
			hr = DMUS_E_NOT_FOUND;
		}
		if (FAILED(hr))
        {
            delete pItem;
			return hr;
        }
	}

	m_EventList.AddHead(pItem);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\seqtrack.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
// SeqTrack.h : Declaration of the CSeqTrack

#ifndef __SEQTRACK_H_
#define __SEQTRACK_H_

#include "dmusici.h"
#include "dmusicf.h"
#include "tlist.h"
#include "PChMap.h"

struct SeqStateData
{
	DWORD						dwPChannelsUsed; // number of PChannels
	// the following two arrays are allocated to the size of dwNumPChannels, which
	// must match the SeqTrack's m_dwPChannelsUsed. The arrays match one-for-one with
	// the parts inside the SeqTrack.
	TListItem<DMUS_IO_SEQ_ITEM>**	apCurrentSeq; // array of size dwNumPChannels
	TListItem<DMUS_IO_CURVE_ITEM>**	apCurrentCurve; // array of size dwNumPChannels
	DWORD						dwValidate;
	MUSIC_TIME					mtCurTimeSig; // time the current timesig started
	MUSIC_TIME					mtNextTimeSig; // time for the next timesig
	DWORD						dwMeasure; // starting measure # of the timesig
	DWORD						dwlnBeat; // length of a beat
	DWORD						dwlnMeasure; // length of a measure
	DWORD						dwlnGrid; // length of a grid
	DWORD						dwGroupBits; // the group bits of this track

	SeqStateData()
	{
		mtCurTimeSig = 0;
		mtNextTimeSig = 0;
		dwMeasure = 0;
		dwlnBeat = DMUS_PPQ;
		dwlnMeasure = DMUS_PPQ * 4;
		dwlnGrid = DMUS_PPQ / 4;
		apCurrentSeq = NULL;
		apCurrentCurve = NULL;
	}
	~SeqStateData()
	{
		if( apCurrentSeq )
		{
			delete [] apCurrentSeq;
		}
		if( apCurrentCurve )
		{
			delete [] apCurrentCurve;
		}
	}
};

// SEQ_PART represents all of the DMUS_PMSG's inside the SeqTrack for one PChannel
struct SEQ_PART
{
	SEQ_PART*			pNext;
	DWORD				dwPChannel;
	TList<DMUS_IO_SEQ_ITEM>	seqList;
	TList<DMUS_IO_CURVE_ITEM>	curveList;

	SEQ_PART() : pNext(NULL) {}; // always initialize pNext to NULL
};

/////////////////////////////////////////////////////////////////////////////
// CSeqTrack
class CSeqTrack : 
	public IPersistStream,
	public IDirectMusicTrack8
{
public:
	CSeqTrack();
	CSeqTrack(
		const CSeqTrack& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd);
	~CSeqTrack();

public:
// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

// IDirectMusicTrack methods
    STDMETHODIMP IsParamSupported(REFGUID rguid);
    STDMETHODIMP Init(IDirectMusicSegment *pSegment);
    STDMETHODIMP InitPlay(IDirectMusicSegmentState *pSegmentState,
                IDirectMusicPerformance *pPerformance,
                void **ppStateData,
                DWORD dwTrackID,
                DWORD dwFlags);
    STDMETHODIMP EndPlay(void *pStateData);
    STDMETHODIMP Play(void *pStateData,MUSIC_TIME mtStart,
                MUSIC_TIME mtEnd,MUSIC_TIME mtOffset,
		        DWORD dwFlags,IDirectMusicPerformance* pPerf,
		        IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID);
    STDMETHODIMP GetParam(REFGUID rguid,MUSIC_TIME mtTime,MUSIC_TIME* pmtNext,void *pData);
    STDMETHODIMP SetParam(REFGUID rguid,MUSIC_TIME mtTime,void *pData);
    STDMETHODIMP AddNotificationType(REFGUID rguidNotification);
    STDMETHODIMP RemoveNotificationType(REFGUID rguidNotification);
    STDMETHODIMP Clone(MUSIC_TIME mtStart,MUSIC_TIME mtEnd,IDirectMusicTrack** ppTrack);
// IDirectMusicTrack8 
    STDMETHODIMP PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf, 
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) ; 
    STDMETHODIMP GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) ; 
    STDMETHODIMP SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,void* pParam, void * pStateData, DWORD dwFlags) ;
    STDMETHODIMP Compose(IUnknown* pContext, 
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;
    STDMETHODIMP Join(IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		IUnknown* pContext,
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;
// IPersist functions
    STDMETHODIMP GetClassID( CLSID* pClsId );
// IPersistStream functions
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load( IStream* pIStream );
    STDMETHODIMP Save( IStream* pIStream, BOOL fClearDirty );
    STDMETHODIMP GetSizeMax( ULARGE_INTEGER FAR* pcbSize );

protected:
	HRESULT STDMETHODCALLTYPE Seek( 
		IDirectMusicSegmentState*,
		IDirectMusicPerformance*,
		DWORD dwVirtualID,
		SeqStateData*,
		MUSIC_TIME mtTime,
		BOOL fGetPrevious,
		MUSIC_TIME mtOffset,
        REFERENCE_TIME rtOffset,
        BOOL fClockTime);
	void SendSeekItem( 
		IDirectMusicPerformance*,
		IDirectMusicGraph*,
		IDirectMusicSegmentState*,
		SeqStateData* pSD,
		DWORD dwVirtualID,
		MUSIC_TIME mtTime,
		MUSIC_TIME mtOffset,
        REFERENCE_TIME rtOffset,
		TListItem<DMUS_IO_SEQ_ITEM>*,
		TListItem<DMUS_IO_CURVE_ITEM>*,
        BOOL fClockTime);
    HRESULT Play(
        void *pStateData,	
        MUSIC_TIME mtStart,	
        MUSIC_TIME mtEnd,
        MUSIC_TIME mtOffset,
        REFERENCE_TIME rtOffset,
	    DWORD dwFlags,		
	    IDirectMusicPerformance* pPerf,	
	    IDirectMusicSegmentState* pSegSt,
	    DWORD dwVirtualID,
        BOOL fClockTime);
	void Construct(void);
	HRESULT LoadCurve( IStream* pIStream, long lSize );
	HRESULT LoadSeq( IStream* pIStream, long lSize );
	void UpdateTimeSig(IDirectMusicSegmentState*, SeqStateData* pSD, MUSIC_TIME mt);
	TListItem<SEQ_PART>* FindPart( DWORD dwPChannel );
	void DeleteSeqPartList(void);
	void SetUpStateCurrentPointers(SeqStateData* pStateData);

// member variables
private:
	TList<SEQ_PART>			m_SeqPartList;
	TListItem<SEQ_PART>*	m_pSeqPartCache;	// used to time-optimize FindPart()
	DWORD					m_dwPChannelsUsed;
	DWORD*					m_aPChannels;
	long					m_cRef;
	DWORD					m_dwValidate; // used to validate state data
	CRITICAL_SECTION		m_CrSec;
    BOOL                    m_fCSInitialized;
	CPChMap					m_PChMap;
};

#endif //__SEQTRACK_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\seqtrack.cpp ===
//
// seqtrack.cpp
//
// Copyright (c) 1998-2001 Microsoft Corporation
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
#pragma warning(disable:4530)

// SeqTrack.cpp : Implementation of CSeqTrack
#include "dmime.h"
#include "dmperf.h"
#include "SeqTrack.h"
#include "dmusici.h"
#include "dmusicf.h"
#include "debug.h"
#include "Validate.h"
#include "debug.h"
#define ASSERT assert

// @doc EXTERNAL
#define MIDI_NOTEOFF    0x80
#define MIDI_NOTEON     0x90
#define MIDI_PTOUCH     0xA0
#define MIDI_CCHANGE    0xB0
#define MIDI_PCHANGE    0xC0
#define MIDI_MTOUCH     0xD0
#define MIDI_PBEND      0xE0
#define MIDI_SYSX       0xF0
#define MIDI_MTC        0xF1
#define MIDI_SONGPP     0xF2
#define MIDI_SONGS      0xF3
#define MIDI_EOX        0xF7
#define MIDI_CLOCK      0xF8
#define MIDI_START      0xFA
#define MIDI_CONTINUE   0xFB
#define MIDI_STOP       0xFC
#define MIDI_SENSE      0xFE
#define MIDI_CC_BS_MSB  0x00
#define MIDI_CC_BS_LSB  0x20

/////////////////////////////////////////////////////////////////////////////
// CSeqTrack
void CSeqTrack::Construct()
{
    InterlockedIncrement(&g_cComponent);

    m_pSeqPartCache = NULL;
    m_dwPChannelsUsed = 0;
    m_aPChannels = NULL;
    m_dwValidate = 0;
    m_fCSInitialized = FALSE;
    InitializeCriticalSection(&m_CrSec);
    m_fCSInitialized = TRUE;
    m_cRef = 1;
}

CSeqTrack::CSeqTrack()
{
    Construct();
}

CSeqTrack::CSeqTrack(
        const CSeqTrack& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd)
{
    Construct();
    m_dwPChannelsUsed = rTrack.m_dwPChannelsUsed;
    if( m_dwPChannelsUsed )
    {
        m_aPChannels = new DWORD[m_dwPChannelsUsed];
        if (m_aPChannels)
        {
            memcpy( m_aPChannels, rTrack.m_aPChannels, sizeof(DWORD) * m_dwPChannelsUsed );
        }
    }

    TListItem<SEQ_PART>* pPart = rTrack.m_SeqPartList.GetHead();
    for( ; pPart; pPart = pPart->GetNext() )
    {
        TListItem<SEQ_PART>* pNewPart = new TListItem<SEQ_PART>;
        if( pNewPart )
        {
            pNewPart->GetItemValue().dwPChannel = pPart->GetItemValue().dwPChannel;
            TListItem<DMUS_IO_SEQ_ITEM>* pScan = pPart->GetItemValue().seqList.GetHead();

            for(; pScan; pScan = pScan->GetNext())
            {
                DMUS_IO_SEQ_ITEM& rScan = pScan->GetItemValue();
                if( rScan.mtTime < mtStart )
                {
                    continue;
                }
                if (rScan.mtTime < mtEnd)
                {
                    TListItem<DMUS_IO_SEQ_ITEM>* pNew = new TListItem<DMUS_IO_SEQ_ITEM>;
                    if (pNew)
                    {
                        DMUS_IO_SEQ_ITEM& rNew = pNew->GetItemValue();
                        memcpy( &rNew, &rScan, sizeof(DMUS_IO_SEQ_ITEM) );
                        rNew.mtTime = rScan.mtTime - mtStart;
                        pNewPart->GetItemValue().seqList.AddHead(pNew); // AddTail can get expensive (n^2), so
                                                    // AddHead instead and Reverse later.
                    }
                }
                else break;
            }
            pNewPart->GetItemValue().seqList.Reverse(); // since we AddHead'd earlier.

            TListItem<DMUS_IO_CURVE_ITEM>* pScanCurve = pPart->GetItemValue().curveList.GetHead();

            for(; pScanCurve; pScanCurve = pScanCurve->GetNext())
            {
                DMUS_IO_CURVE_ITEM& rScan = pScanCurve->GetItemValue();
                if( rScan.mtStart < mtStart )
                {
                    continue;
                }
                if (rScan.mtStart < mtEnd)
                {
                    TListItem<DMUS_IO_CURVE_ITEM>* pNew = new TListItem<DMUS_IO_CURVE_ITEM>;
                    if (pNew)
                    {
                        DMUS_IO_CURVE_ITEM& rNew = pNew->GetItemValue();
                        memcpy( &rNew, &rScan, sizeof(DMUS_IO_CURVE_ITEM) );
                        rNew.mtStart = rScan.mtStart - mtStart;
                        pNewPart->GetItemValue().curveList.AddHead(pNew); // AddTail can get expensive (n^2), so
                                                    // AddHead instead and Reverse later.
                    }
                }
                else break;
            }
            pNewPart->GetItemValue().curveList.Reverse(); // since we AddHead'd earlier.
            m_SeqPartList.AddHead(pNewPart);
        }
        m_SeqPartList.Reverse();
    }
}

CSeqTrack::~CSeqTrack()
{
    if (m_fCSInitialized)
    {
        DeleteSeqPartList();                // This will be empty if critical section
                                            // never got initialized.
        DeleteCriticalSection(&m_CrSec);
    }

    InterlockedDecrement(&g_cComponent);
}

// @method:(INTERNAL) HRESULT | IDirectMusicTrack | QueryInterface | Standard QueryInterface implementation for <i IDirectMusicSeqTrack>
//
// @rdesc Returns one of the following:
//
// @flag S_OK | If the interface is supported and was returned
// @flag E_NOINTERFACE | If the object does not support the given interface.
// @flag E_POINTER | <p ppv> is NULL or invalid.
//
STDMETHODIMP CSeqTrack::QueryInterface(
    const IID &iid,   // @parm Interface to query for
    void **ppv)       // @parm The requested interface will be returned here
{
    V_INAME(CSeqTrack::QueryInterface);
    V_PTRPTR_WRITE(ppv);
    V_REFGUID(iid);

   if (iid == IID_IUnknown || iid == IID_IDirectMusicTrack || iid == IID_IDirectMusicTrack8)
    {
        *ppv = static_cast<IDirectMusicTrack*>(this);
    } else
    if (iid == IID_IPersistStream)
    {
        *ppv = static_cast<IPersistStream*>(this);
    } else
    {
        *ppv = NULL;
        Trace(4,"Warning: Request to query unknown interface on Sequence Track\n");
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


// @method:(INTERNAL) HRESULT | IDirectMusicTrack | AddRef | Standard AddRef implementation for <i IDirectMusicSeqTrack>
//
// @rdesc Returns the new reference count for this object.
//
STDMETHODIMP_(ULONG) CSeqTrack::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


// @method:(INTERNAL) HRESULT | IDirectMusicTrack | Release | Standard Release implementation for <i IDirectMusicSeqTrack>
//
// @rdesc Returns the new reference count for this object.
//
STDMETHODIMP_(ULONG) CSeqTrack::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

/////////////////////////////////////////////////////////////////////////////
// IPersist

HRESULT CSeqTrack::GetClassID( CLSID* pClassID )
{
    V_INAME(CSeqTrack::GetClassID);
    V_PTR_WRITE(pClassID, CLSID);
    *pClassID = CLSID_DirectMusicSeqTrack;
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IPersistStream functions

HRESULT CSeqTrack::IsDirty()
{
    return S_FALSE;
}

/*

  method HRESULT | ISeqTrack | LoadSeq |
  Call this with an IStream filled with SeqEvents, sorted in time order.
  parm IStream* | pIStream |
  A stream of SeqEvents, sorted in time order. The seek pointer should point
  to the first event. The stream should contain only SeqEvents and nothing more.
  rvalue E_POINTER | If pIStream == NULL or invalid.
  rvalue S_OK | Success.
  comm The <p pIStream> will be AddRef'd inside this function and held
  until the SeqTrack is released.
*/
HRESULT CSeqTrack::LoadSeq( IStream* pIStream, long lSize )
{
    HRESULT hr = S_OK;
    TListItem<SEQ_PART>* pPart;

    EnterCriticalSection(&m_CrSec);

    // copy contents of the stream into the list.
    LARGE_INTEGER li;
    DMUS_IO_SEQ_ITEM seqEvent;
    DWORD dwSubSize;
    // read in the size of the data structures
    if( FAILED( pIStream->Read( &dwSubSize, sizeof(DWORD), NULL )))
    {
        Trace(1,"Error: Failure reading sequence track.\n");
        hr = DMUS_E_CANNOTREAD;
        goto END;
    }
    lSize -= sizeof(DWORD);

    DWORD dwRead, dwSeek;
    if( dwSubSize > sizeof(DMUS_IO_SEQ_ITEM) )
    {
        dwRead = sizeof(DMUS_IO_SEQ_ITEM);
        dwSeek = dwSubSize - dwRead;
        li.HighPart = 0;
        li.LowPart = dwSeek;
    }
    else
    {
        if( dwSubSize == 0 )
        {
            Trace(1,"Error: Failure reading sequence track.\n");
            hr = DMUS_E_CHUNKNOTFOUND;
            goto END;
        }
        dwRead = dwSubSize;
        dwSeek = 0;
    }
    if( 0 == dwRead )
    {
        hr = DMUS_E_CANNOTREAD;
        goto END;
    }
    while( lSize > 0 )
    {
        if( FAILED( pIStream->Read( &seqEvent, dwRead, NULL )))
        {
            Trace(1,"Error: Failure reading sequence track.\n");
            hr = DMUS_E_CANNOTREAD;
            goto END;
        }
        lSize -= dwRead;
        if( dwSeek )
        {
            if( FAILED( pIStream->Seek( li, STREAM_SEEK_CUR, NULL )))
            {
                hr = DMUS_E_CANNOTSEEK;
                goto END;
            }
            lSize -= dwSeek;
        }
        pPart = FindPart(seqEvent.dwPChannel);
        if( pPart )
        {
            TListItem<DMUS_IO_SEQ_ITEM>* pEvent = new TListItem<DMUS_IO_SEQ_ITEM>(seqEvent);
            if( pEvent )
            {
                pPart->GetItemValue().seqList.AddHead(pEvent); // AddTail can get
                                                            // expensive (n pow 2) so
                                                            // AddHead instead and reverse later.
            }
        }
    }
END:
    for( pPart = m_SeqPartList.GetHead(); pPart; pPart = pPart->GetNext() )
    {
        pPart->GetItemValue().seqList.Reverse(); // since we AddHead'd earlier
    }
    m_dwValidate++; // used to validate state data that's out there
    LeaveCriticalSection(&m_CrSec);
    return hr;
}

/*
  method HRESULT | LoadCurve
  Call this with an IStream filled with CurveEvents, sorted in time order.
  parm IStream* | pIStream |
  A stream of CurveEvents, sorted in time order. The seek pointer should point
  to the first event. The stream should contain only CurveEvents and nothing more.
  rvalue E_POINTER | If pIStream == NULL or invalid.
  rvalue S_OK | Success.
There are also other error codes.
  comm The <p pIStream> will be AddRef'd inside this function and held
  until the CurveTrack is released.
*/
HRESULT CSeqTrack::LoadCurve( IStream* pIStream, long lSize )
{
    HRESULT hr = S_OK;
    TListItem<SEQ_PART>* pPart;

    EnterCriticalSection(&m_CrSec);

    DWORD dwSubSize;
    // copy contents of the stream into the list.
    LARGE_INTEGER li;
    DMUS_IO_CURVE_ITEM curveEvent;
    // read in the size of the data structures
    if( FAILED( pIStream->Read( &dwSubSize, sizeof(DWORD), NULL )))
    {
        Trace(1,"Error: Failure reading sequence track.\n");
        hr = DMUS_E_CANNOTREAD;
        goto END;
    }
    lSize -= sizeof(DWORD);

    DWORD dwRead, dwSeek;
    if( dwSubSize > sizeof(DMUS_IO_CURVE_ITEM) )
    {
        dwRead = sizeof(DMUS_IO_CURVE_ITEM);
        dwSeek = dwSubSize - dwRead;
        li.HighPart = 0;
        li.LowPart = dwSeek;
    }
    else
    {
        if( dwSubSize == 0 )
        {
            Trace(1,"Error: Failure reading sequence track - bad data.\n");
            hr = DMUS_E_CHUNKNOTFOUND;
            goto END;
        }
        dwRead = dwSubSize;
        dwSeek = 0;
    }
    if( 0 == dwRead )
    {
        Trace(1,"Error: Failure reading sequence track - bad data.\n");
        hr = DMUS_E_CANNOTREAD;
        goto END;
    }
    while( lSize > 0 )
    {
        curveEvent.wMergeIndex = 0; // Older format doesn't support this.
        if( FAILED( pIStream->Read( &curveEvent, dwRead, NULL )))
        {
            hr = DMUS_E_CANNOTREAD;
            break;
        }
        lSize -= dwRead;
        if( dwSeek )
        {
            pIStream->Seek( li, STREAM_SEEK_CUR, NULL );
            lSize -= dwSeek;
        }
        pPart = FindPart(curveEvent.dwPChannel);
        if( pPart )
        {
            TListItem<DMUS_IO_CURVE_ITEM>* pEvent = new TListItem<DMUS_IO_CURVE_ITEM>(curveEvent);
            if( pEvent )
            {
                pPart->GetItemValue().curveList.AddHead(pEvent); // AddTail can get
                                                            // expensive (n pow 2) so
                                                            // AddHead instead and reverse later.
            }
        }
    }
END:
    for( pPart = m_SeqPartList.GetHead(); pPart; pPart = pPart->GetNext() )
    {
        pPart->GetItemValue().curveList.Reverse(); // since we AddHead'd earlier
    }
    m_dwValidate++; // used to validate state data that's out there
    LeaveCriticalSection(&m_CrSec);
    return hr;
}

HRESULT CSeqTrack::Load( IStream* pIStream )
{
    V_INAME(CSeqTrack::Load);
    V_INTERFACE(pIStream);
    HRESULT hr = S_OK;

    EnterCriticalSection(&m_CrSec);
    m_dwValidate++; // used to validate state data that's out there
    DeleteSeqPartList();
    LeaveCriticalSection(&m_CrSec);

    // read in the chunk id
    long lSize;
    DWORD dwChunk;
    if( FAILED( pIStream->Read( &dwChunk, sizeof(DWORD), NULL )))
    {
        Trace(1,"Error: Failure reading sequence track.\n");
        hr = DMUS_E_CANNOTREAD;
        goto END;
    }
    if( dwChunk != DMUS_FOURCC_SEQ_TRACK )
    {
        Trace(1,"Error: Failure reading sequence track - bad data.\n");
        hr = DMUS_E_CHUNKNOTFOUND;
        goto END;
    }
    // read in the overall size
    if( FAILED( pIStream->Read( &lSize, sizeof(long), NULL )))
    {
        hr = DMUS_E_CANNOTREAD;
        goto END;
    }
    while( lSize )
    {
        DWORD dwSubChunk, dwSubSize;
        if( FAILED( pIStream->Read( &dwSubChunk, sizeof(DWORD), NULL )))
        {
            Trace(1,"Error: Failure reading sequence track.\n");
            hr = DMUS_E_CANNOTREAD;
            goto END;
        }
        lSize -= sizeof(DWORD);
        // read in the overall size
        if( FAILED( pIStream->Read( &dwSubSize, sizeof(DWORD), NULL )))
        {
            Trace(1,"Error: Failure reading sequence track.\n");
            hr = DMUS_E_CANNOTREAD;
            goto END;
        }
        if( (dwSubSize == 0) || (dwSubSize > (DWORD)lSize) )
        {
            Trace(1,"Error: Failure reading sequence track - bad data.\n");
            hr = DMUS_E_CHUNKNOTFOUND;
            goto END;
        }
        lSize -= sizeof(DWORD);
        switch( dwSubChunk )
        {
        case DMUS_FOURCC_SEQ_LIST:
            if( FAILED( hr = LoadSeq( pIStream, dwSubSize )))
            {
                goto END;
            }
            break;
        case DMUS_FOURCC_CURVE_LIST:
            if( FAILED( hr = LoadCurve( pIStream, dwSubSize )))
            {
                goto END;
            }
            break;
        default:
            LARGE_INTEGER li;
            li.HighPart = 0;
            li.LowPart = dwSubSize;
            if( FAILED( pIStream->Seek( li, STREAM_SEEK_CUR, NULL )))
            {
                hr = DMUS_E_CANNOTREAD;
                goto END;
            }
            break;
        }
        lSize -= dwSubSize;
    }
END:
    return hr;
}

HRESULT CSeqTrack::Save( IStream* pIStream, BOOL fClearDirty )
{
    return E_NOTIMPL;
}

HRESULT CSeqTrack::GetSizeMax( ULARGE_INTEGER FAR* pcbSize )
{
    return E_NOTIMPL;
}

// IDirectMusicTrack
/*
@method HRESULT | IDirectMusicTrack | IsParamSupported |
Check to see if the Track supports data types in <om .GetParam> and <om .SetParam>.

@rvalue S_OK | It does support the type of data.
@rvalue S_FALSE | It does not support the type of data.
@rvalue E_NOTIMPL | (Or any other failure code) It does not support the type of data.

@comm Note that it is valid for a Track to return different results for the same
guid depending on its current state.
*/
HRESULT STDMETHODCALLTYPE CSeqTrack::IsParamSupported(
    REFGUID rguidType)    // @parm The guid identifying the type of data to check.
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicTrack::Init
/*
@method HRESULT | IDirectMusicTrack | Init |
When a track is first added to a <i IDirectMusicSegment>, this method is called
by that Segment.

@rvalue S_OK | Success.
@rvalue E_POINTER | <p pSegment> is NULL or invalid.

@comm If the Track plays messages, it should call <om IDirectMusicSegment.SetPChannelsUsed>.
*/
HRESULT CSeqTrack::Init(
    IDirectMusicSegment *pSegment)    // @parm Pointer to the Segment to which this Track belongs.
{
    if( m_dwPChannelsUsed && m_aPChannels )
    {
        pSegment->SetPChannelsUsed( m_dwPChannelsUsed, m_aPChannels );
    }
    return S_OK;
}

/*
@method HRESULT | IDirectMusicTrack | InitPlay |
This method is called when a Segment is ready to start playing. The <p ppStateData> field
may return a pointer to a structure of state data, which is sent into <om .Play> and
<om .EndPlay>, and allows the Track to keep track of variables on a <i SegmentState> by
<i SegmentState> basis.

@rvalue S_OK | Success. This is the only valid return value from this method.
@rvalue E_POINTER | <p pSegmentState>, <p pPerf>, or <p ppStateData> is NULL or
invalid.

@comm Note that it is unneccessary for the Track to store the <p pSegmentState>, <p pPerf>,
or <p dwTrackID> parameters, since they are also sent into <om .Play>.
*/
HRESULT CSeqTrack::InitPlay(
    IDirectMusicSegmentState *pSegmentState,    // @parm The calling <i IDirectMusicSegmentState> pointer.
    IDirectMusicPerformance *pPerf,    // @parm The calling <i IDirectMusicPerformance> pointer.
    void **ppStateData,        // @parm This method can return state data information here.
    DWORD dwTrackID,        // @parm The virtual track ID assigned to this Track instance.
    DWORD dwFlags)          // @parm Same flags that were set with the call
            // to PlaySegment. These are passed all the way down to the tracks, who may want to know
            // if the track was played as a primary, controlling, or secondary segment.
{
    V_INAME(IDirectMusicTrack::InitPlay);
    V_PTRPTR_WRITE(ppStateData);
    V_INTERFACE(pSegmentState);
    V_INTERFACE(pPerf);

    SeqStateData* pStateData;
    pStateData = new SeqStateData;
    if( NULL == pStateData )
        return E_OUTOFMEMORY;
    *ppStateData = pStateData;
    SetUpStateCurrentPointers(pStateData);
    // need to know the group this track is in, for the mute track GetParam
    IDirectMusicSegment* pSegment;
    if( SUCCEEDED( pSegmentState->GetSegment(&pSegment)))
    {
        pSegment->GetTrackGroup( this, &pStateData->dwGroupBits );
        pSegment->Release();
    }
    return S_OK;
}

/*
@method HRESULT | IDirectMusicTrack | EndPlay |
This method is called when the <i IDirectMusicSegmentState> object that originally called
<om .InitPlay> is destroyed.

@rvalue S_OK | Success.
@rvalue E_POINTER | <p pStateData> is invalid.
@comm The return code isn't used, but S_OK is preferred.
*/
HRESULT CSeqTrack::EndPlay(
    void *pStateData)    // @parm The state data returned from <om .InitPlay>.
{
    ASSERT( pStateData );
    if( pStateData )
    {
        V_INAME(IDirectMusicTrack::EndPlay);
        V_BUFPTR_WRITE(pStateData, sizeof(SeqStateData));
        SeqStateData* pSD = (SeqStateData*)pStateData;
        delete pSD;
    }
    return S_OK;
}

void CSeqTrack::SetUpStateCurrentPointers(SeqStateData* pStateData)
{
    ASSERT(pStateData);
    pStateData->dwPChannelsUsed = m_dwPChannelsUsed;
    if( m_dwPChannelsUsed )
    {
        if( pStateData->apCurrentSeq )
        {
            delete [] pStateData->apCurrentSeq;
            pStateData->apCurrentSeq = NULL;
        }
        if( pStateData->apCurrentCurve )
        {
            delete [] pStateData->apCurrentCurve;
            pStateData->apCurrentCurve = NULL;
        }
        pStateData->apCurrentSeq = new TListItem<DMUS_IO_SEQ_ITEM>* [m_dwPChannelsUsed];
        pStateData->apCurrentCurve = new TListItem<DMUS_IO_CURVE_ITEM>* [m_dwPChannelsUsed];
        if( pStateData->apCurrentSeq )
        {
            memset( pStateData->apCurrentSeq, 0, sizeof(TListItem<DMUS_IO_SEQ_ITEM>*) * m_dwPChannelsUsed );
        }
        if( pStateData->apCurrentCurve )
        {
            memset( pStateData->apCurrentCurve, 0, sizeof(TListItem<DMUS_IO_CURVE_ITEM>*) * m_dwPChannelsUsed );
        }
    }
    pStateData->dwValidate = m_dwValidate;
}

// DeleteSeqPartList() - delete all parts in m_SeqPartList, and associated events.
void CSeqTrack::DeleteSeqPartList(void)
{
    EnterCriticalSection(&m_CrSec);
    m_dwPChannelsUsed = 0;
    if (m_aPChannels) delete [] m_aPChannels;
    m_aPChannels = NULL;
    m_pSeqPartCache = NULL;
    if( m_SeqPartList.GetHead() )
    {
        TListItem<SEQ_PART>* pItem;
        while( pItem = m_SeqPartList.RemoveHead() )
        {
            TListItem<DMUS_IO_SEQ_ITEM>* pEvent;
            while( pEvent = pItem->GetItemValue().seqList.RemoveHead() )
            {
                delete pEvent;
            }
            TListItem<DMUS_IO_CURVE_ITEM>* pCurve;
            while( pCurve = pItem->GetItemValue().curveList.RemoveHead() )
            {
                delete pCurve;
            }
            delete pItem;
        }
    }
    LeaveCriticalSection(&m_CrSec);
}

// FindPart() - return the SEQ_PART corresponding to dwPChannel, or create one.
TListItem<SEQ_PART>* CSeqTrack::FindPart( DWORD dwPChannel )
{
    TListItem<SEQ_PART>* pPart;

    if( m_pSeqPartCache && (m_pSeqPartCache->GetItemValue().dwPChannel == dwPChannel) )
    {
        return m_pSeqPartCache;
    }
    for( pPart = m_SeqPartList.GetHead(); pPart; pPart = pPart->GetNext() )
    {
        if( pPart->GetItemValue().dwPChannel == dwPChannel )
        {
            break;
        }
    }
    if( NULL == pPart )
    {
        pPart = new TListItem<SEQ_PART>;
        if( pPart )
        {
            pPart->GetItemValue().dwPChannel = dwPChannel;
            m_SeqPartList.AddHead( pPart );
        }
        m_dwPChannelsUsed++;

        DWORD* aPChannels = new DWORD[m_dwPChannelsUsed];
        if( aPChannels )
        {
            if( m_aPChannels )
            {
                memcpy( aPChannels, m_aPChannels, sizeof(DWORD) * (m_dwPChannelsUsed - 1) );
            }
            aPChannels[m_dwPChannelsUsed - 1] = dwPChannel;
        }
        if( m_aPChannels )
        {
            delete [] m_aPChannels;
        }
        m_aPChannels = aPChannels;
    }
    m_pSeqPartCache = pPart;
    return pPart;
}

void CSeqTrack::UpdateTimeSig(IDirectMusicSegmentState* pSegSt,
                                         SeqStateData* pSD,
                                         MUSIC_TIME mt)
{
    // get a new time sig if needed
    if( (mt >= pSD->mtNextTimeSig) || (mt < pSD->mtCurTimeSig) )
    {
        IDirectMusicSegment* pSeg;
        DMUS_TIMESIGNATURE timesig;
        MUSIC_TIME mtNext;
        HRESULT hr;
        if(SUCCEEDED(hr = pSegSt->GetSegment(&pSeg)))
        {
            DWORD dwGroup;
            if( SUCCEEDED(hr = pSeg->GetTrackGroup( this, &dwGroup )))
            {
                if(SUCCEEDED(hr = pSeg->GetParam( GUID_TimeSignature, dwGroup,
                    0, mt, &mtNext, (void*)&timesig )))
                {
                    timesig.mtTime += mt;
                    if( pSD->dwlnMeasure )
                    {
                        pSD->dwMeasure = (timesig.mtTime - pSD->mtCurTimeSig) / pSD->dwlnMeasure;
                    }
                    else
                    {
                        pSD->dwMeasure = 0;
                    }
                    pSD->mtCurTimeSig = timesig.mtTime;
                    if( mtNext == 0 ) mtNext = 0x7fffffff;
                    pSD->mtNextTimeSig = mtNext;
                    if( timesig.bBeat )
                    {
                        pSD->dwlnBeat = DMUS_PPQ * 4 / timesig.bBeat;
                    }
                    pSD->dwlnMeasure = pSD->dwlnBeat * timesig.bBeatsPerMeasure;
                    if( timesig.wGridsPerBeat )
                    {
                        pSD->dwlnGrid = pSD->dwlnBeat / timesig.wGridsPerBeat;
                    }
                }
            }
            pSeg->Release();
        }
        if( FAILED(hr) )
        {
            // couldn't get time sig, default to 4/4
            pSD->mtNextTimeSig = 0x7fffffff;
            pSD->dwlnBeat = DMUS_PPQ;
            pSD->dwlnMeasure = DMUS_PPQ * 4;
            pSD->dwlnGrid = DMUS_PPQ / 4;
            pSD->dwMeasure = 0;
            pSD->mtCurTimeSig = 0;
        }
    }
    // make absolutely sure there is no way these can be 0, since we divide
    // by them.
    if( 0 == pSD->dwlnGrid ) pSD->dwlnGrid = DMUS_PPQ / 4;
    if( 0 == pSD->dwlnBeat ) pSD->dwlnBeat = DMUS_PPQ;
    if( 0 == pSD->dwlnMeasure ) pSD->dwlnMeasure = DMUS_PPQ * 4;
}

STDMETHODIMP CSeqTrack::PlayEx(void* pStateData,REFERENCE_TIME rtStart,
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf,
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID)
{
    V_INAME(IDirectMusicTrack::PlayEx);
    V_BUFPTR_WRITE( pStateData, sizeof(SeqStateData));
    V_INTERFACE(pPerf);
    V_INTERFACE(pSegSt);

    HRESULT hr;
    EnterCriticalSection(&m_CrSec);
    if (dwFlags & DMUS_TRACKF_CLOCK)
    {
        // Convert all reference times to millisecond times. Then, just use same MUSIC_TIME
        // variables.
        hr = Play(pStateData,(MUSIC_TIME)(rtStart / REF_PER_MIL),(MUSIC_TIME)(rtEnd / REF_PER_MIL),
            (MUSIC_TIME)(rtOffset / REF_PER_MIL),rtOffset,dwFlags,pPerf,pSegSt,dwVirtualID,TRUE);
    }
    else
    {
        hr = Play(pStateData,(MUSIC_TIME)rtStart,(MUSIC_TIME)rtEnd,
            (MUSIC_TIME)rtOffset,0,dwFlags,pPerf,pSegSt,dwVirtualID,FALSE);
    }
    LeaveCriticalSection(&m_CrSec);
    return hr;
}
/*
@enum DMUS_TRACKF_FLAGS | Sent in <om IDirectMusicTrack.Play>'s dwFlags parameter.
@emem DMUS_TRACKF_SEEK | Play was called on account of seeking, meaning that mtStart is
not necessarily the same as the previous Play call's mtEnd.
@emem DMUS_TRACKF_LOOP | Play was called on account of a loop, e.g. repeat.
@emem DMUS_TRACKF_START | This is the first call to Play. DMUS_TRACKF_SEEK may also be set if the
Track is not playing from the beginning.
@emem DMUS_TRACKF_FLUSH | The call to Play is on account of a flush or invalidate, that
requires the Track to replay something it played previously. In this case, DMUS_TRACKF_SEEK
will be set as well.

  @method HRESULT | IDirectMusicTrack | Play |
  Play method.
  @rvalue DMUS_DMUS_S_END | The Track is done playing.
  @rvalue S_OK | Success.
  @rvalue E_POINTER | <p pStateData>, <p pPerf>, or <p pSegSt> is NULL or invalid.
*/
STDMETHODIMP CSeqTrack::Play(
    void *pStateData,    // @parm State data pointer, from <om .InitPlay>.
    MUSIC_TIME mtStart,    // @parm The start time to play.
    MUSIC_TIME mtEnd,    // @parm The end time to play.
    MUSIC_TIME mtOffset,// @parm The offset to add to all messages sent to
                        // <om IDirectMusicPerformance.SendPMsg>.
    DWORD dwFlags,        // @parm Flags that indicate the state of this call.
                        // See <t DMUS_TRACKF_FLAGS>. If dwFlags == 0, this is a
                        // normal Play call continuing playback from the previous
                        // Play call.
    IDirectMusicPerformance* pPerf,    // @parm The <i IDirectMusicPerformance>, used to
                        // call <om IDirectMusicPerformance.AllocPMsg>,
                        // <om IDirectMusicPerformance.SendPMsg>, etc.
    IDirectMusicSegmentState* pSegSt,    // @parm The <i IDirectMusicSegmentState> this
                        // track belongs to. QueryInterface() can be called on this to
                        // obtain the SegmentState's <i IDirectMusicGraph> in order to
                        // call <om IDirectMusicGraph.StampPMsg>, for instance.
    DWORD dwVirtualID    // @parm This track's virtual track id, which must be set
                        // on any <t DMUS_PMSG>'s m_dwVirtualTrackID member that
                        // will be queued to <om IDirectMusicPerformance.SendPMsg>.
    )
{
    V_INAME(IDirectMusicTrack::Play);
    V_BUFPTR_WRITE( pStateData, sizeof(SeqStateData));
    V_INTERFACE(pPerf);
    V_INTERFACE(pSegSt);

    EnterCriticalSection(&m_CrSec);
    HRESULT    hr = Play(pStateData,mtStart,mtEnd,mtOffset,0,dwFlags,pPerf,pSegSt,dwVirtualID,FALSE);
    LeaveCriticalSection(&m_CrSec);
    return hr;
}

/*  The Play method handles both music time and clock time versions, as determined by
    fClockTime. If running in clock time, rtOffset is used to identify the start time
    of the segment. Otherwise, mtOffset. The mtStart and mtEnd parameters are in MUSIC_TIME units
    or milliseconds, depending on which mode.
*/

HRESULT CSeqTrack::Play(
    void *pStateData,
    MUSIC_TIME mtStart,
    MUSIC_TIME mtEnd,
    MUSIC_TIME mtOffset,
    REFERENCE_TIME rtOffset,
    DWORD dwFlags,
    IDirectMusicPerformance* pPerf,
    IDirectMusicSegmentState* pSegSt,
    DWORD dwVirtualID,
    BOOL fClockTime)
{
    if (dwFlags & DMUS_TRACKF_PLAY_OFF)
    {
        return S_OK;
    }
    HRESULT    hr = S_OK;
    IDirectMusicGraph* pGraph = NULL;
    DMUS_PMSG* pEvent = NULL;
    SeqStateData* pSD = (SeqStateData*)pStateData;
    BOOL fSeek = (dwFlags & DMUS_TRACKF_SEEK) ? TRUE : FALSE;

    if( dwFlags & (DMUS_TRACKF_SEEK | DMUS_TRACKF_FLUSH | DMUS_TRACKF_DIRTY |
        DMUS_TRACKF_LOOP) )
    {
        // need to reset the PChannel Map in case of any of these flags.
        m_PChMap.Reset();
    }

    if( pSD->dwValidate != m_dwValidate )
    {
        SetUpStateCurrentPointers(pSD);
        fSeek = TRUE;
    }

    if( fSeek )
    {
        if( dwFlags & DMUS_TRACKF_START )
        {
            Seek( pSegSt, pPerf, dwVirtualID, pSD, mtStart, TRUE, mtOffset, rtOffset, fClockTime );
        }
        else
        {
            Seek( pSegSt, pPerf, dwVirtualID, pSD, mtStart, FALSE, mtOffset, rtOffset, fClockTime );
        }
    }

    if( FAILED( pSegSt->QueryInterface( IID_IDirectMusicGraph,
        (void**)&pGraph )))
    {
        pGraph = NULL;
    }

    DWORD dwIndex;
    DWORD dwPChannel;
    DWORD dwMutePChannel;
    BOOL fMute;
    TListItem<SEQ_PART>* pPart = m_SeqPartList.GetHead();
    for( dwIndex = 0; pPart && (dwIndex < m_dwPChannelsUsed); dwIndex++,pPart = pPart->GetNext() )
    {
        dwPChannel = pPart->GetItemValue().dwPChannel;
        if( pSD->apCurrentCurve )
        {
            for( ; pSD->apCurrentCurve[dwIndex];
                pSD->apCurrentCurve[dwIndex] = pSD->apCurrentCurve[dwIndex]->GetNext() )
            {
                DMUS_IO_CURVE_ITEM& rItem = pSD->apCurrentCurve[dwIndex]->GetItemValue();
                if( rItem.mtStart >= mtEnd )
                {
                    break;
                }
                m_PChMap.GetInfo( dwPChannel, rItem.mtStart, mtOffset, pSD->dwGroupBits,
                    pPerf, &fMute, &dwMutePChannel, fClockTime );
                if( !fMute )
                {
                    DMUS_CURVE_PMSG* pCurve;
                    if( SUCCEEDED( pPerf->AllocPMsg( sizeof(DMUS_CURVE_PMSG),
                        (DMUS_PMSG**)&pCurve )))
                    {
                        pEvent = (DMUS_PMSG*)pCurve;
                        if (fClockTime)
                        {
                            pCurve->wMeasure = 0;
                            pCurve->bBeat = 0;
                            pCurve->bGrid = 0;
                            pCurve->nOffset = rItem.nOffset;
                            pCurve->rtTime = ((rItem.mtStart + rItem.nOffset) * REF_PER_MIL) + rtOffset;
                            // Set the DX8 flag to indicate the wMergeIndex and wParamType fields are valid.
                            pCurve->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME | DMUS_PMSGF_DX8;
                        }
                        else
                        {
                            UpdateTimeSig( pSegSt, pSD, rItem.mtStart);
                            long lTemp = (rItem.mtStart - pSD->mtCurTimeSig);
                            pCurve->wMeasure = (WORD)((lTemp / pSD->dwlnMeasure) + pSD->dwMeasure);
                            lTemp = lTemp % pSD->dwlnMeasure;
                            pCurve->bBeat = (BYTE)(lTemp / pSD->dwlnBeat);
                            lTemp = lTemp % pSD->dwlnBeat;
                            pCurve->bGrid = (BYTE)(lTemp / pSD->dwlnGrid);
                            //pCurve->nOffset = (short)(lTemp % pSD->dwlnGrid);
                            pCurve->nOffset = (short)(lTemp % pSD->dwlnGrid) + rItem.nOffset;
                            pCurve->mtTime = rItem.mtStart + mtOffset + rItem.nOffset;
                            // Set the DX8 flag to indicate the wMergeIndex and wParamType fields are valid.
                            pCurve->dwFlags = DMUS_PMSGF_MUSICTIME | DMUS_PMSGF_DX8;
                        }
                        pCurve->dwPChannel = dwMutePChannel;
                        pCurve->dwVirtualTrackID = dwVirtualID;
                        pCurve->dwType = DMUS_PMSGT_CURVE;
                        pCurve->mtDuration = rItem.mtDuration;
                        pCurve->mtResetDuration = rItem.mtResetDuration;
                        pCurve->nStartValue = rItem.nStartValue;
                        pCurve->nEndValue = rItem.nEndValue;
                        pCurve->nResetValue = rItem.nResetValue;
                        pCurve->bType = rItem.bType;
                        pCurve->bCurveShape = rItem.bCurveShape;
                        pCurve->bCCData = rItem.bCCData;
                        pCurve->bFlags = rItem.bFlags;
                        pCurve->wParamType = rItem.wParamType;
                        pCurve->wMergeIndex = rItem.wMergeIndex;
                        pCurve->dwGroupID = pSD->dwGroupBits;

                        if( pGraph )
                        {
                            pGraph->StampPMsg( pEvent );
                        }
                        if(FAILED(pPerf->SendPMsg( pEvent )))
                        {
                            pPerf->FreePMsg(pEvent);
                        }
                    }
                }
            }
        }
        if( pSD->apCurrentSeq )
        {
            for( ; pSD->apCurrentSeq[dwIndex];
                pSD->apCurrentSeq[dwIndex] = pSD->apCurrentSeq[dwIndex]->GetNext() )
            {
                DMUS_IO_SEQ_ITEM& rItem = pSD->apCurrentSeq[dwIndex]->GetItemValue();
                if( rItem.mtTime >= mtEnd )
                {
                    break;
                }
                m_PChMap.GetInfo( dwPChannel, rItem.mtTime, mtOffset, pSD->dwGroupBits,
                                  pPerf, &fMute, &dwMutePChannel, fClockTime );
                if( !fMute )
                {
                    if( (rItem.bStatus & 0xf0) == 0x90 )
                    {
                        // this is a note event
                        DMUS_NOTE_PMSG* pNote;
                        if( SUCCEEDED( pPerf->AllocPMsg( sizeof(DMUS_NOTE_PMSG),
                            (DMUS_PMSG**)&pNote )))
                        {
                            pNote->bFlags = DMUS_NOTEF_NOTEON;
                            pNote->mtDuration = rItem.mtDuration;
                            pNote->bMidiValue = rItem.bByte1;
                            pNote->bVelocity = rItem.bByte2;
                            pNote->dwType = DMUS_PMSGT_NOTE;
                            pNote->bPlayModeFlags = DMUS_PLAYMODE_FIXED;
                            pNote->wMusicValue = pNote->bMidiValue;
                            pNote->bSubChordLevel = 0;  // SUBCHORD_BASS
                            if (fClockTime)
                            {
                                pNote->rtTime = ((rItem.mtTime + rItem.nOffset) * REF_PER_MIL) + rtOffset;
                                pNote->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME;
                                pNote->wMeasure = 0;
                                pNote->bBeat = 0;
                                pNote->bGrid = 0;
                                pNote->nOffset = rItem.nOffset;
                            }
                            else
                            {
                                pNote->mtTime = rItem.mtTime + mtOffset + rItem.nOffset;
                                UpdateTimeSig( pSegSt, pSD, rItem.mtTime );
                                pNote->dwFlags = DMUS_PMSGF_MUSICTIME;
                                long lTemp = (rItem.mtTime - pSD->mtCurTimeSig);
                                pNote->wMeasure = (WORD)((lTemp / pSD->dwlnMeasure) + pSD->dwMeasure);
                                lTemp = lTemp % pSD->dwlnMeasure;
                                pNote->bBeat = (BYTE)(lTemp / pSD->dwlnBeat);
                                lTemp = lTemp % pSD->dwlnBeat;
                                pNote->bGrid = (BYTE)(lTemp / pSD->dwlnGrid);
                                //pNote->nOffset = (short)(lTemp % pSD->dwlnGrid);
                                pNote->nOffset = (short)(lTemp % pSD->dwlnGrid) + rItem.nOffset;
                            }
                            pNote->bTimeRange = 0;
                            pNote->bDurRange = 0;
                            pNote->bVelRange = 0;
                            pNote->cTranspose = 0;
                            pEvent = (DMUS_PMSG*)pNote;
                        }
                    }
                    else
                    {
                        // it's a MIDI short that's not a note
                        DMUS_MIDI_PMSG* pMidi;
                        if( SUCCEEDED( pPerf->AllocPMsg( sizeof(DMUS_MIDI_PMSG),
                            (DMUS_PMSG**)&pMidi )))
                        {
                            pMidi->bStatus = rItem.bStatus & 0xf0;
                            pMidi->bByte1 = rItem.bByte1;
                            pMidi->bByte2 = rItem.bByte2;
                            pMidi->dwType = DMUS_PMSGT_MIDI;
                            if (fClockTime)
                            {
                                pMidi->rtTime = (rItem.mtTime * REF_PER_MIL) + rtOffset;
                                pMidi->dwFlags |= DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME;
                            }
                            else
                            {
                                pMidi->mtTime = rItem.mtTime + mtOffset;
                                pMidi->dwFlags |= DMUS_PMSGF_MUSICTIME;
                            }
                            pEvent = (DMUS_PMSG*)pMidi;
                        }
                    }
                    if( pEvent )
                    {
                        pEvent->dwPChannel = dwMutePChannel;
                        pEvent->dwVirtualTrackID = dwVirtualID;
                        pEvent->dwGroupID = pSD->dwGroupBits;
                        if( pGraph )
                        {
                            pGraph->StampPMsg( pEvent );
                        }
                        if(FAILED(pPerf->SendPMsg( pEvent )))
                        {
                            pPerf->FreePMsg(pEvent);
                        }
                    }
                }
            }
        }
    }

    if( pGraph )
    {
        pGraph->Release();
    }
    return hr;
}

// SendSeekItem() - sends either the pSeq or pCurve, depending on which occurs
// latest. Sends the item at mtTime + mtOffset.
void CSeqTrack::SendSeekItem( IDirectMusicPerformance* pPerf,
                                        IDirectMusicGraph* pGraph,
                                        IDirectMusicSegmentState* pSegSt,
                                        SeqStateData* pSD,
                                        DWORD dwVirtualID,
                                        MUSIC_TIME mtTime,
                                        MUSIC_TIME mtOffset,
                                        REFERENCE_TIME rtOffset,
                                        TListItem<DMUS_IO_SEQ_ITEM>* pSeq,
                                        TListItem<DMUS_IO_CURVE_ITEM>* pCurve,
                                        BOOL fClockTime)
{
    DWORD dwMutePChannel;
    BOOL fMute;

    if( pSeq )
    {
        DMUS_IO_SEQ_ITEM& rSeq = pSeq->GetItemValue();
        if( pCurve )
        {
            DMUS_IO_CURVE_ITEM& rCurve = pCurve->GetItemValue();
            if( rSeq.mtTime >= rCurve.mtStart + rCurve.mtDuration )
            {
                // the seq item happens after the curve item. Send the
                // seq item and clear the curve item so it doesn't go out.
                pCurve = NULL;
            }
        }
        // if pCurve is NULL or was set to NULL, send out the seq item
        if( NULL == pCurve )
        {
            m_PChMap.GetInfo( rSeq.dwPChannel, rSeq.mtTime, mtOffset, pSD->dwGroupBits,
                pPerf, &fMute, &dwMutePChannel, fClockTime );
            if( !fMute )
            {
                DMUS_MIDI_PMSG* pMidi;
                if( SUCCEEDED( pPerf->AllocPMsg( sizeof(DMUS_MIDI_PMSG),
                    (DMUS_PMSG**)&pMidi )))
                {
                    pMidi->bStatus = rSeq.bStatus & 0xf0;
                    pMidi->bByte1 = rSeq.bByte1;
                    pMidi->bByte2 = rSeq.bByte2;
                    pMidi->dwType = DMUS_PMSGT_MIDI;

                    ASSERT( mtTime > rSeq.mtTime ); // this is true for back-seeking
                    if (fClockTime)
                    {
                        pMidi->rtTime = (mtTime * REF_PER_MIL) + rtOffset;
                        pMidi->dwFlags |= DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME;
                    }
                    else
                    {
                        pMidi->mtTime = mtTime + mtOffset;
                        pMidi->dwFlags |= DMUS_PMSGF_MUSICTIME;
                    }
                    pMidi->dwPChannel = dwMutePChannel;
                    pMidi->dwVirtualTrackID = dwVirtualID;
                    pMidi->dwGroupID = pSD->dwGroupBits;
                    if( pGraph )
                    {
                        pGraph->StampPMsg( (DMUS_PMSG*)pMidi );
                    }
                    if(FAILED(pPerf->SendPMsg( (DMUS_PMSG*)pMidi )))
                    {
                        pPerf->FreePMsg((DMUS_PMSG*)pMidi);
                    }
                }
            }
        }
    }

    if( pCurve )
    {
        DMUS_IO_CURVE_ITEM& rCurve = pCurve->GetItemValue();
        m_PChMap.GetInfo( rCurve.dwPChannel, rCurve.mtStart, mtOffset, pSD->dwGroupBits,
            pPerf, &fMute, &dwMutePChannel, fClockTime );
        if( !fMute )
        {
            DMUS_CURVE_PMSG* pCurvePmsg;
            if( SUCCEEDED( pPerf->AllocPMsg( sizeof(DMUS_CURVE_PMSG),
                (DMUS_PMSG**)&pCurvePmsg )))
            {
                if (fClockTime) // If clock time, don't fill in time signature info, it's useless.
                {
                    pCurvePmsg->wMeasure = 0;
                    pCurvePmsg->bBeat = 0;
                    pCurvePmsg->bGrid = 0;
                    pCurvePmsg->nOffset = 0;
                    pCurvePmsg->rtTime = ((mtTime + rCurve.nOffset) * REF_PER_MIL) + rtOffset;
                    pCurvePmsg->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME;
                }
                else
                {
                    UpdateTimeSig( pSegSt, pSD, rCurve.mtStart);
                    long lTemp = (rCurve.mtStart - pSD->mtCurTimeSig);
                    pCurvePmsg->wMeasure = (WORD)((lTemp / pSD->dwlnMeasure) + pSD->dwMeasure);
                    lTemp = lTemp % pSD->dwlnMeasure;
                    pCurvePmsg->bBeat = (BYTE)(lTemp / pSD->dwlnBeat);
                    lTemp = lTemp % pSD->dwlnBeat;
                    pCurvePmsg->bGrid = (BYTE)(lTemp / pSD->dwlnGrid);
                    pCurvePmsg->nOffset = (short)(lTemp % pSD->dwlnGrid) + rCurve.nOffset;
                    pCurvePmsg->dwFlags = DMUS_PMSGF_MUSICTIME;
                    ASSERT( mtTime > rCurve.mtStart );// this is true for back-seeking
                    // in any case, play curve at mtTime + mtOffset + pCurvePmsg->nOffset
                    pCurvePmsg->mtTime = mtTime + mtOffset + rCurve.nOffset;
                    pCurvePmsg->dwFlags = DMUS_PMSGF_MUSICTIME;
                }

                pCurvePmsg->dwPChannel = dwMutePChannel;
                pCurvePmsg->dwVirtualTrackID = dwVirtualID;
                pCurvePmsg->dwType = DMUS_PMSGT_CURVE;
                pCurvePmsg->bType = rCurve.bType;
                pCurvePmsg->bCCData = rCurve.bCCData;
                pCurvePmsg->bFlags = rCurve.bFlags;
                pCurvePmsg->dwGroupID = pSD->dwGroupBits;
                pCurvePmsg->nStartValue = rCurve.nStartValue;
                pCurvePmsg->nEndValue = rCurve.nEndValue;
                pCurvePmsg->nResetValue = rCurve.nResetValue;

                if( mtTime >= rCurve.mtStart + rCurve.mtDuration )
                {
                    // playing at a time past the curve's duration. Just play
                    // an instant curve at that time instead. Instant curves
                    // play at their endvalue. Duration is irrelavant.
                    pCurvePmsg->bCurveShape = DMUS_CURVES_INSTANT;
                    if( pCurvePmsg->bFlags & DMUS_CURVE_RESET )
                    {
                        if( mtTime >= rCurve.mtStart + rCurve.mtDuration +
                            rCurve.mtResetDuration + rCurve.nOffset )
                        {
                            // don't need the curve reset any more
                            pCurvePmsg->bFlags &= ~DMUS_CURVE_RESET;
                        }
                        else
                        {
                            // otherwise make sure the reset event happens at the same time
                            // it would have if we weren't seeking back.
                            pCurvePmsg->mtResetDuration = rCurve.mtStart + rCurve.mtDuration +
                                rCurve.mtResetDuration + rCurve.nOffset - mtTime;
                        }
                    }
                }
                else
                {
                    // playing at a time in the middle of a curve.
                    pCurvePmsg->bCurveShape = rCurve.bCurveShape;
                    if (fClockTime)
                    {
                        pCurvePmsg->mtOriginalStart = mtTime - (rCurve.mtStart + mtOffset + rCurve.nOffset);
                    }
                    else
                    {
                        pCurvePmsg->mtOriginalStart = rCurve.mtStart + mtOffset + rCurve.nOffset;
                    }
                    if( pCurvePmsg->bCurveShape != DMUS_CURVES_INSTANT )
                    {
                        pCurvePmsg->mtDuration = rCurve.mtStart + rCurve.mtDuration - mtTime;
                    }
                    pCurvePmsg->mtResetDuration = rCurve.mtResetDuration;
                }

                if( pGraph )
                {
                    pGraph->StampPMsg( (DMUS_PMSG*)pCurvePmsg );
                }
                if(FAILED(pPerf->SendPMsg( (DMUS_PMSG*)pCurve )))
                {
                    pPerf->FreePMsg((DMUS_PMSG*)pCurve);
                }
            }
        }
    }
}

// Seek() - set all pSD's pointers to the correct location. If fGetPrevious is set,
// also send control change, pitch bend, curves, etc. that are in the past so the
// state at mtTime is as if we played from the beginning of the track.
HRESULT CSeqTrack::Seek( IDirectMusicSegmentState* pSegSt,
    IDirectMusicPerformance* pPerf, DWORD dwVirtualID,
    SeqStateData* pSD, MUSIC_TIME mtTime, BOOL fGetPrevious,
    MUSIC_TIME mtOffset, REFERENCE_TIME rtOffset, BOOL fClockTime)
{
    DWORD dwIndex;
    TListItem<SEQ_PART>* pPart;
    TListItem<DMUS_IO_SEQ_ITEM>* pSeqItem;
    TListItem<DMUS_IO_CURVE_ITEM>* pCurveItem;

    // in the case of mtTime == 0 and fGetPrevious (which means DMUS_SEGF_START was
    // set in Play() ) we want to reset all lists to the beginning regardless of time.
    if( fGetPrevious && ( mtTime == 0 ) )
    {
        pPart = m_SeqPartList.GetHead();
        for( dwIndex = 0; dwIndex < m_dwPChannelsUsed; dwIndex++ )
        {
            if( pPart )
            {
                pSeqItem = pPart->GetItemValue().seqList.GetHead();
                if( pSeqItem && pSD->apCurrentSeq )
                {
                    pSD->apCurrentSeq[dwIndex] = pSeqItem;
                }
                pCurveItem = pPart->GetItemValue().curveList.GetHead();
                if( pCurveItem && pSD->apCurrentCurve )
                {
                    pSD->apCurrentCurve[dwIndex] = pCurveItem;
                }
                pPart = pPart->GetNext();
            }
            else
            {
                break;
            }
        }
        return S_OK;
    }

#define CC_1    96
    // CC_1 is the limit of the CC#'s we pay attention to. CC#96 through #101
    // are registered and non-registered parameter #'s, and data increment and
    // decrement, which we are choosing to ignore.

    TListItem<DMUS_IO_SEQ_ITEM>*    apSeqItemCC[ CC_1 ];
    TListItem<DMUS_IO_CURVE_ITEM>*    apCurveItemCC[ CC_1 ];
    TListItem<DMUS_IO_SEQ_ITEM>*    pSeqItemMonoAT;
    TListItem<DMUS_IO_CURVE_ITEM>*    pCurveItemMonoAT;
    TListItem<DMUS_IO_SEQ_ITEM>*    pSeqItemPBend;
    TListItem<DMUS_IO_CURVE_ITEM>*    pCurveItemPBend;
    IDirectMusicGraph* pGraph;
    if( FAILED( pSegSt->QueryInterface( IID_IDirectMusicGraph,
        (void**)&pGraph )))
    {
        pGraph = NULL;
    }

    pPart = m_SeqPartList.GetHead();
    for( dwIndex = 0; dwIndex < m_dwPChannelsUsed; dwIndex++ )
    {
        if( pPart )
        {
            memset(apSeqItemCC, 0, sizeof(TListItem<DMUS_IO_SEQ_ITEM>*) * CC_1);
            memset(apCurveItemCC, 0, sizeof(TListItem<DMUS_IO_CURVE_ITEM>*) * CC_1);
            pSeqItemMonoAT = NULL;
            pCurveItemMonoAT = NULL;
            pSeqItemPBend = NULL;
            pCurveItemPBend = NULL;

            // scan the seq event list in this part, storing any CC, MonoAT, and PBend
            // events we come across.
            for( pSeqItem = pPart->GetItemValue().seqList.GetHead(); pSeqItem; pSeqItem = pSeqItem->GetNext() )
            {
                DMUS_IO_SEQ_ITEM& rSeqItem = pSeqItem->GetItemValue();
                if( rSeqItem.mtTime >= mtTime )
                {
                    break;
                }
                if( !fGetPrevious )
                {
                    // if we don't care about previous events, just continue
                    continue;
                }
                switch( rSeqItem.bStatus & 0xf0 )
                {
                case MIDI_CCHANGE:
                    // ignore Registered and Non-registered Parameters,
                    // Data increment, Data decrement, and Data entry MSB and LSB.
                    if( ( rSeqItem.bByte1 < CC_1 ) && ( rSeqItem.bByte1 != 6 ) &&
                        ( rSeqItem.bByte1 != 38 ) )
                    {
                        apSeqItemCC[ rSeqItem.bByte1 ] = pSeqItem;
                    }
                    break;
                case MIDI_MTOUCH:
                    pSeqItemMonoAT = pSeqItem;
                    break;
                case MIDI_PBEND:
                    pSeqItemPBend = pSeqItem;
                    break;
                default:
                    break;
                }
            }
            if( pSD->apCurrentSeq )
            {
                pSD->apCurrentSeq[dwIndex] = pSeqItem;
            }
            // scan the curve event list in this part, storing any CC, MonoAT, and PBend
            // events we come across
            for( pCurveItem = pPart->GetItemValue().curveList.GetHead(); pCurveItem; pCurveItem = pCurveItem->GetNext() )
            {
                DMUS_IO_CURVE_ITEM& rCurveItem = pCurveItem->GetItemValue();
                if( rCurveItem.mtStart >= mtTime )
                {
                    break;
                }
                if( !fGetPrevious )
                {
                    // if we don't care about previous events, just continue
                    continue;
                }
                switch( rCurveItem.bType )
                {
                case DMUS_CURVET_CCCURVE:
                    if( ( rCurveItem.bCCData < CC_1 ) && ( rCurveItem.bCCData != 6 ) &&
                        ( rCurveItem.bCCData != 38 ) )
                    {
                        if( apCurveItemCC[ rCurveItem.bCCData ] )
                        {
                            DMUS_IO_CURVE_ITEM& rTemp = apCurveItemCC[ rCurveItem.bCCData ]->GetItemValue();
                            if( rCurveItem.mtStart + rCurveItem.mtDuration + rCurveItem.nOffset >
                                rTemp.mtStart + rTemp.mtDuration + rTemp.nOffset )
                            {
                                apCurveItemCC[ rCurveItem.bCCData ] = pCurveItem;
                            }
                        }
                        else
                        {
                            apCurveItemCC[ rCurveItem.bCCData ] = pCurveItem;
                        }
                    }
                    break;
                case DMUS_CURVET_MATCURVE:
                    if( pCurveItemMonoAT )
                    {
                        DMUS_IO_CURVE_ITEM& rTemp = pCurveItemMonoAT->GetItemValue();
                        if( rCurveItem.mtStart + rCurveItem.mtDuration + rCurveItem.nOffset >
                            rTemp.mtStart + rTemp.mtDuration + rTemp.nOffset )
                        {
                            pCurveItemMonoAT = pCurveItem;
                        }
                    }
                    else
                    {
                        pCurveItemMonoAT = pCurveItem;
                    }
                    break;
                case DMUS_CURVET_PBCURVE:
                    if( pCurveItemPBend )
                    {
                        DMUS_IO_CURVE_ITEM& rTemp = pCurveItemPBend->GetItemValue();
                        if( rCurveItem.mtStart + rCurveItem.mtDuration + rCurveItem.nOffset >
                            rTemp.mtStart + rTemp.mtDuration + rTemp.nOffset )
                        {
                            pCurveItemPBend = pCurveItem;
                        }
                    }
                    else
                    {
                        pCurveItemPBend = pCurveItem;
                    }
                    break;
                default:
                    break;
                }
            }
            if( pSD->apCurrentCurve )
            {
                pSD->apCurrentCurve[dwIndex] = pCurveItem;
            }
            if( fGetPrevious )
            {
                DWORD dwCC;
                // create and send past events appropriately
                SendSeekItem( pPerf, pGraph, pSegSt, pSD, dwVirtualID, mtTime, mtOffset, rtOffset, pSeqItemPBend, pCurveItemPBend, fClockTime );
                SendSeekItem( pPerf, pGraph, pSegSt, pSD, dwVirtualID, mtTime, mtOffset, rtOffset, pSeqItemMonoAT, pCurveItemMonoAT, fClockTime );
                for( dwCC = 0; dwCC < CC_1; dwCC++ )
                {
                    SendSeekItem( pPerf, pGraph, pSegSt, pSD, dwVirtualID, mtTime, mtOffset, rtOffset, apSeqItemCC[dwCC], apCurveItemCC[dwCC], fClockTime );
                }
            }
            pPart = pPart->GetNext();
        }
    }

    if( pGraph )
    {
        pGraph->Release();
    }
    return S_OK;
}

/*
  @method HRESULT | IDirectMusicTrack | GetParam |
  Retrieves data from a Track.

  @rvalue S_OK | Got the data ok.
  @rvalue E_NOTIMPL | Not implemented.
*/
STDMETHODIMP CSeqTrack::GetParam(
    REFGUID rguidType,    // @parm The type of data to obtain.
    MUSIC_TIME mtTime,    // @parm The time, in Track time, to obtain the data.
    MUSIC_TIME* pmtNext,// @parm Returns the Track time until which the data is valid. <p pmtNext>
                        // may be NULL. If this returns a value of 0, it means that this
                        // data will either be always valid, or it is unknown when it will
                        // become invalid.
    void *pData)        // @parm The struture in which to return the data. Each
                        // <p pGuidType> identifies a particular structure of a
                        // particular size. It is important that this field contain
                        // the correct structure of the correct size. Otherwise,
                        // fatal results can occur.
{
    return E_NOTIMPL;
}

/*
  @method HRESULT | IDirectMusicTrack | SetParam |
  Sets data on a Track.

  @rvalue S_OK | Set the data ok.
  @rvalue E_NOTIMPL | Not implemented.
*/
STDMETHODIMP CSeqTrack::SetParam(
    REFGUID rguidType,    // @parm The type of data to set.
    MUSIC_TIME mtTime,    // @parm The time, in Track time, to set the data.
    void *pData)        // @parm The struture containing the data to set. Each
                        // <p pGuidType> identifies a particular structure of a
                        // particular size. It is important that this field contain
                        // the correct structure of the correct size. Otherwise,
                        // fatal results can occur.
{
    return E_NOTIMPL;
}

STDMETHODIMP CSeqTrack::GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags)
{
    return E_NOTIMPL;
}

STDMETHODIMP CSeqTrack::SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,
                                      void* pParam, void * pStateData, DWORD dwFlags)
{
    return E_NOTIMPL;
}

/*
  @method HRESULT | IDirectMusicTrack | AddNotificationType |
  Similar to and called from <om IDirectMusicSegment.AddNotificationType>. This
  gives the track a chance to respond to notifications.

  @rvalue E_NOTIMPL | The track doesn't support notifications.
  @rvalue S_OK | Success.
  @rvalue S_FALSE | The track doesn't support the requested notification type.
*/
HRESULT STDMETHODCALLTYPE CSeqTrack::AddNotificationType(
     REFGUID rguidNotification) // @parm The notification guid to add.
{
    return E_NOTIMPL;
}

/*
  @method HRESULT | IDirectMusicTrack | RemoveNotificationType |
  Similar to and called from <om IDirectMusicSegment.RemoveNotificationType>. This
  gives the track a chance to remove notifications.

  @rvalue E_NOTIMPL | The track doesn't support notifications.
  @rvalue S_OK | Success.
  @rvalue S_FALSE | The track doesn't support the requested notification type.
*/
HRESULT STDMETHODCALLTYPE CSeqTrack::RemoveNotificationType(
     REFGUID rguidNotification) // @parm The notification guid to remove.
{
    return E_NOTIMPL;
}

/*
  @method HRESULT | IDirectMusicTrack | Clone |
  Creates a copy of the Track.

  @rvalue S_OK | Success.
  @rvalue E_OUTOFMEMORY | Out of memory.
  @rvalue E_POINTER | <p ppTrack> is NULL or invalid.

  @xref <om IDirectMusicSegment.Clone>
*/
HRESULT STDMETHODCALLTYPE CSeqTrack::Clone(
    MUSIC_TIME mtStart,    // @parm The start of the part to clone. It should be 0 or greater,
                        // and less than the length of the Track.
    MUSIC_TIME mtEnd,    // @parm The end of the part to clone. It should be greater than
                        // <p mtStart> and less than the length of the Track.
    IDirectMusicTrack** ppTrack)    // @parm Returns the cloned Track.
{
    V_INAME(IDirectMusicTrack::Clone);
    V_PTRPTR_WRITE(ppTrack);

    HRESULT hr = S_OK;

    if(mtStart < 0 )
    {
        Trace(1,"Error: Invalid clone parameters to Sequence Track, start time is %ld.\n",mtStart);
        return E_INVALIDARG;
    }
    if(mtStart > mtEnd)
    {
        Trace(1,"Error: Invalid clone parameters to Sequence Track, start time %ld is greater than end %ld.\n",mtStart,mtEnd);
        return E_INVALIDARG;
    }

    EnterCriticalSection(&m_CrSec);
    CSeqTrack *pDM;

    try
    {
        pDM = new CSeqTrack(*this, mtStart, mtEnd);
    }
    catch( ... )
    {
        pDM = NULL;
    }

    LeaveCriticalSection(&m_CrSec);
    if (pDM == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = pDM->QueryInterface(IID_IDirectMusicTrack, (void**)ppTrack);
    pDM->Release();

    return hr;
}


STDMETHODIMP CSeqTrack::Compose(
        IUnknown* pContext,
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack)
{
    return E_NOTIMPL;
}

STDMETHODIMP CSeqTrack::Join(
        IDirectMusicTrack* pNewTrack,
        MUSIC_TIME mtJoin,
        IUnknown* pContext,
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\segtrtrk.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of CSegTriggerTrack.
//

// This track type holds events that cause other segments to be cued at
// specific points during playback of a segment.

#pragma once

#include "trackhelp.h"
#include "tlist.h"
#include "smartref.h"

//////////////////////////////////////////////////////////////////////
// Types

// Items in list of events
struct TriggerInfo
{
	TriggerInfo() : lTriggerTime(0), lTimePhysical(0), dwPlayFlags(0), dwFlags(0), pIDMSegment(NULL) {}
	~TriggerInfo() {
		RELEASE(pIDMSegment);
	}

	HRESULT Clone(const TriggerInfo &o, MUSIC_TIME mtStart)
	{
		lTriggerTime = o.lTriggerTime - mtStart;
		lTimePhysical = o.lTimePhysical - mtStart;
		dwPlayFlags = o.dwPlayFlags;
		dwFlags = o.dwFlags;
		pIDMSegment = o.pIDMSegment;
		pIDMSegment->AddRef();
		return S_OK;
	}

	// from event header chunk <scrh>
	MUSIC_TIME lTriggerTime; // Logical time
	MUSIC_TIME lTimePhysical;
	DWORD dwPlayFlags;
	DWORD dwFlags;
	// from reference <DMRF>
	IDirectMusicSegment *pIDMSegment;
};

// State data.  This track needs to get the audio path that's currently playing so that it
// can use it when playing triggered segments.
struct CSegTriggerTrackState : public CStandardStateData<TriggerInfo>
{
	CSegTriggerTrackState() : pAudioPath(NULL) {};
	~CSegTriggerTrackState() { if (pAudioPath) pAudioPath->Release(); }
	IDirectMusicAudioPath *pAudioPath;
};

//////////////////////////////////////////////////////////////////////
// CSegTriggerTrack

class CSegTriggerTrack;
typedef CPlayingTrack<CSegTriggerTrack, TriggerInfo, CSegTriggerTrackState> CSegTriggerTrackBase;

class CSegTriggerTrack
  : public CSegTriggerTrackBase
{
public:
	// When the segment trigger track plays one of its items, it plays a segment.  If an invalidation occurs, that Play operation
	// can't be retracted.  Then the track is played again (with the FLUSH bit set).  This was causing it to trigger the segment
	// a second time.  To fix this, the last parameter to the CSegTriggerTrackBase is false, which instructs it not to call play
	// a second time when the FLUSH bit is set.
	CSegTriggerTrack(HRESULT *pHr) : CSegTriggerTrackBase(&g_cComponent, CLSID_DirectMusicSegmentTriggerTrack, true, false), m_dwFlags(NULL), m_dwRecursionCount(0) {}

	// Implement SetParam by calling SetParam in turn on all the child segments.  This is needed, for example so that downloading a segment with a segment trigger track will download all the triggered segments as well.
	STDMETHOD(IsParamSupported)(REFGUID rguid) { return S_OK; } // Once or more of our child segments could potentially support any type of parameter.
	STDMETHOD(SetParam)(REFGUID rguid, MUSIC_TIME mtTime, void *pData);

	STDMETHOD(InitPlay)(
		IDirectMusicSegmentState *pSegmentState,
		IDirectMusicPerformance *pPerformance,
		void **ppStateData,
		DWORD dwTrackID,
		DWORD dwFlags);

protected:
	HRESULT PlayItem(
		const TriggerInfo &item,
		statedata &state,
		IDirectMusicPerformance *pPerf,
		IDirectMusicSegmentState* pSegSt,
		DWORD dwVirtualID,
		MUSIC_TIME mtOffset,
		REFERENCE_TIME rtOffset,
		bool fClockTime);
	HRESULT LoadRiff(SmartRef::RiffIter &ri, IDirectMusicLoader *pIDMLoader);

private:
	HRESULT LoadTrigger(SmartRef::RiffIter ri, IDirectMusicLoader *pIDMLoader);

	// Data
	DWORD m_dwFlags; // from track header (sgth chunk)
    BOOL  m_dwRecursionCount; // Used to keep track of recursive calls to self.
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\smartref.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Simple helper classes that use the "resource acquisition is initialization" technique.
// In English, this means they acquire a reference to a resource and the resource is automatically
//    released in the destructor.
//

#include "smartref.h"
using namespace SmartRef;
#include <xutility>
#include "miscutil.h"
#include "dmusicf.h"

//////////////////////////////////////////////////////////////////////
// AString

AString::AString(const char *psz, UINT cch)
{
	assert(psz);
	m_psz = new char[cch + 1];
	if (m_psz)
	{
		strncpy(m_psz, psz, cch);
		m_psz[cch] = L'\0';
	}
}

AString &
AString::operator =(const char *psz)
{
	if (m_psz)
	{
		delete[] m_psz;
		m_psz = NULL;
	}

	if (psz)
	{
		m_psz = new char[strlen(psz) + 1];
		if (m_psz)
			strcpy(m_psz, psz);
	}

	return *this;
}

AString &AString::Assign(const char *psz, UINT cch)
{
	assert(psz);
	if (m_psz)
	{
		delete[] m_psz;
		m_psz = NULL;
	}

	m_psz = new char[cch + 1];
	if (m_psz)
	{
		strncpy(m_psz, psz, cch);
		m_psz[cch] = L'\0';
	}

	return *this;
}

AString &
AString::AssignFromW(const WCHAR *psz)
{
	if (m_psz)
	{
		delete[] m_psz;
		m_psz = NULL;
	}

	if (psz)
	{
		int cch = WideCharToMultiByte(CP_ACP, 0, psz, -1, NULL, 0, NULL, NULL);
		if (cch)
		{
			m_psz = new char[cch];
			if (m_psz)
			{
				cch = WideCharToMultiByte(CP_ACP, 0, psz, -1, m_psz, cch, NULL, NULL);
				if (!cch)
				{
					assert(false);
					delete[] m_psz;
					m_psz = NULL;
				}
			}
		}
	}

	return *this;
}

//////////////////////////////////////////////////////////////////////
// WString

WString &
WString::operator =(const WCHAR *psz)
{
	if (m_psz)
	{
		delete[] m_psz;
		m_psz = NULL;
	}

	if (psz)
	{
		m_psz = new WCHAR[wcslen(psz) + 1];
		if (m_psz)
			wcscpy(m_psz, psz);
	}

	return *this;
}

WString &WString::Assign(const WCHAR *psz, UINT cch)
{
	assert(psz);
	if (m_psz)
	{
		delete[] m_psz;
		m_psz = NULL;
	}

	m_psz = new WCHAR[cch + 1];
	if (m_psz)
	{
		wcsncpy(m_psz, psz, cch);
		m_psz[cch] = L'\0';
	}

	return *this;
}

WString &
WString::AssignFromA(const char *psz)
{
	if (m_psz)
	{
		delete[] m_psz;
		m_psz = NULL;
	}

	if (psz)
	{
		int cch = MultiByteToWideChar(CP_ACP, 0, psz, -1, NULL, 0);
		if (cch)
		{
			m_psz = new WCHAR[cch];
			if (m_psz)
			{
				cch = MultiByteToWideChar(CP_ACP, 0, psz, -1, m_psz, cch);
				if (!cch)
				{
					assert(false);
					delete[] m_psz;
					m_psz = NULL;
				}
			}
		}
	}

	return *this;
}

//////////////////////////////////////////////////////////////////////
// RiffIter

RiffIter::RiffIter(IStream *pStream)
  : m_hr(S_OK),
	m_pIStream(pStream),
	m_pIDMStream(NULL),
	m_fParent(false)
{
	m_pIStream->AddRef();

	ZeroMemory(&m_ckParent, sizeof(m_ckParent));
	ZeroMemory(&m_ckChild, sizeof(m_ckChild));

	m_hr = ::AllocDirectMusicStream(m_pIStream, &m_pIDMStream);
	if (FAILED(m_hr))
		return;

	m_hr = m_pIDMStream->Descend(&m_ckChild, NULL, 0);
}

RiffIter::~RiffIter()
{
	if (!m_fParent)
	{
		SafeRelease(m_pIStream);
		SafeRelease(m_pIDMStream);
	}
}

RiffIter
&RiffIter::operator ++()
{
	if (validate())
		return *this;

	m_hr = m_pIDMStream->Ascend(&m_ckChild, 0);
	if (FAILED(m_hr))
		return *this;

	m_ckChild.ckid = 0;
	m_ckChild.fccType = 0;
	m_hr = m_pIDMStream->Descend(&m_ckChild, m_fParent ? &m_ckParent : NULL, 0);
	return *this;
}

RiffIter
&RiffIter::Find(RiffType t, FOURCC idFind)
{
	if (validate())
		return *this;

	while (*this && (type() != t || id() != idFind))
		++*this;

	return *this;
}

HRESULT
RiffIter::ReadChunk(
		void *pv,
		UINT cb)
{
	if (type() != Chunk)
	{
		assert(false);
		return DMUS_E_CANNOTREAD;
	}

	ZeroMemory(pv, cb);
	DWORD cbRead = 0;
	DWORD cbSize = std::_cpp_min<DWORD>(cb, m_ckChild.cksize);
	HRESULT hr = m_pIStream->Read(pv, cbSize, &cbRead);
	if (FAILED(hr) || cbRead != cbSize)
	{
		Trace(1, "Error: Unable to read file.\n");
		hr = DMUS_E_CANNOTREAD;
	}
	return hr;
}

HRESULT
RiffIter::ReadArrayChunk(
	DWORD cbSize,
	void **ppv,
	int *pcRecords)
{
	// zero the out params
	*ppv = NULL;
	*pcRecords = 0;

	// get the size of the chunk and its records

	UINT cbChunk = size();
	if (cbChunk < sizeof(DWORD))
	{
		assert(false);
		return E_FAIL;
	}

	DWORD cbChunkRecord = 0;
	HRESULT hr = RiffIterReadChunk(*this, &cbChunkRecord);
	if (FAILED(hr))
		return hr;
	cbChunk -= sizeof(DWORD);

	if (cbChunk % cbChunkRecord != 0)
	{
		// array is not divisible by size of records!
		assert(false);
		return E_FAIL;
	}

	UINT cRecords = cbChunk / cbChunkRecord;

	// Get the whole rest of the chunk
	PtrArray<char> sprgChunk = new char[cbChunk];
	if (!sprgChunk)
		return E_OUTOFMEMORY;
	hr = ReadChunk(sprgChunk, cbChunk);
	if (FAILED(hr))
		return hr;

	// Return the chunk and its info.

	if (cbChunkRecord == cbSize)
	{
		// Great!  Return the chunk as is.
		*ppv = sprgChunk.disown();
	}
	else
	{
		// make an array of the requested size
		char *pArray = new char[cbSize * cRecords];
		if (!pArray)
			return E_OUTOFMEMORY;
		ZeroMemory(pArray, cbSize * cRecords);

		// copy each record
		char *pRec = sprgChunk; // iterate reading each record of the chunk
		char *pEnd = pRec + cbChunkRecord * cRecords; // stop before this (nonexistant) record
		char *pOut = pArray; // iterate writing into the array
		while (pRec < pEnd)
		{
			memcpy(pOut, pRec, std::_cpp_min<DWORD>(cbChunkRecord, cbSize));
			pRec += cbChunkRecord;
			pOut += cbSize;
		}
		*ppv = pArray;
	}

	*pcRecords = cRecords;
	return hr;
}

HRESULT RiffIter::FindAndGetEmbeddedObject(
		RiffType t,
		FOURCC idFind,
		HRESULT hrOnNotFound,
		IDirectMusicLoader *pLoader,
		REFCLSID rclsid,
		REFIID riid,
		LPVOID *ppv)
{
	if (validate() || !pLoader || !ppv)
	{
		assert(false);
		return E_FAIL;
	}

	*ppv = NULL;
	MMCKINFO ckLast;
	ZeroMemory(&ckLast, sizeof(ckLast));

	while (*this && (type() != t || id() != idFind))
	{
		ckLast = m_ckChild;
		++*this;
	}

	if (!*this)
		return hrOnNotFound;

	// Ascend in such a way that the stream can be used to find this chunk.
	m_hr = m_pIDMStream->Ascend(&ckLast, 0);
	if (FAILED(m_hr))
		return m_hr;

	// Call GetObject using the stream
	DMUS_OBJECTDESC desc;
	ZeroAndSize(&desc);
	desc.dwValidData = DMUS_OBJ_CLASS | DMUS_OBJ_STREAM;
	desc.guidClass = rclsid;
	desc.pStream = m_pIStream;
	HRESULT hrLoad = pLoader->GetObject(&desc, riid, ppv);

	// Descend again to leave the stream at the next chunk
	m_ckChild.ckid = 0;
	m_ckChild.fccType = 0;
	m_hr = m_pIDMStream->Descend(&m_ckChild, m_fParent ? &m_ckParent : NULL, 0);

	HRESULT hrDescend = this->hr();
	if (FAILED(hrDescend))
	{
		// Give precedence to reporting failure in the stream even though getting the
		// object succeeded before the failure.
		if (*ppv)
		{
			IUnknown *punk = static_cast<IUnknown *>(*ppv);
			if (punk)
				punk->Release();
			*ppv = NULL;
		}
		return hrDescend;
	}
	else
	{
		return hrLoad;
	}
}

HRESULT
RiffIter::ReadReference(DMUS_OBJECTDESC *pDESC)
{
	HRESULT hr = S_OK;

	assert(this->type() == List && this->id() == DMUS_FOURCC_REF_LIST);

	ZeroAndSize(pDESC);

	for (RiffIter ri = this->Descend(); ri; ++ri)
	{
		switch (ri.id())
		{
			case  DMUS_FOURCC_REF_CHUNK:
				DMUS_IO_REFERENCE ioDMRef;
				hr = SmartRef::RiffIterReadChunk(ri, &ioDMRef);
				if (SUCCEEDED(hr))
				{
					pDESC->guidClass = ioDMRef.guidClassID;
					pDESC->dwValidData |= ioDMRef.dwValidData;
					pDESC->dwValidData |= DMUS_OBJ_CLASS;
				}
				break;

			case DMUS_FOURCC_GUID_CHUNK:
				hr = SmartRef::RiffIterReadChunk(ri, &pDESC->guidObject);
				if (SUCCEEDED(hr))
					pDESC->dwValidData |=  DMUS_OBJ_OBJECT;
				break;

			case DMUS_FOURCC_DATE_CHUNK:
				hr = SmartRef::RiffIterReadChunk(ri, &pDESC->ftDate);
				if (SUCCEEDED(hr))
					pDESC->dwValidData |=  DMUS_OBJ_DATE;
				break;

			case DMUS_FOURCC_NAME_CHUNK:
				hr = SmartRef::RiffIterReadChunk(ri, &pDESC->wszName);
				if (SUCCEEDED(hr))
					pDESC->dwValidData |=  DMUS_OBJ_NAME;
				break;
			
			case DMUS_FOURCC_FILE_CHUNK:
				hr = SmartRef::RiffIterReadChunk(ri, &pDESC->wszFileName);
				if (SUCCEEDED(hr))
					pDESC->dwValidData |=  DMUS_OBJ_FILENAME;
				break;

			case DMUS_FOURCC_CATEGORY_CHUNK:
				hr = SmartRef::RiffIterReadChunk(ri, &pDESC->wszCategory);
				if (SUCCEEDED(hr))
					pDESC->dwValidData |=  DMUS_OBJ_CATEGORY;
				break;

			case DMUS_FOURCC_VERSION_CHUNK:
				DMUS_IO_VERSION ioDMObjVer;
				hr = SmartRef::RiffIterReadChunk(ri, &ioDMObjVer);
				if (SUCCEEDED(hr))
				{
					pDESC->vVersion.dwVersionMS = ioDMObjVer.dwVersionMS;
					pDESC->vVersion.dwVersionLS = ioDMObjVer.dwVersionLS;
					pDESC->dwValidData |= DMUS_OBJ_VERSION;
				}
				else
				{
					hr = E_FAIL;
				}
				break;

			default:
				break;
		}
	}
	return ri.hr();
}

HRESULT RiffIter::LoadObjectInfo(ObjectInfo *pObjInfo, RiffType rtypeStop, FOURCC ridStop)
{
	assert(pObjInfo);
	pObjInfo->Clear();

	HRESULT hr = S_OK;

	if (!(*this))
		return this->hr();

	for ( ; *this; ++(*this))
	{
		RiffType rtype = type();
		FOURCC fcc = id();
		if (rtype == rtypeStop && fcc == ridStop)
			return S_OK;

		if (rtype == SmartRef::RiffIter::Chunk)
		{
			if (fcc == DMUS_FOURCC_GUID_CHUNK)
				hr = SmartRef::RiffIterReadChunk(*this, &pObjInfo->guid);
			else if (fcc == DMUS_FOURCC_VERSION_CHUNK)
				hr = SmartRef::RiffIterReadChunk(*this, &pObjInfo->vVersion);
		}
		else if (rtype == SmartRef::RiffIter::List)
		{
			if (fcc == DMUS_FOURCC_UNFO_LIST)
			{
				RiffIter riUnfo = this->Descend();
				if (!riUnfo)
					return riUnfo.hr();
				if (riUnfo.Find(SmartRef::RiffIter::Chunk, DMUS_FOURCC_UNAM_CHUNK))
				{
					hr = riUnfo.ReadTextTrunc(pObjInfo->wszName, DMUS_MAX_NAME);
					if (FAILED(hr))
						return hr;
				}
			}
		}

		if (FAILED(hr))
			return hr;
	}
	
	Trace(1, "Error: Unable to read file.\n");
	return E_FAIL;
}

HRESULT RiffIter::ReadText(WCHAR **ppwsz)
{
	DWORD dwSize = this->size();
	if (dwSize % 2 != 0)
	{
		assert(false);
		return E_FAIL;
	}
	*ppwsz = new WCHAR[dwSize / 2];
	if (!*ppwsz)
		return E_OUTOFMEMORY;
	HRESULT hr = this->ReadChunk(*ppwsz, dwSize);
	return hr;
}

HRESULT RiffIter::ReadTextTrunc(WCHAR *pwsz, UINT cbBufSize)
{
	DWORD dwSize = this->size();
	if (dwSize % 2 != 0)
	{
		assert(false);
		return E_FAIL;
	}
	HRESULT hr = this->ReadChunk(pwsz, std::_MIN<DWORD>(dwSize, (cbBufSize - 1) * 2));
	pwsz[cbBufSize - 1] = L'\0';
	return hr;
}

RiffIter::RiffIter(const RiffIter &other, MMCKINFO ckParent)
  : m_hr(S_OK),
	m_pIStream(other.m_pIStream),
	m_pIDMStream(other.m_pIDMStream),
	m_fParent(true),
	m_ckParent(ckParent)
{
	other.validate();
	ZeroMemory(&m_ckChild, sizeof(m_ckChild));

	m_hr = m_pIDMStream->Descend(&m_ckChild, &m_ckParent, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\smartref.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Simple helper classes that use the "resource acquisition is initialization" technique.
// In English, this means they acquire a reference to a resource and the resource is automatically
//    released in the destructor.
//

// This is particularly helpful if you are using exception handling or simulating it (painfully)
//    in OLE by putting "if (FAILED(hr)) return;" after every function call.  In such circumstances
//    it simpler if you know that the resource will be automatically freed no matter how you end
//    up exiting the function.
// Since we're not using exception handling, these classes do not throw.  If resource acquisition
//    could fail, be sure to check for the error before using the resource!
// Sometimes these helper classes are more than just simple wrappers for freeing the resource.
//    They may also provide useful methods that make it easier to perform operations on the resource.
// Everything here is enclosed in the SmartRef namespace.  Thus you can't refer to CritSec directly.
//    Instead you must say SmartRef::CritSec.

#pragma once
#include "debug.h"
#include "mmsystem.h"
#include "dmstrm.h"
#include "dmerror.h"
#include "dmusici.h"

// Place this in the private: section of a class to prevent use of the default C++ copy and assignment.
// Creates an error if someone later tries to use the automatic member-by-member copy that would be incorrect.
// Use this if you don't do the work to implement correct copying or if copying doesn't make sense for this class.
#define NOCOPYANDASSIGN(classname) classname(const classname &o); classname &operator= (const classname &o);

namespace SmartRef
{

	// Enters a critical section on contruction.  Leaves on destruction.
	class CritSec
	{
	public:
		CritSec(CRITICAL_SECTION *pCriticalSection) : m_pCriticalSection(pCriticalSection) { EnterCriticalSection(m_pCriticalSection); }
		~CritSec() { LeaveCriticalSection(m_pCriticalSection); }
	private:
		NOCOPYANDASSIGN(CritSec)
		CRITICAL_SECTION *m_pCriticalSection;
	};

	// Makes a copy of an ANSI string and frees it on destruction.
	// hungarian: astr
	class AString
	{
	public:
		AString(const WCHAR *psz) : m_psz(NULL) { this->AssignFromW(psz); }
		AString(const char *psz = NULL) : m_psz(NULL) { *this = psz; }
		AString(const char *psz, UINT cch); // take first cch characters of psz
		AString(const AString &str) : m_psz(NULL) { *this = str.m_psz; }
		~AString() { *this = NULL; }
		operator const char *() const { return m_psz; }
		AString &operator= (const char *psz);
		AString &operator= (const AString &str) { return *this = str.m_psz; }
		AString &Assign(const char *psz, UINT cch); // take first cch characters of psz
		AString &AssignFromW(const WCHAR *psz);

		char ** operator& () { assert(!m_psz); return &m_psz; } // allows direct setting of psz, adopting a string without copying it

	private:
		char *m_psz;
	};

	// Same as AString for Unicode strings.
	// Also accepts ANSI strings, converting them to Unicode.
	// hungarian: wstr
	class WString
	{
	public:
		WString(const char *psz) : m_psz(NULL) { this->AssignFromA(psz); }
		WString(const WCHAR *psz = NULL) : m_psz(NULL) { *this = psz; }
		WString(const WCHAR *psz, UINT cch) : m_psz(NULL) { this->Assign(psz, cch); }
		WString(const WString &str) : m_psz(NULL) { *this = str.m_psz; }
		~WString() { *this = static_cast<WCHAR *>(NULL); }
		operator const WCHAR *() const { return m_psz; }
		WString &operator= (const WCHAR *psz);
		WString &operator= (const WString &str) { return *this = str.m_psz; }
		WString &Assign(const WCHAR *psz, UINT cch); // take first cch characters of psz
		WString &AssignFromA(const char *psz);

		WCHAR ** operator& () { assert(!m_psz); return &m_psz; } // allows direct setting of psz, adopting a string without copying it

	private:
		WCHAR *m_psz;
	};

	// Allocates a writable buffer of a fixed size and frees it on destruction.
	// (For example, you could use a Buffer<char> to write a string into.)
	// hungarian: buf prefixed by type
	//            use abuf for Buffer<char> and wbuf for Buffer<WCHAR>
	template<class T>
	class Buffer
	{
	public:
		Buffer(UINT uiSize) { m_p = new T[uiSize + 1]; }
		~Buffer() { delete[] m_p; }
		operator T *() { return m_p; }

		// use to defer allocation (say, if you don't know the size at the declaration)
		Buffer() : m_p(NULL) {}
		void Alloc(UINT uiSize) { delete[] m_p; m_p = new T[uiSize + 1]; }
		T* disown() { T *_p = m_p; m_p = NULL; return _p; }
		T** operator& () { assert(!m_p); return &m_p; } // allows direct setting of m_p, adopting a string without copying it

	private:
		NOCOPYANDASSIGN(Buffer)
		T *m_p;
	};

	// Holds an array that grows automatically.
	// Doesn't throw so you must call AccessTo before using a position that might have required
	//    reallocation to ensure that memory didn't run out.
	// Values held in the vector must have value semantics so that they can be copied freely
	//    into reallocated memory slots.
	// hungarian: vec prefixed by type
	//            of just use svec (for smart vector) without specifying the type
	//            use avec for Vector<char> and wvec for Vector<WCHAR>
	template<class T>
	class Vector
	{
	public:
		Vector() : m_pT(NULL), m_size(0), m_capacity(0) {}
		~Vector() { delete[] m_pT; }
		UINT size() { return m_size; }
		operator bool() { return m_fFail; }
		bool AccessTo(UINT uiPos) { return Grow(uiPos + 1); }
		T& operator[](UINT uiPos) { assert(uiPos < m_size); return m_pT[uiPos]; }
		T* GetArray() { return m_pT; } // Danger: only use when needed and don't write past the end.
		void Shrink(UINT uiNewSize) { m_size = uiNewSize; } // Semantically shrinks -- doesn't actually free up any memory

	private:
		NOCOPYANDASSIGN(Vector)
		bool Grow(UINT size)
			{
				if (size > m_size)
				{
					if (size > m_capacity)
					{
						for (UINT capacity = m_capacity ? m_capacity : 1;
								capacity < size;
								capacity *= 2)
						{}
						T *pT = new T[capacity];
						if (!pT)
							return false;
						for (UINT i = 0; i < m_size; ++i)
							pT[i] = m_pT[i];
						delete[] m_pT;
						m_pT = pT;
						m_capacity = capacity;
					}
					m_size = size;
				}
				return true;
			}

		T *m_pT;
		UINT m_size;
		UINT m_capacity;
	};

	// Standard stack abstract data type.
	// Values held in the stack must have value semantics so that they can be copied freely
	//    into reallocated memory slots.
	// hungarian: stack prefixed by type
	template<class T>
	class Stack
	{
	public:
		Stack() : iTop(-1) {}
		bool empty() { return iTop < 0; }
		HRESULT push(const T& t) { if (!m_vec.AccessTo(iTop + 1)) return E_OUTOFMEMORY; m_vec[++iTop] = t; return S_OK; }
		T top() { if (empty()) {assert(false); return T();} return m_vec[iTop]; }
		void pop() { if (empty()) {assert(false); return;} --iTop; }

	private:
		Vector<T> m_vec;
		int iTop;
	};

	// Lookup table that maps keys to values.  Grows automatically as needed.
	// Type K (keys) must support operator =, operator ==. and a Hash function that returns an int.
	// Type V must support operator =.
	template <class K, class V>
	class Hash
	{
	public:
		Hash(HRESULT *phr, int iInitialSize = 2) : m_p(NULL), m_iCapacity(0), m_iSize(0) { *phr = Grow(iInitialSize); }
		~Hash() { delete[] m_p; }

		struct entry
		{
			V v;
			bool fFound() { return iHash != -1; }
		private:
			// only let the hash make them
			friend class Hash<K, V>;
			entry() : iHash(-1) {};
			entry(const entry &o); // disallowed copy constructor

			int iHash;
			K k;
		};

		entry &Find(K k) // if iHash is -1 then it wasn't found and you may immediately add the entry using Add().
		{
			assert(m_p);
			return HashTo(k.Hash(), k, m_p, m_iCapacity);
		}

		// Warning: no intervening additions may have occurred between the time e was returned by Find and the time Add(e, ...) is called.
		// Also k must be the same in both calls.  If you want to be crafty, "same" can be replaced with equivalence in terms of Hash and operator==.
		HRESULT Add(entry &e, K k, V v)
		{
			assert(!e.fFound());
			assert(&e == &Find(k));

			e.v = v;
			e.iHash = k.Hash();
			e.k = k;
			++m_iSize;
			if (m_iSize * 2 > m_iCapacity)
				return Grow(m_iCapacity * 2);
			return S_OK;
		}

		V &operator[](K k)
		{
			entry &e = Find(k);
			assert(e.fFound());
			return e.v;
		}

	private:
		HRESULT Grow(int iCapacity)
		{
#ifdef DBG
			// size must be at least 2 and a power of 2
			for (int iCheckSize = iCapacity; !(iCheckSize & 1); iCheckSize >>= 1)
			{}
			assert(iCapacity > 1 && iCheckSize == 1);
#endif

			// alloc new table
			entry *p = new entry[iCapacity];
			if (!p)
			{
				delete[] m_p;
				return E_OUTOFMEMORY;
			}

			// rehash everything into the larger table
			for (int i = 0; i < m_iCapacity; ++i)
			{
				entry &eSrc = m_p[i];
				if (eSrc.iHash != -1)
				{
					entry &eDst = HashTo(eSrc.iHash, eSrc.k, p, iCapacity);
					assert(eDst.iHash == -1);
					eDst = eSrc;
				}
			}

			delete[] m_p;
			m_p = p;
			m_iCapacity = iCapacity;
			return S_OK;
		}

		entry &HashTo(int iHash, K k, entry *p, int iCapacity)
		{
			// initial hash using modulus, then jump three slots at a time (3 is guaranteed to take us to all slots because capacity is a power of 2)
			assert(iHash >= 0);
			for (int i = iHash % iCapacity;
					p[i].iHash != -1 && (p[i].iHash != iHash || !(p[i].k == k)); // rehash while slot occupied or it doesn't match
					i = (i + 3) % iCapacity)
			{}
			return p[i];
		}
		
		entry *m_p;
		int m_iCapacity;
		int m_iSize;
	};

	// Holds the supplied pointer and frees it on destruction.
	// hungarian: sp (smart pointer)
	template <class T>
	class Ptr
	{
	public:
		Ptr(T *_p) : p(_p) {}
		~Ptr() { delete p; }
		operator T*() { return p; }
		T *operator->() { return p; }

		T* disown() { T *_p = p; p = NULL; return _p; }

	private:
		NOCOPYANDASSIGN(Ptr)
		T* p;
	};

	// Holds the supplied pointer to an array and frees it (with delete[]) on destruction.
	// hungarian: sprg
	template <class T>
	class PtrArray
	{
	public:
		PtrArray(T *_p) : p(_p) {}
		~PtrArray() { delete[] p; }
		operator T*() { return p; }

		T* disown() { T *_p = p; p = NULL; return _p; }

	private:
		NOCOPYANDASSIGN(PtrArray)
		T* p;
	};

	// Holds the supplied COM interface and releases it on destruction.
	// hungarian: scom
	template <class T>
	class ComPtr
	{
	public:
		ComPtr(T *_p = NULL) : p(_p) {}
		~ComPtr() { *this = NULL; }
		operator T*() { return p; }
		T* operator-> () { assert(p); return p; }
		ComPtr &operator= (T *_p) { if (p) p->Release(); p = _p; return *this; }
		T** operator& () { assert(!p); return &p; }

		void Release() { *this = NULL; }
		T* disown() { T *_p = p; p = NULL; return _p; }

	private:
		T* p;
	};

	// Holds the supplied registry key handle and closes it on destruction.
	// hungarian: shkey
	class HKey
	{
	public:
		HKey(HKEY hkey = NULL) : m_hkey(hkey) {}
		~HKey() { *this = NULL; }
		HKey &operator= (HKEY hkey) { if (m_hkey) ::RegCloseKey(m_hkey); m_hkey = hkey; return *this; }
		HKEY *operator& () { assert(!m_hkey); return &m_hkey; }
		operator HKEY() { return m_hkey; }

	private:
		NOCOPYANDASSIGN(HKey)
		HKEY m_hkey;
	};

	// Allocates and clears a one of the DMUS_*_PMSG structures.  You fill out its fields
	// and then call StampAndSend.  The message is automatically cleared after a successful
	// send or freed on destruction.  Be sure the check the hr function for failures.
	// hungarian: pmsg
	template <class T>
	class PMsg
	{
	public:
		T *p; // pointer to the message structure -- use to set the fields before sending
		PMsg(IDirectMusicPerformance *pPerf, UINT cbExtra = 0) // use cbExtra to allocate extra space in the structure, such as for DMUS_SYSEX_PMSG or DMUS_LYRIC_PMSG
		  : m_pPerf(pPerf), m_hr(S_OK), p(NULL)
		{
			const UINT cb = sizeof(T) + cbExtra;
			m_hr = m_pPerf->AllocPMsg(cb, reinterpret_cast<DMUS_PMSG**>(&p));
			if (SUCCEEDED(m_hr))
			{
				assert(p->dwSize == cb);
				ZeroMemory(p, cb);
				p->dwSize = cb;
			}
		}
		~PMsg() { if (p) m_pPerf->FreePMsg(reinterpret_cast<DMUS_PMSG*>(p)); }
		void StampAndSend(IDirectMusicGraph *pGraph)
		{
			m_hr = pGraph->StampPMsg(reinterpret_cast<DMUS_PMSG*>(p));
			if (FAILED(m_hr))
				return;

			m_hr = m_pPerf->SendPMsg(reinterpret_cast<DMUS_PMSG*>(p));
			if (SUCCEEDED(m_hr))
				p = NULL; // PMsg now owned by the performance
		}
		HRESULT hr() { return m_hr; }

	private:
		NOCOPYANDASSIGN(PMsg)
		IDirectMusicPerformance *m_pPerf; // weak ref
		HRESULT m_hr;
	};

	// Walks through the RIFF file structure held in a stream.  Releases it on destruction.
	// Although I found this to be quite useful, it a bit complicated.  You should look over
	//    the source or step through some examples before you use it.  Although I'm not positive
	//    this wouldn't work, it is not designed to have multiple RiffIter's walking over the
	//    same stream at once (see note in Descend).
	// hungarian: ri
	class RiffIter
	{
	public:
		enum RiffType { Riff, List, Chunk };

		RiffIter(IStream *pStream);
		~RiffIter();

		RiffIter &operator ++();
		RiffIter &Find(RiffType t, FOURCC id);
		HRESULT FindRequired(RiffType t, FOURCC id, HRESULT hrOnNotFound) { if (Find(t, id)) return S_OK; HRESULT _hr = hr(); return SUCCEEDED(_hr) ? hrOnNotFound : _hr; } // Attempts to find the expected chunk.  Returns S_OK if found, an error code if there was a problem reading, and hrOnNotFound if reading worked OK but the chunk simply wasn't there.

		// With Descend, use the returned iterator to process the children before resuming use of the parent.  Using both at once won't work.
		RiffIter Descend() { validate(); return RiffIter(*this, m_ckChild); }

		operator bool() const { return SUCCEEDED(m_hr); }
		HRESULT hr() const { return (m_hr == DMUS_E_DESCEND_CHUNK_FAIL) ? S_OK : m_hr; }

		RiffType type() const { validate(); return (m_ckChild.ckid == FOURCC_LIST) ? List : ((m_ckChild.ckid == FOURCC_RIFF) ? Riff : Chunk); }
		FOURCC id() const { validate(); return (type() == Chunk) ? m_ckChild.ckid : m_ckChild.fccType; }

		DWORD size() const { validate(); assert(type() == Chunk); return m_ckChild.cksize; }
		HRESULT ReadChunk(void *pv, UINT cb);
		HRESULT ReadArrayChunk(DWORD cbSize, void **ppv, int *pcRecords); // Reads an array chunk that is an array of records where the first DWORD gives the size of the records.  The records are copied into an array of records of size dwSize (filling with zero if the actual records in the file are smaller and ignoring additional fields if the actual records are larger).  ppv is set to return a pointer to this array, which the caller now owns and must delete.  pcRecords is set to the number of records returned.

		// Find the chunk (or return hrOnNoteFound). Load an object embedded in the stream. Then leaves the iterator on the next chunk.
		HRESULT FindAndGetEmbeddedObject(RiffType t, FOURCC id, HRESULT hrOnNotFound, IDirectMusicLoader *pLoader, REFCLSID rclsid, REFIID riid, LPVOID *ppv);

		// read specific RIFF structures
		HRESULT ReadReference(DMUS_OBJECTDESC *pDESC); // no need to init (zero, set size) the passed descriptor before calling
		HRESULT LoadReference(IDirectMusicLoader *pIDMLoader, const IID &iid, void **ppvObject)
		{
			DMUS_OBJECTDESC desc;
			HRESULT hr = ReadReference(&desc);
			if(SUCCEEDED(hr))
				hr = pIDMLoader->GetObject(&desc, iid, ppvObject);
			return hr;
		}

		struct ObjectInfo
		{
			ObjectInfo() { Clear(); }
			void Clear() { wszName[0] = L'\0'; guid = GUID_NULL; vVersion.dwVersionMS = 0; vVersion.dwVersionLS = 0; }

			WCHAR wszName[DMUS_MAX_NAME];
			GUID guid;
			DMUS_VERSION vVersion;
		};
		HRESULT LoadObjectInfo(ObjectInfo *pObjInfo, RiffType rtypeStop, FOURCC ridStop); // No need to init/zero. Reads from <guid-ck>, <vers-ck>, and <UNFO-list>/<UNAM-ck>. Stops at rtypeStop/ridStop, or returns E_FAIL if not found.

		HRESULT ReadText(WCHAR **ppwsz); // allocates a buffer and reads the current chunk--a NULL-terminated Unicode string--into it
		HRESULT ReadTextTrunc(WCHAR *pwsz, UINT cbBufSize); // reads only as much as it can fit in the buffer with a terminator

		// This is deliberately placed in the public section but never implemented in order to allow statements such as:
		//   SmartRef::RiffIter riChild = ri.Descend();
		// But it is never defined to prevent someone from trying to actually make two copies of a riffiter and then use them, which is not supported.
		// This would yield an unresolved symbol error:
		//   SmartRef::RiffIter riError = ri;
		// We don't allow general copying of RiffIters.  Only used to get the return value of Descend, where it is optimized away.
		RiffIter(const RiffIter &o);

	private:
		RiffIter &operator= (const RiffIter &o); // Also never defined -- don't allow assignment

		RiffIter(const RiffIter &other, MMCKINFO ckParent);
		bool validate() const { if (FAILED(m_hr)) { assert(false); return true; } else return false; }

		HRESULT m_hr;
		IStream *m_pIStream;
		IDMStream *m_pIDMStream;
		bool m_fParent;
		MMCKINFO m_ckParent;
		MMCKINFO m_ckChild;
	};

	// Templated ReadChunk typed helpers (templated member function wasn't working for me on current version of compiler)
	template <class T> HRESULT RiffIterReadChunk(RiffIter &ri, T *pT) { return ri.ReadChunk(pT, sizeof(*pT)); }
	template <class T> HRESULT RiffIterReadArrayChunk(RiffIter &ri, T **ppT, int *pcRecords) { return ri.ReadArrayChunk(sizeof(T), reinterpret_cast<void**>(ppT), pcRecords); }

}; // namespace SmartRef
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\song.cpp ===
//
// Copyright (c) 1998-2001 Microsoft Corporation
// song.cpp : Implementation of CSong
//

#include "dmime.h"
#include "song.h"
#include "validp.h"
#include "dmstrm.h"
#include "Validate.h"
#include "debug.h"

CTrack::CTrack()
{
    m_pTrack = NULL;
    m_pTrack8 = NULL;
    m_pTrackState = NULL;
    m_bDone = FALSE;
    m_dwPriority = 0;
    m_dwPosition = 0;
    m_dwFlags = DMUS_TRACKCONFIG_DEFAULT;
    m_dwInternalFlags = 0;
    m_dwGroupBits = 0xFFFFFFFF;
    m_dwVirtualID = 0;
    m_guidClassID = GUID_NULL;
}

CTrack::~CTrack()
{
    assert( !( m_pTrackState && !m_pTrack ) ); // if we have state but no track, something's wrong
    if( m_pTrack )
    {
        if( m_pTrackState )
        {
            m_pTrack->EndPlay( m_pTrackState ); // allow the track to delete its state data
        }
        m_pTrack->Release();
    }
    if ( m_pTrack8 )
    {
        m_pTrack8->Release();
    }
}

HRESULT CTrackList::CreateCopyWithBlankState(CTrackList* pTrackList)
{
    if( pTrackList )
    {
        CTrack* pTrack;
        CTrack* pCopy;
        pTrackList->Clear();
        pTrack = (CTrack*)m_pHead;
        while( pTrack )
        {
            pCopy = new CTrack;
            if( pCopy )
            {
                // copy the IDirectMusicTrack pointer, but leave
                // the track state blank.
                *pCopy = *pTrack;
                pCopy->SetNext(NULL);
                pCopy->m_pTrackState = NULL;
                assert( pCopy->m_pTrack );
                pCopy->m_pTrack->AddRef();
                if (pCopy->m_pTrack8)
                {
                    pCopy->m_pTrack8->AddRef();
                }
                pTrackList->Cat( pCopy );
            }
            else
            {
                assert(FALSE); // out of memory
                return E_OUTOFMEMORY;
            }
            pTrack = pTrack->GetNext();
        }
    }
    else
    {
        assert(FALSE); // out of memory
        return E_OUTOFMEMORY;
    }
    return S_OK;
}

CVirtualSegment::CVirtualSegment()
{
    m_wszName[0] = 0;
    m_pSourceSegment = NULL;
    m_pPlaySegment = NULL;
    m_pGraph = NULL;
    m_dwFlags = 0;
    m_dwID = 0;
    m_dwNextPlayID = DMUS_SONG_NOSEG;
    m_dwNextPlayFlags = 0;
    m_mtTime = 0;
    m_dwTransitionCount = 0;
    m_pTransitions = NULL;
    m_SegHeader.rtLength = 0;
    m_SegHeader.dwFlags = 0;
    m_SegHeader.dwRepeats = 0;      /* Number of repeats. By default, 0. */
    m_SegHeader.mtLength = 0xC00;   /* Length, in music time. */
    m_SegHeader.mtPlayStart = 0;    /* Start of playback. By default, 0. */
    m_SegHeader.mtLoopStart = 0;    /* Start of looping portion. By default, 0. */
    m_SegHeader.mtLoopEnd = 0;      /* End of loop. Must be greater than dwPlayStart. By default equal to length. */
    m_SegHeader.dwResolution = 0;   /* Default resolution. */
}

CVirtualSegment::~CVirtualSegment()
{
    if (m_pSourceSegment)
    {
        m_pSourceSegment->Release();
    }
    if (m_pPlaySegment)
    {
        m_pPlaySegment->Release();
    }
    if (m_pGraph)
    {
        m_pGraph->Release();
    }
    if (m_pTransitions)
    {
        delete [] m_pTransitions;
    }
    m_TrackList.Clear();
}

CTrack * CVirtualSegment::GetTrackByParam( CTrack * pCTrack,
    REFGUID rguidType,DWORD dwGroupBits,DWORD dwIndex)
{
    // If the caller was already part way through the list, it passes the current
    // track. Otherwise, NULL to indicate start at the top.
    if (pCTrack)
    {
        pCTrack = pCTrack->GetNext();
    }
    else
    {
        pCTrack = m_TrackList.GetHead();
    }
    while( pCTrack )
    {
        ASSERT(pCTrack->m_pTrack);
        if( (pCTrack->m_dwGroupBits & dwGroupBits ) &&
            (pCTrack->m_dwFlags & DMUS_TRACKCONFIG_CONTROL_ENABLED))
        {
            if( (GUID_NULL == rguidType) || (pCTrack->m_pTrack->IsParamSupported( rguidType ) == S_OK ))
            {
                if( 0 == dwIndex )
                {
                    return pCTrack;
                }
                dwIndex--;
            }
        }
        pCTrack = pCTrack->GetNext();
    }
    return NULL;
}

void CVirtualSegmentList::Clear()
{
    CVirtualSegment *pVirtualSegment;
    while (pVirtualSegment = RemoveHead())
    {
        delete pVirtualSegment;
    }
}

CSongSegment::CSongSegment()
{
    m_pSegment = NULL;
    m_dwLoadID = 0;
}

CSongSegment::~CSongSegment()
{
    if (m_pSegment)
    {
        m_pSegment->Release();
    }
}

HRESULT CSongSegmentList::AddSegment(CSegment *pSegment, DWORD dwLoadID)
{
    CSongSegment *pSeg = new CSongSegment;
    if (pSeg)
    {
        pSeg->m_dwLoadID = dwLoadID;
        pSeg->m_pSegment = pSegment;
        pSegment->AddRef();
        AddTail(pSeg);
        return S_OK;
    }
    return E_OUTOFMEMORY;
}

void CSongSegmentList::Clear()
{
    CSongSegment *pSongSegment;
    while (pSongSegment = RemoveHead())
    {
        delete pSongSegment;
    }
}


CSong::CSong()
{
    InitializeCriticalSection(&m_CriticalSection);
    m_dwStartSegID = DMUS_SONG_NOSEG;
    m_pAudioPathConfig = NULL;
    m_fPartialLoad = FALSE;
    m_cRef = 1;
    m_dwFlags = 0;
    m_dwValidData = DMUS_OBJ_CLASS; // upon creation, only this data is valid
    memset(&m_guidObject,0,sizeof(m_guidObject));
    memset(&m_ftDate, 0,sizeof(m_ftDate));
    memset(&m_vVersion, 0,sizeof(m_vVersion));
    m_pUnkDispatch = NULL;
    InterlockedIncrement(&g_cComponent);
    m_fZombie = false;
    TraceI(2, "Song %lx created\n", this );
}

CSong::~CSong()
{
    Clear();

    if (m_pUnkDispatch)
    {
        m_pUnkDispatch->Release(); // free IDispatch implementation we may have borrowed
    }
    DeleteCriticalSection(&m_CriticalSection);
    InterlockedDecrement(&g_cComponent);
    TraceI(2, "Song %lx destroyed\n", this );
}


void CSong::Clear()
{
    if (m_pAudioPathConfig)
    {
        m_pAudioPathConfig->Release();
        m_pAudioPathConfig = NULL;
    }
    m_GraphList.Clear();
    m_PlayList.Clear();
    m_SegmentList.Clear();
    m_VirtualSegmentList.Clear();
    m_dwStartSegID = DMUS_SONG_NOSEG;
    m_fPartialLoad = FALSE;
    m_dwFlags = 0;
    m_dwValidData = DMUS_OBJ_CLASS; // upon creation, only this data is valid
}

STDMETHODIMP_(void) CSong::Zombie()
{
    Clear();
    m_fZombie = true;
}

STDMETHODIMP CSong::QueryInterface(
    const IID &iid,   // @parm Interface to query for
    void **ppv)       // @parm The requested interface will be returned here
{
    V_INAME(CSong::QueryInterface);
    V_PTRPTR_WRITE(ppv);
    V_REFGUID(iid);

    *ppv = NULL;
    if (iid == IID_IUnknown || iid == IID_IDirectMusicSong)
    {
        *ppv = static_cast<IDirectMusicSong*>(this);
    }
    else if (iid == IID_CSong)
    {
        *ppv = static_cast<CSong*>(this);
    }
    else if (iid == IID_IPersistStream)
    {
        *ppv = static_cast<IPersistStream*>(this);
    }
    else if(iid == IID_IDirectMusicObject)
    {
        *ppv = static_cast<IDirectMusicObject*>(this);
    }
    else if (iid == IID_IDirectMusicObjectP)
    {
        *ppv = static_cast<IDirectMusicObjectP*>(this);
    }
    else if(iid == IID_IDispatch)
    {
        // A helper scripting object implements IDispatch, which we expose via COM aggregation.
        if (!m_pUnkDispatch)
        {
            // Create the helper object
            ::CoCreateInstance(
                CLSID_AutDirectMusicSong,
                static_cast<IDirectMusicSong*>(this),
                CLSCTX_INPROC_SERVER,
                IID_IUnknown,
                reinterpret_cast<void**>(&m_pUnkDispatch));
        }
        if (m_pUnkDispatch)
        {
            return m_pUnkDispatch->QueryInterface(IID_IDispatch, ppv);
        }
    }

    if (*ppv == NULL)
    {
        Trace(4,"Warning: Request to query unknown interface on Song object\n");
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG) CSong::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CSong::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        m_cRef = 100; // artificial reference count to prevent reentrency due to COM aggregation
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP CSong::Compose( )
{
    if (m_fZombie)
    {
        Trace(1, "Error: Call of IDirectMusicSong::Compose after the song has been garbage collected. "
                    "It is invalid to continue using a song after releasing it from the loader (ReleaseObject/ReleaseObjectByUnknown) "
                    "and then calling CollectGarbage or Release on the loader.");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    HRESULT hr = S_OK;
    EnterCriticalSection(&m_CriticalSection);
    // Go through the seg ref list and create master composition tracks for each composing track.
    TList<ComposingTrack> MasterTrackList;
    CVirtualSegment* pVirtualSegment = m_VirtualSegmentList.GetHead();
    for (; pVirtualSegment; pVirtualSegment = pVirtualSegment->GetNext())
    {
        if (!pVirtualSegment->m_pPlaySegment)
        {
            Trace(1,"Error: Corrupt song, one or more virtual segments do not resolve to real segments. Unable to compose.\n");
            hr = E_POINTER;
            break;
        }
        CSegment *pSegment = pVirtualSegment->m_pPlaySegment;
        CTrack* pTrack = pSegment->m_TrackList.GetHead();
        for (; pTrack; pTrack = pTrack->GetNext())
        {
            if (pTrack->m_dwFlags & DMUS_TRACKCONFIG_COMPOSING)
            {
                DWORD dwTrackGroup = pTrack->m_dwGroupBits;
                // filter out any group bits already covered by other master tracks of same type
                TListItem<ComposingTrack>* pMaster = MasterTrackList.GetHead();
                for (; pMaster; pMaster = pMaster->GetNext())
                {
                    ComposingTrack& rMaster = pMaster->GetItemValue();
                    if (rMaster.GetTrackID() == pTrack->m_guidClassID)
                    {
                        DWORD dwMaster = rMaster.GetTrackGroup();
                        if (dwMaster == dwTrackGroup)
                        {
                            // Exact match: put the track here.
                            hr = rMaster.AddTrack(pVirtualSegment, pTrack);
                            dwTrackGroup = 0;
                            break;
                        }
                        DWORD dwIntersection = dwMaster & dwTrackGroup;
                        if (dwIntersection)
                        {
                            dwTrackGroup |= ~dwIntersection;
                        }
                    }
                }
                // If we've still got any group bits left, add a new composing track
                if (dwTrackGroup)
                {
                    TListItem<ComposingTrack>* pTrackItem = new TListItem<ComposingTrack>;
                    if (!pTrackItem)
                    {
                        hr = E_OUTOFMEMORY;
                    }
                    else
                    {
                        ComposingTrack& rTrack = pTrackItem->GetItemValue();
                        rTrack.SetTrackGroup(dwTrackGroup);
                        rTrack.SetTrackID(pTrack->m_guidClassID);
                        rTrack.SetPriority(pTrack->m_dwPriority);
                        // Add tracks in priority order (higher priority first)
                        pMaster = MasterTrackList.GetHead();
                        TListItem<ComposingTrack>* pPrevious = NULL;
                        for (; pMaster; pMaster = pMaster->GetNext())
                        {
                            ComposingTrack& rMaster = pMaster->GetItemValue();
                            if (pTrack->m_dwPriority > rMaster.GetPriority()) break;
                            pPrevious = pMaster;
                        }
                        if (!pPrevious) // this has higher priority than anything in the list
                        {
                            MasterTrackList.AddHead(pTrackItem);
                        }
                        else // lower priority than pPrevious, higher than pMaster
                        {
                            pTrackItem->SetNext(pMaster);
                            pPrevious->SetNext(pTrackItem);
                        }
                        hr = pTrackItem->GetItemValue().AddTrack(pVirtualSegment, pTrack);
                    }
                }
            }
            if (FAILED(hr)) break;
        }
        if (FAILED(hr)) break;
    }

    // Call compose on each master composition track
    if (SUCCEEDED(hr))
    {
        TListItem<ComposingTrack>* pMaster = MasterTrackList.GetHead();
        if (pMaster)
        {
            for (; pMaster; pMaster = pMaster->GetNext())
            {
                hr = pMaster->GetItemValue().Compose(this);
            }
        }
        else hr = S_FALSE;
    }

    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

STDMETHODIMP CSong::Download(IUnknown *pAudioPath)
{
    V_INAME(IDirectMusicSong::Download);
    V_INTERFACE(pAudioPath);

    if (m_fZombie)
    {
        Trace(1, "Error: Call of IDirectMusicSong::Download after the song has been garbage collected. "
                    "It is invalid to continue using a song after releasing it from the loader (ReleaseObject/ReleaseObjectByUnknown) "
                    "and then calling CollectGarbage or Release on the loader.");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    DWORD dwSuccess = 0;
    HRESULT hr = S_OK;
    HRESULT hrFail = S_OK;
    EnterCriticalSection(&m_CriticalSection);
    CSegment *pSegment = m_PlayList.GetHead();
    for (;pSegment;pSegment = pSegment->GetNext())
    {
        if (SUCCEEDED(hr = pSegment->Download(pAudioPath)))
        {
            // count partial successes, so that S_FALSE will be returned if we have, e.g.,
            // one partial success followed by one failure
            dwSuccess++;
        }
        if (hr != S_OK)
        {
            // keep track of partial successes so that they always percolate up
            hrFail = hr;
        }
    }
    LeaveCriticalSection(&m_CriticalSection);
    if (hrFail != S_OK && dwSuccess)
    {
        Trace(1,"Warning: Only %ld of the total %ld segments successfully downloaded.\n",
            dwSuccess,m_PlayList.GetCount());
        hr = S_FALSE;
    }
    return hr;
}

STDMETHODIMP CSong::Unload(IUnknown *pAudioPath)
{
    V_INAME(IDirectMusicSong::Unload);
    V_INTERFACE(pAudioPath);

    if (m_fZombie)
    {
        Trace(1, "Error: Call of IDirectMusicSong::Unload after the song has been garbage collected. "
                    "It is invalid to continue using a song after releasing it from the loader (ReleaseObject/ReleaseObjectByUnknown) "
                    "and then calling CollectGarbage or Release on the loader.");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    DWORD dwSuccess = 0;
    HRESULT hr = S_OK;
    HRESULT hrFail = S_OK;
    EnterCriticalSection(&m_CriticalSection);
    CSegment *pSegment = m_PlayList.GetHead();
    for (;pSegment;pSegment = pSegment->GetNext())
    {
        if (SUCCEEDED(hr = pSegment->Unload(pAudioPath)))
        {
            dwSuccess++;
        }
        else
        {
            hrFail = hr;
        }
    }
    LeaveCriticalSection(&m_CriticalSection);
    if (FAILED(hrFail) && dwSuccess)
    {
        Trace(1,"Warning: Only %ld of the total %ld segments successfully unloaded.\n",
            dwSuccess,m_PlayList.GetCount());
        hr = S_FALSE;
    }
    return hr;
}


/*STDMETHODIMP CSong::Clone(IDirectMusicSong **ppSong)

{
    V_INAME(IDirectMusicSong::Clone);
    V_PTRPTR_WRITE_OPT(ppSong);
    HRESULT hr = E_OUTOFMEMORY;
    CSong *pSong = new CSong();
    if (*ppSong)
    {
        *ppSong = pSong;
        EnterCriticalSection(&m_CriticalSection);
        CSegment *pSegment = m_PlayList.GetHead();
        for (;pSegment;pSegment = pSegment->GetNext())
        {
            IDirectMusicSegment *pISeg;
            hr = pSegment->Clone(0,pSegment->m_mtLength,&pISeg);
            if (SUCCEEDED(hr))
            {
                CSegment *pCopy = (CSegment *) pISeg;
                pSong->m_PlayList.AddTail(pCopy);
                pCopy->m_pSong = pSong;
            }
        }
        pSong->m_dwValidData = m_dwValidData;
        pSong->m_guidObject = m_guidObject;
        pSong->m_ftDate = m_ftDate;
        pSong->m_vVersion = m_vVersion;
        wcscpy(pSong->m_wszName,m_wszName);
        wcscpy(pSong->m_wszCategory,m_wszCategory);
        wcscpy(pSong->m_wszFileName,m_wszFileName);
        pSong->m_dwVersion = m_dwVersion;
        pSong->m_dwFlags = m_dwFlags;
        pSong->m_pAudioPathConfig = m_pAudioPathConfig;
        if (m_pAudioPathConfig)
            m_pAudioPathConfig->AddRef();
        LeaveCriticalSection(&m_CriticalSection);
    }
    return hr;
}
*/

STDMETHODIMP CSong::GetParam( REFGUID rguidType,
                        DWORD dwGroupBits,
                        DWORD dwIndex,
                        MUSIC_TIME mtTime,
                        MUSIC_TIME* pmtNext,
                        void* pParam)
{
    V_INAME(IDirectMusiCSong::GetParam);
    V_REFGUID(rguidType);
    V_PTR_WRITE_OPT(pmtNext,MUSIC_TIME);

    if (m_fZombie)
    {
        Trace(1, "Error: Call of IDirectMusicSong::GetParam after the song has been garbage collected. "
                    "It is invalid to continue using a song after releasing it from the loader (ReleaseObject/ReleaseObjectByUnknown) "
                    "and then calling CollectGarbage or Release on the loader.");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    HRESULT hr = DMUS_E_TRACK_NOT_FOUND;
/*    BOOL fMultipleTry = FALSE;
    if (dwIndex == DMUS_SEG_ANYTRACK)
    {
        dwIndex = 0;
        fMultipleTry = TRUE;
    }*/
    EnterCriticalSection(&m_CriticalSection);
    /*CSegment *pSegment = m_PlayList.GetHead();
    for (;pSegment;pSegment = pSegment->GetNext())
    {
        if (pSegment->m_mtStart <= mtTime &&
            mtTime < pSegment->m_mtStart + pSegment->m_mtLength)
        {
            hr = pSegment->GetParam(rguidType, dwGroupBits, dwIndex, mtTime - pSegment->m_mtStart, pmtNext, pParam);
            if (SUCCEEDED(hr)) break;
        }
    }*/
    CVirtualSegment *pVirtualSegment = m_VirtualSegmentList.GetHead();
    for (;pVirtualSegment;pVirtualSegment = pVirtualSegment->GetNext())
    {
        if (pVirtualSegment->m_mtTime <= mtTime &&
            pVirtualSegment->m_pPlaySegment &&
            mtTime < pVirtualSegment->m_mtTime + pVirtualSegment->m_pPlaySegment->m_mtLength)
        {
            hr = pVirtualSegment->m_pPlaySegment->GetParam(rguidType, dwGroupBits, dwIndex, mtTime - pVirtualSegment->m_mtTime, pmtNext, pParam);
            if (SUCCEEDED(hr)) break;
        }
    }
/*    for (;pVirtualSegment;pVirtualSegment = pVirtualSegment->GetNext())
    {
        if (pVirtualSegment->m_mtTime <= mtTime)
        {
            CTrack* pCTrack;
            pCTrack = pVirtualSegment->GetTrackByParam(NULL, rguidType,dwGroupBits, dwIndex);
            while (pCTrack)
            {
                if (pCTrack->m_pTrack8)
                {
                    REFERENCE_TIME rtNext, *prtNext;
                    // We need to store the next time in a 64 bit pointer. But, don't
                    // make 'em fill it in unless the caller requested it.
                    if (pmtNext)
                    {
                        prtNext = &rtNext;
                    }
                    else
                    {
                        prtNext = NULL;
                    }
                    hr = pCTrack->m_pTrack8->GetParamEx( rguidType, mtTime - pVirtualSegment->m_mtTime, prtNext, pParam,
                        NULL, 0 );
                    if (pmtNext)
                    {
                        *pmtNext = (MUSIC_TIME) rtNext;
                    }
                }
                else
                {
                    hr = pCTrack->m_pTrack->GetParam( rguidType, mtTime - pVirtualSegment->m_mtTime, pmtNext, pParam );
/ *                 if( pmtNext && (( *pmtNext == 0 ) || (*pmtNext > (m_mtLength - mtTime))))
                    {
                        *pmtNext = m_mtLength - mtTime;
                    }* /
                }
                // If nothing was found and dwIndex was DMUS_SEG_ANYTRACK, try again...
                if (fMultipleTry && (hr == DMUS_E_NOT_FOUND))
                {
                    pCTrack = pVirtualSegment->GetTrackByParam(pCTrack, rguidType,dwGroupBits, dwIndex);
                }
                else
                {
                    pCTrack = NULL;
                }
            }
        }
    }*/
    if (FAILED(hr) && pmtNext)
    {
        // return the time of the first segment after mtTime (or 0 if there is no such segment)
        pVirtualSegment = m_VirtualSegmentList.GetHead();
        for (;pVirtualSegment;pVirtualSegment = pVirtualSegment->GetNext())
        {
            if (pVirtualSegment->m_mtTime > mtTime)
            {
                *pmtNext = pVirtualSegment->m_mtTime;
                break;
            }
        }
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

HRESULT CSong::Instantiate()
{
    V_INAME(IDirectMusicSong::Instantiate);
    EnterCriticalSection(&m_CriticalSection);
    CVirtualSegment *pRef = m_VirtualSegmentList.GetHead();
    m_PlayList.Clear();
    for (;pRef;pRef = pRef->GetNext())
    {
        // the constructor below does an AddRef.
        CSegment *pSegment = new CSegment(&pRef->m_SegHeader,pRef->m_pSourceSegment);
        if (pSegment)
        {
            if (pRef->m_wszName[0])
            {
                wcscpy(pSegment->m_wszName,pRef->m_wszName);
                pSegment->m_dwValidData |= DMUS_OBJ_NAME;
            }
            CTrack *pTrack;
            for (pTrack = pRef->m_TrackList.GetHead();pTrack;pTrack = pTrack->GetNext())
            {
                CTrack *pCopy = new CTrack;
                if( pCopy )
                {
                    *pCopy = *pTrack;
                    pCopy->SetNext(NULL);
                    pCopy->m_pTrackState = NULL;
                    pCopy->m_pTrack->AddRef();
                    if (pCopy->m_pTrack8)
                    {
                        pCopy->m_pTrack8->AddRef();
                    }
                    // The tracks were in backwards order. This puts them back in order, and ahead of the segment tracks.
                    pSegment->m_TrackList.AddHead( pCopy );
                }
            }
            pSegment->m_pSong = this;
            pSegment->m_dwPlayID = pRef->m_dwID;
//Trace(0,"Intantiating PlaySegment %ls with ID %ld.\n",pRef->m_wszName,pRef->m_dwID);
            pSegment->m_dwNextPlayFlags = pRef->m_dwNextPlayFlags;
            pSegment->m_dwNextPlayID = pRef->m_dwNextPlayID;
            m_PlayList.AddTail(pSegment);
            if (pRef->m_pPlaySegment) pRef->m_pPlaySegment->Release();
            pRef->m_pPlaySegment = pSegment;
            pRef->m_pPlaySegment->AddRef();
        }
    }
    LeaveCriticalSection(&m_CriticalSection);
    return S_OK;
}

HRESULT CSong::EnumSegment( DWORD dwIndex,IDirectMusicSegment **ppSegment)
{
    V_INAME(IDirectMusicSong::EnumSegment);
    V_PTRPTR_WRITE (ppSegment);

    if (m_fZombie)
    {
        Trace(1, "Error: Call of IDirectMusicSong::EnumSegment after the song has been garbage collected. "
                    "It is invalid to continue using a song after releasing it from the loader (ReleaseObject/ReleaseObjectByUnknown) "
                    "and then calling CollectGarbage or Release on the loader.");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    HRESULT hr = S_FALSE;
    EnterCriticalSection(&m_CriticalSection);
    CSegment *pSegment = m_PlayList.GetHead();
    for (;pSegment && dwIndex;pSegment = pSegment->GetNext()) dwIndex--;
    if (pSegment)
    {
        *ppSegment = static_cast<IDirectMusicSegment*>(pSegment);
        pSegment->AddRef();
        hr = S_OK;
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

HRESULT CSong::GetPlaySegment( DWORD dwIndex,CSegment **ppSegment)
{
    HRESULT hr = S_FALSE;
    EnterCriticalSection(&m_CriticalSection);
    CSegment *pSegment = m_PlayList.GetHead();
    for (;pSegment;pSegment = pSegment->GetNext())
    {
        if (pSegment->m_dwPlayID == dwIndex)
        {
            *ppSegment = pSegment;
            pSegment->AddRef();
            hr = S_OK;
            break;
        }
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

STDMETHODIMP CSong::GetSegment(WCHAR *wszName, IDirectMusicSegment **ppSegment)
{
    V_INAME(IDirectMusicSong::GetSegment);
    V_PTRPTR_WRITE(ppSegment);

    if (m_fZombie)
    {
        Trace(1, "Error: Call of IDirectMusicSong::GetSegment after the song has been garbage collected. "
                    "It is invalid to continue using a song after releasing it from the loader (ReleaseObject/ReleaseObjectByUnknown) "
                    "and then calling CollectGarbage or Release on the loader.");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    HRESULT hr = S_FALSE;
    CSegment *pSegment;
    if (wszName)
    {
        V_BUFPTR_READ(wszName,2);
        EnterCriticalSection(&m_CriticalSection);
        pSegment = m_PlayList.GetHead();
        for (;pSegment;pSegment = pSegment->GetNext())
        {
            if (_wcsicmp(pSegment->m_wszName, wszName) == 0)
            {
                pSegment->AddRef();
                hr = S_OK;
                break;
            }
        }
        LeaveCriticalSection(&m_CriticalSection);
    }
    else
    {
        hr = GetPlaySegment( m_dwStartSegID,&pSegment);
    }
    if (hr == S_OK)
    {
        *ppSegment = static_cast<IDirectMusicSegment*>(pSegment);
    }
    else
    {
#ifdef DBG
        if (wszName)
        {
            Trace(1,"Error: Unable to find segment %ls in song.\n",wszName);
        }
        else
        {
            Trace(1,"Error: Unable to find starting segment in the song.\n");
        }
#endif
    }
    return hr;
}

STDMETHODIMP CSong::GetAudioPathConfig(IUnknown ** ppAudioPathConfig)
{
    V_INAME(IDirectMusicSegment::GetAudioPathConfig);
    V_PTRPTR_WRITE(ppAudioPathConfig);

    if (m_fZombie)
    {
        Trace(1, "Error: Call of IDirectMusicSong::GetAudioPathConfig after the song has been garbage collected. "
                    "It is invalid to continue using a song after releasing it from the loader (ReleaseObject/ReleaseObjectByUnknown) "
                    "and then calling CollectGarbage or Release on the loader.");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    HRESULT hr;
    EnterCriticalSection(&m_CriticalSection);
    if (m_pAudioPathConfig)
    {
        hr = m_pAudioPathConfig->QueryInterface(IID_IUnknown,(void **)ppAudioPathConfig);
    }
    else
    {
        Trace(2,"Warning: No embedded audiopath configuration in the song.\n");
        hr = DMUS_E_NO_AUDIOPATH_CONFIG;
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// IPersist

HRESULT CSong::GetClassID( CLSID* pClassID )
{
    V_INAME(CSong::GetClassID);
    V_PTR_WRITE(pClassID, CLSID);

    if (m_fZombie)
    {
        Trace(1, "Error: Call of IDirectMusicSong::GetClassID after the song has been garbage collected. "
                    "It is invalid to continue using a song after releasing it from the loader (ReleaseObject/ReleaseObjectByUnknown) "
                    "and then calling CollectGarbage or Release on the loader.");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    *pClassID = CLSID_DirectMusicSong;
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IPersistStream functions

HRESULT CSong::IsDirty()
{
    return E_NOTIMPL;
}

HRESULT CSong::Load( IStream* pIStream )
{
    V_INAME(CSong::Load);
    V_INTERFACE(pIStream);

    // Song format temporarily turned off for DX8 release.
    return E_NOTIMPL;
    /*
    if (m_fZombie)
    {
        Trace(1, "Error: Call of IDirectMusicSong::Load after the song has been garbage collected. "
                    "It is invalid to continue using a song after releasing it from the loader (ReleaseObject/ReleaseObjectByUnknown) "
                    "and then calling CollectGarbage or Release on the loader.");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    // Create RIFF parser.
    CRiffParser Parser(pIStream);

    RIFFIO ckMain;
    HRESULT hr = S_OK;
    // First, clear the song in case it is being read into a second time.
    Clear();

    Parser.EnterList(&ckMain);
    if (Parser.NextChunk(&hr))
    {
        if (ckMain.fccType == DMUS_FOURCC_SONG_FORM)
        {
            EnterCriticalSection(&m_CriticalSection);
            RIFFIO ckNext;
            RIFFIO ckChild;
            IDirectMusicContainer *pContainer = NULL; // For handling embedded container with linked objects.
            Parser.EnterList(&ckNext);
            while(Parser.NextChunk(&hr))
            {
                switch(ckNext.ckid)
                {
                    case DMUS_FOURCC_SONG_CHUNK:
                        DMUS_IO_SONG_HEADER ioSongHdr;
                        ioSongHdr.dwFlags = 0;
                        hr = Parser.Read(&ioSongHdr, sizeof(DMUS_IO_SONG_HEADER));
                        if(SUCCEEDED(hr))
                        {
                            m_dwFlags = ioSongHdr.dwFlags;
                            m_dwStartSegID = ioSongHdr.dwStartSegID;
                        }
                        break;

                    case DMUS_FOURCC_GUID_CHUNK:
                        if( ckNext.cksize == sizeof(GUID) )
                        {
                            hr = Parser.Read(&m_guidObject, sizeof(GUID));
                            if( SUCCEEDED(hr) )
                            {
                                m_dwValidData |= DMUS_OBJ_OBJECT;
                            }
                        }
                        break;

                    case DMUS_FOURCC_VERSION_CHUNK:
                        hr = Parser.Read( &m_vVersion, sizeof(DMUS_VERSION) );
                        if( SUCCEEDED(hr) )
                        {
                            m_dwValidData |= DMUS_OBJ_VERSION;
                        }
                        break;

                    case DMUS_FOURCC_CATEGORY_CHUNK:
                        hr = Parser.Read( m_wszCategory, sizeof(WCHAR)*DMUS_MAX_CATEGORY );
                        if( SUCCEEDED(hr) )
                        {
                            m_dwValidData |= DMUS_OBJ_CATEGORY;
                        }
                        break;

                    case DMUS_FOURCC_DATE_CHUNK:
                        if( sizeof(FILETIME) == ckNext.cksize )
                        {
                            hr = Parser.Read( &m_ftDate, sizeof(FILETIME) );
                            if( SUCCEEDED(hr) )
                            {
                                m_dwValidData |= DMUS_OBJ_DATE;
                            }
                        }
                        break;

                    case FOURCC_LIST:
                    case FOURCC_RIFF:
                        switch(ckNext.fccType)
                        {
                            case DMUS_FOURCC_UNFO_LIST:
                                Parser.EnterList(&ckChild);
                                while(Parser.NextChunk(&hr))
                                {
                                    switch( ckChild.ckid )
                                    {
                                        case DMUS_FOURCC_UNAM_CHUNK:
                                        {
                                            hr = Parser.Read(&m_wszName, sizeof(m_wszName));
                                            if(SUCCEEDED(hr) )
                                            {
                                                m_dwValidData |= DMUS_OBJ_NAME;
                                            }
                                            break;
                                        }
                                        default:
                                            break;
                                    }
                                }
                                Parser.LeaveList();
                                break;
                            case DMUS_FOURCC_CONTAINER_FORM:
                                // An embedded container RIFF chunk which includes a bunch
                                // of objects referenced by the song. This should precede the
                                // segments and gets loaded prior to them. Loading this
                                // causes all of its objects to get SetObject'd in the loader,
                                // so they later get pulled in as requested by the tracks in the segments.
                                // After the tracks are loaded, the loader references are
                                // released by a call to release the IDirectMusicContainer.
                                {
                                    DMUS_OBJECTDESC Desc;
                                    IDirectMusicLoader *pLoader;
                                    IDirectMusicGetLoader *pGetLoader;
                                    HRESULT hr = pIStream->QueryInterface(IID_IDirectMusicGetLoader,(void **) &pGetLoader);
                                    if (SUCCEEDED(hr))
                                    {
                                        if (SUCCEEDED(pGetLoader->GetLoader(&pLoader)))
                                        {
                                            // Move back stream's current position
                                            Parser.SeekBack();
                                            Desc.dwSize = sizeof(Desc);
                                            Desc.dwValidData = DMUS_OBJ_CLASS | DMUS_OBJ_STREAM;
                                            Desc.guidClass = CLSID_DirectMusicContainer;
                                            Desc.pStream = pIStream;
                                            pLoader->GetObject(&Desc,IID_IDirectMusicContainer,(void **) &pContainer);
                                            if (pContainer)
                                            {
                                                // Don't cache the container object! We want it and the
                                                // objects it references to go away when the segment is done loading.
                                                IDirectMusicObject *pObject = NULL;
                                                pContainer->QueryInterface(IID_IDirectMusicObject,(void **)&pObject);
                                                if (pObject)
                                                {
                                                    pLoader->ReleaseObject(pObject);
                                                    pObject->Release();
                                                }
                                            }
                                            // Now, seek to the end of this chunk.
                                            Parser.SeekForward();
                                            pLoader->Release();
                                        }
                                        pGetLoader->Release();
                                    }
                                }
                                break;
                            case DMUS_FOURCC_SONGSEGMENTS_LIST:
                                hr = LoadSegmentList(&Parser); //pIStream, pIDirectMusicStream, ckNext);
                                break;
                            case DMUS_FOURCC_SEGREFS_LIST:
                                hr = LoadVirtualSegmentList(&Parser);
                                break;
                            case DMUS_FOURCC_AUDIOPATH_FORM:
                                // Move back to start of this chunk.
                                Parser.SeekBack();
                                hr = LoadAudioPath(pIStream);
                                // Now, seek to the end of this chunk.
                                Parser.SeekForward();
                                break;
                            default:
                                break;
                        }
                        break;

                    default:
                        break;

                }
            }
            Parser.LeaveList();
            LeaveCriticalSection(&m_CriticalSection);

            if (pContainer)
            {
                pContainer->Release();
            }

            if( SUCCEEDED(hr) )
            {
                if( m_fPartialLoad & PARTIALLOAD_E_FAIL )
                {
                    if( m_fPartialLoad & PARTIALLOAD_S_OK )
                    {
                        Trace(1,"Error: Song load was incomplete, some components failed loading.\n");
                        hr = DMUS_S_PARTIALLOAD;
                    }
                    else
                    {
                        Trace(1,"Error: Song load failed because all components failed loading.\n");
                        hr = DMUS_E_ALL_TRACKS_FAILED;
                    }
                }
            }
        }
        else
        {
            // Couldn't find the chunk header for a song.
            // But, maybe this is actually a segment, in which case see if
            // the segment object will load it.
            CSegment *pSegment = new CSegment;
            if (pSegment)
            {
                pSegment->AddRef(); // Segment::Load (and possibly others) may need the refcount
                // Force the version so audiopath functionality will be supported.
                pSegment->m_dwVersion = 8;
                Parser.SeekBack();
                hr = pSegment->Load(pIStream);
                if (SUCCEEDED(hr))
                {
                    DMUS_OBJECTDESC Desc;
                    Desc.dwSize = sizeof (Desc);
                    pSegment->GetDescriptor(&Desc);
                    Desc.guidClass = CLSID_DirectMusicSong;
                    SetDescriptor(&Desc);
                    // AddSegment addref's by one.
                    m_SegmentList.AddSegment(pSegment,0);
                    pSegment->GetAudioPathConfig((IUnknown **) &m_pAudioPathConfig);
                    m_dwStartSegID = 0; // Points to this segment.
                    CVirtualSegment *pVirtual = new CVirtualSegment;
                    if (pVirtual)
                    {
                        pVirtual->m_pSourceSegment = pSegment;
                        pSegment->AddRef();
                        pVirtual->m_SegHeader.dwRepeats = pSegment->m_dwRepeats;
                        pVirtual->m_SegHeader.dwResolution = pSegment->m_dwResolution;
                        pVirtual->m_SegHeader.mtLength = pSegment->m_mtLength;
                        pVirtual->m_SegHeader.mtLoopEnd = pSegment->m_mtLoopEnd;
                        pVirtual->m_SegHeader.mtLoopStart = pSegment->m_mtLoopStart;
                        pVirtual->m_SegHeader.mtPlayStart = pSegment->m_mtStart;
                        pVirtual->m_SegHeader.rtLength = pSegment->m_rtLength;
                        pVirtual->m_SegHeader.dwFlags = pSegment->m_dwSegFlags;
                        if (pSegment->m_dwValidData & DMUS_OBJ_NAME)
                        {
                            wcscpy(pVirtual->m_wszName,pSegment->m_wszName);
                        }
                        m_VirtualSegmentList.AddHead(pVirtual);
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                    pSegment->Release(); // release the initial AddRef
                }
                if (FAILED(hr))
                {
                    delete pSegment;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    // If there are no virtual segments, clear the song and fail the load
    if ( !m_VirtualSegmentList.GetHead() )
    {
        Clear();
        hr = DMUS_E_NOT_INIT;
    }
    if (SUCCEEDED(hr)) Instantiate();
    return hr;*/
}

HRESULT CSong::LoadAudioPath(IStream *pStream)
{
    assert(pStream);

    CAudioPathConfig *pPath = new CAudioPathConfig;
    if (pPath == NULL) {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pPath->Load(pStream);

    EnterCriticalSection(&m_CriticalSection);
    if(m_pAudioPathConfig)
    {
        m_pAudioPathConfig->Release();
    }
    m_pAudioPathConfig = pPath;
    LeaveCriticalSection(&m_CriticalSection);

    return hr;
}

HRESULT CSong::LoadReferencedSegment(CSegment **ppSegment, CRiffParser *pParser)
{

    IDirectMusicLoader* pLoader = NULL;
    IDirectMusicGetLoader *pIGetLoader;
    HRESULT hr = pParser->GetStream()->QueryInterface( IID_IDirectMusicGetLoader,(void **) &pIGetLoader );
    if (FAILED(hr)) return hr;
    hr = pIGetLoader->GetLoader(&pLoader);
    pIGetLoader->Release();
    if (FAILED(hr)) return hr;

    DMUS_OBJECTDESC desc;
    ZeroMemory(&desc, sizeof(desc));

    RIFFIO ckNext;

    pParser->EnterList(&ckNext);
    while(pParser->NextChunk(&hr))
    {
        switch(ckNext.ckid)
        {
            case  DMUS_FOURCC_REF_CHUNK:
                DMUS_IO_REFERENCE ioDMRef;
                hr = pParser->Read(&ioDMRef, sizeof(DMUS_IO_REFERENCE));
                if(SUCCEEDED(hr))
                {
                    if (ioDMRef.guidClassID != CLSID_DirectMusicSegment)
                    {
                        Trace(1,"Error: Invalid segment reference in song.\n");
                        hr = DMUS_E_CANNOTREAD;
                    }
                    else
                    {
                        desc.guidClass = ioDMRef.guidClassID;
                        desc.dwValidData |= ioDMRef.dwValidData;
                        desc.dwValidData |= DMUS_OBJ_CLASS;
                    }
                }
                break;

            case DMUS_FOURCC_GUID_CHUNK:
                hr = pParser->Read(&(desc.guidObject), sizeof(GUID));
                if(SUCCEEDED(hr))
                {
                    desc.dwValidData |=  DMUS_OBJ_OBJECT;
                }
                break;

            case DMUS_FOURCC_NAME_CHUNK:
                hr = pParser->Read(desc.wszName, sizeof(desc.wszName));
                if(SUCCEEDED(hr))
                {
                    desc.dwValidData |=  DMUS_OBJ_NAME;
                }
                break;

            case DMUS_FOURCC_FILE_CHUNK:
                hr = pParser->Read(desc.wszFileName, sizeof(desc.wszFileName));
                if(SUCCEEDED(hr))
                {
                    desc.dwValidData |=  DMUS_OBJ_FILENAME;
                }
                break;

            case DMUS_FOURCC_CATEGORY_CHUNK:
                hr = pParser->Read(desc.wszCategory, sizeof(desc.wszCategory));
                if(SUCCEEDED(hr))
                {
                    desc.dwValidData |=  DMUS_OBJ_CATEGORY;
                }
                break;

            default:
                break;
        }
    }
    pParser->LeaveList();

    if(SUCCEEDED(hr))
    {
        desc.dwSize = sizeof(DMUS_OBJECTDESC);
        hr = pLoader->GetObject(&desc, IID_CSegment, (void**)ppSegment);
        // Once we get the object, we need to ensure that the same object is never
        // connected up to any other songs (or this one, too.)
        // So, we ensure that the loader doesn't keep it around.
        if (SUCCEEDED(hr))
        {
            IDirectMusicObject *pObject;
            if (SUCCEEDED((*ppSegment)->QueryInterface(IID_IDirectMusicObject,(void **)&pObject)))
            {
                pLoader->ReleaseObject(pObject);
                pObject->Release();
            }
            // If the segment has a next pointer, it still must be in another song. This
            // should never happen, but being paranoid...
            if ((*ppSegment)->GetNext())
            {
                *ppSegment = NULL;
                hr = E_FAIL;
                TraceI(0,"Error: Attempt to load song segment that is already referenced by another song. \n");
            }
        }
    }

    if (pLoader)
    {
        pLoader->Release();
    }
    return hr;
}

HRESULT CSong::LoadSegmentList(CRiffParser *pParser)
{
    assert(pParser);

    RIFFIO ckNext, ckChild;
    DWORD dwSegmentCount = 0;

    HRESULT hr = S_OK;
    pParser->EnterList(&ckNext);
    while(pParser->NextChunk(&hr))
    {
        switch(ckNext.ckid)
        {
        case FOURCC_LIST:
            if (ckNext.fccType == DMUS_FOURCC_SONGSEGMENT_LIST)
            {
                pParser->EnterList(&ckChild);
                while (pParser->NextChunk(&hr))
                {
                    switch(ckChild.ckid)
                    {
                    case FOURCC_RIFF:
                    case FOURCC_LIST:
                        if ((ckChild.fccType == DMUS_FOURCC_SEGMENT_FORM) ||
                            (ckChild.fccType == DMUS_FOURCC_REF_LIST))
                        {
                            CSegment *pSegment = NULL;
                            if (ckChild.fccType == DMUS_FOURCC_SEGMENT_FORM)
                            {
                                pSegment = new CSegment;
                                if (pSegment)
                                {
                                    pSegment->AddRef(); // Segment::Load may need a refcount
                                    // Force the version so audiopath functionality will be supported.
                                    pSegment->m_dwVersion = 8;
                                    // Move back to start of this chunk.
                                    pParser->SeekBack();
                                    hr = pSegment->Load(pParser->GetStream());
                                    pParser->SeekForward();
                                }
                                else
                                {
                                    return E_OUTOFMEMORY;
                                }
                            }
                            else
                            {
                                // This will increment the refcount for the segment
                                hr = LoadReferencedSegment( &pSegment, pParser );
                            }
                            if (SUCCEEDED(hr))
                            {
                                // This increments the refcount.
                                m_SegmentList.AddSegment(pSegment,dwSegmentCount);
                            }
                            pSegment->Release(); // Release the extra AddRef
                            dwSegmentCount++;
                            if(SUCCEEDED(hr) && hr != DMUS_S_PARTIALLOAD)
                            {
                                m_fPartialLoad |= PARTIALLOAD_S_OK;
                            }
                            else
                            {
                                m_fPartialLoad |= PARTIALLOAD_E_FAIL;
                                hr = S_OK;
                            }

                        }
                        break;
                    }
                }
                pParser->LeaveList();
            }

        default:
            break;

        }
    }
    pParser->LeaveList();

    return hr;
}

HRESULT CSong::LoadGraphList(CRiffParser *pParser)
{
    RIFFIO ckNext;
    DWORD dwGraphCount = 0;

    HRESULT hr = S_OK;
    pParser->EnterList(&ckNext);
    while(pParser->NextChunk(&hr))
    {
        switch(ckNext.ckid)
        {
            case FOURCC_RIFF:
                switch(ckNext.fccType)
                {
                    CGraph *pGraph;
                    case DMUS_FOURCC_TOOLGRAPH_FORM :
                        // Move back to start of this chunk.
                        pParser->SeekBack();
                        pGraph = new CGraph;
                        if (pGraph)
                        {
                            hr = pGraph->Load(pParser->GetStream());
                            dwGraphCount++;
                            if (SUCCEEDED(hr))
                            {
                                m_GraphList.AddTail(pGraph);
                                pGraph->m_dwLoadID = dwGraphCount;
                            }
                            if(SUCCEEDED(hr) && hr != DMUS_S_PARTIALLOAD)
                            {
                                m_fPartialLoad |= PARTIALLOAD_S_OK;
                            }
                            else
                            {
                                m_fPartialLoad |= PARTIALLOAD_E_FAIL;
                                hr = S_OK;
                            }
                        }
                        else
                        {
                            return E_OUTOFMEMORY;
                        }
                        pParser->SeekForward();
                        break;
                    default:
                        break;
                }
                break;

            default:
                break;

        }
    }
    pParser->LeaveList();
    return hr;
}

HRESULT CSong::GetTransitionSegment(CSegment *pSource, CSegment *pDestination,
                                    DMUS_IO_TRANSITION_DEF *pTransDef)
{
    HRESULT hr = DMUS_E_NOT_FOUND;
//    if (pSource) Trace(0,"Transitioning from %ls ",pSource->m_wszName);
//    if (pDestination) Trace(0,"to %ls",pDestination->m_wszName);
//    Trace(0,"\n");
    EnterCriticalSection(&m_CriticalSection);
    // Default values for other fields, in case we don't find a match.
    pTransDef->dwPlayFlags = 0;
    pTransDef->dwTransitionID = DMUS_SONG_NOSEG;
    pTransDef->dwSegmentID = DMUS_SONG_NOSEG;
    CVirtualSegment *pVSource = NULL;
    // If there is a source segment, look to see if it's in this song
    // and pull the matchin virtual segment.
    if (pSource)
    {
        pVSource = m_VirtualSegmentList.GetHead();
        for (;pVSource;pVSource = pVSource->GetNext())
        {
            if (pVSource->m_pPlaySegment == pSource)
            {
//                Trace(0,"Found match for source segment %ls in song\n",pSource->m_wszName);
                break;
            }
        }
    }
    CVirtualSegment *pVDestination = NULL;
    // If there is a destination segment, look to see if it's in this song
    // and pull the matching virtual segment.
    if (pDestination)
    {
        pVDestination = m_VirtualSegmentList.GetHead();
        for (;pVDestination;pVDestination = pVDestination->GetNext())
        {
            if (pVDestination->m_pPlaySegment == pDestination)
            {
//                Trace(0,"Found match for destination segment %ls in song\n",pDestination->m_wszName);
                break;
            }
        }
    }

    if (pVSource)
    {
        if (pVDestination)
        {
            pTransDef->dwSegmentID = pVDestination->m_dwID;
        }
        else
        {
            // If there is no destination, mark this to transition to nothing.
            pTransDef->dwSegmentID = DMUS_SONG_NOSEG;
        }
        if (pVSource->m_dwTransitionCount)
        {
            ASSERT(pVSource->m_pTransitions);
            DWORD dwIndex;
            DWORD dwMatchCount = 0;
            // First, find out how many transitions match the requirement.
            // We'll randomly select from the matching ones.
            for (dwIndex = 0; dwIndex < pVSource->m_dwTransitionCount; dwIndex++)
            {
                if (pVSource->m_pTransitions[dwIndex].dwSegmentID == pTransDef->dwSegmentID)
                {
                    dwMatchCount++;
                }
            }
            DWORD dwChoice;
            if (dwMatchCount)
            {
                dwChoice = rand() % dwMatchCount;
            }
            for (dwIndex = 0; dwIndex < pVSource->m_dwTransitionCount; dwIndex++)
            {
                if (pVSource->m_pTransitions[dwIndex].dwSegmentID == pTransDef->dwSegmentID)
                {
                    if (!dwChoice)
                    {
//Trace(0,"Chose transition from %lx with Transition %lx, flags %lx\n",pVSource->m_pTransitions[dwIndex].dwSegmentID,
//    pVSource->m_pTransitions[dwIndex].dwTransitionID,pVSource->m_pTransitions[dwIndex].dwPlayFlags);
                        pTransDef->dwPlayFlags = pVSource->m_pTransitions[dwIndex].dwPlayFlags;
                        pTransDef->dwTransitionID = pVSource->m_pTransitions[dwIndex].dwTransitionID;
                        hr = S_OK;
                        break;
                    }
                    dwChoice--;
                }
                else if ((pVSource->m_pTransitions[dwIndex].dwSegmentID == DMUS_SONG_ANYSEG) && !dwMatchCount)
                {
                    // Mark the segment and flags, but don't break because we might still have the matched segment in the list.
                    pTransDef->dwPlayFlags = pVSource->m_pTransitions[dwIndex].dwPlayFlags;
                    pTransDef->dwTransitionID = pVSource->m_pTransitions[dwIndex].dwTransitionID;
//Trace(0,"Found default transition from %lx with Transition %lx, flags %lx\n",pVSource->m_pTransitions[dwIndex].dwSegmentID,
//    pVSource->m_pTransitions[dwIndex].dwTransitionID,pVSource->m_pTransitions[dwIndex].dwPlayFlags);
                    hr = S_OK;
                    break;
                }
            }
        }
    }
    else if (pVDestination)
    {
        // This is the special case where there is no source segment, perhaps because we are starting
        // playback or we are starting from a different song. In this case, look for a transition in the destination
        // segment for the special case of DMUS_SONG_NOFROMSEG. Typically, this represents a transition
        // segment that is an intro.
        if (pVDestination->m_dwTransitionCount)
        {
            ASSERT(pVDestination->m_pTransitions);
            DWORD dwIndex;
            DWORD dwMatchCount = 0;
            // First, find out how many transitions match the requirement.
            // We'll randomly select from the matching ones.
            for (dwIndex = 0; dwIndex < pVDestination->m_dwTransitionCount; dwIndex++)
            {
                if (pVDestination->m_pTransitions[dwIndex].dwSegmentID == DMUS_SONG_NOFROMSEG)
                {
                    dwMatchCount++;
                }
            }
            DWORD dwChoice;
            if (dwMatchCount)
            {
                dwChoice = rand() % dwMatchCount;
            }
            for (dwIndex = 0; dwIndex < pVDestination->m_dwTransitionCount; dwIndex++)
            {
                if (pVDestination->m_pTransitions[dwIndex].dwSegmentID == DMUS_SONG_NOFROMSEG)
                {
                    if (!dwChoice)
                    {
//Trace(0,"Chose transition from NONE with Transition %lx, flags %lx\n",
//    pVDestination->m_pTransitions[dwIndex].dwTransitionID,pVDestination->m_pTransitions[dwIndex].dwPlayFlags);
                        pTransDef->dwPlayFlags = pVDestination->m_pTransitions[dwIndex].dwPlayFlags;
                        pTransDef->dwTransitionID = pVDestination->m_pTransitions[dwIndex].dwTransitionID;
                        hr = S_OK;
                        break;
                    }
                    dwChoice--;
                }
            }
        }
    }
    LeaveCriticalSection(&m_CriticalSection);
#ifdef DBG
    if (hr == DMUS_E_NOT_FOUND)
    {
        Trace(2,"Warning: No transition segment was found in song.\n");
    }
#endif
    return hr;
}


void CSong::GetSourceSegment(CSegment **ppSegment,DWORD dwSegmentID)
{
    CSongSegment *pSongSegment = m_SegmentList.GetHead();
    while (pSongSegment)
    {
        if (pSongSegment->m_dwLoadID == dwSegmentID)
        {
            if (pSongSegment->m_pSegment)
            {
                pSongSegment->m_pSegment->AddRef();
                *ppSegment = pSongSegment->m_pSegment;
                return;
            }
        }
        pSongSegment = pSongSegment->GetNext();
    }
}

void CSong::GetGraph(CGraph **ppGraph,DWORD dwGraphID)
{
    CGraph *pGraph = m_GraphList.GetHead();
    while (pGraph)
    {
        if (pGraph->m_dwLoadID == dwGraphID)
        {
            pGraph->AddRef();
            *ppGraph = pGraph;
            return;
        }
        pGraph = pGraph->GetNext();
    }
}

BOOL CSong::GetSegmentTrack(IDirectMusicTrack **ppTrack,DWORD dwSegmentID,DWORD dwGroupBits,DWORD dwIndex,REFGUID guidClassID)
{
    CSongSegment *pSongSegment = m_SegmentList.GetHead();
    while (pSongSegment)
    {
        if (pSongSegment->m_dwLoadID == dwSegmentID)
        {
            if (pSongSegment->m_pSegment)
            {
                return (pSongSegment->m_pSegment->GetTrack(guidClassID,dwGroupBits,dwIndex,ppTrack) == S_OK);
            }
        }
        pSongSegment = pSongSegment->GetNext();
    }
    return FALSE;
}


HRESULT CSong::LoadVirtualSegmentList(CRiffParser *pParser)
{
    RIFFIO ckNext;
    RIFFIO ckChild;
    RIFFIO ckUNFO;
    DWORD dwSegmentCount = 0;
    CVirtualSegment *pVirtualSegment;
    MUSIC_TIME mtTime = 0;

    HRESULT hr = S_OK;
    pParser->EnterList(&ckNext);
    while(pParser->NextChunk(&hr))
    {
        switch(ckNext.ckid)
        {
            case FOURCC_RIFF:
            case FOURCC_LIST:
                switch(ckNext.fccType)
                {
                    case DMUS_FOURCC_SEGREF_LIST:
                        pVirtualSegment = new CVirtualSegment;
                        if (pVirtualSegment)
                        {
                            BOOL fGotHeader = FALSE;
                            BOOL fGotSegmentHeader = FALSE;
                            pVirtualSegment->m_mtTime = mtTime; // Give the start time, an accumulation of all preceding segments.
                            pParser->EnterList(&ckChild);
                            while(pParser->NextChunk(&hr))
                            {
                                switch( ckChild.ckid )
                                {
                                    case FOURCC_RIFF:
                                    case FOURCC_LIST:
                                        switch(ckChild.fccType)
                                        {
                                        case DMUS_FOURCC_TRACKREFS_LIST:
                                            hr = LoadTrackRefList(pParser, pVirtualSegment);
                                            break;
                                        case DMUS_FOURCC_UNFO_LIST:
                                            pParser->EnterList(&ckUNFO);
                                            while(pParser->NextChunk(&hr))
                                            {
                                                switch( ckUNFO.ckid )
                                                {
                                                    case DMUS_FOURCC_UNAM_CHUNK:
                                                    {
                                                        hr = pParser->Read(pVirtualSegment->m_wszName, sizeof(pVirtualSegment->m_wszName));
                                                        break;
                                                    }
                                                    default:
                                                        break;
                                                }
                                            }
                                            pParser->LeaveList();
                                        }
                                        break;
                                    case DMUS_FOURCC_SEGREF_CHUNK:
                                    {
                                        DMUS_IO_SEGREF_HEADER ioVirtualSegment;
                                        hr = pParser->Read(&ioVirtualSegment,sizeof(ioVirtualSegment));
                                        if(SUCCEEDED(hr) )
                                        {
                                            pVirtualSegment->m_dwFlags = ioVirtualSegment.dwFlags;
                                            pVirtualSegment->m_dwID = ioVirtualSegment.dwID;
                                            pVirtualSegment->m_dwNextPlayID = ioVirtualSegment.dwNextPlayID;
                                            if (ioVirtualSegment.dwSegmentID != DMUS_SONG_NOSEG)
                                            {
                                                GetSourceSegment(&pVirtualSegment->m_pSourceSegment,ioVirtualSegment.dwSegmentID);
                                            }
                                            if (ioVirtualSegment.dwToolGraphID != DMUS_SONG_NOSEG)
                                            {
                                                GetGraph(&pVirtualSegment->m_pGraph,ioVirtualSegment.dwToolGraphID);
                                            }
                                            fGotHeader = TRUE;
                                        }
                                        break;
                                    }
                                    case DMUS_FOURCC_SEGTRANS_CHUNK:
                                        {
                                            DWORD dwTransCount;
                                            dwTransCount = ckChild.cksize / sizeof(DMUS_IO_TRANSITION_DEF);
                                            if (dwTransCount > 0)
                                            {
                                                pVirtualSegment->m_pTransitions = new DMUS_IO_TRANSITION_DEF[dwTransCount];
                                                if (pVirtualSegment->m_pTransitions)
                                                {
                                                    pVirtualSegment->m_dwTransitionCount = dwTransCount;
                                                    hr = pParser->Read(pVirtualSegment->m_pTransitions,sizeof(DMUS_IO_TRANSITION_DEF)*dwTransCount);
                                                }
                                                else
                                                {
                                                    return E_OUTOFMEMORY;
                                                }
                                            }
                                        }
                                        break;
                                    case DMUS_FOURCC_SEGMENT_CHUNK:
                                        fGotSegmentHeader = TRUE;
                                        hr = pParser->Read(&pVirtualSegment->m_SegHeader, sizeof(DMUS_IO_SEGMENT_HEADER));
                                        mtTime += (pVirtualSegment->m_SegHeader.dwRepeats * (pVirtualSegment->m_SegHeader.mtLoopEnd - pVirtualSegment->m_SegHeader.mtLoopStart)) +
                                            pVirtualSegment->m_SegHeader.mtLength - pVirtualSegment->m_SegHeader.mtPlayStart;
                                    default:
                                        break;
                                }
                            }
                            pParser->LeaveList();
                            if (fGotHeader && fGotSegmentHeader)
                            {
//Trace(0,"Adding VSegment %ls with ID %ld to song.\n",pVirtualSegment->m_wszName,pVirtualSegment->m_dwID);
                                m_VirtualSegmentList.AddTail(pVirtualSegment);
                            }
                            else
                            {
                                delete pVirtualSegment;
                            }
                            break;
                        }
                        else
                        {
                            return E_OUTOFMEMORY;
                        }
                        break;
                    default:
                        break;
                }
                break;

            default:
                break;

        }
    }
    pParser->LeaveList();
    return hr;
}

struct ClassGuidCounts
{
    GUID guidClass;
    DWORD dwCount;
};

HRESULT CSong::LoadTrackRefList(CRiffParser *pParser,CVirtualSegment *pVirtualSegment)
{
    RIFFIO ckNext;
    RIFFIO ckChild;

    HRESULT hr = S_OK;
    TList<ClassGuidCounts> GuidCountList;
    pParser->EnterList(&ckNext);
    while(pParser->NextChunk(&hr))
    {
        switch(ckNext.ckid)
        {
            case FOURCC_LIST:
                switch(ckNext.fccType)
                {
                    CTrack *pTrack;
                    case DMUS_FOURCC_TRACKREF_LIST :
                        pTrack = new CTrack;
                        if (pTrack)
                        {
                            TListItem<ClassGuidCounts>* pCountItem = NULL;
                            DMUS_IO_TRACKREF_HEADER ioTrackRef;
                            DMUS_IO_TRACK_HEADER ioTrackHdr;
                            DMUS_IO_TRACK_EXTRAS_HEADER ioTrackExtrasHdr;
                            ioTrackExtrasHdr.dwPriority = 0;
                            ioTrackExtrasHdr.dwFlags = DMUS_TRACKCONFIG_DEFAULT;
                            ioTrackHdr.dwPosition = 0;
                            BOOL fGotHeader = FALSE;
                            BOOL fGotRef = FALSE;
                            pParser->EnterList(&ckChild);
                            while(pParser->NextChunk(&hr))
                            {
                                switch( ckChild.ckid )
                                {
                                    case DMUS_FOURCC_TRACKREF_CHUNK:
                                    {
                                        hr = pParser->Read(&ioTrackRef, sizeof(ioTrackRef));
                                        fGotRef = SUCCEEDED(hr);
                                        break;
                                    }
                                    case DMUS_FOURCC_TRACK_CHUNK:
                                    {
                                        hr = pParser->Read(&ioTrackHdr, sizeof(ioTrackHdr));
                                        fGotHeader = SUCCEEDED(hr);
                                        pTrack->m_guidClassID = ioTrackHdr.guidClassID;
                                        pTrack->m_dwGroupBits = ioTrackHdr.dwGroup;
                                        pTrack->m_dwPosition = ioTrackHdr.dwPosition;
                                        break;
                                    }
                                    case DMUS_FOURCC_TRACK_EXTRAS_CHUNK:
                                    {
                                        hr = pParser->Read(&ioTrackExtrasHdr, sizeof(ioTrackExtrasHdr));
                                        pTrack->m_dwPriority = ioTrackExtrasHdr.dwPriority;
                                        pTrack->m_dwFlags = ioTrackExtrasHdr.dwFlags;
                                        break;

                                    }
                                    default:
                                        break;
                                }
                            }
                            pParser->LeaveList();
                            if (fGotHeader && fGotRef)
                            {
                                if (ioTrackRef.dwSegmentID != DMUS_SONG_NOSEG)
                                {
                                    DWORD dwID = 0;
                                    for (pCountItem = GuidCountList.GetHead(); pCountItem; pCountItem = pCountItem->GetNext())
                                    {
                                        if (pCountItem->GetItemValue().guidClass == pTrack->m_guidClassID)
                                        {
                                            break;
                                        }
                                    }
                                    if (pCountItem)
                                    {
                                        dwID = pCountItem->GetItemValue().dwCount;
                                    }
                                    fGotHeader = GetSegmentTrack(&pTrack->m_pTrack,ioTrackRef.dwSegmentID,pTrack->m_dwGroupBits,dwID,pTrack->m_guidClassID);
                                }
                            }
                            if (fGotHeader && pTrack->m_pTrack)
                            {
                                pTrack->m_pTrack->QueryInterface(IID_IDirectMusicTrack8,(void **) &pTrack->m_pTrack8);
                                // Add the track based on position.
                                CTrack* pScan = pVirtualSegment->m_TrackList.GetHead();
                                CTrack* pPrevTrack = NULL;
                                for (; pScan; pScan = pScan->GetNext())
                                {
                                    if (pTrack->Less(pScan))
                                    {
                                        break;
                                    }
                                    pPrevTrack = pScan;
                                }
                                if (pPrevTrack)
                                {
                                    pPrevTrack->SetNext(pTrack);
                                    pTrack->SetNext(pScan);
                                }
                                else
                                {
                                    pVirtualSegment->m_TrackList.AddHead( pTrack );
                                }
                                if (pCountItem)
                                {
                                    pCountItem->GetItemValue().dwCount++;
                                }
                                else
                                {
                                    TListItem<ClassGuidCounts>* pNew = new TListItem<ClassGuidCounts>;
                                    if (pNew)
                                    {
                                        pNew->GetItemValue().dwCount = 1;
                                        pNew->GetItemValue().guidClass = pTrack->m_guidClassID;
                                        GuidCountList.AddHead(pNew);
                                    }
                                    else return E_OUTOFMEMORY;
                                }
                            }
                            else
                            {
                                delete pTrack;
                            }
                            break;
                        }
                        else
                        {
                            return E_OUTOFMEMORY;
                        }
                        break;

                    default:
                        break;
                }
                break;

            default:
                break;

        }
    }
    pParser->LeaveList();
    return hr;
}

HRESULT CSong::Save( IStream* pIStream, BOOL fClearDirty )
{
    return E_NOTIMPL;
}

HRESULT CSong::GetSizeMax( ULARGE_INTEGER FAR* pcbSize )
{
    return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// IDirectMusicObject

STDMETHODIMP CSong::GetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
    // Argument validation
    V_INAME(CSong::GetDescriptor);
    V_STRUCTPTR_WRITE(pDesc, DMUS_OBJECTDESC);

    if (m_fZombie)
    {
        Trace(1, "Error: Call of IDirectMusicSong::GetDescriptor after the song has been garbage collected. "
                    "It is invalid to continue using a song after releasing it from the loader (ReleaseObject/ReleaseObjectByUnknown) "
                    "and then calling CollectGarbage or Release on the loader.");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    memset( pDesc, 0, sizeof(DMUS_OBJECTDESC));
    pDesc->dwSize = sizeof(DMUS_OBJECTDESC);
    pDesc->guidClass = CLSID_DirectMusicSong;
    pDesc->guidObject = m_guidObject;
    pDesc->ftDate = m_ftDate;
    pDesc->vVersion = m_vVersion;
    memcpy( pDesc->wszName, m_wszName, sizeof(m_wszName) );
    memcpy( pDesc->wszCategory, m_wszCategory, sizeof(m_wszCategory) );
    memcpy( pDesc->wszFileName, m_wszFileName, sizeof(m_wszFileName) );
    pDesc->dwValidData = ( m_dwValidData | DMUS_OBJ_CLASS );

    return S_OK;
}

STDMETHODIMP CSong::SetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
    // Argument validation
    V_INAME(CSong::SetDescriptor);
    V_STRUCTPTR_READ(pDesc, DMUS_OBJECTDESC);

    if (m_fZombie)
    {
        Trace(1, "Error: Call of IDirectMusicSong::SetDescriptor after the song has been garbage collected. "
                    "It is invalid to continue using a song after releasing it from the loader (ReleaseObject/ReleaseObjectByUnknown) "
                    "and then calling CollectGarbage or Release on the loader.");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    HRESULT hr = E_INVALIDARG;
    DWORD dw = 0;

    if( pDesc->dwSize >= sizeof(DMUS_OBJECTDESC) )
    {
        if( pDesc->dwValidData & DMUS_OBJ_OBJECT )
        {
            m_guidObject = pDesc->guidObject;
            dw |= DMUS_OBJ_OBJECT;
        }
        if( pDesc->dwValidData & DMUS_OBJ_NAME )
        {
            memcpy( m_wszName, pDesc->wszName, sizeof(WCHAR)*DMUS_MAX_NAME );
            dw |= DMUS_OBJ_NAME;
        }
        if( pDesc->dwValidData & DMUS_OBJ_CATEGORY )
        {
            memcpy( m_wszCategory, pDesc->wszCategory, sizeof(WCHAR)*DMUS_MAX_CATEGORY );
            dw |= DMUS_OBJ_CATEGORY;
        }
        if( ( pDesc->dwValidData & DMUS_OBJ_FILENAME ) ||
            ( pDesc->dwValidData & DMUS_OBJ_FULLPATH ) )
        {
            memcpy( m_wszFileName, pDesc->wszFileName, sizeof(WCHAR)*DMUS_MAX_FILENAME );
            dw |= (pDesc->dwValidData & (DMUS_OBJ_FILENAME | DMUS_OBJ_FULLPATH));
        }
        if( pDesc->dwValidData & DMUS_OBJ_VERSION )
        {
            m_vVersion = pDesc->vVersion;
            dw |= DMUS_OBJ_VERSION;
        }
        if( pDesc->dwValidData & DMUS_OBJ_DATE )
        {
            m_ftDate = pDesc->ftDate;
            dw |= DMUS_OBJ_DATE;
        }
        m_dwValidData |= dw;
        if( pDesc->dwValidData & (~dw) )
        {
            Trace(2,"Warning: Song::SetDescriptor was not able to handle all passed fields, dwValidData bits %lx.\n",pDesc->dwValidData & (~dw));
            hr = S_FALSE; // there were extra fields we didn't parse;
            pDesc->dwValidData = dw;
        }
        else
        {
            hr = S_OK;
        }
    }
    return hr;
}

STDMETHODIMP CSong::ParseDescriptor(LPSTREAM pIStream, LPDMUS_OBJECTDESC pDesc)
{
    V_INAME(CSong::ParseDescriptor);
    V_INTERFACE(pIStream);
    V_STRUCTPTR_WRITE(pDesc, DMUS_OBJECTDESC);

    if (m_fZombie)
    {
        Trace(1, "Error: Call of IDirectMusicSong::ParseDescriptor after the song has been garbage collected. "
                    "It is invalid to continue using a song after releasing it from the loader (ReleaseObject/ReleaseObjectByUnknown) "
                    "and then calling CollectGarbage or Release on the loader.");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    CRiffParser Parser(pIStream);
    RIFFIO ckMain;
    RIFFIO ckNext;
    RIFFIO ckUNFO;
    HRESULT hr = S_OK;

    Parser.EnterList(&ckMain);
    if (Parser.NextChunk(&hr) && (ckMain.fccType == DMUS_FOURCC_SONG_FORM))
    {
        pDesc->dwValidData = DMUS_OBJ_CLASS;
        pDesc->guidClass = CLSID_DirectMusicSong;
        Parser.EnterList(&ckNext);
        while(Parser.NextChunk(&hr))
        {
            switch(ckNext.ckid)
            {
            case DMUS_FOURCC_GUID_CHUNK:
                hr = Parser.Read( &pDesc->guidObject, sizeof(GUID) );
                if( SUCCEEDED(hr) )
                {
                    pDesc->dwValidData |= DMUS_OBJ_OBJECT;
                }
                break;
            case DMUS_FOURCC_VERSION_CHUNK:
                hr = Parser.Read( &pDesc->vVersion, sizeof(DMUS_VERSION) );
                if( SUCCEEDED(hr) )
                {
                    pDesc->dwValidData |= DMUS_OBJ_VERSION;
                }
                break;

            case DMUS_FOURCC_CATEGORY_CHUNK:
                hr = Parser.Read( &pDesc->wszCategory, sizeof(pDesc->wszCategory) );
                if( SUCCEEDED(hr) )
                {
                    pDesc->dwValidData |= DMUS_OBJ_CATEGORY;
                }
                break;

            case DMUS_FOURCC_DATE_CHUNK:
                hr = Parser.Read( &pDesc->ftDate, sizeof(FILETIME) );
                if( SUCCEEDED(hr))
                {
                    pDesc->dwValidData |= DMUS_OBJ_DATE;
                }
                break;
            case FOURCC_LIST:
                switch(ckNext.fccType)
                {
                case DMUS_FOURCC_UNFO_LIST:
                    Parser.EnterList(&ckUNFO);
                    while (Parser.NextChunk(&hr))
                    {
                        switch( ckUNFO.ckid )
                        {
                        case DMUS_FOURCC_UNAM_CHUNK:
                        {
                            hr = Parser.Read(&pDesc->wszName, sizeof(pDesc->wszName));
                            if(SUCCEEDED(hr) )
                            {
                                pDesc->dwValidData |= DMUS_OBJ_NAME;
                            }
                            break;
                        }
                        default:
                            break;
                        }
                    }
                    Parser.LeaveList();
                    break;
                }
                break;

            default:
                break;

            }
        }
        Parser.LeaveList();
    }
    else
    {
        // Couldn't find the chunk header for a song.
        // But, maybe this is actually a segment, in which case see if
        // the segment object will parse it.
        CSegment *pSegment = new CSegment;
        if (pSegment)
        {
            pSegment->AddRef(); // just to be safe...
            // Force the version so audiopath functionality will be supported.
            pSegment->m_dwVersion = 8;
            Parser.SeekBack();
            hr = pSegment->ParseDescriptor(pIStream,pDesc);
            pDesc->guidClass = CLSID_DirectMusicSong;
            // Done with the segment, say bye bye.
            delete pSegment;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

ComposingTrack::ComposingTrack() : m_dwTrackGroup(0), m_dwPriority(0)
{
    memset((void*) &m_guidClassID, 0, sizeof(m_guidClassID));
}

ComposingTrack::~ComposingTrack()
{
    TListItem<CompositionComponent>* pComponent = m_Components.GetHead();
    for (; pComponent; pComponent = pComponent->GetNext())
    {
        CompositionComponent& rComponent = pComponent->GetItemValue();
        if (rComponent.pVirtualSegment && rComponent.pVirtualSegment->m_pPlaySegment)
        {
            rComponent.pVirtualSegment->m_pPlaySegment->Release();
        }
        if (rComponent.pComposingTrack && rComponent.pComposingTrack->m_pTrack8)
        {
            rComponent.pComposingTrack->m_pTrack8->Release();
        }
    }
}

HRESULT ComposingTrack::AddTrack(CVirtualSegment* pVirtualSegment, CTrack* pTrack)
{
    HRESULT hr = S_OK;
    if (!pVirtualSegment || !pVirtualSegment->m_pPlaySegment || !pTrack || !pTrack->m_pTrack8)
    {
        Trace(1,"Error: Unable to compose song because of a required segment or track is missing.\n");
        return E_INVALIDARG;
    }
    TListItem<CompositionComponent>* pComponent = new TListItem<CompositionComponent>;
    if (!pComponent)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        pVirtualSegment->m_pPlaySegment->AddRef();
        pTrack->m_pTrack8->AddRef();
        CompositionComponent& rComponent = pComponent->GetItemValue();
        rComponent.pVirtualSegment = pVirtualSegment;
        rComponent.pComposingTrack = pTrack;
        rComponent.mtTime = pVirtualSegment->m_mtTime;
        m_Components.AddHead(pComponent);
    }
    return hr;
}

BOOL Less(CompositionComponent& Comp1, CompositionComponent& Comp2)
{
    return Comp1.mtTime < Comp2.mtTime;
}

// Compose does the joining, composing, successive splitting, and adding to segments
HRESULT ComposingTrack::Compose(IDirectMusicSong* pSong)
{
    HRESULT hr = S_OK;
    IDirectMusicTrack8* pMasterTrack = NULL;
    IDirectMusicTrack8* pComposedTrack = NULL;
    m_Components.MergeSort(Less);
    // Join the tracks together according to the ordering of their associated segments.
    TListItem<CompositionComponent>* pComponent = m_Components.GetHead();
    for (; pComponent; pComponent = pComponent->GetNext())
    {
        CompositionComponent& rComponent = pComponent->GetItemValue();
        if (!pMasterTrack)
        {
            //MUSIC_TIME mtEnd = 0;
            //if (pComponent->GetNext())
            //{
            //  mtEnd = pComponent->GetNext()->GetItemValue().mtTime;
            //}
            //else
            //{
            //  rComponent.pVirtualSegment->m_pPlaySegment->GetLength(&mtEnd);
            //}
            //hr = rComponent.pComposingTrack->m_pTrack8->Clone(0, mtEnd, (IDirectMusicTrack**)&pMasterTrack);
            hr = rComponent.pComposingTrack->m_pTrack8->Clone(0, 0, (IDirectMusicTrack**)&pMasterTrack);
        }
        //else
        if (SUCCEEDED(hr))
        {
            hr = pMasterTrack->Join(rComponent.pComposingTrack->m_pTrack8, rComponent.mtTime, pSong, m_dwTrackGroup, NULL);
        }
        if (FAILED(hr)) break;
    }

    // Call Compose on the joined track.
    if (SUCCEEDED(hr))
    {
        hr = pMasterTrack->Compose(pSong, m_dwTrackGroup, (IDirectMusicTrack**)&pComposedTrack);
    }

    // Split the composed result according to the original segments.
    if (SUCCEEDED(hr))
    {
        MUSIC_TIME mtStart = 0;
        MUSIC_TIME mtEnd = 0;
        pComponent = m_Components.GetHead();
        for (; pComponent; pComponent = pComponent->GetNext())
        {
            CompositionComponent& rComponent = pComponent->GetItemValue();
            mtStart = rComponent.mtTime;
            // only split off a composed track if the original segment contained a composing track
            IDirectMusicTrack* pOldTrack = NULL;
            IPersistStream* pPersist = NULL;
            GUID guidClassId;
            memset(&guidClassId, 0, sizeof(guidClassId));
            if (SUCCEEDED(pMasterTrack->QueryInterface(IID_IPersistStream, (void**)&pPersist)) &&
                SUCCEEDED(pPersist->GetClassID(&guidClassId)) &&
                SUCCEEDED( rComponent.pVirtualSegment->m_pPlaySegment->GetTrack( guidClassId, m_dwTrackGroup, 0, &pOldTrack ) )  )
            {
                pPersist->Release();
                pOldTrack->Release();
                if (pComponent->GetNext())
                {
                    mtEnd = pComponent->GetNext()->GetItemValue().mtTime;
                }
                else
                {
                    MUSIC_TIME mtLength = 0;
                    rComponent.pVirtualSegment->m_pPlaySegment->GetLength(&mtLength);
                    mtEnd = mtStart + mtLength;
                }
                IDirectMusicTrack8* pComposedFragment = NULL;
                hr = pComposedTrack->Clone(mtStart, mtEnd, (IDirectMusicTrack**)&pComposedFragment);
                if (SUCCEEDED(hr))
                {
                    // Remove any tracks of this type (in the same group) from the segment.
                    pOldTrack = NULL;
                    pPersist = NULL;
                    memset(&guidClassId, 0, sizeof(guidClassId));
                    if (SUCCEEDED(pComposedFragment->QueryInterface(IID_IPersistStream, (void**)&pPersist)) )
                    {
                        if (SUCCEEDED(pPersist->GetClassID(&guidClassId)) &&
                            SUCCEEDED( rComponent.pVirtualSegment->m_pPlaySegment->GetTrack( guidClassId, m_dwTrackGroup, 0, &pOldTrack ) ) )
                        {
                            rComponent.pVirtualSegment->m_pPlaySegment->RemoveTrack( pOldTrack );
                            pOldTrack->Release();
                        }
                        pPersist->Release();
                    }
                    hr = rComponent.pVirtualSegment->m_pPlaySegment->InsertTrack(pComposedFragment, m_dwTrackGroup);
                    pComposedFragment->Release(); // release from the Clone
                }

                if (FAILED(hr)) break;
            }
            else // the QI to pPersist might have succeeded, so clean it up
            {
                if (pPersist) pPersist->Release();
            }
        }
        if (pComposedTrack) pComposedTrack->Release();
    }

    if (pMasterTrack) pMasterTrack->Release();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\song.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
// DMSegObj.h : Declaration of the CSegment

#ifndef __DIRECTMUSICSONGOBJECT_H_
#define __DIRECTMUSICSONGOBJECT_H_

#include "dmusici.h"
#include "dmusicf.h"
#include "dmime.h"
#include "TrkList.h"
#include "dmgraph.h"
#include "dmsegobj.h"
#include "tlist.h"
#include "dmusicp.h"

class CVirtualSegment : public AListItem
{
friend class CSong;
friend class ComposingTrack;
public:
    CVirtualSegment();
    ~CVirtualSegment();
    CVirtualSegment* GetNext() { return (CVirtualSegment*)AListItem::GetNext();}
    CTrack * GetTrackByParam( CTrack * pCTrack,
        REFGUID rguidType,DWORD dwGroupBits,DWORD dwIndex);
private:
    CTrackList              m_TrackList;        // List of tracks that this segment uses.
    CSegment *              m_pSourceSegment;   // Segment that is used as basis for this segment.
    CSegment *              m_pPlaySegment;     // Resulting segment that will be played.
    CGraph *                m_pGraph;           // Optional tool graph.
    DWORD                   m_dwFlags;          // Various control flags.
    DWORD                   m_dwID;             // Unique ID.
    DWORD                   m_dwNextPlayID;     // ID of next segment, to chain segments into a song.
    DWORD                   m_dwNextPlayFlags;  // DMUS_SEGF flags for playing next segment, when chaining a song.
    DMUS_IO_SEGMENT_HEADER  m_SegHeader;        // Segment header, used to define the segment that it creates, or change the one it references.
    MUSIC_TIME              m_mtTime;           // Start time of this segment.
    DWORD                   m_dwTransitionCount;// How many transitions are defined. 
    DMUS_IO_TRANSITION_DEF *m_pTransitions;     // Array of transitions from other segments.
	WCHAR	                m_wszName[DMUS_MAX_NAME];// Name of generated segment.
};

class CVirtualSegmentList : public AList
{
public:
    void Clear();
    void AddHead(CVirtualSegment* pVirtualSegment) { AList::AddHead((AListItem*)pVirtualSegment);}
    void Insert(CVirtualSegment* pVirtualSegment);
    CVirtualSegment* GetHead(){return (CVirtualSegment*)AList::GetHead();}
    CVirtualSegment* GetItem(LONG lIndex){return (CVirtualSegment*)AList::GetItem(lIndex);}
    CVirtualSegment* RemoveHead()  { return (CVirtualSegment *)AList::RemoveHead();};
    void Remove(CVirtualSegment* pVirtualSegment){AList::Remove((AListItem*)pVirtualSegment);}
    void AddTail(CVirtualSegment* pVirtualSegment){AList::AddTail((AListItem*)pVirtualSegment);}
    CVirtualSegment* GetTail(){ return (CVirtualSegment*)AList::GetTail();}
};

class CSongSegment : public AListItem
{
public:
    CSongSegment();
    ~CSongSegment();
    CSongSegment* GetNext() { return (CSongSegment*)AListItem::GetNext();}
    CSegment *              m_pSegment;   
    DWORD                   m_dwLoadID;
};

class CSongSegmentList : public AList
{
public:
    HRESULT AddSegment(CSegment *pSegment, DWORD dwLoadID);
    void Clear();
    void AddHead(CSongSegment* pSongSegment) { AList::AddHead((AListItem*)pSongSegment);}
    void Insert(CSongSegment* pSongSegment);
    CSongSegment* GetHead(){return (CSongSegment*)AList::GetHead();}
    CSongSegment* GetItem(LONG lIndex){return (CSongSegment*)AList::GetItem(lIndex);}
    CSongSegment* RemoveHead()  { return (CSongSegment *)AList::RemoveHead();};
    void Remove(CSongSegment* pSongSegment){AList::Remove((AListItem*)pSongSegment);}
    void AddTail(CSongSegment* pSongSegment){AList::AddTail((AListItem*)pSongSegment);}
    CSongSegment* GetTail(){ return (CSongSegment*)AList::GetTail();}
};


class CSong;

DEFINE_GUID(IID_CSong,0xb06c0c22, 0xd3c7, 0x11d3, 0x9b, 0xd1, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);


/////////////////////////////////////////////////////////////////////////////
// CSong
class CSong : 
	public IDirectMusicSong,
	public IPersistStream,
	public IDirectMusicObject,
    public IDirectMusicObjectP
{
public:
	CSong();
	~CSong();

public:
// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
// IDirectMusicSong
    STDMETHODIMP Compose( );
    STDMETHODIMP GetParam( REFGUID rguidType, 
                            DWORD dwGroupBits, 
                            DWORD dwIndex, 
                            MUSIC_TIME mtTime, 
                            MUSIC_TIME* pmtNext, 
                            void* pParam) ;
    STDMETHODIMP GetSegment( WCHAR *wszName,IDirectMusicSegment **ppSegment) ;
    STDMETHODIMP EnumSegment( DWORD dwIndex,IDirectMusicSegment **ppSegment) ;
    STDMETHODIMP GetAudioPathConfig(IUnknown ** ppAudioPathConfig);
    STDMETHODIMP Download(IUnknown *pAudioPath);
    STDMETHODIMP Unload(IUnknown *pAudioPath);

// IPersist 
    STDMETHODIMP GetClassID( CLSID* pClsId );

// IPersistStream 
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load( IStream* pIStream );
    STDMETHODIMP Save( IStream* pIStream, BOOL fClearDirty );
    STDMETHODIMP GetSizeMax( ULARGE_INTEGER FAR* pcbSize );

// IDirectMusicObject 
	STDMETHODIMP GetDescriptor(LPDMUS_OBJECTDESC pDesc);
	STDMETHODIMP SetDescriptor(LPDMUS_OBJECTDESC pDesc);
	STDMETHODIMP ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc);

// IDirectMusicObjectP
	STDMETHOD_(void, Zombie)();

public:
    HRESULT GetTransitionSegment(CSegment *pSource, CSegment *pDestination,
        DMUS_IO_TRANSITION_DEF *pTransDef);
    HRESULT GetPlaySegment( DWORD dwIndex,CSegment **ppSegment) ;
private:
    void                Clear();
    HRESULT				Instantiate() ;
    HRESULT             LoadReferencedSegment(CSegment **ppSegment, CRiffParser *pParser);
    HRESULT             LoadSegmentList(CRiffParser *pParser);
    HRESULT             LoadGraphList(CRiffParser *pParser);
    HRESULT             LoadVirtualSegmentList(CRiffParser *pParser);
    HRESULT             LoadTrackRefList(CRiffParser *pParser, CVirtualSegment *pVirtualSegment);
    HRESULT             LoadAudioPath(IStream *pStream);

    void GetGraph(CGraph **ppGraph,DWORD dwGraphID);
    void GetSourceSegment(CSegment **ppSegment,DWORD dwSegmentID);
    BOOL GetSegmentTrack(IDirectMusicTrack **ppTrack,DWORD dwSegmentID,DWORD dwGroupBits,DWORD dwIndex,REFGUID guidClassID);
    CAudioPathConfig*   m_pAudioPathConfig;     // Optional audio path loaded from file. 
    CGraphList          m_GraphList;            // List of graphs for use by segments in the song.
    CSongSegmentList    m_SegmentList;          // List of source segments.
    CSegmentList        m_PlayList;             // List of composed segments.
    CVirtualSegmentList m_VirtualSegmentList;   // List of segment references. This is what is used to compose the finished song.         
    CRITICAL_SECTION    m_CriticalSection;      
	DWORD	            m_fPartialLoad;
    DWORD               m_dwFlags;
    DWORD               m_dwStartSegID;         // ID of first segment, in play list, that should play.
	long                m_cRef;
// IDirectMusicObject variables
	DWORD	            m_dwValidData;
	GUID	            m_guidObject;
	FILETIME	        m_ftDate;                       /* Last edited date of object. */
	DMUS_VERSION	    m_vVersion;                 /* Version. */
	WCHAR	            m_wszName[DMUS_MAX_NAME];			/* Name of object.       */
	WCHAR	            m_wszCategory[DMUS_MAX_CATEGORY];	/* Category for object */
	WCHAR               m_wszFileName[DMUS_MAX_FILENAME];	/* File path. */
    DWORD               m_dwVersion;        // Which version of the interfaces is the app requesting?
    IUnknown *          m_pUnkDispatch;     // holds the controlling unknown of the scripting object that implements IDispatch

    bool                m_fZombie;
};


struct CompositionComponent
{
	CVirtualSegment*	pVirtualSegment;			// composing track came from here
	CTrack*		pComposingTrack;	// used for composition
	MUSIC_TIME	mtTime;
};

class ComposingTrack
{
public:
	ComposingTrack();
	~ComposingTrack();
	DWORD GetTrackGroup() { return m_dwTrackGroup; }
	GUID GetTrackID() { return m_guidClassID; }
	DWORD GetPriority() { return m_dwPriority; }
	void SetPriority(DWORD dwPriority) { m_dwPriority = dwPriority; }
	void SetTrackGroup(DWORD dwTrackGroup) { m_dwTrackGroup = dwTrackGroup; }
	void SetTrackID(GUID& rguidClassID) { m_guidClassID = rguidClassID; }
	HRESULT AddTrack(CVirtualSegment* pVirtualSegment, CTrack* pTrack);
	HRESULT Compose(IDirectMusicSong* pSong);
private:
	GUID						m_guidClassID;		// composing track's class id
	DWORD						m_dwTrackGroup;		// track will be composed from these groups
    DWORD						m_dwPriority;		// Track priority, to order the composition process.
	TList<CompositionComponent>	m_Components;		// list of components making up the master
};

#endif //__DIRECTMUSICSONGOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\sysextrk.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)

// SysExTrk.cpp : Implementation of CSysExTrk
#include "dmime.h"
#include "SysExTrk.h"
#include "dmusici.h"
#include "dmusicf.h"
#include "dmperf.h"
#include "debug.h"
#include "Validate.h"
#include "debug.h"
#define ASSERT	assert

/////////////////////////////////////////////////////////////////////////////
// CSysExTrack
void CSysExTrack::Construct()
{
	InterlockedIncrement(&g_cComponent);

	m_cRef = 1;
	m_dwValidate = 0;
    m_fCSInitialized = FALSE;
	InitializeCriticalSection(&m_CrSec);
    m_fCSInitialized = TRUE;
}

CSysExTrack::CSysExTrack()
{
	Construct();
}

CSysExTrack::CSysExTrack(
		CSysExTrack& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd)
{
	Construct();
	SysExListItem* pScan = rTrack.m_SysExEventList.GetHead();

	for(; pScan; pScan = pScan->GetNext())
	{
		FullSysexEvent* pItem = pScan->m_pItem;
		if( NULL == pItem )
		{
			continue;
		}
		else if( pItem->mtTime < mtStart )
		{
			continue;
		}
		else if (pItem->mtTime < mtEnd)
		{
			SysExListItem* pNew = new SysExListItem;
			if (pNew)
			{
				FullSysexEvent item;
				item.mtTime = pItem->mtTime - mtStart;
				item.dwSysExLength = pItem->dwSysExLength;
				if (item.dwSysExLength && (item.pbSysExData = new BYTE[item.dwSysExLength]))
                {
					memcpy( item.pbSysExData, pItem->pbSysExData, item.dwSysExLength );
					pNew->SetItem(item);
					m_SysExEventList.AddTail(pNew);
				}
                else
                {
                    delete pNew;
                }
			}
		}
		else break;
	}
}

CSysExTrack::~CSysExTrack()
{
    if (m_fCSInitialized)
    {
	    DeleteCriticalSection(&m_CrSec);
    }

	InterlockedDecrement(&g_cComponent);
}

// method:(EXTERNAL) HRESULT | IDirectMusicSysExTrack | QueryInterface | Standard QueryInterface implementation for <i IDirectMusicSysExTrack>
//
// parm const IID & | iid | Interface to query for
// parm void ** | ppv | The requested interface will be returned here
//
// rdesc Returns one of the following:
//
// flag S_OK | If the interface is supported and was returned
// flag E_NOINTERFACE | If the object does not support the given interface.
//
// mfunc:(INTERNAL)
//
//
STDMETHODIMP CSysExTrack::QueryInterface(
    const IID &iid,   // @parm Interface to query for
    void **ppv)       // @parm The requested interface will be returned here
{
	V_INAME(CSysExTrack::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

   if (iid == IID_IUnknown || iid == IID_IDirectMusicTrack || iid == IID_IDirectMusicTrack8)
    {
        *ppv = static_cast<IDirectMusicTrack*>(this);
    } else
	if (iid == IID_IPersistStream)
	{
        *ppv = static_cast<IPersistStream*>(this);
	} else
    {
        *ppv = NULL;
        Trace(4,"Warning: Request to query unknown interface on Sysex Track\n");
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


// method:(EXTERNAL) HRESULT | IDirectMusicSysExTrack | AddRef | Standard AddRef implementation for <i IDirectMusicSysExTrack>
//
// rdesc Returns the new reference count for this object.
//
// mfunc:(INTERNAL)
//
//
STDMETHODIMP_(ULONG) CSysExTrack::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


// method:(EXTERNAL) HRESULT | IDirectMusicSysExTrack | Release | Standard Release implementation for <i IDirectMusicSysExTrack>
//
// rdesc Returns the new reference count for this object.
//
// mfunc:(INTERNAL)
//
//
STDMETHODIMP_(ULONG) CSysExTrack::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

/////////////////////////////////////////////////////////////////////////////
// IPersist

HRESULT CSysExTrack::GetClassID( CLSID* pClassID )
{
	V_INAME(CSysExTrack::GetClassID);
	V_PTR_WRITE(pClassID, CLSID); 
	*pClassID = CLSID_DirectMusicSysExTrack;
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IPersistStream functions

HRESULT CSysExTrack::IsDirty()
{
	return S_FALSE;
}

/*

  method HRESULT | ISeqTrack | Load |
  Call this with an IStream filled with SysExEvents, sorted in time order.
  parm IStream* | pIStream |
  A stream of SysExEvents, sorted in time order. The seek pointer should point
  to the first event. The stream should contain only SysExEvents and nothing more.
  rvalue E_POINTER | If pIStream == NULL or invalid.
  rvalue S_OK
  comm The <p pIStream> will be AddRef'd inside this function and held
  until the SysExTrack is released.
*/
HRESULT CSysExTrack::Load( IStream* pIStream )
{
	V_INAME(CSysExTrack::Load);
	V_INTERFACE(pIStream);

	EnterCriticalSection(&m_CrSec);
	HRESULT hr = S_OK;

	m_dwValidate++;
	if( m_SysExEventList.GetHead() )
	{
		m_SysExEventList.DeleteAll();
	}

	// copy contents of the stream into the list.
	//DMUS_IO_SYSEX_ITEM sysexEvent;
	FullSysexEvent sysexEvent;
	// read in the chunk id
	DWORD dwChunk;
	long lSize;
	pIStream->Read( &dwChunk, sizeof(DWORD), NULL);
	if( dwChunk != DMUS_FOURCC_SYSEX_TRACK )
	{
        Trace(1,"Error: Invalid data in sysex track.\n");
        LeaveCriticalSection(&m_CrSec);
		return DMUS_E_CHUNKNOTFOUND;
	}
	// read in the overall size
	if( FAILED( pIStream->Read( &lSize, sizeof(long), NULL )))
	{
        Trace(1,"Error: Unable to read sysex track.\n");
		LeaveCriticalSection(&m_CrSec);
		return DMUS_E_CANNOTREAD;
	}

	DMUS_IO_SYSEX_ITEM SysexItem;
	BYTE* pbSysExData;
	while( lSize > 0 )
	{
		if( FAILED( pIStream->Read( &SysexItem, sizeof(DMUS_IO_SYSEX_ITEM), NULL )))
		{
            Trace(1,"Error: Unable to read sysex track.\n");
			hr = DMUS_E_CANNOTREAD;
			break;
		}
		lSize -= sizeof(DMUS_IO_SYSEX_ITEM);
		pbSysExData = new BYTE[SysexItem.dwSysExLength];
		if( NULL == pbSysExData )
		{
			hr = E_OUTOFMEMORY;
			break;
		}
		if( FAILED( pIStream->Read( pbSysExData, SysexItem.dwSysExLength, NULL )))
		{
            Trace(1,"Error: Unable to read sysex track.\n");
			hr = DMUS_E_CANNOTREAD;
			break;
		}
		lSize -= SysexItem.dwSysExLength;
		sysexEvent.mtTime = SysexItem.mtTime;
		sysexEvent.dwPChannel = SysexItem.dwPChannel;
		sysexEvent.dwSysExLength = SysexItem.dwSysExLength;
		sysexEvent.pbSysExData = pbSysExData;
		SysExListItem* pNew = new SysExListItem;
		if (pNew)
		{
			if( FAILED( pNew->SetItem(sysexEvent)))
			{
				delete [] pbSysExData;
				hr = E_OUTOFMEMORY;
				break;
			}
			m_SysExEventList.AddTail(pNew);
		}
		else
		{
			delete [] pbSysExData;
			hr = E_OUTOFMEMORY;
			break;
		}
	}
	LeaveCriticalSection(&m_CrSec);
	return hr;
}

HRESULT CSysExTrack::Save( IStream* pIStream, BOOL fClearDirty )
{
	return E_NOTIMPL;
}

HRESULT CSysExTrack::GetSizeMax( ULARGE_INTEGER FAR* pcbSize )
{
	return E_NOTIMPL;
}

// IDirectMusicTrack

HRESULT STDMETHODCALLTYPE CSysExTrack::IsParamSupported( 
    /* [in] */ REFGUID rguid)
{
	return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicTrack::Init
/*
method HRESULT | IDirectMusicTrack | Init |
When a track is first added to a Segment, it's Init() routine is called
by that Segment.

parm IDirectMusicSegment* | pSegment |
[in] Pointer to the Segment to which this Track belongs.

rvalue S_OK
*/
HRESULT CSysExTrack::Init( 
    /* [in] */ IDirectMusicSegment *pSegment)
{
	return S_OK;
}

HRESULT CSysExTrack::InitPlay( 
    /* [in] */ IDirectMusicSegmentState *pSegmentState,
    /* [in] */ IDirectMusicPerformance *pPerformance,
    /* [out] */ void **ppStateData,
    /* [in] */ DWORD dwTrackID,
    /* [in] */ DWORD dwFlags)
{
	V_INAME(IDirectMusicTrack::InitPlay);
	V_PTRPTR_WRITE(ppStateData);
	V_INTERFACE(pSegmentState);
	V_INTERFACE(pPerformance);

	SysExStateData* pStateData;
	pStateData = new SysExStateData;
	if( NULL == pStateData )
		return E_OUTOFMEMORY;
	*ppStateData = pStateData;
	pStateData->dwVirtualTrackID = dwTrackID;
	pStateData->pPerformance = pPerformance; // weak reference, no addref.
	pStateData->pSegState = pSegmentState; // weak reference, no addref.
	pStateData->pCurrentSysEx = m_SysExEventList.GetHead();
	pStateData->dwValidate = m_dwValidate;
	return S_OK;
}

HRESULT CSysExTrack::EndPlay( 
    /* [in] */ void *pStateData)
{
	ASSERT( pStateData );
	if( pStateData )
	{
		V_INAME(IDirectMusicTrack::EndPlay);
		V_BUFPTR_WRITE(pStateData, sizeof(SysExStateData));
		SysExStateData* pSD = (SysExStateData*)pStateData;
		delete pSD;
	}
	return S_OK;
}

STDMETHODIMP CSysExTrack::PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf,
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) 
{
	V_INAME(IDirectMusicTrack::PlayEx);
	V_BUFPTR_WRITE( pStateData, sizeof(SysExStateData));
	V_INTERFACE(pPerf);
	V_INTERFACE(pSegSt);

    HRESULT hr;
    EnterCriticalSection(&m_CrSec);
    if (dwFlags & DMUS_TRACKF_CLOCK)
    {
        // Convert all reference times to millisecond times. Then, just use same MUSIC_TIME
        // variables.
	    hr = Play(pStateData,(MUSIC_TIME)(rtStart / REF_PER_MIL),(MUSIC_TIME)(rtEnd / REF_PER_MIL),
            (MUSIC_TIME)(rtOffset / REF_PER_MIL),rtOffset,dwFlags,pPerf,pSegSt,dwVirtualID,TRUE);
    }
    else
    {
	    hr = Play(pStateData,(MUSIC_TIME)rtStart,(MUSIC_TIME)rtEnd,
            (MUSIC_TIME)rtOffset,0,dwFlags,pPerf,pSegSt,dwVirtualID,FALSE);
    }
    LeaveCriticalSection(&m_CrSec);
	return hr;
}

/*

  method HRESULT | CSysExTrack | Play |
  Play method.
  rvalue S_FALSE | If there has been no stream loaded into the Track.
  rvalue S_OK
*/
HRESULT CSysExTrack::Play( 
    /* [in] */ void *pStateData,
    /* [in] */ MUSIC_TIME mtStart,
    /* [in] */ MUSIC_TIME mtEnd,
    /* [in] */ MUSIC_TIME mtOffset,
	DWORD dwFlags,
	IDirectMusicPerformance* pPerf,
	IDirectMusicSegmentState* pSegSt,
	DWORD dwVirtualID
	)
{
	V_INAME(IDirectMusicTrack::Play);
	V_BUFPTR_WRITE( pStateData, sizeof(SysExStateData));
	V_INTERFACE(pPerf);
	V_INTERFACE(pSegSt);

	EnterCriticalSection(&m_CrSec);
	HRESULT	hr = Play(pStateData,mtStart,mtEnd,mtOffset,0,dwFlags,pPerf,pSegSt,dwVirtualID,FALSE);
	LeaveCriticalSection(&m_CrSec);
	return hr;
}

/*  The Play method handles both music time and clock time versions, as determined by
    fClockTime. If running in clock time, rtOffset is used to identify the start time
    of the segment. Otherwise, mtOffset. The mtStart and mtEnd parameters are in MUSIC_TIME units
    or milliseconds, depending on which mode. 
*/

HRESULT CSysExTrack::Play( 
    void *pStateData,	
    MUSIC_TIME mtStart,	
    MUSIC_TIME mtEnd,
    MUSIC_TIME mtOffset,
    REFERENCE_TIME rtOffset,
	DWORD dwFlags,		
	IDirectMusicPerformance* pPerf,	
	IDirectMusicSegmentState* pSegSt,
	DWORD dwVirtualID,
    BOOL fClockTime)
{
    if (dwFlags & DMUS_TRACKF_PLAY_OFF)
    {
	    return S_OK;
    }
	IDirectMusicGraph* pGraph = NULL;
	DMUS_SYSEX_PMSG* pSysEx;
	SysExStateData* pSD = (SysExStateData*)pStateData;
	HRESULT	hr = S_OK;
	BOOL fSeek = (dwFlags & DMUS_TRACKF_SEEK) ? TRUE : FALSE;

	// if mtStart is 0 and dwFlags contains DMUS_TRACKF_START, we want to be sure to
	// send out any negative time events. So, we'll set mtStart to -768.
	if( (mtStart == 0) && ( dwFlags & DMUS_TRACKF_START ))
	{
		mtStart = -768;
	}

	// if pSD->pCurrentSysEx is NULL, and we're in a normal Play call (dwFlags is 0)
	// this means that we either have no events, or we got to the end of the event
	// list previously. So, it's safe to just return.
	if( (pSD->pCurrentSysEx == NULL) && (dwFlags == 0) )
	{
		return S_FALSE;
	}

	if( pSD->dwValidate != m_dwValidate )
	{
		pSD->dwValidate = m_dwValidate;
		pSD->pCurrentSysEx = NULL;
	}
	if( NULL == m_SysExEventList.GetHead() )
	{
		return DMUS_S_END;
	}
	// if the previous end time isn't the same as the current start time,
	// we need to seek to the right position.
	if( fSeek || ( pSD->mtPrevEnd != mtStart ))
	{
		Seek( pStateData, mtStart );
	}
	else if( NULL == pSD->pCurrentSysEx )
	{
		pSD->pCurrentSysEx = m_SysExEventList.GetHead();
	}
	pSD->mtPrevEnd = mtEnd;

	if( FAILED( pSD->pSegState->QueryInterface( IID_IDirectMusicGraph,
		(void**)&pGraph )))
	{
		pGraph = NULL;
	}

	for( ; pSD->pCurrentSysEx; pSD->pCurrentSysEx = pSD->pCurrentSysEx->GetNext() )
	{
		FullSysexEvent* pItem = pSD->pCurrentSysEx->m_pItem;
		if( NULL == pItem )
		{
			continue;
		}
		if( pItem->mtTime >= mtEnd )
		{
			// this time is in the future. Return now to retain the same
			// seek pointers for next time.
			hr = S_OK;
			break;
		}
		if( (pItem->mtTime < mtStart) && !fSeek )
		{
			break;
		}
		// allocate a DMUS_SYSEX_PMSG of the approriate size and read 
		// the sysex data into it
		if( SUCCEEDED( hr = pSD->pPerformance->AllocPMsg( 
			sizeof(DMUS_SYSEX_PMSG) + pItem->dwSysExLength, (DMUS_PMSG**)&pSysEx ) ) )
		{
			memcpy( pSysEx->abData, pItem->pbSysExData, pItem->dwSysExLength );
            if (fClockTime)
            {
                pSysEx->rtTime = (pItem->mtTime  * REF_PER_MIL) + rtOffset;
                pSysEx->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME;

            }
            else
            {
			    pSysEx->mtTime = pItem->mtTime + mtOffset;
                pSysEx->dwFlags = DMUS_PMSGF_MUSICTIME;
            }
			pSysEx->dwLen = pItem->dwSysExLength;
			pSysEx->dwPChannel = 0;
			pSysEx->dwVirtualTrackID = pSD->dwVirtualTrackID;
			pSysEx->dwType = DMUS_PMSGT_SYSEX;
			pSysEx->dwGroupID = 0xffffffff;

			if( pGraph )
			{
				pGraph->StampPMsg( (DMUS_PMSG*)pSysEx );
			}
			if(FAILED(pSD->pPerformance->SendPMsg( (DMUS_PMSG*)pSysEx )))
			{
				pSD->pPerformance->FreePMsg( (DMUS_PMSG*)pSysEx );
			}
		}
        else
        {
            hr = DMUS_S_END;
            break;
        }
	}
	if( pGraph )
	{
		pGraph->Release();
	}
	return hr;
}

HRESULT CSysExTrack::Seek( 
    /* [in] */ void *pStateData,
    /* [in] */ MUSIC_TIME mtTime)
{
	SysExStateData* pSD = (SysExStateData*)pStateData;

	if( NULL == m_SysExEventList.GetHead() )
	{
		return S_FALSE;
	}
	if( NULL == pSD->pCurrentSysEx )
	{
		pSD->pCurrentSysEx = m_SysExEventList.GetHead();
	}
	// if the current event's time is on or past mtTime, we need to rewind to the beginning
	FullSysexEvent* pItem = pSD->pCurrentSysEx->m_pItem;
	if( pItem->mtTime >= mtTime )
	{
		pSD->pCurrentSysEx = m_SysExEventList.GetHead();
	}
	// now start seeking until we find an event with time on or past mtTime
	for( ; pSD->pCurrentSysEx; pSD->pCurrentSysEx = pSD->pCurrentSysEx->GetNext() )
	{
		pItem = pSD->pCurrentSysEx->m_pItem;
		if( pItem->mtTime >= mtTime )
		{
			break;
		}
	}
	return S_OK;
}

STDMETHODIMP CSysExTrack::GetParam( 
	REFGUID rguid,
    MUSIC_TIME mtTime,
	MUSIC_TIME* pmtNext,
    void *pData)
{
	return E_NOTIMPL;
}

STDMETHODIMP CSysExTrack::SetParam( 
	REFGUID rguid,
    MUSIC_TIME mtTime,
    void *pData)
{
	return E_NOTIMPL;
}

STDMETHODIMP CSysExTrack::GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) 
{
	return E_NOTIMPL;
}

STDMETHODIMP CSysExTrack::SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,
                                      void* pParam, void * pStateData, DWORD dwFlags) 
{
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CSysExTrack::AddNotificationType(
	/* [in] */  REFGUID rguidNotification)
{
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CSysExTrack::RemoveNotificationType(
	/* [in] */  REFGUID rguidNotification)
{
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CSysExTrack::Clone(
	MUSIC_TIME mtStart,
	MUSIC_TIME mtEnd,
	IDirectMusicTrack** ppTrack)
{
	V_INAME(IDirectMusicTrack::Clone);
	V_PTRPTR_WRITE(ppTrack);

	HRESULT hr = S_OK;

	if((mtStart < 0 ) || (mtStart > mtEnd))
	{
        Trace(1,"Error: Unable to clone sysex track, invalid start parameter.\n",mtStart);
		return E_INVALIDARG;
	}

	EnterCriticalSection(&m_CrSec);

    CSysExTrack *pDM;
    
    try
    {
        pDM = new CSysExTrack(*this, mtStart, mtEnd);
    }
    catch( ... )
    {
        pDM = NULL;
    }

	LeaveCriticalSection(&m_CrSec);
    if (pDM == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = pDM->QueryInterface(IID_IDirectMusicTrack, (void**)ppTrack);
    pDM->Release();

	return hr;
}


STDMETHODIMP CSysExTrack::Compose(
		IUnknown* pContext, 
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) 
{
	return E_NOTIMPL;
}

STDMETHODIMP CSysExTrack::Join(
		IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		IUnknown* pContext,
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) 
{
	return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\sysextrk.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
// SysExTrk.h : Declaration of the CSysExTrk

#ifndef __SYSEXTRK_H_
#define __SYSEXTRK_H_

#include "dmusici.h"
#include "dmusicf.h"
#include "alist.h"

// FullSysexEvent is DMUS_IO_SYSEX_ITEM plus data pointer
struct FullSysexEvent : DMUS_IO_SYSEX_ITEM
{
	BYTE* pbSysExData;
};

class SysExListItem : public AListItem
{
public:
	SysExListItem()
	{
		m_pItem = NULL;
	};

	HRESULT SetItem( FullSysexEvent item )
	{
		if( m_pItem )
		{
			delete [] m_pItem->pbSysExData;
		}
		else
		{
			m_pItem = new FullSysexEvent;
		}
		if( m_pItem )
		{
			m_pItem->mtTime = item.mtTime;
			m_pItem->dwSysExLength = item.dwSysExLength;
			m_pItem->pbSysExData = item.pbSysExData;
			return S_OK;
		}
		else
		{
			return E_OUTOFMEMORY;
		}
	};

	~SysExListItem()
	{
		if( m_pItem )
		{
			if( m_pItem->pbSysExData )
			{
				delete [] m_pItem->pbSysExData;
			}
			delete m_pItem;
		}
	};

	SysExListItem* GetNext()
	{
		return (SysExListItem*)AListItem::GetNext();
	};
public:
	FullSysexEvent* m_pItem;
};

class SysExList : public AList
{
public:
	~SysExList()
	{
		SysExListItem* pItem;
		while( pItem = (SysExListItem*)AList::RemoveHead() )
		{
			delete pItem;
		}
	};

	void DeleteAll()
	{
		SysExListItem* pItem;
		while( pItem = (SysExListItem*)AList::RemoveHead() )
		{
			delete pItem;
		}
	};

    SysExListItem* GetHead() 
	{
		return (SysExListItem*)AList::GetHead();
	};
};

struct SysExStateData
{
	SysExListItem*				pCurrentSysEx;
	IDirectMusicPerformance*	pPerformance;
	IDirectMusicSegmentState*	pSegState;
	DWORD						dwVirtualTrackID;
	DWORD						dwValidate;
	MUSIC_TIME					mtPrevEnd;

	SysExStateData()
	{
		mtPrevEnd = 0;
	}
};

/////////////////////////////////////////////////////////////////////////////
// CSysExTrk
class CSysExTrack : 
	public IPersistStream,
	public IDirectMusicTrack8
{
public:
	CSysExTrack();
	CSysExTrack::CSysExTrack(
		CSysExTrack& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd);
	~CSysExTrack();

// ISysExTrk
public:
// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

// IDirectMusicTrack methods
    STDMETHODIMP IsParamSupported(REFGUID rguid);
    STDMETHODIMP Init(IDirectMusicSegment *pSegment);
    STDMETHODIMP InitPlay(IDirectMusicSegmentState *pSegmentState,
                IDirectMusicPerformance *pPerformance,
                void **ppStateData,
                DWORD dwTrackID,
                DWORD dwFlags);
    STDMETHODIMP EndPlay(void *pStateData);
    STDMETHODIMP Play(void *pStateData,MUSIC_TIME mtStart,
                MUSIC_TIME mtEnd,MUSIC_TIME mtOffset,
		        DWORD dwFlags,IDirectMusicPerformance* pPerf,
		        IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID);
    STDMETHODIMP GetParam(REFGUID rguid,MUSIC_TIME mtTime,MUSIC_TIME* pmtNext,void *pData);
    STDMETHODIMP SetParam(REFGUID rguid,MUSIC_TIME mtTime,void *pData);
    STDMETHODIMP AddNotificationType(REFGUID rguidNotification);
    STDMETHODIMP RemoveNotificationType(REFGUID rguidNotification);
    STDMETHODIMP Clone(MUSIC_TIME mtStart,MUSIC_TIME mtEnd,IDirectMusicTrack** ppTrack);
// IDirectMusicTrack8 
    STDMETHODIMP PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf, 
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) ; 
    STDMETHODIMP GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) ; 
    STDMETHODIMP SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,void* pParam, void * pStateData, DWORD dwFlags) ;
    STDMETHODIMP Compose(IUnknown* pContext, 
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;
    STDMETHODIMP Join(IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		IUnknown* pContext,
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;

// IPersist functions
    STDMETHODIMP GetClassID( CLSID* pClsId );
// IPersistStream functions
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load( IStream* pIStream );
    STDMETHODIMP Save( IStream* pIStream, BOOL fClearDirty );
    STDMETHODIMP GetSizeMax( ULARGE_INTEGER FAR* pcbSize );

protected:
	HRESULT Seek(void *pStateData,MUSIC_TIME mtTime);
    HRESULT Play(void *pStateData,MUSIC_TIME mtStart,MUSIC_TIME mtEnd,
        MUSIC_TIME mtOffset,REFERENCE_TIME rtOffset,DWORD dwFlags,		
	    IDirectMusicPerformance* pPerf,IDirectMusicSegmentState* pSegSt,
	    DWORD dwVirtualID,BOOL fClockTime);
	void Construct(void);

// private member variables
protected:
	SysExList	m_SysExEventList;
	long	m_cRef;
	DWORD	m_dwValidate;
	CRITICAL_SECTION m_CrSec;
    BOOL    m_fCSInitialized;
};

#endif //__SYSEXTRK_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\str.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1998 Microsoft Corporation
//
//  File:       str.h
//
//--------------------------------------------------------------------------

//
// string.h
//

#include <objbase.h>

#ifndef __BRSTRING_H__
#define __BRSTRING_H__

class Archive;

class String
{
    friend String operator+( const String& str1, const String& str2 );
    friend String operator+( const String& str1, LPCSTR lpszStr );
    friend String operator+( LPCSTR lpszStr, const String& str1 );
    friend String operator+( const String& str1, char ch );
    friend String operator+( char ch, const String& str1 );

public:
    String();
    String( LPCSTR lpszStr );
    String( const String& str );
    String( LPCWSTR pszWstr );
    ~String();

    //BOOL LoadString( UINT nID, HINSTANCE hInstance );

    BOOL IsEmpty() const
    {
        return ( m_wLength == 0 );
    };
    WORD GetLength() const
    {
        return m_wLength;
    };
    int Compare( const String& str ) const
    {
		if (m_pBuf && str.m_pBuf)
		{
			return _wcsicmp( m_pBuf, str.m_pBuf );
		}
		else if (!m_pBuf && !str.m_pBuf)
		{
			return 0;
		}
		else if (!m_pBuf)
		{
			return -1;
		}
		else
		{
			return 1;
		}
    };
    int Compare( LPCWSTR lpwzStr ) const
    {
		if (m_pBuf && lpwzStr)
		{
			return _wcsicmp( m_pBuf, lpwzStr );
		}
		else if (!m_pBuf && !lpwzStr)
		{
			return 0;
		}
		else if (!m_pBuf)
		{
			return -1;
		}
		else
		{
			return 1;
		}
    };
    void Concat( const String& str );
    void Concat( LPCWSTR lpwzStr );
    void Concat( WCHAR wch );
    void TrimTrailingSpaces();
    WCHAR GetAt( UINT nIndex ) const
    {
        if( nIndex >= m_wLength )
        {
            return L'\0';
        }
        return m_pBuf[nIndex];
    };
    void SetAt( UINT nIndex, char ch )
    {
        if( nIndex < m_wLength )
        {
            m_pBuf[nIndex] = ch;
        }
    };
    HRESULT ReadWCS( LPSTREAM pStream, DWORD cSize );
    //HRESULT WriteWCS( LPSTREAM pStream );

// operators
    const String& operator+=( const String& str )   // concatenation
    {
        Concat( str );
        return *this;
    };
    const String& operator+=( LPCSTR lpszStr )      // concatenation
    {
        Concat( lpszStr );
        return *this;
    };
    const String& operator+=( char ch )             // concatenation
    {
        Concat( ch );
        return *this;
    };
    String& operator=( const String& str );
	String& operator=( LPCSTR pszStr );
    String& operator=( LPCWSTR pszWstr );
    operator const WCHAR*() const
    {
        return m_pBuf;
    }

private:
    WORD figureblocksize( WORD slen )
    {
        ++slen;         // for '\0'
        slen = static_cast<WORD>( slen / sm_wBlockSize );
        return static_cast<WORD>( ( slen + 1 ) * sm_wBlockSize );
    };

private:
    WORD m_wLength;
    WORD m_wAllocated;
    WCHAR* m_pBuf;

    static WORD sm_wBlockSize;  // size blocks are allocated in for strings
};

inline BOOL operator==( const String& s1, const String& s2 )
{
    return ( s1.Compare( s2 ) == 0 );
}

inline BOOL operator==( const WCHAR* s1, const String& s2 )
{
    return ( s2.Compare( s1 ) == 0 );
}

inline BOOL operator==( const String& s1, const WCHAR* s2 )
{
    return ( s1.Compare( s2 ) == 0 );
}

inline BOOL operator!=( const String& s1, const String& s2 )
{
    return ( s1.Compare( s2 ) != 0 );
}

inline BOOL operator!=( const WCHAR* s1, const String& s2 )
{
    return ( s2.Compare( s1 ) != 0 );
}

inline BOOL operator!=( const String& s1, const WCHAR* s2 )
{
    return ( s1.Compare( s2 ) != 0 );
}

inline BOOL operator<( const String& s1, const String& s2 )
{
    return ( s1.Compare( s2 ) < 0 );
}

inline BOOL operator<( const WCHAR* s1, const String& s2 )
{
    return ( s2.Compare( s1 ) > 0 );
}

inline BOOL operator<( const String& s1, const WCHAR* s2 )
{
    return ( s1.Compare( s2 ) < 0 );
}

inline BOOL operator>( const String& s1, const String& s2 )
{
    return ( s1.Compare( s2 ) > 0 );
}

inline BOOL operator>( const WCHAR* s1, const String& s2 )
{
    return ( s2.Compare( s1 ) < 0 );
}

inline BOOL operator>( const String& s1, const WCHAR* s2 )
{
    return ( s1.Compare( s2 ) > 0 );
}

inline BOOL operator<=( const String& s1, const String& s2 )
{
    return ( s1.Compare( s2 ) <= 0 );
}

inline BOOL operator<=( const WCHAR* s1, const String& s2 )
{
    return ( s2.Compare( s1 ) >= 0 );
}

inline BOOL operator<=( const String& s1, const WCHAR* s2 )
{
    return ( s1.Compare( s2 ) <= 0 );
}

inline BOOL operator>=( const String& s1, const String& s2 )
{
    return ( s1.Compare( s2 ) >= 0 );
}

inline BOOL operator>=( const WCHAR* s1, const String& s2 )
{
    return ( s2.Compare( s1 ) <= 0 );
}

inline BOOL operator>=( const String& s1, const WCHAR* s2 )
{
    return ( s1.Compare( s2 ) >= 0 );
}
#endif // __BRSTRING_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\tlist.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       tlist.cpp
//
//--------------------------------------------------------------------------

//
// tlist.cpp
//

//#include "stdafx.h"
#include "tlist.h"

template <class T>
TListItem<T>::~TListItem()
{
	//if (m_pNext != NULL) { delete m_pNext; }
	// IMPORTANT: user of the list is required to delete content first!
	//ZeroMemory(&m_Tinfo, sizeof(T));
}

template <class T>
void TListItem<T>::Delete(TListItem<T>* pFirst)
{
	TListItem<T>* pScan = pFirst;
	TListItem<T>* pNext = NULL;
	while (pScan)
	{
		pNext = pScan->m_pNext;
		delete pScan;
		pScan = pNext;
	}
}

template <class T>
LONG TListItem<T>::GetCount(void) const
{
    LONG l;
    const TListItem<T> *li;

    for(l=0,li=this; li!=NULL ; li=li->m_pNext,++l);
    return l;
}

template <class T>
TListItem<T>* TListItem<T>::Cat(TListItem<T> *pItem)
{
    TListItem<T> *li;

    if(this==NULL)
        return pItem;
    for(li=this ; li->m_pNext!=NULL ; li=li->m_pNext);
    li->m_pNext=pItem;
    return this;
}

template <class T>
TListItem<T>* TListItem<T>::Remove(TListItem<T> *pItem)
{
    TListItem<T> *li,*prev;

    if(pItem==this)
        return m_pNext;
    prev=NULL;
    for(li=this; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    if(li==NULL)     // item not found in list
        return this;

//  here it is guaranteed that prev is non-NULL since we checked for
//  that condition at the very beginning

    prev->SetNext(li->m_pNext);
    li->SetNext(NULL);
    return this;
}

template <class T>
TListItem<T>* TListItem<T>::GetPrev(TListItem<T> *pItem) const
{
    const TListItem<T> *li,*prev;

    prev=NULL;
    for(li=this ; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    return (TListItem<T>*)prev;
}

template <class T>
TListItem<T> * TListItem<T>::GetItem(LONG index)

{
	TListItem<T> *scan;
	for (scan = this; scan!=NULL && index; scan = scan->m_pNext) 
	{
		index--;
	}
	return (scan);
}

template <class T>
TListItem<T>* TListItem<T>::MergeSort(BOOL (* fcnCompare) (T&, T&))
{
	if (m_pNext != NULL)
	{
		TListItem<T> *pList1, *pList2;
		Divide(pList1, pList2);
		return pList1->MergeSort(fcnCompare)->Merge(pList2->MergeSort(fcnCompare), fcnCompare);
	}
	return this;
}

template <class T>
void TListItem<T>::Divide(TListItem<T>*& pHead1, TListItem<T>*& pHead2)
{
	TListItem<T> *pCurrent = this, *pTail1 = NULL, *pTail2 = NULL;
	do
	{
		pHead1 = pCurrent;
		pCurrent = pCurrent->m_pNext;
		pHead1->m_pNext = pTail1;
		pTail1 = pHead1;
		if (pCurrent != NULL)
		{
			pHead2 = pCurrent;
			pCurrent = pCurrent->m_pNext;
			pHead2->m_pNext = pTail2;
			pTail2 = pHead2;
		}
	} while (pCurrent != NULL);
}

template <class T>
TListItem<T>* TListItem<T>::Merge(TListItem<T>* pOtherList, BOOL (* fcnCompare) (T&, T&))
{
	if (!pOtherList) return this;
	TListItem<T>
		*pThisList = this, *pResultHead = NULL, *pResultTail = NULL, *pMergeItem = NULL;
	while (pThisList && pOtherList)
	{
		if ( fcnCompare(pThisList->m_Tinfo, pOtherList->m_Tinfo) )
		{
			pMergeItem = pThisList;
			pThisList = pThisList->GetNext();
		}
		else
		{
			pMergeItem = pOtherList;
			pOtherList = pOtherList->GetNext();
		}
		pMergeItem->SetNext(NULL);
		if (!pResultTail)
		{
			pResultHead = pResultTail = pMergeItem;
		}
		else
		{
			pResultTail->SetNext(pMergeItem);
			pResultTail = pMergeItem;
		}
	}
	if (pThisList) pResultTail->SetNext(pThisList);
	else pResultTail->SetNext(pOtherList);
	return pResultHead;
}

template <class T>
void TList<T>::InsertBefore(TListItem<T> *pItem,TListItem<T> *pInsert)

{
	TListItem<T> *prev = GetPrev(pItem);
	pInsert->SetNext(pItem);
	if (prev) prev->SetNext(pInsert);
	else m_pHead = pInsert;
}

template <class T>
void TList<T>::AddTail(TListItem<T> *pItem) 

{
	m_pHead = m_pHead->AddTail(pItem);
}

template <class T>
void TList<T>::MergeSort(BOOL (* fcnCompare) (T&, T&))
{
	if (m_pHead != NULL && m_pHead->GetNext() != NULL)
		m_pHead = m_pHead->MergeSort(fcnCompare);
}

template <class T>
void TList<T>::Reverse(void)
{
	if( m_pHead )
	{
		TListItem<T>* pNewHead = m_pHead;
		TListItem<T>* pNext = m_pHead->GetNext();
		pNewHead->SetNext(NULL);
		for( m_pHead = pNext; m_pHead; m_pHead = pNext )
		{
			pNext = m_pHead->GetNext();
			m_pHead->SetNext(pNewHead);
			pNewHead = m_pHead;
		}
		m_pHead = pNewHead;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\toolprops_i.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0328 */
/* at Wed Jun 07 15:59:39 2000
 */
/* Compiler settings for ..\toolprops.idl:
    Os (OptLev=s), W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_TOOLPROPSLib,0x2735B8F3,0xFF4A,0x4AF2,0x80,0x53,0xBE,0x22,0xC0,0xCA,0x32,0x32);


MIDL_DEFINE_GUID(CLSID, CLSID_EchoPage,0x5337AF8F,0x3827,0x44DD,0x9E,0xE9,0xAB,0x6E,0x1A,0xAB,0xB6,0x0F);


MIDL_DEFINE_GUID(CLSID, CLSID_TransposePage,0x691BD8C2,0x2B07,0x4C92,0xA8,0x2E,0x92,0xD8,0x58,0xDE,0x23,0xD6);


MIDL_DEFINE_GUID(CLSID, CLSID_DurationPage,0x79D9CAF8,0xDBDA,0x4560,0xA8,0xB0,0x07,0xE7,0x3A,0x79,0xFA,0x6B);


MIDL_DEFINE_GUID(CLSID, CLSID_QuantizePage,0x623286DC,0x67F8,0x4055,0xA9,0xBE,0xF7,0xA7,0x17,0x6B,0xD1,0x50);


MIDL_DEFINE_GUID(CLSID, CLSID_TimeShiftPage,0x7D3BDEE7,0x9557,0x4085,0x82,0xEE,0x1B,0x2F,0x02,0xCE,0x4B,0xA6);


MIDL_DEFINE_GUID(CLSID, CLSID_SwingPage,0x0B237E01,0x062A,0x4A40,0x8D,0x43,0x4B,0x5F,0xCD,0x49,0x96,0x5A);


MIDL_DEFINE_GUID(CLSID, CLSID_VelocityPage,0x30EC7213,0x64BE,0x4EF6,0xBB,0x1B,0x46,0x34,0x27,0xEC,0x86,0x4B);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0328 */
/* at Wed Jun 07 15:59:39 2000
 */
/* Compiler settings for ..\toolprops.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_TOOLPROPSLib,0x2735B8F3,0xFF4A,0x4AF2,0x80,0x53,0xBE,0x22,0xC0,0xCA,0x32,0x32);


MIDL_DEFINE_GUID(CLSID, CLSID_EchoPage,0x5337AF8F,0x3827,0x44DD,0x9E,0xE9,0xAB,0x6E,0x1A,0xAB,0xB6,0x0F);


MIDL_DEFINE_GUID(CLSID, CLSID_TransposePage,0x691BD8C2,0x2B07,0x4C92,0xA8,0x2E,0x92,0xD8,0x58,0xDE,0x23,0xD6);


MIDL_DEFINE_GUID(CLSID, CLSID_DurationPage,0x79D9CAF8,0xDBDA,0x4560,0xA8,0xB0,0x07,0xE7,0x3A,0x79,0xFA,0x6B);


MIDL_DEFINE_GUID(CLSID, CLSID_QuantizePage,0x623286DC,0x67F8,0x4055,0xA9,0xBE,0xF7,0xA7,0x17,0x6B,0xD1,0x50);


MIDL_DEFINE_GUID(CLSID, CLSID_TimeShiftPage,0x7D3BDEE7,0x9557,0x4085,0x82,0xEE,0x1B,0x2F,0x02,0xCE,0x4B,0xA6);


MIDL_DEFINE_GUID(CLSID, CLSID_SwingPage,0x0B237E01,0x062A,0x4A40,0x8D,0x43,0x4B,0x5F,0xCD,0x49,0x96,0x5A);


MIDL_DEFINE_GUID(CLSID, CLSID_VelocityPage,0x30EC7213,0x64BE,0x4EF6,0xBB,0x1B,0x46,0x34,0x27,0xEC,0x86,0x4B);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\tpool.h ===
// Copyright (c) 1998 Microsoft Corporation
//
// TPool.h
//
// Template pool memory manager. Efficiently manage requests for many of the same (small) object.
// Named after t'Pool, the Vulcan programmer who invented the technique.
//
#ifndef _TPOOL_H_
#define _TPOOL_H_

#include "debug.h"

#define POOL_DEFAULT_BYTE_PER_BLOCK     4096
#define MIN_ITEMS_PER_BLOCK             4

///////////////////////////////////////////////////////////////////////////////
//
// CPool
//
// A simple memory manager that efficiently handles many objects of the same 
// size by allocating blocks containing multiple objects at once.
//
// 
template<class contained> class CPool
{
public:
    CPool(int nApproxBytesPerBlock = POOL_DEFAULT_BYTE_PER_BLOCK);
    ~CPool();

    contained *Alloc();
    void Free(contained* pToFree);

private:
    union CPoolNode
    {
        CPoolNode       *pNext;
        contained       c;
    };

    class CPoolBlock
    {
    public:
        CPoolBlock      *pNext;
        CPoolNode       *pObjects;
    };

    int                 nItemsPerBlock;             // Based on bytes per block
    int                 nAllocatedBlocks;           // # allocated blocks
    CPoolBlock          *pAllocatedBlocks;          // list of allocated blocks
    int                 nFreeList;                  // # nodes in free list
    CPoolNode           *pFreeList;                 // free list

private:
    bool RefillFreeList();

#ifdef DBG
    bool IsPoolNode(CPoolNode *pNode);
    bool IsInFreeList(CPoolNode *pNode);
#endif

};

///////////////////////////////////////////////////////////////////////////////
//
// CPool::CPool
//
// Figure out the number of contained objects per block based on the requested
// approximate block size. Initialize the free list to contain one block's 
// worth of objects.
// 
//
template<class contained> CPool<contained>::CPool(int nApproxBytesPerBlock)
{
    // Figure out how many items per block and cheat if too small
    //
    nItemsPerBlock = nApproxBytesPerBlock / sizeof(CPoolNode);
    if (nItemsPerBlock < MIN_ITEMS_PER_BLOCK)
    {
        nItemsPerBlock = MIN_ITEMS_PER_BLOCK;
    }

    nAllocatedBlocks = 0;
    pAllocatedBlocks = NULL;
    nFreeList = 0;
    pFreeList = NULL;

    // Fill up with some items ahead of time
    //
    RefillFreeList();
}

///////////////////////////////////////////////////////////////////////////////
//
// CPool::~CPool
//
// Free up all allocated blocks. There should be no outstanding blocks 
// allocated at this point.
//
// 
template<class contained> CPool<contained>::~CPool()
{
#ifdef DBG
    if (nFreeList < nAllocatedBlocks * nItemsPerBlock)
    {
        TraceI(0, "CPool::~Cpool: Warning: free'ing with outstanding objects allocated.\n");
    }
#endif
    
    // Clean up all allocated blocks and contained objects.
    //
    while (pAllocatedBlocks)
    {
        CPoolBlock *pNext = pAllocatedBlocks->pNext;

        delete[] pAllocatedBlocks->pObjects;
        delete pAllocatedBlocks;

        pAllocatedBlocks = pNext;
    }
}

///////////////////////////////////////////////////////////////////////////////
//
// CPool::Alloc
//
// Attempt to allocate a contained object and return NULL if out of memory.
// If the free list is empty then allocate another block.
//
// 
template<class contained> contained *CPool<contained>::Alloc()
{
    if (pFreeList == NULL)
    {
        if (!RefillFreeList())
        {
            return false;
        }
    }

    nFreeList--;
    contained *pAlloc = (contained*)pFreeList;
    pFreeList = pFreeList->pNext;

    return pAlloc;
}

///////////////////////////////////////////////////////////////////////////////
//
// CPool::Free
//
// Return a contained object to the free list. In the debug version make sure
// the object was in fact allocated from this pool in the first place and that
// it isn't already in the free list.
//
// 
template<class contained> void CPool<contained>::Free(contained *pToFree)
{
    CPoolNode *pNode = (CPoolNode*)pToFree;

#ifdef DBG
    if (!IsPoolNode(pNode))
    {
        TraceI(0, "CPool::Free() Object %p is not a pool node; ignored.\n", pToFree);
        return;
    }
    
    if (IsInFreeList(pNode))
    {
        TraceI(0, "CPool::Free() Object %p is already in the free list; ignored.\n", pToFree);
        return;
    }
#endif

    nFreeList++;
    pNode->pNext = pFreeList;
    pFreeList = pNode;
}

///////////////////////////////////////////////////////////////////////////////
//
// CPool::RefillFreeList
//
// Add one block's worth of contained objects to the free list, tracking the 
// allocated memory so we can free it later.
//
// 
template<class contained> bool CPool<contained>::RefillFreeList()
{
    // Allocate a new block and the actual block of objects
    //
    CPoolBlock *pNewBlock = new CPoolBlock;
    if (pNewBlock == NULL)
    {
        return false;
    }

    pNewBlock->pObjects = new CPoolNode[nItemsPerBlock];
    if (pNewBlock->pObjects == NULL)
    {
        delete pNewBlock;
        return false;
    }
    
    TraceI(1, "CPool: Alllocated block %p objects %p for %d bytes\n", 
        pNewBlock, pNewBlock->pObjects, sizeof(CPoolNode) * nItemsPerBlock);

    // Link the block and objects into the right places. First link the new block
    // into the list of allocated blocks.
    //
    pNewBlock->pNext = pAllocatedBlocks;
    pAllocatedBlocks = pNewBlock;

    // Link all the contained object nodes into the free list.
    //
    CPoolNode *pFirstNode = &pNewBlock->pObjects[0];
    CPoolNode *pLastNode  = &pNewBlock->pObjects[nItemsPerBlock - 1];

    for (CPoolNode *pNode = pFirstNode; pNode < pLastNode; pNode++)
    {
        pNode->pNext = pNode + 1;
    }

    pLastNode->pNext = pFreeList;
    pFreeList = pFirstNode;
    
    nFreeList += nItemsPerBlock;
    nAllocatedBlocks++;

    return true;
}

#ifdef DBG
///////////////////////////////////////////////////////////////////////////////
//
// CPool::IsPoolNode (debug)
//
// Verify that the passed pointer is a pointer to a pool node by walking the list
// of allocated blocks.
//
// 
template<class contained> bool CPool<contained>::IsPoolNode(CPoolNode *pTest)
{
    for (CPoolBlock *pBlock = pAllocatedBlocks; pBlock; pBlock = pBlock->pNext)
    {
        CPoolNode *pFirstNode = &pBlock->pObjects[0];
        CPoolNode *pLastNode  = &pBlock->pObjects[nItemsPerBlock - 1];

        for (CPoolNode *pNode = pFirstNode; pNode <= pLastNode; pNode++)
        {
            if (pNode == pTest)
            {
                return true;
            }
        }
    }

    return false;
}

///////////////////////////////////////////////////////////////////////////////
//
// CPool::IsInFreeList (debug)
//
// Verify that the passed pointer points to a node that is already in the free
// list.
//
// 
template<class contained> bool CPool<contained>::IsInFreeList(CPoolNode *pTest)
{
    for (CPoolNode *pNode = pFreeList; pNode; pNode = pNode->pNext)
    {
        if (pTest == pNode)
        {
            return true;
        }
    }
    
    return false;
}
#endif  // DBG
#endif  // _TPOOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\template.h ===
// Copyright (c) 1998 Microsoft Corporation
// templates.h

#ifndef __TEMPLATES_H__
#define __TEMPLATES_H__

#include <windows.h>

template< class T > T* List_Cat( T* p1, T* p2 )
{
    T* pScan;

    if( p1 == NULL )
    {
        return p2;
    }
    for( pScan = p1 ; pScan->pNext != NULL ; pScan = (T*)pScan->pNext );
    pScan->pNext = p2;
    return p1;
}

template< class T > DWORD List_Len( T* p )
{
    DWORD dw;

    for( dw = 0 ; p != NULL ; p = (T*)p->pNext )
    {
         ++dw;
    }

    return dw;
}

template< class T > BOOL inlist( T* lst, T* p )
{
    if( p == NULL )
    {
        return TRUE;
    }

    for( ; lst != NULL ; lst = (T*)lst->pNext )
    {
        if( p == lst )
        {
            return TRUE;
        }
    }

    return FALSE;
}

template< class T > T* List_Index( T* lst, DWORD dwIndex )
{
    T* pScan;

    for( pScan = lst ; dwIndex > 0 && pScan != NULL && pScan->pNext != NULL ; --dwIndex, pScan = (T*)pScan->pNext );

    return pScan;
}

template< class T > T* List_Insert( T* lst, T* p, DWORD dwIndex )
{
    T* pPrev;

    if( lst == NULL || dwIndex == 0 )
    {
        p->pNext = lst;
        lst = p;
    }
    else
    {
        pPrev = List_Index( lst, dwIndex - 1 );
        p->pNext = pPrev->pNext;
        pPrev->pNext = p;
    }

    return lst;
}

template< class T > T* List_Remove( T* lst, T* p )
{
    if( lst != NULL )
    {
        if( lst == p )
        {
            lst = (T*)lst->pNext;
            p->pNext = NULL;
        }
        else
        {
            T* pScan;

            for( pScan = lst ; pScan->pNext != p && pScan->pNext != NULL ; pScan = (T*)pScan->pNext );
            if( pScan->pNext != NULL )
            {
                pScan->pNext = pScan->pNext->pNext;
                p->pNext = NULL;
            }
        }
    }

    return lst;
}

template< class T > long List_Position( T* lst, T* p )
{
    long lPos;

    lPos = 0;
    while( lst != NULL && lst != p )
    {
        lst = lst->pNext;
        ++lPos;
    }
    if( lst == NULL )
    {
        return -1;
    }

    return lPos;
}

template< class T > T* List_Clone( T* lst )
{
    T* pPrev;
    T* lstClone;
    T* pCopy;

    lstClone = NULL;
    pPrev = NULL;

    for( ; lst ; lst = (T*)lst->pNext )
    {
        pCopy = new T;
        if( pCopy != NULL )
        {
            memcpy( pCopy, lst, sizeof( T ) );
            pCopy->pNext = NULL;
            if( pPrev != NULL )
            {
                pPrev->pNext = pCopy;
            }
            else
            {
                lstClone = pCopy;
            }
            pPrev = pCopy;
        }
    }

    return lstClone;
}

template< class T > void List_Free( T* lst )
{
    T* pNext;

    for( ; lst != NULL ; lst = pNext )
    {
        pNext = (T*)lst->pNext;
        delete lst;
    }
}

template< class T > T* Clone( T* p )
{
    T* pCopy;

    pCopy = new T;
    if( pCopy != NULL )
    {
        memcpy( pCopy, p, sizeof( T ) );
        pCopy->pNext = NULL;
    }

    return pCopy;
}

#endif // __TEMPLATES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\trackhelp.inl ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Base classes that implement aspects of a standard DirectMusic track.
// Implementations for CPlayingTrack.
//

//////////////////////////////////////////////////////////////////////
// Creation

template<class T, class EventItem, class StateData>
CPlayingTrack<T, EventItem, StateData>::CPlayingTrack(
		long *plModuleLockCounter,
		const CLSID &rclsid,
		bool fNeedsLoader,
		bool fPlayInvalidations)
  : m_dwValidate(0),
	m_fNeedsLoader(fNeedsLoader),
	m_fPlayInvalidations(fPlayInvalidations),
	CBasicTrack(plModuleLockCounter, rclsid)
{
}

//////////////////////////////////////////////////////////////////////
// IPersistStream

// Function used to sort the event list according to trigger time.
template<class EventItem>
struct CmpStruct //  shouldn't need this, but I had trouble getting a straight templated function to match the function pointer with the NT compiler.  try again later with the new one.
{
	static BOOL EventCompare(EventItem &ri1, EventItem &ri2)
	{
		return ri1.lTriggerTime < ri2.lTriggerTime;
	}
};

template<class T, class EventItem, class StateData>
STDMETHODIMP
CPlayingTrack<T, EventItem, StateData>::Load(IStream* pIStream)
{
	V_INAME(CPlayingTrack::Load);
	V_INTERFACE(pIStream);
	HRESULT hr = S_OK;

	SmartRef::CritSec CS(&m_CriticalSection);

	// Clear the event list in case we're being reloaded.
	m_EventList.CleanUp();
	// Increment counter so the next play will update state data with the new list.
	++m_dwValidate;

	// Get the loader if requested in constructor
	SmartRef::ComPtr<IDirectMusicLoader> scomLoader;
	if (m_fNeedsLoader)
	{
		IDirectMusicGetLoader *pIGetLoader;
		hr = pIStream->QueryInterface(IID_IDirectMusicGetLoader, reinterpret_cast<void**>(&pIGetLoader));
		if (FAILED(hr))
			return hr;
		hr = pIGetLoader->GetLoader(&scomLoader);
		pIGetLoader->Release();
		if (FAILED(hr))
			return hr;
	}

	SmartRef::RiffIter ri(pIStream);
	if (!ri)
		return ri.hr();

	hr = this->LoadRiff(ri, scomLoader);
	if (FAILED(hr))
		return hr;

	m_EventList.MergeSort(CmpStruct<EventItem>::EventCompare);

	return hr;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicTrack

template<class T, class EventItem, class StateData>
STDMETHODIMP
CPlayingTrack<T, EventItem, StateData>::InitPlay(
		IDirectMusicSegmentState *pSegmentState,
		IDirectMusicPerformance *pPerformance,
		void **ppStateData,
		DWORD dwTrackID,
		DWORD dwFlags)
{
	V_INAME(CPlayingTrack::InitPlay);
	V_PTRPTR_WRITE(ppStateData);
	V_INTERFACE(pSegmentState);
	V_INTERFACE(pPerformance);

	SmartRef::CritSec CS(&m_CriticalSection);

	// Set up state data
	StateData *pStateData = new StateData;
	if (!pStateData)
		return E_OUTOFMEMORY;

	*ppStateData = pStateData;

	return S_OK;
}

template<class T, class EventItem, class StateData>
STDMETHODIMP
CPlayingTrack<T, EventItem, StateData>::EndPlay(void *pStateData)
{
	V_INAME(CPlayingTrack::EndPlay);
	V_BUFPTR_WRITE(pStateData, sizeof(StateData));

	SmartRef::CritSec CS(&m_CriticalSection);

	StateData *pSD = static_cast<StateData *>(pStateData);
	delete pSD;

	return S_OK;
}

template<class T, class EventItem, class StateData>
STDMETHODIMP
CPlayingTrack<T, EventItem, StateData>::Clone(
		MUSIC_TIME mtStart,
		MUSIC_TIME mtEnd,
		IDirectMusicTrack** ppTrack)
{
	V_INAME(CPlayingTrack::Clone);
	V_PTRPTR_WRITE(ppTrack);

	SmartRef::CritSec CS(&m_CriticalSection);

	HRESULT hr = S_OK;

	T *pTrack = new T(&hr);
	if (FAILED(hr))
		return hr;
	*ppTrack = pTrack;
	if (!pTrack)
		return E_OUTOFMEMORY;

	pTrack->AddRef();
	for (TListItem<EventItem> *pItem = m_EventList.GetHead();
			pItem;
			pItem = pItem->GetNext())
	{
		EventItem &ritem = pItem->GetItemValue();
		if (ritem.lTriggerTime >= mtEnd)
			break;
		if (ritem.lTriggerTime < mtStart)
			continue;

		TListItem<EventItem> *pNewItem = new TListItem<EventItem>;
		if (!pNewItem)
		{
			hr = E_OUTOFMEMORY;
			goto End;
		}

		EventItem &rnew = pNewItem->GetItemValue();
		hr = rnew.Clone(ritem, mtStart);
		if (FAILED(hr))
		{
			delete pNewItem;
			goto End;
		}
		pTrack->m_EventList.AddHead(pNewItem);
	}
	pTrack->m_EventList.Reverse();
	++pTrack->m_dwValidate;

End:
	if (FAILED(hr))
		pTrack->Release();
	return hr;
}

template<class T, class EventItem, class StateData>
HRESULT
CPlayingTrack<T, EventItem, StateData>::PlayMusicOrClock(
	void *pStateData,
	MUSIC_TIME mtStart,
	MUSIC_TIME mtEnd,
	MUSIC_TIME mtOffset,
	REFERENCE_TIME rtOffset,
	DWORD dwFlags,
	IDirectMusicPerformance* pPerf,
	IDirectMusicSegmentState* pSegSt,
	DWORD dwVirtualID,
	bool fClockTime)
{
	V_INAME(CPlayingTrack::Play);
	V_BUFPTR_WRITE( pStateData, sizeof(StateData));
	V_INTERFACE(pPerf);
	V_INTERFACE(pSegSt);

	if (dwFlags & DMUS_TRACKF_PLAY_OFF)
		return S_OK;

	SmartRef::CritSec CS(&m_CriticalSection);

	StateData *pSD = static_cast<StateData *>(pStateData);
	TListItem<EventItem> *li = pSD->pCurrentEvent;

	// Seek through the event list to find the proper first event if
	// the event list pointed to by the state data has been reloaded
	// or if playback has made a jump to a different position in the track.
	if (m_dwValidate != pSD->dwValidate ||
			dwFlags & (DMUS_TRACKF_SEEK | DMUS_TRACKF_LOOP | DMUS_TRACKF_FLUSH))
	{
		assert(m_dwValidate != pSD->dwValidate || dwFlags & DMUS_TRACKF_SEEK); // by contract SEEK should be set whenever the other dwFlags are
		li = this->Seek(mtStart);
		pSD->dwValidate = m_dwValidate;
	}

	if (m_fPlayInvalidations || !(dwFlags & DMUS_TRACKF_FLUSH))
	{
		for (; li; li = li->GetNext())
		{
			EventItem &rinfo = li->GetItemValue();
			if (rinfo.lTriggerTime < mtStart) // this can happen if DMUS_TRACKF_PLAY_OFF was set and the seek pointer remains at events from the past
				continue;
			if (rinfo.lTriggerTime >= mtEnd)
				break;
			if (FAILED(this->PlayItem(rinfo, *pSD, pPerf, pSegSt, dwVirtualID, mtOffset, rtOffset, fClockTime)))
			{
				// Returning an error from Play is not allowed.  Just ignore it and assert
				// so we would detect this while testing.
				assert(false);
				continue;
			}
		}
	}

	pSD->pCurrentEvent = li;
	return li ? S_OK : DMUS_S_END;
}

template<class T, class EventItem, class StateData>
TListItem<EventItem> *
CPlayingTrack<T, EventItem, StateData>::Seek(MUSIC_TIME mtStart)
{
	TListItem<EventItem> *li;
	for (li = m_EventList.GetHead();
			li && li->GetItemValue().lTriggerTime < mtStart;
			li = li->GetNext())
	{}

	return li;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\tempotrk.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
// TempoTrk.h : Declaration of the CTempoTrack

#ifndef __TEMPOTRK_H_
#define __TEMPOTRK_H_

#include "dmusici.h"
#include "dmusicf.h"
#include "tlist.h"

struct PrivateTempo
{
    double      dblTempo;
    MUSIC_TIME  mtTime;
    MUSIC_TIME  mtDelta;
    bool        fLast;

    PrivateTempo() : dblTempo(120.), mtTime(0), mtDelta(0), fLast(false) {}
};

DEFINE_GUID(GUID_PrivateTempoParam, 0xe8dbd832, 0xbcf0, 0x4c8c, 0xa0, 0x75, 0xa3, 0xf1, 0x5e, 0x67, 0xfd, 0x63);

struct TempoStateData
{
	IDirectMusicPerformance*	pPerformance;
	IDirectMusicSegmentState*	pSegState;
	DWORD						dwVirtualTrackID;
	MUSIC_TIME					mtPrevEnd;
	TListItem<DMUS_IO_TEMPO_ITEM>*		pCurrentTempo;
	DWORD						dwValidate;
    BOOL                        fActive;

	TempoStateData()
	{
		mtPrevEnd = 0;
	}
};

/////////////////////////////////////////////////////////////////////////////
// CTempoTrack
class CTempoTrack : 
	public IPersistStream,
	public IDirectMusicTrack8
{
public:
	CTempoTrack();
	CTempoTrack(
		const CTempoTrack& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd);
	~CTempoTrack();

// member variables
protected:
	TList<DMUS_IO_TEMPO_ITEM>	m_TempoEventList;
	long				m_cRef;
	DWORD				m_dwValidate; // used to validate state data
	CRITICAL_SECTION	m_CrSec;
    BOOL                m_fCSInitialized;
	BOOL				m_fActive; // if FALSE, disable output and param support
    BOOL                m_fStateSetBySetParam;  // If TRUE, active flag was set by GUID. Don't override. 

public:
// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

// IDirectMusicTrack methods
    STDMETHODIMP IsParamSupported(REFGUID rguid);
    STDMETHODIMP Init(IDirectMusicSegment *pSegment);
    STDMETHODIMP InitPlay(IDirectMusicSegmentState *pSegmentState,
                IDirectMusicPerformance *pPerformance,
                void **ppStateData,
                DWORD dwTrackID,
                DWORD dwFlags);
    STDMETHODIMP EndPlay(void *pStateData);
    STDMETHODIMP Play(void *pStateData,MUSIC_TIME mtStart,
                MUSIC_TIME mtEnd,MUSIC_TIME mtOffset,
		        DWORD dwFlags,IDirectMusicPerformance* pPerf,
		        IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID);
    STDMETHODIMP GetParam(REFGUID rguid,MUSIC_TIME mtTime,MUSIC_TIME* pmtNext,void *pData);
    STDMETHODIMP SetParam(REFGUID rguid,MUSIC_TIME mtTime,void *pData);
    STDMETHODIMP AddNotificationType(REFGUID rguidNotification);
    STDMETHODIMP RemoveNotificationType(REFGUID rguidNotification);
    STDMETHODIMP Clone(MUSIC_TIME mtStart,MUSIC_TIME mtEnd,IDirectMusicTrack** ppTrack);
// IDirectMusicTrack8 
    STDMETHODIMP PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf, 
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) ; 
    STDMETHODIMP GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) ; 
    STDMETHODIMP SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,void* pParam, void * pStateData, DWORD dwFlags) ;
    STDMETHODIMP Compose(IUnknown* pContext, 
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;
    STDMETHODIMP Join(IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		IUnknown* pContext,
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;
// IPersist functions
    STDMETHODIMP GetClassID( CLSID* pClsId );
// IPersistStream functions
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load( IStream* pIStream );
    STDMETHODIMP Save( IStream* pIStream, BOOL fClearDirty );
    STDMETHODIMP GetSizeMax( ULARGE_INTEGER FAR* pcbSize );
protected:
    HRESULT Play(
        void *pStateData,	
        MUSIC_TIME mtStart,	
        MUSIC_TIME mtEnd,
        MUSIC_TIME mtOffset,
        REFERENCE_TIME rtOffset,
	    DWORD dwFlags,		
	    IDirectMusicPerformance* pPerf,	
	    IDirectMusicSegmentState* pSegSt,
	    DWORD dwVirtualID,
        BOOL fClockTime);
	HRESULT Seek(TempoStateData *pSD,MUSIC_TIME mtTime,BOOL fGetPrevious );
	void Construct(void);
	HRESULT JoinInternal(IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		DWORD dwTrackGroup);
};

#endif //__TEMPOTRK_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\tempotrk.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)

// TempoTrk.cpp : Implementation of CTempoTrack
#include "dmime.h"
#include "TempoTrk.h"
#include "dmusici.h"
#include "dmusicf.h"
#include "debug.h"
#include "dmperf.h"
#include "Validate.h"
#include "debug.h"
#define ASSERT  assert

/////////////////////////////////////////////////////////////////////////////
// CTempoTrack

void CTempoTrack::Construct()
{
    InterlockedIncrement(&g_cComponent);

    m_cRef = 1;
    m_dwValidate = 0;
    m_fCSInitialized = FALSE;
    InitializeCriticalSection(&m_CrSec);
    m_fCSInitialized = TRUE;
}

CTempoTrack::CTempoTrack()
{
    Construct();
    m_fActive = TRUE;
    m_fStateSetBySetParam = FALSE;
}

CTempoTrack::CTempoTrack(
        const CTempoTrack& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd)
{
    Construct();
    m_fActive = rTrack.m_fActive;
    m_fStateSetBySetParam = rTrack.m_fStateSetBySetParam;
    TListItem<DMUS_IO_TEMPO_ITEM>* pScan = rTrack.m_TempoEventList.GetHead();
    //1////////////////////////////////////////
    TListItem<DMUS_IO_TEMPO_ITEM>* pPrevious = NULL;
    //1////////////////////////////////////////
    for(; pScan; pScan = pScan->GetNext())
    {
        DMUS_IO_TEMPO_ITEM& rScan = pScan->GetItemValue();
        //2////////////////////////////////////////
        if (rScan.lTime < mtStart)
        {
            pPrevious = pScan;
        }
        //2////////////////////////////////////////
        else if (rScan.lTime < mtEnd)
        {
            //3////////////////////////////////////////
            if (rScan.lTime == mtStart)
            {
                pPrevious = NULL;
            }
            //3////////////////////////////////////////
            TListItem<DMUS_IO_TEMPO_ITEM>* pNew = new TListItem<DMUS_IO_TEMPO_ITEM>;
            if (pNew)
            {
                DMUS_IO_TEMPO_ITEM& rNew = pNew->GetItemValue();
                memcpy( &rNew, &rScan, sizeof(DMUS_IO_TEMPO_ITEM) );
                rNew.lTime = rScan.lTime - mtStart;
                m_TempoEventList.AddHead(pNew); // instead of AddTail, which is n^2. We reverse below.
            }
        }
        else break;
    }
    m_TempoEventList.Reverse(); // for above AddHead.
    //4////////////////////////////////////////
    if (pPrevious)
    {
        DMUS_IO_TEMPO_ITEM& rPrevious = pPrevious->GetItemValue();
        TListItem<DMUS_IO_TEMPO_ITEM>* pNew = new TListItem<DMUS_IO_TEMPO_ITEM>;
        if (pNew)
        {
            DMUS_IO_TEMPO_ITEM& rNew = pNew->GetItemValue();
            memcpy( &rNew, &rPrevious, sizeof(DMUS_IO_TEMPO_ITEM) );
            rNew.lTime = 0;
            m_TempoEventList.AddHead(pNew);
        }
    }
    //4////////////////////////////////////////
}

CTempoTrack::~CTempoTrack()
{
    if (m_fCSInitialized)
    {
        DeleteCriticalSection(&m_CrSec);
    }
    InterlockedDecrement(&g_cComponent);
}

// @method:(INTERNAL) HRESULT | IDirectMusicTempoTrack | QueryInterface | Standard QueryInterface implementation for <i IDirectMusicTempoTrack>
//
// @parm const IID & | iid | Interface to query for
// @parm void ** | ppv | The requested interface will be returned here
//
// @rdesc Returns one of the following:
//
// @flag S_OK | If the interface is supported and was returned
// @flag E_NOINTERFACE | If the object does not support the given interface.
//
// @mfunc:(INTERNAL)
//
//
STDMETHODIMP CTempoTrack::QueryInterface(
    const IID &iid,   // @parm Interface to query for
    void **ppv)       // @parm The requested interface will be returned here
{
    V_INAME(CTempoTrack::QueryInterface);
    V_PTRPTR_WRITE(ppv);
    V_REFGUID(iid);

    if (iid == IID_IUnknown || iid == IID_IDirectMusicTrack || iid == IID_IDirectMusicTrack8)
    {
        *ppv = static_cast<IDirectMusicTrack8*>(this);
    } else
    if (iid == IID_IPersistStream)
    {
        *ppv = static_cast<IPersistStream*>(this);
    } else
    {
        *ppv = NULL;
        Trace(4,"Warning: Request to query unknown interface on Tempo Track\n");
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


// @method:(INTERNAL) HRESULT | IDirectMusicTempoTrack | AddRef | Standard AddRef implementation for <i IDirectMusicTempoTrack>
//
// @rdesc Returns the new reference count for this object.
//
// @mfunc:(INTERNAL)
//
//
STDMETHODIMP_(ULONG) CTempoTrack::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


// @method:(INTERNAL) HRESULT | IDirectMusicTempoTrack | Release | Standard Release implementation for <i IDirectMusicTempoTrack>
//
// @rdesc Returns the new reference count for this object.
//
// @mfunc:(INTERNAL)
//
//
STDMETHODIMP_(ULONG) CTempoTrack::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

/////////////////////////////////////////////////////////////////////////////
// IPersist

HRESULT CTempoTrack::GetClassID( CLSID* pClassID )
{
    V_INAME(CTempoTrack::GetClassID);
    V_PTR_WRITE(pClassID, CLSID); 
    *pClassID = CLSID_DirectMusicTempoTrack;
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IPersistStream functions

HRESULT CTempoTrack::IsDirty()
{
    return S_FALSE;
}

/*

  @method HRESULT | ITempoTrack | Load |
  Call this with an IStream filled with DMUS_IO_TEMPO_ITEM's, sorted in time order.
  @parm IStream* | pIStream |
  A stream of DMUS_IO_TEMPO_ITEM's, sorted in time order. The seek pointer should be
  set to the first event. The stream should only contain Tempo events and
  nothing more.
  @rvalue E_INVALIDARG | If pIStream == NULL
  @rvalue S_OK
  @comm The <p pIStream> will be AddRef'd inside this function and held
  until the TempoTrack is released.
*/
HRESULT CTempoTrack::Load( IStream* pIStream )
{
    V_INAME(CTempoTrack::Load);
    V_INTERFACE(pIStream);
    HRESULT hr = S_OK;

    EnterCriticalSection(&m_CrSec);
    m_dwValidate++; // used to validate state data that's out there
    if( m_TempoEventList.GetHead() )
    {
        TListItem<DMUS_IO_TEMPO_ITEM>* pItem;
        while( pItem = m_TempoEventList.RemoveHead() )
        {
            delete pItem;
        }
    }

    // copy contents of the stream into the list.
    LARGE_INTEGER li;
    DMUS_IO_TEMPO_ITEM tempoEvent;
    // read in the chunk id
    DWORD dwChunk, dwSubSize;
    long lSize;
    pIStream->Read( &dwChunk, sizeof(DWORD), NULL );
    if( dwChunk != DMUS_FOURCC_TEMPO_TRACK )
    {
        Trace(1,"Error: Invalid data in tempo track.\n");
        LeaveCriticalSection(&m_CrSec);
        return DMUS_E_CHUNKNOTFOUND;
    }
    // read in the overall size
    pIStream->Read( &lSize, sizeof(long), NULL );
    // read in the size of the data structures
    if( FAILED( pIStream->Read( &dwSubSize, sizeof(DWORD), NULL )))
    {
        // Check to make sure our reads are succeeding (we can safely
        // assume the previous reads worked if we got this far.)
        Trace(1,"Error: Unable to read tempo track.\n");
        LeaveCriticalSection(&m_CrSec);
        return DMUS_E_CANNOTREAD;
    }
    lSize -= sizeof(DWORD);

    DWORD dwRead, dwSeek;
    if( dwSubSize > sizeof(DMUS_IO_TEMPO_ITEM) )
    {
        dwRead = sizeof(DMUS_IO_TEMPO_ITEM);
        dwSeek = dwSubSize - dwRead;
        li.HighPart = 0;
        li.LowPart = dwSeek;
    }
    else
    {
        dwRead = dwSubSize;
        dwSeek = 0;
    }
    if( dwRead )
    {
        while( lSize > 0 )
        {
            if( FAILED( pIStream->Read( &tempoEvent, dwRead, NULL )))
            {
                Trace(1,"Error: Failure reading tempo track.\n");
                hr = DMUS_E_CANNOTREAD;
                break;
            }
            lSize -= dwRead;
            if( dwSeek )
            {
                if( FAILED( pIStream->Seek( li, STREAM_SEEK_CUR, NULL )))
                {
                    Trace(1,"Error: Failure reading tempo track.\n");
                    hr = DMUS_E_CANNOTSEEK;
                    break;
                }                                             
                lSize -= dwSeek;
            }
            TListItem<DMUS_IO_TEMPO_ITEM>* pNew = 
                new TListItem<DMUS_IO_TEMPO_ITEM>(tempoEvent);
            if (pNew)
            {
                m_TempoEventList.AddHead(pNew); // instead of AddTail, which is n^2. We reverse below.
            }
        }
        m_TempoEventList.Reverse();
    }
    else
    {
        Trace(1,"Error: Failure reading tempo track.\n");
        hr = DMUS_E_CANNOTREAD;
    }
    LeaveCriticalSection(&m_CrSec);
    return hr;
}

HRESULT CTempoTrack::Save( IStream* pIStream, BOOL fClearDirty )
{
    return E_NOTIMPL;
}

HRESULT CTempoTrack::GetSizeMax( ULARGE_INTEGER FAR* pcbSize )
{
    return E_NOTIMPL;
}

// IDirectMusicTrack
HRESULT STDMETHODCALLTYPE CTempoTrack::IsParamSupported( 
    /* [in] */ REFGUID rguid)
{
    V_INAME(IDirectMusicTrack::IsParamSupported);
    V_REFGUID(rguid);

    if (m_fStateSetBySetParam)
    {
        if( m_fActive )
        {
            if( rguid == GUID_DisableTempo ) return S_OK;
            if( rguid == GUID_TempoParam ) return S_OK;
            if( rguid == GUID_PrivateTempoParam ) return S_OK;
            if( rguid == GUID_EnableTempo ) return DMUS_E_TYPE_DISABLED;
        }
        else
        {
            if( rguid == GUID_EnableTempo ) return S_OK;
            if( rguid == GUID_DisableTempo ) return DMUS_E_TYPE_DISABLED;
            if( rguid == GUID_PrivateTempoParam ) return DMUS_E_TYPE_DISABLED;
            if( rguid == GUID_TempoParam ) return DMUS_E_TYPE_DISABLED;
        }
    }
    else
    {
        if(( rguid == GUID_DisableTempo ) ||
            ( rguid == GUID_TempoParam ) ||
            ( rguid == GUID_PrivateTempoParam ) ||
            ( rguid == GUID_EnableTempo )) return S_OK;
    }

    return DMUS_E_TYPE_UNSUPPORTED;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicTrack::Init
HRESULT CTempoTrack::Init( 
    /* [in] */ IDirectMusicSegment *pSegment)
{
    return S_OK;
}

HRESULT CTempoTrack::InitPlay( 
    /* [in] */ IDirectMusicSegmentState *pSegmentState,
    /* [in] */ IDirectMusicPerformance *pPerformance,
    /* [out] */ void **ppStateData,
    /* [in] */ DWORD dwTrackID,
    /* [in] */ DWORD dwFlags)
{
    V_INAME(IDirectMusicTrack::InitPlay);
    V_PTRPTR_WRITE(ppStateData);
    V_INTERFACE(pSegmentState);
    V_INTERFACE(pPerformance);

    TempoStateData* pStateData;
    pStateData = new TempoStateData;
    if( NULL == pStateData )
        return E_OUTOFMEMORY;
    *ppStateData = pStateData;
    if (m_fStateSetBySetParam)
    {
        pStateData->fActive = m_fActive;
    }
    else
    {
        pStateData->fActive = ((dwFlags & DMUS_SEGF_CONTROL) ||
            !(dwFlags & DMUS_SEGF_SECONDARY));
    }
    pStateData->dwVirtualTrackID = dwTrackID;
    pStateData->pPerformance = pPerformance; // weak reference, no addref.
    pStateData->pSegState = pSegmentState; // weak reference, no addref.
    pStateData->pCurrentTempo = m_TempoEventList.GetHead();
    pStateData->dwValidate = m_dwValidate;
    return S_OK;
}

HRESULT CTempoTrack::EndPlay( 
    /* [in] */ void *pStateData)
{
    ASSERT( pStateData );
    if( pStateData )
    {
        V_INAME(IDirectMusicTrack::EndPlay);
        V_BUFPTR_WRITE(pStateData, sizeof(TempoStateData));
        TempoStateData* pSD = (TempoStateData*)pStateData;
        delete pSD;
    }
    return S_OK;
}

STDMETHODIMP CTempoTrack::PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf,
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) 
{
    V_INAME(IDirectMusicTrack::PlayEx);
    V_BUFPTR_WRITE( pStateData, sizeof(TempoStateData));
    V_INTERFACE(pPerf);
    V_INTERFACE(pSegSt);

    HRESULT hr;
    EnterCriticalSection(&m_CrSec);
    if (dwFlags & DMUS_TRACKF_CLOCK)
    {
        // Convert all reference times to millisecond times. Then, just use same MUSIC_TIME
        // variables.
        hr = Play(pStateData,(MUSIC_TIME)(rtStart / REF_PER_MIL),(MUSIC_TIME)(rtEnd / REF_PER_MIL),
            (MUSIC_TIME)(rtOffset / REF_PER_MIL),rtOffset,dwFlags,pPerf,pSegSt,dwVirtualID,TRUE);
    }
    else
    {
        hr = Play(pStateData,(MUSIC_TIME)rtStart,(MUSIC_TIME)rtEnd,
            (MUSIC_TIME)rtOffset,0,dwFlags,pPerf,pSegSt,dwVirtualID,FALSE);
    }
    LeaveCriticalSection(&m_CrSec);
    return hr;
}

STDMETHODIMP CTempoTrack::Play( 
    void *pStateData,   
    MUSIC_TIME mtStart, 
    MUSIC_TIME mtEnd,
    MUSIC_TIME mtOffset,
    DWORD dwFlags,  
    IDirectMusicPerformance* pPerf,
    IDirectMusicSegmentState* pSegSt,   
    DWORD dwVirtualID)
{
    V_INAME(IDirectMusicTrack::Play);
    V_BUFPTR_WRITE( pStateData, sizeof(TempoStateData));
    V_INTERFACE(pPerf);
    V_INTERFACE(pSegSt);

    EnterCriticalSection(&m_CrSec);
    HRESULT hr = Play(pStateData,mtStart,mtEnd,mtOffset,0,dwFlags,pPerf,pSegSt,dwVirtualID,FALSE);
    LeaveCriticalSection(&m_CrSec);
    return hr;
}

HRESULT CTempoTrack::Play( 
    void *pStateData,   
    MUSIC_TIME mtStart, 
    MUSIC_TIME mtEnd,
    MUSIC_TIME mtOffset,
    REFERENCE_TIME rtOffset,
    DWORD dwFlags,      
    IDirectMusicPerformance* pPerf, 
    IDirectMusicSegmentState* pSegSt,
    DWORD dwVirtualID,
    BOOL fClockTime)
{
    if (dwFlags & DMUS_TRACKF_PLAY_OFF)
    {
        return S_OK;
    }
    HRESULT hr = DMUS_S_END;
    IDirectMusicGraph* pGraph = NULL;
    TempoStateData* pSD = (TempoStateData*)pStateData;
    BOOL fSeek = (dwFlags & DMUS_TRACKF_SEEK) ? TRUE : FALSE;

    // if mtStart is 0 and dwFlags contains DMUS_TRACKF_START, we want to be sure to
    // send out any negative time events. So, we'll set mtStart to -768.
    if( (mtStart == 0) && ( dwFlags & DMUS_TRACKF_START ))
    {
        mtStart = -768;
    }

    // if pSD->pCurrentTempo is NULL, and we're in a normal Play call (dwFlags is 0)
    // this means that we either have no events, or we got to the end of the event
    // list previously. So, it's safe to just return.
    if( (pSD->pCurrentTempo == NULL) && (dwFlags == 0) )
    {
        return S_FALSE;
    }

    if( pSD->dwValidate != m_dwValidate )
    {
        pSD->dwValidate = m_dwValidate;
        pSD->pCurrentTempo = NULL;
    }
    if (!pSD->pCurrentTempo)
    {
        pSD->pCurrentTempo = m_TempoEventList.GetHead();
    }
    if (!pSD->pCurrentTempo)
    {
        return DMUS_S_END;
    }
    // if the previous end time isn't the same as the current start time,
    // we need to seek to the right position.
    if( fSeek || ( pSD->mtPrevEnd != mtStart ))
    {
        TempoStateData tempData;
        BOOL fFlag = TRUE;
        tempData = *pSD; // put this in so we can use Seek in other functions such as GetParam
        if( !fSeek && (dwFlags & DMUS_TRACKF_DIRTY ))
        {
            fFlag = FALSE;
        }
        Seek( &tempData, mtStart, fFlag );
        *pSD = tempData;
    }
    pSD->mtPrevEnd = mtEnd;

    if( FAILED( pSD->pSegState->QueryInterface( IID_IDirectMusicGraph,
        (void**)&pGraph )))
    {
        pGraph = NULL;
    }

    for (; pSD->pCurrentTempo; pSD->pCurrentTempo = pSD->pCurrentTempo->GetNext())
    {
        DMUS_IO_TEMPO_ITEM& rTempoEvent = pSD->pCurrentTempo->GetItemValue();
        if( rTempoEvent.lTime >= mtEnd )
        {
            // this time is in the future. Return now to retain the same
            // seek pointers for next time.
            hr = S_OK;
            break;
        }
        if( rTempoEvent.lTime < mtStart )
        {
            if( dwFlags & DMUS_TRACKF_FLUSH )
            {
                // this time is in the past, and this call to Play is in response to an
                // invalidate. We don't want to replay stuff before the start time.
                continue;
            }
            else if( !( dwFlags & DMUS_TRACKF_START) && !(dwFlags & DMUS_TRACKF_SEEK) )
            {
                // we really only want to play events earlier than mtStart on account
                // of a START or SEEK (that isn't a FLUSH.)
                continue;
            }
        }
        if( pSD->fActive )
        {
            DMUS_TEMPO_PMSG* pTempo;
            if( SUCCEEDED( pSD->pPerformance->AllocPMsg( sizeof(DMUS_TEMPO_PMSG),
                (DMUS_PMSG**)&pTempo )))
            {
                if( rTempoEvent.lTime < mtStart )
                {
                    // this only happens in the case where we've puposefully seeked
                    // and need to time stamp this event with the start time
                    if (fClockTime)
                    {
                        pTempo->rtTime = (mtStart * REF_PER_MIL) + rtOffset;
                        pTempo->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME;
                    }
                    else
                    {
                        pTempo->mtTime = mtStart + mtOffset;
                        pTempo->dwFlags = DMUS_PMSGF_MUSICTIME;
                    }
                }
                else
                {
                    if (fClockTime)
                    {
                        pTempo->rtTime = (rTempoEvent.lTime  * REF_PER_MIL) + rtOffset;
                        pTempo->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME;
                    }
                    else
                    {
                        pTempo->mtTime = rTempoEvent.lTime + mtOffset;
                        pTempo->dwFlags = DMUS_PMSGF_MUSICTIME;
                    }
                }
                pTempo->dblTempo = rTempoEvent.dblTempo;
                pTempo->dwVirtualTrackID = pSD->dwVirtualTrackID;
                pTempo->dwType = DMUS_PMSGT_TEMPO;
                pTempo->dwGroupID = 0xffffffff;
                if( pGraph )
                {
                    pGraph->StampPMsg( (DMUS_PMSG*)pTempo );
                }
                if(FAILED(pSD->pPerformance->SendPMsg( (DMUS_PMSG*)pTempo )))
                {
                    pSD->pPerformance->FreePMsg( (DMUS_PMSG*)pTempo );
                }
            }
        }
    }
    if( pGraph )
    {
        pGraph->Release();
    }
    return hr;
}

// if fGetPrevious is TRUE, seek to the event prior to mtTime. Otherwise, seek to
// the event on or after mtTime
HRESULT CTempoTrack::Seek( 
    /* [in] */ TempoStateData *pSD,
    /* [in] */ MUSIC_TIME mtTime, BOOL fGetPrevious)
{
    TListItem<DMUS_IO_TEMPO_ITEM>* pScan = pSD->pCurrentTempo;
    if (!pScan)
    {
        pScan = m_TempoEventList.GetHead();
    }
    if (!pScan)
    {
        return S_FALSE;
    }
    // if the event's time is on or past mtTime, we need to go to the beginning
    if (pScan->GetItemValue().lTime >= mtTime)
    {
        pScan = m_TempoEventList.GetHead();
    }
    pSD->pCurrentTempo = pScan;
    for (; pScan; pScan = pScan->GetNext())
    {
        if (pScan->GetItemValue().lTime >= mtTime)
        {
            if (!fGetPrevious)
            {
                pSD->pCurrentTempo = pScan;
            }
            break;
        }
        pSD->pCurrentTempo = pScan;
    }
    return S_OK;
}

STDMETHODIMP CTempoTrack::GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) 
{
    HRESULT hr;
    MUSIC_TIME mtNext;
    if (dwFlags & DMUS_TRACK_PARAMF_CLOCK)
    {
        hr = GetParam(rguidType,(MUSIC_TIME) (rtTime / REF_PER_MIL), &mtNext, pParam);
        if (prtNext)
        {
            *prtNext = mtNext * REF_PER_MIL;
        }
    }
    else
    {
        hr = GetParam(rguidType,(MUSIC_TIME) rtTime, &mtNext, pParam);
        if (prtNext)
        {
            *prtNext = mtNext;
        }
    }
    return hr;
}

STDMETHODIMP CTempoTrack::SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,
                                      void* pParam, void * pStateData, DWORD dwFlags) 
{    
    if (dwFlags & DMUS_TRACK_PARAMF_CLOCK)
    {
        rtTime /= REF_PER_MIL;
    }
    return SetParam(rguidType, (MUSIC_TIME) rtTime , pParam);
}


HRESULT CTempoTrack::GetParam( 
    REFGUID rguid,
    MUSIC_TIME mtTime,
    MUSIC_TIME* pmtNext,
    void *pData)
{
    V_INAME(IDirectMusicTrack::GetParam);
    V_PTR_WRITE_OPT(pmtNext,MUSIC_TIME);
    V_REFGUID(rguid);

    HRESULT hr = DMUS_E_GET_UNSUPPORTED;
    if( NULL == pData )
    {
        return E_POINTER;
    }
    if( rguid == GUID_PrivateTempoParam )
    {
        DMUS_TEMPO_PARAM TempoData;
        PrivateTempo* pPrivateTempoData = (PrivateTempo*)pData;
        hr = GetParam(GUID_TempoParam, mtTime, pmtNext, (void*)&TempoData);
        if (hr == S_OK)
        {
            pPrivateTempoData->dblTempo = TempoData.dblTempo;
            pPrivateTempoData->mtTime = 0; // must be set by the caller
            pPrivateTempoData->mtDelta = TempoData.mtTime;
            pPrivateTempoData->fLast = (pmtNext && !*pmtNext);
        }
        else if (hr == DMUS_E_NOT_FOUND) // the tempo track was empty
        {
            pPrivateTempoData->fLast = true;
        }
    }
    else if( rguid == GUID_TempoParam )
    {
        if( !m_fActive )
        {
            return DMUS_E_TYPE_DISABLED;
        }
        DMUS_TEMPO_PARAM* pTempoData = (DMUS_TEMPO_PARAM*)pData;
        TListItem<DMUS_IO_TEMPO_ITEM>* pScan = m_TempoEventList.GetHead();
        TListItem<DMUS_IO_TEMPO_ITEM>* pPrevious = pScan;
        if (!pScan)
        {
            return DMUS_E_NOT_FOUND;
        }
        for (; pScan; pScan = pScan->GetNext())
        {
            if (pScan->GetItemValue().lTime > mtTime)
            {
                break;
            }
            pPrevious = pScan;
        }
        DMUS_IO_TEMPO_ITEM& rTempoEvent = pPrevious->GetItemValue();
        pTempoData->dblTempo = rTempoEvent.dblTempo;
        pTempoData->mtTime = rTempoEvent.lTime - mtTime;
        if (pmtNext)
        {
            *pmtNext = 0;
        }
        if (pScan)
        {
            DMUS_IO_TEMPO_ITEM& rNextTempoEvent = pScan->GetItemValue();
            if (pmtNext)
            {
                *pmtNext = rNextTempoEvent.lTime - mtTime;
            }
        }
        hr = S_OK;
    }
    return hr;
}

// Q: if all tracks are time-stamped, why do we need mtTime?
HRESULT CTempoTrack::SetParam( 
    REFGUID rguid,
    MUSIC_TIME mtTime,
    void *pData)
{
    V_INAME(IDirectMusicTrack::SetParam);
    V_REFGUID(rguid);

    EnterCriticalSection(&m_CrSec);

    HRESULT hr = DMUS_E_SET_UNSUPPORTED;

    if( rguid == GUID_DisableTempo )
    {
        if (m_fStateSetBySetParam && !m_fActive)
        {       // Already been disabled.
            hr = DMUS_E_TYPE_DISABLED;
        }
        else
        {
            m_fStateSetBySetParam = TRUE;
            m_fActive = FALSE;
            hr = S_OK;
        }
    }
    else if( rguid == GUID_EnableTempo )
    {
        if (m_fStateSetBySetParam && m_fActive)
        {       // Already been enabled.
            hr = DMUS_E_TYPE_DISABLED;
        }
        else
        {
            m_fStateSetBySetParam = TRUE;
            m_fActive = TRUE;
            hr = S_OK;
        }
    }
    else if( rguid == GUID_TempoParam )
    {
        if (!m_fActive)
        {   // Oops, app intentionally disabled tempo.
            hr = DMUS_E_TYPE_DISABLED;
        }
        else
        {
            if( NULL == pData )
            {
                LeaveCriticalSection(&m_CrSec);
                return E_POINTER;
            }
            DMUS_TEMPO_PARAM* pTempoData = (DMUS_TEMPO_PARAM*)pData;
            TListItem<DMUS_IO_TEMPO_ITEM>* pScan = m_TempoEventList.GetHead();
            TListItem<DMUS_IO_TEMPO_ITEM>* pPrevious = NULL;
            for (; pScan; pScan = pScan->GetNext())
            {
                if (pScan->GetItemValue().lTime >= mtTime)
                {
                    break;
                }
                pPrevious = pScan;
            }
            // Make a new DMUS_IO_TEMPO_ITEM and insert it after pPrevious
            TListItem<DMUS_IO_TEMPO_ITEM>* pNew = new TListItem<DMUS_IO_TEMPO_ITEM>;
            if (!pNew)
            {
                LeaveCriticalSection(&m_CrSec);
                return E_OUTOFMEMORY;
            }
            DMUS_IO_TEMPO_ITEM& rTempoEvent = pNew->GetItemValue();
            rTempoEvent.dblTempo = pTempoData->dblTempo;
            /*
            // I believe the fix for 204160 was supposed to change this line to what 
            // follows the comment.  RSW
            rTempoEvent.lTime = pTempoData->mtTime;
            */
            rTempoEvent.lTime = mtTime;
            if (pPrevious)
            {
                pNew->SetNext(pScan);
                pPrevious->SetNext(pNew);
            }
            else
            {
                m_TempoEventList.AddHead(pNew);
            }
            if (pScan && pScan->GetItemValue().lTime == mtTime)
            {
                // remove it
                pNew->SetNext(pScan->GetNext());
                pScan->SetNext(NULL);
                delete pScan;
            }
            m_dwValidate++;
            hr = S_OK;
        }
    }
    LeaveCriticalSection(&m_CrSec);
    return hr;
}

HRESULT STDMETHODCALLTYPE CTempoTrack::AddNotificationType(
    /* [in] */  REFGUID rguidNotification)
{
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CTempoTrack::RemoveNotificationType(
    /* [in] */  REFGUID rguidNotification)
{
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CTempoTrack::Clone(
    MUSIC_TIME mtStart,
    MUSIC_TIME mtEnd,
    IDirectMusicTrack** ppTrack)
{
    V_INAME(IDirectMusicTrack::Clone);
    V_PTRPTR_WRITE(ppTrack);

    HRESULT hr = S_OK;

    if(mtStart < 0 )
    {
        return E_INVALIDARG;
    }
    if(mtStart > mtEnd)
    {
        return E_INVALIDARG;
    }

    EnterCriticalSection(&m_CrSec);

    CTempoTrack *pDM;
    
    try
    {
        pDM = new CTempoTrack(*this, mtStart, mtEnd);
    }
    catch( ... )
    {
        pDM = NULL;
    }

    LeaveCriticalSection(&m_CrSec);
    if (pDM == NULL) {
        return E_OUTOFMEMORY;
    }


    hr = pDM->QueryInterface(IID_IDirectMusicTrack, (void**)ppTrack);
    pDM->Release();

    return hr;
}

STDMETHODIMP CTempoTrack::Compose(
        IUnknown* pContext, 
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack) 
{
    return E_NOTIMPL;
}

STDMETHODIMP CTempoTrack::Join(
        IDirectMusicTrack* pNewTrack,
        MUSIC_TIME mtJoin,
        IUnknown* pContext,
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack) 
{
    V_INAME(IDirectMusicTrack::Join);
    V_INTERFACE(pNewTrack);
    V_INTERFACE_OPT(pContext);
    V_PTRPTR_WRITE_OPT(ppResultTrack);

    HRESULT hr = S_OK;
    EnterCriticalSection(&m_CrSec);

    if (ppResultTrack)
    {
        hr = Clone(0, mtJoin, ppResultTrack);
        if (SUCCEEDED(hr))
        {
            hr = ((CTempoTrack*)*ppResultTrack)->JoinInternal(pNewTrack, mtJoin, dwTrackGroup);
        }
    }
    else
    {
        hr = JoinInternal(pNewTrack, mtJoin, dwTrackGroup);
    }

    LeaveCriticalSection(&m_CrSec);
    return hr;
}

HRESULT CTempoTrack::JoinInternal(
        IDirectMusicTrack* pNewTrack,
        MUSIC_TIME mtJoin,
        DWORD dwTrackGroup)
{
    HRESULT hr = S_OK;
    CTempoTrack* pOtherTrack = (CTempoTrack*)pNewTrack;
    TListItem<DMUS_IO_TEMPO_ITEM>* pScan = pOtherTrack->m_TempoEventList.GetHead();
    for (; pScan; pScan = pScan->GetNext())
    {
        DMUS_IO_TEMPO_ITEM& rScan = pScan->GetItemValue();
        TListItem<DMUS_IO_TEMPO_ITEM>* pNew = new TListItem<DMUS_IO_TEMPO_ITEM>;
        if (pNew)
        {
            DMUS_IO_TEMPO_ITEM& rNew = pNew->GetItemValue();
            rNew.lTime = rScan.lTime + mtJoin;
            rNew.dblTempo = rScan.dblTempo;
            m_TempoEventList.AddTail(pNew);
        }
        else
        {
            hr = E_OUTOFMEMORY;
            break;
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\timesig.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       timesig.h
//
//--------------------------------------------------------------------------

// TimeSig.h : time signature stuff
#ifndef __TIME_CONVERT__
#define __TIME_CONVERT__
#include "dmusici.h"
#include "dmusicf.h"
#include "score.h"
#include "debug.h"

struct DirectMusicTimeSig
{
	// Time signatures define how many beats per measure, which note receives
	// the beat, and the grid resolution.
	DirectMusicTimeSig() : m_bBeatsPerMeasure(0), m_bBeat(0), m_wGridsPerBeat(0) { }

	DirectMusicTimeSig(BYTE bBPM, BYTE bBeat, WORD wGPB) : 
		m_bBeatsPerMeasure(bBPM), 
		m_bBeat(bBeat),
		m_wGridsPerBeat(wGPB) 
	{ }

	DirectMusicTimeSig(DMUS_TIMESIGNATURE& TSE) : 
		m_bBeatsPerMeasure(TSE.bBeatsPerMeasure), 
		m_bBeat(TSE.bBeat), 
		m_wGridsPerBeat(TSE.wGridsPerBeat) 
	{ }

	operator DMUS_TIMESIGNATURE()
	{
		DMUS_TIMESIGNATURE TSE;
		TSE.bBeatsPerMeasure = m_bBeatsPerMeasure; 
		TSE.bBeat = m_bBeat;
		TSE.wGridsPerBeat = m_wGridsPerBeat; 
		TSE.mtTime = 0;
		return TSE;
	}

	MUSIC_TIME ClocksPerBeat()
	{	
		if (m_bBeat)
		{
			return DMUS_PPQ * 4 / m_bBeat;
		}
		else
		{
			return 0;
		}
	}

	MUSIC_TIME FloorBeat(MUSIC_TIME mtTime)
	{	MUSIC_TIME mtOneBeat = ClocksPerBeat();
		return (!mtOneBeat || mtTime < mtOneBeat) ? 0 : (mtTime - (mtTime % mtOneBeat));
	}

	MUSIC_TIME CeilingBeat(MUSIC_TIME mtTime)
	{	return OnBeat(mtTime) ? mtTime : (FloorBeat(mtTime) + ClocksPerBeat());
	}

	BOOL OnBeat(MUSIC_TIME mtTime)
	{	MUSIC_TIME mtOneBeat = ClocksPerBeat();
		return (!mtOneBeat) ? FALSE : !(mtTime % mtOneBeat);
	}

	MUSIC_TIME GridsToMeasure(WORD wGrid)
	{	
		if (m_wGridsPerBeat && m_bBeatsPerMeasure)
		{
			return (wGrid / m_wGridsPerBeat) / m_bBeatsPerMeasure;
		}
		else
		{
			return 0;
		}
	}

	MUSIC_TIME GridsToBeat(WORD wGrid)
	{	
		if (m_wGridsPerBeat && m_bBeatsPerMeasure)
		{
			return (wGrid / m_wGridsPerBeat) % m_bBeatsPerMeasure;
		}
		else
		{
			return 0;
		}
	}

	MUSIC_TIME GridOffset(WORD wGrid)
	{	
		if (m_wGridsPerBeat)
		{
			return wGrid - ((wGrid / m_wGridsPerBeat) * m_wGridsPerBeat);
		}
		else
		{
			return 0;
		}
	}

	MUSIC_TIME ClocksPerGrid()
	{
		if (m_wGridsPerBeat)
		{
			return ClocksPerBeat() / m_wGridsPerBeat;
		}
		else
		{
			return 0;
		}
	}

	MUSIC_TIME ClocksPerMeasure()
	{ 
		return ClocksPerBeat() * m_bBeatsPerMeasure;
	}

	MUSIC_TIME ClocksToMeasure(DWORD dwTotalClocks)
	{ 
		MUSIC_TIME mtCPM = ClocksPerMeasure();
		if (mtCPM)
		{
			return (dwTotalClocks / mtCPM);
		}
		else
		{
			return 0;
		}
	}

	MUSIC_TIME ClocksToBeat(DWORD dwTotalClocks)
	{
		MUSIC_TIME mtCPB = ClocksPerBeat();
		if (mtCPB)
		{
			return dwTotalClocks / mtCPB;
		}
		else
		{
			return 0;
		}
	}

	MUSIC_TIME MeasureAndBeatToClocks(WORD wMeasure, BYTE bBeat)
	{ 
		return ClocksPerMeasure() * wMeasure + (ClocksPerBeat() * bBeat);
	}

	MUSIC_TIME GridToClocks(WORD wGrid)
	{
		if (m_wGridsPerBeat)
		{
			return (ClocksPerBeat() * (wGrid / m_wGridsPerBeat)) + (ClocksPerGrid() * (wGrid % m_wGridsPerBeat));
		}
		else
		{
			return ClocksPerGrid() * wGrid;
		}
	}

	BYTE	m_bBeatsPerMeasure;		// beats per measure (top of time sig)
	BYTE	m_bBeat;				// what note receives the beat (bottom of time sig.)
									// we can assume that 0 means 256th note
	WORD	m_wGridsPerBeat;		// grids per beat
};

// Convert old clocks to new clocks
template <class T>
inline T ConvertTime(T oldTime)
{ return (T)((DMUS_PPQ / PPQN) * oldTime); }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\validp.h ===
// Copyright (c) 1998 Microsoft Corporation
// ValidP.h --- An inline function to test for valid pointers

#ifndef __VALID_P__
#define __VALID_P__

// The debug version checks for Null pointers and pointers to unreadable/unwriteable data.
// (NOTE: only the first byte pointed to is checked)
// The non-debug version just checks for Null pointers.

template <class T>
inline BOOL Validate(T *p)
{ 
#ifdef _DEBUG
	return (p != NULL) && !IsBadReadPtr(p, 1) && !IsBadWritePtr(p, 1);
#else
	return p != NULL;
#endif
}

/* Use:

  Foo *pFoo;
  //
  // stuff...
  //
  if (Validate(pFoo))
  {
     // do stuff with the pointer
  }
  else
  {
     // don't do stuff with the pointer
  }

*/

#endif // __VALID_P__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\trackhelp.cpp ===
//
// Copyright (c) 1999-2001 Microsoft Corporation. All rights reserved.
//
// Base classes that implement aspects of a standard DirectMusic track.
// Implementations for CBasicTrack.
//

#include "trackhelp.h"
#include "validate.h"

//////////////////////////////////////////////////////////////////////
// Creation

CBasicTrack::CBasicTrack(long *plModuleLockCounter, const CLSID &rclsid)
  : m_cRef(0),
    m_plModuleLockCounter(plModuleLockCounter),
    m_rclsid(rclsid)
{
    InitializeCriticalSection(&m_CriticalSection);
    // Note: on pre-Blackcomb OS's, this call can raise an exception; if it
    // ever pops in stress, we can add an exception handler and retry loop.
    InterlockedIncrement(plModuleLockCounter);
}

//////////////////////////////////////////////////////////////////////
// IUnknown

STDMETHODIMP 
CBasicTrack::QueryInterface(const IID &iid, void **ppv)
{
    V_INAME(CBasicTrack::QueryInterface);
    V_PTRPTR_WRITE(ppv);
    V_REFGUID(iid);

    if (iid == IID_IUnknown || iid == IID_IDirectMusicTrack || iid == IID_IDirectMusicTrack8)
        *ppv = static_cast<IDirectMusicTrack8*>(this);
    else if (iid == IID_IPersistStream)
        *ppv = static_cast<IPersistStream*>(this);
    else if (iid == IID_IPersist)
        *ppv = static_cast<IPersist*>(this);
    else
    {
        *ppv = NULL;
        Trace(4,"Warning: Request to query unknown interface on Track\n");
        return E_NOINTERFACE;
    }
    
    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG)
CBasicTrack::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG)
CBasicTrack::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        DeleteCriticalSection(&m_CriticalSection);
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// IUnknown

STDMETHODIMP
CBasicTrack::GetClassID(CLSID* pClassID)
{
    V_INAME(CBasicTrack::GetClassID);
    V_PTR_WRITE(pClassID, sizeof(pClassID));
    *pClassID = m_rclsid;
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicTrack

STDMETHODIMP
CBasicTrack::Init(IDirectMusicSegment *pSegment)
{
    V_INAME(CBasicTrack::Init);
    V_INTERFACE(pSegment);
    return S_OK;
}

STDMETHODIMP
CBasicTrack::Play(
        void *pStateData,
        MUSIC_TIME mtStart,
        MUSIC_TIME mtEnd,
        MUSIC_TIME mtOffset,
        DWORD dwFlags,
        IDirectMusicPerformance* pPerf,
        IDirectMusicSegmentState* pSegSt,
        DWORD dwVirtualID)
{
    return this->PlayMusicOrClock(
                    pStateData,
                    mtStart,
                    mtEnd,
                    mtOffset,
                    0,
                    dwFlags,
                    pPerf,
                    pSegSt,
                    dwVirtualID,
                    false);
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicTrack8

STDMETHODIMP CBasicTrack::PlayEx(
        void* pStateData,
        REFERENCE_TIME rtStart,
        REFERENCE_TIME rtEnd,
        REFERENCE_TIME rtOffset,
        DWORD dwFlags,
        IDirectMusicPerformance* pPerf,
        IDirectMusicSegmentState* pSegSt,
        DWORD dwVirtualID)
{
    if (dwFlags & DMUS_TRACKF_CLOCK)
    {
        // Convert all reference times to millisecond times and then just use them as if this were MUSIC_TIME.
        return this->PlayMusicOrClock(
                    pStateData,
                    static_cast<MUSIC_TIME>(rtStart / gc_RefPerMil),
                    static_cast<MUSIC_TIME>(rtEnd / gc_RefPerMil),
                    static_cast<MUSIC_TIME>(rtOffset / gc_RefPerMil),
                    rtOffset,
                    dwFlags,
                    pPerf,
                    pSegSt,
                    dwVirtualID,
                    true);
    }
    else
    {
        return this->PlayMusicOrClock(
                    pStateData,
                    static_cast<MUSIC_TIME>(rtStart),
                    static_cast<MUSIC_TIME>(rtEnd),
                    static_cast<MUSIC_TIME>(rtOffset),
                    0,
                    dwFlags,
                    pPerf,
                    pSegSt,
                    dwVirtualID,
                    false);
    }
}

STDMETHODIMP CBasicTrack::GetParamEx(
        REFGUID rguidType,
        REFERENCE_TIME rtTime,
        REFERENCE_TIME* prtNext,
        void* pParam,
        void * pStateData,
        DWORD dwFlags)
{
    HRESULT hr;
    MUSIC_TIME mtNext;
    if (dwFlags & DMUS_TRACK_PARAMF_CLOCK)
    {
        hr = GetParam(rguidType, static_cast<MUSIC_TIME>(rtTime / gc_RefPerMil), &mtNext, pParam);
        if (prtNext)
        {
            *prtNext = mtNext * gc_RefPerMil;
        }
    }
    else
    {
        hr = GetParam(rguidType, static_cast<MUSIC_TIME>(rtTime), &mtNext, pParam);
        if (prtNext)
        {
            *prtNext = mtNext;
        }
    }
    return hr;
}

STDMETHODIMP CBasicTrack::SetParamEx(
        REFGUID rguidType,
        REFERENCE_TIME rtTime,
        void* pParam, void * pStateData, DWORD dwFlags) 
{
    if (dwFlags & DMUS_TRACK_PARAMF_CLOCK)
    {
        rtTime /= gc_RefPerMil;
    }
    return SetParam(rguidType, static_cast<MUSIC_TIME>(rtTime ), pParam);
}

STDMETHODIMP CBasicTrack::Compose(
        IUnknown* pContext, 
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack) 
{
    return E_NOTIMPL;
}

STDMETHODIMP CBasicTrack::Join(
        IDirectMusicTrack* pNewTrack,
        MUSIC_TIME mtJoin,
        IUnknown* pContext,
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack) 
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\tlist.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1998 Microsoft Corporation
//
//  File:       tlist.h
//
//--------------------------------------------------------------------------

//
// tlist.h --- template version of AList
//
#ifndef __TLIST_H__
#define __TLIST_H__

//#include "stdafx.h"

//template <class T>
//typedef BOOL (* TRelation) (T, T);

// TListItem<> contains four more members than AListItem: one additional constructor,
// a destructor, one member function, and one data member.
template <class T>
class TListItem
{
public:
    TListItem() { m_pNext=NULL; };
    ~TListItem();												// new destructor
	static void Delete(TListItem<T>* pFirst);                           // new deletion helper
    TListItem(const T& item) { m_Tinfo = item; m_pNext=NULL; };	// additional constructor.
    TListItem<T> *GetNext() const {return m_pNext;};
    void SetNext(TListItem<T> *pNext) {m_pNext=pNext;};
    LONG GetCount() const;
    TListItem<T>* Cat(TListItem<T>* pItem);
    TListItem<T>* AddTail(TListItem<T>* pItem) {return Cat(pItem);};
    TListItem<T>* Remove(TListItem<T>* pItem);
    TListItem<T>* GetPrev(TListItem<T> *pItem) const;
    TListItem<T>* GetItem(LONG index);
    T& GetItemValue() { return m_Tinfo; }  // additional member function
	TListItem<T>* MergeSort(BOOL (* fcnCompare) (T&, T&)); // Destructively mergeSorts the list items 
private:
	void Divide(TListItem<T>* &pHalf1, TListItem<T>* &pHalf2);
	TListItem<T>* Merge(TListItem<T>* pOtherList, BOOL (* fcnCompare) (T&, T&));
	T m_Tinfo;  // additional data member, but memory is the same since in AListItem 
				// you put the extra data member in the derived class 
    TListItem<T> *m_pNext;
};

// TList<> adds a destructor to AList.
template <class T>
class TList
{
public:
    TList() {m_pHead=NULL;}
	~TList()
	{ 
		//if (m_pHead != NULL) delete m_pHead;
		TListItem<T>::Delete(m_pHead);
	} // new destructor
    TListItem<T> *GetHead() const { return m_pHead;};

    void RemoveAll() { m_pHead=NULL;};
    void CleanUp() 
	{ 
		//if (m_pHead) delete m_pHead;
		if (m_pHead) TListItem<T>::Delete(m_pHead);
		m_pHead=NULL;
	}
    LONG GetCount() const {return m_pHead->GetCount();}; 
    TListItem<T> *GetItem(LONG index) { return m_pHead->GetItem(index);}; 
    void InsertBefore(TListItem<T> *pItem,TListItem<T> *pInsert);
    void Cat(TListItem<T> *pItem) {m_pHead=m_pHead->Cat(pItem);};
    void Cat(TList<T> *pList)
        {
//            assert(pList!=NULL);
            m_pHead=m_pHead->Cat(pList->GetHead());
        };
    void AddHead(TListItem<T> *pItem)
        {
//            assert(pItem!=NULL);
            pItem->SetNext(m_pHead);
            m_pHead=pItem;
        }
    void AddTail(TListItem<T> *pItem);// {m_pHead=m_pHead->AddTail(pItem);};
    void Remove(TListItem<T> *pItem) {m_pHead=m_pHead->Remove(pItem);};
    TListItem<T> *GetPrev(TListItem<T> *pItem) const {return m_pHead->GetPrev(pItem);};
    TListItem<T> *GetTail() const {return GetPrev(NULL);};
    BOOL IsEmpty(void) const {return (m_pHead==NULL);};
    TListItem<T> *RemoveHead(void)
        {
            TListItem<T> *li;
            li=m_pHead;
            if(m_pHead)
			{
                m_pHead=m_pHead->GetNext();
				li->SetNext(NULL);
			}
            return li;
        }
	void MergeSort(BOOL (* fcnCompare) (T&, T&)); // Destructively mergeSorts the list
	void Reverse(void); // Reverses the entire list
	HRESULT Copy(TList<T>& rList); // Copies one list to another

protected:
    TListItem<T> *m_pHead;
};

#include "tlist.cpp"

#endif // __TLIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\trklist.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
//////////////////////////////////////////////////////////////////////
// TrkList.h

#include "alist.h"
#include "dmusici.h"
#include "debug.h"
#define ASSERT	assert

#ifndef __TRACKLIST_H_
#define __TRACKLIST_H_

#define TRACKINTERNAL_START_PADDED 0x1
#define TRACKINTERNAL_END_PADDED 0x2

class CSegment;

class CTrack : public AListItem
{
public:
	CTrack();
	~CTrack();
	CTrack* GetNext()
	{
		return (CTrack*)AListItem::GetNext();
	};
    bool Less(CTrack* pCTrack)
    {
        // Give the sysex track priority over any other track at the same position,
        // and the band track priority over any track but the sysex track. 
        return
            ( m_dwPosition < pCTrack->m_dwPosition ||
              (m_dwPosition == pCTrack->m_dwPosition && 
               m_guidClassID == CLSID_DirectMusicSysExTrack) ||
              (m_dwPosition == pCTrack->m_dwPosition && 
               m_guidClassID == CLSID_DirectMusicBandTrack &&
               pCTrack->m_guidClassID != CLSID_DirectMusicSysExTrack) );
    }
public:
    CLSID               m_guidClassID;  // Class ID of track.
	IDirectMusicTrack*	m_pTrack;       // Standard track interface.
    IDirectMusicTrack8* m_pTrack8;      // Extra DX8 functions.
    void*				m_pTrackState; // state pointer returned by IDirectMusicTrack::InitPerformance
	BOOL				m_bDone;
	DWORD				m_dwVirtualID; // only valid inside segment states
	DWORD				m_dwGroupBits;
    DWORD               m_dwPriority;  // Track priority, to order the composition process.
    DWORD               m_dwPosition;  // Track position, to determine the Play order.
    DWORD               m_dwFlags;     // DMUS_TRACKCONFIG_ flags. 
    DWORD               m_dwInternalFlags;     // TRACKINTERNAL_ flags. 
};

class CTrackList : public AList
{
public:
    CTrack* GetHead() 
	{
		return (CTrack*)AList::GetHead();
	};
    CTrack* RemoveHead() 
	{
		return (CTrack*)AList::RemoveHead();
	};
    CTrack* GetItem(LONG lIndex) 
	{
		return (CTrack*) AList::GetItem(lIndex);
	};
	void Clear(void)
	{
		CTrack* pTrack;
		while( pTrack = RemoveHead() )
		{
			delete pTrack;
		}
	}
	HRESULT CreateCopyWithBlankState(CTrackList* pTrackList);
};

#endif // __TRACKLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\trackhelp.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Base classes that implement aspects of a standard DirectMusic track.
// Unless you're doing something pretty unusual, you should be able to inherit from one
//    of these classes and reduce the work needed to implement a new track type.
//
// * CBasicTrack
//    Contains stubs that no-op or return notimpl most track methods.
//    You implement Load, InitPlay, EndPlay, PlayMusicOrClock, and Clone.
//
// * CPlayingTrack
//    CBasicTrack plus standard implementations of InitPlay, EndPlay, Clone.
//    PlayMusicOrClock and Load are partially implemented.  You fill in the rest by implementing
//       the methods PlayItem and LoadRiff.
//    You also must implement classes for event items and (optionally) state data.

#pragma once

#include "dmusici.h"
#include "validate.h"
#include "miscutil.h"
#include "tlist.h"
#include "smartref.h"


const int gc_RefPerMil = 10000; // Value for converting from reference time to milliseconds


//////////////////////////////////////////////////////////////////////
// TrackHelpCreateInstance
// Standard implementation of CreateInstance to call from class factory templated on
// the type of your derived class.  Your class constructor must take an HRESULT pointer
// it can use to return an error.

template <class T>
HRESULT TrackHelpCreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv, T *pUnused = NULL)
{
	// 
	// pUnused is just a dummy to force generation of the correct template type T.
	// Compiler bug?

	*ppv = NULL;
	if (pUnknownOuter)
		 return CLASS_E_NOAGGREGATION;

	HRESULT hr = S_OK;
	T *pInst = new T(&hr);
	if (pInst == NULL)
		return E_OUTOFMEMORY;
	if (FAILED(hr))
		return hr;

	return pInst->QueryInterface(iid, ppv);
}

//////////////////////////////////////////////////////////////////////
// CBasicTrack
//
// Base class with a standard implementation the following aspects of a DirectMusic track:
// - IUnknown: AddRef, Release, and QueryInterface (QI for IUnknown, IDirectMusicTrack, IDirectMusicTrack8, IPersistStream, IPersist)
// - IPersistStrea: stubs out GetClassID, IsDirty, Save, and GetSizeMax.
// - IDirectMusicTrack:
//      stubs out IsParamSupported, Init, GetParam, SetParam, AddNotificationType, RemoveNotificationType.
//      implements millisecond time conversion for PlayEx, GetParamEx, SetParamEx.
// - Declares and initializes a critical section.
//
// Pure virtual functions you must implement:
// - Load
// - InitPlay
// - EndPlay
// - Clone
// - PlayMusicOrClock (single method called by both Play and PlayEx)

class CBasicTrack
  : public IPersistStream,
	public IDirectMusicTrack8
{
public:
	// IUnknown
	STDMETHOD(QueryInterface)(const IID &iid, void **ppv);
	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();

	// IPersistStream functions
	STDMETHOD(GetClassID)(CLSID* pClassID);
	STDMETHOD(IsDirty)() {return S_FALSE;}
	STDMETHOD(Load)(IStream* pStream) = 0;
	STDMETHOD(Save)(IStream* pStream, BOOL fClearDirty) {return E_NOTIMPL;}
	STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pcbSize) {return E_NOTIMPL;}

	// IDirectMusicTrack methods
	STDMETHOD(IsParamSupported)(REFGUID rguid) {return DMUS_E_TYPE_UNSUPPORTED;}
	STDMETHOD(Init)(IDirectMusicSegment *pSegment);
	STDMETHOD(InitPlay)(
		IDirectMusicSegmentState *pSegmentState,
		IDirectMusicPerformance *pPerformance,
		void **ppStateData,
		DWORD dwTrackID,
		DWORD dwFlags) = 0;
	STDMETHOD(EndPlay)(void *pStateData) = 0;
	STDMETHOD(Play)(
		void *pStateData,
		MUSIC_TIME mtStart,
		MUSIC_TIME mtEnd,
		MUSIC_TIME mtOffset,
		DWORD dwFlags,
		IDirectMusicPerformance* pPerf,
		IDirectMusicSegmentState* pSegSt,
		DWORD dwVirtualID);
	STDMETHOD(GetParam)(REFGUID rguid,MUSIC_TIME mtTime,MUSIC_TIME* pmtNext,void *pData) {return DMUS_E_GET_UNSUPPORTED;}
	STDMETHOD(SetParam)(REFGUID rguid,MUSIC_TIME mtTime,void *pData) {return DMUS_E_SET_UNSUPPORTED;}
	STDMETHOD(AddNotificationType)(REFGUID rguidNotification) {return E_NOTIMPL;}
	STDMETHOD(RemoveNotificationType)(REFGUID rguidNotification) {return E_NOTIMPL;}
	STDMETHOD(Clone)(MUSIC_TIME mtStart,MUSIC_TIME mtEnd,IDirectMusicTrack** ppTrack) = 0;

	// IDirectMusicTrack8
	STDMETHODIMP PlayEx(
		void* pStateData,
		REFERENCE_TIME rtStart,
		REFERENCE_TIME rtEnd,
		REFERENCE_TIME rtOffset,
		DWORD dwFlags,
		IDirectMusicPerformance* pPerf,
		IDirectMusicSegmentState* pSegSt,
		DWORD dwVirtualID);
	STDMETHODIMP GetParamEx(REFGUID rguidType, REFERENCE_TIME rtTime, REFERENCE_TIME* prtNext, void* pParam, void * pStateData, DWORD dwFlags);
    STDMETHODIMP SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,void* pParam, void * pStateData, DWORD dwFlags) ;
    STDMETHODIMP Compose(IUnknown* pContext, 
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;
    STDMETHODIMP Join(IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		IUnknown* pContext,
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;

protected:
	// plModuleLockCounter: a pointer to your .dll's lock counter that will be incremented/decremented when the track is created/destroyed
	// rclsid: the classid of your track
	CBasicTrack(long *plModuleLockCounter, const CLSID &rclsid); // Takes pointer to lock counter to increment and decrement on component creation/destruction.  Typically, pass &g_cComponent and the clsid of your track.
	virtual ~CBasicTrack() { InterlockedDecrement(m_plModuleLockCounter); }

	// Shared implentation of play for either music or clock time.
	virtual HRESULT PlayMusicOrClock(
		void *pStateData,
		MUSIC_TIME mtStart,
		MUSIC_TIME mtEnd,
		MUSIC_TIME mtOffset,
		REFERENCE_TIME rtOffset,
		DWORD dwFlags,
		IDirectMusicPerformance* pPerf,
		IDirectMusicSegmentState* pSegSt,
		DWORD dwVirtualID,
		bool fClockTime) = 0;

	// Use this critical section to guard entry points for thread safety
	CRITICAL_SECTION m_CriticalSection;

private:
	long m_cRef;
	long *m_plModuleLockCounter;
	const CLSID &m_rclsid;
};

//////////////////////////////////////////////////////////////////////
// CPlayingTrack
//
// Base class that provides standard implementations of InitPlay, EndPlay, and Clone.
// Also, partially implemented are:
//  - PlayMusicOrClock.  You must implement the pure virual function PlayItem, which is
//    called during play as each event needs to be performed.
//  - Load.  This just does a few standard things (clearing the event list, incrementing the
//    state data counter, optionally getting the loader, and sorting the results).  It
//    depends on your implementation of the pure virtual function LoadRiff that you must
//    implement to do the real processing.
// Template types required:
//    T: Your derived class (needed for New in clone).  Must have a constructor that takes a pointer to an HRESULT.
//    StateData: Type for your state data.  Must contain dwValidate, used to check if the track has been reloaded, and pCurrentEvent, a pointer to the next event item to be played.
//    EventItem: Type for the event items in your track.  Must contain lTriggerTime, which is the time during Play when PlayItem will be called.  Must implement Clone, which copies another EventItem, shifting it back according to a start MUSIC_TIME.

// Standard state data for use with CPlayingTrack.  Or inherit from it and add more information.
template<class EventItem>
struct CStandardStateData
{
	CStandardStateData() : dwValidate(0), pCurrentEvent(NULL) {}
	DWORD dwValidate;
	TListItem<EventItem> *pCurrentEvent;
};

template<class T, class EventItem, class StateData = CStandardStateData<EventItem> >
class CPlayingTrack
  : public CBasicTrack
{
public:
	typedef StateData statedata;

	STDMETHOD(Load)(IStream* pIStream);
	STDMETHOD(InitPlay)(
		IDirectMusicSegmentState *pSegmentState,
		IDirectMusicPerformance *pPerformance,
		void **ppStateData,
		DWORD dwTrackID,
		DWORD dwFlags);
	STDMETHOD(EndPlay)(void *pStateData);
	STDMETHOD(Clone)(MUSIC_TIME mtStart,MUSIC_TIME mtEnd,IDirectMusicTrack** ppTrack);
	virtual HRESULT PlayMusicOrClock(
		void *pStateData,
		MUSIC_TIME mtStart,
		MUSIC_TIME mtEnd,
		MUSIC_TIME mtOffset,
		REFERENCE_TIME rtOffset,
		DWORD dwFlags,
		IDirectMusicPerformance* pPerf,
		IDirectMusicSegmentState* pSegSt,
		DWORD dwVirtualID,
		bool fClockTime);

protected:
	// plModuleLockCounter: a pointer to your .dll's lock counter that will be incremented/decremented when the track is created/destroyed
	// rclsid: the classid of your track
	// fNeedsLoader: pass true if you will need a reference to the loader when your LoadRiff method is called
	// fPlayInvalidations: if true, then your items will be played more than once when an invalidation occurs
	//						pass false if your track doesn't want to respond to invalidations
	CPlayingTrack(long *plModuleLockCounter, const CLSID &rclsid, bool fNeedsLoader, bool fPlayInvalidations);

	virtual HRESULT PlayItem(
		const EventItem &item,
		StateData &state,
		IDirectMusicPerformance *pPerf,
		IDirectMusicSegmentState* pSegSt,
		DWORD dwVirtualID,
		MUSIC_TIME mtOffset,
		REFERENCE_TIME rtOffset,
		bool fClockTime) = 0; // feel free to add additional parameters if you need to pass more information from Play
	virtual HRESULT LoadRiff(SmartRef::RiffIter &ri, IDirectMusicLoader *pIDMLoader) = 0; // note that pIDMLoader will be null unless true is passed for fNeedsLoader in constructor

	virtual TListItem<EventItem> *Seek(MUSIC_TIME mtStart); // this method is provided in case you want to inherit and intercept when a seek is happening

	// Increment this counter in Load, causing the state data to synchonize with the new events
	DWORD m_dwValidate;
	TList<EventItem> m_EventList;
	bool m_fNeedsLoader;
	bool m_fPlayInvalidations;
};

#include "trackhelp.inl"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\tsigtrk.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
// TSigTrk.h : Declaration of the CTimeSigTrack

#ifndef __TSIGTRK_H_
#define __TSIGTRK_H_

#include "dmusici.h"
#include "dmusicf.h"
#include "alist.h"

class CRiffParser;

class CTimeSigItem : public AListItem
{
public:
    CTimeSigItem();
    CTimeSigItem* GetNext(){ return (CTimeSigItem*)AListItem::GetNext(); };
    DMUS_IO_TIMESIGNATURE_ITEM  m_TimeSig;
};

   
class CTimeSigList : public AList
{
public:
    CTimeSigItem* GetHead() {return (CTimeSigItem*)AList::GetHead();};
    CTimeSigItem* RemoveHead() {return (CTimeSigItem*)AList::RemoveHead();};
    CTimeSigItem* GetItem(LONG lIndex) { return (CTimeSigItem*) AList::GetItem(lIndex);};
};

class CTimeSigStateData
{
public:
    CTimeSigStateData()
	{
		m_mtPrevEnd = 0;
		m_bBeat = 4;
		m_bBeatsPerMeasure = 4;
		m_mtTimeSig = 0;
        m_fActive = TRUE;
		/* don't need these since they are always initialized
		m_pPerformance = NULL;
		m_pSegState = NULL;
		m_dwVirtualTrackID = 0;
		*/
	}
    CTimeSigItem *	            m_pCurrentTSig;
	IDirectMusicPerformance*	m_pPerformance;
	IDirectMusicSegmentState*	m_pSegState;
	DWORD						m_dwVirtualTrackID;
	DWORD						m_dwValidate; // used to validate state data
	MUSIC_TIME					m_mtPrevEnd;
	MUSIC_TIME					m_mtTimeSig; // previous time sig time
    BOOL                        m_fActive;
    BYTE						m_bBeat; // previous beat
	BYTE						m_bBeatsPerMeasure; // previous beats per measure
};

/////////////////////////////////////////////////////////////////////////////
// CTimeSigTrack
class CTimeSigTrack : 
	public IPersistStream,
	public IDirectMusicTrack
{
public:
	CTimeSigTrack();
	CTimeSigTrack(CTimeSigTrack *pTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd);
	~CTimeSigTrack();

// member variables
protected:
	CTimeSigList	    m_TSigEventList;
	long		        m_cRef;
	DWORD		        m_dwValidate; // used to validate state data.
	CRITICAL_SECTION	m_CrSec;
    BOOL                m_fCSInitialized;
	BOOL		        m_fNotificationMeasureBeat;
	BOOL		        m_fActive;              // Track is active for generating time signatures
    BOOL                m_fStateSetBySetParam;  // If TRUE, active flag was set by GUID. Don't override. 

public:
// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

// IDirectMusicTrack methods
    STDMETHODIMP IsParamSupported(REFGUID rguid);
    STDMETHODIMP Init(IDirectMusicSegment *pSegment);
    STDMETHODIMP InitPlay(IDirectMusicSegmentState *pSegmentState,
                IDirectMusicPerformance *pPerformance,
                void **ppStateData,
                DWORD dwTrackID,
                DWORD dwFlags);
    STDMETHODIMP EndPlay(void *pStateData);
    STDMETHODIMP Play(void *pStateData,MUSIC_TIME mtStart,
                MUSIC_TIME mtEnd,MUSIC_TIME mtOffset,
		        DWORD dwFlags,IDirectMusicPerformance* pPerf,
		        IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID);
    STDMETHODIMP GetParam(REFGUID rguid,MUSIC_TIME mtTime,MUSIC_TIME* pmtNext,void *pData);
    STDMETHODIMP SetParam(REFGUID rguid,MUSIC_TIME mtTime,void *pData);
    STDMETHODIMP AddNotificationType(REFGUID rguidNotification);
    STDMETHODIMP RemoveNotificationType(REFGUID rguidNotification);
    STDMETHODIMP Clone(MUSIC_TIME mtStart,MUSIC_TIME mtEnd,IDirectMusicTrack** ppTrack);

// IPersist functions
    STDMETHODIMP GetClassID( CLSID* pClsId );
// IPersistStream functions
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load( IStream* pIStream );
    STDMETHODIMP Save( IStream* pIStream, BOOL fClearDirty );
    STDMETHODIMP GetSizeMax( ULARGE_INTEGER FAR* pcbSize );
protected:
	HRESULT STDMETHODCALLTYPE Seek( void *pStateData,MUSIC_TIME mtTime,BOOL fGetPrevious);
	void Construct(void);
    void Clear();
    HRESULT LoadTimeSigList( CRiffParser *pParser, long lChunkSize );
protected:
	MUSIC_TIME NotificationMeasureBeat( MUSIC_TIME mtStart, MUSIC_TIME mtEnd,
			CTimeSigStateData* pSD, MUSIC_TIME mtOffset );
};

#endif //__TSIGTRK_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\tsigtrk.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)
// TimeSigTrk.cpp : Implementation of CTimeSigTrack

#include "dmime.h"
#include "TSigTrk.h"
#include "dmusici.h"
#include "dmusicf.h"
#include "debug.h"
#include "dmstrm.h"
#include "Validate.h"
#include "debug.h"
#define ASSERT	assert

CTimeSigItem::CTimeSigItem()

{ 
    m_TimeSig.lTime = 0;
    m_TimeSig.bBeatsPerMeasure = 0; 
    m_TimeSig.bBeat = 0;
    m_TimeSig.wGridsPerBeat = 0;
}

/////////////////////////////////////////////////////////////////////////////
// CTimeSigTrack

void CTimeSigTrack::Construct()
{
	InterlockedIncrement(&g_cComponent);

	m_cRef = 1;
    m_fCSInitialized = FALSE;
	InitializeCriticalSection(&m_CrSec);
    m_fCSInitialized = TRUE;
	m_dwValidate = 0;
	m_fNotificationMeasureBeat = FALSE;
}

CTimeSigTrack::CTimeSigTrack()
{
	Construct();
	m_fActive = TRUE;
    m_fStateSetBySetParam = FALSE;
}

CTimeSigTrack::CTimeSigTrack(
		CTimeSigTrack *pSourceTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd)
{
	Construct();
	m_fActive = pSourceTrack->m_fActive;
    m_fStateSetBySetParam = pSourceTrack->m_fStateSetBySetParam;
    // Clone the time signature list.
	CTimeSigItem* pScan = pSourceTrack->m_TSigEventList.GetHead();
	CTimeSigItem* pPrevious = NULL;
	for(; pScan; pScan = pScan->GetNext())
	{
		if (pScan->m_TimeSig.lTime < mtStart)
		{
			pPrevious = pScan;
		}
		else if (pScan->m_TimeSig.lTime < mtEnd)
		{
			if (pScan->m_TimeSig.lTime == mtStart)
			{
				pPrevious = NULL;
			}
			CTimeSigItem* pNew = new CTimeSigItem;
			if (pNew)
			{
				pNew->m_TimeSig = pScan->m_TimeSig;
				pNew->m_TimeSig.lTime = pScan->m_TimeSig.lTime - mtStart;
				m_TSigEventList.AddHead(pNew); // instead of AddTail, which is n^2. We reverse below.
			}
		}
		else break;
	}
	m_TSigEventList.Reverse(); // Now, put list in order.
    // Then, install the time signature that precedes the clone.
	if (pPrevious)
	{
		CTimeSigItem* pNew = new CTimeSigItem;
		if (pNew)
		{
			pNew->m_TimeSig = pPrevious->m_TimeSig;
			pNew->m_TimeSig.lTime = 0;
			m_TSigEventList.AddHead(pNew);
		}
	}
}

void CTimeSigTrack::Clear()

{
    CTimeSigItem* pItem;
	while( pItem = m_TSigEventList.RemoveHead() )
	{
		delete pItem;
	}
}

CTimeSigTrack::~CTimeSigTrack()
{
    Clear();
    if (m_fCSInitialized)
    {
	    DeleteCriticalSection(&m_CrSec);
    }
	InterlockedDecrement(&g_cComponent);
}

// @method:(EXTERNAL) HRESULT | IDirectMusicTimeSigTrack | QueryInterface | Standard QueryInterface implementation for <i IDirectMusicTimeSigTrack>
//
// @parm const IID & | iid | Interface to query for
// @parm void ** | ppv | The requested interface will be returned here
//
// @rdesc Returns one of the following:
//
// @flag S_OK | If the interface is supported and was returned
// @flag E_NOINTERFACE | If the object does not support the given interface.
//
// @mfunc:(INTERNAL)
//
//
STDMETHODIMP CTimeSigTrack::QueryInterface(
    const IID &iid,   // @parm Interface to query for
    void **ppv)       // @parm The requested interface will be returned here
{
	V_INAME(CTimeSigTrack::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

   if (iid == IID_IUnknown || iid == IID_IDirectMusicTrack)
    {
        *ppv = static_cast<IDirectMusicTrack*>(this);
    } else
	if (iid == IID_IPersistStream)
	{
        *ppv = static_cast<IPersistStream*>(this);
	} else
    {
        *ppv = NULL;
        Trace(4,"Warning: Request to query unknown interface on Time Signature Track\n");
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


// @method:(EXTERNAL) HRESULT | IDirectMusicTimeSigTrack | AddRef | Standard AddRef implementation for <i IDirectMusicTimeSigTrack>
//
// @rdesc Returns the new reference count for this object.
//
// @mfunc:(INTERNAL)
//
//
STDMETHODIMP_(ULONG) CTimeSigTrack::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


// @method:(EXTERNAL) HRESULT | IDirectMusicTimeSigTrack | Release | Standard Release implementation for <i IDirectMusicTimeSigTrack>
//
// @rdesc Returns the new reference count for this object.
//
// @mfunc:(INTERNAL)
//
//
STDMETHODIMP_(ULONG) CTimeSigTrack::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

/////////////////////////////////////////////////////////////////////////////
// IPersist

HRESULT CTimeSigTrack::GetClassID( CLSID* pClassID )
{
	V_INAME(CTimeSigTrack::GetClassID);
	V_PTR_WRITE(pClassID, CLSID); 
	*pClassID = CLSID_DirectMusicTimeSigTrack;
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IPersistStream functions

HRESULT CTimeSigTrack::IsDirty()
{
	return S_FALSE;
}

/*

  @method HRESULT | ITimeSigTrack | Load |
  Call this with an IStream filled with DMUS_IO_TIMESIGNATURE_ITEM's, sorted in time order.
  @parm IStream* | pIStream |
  A stream of DMUS_IO_TIMESIGNATURE_ITEM's, sorted in time order. The seek pointer should be
  set to the first event. The stream should only contain TimeSig events and
  nothing more.
  @rvalue E_INVALIDARG | If pIStream == NULL
  @rvalue S_OK
  @comm The <p pIStream> will be AddRef'd inside this function and held
  until the TimeSigTrack is released.
*/

HRESULT CTimeSigTrack::Load( IStream* pIStream )
{
	V_INAME(CTimeSigTrack::Load);
	V_INTERFACE(pIStream);

    CRiffParser Parser(pIStream);
	EnterCriticalSection(&m_CrSec);
	m_dwValidate++; // used to validate state data that's out there
    RIFFIO ckMain;

    HRESULT hr = S_OK;

    Parser.EnterList(&ckMain);  
    if (Parser.NextChunk(&hr))
    { 
 		if (ckMain.ckid == DMUS_FOURCC_TIMESIG_CHUNK)
        {
            hr = LoadTimeSigList(&Parser,ckMain.cksize);
        }
        else if ((ckMain.ckid == FOURCC_LIST) && 
            (ckMain.fccType == DMUS_FOURCC_TIMESIGTRACK_LIST))
        {
            Clear();
	        RIFFIO ckNext;    // Descends into the children chunks.
            Parser.EnterList(&ckNext);
            while (Parser.NextChunk(&hr))
            {
		        switch(ckNext.ckid)
		        {
                case DMUS_FOURCC_TIMESIG_CHUNK :
                    hr = LoadTimeSigList(&Parser,ckNext.cksize);
                    break;
                }    
            }
            Parser.LeaveList();
        }
        else
        {
            Trace(1,"Error: Failure reading bad data in time signature track.\n");
            hr = DMUS_E_CHUNKNOTFOUND;
        }
    }

	LeaveCriticalSection(&m_CrSec);
	return hr;
}


HRESULT CTimeSigTrack::LoadTimeSigList( CRiffParser *pParser, long lChunkSize )
{
	HRESULT hr;

	// copy contents of the stream into the list.
	DWORD dwSubSize;
	// read in the size of the data structures
	hr = pParser->Read( &dwSubSize, sizeof(DWORD));
    if (SUCCEEDED(hr))
    {
	    lChunkSize -= sizeof(DWORD);

	    DWORD dwRead, dwSeek;
	    if( dwSubSize > sizeof(DMUS_IO_TIMESIGNATURE_ITEM) )
	    {
		    dwRead = sizeof(DMUS_IO_TIMESIGNATURE_ITEM);
		    dwSeek = dwSubSize - dwRead;
	    }
	    else
	    {
		    dwRead = dwSubSize;
		    dwSeek = 0;
	    }
	    if( 0 == dwRead )
	    {
            Trace(1,"Error: Failure reading time signature track.\n");
		    hr = DMUS_E_CANNOTREAD;
	    }
        else
        {
	        while( lChunkSize > 0 )
	        {
                CTimeSigItem *pNew = new CTimeSigItem;
                if (pNew)
                {
		            if( FAILED( pParser->Read( &pNew->m_TimeSig, dwRead )))
		            {
                        delete pNew;
			            hr = DMUS_E_CANNOTREAD;
			            break;
		            }
				    // make sure this time sig is OK
				    if (!pNew->m_TimeSig.bBeatsPerMeasure)
				    {
					    Trace(1, "Warning: invalid content: DMUS_IO_TIMESIGNATURE_ITEM.bBeatsPerMeasure\n");
					    pNew->m_TimeSig.bBeatsPerMeasure = 4;
				    }
				    if (!pNew->m_TimeSig.bBeat)
				    {
					    Trace(1, "Warning: invalid content: DMUS_IO_TIMESIGNATURE_ITEM.bBeat\n");
					    pNew->m_TimeSig.bBeat = 4;
				    }
				    if (!pNew->m_TimeSig.wGridsPerBeat)
				    {
					    Trace(1, "Warning: invalid content: DMUS_IO_TIMESIGNATURE_ITEM.wGridsPerBeat\n");
					    pNew->m_TimeSig.wGridsPerBeat = 4;
				    }
                    m_TSigEventList.AddHead(pNew); 
		            lChunkSize -= dwRead;
		            if( dwSeek )
		            {
			            if( FAILED( pParser->Skip(dwSeek)))
			            {
				            hr = DMUS_E_CANNOTSEEK;
				            break;
			            }
			            lChunkSize -= dwSeek;
		            }
		        }
	        }
            m_TSigEventList.Reverse();
            // If there is no time signature at the start, make a copy of the 
            // first time signature and stick it there. This resolves a bug in 6.1 
            // where notification messages and GetParam() were inconsistent
            // in their behavior under this circumstance. This ensures they behave
            // the same.
            CTimeSigItem *pTop = m_TSigEventList.GetHead();
            if (pTop && (pTop->m_TimeSig.lTime > 0))
            {
                CTimeSigItem *pCopy = new CTimeSigItem;
                if (pCopy)
                {
                    *pCopy = *pTop;
                    pCopy->m_TimeSig.lTime = 0;
                    m_TSigEventList.AddHead(pCopy);
                }                
            }
        }
    }
	return hr;
}

HRESULT CTimeSigTrack::Save( IStream* pIStream, BOOL fClearDirty )
{
	return E_NOTIMPL;
}

HRESULT CTimeSigTrack::GetSizeMax( ULARGE_INTEGER FAR* pcbSize )
{
	return E_NOTIMPL;
}

// IDirectMusicTrack

HRESULT STDMETHODCALLTYPE CTimeSigTrack::IsParamSupported( 
    /* [in] */ REFGUID rguid)
{
	V_INAME(CTimeSigTrack::IsParamSupported);
	V_REFGUID(rguid);

    if (m_fStateSetBySetParam)
    {
	    if( m_fActive )
	    {
		    if( rguid == GUID_DisableTimeSig ) return S_OK;
		    if( rguid == GUID_TimeSignature ) return S_OK;
		    if( rguid == GUID_EnableTimeSig ) return DMUS_E_TYPE_DISABLED;
	    }
	    else
	    {
		    if( rguid == GUID_EnableTimeSig ) return S_OK;
		    if( rguid == GUID_DisableTimeSig ) return DMUS_E_TYPE_DISABLED;
		    if( rguid == GUID_TimeSignature ) return DMUS_E_TYPE_DISABLED;
	    }
    }
    else
    {
		if(( rguid == GUID_DisableTimeSig ) ||
		    ( rguid == GUID_TimeSignature ) ||
		    ( rguid == GUID_EnableTimeSig )) return S_OK;
    }
	return DMUS_E_TYPE_UNSUPPORTED;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicTrack::Init
HRESULT CTimeSigTrack::Init( 
    /* [in] */ IDirectMusicSegment *pSegment)
{
	return S_OK;
}

HRESULT CTimeSigTrack::InitPlay( 
    /* [in] */ IDirectMusicSegmentState *pSegmentState,
    /* [in] */ IDirectMusicPerformance *pPerformance,
    /* [out] */ void **ppStateData,
    /* [in] */ DWORD dwTrackID,
    /* [in] */ DWORD dwFlags)
{
	V_INAME(IDirectMusicTrack::InitPlay);
	V_PTRPTR_WRITE(ppStateData);
	V_INTERFACE(pSegmentState);
	V_INTERFACE(pPerformance);

    EnterCriticalSection(&m_CrSec);
	CTimeSigStateData* pStateData;
	pStateData = new CTimeSigStateData;
	if( NULL == pStateData )
		return E_OUTOFMEMORY;
	*ppStateData = pStateData;
    if (m_fStateSetBySetParam)
    {
        pStateData->m_fActive = m_fActive;
    }
    else
    {
        pStateData->m_fActive = !(dwFlags & (DMUS_SEGF_CONTROL | DMUS_SEGF_SECONDARY));
    }
	pStateData->m_dwVirtualTrackID = dwTrackID;
	pStateData->m_pPerformance = pPerformance; // weak reference, no addref.
	pStateData->m_pSegState = pSegmentState; // weak reference, no addref.
	pStateData->m_pCurrentTSig = m_TSigEventList.GetHead();
	pStateData->m_dwValidate = m_dwValidate;
    LeaveCriticalSection(&m_CrSec);
	return S_OK;
}

HRESULT CTimeSigTrack::EndPlay( 
    /* [in] */ void *pStateData)
{
	ASSERT( pStateData );
	if( pStateData )
	{
		V_INAME(CTimeSigTrack::EndPlay);
		V_BUFPTR_WRITE(pStateData, sizeof(CTimeSigStateData));
		CTimeSigStateData* pSD = (CTimeSigStateData*)pStateData;
		delete pSD;
	}
	return S_OK;
}

HRESULT CTimeSigTrack::Play( 
    /* [in] */ void *pStateData,
    /* [in] */ MUSIC_TIME mtStart,
    /* [in] */ MUSIC_TIME mtEnd,
    /* [in] */ MUSIC_TIME mtOffset,
	DWORD dwFlags,
	IDirectMusicPerformance* pPerf,
	IDirectMusicSegmentState* pSegSt,
	DWORD dwVirtualID
	)
{
	V_INAME(IDirectMusicTrack::Play);
	V_BUFPTR_WRITE( pStateData, sizeof(CTimeSigStateData));
	V_INTERFACE(pPerf);
	V_INTERFACE(pSegSt);

	EnterCriticalSection(&m_CrSec);
	HRESULT hr = S_OK;
	IDirectMusicGraph* pGraph = NULL;
	DMUS_TIMESIG_PMSG* pTimeSig;
	CTimeSigStateData* pSD = (CTimeSigStateData*)pStateData;
	MUSIC_TIME mtNotification = mtStart;
	BOOL fSeek = (dwFlags & DMUS_TRACKF_SEEK) ? TRUE : FALSE;

	// if mtStart is 0 and dwFlags contains DMUS_TRACKF_START, we want to be sure to
	// send out any negative time events. So, we'll set mtStart to -768.
	if( (mtStart == 0) && ( dwFlags & DMUS_TRACKF_START ))
	{
		mtStart = -768;
	}

	if( pSD->m_dwValidate != m_dwValidate )
	{
		pSD->m_dwValidate = m_dwValidate;
		pSD->m_pCurrentTSig = NULL;
	}
	// if the previous end time isn't the same as the current start time,
	// we need to seek to the right position.
	if( fSeek || ( pSD->m_mtPrevEnd != mtStart ))
	{
		if( dwFlags & (DMUS_TRACKF_START | DMUS_TRACKF_LOOP) )
		{
			Seek( pStateData, mtStart, TRUE );
		}
		else
		{
			Seek( pStateData, mtStart, FALSE );
		}
	}
	pSD->m_mtPrevEnd = mtEnd;

	if( NULL == pSD->m_pCurrentTSig )
	{
		pSD->m_pCurrentTSig = m_TSigEventList.GetHead();
	}

	if( FAILED( pSD->m_pSegState->QueryInterface( IID_IDirectMusicGraph,
		(void**)&pGraph )))
	{
		pGraph = NULL;
	}

	for( ; pSD->m_pCurrentTSig; pSD->m_pCurrentTSig = pSD->m_pCurrentTSig->GetNext() )
	{
		DMUS_IO_TIMESIGNATURE_ITEM *pItem = &pSD->m_pCurrentTSig->m_TimeSig;
		if( pItem->lTime >= mtEnd )
		{
			break;
		}
		if( (pItem->lTime < mtStart) && !fSeek )
		{
			break;
		}
		if( pSD->m_fActive && !(dwFlags & DMUS_TRACKF_PLAY_OFF) && SUCCEEDED( pSD->m_pPerformance->AllocPMsg( sizeof(DMUS_TIMESIG_PMSG),
			(DMUS_PMSG**)&pTimeSig )))
		{
			if( pItem->lTime < mtStart )
			{
				// this only happens in the case where we've puposefully seeked
				// and need to time stamp this event with the start time
				pTimeSig->mtTime = mtStart + mtOffset;
			}
			else
			{
				pTimeSig->mtTime = pItem->lTime + mtOffset;
			}
			pTimeSig->bBeatsPerMeasure = pItem->bBeatsPerMeasure;
			pTimeSig->bBeat = pItem->bBeat;
			pTimeSig->wGridsPerBeat = pItem->wGridsPerBeat;
			pTimeSig->dwFlags |= DMUS_PMSGF_MUSICTIME;
			pTimeSig->dwVirtualTrackID = pSD->m_dwVirtualTrackID;
			pTimeSig->dwType = DMUS_PMSGT_TIMESIG;
			pTimeSig->dwGroupID = 0xffffffff;

			if( pGraph )
			{
				pGraph->StampPMsg( (DMUS_PMSG*)pTimeSig );
			}
			TraceI(3, "TimeSigtrk: TimeSig event\n");
			if(FAILED(pSD->m_pPerformance->SendPMsg( (DMUS_PMSG*)pTimeSig )))
			{
				pSD->m_pPerformance->FreePMsg( (DMUS_PMSG*)pTimeSig );
			}
		}
		if( pSD->m_fActive && m_fNotificationMeasureBeat && !(dwFlags & DMUS_TRACKF_NOTIFY_OFF))
		{
			// create beat and measure notifications for up to this time
            if (mtNotification < pItem->lTime)
            {
			    mtNotification = NotificationMeasureBeat( mtNotification, pItem->lTime, pSD, mtOffset );
            }
        }
		// set the state data to the new beat and beats per measure, and time
		pSD->m_bBeat = pItem->bBeat;
		pSD->m_bBeatsPerMeasure = pItem->bBeatsPerMeasure;
		pSD->m_mtTimeSig = pItem->lTime;
	}
	if( pSD->m_fActive && m_fNotificationMeasureBeat && ( mtNotification < mtEnd ) 
        && !(dwFlags & DMUS_TRACKF_NOTIFY_OFF))
	{
		NotificationMeasureBeat( mtNotification, mtEnd, pSD, mtOffset );
	}
	if( pGraph )
	{
		pGraph->Release();
	}

	LeaveCriticalSection(&m_CrSec);
	return hr;
}

// seeks to the time sig. just before mtTime.
HRESULT CTimeSigTrack::Seek( 
    /* [in] */ void *pStateData,
    /* [in] */ MUSIC_TIME mtTime, BOOL fGetPrevious)
{
	CTimeSigStateData* pSD = (CTimeSigStateData*)pStateData;

	if( m_TSigEventList.IsEmpty() )
	{
		return S_FALSE;
	}
	if( NULL == pSD->m_pCurrentTSig )
	{
		pSD->m_pCurrentTSig = m_TSigEventList.GetHead();
	}
	// if the current event's time is on or past mtTime, we need to rewind to the beginning
	if( pSD->m_pCurrentTSig->m_TimeSig.lTime >= mtTime )
	{
		pSD->m_pCurrentTSig = m_TSigEventList.GetHead();
	}
	// now start seeking until we find an event with time on or past mtTime
	CTimeSigItem*	pTSig;
	for( pTSig = pSD->m_pCurrentTSig; pTSig ; pTSig = pTSig->GetNext() )
	{
		if( pTSig->m_TimeSig.lTime >= mtTime )
		{
			break;
		}
		pSD->m_pCurrentTSig = pTSig;
	}
	if( !fGetPrevious && pSD->m_pCurrentTSig )
	{
		pSD->m_pCurrentTSig = pSD->m_pCurrentTSig->GetNext();
	}
	return S_OK;
}

HRESULT CTimeSigTrack::GetParam( 
	REFGUID rguid,
    MUSIC_TIME mtTime,
	MUSIC_TIME* pmtNext,
    void *pData)
{
	V_INAME(CTimeSigTrack::GetParam);
	V_PTR_WRITE_OPT(pmtNext,MUSIC_TIME);
	V_REFGUID(rguid);

	HRESULT hr = DMUS_E_GET_UNSUPPORTED;
    EnterCriticalSection(&m_CrSec);
	if( NULL == pData )
	{
		hr = E_POINTER;
	}
	else if( GUID_TimeSignature == rguid )
	{
		if( !m_fActive )
		{
			hr = DMUS_E_TYPE_DISABLED;
		}
        else
        {
            DMUS_TIMESIGNATURE* pTSigData = (DMUS_TIMESIGNATURE*)pData;
		    CTimeSigItem* pScan = m_TSigEventList.GetHead();
		    CTimeSigItem* pPrevious = pScan;
		    if (pScan)
		    {
		        for (; pScan; pScan = pScan->GetNext())
		        {
			        if (pScan->m_TimeSig.lTime > mtTime)
			        {
				        break;
			        }
			        pPrevious = pScan;
		        }
		        pTSigData->mtTime = pPrevious->m_TimeSig.lTime - mtTime;
		        pTSigData->bBeatsPerMeasure = pPrevious->m_TimeSig.bBeatsPerMeasure;
		        pTSigData->bBeat = pPrevious->m_TimeSig.bBeat;
		        pTSigData->wGridsPerBeat = pPrevious->m_TimeSig.wGridsPerBeat;
		        if (pmtNext)
		        {
			        *pmtNext = 0;
		        }
		        if (pScan)
		        {
			        if (pmtNext)
			        {
				        *pmtNext = pScan->m_TimeSig.lTime - mtTime;
			        }
		        }
		        hr = S_OK;
            }
            else
            {
                hr = DMUS_E_NOT_FOUND;
		    }
        }
	}
    LeaveCriticalSection(&m_CrSec);
	return hr;
}

HRESULT CTimeSigTrack::SetParam( 
	REFGUID rguid,
    MUSIC_TIME mtTime,
    void *pData)
{
	V_INAME(CTimeSigTrack::SetParam);
	V_REFGUID(rguid);

	HRESULT hr = DMUS_E_SET_UNSUPPORTED;

	if( rguid == GUID_EnableTimeSig )
	{
        if (m_fStateSetBySetParam && m_fActive)
        {       // Already been enabled.
            hr = DMUS_E_TYPE_DISABLED;
        }
		else
        {
            m_fStateSetBySetParam = TRUE;
            m_fActive = TRUE;
		    hr = S_OK;
        }
	}
	else if( rguid == GUID_DisableTimeSig )
	{
        if (m_fStateSetBySetParam && !m_fActive)
        {       // Already been disabled.
            hr = DMUS_E_TYPE_DISABLED;
        }
		else
        {
            m_fStateSetBySetParam = TRUE;
            m_fActive = FALSE;
		    hr = S_OK;
        }
	}
	return hr;
}

HRESULT STDMETHODCALLTYPE CTimeSigTrack::AddNotificationType(
	/* [in] */  REFGUID rguidNotification)
{
	V_INAME(IDirectMusicTrack::AddNotificationType);
	V_REFGUID(rguidNotification);

	HRESULT hr = S_FALSE;

	if( rguidNotification == GUID_NOTIFICATION_MEASUREANDBEAT )
	{
		m_fNotificationMeasureBeat = TRUE;
		hr = S_OK;
	}
	return hr;
}

HRESULT STDMETHODCALLTYPE CTimeSigTrack::RemoveNotificationType(
	/* [in] */  REFGUID rguidNotification)
{
	V_INAME(IDirectMusicTrack::RemoveNotificationType);
	V_REFGUID(rguidNotification);

	HRESULT hr = S_FALSE;

	if( rguidNotification == GUID_NOTIFICATION_MEASUREANDBEAT )
	{
		m_fNotificationMeasureBeat = FALSE;
		hr = S_OK;
	}
	return hr;
}

// send measure and beat notifications
MUSIC_TIME CTimeSigTrack::NotificationMeasureBeat( MUSIC_TIME mtStart, MUSIC_TIME mtEnd,
	CTimeSigStateData* pSD, MUSIC_TIME mtOffset )
{
	DMUS_NOTIFICATION_PMSG* pEvent = NULL;
	MUSIC_TIME mtTime;
	DWORD dwMeasure;
	BYTE bCurrentBeat;

	if( pSD->m_mtTimeSig >= mtEnd )
		return mtStart;

	if( pSD->m_mtTimeSig > mtStart )
	{
		mtStart = pSD->m_mtTimeSig;
	}

	// now actually generate the beat events.
	// Generate events that are on beat boundaries, from mtStart to mtEnd
	long lQuantize = ( DMUS_PPQ * 4 ) / pSD->m_bBeat;

	mtTime = mtStart - pSD->m_mtTimeSig;
	if( mtTime ) // 0 stays 0
	{
		// quantize to next boundary
		mtTime = ((( mtTime - 1 ) / lQuantize ) + 1 ) * lQuantize;
	}
	mtStart += mtTime - ( mtStart - pSD->m_mtTimeSig );
	
	bCurrentBeat = (BYTE)(( ( mtStart - pSD->m_mtTimeSig ) / lQuantize ) % pSD->m_bBeatsPerMeasure);
	dwMeasure = mtStart / (pSD->m_bBeatsPerMeasure * lQuantize );
	while( mtStart < mtEnd )
	{
		if( SUCCEEDED( pSD->m_pPerformance->AllocPMsg( sizeof(DMUS_NOTIFICATION_PMSG), 
			(DMUS_PMSG**)&pEvent )))
		{
			pEvent->dwType = DMUS_PMSGT_NOTIFICATION;
			pEvent->mtTime = mtStart + mtOffset;
			pEvent->dwFlags = DMUS_PMSGF_MUSICTIME | DMUS_PMSGF_TOOL_ATTIME;
            pEvent->dwPChannel = 0;
			pSD->m_pSegState->QueryInterface(IID_IUnknown, (void**)&pEvent->punkUser);

			pEvent->dwNotificationOption = DMUS_NOTIFICATION_MEASUREBEAT;
			pEvent->dwField1 = bCurrentBeat;
			pEvent->dwField2 = dwMeasure;
			pEvent->guidNotificationType = GUID_NOTIFICATION_MEASUREANDBEAT;
			pEvent->dwGroupID = 0xffffffff;

			IDirectMusicGraph* pGraph;
			if( SUCCEEDED( pSD->m_pSegState->QueryInterface( IID_IDirectMusicGraph,
				(void**)&pGraph )))
			{
				pGraph->StampPMsg((DMUS_PMSG*) pEvent );
				pGraph->Release();
			}
			if(FAILED(pSD->m_pPerformance->SendPMsg((DMUS_PMSG*) pEvent )))
			{
				pSD->m_pPerformance->FreePMsg( (DMUS_PMSG*)pEvent );
			}
		}
		bCurrentBeat++;
		if( bCurrentBeat >= pSD->m_bBeatsPerMeasure )
		{
			bCurrentBeat = 0;
			dwMeasure += 1;
		}
		mtStart += lQuantize;
	}
	return mtEnd;
}

HRESULT STDMETHODCALLTYPE CTimeSigTrack::Clone(
	MUSIC_TIME mtStart,
	MUSIC_TIME mtEnd,
	IDirectMusicTrack** ppTrack)
{
	V_INAME(IDirectMusicTrack::Clone);
	V_PTRPTR_WRITE(ppTrack);

	HRESULT hr = S_OK;

	if((mtStart < 0 ) ||(mtStart > mtEnd))
	{
        Trace(1,"Error: Clone failed on time signature track because of invalid start or end time.\n");
		return E_INVALIDARG;
	}

	EnterCriticalSection(&m_CrSec);
    CTimeSigTrack *pDM;
    
    try
    {
        pDM = new CTimeSigTrack(this, mtStart, mtEnd);
    }
    catch( ... )
    {
        pDM = NULL;
    }

	LeaveCriticalSection(&m_CrSec);
    if (pDM == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = pDM->QueryInterface(IID_IDirectMusicTrack, (void**)ppTrack);
    pDM->Release();

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\validate.h ===
//
// validate.h
//
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Parameter validation macros
//
// Summary:
//
// V_INAME(interfacename)                - Set the interface name for error display
// V_STRUCTPTR_READ(ptr,type)            - A dwSize struct which we will read
// V_STRUCTPTR_WRITE(ptr,type)           - A dwSize struct which we will read/write
// V_PTR_READ(ptr,type)                  - A typed ptr w/o a dwSize which we will read
// V_PTR_WRITE(ptr,type)                 - A typed ptr w/o a dwSize which we will read/write
// V_PTR_WRITE_OPT(ptr,type)             - An optional typed ptr w/o a dwSize which we will read/write
// V_BUFPTR_READ(ptr,size)               - A variable-size buffer that we will read
// V_BUFPTR_READ_OPT(ptr,size)			 - An optional variable-size buffer that we will read
// V_BUFPTR_WRITE(ptr,size)              - A variable-size buffer that we will read/write
// V_BUFPTR_WRITE_OPT(ptr,size)          - An optional variable-size buffer that we will read/write
// V_PTRPTR_WRITE(ptrptr)                - A pointer to a pointer to write to
// V_PTRPTR_WRITE_OPT(ptrptr)            - A pointer to a pointer to write to that is optional
// V_PUNKOUTER(punk)                     - A pointer to a controlling unknown, aggregation supported
// V_PUNKOUTER_NOADD(punk)               - A pointer to a controlling unknown, aggregation not supported
// V_INTERFACE(ptr)                      - A pointer to a COM interface
// V_INTERFACE_OPT(ptr)                  - An optional pointer to a COM interface
// V_REFGUID(ref)                        - A reference to a GUID (type REFGUID)
// V_HWND(hwnd)							 - A window handle
// V_HWNDOPT(hwnd)						 - An optional window handle
//
// For handling different versions of structures:
// 
// V_STRUCTPTR_READ_VER(ptr,ver)         - Begin a struct version block for read access
//                                         At the end, 'ver' will contain the 
//                                         discovered version of the struct
// V_STRUCTPTR_READ_VER_CASE(base,ver)   - Test struct against version ver of
//                                         type 'base'. 
// V_STRUCTPTR_READ_VER_END(base,ptr)    - End a struct version block
//
// V_STRUCTPTR_WRITE_VER(ptr,ver)        - Struct version block for write access
// V_STRUCTPTR_WRITE_VER_CASE(base,ver)
// V_STRUCTPTR_WRITE_VER_END(base,ptr)
//
// The struct version block expects type names of a base type followed by a 
// numeric version, such as
//
// typedef struct { } FOO7;
// typedef struct { } FOO8;
//
// In the header FOO and LPFOO are conditionally typedef'd based on a version
// #define. The DLL will be compiled with the latest version number and hence
// the largest version of the struct.
//
// Since Windows headers are compiled by default with 8-byte alignment, adding
// one DWORD may not cause the size of the structure to change. If this happens
// you will get a 'case label already used' error on one of the VER_CASE macros.
// If this happens, you can get around it by adding a dwReserved field to the 
// end of the struct to force the padding.
//
// 'optional' means the pointer is allowed to be NULL by the interface specification.
//
// Sample usage:
//
// int IDirectMusic::SetFooBarInterface(
//     LPDMUS_REQUESTED_CAPS    pCaps,          // Caps w/ dwSize (read-only)
//     LPVOID                   pBuffer,        // Buffer we will fill in
//     DWORD                    cbSize,         // Size of the buffer
//     PDIRECTMUSICBAR          pBar)           // Callback interface for bar on this buffer
// {
//     V_INTERFACE(IDirectMusic::SetFooBarInterface);
//     V_BUFPTR_WRITE(pBuffer, cbSize);
//     V_INTERFACE(pBar);
//     DWORD dwCapsVer;                         // Must be a DWORD!!!
//
//     V_STRUCTPTR_READ_VER(pCaps, dwCapsVer);
//     V_STRUCTPTR_READ_VER_CASE(DMUS_REQUESTED_CAPS, 7);
//     V_STRUCTPTR_READ_VER_CASE(DMUS_REQUESTED_CAPS, 8);
//     V_STRUCTPTR_READ_VER_END_(DMUS_REQUESTED_CAPS, pCaps);
//
//     // At this point, if we are still in the function we have a valid pCaps
//     // pointer and dwCapsVer is either 7 or 8, indicating the version of
//     // the struct passed in.
//
//     ...
// }
//
#ifndef _VALIDATE_H_
#define _VALIDATE_H_


#ifdef DBG
#include <stddef.h>

#include "debug.h"

// To turn on DebugBreak on parameter error, use the following or -DRIP_BREAK in the build:
//
//#define RIP_BREAK 1

#ifdef RIP_BREAK
#define _RIP_BREAK DebugBreak();
#else
#define _RIP_BREAK 
#endif

#define V_INAME(x) \
    static const char __szValidateInterfaceName[] = #x;                       

#define RIP_E_POINTER(ptr) \
{   Trace(-1, "%s: Invalid pointer " #ptr "\n", __szValidateInterfaceName); \
    _RIP_BREAK \
    return E_POINTER; }

#define RIP_E_INVALIDARG(ptr) \
{   Trace(-1, "%s: Invalid argument " #ptr "\n", __szValidateInterfaceName); \
    _RIP_BREAK \
    return E_INVALIDARG; }

#define RIP_E_HANDLE(h) \
{	Trace(-1, "%s: Invalid handle " #h "\n", __szValidateInterfaceName); \
    _RIP_BREAK \
	return E_HANDLE; }
    
#define RIP_W_INVALIDSIZE(ptr) \
{   Trace(-1, "%s: " #ptr "->dwSize matches no known structure size. Defaulting to oldest structure.\n", \
    __szValidateInterfaceName); \
    _RIP_BREAK \
    }
    
#define RIP_E_INVALIDSIZE(ptr) \
{   Trace(-1, "%s: " #ptr "->dwSize is too small\n", __szValidateInterfaceName); \
    _RIP_BREAK \
    return E_INVALIDARG; }
    
#define RIP_E_BLOCKVSDWSIZE(ptr) \
{   Trace(-1, "%s: " #ptr " does not point to as much memory as " #ptr "->dwSize indicates\n", \
    __szValidateInterfaceName); \
    _RIP_BREAK \
    return E_INVALIDARG; }    

// NOTE: The DebugBreak() not in #ifdef is intentional - this is something that
// must be fixed in our code, not an app-generated error.
//
#define V_ASSERT(exp) \
{   if (!(exp)) { \
        Trace(-1, "%s@%s: %s\n", __FILE__, __LINE__, #exp); \
        DebugBreak(); }}

#else

#define V_INAME(x)
#define RIP_E_POINTER(ptr)          { return E_POINTER; }
#define RIP_E_INVALIDARG(ptr)       { return E_INVALIDARG; }
#define RIP_E_HANDLE(h)	            { return E_HANDLE; }
#define RIP_E_BLOCKVSDWSIZE(ptr)    { return E_INVALIDARG; }
#define RIP_W_INVALIDSIZE(ptr)
#define RIP_E_INVALIDSIZE(ptr)      { return E_INVALIDARG; }
#define V_ASSERT(exp)

#endif          // DBG

// A passed struct we will only read from or may write to. Must be a struct
// with a dwSize.
//
// int foo(CFoo *pFoo)
// ...
// V_STRUCTPTR_READ(pFoo, CFoo);
// V_STRUCTPTR_WRITE(pFoo, CFoo);
//
// Use _PTR_ variants for structs w/o a dwSize
//
#define V_STRUCTPTR_READ(ptr,type) \
{   V_ASSERT(offsetof(type, dwSize) == 0); \
    if (IsBadReadPtr(ptr, sizeof(DWORD)))               RIP_E_BLOCKVSDWSIZE(ptr); \
	if (ptr->dwSize < sizeof(type))						RIP_E_INVALIDSIZE(ptr); \
    if (IsBadReadPtr(ptr, (ptr)->dwSize))               RIP_E_BLOCKVSDWSIZE(ptr); }

#define V_STRUCTPTR_WRITE(ptr,type) \
{   V_ASSERT(offsetof(type, dwSize) == 0); \
    if (IsBadReadPtr(ptr, sizeof(DWORD)))               RIP_E_BLOCKVSDWSIZE(ptr); \
	if (ptr->dwSize < sizeof(type))						RIP_E_INVALIDSIZE(ptr); \
    if (IsBadWritePtr(ptr, (ptr)->dwSize))              RIP_E_BLOCKVSDWSIZE(ptr); }

#define V_PTR_READ(ptr,type) \
{ if (IsBadReadPtr(ptr, sizeof(type)))                  RIP_E_POINTER(ptr); }

#define V_PTR_WRITE(ptr,type) \
{ if (IsBadWritePtr(ptr, sizeof(type)))                 RIP_E_POINTER(ptr); }

#define V_PTR_WRITE_OPT(ptr,type) \
{ if (ptr) if (IsBadWritePtr(ptr, sizeof(type)))        RIP_E_POINTER(ptr); }

// A buffer pointer with separate length (not defined by the pointer type) we will only
// read from or may write to.
//
// int foo(LPVOID *pBuffer, DWORD cbBuffer)
// ...
// V_BUFPTR_READ(pBuffer, cbBuffer);
// V_BUFPTR_WRITE(pBuffer, cbBuffer);
//
#define V_BUFPTR_READ(ptr,len) \
{   if (IsBadReadPtr(ptr, len))                         RIP_E_POINTER(ptr); }

#define V_BUFPTR_READ_OPT(ptr,len) \
{	if (ptr) V_BUFPTR_READ(ptr,len); }

#define V_BUFPTR_WRITE(ptr,len) \
{   if (IsBadWritePtr(ptr, len))                        RIP_E_POINTER(ptr); }

#define V_BUFPTR_WRITE_OPT(ptr,len) \
{	if (ptr) V_BUFPTR_WRITE(ptr,len); }

// A pointer to a pointer (such as a pointer to an interface pointer) to return
//
// int foo(IReturnMe **ppRet)
// ...
// V_PTRPTR_WRITE(ppRet);
// V_PTRPTR_WRITE_OPT(ppRet);
//
#define V_PTRPTR_WRITE(ptr) \
{   if (IsBadWritePtr(ptr, sizeof(void*)))              RIP_E_POINTER(ptr); }

#define V_PTRPTR_WRITE_OPT(ptr) \
{   if (ptr) if (IsBadWritePtr(ptr, sizeof(void*)))     RIP_E_POINTER(ptr); }

// A pointer to a controlling unknown
//
#define V_PUNKOUTER(punk) \
{   if (punk && IsBadCodePtr(punk))                     RIP_E_POINTER(ptr); }

// A pointer to a controlling unknown for which we don't support aggregation
//
#define V_PUNKOUTER_NOAGG(punk) \
{   if (punk && IsBadReadPtr(punk, sizeof(IUnknown)))   RIP_E_POINTER(ptr); \
    if (punk) return CLASS_E_NOAGGREGATION; }

// Validate an incoming interface pointer. 
//
struct _V_GENERIC_INTERFACE
{
    FARPROC *(__vptr[1]);
};

#define V_INTERFACE(ptr) \
{   if (IsBadReadPtr(ptr, sizeof(_V_GENERIC_INTERFACE)))                              RIP_E_POINTER(ptr); \
    if (IsBadReadPtr(*reinterpret_cast<_V_GENERIC_INTERFACE*>(ptr)->__vptr, sizeof(FARPROC))) \
                                                                                      RIP_E_POINTER(ptr); \
    if (IsBadCodePtr(*(reinterpret_cast<_V_GENERIC_INTERFACE*>(ptr)->__vptr)[0]))     RIP_E_POINTER(ptr); }

#define V_INTERFACE_OPT(ptr) \
{   if (ptr) V_INTERFACE(ptr); }

// Validation for a reference to a GUID, which we only ever read. 
//
#define V_REFGUID(ref) \
{   if (IsBadReadPtr((void*)&ref, sizeof(GUID)))        RIP_E_POINTER((void*)&ref); }

// Validation for a window handle
//
#define V_HWND(h) \
{	if (!IsWindow(h))									RIP_E_HANDLE(h); }	

#define V_HWND_OPT(h) \
{	if (h) if (!IsWindow(h))							RIP_E_HANDLE(h); }	

// Validation for multiple sized structs based on version
//
#define V_STRUCTPTR_READ_VER(ptr,ver) \
{   ver = 7; DWORD *pdw = &ver;  \
    if (IsBadReadPtr(ptr, sizeof(DWORD)))               RIP_E_BLOCKVSDWSIZE(ptr); \
    if (IsBadReadPtr(ptr, (ptr)->dwSize))               RIP_E_BLOCKVSDWSIZE(ptr); \
    switch ((ptr)->dwSize) {
    
#define V_STRUCTPTR_READ_VER_CASE(basetype,ver) \
    case sizeof(basetype##ver) : \
    V_ASSERT(offsetof(basetype##ver, dwSize) == 0); \
    *pdw = ver; break;
    
#define V_STRUCTPTR_READ_VER_END(basetype,ptr) \
    default : if ((ptr)->dwSize > sizeof(basetype##7)) \
    { RIP_W_INVALIDSIZE(ptr); } else \
    RIP_E_INVALIDSIZE(ptr); }}


#define V_STRUCTPTR_WRITE_VER(ptr,ver) \
{   ver = 7; DWORD *pdw = &ver;  \
    if (IsBadReadPtr(ptr, sizeof(DWORD)))               RIP_E_BLOCKVSDWSIZE(ptr); \
    if (IsBadWritePtr(ptr, (ptr)->dwSize))              RIP_E_BLOCKVSDWSIZE(ptr); \
    switch ((ptr)->dwSize) {
    
#define V_STRUCTPTR_WRITE_VER_CASE(basetype,ver) \
    case sizeof(basetype##ver) : \
        V_ASSERT(offsetof(basetype##ver, dwSize) == 0); \
        *pdw = ver; break;
    
#define V_STRUCTPTR_WRITE_VER_END(basetype,ptr) \
    default : if ((ptr)->dwSize > sizeof(basetype##7)) \
    { RIP_W_INVALIDSIZE(ptr); } else \
    RIP_E_INVALIDSIZE(ptr); }}



#endif          // _VALIDATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\wavtrack.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)

// WavTrack.cpp : Implementation of CWavTrack
#include "dmime.h"
#include "dmperf.h"
#include "WavTrack.h"
#include "dmusici.h"
#include "dmusicf.h"
#include "debug.h"
#include "Validate.h"
#include "debug.h"
#include "dswave.h"
#include "dmsegobj.h"
#define ASSERT  assert
#include <math.h>

// @doc EXTERNAL

TList<TaggedWave> WaveItem::st_WaveList;
CRITICAL_SECTION WaveItem::st_WaveListCritSect;
long CWavTrack::st_RefCount = 0;

BOOL PhysicalLess(WaveItem& WI1, WaveItem& WI2)
{
    return WI1.m_rtTimePhysical < WI2.m_rtTimePhysical;
}

BOOL LogicalLess(WaveItem& WI1, WaveItem& WI2)
{
    return WI1.m_mtTimeLogical < WI2.m_mtTimeLogical;
}

/////////////////////////////////////////////////////////////////////////////
// CWavTrack

void CWavTrack::FlushWaves()
{
    UnloadAllWaves(NULL);
    EnterCriticalSection(&WaveItem::st_WaveListCritSect);
    while (!WaveItem::st_WaveList.IsEmpty())
    {
        TListItem<TaggedWave>* pScan = WaveItem::st_WaveList.RemoveHead();
        delete pScan;
    }
    LeaveCriticalSection(&WaveItem::st_WaveListCritSect);
}

HRESULT CWavTrack::UnloadAllWaves(IDirectMusicPerformance* pPerformance)
{
    HRESULT hr = S_OK;
    EnterCriticalSection(&WaveItem::st_WaveListCritSect);
    TListItem<TaggedWave>* pScan = WaveItem::st_WaveList.GetHead();
    TListItem<TaggedWave>* pNext = NULL;
    for (; pScan; pScan = pNext)
    {
        pNext = pScan->GetNext();
        TaggedWave& rScan = pScan->GetItemValue();
        if (!pPerformance || rScan.m_pPerformance == pPerformance)
        {
            if (rScan.m_pPort)
            {
                if (rScan.m_pDownloadedWave)
                {
                    Trace(1, "Error: Wave was downloaded but never unloaded.\n");
                    rScan.m_pPort->UnloadWave(rScan.m_pDownloadedWave);
                    rScan.m_pDownloadedWave = NULL;
                }
                rScan.m_pPort->Release();
                rScan.m_pPort = NULL;
            }
            if (rScan.m_pPerformance)
            {
                rScan.m_pPerformance->Release();
                rScan.m_pPerformance = NULL;
            }
            if (rScan.m_pWave)
            {
                rScan.m_pWave->Release();
                rScan.m_pWave = NULL;
            }
            WaveItem::st_WaveList.Remove(pScan);
            delete pScan;
        }
    }
    LeaveCriticalSection(&WaveItem::st_WaveListCritSect);
    return hr;
}

// This SHOULD NOT be called except from a constructor.
void CWavTrack::Construct()
{
    InterlockedIncrement(&g_cComponent);

    m_fCSInitialized = FALSE;
    InitializeCriticalSection(&m_CrSec);
    m_fCSInitialized = TRUE;

    m_dwPChannelsUsed = 0;
    m_aPChannels = NULL;
    m_dwTrackFlags = 0;
    m_dwValidate = 0;
    m_cRef = 1;
    m_dwVariation = 0;
    m_dwPart = 0;
    m_dwIndex = 0;
    m_dwLockID = 0;
    m_fAudition = FALSE;
    m_fAutoDownload = FALSE;
    m_fLockAutoDownload = FALSE;
    st_RefCount++;
    m_pdwVariations = NULL;
    m_pdwRemoveVariations = NULL;
    m_dwWaveItems = 0;
}

void CWavTrack::CleanUp()
{
    m_dwPChannelsUsed = 0;
    if (m_aPChannels) delete [] m_aPChannels;
    if (m_pdwVariations) delete [] m_pdwVariations;
    if (m_pdwRemoveVariations) delete [] m_pdwRemoveVariations;
    m_aPChannels = NULL;
    m_pdwVariations = NULL;
    m_pdwRemoveVariations = NULL;
    TListItem<WavePart>* pScan = m_WavePartList.GetHead();
    for (; pScan; pScan = pScan->GetNext() )
    {
        pScan->GetItemValue().CleanUp();
    }
    m_WavePartList.CleanUp();
    RemoveDownloads(NULL);
}

void CWavTrack::CleanUpTempParts()
{
    TListItem<WavePart>* pScan = m_TempWavePartList.GetHead();
    for (; pScan; pScan = pScan->GetNext() )
    {
        pScan->GetItemValue().CleanUp();
    }
    m_TempWavePartList.CleanUp();
}

void CWavTrack::MovePartsToTemp()
{
    CleanUpTempParts();
    TListItem<WavePart>* pScan = m_WavePartList.RemoveHead();
    for (; pScan; pScan = m_WavePartList.RemoveHead() )
    {
        m_TempWavePartList.AddHead(pScan);
    }
}

// NULL for non-streaming waves.
// For streaming waves, return the DownLoadedWave that's associated with the same wave
// with the same start offset (and remove it from the Item list so it's not returned again).
IDirectSoundDownloadedWaveP* CWavTrack::FindDownload(TListItem<WaveItem>* pItem)
{
    if (!pItem || !pItem->GetItemValue().m_pWave || !pItem->GetItemValue().m_fIsStreaming)
    {
        return NULL;
    }

    WaveItem& rWaveItem = pItem->GetItemValue();

    TListItem<WavePart>* pScan = m_TempWavePartList.GetHead();
    for (; pScan ; pScan = pScan->GetNext())
    {
        TListItem<WaveItem>* pItemScan = pScan->GetItemValue().m_WaveItemList.GetHead();
        TListItem<WaveItem>* pNext = NULL;
        for (; pItemScan; pItemScan = pNext)
        {
            pNext = pItemScan->GetNext();
            WaveItem& rTempItem = pItemScan->GetItemValue();
            if (rTempItem.m_fIsStreaming &&
                rWaveItem.m_pWave == rTempItem.m_pWave &&
                rWaveItem.m_rtStartOffset == rTempItem.m_rtStartOffset)
            {
                IDirectSoundDownloadedWaveP* pReturn = rTempItem.m_pDownloadedWave;
                if (rTempItem.m_pWave)
                {
                    rTempItem.m_pWave->Release();
                    rTempItem.m_pWave = NULL;
                }
                rTempItem.m_pDownloadedWave = NULL;
                pScan->GetItemValue().m_WaveItemList.Remove(pItemScan);
                delete pItemScan;
                return pReturn;
            }
        }
    }
    return NULL;
}

HRESULT CWavTrack::GetDownload(
        IDirectSoundDownloadedWaveP* pWaveDL,
        WaveStateData* pStateData,
        IDirectMusicPortP* pPortP,
        IDirectSoundWave* pWave,
        REFERENCE_TIME rtStartOffset,
        WaveItem& rItem,
        DWORD dwMChannel,
        DWORD dwGroup,
        IDirectMusicVoiceP **ppVoice)
{
    HRESULT hr = S_OK;
    TListItem<WaveDLOnPlay>* pNew = NULL;
    if (!pWaveDL || !pStateData) return E_POINTER;

    IDirectSoundDownloadedWaveP* pNewWaveDL = NULL;
    if (rItem.m_fIsStreaming)
    {
        bool fPair = false;
        TListItem<WavePair>* pPair = m_WaveList.GetHead();
        for (; pPair; pPair = pPair->GetNext())
        {
            if (pWaveDL == pPair->GetItemValue().m_pWaveDL)
            {
                if (!pNewWaveDL)
                {
                    // download a new one (to be returned), and put it in the state data's list.
                    if (FAILED(hr = pPortP->DownloadWave( pWave, &pNewWaveDL, rtStartOffset )))
                    {
                        return hr;
                    }
                    pNew = new TListItem<WaveDLOnPlay>;
                    if (!pNew)
                    {
                        pPortP->UnloadWave(pNewWaveDL);
                        return E_OUTOFMEMORY;
                    }
                    pNew->GetItemValue().m_pWaveDL = pNewWaveDL;
                    pNew->GetItemValue().m_pPort = pPortP;
                    pPortP->AddRef();
                    pStateData->m_WaveDLList.AddHead(pNew);
                }
                if (pStateData == pPair->GetItemValue().m_pStateData)
                {
                    fPair = true;
                    break;
                }
            }
        }
        if (!fPair)
        {
            // create one and add it to m_WaveList
            pPair = new TListItem<WavePair>;
            if (!pPair)
            {
                return E_OUTOFMEMORY;
            }
            pPair->GetItemValue().m_pStateData = pStateData;
            pPair->GetItemValue().m_pWaveDL = pWaveDL;
            pWaveDL->AddRef();
            m_WaveList.AddHead(pPair);
        }
    }
    if (SUCCEEDED(hr))
    {
        if (!pNewWaveDL) pNewWaveDL = pWaveDL;
        hr = pPortP->AllocVoice(pNewWaveDL,
            dwMChannel, dwGroup, rtStartOffset,
            rItem.m_dwLoopStart, rItem.m_dwLoopEnd,
            ppVoice);
        if (SUCCEEDED(hr))
        {
            if (pNew)
            {
                pNew->GetItemValue().m_pVoice = *ppVoice;
            }
            else
            {
                if (pStateData->m_apVoice[rItem.m_dwVoiceIndex])
                {
                    pStateData->m_apVoice[rItem.m_dwVoiceIndex]->Release();
                }
                pStateData->m_apVoice[rItem.m_dwVoiceIndex] = *ppVoice;
            }
        }
    }
    return hr;
}

void CWavTrack::RemoveDownloads(WaveStateData* pStateData)
{
    TListItem<WavePair>* pPair = m_WaveList.GetHead();
    TListItem<WavePair>* pNextPair = NULL;
    for (; pPair; pPair = pNextPair)
    {
        pNextPair = pPair->GetNext();
        if (!pStateData || pPair->GetItemValue().m_pStateData == pStateData)
        {
            m_WaveList.Remove(pPair);
            delete pPair;
        }
    }

    if (pStateData)
    {
        TListItem<WaveDLOnPlay>* pWDLOnPlay = NULL;
        while (!pStateData->m_WaveDLList.IsEmpty())
        {
            pWDLOnPlay = pStateData->m_WaveDLList.RemoveHead();
            delete pWDLOnPlay;
        }
    }
}

CWavTrack::CWavTrack()
{
    Construct();
}

CWavTrack::CWavTrack(const CWavTrack& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd)
{
    Construct();
    CopyParts(rTrack.m_WavePartList, mtStart, mtEnd);
    m_lVolume = rTrack.m_lVolume;
    m_dwTrackFlags = rTrack.m_dwTrackFlags;
}

HRESULT CWavTrack::InitTrack(DWORD dwPChannels)
{
    HRESULT hr = S_OK;

    m_dwPChannelsUsed = dwPChannels;
    m_dwWaveItems = 0;
    if( m_dwPChannelsUsed )
    {
        m_aPChannels = new DWORD[m_dwPChannelsUsed];
        if (!m_aPChannels) hr = E_OUTOFMEMORY;
        else if (m_dwTrackFlags & DMUS_WAVETRACKF_PERSIST_CONTROL)
        {
            m_pdwVariations = new DWORD[m_dwPChannelsUsed];
            m_pdwRemoveVariations = new DWORD[m_dwPChannelsUsed];
            if (!m_pdwVariations || !m_pdwRemoveVariations) hr = E_OUTOFMEMORY;
        }
        if (SUCCEEDED(hr))
        {
            TListItem<WavePart>* pScan = m_WavePartList.GetHead();
            for (DWORD dw = 0; pScan && dw < m_dwPChannelsUsed; pScan = pScan->GetNext(), dw++)
            {
                m_aPChannels[dw] = pScan->GetItemValue().m_dwPChannel;
                if (m_pdwVariations) m_pdwVariations[dw] = 0;
                if (m_pdwRemoveVariations) m_pdwRemoveVariations[dw] = 0;
                TListItem<WaveItem>* pItemScan = pScan->GetItemValue().m_WaveItemList.GetHead();
                for (; pItemScan; pItemScan = pItemScan->GetNext())
                {
                    pItemScan->GetItemValue().m_dwVoiceIndex = m_dwWaveItems;
                    m_dwWaveItems++;
                }
            }
        }
        else CleanUp();
    }
    return hr;
}

CWavTrack::~CWavTrack()
{
    if (m_fCSInitialized)
    {
        CleanUpTempParts();
        CleanUp();
        st_RefCount--;
        if (st_RefCount <= 0)
        {
            // if there's still something in the wave list, it means there are waves that
            // haven't been unloaded; but at this point we've gotten rid of all wave tracks,
            // so unload and release everything now.
            UnloadAllWaves(NULL);
            EnterCriticalSection(&WaveItem::st_WaveListCritSect);
            WaveItem::st_WaveList.CleanUp();
            LeaveCriticalSection(&WaveItem::st_WaveListCritSect);
        }
        DeleteCriticalSection(&m_CrSec);
    }

    InterlockedDecrement(&g_cComponent);
}

// @method:(INTERNAL) HRESULT | IDirectMusicTrack | QueryInterface | Standard QueryInterface implementation for <i IDirectMusicSeqTrack>
//
// @rdesc Returns one of the following:
//
// @flag S_OK | If the interface is supported and was returned
// @flag E_NOINTERFACE | If the object does not support the given interface.
// @flag E_POINTER | <p ppv> is NULL or invalid.
//
STDMETHODIMP CWavTrack::QueryInterface(
    const IID &iid,   // @parm Interface to query for
    void **ppv)       // @parm The requested interface will be returned here
{
    V_INAME(CWavTrack::QueryInterface);
    V_PTRPTR_WRITE(ppv);
    V_REFGUID(iid);

   if (iid == IID_IUnknown || iid == IID_IDirectMusicTrack || iid == IID_IDirectMusicTrack8)
    {
        *ppv = static_cast<IDirectMusicTrack*>(this);
    }
    else if (iid == IID_IPersistStream)
    {
        *ppv = static_cast<IPersistStream*>(this);
    }
    else if (iid == IID_IPrivateWaveTrack)
    {
        *ppv = static_cast<IPrivateWaveTrack*>(this);
    }
    else
    {
        *ppv = NULL;
        Trace(4,"Warning: Request to query unknown interface on Wave Track\n");
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


// @method:(INTERNAL) HRESULT | IDirectMusicTrack | AddRef | Standard AddRef implementation for <i IDirectMusicSeqTrack>
//
// @rdesc Returns the new reference count for this object.
//
STDMETHODIMP_(ULONG) CWavTrack::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


// @method:(INTERNAL) HRESULT | IDirectMusicTrack | Release | Standard Release implementation for <i IDirectMusicSeqTrack>
//
// @rdesc Returns the new reference count for this object.
//
STDMETHODIMP_(ULONG) CWavTrack::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

/////////////////////////////////////////////////////////////////////////////
// IPersist

HRESULT CWavTrack::GetClassID( CLSID* pClassID )
{
    V_INAME(CSeqTrack::GetClassID);
    V_PTR_WRITE(pClassID, CLSID);
    *pClassID = CLSID_DirectMusicWaveTrack;
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IPersistStream functions

HRESULT CWavTrack::IsDirty()
{
    return S_FALSE;
}

HRESULT CWavTrack::Load( IStream* pIStream )
{
    V_INAME(CWavTrack::Load);
    V_INTERFACE(pIStream);

    DWORD dwSize;
    DWORD dwByteCount;

    // Verify that the stream pointer is non-null
    if( pIStream == NULL )
    {
        Trace(1,"Error: Null stream passed to wave track.\n");
        return E_POINTER;
    }

    IDMStream* pIRiffStream;
    HRESULT hr = E_FAIL;

    // Try and allocate a RIFF stream
    if( FAILED( hr = AllocDirectMusicStream( pIStream, &pIRiffStream ) ) )
    {
        return hr;
    }

    // Variables used when loading the Wave track
    MMCKINFO ckTrack;
    MMCKINFO ckList;

    EnterCriticalSection(&m_CrSec);
    m_dwValidate++; // used to validate state data that's out there
    MovePartsToTemp();
    CleanUp();

    // Interate through every chunk in the stream
    while( pIRiffStream->Descend( &ckTrack, NULL, 0 ) == S_OK )
    {
        switch( ckTrack.ckid )
        {
            case FOURCC_LIST:
                switch( ckTrack.fccType )
                {
                    case DMUS_FOURCC_WAVETRACK_LIST:
                        while( pIRiffStream->Descend( &ckList, &ckTrack, 0 ) == S_OK )
                        {
                            switch( ckList.ckid )
                            {
                                case DMUS_FOURCC_WAVETRACK_CHUNK:
                                {
                                    DMUS_IO_WAVE_TRACK_HEADER iTrackHeader;

                                    // Read in the item's header structure
                                    dwSize = min( sizeof( DMUS_IO_WAVE_TRACK_HEADER ), ckList.cksize );
                                    hr = pIStream->Read( &iTrackHeader, dwSize, &dwByteCount );

                                    // Handle any I/O error by returning a failure code
                                    if( FAILED( hr ) ||  dwByteCount != dwSize )
                                    {
                                        if (SUCCEEDED(hr)) hr = DMUS_E_CANNOTREAD;
                                        goto ON_ERROR;
                                    }

                                    m_lVolume = iTrackHeader.lVolume;
                                    m_dwTrackFlags = iTrackHeader.dwFlags;
                                    break;
                                }

                                case FOURCC_LIST:
                                    switch( ckList.fccType )
                                    {
                                        case DMUS_FOURCC_WAVEPART_LIST:
                                        {
                                            TListItem<WavePart>* pNewPart = new TListItem<WavePart>;
                                            if( !pNewPart )
                                            {
                                                hr = E_OUTOFMEMORY;
                                                goto ON_ERROR;
                                            }
                                            hr = pNewPart->GetItemValue().Load( pIRiffStream, &ckList );
                                            if( FAILED ( hr ) )
                                            {
                                                delete pNewPart;
                                                goto ON_ERROR;
                                            }
                                            InsertByAscendingPChannel( pNewPart );
                                            break;
                                        }
                                    }
                                    break;
                            }

                            pIRiffStream->Ascend( &ckList, 0 );
                        }
                        break;
                }
                break;
        }

        pIRiffStream->Ascend( &ckTrack, 0 );
    }
    hr = InitTrack(m_WavePartList.GetCount());
    if (SUCCEEDED(hr))
    {
        TListItem<WavePart>* pScan = m_WavePartList.GetHead();
        for (; pScan ; pScan = pScan->GetNext())
        {
            TListItem<WaveItem>* pItemScan = pScan->GetItemValue().m_WaveItemList.GetHead();
            for (; pItemScan; pItemScan = pItemScan->GetNext())
            {
                pItemScan->GetItemValue().m_pDownloadedWave = FindDownload(pItemScan);
            }
        }
    }
    else CleanUp();

ON_ERROR:
    CleanUpTempParts();
    LeaveCriticalSection(&m_CrSec);
    pIRiffStream->Release();
    return hr;
}

HRESULT CWavTrack::CopyParts( const TList<WavePart>& rParts, MUSIC_TIME mtStart, MUSIC_TIME mtEnd )
{
    HRESULT hr = S_OK;
    CleanUp();
    TListItem<WavePart>* pScan = rParts.GetHead();
    for (; pScan; pScan = pScan->GetNext() )
    {
        WavePart& rScan = pScan->GetItemValue();
        TListItem<WavePart>* pNew = new TListItem<WavePart>;
        if (pNew)
        {
            WavePart& rNew = pNew->GetItemValue();
            rNew.m_dwLockToPart = rScan.m_dwLockToPart;
            rNew.m_dwPChannel = rScan.m_dwPChannel;
            rNew.m_dwIndex = rScan.m_dwIndex;
            rNew.m_dwPChannelFlags = rScan.m_dwPChannelFlags;
            rNew.m_lVolume = rScan.m_lVolume;
            rNew.m_dwVariations = rScan.m_dwVariations;
            if (SUCCEEDED(hr = rNew.CopyItems(rScan.m_WaveItemList, mtStart, mtEnd)))
            {
                m_WavePartList.AddHead(pNew);
            }
            else
            {
                delete pNew;
                break;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
            break;
        }
    }
    if (SUCCEEDED(hr))
    {
        m_WavePartList.Reverse();
    }
    else
    {
        CleanUp();
    }
    return hr;
}

void CWavTrack::InsertByAscendingPChannel( TListItem<WavePart>* pPart )
{
    if (pPart)
    {
        DWORD dwPChannel = pPart->GetItemValue().m_dwPChannel;
        TListItem<WavePart>* pScan = m_WavePartList.GetHead();
        TListItem<WavePart>* pPrevious = NULL;
        for (; pScan; pScan = pScan->GetNext())
        {
            if (dwPChannel < pScan->GetItemValue().m_dwPChannel)
            {
                break;
            }
            pPrevious = pScan;
        }
        if (pPrevious)
        {
            pPart->SetNext(pScan);
            pPrevious->SetNext(pPart);
        }
        else
        {
            m_WavePartList.AddHead(pPart);
        }
    }
}

HRESULT CWavTrack::Save( IStream* pIStream, BOOL fClearDirty )
{
    return E_NOTIMPL;
}

HRESULT CWavTrack::GetSizeMax( ULARGE_INTEGER FAR* pcbSize )
{
    return E_NOTIMPL;
}

// IDirectMusicTrack
/*
@method HRESULT | IDirectMusicTrack | IsParamSupported |
Check to see if the Track supports data types in <om .GetParam> and <om .SetParam>.

@rvalue S_OK | It does support the type of data.
@rvalue S_FALSE | It does not support the type of data.
@rvalue E_NOTIMPL | (Or any other failure code) It does not support the type of data.

@comm Note that it is valid for a Track to return different results for the same
guid depending on its current state.
*/
HRESULT STDMETHODCALLTYPE CWavTrack::IsParamSupported(
    REFGUID rguidType)  // @parm The guid identifying the type of data to check.
{
    if(rguidType == GUID_Download ||
       rguidType == GUID_DownloadToAudioPath ||
       rguidType == GUID_UnloadFromAudioPath ||
       rguidType == GUID_Enable_Auto_Download ||
       rguidType == GUID_Disable_Auto_Download ||
       rguidType == GUID_Unload )
    {
        return S_OK;
    }
    else
    {
        return DMUS_E_TYPE_UNSUPPORTED;
    }
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicTrack::Init
/*
@method HRESULT | IDirectMusicTrack | Init |
When a track is first added to a <i IDirectMusicSegment>, this method is called
by that Segment.

@rvalue S_OK | Success.
@rvalue E_POINTER | <p pSegment> is NULL or invalid.

@comm If the Track plays messages, it should call <om IDirectMusicSegment.SetPChannelsUsed>.
*/
HRESULT CWavTrack::Init(
    IDirectMusicSegment *pSegment)  // @parm Pointer to the Segment to which this Track belongs.
{
    EnterCriticalSection(&m_CrSec);
    if( m_dwPChannelsUsed && m_aPChannels )
    {
        pSegment->SetPChannelsUsed( m_dwPChannelsUsed, m_aPChannels );
    }
    CSegment* pCSegment = NULL;
    bool fSortLogical = false;
    if (SUCCEEDED(pSegment->QueryInterface(IID_CSegment, (void**)&pCSegment)))
    {
        DWORD dwGroupBits = 0;
        if (FAILED(pSegment->GetTrackGroup( this, &dwGroupBits )))
        {
            dwGroupBits = 0xffffffff;
        }
        DWORD dwConfig = 0;
        if (SUCCEEDED(pCSegment->GetTrackConfig(CLSID_DirectMusicWaveTrack, dwGroupBits, 0, &dwConfig)))
        {
            if ( !(dwConfig & DMUS_TRACKCONFIG_PLAY_CLOCKTIME) )
            {
                fSortLogical = true;
            }
        }
        pCSegment->Release();
    }
    TListItem<WavePart>* pScan = m_WavePartList.GetHead();
    for (; pScan; pScan = pScan->GetNext())
    {
        if (fSortLogical)
        {
            pScan->GetItemValue().m_WaveItemList.MergeSort(LogicalLess);
        }
        else
        {
            pScan->GetItemValue().m_WaveItemList.MergeSort(PhysicalLess);
        }
    }
    LeaveCriticalSection(&m_CrSec);
    return S_OK;
}

/*
@method HRESULT | IDirectMusicTrack | InitPlay |
This method is called when a Segment is ready to start playing. The <p ppStateData> field
may return a pointer to a structure of state data, which is sent into <om .Play> and
<om .EndPlay>, and allows the Track to keep track of variables on a <i SegmentState> by
<i SegmentState> basis.

@rvalue S_OK | Success. This is the only valid return value from this method.
@rvalue E_POINTER | <p pSegmentState>, <p pPerf>, or <p ppStateData> is NULL or
invalid.

@comm Note that it is unneccessary for the Track to store the <p pSegmentState>, <p pPerf>,
or <p dwTrackID> parameters, since they are also sent into <om .Play>.
*/
HRESULT CWavTrack::InitPlay(
    IDirectMusicSegmentState *pSegmentState,    // @parm The calling <i IDirectMusicSegmentState> pointer.
    IDirectMusicPerformance *pPerf, // @parm The calling <i IDirectMusicPerformance> pointer.
    void **ppStateData,     // @parm This method can return state data information here.
    DWORD dwTrackID,        // @parm The virtual track ID assigned to this Track instance.
    DWORD dwFlags)          // @parm Same flags that were set with the call
            // to PlaySegment. These are passed all the way down to the tracks, who may want to know
            // if the track was played as a primary, controlling, or secondary segment.
{
    V_INAME(IDirectMusicTrack::InitPlay);
    V_PTRPTR_WRITE(ppStateData);
    V_INTERFACE(pSegmentState);
    V_INTERFACE(pPerf);
    HRESULT hr = E_OUTOFMEMORY;
    IDirectMusicSegmentState8 *pSegSt8 = NULL;

    EnterCriticalSection(&m_CrSec);
    WaveStateData* pStateData = new WaveStateData;
    if( NULL == pStateData )
    {
        goto ON_END;
    }

    // Get the audiopath being used by our segment state and save it in our state data.
    hr = pSegmentState->QueryInterface(IID_IDirectMusicSegmentState8, reinterpret_cast<void**>(&pSegSt8));
    if (SUCCEEDED(hr))
    {
        hr = pSegSt8->GetObjectInPath(
                        0,                          // pchannel doesn't apply
                        DMUS_PATH_AUDIOPATH,        // get the audiopath
                        0,                          // buffer index doesn't apply
                        CLSID_NULL,                 // clsid doesn't apply
                        0,                          // there should be only one audiopath
                        IID_IDirectMusicAudioPath,
                        reinterpret_cast<void**>(&pStateData->m_pAudioPath));

        // If this doesn't find an audiopath that's OK.  If we're not playing on an audiopath then
        // pAudioPath stays NULL and we'll play our triggered segments on the general performance.
        if (hr == DMUS_E_NOT_FOUND)
            hr = S_OK;

        pSegSt8->Release();
    }

    pStateData->m_pPerformance = pPerf;
    {
        *ppStateData = pStateData;
        StatePair SP(pSegmentState, pStateData);
        TListItem<StatePair>* pPair = new TListItem<StatePair>(SP);
        if (!pPair)
        {
            goto ON_END;
        }
        m_StateList.AddHead(pPair);
    }
    SetUpStateCurrentPointers(pStateData);

    // Set up arrays for variations
    if (m_dwPChannelsUsed)
    {
        pStateData->pdwVariations = new DWORD[m_dwPChannelsUsed];
        if (!pStateData->pdwVariations)
        {
            goto ON_END;
        }
        pStateData->pdwRemoveVariations = new DWORD[m_dwPChannelsUsed];
        if (!pStateData->pdwRemoveVariations)
        {
            goto ON_END;
        }
        for (DWORD dw = 0; dw < m_dwPChannelsUsed; dw++)
        {
            if ( (m_dwTrackFlags & DMUS_WAVETRACKF_PERSIST_CONTROL) &&
                 m_pdwVariations &&
                 m_pdwRemoveVariations )
            {
                pStateData->pdwVariations[dw] = m_pdwVariations[dw];
                pStateData->pdwRemoveVariations[dw] = m_pdwRemoveVariations[dw];
            }
            else
            {
                pStateData->pdwVariations[dw] = 0;
                pStateData->pdwRemoveVariations[dw] = 0;
            }
        }
    }

    // need to know the group this track is in, for the mute track GetParam
    IDirectMusicSegment* pSegment;
    if( SUCCEEDED( pSegmentState->GetSegment(&pSegment)))
    {
        pSegment->GetTrackGroup( this, &pStateData->dwGroupBits );
        pSegment->Release();
    }

    // for auditioning variations...
    pStateData->InitVariationInfo(m_dwVariation, m_dwPart, m_dwIndex, m_dwLockID, m_fAudition);
    hr = S_OK;

    BOOL fGlobal; // if the performance has been set with an autodownload preference,
                // use that. otherwise, assume autodownloading is off, unless it has
                // been locked (i.e. specified on the band track.)
    if( SUCCEEDED( pPerf->GetGlobalParam( GUID_PerfAutoDownload, &fGlobal, sizeof(BOOL) )))
    {
        if( !m_fLockAutoDownload )
        {
            // it might seem like we can just assign m_fAutoDownload = fGlobal,
            // but that's bitten markburt before, so I'm being paranoid today.
            if( fGlobal )
            {
                m_fAutoDownload = TRUE;
            }
            else
            {
                m_fAutoDownload = FALSE;
            }
        }
    }
    else if( !m_fLockAutoDownload )
    {
        m_fAutoDownload = FALSE;
    }
    // Call SetParam to download all waves used by the track
    // This is the auto-download feature that can be turned off with a call to SetParam
    if(m_fAutoDownload)
    {
        hr = SetParam(GUID_Download, 0, (void *)pPerf);
        if (FAILED(hr)) goto ON_END;
    }

    ///////////////// pre-allocate voices for all waves in the track ////////////////
    pStateData->m_dwVoices = m_dwWaveItems;
    pStateData->m_apVoice = new IDirectMusicVoiceP*[m_dwWaveItems];
    if (!pStateData->m_apVoice)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        for (DWORD dw = 0; dw < m_dwWaveItems; dw++)
        {
            pStateData->m_apVoice[dw] = NULL;
        }
        Seek( pSegmentState, pPerf, dwTrackID, pStateData, 0, TRUE, 0, FALSE );
        TListItem<WavePart>* pPart = m_WavePartList.GetHead();
        DWORD dwPChannel = 0;
        for( DWORD dwIndex = 0; dwIndex < m_dwPChannelsUsed; dwIndex++ )
        {
            long lPartVolume = 0;
            if( pPart )
            {
                WavePart& rPart = pPart->GetItemValue();
                dwPChannel = rPart.m_dwPChannel;
                lPartVolume = rPart.m_lVolume;
            }
            if( pStateData->apCurrentWave )
            {
                for( ; pStateData->apCurrentWave[dwIndex];
                    pStateData->apCurrentWave[dwIndex] = pStateData->apCurrentWave[dwIndex]->GetNext() )
                {
                    WaveItem& rItem = pStateData->apCurrentWave[dwIndex]->GetItemValue();
                    DWORD dwGroup = 0;
                    DWORD dwMChannel = 0;
                    IDirectMusicPort* pPort = NULL;
                    hr = rItem.PChannelInfo(pPerf, pStateData->m_pAudioPath, dwPChannel, &pPort, &dwGroup, &dwMChannel);
                    if (SUCCEEDED(hr) && pPort)
                    {
                        IDirectMusicPortP* pPortP = NULL;
                        if (SUCCEEDED(hr = pPort->QueryInterface(IID_IDirectMusicPortP, (void**) &pPortP)))
                        {
                            EnterCriticalSection(&WaveItem::st_WaveListCritSect);
                            TListItem<TaggedWave>* pDLWave = rItem.st_WaveList.GetHead();
                            for (; pDLWave; pDLWave = pDLWave->GetNext())
                            {
                                TaggedWave& rDLWave = pDLWave->GetItemValue();
                                if (rDLWave.m_pWave == rItem.m_pWave &&
                                    rDLWave.m_pPerformance == pPerf &&
                                    rDLWave.m_pPort == pPortP &&
                                    ( !rItem.m_fIsStreaming ||
                                      rDLWave.m_pDownloadedWave == rItem.m_pDownloadedWave ) )
                                {
                                    break;
                                }
                            }
                            if (pDLWave)
                            {
                                TaggedWave& rDLWave = pDLWave->GetItemValue();
                                REFERENCE_TIME rtStartOffset = rItem.m_rtStartOffset;
                                if (rItem.m_dwVoiceIndex == 0xffffffff)
                                {
                                    hr = DMUS_E_NOT_INIT;
                                    TraceI(0, "Voice index not initialized!\n");
                                }
                                else if(!rItem.m_fIsStreaming || (rItem.m_fIsStreaming && rItem.m_fUseNoPreRoll == FALSE))
                                {
                                    IDirectMusicVoiceP *pVoice = NULL;
                                    hr = GetDownload(
                                        rDLWave.m_pDownloadedWave,
                                        pStateData,
                                        pPortP,
                                        rDLWave.m_pWave,
                                        rtStartOffset,
                                        rItem,
                                        dwMChannel, dwGroup,
                                        &pVoice);
                                }
                            }
                            else
                            {
                                hr = DMUS_E_NOT_INIT;
                                Trace(1, "Error: Attempt to play wave that has not been downloaded.\n");

                            }
                            LeaveCriticalSection(&WaveItem::st_WaveListCritSect);

                            // Release the private interface
                            pPortP->Release();
                        }
                        pPort->Release();
                    }
                    else if (SUCCEEDED(hr) && !pPort)
                    {
                        Trace(1, "Error: the performance was unable to find a port for voice allocation.\n");
                        hr = DMUS_E_NOT_FOUND;
                    }
                }
            }
            if( pPart )
            {
                pPart = pPart->GetNext();
            }
        }
    }

ON_END:
    if (FAILED(hr) && pStateData)
    {
        delete pStateData;
        pStateData = NULL;
    }
    LeaveCriticalSection(&m_CrSec);
    return hr;
}

/*
@method HRESULT | IDirectMusicTrack | EndPlay |
This method is called when the <i IDirectMusicSegmentState> object that originally called
<om .InitPlay> is destroyed.

@rvalue S_OK | Success.
@rvalue E_POINTER | <p pStateData> is invalid.
@comm The return code isn't used, but S_OK is preferred.
*/
HRESULT CWavTrack::EndPlay(
    void *pStateData)   // @parm The state data returned from <om .InitPlay>.
{
    EnterCriticalSection(&m_CrSec);

    ASSERT( pStateData );
    if( pStateData )
    {
        V_INAME(IDirectMusicTrack::EndPlay);
        V_BUFPTR_WRITE(pStateData, sizeof(WaveStateData));
        WaveStateData* pSD = (WaveStateData*)pStateData;
        RemoveDownloads(pSD);
        if(m_fAutoDownload)
        {
            SetParam(GUID_Unload, 0, (void *)pSD->m_pPerformance);
        }
        for (TListItem<StatePair>* pScan = m_StateList.GetHead(); pScan; pScan = pScan->GetNext())
        {
            StatePair& rPair = pScan->GetItemValue();
            if (pSD == rPair.m_pStateData)
            {
                rPair.m_pSegState = NULL;
                rPair.m_pStateData = NULL;
                break;
            }
        }
        delete pSD;
    }

    LeaveCriticalSection(&m_CrSec);
    return S_OK;
}

void CWavTrack::SetUpStateCurrentPointers(WaveStateData* pStateData)
{
    ASSERT(pStateData);
    pStateData->dwPChannelsUsed = m_dwPChannelsUsed;
    if( m_dwPChannelsUsed )
    {
        if( pStateData->apCurrentWave )
        {
            delete [] pStateData->apCurrentWave;
            pStateData->apCurrentWave = NULL;
        }
        pStateData->apCurrentWave = new TListItem<WaveItem>* [m_dwPChannelsUsed];
        if( pStateData->apCurrentWave )
        {
            memset( pStateData->apCurrentWave, 0, sizeof(TListItem<WavePart>*) * m_dwPChannelsUsed );
        }
    }
    pStateData->dwValidate = m_dwValidate;
}

REFERENCE_TIME ConvertOffset(REFERENCE_TIME rtOffset, long lPitch)
{
    if (lPitch)
    {
        double dblPitch = (double) lPitch;
        double dblStart = (double) rtOffset;
        dblStart *= pow(2, (dblPitch / 1200.0));
        rtOffset = (REFERENCE_TIME) dblStart;
    }
    return rtOffset;
}

STDMETHODIMP CWavTrack::PlayEx(void* pStateData,REFERENCE_TIME rtStart,
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf,
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID)
{
    V_INAME(IDirectMusicTrack::PlayEx);
    V_BUFPTR_WRITE( pStateData, sizeof(WaveStateData));
    V_INTERFACE(pPerf);
    V_INTERFACE(pSegSt);

    HRESULT hr;
    EnterCriticalSection(&m_CrSec);
    BOOL fClock = (dwFlags & DMUS_TRACKF_CLOCK) ? TRUE : FALSE;
/*    if (dwFlags & DMUS_TRACKF_CLOCK)
    {
        hr = Play(pStateData,(MUSIC_TIME)(rtStart / REF_PER_MIL),(MUSIC_TIME)(rtEnd / REF_PER_MIL),
            (MUSIC_TIME)(rtOffset / REF_PER_MIL),rtOffset,dwFlags,pPerf,pSegSt,dwVirtualID,TRUE);
    }
    else*/
    {
        hr = Play(pStateData, rtStart, rtEnd, rtOffset, dwFlags, pPerf, pSegSt, dwVirtualID, fClock);
    }
    LeaveCriticalSection(&m_CrSec);
    return hr;
}
/*
@enum DMUS_TRACKF_FLAGS | Sent in <om IDirectMusicTrack.Play>'s dwFlags parameter.
@emem DMUS_TRACKF_SEEK | Play was called on account of seeking, meaning that mtStart is
not necessarily the same as the previous Play call's mtEnd.
@emem DMUS_TRACKF_LOOP | Play was called on account of a loop, e.g. repeat.
@emem DMUS_TRACKF_START | This is the first call to Play. DMUS_TRACKF_SEEK may also be set if the
Track is not playing from the beginning.
@emem DMUS_TRACKF_FLUSH | The call to Play is on account of a flush or invalidate, that
requires the Track to replay something it played previously. In this case, DMUS_TRACKF_SEEK
will be set as well.

  @method HRESULT | IDirectMusicTrack | Play |
  Play method.
  @rvalue DMUS_DMUS_S_END | The Track is done playing.
  @rvalue S_OK | Success.
  @rvalue E_POINTER | <p pStateData>, <p pPerf>, or <p pSegSt> is NULL or invalid.
*/
STDMETHODIMP CWavTrack::Play(
    void *pStateData,   // @parm State data pointer, from <om .InitPlay>.
    MUSIC_TIME mtStart, // @parm The start time to play.
    MUSIC_TIME mtEnd,   // @parm The end time to play.
    MUSIC_TIME mtOffset,// @parm The offset to add to all messages sent to
                        // <om IDirectMusicPerformance.SendPMsg>.
    DWORD dwFlags,      // @parm Flags that indicate the state of this call.
                        // See <t DMUS_TRACKF_FLAGS>. If dwFlags == 0, this is a
                        // normal Play call continuing playback from the previous
                        // Play call.
    IDirectMusicPerformance* pPerf, // @parm The <i IDirectMusicPerformance>, used to
                        // call <om IDirectMusicPerformance.AllocPMsg>,
                        // <om IDirectMusicPerformance.SendPMsg>, etc.
    IDirectMusicSegmentState* pSegSt,   // @parm The <i IDirectMusicSegmentState> this
                        // track belongs to. QueryInterface() can be called on this to
                        // obtain the SegmentState's <i IDirectMusicGraph> in order to
                        // call <om IDirectMusicGraph.StampPMsg>, for instance.
    DWORD dwVirtualID   // @parm This track's virtual track id, which must be set
                        // on any <t DMUS_PMSG>'s m_dwVirtualTrackID member that
                        // will be queued to <om IDirectMusicPerformance.SendPMsg>.
    )
{
    V_INAME(IDirectMusicTrack::Play);
    V_BUFPTR_WRITE( pStateData, sizeof(WaveStateData));
    V_INTERFACE(pPerf);
    V_INTERFACE(pSegSt);

    EnterCriticalSection(&m_CrSec);
    HRESULT hr = Play(pStateData, mtStart, mtEnd, mtOffset, dwFlags, pPerf, pSegSt, dwVirtualID, FALSE);
    LeaveCriticalSection(&m_CrSec);
    return hr;
}

/*  The Play method handles both music time and clock time versions, as determined by
    fClockTime. If running in clock time, rtOffset is used to identify the start time
    of the segment. Otherwise, mtOffset. The mtStart and mtEnd parameters are in MUSIC_TIME units
    or milliseconds, depending on which mode.
*/

// BUGBUG go through all the times and make sure music time/reference time stuff
// all makes sense

HRESULT CWavTrack::Play(
    void *pStateData,
    REFERENCE_TIME rtStart,
    REFERENCE_TIME rtEnd,
    //MUSIC_TIME mtOffset,
    REFERENCE_TIME rtOffset,
    DWORD dwFlags,
    IDirectMusicPerformance* pPerf,
    IDirectMusicSegmentState* pSegSt,
    DWORD dwVirtualID,
    BOOL fClockTime)
{
    if (dwFlags & DMUS_TRACKF_PLAY_OFF)
    {
        return S_OK;
    }
    HRESULT hr = S_OK;
    IDirectMusicGraph* pGraph = NULL;
    WaveStateData* pSD = (WaveStateData*)pStateData;
    if ( dwFlags & DMUS_TRACKF_LOOP )
    {
        REFERENCE_TIME rtPerfStart = rtStart + rtOffset;
        MUSIC_TIME mtPerfStart = 0;
        if (fClockTime)
        {
            pPerf->ReferenceToMusicTime(rtPerfStart, &mtPerfStart);
        }
        else
        {
            mtPerfStart = (MUSIC_TIME)rtPerfStart;
        }
        CPerformance* pCPerf = NULL;
        if (SUCCEEDED(pPerf->QueryInterface(IID_CPerformance, (void**)&pCPerf)))
        {
            pCPerf->FlushVirtualTrack(dwVirtualID, mtPerfStart, FLUSH_ON_REPEAT);
            pCPerf->Release();
        }
        pSD->m_fLoop = true;
    }
    BOOL fSeek = (dwFlags & DMUS_TRACKF_SEEK) ? TRUE : FALSE;
    if ( dwFlags & (DMUS_TRACKF_START | DMUS_TRACKF_LOOP) )
    {
        pSD->rtNextVariation = 0;
    }

    // if we're sync'ing variations to the pattern track, get the current variations
    if ( (m_dwTrackFlags & DMUS_WAVETRACKF_SYNC_VAR) &&
         (!pSD->rtNextVariation || (rtStart <= pSD->rtNextVariation && rtEnd > pSD->rtNextVariation)) )
    {
        hr = SyncVariations(pPerf, pSD, rtStart, rtOffset, fClockTime);
    }
    else if (dwFlags & (DMUS_TRACKF_START | DMUS_TRACKF_LOOP))
    {
        hr = ComputeVariations(pSD);
    }

    if( dwFlags & (DMUS_TRACKF_SEEK | DMUS_TRACKF_FLUSH | DMUS_TRACKF_DIRTY |
        DMUS_TRACKF_LOOP) )
    {
        // need to reset the PChannel Map in case of any of these flags.
        m_PChMap.Reset();
    }
    if( pSD->dwValidate != m_dwValidate )
    {
        if (pSD->m_apVoice)
        {
            for (DWORD dw = 0; dw < pSD->m_dwVoices; dw++)
			{
				if (pSD->m_apVoice[dw])
				{
					pSD->m_apVoice[dw]->Release();
				}
            }
            delete [] pSD->m_apVoice;
        }
        pSD->m_apVoice = new IDirectMusicVoiceP*[m_dwWaveItems];
        if (!pSD->m_apVoice)
        {
            return E_OUTOFMEMORY;
        }
        else
        {
            for (DWORD dw = 0; dw < m_dwWaveItems; dw++)
            {
                pSD->m_apVoice[dw] = NULL;
            }
        }
        pSD->m_dwVoices = m_dwWaveItems;
        SetUpStateCurrentPointers(pSD);
        fSeek = TRUE;
    }

    if( fSeek )
    {
        if( dwFlags & (DMUS_TRACKF_START | DMUS_TRACKF_LOOP) )
        {
            Seek( pSegSt, pPerf, dwVirtualID, pSD, rtStart, TRUE, rtOffset, fClockTime );
        }
        else
        {
            Seek( pSegSt, pPerf, dwVirtualID, pSD, rtStart, FALSE, rtOffset, fClockTime );
        }
    }

    if( FAILED( pSegSt->QueryInterface( IID_IDirectMusicGraph,
        (void**)&pGraph )))
    {
        pGraph = NULL;
    }

    DWORD dwIndex;
    DWORD dwPChannel;
    DWORD dwMutePChannel;
    BOOL fMute;

    TListItem<WavePart>* pPart = m_WavePartList.GetHead();
    for( dwIndex = 0; dwIndex < m_dwPChannelsUsed; dwIndex++ )
    {
        long lPartVolume = 0;
        if( pPart )
        {
            WavePart& rPart = pPart->GetItemValue();
            dwPChannel = rPart.m_dwPChannel;
            lPartVolume = rPart.m_lVolume;
        }
        if( pSD->apCurrentWave )
        {
            for( ; pSD->apCurrentWave[dwIndex];
                pSD->apCurrentWave[dwIndex] = pSD->apCurrentWave[dwIndex]->GetNext() )
            {
                DWORD dwItemVariations = 0;
                WaveItem& rItem = pSD->apCurrentWave[dwIndex]->GetItemValue();
                REFERENCE_TIME rtTime = fClockTime ? rItem.m_rtTimePhysical : rItem.m_mtTimeLogical;
                if( rtTime >= rtEnd )
                {
                    break;
                }
                if (pPart)
                {
                    dwItemVariations = pSD->Variations(pPart->GetItemValue(), dwIndex) & rItem.m_dwVariations;
                }
                MUSIC_TIME mtTime = 0;
                MUSIC_TIME mtOffset = 0;
                if (fClockTime)
                {
                    MUSIC_TIME mtPerfTime = 0;
                    pPerf->ReferenceToMusicTime(rtOffset, &mtOffset);
                    pPerf->ReferenceToMusicTime(rItem.m_rtTimePhysical + rtOffset, &mtPerfTime);
                    mtTime = mtPerfTime - mtOffset;
                }
                else
                {
                    mtTime = rItem.m_mtTimeLogical;
                    mtOffset = (MUSIC_TIME)rtOffset;
                }
                m_PChMap.GetInfo( dwPChannel, mtTime, mtOffset, pSD->dwGroupBits,
                    pPerf, &fMute, &dwMutePChannel, FALSE );
                if( !fMute && dwItemVariations )
                {
                    DWORD dwGroup = 0;
                    DWORD dwMChannel = 0;
                    IDirectMusicPort* pPort = NULL;
                    hr = rItem.PChannelInfo(pPerf, pSD->m_pAudioPath, dwMutePChannel, &pPort, &dwGroup, &dwMChannel);
                    if (SUCCEEDED(hr) && pPort)
                    {
                        IDirectMusicPortP* pPortP = NULL;
                        hr = pPort->QueryInterface(IID_IDirectMusicPortP, (void**) &pPortP);
                        if (SUCCEEDED(hr))
                        {
                            EnterCriticalSection(&WaveItem::st_WaveListCritSect);
                            TListItem<TaggedWave>* pDLWave = rItem.st_WaveList.GetHead();
                            for (; pDLWave; pDLWave = pDLWave->GetNext())
                            {
                                TaggedWave& rDLWave = pDLWave->GetItemValue();
                                if (rDLWave.m_pWave == rItem.m_pWave &&
                                    rDLWave.m_pPerformance == pPerf &&
                                    rDLWave.m_pPort == pPortP &&
                                    ( !rItem.m_fIsStreaming ||
                                      rDLWave.m_pDownloadedWave == rItem.m_pDownloadedWave ) )
                                {
                                    break;
                                }
                            }
                            if (pDLWave)
                            {
                                REFERENCE_TIME rtDurationMs = 0;
                                REFERENCE_TIME rtStartOffset = rItem.m_rtStartOffset;
                                REFERENCE_TIME rtDuration = rItem.m_rtDuration;
                                DMUS_WAVE_PMSG* pWave;
                                if( SUCCEEDED( pPerf->AllocPMsg( sizeof(DMUS_WAVE_PMSG),
                                    (DMUS_PMSG**)&pWave )))
                                {
                                    pWave->dwType = DMUS_PMSGT_WAVE;
                                    pWave->dwPChannel = dwMutePChannel;
                                    pWave->dwVirtualTrackID = dwVirtualID;
                                    pWave->dwGroupID = pSD->dwGroupBits;
                                    if (fClockTime)
                                    {
                                        REFERENCE_TIME rtPlay = rItem.m_rtTimePhysical;
                                        rtDuration -= ConvertOffset(rtStartOffset, -rItem.m_lPitch);
                                        if (rtPlay < rtStart)
                                        {
                                            REFERENCE_TIME rtPlayOffset = ConvertOffset(rtStart - rtPlay, rItem.m_lPitch);
                                            rtStartOffset += rtPlayOffset;
                                            rtDuration -= (rtStart - rtPlay);
                                            rtPlay = rtStart;
                                        }
                                        pWave->rtTime = rtPlay + rtOffset;
                                        pWave->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME;
                                        pWave->lOffset = 0;
                                        rtDurationMs = rtDuration / REF_PER_MIL;
                                    }
                                    else
                                    {
                                        REFERENCE_TIME rtPlay = 0;
                                        MUSIC_TIME mtPlay = (MUSIC_TIME)rItem.m_rtTimePhysical;
                                        pPerf->MusicToReferenceTime(mtPlay + (MUSIC_TIME)rtOffset, &rtPlay);
                                        MUSIC_TIME mtRealPlay = 0;
                                        pPerf->ReferenceToMusicTime(rtPlay + rtStartOffset, &mtRealPlay);
                                        if (mtRealPlay > rtOffset + mtPlay)
                                        {
                                            rtDuration -= ConvertOffset(mtRealPlay - (rtOffset + mtPlay), -rItem.m_lPitch);

                                        }
                                        if (mtPlay < (MUSIC_TIME) rtStart)
                                        {
                                            // Calculate distance from wave start to segment start, but begin
                                            // the calculation at segment start to avoid strangeness
                                            // when attempting to do conversions at times earlier than
                                            // segment start.
                                            REFERENCE_TIME rtRefStartPlus = 0;
                                            REFERENCE_TIME rtRefPlayPlus = 0;
                                            MUSIC_TIME mtNewDuration = 0;
                                            pPerf->MusicToReferenceTime((MUSIC_TIME)rtStart + (MUSIC_TIME)rtStart + (MUSIC_TIME)rtOffset, &rtRefStartPlus);
                                            pPerf->MusicToReferenceTime((MUSIC_TIME)rtStart + mtPlay + (MUSIC_TIME)rtOffset, &rtRefPlayPlus);
                                            rtStartOffset += ConvertOffset((rtRefStartPlus - rtRefPlayPlus), rItem.m_lPitch);
                                            mtPlay = (MUSIC_TIME) rtStart;
                                            REFERENCE_TIME rtRealDuration = 0;
                                            pPerf->MusicToReferenceTime((MUSIC_TIME)rtStart + (MUSIC_TIME)rItem.m_rtDuration + (MUSIC_TIME)rtOffset, &rtRealDuration);
                                            pPerf->ReferenceToMusicTime(rtRealDuration - (ConvertOffset(rItem.m_rtStartOffset, -rItem.m_lPitch) + (rtRefStartPlus - rtRefPlayPlus)), &mtNewDuration);
                                            rtDuration = (REFERENCE_TIME)mtNewDuration - (rtStart + rtOffset);
                                        }
                                        pWave->mtTime = mtPlay + (MUSIC_TIME)rtOffset;
                                        pWave->dwFlags = DMUS_PMSGF_MUSICTIME;
                                        pWave->lOffset = (MUSIC_TIME)rItem.m_rtTimePhysical - rItem.m_mtTimeLogical;
                                        REFERENCE_TIME rtZero = 0;
                                        pPerf->MusicToReferenceTime((MUSIC_TIME)rtOffset + mtPlay, &rtZero);
                                        pPerf->MusicToReferenceTime((MUSIC_TIME)(rtDuration + rtOffset) + mtPlay, &rtDurationMs);
                                        rtDurationMs -= rtZero;
                                        rtDurationMs /= REF_PER_MIL;
                                    }
                                    // If we're either past the end of the wave, or we're within
                                    // 150 ms of the end of a looping wave (and we've just started
                                    // playback), or if this is a loop start and the wave should not 
                                    // play on loop, don't play the wave.
                                    if ( rtDurationMs <= 0 ||
                                         (rItem.m_dwLoopEnd && (dwFlags & DMUS_TRACKF_START) && rtDurationMs < 150) ||
                                         (rItem.m_dwFlags & DMUS_WAVEF_IGNORELOOPS) && (dwFlags & DMUS_TRACKF_LOOP))
                                    {
                                        pPerf->FreePMsg((DMUS_PMSG*)pWave);
                                    }
                                    else
                                    {
                                        pWave->rtStartOffset = rtStartOffset;
                                        pWave->rtDuration = rtDuration;
                                        pWave->lVolume = rItem.m_lVolume + lPartVolume + m_lVolume;
                                        if (rItem.m_wVolumeRange)
                                        {
                                            long lRand = rand() % (2 * rItem.m_wVolumeRange);
                                            lRand -= rItem.m_wVolumeRange;
                                            pWave->lVolume += lRand;
                                        }
                                        pWave->lPitch = rItem.m_lPitch;
                                        if (rItem.m_wPitchRange)
                                        {
                                            long lRand = rand() % (2 * rItem.m_wPitchRange);
                                            lRand -= rItem.m_wPitchRange;
                                            pWave->lPitch += lRand;
                                        }

                                        pWave->bFlags = (BYTE)(rItem.m_dwFlags & 0xff);
                                        IDirectMusicVoiceP *pVoice = NULL;
                                        if (rItem.m_dwVoiceIndex == 0xffffffff)
                                        {
                                            hr = DMUS_E_NOT_INIT;
                                            TraceI(0, "Voice index not initialized!\n");
                                        }
                                        else
                                        {
                                            if ( pSD->m_fLoop ||
                                                 !pSD->m_apVoice[rItem.m_dwVoiceIndex] ||
                                                 rtStartOffset != rItem.m_rtStartOffset ||
                                                 dwMutePChannel != dwPChannel)
                                            {
                                                hr = GetDownload(
                                                    pDLWave->GetItemValue().m_pDownloadedWave,
                                                    pSD,
                                                    pPortP,
                                                    pDLWave->GetItemValue().m_pWave,
                                                    pWave->rtStartOffset,
                                                    rItem,
                                                    dwMChannel, dwGroup,
                                                    &pVoice);
                                            }
                                            else
                                            {
                                                pVoice = pSD->m_apVoice[rItem.m_dwVoiceIndex];
                                            }
                                        }
                                        if (SUCCEEDED(hr))
                                        {
                                            pWave->punkUser = (IUnknown*)pVoice;
                                            pVoice->AddRef();
                                            if( pGraph )
                                            {
                                                pGraph->StampPMsg( (DMUS_PMSG*)pWave );
                                            }
                                            hr = pPerf->SendPMsg( (DMUS_PMSG*)pWave );
                                        }
                                        if(FAILED(hr))
                                        {
                                            pPerf->FreePMsg((DMUS_PMSG*)pWave);
                                        }
                                    }
                                }
                            }
                            LeaveCriticalSection(&WaveItem::st_WaveListCritSect);

                            pPortP->Release();
                        }
                        pPort->Release();
                    }
                    else if (SUCCEEDED(hr) && !pPort)
                    {
                        Trace(1, "Error: the performance was unable to find a port for voice allocation.\n");
                        hr = DMUS_E_NOT_FOUND;
                    }
                }
            }
        }
        if( pPart )
        {
            pPart = pPart->GetNext();
        }
    }

    if( pGraph )
    {
        pGraph->Release();
    }
    return hr;
}

// Seek() - set all pSD's pointers to the correct location. If fGetPrevious is set,
// it's legal to start in the middle of a wave.
HRESULT CWavTrack::Seek( IDirectMusicSegmentState* pSegSt,
    IDirectMusicPerformance* pPerf, DWORD dwVirtualID,
    WaveStateData* pSD, REFERENCE_TIME rtTime, BOOL fGetPrevious,
    REFERENCE_TIME rtOffset, BOOL fClockTime)
{
    DWORD dwIndex;
    TListItem<WavePart>* pPart;
    TListItem<WaveItem>* pWaveItem;

    // in the case of fGetPrevious (which means DMUS_SEGF_START/LOOP was
    // set in Play() ) we want to reset all lists to the beginning regardless of time.
    if( fGetPrevious )//&& ( rtTime == 0 ) )
    {
        pPart = m_WavePartList.GetHead();
        for( dwIndex = 0; dwIndex < m_dwPChannelsUsed; dwIndex++ )
        {
            if( pPart )
            {
                pWaveItem = pPart->GetItemValue().m_WaveItemList.GetHead();
                if( pWaveItem && pSD->apCurrentWave )
                {
                    pSD->apCurrentWave[dwIndex] = pWaveItem;
                }
                pPart = pPart->GetNext();
            }
            else
            {
                break;
            }
        }
        return S_OK;
    }

    pPart = m_WavePartList.GetHead();
    for( dwIndex = 0; dwIndex < m_dwPChannelsUsed; dwIndex++ )
    {
        if( pPart )
        {
            // scan the wave event list in this part.
            for( pWaveItem = pPart->GetItemValue().m_WaveItemList.GetHead(); pWaveItem; pWaveItem = pWaveItem->GetNext() )
            {
                WaveItem& rWaveItem = pWaveItem->GetItemValue();
                REFERENCE_TIME rtWaveTime = fClockTime ? rWaveItem.m_rtTimePhysical : rWaveItem.m_mtTimeLogical;
                if( rtWaveTime >= rtTime )
                {
                    break;
                }
                if( !fGetPrevious )
                {
                    // if we don't care about previous events, just continue
                    continue;
                }
            }
            if( pSD->apCurrentWave )
            {
                pSD->apCurrentWave[dwIndex] = pWaveItem;
            }
            pPart = pPart->GetNext();
        }
    }

    return S_OK;
}

/*
  @method HRESULT | IDirectMusicTrack | GetParam |
  Retrieves data from a Track.

  @rvalue S_OK | Got the data ok.
  @rvalue E_NOTIMPL | Not implemented.
*/
STDMETHODIMP CWavTrack::GetParam(
    REFGUID rguidType,  // @parm The type of data to obtain.
    MUSIC_TIME mtTime,  // @parm The time, in Track time, to obtain the data.
    MUSIC_TIME* pmtNext,// @parm Returns the Track time until which the data is valid. <p pmtNext>
                        // may be NULL. If this returns a value of 0, it means that this
                        // data will either be always valid, or it is unknown when it will
                        // become invalid.
    void *pData)        // @parm The struture in which to return the data. Each
                        // <p pGuidType> identifies a particular structure of a
                        // particular size. It is important that this field contain
                        // the correct structure of the correct size. Otherwise,
                        // fatal results can occur.
{
    return E_NOTIMPL;
}

/*
  @method HRESULT | IDirectMusicTrack | SetParam |
  Sets data on a Track.

  @rvalue S_OK | Set the data ok.
  @rvalue E_NOTIMPL | Not implemented.
*/
STDMETHODIMP CWavTrack::SetParam(
    REFGUID rguidType,  // @parm The type of data to set.
    MUSIC_TIME mtTime,  // @parm The time, in Track time, to set the data.
    void *pData)        // @parm The struture containing the data to set. Each
                        // <p pGuidType> identifies a particular structure of a
                        // particular size. It is important that this field contain
                        // the correct structure of the correct size. Otherwise,
                        // fatal results can occur.
{
    return SetParamEx(rguidType, mtTime, pData, NULL, 0);
}

STDMETHODIMP CWavTrack::GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags)
{
    return E_NOTIMPL;
}

STDMETHODIMP CWavTrack::SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,
                                      void* pParam, void * pStateData, DWORD dwFlags)
{
    V_INAME(CBandTrk::SetParamEx);
    V_REFGUID(rguidType);

    HRESULT hr = S_OK;

    if((pParam == NULL) &&
       (rguidType != GUID_Enable_Auto_Download) &&
       (rguidType != GUID_Disable_Auto_Download))
    {
        return E_POINTER;
    }

    EnterCriticalSection(&m_CrSec);

    if(rguidType == GUID_Download)
    {
        IDirectMusicPerformance* pPerf = (IDirectMusicPerformance*)pParam;
        V_INTERFACE(pPerf);

        HRESULT hrFail = S_OK;
        DWORD dwSuccess = 0;

        TListItem<WavePart>* pPart = m_WavePartList.GetHead();
        for(; pPart; pPart = pPart->GetNext())
        {
            if ( FAILED(hr = pPart->GetItemValue().Download(pPerf, NULL, NULL, GUID_NULL)) )
            {
                hrFail = hr;
            }
            else
            {
                dwSuccess++;
            }
        }
        // If we had a failure, return it if we had no successes.
        // Else return S_FALSE for partial success.
        if (FAILED(hrFail) && dwSuccess)
        {
            Trace(1,"Error: Wavetrack download was only partially successful. Some sounds will not play.\n");
            hr = S_FALSE;
        }
#ifdef DBG
        if (FAILED(hr))
        {
            Trace(1, "Error: Wavetrack failed download.\n");
        }
#endif
    }
    else if(rguidType == GUID_DownloadToAudioPath)
    {
        IUnknown* pUnknown = (IUnknown*)pParam;
        V_INTERFACE(pUnknown);

        HRESULT hrFail = S_OK;
        DWORD dwSuccess = 0;

        IDirectMusicAudioPath* pPath = NULL;
        IDirectMusicPerformance *pPerf = NULL;
        hr = pUnknown->QueryInterface(IID_IDirectMusicAudioPath,(void **)&pPath);
        if (SUCCEEDED(hr))
        {
            hr = pPath->GetObjectInPath(0,DMUS_PATH_PERFORMANCE,0,CLSID_DirectMusicPerformance,0,IID_IDirectMusicPerformance,(void **)&pPerf);
        }
        else
        {
            hr = pUnknown->QueryInterface(IID_IDirectMusicPerformance,(void **)&pPerf);
        }
        if (SUCCEEDED(hr))
        {
            TListItem<WavePart>* pPart = m_WavePartList.GetHead();
            for(; pPart; pPart = pPart->GetNext())
            {
                if ( FAILED(hr = pPart->GetItemValue().Download(pPerf, pPath, NULL, GUID_NULL)) )
                {
                    hrFail = hr;
                }
                else
                {
                    dwSuccess++;
                }
            }
        }
        // If we had a failure, return it if we had no successes.
        // Else return S_FALSE for partial success.
        if (FAILED(hrFail) && dwSuccess)
        {
            Trace(1,"Error: Wavetrack download was only partially successful. Some sounds will not play.\n");
            hr = S_FALSE;
        }
#ifdef DBG
        if (FAILED(hr))
        {
            Trace(1, "Error: Wavetrack failed download.\n");
        }
#endif
        if (pPath) pPath->Release();
        if (pPerf) pPerf->Release();
    }
    else if(rguidType == GUID_Unload)
    {
        IDirectMusicPerformance* pPerf = (IDirectMusicPerformance*)pParam;
        V_INTERFACE(pPerf);
        TListItem<WavePart>* pPart = m_WavePartList.GetHead();
        for(; pPart; pPart = pPart->GetNext())
        {
            pPart->GetItemValue().Unload(pPerf, NULL, NULL);
        }
    }
    else if(rguidType == GUID_UnloadFromAudioPath)
    {
        IUnknown* pUnknown = (IUnknown*)pParam;
        V_INTERFACE(pUnknown);

        IDirectMusicAudioPath* pPath = NULL;
        IDirectMusicPerformance *pPerf = NULL;
        hr = pUnknown->QueryInterface(IID_IDirectMusicAudioPath,(void **)&pPath);
        if (SUCCEEDED(hr))
        {
            hr = pPath->GetObjectInPath(0,DMUS_PATH_PERFORMANCE,0,CLSID_DirectMusicPerformance,0,IID_IDirectMusicPerformance,(void **)&pPerf);
        }
        else
        {
            hr = pUnknown->QueryInterface(IID_IDirectMusicPerformance,(void **)&pPerf);
        }
        if (SUCCEEDED(hr))
        {
            TListItem<WavePart>* pPart = m_WavePartList.GetHead();
            for(; pPart; pPart = pPart->GetNext())
            {
                pPart->GetItemValue().Unload(pPerf, pPath, NULL);
            }
        }
        if (pPath) pPath->Release();
        if (pPerf) pPerf->Release();
    }
    else if(rguidType == GUID_Enable_Auto_Download)
    {
        m_fAutoDownload = TRUE;
        m_fLockAutoDownload = TRUE;
    }
    else if(rguidType == GUID_Disable_Auto_Download)
    {
        m_fAutoDownload = FALSE;
        m_fLockAutoDownload = TRUE;
    }
    else
    {
        hr = DMUS_E_TYPE_UNSUPPORTED;
    }

    LeaveCriticalSection(&m_CrSec);

    return hr;
}

/*
  @method HRESULT | IDirectMusicTrack | AddNotificationType |
  Similar to and called from <om IDirectMusicSegment.AddNotificationType>. This
  gives the track a chance to respond to notifications.

  @rvalue E_NOTIMPL | The track doesn't support notifications.
  @rvalue S_OK | Success.
  @rvalue S_FALSE | The track doesn't support the requested notification type.
*/
HRESULT STDMETHODCALLTYPE CWavTrack::AddNotificationType(
     REFGUID rguidNotification) // @parm The notification guid to add.
{
    return E_NOTIMPL;
}

/*
  @method HRESULT | IDirectMusicTrack | RemoveNotificationType |
  Similar to and called from <om IDirectMusicSegment.RemoveNotificationType>. This
  gives the track a chance to remove notifications.

  @rvalue E_NOTIMPL | The track doesn't support notifications.
  @rvalue S_OK | Success.
  @rvalue S_FALSE | The track doesn't support the requested notification type.
*/
HRESULT STDMETHODCALLTYPE CWavTrack::RemoveNotificationType(
     REFGUID rguidNotification) // @parm The notification guid to remove.
{
    return E_NOTIMPL;
}

/*
  @method HRESULT | IDirectMusicTrack | Clone |
  Creates a copy of the Track.

  @rvalue S_OK | Success.
  @rvalue E_OUTOFMEMORY | Out of memory.
  @rvalue E_POINTER | <p ppTrack> is NULL or invalid.

  @xref <om IDirectMusicSegment.Clone>
*/
HRESULT STDMETHODCALLTYPE CWavTrack::Clone(
    MUSIC_TIME mtStart, // @parm The start of the part to clone. It should be 0 or greater,
                        // and less than the length of the Track.
    MUSIC_TIME mtEnd,   // @parm The end of the part to clone. It should be greater than
                        // <p mtStart> and less than the length of the Track.
    IDirectMusicTrack** ppTrack)    // @parm Returns the cloned Track.
{
    V_INAME(IDirectMusicTrack::Clone);
    V_PTRPTR_WRITE(ppTrack);

    HRESULT hr = S_OK;

    if((mtStart < 0 )||(mtStart > mtEnd))
    {
        Trace(1,"Error: Wave track clone failed because of invalid start or end time.\n");
        return E_INVALIDARG;
    }

    EnterCriticalSection(&m_CrSec);
    CWavTrack *pDM;

    try
    {
        pDM = new CWavTrack(*this, mtStart, mtEnd);
    }
    catch( ... )
    {
        pDM = NULL;
    }

    if (pDM == NULL)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        hr = pDM->InitTrack(m_dwPChannelsUsed);
        if (SUCCEEDED(hr))
        {
            hr = pDM->QueryInterface(IID_IDirectMusicTrack, (void**)ppTrack);
        }
        pDM->Release();
    }

    LeaveCriticalSection(&m_CrSec);
    return hr;
}


STDMETHODIMP CWavTrack::Compose(
        IUnknown* pContext,
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack)
{
    return E_NOTIMPL;
}

STDMETHODIMP CWavTrack::Join(
        IDirectMusicTrack* pNewTrack,
        MUSIC_TIME mtJoin,
        IUnknown* pContext,
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack)
{
    return E_NOTIMPL;
}

HRESULT CWavTrack::ComputeVariations(WaveStateData* pSD)
{
    if (!pSD)
    {
        Trace(1,"Error: Unable to play wave track - not initialized.\n");
        return DMUS_E_NOT_INIT;
    }
    HRESULT hr = S_OK;
    // First, initialize the array of variation groups.
    for (int i = 0; i < MAX_WAVE_VARIATION_LOCKS; i++)
    {
        pSD->adwVariationGroups[i] = 0;
    }
    // Now, compute the variations for each part.
    TListItem<WavePart>* pScan = m_WavePartList.GetHead();
    for (i = 0; pScan && i < (int)m_dwPChannelsUsed; pScan = pScan->GetNext(), i++)
    {
        hr = ComputeVariation(i, pScan->GetItemValue(), pSD);
        if (FAILED(hr))
        {
            break;
        }
    }
    return hr;
}

HRESULT CWavTrack::SyncVariations(IDirectMusicPerformance* pPerf,
                                  WaveStateData* pSD,
                                  REFERENCE_TIME rtStart,
                                  REFERENCE_TIME rtOffset,
                                  BOOL fClockTime)
{
    if (!pSD)
    {
        Trace(1,"Error: Unable to play wave track - not initialized.\n");
        return DMUS_E_NOT_INIT;
    }
    HRESULT hr = S_OK;
    // Get the current variations
    DMUS_VARIATIONS_PARAM Variations;
    memset(&Variations, 0, sizeof(Variations));
    // Call GetParam for variations to sync to
    MUSIC_TIME mtNow = 0;
    MUSIC_TIME mtNext = 0;
    REFERENCE_TIME rtNext = 0;
    if (fClockTime)
    {
        pPerf->ReferenceToMusicTime(pSD->rtNextVariation + rtOffset, &mtNow);
        hr = pPerf->GetParam(GUID_Variations, 0xffffffff, DMUS_SEG_ANYTRACK, mtNow, &mtNext, (void*) &Variations);
        if (SUCCEEDED(hr) &&
            SUCCEEDED(pPerf->MusicToReferenceTime(mtNext + mtNow, &rtNext)) )
        {
            pSD->rtNextVariation += rtNext;
        }
    }
    else
    {
        mtNow = (MUSIC_TIME) (pSD->rtNextVariation + rtOffset);
        hr = pPerf->GetParam(GUID_Variations, 0xffffffff, DMUS_SEG_ANYTRACK, mtNow, &mtNext, (void*) &Variations);
        if (SUCCEEDED(hr))
        {
            pSD->rtNextVariation += mtNext;
        }
    }
    if (SUCCEEDED(hr))
    {
        // Initialize the array of variation groups.
        for (int nGroup = 0; nGroup < MAX_WAVE_VARIATION_LOCKS; nGroup++)
        {
            pSD->adwVariationGroups[nGroup] = 0;
        }
        TListItem<WavePart>* pScan = m_WavePartList.GetHead();
        for (DWORD dwPart = 0; pScan && dwPart < m_dwPChannelsUsed; pScan = pScan->GetNext(), dwPart++)
        {
            WavePart& rPart = pScan->GetItemValue();
            for (DWORD dwSyncPart = 0; dwSyncPart < Variations.dwPChannelsUsed; dwSyncPart++)
            {
                if (rPart.m_dwPChannel == Variations.padwPChannels[dwSyncPart])
                {
                    pSD->pdwVariations[dwPart] = Variations.padwVariations[dwSyncPart];
                    break;
                }
            }
            if (dwSyncPart == Variations.dwPChannelsUsed) // no part to sync to
            {
                hr = ComputeVariation((int)dwPart, rPart, pSD);
                if (FAILED(hr))
                {
                    break;
                }
            }
        }
    }
    else
    {
        return ComputeVariations(pSD);
    }
    return hr;
}

HRESULT CWavTrack::ComputeVariation(int nPart, WavePart& rWavePart, WaveStateData* pSD)
{
    BYTE bLockID = (BYTE)rWavePart.m_dwLockToPart;
    if (bLockID && pSD->adwVariationGroups[bLockID - 1] != 0)
    {
        pSD->pdwVariations[nPart] = pSD->adwVariationGroups[bLockID - 1];
    }
    else if (!rWavePart.m_dwVariations)
    {
        // No variations; clear the flags for this part.
        pSD->pdwVariations[nPart] = 0;
        pSD->pdwRemoveVariations[nPart] = 0;
    }
    else
    {
        // First, collect all matches.
        DWORD dwMatches = rWavePart.m_dwVariations;
        int nMatchCount = 0;
        for (int n = 0; n < 32; n++)
        {
            if (dwMatches & (1 << n)) nMatchCount++;
        }
        // Now, select a variation based on the part's variation mode.
        BYTE bMode = (BYTE)(rWavePart.m_dwPChannelFlags & 0xf);
        DWORD dwTemp = dwMatches;
        if ( bMode == DMUS_VARIATIONT_RANDOM_ROW )
        {
            dwTemp &= ~pSD->pdwRemoveVariations[nPart];
            if (!dwTemp)
            {
                // start counting all over, but don't repeat this one
                pSD->pdwRemoveVariations[nPart] = 0;
                dwTemp = dwMatches;
                bMode = DMUS_VARIATIONT_NO_REPEAT;
            }
        }
        if ( bMode == DMUS_VARIATIONT_NO_REPEAT && pSD->pdwVariations[nPart] != 0 )
        {
            dwTemp &= ~pSD->pdwVariations[nPart];
        }
        if (dwTemp != dwMatches)
        {
            if (dwTemp) // otherwise, keep what we had
            {
                for (int i = 0; i < 32; i++)
                {
                    if ( ((1 << i) & dwMatches) && !((1 << i) & dwTemp) )
                    {
                        nMatchCount--;
                    }
                }
                dwMatches = dwTemp;
            }
        }
        int nV = 0;
        switch (bMode)
        {
        case DMUS_VARIATIONT_RANDOM_ROW:
        case DMUS_VARIATIONT_NO_REPEAT:
        case DMUS_VARIATIONT_RANDOM:
            {
                short nChoice = (short) (rand() % nMatchCount);
                short nCount = 0;
                for (nV = 0; nV < 32; nV++)
                {
                    if ((1 << nV) & dwMatches)
                    {
                        if (nChoice == nCount)
                            break;
                        nCount++;
                    }
                }
                pSD->pdwVariations[nPart] = 1 << nV;
                if (bMode == DMUS_VARIATIONT_RANDOM_ROW)
                {
                    pSD->pdwRemoveVariations[nPart] |= pSD->pdwVariations[nPart];
                }
                TraceI(3, "New variation: %d\n", nV);
                break;
            }
        case DMUS_VARIATIONT_RANDOM_START:
            // Choose an initial value
            if (pSD->pdwVariations[nPart] == 0)
            {
                int nStart = 0;
                nStart = (BYTE) (rand() % nMatchCount);
                int nCount = 0;
                for (nV = 0; nV < 32; nV++)
                {
                    if ((1 << nV) & dwMatches)
                    {
                        if (nStart == nCount)
                            break;
                        nCount++;
                    }
                }
                pSD->pdwVariations[nPart] = 1 << nV;
            }
            // Now, go directly to the sequential case (no break)
        case DMUS_VARIATIONT_SEQUENTIAL:
            {
                if (!pSD->pdwVariations[nPart]) pSD->pdwVariations[nPart] = 1;
                else
                {
                    pSD->pdwVariations[nPart] <<= 1;
                    if (!pSD->pdwVariations[nPart]) pSD->pdwVariations[nPart] = 1;
                }
                while (!(pSD->pdwVariations[nPart] & dwMatches))
                {
                    pSD->pdwVariations[nPart] <<= 1;
                    if (!pSD->pdwVariations[nPart]) pSD->pdwVariations[nPart] = 1;
                }
                TraceI(3, "New variation: %d\n", pSD->pdwVariations[nPart]);
                break;
            }
        }
        // If this is a locked variation, it's the first in its group, so record it.
        if (bLockID)
        {
            pSD->adwVariationGroups[bLockID - 1] = pSD->pdwVariations[nPart];
        }
        if ( (m_dwTrackFlags & DMUS_WAVETRACKF_PERSIST_CONTROL) &&
             m_pdwVariations &&
             m_pdwRemoveVariations )
        {
            m_pdwVariations[nPart] = pSD->pdwVariations[nPart];
            m_pdwRemoveVariations[nPart] = pSD->pdwRemoveVariations[nPart];
        }
    }
    return S_OK;
}

// Sets the variations to be played for a part.  All other parts use the MOAW
// to determine which variation plays.
HRESULT CWavTrack::SetVariation(
            IDirectMusicSegmentState* pSegState, DWORD dwVariationFlags, DWORD dwPart, DWORD dwIndex)
{
    WaveStateData* pState = NULL;
    EnterCriticalSection( &m_CrSec );
    m_dwVariation = dwVariationFlags;
    m_dwPart = dwPart;
    m_dwIndex = dwIndex;
    m_fAudition = TRUE;
    TListItem<WavePart>* pScan = m_WavePartList.GetHead();
    for (; pScan; pScan = pScan->GetNext() )
    {
        WavePart& rScan = pScan->GetItemValue();
        if (rScan.m_dwPChannel == dwPart && rScan.m_dwIndex == dwIndex)
        {
            m_dwLockID = rScan.m_dwLockToPart;
        }
    }
    pState = FindState(pSegState);
    if (pState)
    {
        pState->InitVariationInfo(dwVariationFlags, dwPart, dwIndex, m_dwLockID, m_fAudition);
    }
    LeaveCriticalSection( &m_CrSec );

    return S_OK;
}

// Clears the variations to be played for a part, so that all parts use the MOAW.
HRESULT CWavTrack::ClearVariations(IDirectMusicSegmentState* pSegState)
{
    WaveStateData* pState = NULL;
    EnterCriticalSection( &m_CrSec );
    m_dwVariation = 0;
    m_dwPart = 0;
    m_dwIndex = 0;
    m_dwLockID = 0;
    m_fAudition = FALSE;
    pState = FindState(pSegState);
    if (pState)
    {
        pState->InitVariationInfo(0, 0, 0, 0, m_fAudition);
    }
    LeaveCriticalSection( &m_CrSec );

    return S_OK;
}

WaveStateData* CWavTrack::FindState(IDirectMusicSegmentState* pSegState)
{
    TListItem<StatePair>* pPair = m_StateList.GetHead();
    for (; pPair; pPair = pPair->GetNext())
    {
        if (pPair->GetItemValue().m_pSegState == pSegState)
        {
            return pPair->GetItemValue().m_pStateData;
        }
    }
    return NULL;
}

// Adds a wave at mtTime to part dwIndex on PChannel dwPChannel
// If there was already a wave there, the two will co-exist
HRESULT CWavTrack::AddWave(
        IDirectSoundWave* pWave,
        REFERENCE_TIME rtTime,
        DWORD dwPChannel,
        DWORD dwIndex,
        REFERENCE_TIME* prtLength)
{
    EnterCriticalSection(&m_CrSec);
    HRESULT hr = S_OK;
    m_lVolume = 0;
    m_dwTrackFlags = 0;
    TListItem<WavePart>* pNewPart = new TListItem<WavePart>;
    if( !pNewPart )
    {
        hr = E_OUTOFMEMORY;
        goto ON_ERROR;
    }
    hr = pNewPart->GetItemValue().Add(pWave, rtTime, dwPChannel, dwIndex, prtLength);
    if( FAILED ( hr ) )
    {
        delete pNewPart;
        goto ON_ERROR;
    }
    InsertByAscendingPChannel( pNewPart );
    m_dwWaveItems = 0;
    m_dwPChannelsUsed = m_WavePartList.GetCount();
    if (m_aPChannels)
    {
        delete [] m_aPChannels;
        m_aPChannels = NULL;
    }
    m_aPChannels = new DWORD[m_dwPChannelsUsed];
    if (m_aPChannels)
    {
        TListItem<WavePart>* pScan = m_WavePartList.GetHead();
        for (DWORD dw = 0; pScan && dw < m_dwPChannelsUsed; pScan = pScan->GetNext(), dw++)
        {
            m_aPChannels[dw] = pScan->GetItemValue().m_dwPChannel;
            TListItem<WaveItem>* pItemScan = pScan->GetItemValue().m_WaveItemList.GetHead();
            for (; pItemScan; pItemScan = pItemScan->GetNext())
            {
                pItemScan->GetItemValue().m_dwVoiceIndex = m_dwWaveItems;
                m_dwWaveItems++;
            }
        }
    }
    else
    {
        CleanUp();
        hr = E_OUTOFMEMORY;
    }
ON_ERROR:
    LeaveCriticalSection(&m_CrSec);
    return hr;
}

HRESULT CWavTrack::DownloadWave(
        IDirectSoundWave* pWave,
        IUnknown* pUnk,
        REFGUID rguidVersion)
{
    V_INAME(CWavTrack::DownloadWave);
    V_INTERFACE_OPT(pWave);
    V_INTERFACE(pUnk);
    V_REFGUID(rguidVersion);

    IDirectMusicAudioPath* pPath = NULL;
    IDirectMusicPerformance *pPerf = NULL;
    HRESULT hr = pUnk->QueryInterface(IID_IDirectMusicAudioPath,(void **)&pPath);
    if (SUCCEEDED(hr))
    {
        hr = pPath->GetObjectInPath(0,DMUS_PATH_PERFORMANCE,0,CLSID_DirectMusicPerformance,0,IID_IDirectMusicPerformance,(void **)&pPerf);
    }
    else
    {
        hr = pUnk->QueryInterface(IID_IDirectMusicPerformance,(void **)&pPerf);
    }
    if (SUCCEEDED(hr))
    {
        EnterCriticalSection(&m_CrSec);
        TListItem<WavePart>* pPart = m_WavePartList.GetHead();
        for(; pPart; pPart = pPart->GetNext())
        {
            // If not S_OK, download is only partial.
            if (pPart->GetItemValue().Download(pPerf, pPath, pWave, rguidVersion) != S_OK)
            {
                Trace(1,"Error: Wave download was only partially successful. Some sounds will not play.\n");
                hr = S_FALSE;
            }
        }
        LeaveCriticalSection(&m_CrSec);
    }
    if (pPath) pPath->Release();
    if (pPerf) pPerf->Release();
    return hr;
}

HRESULT CWavTrack::UnloadWave(
        IDirectSoundWave* pWave,
        IUnknown* pUnk)
{
    V_INAME(CWavTrack::UnloadWave);
    V_INTERFACE_OPT(pWave);
    V_INTERFACE(pUnk);

    IDirectMusicAudioPath* pPath = NULL;
    IDirectMusicPerformance *pPerf = NULL;
    HRESULT hr = pUnk->QueryInterface(IID_IDirectMusicAudioPath,(void **)&pPath);
    if (SUCCEEDED(hr))
    {
        hr = pPath->GetObjectInPath(0,DMUS_PATH_PERFORMANCE,0,CLSID_DirectMusicPerformance,0,IID_IDirectMusicPerformance,(void **)&pPerf);
    }
    else
    {
        hr = pUnk->QueryInterface(IID_IDirectMusicPerformance,(void **)&pPerf);
    }
    if (SUCCEEDED(hr))
    {
        EnterCriticalSection(&m_CrSec);
        TListItem<WavePart>* pPart = m_WavePartList.GetHead();
        for(; pPart; pPart = pPart->GetNext())
        {
            // If not S_OK, unload is only partial.
            if (pPart->GetItemValue().Unload(pPerf, pPath, pWave) != S_OK)
            {
                Trace(1,"Error: Wavetrack unload was only partially successful.\n");
                hr = S_FALSE;
            }
        }
        LeaveCriticalSection(&m_CrSec);
    }
    if (pPath) pPath->Release();
    if (pPerf) pPerf->Release();
    return hr;
}

HRESULT CWavTrack::RefreshWave(
        IDirectSoundWave* pWave,
        IUnknown* pUnk,
        DWORD dwPChannel,
        REFGUID rguidVersion)
{
    V_INAME(CWavTrack::RefreshWave);
    V_INTERFACE_OPT(pWave);
    V_INTERFACE(pUnk);

    IDirectMusicAudioPath* pPath = NULL;
    IDirectMusicPerformance *pPerf = NULL;
    HRESULT hr = pUnk->QueryInterface(IID_IDirectMusicAudioPath,(void **)&pPath);
    if (SUCCEEDED(hr))
    {
        hr = pPath->GetObjectInPath(0,DMUS_PATH_PERFORMANCE,0,CLSID_DirectMusicPerformance,0,IID_IDirectMusicPerformance,(void **)&pPerf);
    }
    else
    {
        hr = pUnk->QueryInterface(IID_IDirectMusicPerformance,(void **)&pPerf);
    }
    if (SUCCEEDED(hr))
    {
        EnterCriticalSection(&m_CrSec);
        TListItem<WavePart>* pPart = m_WavePartList.GetHead();
        for(; pPart; pPart = pPart->GetNext())
        {
            // If not S_OK, refresh is only partial.
            if (pPart->GetItemValue().Refresh(pPerf, pPath, pWave, dwPChannel, rguidVersion) != S_OK)
            {
                Trace(1,"Error: Wavetrack refresh was only partially successful. Some sounds will not play.\n");
                hr = S_FALSE;
            }
        }
        LeaveCriticalSection(&m_CrSec);
    }
    if (pPath) pPath->Release();
    if (pPerf) pPerf->Release();
    return hr;
}

HRESULT CWavTrack::FlushAllWaves()
{
    FlushWaves();
    return S_OK;
}

HRESULT CWavTrack::OnVoiceEnd(IDirectMusicVoiceP *pVoice, void *pStateData)
{
    HRESULT hr = S_OK;
    if( pStateData && pVoice )
    {
        EnterCriticalSection(&m_CrSec);

        WaveStateData* pSD = (WaveStateData*)pStateData;
        TListItem<WaveDLOnPlay>* pWDLOnPlay = pSD->m_WaveDLList.GetHead();
        TListItem<WaveDLOnPlay>* pWDLNext = NULL;
        for (; pWDLOnPlay; pWDLOnPlay = pWDLNext)
        {
            pWDLNext = pWDLOnPlay->GetNext();
            if (pWDLOnPlay->GetItemValue().m_pVoice == pVoice)
            {
                pSD->m_WaveDLList.Remove(pWDLOnPlay);
                delete pWDLOnPlay;
                break;
            }
        }

        LeaveCriticalSection(&m_CrSec);
    }
    else
    {
        hr = E_POINTER;
    }
    return hr;
}

////////////////////////////////////////////////////////////////////
// WavePart

HRESULT WavePart::Load( IDMStream* pIRiffStream, MMCKINFO* pckParent )
{
    MMCKINFO        ck;
    MMCKINFO        ckList;
    DWORD           dwByteCount;
    DWORD           dwSize;
    HRESULT         hr = E_FAIL;

    // LoadPChannel does not expect to be called twice on the same object!

    if( pIRiffStream == NULL ||  pckParent == NULL )
    {
        ASSERT( 0 );
        return DMUS_E_CANNOTREAD;
    }

    IStream* pIStream = pIRiffStream->GetStream();
    ASSERT( pIStream != NULL );

    // Load the PChannel
    while( pIRiffStream->Descend( &ck, pckParent, 0 ) == S_OK )
    {
        switch( ck.ckid )
        {
            case DMUS_FOURCC_WAVEPART_CHUNK:
            {
                DMUS_IO_WAVE_PART_HEADER iPartHeader;
                memset(&iPartHeader, 0, sizeof(iPartHeader));

                // Read in the item's header structure
                dwSize = min( sizeof( DMUS_IO_WAVE_PART_HEADER ), ck.cksize );
                hr = pIStream->Read( &iPartHeader, dwSize, &dwByteCount );

                // Handle any I/O error by returning a failure code
                if( FAILED( hr ) ||  dwByteCount != dwSize )
                {
                    Trace(1,"Error: Unable to read wave track - bad file.\n");
                    if (SUCCEEDED(hr)) hr = DMUS_E_CANNOTREAD;
                    goto ON_ERROR;
                }

                m_dwPChannel = iPartHeader.dwPChannel;
                m_dwIndex = iPartHeader.dwIndex;

                m_lVolume = iPartHeader.lVolume;
                m_dwLockToPart = iPartHeader.dwLockToPart;
                m_dwPChannelFlags = iPartHeader.dwFlags;
                m_dwVariations = iPartHeader.dwVariations;
                break;
            }

            case FOURCC_LIST:
                switch( ck.fccType )
                {
                    case DMUS_FOURCC_WAVEITEM_LIST:
                        while( pIRiffStream->Descend( &ckList, &ck, 0 ) == S_OK )
                        {
                            switch( ckList.ckid )
                            {
                                case FOURCC_LIST:
                                    switch( ckList.fccType )
                                    {
                                        case DMUS_FOURCC_WAVE_LIST:
                                        {
                                            TListItem<WaveItem>* pNewItem = new TListItem<WaveItem>;
                                            if( pNewItem == NULL )
                                            {
                                                hr = E_OUTOFMEMORY;
                                                goto ON_ERROR;
                                            }
                                            hr = pNewItem->GetItemValue().Load( pIRiffStream, &ckList );
                                            if( FAILED ( hr ) )
                                            {
                                                delete pNewItem;
                                                goto ON_ERROR;
                                            }
                                            m_WaveItemList.AddHead( pNewItem );
                                            //InsertByAscendingTime( pNewItem );
                                            break;
                                        }
                                    }
                            }

                            pIRiffStream->Ascend( &ckList, 0 );
                        }
                        break;
                }
                break;
        }

        // Ascend out of the chunk
        pIRiffStream->Ascend( &ck, 0 );
    }

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}

void WavePart::CleanUp()
{
    TListItem<WaveItem>* pScan = m_WaveItemList.GetHead();
    for (; pScan; pScan = pScan->GetNext() )
    {
        pScan->GetItemValue().CleanUp();
    }
    m_WaveItemList.CleanUp();
}

HRESULT WavePart::CopyItems( const TList<WaveItem>& rItems, MUSIC_TIME mtStart, MUSIC_TIME mtEnd )
{
    HRESULT hr = S_OK;
    CleanUp();
    TListItem<WaveItem>* pScan = rItems.GetHead();
    for (; pScan; pScan = pScan->GetNext() )
    {
        WaveItem& rScan = pScan->GetItemValue();
        if (mtStart <= (MUSIC_TIME) rScan.m_rtTimePhysical &&
            (!mtEnd || (MUSIC_TIME) rScan.m_rtTimePhysical < mtEnd) )
        {
            TListItem<WaveItem>* pNew = new TListItem<WaveItem>;
            if (pNew)
            {
                WaveItem& rNew = pNew->GetItemValue();
                rNew.m_rtTimePhysical = rScan.m_rtTimePhysical - mtStart;
                rNew.m_lVolume = rScan.m_lVolume;
                rNew.m_lPitch = rScan.m_lPitch;
                rNew.m_dwVariations = rScan.m_dwVariations;
                rNew.m_rtStartOffset = rScan.m_rtStartOffset;
                rNew.m_rtDuration = rScan.m_rtDuration;
                rNew.m_mtTimeLogical = rScan.m_mtTimeLogical;
                rNew.m_dwFlags = rScan.m_dwFlags;
                rNew.m_pWave = rScan.m_pWave;
                rNew.m_dwLoopStart = rScan.m_dwLoopStart;
                rNew.m_dwLoopEnd = rScan.m_dwLoopEnd;
                rNew.m_fIsStreaming = rScan.m_fIsStreaming;
                if (rNew.m_pWave)
                {
                    rNew.m_pWave->AddRef();
                }
                if (SUCCEEDED(hr))
                {
                    m_WaveItemList.AddHead(pNew);
                }
                else
                {
                    delete pNew;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
                break;
            }
        }
    }
    if (SUCCEEDED(hr))
    {
        m_WaveItemList.Reverse();
    }
    else
    {
        CleanUp();
    }
    return hr;
}

HRESULT WavePart::Download(IDirectMusicPerformance* pPerformance,
                           IDirectMusicAudioPath* pPath,
                           IDirectSoundWave* pWave,
                           REFGUID rguidVersion)
{
    HRESULT hr = S_OK;
    TListItem<WaveItem>* pItem = m_WaveItemList.GetHead();
    for(; pItem; pItem = pItem->GetNext())
    {
        HRESULT hrItem = pItem->GetItemValue().Download(pPerformance, pPath, m_dwPChannel, pWave, rguidVersion);
        if (hrItem != S_OK)
        {
            hr = hrItem; // if any attempt failed, return the failure (but keep downloading)
        }
    }
    return hr;
}

HRESULT WavePart::Unload(IDirectMusicPerformance* pPerformance, IDirectMusicAudioPath* pPath, IDirectSoundWave* pWave)
{
    HRESULT hr = S_OK;
    TListItem<WaveItem>* pItem = m_WaveItemList.GetHead();
    for(; pItem; pItem = pItem->GetNext())
    {
        HRESULT hrItem = pItem->GetItemValue().Unload(pPerformance, pPath, m_dwPChannel, pWave);
        if (hrItem != S_OK)
        {
            hr = hrItem; // if any attempt failed, return the failure (but keep unloading)
        }
    }
    return hr;
}

HRESULT WavePart::Refresh(IDirectMusicPerformance* pPerformance,
                          IDirectMusicAudioPath* pPath,
                          IDirectSoundWave* pWave,
                          DWORD dwPChannel,
                          REFGUID rguidVersion)
{
    HRESULT hr = S_OK;
    TListItem<WaveItem>* pItem = m_WaveItemList.GetHead();
    for(; pItem; pItem = pItem->GetNext())
    {
        HRESULT hrItem = pItem->GetItemValue().Refresh(pPerformance, pPath, m_dwPChannel, dwPChannel, pWave, rguidVersion);
        if (hrItem != S_OK)
        {
            hr = hrItem; // if any attempt failed, return the failure (but keep refreshing)
        }
    }
    return hr;
}

HRESULT WavePart::Add(
        IDirectSoundWave* pWave,
        REFERENCE_TIME rtTime,
        DWORD dwPChannel,
        DWORD dwIndex,
        REFERENCE_TIME* prtLength)
{
    HRESULT hr = S_OK;
    m_dwPChannel = dwPChannel;
    m_dwIndex = dwIndex;

    m_lVolume = 0;
    m_dwLockToPart = 0;
    m_dwPChannelFlags = 0;
    m_dwVariations = 0xffffffff;

    TListItem<WaveItem>* pNewItem = new TListItem<WaveItem>;
    if( pNewItem == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto ON_ERROR;
    }
    hr = pNewItem->GetItemValue().Add( pWave, rtTime, prtLength );
    if( FAILED ( hr ) )
    {
        delete pNewItem;
        goto ON_ERROR;
    }
    m_WaveItemList.AddHead( pNewItem );
ON_ERROR:
    return hr;
}

////////////////////////////////////////////////////////////////////
// WaveItem

HRESULT WaveItem::Load( IDMStream* pIRiffStream, MMCKINFO* pckParent )
{
    MMCKINFO        ck;
    DWORD           dwByteCount;
    DWORD           dwSize;
    HRESULT         hr = E_FAIL;

    // LoadListItem does not expect to be called twice on the same object
    // Code assumes item consists of initial values
    ASSERT( m_rtTimePhysical == 0 );

    if( pIRiffStream == NULL ||  pckParent == NULL )
    {
        ASSERT( 0 );
        return DMUS_E_CANNOTREAD;
    }

    IStream* pIStream = pIRiffStream->GetStream();
    ASSERT( pIStream != NULL );

    // Load the track item
    while( pIRiffStream->Descend( &ck, pckParent, 0 ) == S_OK )
    {
        switch( ck.ckid )
        {
            case DMUS_FOURCC_WAVEITEM_CHUNK:
            {
                DMUS_IO_WAVE_ITEM_HEADER iItemHeader;
                iItemHeader.wVolumeRange = 0;
                iItemHeader.wPitchRange = 0;

                // Read in the item's header structure
                dwSize = min( sizeof( DMUS_IO_WAVE_ITEM_HEADER ), ck.cksize );
                hr = pIStream->Read( &iItemHeader, dwSize, &dwByteCount );

                // Handle any I/O error by returning a failure code
                if( FAILED( hr ) ||  dwByteCount != dwSize )
                {
                    Trace(1,"Error: Unable to read wave track - bad file.\n");
                    if (SUCCEEDED(hr)) hr = DMUS_E_CANNOTREAD;
                    goto ON_ERROR;
                }

                m_lVolume = iItemHeader.lVolume;
                m_lPitch = iItemHeader.lPitch;
                m_dwVariations = iItemHeader.dwVariations;
                m_rtTimePhysical = iItemHeader.rtTime;
                m_rtStartOffset = iItemHeader.rtStartOffset;
                m_rtDuration = iItemHeader.rtDuration;
                m_mtTimeLogical = iItemHeader.mtLogicalTime;
                m_dwFlags = iItemHeader.dwFlags;
                m_dwLoopStart = iItemHeader.dwLoopStart;
                m_dwLoopEnd = iItemHeader.dwLoopEnd;
                m_wVolumeRange = iItemHeader.wVolumeRange;
                m_wPitchRange = iItemHeader.wPitchRange;
                if (m_dwLoopEnd) m_dwLoopEnd++; // fix for bug 38505
                break;
            }

            case FOURCC_LIST:
                if( ck.fccType == DMUS_FOURCC_REF_LIST )
                {
                    hr = LoadReference( pIStream, pIRiffStream, ck );
                }
                break;
        }

        // Ascend out of the chunk
        pIRiffStream->Ascend( &ck, 0 );
    }

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}

HRESULT WaveItem::LoadReference(IStream *pStream,
                                         IDMStream *pIRiffStream,
                                         MMCKINFO& ckParent)
{
    if (!pStream || !pIRiffStream) return E_INVALIDARG;

    IDirectSoundWave* pWave;
    IDirectMusicLoader* pLoader = NULL;
    IDirectMusicGetLoader *pIGetLoader;
    HRESULT hr = pStream->QueryInterface( IID_IDirectMusicGetLoader,(void **) &pIGetLoader );
    if (FAILED(hr)) return hr;
    hr = pIGetLoader->GetLoader(&pLoader);
    pIGetLoader->Release();
    if (FAILED(hr)) return hr;

    DMUS_OBJECTDESC desc;
    ZeroMemory(&desc, sizeof(desc));

    MMCKINFO ckNext;
    ckNext.ckid = 0;
    ckNext.fccType = 0;
    DWORD dwSize = 0;

    while( pIRiffStream->Descend( &ckNext, &ckParent, 0 ) == S_OK )
    {
        switch(ckNext.ckid)
        {
            case  DMUS_FOURCC_REF_CHUNK:
                DMUS_IO_REFERENCE ioDMRef;
                hr = pStream->Read(&ioDMRef, sizeof(DMUS_IO_REFERENCE), NULL);
                if(SUCCEEDED(hr))
                {
                    desc.guidClass = ioDMRef.guidClassID;
                    desc.dwValidData |= ioDMRef.dwValidData;
                    desc.dwValidData |= DMUS_OBJ_CLASS;
                }
                break;

            case DMUS_FOURCC_GUID_CHUNK:
                hr = pStream->Read(&(desc.guidObject), sizeof(GUID), NULL);
                if(SUCCEEDED(hr) )
                {
                    desc.dwValidData |=  DMUS_OBJ_OBJECT;
                }
                break;

            case DMUS_FOURCC_DATE_CHUNK:
                hr = pStream->Read(&(desc.ftDate), sizeof(FILETIME), NULL);
                if(SUCCEEDED(hr))
                {
                    desc.dwValidData |=  DMUS_OBJ_DATE;
                }
                break;

            case DMUS_FOURCC_NAME_CHUNK:
                dwSize = min(sizeof(desc.wszName), ckNext.cksize);
                hr = pStream->Read(desc.wszName, dwSize, NULL);
                if(SUCCEEDED(hr) )
                {
                    desc.dwValidData |=  DMUS_OBJ_NAME;
                }
                break;

            case DMUS_FOURCC_FILE_CHUNK:
                dwSize = min(sizeof(desc.wszFileName), ckNext.cksize);
                hr = pStream->Read(desc.wszFileName, dwSize, NULL);
                if(SUCCEEDED(hr))
                {
                    desc.dwValidData |=  DMUS_OBJ_FILENAME;
                }
                break;

            case DMUS_FOURCC_CATEGORY_CHUNK:
                dwSize = min(sizeof(desc.wszCategory), ckNext.cksize);
                hr = pStream->Read(desc.wszCategory, dwSize, NULL);
                if(SUCCEEDED(hr) )
                {
                    desc.dwValidData |=  DMUS_OBJ_CATEGORY;
                }
                break;

            case DMUS_FOURCC_VERSION_CHUNK:
                DMUS_IO_VERSION ioDMObjVer;
                hr = pStream->Read(&ioDMObjVer, sizeof(DMUS_IO_VERSION), NULL);
                if(SUCCEEDED(hr))
                {
                    desc.vVersion.dwVersionMS = ioDMObjVer.dwVersionMS;
                    desc.vVersion.dwVersionLS = ioDMObjVer.dwVersionLS;
                    desc.dwValidData |= DMUS_OBJ_VERSION;
                }
                break;

            default:
                break;
        }

        if(SUCCEEDED(hr) && pIRiffStream->Ascend(&ckNext, 0) == S_OK)
        {
            ckNext.ckid = 0;
            ckNext.fccType = 0;
        }
        else if (SUCCEEDED(hr)) hr = DMUS_E_CANNOTREAD;
    }

    if (!(desc.dwValidData &  DMUS_OBJ_NAME) &&
        !(desc.dwValidData &  DMUS_OBJ_FILENAME) &&
        !(desc.dwValidData &  DMUS_OBJ_OBJECT) )
    {
        Trace(1,"Error: Wave track is unable to reference a wave because it doesn't have any valid reference information.\n");
        hr = DMUS_E_CANNOTREAD;
    }
    if(SUCCEEDED(hr))
    {
        desc.dwSize = sizeof(DMUS_OBJECTDESC);
        hr = pLoader->GetObject(&desc, IID_IDirectSoundWave, (void**)&pWave);
        if (SUCCEEDED(hr))
        {
            if (m_pWave) m_pWave->Release();
            m_pWave = pWave; // no need to AddRef; GetObject did that
            REFERENCE_TIME rtReadAhead = 0;
            DWORD dwFlags = 0;
            m_pWave->GetStreamingParms(&dwFlags, &rtReadAhead);
            m_fIsStreaming = dwFlags & DMUS_WAVEF_STREAMING ? TRUE : FALSE;
            m_fUseNoPreRoll = dwFlags & DMUS_WAVEF_NOPREROLL ? TRUE : FALSE;
        }
    }

    if (pLoader)
    {
        pLoader->Release();
    }
    return hr;
}

HRESULT WaveItem::Download(IDirectMusicPerformance* pPerformance,
                           IDirectMusicAudioPath* pPath,
                           DWORD dwPChannel,
                           IDirectSoundWave* pWave,
                           REFGUID rguidVersion)
{
    HRESULT hr = S_OK;
    IDirectMusicPort* pPort = NULL;
    DWORD dwGroup = 0;
    DWORD dwMChannel = 0;
    if (m_pWave && (!pWave || pWave == m_pWave))
    {
        hr = PChannelInfo(pPerformance, pPath, dwPChannel, &pPort, &dwGroup, &dwMChannel);
        if (SUCCEEDED(hr) && pPort)
        {
            IDirectMusicPortP* pPortP = NULL;
            if (SUCCEEDED(hr = pPort->QueryInterface(IID_IDirectMusicPortP, (void**) &pPortP)))
            {
                EnterCriticalSection(&WaveItem::st_WaveListCritSect);
                TListItem<TaggedWave>* pDLWave = st_WaveList.GetHead();
                for (; pDLWave; pDLWave = pDLWave->GetNext())
                {
                    TaggedWave& rDLWave = pDLWave->GetItemValue();
                    if ( rDLWave.m_pWave == m_pWave &&
                         rDLWave.m_pPerformance == pPerformance &&
                         rDLWave.m_pPort == pPortP &&
                         ( !m_fIsStreaming ||
                           rDLWave.m_pDownloadedWave == m_pDownloadedWave ) )
                    {
                        break;
                    }
                }
                // only download the wave if:
                // 1) it hasn't already been downloaded to the port, or
                // 2) its version doesn't match the currently downloaded version.
                if (!pDLWave)
                {
                    pDLWave = new TListItem<TaggedWave>;
                    if (!pDLWave)
                    {
                        hr = E_OUTOFMEMORY;
                    }
                    else
                    {
                        TaggedWave& rDLWave = pDLWave->GetItemValue();
                        hr = pPortP->DownloadWave( m_pWave, &(rDLWave.m_pDownloadedWave), m_rtStartOffset );
                        if (SUCCEEDED(hr))
                        {
                            rDLWave.m_pPort = pPortP;
                            rDLWave.m_pPort->AddRef();
                            rDLWave.m_pPerformance = pPerformance;
                            rDLWave.m_pPerformance->AddRef();
                            rDLWave.m_pWave = m_pWave;
                            rDLWave.m_pWave->AddRef();
                            rDLWave.m_lRefCount = 1;
                            rDLWave.m_guidVersion = rguidVersion;
                            st_WaveList.AddHead(pDLWave);
                            if (m_pDownloadedWave)
                            {
                                m_pDownloadedWave->Release();
                            }
                            if(m_fIsStreaming)
                            {
                                m_pDownloadedWave = rDLWave.m_pDownloadedWave;
                                m_pDownloadedWave->AddRef();
                            }
                        }
                        else
                        {
                            delete pDLWave;
                        }
                    }
                }
                else if (rguidVersion != pDLWave->GetItemValue().m_guidVersion)
                {
                    TaggedWave& rDLWave = pDLWave->GetItemValue();
                    if (rDLWave.m_pDownloadedWave)
                    {
                        pPortP->UnloadWave(rDLWave.m_pDownloadedWave);
                        rDLWave.m_pDownloadedWave = NULL;
                    }
                    if (rDLWave.m_pPort)
                    {
                        rDLWave.m_pPort->Release();
                        rDLWave.m_pPort = NULL;
                    }
                    if (rDLWave.m_pPerformance)
                    {
                        rDLWave.m_pPerformance->Release();
                        rDLWave.m_pPerformance = NULL;
                    }
                    hr = pPortP->DownloadWave( m_pWave, &(rDLWave.m_pDownloadedWave), m_rtStartOffset );
                    if (SUCCEEDED(hr))
                    {
                        rDLWave.m_pPort = pPortP;
                        rDLWave.m_pPort->AddRef();
                        rDLWave.m_pPerformance = pPerformance;
                        rDLWave.m_pPerformance->AddRef();
                        rDLWave.m_lRefCount = 1;
                        rDLWave.m_guidVersion = rguidVersion;
                        if (m_pDownloadedWave)
                        {
                            m_pDownloadedWave->Release();
                        }

                        if(m_fIsStreaming)
                        {
                            m_pDownloadedWave = rDLWave.m_pDownloadedWave;
                            m_pDownloadedWave->AddRef();
                        }
                    }
                    else
                    {
                        if (rDLWave.m_pWave)
                        {
                            rDLWave.m_pWave->Release();
                            rDLWave.m_pWave = NULL;
                        }
                        st_WaveList.Remove(pDLWave);
                        delete pDLWave;
                    }
                }
                else // keep track of this, but return S_FALSE (indicates wave wasn't downloaded)
                {
                    pDLWave->GetItemValue().m_lRefCount++;
                    hr = S_FALSE;
                }
                LeaveCriticalSection(&WaveItem::st_WaveListCritSect);

                pPortP->Release();
            }
            pPort->Release();
        }
        else if (SUCCEEDED(hr) && !pPort)
        {
            Trace(1, "Error: the performance was unable to find a port for download.\n");
            hr = DMUS_E_NOT_FOUND;
        }
    }
    else
    {
        Trace(1,"Error: Wavetrack download failed, initialization error.\n");
        hr = DMUS_E_NOT_INIT;
    }

    return hr;
}

HRESULT WaveItem::Unload(IDirectMusicPerformance* pPerformance,
                         IDirectMusicAudioPath* pPath,
                         DWORD dwPChannel,
                         IDirectSoundWave* pWave)
{
    IDirectMusicPort* pPort = NULL;
    DWORD dwGroup = 0;
    DWORD dwMChannel = 0;
    HRESULT hr = S_OK;
    if (m_pWave && (!pWave || pWave == m_pWave))
    {
        hr = PChannelInfo(pPerformance, pPath, dwPChannel, &pPort, &dwGroup, &dwMChannel);
        if (SUCCEEDED(hr) && pPort)
        {
            IDirectMusicPortP* pPortP = NULL;
            if (SUCCEEDED(hr = pPort->QueryInterface(IID_IDirectMusicPortP, (void**) &pPortP)))
            {
                EnterCriticalSection(&WaveItem::st_WaveListCritSect);
                TListItem<TaggedWave>* pDLWave = st_WaveList.GetHead();
                for (; pDLWave; pDLWave = pDLWave->GetNext())
                {
                    TaggedWave& rDLWave = pDLWave->GetItemValue();
                    if (rDLWave.m_pWave == m_pWave &&
                        rDLWave.m_pPerformance == pPerformance &&
                        rDLWave.m_pPort == pPortP &&
                        ( !m_fIsStreaming ||
                          rDLWave.m_pDownloadedWave == m_pDownloadedWave ) )
                    {
                        rDLWave.m_lRefCount--;
                        if (rDLWave.m_lRefCount <= 0)
                        {
                            if (rDLWave.m_pWave)
                            {
                                rDLWave.m_pWave->Release();
                                rDLWave.m_pWave = NULL;
                            }
                            if (rDLWave.m_pPort)
                            {
                                rDLWave.m_pPort->Release();
                                rDLWave.m_pPort = NULL;
                            }
                            if (rDLWave.m_pPerformance)
                            {
                                rDLWave.m_pPerformance->Release();
                                rDLWave.m_pPerformance = NULL;
                            }
                            if (rDLWave.m_pDownloadedWave)
                            {
                                pPortP->UnloadWave(rDLWave.m_pDownloadedWave);
                                rDLWave.m_pDownloadedWave = NULL;
                            }
                            if (m_pDownloadedWave)
                            {
                                m_pDownloadedWave->Release();
                                m_pDownloadedWave = NULL;
                            }
                            st_WaveList.Remove(pDLWave);
                            delete pDLWave;
                        }
                        else
                        {
                            hr = S_FALSE; // indicates wave wasn't actually unloaded
                        }
                        break;
                    }
                }
                LeaveCriticalSection(&WaveItem::st_WaveListCritSect);

                pPortP->Release();
            }
            pPort->Release();
        }
        else if (SUCCEEDED(hr) && !pPort)
        {
            Trace(1, "Error: the performance was unable to find a port for unload.\n");
            hr = DMUS_E_NOT_FOUND;
        }
    }

    return hr;
}

HRESULT WaveItem::Refresh(IDirectMusicPerformance* pPerformance,
                          IDirectMusicAudioPath* pPath,
                          DWORD dwOldPChannel,
                          DWORD dwNewPChannel,
                          IDirectSoundWave* pWave,
                          REFGUID rguidVersion)
{
    IDirectMusicPort* pOldPort = NULL;
    IDirectMusicPort* pNewPort = NULL;
    DWORD dwGroup = 0;
    DWORD dwMChannel = 0;
    HRESULT hr = S_OK;
    hr = PChannelInfo(pPerformance, pPath, dwOldPChannel, &pOldPort, &dwGroup, &dwMChannel);
    if (SUCCEEDED(hr))
    {
        hr = PChannelInfo(pPerformance, pPath, dwNewPChannel, &pNewPort, &dwGroup, &dwMChannel);
    }
    if (SUCCEEDED(hr))
    {
        // if the old port and new port are different, unload the wave from the old port
        // and download to the new one.
        if (pOldPort != pNewPort)
        {
            Unload(pPerformance, pPath, dwOldPChannel, pWave);
            hr = Download(pPerformance, pPath, dwNewPChannel, pWave, rguidVersion);
        }
    }
    if (pOldPort) pOldPort->Release();
    if (pNewPort) pNewPort->Release();
    return hr;
}

HRESULT WaveItem::PChannelInfo(
    IDirectMusicPerformance* pPerformance,
    IDirectMusicAudioPath* pAudioPath,
    DWORD dwPChannel,
    IDirectMusicPort** ppPort,
    DWORD* pdwGroup,
    DWORD* pdwMChannel)
{
    HRESULT hr = S_OK;
    DWORD dwConvertedPChannel = dwPChannel;
    if (pAudioPath)
    {
        hr = pAudioPath->ConvertPChannel(dwPChannel, &dwConvertedPChannel);
    }
    if (SUCCEEDED(hr))
    {
        hr = pPerformance->PChannelInfo(dwConvertedPChannel, ppPort, pdwGroup, pdwMChannel);
    }
    return hr;
}

void WaveItem::CleanUp()
{
    if (m_pWave)
    {
        m_pWave->Release();
        m_pWave = NULL;
    }
    if (m_pDownloadedWave)
    {
        m_pDownloadedWave->Release();
        m_pDownloadedWave = NULL;
    }
}

HRESULT WaveItem::Add(IDirectSoundWave* pWave, REFERENCE_TIME rtTime,
        REFERENCE_TIME* prtLength)
{
    HRESULT hr = S_OK;
    IPrivateWave* pPrivWave = NULL;
    *prtLength = 0; // in case GetLength fails...
    REFERENCE_TIME rtLength = 0;
    m_rtDuration = 0;
    if (SUCCEEDED(hr = pWave->QueryInterface(IID_IPrivateWave, (void**)&pPrivWave)))
    {
        if (SUCCEEDED(hr = pPrivWave->GetLength(&rtLength)))
        {
            // Assumes the track is clock time
            m_rtDuration = rtLength * REF_PER_MIL;
            *prtLength = rtLength; // NOTE: length in milliseconds; duration in Ref time
        }
        pPrivWave->Release();
    }
    if (SUCCEEDED(hr))
    {
        m_lVolume = 0;
        m_lPitch = 0;
        m_dwVariations = 0xffffffff;
        m_rtTimePhysical = rtTime;
        m_rtStartOffset = 0;
        m_mtTimeLogical = 0;
        m_dwFlags = 0;
        m_dwLoopStart = 0;
        m_dwLoopEnd = 0;
        if (m_pWave)
        {
            m_pWave->Release();
            m_pWave = NULL;
        }
        m_pWave = pWave;
        if (m_pWave)
        {
            m_pWave->AddRef();
            REFERENCE_TIME rtReadAhead = 0;
            DWORD dwFlags = 0;
            m_pWave->GetStreamingParms(&dwFlags, &rtReadAhead);
            m_fIsStreaming = dwFlags & DMUS_WAVEF_STREAMING ? TRUE : FALSE;
            m_fUseNoPreRoll = dwFlags & DMUS_WAVEF_NOPREROLL ? TRUE : FALSE;
        }
        if (m_pDownloadedWave)
        {
            m_pDownloadedWave->Release();
        }
        m_pDownloadedWave = NULL;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\watson\xbdumplog\Output.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:     xbWatson.cpp
// Contents: Contains the windows entry point for the xbWatson executable.
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  OutputMsg
// Purpose:   Utility function - dumps the specified message to the command prompt.  This will
//            only work if launched from a command prompt.
// Arguments: szMsg         -- The format of the message (just like 'printf').
//            ...           -- Arguments for the message.
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void OutputMsg(char *szMsg, ...)
{
    // szMsgOut         -- Buffer to hold the final formatted string to output.
    char szMsgOut[1024];

    // valist           -- vararg var used to generate final formatted string.
    va_list valist;

    // Create the final formatted string.
    va_start (valist, szMsg);
    vsprintf (szMsgOut, szMsg, valist);
    printf(szMsgOut);
    va_end (valist);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\XDmime\wavtrack.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
// WavTrack.h : Declaration of the CWavTrack

#ifndef __WAVTRACK_H_
#define __WAVTRACK_H_

#include "dmusici.h"
#include "dmusicf.h"
#include "dmstrm.h"
#include "tlist.h"
#include "PChMap.h"
#include "dmusiccp.h"
#include "dsoundp.h"  // For IDirectSoundWave

interface IPrivateWaveTrack : IUnknown
{
    virtual HRESULT STDMETHODCALLTYPE SetVariation(
        IDirectMusicSegmentState* pSegState,
        DWORD dwVariationFlags,
        DWORD dwPChannel,
        DWORD dwIndex)=0;
    virtual HRESULT STDMETHODCALLTYPE ClearVariations(IDirectMusicSegmentState* pSegState)=0;
    virtual HRESULT STDMETHODCALLTYPE AddWave(
        IDirectSoundWave* pWave,
        REFERENCE_TIME rtTime,
        DWORD dwPChannel,
        DWORD dwIndex,
        REFERENCE_TIME* prtLength)=0;
    virtual HRESULT STDMETHODCALLTYPE DownloadWave(
        IDirectSoundWave* pWave,   // wave to download
        IUnknown* pUnk,            // performance or audio path
        REFGUID rguidVersion)=0;   // version of downloaded wave
    virtual HRESULT STDMETHODCALLTYPE UnloadWave(
        IDirectSoundWave* pWave,   // wave to unload
        IUnknown* pUnk)=0;         // performance or audio path
    virtual HRESULT STDMETHODCALLTYPE RefreshWave(
        IDirectSoundWave* pWave,   // wave to refresh
        IUnknown* pUnk,            // performance or audio path
        DWORD dwPChannel,          // new PChannel for the wave
        REFGUID rguidVersion)=0;  // version of refreshed wave
    virtual HRESULT STDMETHODCALLTYPE FlushAllWaves()=0;
    virtual HRESULT STDMETHODCALLTYPE OnVoiceEnd(IDirectMusicVoiceP *pVoice, void *pStateData)=0;
};

DEFINE_GUID(IID_IPrivateWaveTrack, 0x492abe2a, 0x38c8, 0x48a3, 0x8f, 0x3c, 0x1e, 0x13, 0xba, 0x1, 0x78, 0x4e);

const int MAX_WAVE_VARIATION_LOCKS = 255;  // max number of variation lock ids

struct TaggedWave
{
    IDirectSoundWave*               m_pWave;
    GUID                            m_guidVersion;
    IDirectSoundDownloadedWaveP*    m_pDownloadedWave;
    long                            m_lRefCount;
    IDirectMusicPortP*              m_pPort;
    IDirectMusicPerformance*        m_pPerformance;

    TaggedWave() : m_pWave(NULL), m_pDownloadedWave(NULL), m_lRefCount(0),
        m_pPort(NULL), m_pPerformance(NULL), m_guidVersion(GUID_NULL)
    {
    }

    ~TaggedWave()
    {
        if (m_pWave) m_pWave->Release();
        if (m_pPort) m_pPort->Release();
        if (m_pPerformance) m_pPerformance->Release();
        if (m_pDownloadedWave) m_pDownloadedWave->Release();
    }
};

struct WaveItem
{
    WaveItem() : m_rtTimePhysical(0), m_lVolume(0), m_lPitch(0), m_dwVariations(0),
        m_rtStartOffset(0), m_rtDuration(0), m_mtTimeLogical(0), m_dwFlags(0),
        m_pWave(NULL), m_dwLoopStart(0), m_dwLoopEnd(0), m_dwVoiceIndex(0xffffffff),
        m_pDownloadedWave(NULL), m_fIsStreaming(FALSE), m_fUseNoPreRoll(FALSE)
    {
    }

    ~WaveItem()
    {
        CleanUp();
    }

    HRESULT Load( IDMStream* pIRiffStream, MMCKINFO* pckParent );
    HRESULT LoadReference(IStream *pStream, IDMStream *pIRiffStream, MMCKINFO& ckParent);
    HRESULT Download(IDirectMusicPerformance* pPerformance, 
        IDirectMusicAudioPath* pPath, 
        DWORD dwPChannel, 
        IDirectSoundWave* pWave, 
        REFGUID rguidVersion);
    HRESULT Unload(IDirectMusicPerformance* pPerformance, 
        IDirectMusicAudioPath* pPath, 
        DWORD dwPChannel, 
        IDirectSoundWave* pWave);
    HRESULT Refresh(IDirectMusicPerformance* pPerformance, 
        IDirectMusicAudioPath* pPath, 
        DWORD dwOldPChannel, 
        DWORD dwNewPChannel,
        IDirectSoundWave* pWave,
        REFGUID rguidVersion);
    static HRESULT PChannelInfo(
        IDirectMusicPerformance* pPerformance,
        IDirectMusicAudioPath* pAudioPath,
        DWORD dwPChannel,
        IDirectMusicPort** ppPort,
        DWORD* pdwGroup,
        DWORD* pdwMChannel);

    void CleanUp();
    HRESULT Add(IDirectSoundWave* pWave, REFERENCE_TIME rtTime, REFERENCE_TIME* prtLength);

    REFERENCE_TIME                  m_rtTimePhysical;
    long                            m_lVolume;
    long                            m_lPitch;
    DWORD                           m_dwVariations; // variations this wave item responds to
    REFERENCE_TIME                  m_rtStartOffset;
    REFERENCE_TIME                  m_rtDuration;
    MUSIC_TIME                      m_mtTimeLogical;
    DWORD                           m_dwFlags;
    IDirectSoundWave*               m_pWave;
    IDirectSoundDownloadedWaveP*    m_pDownloadedWave;
    WORD                            m_wVolumeRange;
    WORD                            m_wPitchRange;
    BOOL                            m_fIsStreaming;
    BOOL                            m_fUseNoPreRoll;
    DWORD                           m_dwLoopStart;
    DWORD                           m_dwLoopEnd;
    DWORD                           m_dwVoiceIndex; // unique (to the track) index for state data's vaoice array

    static TList<TaggedWave>        st_WaveList;
    static CRITICAL_SECTION         st_WaveListCritSect;
};

struct WavePart
{
    WavePart() : m_dwPChannel(0), m_lVolume(0), m_dwLockToPart(0), 
        m_dwPChannelFlags(0), m_dwVariations(0), m_dwIndex(0)
    {
    }

    ~WavePart()
    {
        CleanUp();
    }

    HRESULT Load( IDMStream* pIRiffStream, MMCKINFO* pckParent );
    HRESULT CopyItems( const TList<WaveItem>& rItems, MUSIC_TIME mtStart, MUSIC_TIME mtEnd );
    void CleanUp();
    HRESULT Download(IDirectMusicPerformance* pPerformance, 
        IDirectMusicAudioPath* pPath, 
        IDirectSoundWave* pWave,
        REFGUID rguidVersion);
    HRESULT Unload(IDirectMusicPerformance* pPerformance, 
        IDirectMusicAudioPath* pPath, 
        IDirectSoundWave* pWave);
    HRESULT Refresh(IDirectMusicPerformance* pPerformance, 
        IDirectMusicAudioPath* pPath, 
        IDirectSoundWave* pWave,
        DWORD dwPChannel,
        REFGUID rguidVersion);
    HRESULT Add(
        IDirectSoundWave* pWave,
        REFERENCE_TIME rtTime,
        DWORD dwPChannel,
        DWORD dwIndex,
        REFERENCE_TIME* prtLength);

    DWORD               m_dwPChannel;
    DWORD               m_dwIndex; // Index to distinguish different parts on the same PChannel
    DWORD               m_lVolume;
    DWORD               m_dwVariations;    // variations enabled for this part
    DWORD               m_dwLockToPart;    // all parts with this ID are locked (0 means no locking)
    DWORD               m_dwPChannelFlags; // lowest-order nibble holds DMUS_VARIATIONT_TYPES value
    TList<WaveItem>     m_WaveItemList;
};

struct WaveDLOnPlay
{
    WaveDLOnPlay() : m_pWaveDL(NULL), m_pPort(NULL), m_pVoice(NULL) {}
    ~WaveDLOnPlay()
    {
        if (m_pPort)
        {
            if (m_pWaveDL)
            {
                m_pPort->UnloadWave(m_pWaveDL);
            }
            m_pWaveDL = NULL;
            m_pPort->Release();
            m_pPort = NULL;
        }
        if (m_pVoice)
        {
            m_pVoice->Release();
            m_pVoice = NULL;
        }
    }

    IDirectSoundDownloadedWaveP*   m_pWaveDL;
    IDirectMusicPortP*             m_pPort;
    IDirectMusicVoiceP*            m_pVoice;
};

struct WaveStateData
{
    DWORD                       dwPChannelsUsed; // number of PChannels
    // the following array is allocated to the size of dwNumPChannels, which
    // must match the Wave Track's m_dwPChannelsUsed. The array matches one-for-one with
    // the parts inside the Wave Track.
    TListItem<WaveItem>**       apCurrentWave; // array of size dwNumPChannels
    DWORD                       dwValidate;
    DWORD                       dwGroupBits; // the group bits of this track
    DWORD*                      pdwVariations;      // array of variations (1 per part)
    DWORD*                      pdwRemoveVariations;    // array of variations already played (1 per part)
    DWORD                       adwVariationGroups[MAX_WAVE_VARIATION_LOCKS];
    REFERENCE_TIME              rtNextVariation; // time of next variation
    DWORD                       m_dwVariation;   // selected variations to audition
    DWORD                       m_dwPart;        // PChannel of part for auditioning variations
    DWORD                       m_dwIndex;       // Index of part for auditioning variations
    DWORD                       m_dwLockID;      // For locking to the part being auditioned
    BOOL                        m_fAudition;     // Am I auditioning variations?
    IDirectMusicPerformance*    m_pPerformance;
    IDirectMusicVoiceP**        m_apVoice;      // array of voices (one per wave item in track)
    DWORD                       m_dwVoices;     // number of voices in m_apVoice
    bool                        m_fLoop;        // set after the wave loops
    IDirectMusicAudioPath*      m_pAudioPath;   // audio path in effect for this track state
    TList<WaveDLOnPlay>         m_WaveDLList;   // waves downloaded while the track was playing

    WaveStateData() : dwPChannelsUsed(0), apCurrentWave(NULL), dwGroupBits(0),
        pdwVariations(NULL), pdwRemoveVariations(NULL), rtNextVariation(0),
        m_dwVariation(0), m_dwPart(0), m_dwIndex(0), m_dwLockID(0), m_fAudition(FALSE),
        m_pPerformance(NULL), m_apVoice(NULL), m_dwVoices(0), m_fLoop(false), m_pAudioPath(NULL)
    {
        for (int i = 0; i < MAX_WAVE_VARIATION_LOCKS; i++)
        {
            adwVariationGroups[i] = 0;
        }
    }

    ~WaveStateData()
    {
        if( apCurrentWave )
        {
            delete [] apCurrentWave;
        }
        if( pdwVariations )
        {
            delete [] pdwVariations;
        }
        if( pdwRemoveVariations )
        {
            delete [] pdwRemoveVariations;
        }
        if (m_apVoice)
        {
            for (DWORD dw = 0; dw < m_dwVoices; dw++)
            {
                if (m_apVoice[dw])
                {
                    m_apVoice[dw]->Release();
                }
            }
            delete [] m_apVoice;
        }
        if( m_pAudioPath )
        {
            m_pAudioPath->Release();
        }
        TListItem<WaveDLOnPlay>* pWDLOnPlay = NULL;
        while (!m_WaveDLList.IsEmpty())
        {
            pWDLOnPlay = m_WaveDLList.RemoveHead();
            delete pWDLOnPlay;
        }
    }

    HRESULT InitVariationInfo(DWORD dwVariations, DWORD dwPart, DWORD dwIndex, DWORD dwLockID, BOOL fAudition)
    {
        HRESULT hr = S_OK;
        m_dwVariation = dwVariations;
        m_dwPart = dwPart;
        m_dwIndex = dwIndex;
        m_dwLockID = dwLockID;
        m_fAudition = fAudition;
        return hr;
    }

    DWORD Variations(WavePart& rPart, int nPartIndex)
    {
        if (m_dwLockID && rPart.m_dwLockToPart == m_dwLockID)
        {
            TraceI(4, "Variations for locked part\n");
            return m_dwVariation;
        }
        else if ( m_fAudition &&
                  (rPart.m_dwPChannel == m_dwPart) &&
                  (rPart.m_dwIndex == m_dwIndex) )
        {
            TraceI(4, "Variations for current part\n");
            return m_dwVariation;
        }
        else
        {
            TraceI(4, "Variations for a different part\n");
            return pdwVariations[nPartIndex];
        }
    }

};

struct StatePair
{
    StatePair() : m_pSegState(NULL), m_pStateData(NULL) {}
    StatePair(const StatePair& rPair)
    {
        m_pSegState = rPair.m_pSegState;
        m_pStateData = rPair.m_pStateData;
    }
    StatePair(IDirectMusicSegmentState* pSegState, WaveStateData* pStateData)
    {
        m_pSegState = pSegState;
        m_pStateData = pStateData;
    }
    StatePair& operator= (const StatePair& rPair)
    {
        if (this != &rPair)
        {
            m_pSegState = rPair.m_pSegState;
            m_pStateData = rPair.m_pStateData;
        }
        return *this;
    }
    ~StatePair()
    {
    }
    IDirectMusicSegmentState*   m_pSegState;
    WaveStateData*          m_pStateData;
};

struct WavePair
{
    WavePair() : m_pWaveDL(NULL), m_pStateData(NULL) {}
    ~WavePair()
    {
        if (m_pWaveDL) m_pWaveDL->Release();
    }

    IDirectSoundDownloadedWaveP*   m_pWaveDL;
    WaveStateData*                 m_pStateData;
};

/////////////////////////////////////////////////////////////////////////////
// CWavTrack
class CWavTrack : 
    public IPersistStream,
    public IDirectMusicTrack8,
    public IPrivateWaveTrack
{
public:
    CWavTrack();
    CWavTrack(const CWavTrack& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd);
    ~CWavTrack();

public:
// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

// IDirectMusicTrack methods
    STDMETHODIMP IsParamSupported(REFGUID rguid);
    STDMETHODIMP Init(IDirectMusicSegment *pSegment);
    STDMETHODIMP InitPlay(IDirectMusicSegmentState *pSegmentState,
                IDirectMusicPerformance *pPerformance,
                void **ppStateData,
                DWORD dwTrackID,
                DWORD dwFlags);
    STDMETHODIMP EndPlay(void *pStateData);
    STDMETHODIMP Play(void *pStateData,MUSIC_TIME mtStart,
                MUSIC_TIME mtEnd,MUSIC_TIME mtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf,
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID);
    STDMETHODIMP GetParam(REFGUID rguid,MUSIC_TIME mtTime,MUSIC_TIME* pmtNext,void *pData);
    STDMETHODIMP SetParam(REFGUID rguid,MUSIC_TIME mtTime,void *pData);
    STDMETHODIMP AddNotificationType(REFGUID rguidNotification);
    STDMETHODIMP RemoveNotificationType(REFGUID rguidNotification);
    STDMETHODIMP Clone(MUSIC_TIME mtStart,MUSIC_TIME mtEnd,IDirectMusicTrack** ppTrack);
// IDirectMusicTrack8 methods
    STDMETHODIMP PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf, 
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) ; 
    STDMETHODIMP GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) ; 
    STDMETHODIMP SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,void* pParam, void * pStateData, DWORD dwFlags) ;
    STDMETHODIMP Compose(IUnknown* pContext, 
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack) ;
    STDMETHODIMP Join(IDirectMusicTrack* pNewTrack,
        MUSIC_TIME mtJoin,
        IUnknown* pContext,
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack) ;
// IPersist methods
    STDMETHODIMP GetClassID( CLSID* pClsId );
// IPersistStream methods
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load( IStream* pIStream );
    STDMETHODIMP Save( IStream* pIStream, BOOL fClearDirty );
    STDMETHODIMP GetSizeMax( ULARGE_INTEGER FAR* pcbSize );
//  IPrivateWaveTrack methods
    STDMETHODIMP SetVariation(
        IDirectMusicSegmentState* pSegState,
        DWORD dwVariationFlags,
        DWORD dwPChannel,
        DWORD dwIndex);
    STDMETHODIMP ClearVariations(IDirectMusicSegmentState* pSegState);
    STDMETHODIMP AddWave(
        IDirectSoundWave* pWave,
        REFERENCE_TIME rtTime,
        DWORD dwPChannel,
        DWORD dwIndex,
        REFERENCE_TIME* prtLength);
    STDMETHODIMP DownloadWave(
        IDirectSoundWave* pWave,
        IUnknown* pUnk,
        REFGUID rguidVersion);
    STDMETHODIMP UnloadWave(
        IDirectSoundWave* pWave,
        IUnknown* pUnk);
    STDMETHODIMP RefreshWave(
        IDirectSoundWave* pWave,
        IUnknown* pUnk,
        DWORD dwPChannel,
        REFGUID rguidVersion);
    STDMETHODIMP FlushAllWaves();
    STDMETHODIMP OnVoiceEnd(IDirectMusicVoiceP *pVoice, void *pStateData);
    // misc
    static HRESULT UnloadAllWaves(IDirectMusicPerformance* pPerformance);

protected:
    void Construct(void);
    HRESULT Play(
        void *pStateData,   
        REFERENCE_TIME rtStart, 
        REFERENCE_TIME rtEnd,
      //  MUSIC_TIME mtOffset,
        REFERENCE_TIME rtOffset,
        DWORD dwFlags,      
        IDirectMusicPerformance* pPerf, 
        IDirectMusicSegmentState* pSegSt,
        DWORD dwVirtualID,
        BOOL fClockTime);
    void InsertByAscendingPChannel( TListItem<WavePart>* pPart );
    HRESULT CopyParts( const TList<WavePart>& rParts, MUSIC_TIME mtStart, MUSIC_TIME mtEnd );
    void CleanUp();
    void CleanUpTempParts();
    void MovePartsToTemp();
    IDirectSoundDownloadedWaveP* FindDownload(TListItem<WaveItem>* pItem);
    void SetUpStateCurrentPointers(WaveStateData* pStateData);
    HRESULT STDMETHODCALLTYPE Seek( 
        IDirectMusicSegmentState*,
        IDirectMusicPerformance*,
        DWORD dwVirtualID,
        WaveStateData*,
        REFERENCE_TIME rtTime,
        BOOL fGetPrevious,
//      MUSIC_TIME mtOffset,
        REFERENCE_TIME rtOffset,
        BOOL fClockTime);
    HRESULT SyncVariations(IDirectMusicPerformance* pPerf, 
        WaveStateData* pSD, 
        REFERENCE_TIME rtStart,
        REFERENCE_TIME rtOffset,  
        BOOL fClockTime);
    HRESULT ComputeVariations(WaveStateData* pSD);
    HRESULT ComputeVariation(int nPart, WavePart& rWavePart, WaveStateData* pSD);
    WaveStateData* FindState(IDirectMusicSegmentState* pSegState);
    HRESULT InitTrack(DWORD dwPChannels);
    HRESULT GetDownload(
        IDirectSoundDownloadedWaveP* pWaveDL,
        WaveStateData* pStateData,
        IDirectMusicPortP* pPortP,
        IDirectSoundWave* pWave,
        REFERENCE_TIME rtStartOffset,
        WaveItem& rItem,
        DWORD dwMChannel,
        DWORD dwGroup,
        IDirectMusicVoiceP **ppVoice);
    void RemoveDownloads(WaveStateData* pStateData);

    static void FlushWaves();

// member variables
private:
    long                m_cRef;
    CRITICAL_SECTION    m_CrSec;
    BOOL                m_fCSInitialized;

    long                m_lVolume;
    DWORD               m_dwTrackFlags; // Only current flag is DMUS_WAVETRACKF_SYNC_VAR
    DWORD               m_dwPChannelsUsed;
    DWORD*              m_aPChannels;
    TList<WavePart>     m_WavePartList;
    TList<WavePart>     m_TempWavePartList; // keep this around when reloading the track
    DWORD               m_dwValidate; // used to validate state data
    CPChMap             m_PChMap;

    DWORD               m_dwVariation;   // selected variations to audition
    DWORD               m_dwPart;        // PChannel of part for auditioning variations
    DWORD               m_dwIndex;       // Index of part for auditioning variations
    DWORD               m_dwLockID;      // For locking to the part being auditioned
    BOOL                m_fAudition;     // Am I auditioning variations?
    BOOL                m_fAutoDownload;
    BOOL                m_fLockAutoDownload; // if true, this flag indicates that we've specifically
                                // commanded the band to autodownload. Otherwise,
                                // it gets its preference from the performance via
                                // GetGlobalParam.
    DWORD*              m_pdwVariations;        // Track's array of variations (1 per part)
    DWORD*              m_pdwRemoveVariations;  // Track's array of variations already played (1 per part)
    DWORD               m_dwWaveItems;          // Total number of wave items in the track

    TList<StatePair>    m_StateList;            // The track's state information
    TList<WavePair>     m_WaveList;             // Information about waves downloaded to the track

    static long         st_RefCount;            // global count of # of instantiated wave tracks
};

#endif //__WAVTRACK_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\watson\xbdbsmon\xbdbsmon.cpp ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    xbdbsmon.cpp

Abstract:

    This module implements routines which monitor debug message from Xbox.
    The debug messages are captured using XboxDbg notification mechanism.

--*/

#include "xbdbsmonp.h"

PDMN_SESSION DmSession = NULL;
BOOL fNotificationOpened = FALSE;
BOOL fConnectionOpened = FALSE;

VOID
TranslateError(
    HRESULT hr
    )
/*++

Routine Description:

    This routine translates HRESULT returned from XboxDbg APIs into string and
    output to standard error

Auguments:

    hr - HRESULT returned from various XboxDbg APIs

Return Value:

    None

--*/
{
    CHAR Buffer[512];

    DmTranslateErrorA( hr, Buffer, sizeof(Buffer) );
    fprintf( stderr, Buffer );
}

DWORD
WINAPI
NotificationProc(
    ULONG Notification,
    DWORD Parameter
    )
/*++

Routine Description:

    This is a callback routine registered by DmNotify.  It is called by XboxDbg
    for various types of notification event.

Arguments:

    Notification - Type of notification, DM_DEBUGSTR for example

    Parameter - Optional parameter based on notification type

Return Value:

    Always zero

--*/
{
    PDMN_DEBUGSTR p = (PDMN_DEBUGSTR)Parameter;

    //
    // Process only if notification type is DM_DEBUGSTR and there is
    // a valid string length
    //

    if ( Notification == DM_DEBUGSTR && p->Length ) {
        fprintf( stdout, "%.*s", p->Length, p->String );
    }

    return 0;
}

BOOL
WINAPI
ConsoleCtrlHandler(
    DWORD CtrlType
    )
/*++

Routine Description:

    A HandlerRoutine function is an application-defined function used with
    the SetConsoleCtrlHandler function.  A console process uses this function
    to handle control signals received by the process

Arguments:

    CtrlType - Indicates the type of control signal received by the handler.

Return Value:

    Return FALSE to terminate the process

--*/
{
    switch ( CtrlType ) {
    case CTRL_C_EVENT:
    case CTRL_BREAK_EVENT:
    case CTRL_CLOSE_EVENT:

        fprintf( stdout, "Terminating...\n" );

        //
        // Close notification and connection if needed
        //

        if ( fNotificationOpened ) {
            DmCloseNotificationSession( DmSession );
        }

        if ( fConnectionOpened ) {
            DmUseSharedConnection( FALSE );
        }

        return FALSE;
    }

    return TRUE;
}

int __cdecl main( int cArg, char **rgszArg )
{
    char *szExe = *rgszArg;
    HRESULT hr;

    //
    // Hook Ctrl+C handle so that we can do a cleanup work
    //

    SetConsoleCtrlHandler( ConsoleCtrlHandler, TRUE );

    //
    // Open a shared debug connection with xbdm
    //

    hr = DmUseSharedConnection( TRUE );

    if ( FAILED(hr) ) {
        TranslateError( hr );
        return 1;
    } else {
        fConnectionOpened = TRUE;
    }

    //
    // Process command line arguments if any
    //

    ++rgszArg;

    while ( --cArg ) {

        if ( **rgszArg != '-' && **rgszArg != '/' ) {
usage:
            fprintf( stderr, "usage: %s [-x xboxname]\n", szExe );
            DmUseSharedConnection( FALSE );
            return 1;
        }

        char *szArg = *rgszArg++;

        while( *++szArg ) {

            switch( *szArg ) {
            case 'x':
            case 'X':
                if (!--cArg) {
                    goto usage;
                }

                hr = DmSetXboxName( *rgszArg++ );

                if( FAILED(hr) ) {
                    TranslateError( hr );
                    DmUseSharedConnection( FALSE );
                    return 1;
                }
                break;

            default:
                goto usage;
            }
        }
    }

    fprintf( stdout, "Initializing...\n" );
    hr = DmOpenNotificationSession( DM_PERSISTENT, &DmSession );

    if ( SUCCEEDED(hr) ) {

        fNotificationOpened = TRUE;

        hr = DmNotify( DmSession, DM_DEBUGSTR, NotificationProc );

        if ( SUCCEEDED(hr) ) {
            fprintf( stdout, "Start listening (Ctrl+C to exit)...\n" );
            Sleep( INFINITE );
        } else {
            TranslateError( hr );
        }

        DmCloseNotificationSession( DmSession );

    } else {
        TranslateError( hr );
    }

    DmUseSharedConnection( FALSE );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\watson\xbdbsmon\xbdbsmonp.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    xbdbsmonp.h

Abstract:

    This is a pre-compiled header file for Xbox debug message monitor

--*/

#include <windows.h>
#include <stdio.h>
#include <xboxdbg.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\watson\xbdumplog\Output.h ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:     Output.h
// Contents: Contains declarations of functions and variables defined in Output.cpp
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  PasteOutput
// Purpose:   Pastes the contents of the clipboard to the output window.
// Arguments: None.
// Return:    None.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void PasteOutput();

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CutOutput
// Purpose:   Cuts the selected text from the output window.
// Arguments: None.
// Return:    None.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CutOutput();

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  DeleteOutput
// Purpose:   Deletes the selected text from the output window.
// Arguments: None.
// Return:    None.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void DeleteOutput();

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CopyOutput
// Purpose:   Copies the current selection to the clipboard
// Arguments: None.
// Return:    None.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CopyOutput();

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  SelectAllOutput
// Purpose:   Selects everything in the output window
// Arguments: None.
// Return:    None.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void SelectAllOutput();

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  OutputMsg
// Purpose:   Utility function - dumps the specified message to the output window.
// Arguments: szMsg         -- The format of the message (just like 'printf').
//            ...           -- Arguments for the message.
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void OutputMsg(char *szMsg, ...);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\watson\xbdumplog\ParseLogFile.h ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:     ParseLogFile.h
// Contents: Contains declarations of functions and variables defined in ParseLogFile.cpp
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  ParseLogFile
// Purpose:   Parses the xbWatson log file, determines the function names of the callstack(s)  (using
//            ImageHlp.dll) and dumps it to the command prompt.
// Arguments: szLogFileName     -- Name of the log file to dump
//            szSymPath         -- Path containing symbols related to the specified log file's app.
// Return:    '1' if successful, '0' otherwise.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
int ParseLogFile(char *szLogFileName, char *szSymPath);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\watson\xbdumplog\ParseLogFile.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:     ParseLogFile.cpp
// Contents: Contains code to parse and output a user-specified log file.
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ DEFINES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// MAX_STACK_DEPTH      -- Maximum depth of a stack trace in the dump file that we'll output.  Any
//                         stack addresses deeper than this are ignored.
#define MAX_STACK_DEPTH 40

// MAX_FUNC_NAME_LEN    -- Maximum length of a function name we'll store (anything else is ignored).
#define MAX_FUNC_NAME_LEN 255


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ LOCAL GLOBAL VARIABLES ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// gs_pthreadinfoRead           -- This variable is necessary since the ImageHlp.dll 'StackWalk()'
//                                 function doesn't support user-data.  This variable points at
//                                 the 'current' thread info structure for when StackWalk() calls
//                                 'ReadStackMem()'.
static sThreadInfo *gs_pthreadinfoRead;

// EXPLICIT_IMAGEHLP            -- Force explicit loading of imagehlp.dll functionality
#define EXPLICIT_IMAGEHLP

#ifdef EXPLICIT_IMAGEHLP
// We explicitly load all of the ImageHlp functions so that we won't fail to load on a machine
// without ImageHlp.dll.  In order to do this, we define function pointers for all of the ImageHlp
// functions that we need, and use GetProcAddress to obtain those addresses.
typedef BOOL   (__stdcall *SYMINITIALIZEPROC)(HANDLE, LPSTR, BOOL);
typedef BOOL   (__stdcall *SYMCLEANUPPROC)(HANDLE);
typedef BOOL   (__stdcall *STACKWALKPROC)(DWORD, HANDLE, HANDLE, LPSTACKFRAME, LPVOID,
                                          PREAD_PROCESS_MEMORY_ROUTINE,PFUNCTION_TABLE_ACCESS_ROUTINE,
                                          PGET_MODULE_BASE_ROUTINE, PTRANSLATE_ADDRESS_ROUTINE);
typedef LPVOID (__stdcall *SYMFUNCTIONTABLEACCESSPROC)(HANDLE, DWORD);
typedef DWORD  (__stdcall *SYMGETMODULEBASEPROC)(HANDLE, DWORD);
typedef BOOL   (__stdcall *SYMGETSYMFROMADDRPROC)(HANDLE, DWORD, PDWORD, PIMAGEHLP_SYMBOL);
typedef BOOL   (__stdcall *SYMGETMODULEINFOPROC)(HANDLE, DWORD, PIMAGEHLP_MODULE);
typedef BOOL   (__stdcall *SYMGETLINEFROMADDRPROC)(HANDLE, DWORD, PDWORD, PIMAGEHLP_LINE);
typedef BOOL   (__stdcall *SYMLOADMODULEPROC)(HANDLE, HANDLE, LPSTR, LPSTR, DWORD, DWORD);
typedef BOOL   (__stdcall *SYMSETOPTIONSPROC)(DWORD);
typedef PIMAGE_NT_HEADERS (__stdcall *IMAGENTHEADERPROC)(LPVOID);
 
static SYMINITIALIZEPROC           _SymInitialize;
static SYMCLEANUPPROC              _SymCleanup;
static STACKWALKPROC               _StackWalk;
static SYMFUNCTIONTABLEACCESSPROC  _SymFunctionTableAccess;
static SYMGETMODULEBASEPROC        _SymGetModuleBase;
static SYMGETSYMFROMADDRPROC       _SymGetSymFromAddr;
static SYMLOADMODULEPROC           _SymLoadModule;
static SYMGETLINEFROMADDRPROC      _SymGetLineFromAddr;
static SYMGETMODULEINFOPROC        _SymGetModuleInfo;
static SYMSETOPTIONSPROC           _SymSetOptions;
static IMAGENTHEADERPROC           _ImageNtHeader;

// g_hlibImageHlp       -- ImageHlp.dll loaded library
HMODULE g_hlibImageHlp;

#else

// Implicitly referencing ImageHlp.dll functionality.  Call the functions directly
#define _SymInitialize          SymInitialize
#define _SymCleanup             SymCleanup
#define _StackWalk              StackWalk
#define _SymFunctionTableAccess SymFunctionTableAccess
#define _SymGetModuleBase       SymGetModuleBase
#define _SymGetSymFromAddr      SymGetSymFromAddr
#define _SymLoadModule          SymLoadModule
#define _SymGetLineFromAddr     SymGetLineFromAddr
#define _SymGetModuleInfo       SymGetModuleInfo
#define _SymSetOptions          SymSetOptions
#define _ImageNtHeader          ImageNtHeader
#endif




// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ STRUCTURES ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// sCallStack           -- Contains a stack backtrace.
typedef struct
{
    // dwThreadId       -- Id of thread cooresponding to this stack backtrace.
    DWORD dwThreadId;

    // nStackDepth      -- Number of elements in the FuncAddr array
    int nStackDepth;
    
    // rgdwFuncAddr     -- The list of function addresses
    DWORD rgdwFuncAddr[MAX_STACK_DEPTH];

    // rgdwFuncParam    -- the parameters to each function.
    DWORD rgdwFuncParam[MAX_STACK_DEPTH][4];

    // rgszFuncName     -- Name of the function with the matching-index address in rgdwFuncAddr.
    char rgszFuncName[MAX_STACK_DEPTH][MAX_FUNC_NAME_LEN];
} sCallStack;


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  GetModuleBaseAddress
// Purpose:   We need to account for base relocation of the user's module.  To do this, we query
//            the user's application for it's code's unrelocated base address and compare it to
//            the relocated base address (stored in the breakinfo structure at time of crash) in
//            order to calculate the proper offset.  Note that we don't need to do this for Xbox
//            system modules since they are forced to a fixed location (ie aren't allowed to
//            relocate).
// Arguments: szAppPath      -- Path/name of the application to examine
//            dwRelocatedBaseAddress -- The address at which the first section was loaded.
//            pdwBaseAddress  -- Buffer that will contain the final base address of the app to use.
// Return:    'true' if the base address was successfully obtained; 'false' otherwise.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
static bool GetModuleBaseAddress(char *szAppPath, DWORD dwRelocatedBaseAddress, DWORD *pdwBaseAddress)
{
    // Open a handle to the file.  This is necessary for the memory mapped file view we'll create
    // further below.
    HANDLE hfile = CreateFile(szAppPath, GENERIC_READ, 0, NULL, OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL, NULL);
    if (hfile == INVALID_HANDLE_VALUE)
    {
        // Failed to open the specified log file.  Try to figure out why.
        DWORD dwErr = GetLastError();
        switch(dwErr)
        {
        case ERROR_FILE_NOT_FOUND:
            OutputMsg("Error: Cannot find the user application (%s).  It must be in the specified symbol path.\r\n", szAppPath);
            return false;

        case ERROR_ACCESS_DENIED:
            OutputMsg("Error: Cannot access application '%s'.\r\n", szAppPath);
            return false;

        default:
            OutputMsg("Error: An unexpected error occurred trying to access the application '%s'.\r\n", szAppPath);
            return false;
        }
    }

    // Obtain the unrelocated base address of the first section from the application's executable.
    // To do this, we need to create a memory mapped file view of the application to pass to
    // ImageNtHeader.

    // CreateFileMapping is the first step in created a memory mapped file.  It points at the file
    // handle that we opened above.
    HANDLE hfileMap = CreateFileMapping(hfile, NULL, PAGE_READONLY, 0, 0, "xbWatson-file-map");
    if (!hfileMap)
        return false;

    // Now that we've got a file handle, map a view of it into our address space.
    VOID *pvFile = MapViewOfFile(hfileMap, FILE_MAP_READ, 0, 0, 0);
    if (!pvFile)
        return false;

    // Get a pointer to the actual NT Header structure
    IMAGE_NT_HEADERS *pnth = _ImageNtHeader(pvFile);
    if (!pnth)
        return false;
    
    // Get a pointer to the first section in the NT Header
    PIMAGE_SECTION_HEADER pish = (PIMAGE_SECTION_HEADER) ((BYTE*)pnth + sizeof(IMAGE_NT_HEADERS));
    
    // Calculate the final base address
    *pdwBaseAddress = dwRelocatedBaseAddress - pish->VirtualAddress;

    // Clean up after ourselves
    UnmapViewOfFile(pvFile);
    CloseHandle(hfile);

    // Return that we successfully obtained the base address offset.
    return true;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  FileExists
// Purpose:   Checks if the specified file exists.  
// Arguments: szFullPathFileName -- Full path and file name of the file to check
// Return:    'true' if the file exists.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
static bool FileExists(char *szFullPathFileName)
{
    // Try opening the file.
    HANDLE hfile = CreateFile(szFullPathFileName, GENERIC_READ, 0, NULL, OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL, NULL);
    if (hfile == INVALID_HANDLE_VALUE)
        return false;

    // File was opened successfully (so it exists).  Close the handle since we don't actually use it
    CloseHandle(hfile);
    return true;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  InitImageHlp
// Purpose:   Initializes ImageHlp.dll symbol-lookup functionality and loads the appropriate modules
//            so that we can later map addresses to function names.
// Arguments: szSymPath     -- Path to the app's exe and pdb files (ie symbol information).
//            pbreakinfo    -- Structure containing module information at time of crash.
// Return:    'true' if the symbol-lookup functionality was successfully initialized.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
static bool InitImageHlp(char *szSymPath, sBreakInfo *pbreakinfo)
{
    char szXBDMPath[MAX_PATH];
    char szXboxKrnlPath[MAX_PATH];
    char szUserAppName[MAX_PATH];
    char szUserAppPath[MAX_PATH];
    char szXboxSDKPath[MAX_PATH];
    bool fLoaded;

#ifdef EXPLICIT_IMAGEHLP
    // Verify that ImageHlp exists on this user's machine
    g_hlibImageHlp = LoadLibrary("ImageHlp.dll");
    if (!g_hlibImageHlp)
        return false;

    // Get function addresses to each of the functions in ImageHlp that we'll need
    _SymInitialize = (SYMINITIALIZEPROC)GetProcAddress(g_hlibImageHlp, "SymInitialize");
    if (!_SymInitialize)
        return false;

    _SymCleanup = (SYMCLEANUPPROC)GetProcAddress(g_hlibImageHlp, "SymCleanup");
    if (!_SymCleanup)
        return false;

    _StackWalk = (STACKWALKPROC)GetProcAddress(g_hlibImageHlp, "StackWalk");
    if (!_StackWalk)
        return false;

    _SymFunctionTableAccess = (SYMFUNCTIONTABLEACCESSPROC)GetProcAddress(g_hlibImageHlp, "SymFunctionTableAccess");
    if (!_SymFunctionTableAccess)
        return false;

    _SymGetModuleBase = (SYMGETMODULEBASEPROC)GetProcAddress(g_hlibImageHlp, "SymGetModuleBase");
    if (!_SymGetModuleBase)
        return false;

    _SymGetSymFromAddr = (SYMGETSYMFROMADDRPROC)GetProcAddress(g_hlibImageHlp, "SymGetSymFromAddr");
    if (!_SymGetSymFromAddr)
        return false;

    _SymLoadModule = (SYMLOADMODULEPROC)GetProcAddress(g_hlibImageHlp, "SymLoadModule");
    if (!_SymLoadModule)
        return false;

    _SymGetModuleInfo = (SYMGETMODULEINFOPROC)GetProcAddress(g_hlibImageHlp, "SymGetModuleInfo");
    if (!_SymGetModuleInfo)
        return false;

    _SymSetOptions = (SYMSETOPTIONSPROC)GetProcAddress(g_hlibImageHlp, "SymSetOptions");
    if (!_SymSetOptions)
        return false;

    _ImageNtHeader = (IMAGENTHEADERPROC)GetProcAddress(g_hlibImageHlp, "ImageNtHeader");
    if (!_ImageNtHeader)
        return false;

    // NOTE: "SymGetLineFromAddr()" was introduced in WinNT5.  We will still run if the user has
    //       an older version of ImageHlp, but they won't get actual line numbers, just function names
    //       and offsets.
    _SymGetLineFromAddr = (SYMGETLINEFROMADDRPROC)GetProcAddress(g_hlibImageHlp, "SymGetLineFromAddr");

    // We successfully loaded each function pointer.  Initialize ImageHlp now.
#endif

    // Initialize the ImageHlp.dll symbol-lookup functionality.
    if (!_SymInitialize((HANDLE)1, NULL, false))
    {
        // ImageHlp.dll doesn't appear to be on this machine.  Warn the user but continue anyways
        // so that they can see the callstack addresses.
        OutputMsg("Warning: ImageHlp.dll was not successfully loaded.  xbWatson will continue but cannot determine function names\r\n");
        return false;
    }

    // Set options so that we can get line numbers.  Also undecorate names.
    _SymSetOptions(SYMOPT_LOAD_LINES | SYMOPT_UNDNAME);

    // Get the XBox SDK installation point from the Registry
    HKEY  hkey;
    DWORD dwByte = 1024;
    RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\XboxSDK"), 0, KEY_READ, &hkey);
    if (RegQueryValueEx(hkey, "InstallPath", NULL,
                        NULL, (LPBYTE) szXboxSDKPath, &dwByte) != ERROR_SUCCESS)
    {
        // The SDK doesn't appear to be properly installed.  We don't force failure because the
        // user could still run this on a non-XDK machine (although they shouldn't).  The warnings
        // below will suffice to notify the user of the lack of xbox system dll symbols.
        sprintf(szXboxSDKPath, "");
    }
    else
        strcat(szXboxSDKPath, "\\Xbox\\Symbols");
    
    RegCloseKey(hkey);

    // Generate the names of the Xbox kernel and XBDM executables so that we can load them.
#define EXTERNAL
#ifdef EXTERNAL
    sprintf(szXBDMPath, "%s\\XBDM.dll", szXboxSDKPath);
    sprintf(szXboxKrnlPath, "%s\\XboxKrnl.exe", szXboxSDKPath);
#else
    sprintf(szXBDMPath, "%s\\XBDM.dll", "C:\\xboxbins\\devkit");
    sprintf(szXboxKrnlPath, "%s\\XboxKrnl.exe", "C:\\xboxbins");
#endif

    // Load the Xbox modules (this sets up the Sym functions so that they can find function addresses.
    // UNDONE-WARN: I'm unable to load symbols for BOTH XBDM and the user's app simultaneously.  I'm not
    //              sure why (conflicting base addresses would be my guess).  For now, the user's app is
    //              more important than XBDM symbols, so XBDM is out of here...
#if 0
    fLoaded = _SymLoadModule((HANDLE)1, NULL, szXBDMPath, NULL, 0, 0) ? 1 : 0;
#endif

    fLoaded = _SymLoadModule((HANDLE)1, NULL, szXboxKrnlPath, NULL, 0, 0) ? 1 : 0;
    if (!fLoaded)
    {
        // Failed to load the Xbox symbols.  Warn the user, but continue on regardless
        OutputMsg("Warning: could not load Xbox system symbols from '%s'.  Please verify installation.\r\n",
                  szXboxSDKPath);
    }

    // Output the stack dump header
    OutputMsg("* Stack backtrace for log file created at %d/%d/%d @ %d:%d:%d.%d:\r\n",
              pbreakinfo->systime.wMonth, pbreakinfo->systime.wDay, pbreakinfo->systime.wYear,
              pbreakinfo->systime.wHour, pbreakinfo->systime.wMinute, pbreakinfo->systime.wSecond,
              pbreakinfo->systime.wMilliseconds);

    // Now load the user-specific module.
    // Given pbreakinfo->szAppName="path\app.xbe", Search priority ==
    //    (a) from specified symbol path
    //    (b) from full path stored in appname

    // Verify a valid szAppName
    if (!strrchr(pbreakinfo->szAppName, '\\'))
    {
        _SymCleanup((HANDLE)1);
        return false;
    }

    // Determine the .exe name
    strcpy(szUserAppName, strrchr(pbreakinfo->szAppName, '\\')+1);
    *(strrchr(szUserAppName, '.')) = '\0';
    strcat(szUserAppName, ".exe");

    // See if the user's app's exe is in the specified symbol path.
    sprintf(szUserAppPath, "%s\\%s", szSymPath, szUserAppName);
    if (!FileExists(szUserAppPath))
    {
        // Not in the specified symbol path; check if it's in the path specified in the app itself
        // Couldn't find it there either
        OutputMsg(" (Warning: \"%s\" not found at specified symbol path (\"%s\")).\r\n", szUserAppName, szSymPath);
        sprintf(szUserAppPath, "%s", pbreakinfo->szAppName);
        if (!FileExists(szUserAppPath))
        {
            // Couldn't find it there either.  User doesn't get symbols!
            OutputMsg(" (Warning: \"%s\" not found at embedded path (\"%s\")).\r\n", szUserAppName,
                      pbreakinfo->szAppName);

            // Return that imagehlp was successfully initialized - the user just doesn't see symbols
            return true;
        }
    }

    OutputMsg(" (User app found at: %s)\r\n", szUserAppPath);

    // We need to account for base relocation of the user's module.  To do this, we query the user's
    // application for it's code's unrelocated base address and compare it to the relocated base address
    // (stored in the breakinfo structure at time of crash) in order to calculate the proper offset.
    // Note that we don't need to do this for Xbox system modules since they are forced to a fixed
    // location (ie aren't allowed to relocate).
    DWORD dwUserAppBaseAddress;

    if (!GetModuleBaseAddress(szUserAppPath, pbreakinfo->dwFirstSectionBase, &dwUserAppBaseAddress))
    {
        OutputMsg("Error: Unable to load user application from '%s'.\r\n", szUserAppPath);
        return false;
    }

    // Load the user's application's symbols
    if (!_SymLoadModule((HANDLE)1, NULL, szUserAppPath, NULL, dwUserAppBaseAddress, 0))
    {
        // Failed to load the user's executable.  Warn them but continue (they can still see addresses)
        OutputMsg("Warning: '%s' not found at specified symbol path (%s).\r\n", szUserAppName, szSymPath);
    }
    
    // Return that we successfully initialized ImageHlp.dll.
    return true;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  UninitImageHlp
// Purpose:   Uninitializes ImageHlp.dll symbol-lookup functionality.
// Arguments: None.
// Return:    None.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
static void UninitImageHlp()
{
    _SymCleanup((HANDLE)1);

#ifdef EXPLICIT_IMAGEHLP
    // Release our handle to the imagehlp library
    FreeLibrary(g_hlibImageHlp);
#endif
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  LoadLogFile
// Purpose:   Loads the specified log file and passes it's contents back in the specified buffer.
// Arguments: szLogFileName     -- Name of the log file to load
//            pbreakinfo        -- The breakinfo structure we'll fill in here.
// Return:    'true' if successfully loaded; 'false' otherwise.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
static bool LoadLogFile(char *szLogFileName, sBreakInfo *pbreakinfo)
{
    // Open the specified log file
    HANDLE hfileLog = CreateFile(szLogFileName, GENERIC_READ, 0, NULL, OPEN_EXISTING,
                                 FILE_ATTRIBUTE_NORMAL, NULL);
    if (hfileLog == INVALID_HANDLE_VALUE)
    {
        // Failed to open the specified log file.  Try to figure out why.
        DWORD dwErr = GetLastError();
        switch(dwErr)
        {
        case ERROR_FILE_NOT_FOUND:
            OutputMsg("Error: Cannot find the specified log file (\"%s\").  It must be in the current directory or specified path.\r\n", szLogFileName);
            return false;

        case ERROR_ACCESS_DENIED:
            OutputMsg("Error: Cannot access specified log file (\"%s\").\r\n", szLogFileName);
            return false;

        default:
            OutputMsg("Error: An unexpected error occurred trying to access the specified log file (\"%s\").\r\n", szLogFileName);
            return false;
        }
    }

    if (!ReadBreakInfo(hfileLog, pbreakinfo))
    {
        // Failed to read the info for some reason.
        OutputMsg("Error: Invalid log file (\"%s\") specified.\r\n", szLogFileName);
        CloseHandle(hfileLog);
        return false;
    }

    // We successfully read from the file.  Close the file and we're done!
    CloseHandle(hfileLog);

    return true;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  ReadStackMem
// Purpose:   Reads a block of memory from the stored Xbox stack.  Called by the StackWalk function
//            when walking the stack.
// Arguments: hProcess          -- Ignored since the Xbox only has one process.
//            pvBaseAddress     -- Address to start reading from.
//            pvBuffer          -- Destination buffer to copy the bits to.
//            nSize             -- Number of bytes to read.
//            pdwNumBytesRead   -- Number of bytes read.
// Returns:   'true' if memory successfully read; 'false' otherwise.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
BOOL __stdcall ReadStackMem(HANDLE hProcess, DWORD pvBaseAddress, void *pvBuffer, DWORD nSize,
                            DWORD *pdwNumBytesRead)
{
    // Since the StackWalk function doesn't allow passing of user-data, we need to go through a
    // global to track the 'current' threadinfo that is being read.

    // Calculate the real address being requested
    DWORD dwAddrReal = (DWORD)pvBaseAddress - gs_pthreadinfoRead->dwStackBase;

    // Verify the caller requested a valid address range
    if ((int)dwAddrReal < 0 || (int)dwAddrReal > (int)gs_pthreadinfoRead->dwStackSize)
    {
        // Uh oh, an out-of-range address was requested.  While ya might think returning 'false'
        // would be the right thing to do, you'd be wrong.  Instead we pretend we actually were
        // able to read from the requested location, only we indicate that no bytes were actually
        // read.  Confusing?  Sure, but it's what StackWalk needs to be happy.
        *pdwNumBytesRead = 0;
        memset(pvBuffer, 0, nSize);
        return true;
    }

    *pdwNumBytesRead = min(nSize, gs_pthreadinfoRead->dwStackSize - dwAddrReal);

    // Copy the requested memory
    memcpy(pvBuffer, &gs_pthreadinfoRead->rgbyStack[dwAddrReal], *pdwNumBytesRead);
    return true;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  GenerateCallstack
// Purpose:   Given a set of thread stack information, uses ImageHlp.dll to walk through the stack
//            and determine the stack back trace.
// Arguments: pcallstack        -- Pointer to the call stack structure we'll fill in.
//            pthreadinfo       -- Structure containing stack information (stack dump, Esp, etc).
// Return:    'true' if callback stack successfully generated; 'false' otherwise.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
static bool GenerateCallstack(sCallStack *pcallstack, sThreadInfo *pthreadinfo)
{
    // sf           -- The structure containing context information for StackWalk
    STACKFRAME sf;

    // Initialize the stackframe structure with values that are consistent across all addresses
    memset (&sf, 0, sizeof(sf));
    sf.AddrPC.Mode    = AddrModeFlat;
    sf.AddrStack.Mode = AddrModeFlat;
    sf.AddrFrame.Mode = AddrModeFlat;

    sf.AddrPC.Offset    = pthreadinfo->cr.Eip;
    sf.AddrStack.Offset = pthreadinfo->cr.Esp;
    sf.AddrFrame.Offset = pthreadinfo->cr.Ebp;

    // Initialize the callstack
    pcallstack->nStackDepth = 0;

    // Store a global pointer to the 'current' threadinfo structure.  This is necessary since
    // StackWalk doesn't support user-data
    gs_pthreadinfoRead = pthreadinfo;

    // Walk the stack
    while (true)
    {
        if (!_StackWalk(IMAGE_FILE_MACHINE_I386, (HANDLE) 1, (HANDLE)1, &sf, 0, &ReadStackMem,
                       _SymFunctionTableAccess, _SymGetModuleBase, 0))
            break;

        // Copy the backtrace information
        pcallstack->rgdwFuncAddr[pcallstack->nStackDepth] = sf.AddrPC.Offset;
        pcallstack->rgdwFuncParam[pcallstack->nStackDepth][0] = sf.Params[0];
        pcallstack->rgdwFuncParam[pcallstack->nStackDepth][1] = sf.Params[1];
        pcallstack->rgdwFuncParam[pcallstack->nStackDepth][2] = sf.Params[2];
        pcallstack->rgdwFuncParam[pcallstack->nStackDepth][3] = sf.Params[3];
        pcallstack->nStackDepth++;
    }

    // Set misc thread info
    pcallstack->dwThreadId = pthreadinfo->dwThreadId;

    return true;
}


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  GetSymNames
// Purpose:   Enumerate the list of addresses in the specified callstack and try to assign function
//            names to them using the ImageHlp.dll symbol-lookup functionality
// Arguments: pcallstack        -- Pointer to the call stack structure with addresses to convert.
// Return:    None.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
static void GetSymNames(sCallStack *pcallstack)
{
    char szBuffer[1024];

    // UNDONE-WARN: Comment this better.

    // Iterate over each address in the recorded call stack, and try to determine the actual symbol
    // name and offset of each stack address.
    for (int i = 0; i < pcallstack->nStackDepth; i++)
    {
        DWORD            dwSymDisp = 0;
        BYTE             bySymBuf[sizeof(IMAGEHLP_SYMBOL) + 512];
        PIMAGEHLP_SYMBOL pihs = (PIMAGEHLP_SYMBOL)bySymBuf;
        IMAGEHLP_MODULE mi;
        memset(&mi, 0, sizeof(mi));
        mi.SizeOfStruct = sizeof(IMAGEHLP_MODULE);
        pihs->SizeOfStruct  = sizeof(bySymBuf);
        pihs->MaxNameLength = 512;

        strcpy(pcallstack->rgszFuncName[i], "    ");

        if (_SymGetModuleInfo((HANDLE)1, pcallstack->rgdwFuncAddr[i] - dwSymDisp, &mi))
        {
            strcat(pcallstack->rgszFuncName[i], mi.ModuleName);
            strcat(pcallstack->rgszFuncName[i], "!");
        }
        else
            strcat(pcallstack->rgszFuncName[i], "Unknown!");

        // Lookup the next function address in the callstack and see if we can match a function name
        // to it.
        if (_SymGetSymFromAddr((HANDLE)1, pcallstack->rgdwFuncAddr[i], &dwSymDisp, pihs))
            sprintf(szBuffer, "%hs + 0x%X\r\n    ", pihs->Name, dwSymDisp);
        else
            sprintf(szBuffer, "Unknown Function\r\n    ");

        strcat(pcallstack->rgszFuncName[i], szBuffer);
        strcat(pcallstack->rgszFuncName[i], "(");

        // If the user has a new-enough ImageHlp.dll, then they have 'SymGetLineFromAddr()' access.
        if (_SymGetLineFromAddr)
        {
            IMAGEHLP_LINE stLine;

            // Initialize the stLine structure as SymGetLineFromAddr needs.
            memset(&stLine, 0, sizeof(IMAGEHLP_LINE));
            stLine.SizeOfStruct = sizeof(IMAGEHLP_LINE);
            
            // Get the line number of the specified address.
            if (_SymGetLineFromAddr((HANDLE)1, pcallstack->rgdwFuncAddr[i], &dwSymDisp, &stLine))
            {
                // Successfully got the line number.  Need to append it to the buffer
                sprintf(szBuffer, "File: '%s'  Line#: %d)", stLine.FileName, stLine.LineNumber);
                strcat(pcallstack->rgszFuncName[i], szBuffer);
            }
            else
                strcat(pcallstack->rgszFuncName[i], "Unknown file)");
        }
        else
            strcat(pcallstack->rgszFuncName[i], "Unknown file)");
    }
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  ParseLogFile
// Purpose:   Parses the xbWatson log file, determines the function names of the callstack(s)  (using
//            ImageHlp.dll) and dumps it to the command prompt.
// Arguments: szLogFileName     -- Name of the log file to dump
//            szSymPath         -- Path containing symbols related to the specified log file's app.
// Return:    '1' if successful, '0' otherwise.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
int ParseLogFile(char *szLogFileName, char *szSymPath)
{
    // nRet             -- Returned value; by default we assume everything went fine.
    int nRet = 1;

    // iThread          -- Used to walk the array of threads
    DWORD iThread;

    // callstack        -- Contains information pertaining to a thread's callstack.
    sCallStack callstack;

    // breakinfo        -- Information about the break.
    sBreakInfo breakinfo;


    // Load the user-specified dump log.
    if (!LoadLogFile(szLogFileName, &breakinfo))
    {
        // Failed to load the log file.  LoadLogFile already notified the user of the error, so
        // don't bother printing anything here.
        return 0;
    }

    // Initalize ImageHlp.dll so that we can walk the stack and determine function names from
    // addresses.  Note that we require ImageHlp to do this, so if it failed to load we're hosed.
    if (!InitImageHlp(szSymPath, &breakinfo))
    {
        // Failed to initialize ImageHlp.dll.  InitImageHlp already notified the user of the error,
        // so don't bother printing anything here.
        return 0;
    }

    OutputMsg("\r\n- Loaded Modules:\r\n");
    
    // Dump the module list
    for (DWORD iModule = 0; iModule < breakinfo.cModules; iModule++)
    {
        OutputMsg("    (%08x - %08x)  %s\r\n", breakinfo.prgdmnml[iModule].BaseAddress, 
                                               (DWORD)breakinfo.prgdmnml[iModule].BaseAddress +
                                                      breakinfo.prgdmnml[iModule].Size,
                                               breakinfo.prgdmnml[iModule].Name);
    }

    // Given the breakinfo, now determine the actual callstack addresses for each thread
    for (iThread = 0; iThread < breakinfo.cThreads; iThread++)
    {
        // Generate the callback stack from the thread's stack dump
        if (!GenerateCallstack(&callstack, &breakinfo.prgthreadinfo[iThread]))
        {
            // Failed to generate the back trace callstack for this thread, so just ignore it
            OutputMsg("\r\n-Backtrace for thread 0x%08x:\r\n", callstack.dwThreadId);
            OutputMsg("    Failed to generate callstack from stack dump.\r\n");
        }
        else
        {
            // Output the thread header
            OutputMsg("\r\n-Thread 0x%08x", callstack.dwThreadId);
            if (callstack.dwThreadId == breakinfo.dwBrokenThreadId)
            {
                // This is the thread in which the break event occurred.  Output information about
                // the break event.
                switch(breakinfo.dwEventType)
                {
                case IDD_EXCEPTION:
                    OutputMsg(", Exception 0x%08x", breakinfo.dwEventCode);
                    switch(breakinfo.dwEventCode)
                    {
                    case 0x80000003:
                        // Breakpoint
                        OutputMsg(" (Breakpoint)");
                        break;

                    case 0xC0000005:
                        // Access Violation
                        if (breakinfo.fWriteException)
                            OutputMsg(" (Write violation at \"0x%08X\")", breakinfo.dwAVAddress);
                        else
                            OutputMsg(" (Read violation at \"0x%08X\")", breakinfo.dwAVAddress);
                        break;
                    }
                    break;

                case IDD_RIP:
                    OutputMsg(", RIP -- \"%s\"", breakinfo.szRIP);
                    break;
                }
            }
            else
                OutputMsg("\r\n");

            // Dump register information for this thread
            OutputMsg("\r\n  Registers:\r\n  eax:0x%08x ebx:0x%08x ecx:0x%08x edx:0x%08x eip:0x%08x\r\n" \
                      "  esi:0x%08x edi:0x%08x esp:0x%08x ebp:0x%08x eflags:0x%08x\r\n",
                      breakinfo.prgthreadinfo[iThread].cr.Eax, breakinfo.prgthreadinfo[iThread].cr.Ebx,
                      breakinfo.prgthreadinfo[iThread].cr.Ecx, breakinfo.prgthreadinfo[iThread].cr.Edx,
                      breakinfo.prgthreadinfo[iThread].cr.Eip, breakinfo.prgthreadinfo[iThread].cr.Esi,
                      breakinfo.prgthreadinfo[iThread].cr.Edi, breakinfo.prgthreadinfo[iThread].cr.Esp,
                      breakinfo.prgthreadinfo[iThread].cr.Ebp, breakinfo.prgthreadinfo[iThread].cr.EFlags);

            // Get the symbol names
            GetSymNames(&callstack);

            // Dump the obtained callstack
            OutputMsg("\r\n  Callstack:\r\n  Addr       Param1       Param2      Param3      Param4\r\n");
            for (int i = 0; i < callstack.nStackDepth; i++)
            {
                // Output the information related to this address in the callstack.
                OutputMsg("  0x%08x (0x%08x, 0x%08x, 0x%08x, 0x%08x)\r\n%s\r\n\r\n",
                          callstack.rgdwFuncAddr[i], callstack.rgdwFuncParam[i][0], 
                          callstack.rgdwFuncParam[i][1], callstack.rgdwFuncParam[i][2],
                          callstack.rgdwFuncParam[i][3], callstack.rgszFuncName[i]);
            }
        }
        OutputMsg("\r\n");
    }

    // Clean up after ourselves
    UninitImageHlp();

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\watson\xbdumplog\StdAfx.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:     StdAfx.cpp
// Contents: Source file that includes just the standard includes file.
//           'xbWatson.pch' will be the pre-compiled header.
//           'stdafx.obj' will be the pre-compiled type information.
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\watson\xbdumplog\StdAfx.h ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:     stdafx.h
// Contents: Precompiled header file.  Include all common header files here.
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ==== Windows Header Files ====
#include <windows.h>
#include <commdlg.h>

// ==== C RunTime Header Files ====
#include <stdlib.h>
#include <stdio.h>
#include <malloc.h>
#include <memory.h>
#include <tchar.h>


// ==== External Support Header Files ====
#include <imagehlp.h>


// ==== Xbox header files ====

// "xboxdbg.h"      -- Functionality that communicates with Xbox.  Necessary for structures...
#include "xboxdbg.h"


// ==== xbWatson Header Files ====
#include "..\xbWatson\Resource.h"
#include "..\xbWatson\GetBreakInfo.h"


// ==== Local Header Files ====
#include "xbDumpLog.h"
#include "ParseLogFile.h"
#include "ReadWriteBreakInfo.h"
#include "Output.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\watson\xbdumplog\ReadWriteBreakInfo.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:     ReadWriteBreakInfo.cpp
// Contents: Contains code to read/write a break info structure from/to a file
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"

// UNDONE: This is the same file as found in xbDumpLog.  Should share code (common lib?) to avoid
//         making a change in one place but not the other...


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ GLOBAL VARIABLES ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// gs_szSignature   -- Specifies the file type.  If the file signature in a specified file doesn't
//                     match this signature, then it is considered an incorrect or mangled file.
//                     In the future, this signature will be used for backwards compatibility.
static char gs_szSignature[] = "XBW1.0";


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  ReadBytes
// Purpose:   Reads bytes from a file and verifies the read succeeded.
// Arguments: hfile             -- The file to read the bytes from.
//            pvBuffer          -- The buffer to read the bytes to.
//            cBytes            -- The number of bytes to read.
// Returns:   'true' if successful, 'false' otherwise
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
static bool ReadBytes(HANDLE hfile, void *pvBuffer, DWORD cBytes)
{
    DWORD dwRead;

    // Read the requested number of bytes from the file.
    if (!ReadFile(hfile, pvBuffer, cBytes, &dwRead, NULL))
        return false;

    // Make sure we read all the bytes we expected to read
    if (dwRead != cBytes)
        return false;

    // Read successful!
    return true;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  WriteBytes
// Purpose:   Writes bytes from a file and verifies the write succeeded.
// Arguments: hfile             -- The file to write the bytes to.
//            pvBuffer          -- The buffer to read the bytes from.
//            cBytes            -- The number of bytes to write.
// Returns:   'true' if successful, 'false' otherwise
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
static bool WriteBytes(HANDLE hfile, void *pvBuffer, DWORD cBytes)
{
    DWORD dwWritten;

    // Write the requested number of bytes to the file.
    if (!WriteFile(hfile, pvBuffer, cBytes, &dwWritten, NULL))
        return false;

    // Make sure we wrote all the bytes we expected to write
    if (dwWritten != cBytes)
        return false;

    // Write successful!
    return true;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  WriteBreakInfo
// Purpose:   Outputs a breakinfo structure to the specified file.  This function does a DEEP copy.
// Arguments: hfile             -- The file to write the breakinfo structure to.
//            pbreakinfo        -- The breakinfo structure to write out
// Returns:   'true' if successful, 'false' otherwise
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool WriteBreakInfo(HANDLE hfile, sBreakInfo *pbreakinfo)
{
    // Write out our signature
    if (!WriteBytes(hfile, gs_szSignature, sizeof(gs_szSignature)))
        return false;

    // Write out the Xbox name, time, and application name to the file
    if (!WriteBytes(hfile, &pbreakinfo->szXboxName, sizeof(pbreakinfo->szXboxName)) || 
        !WriteBytes(hfile, &pbreakinfo->systime, sizeof(pbreakinfo->systime))       ||
        !WriteBytes(hfile, &pbreakinfo->szAppName, sizeof(pbreakinfo->szAppName)))
        return false;

    // Write out the type of event that occurred, as well as the thread id in which it occurred.
    if (!WriteBytes(hfile, &pbreakinfo->dwEventType, sizeof(pbreakinfo->dwEventType)))
        return false;
    if (!WriteBytes(hfile, &pbreakinfo->dwBrokenThreadId, sizeof(pbreakinfo->dwBrokenThreadId)))
        return false;
    
    // If the event was a RIP, then write out the RIP string.
    if (pbreakinfo->dwEventType == IDD_RIP)
    {
        if (!WriteBytes(hfile, pbreakinfo->szRIP, sizeof(pbreakinfo->szRIP)))
            return false;
    }
    else
    {
        // It was an exception - write out the exception info
        if (!WriteBytes(hfile, &pbreakinfo->dwEventCode, sizeof(pbreakinfo->dwEventCode)))
            return false;
        if (!WriteBytes(hfile, &pbreakinfo->fWriteException, sizeof(pbreakinfo->fWriteException)))
            return false;
        if (!WriteBytes(hfile, &pbreakinfo->dwAVAddress, sizeof(pbreakinfo->dwAVAddress)))
            return false;
    }

    // Write out the module information to the file
    if (!WriteBytes(hfile, &pbreakinfo->cModules, sizeof(pbreakinfo->cModules)))
        return false;
    if (!WriteBytes(hfile, pbreakinfo->prgdmnml, sizeof(DMN_MODLOAD) * pbreakinfo->cModules))
        return false;
    
    // Write out thread informaton to the file
    if (!WriteBytes(hfile, &pbreakinfo->cThreads, sizeof(pbreakinfo->cThreads)))
        return false;

    for (DWORD i = 0; i < pbreakinfo->cThreads; i++)
    {
        sThreadInfo *pthreadinfo = &pbreakinfo->prgthreadinfo[i];
        if (pthreadinfo->fValid)
        {
            if (!WriteBytes(hfile, &pthreadinfo->cr,          sizeof(pthreadinfo->cr))          ||
                !WriteBytes(hfile, &pthreadinfo->dwThreadId,  sizeof(pthreadinfo->dwThreadId))  ||
                !WriteBytes(hfile, &pthreadinfo->dwStackBase, sizeof(pthreadinfo->dwStackBase)) ||
                !WriteBytes(hfile, &pthreadinfo->dwStackSize, sizeof(pthreadinfo->dwStackSize)))
                return false;
            if (!WriteBytes(hfile, pthreadinfo->rgbyStack, sizeof(BYTE) * pthreadinfo->dwStackSize))
                return false;
        }
    }

    // Finally, write out the RELOCATED base address of the first section
    if (!WriteBytes(hfile, &pbreakinfo->dwFirstSectionBase, sizeof(DWORD)))
        return false;

    return true;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  ReadBreakInfo
// Purpose:   Reads a breakinfo structure from the specified file.
// Arguments: hfile             -- The file to read the breakinfo structure from.
//            pbreakinfo        -- The breakinfo structure to read in.
// Returns:   'true' if successful, 'false' otherwise
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool ReadBreakInfo(HANDLE hfile, sBreakInfo *pbreakinfo)
{
    // szSignature      -- Used to verify the specified file is the correct type
    char szSignature[7];

    // Read in the file signature and verify it's the version we expect
    if (!ReadBytes(hfile, szSignature, sizeof(szSignature)))
        return false;
    if (strcmp(szSignature, gs_szSignature))
    {
        // Signatures don't match!
        return false;
    }

    // Read in the Xbox name, time, and application name from the file
    if (!ReadBytes(hfile, &pbreakinfo->szXboxName, sizeof(pbreakinfo->szXboxName)) || 
        !ReadBytes(hfile, &pbreakinfo->systime, sizeof(pbreakinfo->systime))        ||
        !ReadBytes(hfile, &pbreakinfo->szAppName, sizeof(pbreakinfo->szAppName)))
        return false;

    // Read in the type of event that occurred, as well as the thread id in which it occurred.
    if (!ReadBytes(hfile, &pbreakinfo->dwEventType, sizeof(pbreakinfo->dwEventType)))
        return false;
    if (!ReadBytes(hfile, &pbreakinfo->dwBrokenThreadId, sizeof(pbreakinfo->dwBrokenThreadId)))
        return false;
    
    // If the event was a RIP, then read in the RIP string.
    if (pbreakinfo->dwEventType == IDD_RIP)
    {
        if (!ReadBytes(hfile, pbreakinfo->szRIP, sizeof(pbreakinfo->szRIP)))
            return false;
    }
    else
    {
        // It was an exception - read in the exception info
        if (!ReadBytes(hfile, &pbreakinfo->dwEventCode, sizeof(pbreakinfo->dwEventCode)))
            return false;
        if (!ReadBytes(hfile, &pbreakinfo->fWriteException, sizeof(pbreakinfo->fWriteException)))
            return false;
        if (!ReadBytes(hfile, &pbreakinfo->dwAVAddress, sizeof(pbreakinfo->dwAVAddress)))
            return false;
    }

    // Read in the number of modules from the file
    if (!ReadBytes(hfile, &pbreakinfo->cModules, sizeof(pbreakinfo->cModules)))
        return false;
    
    // Allocate space for the modules.
    pbreakinfo->prgdmnml = new DMN_MODLOAD[pbreakinfo->cModules];
    if (pbreakinfo->prgdmnml == NULL)
        return false;

    // Read in the actual module information
    if (!ReadBytes(hfile, pbreakinfo->prgdmnml, sizeof(DMN_MODLOAD) * pbreakinfo->cModules))
        return false;
    
    // Read the number of threads in this break event.
    if (!ReadBytes(hfile, &pbreakinfo->cThreads, sizeof(pbreakinfo->cThreads)))
        return false;

    // Allocate space for the threads
    pbreakinfo->prgthreadinfo = new sThreadInfo[pbreakinfo->cThreads];
    if (pbreakinfo->prgthreadinfo == NULL)
        return false;

    // Read in thread informaton from the file
    for (DWORD i = 0; i < pbreakinfo->cThreads; i++)
    {
        sThreadInfo *pthreadinfo = &pbreakinfo->prgthreadinfo[i];
        if (!ReadBytes(hfile, &pthreadinfo->cr,          sizeof(pthreadinfo->cr))          ||
            !ReadBytes(hfile, &pthreadinfo->dwThreadId,  sizeof(pthreadinfo->dwThreadId))  ||
            !ReadBytes(hfile, &pthreadinfo->dwStackBase, sizeof(pthreadinfo->dwStackBase)) ||
            !ReadBytes(hfile, &pthreadinfo->dwStackSize, sizeof(pthreadinfo->dwStackSize)))
            return false;

        // Allocate space for the stack
        pthreadinfo->rgbyStack = new BYTE[pthreadinfo->dwStackSize];

        // Read in the actual bytes of the stack
        if (!ReadBytes(hfile, pthreadinfo->rgbyStack, sizeof(BYTE) * pthreadinfo->dwStackSize))
            return false;

        // The 'fValid' flag is really only used in writing out a break info file, but we'll set
        // it here for completeness' sake.
        pthreadinfo->fValid = true;
    }

    // Finally, get the RELOCATED base address of the first section
    if (!ReadBytes(hfile, &pbreakinfo->dwFirstSectionBase, sizeof(DWORD)))
        return false;

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\watson\xbdumplog\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by xbWatson.rc
//
#define IDC_MYICON                      2
#define ID_IGNORE                       3
#define ID_CONTINUE                     4
#define IDD_XBWATSON_DIALOG             102
#define IDD_ABOUTBOX                    103
#define IDS_APP_TITLE                   103
#define IDM_ABOUT                       104
#define IDM_EXIT                        105
#define IDS_HELLO                       106
#define IDI_XBWATSON                    107
#define IDI_SMALL                       108
#define IDC_XBWATSON                    109
#define IDR_MAINFRAME                   128
#define IDD_ASSERT                      129
#define IDI_RED_X                       130
#define IDD_EXCEPTION                   134
#define IDD_RIP                         135
#define IDD_BREAKPOINT                  137
#define ID_ABORT                        1001
#define ID_RETRY                        1002
#define ID_REBOOT                       1004
#define ID_DUMP                         1005
#define IDC_RIP                         1006
#define ID_DONOTHING                    1008
#define IDM_SAVE                        32771
#define ID_EDIT_CUT                     32772
#define ID_EDIT_COPY                    32773
#define ID_EDIT_PASTE                   32774
#define ID_EDIT_DELETE                  32775
#define ID_EDIT_SELECTALL               32777
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        138
#define _APS_NEXT_COMMAND_VALUE         32778
#define _APS_NEXT_CONTROL_VALUE         1009
#define _APS_NEXT_SYMED_VALUE           110
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\watson\xbdumplog\ReadWriteBreakInfo.h ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:     ReadWriteBreakInfo.h
// Contents: Contains declarations of functions and variables defined in ReadWriteBreakInfo.cpp
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  WriteBreakInfo
// Purpose:   Outputs a breakinfo structure to the specified file.  This function does a DEEP copy.
// Arguments: hfile             -- The file to write the breakinfo structure to.
//            pbreakinfo        -- The breakinfo structure to write out
// Returns:   'true' if successful, 'false' otherwise
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool WriteBreakInfo(HANDLE hfile, sBreakInfo *pbreakinfo);

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  ReadBreakInfo
// Purpose:   Reads a breakinfo structure from the specified file.
// Arguments: hfile             -- The file to read the breakinfo structure from.
//            pbreakinfo        -- The breakinfo structure to read in.
// Returns:   'true' if successful, 'false' otherwise
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool ReadBreakInfo(HANDLE hfile, sBreakInfo *pbreakinfo);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\watson\xbdumplog\xbDumpLog.h ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:     xbWatson.h
// Contents: Contains declarations of functions and variables defined in xbWatson.cpp
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ ENUMERATIONS ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// eMode            -- Contains the various modes that this application can run in.
typedef enum eMode
{
    // MODE_LOGGING -- In this mode, xbWatson displays a log view window, allows the user to save the
    //                 log, and displays Xbox assert messages.
    MODE_LOGGING,

    // MODE_STACKDUMP -- In this mode, xbWatson parses a previously created log file and displays
    //                   the callstack (with function names where possible)
    MODE_STACKDUMP,
};


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ GLOBAL VARIABLES ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// g_hwndEdit       -- Edit control that contains the current log dump
extern HWND g_hwndEdit;

// g_hwnd           -- The app's main window
extern HWND g_hwnd;

// g_hInstance      -- Handle to this instance of xbWatson.
extern HINSTANCE g_hInstance;


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  OutputMsg
// Purpose:   Utility function - dumps the specified message to the command prompt.  This will
//            only work if launched from a command prompt.
// Arguments: szMsg         -- The format of the message (just like 'printf').
//            ...           -- Arguments for the message.
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void OutputMsg(char *szMsg, ...);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\watson\xbwatson\GetBreakInfo.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:     GetBreakInfo.cpp
// Contents: Contains code to request information about the connected Xbox.
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  GetStackBaseAndSize
// Purpose:   Obtain the stack base and stack size of the specified thread.
// Arguments: pdwStackBase      -- Pointer to buffer to contain the base of the stack
//            pdwStackSize      -- Pointer to buffer to contain the size of the stack
//            dwThreadId        -- Id of the thread on which we'll get information.
// Returns:   'true' if successful, 'false' otherwise
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
static bool GetStackBaseAndSize(DWORD *pdwStackBase, DWORD *pdwStackSize, DWORD dwThreadId)
{
    //  The Xbox stack looks (roughly) something like this:
    //      _________
    //      |       |   <-- NPX save (kernel stack information - we don't care about it).
    //      +-------+   <-- Stack Base
    //      |       |
    //      |       |   <-- Thread Local Storage (TLS)
    //      |       |
    //      +-------+   <-- TlsBase
    //      |       |
    //      |       |   <-- Stack
    //      |       |   
    //      +-------+   <-- ESP
    //      |///////|
    //      |///////|   <-- Not yet used memory
    //      |       |
    //
    //  We can obtain the 'TlsBase' value from the Xbox via DmGetThreadInfo.
    //  On the Xbox, we actually don't need the TLS information, so we can essentially collapse
    //  the stack so that StackBase == TlsBase (so we have our stackbase; 'TlsBase').
    //  From there, calculating the size of the stack we care about is simply TlsBase - ESP.

    // dmti             -- Will contain information about the specified thread.
    DM_THREADINFO dmti;

    // cr               -- Will contain the context information for the specified thread.
    CONTEXT cr;

    // Request the thread information from the Xbox
    if (DmGetThreadInfo(dwThreadId, &dmti) != XBDM_NOERR)
    {
        // Failed to communicate with the Xbox. Jump ship.
        return false;
    }

    // NOTE: It's possible (though very unlikely) that we'll get a TLSData value of '0'.  In that
    //       case it's okay to completely ignore the thread.
    if (dmti.TlsBase == 0)
        return false;
    
    // Get the current stack pointer (ESP).  UNDONE-WARN: Don't need all of these flags (elsewhere too)
    cr.ContextFlags = CONTEXT_INTEGER | CONTEXT_CONTROL | CONTEXT_FULL | CONTEXT_FLOATING_POINT |
                      CONTEXT_EXTENDED_REGISTERS;
    if (DmGetThreadContext(dwThreadId, &cr) != XBDM_NOERR)
    {
        // Failed to get Esp - can't determine stack size.
        return false;
    }

    // Set the stack base and stack size values as described above.
    //*pdwStackBase = (DWORD)dmti.TlsBase;
    //*pdwStackSize = *pdwStackBase - cr.Esp;

    // Note: to ease lookup, we point the base of the stack at esp rather than tlsbase; this allows
    //       easier address translation on the flip side.
    *pdwStackBase = cr.Esp;
    *pdwStackSize = (DWORD)dmti.TlsBase - *pdwStackBase;

    // Return that we successfully obtained the stack base and stack size.
    return true;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  GetPerThreadBreakInfo
// Purpose:   Obtains thread-specific information (callstacks, context, etc) using the specified
//            thread id.
// Arguments: dwThreadId        -- Id of the thread on which we'll get information.
//            pthreadinfo       -- ThreadInfo structure that we'll fill in here.
// Returns:   'true' if successful, 'false' otherwise
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
static bool GetPerThreadBreakInfo(DWORD dwThreadId, sThreadInfo *pthreadinfo)
{
    // cBytesRead       -- Number of bytes read in the DmGetMemory call
    DWORD cBytesRead;

    // cr               -- Will contain the context information for the specified thread.
    CONTEXT cr;


    // Get the current stack pointer
    cr.ContextFlags = CONTEXT_INTEGER | CONTEXT_CONTROL | CONTEXT_FULL | CONTEXT_FLOATING_POINT |
                      CONTEXT_EXTENDED_REGISTERS;
    if (DmGetThreadContext(dwThreadId, &cr) != XBDM_NOERR)
    {
        // Failed to get Esp - can't read per-thread info
        pthreadinfo->fValid = false;
        return false;
    }

    // Store the entire context of the thread in the threadinfo structure
    pthreadinfo->cr = cr;
    pthreadinfo->dwThreadId = dwThreadId;

    // Determine the base and the size of the stack for the specified thread.
    GetStackBaseAndSize(&pthreadinfo->dwStackBase, &pthreadinfo->dwStackSize, dwThreadId);

    // Allocate space for the stack
    pthreadinfo->rgbyStack = new BYTE[pthreadinfo->dwStackSize];
    if (!pthreadinfo->rgbyStack)
    {
        // Out of memory.  Jump Ship.
        return false;
    }

    // Get the entire stack from the Xbox
    if (DmGetMemory((BYTE*)cr.Esp, pthreadinfo->dwStackSize, pthreadinfo->rgbyStack, &cBytesRead) != XBDM_NOERR)
    {
        // Failed to read for some reason.  Jump ship.
        return false;
    }

    // Mark that we successfully got the thread information
    pthreadinfo->fValid = true;

    return true;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  GetBreakInfo
// Purpose:   Requests a slew of Access Violation-related information from the Xbox that reported
//            an error.
// Arguments: dwThreadId        -- Id of the thread on which we'll get information.
//            dwEventType       -- The event that occurred immediately before the dump (RIP, etc).
//            pbreakinfo        -- The breakinfo structure we'll fill in here.
// Returns:   'true' if successful, 'false' otherwise
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool GetBreakInfo(DWORD dwThreadId, DWORD dwEventType, sBreakInfo *pbreakinfo)
{
    // rgdwThreads      -- Contains the list of threads currently running on the Xbox.
    DWORD rgdwThreads[MAX_XBOX_THREADS];

    PDM_WALK_MODULES pdmwm;
    DMN_MODLOAD      dmnml;

    // Note: Even though the connected Xbox has crashed, we're able to talk to it because of the
    //       'kd disable' trick we pulled earlier - it's sitting in a loop waiting for someone to
    //       talk to it.  We use this to query for the necessary exception-related information.
    
    // Store information about the type of break which occurred
    pbreakinfo->dwEventType      = dwEventType;
    pbreakinfo->dwBrokenThreadId = dwThreadId;
    if (dwEventType == IDD_RIP)
    {
        // The event was a RIP.  Store the string that the Xbox reported
        strcpy(pbreakinfo->szRIP, g_pszRIP);
    }
    else
    {
        // The event was an exception.  Store information about the exception.
        pbreakinfo->fWriteException = g_fWriteException;
        pbreakinfo->dwAVAddress     = (DWORD)g_pvAVAddress;
        pbreakinfo->dwEventCode     = g_dwExceptionCode;
    }
    
    // Get information about the application that AV'ed.
    DM_XBE dmxbe;
    if (DmGetXbeInfo(NULL, &dmxbe) != XBDM_NOERR)
    {
        // Failed that too.  Give up
        return false;
    }
    strcpy(pbreakinfo->szAppName, dmxbe.LaunchPath);

    // Get the time of the break (roughly).
    DmGetSystemTime(&pbreakinfo->systime);

    // Get the name of the Xbox.
    char szXboxName[1024];
    DWORD dw = 1024;
    DmGetXboxName(szXboxName, &dw);
    strcpy(pbreakinfo->szXboxName, szXboxName);

    // Get the list of modules on the Xbox.  Go through it once to determine the number of
    // modules; then allocate enough space to hold them and go through again.
    pbreakinfo->cModules = 0;
    pdmwm = NULL;
    while (DmWalkLoadedModules(&pdmwm, &dmnml) == XBDM_NOERR)
        pbreakinfo->cModules++;

    // Allocate space for the modules
    pbreakinfo->prgdmnml = new DMN_MODLOAD[pbreakinfo->cModules];
    
    // Do the module walk again now that we've allocated sufficient space for it
    pdmwm = NULL;
    for (DWORD i = 0; i < pbreakinfo->cModules; i++)
    {
        DmWalkLoadedModules(&pdmwm, &pbreakinfo->prgdmnml[i]);

        // If the loaded module == the user's application, then get the BaseAddress of the first
        // section.  In the .log parsing code, we will compare this section offset with the
        // unrelocated section offset in order to obtain the correct base address for the entire
        // module...

        // Note: Because the XBE is stored as 'path\app.xbe' and the module name is stored
        //       as 'app.exe', a bit of code is necessary here to obtain the undecorated module
        //       and file name for correct comparison.
        char szAppName[MAX_PATH];
        char szModuleName[MAX_PATH];
        strcpy(szAppName, strrchr(pbreakinfo->szAppName, '\\') + 1);
        *(strrchr(szAppName, '.')) = '\0';
        strcpy(szModuleName, pbreakinfo->prgdmnml[i].Name);
        *(strrchr(szModuleName, '.')) = '\0';
        if (!lstrcmpi(szAppName, szModuleName))
        {
            // This is the user's application module
            DMN_SECTIONLOAD dmnsl;
            PDM_WALK_MODSECT pdmwms = NULL;

            // We only need the first section, so call WalkModuleSections only once.
            DmWalkModuleSections(&pdmwms, pbreakinfo->prgdmnml[i].Name, &dmnsl);

            // Store the first section's base address in the breakinfo structure so that we can
            // write it out later.
            pbreakinfo->dwFirstSectionBase = (DWORD)dmnsl.BaseAddress;
        }
    }

    // State dump for each thread.

    // DmGetThreadList needs the upper bound the array it's passed, so specify it here.  After the
    // call to DmGetThreadList returns, 'pbreakinfo->cThreads' will contain the *actual* number of elements.
    pbreakinfo->cThreads = MAX_XBOX_THREADS;

    // Get the list of threads from the Xbox.
    if (DmGetThreadList(rgdwThreads, &pbreakinfo->cThreads) == XBDM_BUFFER_TOO_SMALL)
        OutputMsg("Warning: More than 100 threads running on the Xbox -- only the first 100 will be stored.\r\n");

    // Allocate space in the breakinfo structure to hold the per-thread information
    pbreakinfo->prgthreadinfo = new sThreadInfo[pbreakinfo->cThreads];

    // Output information on each thread currently running.
    for (i = 0; i < pbreakinfo->cThreads; i++)
        if (!GetPerThreadBreakInfo(rgdwThreads[i], &pbreakinfo->prgthreadinfo[i]))
        {
            // Failed to get the per-thread info.  Warn the user but continue on with the next thread.
            OutputMsg("Warning: Failed to get stack for thread '%d'.  Thread skipped.\r\n", dwThreadId);
        }

    return true;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  FreeBreakInfo
// Purpose:   Frees space allocated for the specified BreakInfo's internals
// Arguments: pbreakinfo        -- The breakinfo structure we'll free up here.
// Returns:   None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void FreeBreakInfo(sBreakInfo *pbreakinfo)
{
    // Free up space allocated for the modules
    delete pbreakinfo->prgdmnml;

    // Free up the per-thread space
    for (DWORD i = 0; i < pbreakinfo->cThreads; i++)
        delete pbreakinfo->prgthreadinfo->rgbyStack;

    // Free up the list of threads
    delete pbreakinfo->prgthreadinfo;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\watson\xbdumplog\xbDumpLog.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:     xbDumpLog.cpp
// Contents: contains main entry point for xbDumpLog application.
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ GLOBAL VARIABLES ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ LOCAL GLOBAL VARIABLES ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  DumpUsage
// Purpose:   Displays usage information to the user
// Arguments: None
// Return:    Always false.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
static bool DumpUsage()
{
    // Pop up a message box explaining proper xbWatson parameters for the user.
    // UNDONE: convert from messagebox to print
    printf("Perform a post-mortem analysis of an xbWatson crash log.\n\n");
    printf("XBDUMPLOG -f crashlog [-p symbolpath]\n\n");
    printf("  -f        Specifies logfile to analyze.\n");
    printf("  -p        Specifies symbol path containing .exe and .pdb file\n\n");

    printf("If no symbol path is specified, the current path is assumed.\n");
    return false;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  ParseCommandLine
// Purpose:   Parses the user-specified command line looking for arguments that affect our functionality.
// Arguments: szCmdLine     -- Contains the parameter list passed to this application
//            szLogFile     -- String filled with the name of the source log file if specified
//            szSymPath     -- String filled with the name of the symbol path if specified
// Return:    true if successfully parsed; false if an invalid parameter was specified.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
static bool ParseCommandLine(int argc, char *argv[], char *szLogFile, char *szSymPath)
{
    bool fLogSpecified = false;

    for (int i = 1; i < argc; i++)
    {
        char *psz = argv[i];

        // First character of each token must be '-' or '/'
        if (*psz != '-' && *psz != '/')
            return DumpUsage();
        switch(*(++psz))
        {
        case 'f':
        case 'F':
            // User is specifying a log file that we will want to dump.  Get the name of the
            // source log file
            strcpy(szLogFile, argv[++i]);
            fLogSpecified = true;
            break;

        case 'p':
        case 'P':
            // User is specifying the symbol path
            strcpy(szSymPath, argv[++i]);
            break;

        case 'h':
        case 'H':
            // User wants to see usage information
            return DumpUsage();

        default:
            // Invalid argument specified - display usage information to the user.
            return DumpUsage();
        }
    }

    if (!fLogSpecified)
        return DumpUsage();
    
    return true;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  main
// Purpose:   This is the default entry point into a console application.
// Arguments: argc			-- The number of arguments passed in the command line.
//            argv			-- The list of arguments passed in the command line.
// Return:    Zero for normal termination, non-zero for abnormal termination.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
int _cdecl main(int argc, char *argv[])
{
    // szLogFile      -- Name of the output file that contains the log dump to parse and display.
    char szLogFile[MAX_PATH];

    // szSymPath      -- Location of user App symbols and executable.  If no symbol path is
    //                   specified, then current directory is assumed.
    char szSymPath[MAX_PATH] = ".";

    // Parse the specified command line.
    if (!ParseCommandLine(argc, argv, szLogFile, szSymPath))
        return 0;

    // Dump the specified log file to the console.
    if (!ParseLogFile(szLogFile, szSymPath))
        return 1;
    
    // Return that everything went fine.
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\watson\xbwatson\GetBreakInfo.h ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:     GetBreakInfo.h
// Contents: Contains declarations of functions and variables defined in GetBreakInfo.cpp
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ DEFINES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// MAX_XBOX_THREADS -- Maximum number of threads expected on the Xbox.
#define MAX_XBOX_THREADS 100


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ STRUCTURES ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// sThreadInfo      -- Contains information about a particular thread that was running at time of
//                     crash.
typedef struct
{
    bool  fValid;                           // 'true' if the thread's stack was successfully read.
    DWORD dwThreadId;                       // Id of the thread.
    DWORD dwStackBase;                      // Loaded address of the first element in the stack.
    DWORD dwStackSize;                      // Size of the stack we're keeping around.
    BYTE  *rgbyStack;                       // Pointer to the stack data.
    CONTEXT cr;                             // Complete context at time of crash.
} sThreadInfo;

// sBreakInfo       -- Encapsulates all information tracked at time of crash.
typedef struct
{
    DWORD           dwEventType;            // The type of break event that occurred.
    DWORD           dwBrokenThreadId;       // ID of the thread in which the break occurred.
    DWORD           dwEventCode;            // Exception code of the break event if not a RIP.
    bool            fWriteException;        // 'true' = write AV.  'False' = read AV.
    DWORD           dwAVAddress;            // address of access violation (if that's what it was).
    char            szRIP[1024];            // RIP string.  Empty if the event wasn't a RIP.
    char            szXboxName[256];        // Name of the Xbox that the break occurred on.
    SYSTEMTIME      systime;                // Time the break occurred.
    char            szAppName[MAX_PATH];    // Name of the user's module.
    DWORD           cModules;               // Number of modules loaded.
    DMN_MODLOAD     *prgdmnml;              // Module information.
    DWORD           cThreads;               // Number of threads active in this break event.
    sThreadInfo     *prgthreadinfo;         // Per-thread break information.
    DWORD           dwFirstSectionBase;     // The LOADED base address of the first section.  Used
                                            // to determine offset from unrelocated address.
} sBreakInfo;


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  GetBreakInfo
// Purpose:   Requests a slew of Access Violation-related information from the Xbox that reported
//            an error.
// Arguments: dwThreadId        -- Id of the thread on which we'll get information.
//            dwEventType       -- The event that occurred immediately before the dump (RIP, etc).
//            pbreakinfo        -- The breakinfo structure we'll fill in here.
// Returns:   'true' if successful, 'false' otherwise
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool GetBreakInfo(DWORD dwThreadId, DWORD dwEventType, sBreakInfo *pbreakinfo);

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  FreeBreakInfo
// Purpose:   Frees space allocated for the specified BreakInfo's internals
// Arguments: pbreakinfo        -- The breakinfo structure we'll free up here.
// Returns:   None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void FreeBreakInfo(sBreakInfo *pbreakinfo);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\watson\xbwatson\HandleAssert.h ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:     HandleAssert.h
// Contents: Contains declarations of functions and variables defined in HandleAssert.cpp
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  HandleAssert
// Purpose:   Called when we've been notified of an Xbox assertion and we need to handle it.  Pops
//            up the Assert dialog box and lets it take control.
// Arguments: szAssert          -- The assert string passed from the Xbox.  Contains file, line, and
//                                 exception information.
//            dwThreadId        -- Id of the thread in which the assert occurred.
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void HandleAssert(char *szAssert, DWORD dwThreadId);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\watson\xbwatson\HandleBreakpoint.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:     HandleBreakpoint.cpp
// Contents: Contains code to handle the Breakpoint dialog box
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ LOCAL GLOBAL VARIABLES ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// gs_dwThreadId     -- Id of the thread in which the Breakpoint occurred.
static DWORD gs_dwThreadId;

// gs_pvAddress      -- Address of the exception.
static void *gs_pvAddress;


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  BreakpointDlgProc
// Purpose:   Message handler for the Breakpoint dialog. This function is automatically called by
//            Windows whenever a message needs to be sent to the dialog box (ie 'paint', 'move', etc).
// Arguments: hDlg          -- Handle to the Dialog box's window
//            message       -- The message sent to the dialog box
//            wParam        -- A message parameter.
//            lParam        -- Another message parameter
// Return:    nonzero if we processed the message
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
LRESULT CALLBACK BreakpointDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    // ps                   -- Standard windows practice.  Used in WM_PAINT.
	PAINTSTRUCT ps;
    HDC hdc;

    // hfont, hfontPrev, lf -- Variables necessary for outputing text
    HFONT   hfont, hfontPrev;
    LOGFONT lf;
    char szBuf[1024];

    // Handle the specified message
	switch (message)
	{
    case WM_INITDIALOG:
        MessageBeep(MB_ICONEXCLAMATION);
        SetWindowPos(hwnd, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW);

        // Set titlebar contents
        sprintf(szBuf, "An exception has occurred [%s]", g_szTargetXbox);
        SetWindowText(hwnd, szBuf);

        // Return that we've handled the message
        return true;

    case WM_PAINT:
        // Standard windows WM_PAINT handling.
		hdc = BeginPaint(hwnd, &ps);

        // Don't draw any background in the ExtTextOut calls below.
        SetBkMode(hdc, TRANSPARENT);

        // Create the GDI font object
        memset(&lf, 0, sizeof(lf));
        lf.lfHeight = -11;
        strcpy(lf.lfFaceName, "Arial");
        hfont = CreateFontIndirect(&lf);

        // Select the newly created font into the assertion dialog's HDC
        hfontPrev = (HFONT)SelectObject(hdc, hfont);

        // Create the exception string
        sprintf(szBuf, "A breakpoint was hit at address 0x%08X", (DWORD)gs_pvAddress);

        // Output the exception text
        ExtTextOut(hdc, 52, 10, 0, NULL, szBuf, strlen(szBuf), NULL);

        // Select the old font back into the assertion dialog's HDC (Windows standard practice).
        SelectObject(hdc, hfontPrev);

        // We're done with our font so delete it.
        DeleteObject(hfont);

        // Notify windows that we're done painting.
        EndPaint(hwnd, &ps);

        // Return that we've handled the message
        return TRUE;

    case WM_COMMAND:
        // The user pressed a button
        switch(LOWORD(wParam))
        {
        case ID_REBOOT:
            // Reboot the Xbox
            DmReboot(DMBOOT_WARM);
            break;

        case ID_CONTINUE:
            // Ignore the Breakpoint.  Tell the Xbox to continue running
		    DmContinueThread(gs_dwThreadId, FALSE);
		    DmGo();
            break;

        case ID_DONOTHING:
            // User doesn't want us to do anything.  They will probably hook up a debugger...
            break;
        }

        // We're done, so exit the dialog.
        EndDialog(hwnd, LOWORD(wParam));

        // Return that we've handled the message
        return true;
    }

    // Return that we haven't handled the message
    return false;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  HandleBreakpoint
// Purpose:   Called when we've been notified of an Xbox Breakpoint and we need to handle it.  Pops
//            up the Breakpoint dialog box and lets it take control.
// Arguments: dwThreadId        -- Id of the thread in which the Breakpoint occurred.
//            pvAddress         -- Address at which the exception occurred.
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void HandleBreakpoint(DWORD dwThreadId, void *pvAddress)
{
    // Track various event-related variable.  Note: Can't avoid global variables with a dialog box...
    gs_dwThreadId = dwThreadId;
    gs_pvAddress  = pvAddress;

    // Open the Breakpoint dialog box - this will handle Ignore, Dump, and Reboot for us.
    DialogBox(g_hInstance, (LPCTSTR)IDD_BREAKPOINT, g_hwnd, (DLGPROC)BreakpointDlgProc);    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\watson\xbwatson\HandleAssert.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:     HandleAssert.cpp
// Contents: Contains code to handle the assert dialog box
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ LOCAL GLOBAL VARIABLES ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// gs_szAssert       -- Assertion string passed from the Xbox.
static char *gs_szAssert;

// gs_szFile         -- String prefixing the file of the assertion in the assertion string
static char *gs_szFile = "File: ";

// gs_szLine         -- String prefixing the line of the assertion in the assertion string
static char *gs_szLine = "Line: ";

// gs_szExp         -- String prefixing the exception of the assertion in the assertion string
static char *gs_szExp  = "Expression: ";

// rgszAssert       -- Contains the text output to the assert dialog box.  We allocate a large
//                     enough per-line buffer to hold the text below and a filename.
static char rgszAssert[8][MAX_PATH + 60] = 
{
    "Assertion failed!",
    "",
    "Program: ",
    "File: ",
    "Line: ",
    "",
    "Expression: ",
    "",
};

// gs_dwThreadId     -- Id of the thread in which the assert occurred.
static DWORD gs_dwThreadId;


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  AssertDlgProc
// Purpose:   Message handler for the Assert dialog. This function is automatically called by Windows
//            whenever a message needs to be sent to the dialog box (ie 'paint', 'move', etc).
// Arguments: hDlg          -- Handle to the Dialog box's window
//            message       -- The message sent to the dialog box
//            wParam        -- A message parameter.
//            lParam        -- Another message parameter
// Return:    nonzero if we processed the message
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
LRESULT CALLBACK AssertDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    // lf, hfont, hfontPrev -- Used in generating the font for the text in the Assert dialog.
    LOGFONT lf;
    HFONT hfont, hfontPrev;

    int i;
    char szBuf[MAX_PATH], szTitle[MAX_PATH];

    // ps                   -- Standard windows practice.  Used in WM_PAINT.
	PAINTSTRUCT ps;
    HDC hdc;

    // szFile, szLine, szExp -- Point at the file in which the assertion occurred.
    char *szFile, szFile2[MAX_PATH];
    char *szLine, szLine2[256];
    char *szExp,  szExp2[256];

    // dmxbe, cr            -- Used to communicate with the Xbox
    DM_XBE dmxbe;
    CONTEXT cr;

    // rgszAssertThis       -- Local copy of the assertion text.
    static char rgszAssertThis[8][MAX_PATH + 60];

    // Handle the specified message
	switch (message)
	{
    case WM_INITDIALOG:
        MessageBeep(MB_ICONEXCLAMATION);
        SetWindowPos(hwnd, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW);
        
        // set titlebar contents
        DmGetXbeInfo(NULL, &dmxbe);
        strcpy(szTitle, strrchr(dmxbe.LaunchPath, '\\') + 1);
        sprintf(szBuf, "Xbox Assertion Failed - %s [%s]", szTitle, g_szTargetXbox);
        SetWindowText(hwnd, szBuf);

        // Return that we've handled the message
        return TRUE;

    case WM_PAINT:
        // Standard windows WM_PAINT handling.
		hdc = BeginPaint(hwnd, &ps);

        // Don't draw any background in the ExtTextOut calls below.
        SetBkMode(hdc, TRANSPARENT);

        // Get the name of the asserting program from the Xbox
        DmGetXbeInfo(NULL, &dmxbe);

        // Use a local copy of the assertion text so that multiple assertions are displayed properly.
        memcpy(rgszAssertThis, rgszAssert, sizeof(rgszAssert));

        // Parse the information out of the assert string
        if (strstr(gs_szAssert, gs_szFile) == NULL)
        {
            // Not a regular assert string - must be abort
            strcpy(rgszAssertThis[0], "Debug Error!");
            strcat(rgszAssertThis[2], dmxbe.LaunchPath);
            strcpy(rgszAssertThis[3], "");
            strcpy(rgszAssertThis[4], "This application has requested the Runtime to terminate it");
            strcpy(rgszAssertThis[5], "in an unusual way.  Please contact the application's support");
            strcpy(rgszAssertThis[6], "team for more information.");
        }
        else
        {
            szFile = strstr(gs_szAssert, gs_szFile) + strlen(gs_szFile);
            szLine = strstr(gs_szAssert, gs_szLine) + strlen(gs_szLine);
            szExp  = strstr(gs_szAssert, gs_szExp) + strlen(gs_szExp);
            strncpy(szFile2, szFile, strchr(szFile, '\n') - szFile);
            strncpy(szLine2, szLine, strchr(szLine, '\n') - szLine);
            strncpy(szExp2,  szExp,  strchr(szExp,  '\n')  - szExp);
            szFile2[strchr(szFile, '\n') - szFile] = '\0';
            szLine2[strchr(szLine, '\n') - szLine] = '\0';
            szExp2[strchr(szExp, '\n')   - szExp]  = '\0';

            // Concatenate the assertion-specific information onto the assertion text.
            strcat(rgszAssertThis[2], dmxbe.LaunchPath);
            strcat(rgszAssertThis[3], szFile2);
            strcat(rgszAssertThis[4], szLine2);
            strcat(rgszAssertThis[6], szExp2);
        }
        // Create the GDI font object
        memset(&lf, 0, sizeof(lf));
        lf.lfHeight = -11;
        strcpy(lf.lfFaceName, "Arial");
        hfont = CreateFontIndirect(&lf);

        // Select the newly created font into the assertion dialog's HDC
        hfontPrev = (HFONT)SelectObject(hdc, hfont);

        // Output each line of assertion text to the assertion dialog.
        for (i = 0; i < 8; i++)
            ExtTextOut(hdc, 60, 10 + i * 13, 0, NULL, rgszAssertThis[i], strlen(rgszAssertThis[i]), NULL);

        // Select the old font back into the assertion dialog's HDC (Windows standard practice).
        SelectObject(hdc, hfontPrev);

        // We're done with our font so delete it.
        DeleteObject(hfont);

        // Notify windows that we're done painting.
        EndPaint(hwnd, &ps);

        // Return that we've handled the message
        return TRUE;

    case WM_COMMAND:
        // The user pressed either 'Reboot', 'Break', or 'Continue'

        // We communicate the choice to the Xbox through the DmSetThreadContext function, and specify
        // the desired action in the context's eax register.

        // Get the existing thread context (so that we don't write bogus ebx, ecx, etc, values.
		cr.ContextFlags = CONTEXT_INTEGER;
		DmGetThreadContext(gs_dwThreadId, &cr);

        switch(LOWORD(wParam))
        {
        case ID_REBOOT:
            // halt the offending thread
            // cr.Eax = 't';

            // Reboot the Xbox
            DmReboot(DMBOOT_WARM);
            EndDialog(hwnd, LOWORD(wParam));
            return TRUE;

        case ID_BREAK:
    		cr.Eax = 'b';
            break;

        case ID_CONTINUE:
    		cr.Eax = 'i';
            break;
        }

        // Tell the Xbox what the user chose.
        DmSetThreadContext(gs_dwThreadId, &cr);

        if (LOWORD(wParam) == ID_CONTINUE)
        {
            // Tell the Xbox to start running again
		    DmContinueThread(gs_dwThreadId, FALSE);
		    DmGo();
        }

        // We're done, so exit the dialog.
        EndDialog(hwnd, LOWORD(wParam));

        // Return that we've handled the message
        return TRUE;
    }

    // Return that we haven't handled the message
    return FALSE;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  HandleAssert
// Purpose:   Called when we've been notified of an Xbox assertion and we need to handle it.  Pops
//            up the Assert dialog box and lets it take control.
// Arguments: szAssert          -- The assert string passed from the Xbox.  Contains file, line, and
//                                 exception information.
//            dwThreadId        -- Id of the thread in which the assert occurred.
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void HandleAssert(char *szAssert, DWORD dwThreadId)
{
    // Track the assert string and thread that the assert occurred in.  Note: Can't avoid global
    // variables with a dialog box...
    gs_szAssert   = szAssert;
    gs_dwThreadId = dwThreadId;

    // Open the assert dialog box - this will handle abort, retry, and fail for us.
    DialogBox(g_hInstance, (LPCTSTR)IDD_ASSERT, g_hwnd, (DLGPROC)AssertDlgProc);    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\watson\xbwatson\HandleException.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:     HandleException.cpp
// Contents: Contains code to handle the exception dialog box
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"        -- Precompiled header file
#include "stdafx.h"


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ LOCAL GLOBAL VARIABLES ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// gs_dwThreadId     -- Id of the thread in which the exception occurred.
static DWORD gs_dwThreadId;

// gs_pvAddress      -- Address of the exception.
void *gs_pvAddress;


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ GLOBAL VARIABLES ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// g_dwExceptionCode -- Exception code of the exception which occurred.
DWORD g_dwExceptionCode;


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  ExceptionDlgProc
// Purpose:   Message handler for the Exception dialog. This function is automatically called by
//            Windows whenever a message needs to be sent to the dialog box (ie 'paint', 'move', etc).
// Arguments: hDlg          -- Handle to the Dialog box's window
//            message       -- The message sent to the dialog box
//            wParam        -- A message parameter.
//            lParam        -- Another message parameter
// Return:    nonzero if we processed the message
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
LRESULT CALLBACK ExceptionDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    static char szLogSaved[] = "(A crash dump has been saved)";
    char szBuf[MAX_PATH + 30];
    char szBuf1[256];
    char szBuf2[256];

    // s_fSaved             -- Tracks whether or not we've saved a file already.  Used in WM_PAINT.
    static bool s_fSaved = false;

    // ps                   -- Standard windows practice.  Used in WM_PAINT.
	PAINTSTRUCT ps;
    HDC hdc;

    // hfont, hfontPrev, lf -- Variables necessary for outputing text
    HFONT   hfont, hfontPrev;
    LOGFONT lf;

    // Handle the specified message
	switch (message)
	{
    case WM_INITDIALOG:
        MessageBeep(MB_ICONEXCLAMATION);
        SetWindowPos(hwnd, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW);

        // Set titlebar contents
        sprintf(szBuf, "An exception has occurred [%s]", g_szTargetXbox);
        SetWindowText(hwnd, szBuf);

        // Mark that we haven't yet saved a file
        s_fSaved = false;

        // Return that we've handled the message
        return true;

    case WM_PAINT:
        // Standard windows WM_PAINT handling.
		hdc = BeginPaint(hwnd, &ps);

        // Don't draw any background in the ExtTextOut calls below.
        SetBkMode(hdc, TRANSPARENT);

        // Create the GDI font object
        memset(&lf, 0, sizeof(lf));
        lf.lfHeight = -11;
        strcpy(lf.lfFaceName, "Arial");
        hfont = CreateFontIndirect(&lf);

        // Select the newly created font into the assertion dialog's HDC
        hfontPrev = (HFONT)SelectObject(hdc, hfont);

        // Create the exception string
        switch(g_dwExceptionCode)
        {
        case 0x80000003:
            // Breakpoint
            sprintf(szBuf1, "A breakpoint exception (0x%08X) has been reached in", g_dwExceptionCode);
            sprintf(szBuf2, "the application at location 0x%08X.", (DWORD)gs_pvAddress);
            break;

        case 0xC0000005:
            // Access Violation
            sprintf(szBuf1, "The instruction at address 0x%08X referenced memory", (DWORD)gs_pvAddress);
            if (g_fWriteException)
                sprintf(szBuf2, "at address 0x%08X.  The memory could not be written.", g_pvAVAddress);
            else
                sprintf(szBuf2, "at address 0x%08X.  The memory could not be read.", g_pvAVAddress);
            break;

        default:
            // Other
            sprintf(szBuf1, "An exception (0x%08X) occurred in the application", g_dwExceptionCode);
            sprintf(szBuf2, "at location 0x%08X", (DWORD)gs_pvAddress);
            break;
        }

        // Output the exception text
        ExtTextOut(hdc, 60, 10, 0, NULL, szBuf1, strlen(szBuf1), NULL);
        ExtTextOut(hdc, 60, 24, 0, NULL, szBuf2, strlen(szBuf2), NULL);

        // If we've already saved a file, then also output that text to the dialog
        if (s_fSaved)
            ExtTextOut(hdc, 103, 50, 0, NULL, szLogSaved, strlen(szLogSaved), NULL);

        // Select the old font back into the assertion dialog's HDC (Windows standard practice).
        SelectObject(hdc, hfontPrev);

        // We're done with our font so delete it.
        DeleteObject(hfont);

        // Notify windows that we're done painting.
        EndPaint(hwnd, &ps);

        // Return that we've handled the message
        return TRUE;

    case WM_COMMAND:
        // The user pressed a button.
        switch(LOWORD(wParam))
        {
        case ID_REBOOT:
            // Reboot the Xbox
            DmReboot(DMBOOT_WARM);
            break;

        case ID_DUMP:
            // Save the exception log to disk
            if (DumpLog(hwnd, IDD_EXCEPTION, gs_dwThreadId))
            {
                // Track that we've saved a file so that WM_PAINT also displays the fact...
                s_fSaved = true;

                // Update the dialog box
                InvalidateRect(hwnd, NULL, false);
            }

            // After saving the log, we remain in the dialog box so that the user can choose to
            // reboot the machine or ignore the exception (or, if so desired, to save the log again)
            return true;

        case ID_CONTINUE:
            // User watns to continue.  Tell the Xbox to start running again
		    DmContinueThread(gs_dwThreadId, FALSE);
		    DmGo();
            break;
        }

        // We're done, so exit the dialog.
        EndDialog(hwnd, LOWORD(wParam));

        // Return that we've handled the message
        return true;
    }

    // Return that we haven't handled the message
    return false;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  HandleException
// Purpose:   Called when we've been notified of an Xbox exception and we need to handle it.  Pops
//            up the Exception dialog box and lets it take control.
// Arguments: dwThreadId        -- Id of the thread in which the exception occurred.
//            dwCode            -- Exception code.
//            pvAddress         -- Address at which the exception occurred.
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void HandleException(DWORD dwThreadId, DWORD dwCode, void *pvAddress)
{
    // Track the  thread that the exception occurred in.  Note: Can't avoid global variables with a
    // dialog box...
    gs_dwThreadId     = dwThreadId;
    gs_pvAddress      = pvAddress;

    // The exception code is file-global since GetBreakInfo needs to get it.
    g_dwExceptionCode = dwCode;

    // Open the exception dialog box - this will handle Ignore, Dump, and Reboot for us.
    DialogBox(g_hInstance, (LPCTSTR)IDD_EXCEPTION, g_hwnd, (DLGPROC)ExceptionDlgProc);    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\watson\xbwatson\HandleRIP.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:     HandleRIP.cpp
// Contents: Contains code to handle the RIP dialog box
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ LOCAL GLOBAL VARIABLES ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// gs_dwThreadId     -- Id of the thread in which the RIP occurred.
static DWORD gs_dwThreadId;


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ GLOBAL VARIABLES ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// g_pszRIP          -- Pointer to string passed back from Xbox in the RIP. This is global because
//                      GetBreakInfo needs to access it.
char *g_pszRIP;


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  RIPDlgProc
// Purpose:   Message handler for the RIP dialog. This function is automatically called by
//            Windows whenever a message needs to be sent to the dialog box (ie 'paint', 'move', etc).
// Arguments: hDlg          -- Handle to the Dialog box's window
//            message       -- The message sent to the dialog box
//            wParam        -- A message parameter.
//            lParam        -- Another message parameter
// Return:    nonzero if we processed the message
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
LRESULT CALLBACK RIPDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    static char szLogSaved[] = "(A crash dump has been saved)";
    char szBuf[1024];
    
    // s_fSaved             -- Tracks whether or not we've saved a file already.  Used in WM_PAINT.
    static bool s_fSaved = false;

    // ps                   -- Standard windows practice.  Used in WM_PAINT.
	PAINTSTRUCT ps;
    HDC hdc;

    // hfont, hfontPrev, lf -- Variables necessary for outputing text
    HFONT   hfont, hfontPrev;
    LOGFONT lf;

    CONTEXT cr;

    // Handle the specified message
	switch (message)
	{
    case WM_INITDIALOG:
        MessageBeep(MB_ICONEXCLAMATION);
        SetWindowPos(hwnd, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW);

        // Set titlebar contents
        sprintf(szBuf, "An exception has occurred [%s]", g_szTargetXbox);
        SetWindowText(hwnd, szBuf);

        // Mark that we haven't yet saved a file
        s_fSaved = false;

        // Return that we've handled the message
        return true;

    case WM_PAINT:
        // Standard windows WM_PAINT handling.
		hdc = BeginPaint(hwnd, &ps);

        // Don't draw any background in the ExtTextOut calls below.
        SetBkMode(hdc, TRANSPARENT);

        // Create the GDI font object
        memset(&lf, 0, sizeof(lf));
        lf.lfHeight = -11;
        strcpy(lf.lfFaceName, "Arial");
        hfont = CreateFontIndirect(&lf);

        // Select the newly created font into the assertion dialog's HDC
        hfontPrev = (HFONT)SelectObject(hdc, hfont);

        // Create the RIP string
        sprintf(szBuf, "A RIP error has occurred on the Xbox");

        // Output the RIP text
        ExtTextOut(hdc, 52, 10, 0, NULL, szBuf, strlen(szBuf), NULL);

        // Create the RIP string
        sprintf(szBuf, "The error description was: %s", g_pszRIP);

        // Output the RIP text
        ExtTextOut(hdc, 52, 25, 0, NULL, szBuf, strlen(szBuf), NULL);

        // If we've already saved a file, then also output that text to the dialog
        if (s_fSaved)
            ExtTextOut(hdc, 103, 50, 0, NULL, szLogSaved, strlen(szLogSaved), NULL);

        // Select the old font back into the assertion dialog's HDC (Windows standard practice).
        SelectObject(hdc, hfontPrev);

        // We're done with our font so delete it.
        DeleteObject(hfont);

        // Notify windows that we're done painting.
        EndPaint(hwnd, &ps);

        // Return that we've handled the message
        return TRUE;

    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case ID_REBOOT:
            // Reboot the Xbox
            DmReboot(DMBOOT_WARM);
            break;

        case ID_DUMP:
            // Save the RIP log to disk
            if (DumpLog(hwnd, IDD_RIP, gs_dwThreadId))
            {
                // Track that we've saved a file so that WM_PAINT also displays the fact...
                s_fSaved = true;

                // Update the dialog box
                InvalidateRect(hwnd, NULL, false);
            }

            // After saving the log, we remain in the dialog box so that the user can choose to
            // reboot the machine or ignore the RIP (or, if so desired, to save the log again)
            return true;

        case ID_BREAK:
            // User wants to hit an INT 3.
            DmGetThreadContext(gs_dwThreadId, &cr);
            DmSetBreakpoint((void*)cr.Eip);
//            DmDoBreak();
            break;

        case ID_CONTINUE:
            // Ignore the RIP.  Tell the Xbox to continue running
		    DmContinueThread(gs_dwThreadId, FALSE);
		    DmGo();
            break;
        }

        // We're done, so exit the dialog.
        EndDialog(hwnd, LOWORD(wParam));

        // Return that we've handled the message
        return true;
    }

    // Return that we haven't handled the message
    return false;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  HandleRIP
// Purpose:   Called when we've been notified of an Xbox RIP and we need to handle it.  Pops
//            up the RIP dialog box and lets it take control.
// Arguments: dwThreadId        -- Id of the thread in which the RIP occurred.
//            pszRIP            -- The string passed back from the Xbox in the RIP.
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void HandleRIP(DWORD dwThreadId, char *pszRIP)
{
    // Track the  thread that the RIP occurred in.  Note: Can't avoid global variables with a
    // dialog box...
    gs_dwThreadId = dwThreadId;
    g_pszRIP     = pszRIP;

    // Open the RIP dialog box - this will handle Ignore, Dump, and Reboot for us.
    DialogBox(g_hInstance, (LPCTSTR)IDD_RIP, g_hwnd, (DLGPROC)RIPDlgProc);    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\watson\xbwatson\HandleException.h ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:     HandleException.h
// Contents: Contains declarations of functions and variables defined in HandleException.cpp
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ GLOBAL VARIABLES ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// g_dwExceptionCode -- Exception code of the exception which occurred.
extern DWORD g_dwExceptionCode;


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  HandleException
// Purpose:   Called when we've been notified of an Xbox exception and we need to handle it.  Pops
//            up the Exception dialog box and lets it take control.
// Arguments: dwThreadId        -- Id of the thread in which the exception occurred.
//            dwCode            -- Exception code.
//            pvAddress         -- Address at which the exception occurred.
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void HandleException(DWORD dwThreadId, DWORD dwCode, void *pvAddress);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\watson\xbwatson\HandleBreakpoint.h ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:     HandleBreakpoint.h
// Contents: Contains declarations of functions and variables defined in HandleBreakpoint.cpp
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  HandleBreakpoint
// Purpose:   Called when we've been notified of an Xbox Breakpoint and we need to handle it.  Pops
//            up the Breakpoint dialog box and lets it take control.
// Arguments: dwThreadId        -- Id of the thread in which the Breakpoint occurred.
//            pvAddress         -- Address at which the exception occurred.
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void HandleBreakpoint(DWORD dwThreadId, void *pvAddress);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\watson\xbwatson\ReadWriteBreakInfo.h ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:     ReadWriteBreakInfo.h
// Contents: Contains declarations of functions and variables defined in ReadWriteBreakInfo.cpp
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  WriteBreakInfo
// Purpose:   Outputs a breakinfo structure to the specified file.  This function does a DEEP copy.
// Arguments: hfile             -- The file to write the breakinfo structure to.
//            pbreakinfo        -- The breakinfo structure to write out
// Returns:   'true' if successful, 'false' otherwise
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool WriteBreakInfo(HANDLE hfile, sBreakInfo *pbreakinfo);

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  ReadBreakInfo
// Purpose:   Reads a breakinfo structure from the specified file.
// Arguments: hfile             -- The file to read the breakinfo structure from.
//            pbreakinfo        -- The breakinfo structure to read in.
// Returns:   'true' if successful, 'false' otherwise
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool ReadBreakInfo(HANDLE hfile, sBreakInfo *pbreakinfo);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\watson\xbwatson\HandleRIP.h ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:     HandleRIP.h
// Contents: Contains declarations of functions and variables defined in HandleRIP.cpp
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ GLOBAL VARIABLES ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// g_pszRIP          -- Pointer to string passed back from Xbox in the RIP. This is global because
//                      GetBreakInfo needs to access it.
extern char *g_pszRIP;


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  HandleRIP
// Purpose:   Called when we've been notified of an Xbox RIP and we need to handle it.  Pops
//            up the RIP dialog box and lets it take control.
// Arguments: dwThreadId        -- Id of the thread in which the RIP occurred.
//            pszRIP            -- The string passed back from the Xbox in the RIP.
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void HandleRIP(DWORD dwThreadId, char *pszRIP);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\watson\xbwatson\InitDM.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:     InitDM.cpp
// Contents: Xbox Debug Monitor initialization and uninitialization code.
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ GLOBAL VARIABLES ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// gs_hthreadConnect -- Handle to the thread that takes care of connecting to the Xbox
HANDLE gs_hthreadConnect;


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ LOCAL GLOBAL VARIABLES ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// gs_pdmsession     -- Current Debug Monitor Session.
static PDMN_SESSION gs_pdmsession = NULL;


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// UNDONE-FEATURE: Should user be able to specify which Xbox to care about?

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  InitDM
// Purpose:   Function that initializes the various Xbox DebugMonitor (DM) connections and callbacks
// Arguments: None
// Returns:   true on success, false on failure
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT HrInitDM(void)
{
    HRESULT hr;
    bool fConnected = false;
    int idm;
    static int rgdm[] = { DM_DEBUGSTR, DM_RIP, DM_ASSERT, DM_EXEC, DM_BREAK,
        DM_EXCEPTION, DM_DATABREAK, DM_NONE };

    // Determine to which Xbox we're talking.
    DWORD dw = MAX_PATH;
    DmGetXboxName(g_szTargetXbox, &dw);

    // Inform XBDM that we need to be notified of events.  Ask that the
    // notification be set up asynchronously, so that we don't block while
    // connection is attempted.
    DmUseSharedConnection(TRUE);
    hr = DmOpenNotificationSession(DM_DEBUGSESSION | DM_ASYNCSESSION,
        &gs_pdmsession);
    if(FAILED(hr))
        gs_pdmsession = NULL;

    // Setup the notification callbacks.  'NotifyProc' will automatically be called whenever the
    // specified events are signaled.
    for(idm = 0; rgdm[idm] != DM_NONE; ++idm) {
        if(SUCCEEDED(hr))
            hr = DmNotify(gs_pdmsession, rgdm[idm], NotifyProc);
    }

    if(FAILED(hr)) {
        // Something went wrong - clean up after ourselves and return 'failure'.

        // Inform XBDM that we're done being notified
        if (gs_pdmsession) {
            DmCloseNotificationSession(gs_pdmsession);
            gs_pdmsession = NULL;
        }

        // We're done with the shared connection
        DmUseSharedConnection(FALSE);
    }

    return hr;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  UninitDM
// Purpose:   Called to clean up after ourselves.  Shuts down the XBox Debug Monitor (DM) connection
//            and registered notification callbacks.
// Arguments: None
// Returns:   None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void UninitDM()
{
    // Inform XBDM that we're done being notified
    if (gs_pdmsession) {
        // inform XBDM that we're done being notified
        DmCloseNotificationSession(gs_pdmsession);
        gs_pdmsession = NULL;
    }

    // We're done with the shared connection
    DmUseSharedConnection(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\watson\xbwatson\InitDM.h ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:     InitDM.h
// Contents: Contains declarations of functions and variables defined in InitDM.cpp
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  InitDM
// Purpose:   Function that initializes the various Xbox DebugMonitor (DM) connections and callbacks
// Arguments: None
// Returns:   true on success, false on failure
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT HrInitDM();

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  UninitDM
// Purpose:   Called to clean up after ourselves.  Shuts down the XBox Debug Monitor (DM) connection
//            and registered notification callbacks.
// Arguments: None
// Returns:   None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void UninitDM();
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\watson\xbwatson\StdAfx.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:     StdAfx.cpp
// Contents: Source file that includes just the standard includes file.
//           'xbWatson.pch' will be the pre-compiled header.
//           'stdafx.obj' will be the pre-compiled type information.
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\watson\xbwatson\Output.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:     xbWatson.cpp
// Contents: Contains the windows entry point for the xbWatson executable.
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"

// UNDONE-WARN: Not modifying the edit menu based on selection state (not worth the trouble).

extern bool g_fLimitText;

#define MAXLINES 100000
#define LINESTOCUT 2000

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  PasteOutput
// Purpose:   Pastes the contents of the clipboard to the output window.
// Arguments: None.
// Return:    None.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void PasteOutput()
{
    // Tell the edit control "paste what's in the clipboard".
    SetFocus(g_hwndEdit);
    SendMessage(g_hwndEdit, WM_PASTE, 0, 0);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CutOutput
// Purpose:   Cuts the selected text from the output window.
// Arguments: None.
// Return:    None.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CutOutput()
{
    int iStart, iEnd;

    // Verify that something is selected
    SendMessage(g_hwndEdit, EM_GETSEL, (WPARAM)&iStart, (LPARAM)&iEnd);
    if (iStart == iEnd)
    {
        // No current selection
        MessageBeep(0);
        return;
    }

    // Tell the edit control "cut what's in the clipboard".
    SetFocus(g_hwndEdit);
    SendMessage(g_hwndEdit, WM_CUT, 0, 0);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  ClearOutput
// Purpose:   Clears the output window
// Arguments: None.
// Return:    None.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void ClearOutput()
{
    SetWindowText(g_hwndEdit, "");
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  DeleteOutput
// Purpose:   Deletes the selected text from the output window.
// Arguments: None.
// Return:    None.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void DeleteOutput()
{
    // Tell the edit control "delete what's in the clipboard".
    SetFocus(g_hwndEdit);
    SendMessage(g_hwndEdit, WM_CLEAR, 0, 0);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CopyOutput
// Purpose:   Copies the current selection to the clipboard
// Arguments: None.
// Return:    None.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CopyOutput()
{
    // Tell the edit control "copy the current selection to the clipboard".
    SetFocus(g_hwndEdit);
    SendMessage(g_hwndEdit, WM_COPY, 0, 0);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  SelectAllOutput
// Purpose:   Selects everything in the output window
// Arguments: None.
// Return:    None.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void SelectAllOutput()
{
    // Tell the edit control "select everything in the output window".
    SetFocus(g_hwndEdit);
    SendMessage(g_hwndEdit, EM_SETSEL, 0, -1);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  OutputMsg
// Purpose:   Utility function - dumps the specified message to the edit control.  This will
//            only work if launched from a command prompt.
// Arguments: szMsg         -- The format of the message (just like 'printf').
//            ...           -- Arguments for the message.
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void OutputMsg(char *szMsg, ...)
{
    // szMsgOut         -- Buffer to hold the final formatted string to output.
    char szMsgOut[1024];

    // valist           -- vararg var used to generate final formatted string.
    va_list valist;

    if (g_fLimitText)
    {
        int nLines = SendMessage(g_hwndEdit, EM_GETLINECOUNT, 0, 0);
        if (nLines > MAXLINES)
        {
            // Oop, too much text.  Delete the first chunk to make room
            SetFocus(g_hwndEdit);
        
            // Delete the first 2000 lines
            int nCharsToDelete = SendMessage(g_hwndEdit, EM_LINEINDEX, LINESTOCUT, 0);
            SendMessage(g_hwndEdit, EM_SETSEL, 0, nCharsToDelete);
            SendMessage(g_hwndEdit, WM_CUT, 0, 0);
        }
    }

    // Move the cursor in the edit control to the very end to append the specified text.
    SendMessage(g_hwndEdit, EM_SETSEL, (WPARAM)-2, (LPARAM)-1);
    
    // Create the final formatted string.
    va_start (valist, szMsg);
    vsprintf (szMsgOut, szMsg, valist);
    va_end (valist);

    // Tell the edit control to add the specified string to the end of the text.
    SendMessage(g_hwndEdit, EM_REPLACESEL, FALSE, (LPARAM)szMsgOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\watson\xbwatson\Output.h ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:     Output.h
// Contents: Contains declarations of functions and variables defined in Output.cpp
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  PasteOutput
// Purpose:   Pastes the contents of the clipboard to the output window.
// Arguments: None.
// Return:    None.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void PasteOutput();

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CutOutput
// Purpose:   Cuts the selected text from the output window.
// Arguments: None.
// Return:    None.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CutOutput();

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  DeleteOutput
// Purpose:   Deletes the selected text from the output window.
// Arguments: None.
// Return:    None.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void DeleteOutput();

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CopyOutput
// Purpose:   Copies the current selection to the clipboard
// Arguments: None.
// Return:    None.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CopyOutput();

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  ClearOutput
// Purpose:   Clears the output window
// Arguments: None.
// Return:    None.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void ClearOutput();

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  SelectAllOutput
// Purpose:   Selects everything in the output window
// Arguments: None.
// Return:    None.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void SelectAllOutput();

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  OutputMsg
// Purpose:   Utility function - dumps the specified message to the output window.
// Arguments: szMsg         -- The format of the message (just like 'printf').
//            ...           -- Arguments for the message.
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void OutputMsg(char *szMsg, ...);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\watson\xbwatson\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by xbWatson.rc
//
#define IDC_MYICON                      2
#define ID_IGNORE                       3
#define ID_CONTINUE                     4
#define IDB_BITMAP1                     101
#define IDD_XBWATSON_DIALOG             102
#define IDD_ABOUTBOX                    103
#define IDS_APP_TITLE                   103
#define IDM_ABOUT                       104
#define IDM_EXIT                        105
#define IDS_HELLO                       106
#define IDI_XBWATSON                    107
#define IDI_SMALL                       108
#define IDC_XBWATSON                    109
#define IDR_MAINFRAME                   128
#define IDD_ASSERT                      129
#define IDI_RED_X                       130
#define IDD_EXCEPTION                   134
#define IDD_RIP                         135
#define IDD_BREAKPOINT                  137
#define ID_ABORT                        1001
#define ID_RETRY                        1002
#define ID_REBOOT                       1004
#define ID_DUMP                         1005
#define IDC_RIP                         1006
#define ID_DONOTHING                    1008
#define ID_EDIT_CLEAR                 1009
#define IDM_SAVE                        32771
#define ID_EDIT_CUT                     32772
#define ID_EDIT_COPY                    32773
#define ID_EDIT_PASTE                   32774
#define ID_EDIT_DELETE                  32775
#define ID_EDIT_SELECTALL               32777
#define IDC_ABOUTTEXT                   32778
#define ID_BREAK                        32779
#define ID_LIMITBUFLEN                  32781
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        138
#define _APS_NEXT_COMMAND_VALUE         32782
#define _APS_NEXT_CONTROL_VALUE         1009
#define _APS_NEXT_SYMED_VALUE           110
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\watson\xbwatson\SaveLogFile.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:     SaveLogFile.cpp
// Contents: Contains code to write out the current log file to a file.
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  DumpLog
// Purpose:   Saves the crash information to a user-specified file.  Opens the common file-save
//            dialog to query the user for the desired file name\path.
//            NOTE: This saves crash info, NOT the log window contents.
// Arguments: hwndWindow        -- Handle to the app's window.  Necessary for the common dialog.
//            dwEventType       -- The event that occurred immediately before the dump (RIP, etc).
//            dwThreadId        -- Thread that the crash occurred in.
// Return:    'true' if the log was successfully saved; 'false' otherwise.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool DumpLog(HWND hwndWindow, DWORD dwEventType, DWORD dwThreadId)
{
    sBreakInfo   breakinfo;
    OPENFILENAME ofn;
    static TCHAR szTitleName[MAX_PATH], szFileName[MAX_PATH];
    static TCHAR szFilter[] = TEXT("Log Files (*.LOG)\0*.log\0") \
                              TEXT("All Files (*.*)\0*.*\0\0");
    
    // Grab a slew of exception-related information
    if (!GetBreakInfo(dwThreadId, dwEventType, &breakinfo))
    {
        MessageBox(NULL, "Failed to obtain crash information from application.  Log will not be saved",
                   "Unable to get crash information", MB_ICONEXCLAMATION | MB_OK);
        return false;
    }

    // Initialize the common save-file dialog box structure
    memset(&ofn, 0, sizeof(ofn));
    ofn.lStructSize    = sizeof(OPENFILENAME);
    ofn.lpstrFilter    = szFilter;
    ofn.nMaxFile       = MAX_PATH;
    ofn.nMaxFileTitle  = MAX_PATH;
    ofn.lpstrDefExt    = TEXT("log");
    ofn.hwndOwner      = hwndWindow;
    ofn.lpstrFile      = szFileName;
    ofn.lpstrFileTitle = szTitleName;
    ofn.Flags          = OFN_OVERWRITEPROMPT;

    // Pop up the common save-file dialog box.
    // UNDONE-FEATURE: Might be nice to track and reuse last-known-good filename for ease of saving...
    if (!GetSaveFileName(&ofn))
        return false;

    HANDLE hfile = CreateFile(ofn.lpstrFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hfile == INVALID_HANDLE_VALUE)
    {
        // Figure out why we died
        DWORD dwErr = GetLastError();
        switch(dwErr)
        {
        case ERROR_ALREADY_EXISTS:
            // Already prompted (automatically) for this in the GetSaveFileName dialog.  Fall
            // out of error handling
            break;

        case ERROR_DISK_FULL:
            MessageBox(NULL, "The specified drive is full.  Please free some space on it or select another drive, and try again.",
                       "Insufficient disk space", MB_ICONWARNING | MB_OK);
            return false;

        case ERROR_ACCESS_DENIED:
            MessageBox(NULL, "The specified file cannot be overwritten.  Please ensure the file isn't in use and try again.",
                       "Cannot overwrite file", MB_ICONWARNING | MB_OK);
            return false;

        default:
            MessageBox(NULL, "xbWatson cannot save the log to the specified location.  Please check the device and try again.",
                       "Cannot save file", MB_ICONWARNING | MB_OK);
        }
    }

    // Write the break information to the file.
    WriteBreakInfo(hfile, &breakinfo);

    // File successfully written
    CloseHandle(hfile);

    // Free up memory allocated for the BreakInfo structure
    FreeBreakInfo(&breakinfo);

    // return that the file was successfully saved.
    return true;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  SaveLogFile
// Purpose:   Saves the contents of the specified edit control to a file.  Opens the common file-
//            save dialog to query the user for the desired file name\path.
//            NOTE: This saves the log window contents, NOT crash info.
// Arguments: hwndWindow        -- Handle to the app's window.  Necessary for the common dialog.
//            hwndEditControl   -- Handle of the edit control whose text we're going to write out.
// Return:    'true' if successfully written; 'false' otherwise.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool SaveLogFile(HWND hwndWindow, HWND hwndEditControl)
{
    OPENFILENAME ofn;
    DWORD dwWritten;
    static TCHAR szTitleName[MAX_PATH], szFileName[MAX_PATH];
    static TCHAR szFilter[] = TEXT("Text Files (*.TXT)\0*.txt\0") \
                              TEXT("All Files (*.*)\0*.*\0\0");

    char szBuffer[65536];

    // Initialize the common save-file dialog box structure
    memset(&ofn, 0, sizeof(ofn));
    ofn.lStructSize    = sizeof(OPENFILENAME);
    ofn.lpstrFilter    = szFilter;
    ofn.nMaxFile       = MAX_PATH;
    ofn.nMaxFileTitle  = MAX_PATH;
    ofn.lpstrDefExt    = TEXT("txt");
    ofn.hwndOwner      = hwndWindow;
    ofn.lpstrFile      = szFileName;
    ofn.lpstrFileTitle = szTitleName;
    ofn.Flags          = OFN_OVERWRITEPROMPT;

    // Pop up the common save-file dialog box.
    // UNDONE-FEATURE: Might be nice to track and re-use last-known-good filename for ease of saving...
    if (!GetSaveFileName(&ofn))
        return false;

    HANDLE hfile = CreateFile(ofn.lpstrFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hfile == INVALID_HANDLE_VALUE)
    {
        // Figure out why we died
        DWORD dwErr = GetLastError();
        switch(dwErr)
        {
        case ERROR_ALREADY_EXISTS:
            // Already prompted (automatically) for this in the GetSaveFileName dialog.  Fall
            // out of error handling
            break;

        case ERROR_DISK_FULL:
            MessageBox(NULL, "The specified drive is full.  Please free some space on it or select another drive, and try again.",
                       "Insufficient disk space", MB_ICONWARNING | MB_OK);
            return false;

        case ERROR_ACCESS_DENIED:
            MessageBox(NULL, "The specified file cannot be overwritten.  Please ensure the file isn't in use and try again.",
                       "Cannot overwrite file", MB_ICONWARNING | MB_OK);
            return false;

        default:
            MessageBox(NULL, "xbWatson cannot save the log to the specified location.  Please check the device and try again.",
                       "Cannot save file", MB_ICONWARNING | MB_OK);
            return false;
        }
    }

    // Get the log file from the edit control
    SendMessage(hwndEditControl, WM_GETTEXT, (WPARAM)65535, (LPARAM)szBuffer);

    // Write the log file to the newly opened file
    if (WriteFile(hfile, szBuffer, strlen(szBuffer), &dwWritten, NULL) == 0)
    {
        // An error occurred.  Figure out why we died
        CloseHandle(hfile);
        DWORD dwErr = GetLastError();
        switch(dwErr)
        {
        case ERROR_DISK_FULL:
            MessageBox(NULL, "The specified drive is full.  Please free some space on it or select another drive, and try again.", "Insufficient disk space", MB_ICONWARNING | MB_OK);
            return false;

        default:
            MessageBox(NULL, "xbWatson cannot save the log to the specified location.  Please check the device and try again.", "Cannot save file", MB_ICONWARNING | MB_OK);
            return false;
        }
    }

    // File successfully written
    CloseHandle(hfile);

    // Return that we successfully wrote the file
    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\watson\xbwatson\ReadWriteBreakInfo.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:     ReadWriteBreakInfo.cpp
// Contents: Contains code to read/write a break info structure from/to a file
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"

// UNDONE: This is the same file as found in xbDumpLog.  Should share code (common lib?) to avoid
//         making a change in one place but not the other...


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ GLOBAL VARIABLES ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// gs_szSignature   -- Specifies the file type.  If the file signature in a specified file doesn't
//                     match this signature, then it is considered an incorrect or mangled file.
//                     In the future, this signature will be used for backwards compatibility.
static char gs_szSignature[] = "XBW1.0";


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  ReadBytes
// Purpose:   Reads bytes from a file and verifies the read succeeded.
// Arguments: hfile             -- The file to read the bytes from.
//            pvBuffer          -- The buffer to read the bytes to.
//            cBytes            -- The number of bytes to read.
// Returns:   'true' if successful, 'false' otherwise
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
static bool ReadBytes(HANDLE hfile, void *pvBuffer, DWORD cBytes)
{
    DWORD dwRead;

    // Read the requested number of bytes from the file.
    if (!ReadFile(hfile, pvBuffer, cBytes, &dwRead, NULL))
        return false;

    // Make sure we read all the bytes we expected to read
    if (dwRead != cBytes)
        return false;

    // Read successful!
    return true;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  WriteBytes
// Purpose:   Writes bytes from a file and verifies the write succeeded.
// Arguments: hfile             -- The file to write the bytes to.
//            pvBuffer          -- The buffer to read the bytes from.
//            cBytes            -- The number of bytes to write.
// Returns:   'true' if successful, 'false' otherwise
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
static bool WriteBytes(HANDLE hfile, void *pvBuffer, DWORD cBytes)
{
    DWORD dwWritten;

    // Write the requested number of bytes to the file.
    if (!WriteFile(hfile, pvBuffer, cBytes, &dwWritten, NULL))
        return false;

    // Make sure we wrote all the bytes we expected to write
    if (dwWritten != cBytes)
        return false;

    // Write successful!
    return true;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  WriteBreakInfo
// Purpose:   Outputs a breakinfo structure to the specified file.  This function does a DEEP copy.
// Arguments: hfile             -- The file to write the breakinfo structure to.
//            pbreakinfo        -- The breakinfo structure to write out
// Returns:   'true' if successful, 'false' otherwise
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool WriteBreakInfo(HANDLE hfile, sBreakInfo *pbreakinfo)
{
    // Write out our signature
    if (!WriteBytes(hfile, gs_szSignature, sizeof(gs_szSignature)))
        return false;

    // Write out the Xbox name, time, and application name to the file
    if (!WriteBytes(hfile, &pbreakinfo->szXboxName, sizeof(pbreakinfo->szXboxName)) || 
        !WriteBytes(hfile, &pbreakinfo->systime, sizeof(pbreakinfo->systime))       ||
        !WriteBytes(hfile, &pbreakinfo->szAppName, sizeof(pbreakinfo->szAppName)))
        return false;

    // Write out the type of event that occurred, as well as the thread id in which it occurred.
    if (!WriteBytes(hfile, &pbreakinfo->dwEventType, sizeof(pbreakinfo->dwEventType)))
        return false;
    if (!WriteBytes(hfile, &pbreakinfo->dwBrokenThreadId, sizeof(pbreakinfo->dwBrokenThreadId)))
        return false;
    
    // If the event was a RIP, then write out the RIP string.
    if (pbreakinfo->dwEventType == IDD_RIP)
    {
        if (!WriteBytes(hfile, pbreakinfo->szRIP, sizeof(pbreakinfo->szRIP)))
            return false;
    }
    else
    {
        // It was an exception - write out the exception info
        if (!WriteBytes(hfile, &pbreakinfo->dwEventCode, sizeof(pbreakinfo->dwEventCode)))
            return false;
        if (!WriteBytes(hfile, &pbreakinfo->fWriteException, sizeof(pbreakinfo->fWriteException)))
            return false;
        if (!WriteBytes(hfile, &pbreakinfo->dwAVAddress, sizeof(pbreakinfo->dwAVAddress)))
            return false;
    }

    // Write out the module information to the file
    if (!WriteBytes(hfile, &pbreakinfo->cModules, sizeof(pbreakinfo->cModules)))
        return false;
    if (!WriteBytes(hfile, pbreakinfo->prgdmnml, sizeof(DMN_MODLOAD) * pbreakinfo->cModules))
        return false;
    
    // Write out thread informaton to the file
    if (!WriteBytes(hfile, &pbreakinfo->cThreads, sizeof(pbreakinfo->cThreads)))
        return false;

    for (DWORD i = 0; i < pbreakinfo->cThreads; i++)
    {
        sThreadInfo *pthreadinfo = &pbreakinfo->prgthreadinfo[i];
        if (pthreadinfo->fValid)
        {
            if (!WriteBytes(hfile, &pthreadinfo->cr,          sizeof(pthreadinfo->cr))          ||
                !WriteBytes(hfile, &pthreadinfo->dwThreadId,  sizeof(pthreadinfo->dwThreadId))  ||
                !WriteBytes(hfile, &pthreadinfo->dwStackBase, sizeof(pthreadinfo->dwStackBase)) ||
                !WriteBytes(hfile, &pthreadinfo->dwStackSize, sizeof(pthreadinfo->dwStackSize)))
                return false;
            if (!WriteBytes(hfile, pthreadinfo->rgbyStack, sizeof(BYTE) * pthreadinfo->dwStackSize))
                return false;
        }
    }

    // Finally, write out the RELOCATED base address of the first section
    if (!WriteBytes(hfile, &pbreakinfo->dwFirstSectionBase, sizeof(DWORD)))
        return false;

    return true;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  ReadBreakInfo
// Purpose:   Reads a breakinfo structure from the specified file.
// Arguments: hfile             -- The file to read the breakinfo structure from.
//            pbreakinfo        -- The breakinfo structure to read in.
// Returns:   'true' if successful, 'false' otherwise
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool ReadBreakInfo(HANDLE hfile, sBreakInfo *pbreakinfo)
{
    // szSignature      -- Used to verify the specified file is the correct type
    char szSignature[7];

    // Read in the file signature and verify it's the version we expect
    if (!ReadBytes(hfile, szSignature, sizeof(szSignature)))
        return false;
    if (strcmp(szSignature, gs_szSignature))
    {
        // Signatures don't match!
        return false;
    }

    // Read in the Xbox name, time, and application name from the file
    if (!ReadBytes(hfile, &pbreakinfo->szXboxName, sizeof(pbreakinfo->szXboxName)) || 
        !ReadBytes(hfile, &pbreakinfo->systime, sizeof(pbreakinfo->systime))        ||
        !ReadBytes(hfile, &pbreakinfo->szAppName, sizeof(pbreakinfo->szAppName)))
        return false;

    // Read in the type of event that occurred, as well as the thread id in which it occurred.
    if (!ReadBytes(hfile, &pbreakinfo->dwEventType, sizeof(pbreakinfo->dwEventType)))
        return false;
    if (!ReadBytes(hfile, &pbreakinfo->dwBrokenThreadId, sizeof(pbreakinfo->dwBrokenThreadId)))
        return false;
    
    // If the event was a RIP, then read in the RIP string.
    if (pbreakinfo->dwEventType == IDD_RIP)
    {
        if (!ReadBytes(hfile, pbreakinfo->szRIP, sizeof(pbreakinfo->szRIP)))
            return false;
    }
    else
    {
        // It was an exception - read in the exception info
        if (!ReadBytes(hfile, &pbreakinfo->dwEventCode, sizeof(pbreakinfo->dwEventCode)))
            return false;
        if (!ReadBytes(hfile, &pbreakinfo->fWriteException, sizeof(pbreakinfo->fWriteException)))
            return false;
        if (!ReadBytes(hfile, &pbreakinfo->dwAVAddress, sizeof(pbreakinfo->dwAVAddress)))
            return false;
    }

    // Read in the number of modules from the file
    if (!ReadBytes(hfile, &pbreakinfo->cModules, sizeof(pbreakinfo->cModules)))
        return false;
    
    // Allocate space for the modules.
    pbreakinfo->prgdmnml = new DMN_MODLOAD[pbreakinfo->cModules];
    if (pbreakinfo->prgdmnml == NULL)
        return false;

    // Read in the actual module information
    if (!ReadBytes(hfile, pbreakinfo->prgdmnml, sizeof(DMN_MODLOAD) * pbreakinfo->cModules))
        return false;
    
    // Read the number of threads in this break event.
    if (!ReadBytes(hfile, &pbreakinfo->cThreads, sizeof(pbreakinfo->cThreads)))
        return false;

    // Allocate space for the threads
    pbreakinfo->prgthreadinfo = new sThreadInfo[pbreakinfo->cThreads];
    if (pbreakinfo->prgthreadinfo == NULL)
        return false;

    // Read in thread informaton from the file
    for (DWORD i = 0; i < pbreakinfo->cThreads; i++)
    {
        sThreadInfo *pthreadinfo = &pbreakinfo->prgthreadinfo[i];
        if (!ReadBytes(hfile, &pthreadinfo->cr,          sizeof(pthreadinfo->cr))          ||
            !ReadBytes(hfile, &pthreadinfo->dwThreadId,  sizeof(pthreadinfo->dwThreadId))  ||
            !ReadBytes(hfile, &pthreadinfo->dwStackBase, sizeof(pthreadinfo->dwStackBase)) ||
            !ReadBytes(hfile, &pthreadinfo->dwStackSize, sizeof(pthreadinfo->dwStackSize)))
            return false;

        // Allocate space for the stack
        pthreadinfo->rgbyStack = new BYTE[pthreadinfo->dwStackSize];

        // Read in the actual bytes of the stack
        if (!ReadBytes(hfile, pthreadinfo->rgbyStack, sizeof(BYTE) * pthreadinfo->dwStackSize))
            return false;

        // The 'fValid' flag is really only used in writing out a break info file, but we'll set
        // it here for completeness' sake.
        pthreadinfo->fValid = true;
    }

    // Finally, get the RELOCATED base address of the first section
    if (!ReadBytes(hfile, &pbreakinfo->dwFirstSectionBase, sizeof(DWORD)))
        return false;

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\watson\xbwatson\StdAfx.h ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:     stdafx.h
// Contents: Precompiled header file.  Include all common header files here.
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ==== Windows Header Files ====
#include <windows.h>
#include <commdlg.h>

// ==== C RunTime Header Files ====
#include <stdlib.h>
#include <stdio.h>
#include <malloc.h>
#include <memory.h>
#include <tchar.h>


// ==== External Support Header Files ====
#include <imagehlp.h>


// ==== Xbox header files ====

// "xboxdbg.h"      -- Functionality that communicates with Xbox
#include "xboxdbg.h"


// ==== Local Header Files ====
#include "resource.h"
#include "xbwatson.h"
#include "SaveLogFile.h"
#include "InitDM.h"
#include "XboxNotify.h"
#include "GetBreakInfo.h"
#include "ReadWriteBreakInfo.h"
#include "Output.h"

// Event notification dialog box handlers
#include "HandleAssert.h"
#include "HandleException.h"
#include "HandleRIP.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\watson\xbwatson\SaveLogFile.h ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:     SaveLogFile.h
// Contents: Contains declarations of functions and variables defined in SaveLogFile.cpp
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  SaveLogFile
// Purpose:   Saves the contents of the specified edit control to a file.  Opens the common file-
//            save dialog to query the user for the desired file name\path.
// Arguments: hwndWindow        -- Handle to the app's window.  Necessary for the common dialog.
//            hwndEditControl   -- Handle of the edit control whose text we're going to write out.
// Return:    'true' if successfully written; 'false' otherwise.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool SaveLogFile(HWND hwndWindow, HWND hwndEditControl);

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  DumpLog
// Purpose:   Saves the crash information to a user-specified file.  Opens the common file-save
//            dialog to query the user for the desired file name\path.
//            NOTE: This saves crash info, NOT the log window contents.
// Arguments: hwndWindow        -- Handle to the app's window.  Necessary for the common dialog.
//            dwEventType       -- The event that occurred immediately before the dump (RIP, etc).
//            dwThreadId        -- Thread that the crash occurred in.
// Return:    'true' if the log was successfully saved; 'false' otherwise.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool DumpLog(HWND hwndWindow, DWORD dwEventType, DWORD dwThreadId);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\watson\xbwatson\XboxNotify.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:     XBoxNotify.cpp
// Contents: Contains code to handle notification messages sent from the Xbox.
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ GLOBAL VARIABLES ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// g_fWriteException    -- If an access violation occurred, 'true' here means it was a write
//                         violation; 'false' means a read violation occurred.
bool g_fWriteException;

// g_pvAVAddress        -- If an access violation occurred, this contains the address that was
//                         incorrectly read or written.
void *g_pvAVAddress;


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  NotifyProc
// Purpose:   This is a callback routine registered by DmNotify.  It is called by XboxDbg for
//            various types of notification event
// Arguments: Notification      -- Type of notification, DM_DEBUGSTR for example
//            Parameter         -- Optional parameter based on notification type
// Returns:   Always zero
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
DWORD WINAPI NotifyProc(DWORD dwNotification, DWORD dwParameter)
{
    char           szBuf[4192] = {0}, szBuf2[4192] = {0};
    PDMN_DEBUGSTR  pdmnds;
    PDMN_BREAK     pdmnb;
    PDMN_DATABREAK pdmndb;
    PDMN_EXCEPTION pdmne;
    char           *pch;
    static BOOL fConnected = FALSE;

    // UNDONE-WARN: Remove flags
    dwNotification &= 0x0FFFFFFF;

    switch(dwNotification)
    {
    case DM_EXEC:
        // Output information about the Exec event.
        // The first time we get exec, we need to print that we successfully
        // connected
        if(!fConnected) {
            fConnected = TRUE;
            OutputMsg("xbwatson: Connection to Xbox successful.\r\n");
        } else if(dwParameter == DMN_EXEC_REBOOT)
            OutputMsg("xbwatson: Xbox is restarting.\r\n");
        break;
        
    case DM_DEBUGSTR:
    case DM_ASSERT:
    case DM_RIP:
        pdmnds = (PDMN_DEBUGSTR)dwParameter;
        if (pdmnds->Length)
        {
            strncpy(szBuf2, pdmnds->String, min(pdmnds->Length, 1024));
            strncpy(szBuf, pdmnds->String, min(pdmnds->Length, 1024));
            switch(dwNotification)
            {
            case DM_DEBUGSTR:
                // Replace the '\n' newline that XboxDbg appends since the edit control hates it
                pch = &szBuf2[min(pdmnds->Length, 1023) - 1];
                if (*pch == '\n')
                {
                    *pch = '\0';
                    OutputMsg("%s\r\n", szBuf2);
                }
                else
                    OutputMsg("%s", szBuf2);
                break;

            case DM_ASSERT:
                // Shrink the assert text for clarity of output
                for (pch = szBuf; *pch; pch++)
                    if (*pch == '\n') *pch = '\0';
                
                // Output the assert information to the log window
                strcat(szBuf, "\r\n");
                OutputMsg("Assert: %s", szBuf);

                // Pop up the Assert dialog and let the user choose what to do.
                HandleAssert(szBuf2, pdmnds->ThreadId);
                break;

            case DM_RIP:
                // Output the RIP information to the log window
                OutputMsg("RIP: %s\r\n", szBuf2);

                // Pop up the RIP dialog and let the user choose to reboot the machine, etc.
                HandleRIP(pdmnds->ThreadId, szBuf2);
                break;
            }            
        }
        break;

    case DM_BREAK:
        pdmnb = (PDMN_BREAK)dwParameter;

        // Output the breakpoint information to the log window
        OutputMsg("Break: 0x%08X 0x%08X\r\n", pdmnb->Address, pdmnb->ThreadId);

        // Pop up the exception dialog and let the user choose to dump the state, reboot the machine, etc
        HandleException(pdmnb->ThreadId, 0x80000003, pdmnb->Address);
        break;

    case DM_DATABREAK:
        pdmndb = (PDMN_DATABREAK)dwParameter;
        OutputMsg("Databreak: 0x%08X 0x%08X 0x%08X 0x%08X\r\n", pdmndb->Address,
                pdmndb->ThreadId, pdmndb->BreakType, pdmndb->DataAddress);

        // Pop up the exception dialog and let the user choose to dump the state, reboot the machine, etc
        HandleException(pdmndb->ThreadId, 0x80000003, pdmndb->Address);
        break;

    case DM_EXCEPTION:
        pdmne = (PDMN_EXCEPTION)dwParameter;
        if (!(pdmne->Flags & DM_EXCEPT_FIRSTCHANCE))
        {
            // output the exception information to the log window
            OutputMsg("Exception: 0x%08X 0x%08X 0x%08X 0x%08X 0x%08X 0x%08X\r\n", pdmne->ThreadId,
                    pdmne->Code, pdmne->Address, pdmne->Flags, pdmne->Information[0], pdmne->Information[1]);

            // Store information about the access violation for the exception dialog
            g_fWriteException = pdmne->Information[0] ? true : false;
            g_pvAVAddress     = (void*)pdmne->Information[1];

            // Pop up the exception dialog and let the user choose to dump the state, reboot the machine, etc
            HandleException(pdmne->ThreadId, pdmne->Code, pdmne->Address);
        }
        break;

    default:
        // All notification messages are handled above, but in case a new one is added later and it somehow
        // gets to us, just output it...
        OutputMsg("%s\r\n", szBuf2);
        break;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\watson\xbwatson\XboxNotify.h ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:     XboxNotify.h
// Contents: Contains declarations of functions and variables defined in XboxNotify.cpp
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ GLOBAL VARIABLES ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// g_fWriteException    -- If an access violation occurred, 'true' here means it was a write
//                         violation; 'false' means a read violation occurred.
extern bool g_fWriteException;

// g_pvAVAddress        -- If an access violation occurred, this contains the address that was
//                         incorrectly read or written.
extern void *g_pvAVAddress;


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  NotifyProc
// Purpose:   This is a callback routine registered by DmNotify.  It is called by XboxDbg for
//            various types of notification event
// Arguments: Notification      -- Type of notification, DM_DEBUGSTR for example
//            Parameter         -- Optional parameter based on notification type
// Returns:   Always zero
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
DWORD WINAPI NotifyProc(DWORD dwNotification, DWORD dwParameter);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\watson\xbwatson\xbWatson.h ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:     xbWatson.h
// Contents: Contains declarations of functions and variables defined in xbWatson.cpp
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ GLOBAL VARIABLES ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// g_hwndEdit       -- Edit control that contains the current log dump
extern HWND g_hwndEdit;

// g_hwnd           -- The app's main window
extern HWND g_hwnd;

// g_hInstance      -- Handle to this instance of xbWatson.
extern HINSTANCE g_hInstance;

// g_szTargetXbox   -- Name of the Xbox that we're watching.
extern char g_szTargetXbox[MAX_PATH];
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\watson\xbwatson\xbWatson.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:     xbWatson.cpp
// Contents: Contains the windows entry point for the xbWatson executable.
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"
#include <xboxverp.h>


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ GLOBAL VARIABLES ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// g_hwndEdit       -- Edit control that contains the current log dump
HWND g_hwndEdit;

// g_hwnd           -- The app's main window
HWND g_hwnd;

// g_hInstance      -- Handle to this instance of xbWatson.
HINSTANCE g_hInstance;

// g_szTargetXbox   -- Name of the Xbox that we're watching.
char g_szTargetXbox[MAX_PATH];

// g_fLimitText     -- if 'true', then buffer length in text control is limited to 25000 lines.
bool g_fLimitText = false;


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  AboutDlgProc
// Purpose:   Message handler for About dialog. This function is automatically called by Windows
//            whenever a message needs to be sent to the dialog box (ie 'paint', 'move', etc).
// Arguments: hDlg          -- Handle to the Dialog box's window
//            message       -- The message sent to the dialog box
//            wParam        -- A message parameter.
//            lParam        -- Another message parameter
// Return:    nonzero if we processed the message
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
LRESULT CALLBACK AboutDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    char szBuf[1024];

	switch (message)
	{
	case WM_INITDIALOG:
        // Get the build number from the resource file
        sprintf(szBuf, "Microsoft (R) xbWatson\nBuild %d\nCopyright (C) Microsoft Corp.",
                VER_PRODUCTBUILD);
        SetDlgItemText(hDlg, IDC_ABOUTTEXT, szBuf);
		return true;

	case WM_COMMAND:
		EndDialog(hDlg, 0);
		return false;
	}
    return false;
}

WNDPROC g_editproc;

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  EditProc
// Purpose:   Subclassed window procedure for the main edit control.  We subclass it so that we
//            can disallow keypresses inside it.
// Arguments: hWnd          -- Handle to the control's window
//            message       -- The message sent to the control box
//            wParam        -- A message parameter.
//            lParam        -- Another message parameter
// Return:    nonzero if we processed the message
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
LRESULT CALLBACK EditProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch(message)
    {
    case WM_CHAR:
        // Override the character so that it doesn't get displayed

        // Beep to inform the user of the invalid action
        MessageBeep(0);

        // Return zero to indicate that we handled the message
        return 0;
        
    default:
        // Pass all other messages to the base window procedure.
        return CallWindowProc(g_editproc, hWnd, message, wParam, lParam);
    }
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  WndProc
// Purpose:   This is the application's Windows message notification function.  When Windows wants
//            to tell the app that something has happened (ie mouse button pressed), it does so by
//            calling into WndProc with the message and it's related information.  If this function
//            does not handle the specified message, then it is passed on to the Win32 function
//            'DefWindowProc', which allows Windows to do any handling on it that it wants.
// Arguments: hWnd          -- Handle to the window
//            message       -- The message sent to the window
//            wParam        -- A message parameter.
//            lParam        -- Another message parameter
// Return:    Result of the message processing - depends on the message sent.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	int wmId, wmEvent;
	PAINTSTRUCT ps;
	HDC hdc;
    LOGFONT lf;
    HFONT hfont;
    HMENU hmenu;

	switch (message) 
	{
        case WM_CREATE:
            g_hwndEdit = CreateWindow(TEXT("edit"), NULL, WS_CHILD | WS_VISIBLE | WS_HSCROLL |//;// ES_READONLY |
                                      WS_VSCROLL | WS_BORDER | ES_LEFT | ES_MULTILINE |
                                      ES_AUTOHSCROLL | ES_AUTOVSCROLL,
                                      0, 0, 0, 0, hWnd, (HMENU)IDC_XBWATSON, ((LPCREATESTRUCT)lParam)->hInstance, NULL);
            g_editproc = (WNDPROC) SetWindowLong(g_hwndEdit, GWL_WNDPROC, (LONG)EditProc);

            // Set the edit control to accept the maximum number of character
            SendMessage(g_hwndEdit, EM_LIMITTEXT, 0, 0);

            // Create the GDI font object
            lf.lfHeight         = -14;
            lf.lfWidth          = 0;        lf.lfEscapement     = 0;
            lf.lfOrientation    = 0;        lf.lfWeight         = 0;
            lf.lfItalic         = 0;        lf.lfUnderline      = 0;
            lf.lfStrikeOut      = 0;        lf.lfCharSet        = 0;
            lf.lfOutPrecision   = 0;        lf.lfClipPrecision  = 0;
            lf.lfQuality        = 0;        lf.lfPitchAndFamily = 0;
            strcpy(lf.lfFaceName, "Courier New");
            hfont = CreateFontIndirect(&lf);
            SendMessage(g_hwndEdit, WM_SETFONT, (WPARAM)hfont, 0);

            // Initialize Xbox communication.
            if (FAILED(HrInitDM()))
                return FALSE;

            break;

        case WM_SIZE:
            MoveWindow(g_hwndEdit, 0, 0, LOWORD(lParam), HIWORD(lParam), TRUE);
            break;

        case WM_COMMAND:
			wmId    = LOWORD(wParam); 
			wmEvent = HIWORD(wParam); 
			// Parse the menu selections:
			switch (wmId)
			{
            case IDM_ABOUT:
                DialogBox(g_hInstance, (LPCTSTR)IDD_ABOUTBOX, hWnd, (DLGPROC)AboutDlgProc);
                break;
            case IDM_EXIT:
                SendMessage(hWnd, WM_CLOSE, 0, 0);
                break;
            case IDM_SAVE:
                SaveLogFile(hWnd, g_hwndEdit);
                break;

            // ==== Edit selections: ====

            case ID_EDIT_SELECTALL:
                SelectAllOutput();
                break;

            case ID_EDIT_COPY:
                CopyOutput();
                break;

            case ID_EDIT_CLEAR:
                ClearOutput();
                break;

            case ID_LIMITBUFLEN:
                g_fLimitText = !g_fLimitText;
                hmenu = GetMenu(g_hwnd);
                CheckMenuItem(hmenu, ID_LIMITBUFLEN, g_fLimitText ? MFS_CHECKED : MFS_UNCHECKED);
                break;

#ifdef EDITABLE
            case ID_EDIT_CUT:
                CutOutput();
                break;

            case ID_EDIT_PASTE:
                PasteOutput();
                break;

            case ID_EDIT_DELETE:
                DeleteOutput();
                break;

#endif
            default:
                return DefWindowProc(hWnd, message, wParam, lParam);
			}
			break;

		case WM_PAINT:
			hdc = BeginPaint(hWnd, &ps);
			// TODO: Add any drawing code here...
			RECT rt;
			GetClientRect(hWnd, &rt);
			EndPaint(hWnd, &ps);
			break;

		case WM_DESTROY:
			PostQuitMessage(0);
			return 0;

		default:
			return DefWindowProc(hWnd, message, wParam, lParam);
   }
   return 0;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  InitInstance
// Purpose:   Register our class and then create and show our window.
// Arguments: hInstance     -- The handle to this instance of the application
//            hPrevInstance -- Obsolete; throwback to Win16 -- ignore
//            szCmdLine     -- Contains the parameter list passed to this application
//            nCmdShow      -- The default visibility of this application (maximized, minimized, etc).
// Return:    true if successfully initialized..
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
static bool InitInstance(int nCmdShow)
{
	WNDCLASSEX wcex;

    // Register the class for the main xbWatson window.
	wcex.cbSize = sizeof(WNDCLASSEX); 
	wcex.style			= CS_HREDRAW | CS_VREDRAW;
	wcex.lpfnWndProc	= (WNDPROC)WndProc;
	wcex.cbClsExtra		= 0;
	wcex.cbWndExtra		= 0;
	wcex.hInstance		= g_hInstance;
	wcex.hIcon			= LoadIcon(g_hInstance, (LPCTSTR)IDI_XBWATSON);
	wcex.hCursor		= LoadCursor(NULL, IDC_ARROW);
	wcex.hbrBackground	= (HBRUSH)(COLOR_WINDOW+1);
	wcex.lpszMenuName	= (LPCSTR)IDC_XBWATSON;
	wcex.lpszClassName	= "xbWatson";
	wcex.hIconSm		= LoadIcon(wcex.hInstance, (LPCTSTR)IDI_SMALL);
	RegisterClassEx(&wcex);

    // Create the main xbWatson window.
    // UNDONE-FEATURE: Store and restore last position ran from (?)
    char sz[MAX_PATH + 30];
    sprintf(sz, "xbWatson - Log Window [%s]", g_szTargetXbox);

    g_hwnd = CreateWindow("xbWatson", sz, WS_OVERLAPPEDWINDOW,
                          CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, NULL, NULL, g_hInstance, NULL);
    if (!g_hwnd)
        return false;

    // Make our window visible and refresh it.
    ShowWindow(g_hwnd, nCmdShow);
    UpdateWindow(g_hwnd);

    return true;
}

bool HandleCmdLine(char *szCmd)
{
    if (*szCmd == NULL)
        return true;

    if ((szCmd[0] == '-' || szCmd[0] == '/') && (szCmd[1] == 'x' || szCmd[1] == 'X'))
    {
        // Get name
        char *pszName = strrchr(&szCmd[2], ' ');
        if (pszName)
            if(SUCCEEDED(DmSetXboxName(pszName+1)))
                return true;
    }

    // If here, then bad cmd line
    char szMsg[1000];
    sprintf(szMsg, "xbWatson.exe.\n\r\nusage: xbWatson [/x xboxname]\r\n"\
            "        /x    Specify Xbox to explore.");

    MessageBox(NULL, szMsg, "Invalid Command Line Option Specified", MB_ICONINFORMATION | MB_OK);
    return false;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  WinMain
// Purpose:   This is the default entry point into a Windows application.  When the application is
//            started, Windows calls into this function - when this function exits, the application
//            ends.  This function creates the Win32 class that represents this application, sets
//            up the Win32 Window in which the shell will be rendered, and then goes into the Win32
//            message loop that drives the application.
// Arguments: hInstance     -- The handle to this instance of the application
//            hPrevInstance -- Obsolete; throwback to Win16 -- ignore
//            szCmdLine     -- Contains the parameter list passed to this application
//            nCmdShow      -- The default visibility of this application (maximized, minimized, etc).
// Return:    result value.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
	MSG msg;
	HACCEL hAccelTable;

    // Keep track of this application's Instance handle.
    g_hInstance = hInstance;

    if (!HandleCmdLine(lpCmdLine))
        return -1;

    // Perform Win32-specific application initialization.
    if (!InitInstance (nCmdShow)) 
        return FALSE;

    // Initialize keyboard accelerators
	hAccelTable = LoadAccelerators(hInstance, (LPCTSTR)IDC_XBWATSON);
    
    // Main message loop:
	while (GetMessage(&msg, NULL, 0, 0)) 
    {
		if (!TranslateAccelerator(g_hwnd, hAccelTable, &msg)) 
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}
//        for (int i = 0; i < 100; i++)
  //          OutputMsg("1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890\n");
    }

    // Uninitialize XBDM.
    UninitDM();

	return msg.wParam;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xboxdbg\fileapi.c ===
/*
 *
 * fileapi.c
 *
 * File APIs
 *
 */

#include "precomp.h"
#include "filefunc.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xboxdbg\makefile.inc ===
$(XDK_LIB_PATH)\$(TARGETNAME).Lib: $(SDK_LIB_PATH)\$(TARGETNAME).Lib
    Copy $? $@

$O\fileapi.obj: fileapi.c filefunc.c

$O\xbconn.obj: xbconn.cpp filefunc.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xboxdbg\counters.c ===
/*
 *
 * counters.c
 *
 * Performance counter stuff
 *
 */

#include "precomp.h"

HRESULT DmWalkPerformanceCounters(PDM_WALK_COUNTERS *ppdmwc, PDM_COUNTINFO pdmci)
{
    PDM_CONNECTION s;
    HRESULT hr;
    char szBuf[1024];
    struct _DM_WALKPC *pwpc, **ppwpc;

    if(!ppdmwc || !pdmci)
        return E_INVALIDARG;

    if(!*ppdmwc) {
        /* This is our first call, so we need to build a list of all of the
         * counters returned by the remote machine */
        hr = HrOpenSharedConnection(&s);
        if(FAILED(hr))
            return hr;
        hr = DmSendCommand(s, "PCLIST", NULL, NULL);
        if(hr != XBDM_MULTIRESPONSE) {
            if(SUCCEEDED(hr)) {
                TerminateConnection(s);
                hr = E_UNEXPECTED;
            }
            CloseSharedConnection(s);
            return hr;
        }

        /* We've got the connection, so we can allocate a walk structure
         * now */
        *ppdmwc = LocalAlloc(LMEM_FIXED, sizeof (struct _DM_WALK_COUNTERS));
        if(!*ppdmwc) {
            CloseSharedConnection(s);
            return E_OUTOFMEMORY;
        }
        ppwpc = &(*ppdmwc)->pwpcFirst;
        /* Read all of the names and construct a buffer for them all */
        for(;;) {
            DWORD cch = sizeof(szBuf);

            hr = DmReceiveSocketLine(s, szBuf, &cch);
            /* Stop if we can't read or if we're done */
            if(FAILED(hr) || (cch == 1 && szBuf[0] == '.'))
                /* We're done now */
                break;
            pwpc = LocalAlloc(LMEM_FIXED, sizeof (struct _DM_WALKPC));
            if(!pwpc) {
                /* Oh no */
                hr = E_OUTOFMEMORY;
                break;
            }
            *ppwpc = pwpc;
            ppwpc = &pwpc->pwpcNext;
            if(!FGetSzParam(szBuf, "name", pwpc->dmci.Name) ||
                !FGetDwParam(szBuf, "type", &pwpc->dmci.Type))
            {
                hr = E_UNEXPECTED;
                break;
            }
        }
        if(FAILED(hr))
            TerminateConnection(s);
        CloseSharedConnection(s);
        *ppwpc = NULL;
        if(FAILED(hr))
            return hr;
    }

    /* We've got our list, so return a line */
    pwpc = (*ppdmwc)->pwpcFirst;
    if(!pwpc)
        return XBDM_ENDOFLIST;
    (*ppdmwc)->pwpcFirst = pwpc->pwpcNext;

    *pdmci = pwpc->dmci;
    LocalFree(pwpc);

    return XBDM_NOERR;
}

HRESULT DmCloseCounters(PDM_WALK_COUNTERS pdmwc)
{
    struct _DM_WALKPC *pwpc;

    if(!pdmwc)
        return E_INVALIDARG;

    while(pdmwc->pwpcFirst) {
        pwpc = pdmwc->pwpcFirst;
        pdmwc->pwpcFirst = pwpc->pwpcNext;
        LocalFree(pwpc);
    }
    LocalFree(pdmwc);
    return XBDM_NOERR;
}

HRESULT DmQueryPerformanceCounter(LPCSTR szName, DWORD dwType, PDM_COUNTDATA pdmcd)
{
    HRESULT hr;
    char sz[512];
    PDM_CONNECTION s;

    if (!pdmcd || !szName)
        return E_INVALIDARG;

    hr = HrOpenSharedConnection(&s);
    if(FAILED(hr))
        return hr;
    sprintf(sz, "QUERYPC NAME=\"%s\" TYPE=0x%08x", szName, dwType);
    hr = DmSendCommand(s, sz, NULL, NULL);
    if(hr != XBDM_MULTIRESPONSE) {
        if(SUCCEEDED(hr)) {
            TerminateConnection(s);
            hr = E_UNEXPECTED;
        }
        CloseSharedConnection(s);
        return hr;
    }
    memset(pdmcd, 0, sizeof *pdmcd);
    for(;;) {
        DWORD cch = sizeof sz;

        hr = DmReceiveSocketLine(s, sz, &cch);
        if(FAILED(hr) || *sz == '.')
            break;
        FGetDwParam(sz, "type", &pdmcd->CountType);
        FGetDwParam(sz, "vallo", &pdmcd->CountValue.LowPart);
        FGetDwParam(sz, "valhi", &pdmcd->CountValue.HighPart);
        FGetDwParam(sz, "ratelo", &pdmcd->RateValue.LowPart);
        FGetDwParam(sz, "ratehi", &pdmcd->RateValue.HighPart);
    }

    CloseSharedConnection(s);
    return hr;
}

HRESULT DmEnableGPUCounter(BOOL f)
{
    char sz[64];

    sprintf(sz, "GPUCOUNT %s", f ? "ENABLE" : "DISABLE");
    return HrOneLineCmd(sz);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xboxdbg\filefunc.c ===
/*
 *
 * filefunc.c
 *
 * File functions
 *
 */

#ifdef _IXBCONN
#define XBAPI(n) CXboxConnection::Hr##n
#define XBIMP(n) (::n)
#define PSCI (&m_sci)
#else
#define XBAPI(n) Dm##n
#define XBIMP(n) (n)
#define PSCI (&g_sci)
#endif

HRESULT XBAPI(ResolveXboxName)(LPDWORD lpdwAddr)
{
	struct sockaddr_in sin;
	HRESULT hr;
    int cb;

    if (!lpdwAddr)
        return E_INVALIDARG;

#ifndef _IXBCONN
	hr = DmSetXboxName(NULL);
	if(FAILED(hr))
		return hr;
#endif
    /* If we already have an open shared connection to this box, we can just
     * pluck the IP address out of there */
    hr = E_FAIL;
    if(PSCI->pdconShared) {
        EnterCriticalSection(&PSCI->csSharedConn);
        cb = sizeof sin;
        if(PSCI->pdconShared && 0 == getpeername(PSCI->pdconShared->s,
                (struct sockaddr *)&sin, &cb))
            hr = XBDM_NOERR;
        LeaveCriticalSection(&PSCI->csSharedConn);
    }
    if(FAILED(hr))
	    hr = HrResolveNameIP(PSCI->szXboxName, &sin);
	if(FAILED(hr))
		return hr;
	*lpdwAddr = ntohl(sin.sin_addr.s_addr);
	return XBDM_NOERR;
}

HRESULT XBAPI(GetNameOfXbox)(LPSTR szName, LPDWORD lpdwSize,
    BOOL fResolvable)
{
    PDM_CONNECTION s;
    HRESULT hr;

    hr = HrOpenSharedConnection(&s);
    if(SUCCEEDED(hr)) {
        hr = XBIMP(HrGetNameOfXbox)(s, szName, lpdwSize, fResolvable);
        CloseSharedConnection(s);
    }
    return hr;
}

HRESULT XBAPI(SetConnectionTimeout)(DWORD dwConnectTimeout,
    DWORD dwConversationTimeout)
{
    PSCI->dwConnectionTimeout = dwConnectTimeout;
    PSCI->dwConversationTimeout = dwConversationTimeout;
    return XBDM_NOERR;
}

HRESULT XBAPI(SendFile)(LPCSTR szLocalName, LPCSTR szRemoteName)
{
    PDM_CONNECTION s;
    HRESULT hr;

	hr = HrOpenSharedConnection(&s);
    if(SUCCEEDED(hr)) {
        hr = XBIMP(HrSendFile)(s, szLocalName, szRemoteName);
        CloseSharedConnection(s);
    }

    return hr;
}

HRESULT XBAPI(ReceiveFile)(LPCSTR szLocalName, LPCSTR szRemoteName)
{
    PDM_CONNECTION s;
    HRESULT hr;

    hr = HrOpenSharedConnection(&s);
    if(SUCCEEDED(hr)) {
        hr = XBIMP(HrReceiveFile)(s, szLocalName, szRemoteName);
        CloseSharedConnection(s);
    }

    return hr;
}

HRESULT XBAPI(GetFileAttributes)(LPCSTR szFile, PDM_FILE_ATTRIBUTES pdm)
{
    return XBIMP(HrGetFileAttributes)(PSCI, szFile, pdm);
}

HRESULT XBAPI(SetFileAttributes)(LPCSTR szFile, PDM_FILE_ATTRIBUTES pdm)
{
    return XBIMP(HrSetFileAttributes)(PSCI, szFile, pdm);
}

HRESULT XBAPI(Mkdir)(LPCSTR szName)
{
    PDM_CONNECTION s;
    HRESULT hr;

	hr = HrOpenSharedConnection(&s);
    if(SUCCEEDED(hr)) {
        hr = XBIMP(HrMkdir)(s, szName);
        CloseSharedConnection(s);
    }

    return hr;
}

HRESULT XBAPI(RenameFile)(LPCSTR szOldName, LPCSTR szNewName)
{
    PDM_CONNECTION s;
    HRESULT hr;

    hr = HrOpenSharedConnection(&s);
    if(SUCCEEDED(hr)) {
        hr = XBIMP(HrRenameFile)(s, szOldName, szNewName);
        CloseSharedConnection(s);
    }

    return hr;
}

HRESULT XBAPI(DeleteFile)(LPCSTR szFileName, BOOL fIsDirectory)
{
    PDM_CONNECTION s;
    HRESULT hr;

	hr = HrOpenSharedConnection(&s);
    if(SUCCEEDED(hr)) {
        hr = XBIMP(HrDeleteFile)(s, szFileName, fIsDirectory);
        CloseSharedConnection(s);
    }

    return hr;
}

HRESULT XBAPI(WalkDir)(PDM_WALK_DIR *ppdmwd, LPCSTR szDirName,
    PDM_FILE_ATTRIBUTES pdmfa)
{
    return XBIMP(HrWalkDir)(PSCI, ppdmwd, szDirName, pdmfa);
}

HRESULT XBAPI(GetDriveList)(LPSTR rgchDrives, DWORD *pcDrives)
{
    PDM_CONNECTION s;
    HRESULT hr;

	hr = HrOpenSharedConnection(&s);
    if(SUCCEEDED(hr)) {
        hr = XBIMP(HrGetDriveList)(s, rgchDrives, pcDrives);
        CloseSharedConnection(s);
    }

    return hr;
}

HRESULT XBAPI(GetDiskFreeSpace)(char *szDrive,
                           PULARGE_INTEGER pnFreeBytesAvailableToCaller,
                           PULARGE_INTEGER pnTotalNumberOfBytes,
                           PULARGE_INTEGER pnTotalNumberOfFreeBytes)
{
    return XBIMP(HrGetDiskFreeSpace)(PSCI, szDrive,
        pnFreeBytesAvailableToCaller, pnTotalNumberOfBytes,
        pnTotalNumberOfFreeBytes);
}

HRESULT XBAPI(GetXbeInfo)(LPCSTR szName, PDM_XBE pxbe)
{
    return XBIMP(HrGetXbeInfo)(PSCI, szName, pxbe);
}

HRESULT XBAPI(GetSystemTime)(LPSYSTEMTIME lpSysTime)
{
    if (!lpSysTime)
        return E_INVALIDARG;

    return XBIMP(HrGetSystemTime)(PSCI, lpSysTime);
}

HRESULT XBAPI(GetAltAddress)(LPDWORD lpdw)
{
    return XBIMP(HrGetAltAddress)(PSCI, lpdw);
}

HRESULT XBAPI(ScreenShot)(LPCSTR filename)
{
    return XBIMP(HrScreenShot)(PSCI, filename);
}

HRESULT XBAPI(IsSecurityEnabled)(LPBOOL pfEnabled)
{
    HRESULT hr;
    PDM_CONNECTION s;

    hr = HrOpenSharedConnection(&s);
    if(SUCCEEDED(hr)) {
        hr = XBIMP(HrIsSecurityEnabled)(s, pfEnabled);
        CloseSharedConnection(s);
    }
    return hr;
}

HRESULT XBAPI(EnableSecurity)(BOOL fEnable)
{
    HRESULT hr;
    PDM_CONNECTION s;

    hr = HrOpenSharedConnection(&s);
    if(SUCCEEDED(hr)) {
        hr = XBIMP(HrEnableSecurity)(s, fEnable);
        CloseSharedConnection(s);
    }
    return hr;
}

HRESULT XBAPI(SetAdminPassword)(LPCSTR szPasswd)
{
    HRESULT hr;
    PDM_CONNECTION s;

    hr = HrOpenSharedConnection(&s);
    if(SUCCEEDED(hr)) {
        hr = XBIMP(HrSetAdminPassword)(s, szPasswd);
        CloseSharedConnection(s);
    }
    return hr;
}

HRESULT XBAPI(AddUser)(LPCSTR szUserName, DWORD dwAccess)
{
    HRESULT hr;
    PDM_CONNECTION s;

    hr = HrOpenSharedConnection(&s);
    if(SUCCEEDED(hr)) {
        hr = XBIMP(HrAddUser)(s, szUserName, dwAccess);
        CloseSharedConnection(s);
    }
    return hr;
}

HRESULT XBAPI(RemoveUser)(LPCSTR szUserName)
{
    HRESULT hr;
    PDM_CONNECTION s;

    hr = HrOpenSharedConnection(&s);
    if(SUCCEEDED(hr)) {
        hr = XBIMP(HrRemoveUser)(s, szUserName);
        CloseSharedConnection(s);
    }
    return hr;
}

HRESULT XBAPI(GetUserAccess)(LPCSTR szUserName, LPDWORD lpdwAccess)
{
    HRESULT hr;
    PDM_CONNECTION s;

    hr = HrOpenSharedConnection(&s);
    if(SUCCEEDED(hr)) {
        hr = XBIMP(HrGetUserAccess)(s, szUserName, lpdwAccess);
        CloseSharedConnection(s);
    }
    return hr;
}

HRESULT XBAPI(SetUserAccess)(LPCSTR szUserName, DWORD dwAccess)
{
    HRESULT hr;
    PDM_CONNECTION s;

    hr = HrOpenSharedConnection(&s);
    if(SUCCEEDED(hr)) {
        hr = XBIMP(HrSetUserAccess)(s, szUserName, dwAccess);
        CloseSharedConnection(s);
    }
    return hr;
}

HRESULT XBAPI(WalkUserList)(PDM_WALK_USERS *ppdmwu, PDM_USER pdu)
{
    return XBIMP(HrWalkUserList)(PSCI, ppdmwu, pdu);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xboxdbg\filexfer.c ===
/*
**
** filexfer.c
**
** File transfer utilities
**
*/

#include "precomp.h"
#include "mswsock.h"

//#define ERRORTRACK

HRESULT HrGetSystemTime(SCI *psci, LPSYSTEMTIME lpSysTime)
{
	HRESULT hr;
	char sz[256];
	DWORD cch;
	FILETIME ft;
    PDM_CONNECTION s;

    hr = HrDoOpenSharedConnection(psci, &s);
    if(FAILED(hr))
        return hr;
	cch = sizeof sz;
	hr = DmSendCommand(s, "SYSTIME", sz, &cch);
	if(SUCCEEDED(hr)) {
		if(FGetDwParam(sz, "high", &ft.dwHighDateTime) &&
				FGetDwParam(sz, "low", &ft.dwLowDateTime))
			FileTimeToSystemTime(&ft, lpSysTime);
		else
			hr = XBDM_UNDEFINED;
	}
    DoCloseSharedConnection(psci, s);
	return hr;
}

void SetTimeCorrection(SCI *psci)
{
	ULARGE_INTEGER liLocal;
	ULARGE_INTEGER liRemote;
	ULARGE_INTEGER liHalfHour;
	ULARGE_INTEGER liHour;
	SYSTEMTIME st;
    FILETIME ft;
	HRESULT hr;
	BOOL fAhead;
    char sz[128];

	if(psci->fGotTimeCorrection)
		return;
	hr = HrGetSystemTime(psci, &st);
    if(hr == XBDM_CLOCKNOTSET) {
        /* Try to synchronize the remote clock with the local clock */
        GetSystemTimeAsFileTime(&ft);
        sprintf(sz, "setsystime clockhi=0x%08x clocklo=0x%08x",
            ft.dwHighDateTime, ft.dwLowDateTime);
        DmSendCommand(NULL, sz, NULL, NULL);
        hr = HrGetSystemTime(psci, &st);
    }
    if(FAILED(hr)) {
        if(hr == XBDM_CLOCKNOTSET)
            /* The box is there but refuses to tell us its time, probably
             * because the time is bogus */
            psci->fGotTimeCorrection = psci->fBadSysTime = TRUE;
		return;
    }
	if(!SystemTimeToFileTime(&st, (LPFILETIME)&liRemote))
		return;
	GetSystemTimeAsFileTime((LPFILETIME)&liLocal);
	/* liHalfHour is one half hour's worth of file time, of 1800 seconds worth
	 * of 100-nanosecond intervals (= 1.8x10^10) */
	liHalfHour.LowPart = 820130816;
	liHalfHour.HighPart = 4;
	liHour.LowPart = 1640261632;
	liHour.HighPart = 8;
	/* Find the difference between the two clocks, rounded to the nearest
	 * hour */
	if(liLocal.QuadPart > liRemote.QuadPart) {
		psci->fAddDiff = FALSE;
		psci->liTimeDiff.QuadPart = liLocal.QuadPart - liRemote.QuadPart;
	} else {
		psci->fAddDiff = TRUE;
		psci->liTimeDiff.QuadPart = liRemote.QuadPart - liLocal.QuadPart;
	}
	if(psci->liTimeDiff.QuadPart < liHalfHour.QuadPart)
		/* Zero difference */
		psci->liTimeDiff.LowPart = psci->liTimeDiff.HighPart = 0;
	else {
		psci->liTimeDiff.QuadPart += liHalfHour.QuadPart;
		psci->liTimeDiff.QuadPart /= liHour.QuadPart;
		psci->liTimeDiff.QuadPart *= liHour.QuadPart;
	}

	psci->fGotTimeCorrection = TRUE;
}

#ifdef ERRORTRACK
void TrackError(PDM_CONNECTION s, LPCSTR szLocalName, LPCSTR szRemoteName,
    int nErr)
{
    HANDLE hFile;
    int cRetries = 4;

    while(cRetries--) {
        hFile = CreateFile("\\\\xbox\\usr\\jlange\\fileerr.txt",
            GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, 0, NULL);
        if(hFile != INVALID_HANDLE_VALUE) {
            /* Seek to EOF and write our information */
            if(INVALID_SET_FILE_POINTER != SetFilePointer(hFile, 0, NULL,
                FILE_END))
            {
                char sz[2048];
                DWORD cb;

                sprintf(sz, "%s: %s, %s (%d)\r\n", s->psci->szXboxName,
                    szLocalName, szRemoteName, nErr);
                WriteFile(hFile, sz, strlen(sz), &cb, NULL);
            }
            CloseHandle(hFile);
            return;
        }
        if(GetLastError() != ERROR_SHARING_VIOLATION)
            return;
    }
}
#endif

HRESULT HrSendFile(PDM_CONNECTION s, LPCSTR szLocalName, LPCSTR szRemoteName)
{
	HANDLE h;
	DWORD dwFileSize;
	HRESULT hr;
	char szCommand[1024];
	DWORD cbBuf, cbSend;
	BYTE *pbBuf;

    if (szLocalName == NULL || szRemoteName == NULL)
        return E_INVALIDARG;

    if(strlen(szRemoteName) > 990)
		return E_INVALIDARG;

	h = CreateFile(szLocalName, GENERIC_READ, FILE_SHARE_READ, NULL,
		OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);
	if(INVALID_HANDLE_VALUE == h)
		return XBDM_FILEERROR;
	dwFileSize = GetFileSize(h, NULL);
	if(dwFileSize == -1) {
		hr = XBDM_FILEERROR;
		goto error;
	}
	sprintf(szCommand, "SENDFILE NAME=\"%s\" LENGTH=0x%x", szRemoteName, dwFileSize);
	hr = DmSendCommand(s, szCommand, NULL, NULL);
	if(FAILED(hr)) {
error:
		CloseHandle(h);
		return hr;
	}

    if (!TransmitFile(s->s, h, dwFileSize, 4096, NULL, NULL, 0)) {
#ifdef ERRORTRACK
        /* Track down errors */
        TrackError(s, szLocalName, szRemoteName, WSAGetLastError());
#endif
        /* Connection lost */
        TerminateConnection(s);
        hr = XBDM_CONNECTIONLOST;
        goto error;
    }

	hr = DmReceiveStatusResponse(s, NULL, NULL);
	CloseHandle(h);
	return hr;
}

HRESULT HrReceiveFile(PDM_CONNECTION s, LPCSTR szLocalName, LPCSTR szRemoteName)
{
	HANDLE h;
	DWORD dwFileSize;
	HRESULT hr;
	char szCommand[1024];
	DWORD cbBuf;
	BYTE *pbBuf;
    BYTE *rgbBuf;

    if (szRemoteName == NULL || szLocalName == NULL)
        return E_INVALIDARG;

	if(strlen(szRemoteName) > 990)
		return E_INVALIDARG;

    rgbBuf = LocalAlloc(LMEM_FIXED, 8192);
    if(!rgbBuf)
        return E_OUTOFMEMORY;

	sprintf(szCommand, "GETFILE NAME=\"%s\"", szRemoteName);
	hr = DmSendCommand(s, szCommand, NULL, NULL);
	if(FAILED(hr))
		goto done;
	/* Get the file size */
	hr = DmReceiveBinary(s, &dwFileSize, sizeof(DWORD), NULL);
	if(FAILED(hr))
		goto done;

	h = CreateFile(szLocalName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
		FILE_ATTRIBUTE_NORMAL, NULL);
    if(INVALID_HANDLE_VALUE == h) {
		hr = XBDM_FILEERROR;
        goto done;
    }

	/* We're ready to receive.  We'll read up to 8k before writing */
	while(dwFileSize) {
		cbBuf = 8192;
		if(cbBuf > dwFileSize)
			cbBuf = dwFileSize;
		hr = DmReceiveBinary(s, rgbBuf, cbBuf, NULL);
		if(FAILED(hr)) {
error:
			CloseHandle(h);
			DeleteFile(szLocalName);
			goto done;
		}
		dwFileSize -= cbBuf;
		pbBuf = rgbBuf;
		while(cbBuf) {
			int cb;

			if(!WriteFile(h, pbBuf, cbBuf, &cb, NULL)) {
				hr = XBDM_FILEERROR;				
				goto error;
			}
			cbBuf -= cb;
			pbBuf += cb;
		}
	}
	CloseHandle(h);
	hr = XBDM_NOERR;
done:
    LocalFree(rgbBuf);
    return hr;
}

void CorrectTime(SCI *psci, LPFILETIME lpft, BOOL fTo)
{
	if(lpft->dwLowDateTime || lpft->dwHighDateTime) {
		SetTimeCorrection(psci);
		if(psci->fGotTimeCorrection && !psci->fBadSysTime) {
			/* The time correction we have is to add if fAdd is true and we're
			 * converting local to remote, so we need to figure out the real
			 * sense */
			BOOL fAdd = !psci->fAddDiff == !fTo;
			if(fAdd)
				((PULARGE_INTEGER)lpft)->QuadPart += psci->liTimeDiff.QuadPart;
			else
				((PULARGE_INTEGER)lpft)->QuadPart -= psci->liTimeDiff.QuadPart;
		} else
			lpft->dwLowDateTime = lpft->dwHighDateTime = 0;
	}
}

void UnpackDmfa(SCI *psci, LPSTR szBuf, PDM_FILE_ATTRIBUTES pdmfa)
{
    if(PchGetParam(szBuf, "directory", FALSE, TRUE))
        pdmfa->Attributes |= FILE_ATTRIBUTE_DIRECTORY;
    if(PchGetParam(szBuf, "readonly", FALSE, TRUE))
        pdmfa->Attributes |= FILE_ATTRIBUTE_READONLY;
    if(PchGetParam(szBuf, "hidden", FALSE, TRUE))
        pdmfa->Attributes |= FILE_ATTRIBUTE_HIDDEN;
    FGetDwParam(szBuf, "createhi", &pdmfa->CreationTime.dwHighDateTime);
    FGetDwParam(szBuf, "createlo", &pdmfa->CreationTime.dwLowDateTime);
    FGetDwParam(szBuf, "changehi", &pdmfa->ChangeTime.dwHighDateTime);
    FGetDwParam(szBuf, "changelo", &pdmfa->ChangeTime.dwLowDateTime);
    FGetDwParam(szBuf, "sizehi", &pdmfa->SizeHigh);
    FGetDwParam(szBuf, "sizelo", &pdmfa->SizeLow);
    FGetSzParam(szBuf, "name", pdmfa->Name);
    CorrectTime(psci, &pdmfa->CreationTime, FALSE);
    CorrectTime(psci, &pdmfa->ChangeTime, FALSE);
}

HRESULT HrGetFileAttributes(SCI *psci, LPCSTR szFile, PDM_FILE_ATTRIBUTES pdm)
{
	HRESULT hr;
	char szBuf[1024];
    PDM_CONNECTION s;

    if (!szFile || !pdm)
        return E_INVALIDARG;

	if(strlen(szFile) > 980)
		return E_INVALIDARG;
    hr = HrDoOpenSharedConnection(psci, &s);
    if(FAILED(hr))
        return hr;
	sprintf(szBuf, "GETFILEATTRIBUTES NAME=\"%s\"", szFile);
	hr = DmSendCommand(s, szBuf, NULL, NULL);
	if(hr != XBDM_MULTIRESPONSE) {
        if(SUCCEEDED(hr)) {
			hr = E_UNEXPECTED;
            TerminateConnection(s);
        }
        DoCloseSharedConnection(psci, s);
	} else {
		memset(pdm, 0, sizeof *pdm);
		for(;;) {
			DWORD cch = sizeof szBuf;

			hr = DmReceiveSocketLine(s, szBuf, &cch);
			if(FAILED(hr) || *szBuf == '.')
				break;
            UnpackDmfa(psci, szBuf, pdm);
		}
        DoCloseSharedConnection(psci, s);
	}
	return hr;
}

HRESULT HrSetFileAttributes(SCI *psci, LPCSTR szFile, PDM_FILE_ATTRIBUTES pdm)
{
	HRESULT hr;
	char szBuf[1024];
    FILETIME ftCreate;
    FILETIME ftChange;
    int ich;
    PDM_CONNECTION s;

    if (!szFile || !pdm)
        return E_INVALIDARG;

	if(strlen(szFile) > 900)
		return E_INVALIDARG;
    /* Copy the filetimes so we don't change the input attributes */
    ftCreate = pdm->CreationTime;
    ftChange = pdm->ChangeTime;
    CorrectTime(psci, &ftCreate, TRUE);
    CorrectTime(psci, &ftChange, TRUE);

	sprintf(szBuf, "SETFILEATTRIBUTES NAME=\"%s\""
		" CREATEHI=0x%08x CREATELO=0x%08x CHANGEHI=0x%08x CHANGELO=0x%08x",
        szFile, ftCreate.dwHighDateTime,
		ftCreate.dwLowDateTime, ftChange.dwHighDateTime,
		ftChange.dwLowDateTime);
    ich = strlen(szBuf);
    if(pdm->Attributes) {
        sprintf(szBuf + ich, " READONLY=%d HIDDEN=%d",
		    (pdm->Attributes & FILE_ATTRIBUTE_READONLY ? 1 : 0),
		    (pdm->Attributes & FILE_ATTRIBUTE_HIDDEN ? 1 : 0));
    }
    hr = HrDoOpenSharedConnection(psci, &s);
    if(FAILED(hr))
        return hr;
	hr = HrDoOneLineCmd(s, szBuf);
    DoCloseSharedConnection(psci, s);
    return hr;
}
 
HRESULT HrMkdir(PDM_CONNECTION s, LPCSTR szName)
{
	char szBuf[1024];

    if (szName == NULL)
        return E_INVALIDARG;

    if(strlen(szName) > 990)
		return E_INVALIDARG;
	sprintf(szBuf, "MKDIR NAME=\"%s\"", szName);
	return HrDoOneLineCmd(s, szBuf);
}

HRESULT HrRenameFile(PDM_CONNECTION s, LPCSTR szOldName, LPCSTR szNewName)
{
	char szBuf[2048];

    if (szOldName == NULL || szNewName == NULL)
        return E_INVALIDARG;

	if(strlen(szOldName) + strlen(szNewName) > 1990)
		return E_INVALIDARG;
	sprintf(szBuf, "RENAME NAME=\"%s\" NEWNAME=\"%s\"", szOldName, szNewName);
	return HrDoOneLineCmd(s, szBuf);
}

HRESULT HrDeleteFile(PDM_CONNECTION s, LPCSTR szFileName, BOOL fIsDirectory)
{
	char szBuf[1024];

    if (szFileName == NULL)
        return E_INVALIDARG;

	if(strlen(szFileName) > 985)
		return E_INVALIDARG;
	sprintf(szBuf, "DELETE NAME=\"%s\" %s", szFileName, fIsDirectory ?
		"DIR" : "");
	return HrDoOneLineCmd(s, szBuf);
}

HRESULT HrOpenDir(SCI *psci, PDM_WALK_DIR *ppdmwd, LPCSTR szDirName,
    LPDWORD pdw)
{
    PDM_CONNECTION s;
	HRESULT hr;
	char szBuf[1024];
	struct _DM_WALKDIR_FILE *pwf, **ppwf;
    DWORD c;

    if (!ppdmwd || !szDirName)
        return E_INVALIDARG;

	/* This is our first call, so we need to build a list of all of the
	 * files returned by the remote machine */
	if(!szDirName || strlen(szDirName) > 990)
		return E_INVALIDARG;
    hr = HrDoOpenSharedConnection(psci, &s);
    if(FAILED(hr))
        return hr;
	sprintf(szBuf, "DIRLIST NAME=\"%s\"", szDirName);
	hr = DmSendCommand(s, szBuf, NULL, NULL);
	if(hr != XBDM_MULTIRESPONSE) {
        if(SUCCEEDED(hr)) {
            hr = E_UNEXPECTED;
fatal:
            TerminateConnection(s);
        }
        DoCloseSharedConnection(psci, s);
		return hr;
	}
	
	/* We've got the connection, so we can allocate a walkdir structure
	 * now */
	*ppdmwd = LocalAlloc(LMEM_FIXED, sizeof (struct _DM_WALK_DIR));
    if(!*ppdmwd) {
        hr = E_OUTOFMEMORY;
        goto fatal;
	}
	ppwf = &(*ppdmwd)->pwfFirst;
	/* Read all of the filenames and construct a buffer for them all */
	for(c = 0; ; ++c) {
        DWORD cch;
		pwf = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
            sizeof (struct _DM_WALKDIR_FILE));
		if(!pwf) {
			/* Oh no */
			hr = E_OUTOFMEMORY;
			break;
		}
        cch = sizeof szBuf;
		hr = DmReceiveSocketLine(s, szBuf, &cch);
		/* Stop if we can't read or if we're done */
		if(FAILED(hr) || (cch == 1 && szBuf[0] == '.')) {
			/* We're done now */
			LocalFree(pwf);
			break;
		}
        UnpackDmfa(psci, szBuf, &pwf->dmfa);
        if(!pwf->dmfa.Name[0]) {
            LocalFree(pwf);
            hr = E_UNEXPECTED;
            break;
        }
		*ppwf = pwf;
		ppwf = &pwf->pwfNext;
	}
	*ppwf = NULL;
    if(FAILED(hr))
        goto fatal;
    DoCloseSharedConnection(psci, s);
    if(pdw)
        *pdw = c;
    return XBDM_NOERR;
}

HRESULT HrWalkDir(SCI *psci, PDM_WALK_DIR *ppdmwd, LPCSTR szDirName,
    PDM_FILE_ATTRIBUTES pdmfa)
{
	HRESULT hr;
	char szBuf[1024];
	struct _DM_WALKDIR_FILE *pwf, **ppwf;

    if (!ppdmwd || !pdmfa)
        return E_INVALIDARG;

    if(!*ppdmwd) {
        hr = HrOpenDir(psci, ppdmwd, szDirName, NULL);
        if(FAILED(hr))
            return hr;
    }

	pwf = (*ppdmwd)->pwfFirst;
	if(!pwf)
		return XBDM_ENDOFLIST;
	(*ppdmwd)->pwfFirst = pwf->pwfNext;

    memcpy(pdmfa, &pwf->dmfa, sizeof *pdmfa);
	CorrectTime(psci, &pdmfa->CreationTime, FALSE);
	CorrectTime(psci, &pdmfa->ChangeTime, FALSE);

	LocalFree(pwf);
	return XBDM_NOERR;
}

HRESULT DmCloseDir(PDM_WALK_DIR pdmwd)
{
	struct _DM_WALKDIR_FILE *pwf;
	if(pdmwd) {
        while(pdmwd->pwfFirst) {
            pwf = pdmwd->pwfFirst;
            pdmwd->pwfFirst = pwf->pwfNext;
            LocalFree(pwf);
        }
        LocalFree(pdmwd);
    }
	return XBDM_NOERR;
}

HRESULT DmWalkLoadedModules(PDM_WALK_MODULES *ppdmwm, DMN_MODLOAD *pdmml)
{
	PDM_CONNECTION s;
	HRESULT hr;
	struct _DM_WALKMOD_MODULE *pwm, **ppwm;

	if(!ppdmwm || !pdmml)
		return E_INVALIDARG;

	if(!*ppdmwm) {
		hr = HrOpenSharedConnection(&s);
		if(FAILED(hr))
			return hr;
		hr = DmSendCommand(s, "MODULES", NULL, 0);
		if(hr != XBDM_MULTIRESPONSE) {
            if(SUCCEEDED(hr)) {
                TerminateConnection(s);
                hr = E_UNEXPECTED;
            }
            CloseSharedConnection(s);
			return hr;
		}
		/* Build up a list of the modules */
		*ppdmwm = LocalAlloc(LMEM_FIXED, sizeof(struct _DM_WALK_MODULES));
		if(!*ppdmwm) {
			CloseSharedConnection(s);
			return E_OUTOFMEMORY;
		}
		ppwm = &(*ppdmwm)->pwmFirst;
		for(;;) {
			char sz[512];
			DWORD cch = sizeof sz;
			hr = DmReceiveSocketLine(s, sz, &cch);
			if(*sz == '.' || FAILED(hr))
				break;
			pwm = LocalAlloc(LMEM_FIXED, sizeof(struct _DM_WALKMOD_MODULE));
			if(!pwm) {
				hr = E_OUTOFMEMORY;
				break;
			}
			if(!FUnpackDmml(sz, &pwm->dmml, FALSE))
				LocalFree(pwm);
			else {
				*ppwm = pwm;
				ppwm = &pwm->pwmNext;
			}
		}
		CloseSharedConnection(s);
		*ppwm = NULL;
		if(FAILED(hr)) {
			DmCloseLoadedModules(*ppdmwm);
			*ppdmwm = NULL;
		}
	}

	/* Now if we have a list, we'll return data from it */
	if(*ppdmwm) {
		pwm = (*ppdmwm)->pwmFirst;
		if(pwm) {
			(*ppdmwm)->pwmFirst = pwm->pwmNext;
			memcpy(pdmml, &pwm->dmml, sizeof pwm->dmml);
			LocalFree(pwm);
			hr = XBDM_NOERR;
		} else
			hr = XBDM_ENDOFLIST;
	}
	return hr;
}

HRESULT DmCloseLoadedModules(PDM_WALK_MODULES pdmwm)
{
	struct _DM_WALKMOD_MODULE *pwm;
	if(pdmwm) {
        while(pdmwm->pwmFirst) {
            pwm = pdmwm->pwmFirst;
            pdmwm->pwmFirst = pwm->pwmNext;
            LocalFree(pwm);
        }
        LocalFree(pdmwm);
    }
	return XBDM_NOERR;
}

HRESULT DmWalkModuleSections(PDM_WALK_MODSECT *ppdmws, LPCSTR szModule,
	DMN_SECTIONLOAD *pdmsl)
{
	PDM_CONNECTION s;
	HRESULT hr;
	struct _DM_WALKMOD_SECTION *pws, **ppws;
	char sz[256];

	if(!ppdmws || !pdmsl)
		return E_INVALIDARG;

	if(!*ppdmws) {
        if(!szModule)
            return E_INVALIDARG;
		hr = HrOpenSharedConnection(&s);
		if(FAILED(hr))
			return hr;
		sprintf(sz, "MODSECTIONS NAME=\"%s\"", szModule);
		hr = DmSendCommand(s, sz, NULL, 0);
		if(hr != XBDM_MULTIRESPONSE) {
            if(SUCCEEDED(hr)) {
                TerminateConnection(s);
                hr = E_UNEXPECTED;
            }
            CloseSharedConnection(s);
			return hr;
		}
		/* Build up a list of the modules */
		*ppdmws = LocalAlloc(LMEM_FIXED, sizeof(struct _DM_WALK_MODSECT));
		if(!*ppdmws) {
			CloseSharedConnection(s);
			return E_OUTOFMEMORY;
		}
		ppws = &(*ppdmws)->pwsFirst;
		for(;;) {
			char sz[512];
			DWORD cch = sizeof sz;
			hr = DmReceiveSocketLine(s, sz, &cch);
			if(*sz == '.' || FAILED(hr))
				break;
			pws = LocalAlloc(LMEM_FIXED, sizeof(struct _DM_WALKMOD_SECTION));
			if(!pws) {
				hr = E_OUTOFMEMORY;
				break;
			}
			if(!FUnpackDmsl(sz, &pws->dmsl, FALSE))
				LocalFree(pws);
			else {
				*ppws = pws;
				ppws = &pws->pwsNext;
			}
		}
		CloseSharedConnection(s);
		*ppws = NULL;
		if(FAILED(hr)) {
			DmCloseModuleSections(*ppdmws);
			*ppdmws = NULL;
		}
	}

	/* Now if we have a list, we'll return data from it */
	if(*ppdmws) {
		pws = (*ppdmws)->pwsFirst;
		if(pws) {
			(*ppdmws)->pwsFirst = pws->pwsNext;
			memcpy(pdmsl, &pws->dmsl, sizeof pws->dmsl);
			LocalFree(pws);
			hr = XBDM_NOERR;
		} else
			hr = XBDM_ENDOFLIST;
	}
	return hr;
}

HRESULT DmCloseModuleSections(PDM_WALK_MODSECT pdmws)
{
	struct _DM_WALKMOD_SECTION *pws;
	if(!pdmws)
		return E_INVALIDARG;
	while(pdmws->pwsFirst) {
		pws = pdmws->pwsFirst;
		pdmws->pwsFirst = pws->pwsNext;
		LocalFree(pws);
	}
	LocalFree(pdmws);
	return XBDM_NOERR;
}

HRESULT DmGetModuleLongName(LPCSTR szShort, LPSTR szLong, LPDWORD pcchLong)
{
	char sz[1024];
	PDM_CONNECTION s;
	HRESULT hr;
	DWORD cch;
	DWORD cchMax;

    if (!szLong || !pcchLong || !szShort)
        return E_INVALIDARG;

	hr = HrOpenSharedConnection(&s);
	if(FAILED(hr))
		return hr;
	sprintf(sz, "MODLONG NAME=\"%s\"", szShort);
	cch = sizeof sz;
	hr = DmSendCommand(s, sz, sz, &cch);
	CloseSharedConnection(s);
	if(FAILED(hr))
		return hr;
	cchMax = *pcchLong - 1;
	for(cch = 0; sz[5+cch] && cch < cchMax; ++cch)
		*szLong++ = sz[5+cch];
	*szLong = 0;
	*pcchLong = cch;
	return hr;
}

HRESULT HrGetXbeInfo(SCI *psci, LPCSTR szName, PDM_XBE pxbe)
{
	PDM_CONNECTION s;
	char sz[1024];
	HRESULT hr;

    if (!pxbe)
        return E_INVALIDARG;

    hr = HrDoOpenSharedConnection(psci, &s);
	if(FAILED(hr))
		return hr;
    if(szName)
	    sprintf(sz, "XBEINFO NAME=\"%s\"", szName);
    else
        strcpy(sz, "XBEINFO RUNNING");
	hr = DmSendCommand(s, sz, NULL, 0);
	if(hr != XBDM_MULTIRESPONSE) {
        if(SUCCEEDED(hr)) {
            TerminateConnection(s);
            hr = E_UNEXPECTED;
        }
        DoCloseSharedConnection(psci, s);
		return hr;
	}
	memset(pxbe, 0, sizeof *pxbe);
	for(;;) {
		DWORD cch = sizeof sz;
		hr = DmReceiveSocketLine(s, sz, &cch);
		if(FAILED(hr) || sz[0] == '.')
			break;
		FGetSzParam(sz, "name", pxbe->LaunchPath);
		FGetDwParam(sz, "timestamp", &pxbe->TimeStamp);
		FGetDwParam(sz, "checksum", &pxbe->CheckSum);
	}
	DoCloseSharedConnection(psci, s);
	return XBDM_NOERR;
}

HRESULT DmSetTitle(LPCSTR szDir, LPCSTR szName, LPCSTR szCmdLine)
{
	char sz[1024];
    char *pch;

    if (!szName)
        return E_INVALIDARG;

    sprintf(sz, "TITLE NAME=\"%s\"", szName);
    pch = sz + strlen(sz);
    if(szDir) {
        sprintf(pch, " DIR=\"%s\"", szDir);
        pch += strlen(pch);
    }

    if(szCmdLine) {
        if(pch + 10 + strlen(szCmdLine) > sz + sizeof(sz))
            return E_INVALIDARG;
        sprintf(pch, " CMDLINE=%s", szCmdLine);
    } else {
#if 0 // Commented out while Raid #4344 is further discussed.
        if(pch + 10 > sz + sizeof(sz))
            return E_INVALIDARG;
        sprintf(pch, " CMDLINE=");
#endif
    }
	return HrOneLineCmd(sz);
}

BOOL FUnpackDmml(LPCSTR sz, PDMN_MODLOAD pdmml, BOOL fCommand)
{
	memset(pdmml, 0, sizeof *pdmml);
    if(!FGetSzParam(sz, "name", pdmml->Name) ||
            !FGetDwParam(sz, "base", (DWORD*)&pdmml->BaseAddress) ||
            !FGetDwParam(sz, "size", &pdmml->Size))
        return FALSE;
	/* Get the checksum and timestamp if available */
	FGetDwParam(sz, "timestamp", &pdmml->TimeStamp);
	FGetDwParam(sz, "checksum", &pdmml->CheckSum);
    if(PchGetParam(sz, "tls", FALSE, fCommand))
        pdmml->Flags |= DMN_MODFLAG_TLS;
    if(PchGetParam(sz, "xbe", FALSE, fCommand))
        pdmml->Flags |= DMN_MODFLAG_XBE;
    return TRUE;
}

BOOL FUnpackDmsl(LPCSTR sz, PDMN_SECTIONLOAD pdmsl, BOOL fCommand)
{
    DWORD dw;
	memset(pdmsl, 0, sizeof *pdmsl);
    if(!FGetSzParam(sz, "name", pdmsl->Name) ||
	        !FGetDwParam(sz, "base", (DWORD*)&pdmsl->BaseAddress) ||
	        !FGetDwParam(sz, "size", &pdmsl->Size))
        return FALSE;
    if(FGetDwParam(sz, "index", &dw))
        pdmsl->Index = (USHORT)dw;
    if(FGetDwParam(sz, "flags", &dw))
        pdmsl->Flags = (USHORT)dw;
    return TRUE;
}

HRESULT HrGetDriveList(PDM_CONNECTION pdcon, LPSTR rgchDrives, DWORD *pcDrives)
{
    HRESULT hr;
    char sz[128];
    DWORD cch;

    cch = sizeof sz;
    hr = DmSendCommand(pdcon, "DRIVELIST", sz, &cch);
    if(hr == XBDM_NOERR) {
        if(cch >= sizeof sz - 1)
            /* Oops, didn't get enough data */
            return XBDM_BUFFER_TOO_SMALL;
        cch -= 5; // strip off "200- " prefix
        if(cch >= *pcDrives - 1)
            return XBDM_BUFFER_TOO_SMALL;
        strcpy(rgchDrives, sz + 5);
        *pcDrives = cch;
    } else {
        if(SUCCEEDED(hr)) {
            hr = E_UNEXPECTED;
            TerminateConnection(pdcon);
        }
    }

    return hr;
}

HRESULT HrGetDiskFreeSpace(SCI *psci, char *szDrive,
                           PULARGE_INTEGER pnFreeBytesAvailableToCaller,
                           PULARGE_INTEGER pnTotalNumberOfBytes,
                           PULARGE_INTEGER pnTotalNumberOfFreeBytes)
{
    char szResult[300], szCommand[100];
    PDM_CONNECTION pdcon;
    HRESULT hr;
    ULARGE_INTEGER rgliT[3];

    if (!szDrive)
        return E_INVALIDARG;
    if(!pnFreeBytesAvailableToCaller)
        pnFreeBytesAvailableToCaller = &rgliT[0];
    if(!pnTotalNumberOfBytes)
        pnTotalNumberOfBytes = &rgliT[1];
    if(!pnTotalNumberOfFreeBytes)
        pnTotalNumberOfFreeBytes = &rgliT[2];

    // Open a connection so that we can send a command across to the XBox
	hr = HrDoOpenSharedConnection(psci, &pdcon);
	if(FAILED(hr))
		return hr;

    // Create the command string
    sprintf(szCommand, "DRIVEFREESPACE NAME=\"%s\"", szDrive);

    // Send the command to the XBox.  If successful, then parse out the results
    hr = DmSendCommand(pdcon, szCommand, NULL, 0);
    if(hr != XBDM_MULTIRESPONSE) {
        if(SUCCEEDED(hr)) {
            hr = E_UNEXPECTED;
            TerminateConnection(pdcon);
        }
    } else {
        pnFreeBytesAvailableToCaller->QuadPart = pnTotalNumberOfBytes->QuadPart =
            pnTotalNumberOfFreeBytes->QuadPart = 0;

        // Receive the rest of the result
        for(;;) {
            DWORD cch = sizeof szResult;
		    hr = DmReceiveSocketLine(pdcon, szResult, &cch);
		    if(FAILED(hr) || *szResult == '.')
    		    break;

            FGetDwParam(szResult, "freetocallerlo",   &pnFreeBytesAvailableToCaller->LowPart);
            FGetDwParam(szResult, "freetocallerhi",   &pnFreeBytesAvailableToCaller->HighPart);
            FGetDwParam(szResult, "totalbyteslo",     &pnTotalNumberOfBytes->LowPart);
            FGetDwParam(szResult, "totalbyteshi",     &pnTotalNumberOfBytes->HighPart);
            FGetDwParam(szResult, "totalfreebyteslo", &pnTotalNumberOfFreeBytes->LowPart);
            FGetDwParam(szResult, "totalfreebyteshi", &pnTotalNumberOfFreeBytes->HighPart);
        }
    }

    // We no longer need our connection to the XBox, so close it.
	DoCloseSharedConnection(psci, pdcon);

    return hr;
}	

BOOL WritePixels(HANDLE hFile, BYTE *pbySource, int cBytesToWrite, int nBitCount);
DWORD dwRedMask, dwGreenMask, dwBlueMask;
DWORD dwRedShift, dwGreenShift, dwBlueUpShift;

HRESULT HrScreenShot(SCI *psci, LPCSTR filename)
{
    PDM_CONNECTION s;
    DWORD cch, cBytesRemainingToWrite;
    char str[256];
    int  bitcount;
    HANDLE hFile;
    DWORD dwTotalSize;
    DWORD dwPitch, dwHeight, dwWidth, dwFormat, dwFrameBufferSize;
    DWORD cBytesToWrite, cBytesToReceive;
    BITMAPFILEHEADER bmfh;
    BITMAPINFOHEADER bmih;
    BYTE bitBuffer[8192];
    int i;
    DWORD dwRest = 0;
    HRESULT hr;
    int nbySrcPitch, nbySrcWidth;
    DWORD dwDestPitch;

    BYTE *pBufferMax = NULL;
    BYTE *pBuffer = NULL;
    int nbyLineWritten = 0;
    int nbyToWrite;

    if (filename == NULL)
        return E_INVALIDARG;

    hr = HrDoOpenSharedConnection(psci, &s);
    if(FAILED(hr))
        return hr;

    cch = 255;
    hr = DmSendCommand( s, "screenshot", str, &cch );
    if(hr != XBDM_BINRESPONSE) {
        if(SUCCEEDED(hr)) {
            TerminateConnection(s);
            hr = E_UNEXPECTED;
        }
        DoCloseSharedConnection(psci, s);
        return hr;
    }

    cch = 255;
    hr = DmReceiveSocketLine(s, str, &cch);
    if(FAILED(hr)) {
        TerminateConnection(s);
        DoCloseSharedConnection(psci, s);
        return hr;
    }

    // Get bitmap information from the returned string
    if(!FGetDwParam(str, "pitch", &dwPitch)) {
error:
        TerminateConnection(s);
        DoCloseSharedConnection(psci, s);
        return E_UNEXPECTED;
    }
    if(!FGetDwParam(str, "height", &dwHeight))
        goto error;
    if(!FGetDwParam(str, "width", &dwWidth))
        goto error;
    if(!FGetDwParam(str, "format", &dwFormat))
        goto error;
    if(!FGetDwParam(str, "framebuffersize", &dwFrameBufferSize))
        goto error;

    switch(dwFormat) {
    case 0x00000012://D3DFMT_LIN_A8R8G8B8:
        nbySrcPitch = dwPitch;
        nbySrcWidth = dwWidth * 4;
        bitcount = 32;
        break;

    case 0x0000001E://D3DFMT_LIN_X8R8G8B8:
        nbySrcPitch = dwPitch;
        nbySrcWidth = dwWidth * 4;
        bitcount = 32;
        break;

    case 0x00000011://D3DFMT_LIN_R5G6B5:    
        nbySrcPitch = dwPitch;
        nbySrcWidth = dwWidth * 2;
        dwRedMask = 0xf800; dwGreenMask = 0x07E0; dwBlueMask = 0x001F;
        dwRedShift = 8; dwGreenShift = 3; dwBlueUpShift = 3;
        bitcount = 16;
        break;

    case 0x0000001C://D3DFMT_LIN_X1R5G5B5:
        nbySrcPitch = dwPitch;
        nbySrcWidth = dwWidth * 2;
        dwRedMask = 0x7c00; dwGreenMask = 0x03E0; dwBlueMask = 0x001F;
        dwRedShift = 7; dwGreenShift = 2; dwBlueUpShift = 3;
        bitcount = 16;
        break;

    default:
        TerminateConnection(s);
        DoCloseSharedConnection(psci, s);
        return E_FAIL;
    }

    // Force destination pitch to 24bpp
    dwDestPitch = dwWidth * 3;

    // Calculate total size of the bitmap
    dwTotalSize = (sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER) + dwDestPitch * dwHeight);

    // Create bitmap structure
    hFile = CreateFile(filename, GENERIC_WRITE, FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if(hFile == INVALID_HANDLE_VALUE) {
        TerminateConnection(s);
        CloseSharedConnection(s);
        return XBDM_FILEERROR;
    }

    ZeroMemory( &bmfh, sizeof(BITMAPFILEHEADER) );
    bmfh.bfType = 'MB';
    bmfh.bfSize = dwTotalSize;
    bmfh.bfOffBits = sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER);
    if(!WriteFile(hFile, &bmfh, sizeof(BITMAPFILEHEADER), &cch, NULL)) {
        TerminateConnection(s);
        CloseHandle(hFile);
        return XBDM_FILEERROR;
    }

    ZeroMemory(&bmih, sizeof(BITMAPINFOHEADER));
    bmih.biSize = sizeof(BITMAPINFOHEADER);
    bmih.biWidth = dwWidth;
    bmih.biHeight = dwHeight;
    bmih.biPlanes = 1;
    bmih.biBitCount = 24;
    if(!WriteFile(hFile, &bmih, sizeof(BITMAPINFOHEADER), &cch, NULL)) {
        TerminateConnection(s);
        CloseHandle(hFile);
        return XBDM_FILEERROR;
    }

    if(SetFilePointer(hFile, dwTotalSize-dwDestPitch, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER) {
        TerminateConnection(s);
        CloseHandle(hFile);
        return XBDM_FILEERROR;
    }

    // Read all of bitmap data
    while(dwFrameBufferSize) {

        // Read the next chunk from the frame buffer if needed.
        if (pBuffer >= pBufferMax) {
            cBytesToReceive = min(dwFrameBufferSize, 8192);

            hr = DmReceiveBinary(s, bitBuffer, cBytesToReceive, &cBytesRemainingToWrite);
            if(FAILED(hr)) {
                CloseHandle(hFile);
                TerminateConnection(s);
                DoCloseSharedConnection(psci, s);
                return hr;
            }

            pBuffer = bitBuffer;
            pBufferMax = pBuffer + cBytesToReceive;
        }

        if (nbyLineWritten < nbySrcWidth)
        {
            nbyToWrite = min(nbySrcWidth - nbyLineWritten, pBufferMax - pBuffer);

            if(!WritePixels(hFile, pBuffer, nbyToWrite, bitcount)) {
                CloseHandle(hFile);
                TerminateConnection(s);
                DoCloseSharedConnection(psci, s);
                return XBDM_FILEERROR;
            }

            pBuffer += nbyToWrite;
            nbyLineWritten += nbyToWrite;
            dwFrameBufferSize -= nbyToWrite;
        }
        else if (nbyLineWritten < nbySrcPitch)
        {
            nbyToWrite = min(nbySrcPitch - nbyLineWritten, pBufferMax - pBuffer);

            pBuffer += nbyToWrite;
            nbyLineWritten += nbyToWrite;
            dwFrameBufferSize -= nbyToWrite;
        }
        else
        {
            SetFilePointer(hFile, -(int)dwDestPitch*2, NULL, FILE_CURRENT);
            nbyLineWritten = 0;
        }
    }

    CloseHandle(hFile);
    DoCloseSharedConnection(psci, s);
    return XBDM_NOERR;
}

BOOL WritePixels(HANDLE hFile, BYTE *pbySource, int cBytesToWrite, int nBitCount)
{
    DWORD dwWritten, i, cPixels;
    BYTE byTemp[8192], *pbyTemp = byTemp;

    // Convert each pixel to full RGB quad.  The following is taken from the
    // BITMAPINFO section in MSDN:
    //  Note:  The bmiColors member should not contain palette indexes if the
    //         bitmap is to be stored in a file or transferred to another
    //         application.  Unless the application has exclusive use and
    //         control of the bitmap, the bitmap color table should contain
    //         explicit RGB values. 
    // Thus, we up-convert as necessary to create RGBQUADs.
    if (nBitCount == 32)
    {
        // 32bit; convert to 24bpp
        cPixels = cBytesToWrite/4;
        for (i = 0; i < cPixels; i++)
        {
            *pbyTemp++ = *pbySource++;
            *pbyTemp++ = *pbySource++;
            *pbyTemp++ = *pbySource++;
            pbySource++;    // Skip the alpha channel
        }
    }
    else
    {
        // 16 bit.  Convert as necessary based on bitmasks
        WORD *pwSource = (WORD*)pbySource;
        cPixels = cBytesToWrite/2;

        for (i = 0; i < cPixels; i++)
        {
            *pbyTemp++ = (BYTE)(((*pwSource) & dwBlueMask)  << dwBlueUpShift);
            *pbyTemp++ = (BYTE)(((*pwSource) & dwGreenMask) >> dwGreenShift);
            *pbyTemp++ = (BYTE)(((*pwSource) & dwRedMask)   >> dwRedShift);
            pwSource++;
        }
    }       

    // Write out the 24bit pixel values to the bmp file
    return WriteFile(hFile, &byTemp, cPixels*3, &dwWritten, NULL);
}

HRESULT DmMonitor(LPVOID bitBuffer, LPDWORD lpFrameBufferSize, LPDWORD lpWidth, LPDWORD lpHeight, LPDWORD lpFormat)
{
    PDM_CONNECTION s;
    DWORD cch, dwFrameBufferSize;
    char str[256];
    int cBytesRead = 0;
    HRESULT hr;

    hr = HrOpenSharedConnection(&s);
    if(FAILED(hr))
        return E_FAIL;

    hr = DmSendCommand( s, "screenshot", str, &cch );
    if(hr != XBDM_BINRESPONSE) {
        if(SUCCEEDED(hr)) {
            TerminateConnection(s);
            hr = E_UNEXPECTED;
        }
        CloseSharedConnection(s);
        return hr;
    }

    cch = 255;
    hr = DmReceiveSocketLine(s, str, &cch);
    if(FAILED(hr)) {
        TerminateConnection(s);
        CloseSharedConnection(s);
        return hr;
    }

    // Get bitmap information from the returned string
    if(lpHeight && !FGetDwParam(str, "height", lpHeight)) {
error:
        TerminateConnection(s);
        CloseSharedConnection(s);
        return E_UNEXPECTED;
    }
    if(lpWidth && !FGetDwParam(str, "width",lpWidth))
        goto error;
    if(lpFormat && !FGetDwParam(str, "format", lpFormat))
        goto error;
    if(lpFrameBufferSize) {
        if (!FGetDwParam(str, "framebuffersize", &dwFrameBufferSize))
            goto error;

        *lpFrameBufferSize = dwFrameBufferSize;
    }

    if(bitBuffer) {
        while(dwFrameBufferSize) {
            DWORD cBytesToReceive = min(dwFrameBufferSize, 8192);

            hr = DmReceiveBinary(s, (LPBYTE) bitBuffer + cBytesRead, cBytesToReceive, &cch);
            if(FAILED(hr)) {
                TerminateConnection(s);
                CloseSharedConnection(s);
                return hr;
            }

            cBytesRead += cch;
            dwFrameBufferSize -= cBytesToReceive;
        }
    }

    CloseSharedConnection(s);
    return XBDM_NOERR;
}

HRESULT DmPixelShaderSnapshot(DWORD dwX, DWORD dwY, DWORD dwFlags, DWORD dwMarker, BYTE *pBuffer)
{
    PDM_CONNECTION s;
    DWORD cch, cBytesRemainingToWrite;
    char str[256], cmd[256];
    DWORD cBytesToWrite, cBytesToReceive;
    HRESULT hr;

    if (pBuffer == NULL)
        return E_INVALIDARG;

    hr = HrOpenSharedConnection(&s);
    if(FAILED(hr))
    {
        sprintf(pBuffer, "Unable to open connection to Xbox");
        return hr;
    }

    cch = 255;
    
    sprintf(cmd, "PSSnap x=%d y=%d flags=%d marker=%d", dwX, dwY, dwFlags, dwMarker);
    hr = DmSendCommand( s, cmd, str, &cch );
    if(hr != XBDM_BINRESPONSE) 
    {
        strcpy(pBuffer, str);
        if(SUCCEEDED(hr)) 
        {
            TerminateConnection(s);
            hr = E_UNEXPECTED;
        }
        CloseSharedConnection(s);
        return hr;
    }

    // Read the 32k snapshot from the Xbox
    hr = DmReceiveBinary(s, pBuffer, 32768, &cBytesRemainingToWrite);
    if(FAILED(hr)) 
    {
        TerminateConnection(s);
        CloseSharedConnection(s);
        sprintf(pBuffer, "Failed to transfer data from Xbox");
        return hr;
    }
    CloseSharedConnection(s);
    return XBDM_NOERR;
}

HRESULT DmVertexShaderSnapshot(DWORD dwFirst, DWORD dwLast, DWORD dwFlags, DWORD dwMarker, BYTE *pBuffer)
{
    PDM_CONNECTION s;
    DWORD cch, cBytesRemainingToWrite;
    char str[256], cmd[256];
    DWORD cBytesToWrite, cBytesToReceive;
    HRESULT hr;

    if (pBuffer == NULL)
        return E_INVALIDARG;

    hr = HrOpenSharedConnection(&s);
    if(FAILED(hr))
    {
        sprintf(pBuffer, "Unable to open connection to Xbox");
        return hr;
    }

    cch = 255;
    
    sprintf(cmd, "VSSnap first=%d last=%d flags=%d marker=%d", dwFirst, dwLast, dwFlags, dwMarker);
    hr = DmSendCommand( s, cmd, str, &cch );
    if(hr != XBDM_BINRESPONSE) 
    {
        strcpy(pBuffer, str);
        // OK for xbdm to return success code
        CloseSharedConnection(s);
        return hr;
    }

    // Read the 32k snapshot from the Xbox
    hr = DmReceiveBinary(s, pBuffer, 32768, &cBytesRemainingToWrite);
    if(FAILED(hr)) 
    {
        TerminateConnection(s);
        CloseSharedConnection(s);
        sprintf(pBuffer, "Failed to transfer data from Xbox");
        return hr;
    }
    CloseSharedConnection(s);
    return XBDM_NOERR;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xboxdbg\resources.h ===
#define IDC_XBDM_NOERRORSTRING  0x8200
#define IDC_E_UNEXPECTED        0x8201
#define IDC_E_INVALIDARG        0x8202

//
// WARNING
// All of the below resource IDs have to match up with the appropriate error
// values
//

#define IDC_XBDM_UNDEFINED      0x8000
#define IDC_XBDM_MAXCONNECT     0x8001
#define IDC_XBDM_NOSUCHFILE     0x8002
#define IDC_XBDM_NOMODULE       0x8003
#define IDC_XBDM_MEMUNMAPPED    0x8004
#define IDC_XBDM_NOTHREAD       0x8005
#define IDC_XBDM_INVALIDCMD     0x8007
#define IDC_XBDM_NOTSTOPPED     0x8008
#define IDC_XBDM_MUSTCOPY       0x8009
#define IDC_XBDM_ALREADYEXISTS  0x800A
#define IDC_XBDM_DIRNOTEMPTY    0x800B
#define IDC_XBDM_BADFILENAME    0x800C
#define IDC_XBDM_CANNOTCREATE   0x800D
#define IDC_XBDM_CANNOTACCESS   0x800E
#define IDC_XBDM_DEVICEFULL     0x800F
#define IDC_XBDM_NOTDEBUGGABLE  0x8010
#define IDC_XBDM_BADCOUNTTYPE   0x8011
#define IDC_XBDM_COUNTUNAVAILABLE 0x8012

#define IDC_XBDM_CANNOTCONNECT  0x8100
#define IDC_XBDM_CONNECTIONLOST 0x8101
#define IDC_XBDM_FILEERROR      0x8103
#define IDC_XBDM_NOTXBEFILE     0x8106
#define IDC_XBDM_MEMSETINCOMPLETE 0x8107
#define IDC_XBDM_NOXBOXNAME     0x8108
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xboxdbg\precomp.h ===
#include <windows.h>
#include <winsock2.h>
#define _XBDM_
#include <xboxdbg.h>
#include <stdio.h>
#include <stdlib.h>

#ifdef __cplusplus
extern "C" {
#endif

#define MAX_XBOX_NAME 256
typedef struct _SCI {
    char szXboxName[MAX_XBOX_NAME];
    ULONG ulXboxIPAddr;
    DWORD dwConnectionTimeout;
    DWORD dwConversationTimeout;
    CRITICAL_SECTION csSharedConn;
    PDM_CONNECTION pdconShared;
    DWORD tidShared;
    union {
        struct {
            ULONG fAllowSharing:1,
                fBadSysTime:1,
                fGotTimeCorrection:1,
                fAddDiff:1,
                fCacheAddr:1,
                fSecureConnection:1,
                unused:26;
        };
        DWORD dwFlags;
    };
    ULARGE_INTEGER liTimeDiff;
} SCI;

extern SCI g_sci;
extern HINSTANCE hXboxdbg;

void EnsureWSAInited();
HRESULT HrOpenConnection(SCI *, PDM_CONNECTION *ppdcon, BOOL fRequireAccess);
HRESULT HrUseSharedConnection(SCI *, BOOL fShare);
HRESULT HrDoOpenSharedConnection(SCI *, PDM_CONNECTION *);
void DoCloseSharedConnection(SCI *, PDM_CONNECTION);
#define HrOpenSharedConnection(s) HrDoOpenSharedConnection(&g_sci, s)
#define CloseSharedConnection(s) DoCloseSharedConnection(&g_sci, s)
void TerminateConnection(PDM_CONNECTION);
HRESULT HrResolveNameIP(LPCSTR szName, struct sockaddr_in *psin);
void InitNotificationEvents(void);
void DestroyNotificationEvents(void);
void StopAllNotifications(void);
void CloseThreadConnection(void);
PDM_CONNECTION PdconWrapSocket(SOCKET);
HRESULT HrOneLineCmd(LPCSTR);
HRESULT HrDoOneLineCmd(PDM_CONNECTION, LPCSTR);
BOOL FUnpackDmml(LPCSTR, PDMN_MODLOAD, BOOL);
BOOL FUnpackDmsl(LPCSTR, PDMN_SECTIONLOAD, BOOL);
HRESULT HrOpenSecureConnection(SCI *, PDM_CONNECTION *, LPCSTR);
HRESULT HrAuthenticateUser(PDM_CONNECTION, PULARGE_INTEGER, PULARGE_INTEGER);
HRESULT HrSetupKeyExchange(PDM_CONNECTION, PULARGE_INTEGER);

/* Security */
void XBCCross(PULARGE_INTEGER pluKey, PULARGE_INTEGER pluData,
    PULARGE_INTEGER pluResult);
void XBCHashData(PULARGE_INTEGER pluHash, const BYTE *pb, ULONG cb);

/* File function implementations */
HRESULT HrSendFile(PDM_CONNECTION, LPCTSTR szLocalName, LPCSTR szRemoteName);
HRESULT HrReceiveFile(PDM_CONNECTION, LPCTSTR szLocalName, LPCSTR szRemoteName);
HRESULT HrGetFileAttributes(SCI *, LPCSTR szFileName, PDM_FILE_ATTRIBUTES);
HRESULT HrSetFileAttributes(SCI *, LPCSTR szFileName, PDM_FILE_ATTRIBUTES);
HRESULT HrMkdir(PDM_CONNECTION, LPCSTR szDirectoryName);
HRESULT HrRenameFile(PDM_CONNECTION, LPCSTR szOldName, LPCSTR szNewName);
HRESULT HrDeleteFile(PDM_CONNECTION, LPCSTR szFileName, BOOL fIsDirectory);
HRESULT HrOpenDir(SCI *, PDM_WALK_DIR *ppdmwd, LPCSTR szDirName,
    LPDWORD pdw);
HRESULT HrWalkDir(SCI *, PDM_WALK_DIR *ppdmwd, LPCSTR szDirName,
    PDM_FILE_ATTRIBUTES pdmfa);
HRESULT HrGetDriveList(PDM_CONNECTION pdcon, LPSTR rgchDrives, DWORD *pcDrives);
HRESULT HrGetDiskFreeSpace(SCI *psci, char *szDrive,
                           PULARGE_INTEGER pnFreeBytesAvailableToCaller,
                           PULARGE_INTEGER pnTotalNumberOfBytes,
                           PULARGE_INTEGER pnTotalNumberOfFreeBytes);
HRESULT HrGetXbeInfo(SCI *psci, LPCSTR szName, PDM_XBE pxbe);
HRESULT HrGetSystemTime(SCI *psci, LPSYSTEMTIME lpSysTime);
HRESULT HrGetNameOfXbox(PDM_CONNECTION, LPSTR szName, LPDWORD lpdwSize,
    BOOL fResolvable);
HRESULT HrGetAltAddress(SCI *psci, LPDWORD lpdw);
HRESULT HrScreenShot(SCI *psci, LPCSTR filename);
HRESULT HrIsSecurityEnabled(PDM_CONNECTION, LPBOOL pfEnabled);
HRESULT HrEnableSecurity(PDM_CONNECTION, BOOL fEnable);
HRESULT HrSetAdminPassword(PDM_CONNECTION, LPCSTR szPasswd);
HRESULT HrSetUserAccess(PDM_CONNECTION, LPCSTR szUserName, DWORD dwAccess);
HRESULT HrGetUserAccess(PDM_CONNECTION, LPCSTR szUserName, LPDWORD lpdwAccess);
HRESULT HrAddUser(PDM_CONNECTION, LPCSTR szUserName, DWORD dwAccess);
HRESULT HrRemoveUser(PDM_CONNECTION, LPCSTR szUserName);
HRESULT HrOpenUserList(SCI *, PDM_WALK_USERS *, LPDWORD);
HRESULT HrWalkUserList(SCI *, PDM_WALK_USERS *, PDM_USER);

// directory walking
typedef struct _DM_WALK_DIR *PDM_WALK_DIR;
DMHRAPI DmWalkDir(PDM_WALK_DIR *, LPCSTR szDir, PDM_FILE_ATTRIBUTES);

BOOL FGetLineData(LPCSTR szBuf, LPCSTR szKey, const char **ppchData);
const char *PchGetParam(LPCSTR szBuf, LPCSTR szKey, BOOL fNeedValue,
	BOOL fNoCommand);
BOOL FGetDwParamFromSz(LPCSTR sz, DWORD *pdwValue);
__inline BOOL FGetDwParam(LPCSTR szBuf, LPCSTR szKey, DWORD *pdwValue)
{
	return FGetDwParamFromSz(PchGetParam(szBuf, szKey, TRUE, TRUE), pdwValue);
}
BOOL FGetQwordParam(LPCSTR szBuf, LPCSTR szKey, ULARGE_INTEGER *plu);
BOOL FGetSzParam(LPCSTR szBuf, LPCSTR szKey, LPSTR szValue);
BOOL FGetNotificationData(LPCSTR sz, DWORD *pdwNotification, PVOID pv);
UINT FGetErrorStringResourceId(HRESULT hr);

struct _DM_CONNECTION {
	BYTE rgbBuf[1024];
	SOCKET s;
    union {
        struct {
            BOOL fAuthenticated:1,
                fAuthenticationAttempted:1,
                unused:30;
        };
        BOOL grbitFlags;
    };
	DWORD ibBuf;
	DWORD cbBuf;
    SCI *psci;
};

struct _DM_WALKDIR_FILE {
    struct _DM_WALKDIR_FILE *pwfNext;
    DM_FILE_ATTRIBUTES dmfa;
};

struct _DM_WALK_DIR {
    struct _DM_WALKDIR_FILE *pwfFirst;
};

struct _DM_WALKMOD_MODULE {
	struct _DM_WALKMOD_MODULE *pwmNext;
    DMN_MODLOAD dmml;
};

struct _DM_WALK_MODULES {
    struct _DM_WALKMOD_MODULE *pwmFirst;
};

struct _DM_WALKMOD_SECTION {
	struct _DM_WALKMOD_SECTION *pwsNext;
    DMN_SECTIONLOAD dmsl;
};

struct _DM_WALK_MODSECT {
    struct _DM_WALKMOD_SECTION *pwsFirst;
};

struct _DM_WALKPC {
    struct _DM_WALKPC *pwpcNext;
    DM_COUNTINFO dmci;
};

struct _DM_WALK_COUNTERS {
    struct _DM_WALKPC *pwpcFirst;
};

struct _DM_WALKUSER {
    struct _DM_WALKUSER *pwuNext;
    DM_USER dmu;
};

struct _DM_WALK_USERS {
    struct _DM_WALKUSER *pwuFirst;
};

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xboxdbg\protocol.c ===
/*
**
** protocol.c
**
** Protocol send/receive stuff for the debug protocol
**
*/

#include "precomp.h"
#include "resources.h"

#define XBOX_NAME_KEY "Software\\Microsoft\\XboxSDK"
#define XBOX_NAME_VALUE "XboxName"

SCI g_sci;
BOOL fWSAInit;
WSADATA wsad;

void EnsureWSAInited(void)
{
	if(!fWSAInit)
		fWSAInit = WSAStartup(2, &wsad) == 0;
}

HRESULT HrUseSharedConnection(SCI *psci, BOOL fShare)
{
	if(!psci->fAllowSharing == !fShare)
		return XBDM_NOERR;
	EnterCriticalSection(&psci->csSharedConn);
	/* If we're turning off sharing and the shared connection is not in use,
	 * then we'll close it, and if it is in use, we'll orphan it */
	if(!fShare && psci->pdconShared) {
        if(psci->tidShared == 0)
		    DmCloseConnection(psci->pdconShared);
		psci->pdconShared = NULL;
	}
	psci->fAllowSharing = fShare;
	LeaveCriticalSection(&psci->csSharedConn);
	return XBDM_NOERR;
}

HRESULT DmUseSharedConnection(BOOL fShare)
{
    return HrUseSharedConnection(&g_sci, fShare);
}

HRESULT DmGetXboxName(LPSTR sz, LPDWORD pcch)
{
	HRESULT hr;
	DWORD ich;

	if(!sz || !pcch)
		return E_INVALIDARG;

	/* Make sure it's appropriately set first */
	hr = DmSetXboxName(NULL);
	if(FAILED(hr))
		return hr;
	for(ich = 0; ich < *pcch; ++ich)
		if(!(sz[ich] = g_sci.szXboxName[ich])) {
			*pcch = ich;
			return XBDM_NOERR;
		}
	sz[--*pcch] = 0;
	return XBDM_BUFFER_TOO_SMALL;
}

HRESULT DmSetXboxName(LPCSTR sz)
{
	HRESULT hr;
	HKEY h;

    g_sci.ulXboxIPAddr = 0;
	if(!sz) {
		/* We're being asked to validate the name that's in the global.  If
		 * no data is in the global, we'll check the registry */
		DWORD dwType;
		DWORD cb;

		if(*g_sci.szXboxName)
			return XBDM_NOERR;

		if(ERROR_SUCCESS != RegOpenKeyEx(HKEY_CURRENT_USER, XBOX_NAME_KEY, 0,
				KEY_QUERY_VALUE, &h))
			return XBDM_NOXBOXNAME;
		cb = sizeof g_sci.szXboxName;
		if(ERROR_SUCCESS != RegQueryValueEx(h, XBOX_NAME_VALUE, 0, &dwType,
				g_sci.szXboxName, &cb) || dwType != REG_SZ) {
			*g_sci.szXboxName = 0;
			hr = XBDM_NOXBOXNAME;
		} else
			hr = XBDM_NOERR;
		RegCloseKey(h);
	} else {
		DWORD cch;
	
		cch = strlen(sz);
		if(cch >= MAX_XBOX_NAME)
			return E_INVALIDARG;
		strcpy(g_sci.szXboxName, sz);
		if(ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER, XBOX_NAME_KEY, 0,
				NULL, 0, KEY_SET_VALUE, NULL, &h, NULL)) {
			RegSetValueEx(h, XBOX_NAME_VALUE, 0, REG_SZ, g_sci.szXboxName,
                1 + cch);
			RegCloseKey(h);
		}
		hr = XBDM_NOERR;
	}

	return hr;
}

HRESULT DmSetXboxNameNoRegister(LPCSTR sz)
{
    if(!sz || strlen(sz) >= MAX_XBOX_NAME)
        return E_INVALIDARG;
    g_sci.ulXboxIPAddr = 0;
    strcpy(g_sci.szXboxName, sz);
    return XBDM_NOERR;
}

HRESULT HrFromStatus(LPSTR sz)
{
	int nCode;

	nCode = (sz[0] - '2') * 100 + (sz[1] - '0') * 10 + (sz[2] - '0');
	if(*sz == '4')
		/* An error code */
		return MAKE_HRESULT(1, FACILITY_XBDM, nCode - 200);
	else
		return MAKE_HRESULT(0, FACILITY_XBDM, nCode);
}

typedef struct _NM {
	BYTE bRequest;
	BYTE cchName;
	char szName[255];
} NM;

BOOL FNmQuery(NM *pnmIn, NM *pnmOut, struct sockaddr_in *psin, BOOL fBroadcast)
{
	struct sockaddr_in sinU;
	SOCKET s;
	int cRetries;
	const DWORD dwRetry = 500;
    NM *pnmResult;
    NM nm;
    BOOL f;

    /* Set up the UDP socket */
	s = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
	if(s == INVALID_SOCKET)
		return E_FAIL;
    if(fBroadcast) {
	    f = TRUE;
	    if(0 != setsockopt(s, SOL_SOCKET, SO_BROADCAST, (PVOID)&f, sizeof f)) {
		    closesocket(s);
		    return E_FAIL;
        }
	    sinU.sin_addr.s_addr = htonl(INADDR_BROADCAST);
    } else
	    sinU.sin_addr.s_addr = psin->sin_addr.s_addr;
	sinU.sin_family = AF_INET;
	sinU.sin_port = htons(DEBUGGER_PORT);

    /* Set up the result */
    pnmResult = pnmOut ? pnmOut : &nm;

    /* Keep retrying every 1/2 second */
    f = FALSE;
	for(cRetries = 4; !f && cRetries--; ) {
        DWORD tickTry = GetTickCount() + dwRetry;
		if(sendto(s, (PVOID)pnmIn, pnmIn->cchName + 2, 0,
			(struct sockaddr *)&sinU, sizeof sinU) == pnmIn->cchName + 2)
		{
			int fSel;

            do {
                int tickRetry;

                /* Look for a response.  If we've already waited for a full
                 * half second, then don't bother any longer */
                tickRetry = tickTry - GetTickCount();
                if(tickRetry <= 0)
                    fSel = 0;
                else {
			        fd_set fds;
			        struct timeval tv;

			        FD_ZERO(&fds);
			        FD_SET(s, &fds);
			        tv.tv_sec = tickRetry / 1000;
			        tv.tv_usec = (tickRetry % 1000) * 1000;
			        fSel = select(0, &fds, NULL, NULL, &tv);
                }

			    if(fSel > 0) {
				    NM nmT;
				    int cbAddr = sizeof sinU;
				    /* Got some data, is it for us? */
				    if(recvfrom(s, (PVOID)pnmResult, sizeof *pnmResult, 0,
						    (struct sockaddr *)&sinU, &cbAddr) <= 0)
					    fSel = -1;
				    else {
					    if(pnmResult->bRequest == 2 && (pnmOut ||
                            (pnmResult->cchName == pnmIn->cchName &&
                            !_strnicmp(pnmIn->szName, pnmResult->szName,
                            pnmIn->cchName))))
                        {
						    /* Got it! */
                            f = TRUE;
                            fSel = 0;
						    break;
                        }
				    }
			    }
                if(fSel < 0) {
				    /* Error, need to sleep */
				    Sleep(tickRetry);
                    fSel = 0;
                }
            } while(fSel);
		} else {
			int err = WSAGetLastError();
			/* Send failed, need to sleep */
			Sleep(dwRetry);
		}
	}

	closesocket(s);

    /* We have our answer */
    if(f)
	    psin->sin_addr.s_addr = sinU.sin_addr.s_addr;
	return f;
}

HRESULT HrResolveXboxName(LPCSTR szName, struct sockaddr_in *psin)
{
	NM nm;

    /* Mark the packet as a name request */
    nm.bRequest = 1;
	for(nm.cchName = 0; szName[nm.cchName]; ++nm.cchName)
		nm.szName[nm.cchName] = szName[nm.cchName];
    return FNmQuery(&nm, NULL, psin, TRUE) ? XBDM_NOERR : XBDM_CANNOTCONNECT;
}

HRESULT HrGetNameOfXbox(PDM_CONNECTION s, LPSTR szName, LPDWORD lpdwSize,
    BOOL fResolvable)
{
    char sz[512];
    DWORD cch;
    NM nmWild, nmName;
    struct sockaddr_in sin, sinT;
    HRESULT hr;
    int cb;

    if(!szName || !lpdwSize)
        return E_INVALIDARG;

    /* First, gather the box's IP address */
    cb = sizeof sin;
    if(0 != getpeername(s->s, (struct sockaddr *)&sin, &cb))
        return E_UNEXPECTED;

    /* First ask the box for its name */
    cch = sizeof sz;
    hr = DmSendCommand(s, "DEBUGNAME", sz, &cch);
    if(SUCCEEDED(hr)) {
        /* Stick this name in the NM */
        if(cch - 5 >= sizeof nmName.szName)
            nmName.cchName = sizeof nmName.szName;
        else
            nmName.cchName = (UCHAR)(cch - 5);
        memcpy(nmName.szName, sz + 5, nmName.cchName);
    } else {
        /* The box apparently doesn't know how to answer its name.  See if
         * we can use the UDP scheme to query the box for its name by
         * wildcard matching */
        nmWild.bRequest = 3;
        if(!FNmQuery(&nmWild, &nmName, &sin, FALSE))
            return XBDM_UNDEFINED;
    }
    if((ULONG)nmName.cchName + 1 >= *lpdwSize)
        return XBDM_BUFFER_TOO_SMALL;
    memcpy(szName, nmName.szName, nmName.cchName);
    szName[nmName.cchName] = 0;
    *lpdwSize = nmName.cchName;

    /* If we require that the name be resolvable, make sure we can resolve it
     * to the same address */
    if(fResolvable) {
        nmName.bRequest = 1;
        if(!FNmQuery(&nmName, NULL, &sinT, TRUE) || sin.sin_addr.s_addr !=
                sinT.sin_addr.s_addr)
            return XBDM_CANNOTCONNECT;
    }

    return XBDM_NOERR;
}

HRESULT HrResolveNameIP(LPCSTR szName, struct sockaddr_in *psin)
{
    HRESULT hr;

	EnsureWSAInited();
	psin->sin_addr.s_addr = inet_addr(szName);
	if(psin->sin_addr.s_addr == INADDR_NONE)
		hr = HrResolveXboxName(szName, psin);
    else
        hr = XBDM_NOERR;
	return hr;
}

PDM_CONNECTION PdconWrapSocket(SOCKET s)
{
	PDM_CONNECTION pdcon;

	pdcon = LocalAlloc(LMEM_FIXED, sizeof *pdcon);
	if(pdcon) {
        memset(pdcon, 0, sizeof *pdcon);
		pdcon->s = s;
		pdcon->cbBuf = pdcon->ibBuf = 0;
        pdcon->grbitFlags = 0;
	}
	return pdcon;
}

HRESULT HrOpenConnectionCore(SCI *psci, PDM_CONNECTION *ppdcon)
{
    struct sockaddr_in sin;
	HRESULT hr;
	PDM_CONNECTION pdcon;
    BOOL fNonBlock;
    BOOL fError;
    struct timeval tv;
    fd_set fds;

    /* Special check to see whether we need to update from the registry */
    if(psci == &g_sci) {
        hr = DmSetXboxName(NULL);
        if(FAILED(hr))
            return hr;
    }

    if(psci->ulXboxIPAddr && psci->fCacheAddr)
        sin.sin_addr.s_addr = psci->ulXboxIPAddr;
    else {
        hr = HrResolveNameIP(psci->szXboxName, &sin);
        if(FAILED(hr))
            return hr;
        psci->ulXboxIPAddr = sin.sin_addr.s_addr;
    }

	pdcon = PdconWrapSocket(INVALID_SOCKET);
	if(!pdcon)
		return E_OUTOFMEMORY;

    /* Set up the socket */
    pdcon->psci = psci;
	pdcon->s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if(pdcon->s == INVALID_SOCKET) {
		hr = XBDM_CANNOTCONNECT;
		goto error;
	}

    /* If we have a timeout value, make the socket nonblocking so we can
     * select on the connect */
    if(psci->dwConnectionTimeout) {
        fNonBlock = TRUE;
        if(0 != ioctlsocket(pdcon->s, FIONBIO, &fNonBlock))
            goto error;
    }

    /* Now attempt to connect the socket */
	sin.sin_family = AF_INET;
	sin.sin_port = htons(DEBUGGER_PORT);
	if(0 != connect(pdcon->s, (struct sockaddr *)&sin, sizeof sin)) {
        if(psci->dwConnectionTimeout && WSAGetLastError() == WSAEWOULDBLOCK) {
            /* Attempt to wait for the connection */
            tv.tv_sec = psci->dwConnectionTimeout / 1000;
            tv.tv_usec = (psci->dwConnectionTimeout % 1000) * 1000;
            FD_ZERO(&fds);
            FD_SET(pdcon->s, &fds);
            fError = select(0, NULL, &fds, NULL, &tv) <= 0;
        } else
            fError = TRUE;
        if(fError) {
		    hr = XBDM_CANNOTCONNECT;
            goto error;
        }
	}

    /* If we haven't already made the socket nonblocking, we do so now */
    if(!psci->dwConnectionTimeout) {
        fNonBlock = TRUE;
        if(0 != ioctlsocket(pdcon->s, FIONBIO, &fNonBlock))
            goto error;
    }

	*ppdcon = pdcon;
	return XBDM_NOERR;
error:
    if(pdcon->s != INVALID_SOCKET)
        closesocket(pdcon->s);
	LocalFree(pdcon);
	return hr;
}

HRESULT HrOpenConnection(SCI *psci, PDM_CONNECTION *ppdcon, BOOL fRequireAccess)
{
	HRESULT hr, hrT;
    char sz[256];
    DWORD cch;
    ULARGE_INTEGER luBoxId;
    ULARGE_INTEGER luConnectNonce;

	if(!ppdcon)
		return E_INVALIDARG;

    hr = HrOpenConnectionCore(psci, ppdcon);
    if(FAILED(hr))
        return hr;

    cch = sizeof sz;
	hr = DmReceiveStatusResponse(*ppdcon, sz, &cch);
	if(FAILED(hr)) {
		DmCloseConnection(*ppdcon);
		return hr;
	}

    /* If this box has security enabled, we need to handshake */
    if(FGetQwordParam(sz, "BOXID", &luBoxId) &&
        FGetQwordParam(sz, "NONCE", &luConnectNonce))
    {
        hrT = HrAuthenticateUser(*ppdcon, &luBoxId, &luConnectNonce);
        if(fRequireAccess)
            hr = hrT;
        if(FAILED(hr)) {
            DmCloseConnection(*ppdcon);
            return hr;
        }
    }

	return XBDM_NOERR;
}

HRESULT HrOpenNonprivilegedConnection(SCI *psci, PDM_CONNECTION *ppdcon)
{
	HRESULT hr;

	if(!ppdcon)
		return E_INVALIDARG;

    hr = HrOpenConnectionCore(psci, ppdcon);
    if(FAILED(hr))
        return hr;

	hr = DmReceiveStatusResponse(*ppdcon, NULL, 0);
	if(FAILED(hr))
		DmCloseConnection(*ppdcon);

    return hr;
}

HRESULT HrOpenSecureConnection(SCI *psci, PDM_CONNECTION *ppdcon, LPCSTR szPasswd)
{
    PDM_CONNECTION pdcon;
    HRESULT hr;
    char sz[256];
    DWORD cch;
    ULARGE_INTEGER luBoxId;
    ULARGE_INTEGER luConnectNonce;
    ULARGE_INTEGER luResponse;
    ULARGE_INTEGER luPasswd;

    if(!ppdcon) {
        /* We're being asked to open a secure shared connection.  If the
         * shared connection is already secure, then we'll just use it; if
         * not, we get ready to open it */
        EnterCriticalSection(&psci->csSharedConn);
        if(psci->fSecureConnection) {
            hr = XBDM_NOERR;
            goto errorwithoutconn;
        }
        if(!psci->fAllowSharing) {
            hr = E_INVALIDARG;
            goto errorwithoutconn;
        }
        if(psci->pdconShared) {
            if(psci->tidShared) {
                /* The shared connection is presently in use.  We'll leave it
                 * open but mark it nonshared */
                psci->tidShared = 0;
            } else {
                /* The shared connection is not presently in use, so we can
                 * close it */
                DmCloseConnection(psci->pdconShared);
            }
            psci->pdconShared = NULL;
        }
    }

    hr = HrOpenConnectionCore(psci, &pdcon);
    if(FAILED(hr))
        goto errorwithoutconn;

    cch = sizeof sz;
	hr = DmReceiveStatusResponse(pdcon, sz, &cch);
	if(FAILED(hr)) {
error:
		DmCloseConnection(pdcon);
errorwithoutconn:
        if(!ppdcon)
            LeaveCriticalSection(&psci->csSharedConn);
		return hr;
	}

    /* If this box has security enabled, we need to send the admin passwd */
    if(FGetQwordParam(sz, "BOXID", &luBoxId) &&
        FGetQwordParam(sz, "NONCE", &luConnectNonce))
    {
        /* Figure out the password */
        luPasswd.QuadPart = 0;
        XBCHashData(&luPasswd, szPasswd, strlen(szPasswd));

        /* Calculate the response */
        XBCCross(&luPasswd, &luConnectNonce, &luResponse);

        /* See if we can authenticate */
        sprintf(sz, "AUTHUSER ADMIN RESP=0q%08x%08x", luResponse.HighPart,
            luResponse.LowPart);
        hr = DmSendCommand(pdcon, sz, NULL, 0);
        if(FAILED(hr))
            goto error;
    }

    /* We now have our secure connection.  If this is supposed to be the
     * shared connection, we mark it shared */
    if(!ppdcon) {
        psci->pdconShared = pdcon;
        psci->fSecureConnection = TRUE;
        LeaveCriticalSection(&psci->csSharedConn);
    }

    return XBDM_NOERR;
}

HRESULT HrGetAltAddress(SCI *psci, LPDWORD lpdw)
{
    PDM_CONNECTION s;
    HRESULT hr;
    char sz[64];
    DWORD cch;

    hr = HrDoOpenSharedConnection(psci, &s);
    if(FAILED(hr))
        return hr;
    cch = sizeof sz;
    hr = DmSendCommand(s, "ALTADDR", sz, &cch);
    if(hr == XBDM_NOERR) {
        if(!FGetDwParam(sz, "addr", lpdw))
            hr = XBDM_UNDEFINED;
    } else if(SUCCEEDED(hr)) {
        TerminateConnection(s);
        hr = E_UNEXPECTED;
    }
    DoCloseSharedConnection(psci, s);
    return hr;
}

HRESULT DmOpenConnection(PDM_CONNECTION *ppdcon)
{
    return HrOpenConnection(&g_sci, ppdcon, TRUE);
}

HRESULT DmOpenSecureConnection(PDM_CONNECTION *ppdcon, LPCSTR szPasswd)
{
    return HrOpenSecureConnection(&g_sci, ppdcon, szPasswd);
}

HRESULT DmCloseConnection(PDM_CONNECTION pdcon)
{
	if(!pdcon)
		return E_INVALIDARG;

	if(pdcon->s != INVALID_SOCKET) {
		DmSendBinary(pdcon, "BYE\015\012", 5);
		closesocket(pdcon->s);
	}
	LocalFree(pdcon);
	return XBDM_NOERR;
}

void TerminateConnection(PDM_CONNECTION s)
{
    closesocket(s->s);
    s->s = INVALID_SOCKET;
}

HRESULT HrDoOpenSharedConnection(SCI *psci, PDM_CONNECTION *ppdcon)
{
	HRESULT hr;
	BOOL fCanShare = FALSE;

	*ppdcon = NULL;
	if(psci->fAllowSharing) {
		EnterCriticalSection(&psci->csSharedConn);
		/* In order to successfully share, the shared connection can't
		 * be in use */
        if(psci->pdconShared && psci->pdconShared->s == INVALID_SOCKET) {
			/* Stale connection; get rid of it */
			DmCloseConnection(psci->pdconShared);
            psci->pdconShared = NULL;
        }
		if(psci->pdconShared == NULL) {
			/* No current connection, so we'll open one */
			fCanShare = TRUE;
			hr = HrOpenConnection(psci, &psci->pdconShared, FALSE);
			if(FAILED(hr))
				psci->pdconShared = NULL;
		} else if(psci->tidShared == 0) {
			fCanShare = TRUE;
			hr = XBDM_NOERR;
		}
		if(fCanShare && psci->pdconShared) {
			psci->tidShared = GetCurrentThreadId();
			*ppdcon = psci->pdconShared;
		}
		LeaveCriticalSection(&psci->csSharedConn);
	}

	if(!fCanShare)
		hr = HrOpenConnection(psci, ppdcon, FALSE);
	return hr;
}

void DoCloseSharedConnection(SCI *psci, PDM_CONNECTION pdcon)
{
	/* We want to close this connection if it's not the shared connection, or
	 * if we're going to disallow sharing.  If it is the shared connection,
	 * we'll just mark it not in use */

	EnterCriticalSection(&psci->csSharedConn);
	if(!pdcon) {
		/* The shared connection is toast, so we're going to get rid of it.
         * If it's in use, we'll orphan it; if not, we'll just close it */
		HrUseSharedConnection(psci, FALSE);
		HrUseSharedConnection(psci, TRUE);

        /* The cached IP address is potentially invalid now, so flush it */
        psci->ulXboxIPAddr = 0;
	} else if(pdcon == psci->pdconShared) {
		if(psci->fAllowSharing)
			pdcon = NULL;
		else
			psci->pdconShared = NULL;
		psci->tidShared = 0;
	}
	LeaveCriticalSection(&psci->csSharedConn);

	if(pdcon)
		DmCloseConnection(pdcon);
}

void CloseThreadConnection(void)
{
    // BUGBUG -- should find all potential SCIs
	if(GetCurrentThreadId() == g_sci.tidShared)
		CloseSharedConnection(g_sci.pdconShared);
}

HRESULT DmDedicateConnection(PDM_CONNECTION pdcon, LPCSTR szHandler)
{
	char sz[256];
	LPCSTR psz;

	if(szHandler) {
		sprintf(sz, "DEDICATE HANDLER=%s", szHandler);
		psz = sz;
	} else
		psz = "DEDICATE GLOBAL";
	return DmSendCommand(pdcon, psz, NULL, NULL);
}

HRESULT DmSendBinary(PDM_CONNECTION pdcon, LPCVOID pv, DWORD cb)
{
	int cbT;
    int err;
    struct timeval tv;
    struct fd_set fds;

	if (!pdcon || !pv)
		return E_INVALIDARG;

    /* Because calls to send require only room in the send buffer but not
     * an actual acknowledgement, we don't need to observe the standard
     * timeout.  However, we could be in a situation where the box is gone
     * and the send buffer is full.  In that case, the socket will time out
     * and reset inside of winsock.  We'll wait arbitrarily long for the
     * send to complete, but we'll wait in one-second increments so we can
     * properly detect a dead socket */

    if(pdcon->s == INVALID_SOCKET)
        return XBDM_CONNECTIONLOST;
    tv.tv_sec = 1;
    tv.tv_usec = 0;
	while(cb) {
		cbT = send(pdcon->s, pv, cb, 0);
		if(cbT <= 0) {
            err = WSAGetLastError();
			if(err == WSAEINTR)
				continue;
            else if(err == WSAEWOULDBLOCK) {
                FD_ZERO(&fds);
                FD_SET(pdcon->s, &fds);
                if(select(0, NULL, &fds, NULL, NULL) >= 0)
                    continue;
            }
			/* Connection lost */
            break;
		}
		pv = (LPCVOID)((BYTE*)pv + cbT);
		cb -= cbT;
	}
    if(cb) {
		/* Connection lost */
		if(pdcon->s != INVALID_SOCKET)
            TerminateConnection(pdcon);
		return XBDM_CONNECTIONLOST;
    }
	return XBDM_NOERR;
}

int CbReceiveBinary(PDM_CONNECTION pdcon, LPVOID pv, DWORD cb)
{
	int cbT;
    int err;
    struct timeval tv, *ptv;
    struct fd_set fds;

    /* Try to receive data */
    cbT = recv(pdcon->s, pv, cb, 0);

    /* If we got good data, send it back */
    if(cbT > 0)
        return cbT;

    /* Figure out what went wrong */
    err = WSAGetLastError();

    /* If we were interrupt, we won't consider it to be fatal */
    if(err == WSAEINTR)
        return 0;

    if(err == WSAEWOULDBLOCK) {
        /* No data yet, so wait for it */
        FD_ZERO(&fds);
        FD_SET(pdcon->s, &fds);
        if(pdcon->psci && pdcon->psci->dwConversationTimeout) {
            ptv = &tv;
            ptv->tv_sec = pdcon->psci->dwConversationTimeout / 1000;
            ptv->tv_usec = (pdcon->psci->dwConversationTimeout % 1000) * 1000;
        } else
            ptv = NULL;
        if(select(0, &fds, NULL, NULL, ptv) > 0)
            /* Data is ready */
            return 0;
    }

    /* Connection lost */
    TerminateConnection(pdcon);
    return -1;
}

HRESULT DmReceiveBinary(PDM_CONNECTION pdcon, LPVOID pv, DWORD cb, LPDWORD pcbRet)
{
	DWORD cbRet = 0;
	int cbT;
    int err;
    struct timeval tv;
    struct fd_set fds;

	if (!pdcon || !pv)
		return E_INVALIDARG;

    if(pdcon->s == INVALID_SOCKET)
        return XBDM_CONNECTIONLOST;
	if(cb) {
		/* Suck data from the buffer first */
		cbT = pdcon->cbBuf - pdcon->ibBuf;
		if((DWORD)cbT > cb)
			cbT = cb;
		if(cbT) {
			memcpy(pv, pdcon->rgbBuf + pdcon->ibBuf, cbT);
			pdcon->ibBuf += cbT;
			pv = (LPVOID)((BYTE *)pv + cbT);
			cbRet += cbT;
			cb -= cbT;
		}
		while(cb) {
			cbT = CbReceiveBinary(pdcon, pv, cb);
			if(cbT < 0)
                break;
			pv = (LPVOID)((BYTE*)pv + cbT);
			cbRet += cbT;
			cb -= cbT;
		}
	}

	if(pcbRet)
		*pcbRet = cbRet;
	return cb ? XBDM_CONNECTIONLOST : XBDM_NOERR;
}

HRESULT DmSendCommand(PDM_CONNECTION pdcon, LPCSTR szCommand, LPSTR szResult,
	LPDWORD pcchResult)
{
	int i;
	DWORD cch;
	HRESULT hr;
	char szT[512];
	BOOL fShared = !pdcon;

	if(szResult && !pcchResult)
		return E_INVALIDARG;

	if(fShared) {
		/* Let's see if we can find a shared connection */
		hr = HrOpenSharedConnection(&pdcon);
		if(FAILED(hr))
			return hr;
	}

    if(!pdcon)
		return XBDM_CONNECTIONLOST;

    if(!szCommand) {
        /* We just wanted to tickle the shared connection */
        if(fShared)
            CloseSharedConnection(pdcon);
        return XBDM_NOERR;
    }

	cch = strlen(szCommand);
	if(cch + 3 < sizeof szT) {
		/* Send the line + crlf in one packet */
		memcpy(szT, szCommand, cch);
		szT[cch] = '\015';
		szT[cch+1] = '\012';
		hr = DmSendBinary(pdcon, szT, cch + 2);
	} else {
		hr = DmSendBinary(pdcon, szCommand, cch);
		if(SUCCEEDED(hr))
			hr = DmSendBinary(pdcon, "\015\012", 2);
	}

	if(SUCCEEDED(hr))
		hr = DmReceiveStatusResponse(pdcon, szResult, pcchResult);

	if(fShared)
		CloseSharedConnection(pdcon);
	return hr;
}

HRESULT DmReceiveStatusResponse(PDM_CONNECTION pdcon, LPSTR sz, LPDWORD pcch)
{
	char szBuf[256];
	int cch;
	HRESULT hr;

	if(sz && !pcch)
		return E_INVALIDARG;

	if(!sz) {
		sz = szBuf;
		cch = sizeof szBuf;
		pcch = &cch;
	}

	hr = DmReceiveSocketLine(pdcon, sz, pcch);
	if(FAILED(hr))
		return hr;

	/* Now we have a three-digit result code.  We'll return an HRESULT with the
	 * three digits of the code (decimal) as the code portion, and we'll
	 * indicate an error if it's an error code */
 	return HrFromStatus(sz);
}

HRESULT DmReceiveSocketLine(PDM_CONNECTION pdcon, LPSTR szResult, LPDWORD pcch)
{
	char ch;
	int cch;

	if (!szResult || !pcch || *pcch == 0 || !pdcon)
		return E_INVALIDARG;

	cch = *pcch - 1;

	/* We can only receive one line, so we'll process a byte at a time and
	 * stop at CRLF.  To be safe, we'll stop at LF and ignore CR */
	do {
		/* Make sure we have some data */
		while(pdcon->ibBuf >= pdcon->cbBuf) {
			pdcon->ibBuf = 0;
			pdcon->cbBuf = CbReceiveBinary(pdcon, pdcon->rgbBuf,
                sizeof pdcon->rgbBuf);
            if((int)pdcon->cbBuf < 0)
				return XBDM_CONNECTIONLOST;
		}
		ch = pdcon->rgbBuf[pdcon->ibBuf++];
		if(ch == '\015')
			continue;
		if(ch != '\012' && cch) {
			*szResult++ = ch;
			--cch;
		}
	} while(ch != '\012');
	*szResult = 0;
	*pcch -= cch + 1;
	return XBDM_NOERR;
}

HRESULT DmReceiveBinaryDataSize(PDM_CONNECTION pdcon, LPDWORD pcb)
{
    if (!pdcon || !pcb)
        return E_INVALIDARG;

	return DmReceiveBinary(pdcon, pcb, sizeof *pcb, NULL);
}

#if 0
BOOL FGetLineData(LPCSTR sz, LPCSTR szKey, const char **ppchData)
{
	int cch = strlen(szKey);

	if(_strnicmp(sz, szKey, cch))
		return FALSE;
	if(sz[cch] == '=') {
		if(ppchData)
			*ppchData = sz + cch;
		return TRUE;
	}
	if(sz[cch] == 0) {
		if(ppchData)
			*ppchData = NULL;
		return TRUE;
	}
	return FALSE;
}
#endif

__inline BOOL FIsSpace(char ch)
{
	return !ch || isspace(ch);
}

const char *PchGetParam(LPCSTR szCmd, LPCSTR szKey, BOOL fNeedValue,
	BOOL fNoCommand)
{
	const char *pchTok;
	int cchTok;
	BOOL fQuote = FALSE;

	/* Skip the command, unless there isn't one */
	pchTok = szCmd;
	if(!fNoCommand)
		while(!FIsSpace(*pchTok))
			++pchTok;

	while(*pchTok) {
		/* Skip leading spaces */
		while(*pchTok && FIsSpace(*pchTok))
			++pchTok;
		if(!*pchTok)
			return NULL;
        for(cchTok = 0; !FIsSpace(pchTok[cchTok]); ++cchTok) {
            if(pchTok[cchTok] == '=') {
                if(!_strnicmp(szKey, pchTok, cchTok))
				    return pchTok + cchTok + 1; /* Skip the '=' */
                break;
            }
        }
		/* If we didn't see the '=' we need to check anyway */
		if(!fNeedValue && pchTok[cchTok] != '=' && !_strnicmp(szKey, pchTok,
                cchTok) && !szKey[cchTok])
			return pchTok + cchTok;
		/* No match, so we need to skip past the value */
		pchTok += cchTok;
		while(*pchTok && (!FIsSpace(*pchTok) || fQuote))
			if(*pchTok++ == '"')
				fQuote = !fQuote;
	}
	return NULL;
}

BOOL FGetSzParam(LPCSTR szLine, LPCSTR szKey, LPSTR szBuf)
{
	BOOL fQuote;
	LPCSTR pch = PchGetParam(szLine, szKey, TRUE, TRUE);

	if(!pch)
		return FALSE;
	fQuote = FALSE;
	while(*pch && (fQuote || !isspace(*pch))) {
		if(*pch == '"') {
			fQuote = !fQuote;
			++pch;
		} else
			*szBuf++ = *pch++;
	}
	*szBuf = 0;
	return TRUE;
}

BOOL FGetDwParamFromSz(LPCSTR sz, DWORD *pdw)
{
	if(!sz)
		return FALSE;
	if(sz[0] == '0') {
		if(sz[1] == 'x') {
			sscanf(sz+2, "%x", pdw);
			return TRUE;
		}
		/* Don't support octal for now */
		return FALSE;
	}
	*pdw = atoi(sz);
	return TRUE;
}

BOOL FGetQwordParam(LPCSTR szLine, LPCSTR szKey, ULARGE_INTEGER *plu)
{
    int cch;
    char sz[32];
    LPCSTR pch;

    if(!FGetSzParam(szLine, szKey, sz))
        return FALSE;
    sz[sizeof sz - 1] = 0;

    /* Verify the 0q prefix */
    if(sz[0] != '0' || sz[1] != 'q')
        return FALSE;
    /* Make sure we have a bunch of hex characters */
    for(cch = 2; cch < sizeof sz && !FIsSpace(sz[cch]); ++cch) {
        if(!(sz[cch] >= '0' && sz[cch] <= '9' ||
                sz[cch] >= 'A' && sz[cch] <= 'F' ||
                sz[cch] >= 'a' && sz[cch] <= 'f'))
            return FALSE;
    }
    cch -= 2;
    if(cch <= 0)
        return FALSE;

    /* Move the text out to the end of the string and fill the preceding
     * characters with zeroes */
    memmove(&sz[sizeof sz - 1 - cch], &sz[2], cch);
    memset(sz, '0', sizeof sz - 1 - cch);

    /* Now parse out the two dwords */
    sscanf(&sz[sizeof sz - 9], "%x", &plu->LowPart);
    sz[sizeof sz - 9] = 0;
    sscanf(&sz[sizeof sz - 17], "%x", &plu->HighPart);
    return TRUE;
}

#ifndef XBDBGS  // DmTranslateError is not available in the static version of the lib
HRESULT DmTranslateErrorA(HRESULT hr, LPSTR lpBuffer, int nBufferMax)
{
    UINT    resourceId;
    int     len;
    HRESULT hrRes = XBDM_NOERR;

    //Parameter check.
    if( (!lpBuffer) || (nBufferMax <= 0))
    {
        return E_INVALIDARG;
    }

    //Get the resource ID
    resourceId = FGetErrorStringResourceId(hr);
    if(0==resourceId) 
    {
        hrRes = XBDM_NOERRORSTRING;
        resourceId = IDC_XBDM_NOERRORSTRING;
    }

    //Load the string
    len = LoadStringA(hXboxdbg, resourceId, lpBuffer, nBufferMax);
    if(0==len)
    {
        hrRes = HRESULT_FROM_WIN32(GetLastError());
    }
    return hrRes;
}

HRESULT DmTranslateErrorW(HRESULT hr, LPWSTR lpBuffer, int nBufferMax)
{
    UINT    resourceId;
    int     len;
    HRESULT hrRes = S_OK;

    //Parameter check.
    if( (!lpBuffer) || (nBufferMax <= 0))
    {
        return E_INVALIDARG;
    }
    
    //Get the resource ID    
    resourceId = FGetErrorStringResourceId(hr);
    if(0==resourceId) 
    {
        hrRes = XBDM_NOERRORSTRING;
        resourceId = IDC_XBDM_NOERRORSTRING;
    }

    //Load the string
    len = LoadStringW(hXboxdbg, resourceId, lpBuffer, nBufferMax);
    if(0==len)
    {
        hrRes = HRESULT_FROM_WIN32(GetLastError());
    }
    return hrRes;
}

UINT FGetErrorStringResourceId(HRESULT hr)
{
	switch(hr) {
	case E_FAIL:
	case E_UNEXPECTED:
		return IDC_E_UNEXPECTED;
	case E_INVALIDARG:
		return IDC_E_INVALIDARG;
    default:
        if(FAILED(hr) && HRESULT_FACILITY(hr) == FACILITY_XBDM)
            return 0x8000 | (hr & 0xfff);
        break;
	}
    return 0;
}
#endif //XBDBGS

HRESULT HrDoOneLineCmd(PDM_CONNECTION s, LPCSTR sz)
{
	HRESULT hr;

	hr = DmSendCommand(s, sz, NULL, 0);
	if(hr == XBDM_READYFORBIN || hr == XBDM_MULTIRESPONSE ||
		hr == XBDM_BINRESPONSE)
	{
		TerminateConnection(s);
		hr = E_UNEXPECTED;
	}
	return hr;
}

HRESULT HrOneLineCmd(LPCSTR sz)
{
	PDM_CONNECTION s;
	HRESULT hr;

	hr = HrOpenSharedConnection(&s);
    if(SUCCEEDED(hr)) {
        hr = HrDoOneLineCmd(s, sz);
    	CloseSharedConnection(s);
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xboxdbg\secure.c ===
/*
 *
 * secure.c
 *
 * Connection security functions
 *
 */

#include "precomp.h"
#include <benaloh.h>

static UCHAR g_rgbOakleyGroup1Base[] =
{
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02
};

static UCHAR g_rgbOakleyGroup1Mod[] =
{
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xc9, 0x0f, 0xda, 0xa2, 0x21, 0x68, 0xc2, 0x34,
    0xc4, 0xc6, 0x62, 0x8b, 0x80, 0xdc, 0x1c, 0xd1,
    0x29, 0x02, 0x4e, 0x08, 0x8a, 0x67, 0xcc, 0x74,
    0x02, 0x0b, 0xbe, 0xa6, 0x3b, 0x13, 0x9b, 0x22,
    0x51, 0x4a, 0x08, 0x79, 0x8e, 0x34, 0x04, 0xdd,
    0xef, 0x95, 0x19, 0xb3, 0xcd, 0x3a, 0x43, 0x1b,
    0x30, 0x2b, 0x0a, 0x6d, 0xf2, 0x5f, 0x14, 0x37,
    0x4f, 0xe1, 0x35, 0x6d, 0x6d, 0x51, 0xc2, 0x45,
    0xe4, 0x85, 0xb5, 0x76, 0x62, 0x5e, 0x7e, 0xc6,
    0xf4, 0x4c, 0x42, 0xe9, 0xa6, 0x3a, 0x36, 0x20,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};

static ULONG rgN[8] = {
    0x283C481D,
    0x9AD82AA1,
    0x85A5E1F9,
    0x1B23963C,
    0xF70B4975,
    0xDFDC02C7,
    0xF29176FC,
    0x6B04BD38
};

void XBCEncryptCore(PULARGE_INTEGER pluKey, PULARGE_INTEGER pluBlock)
{
    int i;

    for(i = 0; i < 8; ++i) { 
        pluBlock->LowPart ^= (pluBlock->HighPart >> 5) + rgN[i] +
            (~pluBlock->HighPart << 6) + (pluBlock->HighPart ^ pluKey->LowPart);
        pluBlock->HighPart ^= (~pluBlock->LowPart >> 5) + rgN[7-i] +
            (pluBlock->LowPart << 6) + (pluBlock->LowPart ^ pluKey->HighPart);
    }
}

void XBCDecryptCore(PULARGE_INTEGER pluKey, PULARGE_INTEGER pluBlock)
{
    int i;

    for(i = 0; i < 8; ++i) { 
        pluBlock->HighPart ^= (~pluBlock->LowPart >> 5) + rgN[i] +
            (pluBlock->LowPart << 6) + (pluBlock->LowPart ^ pluKey->HighPart);
        pluBlock->LowPart ^= (pluBlock->HighPart >> 5) + rgN[7-i] +
            (~pluBlock->HighPart << 6) + (pluBlock->HighPart ^ pluKey->LowPart);
    }
}

void XBCHashBlock(PULARGE_INTEGER pluHash, PULARGE_INTEGER pluData)
{
    /* We don't use Davies-Meyer directly, we use an analogous formula:
     *   H(i) = E(H(i-1),M(i)) X M(i)
     */
    ULARGE_INTEGER luTemp;

    luTemp = *pluData;
    XBCEncryptCore(pluHash, &luTemp);
    pluHash->LowPart = pluData->LowPart ^ luTemp.LowPart;
    pluHash->HighPart = pluData->HighPart ^ luTemp.HighPart;
}

void XBCHashData(PULARGE_INTEGER pluHash, const BYTE *pb, ULONG cb)
{
    ULARGE_INTEGER lu;

    /* Process the 8-byte chunks first */
    while(cb >= 8) {
        memcpy(&lu, pb, 8);
        pb += 8;
        cb -= 8;
        XBCHashBlock(pluHash, &lu);
    }
    if(cb) {
        memset(&lu, 0, sizeof lu);
        memcpy(&lu, pb, cb);
        XBCHashBlock(pluHash, &lu);
    }
}

void XBCCross(PULARGE_INTEGER pluKey, PULARGE_INTEGER pluData,
    PULARGE_INTEGER pluResult)
{
    ULARGE_INTEGER luTemp;

    /* Compute H(K, H(K, M)) where K is the key and M is the data */
    pluResult->QuadPart = 0x2718281831415926;
    XBCHashBlock(pluResult, pluKey);
    luTemp = *pluResult;
    XBCHashBlock(&luTemp, pluData);
    XBCHashBlock(pluResult, &luTemp);
}

HRESULT HrSetupKeyExchange(PDM_CONNECTION pdcon, PULARGE_INTEGER pluKey)
{
    int i;
    HRESULT hr;
    DWORD cb;
    PULARGE_INTEGER plu;
    BYTE rgbDH[96];
    BYTE rgbX[96];
    BYTE rgbGY[96];
    char szCmd[256];

    // Send the KEYXCHG command to start DH
    hr = DmSendCommand(pdcon, "KEYXCHG", NULL, NULL);
    if(hr != XBDM_READYFORBIN) {
        if(SUCCEEDED(hr)) {
            TerminateConnection(pdcon);
            hr = E_UNEXPECTED;
        }
        return hr;
    }

    /* Perform Diffie-Hellman key exchange.  We make up a random number
     * X and send g^X to the Xbox.  We receive g^Y and use that to compute
     * g^XY.  The hash of that key is what we use as our key-exchange key.
     * The random number X is the current system time, repeatedly hashed into
     * the rdtsc value, xor'ed with whatever junk was in rgbX to start with */
    GetSystemTimeAsFileTime((PFILETIME)rgbX);
    for(i = 1; i < 96/8; ++i) {
        plu = (PULARGE_INTEGER)rgbX + i;
        _asm {
            mov ecx, plu
            rdtsc
            xor [ecx], eax
            xor [ecx+4], edx
        }
        XBCHashBlock(plu, plu - 1);
    }
    BenalohModExp((PULONG)rgbDH, (PULONG)g_rgbOakleyGroup1Base,
        (PULONG)rgbX, (PULONG)g_rgbOakleyGroup1Mod, 96/4);
    hr = DmSendBinary(pdcon, rgbDH, sizeof rgbDH);
    if(FAILED(hr)) {
Failure:
        TerminateConnection(pdcon);
        return hr;
    }
    cb = sizeof szCmd;
    hr = DmReceiveStatusResponse(pdcon, szCmd, &cb);
    if(hr != XBDM_BINRESPONSE) {
        hr = E_UNEXPECTED;
        goto Failure;
    }
    hr = DmReceiveBinary(pdcon, rgbGY, sizeof rgbGY, &cb);
    if(FAILED(hr))
        goto Failure;
    BenalohModExp((PULONG)rgbDH, (PULONG)rgbGY, (PULONG)rgbX,
        (PULONG)g_rgbOakleyGroup1Mod, 96/4);
    pluKey->QuadPart = 0;
    XBCHashData(pluKey, rgbDH, sizeof rgbDH);

    return XBDM_NOERR;
}

HRESULT HrAuthenticateUser(PDM_CONNECTION pdcon, PULARGE_INTEGER pluBoxId,
    PULARGE_INTEGER pluConnectNonce)
{
    int i;
    HRESULT hr;
    HKEY h;
    DWORD reg;
    DWORD cb;
    PULARGE_INTEGER plu;
    ULARGE_INTEGER luSeed;
    ULARGE_INTEGER luPasswd;
    ULARGE_INTEGER luResp;
    ULARGE_INTEGER luDH;
    struct sockaddr_in sin;
    char szName[MAX_COMPUTERNAME_LENGTH+1];
    char szCmd[MAX_COMPUTERNAME_LENGTH+64];

    pdcon->fAuthenticationAttempted = TRUE;

    /* Make sure we have a name */
    cb = sizeof szName;
    if(!GetComputerName(szName, &cb))
        return E_OUTOFMEMORY;

    /* See if we can find our passwd seed */
	if(ERROR_SUCCESS != RegCreateKeyEx(HKEY_LOCAL_MACHINE,
            "Software\\Microsoft\\XboxSDK", 0, NULL, 0, KEY_QUERY_VALUE |
            KEY_SET_VALUE, NULL, &h, NULL))
        return E_OUTOFMEMORY;
    cb = sizeof luSeed;
    if(ERROR_SUCCESS != RegQueryValueEx(h, "SecuritySeed", NULL, &reg,
        (PBYTE)&luSeed, &cb) || reg != REG_BINARY)
    {
        /* Either the data was missing or it wasn't what we want.  We'll make
         * up a new number */
        _asm {
            lea ecx, luSeed
            rdtsc
            mov [ecx], eax
            mov [ecx+4], edx
        }
        cb = sizeof sin;
        getsockname(pdcon->s, (struct sockaddr *)&sin, (int *)&cb);
        XBCHashData(&luSeed, (PBYTE)&sin, sizeof sin);
        if(ERROR_SUCCESS != RegSetValueEx(h, "SecuritySeed", 0, REG_BINARY,
            (PBYTE)&luSeed, sizeof luSeed))
        {
            RegCloseKey(h);
            return E_OUTOFMEMORY;
        }
    }

    /* Compute the password we want to use */
    XBCCross(&luSeed, pluBoxId, &luPasswd);

    /* Compute the response we're supposed to send */
    XBCCross(&luPasswd, pluConnectNonce, &luResp);

    /* First attempt: authenticate normally, using response */
    sprintf(szCmd, "AUTHUSER NAME=\"%s\" RESP=0q%08x%08x", szName,
        luResp.HighPart, luResp.LowPart);
    cb = sizeof szCmd;
    hr = DmSendCommand(pdcon, szCmd, szCmd, &cb);
    if(hr != XBDM_KEYXCHG)
        /* Either we've succeeded or failed at this point, so we can just
         * return */
        return hr;

    /* We're authenticatable, but haven't sent a password yet.  We DH key
     * exchange and then send the password over */
    hr = HrSetupKeyExchange(pdcon, &luDH);

    /* Now send the password */
    luPasswd.LowPart ^= luDH.LowPart;
    luPasswd.HighPart ^= luDH.HighPart;
    sprintf(szCmd, "AUTHUSER NAME=\"%s\" PASSWD=0q%08x%08x", szName,
        luPasswd.HighPart, luPasswd.LowPart);
    cb = sizeof szCmd;
    hr = DmSendCommand(pdcon, szCmd, szCmd, &cb);
    pdcon->fAuthenticated = SUCCEEDED(hr);

    /* That's all we can do */
    return hr;
}

DWORD DmplFromSz(LPCSTR sz)
{
    ULONG dmpl = 0;

    if(PchGetParam(sz, "read", FALSE, TRUE))
        dmpl |= DMPL_PRIV_READ;
    if(PchGetParam(sz, "write", FALSE, TRUE))
        dmpl |= DMPL_PRIV_WRITE;
    if(PchGetParam(sz, "control", FALSE, TRUE))
        dmpl |= DMPL_PRIV_CONTROL;
    if(PchGetParam(sz, "config", FALSE, TRUE))
        dmpl |= DMPL_PRIV_CONFIGURE;
    if(PchGetParam(sz, "manage", FALSE, TRUE))
        dmpl |= DMPL_PRIV_MANAGE;

    return dmpl;
}

void FillAccessPrivSz(LPSTR sz, DWORD dwPriv)
{
    LPSTR szOrig = sz;

    if(dwPriv & DMPL_PRIV_READ) {
        strcpy(sz, " read");
        sz += 5;
    }
    if(dwPriv & DMPL_PRIV_WRITE) {
        strcpy(sz, " write");
        sz += 6;
    }
    if(dwPriv & DMPL_PRIV_CONTROL) {
        strcpy(sz, " control");
        sz += 8;
    }
    if(dwPriv & DMPL_PRIV_CONFIGURE) {
        strcpy(sz, " config");
        sz += 7;
    }
    if(dwPriv & DMPL_PRIV_MANAGE) {
        strcpy(sz, " manage");
        sz += 7;
    }
    *sz = 0;
}

HRESULT HrSetUserAccess(PDM_CONNECTION s, LPCSTR szUserName, DWORD dwAccess)
{
    char sz[1024];

    if(!szUserName)
        return E_INVALIDARG;

    sprintf(sz, "SETUSERPRIV NAME=\"%s\"", szUserName);
    FillAccessPrivSz(sz + strlen(sz), dwAccess);
    return HrDoOneLineCmd(s, sz);
}

HRESULT HrGetUserAccess(PDM_CONNECTION s, LPCSTR szUserName, LPDWORD lpdwAccess)
{
    char sz[1024];
    HRESULT hr;
    DWORD cch;
    LPCSTR psz;

    if(!lpdwAccess)
        return E_INVALIDARG;
    if(szUserName) {
        sprintf(sz, "GETUSERPRIV NAME=\"%s\"", szUserName);
        psz = sz;
    } else
        psz = "GETUSERPRIV ME";
    cch = sizeof sz;
    hr = DmSendCommand(s, psz, sz, &cch);
    if(SUCCEEDED(hr))
        *lpdwAccess = DmplFromSz(sz + 5);
    return hr;
}

HRESULT HrAddUser(PDM_CONNECTION s, LPCSTR szUserName, DWORD dwAccess)
{
    char sz[1024];
    HRESULT hr;

    if(!szUserName)
        return E_INVALIDARG;
    sprintf(sz, "USER NAME=\"%s\"", szUserName);
    FillAccessPrivSz(sz + strlen(sz), dwAccess);
    return HrDoOneLineCmd(s, sz);
}

HRESULT HrRemoveUser(PDM_CONNECTION s, LPCSTR szUserName)
{
    char sz[1024];
    HRESULT hr;

    if(!szUserName)
        return E_INVALIDARG;
    sprintf(sz, "USER NAME=\"%s\" REMOVE", szUserName);
    return HrDoOneLineCmd(s, sz);
}


HRESULT HrOpenUserList(SCI *psci, PDM_WALK_USERS *ppdmwu, LPDWORD lpdw)
{
    PDM_CONNECTION s;
    HRESULT hr;
    char sz[1024];
    struct _DM_WALKUSER *pwu, **ppwu;
    DWORD cch;
    DWORD c;

    if(!ppdmwu)
        return E_INVALIDARG;

    hr = HrDoOpenSharedConnection(psci, &s);
    if(FAILED(hr))
        return hr;
    hr = DmSendCommand(s, "USERLIST", NULL, 0);
    if(hr != XBDM_MULTIRESPONSE) {
        if(SUCCEEDED(hr)) {
            hr = E_UNEXPECTED;
fatal:
            TerminateConnection(s);
        }
        DoCloseSharedConnection(psci, s);
        return hr;
    }
    *ppdmwu = LocalAlloc(LMEM_FIXED, sizeof(struct _DM_WALK_USERS));
    if(!*ppdmwu) {
        hr = E_OUTOFMEMORY;
        goto fatal;
    }
    ppwu = &(*ppdmwu)->pwuFirst;
    for(c = 0; ; ++c) {
        cch = sizeof sz;
        hr = DmReceiveSocketLine(s, sz, &cch);
        if(FAILED(hr) || sz[0] == '.')
            break;
        if(sz[0] == '.')
            break;
        pwu = LocalAlloc(LMEM_FIXED, sizeof *pwu);
        if(!pwu) {
            hr = E_OUTOFMEMORY;
            break;
        }
        memset(pwu, 0, sizeof *pwu);
        FGetSzParam(sz, "name", pwu->dmu.UserName);
        pwu->dmu.AccessPrivileges = DmplFromSz(sz);
        *ppwu = pwu;
        ppwu = &pwu->pwuNext;
        ++c;
    }
    *ppwu = NULL;
    if(FAILED(hr))
        goto fatal;
    DoCloseSharedConnection(psci, s);
    if(lpdw)
        *lpdw = c;
    return XBDM_NOERR;
}

HRESULT HrWalkUserList(SCI *psci, PDM_WALK_USERS *ppdmwu, PDM_USER pdusr)
{
    HRESULT hr;
    PDM_CONNECTION s;
    struct _DM_WALKUSER *pwu, **ppwu;

    if(!ppdmwu || !pdusr)
        return E_INVALIDARG;

    if(!*ppdmwu) {
        hr = HrOpenUserList(psci, ppdmwu, NULL);
        if(FAILED(hr))
            return hr;
    }

    ppwu = &(*ppdmwu)->pwuFirst;
    pwu = *ppwu;
    if(!pwu)
        return XBDM_ENDOFLIST;
    *ppwu = pwu->pwuNext;
    memcpy(pdusr, &pwu->dmu, sizeof *pdusr);
    LocalFree(pwu);

    return XBDM_NOERR;
}

HRESULT DmCloseUserList(PDM_WALK_USERS pdmwu)
{
    struct _DM_WALKUSER *pwu;

    if(pdmwu) {
        pwu = pdmwu->pwuFirst;
        if(pwu) {
            pdmwu->pwuFirst = pwu->pwuNext;
            LocalFree(pwu);
        }
        LocalFree(pdmwu);
    }
    
    return XBDM_NOERR;
}

HRESULT HrSetAdminPassword(PDM_CONNECTION s, LPCSTR szPasswd)
{
    ULARGE_INTEGER luPasswd;
    ULARGE_INTEGER luKey;
    HRESULT hr;
    char sz[256];

    if(!szPasswd) {
        /* We're removing the password */
        return HrDoOneLineCmd(s, "ADMINPW NONE");
    }

    hr = HrSetupKeyExchange(s, &luKey);
    if(SUCCEEDED(hr)) {
        luPasswd.QuadPart = 0;
        XBCHashData(&luPasswd, szPasswd, strlen(szPasswd));
        luPasswd.LowPart ^= luKey.LowPart;
        luPasswd.HighPart ^= luKey.HighPart;
        sprintf(sz, "ADMINPW PASSWD=0q%08x%08x", luPasswd.HighPart,
            luPasswd.LowPart);
        hr = HrDoOneLineCmd(s, sz);
    }

    return hr;
}

HRESULT HrIsSecurityEnabled(PDM_CONNECTION pdcon, LPBOOL pfEnabled)
{
    HRESULT hr;

    if(!pfEnabled)
        return E_INVALIDARG;

    /* We ask the box for its ID.  We don't care what the box ID actually is,
     * just whether it has one.  That will tell us whether the box is locked
     * or not, or whether the box doesn't understand the boxid concept */
    hr = DmSendCommand(pdcon, "BOXID", NULL, 0);
    if(SUCCEEDED(hr))
        *pfEnabled = TRUE;
    else {
        switch(hr) {
        case XBDM_INVALIDCMD:
            /* The box doesn't understand the command, which doesn't necessarily
             * mean that the box isn't locked.  We check the state at the time
             * this connection was established */
            *pfEnabled = pdcon->fAuthenticationAttempted;
            hr = XBDM_NOERR;
            break;
        case XBDM_NOTLOCKED:
            *pfEnabled = FALSE;
            hr = XBDM_NOERR;
            break;
        }
    }

    return hr;
}

HRESULT HrEnableSecurity(PDM_CONNECTION s, BOOL fEnable)
{
    char sz[256];
    LPCSTR psz;
    ULARGE_INTEGER luBoxId;
    struct sockaddr_in rgsin[3];
    int cb;
    FILETIME ft;
    HRESULT hr;

    if(!fEnable)
        psz = "LOCKMODE UNLOCK";
    else {
        /* We prohibit enabling of security on pre-4100 build boxes.  We
         * do this by getting the current boxid.  If the boxid command is
         * unsupported, we assume this is a pre-4100 box and we return an
         * error */
        hr = DmSendCommand(s, "BOXID", NULL, 0);
        if(XBDM_INVALIDCMD == hr)
            return hr;

        /* We need to construct a unique box id to lock this box.  We'll hash
         * our IP address, the box's IP address, and the time we did the
         * lock */
        memset(rgsin, 0, sizeof rgsin);
        cb = sizeof rgsin[0];
        getsockname(s->s, (struct sockaddr *)&rgsin[0], &cb);
        cb = sizeof rgsin[1];
        getpeername(s->s, (struct sockaddr *)&rgsin[1], &cb);
        GetSystemTimeAsFileTime(&ft);
        memset(&rgsin[0], 0, sizeof rgsin);
        memcpy(&rgsin[2], &ft, sizeof ft);
        XBCHashData(&luBoxId, (PUCHAR)rgsin, sizeof rgsin);
        sprintf(sz, "LOCKMODE BOXID=0q%08x%08x", luBoxId.HighPart,
            luBoxId.LowPart);
        psz = sz;
    }

    return DmSendCommand(s, psz, NULL, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xboxdbg\sources.inc ===
MSC_WARNING_LEVEL=/W3 /WX

INCLUDES=..;$(BASEDIR)\private\inc\crypto

SOURCES_COMMON=\
    ..\secure.c \
    ..\protocol.c\
    ..\filexfer.c\
    ..\fileapi.c\
    ..\xbconn.cpp\
    ..\threadbrk.c\
    ..\counters.c\
    ..\xbeutil.c

PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=..\precomp.pch
PRECOMPILED_OBJ=..\precomp.obj
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xboxdbg\threadbrk.c ===
/*
 *
 * threadbrk.c
 *
 * Thread and breakpoint routines
 *
 */

#include "precomp.h"

HRESULT DmGo(void)
{
	return HrOneLineCmd("GO");
}

HRESULT DmStop(void)
{
	return HrOneLineCmd("STOP");
}

HRESULT DmSetBreakpoint(PVOID addr)
{
	char sz[64];

	sprintf(sz, "BREAK ADDR=0x%08x", addr);
	return HrOneLineCmd(sz);
}

HRESULT DmRemoveBreakpoint(PVOID addr)
{
	char sz[128];

	sprintf(sz, "BREAK ADDR=0x%08x CLEAR", addr);
	return HrOneLineCmd(sz);
}

HRESULT DmIsBreakpoint(PVOID addr, LPDWORD pdwType)
{
    HRESULT hr;
    char szCmd[128];
    char szResp[128];
    DWORD cchResp;
    PDM_CONNECTION s;

    if(!pdwType)
        return E_INVALIDARG;
    hr = HrOpenSharedConnection(&s);
    if(FAILED(hr))
        return hr;
    sprintf(szCmd, "ISBREAK ADDR=0x%08x", addr);
    cchResp = sizeof szResp;
    hr = DmSendCommand(s, szCmd, szResp, &cchResp);
    if(XBDM_NOERR == hr) {
        if(!FGetDwParam(szResp, "type", pdwType))
            hr = E_UNEXPECTED;
    } else if(SUCCEEDED(hr)) {
        TerminateConnection(s);
        hr = E_UNEXPECTED;
    }
    CloseSharedConnection(s);
    return hr;
}

HRESULT DmSetDataBreakpoint(PVOID pvAddr, DWORD dwType, DWORD dwSize)
{
	char sz[128];
	LPCSTR szType;
	BOOL fClear = dwType == DMBREAK_NONE;

	if(!fClear && !(dwSize == 1 || dwSize == 2 || dwSize == 4))
		return E_INVALIDARG;

	switch(dwType) {
	case DMBREAK_NONE:
		/* For none, we just say "write" because it doesn't really matter */
	case DMBREAK_WRITE:
		szType = "WRITE";
		break;
	case DMBREAK_READWRITE:
		szType = "READ";
		break;
	case DMBREAK_EXECUTE:
		szType = "EXECUTE";
		break;
	default:
		return E_INVALIDARG;
	}

	sprintf(sz, "BREAK %s=0x%08x SIZE=%lu %s", szType, pvAddr, dwSize,
		fClear ? "CLEAR" : "");
	return HrOneLineCmd(sz);
}

typedef struct _XFLOATSAVE {
    USHORT  ControlWord;
    USHORT  StatusWord;
    USHORT  TagWord;
    USHORT  ErrorOpcode;
    ULONG   ErrorOffset;
    ULONG   ErrorSelector;
    ULONG   DataOffset;
    ULONG   DataSelector;
    ULONG   MXCsr;
    ULONG   Reserved2;
    UCHAR   RegisterArea[128];
    UCHAR   XmmRegisterArea[128];
} XFLOATSAVE, *PXFLOATSAVE;

HRESULT HrGetExtContext(PDM_CONNECTION s, DWORD tid, PXFLOATSAVE pxfs)
{
	char sz[64];
	DWORD cb;
	BYTE rgbBuf[512];
	HRESULT hr;

	sprintf(sz, "GETEXTCONTEXT THREAD=%d", tid);
	hr = DmSendCommand(s, sz, NULL, 0);
	if(FAILED(hr))
		return hr;
	hr = DmReceiveBinary(s, &cb, sizeof cb, NULL);
	if(FAILED(hr))
		return hr;
	if(cb < sizeof *pxfs) {
		DmReceiveBinary(s, pxfs, cb, NULL);
		hr = E_UNEXPECTED;
	} else {
		hr = DmReceiveBinary(s, pxfs, sizeof *pxfs, NULL);
		cb -= sizeof *pxfs;
		if(SUCCEEDED(hr)) {
			while(cb) {
				DWORD cbT = cb;
				if(cbT > sizeof rgbBuf)
					cbT = sizeof rgbBuf;
				if(FAILED(DmReceiveBinary(s, rgbBuf, cb, NULL)))
					cb = cbT;
				cb -= cbT;
			}
		}
	}
	return hr;
}

HRESULT DmGetThreadContext(DWORD tid, PCONTEXT pcr)
{
	PDM_CONNECTION s;
	HRESULT hr;
	char sz[128];
	DWORD dwFlags;
	BOOL fWantCtx = FALSE;
	BOOL fWantExtCtx = FALSE;
	XFLOATSAVE xfs;
	PXFLOATSAVE pxfs;
	DWORD dwCr0Npx;

    if (!pcr)
        return E_INVALIDARG;

	dwFlags = pcr->ContextFlags;

    if((BYTE *)&pcr->Edi - (BYTE *)pcr != 0x9c) {
		_asm int 3
	}

	pcr->ContextFlags = 0;
	hr = HrOpenSharedConnection(&s);
	if(FAILED(hr))
		return hr;
	sprintf(sz, "GETCONTEXT THREAD=%d", tid);
	if((dwFlags & CONTEXT_CONTROL) == CONTEXT_CONTROL) {
		strcat(sz, " CONTROL");
		fWantCtx = TRUE;
	}
	if((dwFlags & CONTEXT_INTEGER) == CONTEXT_INTEGER) {
		strcat(sz, " INT");
		fWantCtx = TRUE;
	}
	if((dwFlags & CONTEXT_FLOATING_POINT) == CONTEXT_FLOATING_POINT) {
		strcat(sz, " FP");
		fWantCtx = TRUE;
		fWantExtCtx = TRUE;
		pxfs = &xfs;
	}
	if((dwFlags & CONTEXT_EXTENDED_REGISTERS) == CONTEXT_EXTENDED_REGISTERS) {
		fWantExtCtx = TRUE;
		pxfs = (PXFLOATSAVE)&pcr->ExtendedRegisters;
	}
	if(fWantCtx) {
		hr = DmSendCommand(s, sz, NULL, 0);
		if(SUCCEEDED(hr) && hr != XBDM_MULTIRESPONSE) {
			TerminateConnection(s);
			hr = E_UNEXPECTED;
		}
	} else
		hr = XBDM_NOERR;
	/* Get the standard context portions */
	if(SUCCEEDED(hr) && fWantCtx) {
		for(;;) {
#define FGR(reg) FGetDwParam(sz, #reg, &pcr->reg)
			DWORD cch;
			char *pch;

			cch = sizeof sz;
			hr = DmReceiveSocketLine(s, sz, &cch);
			if(FAILED(hr) || sz[0] == '.')
				break;
			if(FGR(Esp))
				pcr->ContextFlags |= CONTEXT_CONTROL;
			FGR(Ebp);
			FGR(Eip);
			FGR(EFlags);
			if(FGR(Eax))
				pcr->ContextFlags |= CONTEXT_INTEGER;
			FGR(Ebx);
			FGR(Ecx);
			FGR(Edx);
			FGR(Esi);
			FGR(Edi);
			FGR(SegCs);
			FGR(SegSs);
			if(FGetDwParam(sz, "Cr0NpxState", &dwCr0Npx))
				pcr->ContextFlags |= CONTEXT_FLOATING_POINT;
#undef FGR
		}
	}
	/* Now get the extended context if we need it */
	if(SUCCEEDED(hr) && fWantExtCtx) {
		HRESULT hrT;
		memset(pxfs, 0, sizeof *pxfs);
		hrT = HrGetExtContext(s, tid, pxfs);
		if(SUCCEEDED(hrT)) {
			pcr->ContextFlags |= dwFlags & CONTEXT_EXTENDED_REGISTERS;
			/* We return the fp area not based on whether it was requested, but
			 * on whether we got the FP control regs earlier */
			if((pcr->ContextFlags & CONTEXT_FLOATING_POINT) ==
				CONTEXT_FLOATING_POINT)
			{
#define FGFpR(reg) pcr->FloatSave.reg = pxfs->reg
				int ireg;

				/* We need to pick apart the extended registers into the FP
				 * state */
				pcr->FloatSave.Cr0NpxState = dwCr0Npx;
				FGFpR(ControlWord);
				FGFpR(StatusWord);
				FGFpR(TagWord);
				FGFpR(ErrorOffset);
				FGFpR(ErrorSelector);
				FGFpR(DataOffset);
				FGFpR(DataSelector);
				for(ireg = 0; ireg < 8; ++ireg)
					memcpy(&pcr->FloatSave.RegisterArea[10 * ireg],
						&pxfs->RegisterArea[16 * ireg], 10);
#undef FGFpR
			}
		} else {
			pcr->ContextFlags &= CONTEXT_FULL;
			if((pcr->ContextFlags & CONTEXT_CONTROL) != CONTEXT_CONTROL &&
					(pcr->ContextFlags & CONTEXT_INTEGER) != CONTEXT_INTEGER)
				pcr->ContextFlags = 0;
			/* whether we return failure depends on whether we got
			 * any other context data */
			if(!pcr->ContextFlags)
				hr = hrT;
		}
	}
	CloseSharedConnection(s);
	return hr;
}

#define SR(reg) (sprintf(szT, " " #reg "=0x%x", pcr->reg), strcat(sz, szT))

HRESULT DmSetThreadContext(DWORD tid, PCONTEXT pcr)
{
	PDM_CONNECTION s;
	HRESULT hr;
	char szT[64];
	char sz[1024];
	XFLOATSAVE xfs;
	PXFLOATSAVE pxfs = NULL;

    if (!pcr)
        return E_INVALIDARG;

	hr = HrOpenSharedConnection(&s);
	if(FAILED(hr))
		return hr;
	sprintf(sz, "SETCONTEXT THREAD=%d", tid);
	if((pcr->ContextFlags & CONTEXT_CONTROL) == CONTEXT_CONTROL) {
		SR(Esp);
		SR(Ebp);
		SR(Eip);
		SR(EFlags);
	}
	if((pcr->ContextFlags & CONTEXT_INTEGER) == CONTEXT_INTEGER) {
		SR(Eax);
		SR(Ebx);
		SR(Ecx);
		SR(Edx);
		SR(Esi);
		SR(Edi);
	}
	if((pcr->ContextFlags & CONTEXT_EXTENDED_REGISTERS) ==
			CONTEXT_EXTENDED_REGISTERS)
		pxfs = (PXFLOATSAVE)&pcr->ExtendedRegisters;
	if((pcr->ContextFlags & CONTEXT_FLOATING_POINT) ==
		CONTEXT_FLOATING_POINT)
	{
#define SFpR(reg) pxfs->reg = pcr->FloatSave.reg;
#define SFpSR(reg) pxfs->reg = (USHORT)pcr->FloatSave.reg;
		if(!pxfs) {
			/* We're only modifying part of the extended register set, so we
			 * need to start with the full extended registers */
			if(SUCCEEDED(HrGetExtContext(s, tid, &xfs)))
				pxfs = &xfs;
		}
		if(pxfs) {
			int ireg;

			sprintf(szT, " Cr0NpxState=0x%x", pcr->FloatSave.Cr0NpxState);
			strcat(sz, szT);
			/* Fill in the extended registers */
			SFpSR(ControlWord);
			SFpSR(StatusWord);
			SFpSR(TagWord);
			SFpSR(ErrorOffset);
			SFpR(ErrorSelector);
			SFpR(DataOffset);
			SFpR(DataSelector);
			for(ireg = 0; ireg < 8; ++ireg)
				memcpy(&pxfs->RegisterArea[16 * ireg],
					&pcr->FloatSave.RegisterArea[10 * ireg], 10);
		}
#undef SFpR
#undef SFpSR
	}

	if(pxfs) {
		sprintf(szT, " ext=%d", sizeof *pxfs);
		strcat(sz, szT);
	}
	hr = DmSendCommand(s, sz, NULL, 0);
	if(hr == XBDM_READYFORBIN) {
		 DmSendBinary(s, pxfs, sizeof *pxfs);
		 hr = DmReceiveStatusResponse(s, NULL, 0);
	}
	CloseSharedConnection(s);
	return hr;
}

HRESULT DmGetThreadList(LPDWORD rgdw, LPDWORD pdw)
{
	DWORD cthread;
	PDM_CONNECTION s;
	HRESULT hr;
	char sz[256];
	
    if (!rgdw || !pdw)
        return E_INVALIDARG;

	hr = HrOpenSharedConnection(&s);
	if(FAILED(hr))
		return hr;
	hr = DmSendCommand(s, "THREADS", NULL, 0);
	if(SUCCEEDED(hr) && hr != XBDM_MULTIRESPONSE) {
		TerminateConnection(s);
		hr = E_UNEXPECTED;
	}
	if(SUCCEEDED(hr)) {
		for(cthread = 0;; ++cthread) {
			DWORD dwLen = sizeof sz;
			hr = DmReceiveSocketLine(s, sz, &dwLen);
			sz[dwLen] = 0;
			if(FAILED(hr) || sz[0] == '.')
				break;
			if(cthread < *pdw)
				rgdw[cthread] = atoi(sz);
		}
		if(cthread > *pdw)
			hr = XBDM_BUFFER_TOO_SMALL;
		else {
			*pdw = cthread;
			hr = XBDM_NOERR;
		}
	}
	CloseSharedConnection(s);
	return hr;
}

HRESULT DmHaltThread(DWORD tid)
{
	char sz[64];

	sprintf(sz, "HALT THREAD=%d", tid);
	return HrOneLineCmd(sz);
}

HRESULT DmContinueThread(DWORD tid, BOOL fException)
{
	char sz[64];

	sprintf(sz, "CONTINUE THREAD=%d %s", tid, fException ? "EXCEPTION" : "");
	return HrOneLineCmd(sz);
}

HRESULT DmGetMemory(const LPBYTE lpbAddr, DWORD cb, LPBYTE lpbBuf, LPDWORD pcbRet)
{
	PDM_CONNECTION s;
	HRESULT hr;
	DWORD cbRet;
	char sz[256];
	char *pch;

	if(!lpbBuf)
		return E_INVALIDARG;

	hr = HrOpenSharedConnection(&s);
	if(FAILED(hr))
		return hr;
	sprintf(sz, "GETMEM ADDR=0x%08x LENGTH=0x%08x", lpbAddr, cb);
	hr = DmSendCommand(s, sz, NULL, 0);
	if(SUCCEEDED(hr) && hr != XBDM_MULTIRESPONSE) {
		TerminateConnection(s);
		hr = E_UNEXPECTED;
	}

	if(SUCCEEDED(hr)) {
		cbRet = 0;
		for(;;) {
			DWORD cch = sizeof sz;
			hr = DmReceiveSocketLine(s, sz, &cch);
			if(*sz == '.' || FAILED(hr))
				break;
			if(!lpbBuf)
				continue;
			for(pch = sz; *pch; pch += 2)
			{
				BYTE b = 0;
				int i = 0;
				if(*pch == '?') {
					/* End of mapped memory */
					lpbBuf = NULL;
					break;
				}
				for(i = 0; i < 2; ++i)
				{
					BYTE bT = pch[i] - '0';
					if(bT > 9)
						bT -= 'A' - '0' - 10;
					if(bT > 15)
						bT -= 'a' - 'A';
					if(bT > 15) {
						/* Don't know what we're looking at */
						lpbBuf = NULL;
						break;
					}
					b = 16*b + bT;
				}
				*lpbBuf++ = b;
				++cbRet;
			}
		}
	}
	CloseSharedConnection(s);
	if(SUCCEEDED(hr)) {
		if(pcbRet)
			*pcbRet = cbRet;
		else if(cbRet != cb)
			hr = XBDM_MEMUNMAPPED;
	}
	return hr;
}

HRESULT DmSetMemory(const BYTE *lpbAddr, DWORD cb, LPBYTE lpbBuf, LPDWORD pcbRet)
{
	PDM_CONNECTION s;
	HRESULT hr;
	char sz[512];
	DWORD cbT;
	char *pch;
	DWORD cch;
	int cbSent;

	if(!lpbBuf)
		return E_INVALIDARG;
	if(pcbRet)
		*pcbRet = cb;
	hr = HrOpenSharedConnection(&s);
	if(FAILED(hr))
		return hr;
	while(cb && SUCCEEDED(hr)) {
		/* We write 128 bytes at a time */
		cbT = 128;
		if(cbT > cb)
			cbT = cb;
		sprintf(sz, "setmem addr=0x%08x data=", lpbAddr);
		for(pch = sz; *pch; ++pch);
		for(cbSent = cbT; cbSent--; ) {
			pch[1] = (*lpbBuf & 0xF) + '0';
			if(pch[1] > '9')
				pch[1] += 'A' - '9' - 1;
			pch[0] = ((*lpbBuf >> 4) & 0xF) + '0';
			if(pch[0] > '9')
				pch[0] += 'A' - '9' - 1;
			++lpbBuf;
			pch += 2;
		}
		*pch = 0;
		cch = sizeof sz;
		hr = DmSendCommand(s, sz, sz, &cch);
		if(hr == XBDM_NOERR || hr == XBDM_MEMUNMAPPED)
			/* Our return string is of the form "xxx- set nnn bytes */
			sscanf(sz + 9, "%d", &cbSent);
		else
			cbSent = 0;
        lpbAddr += cbSent;
		cb -= cbSent;
	}
	if(pcbRet) {
		*pcbRet -= cb;
		if(*pcbRet)
			hr = XBDM_NOERR;
	} else
		hr = XBDM_MEMSETINCOMPLETE;
	CloseSharedConnection(s);
	return hr;
}

HRESULT DmIsThreadStopped(DWORD tid, PDM_THREADSTOP pdmts)
{
	PDM_CONNECTION s;
	HRESULT hr;
	char sz[512];
	DWORD cch;

    if (!pdmts)
        return E_INVALIDARG;
    
	hr = HrOpenSharedConnection(&s);
	if(FAILED(hr))
		return hr;
	sprintf(sz, "ISSTOPPED THREAD=%d", tid);
	cch = sizeof sz;
	hr = DmSendCommand(s, sz, sz, &cch);
	if(SUCCEEDED(hr)) {
		/* The string we got back is in the form "200- notification string",
		 * so we just pass off that string to the notifier to construct the
		 * data we want */
		if(!FGetNotificationData(sz + 5, &pdmts->NotifiedReason, &pdmts->u))
			pdmts->NotifiedReason = DM_NONE;
	}
	CloseSharedConnection(s);
	return hr;
}

HRESULT DmGetThreadInfo(DWORD tid, PDM_THREADINFO pdmti)
{
	PDM_CONNECTION s;
	HRESULT hr;
	char sz[256];

    if (!pdmti)
        return E_INVALIDARG;

	hr = HrOpenSharedConnection(&s);
	if(FAILED(hr))
		return hr;
	sprintf(sz, "THREADINFO THREAD=%d", tid);
	hr = DmSendCommand(s, sz, NULL, 0);
	if(hr != XBDM_MULTIRESPONSE) {
        if(SUCCEEDED(hr)) {
		    TerminateConnection(s);
            hr = E_UNEXPECTED;
        }
        CloseSharedConnection(s);
		return hr;
	}
	memset(pdmti, 0, sizeof *pdmti);
	for(;;) {
		DWORD cch = sizeof sz;

		hr = DmReceiveSocketLine(s, sz, &cch);
		if(FAILED(hr) || *sz == '.')
			break;
		FGetDwParam(sz, "suspend", &pdmti->SuspendCount);
		FGetDwParam(sz, "priority", &pdmti->Priority);
		FGetDwParam(sz, "tlsbase", (DWORD *)&pdmti->TlsBase);
	}
	CloseSharedConnection(s);
	return hr;
}

HRESULT DmGetXtlData(PDM_XTLDATA pdmxd)
{
    char sz[256];
    PDM_CONNECTION s;
    HRESULT hr;

    if(!pdmxd)
        return E_INVALIDARG;
    hr = HrOpenSharedConnection(&s);
    if(FAILED(hr))
        return hr;
    hr = DmSendCommand(s, "XTLINFO", NULL, 0);
	if(hr != XBDM_MULTIRESPONSE) {
        if(SUCCEEDED(hr)) {
		    TerminateConnection(s);
            hr = E_UNEXPECTED;
        }
        CloseSharedConnection(s);
		return hr;
	}
    memset(pdmxd, 0, sizeof *pdmxd);
    for(;;) {
		DWORD cch = sizeof sz;

		hr = DmReceiveSocketLine(s, sz, &cch);
		if(FAILED(hr) || *sz == '.')
			break;
        FGetDwParam(sz, "lasterr", &pdmxd->LastErrorOffset);
    }
    CloseSharedConnection(s);
    return hr;
}

HRESULT DmSuspendThread(DWORD tid)
{
	char sz[64];

	sprintf(sz, "SUSPEND THREAD=%d", tid);
	return HrOneLineCmd(sz);
}

HRESULT DmResumeThread(DWORD tid)
{
	char sz[64];

	sprintf(sz, "RESUME THREAD=%d", tid);
	return HrOneLineCmd(sz);
}

HRESULT DmSetInitialBreakpoint(void)
{
	return HrOneLineCmd("BREAK START");
}

HRESULT DmStopOn(DWORD dwStop, BOOL fStop)
{
	char sz[256];
	
	strcpy(sz, fStop ? "STOPON" : "NOSTOPON");
	if(dwStop & DMSTOP_CREATETHREAD)
		strcat(sz, " CREATETHREAD");
	if(dwStop & DMSTOP_FCE)
		strcat(sz, " FCE");
	if(dwStop & DMSTOP_DEBUGSTR)
		strcat(sz, " DEBUGSTR");
	return HrOneLineCmd(sz);
}

HRESULT DmReboot(DWORD dwFlags)
{
	char *szEmpty = "";
	char *szWait;
	char *szWarm = dwFlags & DMBOOT_WARM ? " WARM" : szEmpty;
    char *szNDebug = dwFlags & DMBOOT_NODEBUG ? " NODEBUG" : szEmpty;
	char sz[64];

    if(dwFlags & DMBOOT_STOP)
        szWait = " STOP";
    else if(dwFlags & DMBOOT_WAIT)
        szWait = " WAIT";
    else
        szWait = szEmpty;
	sprintf(sz, "REBOOT%s%s%s", szWait, szWarm, szNDebug);
	return HrOneLineCmd(sz);
}

HRESULT DmSetConfigValue(ULONG ulValueIndex, ULONG ulType, PVOID pValue, ULONG cbValueLength)
{
    if (!pValue)
        return E_INVALIDARG;

	/* Note: only setting DWORD values for now */
	if ((REG_DWORD == ulType) && (NULL != pValue) && (sizeof(DWORD) == cbValueLength))
	{
		char sz[128];
		sprintf(sz, "SETCONFIG INDEX=0x%08x VALUE=0x%08x", ulValueIndex, *((PDWORD) pValue));
		return HrOneLineCmd(sz);
	}
	else
	{
		return E_NOTIMPL;
	}
}

HRESULT DmConnectDebugger(BOOL fConnect)
{
    char sz[32];

    sprintf(sz, "DEBUGGER %s", fConnect ? "CONNECT" : "DISCONNECT");
	return HrOneLineCmd(sz);
}

HRESULT DmSetupFunctionCall(DWORD tid)
{
	char sz[256];

	sprintf(sz, "FUNCCALL THREAD=%lu", tid);
	return HrOneLineCmd(sz);
}

HRESULT DmCAPControl(LPCSTR action)
{
    char sz[128];
    if (!action)
        return E_INVALIDARG;
    sprintf(sz, "CAPCONTROL %s", action);
    return HrOneLineCmd(sz);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xboxdbg\xbconn.cpp ===
/*
 *
 * xbconn.cpp
 *
 * IXboxConnection implementation
 *
 */

#include "precomp.h"
#undef HrOpenSharedConnection
#undef CloseSharedConnection
#include <ixbconn.h>

#undef PURE
#undef THIS_
#undef THIS

class CXboxConnection : public IXboxConnection
{
public:
    STDMETHOD(QueryInterface) (REFIID riid, LPVOID FAR *ppvObj);
    STDMETHOD_(ULONG, AddRef) (void);
    STDMETHOD_(ULONG, Release) (void);

    // IXboxConnection
    STDMETHOD(HrSetConnectionTimeout) (DWORD dwConnectTimeout,
        DWORD dwConversationTimeout);
    STDMETHOD(HrUseSharedConnection) (BOOL fShare);
    STDMETHOD(HrUseSecureConnection) (LPCSTR szPasswd);
    STDMETHOD(HrSendCommand) (LPCSTR szCommand, LPSTR szResponse,
        LPDWORD lpdwResponseSize);
    STDMETHOD(HrResolveXboxName) (LPDWORD lpdwAddress);
    STDMETHOD(HrGetNameOfXbox) (LPSTR szName, LPDWORD lpdwSize,
        BOOL fResolvable);
    STDMETHOD(HrSendFile) (LPCSTR szLocalName, LPCSTR szRemoteName);
    STDMETHOD(HrReceiveFile) (LPCSTR szLocalName, LPCSTR szRemoteName);
    STDMETHOD(HrGetFileAttributes) (LPCSTR szFileName, PDM_FILE_ATTRIBUTES pfa);
    STDMETHOD(HrSetFileAttributes) (LPCSTR szFileName, PDM_FILE_ATTRIBUTES pfa);
    STDMETHOD(HrMkdir) (LPCSTR szDirectoryName);
    STDMETHOD(HrRenameFile) (LPCSTR szOldName, LPCSTR szNewName);
    STDMETHOD(HrDeleteFile) (LPCSTR szFileName, BOOL fIsDirectory);
    STDMETHOD(HrOpenDir) (PDM_WALK_DIR *ppwd, LPCSTR szDir, LPDWORD pdw);
    STDMETHOD(HrWalkDir) (PDM_WALK_DIR *ppwd, LPCSTR szDir, PDM_FILE_ATTRIBUTES pfa);
    STDMETHOD(HrCloseDir) (PDM_WALK_DIR pwd);
    STDMETHOD(HrGetDriveList) (LPSTR rgchDrives, LPDWORD pcDrives);
    STDMETHOD(HrGetDiskFreeSpace) (LPSTR szDrive,
        PULARGE_INTEGER pnFreeBytesAvailableToCaller,
        PULARGE_INTEGER pnTotalNumberOfBytes,
        PULARGE_INTEGER pnTotalNumberOfFreeBytes);
    STDMETHOD(HrReboot)(DWORD dwFlags, LPCSTR pszXbeName);
    STDMETHOD(HrGetXbeInfo)(LPCSTR szName, PDM_XBE pxbe);
    STDMETHOD(HrGetSystemTime)(LPSYSTEMTIME lpSysTime);
    STDMETHOD(HrGetAltAddress)(LPDWORD lpdw);
    STDMETHOD(HrScreenShot)(LPCSTR filename);
    STDMETHOD(HrEnableSecurity)(BOOL fEnable);
    STDMETHOD(HrIsSecurityEnabled)(LPBOOL pfEnabled);
    STDMETHOD(HrSetAdminPassword)(LPCSTR szPasswd);
    STDMETHOD(HrSetUserAccess)(LPCSTR szUserName, DWORD dwAccess);
    STDMETHOD(HrGetUserAccess)(LPCSTR szUserName, LPDWORD lpdwAccess);
    STDMETHOD(HrAddUser)(LPCSTR szUserName, DWORD dwAccess);
    STDMETHOD(HrRemoveUser)(LPCSTR szUserName);
    STDMETHOD(HrOpenUserList)(PDM_WALK_USERS *, LPDWORD);
    STDMETHOD(HrWalkUserList)(PDM_WALK_USERS *, PDM_USER);
    STDMETHOD(HrCloseUserList)(PDM_WALK_USERS);

    CXboxConnection(LPCSTR szName);
    ~CXboxConnection();

    HRESULT HrOpenSharedConnection(PDM_CONNECTION *ppdcon)
    {
        return HrDoOpenSharedConnection(&m_sci, ppdcon);
    }

    void CloseSharedConnection(PDM_CONNECTION pdcon)
    {
        DoCloseSharedConnection(&m_sci, pdcon);
    }

    long m_cRef;
    SCI m_sci;

    void *operator new(size_t cb)
    {
        return LocalAlloc(LMEM_FIXED, cb);
    }

    void operator delete(void *pv)
    {
        if(pv)
            LocalFree(pv);
    }
};

CXboxConnection::CXboxConnection(LPCSTR szName)
{
    memset(&m_sci, 0, sizeof m_sci);
    strcpy(m_sci.szXboxName, szName);
    InitializeCriticalSection(&m_sci.csSharedConn);
    m_sci.fCacheAddr = TRUE;
    m_cRef = 1;
}

CXboxConnection::~CXboxConnection()
{
    HrUseSharedConnection(FALSE);
    DeleteCriticalSection(&m_sci.csSharedConn);
}

// import function definitions
#include "filefunc.c"

STDMETHODIMP CXboxConnection::QueryInterface(REFIID riid, LPVOID FAR *ppvObj)
{
    /* We don't support QI */
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CXboxConnection::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CXboxConnection::Release(void)
{
    int cRef = InterlockedDecrement(&m_cRef);
    if(0 == cRef)
        delete this;
    return cRef;
}

STDMETHODIMP CXboxConnection::HrUseSharedConnection(BOOL fShare)
{
    return ::HrUseSharedConnection(&m_sci, fShare);
}

STDMETHODIMP CXboxConnection::HrUseSecureConnection(LPCSTR szPasswd)
{
    return ::HrOpenSecureConnection(&m_sci, NULL, szPasswd);
}

STDMETHODIMP CXboxConnection::HrSendCommand(LPCSTR szCommand, LPSTR szResponse,
    LPDWORD lpdwResponseSize)
{
    HRESULT hr;
    PDM_CONNECTION s;

    hr = HrOpenSharedConnection(&s);
    if(SUCCEEDED(hr)) {
        hr = DmSendCommand(s, szCommand, szResponse, lpdwResponseSize);
        CloseSharedConnection(s);
    }
    return hr;
}

STDMETHODIMP CXboxConnection::HrOpenDir(PDM_WALK_DIR *ppwd, LPCSTR szDirName,
    LPDWORD pdw)
{
    return ::HrOpenDir(&m_sci, ppwd, szDirName, pdw);
}

STDMETHODIMP CXboxConnection::HrCloseDir(PDM_WALK_DIR pwd)
{
    return DmCloseDir(pwd);
}

STDMETHODIMP CXboxConnection::HrOpenUserList(PDM_WALK_USERS *ppwu, LPDWORD pdw)
{
    return ::HrOpenUserList(&m_sci, ppwu, pdw);
}

STDMETHODIMP CXboxConnection::HrCloseUserList(PDM_WALK_USERS pwu)
{
    return DmCloseUserList(pwu);
}

HRESULT CXboxConnection::HrReboot(DWORD dwFlags, LPCSTR pszXbeName)
{
    PDM_CONNECTION s;
    char *szEmpty = "";
	char *szWait;
	char *szWarm = dwFlags & DMBOOT_WARM ? " WARM" : szEmpty;
    
	char sz[512];

    if(dwFlags & DMBOOT_STOP)
        szWait = " STOP";
    else if(dwFlags & DMBOOT_WAIT)
        szWait = " WAIT";
    else
        szWait = szEmpty;

    if(!pszXbeName)
    {
        char *szNDebug = dwFlags & DMBOOT_NODEBUG ? " NODEBUG" : szEmpty;
	    sprintf(sz, "REBOOT%s%s%s", szWait, szWarm, szNDebug);    
    } else
    {
        char *szDebug = dwFlags & DMBOOT_NODEBUG ? szEmpty : " DEBUG";
        sprintf(sz, "magicboot title=%s%s", pszXbeName,szDebug);
    }
    
    HRESULT hr = HrOpenSharedConnection(&s);
    if(SUCCEEDED(hr)) {
        hr = HrDoOneLineCmd(s, sz);
        CloseSharedConnection(s);
    }
    return hr;
}

HRESULT DmGetXboxConnection(LPCSTR sz, DWORD dwVersion, IXboxConnection **ppvObj)
{
    CXboxConnection *pxc;
    PDM_CONNECTION pdcon;
    HRESULT hr;
    struct sockaddr_in sin;

    if(dwVersion != XBCONN_VERSION)
        return E_INVALIDARG;

    pxc = new CXboxConnection(sz);
    if(!pxc)
        return E_OUTOFMEMORY;
    *ppvObj = pxc;
    /* Make sure we can get an IP address */
    hr = HrResolveNameIP(pxc->m_sci.szXboxName, &sin);
    if(SUCCEEDED(hr))
        pxc->m_sci.ulXboxIPAddr = sin.sin_addr.s_addr;
    else
        delete pxc;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xboxdbg\dll\makefile.inc ===
$(XDK_LIB_PATH)\$(TARGETNAME).Lib: $(SDK_LIB_PATH)\$(TARGETNAME).Lib
    Copy $? $@

$O\fileapi.obj: ..\fileapi.c ..\filefunc.c

$O\xbconn.obj: ..\xbconn.cpp ..\filefunc.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xboxdbg\dll\xboxdbg.c ===
/*
**
** xboxdbg.c
**
** Utility functions to talk to the xbox debug monitor
**
*/

#include "precomp.h"
HINSTANCE hXboxdbg;
BOOL WINAPI DllMain(HINSTANCE hinst, DWORD dwReason, LPVOID lpv)
{
	SOCKET s;

	switch(dwReason)
	{
	case DLL_PROCESS_ATTACH:
        hXboxdbg = hinst;
		InitNotificationEvents();
		break;
	case DLL_PROCESS_DETACH:
		DestroyNotificationEvents();
		break;
	case DLL_THREAD_DETACH:
		CloseThreadConnection();
		break;
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xboxdbg\xbeutil.c ===
/*
 *
 * xbeutil.c
 *
 * XBE image file utilities
 *
 */

#include "precomp.h"
#include <xbeimage.h>

HRESULT HrGetXbeHeader(LPCSTR szXbe, PXBEIMAGE_HEADER pxh, HANDLE *ph)
{
	HANDLE hFile;
	HRESULT hr;
	DWORD cb;

	hFile = CreateFile(szXbe, GENERIC_READ, FILE_SHARE_READ, NULL,
		OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if(INVALID_HANDLE_VALUE == hFile)
		return XBDM_NOSUCHFILE;
	if(!ReadFile(hFile, pxh, sizeof *pxh, &cb, NULL) || cb < sizeof *pxh)
		hr = XBDM_NOTXBEFILE;
	else if(pxh->Signature != XBEIMAGE_SIGNATURE)
		hr = XBDM_NOTXBEFILE;
	else
		hr = XBDM_NOERR;
	if(FAILED(hr) || !ph)
		CloseHandle(hFile);
	else if(ph)
		*ph = hFile;
	return hr;
}

HRESULT XbeGetLocalModulePath(LPCSTR szXbe, LPCSTR szModule, LPSTR szPath,
	DWORD cchPath)
{
	HANDLE hFile;
	XBEIMAGE_HEADER xih;
	DWORD cb, cbT;
	char rgchNames[MAX_PATH + 2];
    char rgchModule[MAX_PATH + 1];
	char *pch;
	HRESULT hr;

    if (!szXbe || !szPath)
        return E_INVALIDARG;

	/* First just read the standard header */
	hr = HrGetXbeHeader(szXbe, &xih, &hFile);
	if(FAILED(hr))
		return hr;
	hr = XBDM_NOMODULE;

    for(;;) {
		/* We're only interested in modules that have embedded PE names */
        if(!xih.DebugFileName || !xih.DebugPathName)
            break;
        /* Read in the debug file name from the file */
        if(INVALID_FILE_SIZE == SetFilePointer(hFile, (ULONG)xih.DebugFileName -
            (ULONG)xih.BaseAddress, NULL, FILE_BEGIN))
            break;
        if(!ReadFile(hFile, rgchModule, sizeof rgchModule, &cb, NULL))
            break;
		for(pch = rgchModule; *pch && pch < rgchModule + cb; ++pch);
		if(pch - rgchModule == (int)cb)
			/* We didn't get a complete string.  Too bad */
			break;
		/* Check whether this is the module we want */
		if(szModule && _strnicmp(szModule, rgchModule, pch - rgchModule))
			break;
        if(!szModule) {
            /* We need to remember this name for later */
            szModule = rgchModule;
        }
        /* Read in the debug path name from the file */
        if(INVALID_FILE_SIZE == SetFilePointer(hFile, (ULONG)xih.DebugPathName -
            (ULONG)xih.BaseAddress, NULL, FILE_BEGIN))
            break;
        if(!ReadFile(hFile, rgchNames, sizeof rgchNames, &cb, NULL))
            break;
		for(pch = rgchNames; *pch && pch < rgchNames + cb; ++pch);
		if(pch - rgchNames == (int)cb)
			/* We didn't get a complete string.  Too bad */
			break;
        hr = XBDM_NOERR;
        break;
    }

	CloseHandle(hFile);
    if(FAILED(hr))
        return hr;

    /* We now have the name of the local file, but we need to ensure that
     * it exists.  If not, we're going to look again alongside the input
     * XBE */
    if(-1 == GetFileAttributes(rgchNames)) {
        char *pchMax = rgchNames + sizeof rgchNames;
        char *pch2 = NULL;
        for(pch = rgchNames; *szXbe && pch < pchMax; ++pch, ++szXbe) {
            *pch = *szXbe;
            if(*pch == '\\')
                pch2 = pch;
        }
        if(*szXbe)
            /* The pathname was too long */
            return XBDM_BADFILENAME;
        pch = pch2 ? pch2 + 1 : szPath;
        while(*szModule && pch < pchMax)
            *pch++ = *szModule++;
        if(pch == pchMax)
            /* The combined name is too long */
            return XBDM_BADFILENAME;
        *pch = 0;
        if(-1 == GetFileAttributes(rgchNames))
            hr = XBDM_NOSUCHFILE;
        else {
            /* The file exists; turn it into a long pathname */
            DWORD cch = GetFullPathName(rgchNames, cchPath, szPath, NULL);
            if(cch == 0)
                hr = E_UNEXPECTED;
            else if(cch > cchPath)
                hr = XBDM_BUFFER_TOO_SMALL;
            else
                hr = XBDM_NOERR;
        }
    } else {
        /* The local name we fetched is valid, so we need to return it */
    	cbT = 0;
		pch = rgchNames;
		while(*pch && pch < rgchNames + cb && cbT < cchPath)
			szPath[cbT++] = *pch++;
		if(pch - rgchNames != (int)cb) {
			if(cbT == cchPath) {
				szPath[cchPath - 1] = 0;
				hr = XBDM_BUFFER_TOO_SMALL;
			} else {
				szPath[cbT] = 0;
				hr = XBDM_NOERR;
			}
		}
	}

    return hr;
}

HRESULT XbeGetXbeInfo(LPCSTR szName, PDM_XBE pxbe)
{
	XBEIMAGE_HEADER xih;
	HRESULT hr;

    if (!szName || !pxbe)
        return E_INVALIDARG;

	hr = HrGetXbeHeader(szName, &xih, NULL);
	if(SUCCEEDED(hr)) {
		int ich;
		for(ich = 0; *szName && ich < sizeof pxbe->LaunchPath - 1; ++ich)
			pxbe->LaunchPath[ich] = *szName++;
		pxbe->LaunchPath[ich] = 0;
		pxbe->TimeStamp = xih.TimeDateStamp;
		pxbe->CheckSum = 0;
        pxbe->StackSize = xih.SizeOfStackCommit;
	}
	return hr;
}

HRESULT XbeGetBuilderArgs(LPCSTR szName, LPSTR szArgs, LPDWORD pcchArgs)
{
    XBEIMAGE_HEADER xih;
    XBEIMAGE_CERTIFICATE xbc;
    HRESULT hr;
    HANDLE h;
    DWORD cb;
    char *pchStart = szArgs;

    if(!pcchArgs || !szName || !szArgs)
        return E_INVALIDARG;

    hr = HrGetXbeHeader(szName, &xih, &h);
    if(FAILED(hr))
        return hr;
    /* We're not going to try to do anything unless we can get the long name */
    if(*pcchArgs < 6)
        hr = XBDM_BUFFER_TOO_SMALL;
    else if(!xih.DebugPathName)
        hr = XBDM_NOTDEBUGGABLE;
    /* We're also going to insist on getting the certificate data */
    else if(INVALID_FILE_SIZE == SetFilePointer(h, (ULONG)xih.Certificate -
            (ULONG)xih.BaseAddress, NULL, FILE_BEGIN) ||
            !ReadFile(h, &xbc, sizeof xbc, &cb, NULL) || cb < sizeof xbc)
		hr = XBDM_FILEERROR;
    else if(INVALID_FILE_SIZE == SetFilePointer(h, (ULONG)xih.DebugPathName -
            (ULONG)xih.BaseAddress, NULL, FILE_BEGIN))
        hr = XBDM_FILEERROR;
    else {
        char *pch;
        memcpy(szArgs, "/IN:\"", 5);
        *pcchArgs -= 5;
        szArgs += 5;
        if(!ReadFile(h, szArgs, *pcchArgs - 1, &cb, NULL))
            cb = 0;
        /* We need to have read the entire name and have room to spare to
         * consider this a success */
		for(pch = szArgs; *pch && pch < szArgs + cb; ++pch);
        if(pch - szArgs == (int)cb)
           /* We didn't get a complete string.  Too bad */
            hr = cb == *pcchArgs - 1 ? XBDM_BUFFER_TOO_SMALL : XBDM_FILEERROR;
        else {
            cb = pch - szArgs;
            *pcchArgs -= cb + 1;
            szArgs += cb + 1;
            szArgs[-1] = '"';
        }
    }
    if(SUCCEEDED(hr)) {
        if(*pcchArgs < 7)
            hr = XBDM_BUFFER_TOO_SMALL;
        else {
            memcpy(szArgs, " /DEBUG", 7);
            *pcchArgs -= 7;
            szArgs += 7;
        }
    }
    if(SUCCEEDED(hr)) {
        if(*pcchArgs < 18)
            hr = XBDM_BUFFER_TOO_SMALL;
        else {
            sprintf(szArgs, " /STACK:0x%08x",
                xih.SizeOfStackCommit);
            *pcchArgs -= 18;
            szArgs += 18;
        }
    }
    if(SUCCEEDED(hr)) {
        if(*pcchArgs < 19)
            hr = XBDM_BUFFER_TOO_SMALL;
        else {
            sprintf(szArgs, " /TESTID:0x%08x", xbc.TitleID);
            *pcchArgs -= 19;
            szArgs += 19;
        }
    }
    if(SUCCEEDED(hr) && xbc.TitleName[0]) {
        if(*pcchArgs < 12)
            hr = XBDM_BUFFER_TOO_SMALL;
        else {
            memcpy(szArgs, " /TESTNAME:\"", 12);
            szArgs += 12;
            *pcchArgs -= 12;
        }
        cb = WideCharToMultiByte(CP_ACP, 0, xbc.TitleName, -1, szArgs,
            *pcchArgs - 1, NULL, NULL);
        if(cb == *pcchArgs - 1)
            hr = XBDM_BUFFER_TOO_SMALL;
        else {
            *pcchArgs -= cb;
            szArgs += cb;
            szArgs[-1] = '"';
        }
    }

    /* That's it */
    if(SUCCEEDED(hr)) {
        if(*pcchArgs == 0)
            hr = XBDM_BUFFER_TOO_SMALL;
        else {
            *szArgs = 0;
            *pcchArgs = szArgs - pchStart;
        }
    }

    CloseHandle(h);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xboxdbg\lib\makefile.inc ===
$O\fileapi.obj: ..\fileapi.c ..\filefunc.c

$O\xbconn.obj: ..\xbconn.cpp ..\filefunc.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xboxdbg\dll\notify.c ===
/*
**
** notify.c
**
** Receive notifications from the Xbox and pass them along
**
*/

#include "precomp.h"

static PDM_CONNECTION pdconNotify;
static SOCKET sockPersist = INVALID_SOCKET;
static HANDLE hthrNotifier;
static CRITICAL_SECTION csNotifyList;
static CRITICAL_SECTION csEnsureNotify;
static HANDLE hevtSockData;
static HANDLE hevtPersistConn;
static HANDLE hevtDropConnection;
static HANDLE hevtTerminate;
static DWORD dwExecState = DMN_EXEC_REBOOT;
static USHORT usPersistPort;
static CRITICAL_SECTION csAssert;
static DMN_DEBUGSTR g_dmdsAssert;

/* Extended notification handler */
typedef struct _ENH {
	char szExtName[64];
	PDM_EXT_NOTIFY_FUNCTION pfnHandler;
} ENH;
#define MAX_ENH 16

#define MAX_NOTIFY 32
typedef struct _DMN_SESSION {
	DWORD dwSig;
	PDMN_SESSION psessNext;
	DWORD dwFlags;
	PDM_NOTIFY_FUNCTION rgpfnNotify[DM_NOTIFYMAX][MAX_NOTIFY];
	int rgcfnNotify[DM_NOTIFYMAX];
	ENH *rgpenh[MAX_ENH];
} DMN_SESSION;
#define DMSESS_DEAD 0x10000
#define DMSESS_MSVC 0x20000
static PDMN_SESSION psessFirst;
static BOOL fUsingSessionList;

/* Notifier Request Queue */
typedef struct _NRQ {
    union {
        struct {
            BOOL fReset:1,
                fAsync:1,
                unused:30;
        };
        BOOL grfFlags;
    };
    HRESULT hr;
    HANDLE hevt;
    PDM_NOTIFY_FUNCTION pfn;
    struct _NRQ *pnrqNext;
} NRQ, *PNRQ;
static HANDLE hevtNRQ;
static PNRQ g_pnrq;

void ResetConnection(PDM_CONNECTION pdcon)
{
	SOCKET s = pdcon->s;

	pdcon->s = INVALID_SOCKET;
    if(s != INVALID_SOCKET) {
        /* We need this connection to RST, not to FIN */
        struct linger lin;
        lin.l_onoff = 1;
        lin.l_linger = 0;
        setsockopt(s, SOL_SOCKET, SO_LINGER, (PVOID)&lin,
            sizeof lin);
		closesocket(s);
    }
}

BOOL FEnterSessionList(void)
{
	BOOL fPrev;
	EnterCriticalSection(&csNotifyList);
	fPrev = fUsingSessionList;
	fUsingSessionList = TRUE;
	return fPrev;
}

void LeaveSessionList(BOOL fStillInList)
{
	PDMN_SESSION psess;
	PDMN_SESSION *ppsess;

	fUsingSessionList = fStillInList;
	if(!fUsingSessionList) {
		/* Free all of the sessions marked dead */
		ppsess = &psessFirst;
		while(*ppsess) {
			psess = *ppsess;
			if(psess->dwFlags & DMSESS_DEAD) {
				*ppsess = psess->psessNext;
				psess->dwSig = 0;
				LocalFree(psess);
			} else
				ppsess = &psess->psessNext;
		}
	}
	if(!psessFirst)
		StopAllNotifications();
	LeaveCriticalSection(&csNotifyList);
}

void SendNotification(DWORD dwNotification, DWORD dw)
{
	DWORD dwIndex = (dwNotification & DM_NOTIFICATIONMASK) - 1;
	int ifn;
	PDMN_SESSION psess;
	BOOL f;

	f = FEnterSessionList();
	for(psess = psessFirst; psess; psess = psess->psessNext) {
		ifn = psess->rgcfnNotify[dwIndex];
		while(ifn-- && !(psess->dwFlags & DMSESS_DEAD))
			(*psess->rgpfnNotify[dwIndex][ifn])(dwNotification, dw);
	}
	LeaveSessionList(f);
}

void GetBreak(LPCSTR sz, PDMN_BREAK pdmbr)
{
	DMN_BREAK dmbr;

	if(!FGetDwParam(sz, "addr", (DWORD*)&pdmbr->Address))
		dmbr.Address = NULL;
	if(!FGetDwParam(sz, "thread", &pdmbr->ThreadId))
		dmbr.ThreadId = 0;
}

void FreeAssertData(void)
{
	EnterCriticalSection(&csAssert);
	if(g_dmdsAssert.String)
		LocalFree((PVOID)g_dmdsAssert.String);
	g_dmdsAssert.String = NULL;
	g_dmdsAssert.Length = 0;
	LeaveCriticalSection(&csAssert);
}

void AddAssertString(PDMN_DEBUGSTR pdmds)
{
	LPSTR szNew = LocalAlloc(LMEM_FIXED, g_dmdsAssert.Length + pdmds->Length +
        1);
	
	EnterCriticalSection(&csAssert);
	if(szNew) {
		if(g_dmdsAssert.String) {
			memcpy(szNew, g_dmdsAssert.String, g_dmdsAssert.Length);
			LocalFree((PVOID)g_dmdsAssert.String);
		}
		memcpy(szNew + g_dmdsAssert.Length, pdmds->String, pdmds->Length + 1);
		g_dmdsAssert.Length += pdmds->Length;
		g_dmdsAssert.String = szNew;
	}
	LeaveCriticalSection(&csAssert);
}

void SetDmdsSuffixAndLength(LPCSTR sz, PDMN_DEBUGSTR pdmds)
{
    char *szSuffix;
    char *szString = (char *)pdmds->String;

	for(pdmds->Length = 0; ; ++pdmds->Length) {
		switch(pdmds->String[pdmds->Length]) {
		case '\n':
		case '\r':
		case 0:
            if(sz) {
                if(PchGetParam(sz, "cr", FALSE, FALSE))
                    szString[pdmds->Length++] = '\015';
                else if(PchGetParam(sz, "lf", FALSE, FALSE))
                    szString[pdmds->Length++] = '\012';
                else if(PchGetParam(sz, "crlf", FALSE, FALSE)) {
                    szString[pdmds->Length++] = '\015';
                    szString[pdmds->Length++] = '\012';
                }
            }
            return;
		}
	}
}

BOOL FGetNotificationData(LPCSTR sz, DWORD *pdwNotification, PVOID pv)
{
	int cchCmd;
	for(cchCmd = 0; sz[cchCmd] && !isspace(sz[cchCmd]); ++cchCmd);
	if(cchCmd == 0)
		return FALSE;

	if(!_strnicmp(sz, "break", cchCmd)) {
		*pdwNotification = DM_BREAK;
		GetBreak(sz, (PDMN_BREAK)pv);
		return TRUE;
	} else if(!_strnicmp(sz, "singlestep", cchCmd)) {
		*pdwNotification = DM_SINGLESTEP;
		GetBreak(sz, (PDMN_BREAK)pv);
		return TRUE;
	} else if(!_strnicmp(sz, "data", cchCmd)) {
#define pdmdb ((PDMN_DATABREAK)pv)
		*pdwNotification = DM_DATABREAK;
		GetBreak(sz, (PDMN_BREAK)pv);
		if(FGetDwParam(sz, "write", (DWORD *)&pdmdb->DataAddress))
			pdmdb->BreakType = DMBREAK_WRITE;
		else if(FGetDwParam(sz, "read", (DWORD *)&pdmdb->DataAddress))
			pdmdb->BreakType = DMBREAK_READWRITE;
		else if(FGetDwParam(sz, "execute", (DWORD *)&pdmdb->DataAddress))
			pdmdb->BreakType = DMBREAK_EXECUTE;
		else {
			pdmdb->DataAddress = NULL;
			pdmdb->BreakType = DMBREAK_NONE;
		}
		return TRUE;
#undef pdmdb
	} else if(!_strnicmp(sz, "exception", cchCmd)) {
#define pdme ((PDMN_EXCEPTION)pv)
		*pdwNotification = DM_EXCEPTION;
		memset(pdme, 0, sizeof *pdme);
		if(!FGetDwParam(sz, "code", &pdme->Code))
			return FALSE;
		FGetDwParam(sz, "thread", &pdme->ThreadId);
		FGetDwParam(sz, "address", (DWORD *)&pdme->Address);
		if(PchGetParam(sz, "first", FALSE, FALSE))
			pdme->Flags |= DM_EXCEPT_FIRSTCHANCE;
		if(PchGetParam(sz, "noncont", FALSE, FALSE))
			pdme->Flags |= DM_EXCEPT_NONCONTINUABLE;
		FGetDwParam(sz, "read", &pdme->Information[1]);
		pdme->Information[0] = FGetDwParam(sz, "write", &pdme->Information[1]);
		return TRUE;
#undef pdme
	} else if(!_strnicmp(sz, "rip", cchCmd)) {
#define pdmds ((PDMN_DEBUGSTR)pv)
		*pdwNotification = DM_RIP;
		memset(pdmds, 0, sizeof *pdmds);
		FGetDwParam(sz, "thread", &pdmds->ThreadId);
		/* We won't actually fill in the string; that will be the job of the
		 * caller if they want it */
		return TRUE;
#undef pdmds
	} else if(!_strnicmp(sz, "assert", cchCmd)) {
		DWORD tid;
		BOOL fRet;
        DMN_DEBUGSTR dmds;

		*pdwNotification = DM_ASSERT;
		if(!FGetDwParam(sz, "thread", &tid))
			return FALSE;
		EnterCriticalSection(&csAssert);
		/* We don't accept thread-interleaved assert data, so if this thread
		 * id doesn't match the one we have stored, we'll dump the stored
		 * assert */
		if(g_dmdsAssert.ThreadId != tid) {
			FreeAssertData();
			g_dmdsAssert.ThreadId = tid;
		}
        /* If we have a string, then we need to process it.  Otherwise, if
		 * this is the end of the assert, we'll have a "prompt" keyword.
		 * In that case, we need to return the aggregate assert, or if there
		 * is none, we say there's an empty string */
        fRet = FALSE;
        dmds.String = PchGetParam(sz, "string", TRUE, FALSE);
        if(dmds.String) {
            ((char *)dmds.String)[-1] = 0;
            SetDmdsSuffixAndLength(sz, &dmds);
            AddAssertString(&dmds);
        } else if(PchGetParam(sz, "prompt", FALSE, FALSE)) {
			fRet = TRUE;
			memcpy(pv, &g_dmdsAssert, sizeof g_dmdsAssert);
		}
		LeaveCriticalSection(&csAssert);
		return fRet;
	}
	return FALSE;
}

void HandleNotification(LPCSTR sz)
{
	int cchCmd;
	int ich;
	DWORD dwFlags;
	DM_THREADSTOP dmts;
	const char *pchStop;
	
	for(cchCmd = 0; sz[cchCmd] && !isspace(sz[cchCmd]); ++cchCmd);
	if(cchCmd == 0)
		return;

	/* Check for external notifications */
	for(ich = 0; ich < cchCmd; ++ich) {
		if(sz[ich] == '!') {
			/* This needs to go the external handlers.  Find out who */
			PDMN_SESSION psess;
			BOOL f;

			f = FEnterSessionList();
			for(psess = psessFirst; psess; psess = psess->psessNext) {
				int ienh;

				for(ienh = 0; ienh < MAX_ENH; ++ienh) {
					if(psess->rgpenh[ienh] && !_strnicmp(sz,
							psess->rgpenh[ienh]->szExtName, ich) &&
							!psess->rgpenh[ienh]->szExtName[ich])
						psess->rgpenh[ienh]->pfnHandler(sz);
				}
			}
			LeaveSessionList(f);
			return;
		}
	}

	dwFlags = 0;
	pchStop = PchGetParam(sz, "stop", FALSE, FALSE);
	if(pchStop)
		dwFlags |= DM_STOPTHREAD;
	if(FGetNotificationData(sz, &dmts.NotifiedReason, &dmts.u)) {
		if(dmts.NotifiedReason == DM_RIP) {
			const char *pchStr = PchGetParam(sz, "string", TRUE, FALSE);
			if(pchStop && pchStr && pchStop >= pchStr)
				/* Not a legimitate stop */
				dwFlags &= DM_STOPTHREAD;
			dmts.u.DebugStr.String = pchStr;
			if(pchStr)
				SetDmdsSuffixAndLength(NULL, &dmts.u.DebugStr);
		}
		SendNotification(dmts.NotifiedReason | dwFlags, (DWORD)&dmts.u);
		if(dmts.NotifiedReason == DM_ASSERT)
			/* We're done with the assert data now */
			FreeAssertData();
	} else if(!_strnicmp(sz, "execution", cchCmd)) {
		DWORD dwExecPrev = dwExecState;
		if(PchGetParam(sz, "started", FALSE, FALSE))
			dwExecState = DMN_EXEC_START;
		else if(PchGetParam(sz, "stopped", FALSE, FALSE))
			dwExecState = DMN_EXEC_STOP;
		else if(PchGetParam(sz, "pending", FALSE, FALSE))
			dwExecState = DMN_EXEC_PENDING;
		else if(PchGetParam(sz, "rebooting", FALSE, FALSE)) {
			dwExecState = DMN_EXEC_REBOOT;
			/* We're also going to lose our connection here */
			if(pdconNotify)
                ResetConnection(pdconNotify);
			/* We're also going to have to terminate the shared connection */
			CloseSharedConnection(NULL);
		} else
			return; // can't process this one
		/* Only inform of state changes */
		if(dwExecState != dwExecPrev)
			SendNotification(DM_EXEC, dwExecState);
	} else if(!_strnicmp(sz, "debugstr", cchCmd)) {
		DMN_DEBUGSTR dmds;
		const char *pchTok;

		dmds.String = PchGetParam(sz, "string", TRUE, FALSE);
		if(!dmds.String)
			/* If there's no string, there's no point */
			return;
        ((char *)dmds.String)[-1] = 0;
		pchTok = PchGetParam(sz, "thread", TRUE, FALSE);
		if(!FGetDwParamFromSz(pchTok, &dmds.ThreadId))
			dmds.ThreadId = 0;
		pchTok = PchGetParam(sz, "stop", FALSE, FALSE);
		dwFlags &= ~DM_STOPTHREAD;
		if(pchTok)
			dwFlags |= DM_STOPTHREAD;
		SetDmdsSuffixAndLength(sz, &dmds);
		SendNotification(DM_DEBUGSTR | dwFlags, (DWORD)&dmds);
	} else if(!_strnicmp(sz, "create", cchCmd)) {
		DMN_CREATETHREAD dmct;

		if(!FGetDwParam(sz, "thread", &dmct.ThreadId))
			return;
		if(!FGetDwParam(sz, "start", (DWORD*)&dmct.StartAddress))
			dmct.StartAddress = NULL;
		SendNotification(DM_CREATETHREAD | dwFlags, (DWORD)&dmct);
	} else if(!_strnicmp(sz, "terminate", cchCmd)) {
		DWORD tid;
		if(FGetDwParam(sz, "thread", &tid))
			SendNotification(DM_DESTROYTHREAD | dwFlags, tid);
    } else if(!_strnicmp(sz, "modload", cchCmd)) {
        DMN_MODLOAD dmml;

        if(FUnpackDmml(sz, &dmml, TRUE))
            SendNotification(DM_MODLOAD | dwFlags, (DWORD)&dmml);
    } else if(!_strnicmp(sz, "sectload", cchCmd)) {
        DMN_SECTIONLOAD dmsl;

        if(FUnpackDmsl(sz, &dmsl, TRUE))
            SendNotification(DM_SECTIONLOAD | dwFlags, (DWORD)&dmsl);
    } else if(!_strnicmp(sz, "sectunload", cchCmd)) {
        DMN_SECTIONLOAD dmsl;

        if(FUnpackDmsl(sz, &dmsl, TRUE))
            SendNotification(DM_SECTIONUNLOAD | dwFlags, (DWORD)&dmsl);
    } else if(!_strnicmp(sz, "fiber", cchCmd)) {
        DMN_FIBER dmfib;

        if(!FGetDwParam(sz, "id", &dmfib.FiberId))
            return;
        if(FGetDwParam(sz, "start", (PDWORD)&dmfib.StartAddress))
            dmfib.Create = TRUE;
        else if(PchGetParam(sz, "delete", FALSE, TRUE))
            dmfib.Create = FALSE;
        else
            return;
        SendNotification(DM_FIBER | dwFlags, (DWORD)&dmfib);
	}
}

void TerminateNotifyThread(void)
{
	FreeLibraryAndExitThread(hXboxdbg, 0);
}

void ClosePersistentNotification(void)
{
	PDM_CONNECTION s;

    if(sockPersist != INVALID_SOCKET) {
        if(SUCCEEDED(HrOpenSharedConnection(&s))) {
		    char sz[128];
		    sprintf(sz, "notifyat port=%d drop", usPersistPort);
		    DmSendCommand(s, sz, NULL, 0);
    		CloseSharedConnection(s);
        }
		closesocket(sockPersist);
		sockPersist = INVALID_SOCKET;
	}
}

void SatisfyNrqList(HRESULT hr)
{
    PNRQ pnrq;
    BOOL fAsync;

    EnterCriticalSection(&csEnsureNotify);
    while(g_pnrq) {
        pnrq = g_pnrq;
        g_pnrq = pnrq->pnrqNext;
        pnrq->pnrqNext = NULL;
        pnrq->hr = hr;
        if(pnrq->pfn && SUCCEEDED(hr))
            /* We were asked to send exec notification when the connection
             * successfully completed */
            (*pnrq->pfn)(DM_EXEC, dwExecState);
        fAsync = pnrq->fAsync;
        if(pnrq->hevt) {
            SetEvent(pnrq->hevt);
            /* Once we've signaled the event, we can't look at pnrq anymore */
            pnrq = NULL;
        }
        if(fAsync) {
            LocalFree(pnrq);
            pnrq = NULL;
        }
    }
    LeaveCriticalSection(&csEnsureNotify);
}

HRESULT HrMakePersistent()
{
	PDM_CONNECTION s;
	char sz[256];
	struct sockaddr_in sin;
	HRESULT hr;
	BOOL f;
	struct hostent *he;
    DWORD dwPersistFlags;
    PDMN_SESSION psess;

    if(sockPersist != INVALID_SOCKET)
		return XBDM_NOERR;

	/* Make sure we have somebody to talk to */
	s = NULL;
	hr = HrOpenSharedConnection(&s);
	if(FAILED(hr))
		f = FALSE;
	else {
		f = TRUE;
		hr = E_UNEXPECTED;
	}

	/* Make sure we can get a socket */
	if(f)
		f = (sockPersist = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) !=
			INVALID_SOCKET;
	else
		sockPersist = INVALID_SOCKET;
	/* Make sure we can give it a port */
	if(f) {
		sin.sin_family = AF_INET;
		sin.sin_port = 0;
		sin.sin_addr.s_addr = 0;
		f = 0 == bind(sockPersist, (struct sockaddr *)&sin, sizeof sin);
	}
	/* Start listening */
	if(f)
		f = 0 == listen(sockPersist, 2);
	/* And find out where we're listening */
	if(f) {
		int cb = sizeof sin;
		f = 0 == getsockname(sockPersist, (struct sockaddr *)&sin, &cb);
		usPersistPort = ntohs(sin.sin_port);
	}
	/* Make sure we'll know when an incoming connection is ready */
	if(f)
		f = 0 == WSAEventSelect(sockPersist, hevtPersistConn, FD_ACCEPT);

	if(!f && sockPersist != INVALID_SOCKET) {
		closesocket(sockPersist);
		sockPersist = INVALID_SOCKET;
	}

    /* Run down the list of open notification sessions and make sure we
     * build up the appropriate flags */
    dwPersistFlags = 0;
    EnterCriticalSection(&csNotifyList);
    for(psess = psessFirst; psess; psess = psess->psessNext) {
        if(!(psess->dwFlags & DMSESS_DEAD))
            dwPersistFlags |= psess->dwFlags;
    }
    LeaveCriticalSection(&csNotifyList);

	/* Now tell the remote machine that we're listening */
	if(f) {
		sprintf(sz, "NOTIFYAT PORT=%d%s", usPersistPort, dwPersistFlags &
            DM_DEBUGSESSION ? " debug" : "");
		hr = DmSendCommand(s, sz, NULL, NULL);
	}

	if(s)
		CloseSharedConnection(s);

	return hr;
}

HRESULT HrEstablishNotificationConnection()
{
    HRESULT hr;
	HANDLE rgh[2];
	fd_set fds;
    struct timeval tv;
    DWORD tickStart;
    DWORD tickNow;
    int n;

	rgh[0] = hevtPersistConn;
	rgh[1] = hevtTerminate;

	for(;;) {
        /* Make sure we have a persistent connection available */
    	hr = HrMakePersistent();
        if(FAILED(hr))
            return hr;

        /* Wait for 60 seconds for a call to come back.  If we've just opened
         * the notification callback, this should happen instantaneously.
         * If the box is rebooting, it will happen when the reboot is
         * complete */
        tickStart = GetTickCount();
        while((tickNow = GetTickCount()) - tickStart < 60000) {
            n = WaitForMultipleObjects(2, rgh, FALSE, 60000 - (tickNow -
                tickStart));
            if(n == WAIT_OBJECT_0) {
                /* We think we have a pending connection, so attempt to accept
                 * it */
                SOCKET s = accept(sockPersist, NULL, NULL);
			    if(s != INVALID_SOCKET) {
				    pdconNotify = PdconWrapSocket(s);
				    break;
                } else {
                    n = WSAGetLastError();
                    if(n != WSAEINTR && n != WSAEWOULDBLOCK) {
                        /* Our persistent connection somehow died, so reset
                         * it */
                        closesocket(sockPersist);
                        sockPersist = INVALID_SOCKET;
                        break;
                    }
                }
            } else if(n == WAIT_OBJECT_0 + 1) {
                /* We're supposed to terminate.  If we have pending requests
                 * to establish a connection, we'll ignore the request to
                 * terminate so we don't have to spin up another thread again
                 * right away */
                EnterCriticalSection(&csEnsureNotify);
                if(!g_pnrq) {
                    closesocket(sockPersist);
                    sockPersist = INVALID_SOCKET;
                    CloseHandle(hthrNotifier);
                    hthrNotifier = NULL;
                    LeaveCriticalSection(&csEnsureNotify);
                    TerminateNotifyThread();
                }
                LeaveCriticalSection(&csEnsureNotify);
            }
        }

        if(pdconNotify)
            /* We have the desired connection */
            return XBDM_NOERR;

		/* Our persistent channel did us no good, so get rid of it, and
         * try again */
		closesocket(sockPersist);
		sockPersist = INVALID_SOCKET;
    }
}

DWORD WINAPI NotifyThread(LPVOID unused)
{
	char szBuf[4096];
	int cbBuf;
	BOOL fSkipString = FALSE;
	HANDLE rgh[4];
	DWORD dwWait;
    NRQ *pnrq;
    HRESULT hr;

	rgh[0] = hevtSockData;
	rgh[1] = hevtNRQ;
	rgh[2] = hevtPersistConn;
	rgh[3] = hevtTerminate;

	for(;;) {
		/* Make sure we've got a socket to listen on */
        hr = HrEstablishNotificationConnection();
        
        /* Run down any pending list of notification requests */
        EnterCriticalSection(&csEnsureNotify);
        SatisfyNrqList(hr);
        ResetEvent(hevtNRQ);
        if(FAILED(hr)) {
            /* We failed to establish a notification connection, so we're
             * going to shut down the thread */
            ClosePersistentNotification();
            CloseHandle(hthrNotifier);
            hthrNotifier = NULL;
            LeaveCriticalSection(&csEnsureNotify);
			TerminateNotifyThread();
        }

		ResetEvent(hevtSockData);
		if(0 != WSAEventSelect(pdconNotify->s, hevtSockData, FD_READ)) {
			/* Act as if no socket */
            ResetConnection(pdconNotify);
			DmCloseConnection(pdconNotify);
			pdconNotify = NULL;
		}
        LeaveCriticalSection(&csEnsureNotify);

		/* Now we just wait until we've got a big enough line to do something
		 * with, or until some other notable event happens */
		cbBuf = 0;
		while(pdconNotify && pdconNotify->s != INVALID_SOCKET) {
			/* Look for something to do */
			if(pdconNotify->ibBuf < pdconNotify->cbBuf)
				dwWait = WAIT_OBJECT_0;
			else
				dwWait = WaitForMultipleObjects(4, rgh, FALSE, INFINITE);
			switch(dwWait) {
			case WAIT_OBJECT_0:
				if(pdconNotify->ibBuf >= pdconNotify->cbBuf) {
					int cb;
					/* Data to receive */
					cb = recv(pdconNotify->s, pdconNotify->rgbBuf, sizeof
						pdconNotify->rgbBuf - 1, 0);
					if(cb <= 0) {
						switch(WSAGetLastError()) {
						case WSAEINTR:
						case WSAEWOULDBLOCK:
							break;
						default:
							/* Lost the connection.  Close it and prepare for
							 * it to be opened again next time we need to
							 * ensure notification */
                            ResetConnection(pdconNotify);
							break;
						}
						cb = 0;
					}
					pdconNotify->cbBuf = cb;
					pdconNotify->ibBuf = 0;
				}
				/* Let's see if we have a delimiting character in the data that
				 * just came in */
				while(pdconNotify && pdconNotify->ibBuf < pdconNotify->cbBuf) {
					szBuf[cbBuf] = pdconNotify->rgbBuf[pdconNotify->ibBuf++];
					if(szBuf[cbBuf] == '\012' || szBuf[cbBuf] == '\015') {
						/* We've got a string, but process it only if it's not
						 * the tail end of some other data */
						szBuf[cbBuf++] = 0;
						if(!fSkipString)
							HandleNotification(szBuf);
						/* Now shift out the data that we've processed */
						cbBuf = 0;
					} else
						++cbBuf;
					if(cbBuf == sizeof szBuf - 1) {
						/* We never got the newline, so we'll just process what
						 * we have and discard the rest when it gets here */
						szBuf[cbBuf] = 0;
						if(!fSkipString)
							HandleNotification(szBuf);
						cbBuf = 0;
						fSkipString = TRUE;
					}
				}
				break;
			case WAIT_OBJECT_0 + 2:
				/* We got a new incoming connection.  That means that the
				 * remote machine rebooted without telling us.  Synthesize
				 * a reboot notification, which will close the connection */
				HandleNotification("execution rebooting");
				/* We also need to set the event again, because our call to
				 * wait caused a reset and we're going to wait again before
				 * calling accept */
				SetEvent(rgh[2]);
				break;
			case WAIT_OBJECT_0 + 3:
				/* We're going to go away now.  Close the existing connection.
                 * If we find a pending request to get a notifier, then we
                 * won't really exit, since our continued existence has been
                 * demanded.  Otherwise, we'll quit */
                EnterCriticalSection(&csEnsureNotify);
                if(!g_pnrq) {
                    ResetConnection(pdconNotify);
                    DmCloseConnection(pdconNotify);
                    ClosePersistentNotification();
    				pdconNotify = NULL;
                    CloseHandle(hthrNotifier);
                    hthrNotifier = NULL;
                    LeaveCriticalSection(&csEnsureNotify);
				    TerminateNotifyThread();
                }
                LeaveCriticalSection(&csEnsureNotify);
                // fall through
			case WAIT_OBJECT_0 + 1:
                /* We've been asked to ensure the notifier.  Walk down the
                 * request list.  If we have any reset requests, then we'll
                 * close the current connection and leave the requests
                 * pending.  Otherwise we'll satisfy them all */
                EnterCriticalSection(&csEnsureNotify);
                for(pnrq = g_pnrq; pnrq; pnrq = pnrq->pnrqNext) {
                    if(pnrq->fReset) {
                        ResetConnection(pdconNotify);
                        ClosePersistentNotification();
                    }
                }
                if(pdconNotify->s != INVALID_SOCKET)
                    SatisfyNrqList(XBDM_NOERR);
				ResetEvent(rgh[1]);
                LeaveCriticalSection(&csEnsureNotify);
                break;
            }
		}
	    if(pdconNotify && pdconNotify->s == INVALID_SOCKET) {
		    DmCloseConnection(pdconNotify);
		    pdconNotify = NULL;
	    }
    }
}

void StopAllNotifications(void)
{
    /* The notification thread will do all of the real cleanup */
	if(hthrNotifier)
		SetEvent(hevtTerminate);
}

void InitNotificationEvents(void)
{
	InitializeCriticalSection(&g_sci.csSharedConn);
	InitializeCriticalSection(&csNotifyList);
	InitializeCriticalSection(&csEnsureNotify);
	InitializeCriticalSection(&csAssert);
	hevtSockData = CreateEvent(NULL, FALSE, FALSE, NULL);
	hevtNRQ = CreateEvent(NULL, TRUE, FALSE, NULL);
	hevtPersistConn = CreateEvent(NULL, FALSE, FALSE, NULL);
	hevtTerminate = CreateEvent(NULL, FALSE, FALSE, NULL);
}

void DestroyNotificationEvents(void)
{
	CloseHandle(hevtSockData);
	CloseHandle(hevtNRQ);
	CloseHandle(hevtPersistConn);
	CloseHandle(hevtTerminate);
	DeleteCriticalSection(&g_sci.csSharedConn);
	DeleteCriticalSection(&csNotifyList);
	DeleteCriticalSection(&csEnsureNotify);
	DeleteCriticalSection(&csAssert);
}

HRESULT HrEnsureNotifier(BOOL fReset, BOOL fAsync, PDM_NOTIFY_FUNCTION pfn)
{
    HRESULT hr;
    NRQ nrq;
    PNRQ pnrq;

    /* For synchronization reasons, only the notification thread is allowed to
     * actually establish notification connections.  So we post a request
     * to it and wait for it to complete */
    if(fAsync) {
        pnrq = LocalAlloc(LMEM_FIXED, sizeof nrq);
        pnrq->grfFlags = 0;
        if(!pnrq)
            return E_OUTOFMEMORY;
        pnrq->fAsync = TRUE;
        pnrq->hevt = NULL;
    } else {
        pnrq = &nrq;
        pnrq->grfFlags = 0;
        pnrq->hevt = CreateEvent(NULL, FALSE, FALSE, NULL);
    }
    pnrq->fReset = !!fReset;
    pnrq->pfn = pfn;
    EnterCriticalSection(&csEnsureNotify);
    pnrq->pnrqNext = g_pnrq;
    g_pnrq = pnrq;

    /* Before we kick off this request, we need to make sure we actually have a
     * notification thread ready to handle it */
	if(!hthrNotifier) {
		char szFileName[MAX_PATH + 1];
		HMODULE hmod;

		if(!GetModuleFileName(hXboxdbg, szFileName, sizeof szFileName))
			hr = E_UNEXPECTED;
		else {
			hmod = LoadLibrary(szFileName);
			if(hmod == hXboxdbg)
				hr = XBDM_NOERR;
			else {
				hr = E_UNEXPECTED;
				if(hmod)
					FreeLibrary(hmod);
			}
		}
		if(SUCCEEDED(hr)) {
			hthrNotifier = CreateThread(NULL, 0, NotifyThread, NULL,
				CREATE_SUSPENDED, NULL);
			if(!hthrNotifier) {
				hr = E_UNEXPECTED;
				FreeLibrary(hXboxdbg);
			} else
				ResumeThread(hthrNotifier);
		}

        /* If we failed to create the thread, then we walk down the pending
         * request list and mark them all as failed */
        if(FAILED(hr))
            SatisfyNrqList(hr);
    }

    LeaveCriticalSection(&csEnsureNotify);

    /* Now tell the the notification thread to process the queue */
    SetEvent(hevtNRQ);

    /* If this was an async request, we'll return success */
    if(fAsync)
        return XBDM_NOERR;

    /* Wait for our request to be handled.  If we failed to create the
     * thread, it was handled in the loop above. */
    WaitForSingleObject(nrq.hevt, INFINITE);
    CloseHandle(nrq.hevt);

	return nrq.hr;
}

HRESULT DmOpenNotificationSession(DWORD dwFlags, PDMN_SESSION *ppsess)
{
	HRESULT hr;

	if(!ppsess)
		return E_INVALIDARG;

    if(dwFlags & DMSESS_MSVC) {
        PDMN_SESSION psess;
        /* This is VC trying to recycle a previously allocated session.  See
         * if we can find it */
        EnterCriticalSection(&csNotifyList);
        for(psess = psessFirst; psess; psess = psess->psessNext)
            if((psess->dwFlags & (DMSESS_MSVC | DMSESS_DEAD)) == DMSESS_MSVC)
                break;
        LeaveCriticalSection(&csNotifyList);
        if(psess) {
            *ppsess = psess;
            return HrEnsureNotifier(TRUE, dwFlags & DM_ASYNCSESSION, NULL);
        }
    }
	*ppsess = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, sizeof(DMN_SESSION));
	if(!*ppsess)
		return E_OUTOFMEMORY;
	(*ppsess)->dwFlags = dwFlags;
	(*ppsess)->dwSig = 'xnot';
	EnterCriticalSection(&csNotifyList);
	(*ppsess)->psessNext = psessFirst;
	psessFirst = *ppsess;
	LeaveCriticalSection(&csNotifyList);
	hr = HrEnsureNotifier(FALSE, dwFlags & DM_ASYNCSESSION, NULL);
    if(FAILED(hr)) {
        /* Failed to get the notifier, so nuke this session */
        (*ppsess)->dwFlags |= DMSESS_DEAD;
        *ppsess = NULL;
        LeaveSessionList(FEnterSessionList());
	}
	return hr;
}

HRESULT DmCloseNotificationSession(PDMN_SESSION psess)
{
	PDMN_SESSION *ppsess;
	BOOL f;

	if(!psess || psess->dwSig != 'xnot')
		return E_INVALIDARG;

	f = FEnterSessionList();
	psess->dwFlags |= DMSESS_DEAD;
	LeaveSessionList(f);

	return XBDM_NOERR;
}

HRESULT DmNotify(PDMN_SESSION psess, DWORD dw, PDM_NOTIFY_FUNCTION pfnHandler)
{
	HRESULT hr;

	if(!psess || psess->dwSig != 'xnot')
		return E_INVALIDARG;

    if(dw != DM_NONE) {
	    hr = HrEnsureNotifier(FALSE, psess->dwFlags & DM_ASYNCSESSION, NULL);
        if(FAILED(hr))
		    return hr;
    }

	EnterCriticalSection(&csNotifyList);
	if(dw == DM_NONE) {
		if(pfnHandler) {
            /* We need to remove this handler from all of the lists */
			for(dw = 0; dw < DM_NOTIFYMAX; ++dw) {
				int ifn;

				for(ifn = 0; ifn < psess->rgcfnNotify[dw]; ++ifn) {
					if(psess->rgpfnNotify[dw][ifn] == pfnHandler)
						psess->rgpfnNotify[dw][ifn--] =
							psess->rgpfnNotify[dw][--psess->rgcfnNotify[dw]];
				}
			}
		} else {
		    /* We need to empty all lists */
			for(dw = 0; dw < DM_NOTIFYMAX; ++dw)
			    psess->rgcfnNotify[dw] = 0;
        }
		hr = XBDM_NOERR;
	} else if(dw <= DM_NOTIFYMAX && pfnHandler) {
		PDMN_SESSION psessT = NULL;
		int cfn = 0;

		--dw;

#if 0
		/* If this function is on any lists already, then we do less work */
		for(psessT = psessFirst; psessT; psessT = psessT->psessNext) {
			cfn = psessT->rgcfnNotify[dw];
			while(cfn--) {
				if(psessT->rgpfnNotify[dw][cfn] == pfnHandler)
					break;
			}
		}
#endif

		if(psess != psessT) {
			if(psess->rgcfnNotify[dw] == MAX_NOTIFY)
				hr = E_OUTOFMEMORY;
			else {
				psess->rgpfnNotify[dw][psess->rgcfnNotify[dw]++] = pfnHandler;
				if(psessT)
					/* Take it off the other list */
					psessT->rgpfnNotify[dw][cfn] =
						psessT->rgpfnNotify[dw][--psessT->rgcfnNotify[dw]];
                else if(dw+1 == DM_EXEC) {
					/* This is a special case and every new handler has to be
					 * immediately informed of the current state, if
					 * available -- except that async handlers only get
                     * called once a connection is available */
                     if(psess->dwFlags & DM_ASYNCSESSION)
                         HrEnsureNotifier(FALSE, TRUE, pfnHandler);
                     else
                        (*pfnHandler)(DM_EXEC, dwExecState);
                }
			}
		}
		hr = XBDM_NOERR;
	} else
		hr = E_INVALIDARG;
	LeaveCriticalSection(&csNotifyList);
	return hr;
}

HRESULT DmRegisterNotificationProcessor(PDMN_SESSION psess, LPCSTR sz,
	PDM_EXT_NOTIFY_FUNCTION pfn)
{
	int ienh;
	ENH *penh;
	HRESULT hr;

	if (!psess || psess->dwSig != 'xnot')
		return E_INVALIDARG;
    if(pfn && !sz)
        return E_INVALIDARG;

	EnterCriticalSection(&csNotifyList);
    if(!pfn) {
        /* We're unregistering.  If we have a string, then only unhook those
         * handlers that match the string */
        for(ienh = 0; ienh < MAX_ENH; ++ienh) {
            if(psess->rgpenh[ienh]) {
                if(sz && _stricmp(psess->rgpenh[ienh]->szExtName, sz))
                    continue;
                LocalFree(psess->rgpenh[ienh]);
                psess->rgpenh[ienh] = NULL;
            }
        }
		hr = XBDM_NOERR;
    } else {
	    /* Let's find somewhere to put it */
	    for(ienh = 0; ienh < MAX_ENH; ++ienh)
		    if(!psess->rgpenh[ienh])
			    break;
	    if(ienh < MAX_ENH) {
		    penh = LocalAlloc(LMEM_FIXED, sizeof *penh);
	    } else
		    penh = NULL;
	    if(penh) {
		    int ich;

		    for(ich = 0; sz[ich] && ich < sizeof penh->szExtName - 1; ++ich)
			    penh->szExtName[ich] = sz[ich];
		    if(sz[ich]) {
			    LocalFree(penh);
			    hr = E_INVALIDARG;
		    } else {
			    penh->szExtName[ich] = 0;
			    penh->pfnHandler = pfn;
			    psess->rgpenh[ienh] = penh;
			    hr = XBDM_NOERR;
		    }
        } else
		    hr = E_OUTOFMEMORY;
    }
	LeaveCriticalSection(&csNotifyList);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbshlext\attrib.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    attrib.cpp

Abstract:

    Implementation of 


Environment:

    Windows 2000 and Later 
    User Mode

Revision History:
    
    06-11-2001 : created (mitchd)

--*/
#include "stdafx.h"

CGetAttributes::CGetAttributes(
    XBOX_MULTIFILE_ATTRIBUTES *pAttributes,
    bool fGetTypeName,
    GET_ATTRIBUTES_CB pfnCallback,
    PVOID pvCallback
    ) :
    m_pAttributes(pAttributes),
    m_fGetTypeName(fGetTypeName),
    m_pfnCallback(pfnCallback),
    m_pvCallback(pvCallback),
    m_fVariousFileTypes(false),
    m_fFirstItem(true)
{
   HRESULT hr;
   m_pAttributes->dwFileCount = 0;
   m_pAttributes->dwFolderCount = 0;
   m_pAttributes->dwValidAttributes = FILE_ATTRIBUTE_READONLY|FILE_ATTRIBUTE_HIDDEN;
   m_pAttributes->ullTotalSize = 0;
}

void
CGetAttributes::VisitFileOrDir(
    IXboxFileOrDirVisit *pFileOrDir, 
    DWORD *pdwFlags
)
{
    HRESULT hr;
    DM_FILE_ATTRIBUTES dmAttributes;
     
    //
    //  Even for a set operation, we need to get the existing
    //  attributes first.
    //

    pFileOrDir->GetFileAttributes(&dmAttributes);
    
    //
    //  Count files and folder.
    //  

    if(dmAttributes.Attributes&FILE_ATTRIBUTE_DIRECTORY)
    {
        m_pAttributes->dwFolderCount++;  
    } else
    {
        m_pAttributes->dwFileCount++;
    }

    //
    //  If this is the first item just copy everything.
    //
    if(m_fFirstItem)
    {
        m_fFirstItem = false;
        m_pAttributes->CreationTime = dmAttributes.CreationTime;
        m_pAttributes->ChangeTime = dmAttributes.ChangeTime;
        m_pAttributes->dwAttributes = dmAttributes.Attributes;
        if(m_fGetTypeName)
        {
            if(dmAttributes.Attributes&FILE_ATTRIBUTE_DIRECTORY)
            {
                strcpy(
                    m_pAttributes->szTypeName, 
                    WindowUtils::GetPreloadedString(IDS_PRELOAD_FOLDER_TYPE_NAME)
                    );
            }else
            {
                SHFILEINFOA shellFileInfo;
                pFileOrDir->GetName(shellFileInfo.szDisplayName);
                shellFileInfo.dwAttributes = dmAttributes.Attributes;
                if(SHGetFileInfoA(
                    shellFileInfo.szDisplayName,
                    dmAttributes.Attributes,
                    &shellFileInfo,
                    sizeof(shellFileInfo),
                    SHGFI_USEFILEATTRIBUTES | SHGFI_TYPENAME
                    )
                )
                {
                    strcpy(m_pAttributes->szTypeName, shellFileInfo.szTypeName);                
                }
            }
        }

    } else
    {   
        
        //
        //  Clear the correct valid bits and OR the bits.
        //

        m_pAttributes->dwValidAttributes &= ~(m_pAttributes->dwAttributes^dmAttributes.Attributes);
        m_pAttributes->dwAttributes |= dmAttributes.Attributes;

        //
        //  Handle the type name.
        //

        if(m_fGetTypeName && !m_fVariousFileTypes)
        {
            if(dmAttributes.Attributes&FILE_ATTRIBUTE_DIRECTORY)
            {
                if(m_pAttributes->dwFileCount)
                {
                    m_fVariousFileTypes = true;
                    LoadStringA(
                        _Module.GetModuleInstance(),
                        IDS_FILETYPE_VARIOUS,
                        m_pAttributes->szTypeName,
                        MAX_PATH
                        );
                }
            }else
            {
                if(m_pAttributes->dwFolderCount)
                {
                    m_fVariousFileTypes = true;
                    LoadStringA(
                        _Module.GetModuleInstance(),
                        IDS_FILETYPE_VARIOUS,
                        m_pAttributes->szTypeName,
                        MAX_PATH
                        );
                } else
                {
                    SHFILEINFOA shellFileInfo;
                    pFileOrDir->GetName(shellFileInfo.szDisplayName);
                    shellFileInfo.dwAttributes = dmAttributes.Attributes;
                    if(SHGetFileInfoA(
                        shellFileInfo.szDisplayName,
                        dmAttributes.Attributes,
                        &shellFileInfo,
                        sizeof(shellFileInfo),
                        SHGFI_USEFILEATTRIBUTES | SHGFI_TYPENAME
                        )
                    )
                    {
                        if(strcmp(m_pAttributes->szTypeName, shellFileInfo.szTypeName))
                        {
                            m_fVariousFileTypes = true;
                            LoadStringA(
                                _Module.GetModuleInstance(),
                                IDS_FILETYPE_VARIOUS,
                                m_pAttributes->szTypeName,
                                MAX_PATH
                                );
                        }
                    }

                }
            }
        }
    }
    
    //
    //  Sum in the size.
    //
    ULARGE_INTEGER uliSize;
    uliSize.HighPart = dmAttributes.SizeHigh;
    uliSize.LowPart = dmAttributes.SizeLow;
    m_pAttributes->ullTotalSize +=  uliSize.QuadPart;

    //
    //  Report Progress
    //

    if(m_pfnCallback)
    {
       if(!m_pfnCallback(m_pvCallback, m_pAttributes))
       {
           //
           //   Stop visiting if callback tells us to.
           //
           *pdwFlags = 0;
       }
    }
}

void CSetAttributes::VisitFileOrDir(IXboxFileOrDirVisit *pFileOrDir, DWORD *)
{
    DM_FILE_ATTRIBUTES dmFileAttributes;
    DWORD              dwOldAttributes;

    LPITEMIDLIST pidl = pFileOrDir->GetPidl(CPidlUtils::PidlTypeAbsolute);

    pFileOrDir->GetFileAttributes(&dmFileAttributes);

    dwOldAttributes = dmFileAttributes.Attributes;
    dmFileAttributes.Attributes &= ~m_dwClearAttributes;
    dmFileAttributes.Attributes |= m_dwSetAttributes;
    
    if(dmFileAttributes.Attributes != dwOldAttributes)
    {
        if(0==dmFileAttributes.Attributes)
        {
            dmFileAttributes.Attributes = FILE_ATTRIBUTE_NORMAL;
        }
        HRESULT hr=pFileOrDir->SetFileAttributes(&dmFileAttributes);
        if(SUCCEEDED(hr))
        {
            SHChangeNotify(SHCNE_ATTRIBUTES, SHCNF_FLUSH|SHCNF_IDLIST, pidl, 0);
            CPidlUtils::Free(pidl);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbshlext\attrib.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    attrib.h

Abstract:

    Declaration  of CGetAttributes and CSetAttributes.

Environment:

    Windows 2000 and Later 
    User Mode

Revision History:
    
    06-11-2001 : created (mitchd)

--*/

//
//  Message sent by CGetAttributes to update the progress of retrieving the attributes
//

struct XBOX_MULTIFILE_ATTRIBUTES
{
    DWORD     dwAttributes;      //Attribute Flags
    DWORD     dwValidAttributes;
    DWORD     dwFileCount;
    DWORD     dwFolderCount;
    ULONGLONG ullTotalSize;
    char      szTypeName[MAX_PATH];  //Get Type name
    FILETIME  ChangeTime;            //If one file
    FILETIME  CreationTime;          //If one file.
};

typedef bool (*GET_ATTRIBUTES_CB)(PVOID pv, XBOX_MULTIFILE_ATTRIBUTES *pAttributes);
class CGetAttributes : public IXboxVisitor
{
  public:
      
    CGetAttributes(XBOX_MULTIFILE_ATTRIBUTES *pAttributes, bool fGetTypeName = true, GET_ATTRIBUTES_CB pfnCallback = NULL, PVOID pvCallback = NULL);

    //
    //  These methods should never be hit.
    //
    void VisitRoot          (IXboxVisit *pRoot,               DWORD *pdwFlags){};
    void VisitAddConsole    (IXboxVisit *pAddConsole,         DWORD *pdwFlags){};
    void VisitConsole       (IXboxConsoleVisit   *pConsole,   DWORD *pdwFlags){};
    void VisitVolume        (IXboxVolumeVisit    *pVolume,    DWORD *pdwFlags){};
    void VisitDirectoryPost (IXboxFileOrDirVisit *pFileOrDir, DWORD *pdwFlags){};

    //
    //  Get or set the attributes.
    //

    void VisitFileOrDir    (IXboxFileOrDirVisit *pFileOrDir,  DWORD *pdwFlags);
    
    private:
      XBOX_MULTIFILE_ATTRIBUTES *m_pAttributes;
      GET_ATTRIBUTES_CB          m_pfnCallback;
      PVOID                      m_pvCallback;
      bool                       m_fGetTypeName;
      bool                       m_fVariousFileTypes;
      bool                       m_fFirstItem;
};


class CSetAttributes : public IXboxVisitor
{
  public:
      
    CSetAttributes(DWORD dwSetAttributes, DWORD dwClearAttributes) :
        m_dwSetAttributes(dwSetAttributes), m_dwClearAttributes(dwClearAttributes)
        {}

    //
    //  These methods should never be hit.
    //
    void VisitRoot          (IXboxVisit *pRoot,               DWORD *pdwFlags){};
    void VisitAddConsole    (IXboxVisit *pAddConsole,         DWORD *pdwFlags){};
    void VisitConsole       (IXboxConsoleVisit   *pConsole,   DWORD *pdwFlags){};
    void VisitVolume        (IXboxVolumeVisit    *pVolume,    DWORD *pdwFlags){};
    void VisitDirectoryPost (IXboxFileOrDirVisit *pFileOrDir, DWORD *pdwFlags){};

    //
    //  Get or set the attributes.
    //

    void VisitFileOrDir    (IXboxFileOrDirVisit *pFileOrDir,  DWORD *pdwFlags);
    
    private:
     DWORD m_dwSetAttributes;
     DWORD m_dwClearAttributes;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbshlext\atlimp.cpp ===
// stdafx.cpp : source file that includes just the standard includes
// stdafx.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbshlext\console.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    console.cpp

Abstract:

   Declaration of CManageConsoles

Environment:

    Windows 2000 and Later 
    User Mode
    Compiles UNICODE, but uses many ANSI APIs explictly.

Revision History:
    
    06-29-2001 : created

--*/

class CManageConsoles
{
  public:
    CManageConsoles();
    ~CManageConsoles();

    //  Add Remove
    BOOL Add(LPSTR pszConsoleName);
    BOOL Remove(LPSTR pszConsoleName);

    //  Set default
    BOOL SetDefault(LPSTR pszConsoleName);
    BOOL IsDefault(LPSTR pszConsoleName);
    //  Enum
    void  ResetEnum() {m_dwEnumIndex=0;}
    BOOL  GetNext(LPSTR pszConsoleName, DWORD *pdwConsoleNameLength);
    DWORD GetMaxCount() {return m_dwMaxCount;}
  private:
    HKEY  m_hKey;
    DWORD m_dwEnumIndex;
    DWORD m_dwMaxCount;
    char  m_szDefaultConsole[60];
    bool  m_fDefaultConsoleValid;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbshlext\console.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    console.cpp

Abstract:

   Implementation of CManageConsoles.  Handles the registry with respect to consoles.

Environment:

    Windows 2000 and Later 
    User Mode
    Compiles UNICODE, but uses many ANSI APIs explictly.

Revision History:
    
    06-29-2001 : created

--*/
#include <stdafx.h>

CManageConsoles::CManageConsoles() : 
    m_hKey(NULL),
    m_dwEnumIndex(0),
    m_dwMaxCount(0),
    m_fDefaultConsoleValid(false)
{
    DWORD   dwBogus;
    DWORD   dwBufferSize;
    LONG    lError;
    
    //
    //  Get the name of the default console
    //
    dwBufferSize = sizeof(m_szDefaultConsole);
    if(SUCCEEDED(DmGetXboxName(m_szDefaultConsole, &dwBufferSize)))
    {
        m_fDefaultConsoleValid = true;
    }

    //
    //  Open\Create the console key
    //
    lError =  RegCreateKeyExA(
                  HKEY_CURRENT_USER,
                  XBOX_SHELL_EXTENSION_CONSOLE_KEY,
                  0,
                  NULL,
                  REG_OPTION_NON_VOLATILE,
                  KEY_ALL_ACCESS,
                  NULL,
                  &m_hKey,
                  NULL
                  );
    if(ERROR_SUCCESS!=lError)
    {
        m_hKey = NULL;
        return;
    }
    
    //
    //  Read the number of consoles
    //
    dwBufferSize = sizeof(DWORD);
    lError = RegQueryValueExA(m_hKey, NULL, NULL, NULL, (PBYTE)&m_dwMaxCount, &dwBufferSize);
    if(ERROR_SUCCESS!=lError)
    {
        m_dwMaxCount = 0;
        RegSetValueEx(m_hKey, NULL, 0, REG_DWORD, (BYTE *)&m_dwMaxCount, sizeof(m_dwMaxCount));
    }

    //
    // Add the default console, note Add is smart enough not to add it, if
    // it is already known.
    //
    if(m_fDefaultConsoleValid)
    {
        Add(m_szDefaultConsole);        
    }
}

CManageConsoles::~CManageConsoles()
{
    if(m_hKey)
    {
        RegCloseKey(m_hKey);
        m_hKey = NULL;
    }
}

BOOL CManageConsoles::Add(LPSTR pszConsoleName)
{
    DWORD dwBogus;
    DWORD dwBufferSize;
    LONG  lError;

    //
    //  Can't do anything if we don't have a key.
    //
    if(!m_hKey) return FALSE;

    //
    //  First, see if the console is already known.
    //
    dwBufferSize = sizeof(dwBogus);
    lError = RegQueryValueExA(
                m_hKey,
                pszConsoleName,
                NULL,
                NULL,
                (PBYTE)&dwBogus,
                &dwBufferSize
                );
    //
    //  If the console is not already known,
    //  add it.
    //
    if(lError != ERROR_SUCCESS)
    {
        lError = RegSetValueExA(
                    m_hKey,
                    pszConsoleName,
                    0,
                    REG_DWORD,
                    (BYTE *)&dwBogus,
                    sizeof(dwBogus)
                    );
        if(ERROR_SUCCESS == lError)
        {
            //
            //  Increment the count of know consoles.
            //
            
            m_dwMaxCount++;
            lError = RegSetValueExA(
                m_hKey,
                NULL,
                0,             
                REG_DWORD,
                (BYTE *)&m_dwMaxCount,
                sizeof(DWORD)
                );
        }
    }

    //
    //  Return our results
    //
    return (ERROR_SUCCESS==lError) ? TRUE : FALSE;
}

BOOL CManageConsoles::Remove(LPSTR pszConsoleName)
{
    DWORD dwBogus = 0;
    DWORD dwBufferSize;
    LONG  lError;

    //
    //  Can't do anything if we don't have a key.
    //
    if(!m_hKey) return FALSE;

    //
    //  If the console is the default console, we must fail.
    //

    if(IsDefault(pszConsoleName))
    {
        return FALSE;
    }

    //
    //  First, see if the console is already known.
    //
    dwBufferSize = sizeof(dwBogus);
    lError = RegQueryValueExA(
                m_hKey,
                pszConsoleName,
                NULL,
                NULL,
                (PBYTE)&dwBogus,
                &dwBufferSize
                );
    //
    //  If the console is known remove it.
    //  
    //
    if(lError == ERROR_SUCCESS)
    {
        lError = RegDeleteValueA(m_hKey, pszConsoleName);      
        if(lError == ERROR_SUCCESS)
        {
            m_dwMaxCount--;
            RegSetValueExA(
                m_hKey,
                NULL,
                0,             
                REG_DWORD,
                (BYTE *)&m_dwMaxCount,
                sizeof(DWORD)
                );
        }
    } else
    {
        // Return success, as there was no need to delete it realy.
        return TRUE;
    }

    // Return success or failure
    return (ERROR_SUCCESS==lError) ? TRUE : FALSE;
}

BOOL CManageConsoles::SetDefault(LPSTR pszConsoleName)
{
    HRESULT hr = E_FAIL;
    
    // Make sure that this has been add first.
    if(pszConsoleName)
    {
        if(Add(pszConsoleName))
        {
            hr = DmSetXboxName(pszConsoleName);
        }
    } else
    {
        hr = DmSetXboxName("");
    }
    
    // Send notification to clear check on current default.
    WCHAR szPath[512];

    if(*m_szDefaultConsole)
    {
        wsprintf(szPath, L"%hs\\%hs", ROOT_GUID_NAME, m_szDefaultConsole);
        SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_PATH|SHCNF_FLUSH, szPath, NULL);
    }
    
    // Handle new name
    if(pszConsoleName)
    {
        strcpy(m_szDefaultConsole, pszConsoleName);
    
        //Notification of new default
        wsprintf(szPath, L"%hs\\%hs", ROOT_GUID_NAME, pszConsoleName);
        SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_PATH|SHCNF_FLUSH, szPath, NULL);
    } else
    {
        m_szDefaultConsole[0] = '\0';
    }

    return SUCCEEDED(hr) ? TRUE : FALSE;
}

BOOL CManageConsoles::IsDefault(LPSTR pszConsoleName)
{
    if(m_fDefaultConsoleValid && (0==_stricmp(pszConsoleName, m_szDefaultConsole)))
    {
        return TRUE;
    }
    
    return FALSE;
}


BOOL CManageConsoles::GetNext(LPSTR pszConsoleName, DWORD *pdwConsoleNameLength)
{
    LONG lError; 
    DWORD dwConsoleNameLength = *pdwConsoleNameLength;
    do
    {
       *pdwConsoleNameLength = dwConsoleNameLength;
       lError = RegEnumValueA(
                   m_hKey,
                   m_dwEnumIndex++,
                   pszConsoleName,
                   pdwConsoleNameLength,
                   NULL,// reserved
                   NULL,// don't want the value type
                   NULL,// or the value
                   NULL // or the value size.
                   );
       // Don't accept the default value as a console name
    }while((ERROR_SUCCESS==lError)&& (*pszConsoleName=='\0'));

    return (ERROR_SUCCESS==lError) ? TRUE : FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbshlext\CXboxStream.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:     CXboxStream.cpp
// Contents: Implementation of CXboxStream.  CXboxStream handles streaming data of a single file
//           across the wire.
// Revision History:
//           04-26-2001 : Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CXboxStream::CXboxStream
// Purpose:   CXboxStream constructor
// Arguments: pixbconn          -- A connection to the xbox that we are streaming from.
//            tszRootFolder     -- The name of the folder that the object exists in.  This will be
//                                 of the form "XE:\Samples\BumpLens".
//            tszFile           -- The file we'll be streaming.  Note that it may exist in a subfolder
//                                 of the root folder.  An example would be "Media\Textures\Lake.bmp"
// Return:    None.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CXboxStream::CXboxStream() : m_cRef(1)
{
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CXboxStream::~CXboxStream
// Purpose:   CXbox destructor
// Arguments: None.
// Return:    None.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CXboxStream::~CXboxStream()
{
    //
    // Close the file if we managed to open it.
    //
    if(m_hFile)
    {
        CloseHandle(m_hFile);
    }
    
    //
    //  Delete the file, if we were asked to.
    //
    if(m_fDeleteOnFinalRelease)
    {
        DeleteFileA(m_szFilename);
    }
}


HRESULT CXboxStream::Initialize(LPCSTR pszFilename, bool fDeleteOnFinalRelease)
{
    HRESULT hr = S_OK;
    m_fDeleteOnFinalRelease = fDeleteOnFinalRelease;
    strcpy(m_szFilename, pszFilename);

    m_hFile = CreateFileA(
                m_szFilename,
                FILE_GENERIC_READ,
                0,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                0);

    if(INVALID_HANDLE_VALUE==m_hFile)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ IUNKNOWN METHODS ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CXboxStream::QueryInterface
// Purpose:   Obtain a particular interface to this object.
// Arguments: riid          -- The interface to this object being queried for.
//            ppvObject     -- Buffer to fill with obtained interface.
// Return:    S_OK if interface obtained; E_NOINTERFACE otherwise.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CXboxStream::QueryInterface(REFIID riid, void **ppvObject)
{ 
    *ppvObject = NULL;

    if (riid == IID_IUnknown) 
        *ppvObject = this;
    else if (riid == IID_IStream) 
        *ppvObject = static_cast<IStream*>(this);
    else
        return E_NOINTERFACE;

    if (*ppvObject)
    {
        static_cast<LPUNKNOWN>(*ppvObject)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}   

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CXboxStream::AddRef
// Purpose:   Add a reference to this object
// Arguments: None
// Return:    New reference count
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP_(ULONG) CXboxStream::AddRef()
{
    // Verify that we initialized properly
    return (ULONG)InterlockedIncrement(&m_cRef);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CXboxStream::Release
// Purpose:   Subtract a reference to this object.  If the new number of references is zero, then
//            delete the object.
// Arguments: None
// Return:    New reference count.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP_(ULONG) CXboxStream::Release()
{
    // Verify that we initialized properly
    if (0 == InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return (ULONG)m_cRef;
}


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ IMPLEMENTED ISTREAM METHODS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CXboxStream::Read
// Purpose:   Read a string of bytes.
// Arguments: pv            -- Buffer into which the bytes are read.
//            cb            -- Number of bytes to read
//            pcbRead       -- Number of bytes actually read.
// Return:    S_OK if successful; error code otherwise.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CXboxStream::Read(void *pv, ULONG cb, ULONG *pcbRead)
{
    // Read the bits from our source file.
    if (!ReadFile(m_hFile, pv, cb, pcbRead, NULL))
        return GetLastError();

    return S_OK;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CXboxStream::Read
// Purpose:   Read a string of bytes.
// Arguments: pv            -- Buffer into which the bytes are read.
//            cb            -- Number of bytes to read
//            pcbRead       -- Number of bytes actually read.
// Return:    S_OK if successful; error code otherwise.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CXboxStream::Write(VOID const *pv, ULONG cb, ULONG *pcbWritten)
{
    // Write the specified bits to our temporary destination file.
    WriteFile(m_hFile, pv, cb, pcbWritten, NULL);
    return S_OK;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CXboxStream::Seek
// Purpose:   Seeks to a particular position in the stream
// Arguments: dbMove        -- Number of bytes in which to move.
//            dwOrigin      -- Starting location of move.
//            pbNewPosition -- Filled with new file pointer.
// Return:    S_OK if successful; error code otherwise.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CXboxStream::Seek(LARGE_INTEGER dbMove, DWORD dwOrigin, ULARGE_INTEGER *pbNewPosition)
{
    // Seek to the specified position in our source and destination files.
    LARGE_INTEGER li = dbMove;
    li.LowPart = SetFilePointer(m_hFile, li.LowPart, &li.HighPart, dwOrigin);

    // Test for failure
    if (li.LowPart == 0xFFFFFFFF)
    {
        // Check if actually an error
        DWORD dwErr = GetLastError();
        if (dwErr != NO_ERROR)
            return dwErr;
    } 
    
    if (pbNewPosition)
        (*pbNewPosition).QuadPart = li.QuadPart;

    return S_OK;
}


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ UNIMPLEMENTED ISTREAM METHODS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CXboxStream::SetSize
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CXboxStream::SetSize(ULARGE_INTEGER cbNewSize)
{
    return E_NOTIMPL;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CXboxStream::CopyTo
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CXboxStream::CopyTo(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead,
                                 ULARGE_INTEGER *pcbWritten)
{
    return E_NOTIMPL;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CXboxStream::Commit
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CXboxStream::Commit(DWORD grfCommitFlags)
{
    return E_NOTIMPL;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CXboxStream::Revert
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CXboxStream::Revert()
{
    return E_NOTIMPL;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CXboxStream::LockRegion
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CXboxStream::LockRegion(ULARGE_INTEGER bOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
    return E_NOTIMPL;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CXboxStream::UnlockRegion
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CXboxStream::UnlockRegion(ULARGE_INTEGER bOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
    return E_NOTIMPL;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CXboxStream::Stat
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CXboxStream::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
    return E_NOTIMPL;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CXboxStream::Clone
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CXboxStream::Clone(IStream **ppstm)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbshlext\CXboxStream.h ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:     CXboxStream.h
// Contents: UNDONE-WARN: Add file description
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ CLASS DECLARATIONS ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

class CXboxStream : public IStream
{
public:
    CXboxStream();
    ~CXboxStream();
    HRESULT Initialize(LPCSTR pszFilename, bool fDeleteOnFinalRelease = true);

    // IUnknown
    STDMETHODIMP QueryInterface (REFIID iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IStream
    STDMETHODIMP Read(void *pv, ULONG cb, ULONG *pcbRead);     
    STDMETHODIMP Write(VOID const *pv, ULONG cb, ULONG *pcbWritten);
    STDMETHODIMP Seek(LARGE_INTEGER dbMove, DWORD dwOrigin, ULARGE_INTEGER *pbNewPosition);
    STDMETHODIMP SetSize(ULARGE_INTEGER cbNewSize);
    STDMETHODIMP CopyTo(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead,
                        ULARGE_INTEGER *pcbWritten);
    STDMETHODIMP Commit(DWORD grfCommitFlags);
    STDMETHODIMP Revert();
    STDMETHODIMP LockRegion(ULARGE_INTEGER bOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    STDMETHODIMP UnlockRegion(ULARGE_INTEGER bOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    STDMETHODIMP Stat(STATSTG *pstatstg, DWORD grfStatFlag);
    STDMETHODIMP Clone(IStream **ppstm);

protected:
    long m_cRef;
    bool m_fDeleteOnFinalRelease;
    HANDLE m_hFile;
    char m_szFilename[MAX_PATH];
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbshlext\dataobj.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    dataobj.cpp

Abstract:

    Implementation of CXboxDataObject.  CXboxDataObject handles file transfer when the
    namespace extension is acting as a source.


Environment:

    Windows 2000 and Later 
    User Mode

Revision History:
    
    04-03-2001 : created (mitchd)
    04-25-2001 : implemented IDataObject methods (jeffsim)
    07-03-2001 : changed implementation to use CXboxSelectedItems and to recurse properly (mitchd)
    07-24-2001 : change implementation for new IXboxVisitor architecture, (mitchd)

--*/

#include "stdafx.h"

//-------------------------------------------------------------------------------------
// Supported data formats
//-------------------------------------------------------------------------------------
CLIPFORMAT CF_FILECONTENTS               = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_FILECONTENTS);
CLIPFORMAT CF_FILEDESCRIPTORA            = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_FILEDESCRIPTORA);
CLIPFORMAT CF_FILEDESCRIPTORW            = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_FILEDESCRIPTORW);
CLIPFORMAT CF_FILENAMEMAPA               = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_FILENAMEMAPA);
CLIPFORMAT CF_FILENAMEMAPW               = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_FILENAMEMAPW);
CLIPFORMAT CF_FILENAME                   = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_FILENAME);
CLIPFORMAT CF_PREFERREDDROPEFFECT        = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_PREFERREDDROPEFFECT);
CLIPFORMAT CF_PERFORMEDDDROPEFFECT       = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_PERFORMEDDROPEFFECT);
CLIPFORMAT CF_LOGICALPERFORMEDDROPEFFECT = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_LOGICALPERFORMEDDROPEFFECT);
CLIPFORMAT CF_PASTESUCCEEDED             = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_PASTESUCCEEDED);
CLIPFORMAT CF_SHELLIDLIST                = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_SHELLIDLIST);
CLIPFORMAT CF_XBOXFILEDESCRIPTOR         = (CLIPFORMAT)RegisterClipboardFormat(TEXT("XBOX_FILEDESCRIPTOR"));



#define FORMAT_XBOXFILEDESCRIPTOR          {CF_XBOXFILEDESCRIPTOR,        NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL}
#define FORMAT_FILEDESCRIPTORA             {CF_FILEDESCRIPTORA,           NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL}
#define FORMAT_FILEDESCRIPTORW             {CF_FILEDESCRIPTORW,           NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL}
#define FORMAT_FILECONTENTS                {CF_FILECONTENTS,              NULL, DVASPECT_CONTENT, -1, TYMED_ISTREAM}
#define FORMAT_SHELLIDLIST                 {CF_SHELLIDLIST,               NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL}
#define FORMAT_PREFERREDDROPEFFECT         {CF_PREFERREDDROPEFFECT,       NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL}
#define FORMAT_PERFORMEDDDROPEFFECT        {CF_PERFORMEDDDROPEFFECT,      NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL}
#define FORMAT_LOGICALPERFORMEDDROPEFFECT  {CF_LOGICALPERFORMEDDROPEFFECT,NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL}
#define FORMAT_PASTESUCCEEDED              {CF_PASTESUCCEEDED,            NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL}

GET_DATA_FORMAT_TABLE_ENTRY CXboxDataObject::sm_GetDataSupportedFormats[] = 
{
  {FORMAT_XBOXFILEDESCRIPTOR,  CXboxDataObject::GetXboxDescriptor},
  {FORMAT_FILEDESCRIPTORA,     CXboxDataObject::GetFileDescriptorA},
  {FORMAT_FILEDESCRIPTORW,     CXboxDataObject::GetFileDescriptorW},
  {FORMAT_FILECONTENTS,        CXboxDataObject::GetFileContents},
  {FORMAT_SHELLIDLIST,         CXboxDataObject::GetShellIdList}
};
UINT CXboxDataObject::sm_uGetDataSupportedCount = sizeof(CXboxDataObject::sm_GetDataSupportedFormats)/sizeof(GET_DATA_FORMAT_TABLE_ENTRY);

SET_DATA_FORMAT_TABLE_ENTRY CXboxDataObject::sm_SetDataSupportedFormats[] = 
{
  {FORMAT_PREFERREDDROPEFFECT,         CXboxDataObject::SetPreferredDropEffect},
  {FORMAT_PERFORMEDDDROPEFFECT,        CXboxDataObject::SetPerformedDropEffect},
  {FORMAT_LOGICALPERFORMEDDROPEFFECT,  CXboxDataObject::SetLogicalPerformedDropEffect},
  {FORMAT_PASTESUCCEEDED,              CXboxDataObject::SetPasteSucceeded}
};
UINT CXboxDataObject::sm_uSetDataSupportedCount = sizeof(CXboxDataObject::sm_SetDataSupportedFormats)/sizeof(SET_DATA_FORMAT_TABLE_ENTRY);


//-------------------------------------------------------------------------------------
// Creation and Destruction
//-------------------------------------------------------------------------------------
HRESULT 
CXboxDataObject::Create(
    UINT           cidl,
    LPCITEMIDLIST *apidl,
    CXboxFolder   *pParent,
    IDataObject   **ppDataObject
    )
/*++
 Routine Description:
  Creates an IDataObject for the selected items of a CXboxFolder.  This works
  for file items as well as other types (for links only).

 Arguments:

  cidl         - number of ItemIDs selected (can be zero, meaning the parent is the selection).
  apidl        - array of selected ItemIDs.
  pParent      - parent of the selected items (unless cidl is zero).
  ppDataObject - [OUT] get the data object on success

 Return Value:

  S_OK on success.
  E_NOINTERFACE if the object type is not supported.
  E_OUTOFMEMORY is always possible.
--*/
{
    ULONG ulShellAttributes = SFGAO_CANCOPY | SFGAO_CANMOVE | SFGAO_CANLINK;
    CXboxFolder *pSelection;
    HRESULT hr = pParent->GetAttributesOf(cidl, apidl, &ulShellAttributes);
    if(SUCCEEDED(hr))
    {
        if(!ulShellAttributes)
        {
            hr=E_NOINTERFACE;
        } else
        {
            hr = pParent->CloneSelection(cidl, apidl,&pSelection);
        }
    }

    if(SUCCEEDED(hr))
    {
        CComObject<CXboxDataObject> *pDataObject;
        hr = CComObject<CXboxDataObject>::CreateInstance(&pDataObject);
        if(SUCCEEDED(hr))
        {
            pDataObject->m_pSelection = pSelection;
            pDataObject->m_ulShellAttributes = ulShellAttributes;
            pDataObject->m_uTopLevelItemCount = cidl;
            pDataObject->QueryInterface(IID_PPV_ARG(IDataObject, ppDataObject));
            SHGetThreadRef(&pDataObject->m_pUnkThread);
            //Assume drop effect copy, it might get changed later.
            DataObjUtil::SetPreferredDropEffect(pDataObject, DROPEFFECT_COPY);
        } else
        {
            pSelection->Release();
        }
    }
    return hr;
}

HRESULT 
CXboxDataObject::Create(
    UINT           cidl,
    CXboxFolder   *pSelection,
    IDataObject   **ppDataObject
    )
/*++
 Routine Description:
  Creates an IDataObject for the selected items of a CXboxFolder.  This works
  for file items as well as other types (for links only).

 Arguments:

  cidl         - number of ItemIDs selected (can be zero, meaning the parent is the selection).
  pSelection   - Xbox Selection Clone
  ppDataObject - [OUT] get the data object on success

 Return Value:

  S_OK on success.
  E_NOINTERFACE if the object type is not supported.
  E_OUTOFMEMORY is always possible.
--*/
{
    ULONG ulShellAttributes = SFGAO_CANCOPY | SFGAO_CANMOVE | SFGAO_CANLINK;
    pSelection->GetSelectShellAttributes(&ulShellAttributes);
    if(!ulShellAttributes)
    {
        return E_NOINTERFACE;
    }

    CComObject<CXboxDataObject> *pDataObject;
    HRESULT hr = CComObject<CXboxDataObject>::CreateInstance(&pDataObject);
    if(SUCCEEDED(hr))
    {
        pSelection->AddRef();
        pDataObject->m_pSelection = pSelection;
        pDataObject->m_ulShellAttributes = ulShellAttributes;
        pDataObject->m_uTopLevelItemCount = cidl;
        pDataObject->QueryInterface(IID_PPV_ARG(IDataObject, ppDataObject));
        SHGetThreadRef(&pDataObject->m_pUnkThread);
        //Assume drop effect copy, it might get changed later.
        DataObjUtil::SetPreferredDropEffect(pDataObject, DROPEFFECT_COPY);
    } else
    {
        pSelection->Release();
    }
    
    return hr;
}

CXboxDataObject::~CXboxDataObject()
/*++
  Routine Description:
    As we go out of existance, we need to clean up anything
    we allocated along the way.

    This may also be the correct place to complete an unoptimized move.
--*/
{
    /*
    **  TODO: Hmm, this may be the time to complete
    **  unoptimized moves.
    */

    
    //
    //  We are done with out clone of the selection
    //
    if(m_pSelection) m_pSelection->Release();
    
    //
    //  Cleanup the m_pXboxFileGroupList, if it 
    //  was ever created.
    //
    free(m_pXboxFileGroupDescriptor);

    //
    //  If we are holding a reference count on the thread
    //  release it.
    //
    if(m_pUnkThread) m_pUnkThread->Release();
}

/*
**  IDataObject Methods
**
*/

STDMETHODIMP CXboxDataObject::GetData(FORMATETC *pfetc, STGMEDIUM *pstgm)
/*++

 Routine Description:

   Implements IDataObject::GetData.  Retrieves the data associated with a particular data format.

 Arguments:

   pfetc - [IN]  Information about the desired data format
   pstgm - [OUT] The data for the desired data format

 Return Value:
   S_OK             - success
   DV_E_LINDEX      - the index did not match.
   DV_E_FORMAT_ETC  - This object does not currently contain the desired clipboard format.
   DV_E_TYMED       - The tymed value was invalid for the desired clipboard format.
   DV_E_DVASPECT    - The dwAspect value was invalid for the desired clipboard format.
   STG_E_MEDIUMFULL - Memory allocation error related to the medium.
   E_OUTOFMEMORY    - Generic memory allocation error.
   E_INVALIDARG     - Caller passed a bad argument.

--*/
{
    HRESULT hr;
    UINT    uDataFormatIndex;

    ENTER_SPEW;
    
    // Validate parameters
    if (pfetc == NULL || pstgm == NULL)
        return E_INVALIDARG;

    //
    //  Dump the format name.
    //
    //DUMP_FORMAT_NAME(pfetc->cfFormat);

    //
    //   First, check our table for supported formats
    //
    hr = FindMatchingGetFormat(pfetc, &uDataFormatIndex);
    if(SUCCEEDED(hr))
    {
        hr = (this->*sm_GetDataSupportedFormats[uDataFormatIndex].pfnGetData)(pfetc, pstgm, false);
    } else
    //
    //  Perhaps someone stored a non-native format.  Check that list too.
    //  
    {
        CStoredDataFormat *pStoredFormat = m_StoredFormats.FindMatch(pfetc);
        if(pStoredFormat)
        {
            hr = pStoredFormat->CopyTo(pstgm);
        }
    }
    return hr;
}


STDMETHODIMP CXboxDataObject::SetData(FORMATETC *pfetc, STGMEDIUM *pstgm, BOOL fRelease)
/*++
 Routine Description:

  Implements IDataObject::SetData.  There are a few formats that are really messages to us.  Those
  are found in our sm_SetDataSupportedFormats table and have special handlers.  The rest we store as
  generic data.  We rely on CStoredDataFormatList to handle this.

 Arguments:
   pfetc    - describes the format to store
   pstgm    - data to store in the specified format.
   fRelease - if true, we store the data, and we are responsible for freeing it when we are done.
              if false, we must store a copy and free it when we are done.

 Return Values:
   S_OK             - Success
   E_INVALIDARG     - Caller passed a bad argument or mutually incompatible arguments.
   STG_E_MEDIUMFULL - fRelease was FALSE, and the memory allocation failed.
   E_OUTOFMEMORY    - some other memory allocation failed.

--*/
{
    HRESULT hr;
    UINT uDataFormatIndex;
    
    //
    // Verify parameters
    //
    if (pfetc == NULL || pstgm == NULL)
    {
        return E_INVALIDARG;
    }

    //
    //  First, check our table for supported formats, and allow
    //  any special handling.
    //
    hr = FindMatchingSetFormat(pfetc, &uDataFormatIndex);
    if(SUCCEEDED(hr))
    {
        hr = (this->*sm_SetDataSupportedFormats[uDataFormatIndex].pfnSetData)(pfetc, pstgm, fRelease);
    } else
    //
    // Otherwise store it as a generic format.
    //
    {
        hr = m_StoredFormats.Store(pfetc, pstgm, fRelease);
    }

    return hr;
}

STDMETHODIMP CXboxDataObject::EnumFormatEtc(DWORD dwDirection, IEnumFORMATETC **ppieftc)
/*++
 Routine Description:
   Implements IDataObject::EnumFormatEtc.
 Arguments:
   dwDirection - DATADIR_GET enumerates which formats may be retrieved via GetData.
   ppieftc     - DATADIR_SET enumerates which formats may be retrieved via SetData.
 Return Value:
   S_OK         - Success
   E_INVALIDARG - Caller passed ppieftc = NULL.
   Other OLE errors.
 Comments:
   We use ATLs standard CComEnum appropriately specialized to CComEnumFormatEtc
   (this is typedef'd in the dataobj.h).  In this routine, we build an array of
   supported formats (both native formats, and those that have been stored with SetData).
   Then initialize CComEnumFormatEtc with this array.

--*/
{
    HRESULT hr = S_OK;
    //
    //  In case we fail, NULL out the out parameter.
    //

    *ppieftc = NULL;

    //
    // Verify parameters
    //

    if (ppieftc == NULL) return E_INVALIDARG;
    if( (DATADIR_GET!=dwDirection) && (DATADIR_SET!=dwDirection))
    {
        _ASSERT(FALSE);
        return E_INVALIDARG;
    }

    //
    //  Build the array
    //
    UINT       uFormatCount;
    FORMATETC *pFirstFormat;
    FORMATETC *pNextFormat;
    if(DATADIR_GET == dwDirection)
    {
        //
        //  If the selected items may be copied then all of the
        //  formats are supported.  Otherwise, just CF_SHELLIDLIST
        //
        if(m_ulShellAttributes&SFGAO_CANCOPY)
        {
            uFormatCount = sm_uGetDataSupportedCount;
        } else
        {
            uFormatCount = 1;
        }
        //
        //  Add in any formats that may have been stored
        //  via SetData.
        //
        uFormatCount += m_StoredFormats.GetCount();
        
        //
        //  Allocate the array.
        //
        pFirstFormat = new FORMATETC[uFormatCount];

        if(pFirstFormat)
        {
            //
            //  Copy the native formats
            //
        
            UINT uIndex = (m_ulShellAttributes&SFGAO_CANCOPY) ? 0 : (sm_uGetDataSupportedCount-1);
            for(pNextFormat = pFirstFormat; uIndex < sm_uGetDataSupportedCount; uIndex++, pNextFormat++)
            {
                memcpy(pNextFormat, &sm_GetDataSupportedFormats[uIndex].formatEtc, sizeof(FORMATETC));
            }

            //
            //  Copy the stored formats.
            //

            CStoredDataFormat *pDataFormat = m_StoredFormats.GetFirst();
            while(pDataFormat)
            {
                pDataFormat->CopyFormat(pNextFormat++);
                pDataFormat = pDataFormat->GetNext();
            }
        }

    } else if(DATADIR_SET)
    {
        uFormatCount = sm_uSetDataSupportedCount;
        //
        //  Allocate the array.
        //
        pFirstFormat = new FORMATETC[uFormatCount];
        
        if(pFirstFormat)
        {
            //
            //  Copy the native formats
            //
        
            UINT uIndex = 0;
            for(pNextFormat = pFirstFormat; uIndex < sm_uSetDataSupportedCount; uIndex++, pNextFormat++)
            {
                memcpy(pNextFormat, &sm_SetDataSupportedFormats[uIndex].formatEtc, sizeof(FORMATETC));
            }
        }
    }

    //
    //  If we managed to get an array, then create an enumerator
    //  and initialize it,
    if(pFirstFormat)
    {
        CComObject<CEnumFormatEtc> *pEnumFormatEtc;
        hr = CComObject<CEnumFormatEtc>::CreateInstance(&pEnumFormatEtc);
        if(SUCCEEDED(hr))
        {
            hr = pEnumFormatEtc->Init(pFirstFormat, pNextFormat, NULL, AtlFlagTakeOwnership);
            if(SUCCEEDED(hr))
            {
                hr = pEnumFormatEtc->QueryInterface(IID_PPV_ARG(IEnumFORMATETC, ppieftc));
            }
            if(FAILED(hr))
            {   
                delete pEnumFormatEtc;
                delete [] pFirstFormat;
            }
        }
        else
        {
            delete [] pFirstFormat;
        }
    } else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

STDMETHODIMP CXboxDataObject::QueryGetData(FORMATETC *pfetc)
/*++
  Routine Description:
    Checks to see if it is possible to get a given data object.
--*/
{
    HRESULT hr;
    ENTER_SPEW;
    
    // Validate parameters
    if (pfetc == NULL) return E_INVALIDARG;

    //
    //  Dump the format name.
    //
    //DUMP_FORMAT_NAME(pfetc->cfFormat);

    //
    //   First, check our table for supported formats
    //

    hr = FindMatchingGetFormat(pfetc);

    //
    //  Perhaps someone stored a non-native format.  Check that list too.
    //

    if(FAILED(hr))
    {
        CStoredDataFormat *pStoredFormat = m_StoredFormats.FindMatch(pfetc);
        if(pStoredFormat)
        {
            hr = S_OK;
        }
    }
    return hr;
}

STDMETHODIMP CXboxDataObject::GetCanonicalFormatEtc(FORMATETC *pfetcIn, FORMATETC *pfetcOut)
/*++
  Routine Description:
    Implements IDataObject::GetCanonicalFormatEtc.
    
    There is a big long discussion in the FTP shell extension code why this should be
    implemented thusly.  The arguments were all pretty generic.
--*/
{
    return DATA_S_SAMEFORMATETC;
}


/*
**  IDataObject methods that we do not (yet?) support
**
*/

STDMETHODIMP CXboxDataObject::DAdvise(FORMATETC *pfetc, DWORD dwAdviseFlags, IAdviseSink * piadvsink,
	                             DWORD * pdwConnection)
{
    return E_NOTIMPL;
}

STDMETHODIMP CXboxDataObject::DUnadvise(DWORD dwConnection)
{
    return E_NOTIMPL;
}

STDMETHODIMP CXboxDataObject::EnumDAdvise(IEnumSTATDATA **ppienumStatData)
{
	return E_NOTIMPL;
}

//
//  BugBug: I think that this is required for persistent storage on the clipboard after a copy and close.
//
STDMETHODIMP CXboxDataObject::GetDataHere(FORMATETC *pfetc, STGMEDIUM *pstgm)
{
    //_ASSERTE(FALSE);
    return E_NOTIMPL;
}

/**
***
*** IAsyncOperation Implementation
***
**/
STDMETHODIMP CXboxDataObject::EndOperation(HRESULT hResult, IBindCtx *pbcReserved, DWORD dwEffects)
{
    //
    //  At the end of an Async Move we need to delete all the items.
    //  In the non-Async case, we do this from the out IShellFolderViewCB
    //  implemented CXboxView.
    //
    
    if(SUCCEEDED(hResult) && (DROPEFFECT_MOVE == dwEffects))
    {
        CXboxDelete objDelete(NULL, m_pSelection->GetChildCount(), true);
        m_pSelection->VisitEach(&objDelete, IXboxVisitor::FlagContinue|IXboxVisitor::FlagRecurse);
    }
    m_fDidAsynchStart = FALSE;
    return S_OK;
}
STDMETHODIMP CXboxDataObject::GetAsyncMode(BOOL *pfIsOpAsync)
{
    if(m_pUnkThread || WindowUtils::IsMainShellProcess())
    {
        *pfIsOpAsync = TRUE;
    } else
    {
        *pfIsOpAsync = FALSE;
    }
    return S_OK;
}
STDMETHODIMP CXboxDataObject::InOperation(BOOL *pfInAsyncOp)
{
    *pfInAsyncOp = m_fDidAsynchStart;
    return S_OK;
}
STDMETHODIMP CXboxDataObject::StartOperation(IBindCtx *pbcReserved)
{
    HRESULT hr;
    _ASSERTE(!pbcReserved);
    
    m_fDidAsynchStart = TRUE;
    return S_OK;
}


/*
**  
**  Internal Implemenation of CXboxDataObject
**
*/


HRESULT CXboxDataObject::AreFormatsEquivalent(FORMATETC *pFormatEtc1, FORMATETC *pFormatEtc2)
/*++
  Routine Description:
   A static method to compare to FORTMATETC and determine equivalence.
   This should be sufficient for GetData, SetData, and QueryGetData.
   The only caveat is checking lindex.  For these, specific knowledge
   of the instance must be taken into account.  So for CF_FILECONTENT
   we just ignore it.
--*/
{
    if(pFormatEtc1->cfFormat != pFormatEtc2->cfFormat)
    {
        return DV_E_FORMATETC;
    }

    //
    //  CAVEAT: CF_FILECONTENTS can take a range of indices,
    //          we will FindMatchingGetFormat deals with this.
    //
    if(CF_FILECONTENTS!=pFormatEtc1->cfFormat)
    {
        if(pFormatEtc1->lindex != pFormatEtc2->lindex)
        {
            return DV_E_LINDEX;
        }
    }

    if(!(pFormatEtc1->tymed&pFormatEtc2->tymed))
    {
        return DV_E_TYMED;
        
    }
    if(pFormatEtc1->dwAspect != pFormatEtc2->dwAspect)
    {
        return DV_E_DVASPECT;
    }

    return S_OK;
}

HRESULT CXboxDataObject::FindMatchingGetFormat(FORMATETC *pFormatEtc, PUINT puIndex)
/*++
  Routine Description:
    Checks the sm_GetDataSupportedFormats for a matching FORMATETC.
--*/
{
    UINT uIndex = (m_ulShellAttributes&SFGAO_CANCOPY) ? 0 : (sm_uGetDataSupportedCount-1);
    HRESULT hrResult = S_OK;
    HRESULT hr;
    
    for(; uIndex < sm_uGetDataSupportedCount; uIndex++)
    {
        hr = AreFormatsEquivalent(&sm_GetDataSupportedFormats[uIndex].formatEtc, pFormatEtc);
        if(SUCCEEDED(hr))
        {
            //
            //  AreFormatsEquivalent cannot check the index for CF_FILECONTENTS
            //  so we do that here.
            //
            if(CF_FILECONTENTS==pFormatEtc->cfFormat)
            {
                if(!IsValidFileContentsIndex(pFormatEtc->lindex))
                {
                    return DV_E_LINDEX;
                }
            }
            if(puIndex)
            {
                *puIndex = uIndex;
            }
            hrResult = S_OK;
            break;
        } else
        {
            //
            //  This is a bit strange. If you look at winerror.h
            //  and the IDataObject::GetData or GetDataObject all the errors
            //  are not equavilent.  Presumable DV_E_FORMATETC implies that you
            //  do not support the format at all, whereas DV_E_ASPECT implies
            //  that the format is just fine, and it is just the you don't
            //  have the correct aspect ratio.  It turns out that the
            //  codes are laid out so that this works.
            //
            if(HRESULT_CODE(hr) > HRESULT_CODE(hrResult))
            {
                hrResult = hr;
            }
        }
    }
    return hrResult;
}
 

HRESULT CXboxDataObject::FindMatchingSetFormat(FORMATETC *pFormatEtc, PUINT puIndex)
/*++
  Routine Description:
    Checks the sm_SetDataSupportedFormats for a matching FORMATETC.
--*/
{
    UINT uIndex;
    HRESULT hrResult = S_OK;
    HRESULT hr;
    
    for(uIndex = 0; uIndex < sm_uSetDataSupportedCount; uIndex++)
    {
        hr = AreFormatsEquivalent(&sm_SetDataSupportedFormats[uIndex].formatEtc, pFormatEtc);
        if(SUCCEEDED(hr))
        {
            if(puIndex)
            {
                *puIndex = uIndex;
            }
            hrResult = S_OK;
            break;
        } else
        {
            if(HRESULT_CODE(hr) > HRESULT_CODE(hrResult))
            {
                hrResult = hr;
            }
        }
    }
    return hrResult;
}


class CCreateXboxFileGroupDesc : public IXboxVisitor
{
  public:
    virtual void VisitRoot         (IXboxVisit *pRoot,                DWORD *pdwFlags){_ASSERTE(FALSE);}
    virtual void VisitAddConsole   (IXboxVisit *pAddConsole,          DWORD *pdwFlags){_ASSERTE(FALSE);}
    virtual void VisitConsole      (IXboxConsoleVisit *pConsole,    DWORD *pdwFlags){_ASSERTE(FALSE);}
    virtual void VisitVolume       (IXboxVolumeVisit *pVolume,     DWORD *pdwFlags){_ASSERTE(FALSE);}
    virtual void VisitDirectoryPost (IXboxFileOrDirVisit *pFileOrDir, DWORD *pdwFlags){_ASSERTE(FALSE);}
    virtual void VisitFileOrDir    (IXboxFileOrDirVisit *pFileOrDir,  DWORD *pdwFlags);

    PXBOXFILEGROUPDESCRIPTOR GetXboxGroupDesc(UINT uTopLevelCount, CXboxFolder *m_pSelection);
  
  private:
    struct XBOX_FILE_ITEM
    {
      DM_FILE_ATTRIBUTES dmFileAttributes;    
      XBOX_FILE_ITEM    *pNext;
    };

    UINT            m_uCount;
    XBOX_FILE_ITEM *m_pListHead;
    XBOX_FILE_ITEM *m_pListTail;
};


void CCreateXboxFileGroupDesc::VisitFileOrDir(IXboxFileOrDirVisit *pFileOrDir, DWORD *pdwFlags)
{
    XBOX_FILE_ITEM *pNewFileItem = new XBOX_FILE_ITEM;
    if(pNewFileItem)
    {
       pFileOrDir->GetFileAttributes(&pNewFileItem->dmFileAttributes);
       //
       //   The name in dmFileAttributes is the simple name, we want
       //   to replace it with the name relative to the point of recursion,
       //   which GetName returns.
       //
       pFileOrDir->GetName(pNewFileItem->dmFileAttributes.Name);

       pNewFileItem->pNext = NULL;
       if(!m_uCount)
       {
           m_pListHead = pNewFileItem;
       } else
       {
           m_pListTail->pNext = pNewFileItem; 
       }
       m_pListTail = pNewFileItem;
       m_uCount++;
    }
}

PXBOXFILEGROUPDESCRIPTOR CCreateXboxFileGroupDesc::GetXboxGroupDesc(UINT uTopLevelCount, CXboxFolder *pSelection)
{   
    PXBOXFILEGROUPDESCRIPTOR pXboxFileGroupDescriptor = NULL;
    UINT uIndex = 0;
    m_uCount = 0;
    m_pListHead = NULL;
    m_pListTail = NULL;

    //
    //  Build the list linked list of XBOX_FILE_ITEM's
    //
    pSelection->VisitEach(this, IXboxVisitor::FlagContinue|IXboxVisitor::FlagRecurse);

    //
    //  Allocate and fill out the XBOXFILEGROUPDESCRIPTOR
    //  
    if(m_pListHead)
    {
        //
        //  Calculate the size and allocate it.
        //
        UINT uSize = sizeof(XBOXFILEGROUPDESCRIPTOR) + (m_uCount-1)*sizeof(FILEDESCRIPTORA);
        pXboxFileGroupDescriptor = (PXBOXFILEGROUPDESCRIPTOR)malloc(uSize);
        if(pXboxFileGroupDescriptor)
        {
            //
            //  Fill in the header content
            //

            pXboxFileGroupDescriptor->cItems = m_uCount;
            pSelection->GetPath(pXboxFileGroupDescriptor->szFolderPath);
            if(!uTopLevelCount)
            {
                LPSTR pszParse = strrchr(pXboxFileGroupDescriptor->szFolderPath,'\\');
                *pszParse = '\0';
            }
        }

        //
        //  Go through our list of item, add them to our XBOXFILEGROUPDESCRIPTOR,
        //  if we managed to allocate it, and then free each item.
        //
        while(m_pListHead)
        {
            XBOX_FILE_ITEM *pFileItem;
            //
            //  Pop a file item off the list
            //
            pFileItem = m_pListHead;
            m_pListHead = pFileItem->pNext;
            if(pXboxFileGroupDescriptor)
            {
                pXboxFileGroupDescriptor->fgd[uIndex].dwFlags = FD_ATTRIBUTES|FD_CREATETIME|FD_FILESIZE|FD_WRITESTIME|FD_PROGRESSUI;
                strcpy(pXboxFileGroupDescriptor->fgd[uIndex].cFileName, pFileItem->dmFileAttributes.Name);
                pXboxFileGroupDescriptor->fgd[uIndex].dwFileAttributes = pFileItem->dmFileAttributes.Attributes;
                pXboxFileGroupDescriptor->fgd[uIndex].ftCreationTime = pFileItem->dmFileAttributes.CreationTime;
                pXboxFileGroupDescriptor->fgd[uIndex].ftLastWriteTime = pFileItem->dmFileAttributes.ChangeTime;
                pXboxFileGroupDescriptor->fgd[uIndex].nFileSizeHigh = pFileItem->dmFileAttributes.SizeHigh;
                pXboxFileGroupDescriptor->fgd[uIndex].nFileSizeLow = pFileItem->dmFileAttributes.SizeLow;
                uIndex++;
            }
            delete pFileItem;
        }
    }
    return pXboxFileGroupDescriptor;
}



PXBOXFILEGROUPDESCRIPTOR CXboxDataObject::GetXboxFileGroupDescriptor()
{
    //
    //  If the data is NOT already rendered, 
    //  use our helper class to create it.
    //
    if(!m_pXboxFileGroupDescriptor)
    {
        CCreateXboxFileGroupDesc createXboxFileGroupDesc;    
        m_pXboxFileGroupDescriptor = createXboxFileGroupDesc.GetXboxGroupDesc(
                                        m_uTopLevelItemCount,
                                        m_pSelection);
    }
    return m_pXboxFileGroupDescriptor;    
}


bool CXboxDataObject::IsValidFileContentsIndex(UINT uIndex)
/*++
  Routine Description:
    Checks if an index is valid for getting CF_FILECONTENTS

--*/
{
    PXBOXFILEGROUPDESCRIPTOR pXboxGroupFileDescriptor;
    pXboxGroupFileDescriptor = GetXboxFileGroupDescriptor();
    if(pXboxGroupFileDescriptor)
    {
        if(uIndex < pXboxGroupFileDescriptor->cItems)
        {
            if(!(pXboxGroupFileDescriptor->fgd[uIndex].dwFileAttributes&FILE_ATTRIBUTE_DIRECTORY))
            {
                return true;
            }
        }
    }
    return false;
}

HRESULT CXboxDataObject::CopyToHGlobal(STGMEDIUM *pstgm, PVOID pvData, UINT cbSize, BOOL fHere)
{
    //
    // Allocate global memory to store the copy we are returning
    //
    if(fHere)
    {
        if(cbSize > GlobalSize(pstgm->hGlobal))
        {
            return STG_E_MEDIUMFULL;
        }
    } else
    {
        pstgm->hGlobal = GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT | GMEM_SHARE, cbSize);
        if (pstgm->hGlobal == NULL)
        {
            return STG_E_MEDIUMFULL;
        }
        pstgm->tymed = TYMED_HGLOBAL;
        pstgm->pUnkForRelease = NULL;
    }

    //
    // Copy the Data Object's XBOXFILEGROUPDESCRIPTOR into the
    // global memory we just allocated.
    //
    PVOID pvGlobal = GlobalLock(pstgm->hGlobal);
    memcpy(pvGlobal, pvData, cbSize);
    GlobalUnlock(pstgm->hGlobal);
    return S_OK;
}

HRESULT CXboxDataObject::GetXboxDescriptor(FORMATETC *pfetc, STGMEDIUM *pstgm, BOOL fHere)
{

    PXBOXFILEGROUPDESCRIPTOR pXboxGroupFileDescriptor = GetXboxFileGroupDescriptor();

    if(!pXboxGroupFileDescriptor)
    {
        return E_OUTOFMEMORY;
    }
    
    _ASSERT(pfetc->tymed&TYMED_HGLOBAL);
        
    //
    //  Calculate the size of the structure
    //

    UINT cItems = pXboxGroupFileDescriptor->cItems;
    UINT cbSize = sizeof(XBOXFILEGROUPDESCRIPTOR) + ((cItems-1)*sizeof(FILEDESCRIPTORA));

    //
    //  Copy the data to the stream.
    //

    return CopyToHGlobal(pstgm, (PVOID)pXboxGroupFileDescriptor, cbSize, fHere);
};

HRESULT CXboxDataObject::GetFileDescriptorA(FORMATETC *pfetc, STGMEDIUM *pstgm, BOOL fHere)
{
    PXBOXFILEGROUPDESCRIPTOR pXboxGroupFileDescriptor = GetXboxFileGroupDescriptor();
    if(!pXboxGroupFileDescriptor)
    {
        return E_OUTOFMEMORY;
    }

    UINT uIndex;
    //
    //  Calculate the size of the structure
    //
    UINT cItems = pXboxGroupFileDescriptor->cItems;
    UINT cbSize = sizeof(FILEGROUPDESCRIPTORA) + ((cItems-1)*sizeof(FILEDESCRIPTORA));

    //
    //  Allocate the medium
    //
    if(fHere)
    {
        if(cbSize > GlobalSize(pstgm->hGlobal))
        {
            return STG_E_MEDIUMFULL;
        }
    } else
    {
        pstgm->hGlobal = GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT | GMEM_SHARE, cbSize);
        if (pstgm->hGlobal == NULL)
        {
            return STG_E_MEDIUMFULL;
        }
        pstgm->tymed = TYMED_HGLOBAL;
        pstgm->pUnkForRelease = NULL;
    }
    
    //
    // Copy the Data Object's XBOXFILEGROUPDESCRIPTOR into the
    // global memory we just allocated.
    //
    FILEGROUPDESCRIPTORA *pfgda = (FILEGROUPDESCRIPTORA *)GlobalLock(pstgm->hGlobal);
    pfgda->cItems = cItems;
    UINT cbCopySize = cItems*sizeof(FILEDESCRIPTORA);
    memcpy(pfgda->fgd, pXboxGroupFileDescriptor->fgd, cbCopySize);
    GlobalUnlock(pstgm->hGlobal);
    
    return S_OK;

}
HRESULT CXboxDataObject::GetFileDescriptorW(FORMATETC *pfetc, STGMEDIUM *pstgm, BOOL fHere)
{
    
    PXBOXFILEGROUPDESCRIPTOR pXboxGroupFileDescriptor = GetXboxFileGroupDescriptor();

    if(!pXboxGroupFileDescriptor)
    {
        return E_OUTOFMEMORY;
    }

    UINT uIndex;
    //
    //  Calculate the size of the structure
    //
    UINT cItems = pXboxGroupFileDescriptor->cItems;
    UINT cbSize = sizeof(FILEGROUPDESCRIPTORW) + ((cItems-1)*sizeof(FILEDESCRIPTORW));

    //
    //  Allocate the medium
    //
    if(fHere)
    {
        if(cbSize > GlobalSize(pstgm->hGlobal))
        {
            return STG_E_MEDIUMFULL;
        }
    } else
    {
        pstgm->hGlobal = GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT | GMEM_SHARE, cbSize);
        if (pstgm->hGlobal == NULL)
        {
            return STG_E_MEDIUMFULL;
        }
        pstgm->tymed = TYMED_HGLOBAL;
        pstgm->pUnkForRelease = NULL;
    }
    
    //
    // Copy the Data Object's XBOXFILEGROUPDESCRIPTOR into the
    // global memory we just allocated.
    //
    FILEGROUPDESCRIPTORW *pfgdw = (FILEGROUPDESCRIPTORW *)GlobalLock(pstgm->hGlobal);
    pfgdw->cItems = cItems;
    for(uIndex = 0; uIndex < cItems; uIndex++)
    {
        pfgdw->fgd[uIndex].dwFlags          = pXboxGroupFileDescriptor->fgd[uIndex].dwFlags;
        pfgdw->fgd[uIndex].clsid            = pXboxGroupFileDescriptor->fgd[uIndex].clsid;
        pfgdw->fgd[uIndex].sizel            = pXboxGroupFileDescriptor->fgd[uIndex].sizel;
        pfgdw->fgd[uIndex].pointl           = pXboxGroupFileDescriptor->fgd[uIndex].pointl;
        pfgdw->fgd[uIndex].dwFileAttributes = pXboxGroupFileDescriptor->fgd[uIndex].dwFileAttributes;
        pfgdw->fgd[uIndex].ftCreationTime   = pXboxGroupFileDescriptor->fgd[uIndex].ftCreationTime;
        pfgdw->fgd[uIndex].ftLastAccessTime = pXboxGroupFileDescriptor->fgd[uIndex].ftLastAccessTime;
        pfgdw->fgd[uIndex].ftLastWriteTime  = pXboxGroupFileDescriptor->fgd[uIndex].ftLastWriteTime;
        pfgdw->fgd[uIndex].nFileSizeHigh    = pXboxGroupFileDescriptor->fgd[uIndex].nFileSizeHigh;
        pfgdw->fgd[uIndex].nFileSizeLow     = pXboxGroupFileDescriptor->fgd[uIndex].nFileSizeLow;
        wsprintfW(pfgdw->fgd[uIndex].cFileName, L"%hs", pXboxGroupFileDescriptor->fgd[uIndex].cFileName);
    }
    GlobalUnlock(pstgm->hGlobal);
    
    return S_OK;
}

HRESULT CXboxDataObject::GetFileContents(FORMATETC *pfetc, STGMEDIUM *pstgm, BOOL fHere)
{
    PXBOXFILEGROUPDESCRIPTOR pXboxGroupFileDescriptor = GetXboxFileGroupDescriptor();
    
    if(!pXboxGroupFileDescriptor)
    {
        return E_OUTOFMEMORY;
    }
    if(fHere)
    {
        return E_NOTIMPL;
    }   
    
    HRESULT hr;
    char szTargetFile[MAX_PATH];
    
    //
    //  Get a temporary file name, since we pass false to open
    //  the file is not actually created, we just get the name.
    //  (The return value is zero for success, INVALID_HANDLE_VALUE
    //   on failure.)
    if(INVALID_HANDLE_VALUE==WindowUtils::CreateTempFile(szTargetFile, false))
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    //
    //  Bring the file across the wire and save it to our temp file
    //
    hr = m_pSelection->ReceiveFile(pXboxGroupFileDescriptor->fgd[pfetc->lindex].cFileName, szTargetFile);
    if(SUCCEEDED(hr))
    {
        //
        //  The file is now in a temp file.  We just need
        //  to create a stream on top if it.
        //
        // Create the object that will handle the caller's streaming requests (read, etc).
        CXboxStream *pxboxstream = new CXboxStream;
        hr = pxboxstream->Initialize(szTargetFile);
        if (SUCCEEDED(hr))
        {
            // Point the storage medium at our newly created IStream derivative.
            pstgm->tymed = TYMED_ISTREAM;
            pstgm->pstm = pxboxstream;
            pstgm->pUnkForRelease = NULL;
        }
    } else
    // It is important to translate the error codes, such that windows gives
    // a sensible error code.
    {
        hr = Utils::XboxErrorToWindowsError(hr);
    }
    return hr;
}

class CCreateShellIdList : public IXboxVisitor
{
  public:
    virtual void VisitRoot         (IXboxVisit          *pItem, DWORD *pf){return Visit(pItem,pf);}
    virtual void VisitAddConsole   (IXboxVisit          *pItem, DWORD *pf){return Visit(pItem,pf);}
    virtual void VisitConsole      (IXboxConsoleVisit   *pItem, DWORD *pf){return Visit(pItem,pf);}
    virtual void VisitVolume       (IXboxVolumeVisit    *pItem, DWORD *pf){return Visit(pItem,pf);}
    virtual void VisitFileOrDir    (IXboxFileOrDirVisit *pItem, DWORD *pf){return Visit(pItem,pf);}
    virtual void VisitDirectoryPost (IXboxFileOrDirVisit *,DWORD *){_ASSERTE(FALSE);}

    void Visit(IXboxVisit *pItem, DWORD *pf);

    HRESULT GetShellIdList(UINT uTopLevelCount, CXboxFolder *pSelection, STGMEDIUM *pstgm, BOOL fHere);
  
  private:

    UINT             m_uCount;
    LPITEMIDLIST    *m_rgPidls;
    UINT             m_uTotalPidlSize;
    HRESULT          m_hr;
};

void CCreateShellIdList::Visit(IXboxVisit *pItem, DWORD *pf)
{
    m_rgPidls[m_uCount] = pItem->GetPidl(CPidlUtils::PidlTypeSimple);
    if(m_rgPidls[m_uCount])
    {
      m_uTotalPidlSize += CPidlUtils::GetLength(m_rgPidls[m_uCount]);
      m_uCount++;
    } else
    {
      *pf = 0;
      m_hr = E_OUTOFMEMORY;
    } 
}

HRESULT CCreateShellIdList::GetShellIdList(UINT uTopLevelCount, CXboxFolder *pSelection, STGMEDIUM *pstgm, BOOL fHere)
{
    CIDA *pCida = NULL;
    UINT  uIndex;
    UINT uPidlLen;
    UINT nNextPidlOffset;
    m_hr = S_OK;
    m_uCount = 0;
    m_uTotalPidlSize = 0;
    
    //
    //  Get the pidl of the parent folder
    //
    LPITEMIDLIST pParentPidl = pSelection->GetPidl(CPidlUtils::PidlTypeAbsolute);
    if(!pParentPidl)
    {
        return E_OUTOFMEMORY;
    }

    uPidlLen = CPidlUtils::GetLength(pParentPidl);
    m_uTotalPidlSize += uPidlLen;
    //
    //  If the pSelection is for itself (not one of its children
    //  then we need its parent.)
    //
    if(!uTopLevelCount)
    {
        //
        //  Do surgery on the parent pidl, lob off the last item.
        //
        LPITEMIDLIST pParsePidl = CPidlUtils::LastItem(pParentPidl);
        pParsePidl->mkid.cb = 0;
        uTopLevelCount = 1;
    }

    m_rgPidls = new LPITEMIDLIST[uTopLevelCount];
    if(m_rgPidls)
    {
        pSelection->VisitEach(this, IXboxVisitor::FlagContinue);
        if(SUCCEEDED(m_hr))
        {
            UINT cbSize = sizeof(CIDA) + (m_uCount)*sizeof(UINT);
            cbSize += m_uTotalPidlSize;

            //
            //  Allocate the storage medium
            //
            if(fHere)
            {
                if(cbSize > GlobalSize(pstgm->hGlobal))
                {
                    m_hr = STG_E_MEDIUMFULL;
                } else
                {
                    pCida = (CIDA *)GlobalLock(pstgm->hGlobal);
                }
            } else
            {
                pstgm->hGlobal = GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT | GMEM_SHARE, cbSize);
                if (pstgm->hGlobal == NULL)
                {
                    m_hr = STG_E_MEDIUMFULL;
                } else
                {
                    pstgm->tymed = TYMED_HGLOBAL;
                    pstgm->pUnkForRelease = NULL;
                    pCida = (CIDA *)GlobalLock(pstgm->hGlobal);
                }
            }
        }
            
        //
        //  Copy the parent pidl.
        //
        if(pCida)
        {
            pCida->cidl = m_uCount;
            nNextPidlOffset = sizeof(CIDA) + m_uCount * sizeof(UINT);
            pCida->aoffset[0] = nNextPidlOffset;
            memcpy((BYTE*)pCida + nNextPidlOffset, pParentPidl, uPidlLen);
            nNextPidlOffset += uPidlLen;
        }
        //
        //  Free the parent pidl
        //  
        CPidlUtils::Free(pParentPidl);
        //
        //  Copy the other pidls, and free them.
        //
        for(uIndex = 0; uIndex < m_uCount; uIndex++)
        {
            if(pCida)
            {
                pCida->aoffset[uIndex+1] = nNextPidlOffset;
                uPidlLen = CPidlUtils::GetLength(m_rgPidls[uIndex]);
                memcpy((BYTE*)pCida + nNextPidlOffset, m_rgPidls[uIndex], uPidlLen);
                nNextPidlOffset += uPidlLen;
            }
            CPidlUtils::Free(m_rgPidls[uIndex]);
        }

        //
        //  Done with the storage medium.
        //
        if(pCida)
        {
            GlobalUnlock(pstgm->hGlobal);
        }

        //
        //  Done with the array for holding the pidls.
        //
        delete [] m_rgPidls;
    }
    return m_hr;
}


HRESULT CXboxDataObject::GetShellIdList(FORMATETC *pfetc, STGMEDIUM *pstgm, BOOL fHere)
/*++
  Routine Description:
    Called to for CF_SHELLIDLIST.  It is much easier to do all this work a helper
    class.
--*/
{
    CCreateShellIdList createShellIdList;
    return createShellIdList.GetShellIdList(this->m_uTopLevelItemCount, m_pSelection, pstgm, fHere);
}

HRESULT CXboxDataObject::SetPreferredDropEffect(FORMATETC *pfetc, STGMEDIUM *pstgm, BOOL fRelease)
{
    m_dwPreferredDropEffect = *((DWORD *)GlobalLock(pstgm->hGlobal));
    GlobalUnlock(pstgm->hGlobal);
    m_dwDropEffectFlags |= DROPEFFECT_PREFERERED_SET;
    return m_StoredFormats.Store(pfetc, pstgm, fRelease);
}

HRESULT CXboxDataObject::SetPerformedDropEffect(FORMATETC *pfetc, STGMEDIUM *pstgm, BOOL fRelease)
{
    m_dwPerformedDropEffect = *((DWORD *)GlobalLock(pstgm->hGlobal));
    GlobalUnlock(pstgm->hGlobal);
    m_dwDropEffectFlags |= DROPEFFECT_PERFORMED_SET;
    return m_StoredFormats.Store(pfetc, pstgm, fRelease);
}

HRESULT CXboxDataObject::SetLogicalPerformedDropEffect(FORMATETC *pfetc, STGMEDIUM *pstgm, BOOL fRelease)
{
    m_dwLogicalPerformedDropEffect = *((DWORD *)GlobalLock(pstgm->hGlobal));
    GlobalUnlock(pstgm->hGlobal);
    m_dwDropEffectFlags |= DROPEFFECT_LOGICALPERFORMED_SET;
    return m_StoredFormats.Store(pfetc, pstgm, fRelease);
}

HRESULT CXboxDataObject::SetPasteSucceeded(FORMATETC *pfetc, STGMEDIUM *pstgm, BOOL fRelease)
{
    m_dwPerformedDropEffect = *((DWORD *)GlobalLock(pstgm->hGlobal));
    GlobalUnlock(pstgm->hGlobal);
    m_dwDropEffectFlags |= DROPEFFECT_PASTESUCCEEDED_SET;
    return m_StoredFormats.Store(pfetc, pstgm, fRelease);
}

/*
**  Implementation of CStoredDataFormatList
**
*/

HRESULT CStoredDataFormatList::Store(FORMATETC *pFormatEtc, STGMEDIUM *pstgm, BOOL fRelease)
/*++
  Routine Description:
    Stores data in a given format in our list.  If there is already data of that format,
    then it writes over it.
--*/
{
    //
    //  We can only store types that we can easily duplicate.
    //
    if(!(pstgm->tymed&(TYMED_HGLOBAL|TYMED_ISTREAM|TYMED_ISTORAGE)))
    {
        return DV_E_TYMED;
    }

    //
    //  Look for a match, if so we will need to overwrite it.
    //

    CStoredDataFormat *pDataFormat = FindMatch(pFormatEtc);
    if(pDataFormat)
    {
        ReleaseStgMedium(&pDataFormat->m_stgm);
    } else
    {
        //
        //  No match so allocate the item
        //
        pDataFormat = new CStoredDataFormat;
        if(pDataFormat)
        {
            pDataFormat->m_pNext = m_pHead;
            m_pHead = pDataFormat;
            m_uCount++;
        } else
        {
            return STG_E_MEDIUMFULL;
        }
    }
    
    //
    //  Blast the FORMATETC
    //
    memcpy(&pDataFormat->m_fetc, pFormatEtc, sizeof(FORMATETC));

    //
    //  If fRelease is set than just blast it over
    //
    if(fRelease)
    {
        memcpy(&pDataFormat->m_stgm, pstgm, sizeof(STGMEDIUM));
    }
    else
    //
    //  Otherwise, use CopyStgMedium, and be prepared
    //  for failure.
    {
        HRESULT hr = CopyStgMedium(pstgm, &pDataFormat->m_stgm);
        if(FAILED(hr))
        {
          //
          // Free the format
          //
          if(pDataFormat == m_pHead)
          {
            m_pHead = pDataFormat->m_pNext;
          } else
          {
            CStoredDataFormat *pPreviousFormat = m_pHead;
            while(pDataFormat != pPreviousFormat->m_pNext)
            {
                pPreviousFormat = pPreviousFormat->m_pNext;
            }
                pPreviousFormat->m_pNext = pDataFormat->m_pNext;
          }
          delete pDataFormat;
          m_uCount--;
          return hr;
        }
    }
    return S_OK;
}

CStoredDataFormat *CStoredDataFormatList::FindMatch(FORMATETC *pfetc)
/*++
  Routine Description:
    Finds stored data that matches the given format.
--*/
{
    CStoredDataFormat *pFormat = m_pHead;
    while(pFormat)
    {
        if(SUCCEEDED(CXboxDataObject::AreFormatsEquivalent(&pFormat->m_fetc, pfetc)))
        {
          break;
        }
        pFormat = pFormat->m_pNext;
    }
    return pFormat;
}

CStoredDataFormatList::~CStoredDataFormatList()
/*++
  Routine Description:
   Destroy the list of stored formats and their contents.
   CStoredDataFormat is really just a slightly glorified
   structure.  The list really owns destruction.
--*/
{
    while(m_pHead)
    {
        CStoredDataFormat *pFormat = m_pHead;
        m_pHead = pFormat->m_pNext;
        ReleaseStgMedium(&pFormat->m_stgm);
        delete pFormat;
    }
}

void CStoredDataFormat::CopyFormat(FORMATETC *pFormatEtc)
/*++
  Routine Description:
    This is used only when retrieving IEnumFORMATETC.  When
    building the array of available formats, the list of stored
    formats is walked, and this method is how the
    format is retrieved from the object.
  Arguments:
   pFormatEtc - buffer to receive format.
--*/
{
    memcpy(pFormatEtc, &m_fetc, sizeof(FORMATETC));
}

HRESULT CStoredDataFormat::CopyTo(STGMEDIUM *pstgm)
/*++
  Routine Description:
    Used by GetData to copy the data out of a stored storage medium
    into a new one.
--*/
{
    return CopyStgMedium(&m_stgm, pstgm);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbshlext\debug.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    debug.h

Abstract:
    
    Debug Facilities.

Environment:

    Windows 2000 and Later 
    User Mode

Revision History:
    
    03-27-2001 : created

--*/


//
// Which stuff do you want to turn on for debug builds
//
#ifdef DBG
//#define SPEW_ENTER_STUFF   //Define to spew on entry to functions
#define OBJECT_TRACKING      //Define to track object (for finding leaks)
#endif

//----------------------------------------------------------------------
//  Debug Spew
//----------------------------------------------------------------------
#ifdef SPEW_ENTER_STUFF
#define RETURN(_RetValue_)\
    ATLTRACE("%s returning 0x%0.8x\n", __FUNCTION__, _RetValue_);\
    return _RetValue_;

#define ENTER_SPEW ATLTRACE("Enter %s\n", __FUNCTION__);
#else
#define RETURN(_RetValue_) return _RetValue_;
#define ENTER_SPEW
#endif

//----------------------------------------------------------------------
//  Object Tracking
//----------------------------------------------------------------------
#ifdef OBJECT_TRACKING

struct CTrackableObject
{
 CTrackableObject();
 ~CTrackableObject();
 CTrackableObject *m_pNext;
 CTrackableObject *m_pPrevious;
 LPCSTR m_pszClassName;
};

struct CObjectTracker
{
  CObjectTracker() : m_pHead(NULL), m_pTail(NULL), m_iObjectCount(0){InitializeCriticalSection(&m_CriticalSection);}
  ~CObjectTracker();
  void DumpObjects();
  CTrackableObject *m_pHead;
  CTrackableObject *m_pTail;
  int m_iObjectCount;
  CRITICAL_SECTION m_CriticalSection;
};

extern CObjectTracker g_ObjectTracker;


// Macros for declarations
#define CTRACKABLEOBJECT ,public CTrackableObject
#define INIT_TRACKABLEOBJECT_NAME(_ClassName_) m_pszClassName=#_ClassName_;
#define DUMP_TRACKED_OBJECTS() g_ObjectTracker.DumpObjects()

#else //OBJECT_TRACKING not defined

#define CTRACKABLEOBJECT
#define INIT_TRACKABLEOBJECT_NAME(_ClassName_)
#define DUMP_TRACKED_OBJECTS()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbshlext\debug.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    debug.cpp

Abstract:

    Implementation of some debug facilities

Environment:

    Windows 2000 and Later 
    User Mode

Revision History:
    
    08-09-2001 : created (mitchd)

--*/

#include <stdafx.h>

#ifdef OBJECT_TRACKING

//
//  Declare the global object tracker.
//
CObjectTracker g_ObjectTracker;

//
//  Dump Objects before the d'tor on the global is called.
//
CObjectTracker::~CObjectTracker()
{
    DUMP_TRACKED_OBJECTS();
    DeleteCriticalSection(&m_CriticalSection);
}


//
//  Trackable Object insert themselves on contruction.
//
CTrackableObject::CTrackableObject() : 
    m_pszClassName(NULL), m_pNext(NULL), m_pPrevious(NULL)
{
    EnterCriticalSection(&g_ObjectTracker.m_CriticalSection);
    if(g_ObjectTracker.m_pHead)
    {
        m_pPrevious = g_ObjectTracker.m_pTail;
        g_ObjectTracker.m_pTail->m_pNext = this;
        g_ObjectTracker.m_pTail = this;
    } else
    {
        g_ObjectTracker.m_pHead = g_ObjectTracker.m_pTail = this;
    }
    g_ObjectTracker.m_iObjectCount++;
    LeaveCriticalSection(&g_ObjectTracker.m_CriticalSection);
}

//
//  Trackable Object remove themselves on destruction.
//
CTrackableObject::~CTrackableObject()
{
    EnterCriticalSection(&g_ObjectTracker.m_CriticalSection);
    g_ObjectTracker.m_iObjectCount--;
    if(m_pPrevious)
    {
        m_pPrevious->m_pNext = m_pNext;
    } else
    {
        g_ObjectTracker.m_pHead = m_pNext;
    }
    if(m_pNext)
    {
        m_pNext->m_pPrevious = m_pPrevious;
    } else
    {
        g_ObjectTracker.m_pTail = m_pPrevious;
    }
    LeaveCriticalSection(&g_ObjectTracker.m_CriticalSection);
}

//
//  The object tracker can dump its objects
//
void CObjectTracker::DumpObjects()
{
    EnterCriticalSection(&m_CriticalSection);
    CTrackableObject *pObject = m_pHead;
    if(m_iObjectCount)
    {
        ATLTRACE("Dumping %d objects still allocated\n", m_iObjectCount);
        while(pObject)
        {
            ATLTRACE("OBJ: %s(0x%0.8x)\n", pObject->m_pszClassName, pObject);
            pObject = pObject->m_pNext;
        }
    } else
    {
        ATLTRACE("There are no objects still allocated\n");
    }
    LeaveCriticalSection(&m_CriticalSection);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbshlext\dataobj.h ===
/*++

Copyright (c) Microsoft Corporation


Module Name:

    DataObj.h

Abstract:
    
    Declares the CXboxDataObject class

Environment:

    Windows 2000
    Uses ATL

Notes:

Revision History:

    April 2001 - created by Mitchell Dernis (mitchd)
    July  2001 - major overhaul (mitchd)

--*/
#ifndef __XBOXDATAOBJ_H__
#define __XBOXDATAOBJ_H__

//------------------------------------------------------------------------
//  Propertary clipboard format for Xbox files.
//
//  This clipboard format is an Xbox specific variation on
//  CFSTR_FILEDESCRIPTOR.  The primary change is the addition of the
//  machine name.  All the files described must be on the same machine.
//
//  There is enough information to obtain a CXboxItem in the target
//  process.
//
//  FORMATETC
//   cfFormat = CFXBOX_FILEDESCRIPTOR 
//   ptd      = NULL
//   dwAspect = DVASPECT_CONTENT
//   lindex   = 0
//   tymed    = TYMED_HGLOBAL
//
//  The contents of the HGLOBAL is CFXBOX_FILEORDIRECTORY.
//
//  
//------------------------------------------------------------------------
const TCHAR CFXBOX_FILEDESCRIPTOR[] = TEXT("CFXBOX_FILEDESCRIPTOR");
typedef struct _XBOXFILEGROUPDESCRIPTOR {
    UINT cItems;
    CHAR szFolderPath[MAX_PATH];
    FILEDESCRIPTORA fgd[1];         //Always ANSI
} XBOXFILEGROUPDESCRIPTOR, *PXBOXFILEGROUPDESCRIPTOR;

//--------------------------------------------------------------------------------
//  Forward Class Declarations
//--------------------------------------------------------------------------------
class CStoredDataFormat;
class CStoredDataFormatList;
class CXboxDataObject;

//--------------------------------------------------------------------------------
//  typedef a specialization of CComEnum for EnumFormatEtc.
//--------------------------------------------------------------------------------
typedef CComEnum<IEnumFORMATETC,&IID_IEnumFORMATETC,FORMATETC,_Copy<FORMATETC>,CComMultiThreadModel> CEnumFormatEtc;

//--------------------------------------------------------------------------------
//  Supported Formats Table
//--------------------------------------------------------------------------------

typedef HRESULT (CXboxDataObject::*PFN_GETDATA)(FORMATETC *pfetc, STGMEDIUM *pstgm, BOOL fHere);
typedef struct _GET_DATA_FORMAT_TABLE_ENTRY
{
    FORMATETC   formatEtc;
    PFN_GETDATA pfnGetData;
} GET_DATA_FORMAT_TABLE_ENTRY, *PGET_DATA_FORMAT_TABLE_ENTRY;

typedef HRESULT (CXboxDataObject::*PFN_SETDATA)(FORMATETC *pfetc, STGMEDIUM *pstgm, BOOL fRelease);
typedef struct _SET_DATA_FORMAT_TABLE_ENTRY
{
    FORMATETC   formatEtc;
    PFN_SETDATA pfnSetData;
} SET_DATA_FORMAT_TABLE_ENTRY, *PSET_DATA_FORMAT_TABLE_ENTRY;

//------------------------------------------------------------------------
// CStoredDataFormat - for storing generic formats
//------------------------------------------------------------------------
class CStoredDataFormat
{
  public:

    CStoredDataFormat *GetNext() {return m_pNext;}
    void               CopyFormat(FORMATETC *pFormatEtc);   //Only information about the format
    HRESULT            CopyTo(STGMEDIUM *pstgm);            //Retrieves the data.
    
  private:
    
    CStoredDataFormat():m_pNext(NULL){}
    ~CStoredDataFormat(){}

    FORMATETC m_fetc;
    STGMEDIUM m_stgm;
    
    CStoredDataFormat *m_pNext;
    friend class CStoredDataFormatList;    
};

class CStoredDataFormatList
{
 public:
  CStoredDataFormatList() : m_pHead(NULL), m_uCount(0){}
  ~CStoredDataFormatList();

  HRESULT           Store(FORMATETC *pFormatEtc, STGMEDIUM *pstgm, BOOL fRelease);
  CStoredDataFormat *FindMatch(FORMATETC *pfetc);
  UINT              GetCount() {return m_uCount;}
  CStoredDataFormat *GetFirst() {return m_pHead;}

 private:    
  CStoredDataFormat *m_pHead;
  UINT               m_uCount;
};

//------------------------------------------------------------------------
// CXboxDataObject
//------------------------------------------------------------------------
class ATL_NO_VTABLE CXboxDataObject : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public IObjectWithSiteImpl<CXboxDataObject>,
    public IAsyncOperation,
    public IDataObject
{
 
  public:
    /*
    **  c'tor and d'tor
    */
    CXboxDataObject () : 
        m_pSelection(NULL),
        m_ulShellAttributes(0),
        m_fDidAsynchStart(FALSE),
        m_pXboxFileGroupDescriptor(NULL),
        m_uTopLevelItemCount(0),
        m_pUnkThread(NULL),
        m_dwPreferredDropEffect(0),
        m_dwPerformedDropEffect(0),
        m_dwLogicalPerformedDropEffect(0),
        m_dwPasteSucceeded(0),
        m_dwDropEffectFlags(0){}
    ~CXboxDataObject ();

    static HRESULT Create(UINT cidl, LPCITEMIDLIST * apidl, CXboxFolder *pParent, IDataObject **ppDataObject);
    static HRESULT Create(UINT cidl, CXboxFolder *pSelection, IDataObject **ppDataObject);

    /*
    ** ATL Interface Map
    */
    DECLARE_PROTECT_FINAL_CONSTRUCT()
    BEGIN_COM_MAP(CXboxDataObject)
     COM_INTERFACE_ENTRY_IID(IID_IObjectWithSite, IObjectWithSite)
     COM_INTERFACE_ENTRY_IID(IID_IDataObject, IDataObject)
     COM_INTERFACE_ENTRY_IID(IID_IAsyncOperation, IAsyncOperation)
    END_COM_MAP()

  public:
   
    /*
    ** IDataObject methods
    */
    STDMETHOD(GetData)(FORMATETC *pfmtetcIn, STGMEDIUM *pstgmed);
    STDMETHOD(GetDataHere)(FORMATETC *pfmtetc, STGMEDIUM *pstgpmed);
    STDMETHOD(QueryGetData)(FORMATETC *pfmtetc);
    STDMETHOD(GetCanonicalFormatEtc)(FORMATETC *pfmtetcIn, FORMATETC *pfmtetcOut);
    STDMETHOD(SetData)(FORMATETC *pfmtetc, STGMEDIUM *pstgmed, BOOL bRelease);
    STDMETHOD(EnumFormatEtc)(DWORD dwDirection, IEnumFORMATETC **ppienumFormatEtc);
    STDMETHOD(DAdvise)(FORMATETC *pfmtetc, DWORD dwAdviseFlags, IAdviseSink * piadvsink, DWORD * pdwConnection);
    STDMETHOD(DUnadvise)(DWORD dwConnection);
    STDMETHOD(EnumDAdvise)(IEnumSTATDATA **ppienumStatData);

    /*
    ** IAsyncOperation methods
    */
    STDMETHOD(EndOperation)(HRESULT hResult, IBindCtx *pbcReserved, DWORD dwEffects);
    STDMETHOD(SetAsyncMode)(BOOL fDoOpAsync){return E_NOTIMPL;}
    STDMETHOD(GetAsyncMode)(BOOL *pfIsOpAsync);
    STDMETHOD(InOperation)(BOOL *pfInAsyncOp);
    STDMETHOD(StartOperation)(IBindCtx *pbcReserved);

    //
    //  A generally useful utility function, ever so slightly customized with respect
    //  to CF_FILECONTENTS
    //
    static HRESULT AreFormatsEquivalent(FORMATETC *pFormatEtc1, FORMATETC *pFormatEtc2);

  protected:

    
    static HRESULT CopyToHGlobal(STGMEDIUM *pstgm, PVOID pvData, UINT cbSize, BOOL fHere);

    //
    //  Used by GetData, QueryGetData. 
    //

    HRESULT FindMatchingGetFormat(FORMATETC *pFormatEtc, PUINT puIndex = NULL);

    //
    //  Used by SetData.
    //

    HRESULT FindMatchingSetFormat(FORMATETC *pFormatEtc, PUINT puIndex = NULL);

    //
    //  Helpers for many of the GetXXX methods.
    //
    PXBOXFILEGROUPDESCRIPTOR GetXboxFileGroupDescriptor();
    bool IsValidFileContentsIndex(UINT uIndex);

    //
    //  Handle getting and setting data objects.
    //

    HRESULT GetXboxDescriptor(FORMATETC *pfetc, STGMEDIUM *pstgm, BOOL fHere);
    HRESULT GetFileDescriptorA(FORMATETC *pfetc, STGMEDIUM *pstgm, BOOL fHere);
    HRESULT GetFileDescriptorW(FORMATETC *pfetc, STGMEDIUM *pstgm, BOOL fHere);
    HRESULT GetFileContents(FORMATETC *pfetc, STGMEDIUM *pstgm, BOOL fHere);
    HRESULT GetShellIdList(FORMATETC *pfetc, STGMEDIUM *pstgm, BOOL fHere);
    HRESULT SetPreferredDropEffect(FORMATETC *pfetc, STGMEDIUM *pstgm, BOOL fRelease);
    HRESULT SetPerformedDropEffect(FORMATETC *pfetc, STGMEDIUM *pstgm, BOOL fRelease);
    HRESULT SetLogicalPerformedDropEffect(FORMATETC *pfetc, STGMEDIUM *pstgm, BOOL fRelease);
    HRESULT SetPasteSucceeded(FORMATETC *pfetc, STGMEDIUM *pstgm, BOOL fRelease);

    //
    //  Data
    //

    CXboxFolder             *m_pSelection;
    ULONG                    m_ulShellAttributes;
    BOOL                     m_fDidAsynchStart;
    PXBOXFILEGROUPDESCRIPTOR m_pXboxFileGroupDescriptor;
    UINT                     m_uTopLevelItemCount;
    CStoredDataFormatList    m_StoredFormats;
    IUnknown                *m_pUnkThread;
    
    DWORD   m_dwPreferredDropEffect;
    DWORD   m_dwPerformedDropEffect;
    DWORD   m_dwLogicalPerformedDropEffect;
    DWORD   m_dwPasteSucceeded;
    DWORD   m_dwDropEffectFlags;
    #define DROPEFFECT_PREFERERED_SET        0x01
    #define DROPEFFECT_PERFORMED_SET         0x02
    #define DROPEFFECT_LOGICALPERFORMED_SET  0x04
    #define DROPEFFECT_PASTESUCCEEDED_SET    0x08


    //
    //  static data
    //
    
    static GET_DATA_FORMAT_TABLE_ENTRY sm_GetDataSupportedFormats[];
    static UINT                        sm_uGetDataSupportedCount;

    static SET_DATA_FORMAT_TABLE_ENTRY sm_SetDataSupportedFormats[];
    static UINT                        sm_uSetDataSupportedCount;
};

#endif //__XBOXDATAOBJ_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbshlext\delete.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    delete.h

Abstract:

    Declaration of CXboxDelete.

    Pass an instance to VisitEach or VisitThese to visit death
    and deletion upon such items.

Environment:

    Windows 2000 and Later 
    User Mode

Revision History:
    
    07-18-2001 : created (mitchd)

--*/

#include "stdafx.h"

class CXboxDelete : public IXboxVisitor
{
  public:
 
    CXboxDelete(HWND hWnd, UINT uItemCount, bool fSilent);
    ~CXboxDelete();

    virtual void VisitRoot         (IXboxVisit *pRoot,                DWORD *pdwFlags);   
    virtual void VisitAddConsole   (IXboxVisit *pAddConsole,          DWORD *pdwFlags);
    virtual void VisitConsole      (IXboxConsoleVisit   *pConsole,    DWORD *pdwFlags);   
    virtual void VisitVolume       (IXboxVolumeVisit    *pVolume,     DWORD *pdwFlags);
    virtual void VisitFileOrDir    (IXboxFileOrDirVisit *pFileOrDir,  DWORD *pdwFlags);
    virtual void VisitDirectoryPost (IXboxFileOrDirVisit *pFileOrDir, DWORD *pdwFlags);
    
  private:

    //
    //  Internal Helpers Methods
    //

    void StartProgressDialog();

    //
    //  arguments from C'tor
    //

    HWND                m_hWnd;
    bool                m_fSilent;

    //
    //  Internal Variables
    //

    bool             m_fFirstItem;
    bool             m_fYesToAllReadOnly;
    bool             m_fNoToAllReadOnly;
    UINT             m_uRecurseDepth;
    UINT             m_uItemCount;
    IProgressDialog *m_pProgressDialog;
    

    // These are really part of us.  We need to make them separate
    // classes and members that point back to us for the CXboxFunctionObject
    // stuff to work.

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbshlext\delete.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    delete.h

Abstract:

    Implementation of CXboxDelete.

    Pass an instance to VisitEach or VisitThese to visit death
    and deletion upon such items.

Environment:

    Windows 2000 and Later 
    User Mode

Revision History:
    
    07-18-2001 : created (mitchd)

--*/

#include "stdafx.h"

CXboxDelete::CXboxDelete(HWND hWnd, UINT uItemCount, bool fSilent) : 
    m_hWnd(hWnd), m_uItemCount(uItemCount),
    m_fSilent(fSilent), m_fFirstItem(true),
    m_fYesToAllReadOnly(false), m_fNoToAllReadOnly(false),
    m_uRecurseDepth(0), m_pProgressDialog(NULL)
{
}

CXboxDelete::~CXboxDelete()
{
    if(m_pProgressDialog)
    {
        m_pProgressDialog->StopProgressDialog();
        m_pProgressDialog->Release();
    }
}

void CXboxDelete::StartProgressDialog()
{
    HRESULT hr;
    WCHAR   wszBuffer[128];
    
    //
    //  Show Dialog That we are preparing the copy.
    //
    hr = CoCreateInstance(
            CLSID_ProgressDialog,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IProgressDialog,
            (LPVOID *)&m_pProgressDialog
            );
    if(FAILED(hr))
    {
        m_pProgressDialog = NULL;
        return;
    }

    //
    //  Set the title of the progress dialog
    //
    
    LoadStringW(_Module.GetModuleInstance(), IDS_FILE_DELETE_PROGRESS_TITLE, wszBuffer, 128);
    m_pProgressDialog->SetTitle(wszBuffer);
    
    //
    //  Set the animation for the progress dialog
    //
    
    m_pProgressDialog->SetAnimation(_Module.GetModuleInstance(), IDA_DELETE);
    
    //
    //  Set the cancel message for the progress dialog
    //

    LoadStringW(_Module.GetModuleInstance(), IDS_FILE_PROGRESS_CANCEL, wszBuffer, 128);
    m_pProgressDialog->SetCancelMsg(wszBuffer, NULL);

    //
    //  Set Line One Text
    //
    LoadStringW(_Module.GetModuleInstance(), IDS_FILE_DELETE_PROGRESS_STATUS, wszBuffer, 128);
    m_pProgressDialog->SetLine(1, wszBuffer, FALSE, NULL);

    //
    //  Show the progress dialog
    //

    m_pProgressDialog->StartProgressDialog(m_hWnd, NULL, PROGDLG_AUTOTIME, NULL);
}



void CXboxDelete::VisitRoot(IXboxVisit *pRoot, DWORD *pdwFlags)
/*++
  Routine Description:
   User is attempting to delete the root.  Given them some nice
   message telling them that they cannot.  If they like like though,
   they may uninstall.
--*/
{
    //
    //  Display Cannot delete message.
    //
    WindowUtils::MessageBoxResource(m_hWnd, IDS_CANNOT_DELETE_ROOT, IDS_GENERIC_CAPTION, MB_OK|MB_ICONEXCLAMATION);
    // Stop visits.
    *pdwFlags = 0;
}

void CXboxDelete::VisitAddConsole(IXboxVisit *pAddConsole, DWORD *pdwFlags)
{
    WindowUtils::MessageBoxResource(m_hWnd, IDS_CANNOT_DELETE_ADD_XBOX, IDS_GENERIC_CAPTION, MB_OK|MB_ICONEXCLAMATION);
}

void CXboxDelete::VisitConsole(IXboxConsoleVisit *pConsole, DWORD *pdwFlags)
/*++
  Routine Description:
    Delete a console.  A.K.A. remove a console from the list of console that
    we know about.  This will fail if it is the default console.
        
    NOT YET IMPLEMENTED.
    
    This Yes\No behavior on each console should be consistent with the way printers
    work in the shell.

--*/
{
    UINT uMsgResult; 
    char szConfirmText[512];
    char szConfirmCaption[60];
    char szConsoleName[60];

    pConsole->GetName(szConsoleName);

    //
    //  Get confirmation.
    //
    CManageConsoles consoleManager;
    BOOL fIsDefault = consoleManager.IsDefault(szConsoleName);
    LoadStringA(_Module.GetModuleInstance(), IDS_CONFIRM_REMOVE_CONSOLE_CAPTION, szConfirmCaption, ARRAYSIZE(szConfirmCaption));
    if(m_fFirstItem)
    {
        m_fFirstItem = false;

        //
        //  There may be one or more than one selected console
        //
        if( m_uItemCount > 1)
        {
            WindowUtils::rsprintf(szConfirmText, IDS_CONFIRM_REMOVE_MULTIPLE_CONSOLES, m_uItemCount);
        } else
        {
            WindowUtils::rsprintf(szConfirmText, IDS_CONFIRM_REMOVE_CONSOLE, szConsoleName);
        }
        // Show this Message if the first item is not the default or if multiple consoles to be deleted.
        // If there is just one console and it is the default, then the below dialog will suffice.
        if((m_uItemCount > 1) || !fIsDefault)
        {
            if(IDYES!=MessageBoxA(m_hWnd, szConfirmText, szConfirmCaption, MB_YESNO|MB_ICONQUESTION))
            {
                *pdwFlags = 0;
                return;
            }
        }
    }
    if(fIsDefault)
    {
        m_fFirstItem = false;
        WindowUtils::rsprintf(szConfirmText, IDS_CONFIRM_REMOVE_DEFAULT_CONSOLE, szConsoleName);
        if(IDYES!=MessageBoxA(m_hWnd, szConfirmText, szConfirmCaption, MB_YESNO|MB_ICONQUESTION))
        {
            return;
        }
        consoleManager.SetDefault(NULL);
    }

    
    
    //
    //  Get the pidl
    //
    LPITEMIDLIST pidl = pConsole->GetPidl(CPidlUtils::PidlTypeAbsolute);
    
    //
    //  Remove the console from the registry.
    //
    consoleManager.Remove(szConsoleName);
    
    //
    //  Notify everyone of the change.
    //
    if(pidl)
    {
        SHChangeNotify(SHCNE_DELETE, SHCNF_IDLIST|SHCNF_FLUSH, pidl, NULL);
        CPidlUtils::Free(pidl);
    }
}

void CXboxDelete::VisitVolume(IXboxVolumeVisit *pVolume, DWORD *pdwFlags)
{
    MessageBoxA(m_hWnd, "Cannot delete a volume.", "CXboxDelete", MB_OK|MB_ICONERROR);
}

void CXboxDelete::VisitFileOrDir(IXboxFileOrDirVisit *pFileOrDir, DWORD *pdwFlags)
/*++
  Routine Description:
    Called to confirm deletion of files and\or folders.  This is the full blown
    confirmation deal.
    
    1) Get the attributes and name.  Return any errors that occur while retrieving these.

    2) If this is the first item of a group of selected items to delete:
    
      a) confirm the whole shabang. 

      b) If the user said 'Yes', start the Progress Dialog.

      c) If the user did not say 'Yes' return E_ABORT.

    3) Check for cancel in the progress dialog.  return E_ABORT on a cancel.

    4) Update the progress dialog to indicate we are working on the current item.

    5) If (one of multiple top-level items AND read-only item AND m_fYesToAllReadOnly is false)
      
      a) Ask the user to confirm.

      b) return S_FALSE if the user said no.

      c) Set m_fYesToAllReadOnly if the user said yes to all.

    6) Increment the recursion depth for any children we may or may not have.

    7) return S_OK.
--*/
{
    HRESULT hr;
    DM_FILE_ATTRIBUTES dmFileAttributes;
    char szItemName[MAX_PATH];
    bool fReadOnly;
    bool fFolder;
    bool fDelete  = true;
    UINT uConfirm;
    
    
    //
    //  Get the attributes.
    //

    pFileOrDir->GetFileAttributes(&dmFileAttributes);
    fReadOnly = (dmFileAttributes.Attributes&FILE_ATTRIBUTE_READONLY) ? true : false;
    fFolder = dmFileAttributes.Attributes&FILE_ATTRIBUTE_DIRECTORY ? true : false;

    if(!m_fSilent)
    {
       
        //
        //  This will give the relative name if we are recursing.
        //
        pFileOrDir->GetName(szItemName);
    
        //
        //  Get User Confirmation
        //  (for this we need the number of items, the name and attributes of the first item)
        //

        if(m_fFirstItem)
        {
            m_fFirstItem = false;

            //
            // There are three different confirmation dialogs for 
            // ConfirmDeleteMultiple, ConfirmDeleteFolder, ConfirmDelete
            // Figure out which one and collect the proper information.
            //
        
            if( m_uItemCount > 1)
            {
                uConfirm = Dialog::ConfirmDeleteMultiple(m_hWnd, m_uItemCount);
            } else
            {
                uConfirm = Dialog::ConfirmDelete(m_hWnd, szItemName, fFolder, fReadOnly);
            }

            if(IDC_XB_YES==uConfirm)
            {
                StartProgressDialog();
            } else
            {
                *pdwFlags = 0;
                return;
            }
        }
    
        if(m_pProgressDialog)
        {
        
            WCHAR wszName[512];
            LoadStringW(_Module.GetModuleInstance(), IDS_FILE_DELETE_PROGRESS_TITLE, wszName, 128);
            m_pProgressDialog->SetTitle(wszName);

            if(m_pProgressDialog->HasUserCancelled())
            {
                *pdwFlags = 0;
                return;
            }

            wsprintfW(wszName, L"%hs", szItemName);
            m_pProgressDialog->SetLine(2, wszName, TRUE, NULL);
        }

        if(!m_uRecurseDepth && (m_uItemCount!=1) && fReadOnly)
        {
            if(m_fYesToAllReadOnly)
            {
                *pdwFlags |= IXboxVisitor::FlagCallPost;
            } else if(m_fNoToAllReadOnly)
            {
                *pdwFlags &= ~IXboxVisitor::FlagCallPost;
            } else
            {
                uConfirm = Dialog::ConfirmDelete(m_hWnd, szItemName, fFolder, fReadOnly);
                switch(uConfirm)
                {
                    case IDC_XB_YESTOALL:    
                        m_fYesToAllReadOnly = true;
                    case IDC_XB_YES:
                        break;
                    case IDC_XB_NOTOALL:
                        m_fNoToAllReadOnly = true;
                    case IDC_XB_NO:
                        fDelete = false;
                        break;
                    case IDC_XB_CANCEL:
                        *pdwFlags = 0;
                        return;
                }
            }
        }
    }
    //
    //  If we are going to delete this item,
    //  we may have work.
    if(fDelete)
    {
        //
        //  If it is not a folder, peform the delete
        //  here.
        //
        if(!fFolder)
        {   
            LPITEMIDLIST pidl = pFileOrDir->GetPidl(CPidlUtils::PidlTypeAbsolute);
            hr = pFileOrDir->Delete();
            if(SUCCEEDED(hr))
            {
               if(pidl)
               {
                   SHChangeNotify(SHCNE_DELETE, SHCNF_IDLIST|SHCNF_FLUSH, pidl, NULL);
               }

            } else if(!m_fSilent)
            {
                MessageBoxA(m_hWnd, szItemName, "Could not delete file.", MB_OK|MB_ICONERROR);
            }
            if(pidl)
            {
                CPidlUtils::Free(pidl);
            }
        } else
        //
        //  It is a folder
        //
        {
            *pdwFlags = IXboxVisitor::FlagRecurse | 
                        IXboxVisitor::FlagContinue |
                        IXboxVisitor::FlagCallPost;
            m_uRecurseDepth++;
        }
    }
    return;
}

void CXboxDelete::VisitDirectoryPost(IXboxFileOrDirVisit *pDirectory, DWORD *pdwFlags)
{
    HRESULT hr;

    LPITEMIDLIST pidl = pDirectory->GetPidl(CPidlUtils::PidlTypeAbsolute);
    m_uRecurseDepth--;
    hr = pDirectory->Delete();
    if(SUCCEEDED(hr))
    {
       if(pidl)
       {
           SHChangeNotify(SHCNE_RMDIR, SHCNF_IDLIST|SHCNF_FLUSH, pidl, NULL);
       }

    } else if(!m_fSilent)
    {
        MessageBoxA(m_hWnd, NULL, "Could not delete folder.", MB_OK|MB_ICONERROR);
    }
    if(pidl)
    {
        CPidlUtils::Free(pidl);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbshlext\details.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    details.cpp

Abstract:

   Implementation of GetDetails and GetColumnHeaderDetails
   for CXboxFolder and its derivatives.

Environment:

    Windows 2000 and Later 
    User Mode
    Compiles UNICODE, but uses many ANSI APIs explictly.

Revision History:
    
    07-11-2001 : created

--*/

#include "stdafx.h"


//---------------------------------------------------------------------------------------------
//  Table for storing column information
//---------------------------------------------------------------------------------------------
typedef struct _XBOX_COLUMN_HEADER_INFORMATION
{
    //For SHCOLUMNID
    const GUID   *pfmtid;
    DWORD        pid;
    //For SHELLDETAILS
    int          fmt;
    int          cxChar;
    //For Finding Resources
    int          ResourceId;
} XBOX_COLUMN_HEADER_INFORMATION, *PXBOX_COLUMN_HEADER_INFORMATION;

static XBOX_COLUMN_HEADER_INFORMATION RootColumns[] = 
{
  /*XBOX_CONSOLE_COLUMN_NAME*/   {&FMTID_Storage, PID_STG_NAME, LVCFMT_LEFT, 30, IDS_COLUMN_HEADER_NAME},
  /*XBOX_CONSOLE_COLUMN_IPADDR*/ {&FMTID_ShellDetails, PID_DESCRIPTIONID, LVCFMT_LEFT, 16, IDS_COLUMN_HEADER_IPADDR}
};

static XBOX_COLUMN_HEADER_INFORMATION ConsoleColumns[] =
{
  /*XBOX_VOLUME_COLUMN_NAME*/ {&FMTID_Storage, PID_STG_NAME, LVCFMT_LEFT, 30, IDS_COLUMN_HEADER_NAME},
  /*XBOX_VOLUME_COLUMN_TYPE*/ {&FMTID_Storage, PID_STG_STORAGETYPE, LVCFMT_LEFT, 20, IDS_COLUMN_HEADER_TYPE},
  /*XBOX_VOLUME_COLUMN_FREE_CAPACITY*/{&FMTID_Volume, PID_VOLUME_FREE, LVCFMT_CENTER, 10, IDS_COLUMN_HEADER_FREE_CAPACITY}, 
  /*XBOX_VOLUME_COLUMN_TOTAL_CAPACITY*/{&FMTID_Storage, PID_STG_SIZE, LVCFMT_CENTER, 10, IDS_COLUMN_HEADER_TOTAL_CAPACITY}
};

static XBOX_COLUMN_HEADER_INFORMATION FileSystemFolderColumns[] =
{
  /*XBOX_FILE_COLUMN_NAME*/ {&FMTID_Storage, PID_STG_NAME, LVCFMT_LEFT, 30, IDS_COLUMN_HEADER_NAME},
  /*XBOX_FILE_COLUMN_SIZE*/ {&FMTID_Storage, PID_STG_SIZE, LVCFMT_RIGHT, 10, IDS_COLUMN_HEADER_SIZE},
  /*XBOX_FILE_COLUMN_TYPE*/ {&FMTID_Storage, PID_STG_STORAGETYPE, LVCFMT_LEFT, 15, IDS_COLUMN_HEADER_TYPE},
  /*XBOX_FILE_COLUMN_MODIFIED*/ {&FMTID_Storage, PID_STG_WRITETIME, LVCFMT_LEFT, 20, IDS_COLUMN_HEADER_MODIFIED},
  /*XBOX_FILE_COLUMN_ATTRIBUTE*/{&FMTID_Storage, PID_STG_ATTRIBUTES, LVCFMT_LEFT, 8, IDS_COLUMN_HEADER_ATTRIBUTES}
};

//---------------------------------------------------------------------------------------------
//  Table Implementation
//---------------------------------------------------------------------------------------------
static HRESULT GetColumnHeaderDetailsFromTable(PXBOX_COLUMN_HEADER_INFORMATION pTable, UINT uColumnCount, UINT iColumn, SHELLDETAILS *pShellDetails)
{
    if(iColumn >= uColumnCount)
    {
        return E_FAIL;
    }
    pShellDetails->cxChar = pTable[iColumn].cxChar;
    pShellDetails->fmt = pTable[iColumn].fmt;
    pShellDetails->str.uType = STRRET_CSTR;
    if(!LoadStringA(_Module.GetModuleInstance(), pTable[iColumn].ResourceId, pShellDetails->str.cStr, MAX_PATH))
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }
    return S_OK;
}

HRESULT CXboxRoot::GetColumnHeaderDetails(UINT iColumn, SHELLDETAILS *pShellDetails)
{
    UINT uColumnCount = (sizeof(RootColumns)/sizeof(XBOX_COLUMN_HEADER_INFORMATION));
    return GetColumnHeaderDetailsFromTable(RootColumns, uColumnCount, iColumn, pShellDetails);
}

HRESULT CXboxConsole::GetColumnHeaderDetails(UINT iColumn, SHELLDETAILS *pShellDetails)
{
    UINT uColumnCount = (sizeof(ConsoleColumns)/sizeof(XBOX_COLUMN_HEADER_INFORMATION));
    return GetColumnHeaderDetailsFromTable(ConsoleColumns, uColumnCount, iColumn, pShellDetails);
}

HRESULT CXboxFileSystemFolder::GetColumnHeaderDetails(UINT iColumn, SHELLDETAILS *pShellDetails)
{
    UINT uColumnCount = (sizeof(FileSystemFolderColumns)/sizeof(XBOX_COLUMN_HEADER_INFORMATION));
    return GetColumnHeaderDetailsFromTable(FileSystemFolderColumns, uColumnCount, iColumn, pShellDetails);
}

HRESULT CXboxRoot::GetDetails(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pShellDetails)
{
    UINT uIndex;
    LPSTR pszParse;
    HRESULT hr = RefreshChildren();
    if(FAILED(hr))
    {
        return hr;
    }   

    hr = GetChildIndex((LPCSTR)pidl->mkid.abID, &uIndex);
    if(FAILED(hr))
    {
        return hr;        
    }

    //
    //  Fill out the column information
    //

    pShellDetails->str.uType = STRRET_CSTR;
    pszParse = m_rgpszChildNames[uIndex];
    switch(iColumn)
    {
        // Get the Actual Name
        case XBOX_CONSOLE_COLUMN_NAME:
          if(*pszParse=='?')
          {
             pszParse++;
             strcpy(pShellDetails->str.cStr, pszParse);
          } else
          {
             strcpy(pShellDetails->str.cStr, GetActualName(uIndex));
          }
          break;
        case XBOX_CONSOLE_COLUMN_IPADDR:
          if(*pszParse!='?')
          {
              DWORD dwChildIPAddress = GetChildIpAddress(uIndex);
              wsprintfA(pShellDetails->str.cStr,
                        "%d.%d.%d.%d",
                        (dwChildIPAddress >> 24)&0xFF,
                        (dwChildIPAddress >> 16)&0xFF,
                        (dwChildIPAddress >> 8)&0xFF,
                         dwChildIPAddress&0xFF
                        );
          } else
          {
            *pShellDetails->str.cStr = '\0';
          }
          break;
        default:
          hr = E_INVALIDARG;
    }
    return hr;
}

HRESULT CXboxConsole::GetDetails(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pShellDetails)
{
    UINT uIndex;
    LPSTR pszParse;
    HRESULT hr = RefreshChildren();
    if(FAILED(hr))
    {
        return hr;
    }   

    hr = GetChildIndex((LPCSTR)pidl->mkid.abID, &uIndex);
    if(FAILED(hr))
    {
        return hr;        
    }

    //
    //  Fill out the column information
    //
    pszParse = m_rgpszChildNames[uIndex];
    pShellDetails->str.uType = STRRET_CSTR;
    switch(iColumn)
    {
        //return the name for both the name and IP address for now.
        case XBOX_VOLUME_COLUMN_NAME:
          strcpy(pShellDetails->str.cStr, pszParse);
          break;
        case XBOX_VOLUME_COLUMN_TYPE:
          LoadStringA(_Module.GetModuleInstance(), m_rguChildVolumeType[uIndex], pShellDetails->str.cStr, MAX_PATH);
          break;
        case XBOX_VOLUME_COLUMN_FREE_CAPACITY:
          FormatUtils::FileSize(m_rgullChildFreeSpace[uIndex], pShellDetails->str.cStr);
          break;
        case XBOX_VOLUME_COLUMN_TOTAL_CAPACITY:
          FormatUtils::FileSize(m_rgullChildTotalSpace[uIndex], pShellDetails->str.cStr);
          break;
        default:
          hr = E_INVALIDARG;
    }
    return hr;
}

HRESULT CXboxFileSystemFolder::GetDetails(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pShellDetails)
{
    UINT uIndex;
    HRESULT hr = RefreshChildren();
    if(FAILED(hr))
    {
        return hr;
    }   

    hr = GetChildIndex((LPCSTR)pidl->mkid.abID, &uIndex);
    if(FAILED(hr))
    {
        return hr;        
    }

    //
    //  Fill out the column information
    //

    pShellDetails->str.uType = STRRET_CSTR;
    switch(iColumn)
    {
        case XBOX_FILE_COLUMN_NAME:
          strcpy(pShellDetails->str.cStr, m_rgpszChildNames[uIndex]);
          break;
        case XBOX_FILE_COLUMN_TYPE:
          strcpy(pShellDetails->str.cStr, m_rgszChildTypeNames[uIndex]);
          break;
        case XBOX_FILE_COLUMN_SIZE:
          if(m_rgChildFileAttributes[uIndex].Attributes&FILE_ATTRIBUTE_DIRECTORY)
          {
            *pShellDetails->str.cStr = '\0';
          } else
          {
              ULARGE_INTEGER uli;
              uli.HighPart = m_rgChildFileAttributes[uIndex].SizeHigh;
              uli.LowPart = m_rgChildFileAttributes[uIndex].SizeLow;
              FormatUtils::FileSize(uli.QuadPart, pShellDetails->str.cStr);
          }
          break;
        case XBOX_FILE_COLUMN_MODIFIED:
          FormatUtils::FileTime(&m_rgChildFileAttributes[uIndex].ChangeTime, pShellDetails->str.cStr);
          break;
        case XBOX_FILE_COLUMN_ATTRIBUTE:
          FormatUtils::FileAttributes(m_rgChildFileAttributes[uIndex].Attributes, pShellDetails->str.cStr);
          break;
        default:
          hr = E_INVALIDARG;
    }
    return hr;
}


HRESULT CXboxRoot::SetStatusBarText(IShellBrowser *pShellBrowser, LPCITEMIDLIST pidlSelect)
{
    UINT uIndex;
    LPSTR pszParse;
    LRESULT lr;
    HRESULT hr = RefreshChildren();
    if(SUCCEEDED(hr))
    {
        hr = GetChildIndex((LPCSTR)pidlSelect->mkid.abID, &uIndex);
        if(SUCCEEDED(hr))
        {
            if('?'==*m_rgpszChildNames[uIndex])
            {
                hr = pShellBrowser->SendControlMsg(
                        FCW_STATUS,
                        SB_SETTEXTA,
                        (WPARAM)0,
                        (LPARAM)WindowUtils::GetPreloadedString(IDS_PRELOAD_STATUS_ADD_CONSOLE_FORMAT),
                        &lr
                        );
            } else
            {
                char szStatusText[30];
                DWORD dwChildIPAddress = GetChildIpAddress(uIndex);
                wsprintfA(szStatusText,
                        "%s (%d.%d.%d.%d)",
                        GetActualName(uIndex),
                        (dwChildIPAddress >> 24)&0xFF,
                        (dwChildIPAddress >> 16)&0xFF,
                        (dwChildIPAddress >> 8)&0xFF,
                         dwChildIPAddress&0xFF
                        );
                hr = pShellBrowser->SendControlMsg(
                        FCW_STATUS,
                        SB_SETTEXTA,
                        (WPARAM)0,
                        (LPARAM)szStatusText,
                        &lr
                        );
            }
        }
    }
    return hr;
}
HRESULT CXboxConsole::SetStatusBarText(IShellBrowser *pShellBrowser, LPCITEMIDLIST pidlSelect)
{
    UINT uIndex;
    LPSTR pszParse;
    LRESULT lr;
    HRESULT hr = RefreshChildren();
    if(SUCCEEDED(hr)) 
    {
        hr = GetChildIndex((LPCSTR)pidlSelect->mkid.abID, &uIndex);
        if(SUCCEEDED(hr))
        {
            char szFree[30];
            char szTotal[30];
            char szStatusText[128];
            FormatUtils::FileSize(m_rgullChildFreeSpace[uIndex], szFree);
            FormatUtils::FileSize(m_rgullChildTotalSpace[uIndex], szTotal);
            WindowUtils::rsprintf(szStatusText, IDS_STATUS_VOLUME, szFree, szTotal);
            hr = pShellBrowser->SendControlMsg(
                        FCW_STATUS,
                        SB_SETTEXTA,
                        (WPARAM)0,
                        (LPARAM)szStatusText,
                        &lr
                        );
        }
    }

    return hr;
}


HRESULT CXboxFileSystemFolder::SetStatusBarText(IShellBrowser *pShellBrowser, LPCITEMIDLIST pidlSelect)
{
    UINT uIndex;
    LRESULT lr;
    HRESULT hr = RefreshChildren();
    if(SUCCEEDED(hr))
    {
        hr = GetChildIndex((LPCSTR)pidlSelect->mkid.abID, &uIndex);
        if(SUCCEEDED(hr))
        {
            char szStatusText[196];
            if(m_rgChildFileAttributes[uIndex].Attributes&FILE_ATTRIBUTE_DIRECTORY)
            {
                WindowUtils::rsprintf(szStatusText, IDS_STATUS_SELOBJECT_COUNT_FORMAT, 1);
            } else
            {
                char szDate[50];
                char szSize[30];
                ULARGE_INTEGER uli;

                FormatUtils::FileTime(&m_rgChildFileAttributes[uIndex].ChangeTime, szDate);
                uli.HighPart = m_rgChildFileAttributes[uIndex].SizeHigh;
                uli.LowPart = m_rgChildFileAttributes[uIndex].SizeLow;
                FormatUtils::FileSize(uli.QuadPart, szSize);
                WindowUtils::rsprintf(szStatusText, IDS_STATUS_FILE, m_rgszChildTypeNames[uIndex], szDate, szSize);
            }
            hr = pShellBrowser->SendControlMsg(
                    FCW_STATUS,
                    SB_SETTEXTA,
                    (WPARAM)0,
                    (LPARAM)szStatusText,
                    &lr
                    );
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbshlext\drawpie.cpp ===
#include <stdafx.h>
#include "drawpie.h"

int IntSqrt(unsigned long dwNum)
{
	// We will keep shifting dwNum left and look at the top two bits.

	// initialize sqrt and remainder to 0.
	DWORD dwSqrt = 0, dwRemain = 0, dwTry;
	int i;

	// We iterate 16 times, once for each pair of bits.
	for (i=0; i<16; ++i)
	{
		// Mask off the top two bits of dwNum and rotate them into the
		// bottom of the remainder
		dwRemain = (dwRemain<<2) | (dwNum>>30);

		// Now we shift the sqrt left; next we'll determine whether the
		// new bit is a 1 or a 0.
		dwSqrt <<= 1;

		// This is where we double what we already have, and try a 1 in
		// the lowest bit.
		dwTry = dwSqrt*2 + 1;

		if (dwRemain >= dwTry)
		{
			// The remainder was big enough, so subtract dwTry from
			// the remainder and tack a 1 onto the sqrt.
			dwRemain -= dwTry;
			dwSqrt |= 0x01;
		}

		// Shift dwNum to the left by 2 so we can work on the next few
		// bits.
		dwNum <<= 2;
	}

	return(dwSqrt);
}

STDAPI_(VOID) DrawPie(HDC hDC, LPCRECT lprcItem, UINT uPctX10, BOOL TrueZr100,
                  UINT uOffset, const COLORREF *lpColors)
{
	int cx, cy, rx, ry, x, y;
	int uQPctX10;
	RECT rcItem;
	HRGN hEllRect, hEllipticRgn, hRectRgn;
	HBRUSH hBrush, hOldBrush;
	HPEN hPen, hOldPen;
    DWORD dwOldLayout;

	rcItem = *lprcItem;
	rcItem.left = lprcItem->left;
	rcItem.top = lprcItem->top;
	rcItem.right = lprcItem->right - rcItem.left;
	rcItem.bottom = lprcItem->bottom - rcItem.top - uOffset;

	rx = rcItem.right / 2;
	cx = rcItem.left + rx - 1;
	ry = rcItem.bottom / 2;
	cy = rcItem.top + ry - 1;
	if (rx<=10 || ry<=10)
	{
		return;
	}

    dwOldLayout = SetLayout(hDC, 0);

	rcItem.right = rcItem.left+2*rx;
	rcItem.bottom = rcItem.top+2*ry;

	if (uPctX10 > 1000)
	{
		uPctX10 = 1000;
	}

	/* Translate to first quadrant of a Cartesian system
	*/
	uQPctX10 = (uPctX10 % 500) - 250;
	if (uQPctX10 < 0)
	{
		uQPctX10 = -uQPctX10;
	}

	/* Calc x and y.  I am trying to make the area be the right percentage.
	** I don't know how to calculate the area of a pie slice exactly, so I
	** approximate it by using the triangle area instead.
	*/
	if (uQPctX10 < 120)
	{
		x = IntSqrt(((DWORD)rx*(DWORD)rx*(DWORD)uQPctX10*(DWORD)uQPctX10)
			/((DWORD)uQPctX10*(DWORD)uQPctX10+(250L-(DWORD)uQPctX10)*(250L-(DWORD)uQPctX10)));

		y = IntSqrt(((DWORD)rx*(DWORD)rx-(DWORD)x*(DWORD)x)*(DWORD)ry*(DWORD)ry/((DWORD)rx*(DWORD)rx));
	}
	else
	{
		y = IntSqrt((DWORD)ry*(DWORD)ry*(250L-(DWORD)uQPctX10)*(250L-(DWORD)uQPctX10)
			/((DWORD)uQPctX10*(DWORD)uQPctX10+(250L-(DWORD)uQPctX10)*(250L-(DWORD)uQPctX10)));

		x = IntSqrt(((DWORD)ry*(DWORD)ry-(DWORD)y*(DWORD)y)*(DWORD)rx*(DWORD)rx/((DWORD)ry*(DWORD)ry));
	}

	/* Switch on the actual quadrant
	*/
	switch (uPctX10 / 250)
	{
	case 1:
		y = -y;
		break;

	case 2:
		break;

	case 3:
		x = -x;
		break;

	default: // case 0 and case 4
		x = -x;
		y = -y;
		break;
	}

	/* Now adjust for the center.
	*/
	x += cx;
	y += cy;

        // BUGBUG
        //
        // Hack to get around bug in NTGDI

        x = x < 0 ? 0 : x;

	/* Draw the shadows using regions (to reduce flicker).
	*/
	hEllipticRgn = CreateEllipticRgnIndirect(&rcItem);
	OffsetRgn(hEllipticRgn, 0, uOffset);
	hEllRect = CreateRectRgn(rcItem.left, cy, rcItem.right, cy+uOffset);
	hRectRgn = CreateRectRgn(0, 0, 0, 0);
	CombineRgn(hRectRgn, hEllipticRgn, hEllRect, RGN_OR);
	OffsetRgn(hEllipticRgn, 0, -(int)uOffset);
	CombineRgn(hEllRect, hRectRgn, hEllipticRgn, RGN_DIFF);

	/* Always draw the whole area in the free shadow/
	*/
	hBrush = CreateSolidBrush(lpColors[DP_FREESHADOW]);
	if (hBrush)
	{
		FillRgn(hDC, hEllRect, hBrush);
		DeleteObject(hBrush);
	}

	/* Draw the used shadow only if the disk is at least half used.
	*/
	if (uPctX10>500 && (hBrush=CreateSolidBrush(lpColors[DP_USEDSHADOW]))!=NULL)
	{
		DeleteObject(hRectRgn);
		hRectRgn = CreateRectRgn(x, cy, rcItem.right, lprcItem->bottom);
		CombineRgn(hEllipticRgn, hEllRect, hRectRgn, RGN_AND);
		FillRgn(hDC, hEllipticRgn, hBrush);
		DeleteObject(hBrush);
	}

	DeleteObject(hRectRgn);
	DeleteObject(hEllipticRgn);
	DeleteObject(hEllRect);

	hPen = CreatePen(PS_SOLID, 1, GetSysColor(COLOR_WINDOWFRAME));
	hOldPen = (HPEN)SelectObject(hDC, hPen);

	if((uPctX10 < 100) && (cy == y))
	{
	    hBrush = CreateSolidBrush(lpColors[DP_FREECOLOR]);
	    hOldBrush = (HBRUSH)SelectObject(hDC, hBrush);
	    if((TrueZr100 == FALSE) || (uPctX10 != 0))
	    {
		Pie(hDC, rcItem.left, rcItem.top, rcItem.right, rcItem.bottom,
			rcItem.left, cy, x, y);
	    }
	    else
	    {
		Ellipse(hDC, rcItem.left, rcItem.top, rcItem.right,
			     rcItem.bottom);
	    }
	}
	else if((uPctX10 > (1000 - 100)) && (cy == y))
	{
	    hBrush = CreateSolidBrush(lpColors[DP_USEDCOLOR]);
	    hOldBrush = (HBRUSH)SelectObject(hDC, hBrush);
	    if((TrueZr100 == FALSE) || (uPctX10 != 1000))
	    {
		Pie(hDC, rcItem.left, rcItem.top, rcItem.right, rcItem.bottom,
			rcItem.left, cy, x, y);
	    }
	    else
	    {
		Ellipse(hDC, rcItem.left, rcItem.top, rcItem.right,
			     rcItem.bottom);
	    }
	}
	else
	{
	    hBrush = CreateSolidBrush(lpColors[DP_USEDCOLOR]);
	    hOldBrush = (HBRUSH)SelectObject(hDC, hBrush);

	    Ellipse(hDC, rcItem.left, rcItem.top, rcItem.right, rcItem.bottom);
	    SelectObject(hDC, hOldBrush);
	    DeleteObject(hBrush);

	    hBrush = CreateSolidBrush(lpColors[DP_FREECOLOR]);
	    hOldBrush = (HBRUSH)SelectObject(hDC, hBrush);
	    Pie(hDC, rcItem.left, rcItem.top, rcItem.right, rcItem.bottom,
		    rcItem.left, cy, x, y);
	}
	SelectObject(hDC, hOldBrush);
	DeleteObject(hBrush);

	/* Do not draw the lines if the %age is truely 0 or 100 (completely
	** empty disk or completly full disk)
	*/
	if((TrueZr100 == FALSE) || ((uPctX10 != 0) && (uPctX10 != 1000)))
	{
	    Arc(hDC, rcItem.left, rcItem.top+uOffset, rcItem.right, rcItem.bottom+uOffset,
		    rcItem.left, cy+uOffset, rcItem.right, cy+uOffset-1);
	    MoveToEx(hDC, rcItem.left, cy, NULL);
	    LineTo(hDC, rcItem.left, cy+uOffset);
	    MoveToEx(hDC, rcItem.right-1, cy, NULL);
	    LineTo(hDC, rcItem.right-1, cy+uOffset);

	    if (uPctX10 > 500)
	    {
		    MoveToEx(hDC, x, y, NULL);
		    LineTo(hDC, x, y+uOffset);
	    }
	}
	SelectObject(hDC, hOldPen);
	DeleteObject(hPen);
    SetLayout(hDC, dwOldLayout);
	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbshlext\dialogs.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    dialogs.cpp

Abstract:

    Implementation of the various dialog boxes that are required.
    These are no more than souped up message boxes for the most
    part, but unfortunately no one 

Environment:

    Windows 2000 and Later 
    User Mode

Revision History:
    
    03-13-2001 : created (mitchd)

--*/

#include <stdafx.h>
#include <windowsx.h>

/*
**  CXboxDialog - a basic dialog that is completely static.  If all of the
**                text and icons can be specified in the template, use this
**                one.
**
**  This is also the base class for more sophisticated dialog prompts.
**
*/
class CXboxDialog
{
  public:
    CXboxDialog():m_hWndDlg(NULL){}
    INT_PTR Execute(LPCSTR lpTemplateName, HWND hWndParent);

    virtual INT_PTR OnInitDialog(HWND hwndDefaultControl);
    virtual INT_PTR OnCommand(WPARAM wParam, LPARAM lParam);
    virtual INT_PTR OnMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);

  protected:

    virtual BOOL End(INT_PTR nResult);
    HWND m_hWndDlg;

  private:
    static INT_PTR CALLBACK DialogProc(HWND hWndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
};

INT_PTR CXboxDialog::Execute(LPCSTR lpTemplateName, HWND hWndParent)
{
    return DialogBoxParamA(_Module.GetModuleInstance(), lpTemplateName, hWndParent, DialogProc, (WPARAM)this);
}

INT_PTR CALLBACK CXboxDialog::DialogProc(HWND hWndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CXboxDialog *pThis;

    //
    //  WM_INITDIALOG is special.
    //
    if(WM_INITDIALOG==uMsg)
    {
        pThis = (CXboxDialog *)lParam;
        SetWindowLong(hWndDlg,DWL_USER,(LONG)pThis);
        pThis->m_hWndDlg = hWndDlg;
        return pThis->OnInitDialog((HWND)wParam);
    }

    pThis = (CXboxDialog *)GetWindowLong(hWndDlg, DWL_USER);
    if(pThis)
    {
        if(WM_COMMAND == uMsg)
            return pThis->OnCommand(wParam, lParam);
        
        return pThis->OnMessage(uMsg, wParam, lParam);
    }
    return 0;
}


INT_PTR CXboxDialog::OnInitDialog(HWND)
{
    return 1;
}

INT_PTR CXboxDialog::OnCommand(WPARAM wParam, LPARAM lParam)
{
    UINT idc = GET_WM_COMMAND_ID(wParam, lParam);
    //
    //  One special case that applies to all the dialogs:
    //  VK_SHIFT+IDC_XB_NO=>IDC_XB_NOTOALL
    //
    if( (IDC_XB_NO == idc) && (GetKeyState(VK_SHIFT) < 0))
    {
        idc = IDC_XB_NOTOALL;
    }
    return End(idc);
}

INT_PTR CXboxDialog::OnMessage(UINT, WPARAM, LPARAM)
{
    return 0;
}

BOOL CXboxDialog::End(INT_PTR nResult)
{
    return EndDialog(m_hWndDlg, nResult);
}

/*
**  Implement CConfirmDialog  - this is the simplest
**  useful class.  
**
**  It is more flexible than a message box in that
**  you can provide a template rather than the MB_
**  flags.
**
**  This is just what we need for many of the shell
**  extension prompts.
*/  

class CConfirmDialog : public CXboxDialog
{
  public:
    CConfirmDialog(){}
    
    INT_PTR Confirm(HWND hWndParent, LPCSTR pszText, LPCSTR pszCaption, LPCSTR lpTemplateName)
    {
        m_pszText = pszText;
        m_pszCaption = pszCaption;
        return Execute(lpTemplateName, hWndParent);       
    }

  protected:
    virtual INT_PTR OnInitDialog(HWND hwndDefaultControl);
    LPCSTR  m_pszText;
    LPCSTR  m_pszCaption;
};

INT_PTR
CConfirmDialog::OnInitDialog(
    HWND
    )
/*++
  Routine Description:
    We need to update the only modifiable filed IDX_XB_TEXT
--*/
{
    //  Fill in the caption.
    if(m_pszCaption)
    {
        SetWindowTextA(m_hWndDlg, m_pszCaption);
    }

    //  Fill in the text
    if(m_pszText)
    {
        HWND hWndCtrl = GetDlgItem(m_hWndDlg, IDC_XB_TEXT);
        if(hWndCtrl)
        {
            SetWindowTextA(hWndCtrl, m_pszText);
        }
    }
    return TRUE;
}

/*
**  CConfirmReplaceDialog - 
**      a more specialized dialog specifically for confirming
**      file replace.  It works with specific template that
**      cannot be specified.
*/

class CConfirmReplaceDialog : public CXboxDialog
{
  public:
    CConfirmReplaceDialog() {}
    
    UINT 
    Confirm(
        HWND hWndParent,
        LPCSTR pszFileName,
        WIN32_FILE_ATTRIBUTE_DATA *pFileAttributes,
        WIN32_FILE_ATTRIBUTE_DATA *pFileAttributes2
        );
    
  protected:
    
    virtual INT_PTR OnInitDialog(HWND hwndDefaultControl);

  private:
    char m_szFileName[MAX_PATH];
    WIN32_FILE_ATTRIBUTE_DATA m_FileAttributes;
    WIN32_FILE_ATTRIBUTE_DATA m_FileAttributes2;
};

UINT 
CConfirmReplaceDialog::Confirm(
    HWND hWndParent,
    LPCSTR pszFileName,
    WIN32_FILE_ATTRIBUTE_DATA *pFileAttributes,
    WIN32_FILE_ATTRIBUTE_DATA *pFileAttributes2
    )
{
    //
    //  Copy the filename
    //
    strcpy(m_szFileName, pszFileName);

    //
    //  Copy the first file attributes
    //
    memcpy(&m_FileAttributes, pFileAttributes, sizeof(WIN32_FILE_ATTRIBUTE_DATA));

    //
    //  Copy the second file attributes, if present
    //
    memcpy(&m_FileAttributes2, pFileAttributes2, sizeof(WIN32_FILE_ATTRIBUTE_DATA));

    //
    //  Execute the dialog
    //
    return Execute(MAKEINTRESOURCEA(IDD_CONFIRM_REPLACE), hWndParent);
}


 
INT_PTR
CConfirmReplaceDialog ::OnInitDialog(
    HWND
    )
/*++
  Routine Description:
    This routine is called when WM_INITDIALOG is sent to the dialog.
    At this time we need to do any required manipulation of the dialog template.
    Basically, we fill in the file name(s) and details.  Remove the "Yes To All" and
    "No To All" buttons if m_fMultiFile is not set.

  Parameters:
    The HWND passed is for the default control.  We don't care about this.
    The HWMD we care about is our window, the m_hWndDlg member.

--*/
{
    HWND hWndCtrl;
    char szFormatBuffer[1024];
    
    //
    //  Update the file name
    //
    hWndCtrl = GetDlgItem(m_hWndDlg, IDC_XB_FILENAME);
    if(hWndCtrl) WindowUtils::SubstituteWindowText(hWndCtrl, m_szFileName);

    //
    //  Update the first file size
    //
    hWndCtrl = GetDlgItem(m_hWndDlg, IDC_XB_FILESIZE);
    if(hWndCtrl)
    {
        ULARGE_INTEGER uliFileSize;
        uliFileSize.HighPart = m_FileAttributes.nFileSizeHigh;
        uliFileSize.LowPart = m_FileAttributes.nFileSizeLow;
        FormatUtils::FileSize(uliFileSize.QuadPart, szFormatBuffer);
        SetWindowTextA(hWndCtrl, szFormatBuffer);
    }

    //
    //  Update the first file time
    //
    hWndCtrl = GetDlgItem(m_hWndDlg, IDC_XB_FILETIME);
    if(hWndCtrl)
    {
        FormatUtils::FileTime(&m_FileAttributes.ftLastWriteTime, szFormatBuffer, DATE_LONGDATE);
        WindowUtils::SubstituteWindowText(hWndCtrl, szFormatBuffer);
    }

    //
    //  Update the Icon of the first file
    //
    hWndCtrl = GetDlgItem(m_hWndDlg, IDC_XB_FILEICON);
    if(hWndCtrl)
    {
        SHFILEINFOA ShellFileInfo;
        if(
          SHGetFileInfoA(
            m_szFileName,
            m_FileAttributes.dwFileAttributes,
            &ShellFileInfo,
            sizeof(ShellFileInfo),
            SHGFI_ICON | 
            SHGFI_SHELLICONSIZE | 
            SHGFI_USEFILEATTRIBUTES
            )
        )
        {
            WindowUtils::ReplaceWindowIcon(hWndCtrl, ShellFileInfo.hIcon);
        }
    }

    
    //
    //  Update the second file size
    //
    hWndCtrl = GetDlgItem(m_hWndDlg, IDC_XB_FILESIZE2);
    if(hWndCtrl)
    {
        ULARGE_INTEGER uliFileSize;
        uliFileSize.HighPart = m_FileAttributes2.nFileSizeHigh;
        uliFileSize.LowPart = m_FileAttributes2.nFileSizeLow;
        FormatUtils::FileSize(uliFileSize.QuadPart,szFormatBuffer );
        SetWindowTextA(hWndCtrl, szFormatBuffer);
    }

    //
    //  Update the second file time
    //
    hWndCtrl = GetDlgItem(m_hWndDlg, IDC_XB_FILETIME2);
    if(hWndCtrl)
    {
        FormatUtils::FileTime(&m_FileAttributes2.ftLastWriteTime, szFormatBuffer, DATE_LONGDATE);
        WindowUtils::SubstituteWindowText(hWndCtrl, szFormatBuffer);
    }

    //
    //  Update the Icon of the second file
    //
    hWndCtrl = GetDlgItem(m_hWndDlg, IDC_XB_FILEICON2);
    if(hWndCtrl)
    {
        SHFILEINFOA ShellFileInfo;
        if(
          SHGetFileInfoA(
            m_szFileName,
            m_FileAttributes2.dwFileAttributes,
            &ShellFileInfo,
            sizeof(ShellFileInfo),
            SHGFI_ICON | 
            SHGFI_SHELLICONSIZE | 
            SHGFI_USEFILEATTRIBUTES
            )
        )
        {
            WindowUtils::ReplaceWindowIcon(hWndCtrl, ShellFileInfo.hIcon);
        }
    }

    return TRUE;
}

/*
**  CConfirmAttributesDialog - 
**      a more specialized dialog specifically for confirming
**      changing of attributes.  It for folders it queries
**      whether or not attributes should be applied recursively.
*/

class CConfirmAttributesDialog : public CXboxDialog
{
  public:
  
    CConfirmAttributesDialog(){}
    UINT Confirm(HWND hWndParent, DWORD dwSetAttributes, DWORD dwClearAttributes, BOOL fMultiItem);

  protected:
  
    virtual INT_PTR OnInitDialog(HWND hwndDefaultControl);
    virtual INT_PTR OnCommand(WPARAM wParam, LPARAM lParam);

  private:
    DWORD m_dwSetAttributes;
    DWORD m_dwClearAttributes;
    BOOL  m_fMultiItem;
    BOOL  m_fRecursive;

};

INT_PTR CConfirmAttributesDialog::OnInitDialog(HWND hwndDefaultControl)
{
    HWND hWndCtrl;
    char  szFormatBuffer[MAX_PATH] = {0};
    hWndCtrl = GetDlgItem(m_hWndDlg, IDC_ATTRIBSTOAPPLY);
    if(hWndCtrl)
    {
        LPSTR pszParse = szFormatBuffer;
        
        if(m_dwSetAttributes&FILE_ATTRIBUTE_READONLY)
        {
            pszParse += LoadStringA(_Module.GetModuleInstance(), IDS_READONLY, pszParse, MAX_PATH);
        } else if(m_dwClearAttributes&FILE_ATTRIBUTE_READONLY)
        {
            pszParse += LoadStringA(_Module.GetModuleInstance(), IDS_NOTREADONLY, pszParse, MAX_PATH);
        }

        if(m_dwSetAttributes&FILE_ATTRIBUTE_HIDDEN)
        {
            pszParse += LoadStringA(_Module.GetModuleInstance(), IDS_HIDE, pszParse, MAX_PATH);
        } else if(m_dwClearAttributes&FILE_ATTRIBUTE_HIDDEN)
        {
            pszParse += LoadStringA(_Module.GetModuleInstance(), IDS_UNHIDE, pszParse, MAX_PATH);
        }
        
        //
        //  Remove the file ",".
        //
        pszParse -= 2;
        *pszParse = '\0';

        SetWindowTextA(hWndCtrl, szFormatBuffer);
    }    

    if(m_fMultiItem)
    {
      LoadStringA(_Module.GetModuleInstance(), IDS_THESELECTEDITEMS, szFormatBuffer, MAX_PATH);
    } else
    {
      LoadStringA(_Module.GetModuleInstance(), IDS_THISFOLDER, szFormatBuffer, MAX_PATH);
    }
    
    hWndCtrl = GetDlgItem(m_hWndDlg, IDC_RECURSIVE_TXT);
    if(hWndCtrl)
    {
        WindowUtils::SubstituteWindowText(hWndCtrl, szFormatBuffer);
    }

    hWndCtrl = GetDlgItem(m_hWndDlg, IDC_NOTRECURSIVE);
    if(hWndCtrl)
    {
        WindowUtils::SubstituteWindowText(hWndCtrl, szFormatBuffer);
        SendMessage(hWndCtrl, BM_SETCHECK, BST_CHECKED, 0);
    }

    hWndCtrl = GetDlgItem(m_hWndDlg, IDC_RECURSIVE);
    if(hWndCtrl)
    {
        WindowUtils::SubstituteWindowText(hWndCtrl, szFormatBuffer);
    }
    return TRUE;
}

UINT CConfirmAttributesDialog::Confirm(HWND hWndParent, DWORD dwSetAttributes, DWORD dwClearAttributes, BOOL fMultiItem)
{
    UINT uResult;
    m_dwSetAttributes = dwSetAttributes;
    m_dwClearAttributes = dwClearAttributes;
    m_fMultiItem = fMultiItem;
    m_fRecursive = FALSE;
    return Execute(MAKEINTRESOURCEA(IDD_ATTRIBS_RECURSIVE), hWndParent);
}

INT_PTR CConfirmAttributesDialog::OnCommand(WPARAM wParam, LPARAM lParam)
{
    UINT uControlId = LOWORD(wParam);
    UINT uCommand = HIWORD(wParam);
    
    //
    //  If Flip the m_fRecursive as buttons are pressed.
    //  
    //
    if( uCommand == BN_CLICKED) 
    { 
        if(uControlId==IDC_RECURSIVE)
        {
            m_fRecursive = TRUE;
            return TRUE;
        }
        if(uControlId==IDC_NOTRECURSIVE)
        {
           m_fRecursive = FALSE;
           return TRUE;
        }
        if((IDOK==uControlId)&&m_fRecursive)
        {
            return End(IDC_XB_YESTOALL);
        }
        return End(uCommand);
    }
    return FALSE;
}


/*
**  CPromptUserNameDialog
*/
class CPromptUserNameDialog : public CXboxDialog
{
  public:
  
    CPromptUserNameDialog(){}
    UINT Prompt(HWND hWndParent, LPSTR pszUserName, int iMaxCount);

  protected:
    virtual INT_PTR OnInitDialog(HWND hwndDefaultControl);
    virtual INT_PTR OnCommand(WPARAM wParam, LPARAM lParam);
    
  private:
    LPSTR m_pszUserName;
    int   m_iMaxCount;
};


UINT CPromptUserNameDialog::Prompt(HWND hWndParent, LPSTR pszUserName, int iMaxCount)
{
    m_pszUserName = pszUserName;
    m_iMaxCount = iMaxCount;
    return Execute(MAKEINTRESOURCEA(IDD_USERNAME_PROMPT), hWndParent);
};

INT_PTR CPromptUserNameDialog::OnInitDialog(HWND hwndDefaultControl)
{
    SendMessage(GetDlgItem(m_hWndDlg, IDC_XB_TEXT), EM_SETLIMITTEXT, (WPARAM)m_iMaxCount, (LPARAM)0);
    EnableWindow(GetDlgItem(m_hWndDlg, IDOK), FALSE);
    SendMessage(m_hWndDlg, DM_SETDEFID, IDCANCEL, 0);
    SetFocus(GetDlgItem(m_hWndDlg, IDC_XB_TEXT));
    return FALSE;
}

INT_PTR CPromptUserNameDialog::OnCommand(WPARAM wParam, LPARAM lParam)
{
    UINT uControlId = LOWORD(wParam);
    UINT uCommand = HIWORD(wParam);

    if( uCommand == BN_CLICKED) 
    { 
        if((uControlId==IDOK) || (uControlId==IDCANCEL))
        {
            End(uControlId);
            return TRUE;
        }
    } else if(uCommand == EN_CHANGE)
    {
        // Keep m_pszUserName in sync with the control.
        // Also, enable\disable OK, based on whether
        // the user name is blank.
        if(uControlId==IDC_XB_TEXT)
        {
            if(GetDlgItemTextA(m_hWndDlg, IDC_XB_TEXT, m_pszUserName, m_iMaxCount))
            {
                EnableWindow(GetDlgItem(m_hWndDlg, IDOK), TRUE);
                SendMessage(m_hWndDlg, DM_SETDEFID, IDOK, 0);
            } else
            {
                EnableWindow(GetDlgItem(m_hWndDlg, IDOK), FALSE);
                SendMessage(m_hWndDlg, DM_SETDEFID, IDCANCEL, 0);
            }
            return TRUE;
        }
    }
    return FALSE;
}

/*
**  CPromptNewPasswordDialog
*/
class CPromptNewPasswordDialog : public CXboxDialog
{
  public:
  
    CPromptNewPasswordDialog(){m_szConfirmPassword[0]='\0';}
    UINT Prompt(HWND hWndParent, LPSTR pszPassword, int iMaxCount);

  protected:
    virtual INT_PTR OnInitDialog(HWND hwndDefaultControl);
    virtual INT_PTR OnCommand(WPARAM wParam, LPARAM lParam);
    
  private:
    LPSTR m_pszPassword;
    char  m_szConfirmPassword[MAX_PATH];
    int   m_iMaxCount;
};


UINT CPromptNewPasswordDialog::Prompt(HWND hWndParent, LPSTR pszPassword, int iMaxCount)
{
    m_pszPassword = pszPassword;
    m_iMaxCount = iMaxCount;
    _ASSERT(iMaxCount <= MAX_PATH);
    return Execute(MAKEINTRESOURCEA(IDD_PASSWORD_PROMPT), hWndParent);
};

INT_PTR CPromptNewPasswordDialog::OnInitDialog(HWND hwndDefaultControl)
{
    SendMessage(GetDlgItem(m_hWndDlg, IDC_SECURITY_PASSWORD_EDIT), EM_SETLIMITTEXT, (WPARAM)m_iMaxCount, (LPARAM)0);
    SendMessage(GetDlgItem(m_hWndDlg, IDC_SECURITY_CONFIRM_PASSWORD), EM_SETLIMITTEXT, (WPARAM)m_iMaxCount, (LPARAM)0);
    EnableWindow(GetDlgItem(m_hWndDlg, IDOK), FALSE);
    SendMessage(m_hWndDlg, DM_SETDEFID, IDCANCEL, 0);
    SetFocus(GetDlgItem(m_hWndDlg, IDC_SECURITY_PASSWORD_EDIT));
    return FALSE;
}

INT_PTR CPromptNewPasswordDialog::OnCommand(WPARAM wParam, LPARAM lParam)
{
    UINT uControlId = LOWORD(wParam);
    UINT uCommand = HIWORD(wParam);
    BOOL fRet = FALSE;
    if( uCommand == BN_CLICKED) 
    { 
        if((uControlId==IDOK))
        {
            //Make sure that the password and confirm password fields are identical.
            if(strcmp(m_pszPassword, m_szConfirmPassword))
            {
                ShowWindow(GetDlgItem(m_hWndDlg, IDC_SECURITY_PASSWORD_MISMATCH), SW_SHOW);
                MessageBeep(MB_ICONASTERISK);
            } else
            {
                End(uControlId);
            }
            fRet = TRUE;
        } else if(uControlId==IDCANCEL)
        {
            End(uControlId);
            fRet = TRUE;
        }
    } else if(uCommand == EN_CHANGE)
    {
        if(uControlId==IDC_SECURITY_PASSWORD_EDIT)
        {
            GetDlgItemTextA(m_hWndDlg, IDC_SECURITY_PASSWORD_EDIT, m_pszPassword, m_iMaxCount);
            fRet = TRUE;
        }
        else if(uControlId==IDC_SECURITY_CONFIRM_PASSWORD)
        {
            GetDlgItemTextA(m_hWndDlg, IDC_SECURITY_CONFIRM_PASSWORD, m_szConfirmPassword, m_iMaxCount);
            fRet = TRUE;
        }
        if(fRet)
        {
            if(*m_pszPassword && *m_szConfirmPassword)
            {
                EnableWindow(GetDlgItem(m_hWndDlg, IDOK), TRUE);
                SendMessage(m_hWndDlg, DM_SETDEFID, IDOK, 0);
            }else
            {
                EnableWindow(GetDlgItem(m_hWndDlg, IDOK), FALSE);
                SendMessage(m_hWndDlg, DM_SETDEFID, IDCANCEL, 0);
            }
        }
    }
    return fRet;
}

/*
**  Implementation of Wrapper Utility Functions
**  to put up the various dialogs used by 
**  the shell extension.
*/

UINT
Dialog::ConfirmReadOnlyMove(HWND hWndParent, LPCSTR pszFileName, bool fFolder)
{
    UINT uRet = IDC_XB_CANCEL;
    UINT uCaptionResource;
    UINT uTextResource;
    char szCaption[80];
    char szText[128];

    //
    //  Choose the text and caption resources based on file or folder.
    //

    if(fFolder)
    {
        uCaptionResource = IDS_CONFIRM_RO_FOLDER_MOVE_CAPTION;
        uTextResource = IDS_CONFIRM_RO_FOLDER_MOVE;
    } else
    {
        uCaptionResource = IDS_CONFIRM_RO_FILE_MOVE_CAPTION;
        uTextResource = IDS_CONFIRM_RO_FILE_MOVE;
    }

    //
    //  Load and format the strings
    //

    LoadStringA(_Module.GetModuleInstance(), uCaptionResource, szCaption, sizeof(szCaption));
    WindowUtils::rsprintf(szText, uTextResource, pszFileName);

    CConfirmDialog *pConfirm = new CConfirmDialog;
    if(pConfirm)
    {
        uRet = pConfirm->Confirm(hWndParent, szText, szCaption, MAKEINTRESOURCEA(IDD_CONFIRM_MOVE));
        delete pConfirm;
    }
    return uRet;
}

UINT
Dialog::ConfirmFolderReplace(
    HWND hWndParent,
    LPCSTR pszFileName
    )
{
    UINT uRet = IDC_XB_CANCEL;
    char szCaption[80];
    char szText[128];

    //
    //  Load and format the strings
    //

    LoadStringA(_Module.GetModuleInstance(), IDS_CONFIRM_FOLDER_REPLACE_CAPTION, szCaption, sizeof(szCaption));
    WindowUtils::rsprintf(szText, IDS_CONFIRM_FOLDER_REPLACE, pszFileName);

    CConfirmDialog *pConfirm = new CConfirmDialog;
    if(pConfirm)
    {
        uRet = pConfirm->Confirm(hWndParent, szText, szCaption, MAKEINTRESOURCEA(IDD_CONFIRM_FOLDER_REPLACE));
        delete pConfirm;
    }
    return uRet;
}

UINT
Dialog::ConfirmFileReplace(
    HWND hWndParent,
    LPCSTR pszFileName,
    WIN32_FILE_ATTRIBUTE_DATA *pTargetFileAttributes,
    WIN32_FILE_ATTRIBUTE_DATA *pSourceFileAttributes
    )
{
    UINT uRet = IDC_XB_CANCEL;
    CConfirmReplaceDialog *pConfirm = new CConfirmReplaceDialog;
    if(pConfirm)
    {
        uRet = pConfirm->Confirm(hWndParent, pszFileName, pTargetFileAttributes, pSourceFileAttributes);
        delete pConfirm;
    }
    return uRet;
}

UINT
Dialog::ConfirmDelete(
    HWND hWndParent,
    LPCSTR pszFileName,
    bool fFolder,
    bool fReadOnly
    )
{
    UINT uRet = IDC_XB_CANCEL;
    UINT uCaptionResource;
    UINT uTextResource;
    char szCaption[80];
    char szText[128];
    
    if(fFolder)
    {
       uCaptionResource = IDS_CONFIRM_DELETE_FOLDER_CAPTION;
       if(fReadOnly) uTextResource = IDS_CONFIRM_DELETE_RO_FOLDER;
       else          uTextResource = IDS_CONFIRM_DELETE_FOLDER;
    }else
    {
       uCaptionResource = IDS_CONFIRM_DELETE_CAPTION;
       if(fReadOnly) uTextResource = IDS_CONFIRM_DELETE_RO;
       else          uTextResource = IDS_CONFIRM_DELETE;
    }

    //
    //  Load and format the text and caption.
    //
    WindowUtils::rsprintf(szText, uTextResource, pszFileName);
    LoadStringA(_Module.GetModuleInstance(), uCaptionResource, szCaption, sizeof(szCaption));
    
    //
    //  Display the dialog
    //
    CConfirmDialog *pConfirm = new CConfirmDialog;
    if(pConfirm)
    {
        uRet = pConfirm->Confirm(hWndParent, szText, szCaption, MAKEINTRESOURCEA(IDD_CONFIRM_DELETE));
        delete pConfirm;
    }
    return uRet;
}

UINT
Dialog::ConfirmDeleteMultiple(
    HWND hWndParent,
    UINT uCount
    )
{
    UINT uRet = IDC_XB_CANCEL;
    char szCaption[80];
    char szText[128];
    
    //
    //  Load and format the text and caption.
    //
    WindowUtils::rsprintf(szText, IDS_CONFIRM_DELETE_MULTIPLE, uCount);
    LoadStringA(_Module.GetModuleInstance(), IDS_CONFIRM_DELETE_MULTIPLE_CAPTION, szCaption, sizeof(szCaption));
    
    CConfirmDialog *pConfirm = new CConfirmDialog;
    if(pConfirm)
    {
        uRet = pConfirm->Confirm(hWndParent, szText, szCaption, MAKEINTRESOURCEA(IDD_CONFIRM_DELETE));
        delete pConfirm;
    }
    return uRet;
}

UINT Dialog::ConfirmSetAttributes(HWND hWndParent, DWORD dwSetAttributes, DWORD dwClearAttributes, BOOL fMultiItem)
{
    CConfirmAttributesDialog confirmDialog;
    return confirmDialog.Confirm(hWndParent, dwSetAttributes, dwClearAttributes, fMultiItem);
}

UINT
Dialog::PromptUserName(HWND hWndParent, LPSTR pszUserName, int iMaxCount)
{
    UINT uRet = IDCANCEL;
    CPromptUserNameDialog *pPromptUserName;
    pPromptUserName = new CPromptUserNameDialog;
    if(pPromptUserName)
    {
        uRet = pPromptUserName->Prompt(hWndParent, pszUserName, iMaxCount);
        delete pPromptUserName;
    }
    return uRet;
}

UINT
Dialog::PromptNewPassword(HWND hWndParent, LPSTR pszPassword, int iMaxCount)
{
    UINT uRet = IDCANCEL;
    CPromptNewPasswordDialog *pPromptNewPassword;
    pPromptNewPassword = new CPromptNewPasswordDialog;
    if(pPromptNewPassword)
    {
        uRet = pPromptNewPassword->Prompt(hWndParent, pszPassword, iMaxCount);
        delete pPromptNewPassword;
    }
    return uRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbshlext\drawpie.h ===
int IntSqrt(unsigned long dwNum);

#define DP_USEDCOLOR  0
#define DP_FREECOLOR  1
#define DP_USEDSHADOW 2
#define DP_FREESHADOW 3

STDAPI_(VOID) DrawPie(HDC hDC, LPCRECT prcItem, UINT uPctX10, BOOL TrueZr100,
                  UINT uOffset, const COLORREF *lpColors);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbshlext\guid.cpp ===
const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbshlext\drop.h ===
/*++

Copyright (c) Microsoft Corporation


Module Name:

    drop.h

Abstract:
    
    Declares the CXboxDropTarget class

Environment:

    Windows 2000
    Uses ATL

Notes:

Revision History:

    April 2001 - created by Mitchell Dernis (mitchd)
    July  2001 - major overhaul (mitchd)

--*/
#ifndef __XBOXDROP_H__
#define __XBOXDROP_H__

//------------------------------------------------------------------------
// CXboxDropTarget
//------------------------------------------------------------------------
class ATL_NO_VTABLE CXboxDropTarget : 
	public CComObjectRootEx<CComMultiThreadModel>,
    public CShellObjectWithSite,
    public IDropTarget
{
  public:

    /*
    ** c'tor and d'tor
    */
    CXboxDropTarget() : m_pSelection(NULL), m_hWnd(NULL), m_dwDefaultEffect(DROPEFFECT_NONE), m_grfKeyState(0) {}
    ~CXboxDropTarget(){if(m_pSelection) m_pSelection->Release(); m_pSelection = NULL;}
    static HRESULT Create(HWND hWndParent, UINT cidl, LPCITEMIDLIST * apidl, CXboxFolder *pParent, IDropTarget **ppDropTarget);
    
    /*
    **  ATL COM INTERFACE MAP
    */
    DECLARE_PROTECT_FINAL_CONSTRUCT()
    BEGIN_COM_MAP(CXboxDropTarget)
        COM_INTERFACE_ENTRY_IID(IID_IObjectWithSite, CShellObjectWithSite)
        COM_INTERFACE_ENTRY_IID(IID_IDropTarget, IDropTarget)
    END_COM_MAP()
  
  public:
    /*
    ** IDropTarget methods
    */
    STDMETHOD(DragEnter)(IDataObject * pDataObject, DWORD grfKeyState, POINTL pt, DWORD * pdwEffect);
    STDMETHOD(DragOver)(DWORD grfKeyState, POINTL pt, DWORD * pdwEffect);
    STDMETHOD(DragLeave)();
    STDMETHOD(Drop)(IDataObject * pDataObject, DWORD grfKeyState, POINTL pt, DWORD * pdwEffect);
    
  protected:

    //
    //  Helper functions
    //
    DWORD DisplayDropPopUp(DWORD dwEffect, POINTL pt);
    DWORD GetEffect(DWORD grfKeyState, POINTL pt);
    BOOL  SetDefaultEffect(IDataObject *pDataObject);
    
    //
    //  Initialized by create
    //
    CXboxFolder *m_pSelection;  //The drop target selection.
    HWND         m_hWnd;        //The windw we are being dropped on.

    //
    //  The state of the drop target
    //
    DWORD     m_dwDefaultEffect; // Set on DragEnter.  This is the default drop effect for the source on the target
                                 // before taking into account keys and mouse buttons.  DROPEFFECT_NONE if the
                                 // the source and target are not compatible.
    DWORD     m_grfKeyState;   // We must cache this from DragEnter and DragOver, as Drop always gets
                               // grfKeyState = 0, I would say that this is probably a bug a in CDefaultView
                               // or some such.
};



struct HDROPFILE
{
    LPSTR pszFile;
    LPSTR pszRelativeFileName;
    HDROPFILE *pNext;
};
typedef struct HDROPFILE *PHDROPFILE; 

typedef struct NAMEMAPPING *PNAMEMAPPING;
struct NAMEMAPPING
{
    STGMEDIUM stgMedium;
    LPSTR     pszNames;
    LPWSTR    pwszNames;
};

#define FILE_PROGRESS_FUDGE_BYTES 65535 // Basically it means that the overhead of each file (or dir) is about equivalent to transfering 64 kbytes.
                                        // This was a trial and error value from looking at the initial time estimate displayed and increasing the
                                        // value until initial value was in the correct ballpark.  As I jacked this number up, the initial estimate
                                        // would get better and better.
class CDropOperation
{
  public:

    CDropOperation(
        CXboxFolder *pSelection,
        IDataObject *pDataObject,
        DWORD dwEffect,
        HWND hWnd
        ) : 
       m_pSelection(pSelection),   
       m_pDataObject(pDataObject),
       m_dwDesiredEffect(dwEffect),
       m_hWnd(hWnd),
       m_hParentWnd(hWnd),
       m_fAsync(FALSE),
       m_pMarshallingStream(0),
       m_pProgressDialog(NULL),
       m_pTargetConnection(NULL),
       m_uConfirmedYesToAll(0),
       m_uConfirmedNoToAll(0),
       m_fCancelled(FALSE),
       m_dwEffectPerformed(0)
       {
            m_pSelection->AddRef();
            m_pDataObject->AddRef();
       }
    ~CDropOperation();
    DWORD StartTransfer();
 
    static CLIPFORMAT GetDropFormat(IDataObject *pDataObject);
    static HRESULT GetDropData(IDataObject *pDataObject, FORMATETC *pFormatEtc, STGMEDIUM *pStgMedium);

  private:

    //  
    //  Track which confirmation dialogs
    //  have been displayed with YesToAll
    //  or NoToAll.
    //
    enum CONFIRM_FLAGS
    {
        ConfirmFlagFileReplace           = 0x01,
        ConfirmFlagReadOnlyFileReplace   = 0x02,
        ConfirmFlagFolderReplace         = 0x04,
        ConfirmFlagReadOnlyFolderReplace = 0x08,
        ConfirmFlagFileMove              = 0x10,
        ConfirmFlagFolderMove            = 0x20
    };
    
    ///
    //  For Async
    //
    static DWORD ThreadProc(PVOID pvThis) {return reinterpret_cast<CDropOperation *>(pvThis)->TransferThread();}
    DWORD TransferThread();

    //
    //  The four main transfer types.
    //
    DWORD DoTransfer(); 
    void  DoXboxFileGroupDescriptorTransfer();
    void  DoHDropTransfer();
    void  DoFileGroupDescriptorWTransfer();
    void  DoFileGroupDescriptorATransfer();

    //
    //  Progress Dialogs
    //
    void StartProgressDialog();
    void SetProgressTarget();
    void UpdateCopyProgress(LPSTR pszFileName);
    void StopProgressDialog();
    BOOL QueryCancel();
    inline void ResetProgress() {if(m_pProgressDialog) m_pProgressDialog->Timer(PDTIMER_RESET,NULL);}

    //
    //  Confirm Dialogs
    //
    bool ConfirmFolderMove(LPCSTR pszFolderName);
    bool ConfirmFileMove(LPCSTR pszFileName);
    bool ConfirmFolderReplace(LPCSTR pszTargetWireName);
    bool ConfirmFileReplace(LPCSTR pszTargetWireName, FILEDESCRIPTORA *pFileDescriptor, bool *pfOverWrite);
    bool ConfirmFileReplace(LPCSTR pszTargetWireName, LPSTR pszFileName, WIN32_FILE_ATTRIBUTE_DATA *pFileAttributeData, bool *pfOverWrite);
    bool ProcessConfirmResponse(UINT uDialogResponse, CDropOperation::CONFIRM_FLAGS eConfirmFlag);

    //
    //  Prompts user that transfer failed for whatever reason, gives opportunity to cancel.
    //
    void HandleTransferFailed(UINT uResourceId, HRESULT hr, LPCSTR pszFilename);

    //
    //  File Transfer Help
    //
    bool MakeTargetDirectory(LPCSTR pszTargetWireName, FILEDESCRIPTORA *pFileDescriptor);
    bool MakeTargetDirectory(LPCSTR pszTargetWireName, DM_FILE_ATTRIBUTES *pSourceFileAttributes);


    //
    //  Converting and validating destination names for CF_HDROP
    //
    void InitNameMapping(IDataObject *pDataObject, PNAMEMAPPING pNameMapping);
    bool GetDestination(PNAMEMAPPING pNameMapping, PHDROPFILE pDropFile);
    void CleanupNameMapping(PNAMEMAPPING pNameMapping);
    void HDropRecurse(LPSTR pszTargetWireName, LPSTR szFullSource, DM_FILE_ATTRIBUTES *pdmFileAttributes, bool fMove);
    void CountDirContents(LPSTR pszDir, WIN32_FIND_DATAA *pFindData);
    void CalculateHDropWork(PHDROPFILE pHDropFiles);
    
    //
    //  Data members passed to the constructor
    //
    CXboxFolder     *m_pSelection;
    IDataObject     *m_pDataObject;
    DWORD            m_dwDesiredEffect;
    HWND             m_hWnd;
    HWND             m_hParentWnd;

    //
    //  Data members for do Async transfers
    //
    BOOL      m_fAsync; 
    IStream  *m_pMarshallingStream;

    //
    //  Progress Dialog
    //
    IProgressDialog *m_pProgressDialog;
    DWORD            m_dwFileCount;
    ULONGLONG        m_ullBytesCompleted;
    ULONGLONG        m_ullBytesTotal;
    //
    //  The data associated with the top level clipboard format:
    //  a.k.a. CF_HDROP, CF_FILEDESCRIPTOR, CF_XBOXFILEDESCRIPTOR, or
    //  CF_FILENAME.  Not CF_FILECONTENT.
    //
    STGMEDIUM m_stgMedium;
    
    //
    //  Connection for talking to the target box.
    //
    IXboxConnection *m_pTargetConnection;
    
    UINT m_uConfirmedYesToAll;  //Use the _CONFIRM_FLAGS
    UINT m_uConfirmedNoToAll;   //Use the _CONFIRM_FLAGS
    BOOL m_fCancelled;

    //
    //  This is filled out by the pfnPrepareCopy method.
    //
    DWORD           m_dwEffectPerformed;

    //
    //  Supported Format Table
    //
    static  const FORMATETC  sm_SupportedFormats[];
    static  const UINT       sm_uSupportedFormatCount;

};

#endif //__XBOXDROP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbshlext\makefile.inc ===
$(O)\xbshlext_i.c : $(O)\xbshlext.h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbshlext\icon.h ===
/*++

Copyright (c) Microsoft Corporation


Module Name:

    xbicon.h

Abstract:
    
    Declaration of CXboxExtractIcon.

    CXboxExtractIcon is initialized in one of the following ways.
    
    a) As a root.
    b) As a console.
    c) As a volume.
    d) As a folder.
    e) As a file.

Environment:

    Windows 2000
    Uses ATL

Notes:

Revision History:

    March 2001 - created by Mitchell Dernis (mitchd)

--*/
#ifndef __XBICON_H_
#define __XBICON_H_


#include "resource.h"       // main symbols

//-----------------------------------------------------------------
//  CXboxExtractIcon - implememtns IExtractIconA and IExtractIConW
//-----------------------------------------------------------------
class ATL_NO_VTABLE CXboxExtractIcon : 
	public CComObjectRootEx<CComMultiThreadModel>,
    public IExtractIconA,
    public IExtractIconW,
    public IXboxVisitor   //For initialization.
{

public:
    CXboxExtractIcon() : 
      m_hr(S_OK),
      m_uCount(0) {}
    ~CXboxExtractIcon(){}

    /*
    **  Type of Icon to present.
    */
    enum XboxIconType
    {
        Root = 0,
        AddConsole,
        Console,
        ConsoleDefault,
        Volume,
        Folder,
        File,
        Xbe
    };
    
    /*
    ** ATL INTERFACE MAP.
    */
    DECLARE_PROTECT_FINAL_CONSTRUCT()
    BEGIN_COM_MAP(CXboxExtractIcon)
     COM_INTERFACE_ENTRY_IID(IID_IExtractIconA, IExtractIconA)
     COM_INTERFACE_ENTRY_IID(IID_IExtractIconW, IExtractIconW)
    END_COM_MAP()

 public:
    // *** IExtractIconA methods ***
    STDMETHOD(Extract)(
        LPCSTR pszFile,
        UINT nIconIndex,
        HICON *phiconLarge,
        HICON *phiconSmall,
        UINT nIconSize
        ) {return S_FALSE;}
    
    STDMETHOD(GetIconLocation)(
        UINT uFlags,
        LPSTR szIconFile,
        UINT cchMax,
        LPINT piIndex,
        UINT *pwFlags
        );
    
    // *** IExtractIconW methods ***
    STDMETHOD(Extract)(
        LPCWSTR pszFile,
        UINT nIconIndex,
        HICON *phiconLarge,
        HICON *phiconSmall,
        UINT nIconSize
        ) {return S_FALSE;}

    STDMETHOD(GetIconLocation)(
        UINT uFlags,
        LPWSTR szIconFile,
        UINT cchMax,
        LPINT piIndex,
        UINT *pwFlags
        );

  public:
    /*
    ** IXboxVisitor
    */
    virtual void VisitRoot          (IXboxVisit *pRoot,                DWORD *pdwFlags);   
    virtual void VisitAddConsole    (IXboxVisit *pAddConsole,          DWORD *pdwFlags);
    virtual void VisitConsole       (IXboxConsoleVisit   *pConsole,    DWORD *pdwFlags);   
    virtual void VisitVolume        (IXboxVolumeVisit    *pVolume,     DWORD *pdwFlags);
    virtual void VisitFileOrDir     (IXboxFileOrDirVisit *pFileOrDir,  DWORD *pdwFlags);
    virtual void VisitDirectoryPost (IXboxFileOrDirVisit *pFileOrDir,  DWORD *pdwFlags){E_NOTIMPL;};

    /*
    **  Did succeed?
    */
    HRESULT GetHResult() {if(m_uCount)return m_hr; return E_NOINTERFACE;}

  private:

    HRESULT GetIconLocationImpl(UINT uFlags, LPSTR szIconFile, UINT cchMax, LPINT piIndex, UINT *pwFlags);

    HRESULT      m_hr;
    UINT         m_uCount;
    XboxIconType m_eIconType;
    CHAR         m_szFilename[MAX_PATH];
    DWORD        m_dwAttributes;
};

#endif //__XBICON_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbshlext\icon.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    xbicon.cpp

Abstract:

    Implementation of CXboxExtractIcon

Environment:

    Windows 2000 and Later 
    User Mode
    ATL

Revision History:
    
    03-13-2001 : created (mitchd)

--*/

#include "stdafx.h"

void CXboxExtractIcon::VisitRoot(IXboxVisit *pRoot, DWORD *pdwFlags)
{    
    if(m_uCount)
    {
        if(CXboxExtractIcon::Root != m_eIconType)
        {
            m_hr = E_FAIL;
            *pdwFlags = 0;
        }
    }
    m_eIconType = CXboxExtractIcon::Root;
    m_uCount++;
}
void CXboxExtractIcon::VisitAddConsole(IXboxVisit *pAddConsole, DWORD *pdwFlags)
{
    if(m_uCount)
    {
        if(CXboxExtractIcon::AddConsole != m_eIconType)
        {
            m_hr = E_FAIL;
            *pdwFlags = 0;
        }
    }
    m_eIconType = CXboxExtractIcon::AddConsole;
    m_uCount++;
}

void CXboxExtractIcon::VisitConsole(IXboxConsoleVisit *pConsole, DWORD *pdwFlags)
{
    if(m_uCount)
    {
        if(CXboxExtractIcon::Console != m_eIconType)
        {
            m_hr = E_FAIL;
            *pdwFlags = 0;
        }
    }

    // Set the icon according to whether or not it is the default.
    m_eIconType = (pConsole->GetDefault()) ? CXboxExtractIcon::ConsoleDefault : CXboxExtractIcon::Console;
    m_uCount++;
}
void CXboxExtractIcon::VisitVolume(IXboxVolumeVisit *pVolume, DWORD *pdwFlags)
{
    if(m_uCount)
    {
        if(CXboxExtractIcon::Volume != m_eIconType)
        {
            m_hr = E_FAIL;
            *pdwFlags = 0;
        }
    }
    m_eIconType = CXboxExtractIcon::Volume;
    m_uCount++;
}

void CXboxExtractIcon::VisitFileOrDir(IXboxFileOrDirVisit *pFileOrDir, DWORD *pdwFlags)
{
    DM_FILE_ATTRIBUTES dmFileAttributes;
    pFileOrDir->GetFileAttributes(&dmFileAttributes);
    if(dmFileAttributes.Attributes&FILE_ATTRIBUTE_DIRECTORY)
    {
        if(m_uCount)
        {
            if(CXboxExtractIcon::Folder != m_eIconType)
            {
                m_hr = E_FAIL;
                *pdwFlags = 0;
            }
        }
        m_eIconType = CXboxExtractIcon::Folder;
    } else
    {
        
        if(CXboxFolder::IsXbeFile(dmFileAttributes.Name)) 
        {
            if(m_uCount)
            {
                if(CXboxExtractIcon::Xbe != m_eIconType)
                {
                    m_hr = E_FAIL;
                    *pdwFlags = 0;
                }
            }
            m_eIconType = CXboxExtractIcon::Xbe;
        } else
        {
            m_eIconType = CXboxExtractIcon::File;
            m_dwAttributes = dmFileAttributes.Attributes;
            strcpy(m_szFilename, dmFileAttributes.Name);
        }
    }
    m_uCount++;
}

HRESULT
CXboxExtractIcon::GetIconLocationImpl(
    UINT uFlags,
    LPSTR szIconFile,
    UINT cchMax,
    LPINT piIndex,
    UINT *pwFlags
    )
{
    DWORD dwResult = 0;
    //
    // Handle case of File Icon.  We defer this to the 
    // case to SHGetFileInfoA so that the icon is whatever
    // was registered for that file type.
    //
    if(CXboxExtractIcon::File==m_eIconType)
    { 
        strcpy(szIconFile, m_szFilename);
        SHFILEINFOA ShellFileInfo;
        if(SHGetFileInfoA(
                    m_szFilename,
                    m_dwAttributes,
                    &ShellFileInfo,
                    sizeof(ShellFileInfo),
                    SHGFI_USEFILEATTRIBUTES|SHGFI_SYSICONINDEX
                    ))
        {
            *piIndex = ShellFileInfo.iIcon;
            *pwFlags = GIL_NOTFILENAME;
            strcpy(szIconFile,"*");
            return S_OK;
        }
        return E_FAIL;
    } else
    {
        //
        //  All other icons are resources in this dll, so the path is to this DLL
        //
        if(GetModuleFileNameA(_Module.GetModuleInstance(), szIconFile, cchMax))
        {
            *pwFlags = 0;
            //
            // Assuming that we got the path, switch on the IconType to get the index
            //
            switch(m_eIconType)
            {
                case CXboxExtractIcon::AddConsole:
                    *piIndex = ICON_INDEX(IDI_ADD_CONSOLE);
                    break;
                case CXboxExtractIcon::Root:
                    *piIndex = ICON_INDEX(IDI_MAIN);
                    break;
                case CXboxExtractIcon::Console:
                    *piIndex = ICON_INDEX(IDI_CONSOLE);
                    break;
                case CXboxExtractIcon::ConsoleDefault:
                    *piIndex = ICON_INDEX(IDI_CONSOLE_DEFAULT);
                    break;
                case CXboxExtractIcon::Volume:
                    *piIndex = ICON_INDEX(IDI_VOLUME);
                    break;
                case CXboxExtractIcon::Folder:
                    *piIndex = ICON_INDEX(IDI_FOLDER);
                    break;
                case CXboxExtractIcon::Xbe:
                    *piIndex = ICON_INDEX(IDI_XBE);
                    break;
                default:
                    _ASSERT(FALSE);
            }
        } else
        {
            dwResult = GetLastError();
        }
    }
    return HRESULT_FROM_WIN32(dwResult);
}

HRESULT
CXboxExtractIcon::GetIconLocation(
    UINT uFlags,
    LPSTR szIconFile,
    UINT cchMax,
    LPINT piIndex,
    UINT *pwFlags
    )
{
    return GetIconLocationImpl(uFlags,szIconFile,cchMax,piIndex,pwFlags);
}
    
HRESULT
CXboxExtractIcon::GetIconLocation(
    UINT uFlags,
    LPWSTR szIconFile,
    UINT cchMax,
    LPINT piIndex,
    UINT *pwFlags
    )
{
    CHAR szIconFileBuffer[MAX_PATH];
    if(cchMax > MAX_PATH) cchMax = MAX_PATH;
    HRESULT hr = GetIconLocationImpl(uFlags,szIconFileBuffer,cchMax,piIndex,pwFlags);
    if(SUCCEEDED(hr))
    {
        wsprintfW(szIconFile, L"%hs", szIconFileBuffer);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbshlext\drop.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    drop.cpp

Abstract:

    Implementation of CXboxDropTarget

Environment:

    Windows 2000 and Later 
    User Mode
    ATL

Revision History:
    
    04-03-2001 : created (mitchd)

--*/

#include "stdafx.h"

//--------------------------------------------------------------------
//  Implemenation of CXboxDropTarget
//--------------------------------------------------------------------

HRESULT 
CXboxDropTarget::Create(
    HWND hWndParent,
    UINT cidl,
    LPCITEMIDLIST * apidl,
    CXboxFolder *pParent,
    IDropTarget **ppDropTarget
    )
/*++
 Routine Description:
  Creates an IDropTarget for THE selected volume or directory.

 Arguments:

  cidl         - number of ItemIDs selected (better be zero -meaning the parent- or one.
  apidl        - array of selected ItemIDs.
  pParent      - parent of the selected items (unless cidl is zero).
  ppDropTarget - [OUT] get the drop target on success

 Return Value:

  S_OK on success.
  E_NOINTERFACE if the object type is not supported.
  E_OUTOFMEMORY is always possible.
--*/
{
    HRESULT      hr;
    ULONG        ulShellAttributes;
    CXboxFolder *pSelection = NULL;

    //
    //  Assume failure until success
    //
    hr = E_NOINTERFACE;
    *ppDropTarget = NULL;
    
    //
    //  Only proceed if only one item is in the selection.
    //
    if(cidl < 2)
    {
        //
        //  Ask the pParent if the selected items are valid drop targets.
        //  Since the parent is part of this code module we can trust it.
        //
        ulShellAttributes = SFGAO_DROPTARGET;
        hr = pParent->GetAttributesOf(cidl, apidl, &ulShellAttributes);
    }


    //
    //  Make a clone
    //

    if(SUCCEEDED(hr) && ulShellAttributes)
    {
        hr = pParent->CloneSelection(cidl, apidl,&pSelection);
    }

    //
    //  Create the object
    //

    if(SUCCEEDED(hr))
    {
        CComObject<CXboxDropTarget> *pDropTarget;
        hr = CComObject<CXboxDropTarget>::CreateInstance(&pDropTarget);
        if(SUCCEEDED(hr))
        {
            pDropTarget->m_pSelection = pSelection;
            pDropTarget->m_hWnd = hWndParent;
            hr = pDropTarget->QueryInterface(IID_PPV_ARG(IDropTarget, ppDropTarget));
            _ASSERT(SUCCEEDED(hr));
        } else
        {
            pSelection->Release();
        }
    }
    return hr;
}

HRESULT
CXboxDropTarget::DragEnter(
    IDataObject * pDataObject,
    DWORD grfKeyState,
    POINTL pt,
    DWORD * pdwEffect
    )
/*++
  Routine Description:
    pDataObject    
--*/
{
    HRESULT hr;
    hr = S_OK;
    
    //
    //  Assume we cannot drop until we learn otherwise.
    //
    *pdwEffect = DROPEFFECT_NONE;

    if(SetDefaultEffect(pDataObject))
    {
        //
        //  Cache this as Drop will need it, and
        //  gets a bogus value.  This may be updated
        //  in DragOver.
        //
        m_grfKeyState = grfKeyState;
            
        //
        // Clear the right mouse button, so GetEffect doesn't go
        // asking the user.
        //
        grfKeyState &= ~MK_RBUTTON;

        //
        //  Get the effect.
        //
        *pdwEffect = GetEffect(grfKeyState, pt);
    }
    return S_OK;
}

HRESULT
CXboxDropTarget::DragOver(
    DWORD grfKeyState,
    POINTL pt,
    DWORD *pdwEffect
    )
{
    //
    //  Update our cached value of grfKeyState
    //
    m_grfKeyState = grfKeyState;
    
    //
    //  Filter out the right mouse button to prevent
    //  GetEffect from querying the user.
    //
    grfKeyState &= ~MK_RBUTTON;

    //
    //  Get the effect 
    //
    *pdwEffect = GetEffect(grfKeyState, pt);
    return S_OK;
}

HRESULT
CXboxDropTarget::DragLeave()
{
    m_dwDefaultEffect = DROPEFFECT_NONE;
    return S_OK;
}

HRESULT
CXboxDropTarget::Drop(
    IDataObject * pDataObject,
    DWORD grfKeyState,
    POINTL pt,
    DWORD * pdwEffect
    )
/*++

  Routine Description:
    Called to start the actual file transfer associated with a drag\drop operation.

    The steps are:
        1) Figure out the drop effect.
        2) Call the XboxItem's DoFileTransfer.

    Note:
        We ignore the *pdwEffect on input.  Instead we call our GetEffect member
        function.  It looks at grfKeyState and decides the effect or prompts the user
        if appropriate.
--*/
{
    HRESULT hr = S_OK;
    *pdwEffect = DROPEFFECT_NONE;

    if(!m_pSelection)
    {
        return S_OK;
    }

    //
    //  Get the effect.
    //
    SetDefaultEffect(pDataObject);  //This shouldn't be necessary, since it was set on DragEnter, but just to be safe.
    *pdwEffect = GetEffect(m_grfKeyState, pt);

    //
    //  If we need to do a transfer, then do it.
    //
    if(DROPEFFECT_NONE != *pdwEffect)
    {
        CDropOperation *pDropOperation = new CDropOperation(m_pSelection, pDataObject, *pdwEffect, m_hWnd);
        *pdwEffect = pDropOperation->StartTransfer();
    }
   
    return hr;
}

BOOL CXboxDropTarget::SetDefaultEffect(IDataObject *pDataObject)
/*++
  Routine Description:
    SetDefaultEffect sets the effect based only the source and target, not considering
    which mouse button was clicked or which keyboard keys are being held down.

    This routine is intended to set m_dwDefaultEffect.

    This is called on DragEnter.  It is also called on Drop simply as a sanity check, really
    it shouldn't be necessary.  On DragOver we can assume that the source has not changed since DragEnter.

    Basically, we ask CDropOperation what clipformat it would use.  If there is none, then the
    data is not dropable on our target.  If it is CF_XBOXFILEDESCRIPTOR, then the source is an Xbox.
    If the drop source is an Xbox, we need to check for two additional conditions:

    1) The target directory and source directory are the same.  These transfers
    are dissallowed, as that would mean copying files over themselves.  Windows Explorer
    renames such files to Copy Of, but we think that is just silly, the user probably
    didn't mean to do it.  We return DROPEFFECT_NONE to disallow these.

    2) If the target and source directory are different, but on the same machine, we return
    DROPEFFECT_MOVE to indicate that a move is the default drop effect.

    Otherwise, we return DROPEFFECT_COPY as the default drop effect.

  Arguments:
    pDataObject - the data object provided by the source.

  Return Value:
    TRUE   - if m_dwDefaultEffect was set to anything but DROPEFFECT_NONE, the data is droppable.
    FALSE  - m_dwDefault was set to DROPEFFECT_NONE, the data is not droppable.
--*/
{
    // If there is no target yet, there is no drop effect.
    if(!m_pSelection)
    {
        m_dwDefaultEffect = DROPEFFECT_NONE;
        return FALSE;
    }

    CLIPFORMAT clipFormat = CDropOperation::GetDropFormat(pDataObject);
    if(!clipFormat)
    {
        m_dwDefaultEffect = DROPEFFECT_NONE;
        return FALSE;
    }
    
    // It is a copy until we find out otherwise.
    m_dwDefaultEffect = DROPEFFECT_COPY;

    // If the source is an Xbox there is more work
    if(CF_XBOXFILEDESCRIPTOR==clipFormat)
    {
        FORMATETC formatEtc;
        STGMEDIUM stgMedium;

        // Get the source directory.  The most effiecient CF for the job is CF_SHELLIDLIST.  
        // CF_XBOXFILEDESCRIPTOR is specific to this shell extension, and we know that we
        // also implemented CF_SHELLIDLIST, so it must have it.

        formatEtc.cfFormat = CF_SHELLIDLIST;
        formatEtc.ptd = NULL;
        formatEtc.dwAspect = DVASPECT_CONTENT;
        formatEtc.lindex = -1;
        formatEtc.tymed = TYMED_HGLOBAL;
        memset(&stgMedium, 0, sizeof(stgMedium));

        // Still check for error, as we could run out of memory, or something bizare
        // in the error case, dissallow transfers, if this fails something else will
        // later too.
        if(SUCCEEDED(pDataObject->GetData(&formatEtc, &stgMedium)))
        {
           BOOL fSameMachine;
           CIDA *pShellIdList = (CIDA  *)GlobalLock(stgMedium.hGlobal);
           LPITEMIDLIST pidlSourceFolder =  (LPITEMIDLIST)( (BYTE *)pShellIdList + pShellIdList->aoffset[0]);
           LPITEMIDLIST pidlTargetFolder = m_pSelection->GetTargetPidl(NULL);
           // Check the two conditions
           if(CXboxFolder::AreItemsIDsIdentical(pidlSourceFolder, pidlTargetFolder, &fSameMachine))
           {
                m_dwDefaultEffect = DROPEFFECT_NONE;
           } else if(fSameMachine)
           {
                m_dwDefaultEffect = DROPEFFECT_MOVE;
           }
           CPidlUtils::Free(pidlTargetFolder);
           ReleaseStgMedium(&stgMedium);
        } else
        {
            m_dwDefaultEffect = DROPEFFECT_NONE;
        }
    }
    return (DROPEFFECT_NONE==m_dwDefaultEffect) ? FALSE : TRUE;
}

DWORD CXboxDropTarget::GetEffect(DWORD grfKeyState, POINTL pt)
/*++
    Routine Description:
      Consider at the grfKeyState to determine the appropriate drop effect.  Possibly
      query the user if the right mouse button is down.

      m_dwDefaultDrop has previously been set.  It is the default effect for the source
      and target assuming that no keys are down, and the left mouse button was used.
      If it DROPEFFECT_NONE, then the source and target are not compatible, we should
      just leave.
      
      It is based off of CTRL, ALT, and SHFT.  None of these down means m_dwDefaultDrop.
      SHFT alone means DROPEFFECT_MOVE. CTRL alone is DROPEFFECT_COPY.  Any other combination
      of CTRL, ALT or SHFT would mean "create shortcut", but we don't support it, so we just
      leave the default.

      If MK_RBUTTON is pressed then we query the user at (pt) with a pop context menu.  The default
      effect on the menu, is the effect that was yielded from the test in the preceding paragraph.
    
    Parameters:
      grfKeyState - bitmap of keys pressed at time of call to Drop or DragEnter.
      pt          - point were drop is taking place.
   
    Return Value:
      The drop effect that should be performed.

    Caveat:
      DragEnter always clears MK_RBUTTON to avoid prompting the user.
    
--*/
{
    // Start with the default effect.
    DWORD dwEffect = m_dwDefaultEffect;

    // If the default effect was none, then there can be no drop, return none.
    if(DROPEFFECT_NONE == m_dwDefaultEffect) return DROPEFFECT_NONE;

    // Alt being down would be short-cut, which we are doing as default, so only
    // check further if ALT is not down.
    if(!(MK_ALT&grfKeyState))
    {
        //Check if shift button is down
        if(MK_SHIFT&grfKeyState)
        {
            //shift and control together is short-cut which we are doing as default.
            if(!(MK_CONTROL&grfKeyState))
                dwEffect = DROPEFFECT_MOVE;
        } else
        {
            // control alone (without SHFT or ALT) means copy
            if(MK_CONTROL&grfKeyState)
                dwEffect = DROPEFFECT_COPY;
        }
    }
    
    //
    //  If the right mouse button is pressed display the drop
    //  context menu (copy\move\cancel) default item in the
    //  menu is the result of the above logic.
    //
    if(MK_RBUTTON&grfKeyState)
    {
        dwEffect = DisplayDropPopUp(dwEffect, pt);
    }
    return dwEffect;
}

DWORD CXboxDropTarget::DisplayDropPopUp(DWORD dwEffect, POINTL pt)
/*++
  Routine Description:
    Display the "drop effect" context menu that queries copy/move/cancel.
--*/
{
    DWORD dwReturnEffect = 0;
    HMENU hMainMenu = LoadMenu(_Module.GetModuleInstance(), MAKEINTRESOURCE(IDM_CONTEXT_MENU_DROP));
    if(hMainMenu)
    {
        HMENU hMenu = GetSubMenu(hMainMenu, 0);
        if(hMenu)
        {
            if(SetMenuDefaultItem(hMenu, dwEffect, FALSE)) //The menu item ID is DROPEFFECT_COPY or DROPEFFECT_MOVE
            {
                SetForegroundWindow(m_hWnd);
                dwReturnEffect = TrackPopupMenuEx(hMenu, TPM_NONOTIFY|TPM_RETURNCMD|TPM_LEFTALIGN|TPM_TOPALIGN, pt.x, pt.y, m_hWnd, NULL);
            }
        }
        DestroyMenu(hMainMenu);
    }
    return dwReturnEffect;
}



//---------------------------------------------------------------------------------------------------------
//  Implementation of CDropOperation
//---------------------------------------------------------------------------------------------------------
const FORMATETC CDropOperation::sm_SupportedFormats[] = 
{
    {CF_XBOXFILEDESCRIPTOR, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
    {CF_HDROP,              NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
    {CF_FILEDESCRIPTORA,    NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
    {CF_FILEDESCRIPTORW,    NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL}
};
const UINT CDropOperation::sm_uSupportedFormatCount = sizeof(CDropOperation::sm_SupportedFormats)/sizeof(FORMATETC);

HRESULT CDropOperation::GetDropData(IDataObject *pDataObject, FORMATETC *pFormatEtc, STGMEDIUM *pStgMedium)
/*++
  Routine Description:
    This static member queries a data object for a supported file transfer format.  It can query only or
    it can retrieve the data.
  Arguments:
   pDataObject - the data object to query.
   pFormatEtc  - [OUT] on output contains the format retrieved.
   pStgMedium  - [IN\OUT] If NULL on input, the QueryGetData is used.  If non-NULL, then it contains the data
                 on output.
 Return Value:
   On success - S_OK.
   Otherwise  - Any error returned from IDataObject::GetQueryData or IDataObject::GetData.
--*/
{
    HRESULT hr;
    UINT uFormatIndex;
    for(uFormatIndex=0; uFormatIndex < sm_uSupportedFormatCount; uFormatIndex++)
    {
        //
        //  Copy the format to the output buffer
        //
        *pFormatEtc = sm_SupportedFormats[uFormatIndex];

        if(pStgMedium)
        {
            hr = pDataObject->GetData(pFormatEtc, pStgMedium);
        } else
        {
            hr = pDataObject->QueryGetData(pFormatEtc);
        }
        if(SUCCEEDED(hr)) break;
    }
    return hr;
}

CLIPFORMAT CDropOperation::GetDropFormat(IDataObject *pDataObject)
/*++
  Routine Description:
    Wraps CDropOperation::GetDropData in the case that we just want to Query.

  Arguments:
    pDataObject - the data object to query.

  Return Value:
    On Success - cfFormat member of FORMATETC for the optimal format.
    Of Failure - 0, no further error information available.

--*/
{
   FORMATETC formatEtc;
   if(SUCCEEDED(CDropOperation::GetDropData(pDataObject, &formatEtc, NULL)))
   {
        return formatEtc.cfFormat;
   }
   return 0;
}


CDropOperation::~CDropOperation()
{
    if(m_pDataObject) m_pDataObject->Release();
    if(m_pSelection) m_pSelection->Release();
}
    
    
DWORD
CDropOperation::StartTransfer()
/*++
  Routine Description:
    Does the Transfer.

  Return Value:
    The effect actually performed.
--*/
{
    DWORD   dwReturn;
    
    HRESULT hr;
    IAsyncOperation *pAsyncOperation;
    IDataObject *pDataObject;
    
    hr = m_pDataObject->QueryInterface(IID_PPV_ARG(IAsyncOperation, &pAsyncOperation));
    if(SUCCEEDED(hr))
    {
        hr = pAsyncOperation->GetAsyncMode(&m_fAsync);
        if(SUCCEEDED(hr)&&m_fAsync)
        {
            hr = pAsyncOperation->StartOperation(NULL);
            pAsyncOperation->Release();
            if(SUCCEEDED(hr))
            {
                //
                //  Pack the IDataObject in a marshalling stream
                //
                hr = CoMarshalInterThreadInterfaceInStream(IID_IDataObject, m_pDataObject, &m_pMarshallingStream);
                if(SUCCEEDED(hr))
                {
                    pDataObject = m_pDataObject;
                    m_pDataObject = NULL;
                    if(SHCreateThread(CDropOperation::ThreadProc, (PVOID)this, CTF_COINIT, NULL))
                    {
                        pDataObject->Release();
                        return DROPEFFECT_NONE;
                    }
                    m_pDataObject = pDataObject;
                    m_pMarshallingStream->Release();
                    m_pMarshallingStream = NULL;
                    hr = HRESULT_FROM_WIN32(GetLastError());
                }
            }
        }
    }

    //
    //  If we are here, either we shouldn't or couldn't do it asynchronously, so trying
    //  doing it synchronously.
    //
    dwReturn = DoTransfer();
    delete this;
    return dwReturn;
}


DWORD CDropOperation::TransferThread()
/*++
  Routine Description:
    The thread routine for doing a background transfer.
    1) Unmarshals the data object across threads.
    2) Calls DoTransfer() to perform the transfer, just as
       if done synchronously.
    3) Get IAsyncOperation interface and calls EndOperation.
    4) Cleans up by deleting this object.
--*/
{
    DWORD dwResult;
    HRESULT hr;
    IAsyncOperation *pAsyncOperation;
    hr = CoGetInterfaceAndReleaseStream(m_pMarshallingStream, IID_PPV_ARG(IDataObject, &m_pDataObject));
    m_pMarshallingStream = NULL;
    if(SUCCEEDED(hr))
    {
        dwResult = DoTransfer();
        hr = m_pDataObject->QueryInterface(IID_PPV_ARG(IAsyncOperation, &pAsyncOperation));
        if(SUCCEEDED(hr))
        {
            pAsyncOperation->EndOperation(S_OK, NULL, dwResult);
            pAsyncOperation->Release();
        }
    }
    delete this;
    return 0;
}

DWORD CDropOperation::DoTransfer()
/*++
  Routine Description:
    The main workhorse routine for performing transfers.  This may be
    called from the main thread to do a synchronous transfer, or may
    be called from CDropOperation::TransferThread.

    1) Get the main clipboard format for the drop: CF_XBOXFILEDESCRIPTOR, CF_HDROP,
       CF_FILEDESCRIPTORA, or CF_FILEDESCRIPTORW.
    2) Put up the ProgressDialog with the message "Calculating the time to [move\copy] the files."
    3) Branch to the correct transfer routine, based on clipboard format.
    4) Stop the Progress Dialog.
    5) Set the performed effect, and the logical effect, etc.
--*/
{
   HRESULT hr;
   FORMATETC formatEtc;

   //
   //  Get the drop format data.
   //
   hr = GetDropData(m_pDataObject, &formatEtc, &m_stgMedium);
   if(FAILED(hr)) return DROPEFFECT_NONE;

   StartProgressDialog();
   
   m_pTargetConnection = m_pSelection->GetXboxConnection();
   m_pTargetConnection->HrUseSharedConnection(TRUE);
   _ASSERTE(m_pTargetConnection);

   //
   //   Call the correct transfer function, cannot use switch\case as
   //   the CF_ constants are runtime constants, not compiler constants.
   //
   if(CF_XBOXFILEDESCRIPTOR==formatEtc.cfFormat)   DoXboxFileGroupDescriptorTransfer();
   else if(CF_HDROP==formatEtc.cfFormat)           DoHDropTransfer();
   else if(CF_FILEDESCRIPTORA==formatEtc.cfFormat) DoFileGroupDescriptorATransfer();
   else if(CF_FILEDESCRIPTORW==formatEtc.cfFormat) DoFileGroupDescriptorWTransfer();
   else _ASSERT(FALSE);

   m_pTargetConnection->HrUseSharedConnection(FALSE);
   m_pTargetConnection->Release();
   m_pTargetConnection = NULL;
   
   //
   //  Release the main transfer data.
   //

   ReleaseStgMedium(&m_stgMedium);

   StopProgressDialog();

   DataObjUtil::SetPerformedDropEffect(m_pDataObject, m_dwEffectPerformed);
   DataObjUtil::SetPasteSucceeded(m_pDataObject, m_dwEffectPerformed);
    
   return m_dwEffectPerformed;
}


void CDropOperation::StartProgressDialog()
/*++
  Routine Description:
    Instantiates and starts the progress dialog.  The initial message is always
    a preparing message appropriate to move versus copy.
--*/
{
   
   HRESULT   hr;
   WCHAR     wszBuffer[128];
   WCHAR     wszProgressText[128];
   UINT      uTitleResource;
   UINT      uPrepareResource;
   HINSTANCE hInstance = _Module.GetModuleInstance(); 

   //
   //  Instantiate a progress dialog
   //
   hr = CoCreateInstance(
            CLSID_ProgressDialog,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_PPV_ARG(IProgressDialog, &m_pProgressDialog)
            );
    if(FAILED(hr))
    {
        m_pProgressDialog = NULL;
        return;
    }
    
    //
    //  Choose resources based on copy versus move.
    //
    if(DROPEFFECT_MOVE == m_dwDesiredEffect)
    {
        uTitleResource = IDS_FILE_MOVE_PROGRESS_TITLE;
        uPrepareResource = IDS_FILE_MOVE_PROGRESS_PREPARING;
    } else
    {
        uTitleResource = IDS_FILE_COPY_PROGRESS_TITLE;
        uPrepareResource = IDS_FILE_COPY_PROGRESS_PREPARING;
    }

    //
    //  Set the title
    //
    LoadStringW(hInstance, uTitleResource, wszBuffer, 128);
    m_pProgressDialog->SetTitle(wszBuffer);

    //
    //  Set the animation
    //
    m_pProgressDialog->SetAnimation(hInstance, IDA_COPY);

    //
    //  Start the dialog
    //
    m_pProgressDialog->StartProgressDialog(m_hWnd, NULL, PROGDLG_AUTOTIME, NULL);

    //
    //  Set the cancel message
    //
    LoadStringW(hInstance, IDS_FILE_PROGRESS_CANCEL, wszBuffer, 128);
    m_pProgressDialog->SetCancelMsg(wszBuffer, NULL);
    
    //
    //  See if we can get the progress dialog's window to use as the parent for message box's.
    //  Note that QueryWinodw will preserve m_hParentWnd if it fails, before the call it
    //  was to the same as m_hWnd in the c'tor.  Ideally, if we get the hWnd of the progress dialog
    //  it will solve some focus problems.
    //
    ComUtils::QueryWindow(&m_hParentWnd, m_pProgressDialog);

    //
    //  Put up the prepare message.
    //
    LoadStringW(hInstance, uPrepareResource, wszBuffer, 128);
    m_pProgressDialog->SetLine(1, wszBuffer,FALSE, NULL);


}

void CDropOperation::SetProgressTarget()
{
    if(!m_pProgressDialog) return;

    union
    {
        WCHAR wszTargetText[MAX_PATH];
        char  szTargetPath[MAX_PATH];
    };
    char   szConsoleName[60];
    char   szTargetText[MAX_PATH];
    m_pSelection->GetConsoleName(szConsoleName);
    m_pSelection->GetTargetWireName(szTargetPath, NULL);
    WindowUtils::rsprintf(szTargetText, IDS_FILE_PROGRESS_TARGET, szTargetPath, szConsoleName);
    Utils::CopyAtoW(wszTargetText, szTargetText);
    m_pProgressDialog->Timer(PDTIMER_RESET,NULL);
    m_pProgressDialog->SetLine(2, wszTargetText, TRUE, NULL);
}

void CDropOperation::UpdateCopyProgress(LPSTR pszFileName)
{
    if(!m_pProgressDialog) return;
    WCHAR wszFileName[MAX_PATH];
    Utils::CopyAtoW(wszFileName, pszFileName);
    m_pProgressDialog->SetLine(1, wszFileName, TRUE, NULL);
    m_pProgressDialog->SetProgress64(m_ullBytesCompleted, m_ullBytesTotal);
}

void CDropOperation::StopProgressDialog()
{
    if(!m_pProgressDialog) return;
    m_hParentWnd = m_hWnd;
    m_pProgressDialog->StopProgressDialog();
    m_pProgressDialog->Release();
    m_pProgressDialog = NULL;
}

BOOL CDropOperation::QueryCancel()
{
   if(!m_fCancelled)
   {
       if(!m_pProgressDialog) return FALSE;
       m_fCancelled = m_pProgressDialog->HasUserCancelled();
   }
   return m_fCancelled;
}

inline BOOL IsDirectory(FILEDESCRIPTORA *pFileDescriptor)
{
    return pFileDescriptor->dwFileAttributes&FILE_ATTRIBUTE_DIRECTORY;
}

inline BOOL IsReadOnly(FILEDESCRIPTORA *pFileDescriptor)
{
    return pFileDescriptor->dwFileAttributes&FILE_ATTRIBUTE_READONLY;
}

bool CDropOperation::ProcessConfirmResponse(UINT uDialogResponse, CDropOperation::CONFIRM_FLAGS eConfirmFlag)
{
    switch(uDialogResponse)
    {
        case IDC_XB_YESTOALL:
         m_uConfirmedYesToAll |= eConfirmFlag;
        case IDC_XB_YES:
         return true;
        case IDC_XB_CANCEL:
         m_fCancelled = TRUE;
        case IDC_XB_NOTOALL:
         m_uConfirmedNoToAll |= eConfirmFlag;
        case IDC_XB_NO:
         return false;
    }
    _ASSERT(FALSE);
    return false;
}

bool CDropOperation::ConfirmFolderMove(LPCSTR pszFolderName)
{
    //
    //  The user has previously answered yestoall or notoall
    //  just return yes or no.
    //
    if(m_uConfirmedNoToAll&CDropOperation::ConfirmFlagFolderMove) return false;
    if(m_uConfirmedYesToAll&CDropOperation::ConfirmFlagFolderMove) return true;

    //Ask the USER
    UINT uDlgResult = Dialog::ConfirmReadOnlyMove(m_hParentWnd, pszFolderName, true);
    
    //
    //  Process the user's response.
    //
    return ProcessConfirmResponse(uDlgResult, CDropOperation::ConfirmFlagFolderMove);
}
bool CDropOperation::ConfirmFileMove(LPCSTR pszFileName)
{
    //
    //  The user has previously answered yestoall or notoall
    //  just return yes or no.
    //
    if(m_uConfirmedNoToAll&CDropOperation::ConfirmFlagFileMove) return false;
    if(m_uConfirmedYesToAll&CDropOperation::ConfirmFlagFileMove) return true;

    //Ask the USER
    UINT uDlgResult = Dialog::ConfirmReadOnlyMove(m_hParentWnd, pszFileName,false);

    //
    //  Process the user's response.
    //
    return ProcessConfirmResponse(uDlgResult, CDropOperation::ConfirmFlagFileMove);
}

bool CDropOperation::ConfirmFileReplace(LPCSTR pszTargetWireName, LPSTR pszFileName, WIN32_FILE_ATTRIBUTE_DATA *pSourceFileAttributes, bool *pfOverWrite)
/*++

  Routine Description:
    Called when a file copy fails because the target already exists.  This routine figures out
    when we should blast over of the file.  It queries the user and keeps track of previous queries.
    Finally, if the answer is yes, it blows away the existing target.

--*/
{
    //
    //  Assume true.
    //  
    bool fResult = true;

    // Get the target attributes.
        
    DM_FILE_ATTRIBUTES dmFileAttributes;
    HRESULT hr = m_pTargetConnection->HrGetFileAttributes(pszTargetWireName, &dmFileAttributes);
    if(FAILED(hr))
    {
        *pfOverWrite = false;
        return true;
    }

    //
    //  If the target is a directory, then notify the user that this just isn't going to work.
    //
    if(dmFileAttributes.Attributes&FILE_ATTRIBUTE_DIRECTORY)
    {
        LPSTR pszSimpleName = strrchr(pszFileName, '\\');
        if(!pszSimpleName) pszSimpleName = pszFileName;
        if(m_dwFileCount>=2)
        {
            if(IDNO==WindowUtils::MessageBoxResource(m_hParentWnd, IDS_COULDNT_REPLACE_DIR_W_FILE_MULTI, IDS_TRANSFER_FAILED_CAPTION, MB_YESNO|MB_ICONERROR, pszSimpleName))
            {
                m_fCancelled = TRUE;
            }
        } else
        {
            // Kill Progress dialog, since the only file won't transfer anyway.
            StopProgressDialog();
            WindowUtils::MessageBoxResource(m_hParentWnd, IDS_COULDNT_REPLACE_DIR_W_FILE, IDS_TRANSFER_FAILED_CAPTION, MB_OK|MB_ICONERROR, pszSimpleName);
        }
        return false;
    }

    //
    //  If it is top level, i.e. doesn't have '\\' in its path,
    //  we should ask the user.
    //
    if(NULL==strchr(pszFileName, '\\'))
    {
        //
        //  If the user previously said notoall, we can leave now.
        //
        if(m_uConfirmedNoToAll&CDropOperation::ConfirmFlagFolderReplace) return false;

        //
        // If the user has not previously said yestoall, then ask the user.
        //
        if(!(m_uConfirmedYesToAll&CDropOperation::ConfirmFlagFolderReplace))
        {
            UINT uDlgResult;

            //
            //  Fill out the WIN32_FILE_ATTRIBUTE_DATA used by the replace dialog.
            //
            FILETIME ft = {0,0};
            WIN32_FILE_ATTRIBUTE_DATA TargetFileAttributes;
            TargetFileAttributes.dwFileAttributes = dmFileAttributes.Attributes;
            TargetFileAttributes.ftCreationTime = dmFileAttributes.CreationTime;
            TargetFileAttributes.ftLastAccessTime = ft;
            TargetFileAttributes.ftLastWriteTime = dmFileAttributes.ChangeTime;
            TargetFileAttributes.nFileSizeHigh = dmFileAttributes.SizeHigh;
            TargetFileAttributes.nFileSizeLow = dmFileAttributes.SizeLow;
            uDlgResult = Dialog::ConfirmFileReplace(m_hParentWnd, pszFileName, &TargetFileAttributes, pSourceFileAttributes);

            //
            //  Process the user's response.
            //
            fResult = ProcessConfirmResponse(uDlgResult, CDropOperation::ConfirmFlagFolderReplace);
        }
    }

    //
    //  If the answer is in the affirmative, blow away the existing file.
    //
    if(fResult)
    {
        //  Don't worry about failures blowing this stuff away.
        //  Soon enough the actual copy will fail.
        if(dmFileAttributes.Attributes&FILE_ATTRIBUTE_READONLY)
        {
            dmFileAttributes.Attributes &= ~FILE_ATTRIBUTE_READONLY;
            if(!dmFileAttributes.Attributes) dmFileAttributes.Attributes = FILE_ATTRIBUTE_NORMAL;
            hr = m_pTargetConnection->HrSetFileAttributes(pszTargetWireName, &dmFileAttributes);
        }
        hr = m_pTargetConnection->HrDeleteFile(pszTargetWireName, FALSE);
        if(FAILED(hr))
        {
            LPSTR pszSimpleName = strrchr(pszFileName, '\\');
            if(!pszSimpleName) pszSimpleName = pszFileName;
            HandleTransferFailed(IDS_COULDNT_REPLACE_FILE, hr, pszSimpleName);
        }
        *pfOverWrite = true;
    }
    
    return fResult;
}

bool CDropOperation::ConfirmFileReplace(LPCSTR szTargetWireName, FILEDESCRIPTORA *pFileDescriptor, bool *pfOverWrite)
{
    WIN32_FILE_ATTRIBUTE_DATA fileAttributes;
    fileAttributes.dwFileAttributes = pFileDescriptor->dwFileAttributes;
    fileAttributes.ftCreationTime = pFileDescriptor->ftCreationTime;
    fileAttributes.ftLastAccessTime = pFileDescriptor->ftLastAccessTime;
    fileAttributes.ftLastWriteTime = pFileDescriptor->ftLastWriteTime;
    fileAttributes.nFileSizeHigh = pFileDescriptor->nFileSizeHigh;
    fileAttributes.nFileSizeLow = pFileDescriptor->nFileSizeLow;
    return ConfirmFileReplace(szTargetWireName, pFileDescriptor->cFileName, &fileAttributes, pfOverWrite);
}

bool CDropOperation::ConfirmFolderReplace(LPCSTR pszFilenName)
{
    //
    //  The user has previously answered yestoall or notoall
    //  just return yes or no.
    //
    if(m_uConfirmedNoToAll&CDropOperation::ConfirmFlagFolderReplace) return false;
    if(m_uConfirmedYesToAll&CDropOperation::ConfirmFlagFolderReplace) return true;

    //Ask the USER
    UINT uDlgResult = Dialog::ConfirmFolderReplace(m_hParentWnd, pszFilenName);

    //
    //  Process the user's response.
    //
    return ProcessConfirmResponse(uDlgResult, CDropOperation::ConfirmFlagFolderReplace);
}

bool CDropOperation::MakeTargetDirectory(LPCSTR pszTargetWireName, FILEDESCRIPTORA *pFileDescriptor)
/*++
  Routine Description:
    Called to make a directory on the target system.  The directory should have the attributes
    of the source
--*/
{
    DM_FILE_ATTRIBUTES dmFileAttributes;
    dmFileAttributes.Attributes = pFileDescriptor->dwFileAttributes;
    dmFileAttributes.ChangeTime = pFileDescriptor->ftLastWriteTime;
    dmFileAttributes.CreationTime = pFileDescriptor->ftCreationTime;
    dmFileAttributes.SizeHigh = pFileDescriptor->nFileSizeHigh;
    dmFileAttributes.SizeLow = pFileDescriptor->nFileSizeLow;
    strcpy(dmFileAttributes.Name, pFileDescriptor->cFileName);
    return MakeTargetDirectory(pszTargetWireName, &dmFileAttributes);
}

bool CDropOperation::MakeTargetDirectory(LPCSTR pszTargetWireName, DM_FILE_ATTRIBUTES *pSourceFileAttributes)
/*++
  Routine Description:
    Called to make a directory on the target system.  
    
    The new directory should have the attributes of the source directory.
    
    If the directory already exists and it is a top-level directory of the drop target
    (it does not a '\\' character in the pSourceFileAttributes->cFilename) then the
    user should be asked for confirmation.

    If the directory exists and confirmation has been given or wasn't needed, then this
    routine sets the attributes of the existing directory to match those of the source
    file.
--*/
{
    
    HRESULT hr;
    bool fOverWrite = false;
    hr = m_pTargetConnection->HrMkdir(pszTargetWireName);
    
    if(XBDM_ALREADYEXISTS == hr)
    {
        if(0==strchr(pSourceFileAttributes->Name, '\\'))
        {
            if(!ConfirmFolderReplace(pSourceFileAttributes->Name))
            {
                return false;
            }
        }
        fOverWrite = true;
    } else if(FAILED(hr))
    {
        LPCSTR pszSimpleName = strrchr(pszTargetWireName, '\\');
        if(!pszSimpleName) pszSimpleName = pszTargetWireName;
        HandleTransferFailed(IDS_COULDNT_CREATE_TARGET_DIR, hr, pszSimpleName);
        return false;
    }
    
    //  Don't bother with errors, there is nothing we are going to do about it, and 
    //  we won't abort or notify the user if we could not change the folder attributes.
    m_pTargetConnection->HrSetFileAttributes(pszTargetWireName, pSourceFileAttributes);
    // Send out notification that directory was created (or updated if this was an fOverWrite
    LPITEMIDLIST pidl = m_pSelection->GetTargetPidl(pSourceFileAttributes->Name);
    SHChangeNotify(fOverWrite ? SHCNE_ATTRIBUTES : SHCNE_MKDIR, SHCNF_FLUSH|SHCNF_IDLIST, pidl, NULL);
    CPidlUtils::Free(pidl);

    return true;
}


void CDropOperation::DoXboxFileGroupDescriptorTransfer()
{
    HRESULT hr;

    _ASSERTE(TYMED_HGLOBAL == m_stgMedium.tymed);
    PXBOXFILEGROUPDESCRIPTOR pXboxFileGroupDescriptor = (PXBOXFILEGROUPDESCRIPTOR)GlobalLock(m_stgMedium.hGlobal);

    IXboxConnection *pSourceConnection;
    char szTargetWireName[MAX_PATH];
    char szSourceWireName[MAX_PATH];
    char szTempFile[MAX_PATH];
        
    LPSTR pszParse;
    LPSTR pszConsoleName;

    bool fMove = (DROPEFFECT_MOVE == m_dwDesiredEffect);
    bool fOptimizedMove = fMove;  //Assume it is optimized, until we found that it doesn't work.
    bool fOverWrite; //Keeps track of overwrite in for notification purposes

    ULARGE_INTEGER li;
    
    //
    //  Generate a temporary filename, we will recycle throughout.
    //
    if(INVALID_HANDLE_VALUE==WindowUtils::CreateTempFile(szTempFile, false))
    {
        //This is an unexpected and somewhat critical error, the use shouldn't ever see it though, unless their machine
        //is hosed for some other reason.  Nothing sucks more than a cycle of errors when the system is hosed, which is likely
        //what will happen if we continue, so let's kill the progress dialog, and cancel the rest of the transfer too.
        StopProgressDialog();
        m_fCancelled = TRUE;
        WindowUtils::MessageBoxResource(m_hParentWnd, IDS_CREATE_TEMP_FILE_FAILED, IDS_TRANSFER_FAILED_CAPTION, MB_OK|MB_ICONERROR);
        GlobalUnlock(m_stgMedium.hGlobal);

        return;
    }

    //
    //  Figure out how many bytes need to be transfered.
    //
    m_dwFileCount = pXboxFileGroupDescriptor->cItems;
    m_ullBytesCompleted = 0;
    m_ullBytesTotal = 0;    
    UINT index;
    for(index=0; index < pXboxFileGroupDescriptor->cItems; index++)
    {
        m_ullBytesTotal += FILE_PROGRESS_FUDGE_BYTES;  //Add fudge bytes for files and directories
        if(!IsDirectory(pXboxFileGroupDescriptor->fgd+index))
        {
            li.LowPart = pXboxFileGroupDescriptor->fgd[index].nFileSizeLow;
            li.HighPart = pXboxFileGroupDescriptor->fgd[index].nFileSizeHigh;
            m_ullBytesTotal += li.QuadPart;
        }
    }

    //
    //  Check the console names and see if it is the same box
    //

    pszParse = pXboxFileGroupDescriptor->szFolderPath;
    pszConsoleName = szSourceWireName; //USe SoureWireName buffer for the console name.
    while(*pszParse!='\\')
    {
        *pszConsoleName++ = *pszParse++;
    }
    *pszConsoleName = '\0';
    m_pSelection->GetConsoleName(szTargetWireName);
    
    //
    //  If source and target are the same box, then we 
    //  can use the same connection.
    //
    if(0==_stricmp(szTargetWireName, szSourceWireName))
    {
        pSourceConnection = m_pTargetConnection;
        pSourceConnection->AddRef();
    } else
    //
    //  Otherwise, we must go out and get our connection
    //
    {
        hr = Utils::GetXboxConnection(szSourceWireName, &pSourceConnection);
        if(FAILED(hr))
        {
            HandleTransferFailed(IDS_COULDNT_CONNECT_TO_XBOX, hr, szSourceWireName);
            GlobalUnlock(m_stgMedium.hGlobal);
            return;
        }
        pSourceConnection->HrUseSharedConnection(TRUE);
        //
        //  And we certainly cannot do optimized moves.
        //
        fOptimizedMove = false;
    }
    
    //
    //  Change the message we are going to start copying.
    //
    SetProgressTarget();

    //
    //  Now loop over everything and do the copy
    //

    for(index=0; index < pXboxFileGroupDescriptor->cItems; index++)
    {
        FILEDESCRIPTORA *fileDescriptor = pXboxFileGroupDescriptor->fgd + index;
        
        //
        //  Each time through check for a cancel.
        //
        if(QueryCancel()) break;

        //
        //  Get information about the item
        //
        bool fIsTopLevel = strchr(fileDescriptor->cFileName, '\\') ? false : true;
        
        //
        //  Update Progress Dialog
        //
        UpdateCopyProgress(fileDescriptor->cFileName);

        //For each file we touch (and directory) add back fudge bytes
        m_ullBytesCompleted += FILE_PROGRESS_FUDGE_BYTES;

        //
        //  Get the target wire name.
        //
        m_pSelection->GetTargetWireName(szTargetWireName, fileDescriptor->cFileName);

        //
        //  For directories, we just create the new directories in first pass
        //  even for move operations
        if(IsDirectory(fileDescriptor))
        {
            //
            //  We have to confirm moves.
            //
            if(fMove && fIsTopLevel && IsReadOnly(fileDescriptor))
            {
                if(ConfirmFolderMove(fileDescriptor->cFileName))
                {
                    if(MakeTargetDirectory(szTargetWireName, fileDescriptor))
                    {
                        continue;
                    }
                }
            } else
            {
                if(MakeTargetDirectory(szTargetWireName, fileDescriptor))
                {
                        continue;
                }
            }

            //
            //  If we fell throughm the directory could not be created
            //  for some reason (file operation failed, user didn't confirm,
            //  etc.).  So skip everything under this directory.
            //

            LPSTR pszDirectory = fileDescriptor->cFileName;
            UINT  uDirectoryNameLen = strlen(pszDirectory);
            do
            {
                fileDescriptor->dwFlags = (UINT)-1;
                index++;
                fileDescriptor = pXboxFileGroupDescriptor->fgd + index;
            }while(0==memcmp(pszDirectory, fileDescriptor->cFileName, uDirectoryNameLen));
            index--; //backup one, since it gets incremented at the start of the loop.
            continue;
        }

        //
        //  If we fell through than it is file.
        //
        
        // By the next time we call UpdateCopyProgress we will be done with this file, either copied
        // cancel or failed.  Anyway you slice it, we need to account for those bytes, and here we get the all at once.
        li.LowPart = fileDescriptor->nFileSizeLow;
        li.HighPart = fileDescriptor->nFileSizeHigh;
        m_ullBytesCompleted += li.QuadPart;
        
        //
        //  The user may need to confirm moves.
        //
        if(fMove && fIsTopLevel && IsReadOnly(fileDescriptor))
        {
            if(!ConfirmFileMove(fileDescriptor->cFileName))
            {
                continue;
            }
        }
        //
        //  We will need a source name
        //
        CXboxFolder::GetWireName(szSourceWireName, pXboxFileGroupDescriptor->szFolderPath, fileDescriptor->cFileName);
        
        //
        //  We will need the source attributes.
        //
        DM_FILE_ATTRIBUTES dmFileAttributes;
        dmFileAttributes.Attributes = fileDescriptor->dwFileAttributes;
        dmFileAttributes.ChangeTime = fileDescriptor->ftLastWriteTime;
        dmFileAttributes.CreationTime = fileDescriptor->ftCreationTime;
        dmFileAttributes.SizeHigh = fileDescriptor->nFileSizeHigh;
        dmFileAttributes.SizeLow = fileDescriptor->nFileSizeLow;

        //
        //  If optimized move is selected,
        //  give it a try.
        //
        if(fOptimizedMove)
        {
            
            hr = S_OK;
            if(IsReadOnly(fileDescriptor))
            {
                dmFileAttributes.Attributes &= ~FILE_ATTRIBUTE_READONLY;
                if(!dmFileAttributes.Attributes) dmFileAttributes.Attributes = FILE_ATTRIBUTE_NORMAL;               
                hr = m_pTargetConnection->HrSetFileAttributes(szSourceWireName, &dmFileAttributes);
                dmFileAttributes.Attributes = fileDescriptor->dwFileAttributes;            
            }
            if(SUCCEEDED(hr))
            {
                if(ConfirmFileReplace(szTargetWireName, fileDescriptor, &fOverWrite))
                {
                    hr = m_pTargetConnection->HrRenameFile(szSourceWireName, szTargetWireName);
                } else
                {
                    hr = E_ABORT;
                }
                //
                //  Restore attributes if it was read-only
                //
                if(IsReadOnly(fileDescriptor))
                {
                    m_pTargetConnection->HrSetFileAttributes(szTargetWireName, &dmFileAttributes);
                }
            }
            //
            //  XBDM_MUSTCOPY means that we cannot do an optimized move on
            //  this file.  This means we shouldn't even try on the rest
            //  of the files.
            if(XBDM_MUSTCOPY==hr)
            {
                fOptimizedMove = false;
            } else if(FAILED(hr))
            {
               LPSTR pszSimpleName = strrchr(szTargetWireName, '\\');
               if(!pszSimpleName) pszSimpleName = szTargetWireName;
               HandleTransferFailed(IDS_COULDNT_MOVE_FILE, hr, pszSimpleName);
               continue;
            } else
            {
                // Send out notification that the source was deleted.
                LPITEMIDLIST pidl = m_pSelection->GetSourcePidl(
                                        pXboxFileGroupDescriptor->szFolderPath,
                                        fileDescriptor->cFileName
                                        );
                SHChangeNotify(SHCNE_DELETE,SHCNF_FLUSH|SHCNF_IDLIST, pidl, NULL);
                CPidlUtils::Free(pidl);
                // Send out notification that target was created (or updated if this was an fOverWrite
                pidl = m_pSelection->GetTargetPidl(fileDescriptor->cFileName);
                SHChangeNotify(fOverWrite ? SHCNE_UPDATEITEM : SHCNE_CREATE,SHCNF_FLUSH|SHCNF_IDLIST, pidl, NULL);
                CPidlUtils::Free(pidl);
                continue;
            }
        } //end of optimized move

        //
        //  Copy the source to a local file.
        //
        hr = pSourceConnection->HrReceiveFile(szTempFile, szSourceWireName);
        if(FAILED(hr))
        {
            LPSTR pszSimpleName = strrchr(szSourceWireName, '\\');
            if(!pszSimpleName) pszSimpleName = szSourceWireName;
            HandleTransferFailed(IDS_COULDNT_READ_SOURCE_FILE, hr, pszSimpleName);
            continue;
        }

        //
        //  Copy the temporary file to the target.
        //

        if(ConfirmFileReplace(szTargetWireName, fileDescriptor, &fOverWrite))
        {
           hr = m_pTargetConnection->HrSendFile(szTempFile, szTargetWireName);
           //
           //  Handle success or failure.
           //
           if(SUCCEEDED(hr))
           {
              //The target attributes should match the source attributes.
              m_pTargetConnection->HrSetFileAttributes(szTargetWireName, &dmFileAttributes);
              // Send out notification that target was created (or updated if this was an fOverWrite
              LPITEMIDLIST pidl = m_pSelection->GetTargetPidl(fileDescriptor->cFileName);
              SHChangeNotify(fOverWrite ? SHCNE_UPDATEITEM : SHCNE_CREATE,SHCNF_FLUSH|SHCNF_IDLIST, pidl, NULL);
              CPidlUtils::Free(pidl);
  
              if(fMove)
              {
                HRESULT hrDelete;
                //If read-only, clear the read-only attribute before trying to delete.
                if(IsReadOnly(fileDescriptor))
                {
                    dmFileAttributes.Attributes &= ~FILE_ATTRIBUTE_READONLY;
                    if(!dmFileAttributes.Attributes) dmFileAttributes.Attributes = FILE_ATTRIBUTE_NORMAL;
                    pSourceConnection->HrSetFileAttributes(szSourceWireName, &dmFileAttributes);
                }
                hrDelete = pSourceConnection->HrDeleteFile(szSourceWireName, IsDirectory(fileDescriptor));
                if(SUCCEEDED(hrDelete))
                {
                    // Send out notification that the source was deleted.
                    pidl = m_pSelection->GetSourcePidl(
                                pXboxFileGroupDescriptor->szFolderPath,
                                fileDescriptor->cFileName
                                );
                    SHChangeNotify(SHCNE_DELETE,SHCNF_FLUSH|SHCNF_IDLIST, pidl, NULL);
                    CPidlUtils::Free(pidl);
                }
              }
            } else
            {
                HandleTransferFailed(IDS_TRANSFER_FAILED, hr, fileDescriptor->cFileName);
            }
        }
        //
        //  Delete the temporary file.
        //
        DeleteFileA(szTempFile);

    } //Loop over all items

    //
    //  The last step is blowing away all the directories on a move.
    //
    if(fMove)
    {
        //
        //  Run the list in the reverse order to delete.
        //
        index=pXboxFileGroupDescriptor->cItems;
        while(index--)
        {
            FILEDESCRIPTORA *fileDescriptor = pXboxFileGroupDescriptor->fgd + index;
            if(IsDirectory(fileDescriptor) &&(fileDescriptor->dwFlags != (UINT)-1))
            {
                CXboxFolder::GetWireName(szSourceWireName, pXboxFileGroupDescriptor->szFolderPath, fileDescriptor->cFileName);
                if(IsReadOnly(fileDescriptor))
                {
                    DM_FILE_ATTRIBUTES dmFileAttributes;
                    dmFileAttributes.Attributes = fileDescriptor->dwFileAttributes;
                    dmFileAttributes.Attributes &= ~FILE_ATTRIBUTE_READONLY;
                    dmFileAttributes.ChangeTime = fileDescriptor->ftLastWriteTime;
                    dmFileAttributes.CreationTime = fileDescriptor->ftCreationTime;
                    dmFileAttributes.SizeHigh = fileDescriptor->nFileSizeHigh;
                    dmFileAttributes.SizeLow = fileDescriptor->nFileSizeLow;
                    pSourceConnection->HrSetFileAttributes(szSourceWireName, &dmFileAttributes);
                }
                hr = pSourceConnection->HrDeleteFile(szSourceWireName, TRUE);
                if(SUCCEEDED(hr))
                {   
                    // Send out notification that the source was deleted.
                    LPITEMIDLIST pidl = m_pSelection->GetSourcePidl(
                                        pXboxFileGroupDescriptor->szFolderPath,
                                        fileDescriptor->cFileName
                                        );
                    SHChangeNotify(SHCNE_RMDIR,SHCNF_FLUSH|SHCNF_IDLIST, pidl, NULL);
                    CPidlUtils::Free(pidl);
                }
            }
        }
    }

    //
    //  Release the source connection, and unlock the HGLOBAL
    //
    pSourceConnection->HrUseSharedConnection(FALSE);
    pSourceConnection->Release();
    GlobalUnlock(m_stgMedium.hGlobal);
    return;
}

void CDropOperation::InitNameMapping(IDataObject *pDataObject, PNAMEMAPPING pNameMapping)
{
    HRESULT hr;
    FORMATETC fetcFileNameMap;
    fetcFileNameMap.cfFormat = CF_FILENAMEMAPA;
    fetcFileNameMap.dwAspect = DVASPECT_CONTENT;
    fetcFileNameMap.lindex   = -1;
    fetcFileNameMap.ptd      = NULL;
    fetcFileNameMap.tymed    = TYMED_HGLOBAL;
    pNameMapping->pszNames   = NULL;
    pNameMapping->pwszNames  = NULL;
    hr = m_pDataObject->GetData(&fetcFileNameMap, &pNameMapping->stgMedium);
    if(SUCCEEDED(hr))
    {
        pNameMapping->pszNames = (LPSTR)GlobalLock(pNameMapping->stgMedium.hGlobal);
        
    } else
    {
        fetcFileNameMap.cfFormat = CF_FILENAMEMAPW;
        hr = m_pDataObject->GetData(&fetcFileNameMap, &pNameMapping->stgMedium);
        if(SUCCEEDED(hr))
        {
            pNameMapping->pwszNames = (LPWSTR)GlobalLock(pNameMapping->stgMedium.hGlobal);
        }
    }
}

bool CDropOperation::GetDestination(PNAMEMAPPING pNameMapping, PHDROPFILE pDropFile)
/*++
  Routine Description:

    Reads the next name mapping and assigns it as a destination.  This is hard to
    do because there are three cases (ANSI name mapping, UNICODE name mapping, and
    none.

    Since the destination is converted to ANSI here, this is also a good place to check
    the legaility of the name on Xbox and possibly alert the user.

--*/
{
    bool fRet = true;
    pDropFile->pszRelativeFileName = NULL;
    //
    //  See if we have an ANSI name mapping
    //
    if(pNameMapping->pszNames)
    {
        UINT uByteCount   = strlen(pNameMapping->pszNames)+1;  //including NULL
        UINT uMBCharCount = _mbstrlen(pNameMapping->pszNames)+1;
        // If this has any multibyte characters we need to 
        // to refuse this.
        if(uByteCount != uMBCharCount)
        {
            UINT uFlags;
            if(m_dwFileCount < 2) 
            {
                uFlags = MB_OK|MB_ICONSTOP;
                StopProgressDialog();  //Kill progress dialog if this was the only file
            }
            else{
                uFlags = MB_OKCANCEL|MB_ICONSTOP;
            }
            if(IDOK!=WindowUtils::MessageBoxResource(m_hParentWnd, IDS_TRANSFER_ILLEGAL_FILENAME, IDS_TRANSFER_FAILED_CAPTION, uFlags, pNameMapping->pszNames))
            {
                m_fCancelled = TRUE;
            }
            fRet = false;
        } else
        {
            pDropFile->pszRelativeFileName = new char[uByteCount];
            if(pDropFile->pszRelativeFileName)
            {
                memcpy(pDropFile->pszRelativeFileName, pNameMapping->pszNames, uByteCount);
                pNameMapping->pszNames += uByteCount;
            } else
            {
                UINT uFlags;
                if(m_dwFileCount < 2) 
                {
                    uFlags = MB_OK|MB_ICONSTOP;
                    StopProgressDialog();  //Kill progress dialog if this was the only file
                }
                else{
                    uFlags = MB_OKCANCEL|MB_ICONSTOP;
                }
                if(IDOK!=WindowUtils::MessageBoxResource(m_hParentWnd, IDS_ERROR_LOW_MEMORY, IDS_TRANSFER_FAILED_CAPTION, uFlags))
                {
                    m_fCancelled = TRUE;
                }
                fRet = false;
            }
        }
    } else if(pNameMapping->pwszNames)
    //
    //  See if we have a UNICODE name mapping
    //
    {
        UINT uCharCount = wcslen(pNameMapping->pwszNames)+1;
        pDropFile->pszRelativeFileName = new char[uCharCount];
        if(pDropFile->pszRelativeFileName)
        {
            if(Utils::CopyWtoA(pDropFile->pszRelativeFileName, pNameMapping->pwszNames))
            {
                UINT uFlags;
                if(m_dwFileCount < 2) 
                {
                    uFlags = MB_OK|MB_ICONSTOP;
                    StopProgressDialog();  //Kill progress dialog if this was the only file
                }
                else{
                    uFlags = MB_OKCANCEL|MB_ICONSTOP;
                }
                
                WCHAR wszCaption[80];
                WCHAR wszError[MAX_PATH+80];
                LoadString(_Module.GetModuleInstance(), IDS_TRANSFER_ILLEGAL_FILENAME_W, wszCaption, ARRAYSIZE(wszCaption));
                wsprintf(wszError, wszCaption, pNameMapping->pwszNames);
                LoadString(_Module.GetModuleInstance(), IDS_TRANSFER_FAILED_CAPTION, wszCaption, ARRAYSIZE(wszCaption));
                MessageBox(m_hParentWnd, wszError, wszCaption, MB_OK);
                if(IDOK!=MessageBox(m_hParentWnd, wszError, wszCaption, uFlags))
                {
                    m_fCancelled = TRUE;
                }
                fRet = false;
                delete [] pDropFile->pszRelativeFileName;
                pDropFile->pszRelativeFileName = NULL;
            }
        } else
        {
            UINT uFlags;
            if(m_dwFileCount < 2) 
            {
                uFlags = MB_OK|MB_ICONSTOP;
                StopProgressDialog();  //Kill progress dialog if this was the only file
            }
            else{
                uFlags = MB_OKCANCEL|MB_ICONSTOP;
            }
            if(IDOK!=WindowUtils::MessageBoxResource(m_hParentWnd, IDS_ERROR_LOW_MEMORY, IDS_TRANSFER_FAILED_CAPTION, uFlags))
            {
                m_fCancelled = TRUE;
            }
            fRet = false;
        }
    } else
    //
    //  There is no mapping, so just take the last path element
    //  and consider that the mapping.
    //
    {
        LPSTR pszRelativeName = strrchr(pDropFile->pszFile, '\\');
        if(pszRelativeName)
        {
            pszRelativeName++;
        } else
        {
            pszRelativeName = pDropFile->pszFile;
        }
        UINT uByteCount   = strlen(pszRelativeName)+1;  //including NULL
        UINT uMBCharCount = _mbstrlen(pszRelativeName)+1;
        if(uByteCount != uMBCharCount)
        {
            UINT uFlags;
            if(m_dwFileCount < 2) 
            {
                uFlags = MB_OK|MB_ICONSTOP;
                StopProgressDialog();  //Kill progress dialog if this was the only file
            }
            else{
                uFlags = MB_OKCANCEL|MB_ICONSTOP;
            }
            if(IDOK!=WindowUtils::MessageBoxResource(m_hParentWnd, IDS_TRANSFER_ILLEGAL_FILENAME, IDS_TRANSFER_FAILED_CAPTION, uFlags, pszRelativeName))
            {
                m_fCancelled = TRUE;
            }
            fRet = false;
        } else
        {
            pDropFile->pszRelativeFileName = new char[uByteCount];
            if(pDropFile->pszRelativeFileName)
            {
                memcpy(pDropFile->pszRelativeFileName, pszRelativeName, uByteCount);
            } else
            {
                UINT uFlags;
                if(m_dwFileCount < 2) 
                {
                    uFlags = MB_OK|MB_ICONSTOP;
                    StopProgressDialog();  //Kill progress dialog if this was the only file
                }
                else{
                    uFlags = MB_OKCANCEL|MB_ICONSTOP;
                }
                if(IDOK!=WindowUtils::MessageBoxResource(m_hParentWnd, IDS_ERROR_LOW_MEMORY, IDS_TRANSFER_FAILED_CAPTION, uFlags))
                {
                    m_fCancelled = TRUE;
                }
                fRet = false;
            }
        }
    }
    return true;
}
void CDropOperation::CleanupNameMapping(PNAMEMAPPING pNameMapping)
{
        
    if(pNameMapping->pwszNames || pNameMapping->pszNames)
    {
        GlobalUnlock(pNameMapping->stgMedium.hGlobal);
        ReleaseStgMedium(&pNameMapping->stgMedium);
    }
}

void CDropOperation::DoHDropTransfer()
{
    
    HRESULT     hr;
    PHDROPFILE  pHDropFiles=NULL;

    _ASSERTE(TYMED_HGLOBAL == m_stgMedium.tymed);
    DROPFILES *pDropFiles;
    pDropFiles = (DROPFILES *)GlobalLock(m_stgMedium.hGlobal);
    bool    fMove = (DROPEFFECT_MOVE == m_dwDesiredEffect);
    bool    fOverWrite; //Keeps track of overwrite in for notification purposes
    
    NAMEMAPPING nameMapping;
    InitNameMapping(m_pDataObject, &nameMapping);
    
    //
    //  Create the list of files to transfer
    //
    if(pDropFiles->fWide)
    {
        PHDROPFILE pHDropFilesTail=NULL;
        LPWSTR pwszNextFile = (LPWSTR)AdvancePtr(pDropFiles,pDropFiles->pFiles);
        while(*pwszNextFile)
        {
            UINT uCharCount = wcslen(pwszNextFile)+1;
            PHDROPFILE pNewDropFile = new HDROPFILE;
            if(pNewDropFile)
            {
                pNewDropFile->pszFile = new char[uCharCount*2];
                if(pNewDropFile->pszFile)
                {
                    if(Utils::CopyWtoA(pNewDropFile->pszFile, pwszNextFile))
                    {
                        WCHAR wszCaption[128];
                        WCHAR wszError[MAX_PATH+128];
                        LoadString(_Module.GetModuleInstance(), IDS_TRANSFER_ILLEGAL_FILENAME_W, wszCaption, ARRAYSIZE(wszCaption));
                        wsprintf(wszError, wszCaption, pwszNextFile);
                        LoadString(_Module.GetModuleInstance(), IDS_TRANSFER_FAILED_CAPTION, wszCaption, ARRAYSIZE(wszCaption));
                        MessageBox(m_hParentWnd, wszError, wszCaption, MB_OK);
                        delete [] pNewDropFile->pszFile;
                        delete pNewDropFile;
                    } else
                    {
                        if(GetDestination(&nameMapping, pNewDropFile))
                        {
                            pNewDropFile->pNext = NULL;
                            if(pHDropFilesTail)  pHDropFilesTail->pNext = pNewDropFile;
                            else                 pHDropFiles = pNewDropFile;
                            pHDropFilesTail = pNewDropFile;
                        }else
                        {
                            delete [] pNewDropFile->pszFile;
                            delete pNewDropFile;
                        }
                    }
                } else
                {
                    delete pNewDropFile;
                }
            }
            // Next string.
            while(*pwszNextFile++);
        }
    } else
    {
        PHDROPFILE pHDropFilesTail=NULL;
        LPSTR pszNextFile = (LPSTR)AdvancePtr(pDropFiles,pDropFiles->pFiles);;
        while(*pszNextFile)
        {
            PHDROPFILE pNewDropFile = new HDROPFILE;
            if(pNewDropFile)
            {
                pNewDropFile->pszFile = pszNextFile;
                if(GetDestination(&nameMapping, pNewDropFile))
                {
                    pNewDropFile->pszRelativeFileName = NULL; //This is fixed up a little later.
                    pNewDropFile->pNext = NULL;
                    if(pHDropFilesTail)  pHDropFilesTail->pNext = pNewDropFile;
                    else                 pHDropFiles = pNewDropFile;
                    pHDropFilesTail = pNewDropFile;
                } else
                {
                        delete pNewDropFile;
                }
            } else
            {
                delete pNewDropFile;
            }
            // Next string.
            while(*pszNextFile++);
        }
    }

    //
    //  We are done with the namemapping
    //
    CleanupNameMapping(&nameMapping);

    //
    //  We now have a linked list of top-level files to copy.
    //  Do a little recursive search on them to get the total number
    //  of a files and the total number of bytes.
    //

    CalculateHDropWork(pHDropFiles);
    
    //
    //  Change message.
    //

    SetProgressTarget();
    char szTargetWireName[MAX_PATH];
    PHDROPFILE pCurrentFile = pHDropFiles;
    for(pCurrentFile = pHDropFiles; pCurrentFile; pCurrentFile = pCurrentFile->pNext)
    {
        //
        //  Query for a cancel
        //
        if(QueryCancel()) break;

        //
        //  Update the progress dialog
        //
        UpdateCopyProgress(pCurrentFile->pszRelativeFileName);

        //Add in fudge bytes for each file or directory
        m_ullBytesCompleted += FILE_PROGRESS_FUDGE_BYTES;

        //
        //  Get the wire name
        //
        m_pSelection->GetTargetWireName(szTargetWireName, pCurrentFile->pszRelativeFileName);
        
        //
        //  Get the attributes of the source file
        //
        WIN32_FILE_ATTRIBUTE_DATA fileAttributes;
        if(GetFileAttributesExA(pCurrentFile->pszFile, GetFileExInfoStandard, &fileAttributes))
        {
            //
            //  Converts the file attributes to DM_FILE_ATTRIBUTES
            //
            DM_FILE_ATTRIBUTES dmFileAttributes;
            dmFileAttributes.Attributes = fileAttributes.dwFileAttributes;
            dmFileAttributes.ChangeTime = fileAttributes.ftLastWriteTime;
            dmFileAttributes.CreationTime = fileAttributes.ftCreationTime;
            dmFileAttributes.SizeHigh = fileAttributes.nFileSizeHigh;
            dmFileAttributes.SizeLow = fileAttributes.nFileSizeLow;
            strcpy(dmFileAttributes.Name, pCurrentFile->pszRelativeFileName);

            // Updates bytes competed, either we will complete them or cancel them
            ULARGE_INTEGER li;
            li.LowPart = fileAttributes.nFileSizeLow;
            li.HighPart = fileAttributes.nFileSizeHigh;
            m_ullBytesCompleted += li.QuadPart;
            if(m_ullBytesCompleted > m_ullBytesTotal) m_ullBytesTotal = m_ullBytesCompleted;

            if(fileAttributes.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                if(fMove && (fileAttributes.dwFileAttributes&FILE_ATTRIBUTE_READONLY))
                {
                    if(!ConfirmFolderMove(pCurrentFile->pszRelativeFileName))
                    {
                        continue;
                    }
                }
                char szFullSource[MAX_PATH];
                strcpy(szFullSource, pCurrentFile->pszFile);
                HDropRecurse(szTargetWireName, szFullSource, &dmFileAttributes, fMove);
            } else
            {
                

                fOverWrite = false;
                if(fMove && (fileAttributes.dwFileAttributes&FILE_ATTRIBUTE_READONLY))
                {
                    if(!ConfirmFileMove(pCurrentFile->pszRelativeFileName))
                    {
                        continue;
                    }
                    
                }
                if(ConfirmFileReplace(szTargetWireName, pCurrentFile->pszRelativeFileName, &fileAttributes, &fOverWrite))
                {
                    hr = m_pTargetConnection->HrSendFile(pCurrentFile->pszFile, szTargetWireName);
                    if(SUCCEEDED(hr))
                    {
                        //
                        // Update 
                        //
                        m_pTargetConnection->HrSetFileAttributes(szTargetWireName, &dmFileAttributes);
                        //
                        //  Notify shell of new file.
                        //
                        LPITEMIDLIST pidl = m_pSelection->GetTargetPidl(pCurrentFile->pszRelativeFileName);
                        if(pidl)
                        {
                            SHChangeNotify(fOverWrite ? SHCNE_ATTRIBUTES : SHCNE_CREATE, SHCNF_FLUSH|SHCNF_IDLIST, pidl, NULL);
                            CPidlUtils::Free(pidl);
                        }
                        if(fMove)
                        {
                            if(fileAttributes.dwFileAttributes&FILE_ATTRIBUTE_READONLY)
                            {
                                SetFileAttributesA(pCurrentFile->pszFile, FILE_ATTRIBUTE_NORMAL);
                            }
                            DeleteFileA(pCurrentFile->pszFile);

                    
                        }
                    } else
                    {
                        HandleTransferFailed(IDS_TRANSFER_FAILED, hr, pCurrentFile->pszRelativeFileName);
                    }
                }
            }
        } else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            HandleTransferFailed(IDS_COULDNT_READ_SOURCE_FILE, hr, pCurrentFile->pszFile);
        }
    }

    //
    //  Now cleanup the linked list of HDROPFILEs
    //
    while(pHDropFiles)
    {
        pCurrentFile = pHDropFiles;
        pHDropFiles = pCurrentFile->pNext;
        if(pDropFiles->fWide)
        {
            delete [] pCurrentFile->pszFile;
        }
        delete [] pCurrentFile->pszRelativeFileName;
        delete pCurrentFile;
    }
}

void CDropOperation::HDropRecurse(LPSTR pszTargetWireName, LPSTR szFullSource, DM_FILE_ATTRIBUTES *pdmFileAttributes, bool fMove)
{
    HRESULT hr;
    UINT uTargetLen = strlen(pszTargetWireName);
    UINT uszFullSourceLen = strlen(szFullSource);
    UINT uszRelativeLen = strlen(pdmFileAttributes->Name);
    bool fOverWrite;

    if(MakeTargetDirectory(pszTargetWireName, pdmFileAttributes))
    {
        szFullSource[uszFullSourceLen] = '\\';
        szFullSource[uszFullSourceLen+1] = '*';
        szFullSource[uszFullSourceLen+2] = '\0';
        WIN32_FIND_DATAA findData;
        HANDLE hFind = FindFirstFileA(szFullSource, &findData);
        while(INVALID_HANDLE_VALUE != hFind)
        {
            if(QueryCancel())
            {
                FindClose(hFind);
                break;
            }
            if(findData.cFileName[0]!='.')
            {
                //Add in fudge bytes for each file or directory
                m_ullBytesCompleted += FILE_PROGRESS_FUDGE_BYTES;

                //
                //  Verify that name is legal
                //
                UINT uCharCount = strlen(findData.cFileName)+1;
                UINT uMbCharCount = _mbstrlen(findData.cFileName)+1;
                if(uCharCount != uMbCharCount)
                {
                    UINT uFlags;
                    if(m_dwFileCount < 2) 
                    {
                        uFlags = MB_OK|MB_ICONSTOP;
                        StopProgressDialog();  //Kill progress dialog if this was the only file
                    }
                    else{
                        uFlags = MB_OKCANCEL|MB_ICONSTOP;
                    }
                    if(IDOK!=WindowUtils::MessageBoxResource(m_hParentWnd, IDS_TRANSFER_ILLEGAL_FILENAME, IDS_TRANSFER_FAILED_CAPTION, uFlags, findData.cFileName))
                    {
                        m_fCancelled = TRUE;
                    }
                } else
                {
                    //
                    //  Tack on name to name of parent directory
                    //
                    LPSTR pszParse; 
                    pszParse = pszTargetWireName + uTargetLen;
                    *pszParse++ = '\\';
                    memcpy(pszParse, findData.cFileName, uCharCount);
                    pszParse = szFullSource + uszFullSourceLen;
                    *pszParse++ = '\\';
                    memcpy(pszParse, findData.cFileName, uCharCount);
                
                    //
                    //  Converts the file attributes to DM_FILE_ATTRIBUTES
                    //
                    DM_FILE_ATTRIBUTES dmFileAttributes;
                    dmFileAttributes.Attributes = findData.dwFileAttributes;
                    dmFileAttributes.ChangeTime = findData.ftLastWriteTime;
                    dmFileAttributes.CreationTime = findData.ftCreationTime;
                    dmFileAttributes.SizeHigh = findData.nFileSizeHigh;
                    dmFileAttributes.SizeLow = findData.nFileSizeLow;
                    memcpy(dmFileAttributes.Name, pdmFileAttributes->Name, uszRelativeLen);
                    pszParse = dmFileAttributes.Name + uszRelativeLen;
                    *pszParse++ = '\\';
                    memcpy(pszParse, findData.cFileName, uCharCount);
                    
                    //
                    //  Update the progress dialog
                    //
                    UpdateCopyProgress(dmFileAttributes.Name);
                    
                    if(findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                    {
                        HDropRecurse(pszTargetWireName, szFullSource, &dmFileAttributes, fMove);
                    }
                    else
                    {
                        // Updates bytes competed, either we will complete them or cancel them
                        ULARGE_INTEGER li;
                        li.LowPart = findData.nFileSizeLow;
                        li.HighPart = findData.nFileSizeHigh;
                        m_ullBytesCompleted += li.QuadPart;
                        if(m_ullBytesCompleted > m_ullBytesTotal) m_ullBytesTotal = m_ullBytesCompleted;

                        if(ConfirmFileReplace(pszTargetWireName, dmFileAttributes.Name, (WIN32_FILE_ATTRIBUTE_DATA *)&findData, &fOverWrite))
                        {
                            
                            hr = m_pTargetConnection->HrSendFile(szFullSource, pszTargetWireName);
                            if(SUCCEEDED(hr))
                            {
                                m_pTargetConnection->HrSetFileAttributes(pszTargetWireName, &dmFileAttributes);
                                //
                                //  Notify shell of new file.
                                //
                                LPITEMIDLIST pidl = m_pSelection->GetTargetPidl(dmFileAttributes.Name);
                                if(pidl)
                                {
                                    SHChangeNotify(fOverWrite ? SHCNE_ATTRIBUTES : SHCNE_CREATE, SHCNF_FLUSH|SHCNF_IDLIST, pidl, NULL);
                                    CPidlUtils::Free(pidl);
                                }
                                if(fMove)
                                {
                                    if(findData.dwFileAttributes&FILE_ATTRIBUTE_READONLY)
                                    {
                                        SetFileAttributesA(szFullSource, FILE_ATTRIBUTE_NORMAL);
                                    }
                                    DeleteFileA(szFullSource);
                                }
                            } else
                            {
                                HandleTransferFailed(IDS_TRANSFER_FAILED, hr, dmFileAttributes.Name);
                            }
                        }
                    }
                }
            }
            //
            //  Setup next loop
            //
            if(!FindNextFileA(hFind, &findData))
            {
                FindClose(hFind);
                hFind = INVALID_HANDLE_VALUE;
            }
        }

        //
        //  Reterminate the paths lopping off anything added here.
        //
        pszTargetWireName[uTargetLen]='\0';
        szFullSource[uszFullSourceLen]='\0';
        if(fMove)
        {
            if(pdmFileAttributes->Attributes&FILE_ATTRIBUTE_READONLY)
            {
                SetFileAttributesA(szFullSource, FILE_ATTRIBUTE_DIRECTORY);
            }
            RemoveDirectoryA(szFullSource);
        }
    }
}


void CDropOperation::CountDirContents(LPSTR pszDir, WIN32_FIND_DATAA *pFindData)
{
    HANDLE hFind;
    hFind = FindFirstFileA(pszDir, pFindData);
    if(INVALID_HANDLE_VALUE != hFind)
    {
        do
        {
            m_dwFileCount++;
            //Add in fudge bytes for each file or directory
            m_ullBytesTotal += FILE_PROGRESS_FUDGE_BYTES;
            if(pFindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                strcpy(pszDir, pFindData->cFileName);
                CountDirContents(pszDir, pFindData);
            } else
            {
                ULARGE_INTEGER li;
                li.LowPart = pFindData->nFileSizeLow;
                li.HighPart = pFindData->nFileSizeHigh;
                m_ullBytesTotal += li.QuadPart;
            }
        }while(FindNextFileA(hFind, pFindData));
        FindClose(hFind);
    }
}

void CDropOperation::CalculateHDropWork(PHDROPFILE pHDropFiles)
{
    WIN32_FILE_ATTRIBUTE_DATA fileAttributes;
    m_dwFileCount = 0;
    m_ullBytesCompleted = 0;
    m_ullBytesTotal = 0;
    PHDROPFILE pCurrentFile;
    ULARGE_INTEGER li;
    for(pCurrentFile = pHDropFiles; pCurrentFile; pCurrentFile = pCurrentFile->pNext)
    {
        if(GetFileAttributesExA(pCurrentFile->pszFile, GetFileExInfoStandard, &fileAttributes))
        {
            m_dwFileCount++;
            //Add in fudge bytes for each file or directory
            m_ullBytesTotal += FILE_PROGRESS_FUDGE_BYTES;
            if(fileAttributes.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                WIN32_FIND_DATAA findData; //scratch buffer for CountDirContents
                char szPath[MAX_PATH] = "";
                PathCombineA(szPath, pCurrentFile->pszFile, "*");
                
                CountDirContents(szPath, &findData);
            } else
            {
                li.LowPart = fileAttributes.nFileSizeLow;
                li.HighPart = fileAttributes.nFileSizeHigh;
                m_ullBytesTotal += li.QuadPart;
            }
        }
    }
}

void CDropOperation::DoFileGroupDescriptorWTransfer()
{
    _ASSERTE(FALSE && "FILEGROUPDESCW not yet implemented");

}

void CDropOperation::DoFileGroupDescriptorATransfer()
{
    _ASSERTE(FALSE && "FILEGROUPDESCA not yet implemented");
}

void CDropOperation::HandleTransferFailed(UINT uResourceId, HRESULT hr, LPCSTR pszFilename)
{
    char szError[512];
    UINT uFlags = MB_ICONERROR;
    if(m_dwFileCount>1)
    {
        uFlags |= MB_OKCANCEL;
    } else
    {
        uFlags |= MB_OK;   
        StopProgressDialog();
    }
    
    //  It has been requested that we special case the disk full error, to include the identity of the
    //  full volume, which is the whole reason that the volume is passed in.
    if(hr==XBDM_DEVICEFULL)
    {
        //Assume that it is the target that is full.  Why would it fail if the source is full?
        char szDriveLetter[MAX_PATH];
        char szConsoleName[60];
        m_pSelection->GetConsoleName(szConsoleName);
        m_pSelection->GetTargetWireName(szDriveLetter, NULL);
        szDriveLetter[1] = '\0';
        WindowUtils::rsprintf(szError, IDS_ERROR_VOLUME_FULL, szDriveLetter, szConsoleName);
    } else
    {
        FormatUtils::XboxErrorString(hr, szError, sizeof(szError));
        if(!FormatMessageA( FORMAT_MESSAGE_FROM_SYSTEM, NULL, GetLastError(), 0, szError, sizeof(szError), NULL))
        {
            LoadStringA(_Module.GetModuleInstance(), IDC_E_UNEXPECTED, szError, sizeof(szError));
        }
    }
    if(IDOK!=WindowUtils::MessageBoxResource(m_hParentWnd, uResourceId, IDS_TRANSFER_FAILED_CAPTION, uFlags, pszFilename, szError))
    {
        m_fCancelled = TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbshlext\menu.h ===
/*++

Copyright (c) Microsoft Corporation


Module Name:

    menu.h

Abstract:
    
    Declars the CXboxContextMenu class

Environment:

    Windows 2000
    Uses ATL

Notes:

Revision History:

    April 2001 - created by Mitchell Dernis (mitchd)
    July  2001 - major overhaul (mitchd)

--*/
#ifndef __XBOXMENU_H__
#define __XBOXMENU_H__

//
//  Funciton Prototype Definition for a Menu Verb
//
class CXboxMenu;
typedef HRESULT (CXboxMenu::*PMENU_VERB)(LPCMINVOKECOMMANDINFO pici);

// CXboxMenu
class ATL_NO_VTABLE CXboxMenu : 
	public CComObjectRootEx<CComMultiThreadModel>,
    public CShellObjectWithSite,
    public IContextMenu
{
  public:
    
    /*
    **  c'tor and d'tor
    */
      CXboxMenu() : m_uItemCount(FALSE), m_pSelection(NULL){}
    ~CXboxMenu(){if(m_pSelection) m_pSelection->Release();}
    static HRESULT Create(UINT cidl, LPCITEMIDLIST * apidl, CXboxFolder *pParent, IContextMenu **ppContextMenu);

    /*
    ** ATL COM INTERFACE MAP
    */

    DECLARE_PROTECT_FINAL_CONSTRUCT()
    BEGIN_COM_MAP(CXboxMenu)
    COM_INTERFACE_ENTRY_IID(IID_IObjectWithSite, IObjectWithSite)
    COM_INTERFACE_ENTRY_IID(IID_IContextMenu, IContextMenu)
    END_COM_MAP()
  
  public:

    /*
    **  IContextMenu methods
    */
    STDMETHOD(GetCommandString)(UINT idCmd, UINT uFlags, UINT *pwReserved, LPSTR pszName, UINT cchMax);
    STDMETHOD(InvokeCommand)(LPCMINVOKECOMMANDINFO pici);
    STDMETHOD(QueryContextMenu)(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags);

    typedef struct _MENU_ITEM_ENTRY
    {
        UINT        uResourceId;       // Resource ID from which to get display string
        LPCSTR      szLangIndepName;   // Language independent name of item
        PMENU_VERB  pmfnVerb;          // Pointer to member function that execture verb 
    }MENU_ITEM_ENTRY, *PMENU_ITEM_ENTRY;

  protected:


    UINT GetCommandIndex(LPCMINVOKECOMMANDINFO pici);

    /*
    **  Implementation of the various supported verbs.
    */
    HRESULT Launch(LPCMINVOKECOMMANDINFO pici);
    HRESULT Open(LPCMINVOKECOMMANDINFO pici);
    HRESULT Explore(LPCMINVOKECOMMANDINFO pici);
    HRESULT RebootWarm(LPCMINVOKECOMMANDINFO pici);
    HRESULT RebootSameTitle(LPCMINVOKECOMMANDINFO pici);
    HRESULT RebootCold(LPCMINVOKECOMMANDINFO pici);
    HRESULT Capture(LPCMINVOKECOMMANDINFO pici);
    HRESULT SetDefault(LPCMINVOKECOMMANDINFO pici);
    HRESULT Security(LPCMINVOKECOMMANDINFO pici);
    HRESULT Cut(LPCMINVOKECOMMANDINFO pici);
    HRESULT Copy(LPCMINVOKECOMMANDINFO pici);
    HRESULT Paste(LPCMINVOKECOMMANDINFO pici);
    HRESULT Delete(LPCMINVOKECOMMANDINFO pici);
    HRESULT Rename(LPCMINVOKECOMMANDINFO pici);
    HRESULT Properties(LPCMINVOKECOMMANDINFO pici);
    HRESULT NewFolder(LPCMINVOKECOMMANDINFO pici);
    HRESULT NewConsole(LPCMINVOKECOMMANDINFO pici);
    HRESULT CutCopy(bool fCut);

    // Also supported, but not in the menu
    HRESULT CreateShortcut(LPCMINVOKECOMMANDINFO pici);
    
    void ExploreOpen(LPCMINVOKECOMMANDINFO pici, BOOL fOpen);
    

    /*
    **  A CXboxFolder selection clone that contains the context.
    */

    DWORD        m_dwVerbs;
    UINT         m_uItemCount;
    CXboxFolder *m_pSelection;

    static MENU_ITEM_ENTRY sm_MenuItems[];
    UINT m_uIdOffset;
    
};

#endif //__XBOXMENU_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbshlext\menu.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    xbicon.cpp

Abstract:

    Implementation of CXboxMenu

Environment:

    Windows 2000 and Later 
    User Mode
    ATL

Notes:

    There are five different menus for which IContextMenu is used:

    1) File Menu (menu bar): with no selection.
    2) File Menu (menu bar) with a selection (one or more items).
    3) Popup Context Menu: with no selection.
    4) Popup Context Menu: with a selection (one or more items).
    5) Short-Cut menu: (popup context on a short-but)

    Unfortunately, we have to do different things in all of these cases,
    and IContextMenu is never explictly told which one it is.  Fortunately,
    a combination of documented and undocumented devices can tell us.  Firstly,
    we are created from IShellFolder::GetUIObjectOf which passes a cidl and apidl
    which are then passed to our create.  If if cidl is 0, there is no select:
    1), 3) or 5) above.  If cidl is > 0, then it is 2) or 4).  1) and 2) always have
    CMF_DVFILE set. 

Revision History:
    
    04-03-2001 : created (mitchd)

--*/

#include "stdafx.h"
static const char *szLangIndepLaunch          = "launch";
static const char *szLangIndepOpen            = "open";
static const char *szLangIndepExplore         = "explore";
static const char *szLangIndepReboot          = "reboot";
static const char *szLangIndepRebootSameTitle = "reboot_same_title";
static const char *szLangIndepRebootCold      = "reboot_cold";
static const char *szLangIndepCapture         = "capture";
static const char *szLangIndepSecurity        = "security";
static const char *szLangIndepSetDefault      = "setdefault";
static const char *szLangIndepCut             = "cut";
static const char *szLangIndepCopy            = "copy";
static const char *szLangIndepPaste           = "paste";
static const char *szLangIndepDelete          = "delete";
static const char *szLangIndepRename          = "rename";
static const char *szLangIndepNewFolder       = "newfolder";
static const char *szLangIndepNewConsole      = "newconsole";
static const char *szLangIndepProps           = "properties";


#define INVALID_MENU_INDEX ((UINT)-1)

CXboxMenu::MENU_ITEM_ENTRY CXboxMenu::sm_MenuItems[] = 
{
    {IDS_CM_LAUNCH,            szLangIndepOpen,            &CXboxMenu::Launch},
    {IDS_CM_OPEN,              szLangIndepOpen,            &CXboxMenu::Open},
    {IDS_CM_EXPLORE,           szLangIndepExplore,         &CXboxMenu::Explore},
    {IDS_CM_REBOOT_WARM,       szLangIndepReboot,          &CXboxMenu::RebootWarm},
    {IDS_CM_REBOOT_SAME_TITLE, szLangIndepRebootSameTitle, &CXboxMenu::RebootSameTitle},
    {IDS_CM_REBOOT_COLD,       szLangIndepRebootCold,      &CXboxMenu::RebootCold},
    {IDS_CM_CAPTURE,           szLangIndepCapture,         &CXboxMenu::Capture},
    {IDS_CM_SECURITY,          szLangIndepSecurity,        &CXboxMenu::Security},
    {IDS_CM_SETDEFAULT,        szLangIndepSetDefault,      &CXboxMenu::SetDefault},
    {IDS_CM_CUT,               szLangIndepCut,             &CXboxMenu::Cut},
    {IDS_CM_COPY,              szLangIndepCopy,            &CXboxMenu::Copy},
    {IDS_CM_PASTE,             szLangIndepPaste,           &CXboxMenu::Paste},
    {IDS_CM_DELETE,            szLangIndepDelete,          &CXboxMenu::Delete},
    {IDS_CM_RENAME,            szLangIndepRename,          &CXboxMenu::Rename},
    {IDS_CM_NEW_FOLDER,        szLangIndepNewFolder,       &CXboxMenu::NewFolder},
    {IDS_CM_NEW_CONSOLE,       szLangIndepNewConsole,      &CXboxMenu::NewConsole},
    {IDS_CM_PROPERTIES,        szLangIndepProps,           &CXboxMenu::Properties}
    
};

//Share Verbs are handled by CDefaultView on the file menu, and on the right click menu in the view.  However, they are not
//handled by CDefaultView on the right click menu for a selection of items in the view.
#define SHARED_VERBS (I2BIT(VERB_OPEN)|I2BIT(VERB_EXPLORE)|I2BIT(VERB_CUT)|I2BIT(VERB_COPY)|I2BIT(VERB_PASTE)\
                      |I2BIT(VERB_DELETE)|I2BIT(VERB_RENAME)|I2BIT(VERB_PROPERTIES))
//SEPARATED_VERBS always have a separator inserted into the menu before them.
#define SEPARATED_VERBS (I2BIT(VERB_REBOOT_WARM)|I2BIT(VERB_CUT)|I2BIT(VERB_DELETE)|I2BIT(VERB_NEWFOLDER)|I2BIT(VERB_NEWCONSOLE)| I2BIT(VERB_PROPERTIES))
// SINGLE_SELECTION_VERBS can only be performed on a single selection: renaming, pasting, launching.
#define SINGLE_SELECTION_VERBS (I2BIT(VERB_PASTE)|I2BIT(VERB_RENAME)|I2BIT(VERB_SETDEFAULT)|I2BIT(VERB_SECURITY)|I2BIT(VERB_LAUNCH))
// Default Verbs - can be a default verb
#define DEFAULT_VERBS (I2BIT(VERB_LAUNCH)|I2BIT(VERB_OPEN))
// SHORTCUT_VERBS - verbs that belong on the context menu of a short-cut
#define SHORTCUT_VERBS (I2BIT(VERB_OPEN)|I2BIT(VERB_EXPLORE)|I2BIT(VERB_CAPTURE)|VERB_REBOOT_BITS|I2BIT(VERB_SECURITY))


#define MENU_ITEM_COUNT   ((sizeof(sm_MenuItems)/sizeof(MENU_ITEM_ENTRY)))

HRESULT CXboxMenu::Create(UINT cidl, LPCITEMIDLIST * apidl, CXboxFolder *pParent, IContextMenu **ppContextMenu)
{
    HRESULT hr;
    CComObject<CXboxMenu> *pNewMenu = new CComObject<CXboxMenu>;
    *ppContextMenu = NULL;
    if(pNewMenu)
    {

        pNewMenu->m_uItemCount = cidl;
        hr = pParent->CloneSelection(cidl, apidl, &pNewMenu->m_pSelection);
        if(SUCCEEDED(hr))
        {
            pNewMenu->m_dwVerbs = pNewMenu->m_pSelection->GetVerbsForSelection();
            hr = pNewMenu->QueryInterface(IID_PPV_ARG(IContextMenu, ppContextMenu));
            _ASSERTE(SUCCEEDED(hr));
        } else
        {
            delete pNewMenu;
        }
    } else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

HRESULT 
CXboxMenu::GetCommandString(
    UINT idCmd,
    UINT uFlags,
    UINT *pwReserved,
    LPSTR pszName,
    UINT cchMax
    )
{
    HRESULT hr = S_OK;
    int iChars = 0;
    
    // Bug 10854
    if(MENU_ITEM_COUNT <= idCmd)
    {
        return E_INVALIDARG;
    }

    switch(uFlags)
    {
        case GCS_HELPTEXTA:
             iChars = LoadStringA(_Module.GetModuleInstance(), HELP_ID_FROM_COMMAND_ID(sm_MenuItems[idCmd].uResourceId), pszName, cchMax);
             if(!iChars) hr = HRESULT_FROM_WIN32(GetLastError());
             break;
        case GCS_HELPTEXTW:
             iChars = LoadStringW(_Module.GetModuleInstance(), HELP_ID_FROM_COMMAND_ID(sm_MenuItems[idCmd].uResourceId), (LPOLESTR)pszName, cchMax);
             if(!iChars) hr = HRESULT_FROM_WIN32(GetLastError());
             break;
        case GCS_VERBA:
             strncpy(pszName, sm_MenuItems[idCmd].szLangIndepName, cchMax);
             break;
        case GCS_VERBW:
             wsprintfW((WCHAR *)pszName, L"%hs", sm_MenuItems[idCmd].szLangIndepName);
             break;
        default:
            _ASSERTE(FALSE);
            hr = E_INVALIDARG;
    };
    
    return hr;
}

HRESULT
CXboxMenu::InvokeCommand(
    LPCMINVOKECOMMANDINFO pici
    )
/*++

--*/
{
    UINT    uCmd;
    
    //
    //  Look up the command index
    //
    uCmd = GetCommandIndex(pici);

    //
    //  If we got a command index
    //  call the verb method.
    //
    if(INVALID_MENU_INDEX != uCmd)
    {
        // This really strange syntax is calling a member of
        // this through a pointer to a member function from 
        // the menu table.
        return (this->*sm_MenuItems[uCmd].pmfnVerb)(pici);
    }

    //
    //  The command was not part of our menu system.  Still it may be some standard
    //  string command that the shell can send.  See if we can handle it.
    if(HIWORD(pici->lpVerb))
    {
        // The shell sends "link" in respone to "create short", we handle it by offering
        // to create a short-cut on the desktop.
        if(0==_stricmp(pici->lpVerb, "link"))
        {
            CreateShortcut(pici);
        }
    }

    //MessageBoxA(pici->hwnd, "Some verb from the CDefView not in our menu", "NYI", MB_OK);
  
    //
    //  Pretend we did something
    //
    return S_FALSE;
}

class CSetDefault : public IXboxVisitor
{
  public:
    CSetDefault() : m_fSet(FALSE), m_fIsDefault(FALSE){}
    virtual void VisitRoot         (IXboxVisit *pRoot,                DWORD *pdwFlags){_ASSERT(FALSE);}
    virtual void VisitAddConsole   (IXboxVisit *pAddConsole,          DWORD *pdwFlags){_ASSERT(FALSE);}
    virtual void VisitConsole      (IXboxConsoleVisit   *pConsole,    DWORD *pdwFlags);
    virtual void VisitVolume       (IXboxVolumeVisit    *pVolume,     DWORD *pdwFlags){_ASSERT(FALSE);}
    virtual void VisitFileOrDir    (IXboxFileOrDirVisit *pFileOrDir,  DWORD *pdwFlags){_ASSERT(FALSE);}
    virtual void VisitDirectoryPost(IXboxFileOrDirVisit *pFileOrDir,  DWORD *pdwFlags){_ASSERT(FALSE);}
    inline void SetDefault(CXboxFolder *pSelection);
    inline BOOL IsDefault(CXboxFolder *pSelection);
  private:
    BOOL m_fSet;
    BOOL m_fIsDefault;
};


HRESULT
CXboxMenu::QueryContextMenu(
    HMENU hmenu,
    UINT indexMenu,
    UINT idCmdFirst,
    UINT idCmdLast,
    UINT uFlags
    )
/*++
    Arguments:
        hmenu      - destination menu
        indexMenu  - location at which menu items should be inserted
        idCmdFirst - first available menu identifier
        idCmdLast  - first unavailable menu identifier    
   
    Return Value:
    
--*/

{
    UINT   uIndex;
    DWORD  dwItemMask; 
    UINT   uMenuId;
    UINT   uDefaultItem;
    char   szMenuItemName[80];
    char   szNewMenuName[80];
    char   szRebootMenuName[80];
    int    iMenuItemCount;
    
    m_uIdOffset = idCmdFirst;

    DWORD dwVerbs = m_dwVerbs;

    /*
    char szDebugMessage[512];
    sprintf(szDebugMessage, "uFlags = 0x%0.8x, m_uItemCount = 0x%0.8x, m_dwVerbs = 0x%0.8x", uFlags, m_uItemCount, m_dwVerbs);
    MessageBoxA(NULL, szDebugMessage, "QueryContextMenu", MB_OK);
    */
    
    //
    //  if CMF_CANRENAME is not set disable it.
    //

    if(!(uFlags&CMF_CANRENAME))
        dwVerbs &= ~I2BIT(VERB_RENAME);

    //
    //  If the default view is calling us to populate the
    //  file menu, don't add the shared items.
    //
    if((m_uItemCount == 0)||(uFlags&CMF_DVFILE))
    {
        dwVerbs &= ~SHARED_VERBS;
    } 
    
    if(m_uItemCount)
    // Do not insert the new folder item on a selection.
    {
        dwVerbs &= ~I2BIT(VERB_NEWFOLDER);
    }
    
    //If CMF_VERBSONLY this is a short-cut menu, so severly restrict, what is allowed on it.
    if(uFlags&CMF_VERBSONLY)
        dwVerbs &= SHORTCUT_VERBS;

    //
    //  If this is a multiple selection, remove the verbs that only apply to a single item.
    //
    if(m_uItemCount > 1)
    {
        dwVerbs &= ~SINGLE_SELECTION_VERBS;
    }

    //If it is  and the console is already the default, skip this verb
    if(dwVerbs&I2BIT(VERB_SETDEFAULT))
    {
        CSetDefault setDefault;
        if(setDefault.IsDefault(m_pSelection))
        {
            dwVerbs &= ~I2BIT(VERB_SETDEFAULT);
        }
    }

    //
    //  There seems to be some anomoly with sub-menus, currently new and reboot.
    //  These don't get removed automatically, so we need to clean them up ourselves.
    //  We were adding them only if they were not already present.  However, that doesn't
    //  work as nicely as I would like, so we will just always remove them, and readd
    //  them.  I doubt the performance hit will be too bad.
    //


    // Load the name of the "new" and "reboot" submenus.
    LoadStringA(_Module.GetModuleInstance(), IDS_CM_NEW, szNewMenuName, 80);        
    LoadStringA(_Module.GetModuleInstance(), IDS_CM_REBOOT, szRebootMenuName, 80);
    
    //  Search

    //  Search the menu to see if has a "New" or "Reboot" drop down.
    iMenuItemCount = GetMenuItemCount(hmenu);
    for(int iPos = 0; iPos < iMenuItemCount; iPos++)
    {
        char szExistingMenuName[80];
        GetMenuStringA(hmenu, iPos, szExistingMenuName, 80, MF_BYPOSITION);
        //See if it is the new menu
        if( (0==strcmp(szNewMenuName, szExistingMenuName)) || 
            (0==strcmp(szRebootMenuName, szExistingMenuName)) ||
            (0==strcmp("&View", szExistingMenuName))//BUG 10101 - The shell faults while handling this,
                                                    //since this problem seems internal to the shell, and I don't
                                                    //have time our resources to track down exactly why, and likely
                                                    //won't be able to fix it without serious hacking, we will just nuke it
                                                    //from our menu.  It wasn't there on Win2K, so big deal!
        )
        {
            DeleteMenu(hmenu, iPos, MF_BYPOSITION); 
        }
    }

    //
    //  Loop through all the items and insert those which have corresponding
    //  bit set in ulVerbs.
    //
    uDefaultItem = INVALID_MENU_INDEX;
    for(uIndex = 0, dwItemMask = 1; uIndex < MENU_ITEM_COUNT; uIndex++, dwItemMask <<= 1)
    {
        // If the item mask is not in our bitmap of verbs,
        // just skip it.
        if(!(dwItemMask&dwVerbs)) continue;

        //
        //  Get the string for the item
        //
        LoadStringA(_Module.GetModuleInstance(), sm_MenuItems[uIndex].uResourceId, szMenuItemName, 80);
        
        // If this is a SEPARATED_VERB, add the separator
        if(SEPARATED_VERBS&dwItemMask)
        {
            InsertMenuA(hmenu, indexMenu, MF_SEPARATOR|MF_BYPOSITION, 0, NULL);
            if(indexMenu != 0xFFFFFFFF) indexMenu++;
        }
        uMenuId = m_uIdOffset+uIndex;
            
        //  If paste, decide whether not to Gray it out.
        UINT uMenuFlags = MF_STRING|MF_BYPOSITION;
        if(VERB_PASTE == uIndex)
        {
            IDataObject *pDataObject;
            HRESULT hr = OleGetClipboard(&pDataObject);
            uMenuFlags |= MF_GRAYED;
            if(SUCCEEDED(hr))
            {
                if(CDropOperation::GetDropFormat(pDataObject))
                {
                    uMenuFlags &= ~MF_GRAYED;
                }
                pDataObject->Release();
            }
        }

        //  If this is the new folder item, then we special case the insertion
        if( (VERB_NEWFOLDER == uIndex) || (VERB_NEWCONSOLE == uIndex) )
        {
            HMENU hNewMenu = CreateMenu();
            InsertMenuA(hNewMenu, -1, MF_STRING|MF_BYPOSITION, uMenuId, szMenuItemName);
            InsertMenuA(hmenu, indexMenu, MF_POPUP|MF_BYPOSITION, (UINT_PTR)hNewMenu, szNewMenuName);
            if(indexMenu != 0xFFFFFFFF) indexMenu++;
        } else if (VERB_REBOOT_WARM == uIndex)
        {
            HMENU hRebootMenu = CreateMenu();
            InsertMenuA(hRebootMenu, -1, MF_STRING|MF_BYPOSITION, uMenuId, szMenuItemName);
            LoadStringA(_Module.GetModuleInstance(), sm_MenuItems[++uIndex].uResourceId, szMenuItemName, 80);
            InsertMenuA(hRebootMenu, -1, MF_STRING|MF_BYPOSITION, ++uMenuId, szMenuItemName);
            LoadStringA(_Module.GetModuleInstance(), sm_MenuItems[++uIndex].uResourceId, szMenuItemName, 80);
            InsertMenuA(hRebootMenu, -1, MF_STRING|MF_BYPOSITION, ++uMenuId, szMenuItemName);
            dwItemMask <<= 2;
            InsertMenuA(hmenu, indexMenu, MF_POPUP|MF_BYPOSITION, (UINT_PTR)hRebootMenu, szRebootMenuName);
            if(indexMenu != 0xFFFFFFFF) indexMenu++;
        } else //  Not the reboot menu or the new folder menu, so just use the standard code.
        {   
            if(dwItemMask&DEFAULT_VERBS)
                        uDefaultItem = uMenuId;
            // Insert the menu item
            InsertMenuA(hmenu, indexMenu, uMenuFlags, uMenuId, szMenuItemName);
            if(indexMenu != 0xFFFFFFFF) indexMenu++;
        }
    }

    // The first item that we inserted is always the default.
    if(INVALID_MENU_INDEX != uDefaultItem)
        SetMenuDefaultItem(hmenu, uDefaultItem, FALSE);
    return MAKE_HRESULT(SEVERITY_SUCCESS, 0, uIndex+m_uIdOffset); 
}

UINT 
CXboxMenu::GetCommandIndex(
    LPCMINVOKECOMMANDINFO pici
    )
{
    //
    //  If the HIWORD is set it is a pointer
    //  to a command string.
    //
    if(HIWORD(pici->lpVerb))
    {
        // This is a pointer to a string, so do a case insenstive comparison against our table.
        for(UINT uId = 0; uId < MENU_ITEM_COUNT; uId++)
        {
            if( 0 == _stricmp(sm_MenuItems[uId].szLangIndepName, pici->lpVerb))
            {
                return uId;
            }
        }
    } else
    //
    //  Otherwise, it is just a command id from our menu, but subtract
    //  the offset we added, when building the menu
    //
    {
        
        UINT uId = LOWORD(pici->lpVerb);
        // Only return uId if it is in range for our ID table.
        if(MENU_ITEM_COUNT > uId)
                        return uId;
    }
    return INVALID_MENU_INDEX;
}

HRESULT CXboxMenu::Cut(LPCMINVOKECOMMANDINFO pici)
{
    HRESULT hr = CutCopy(true);
    return hr;
}

HRESULT CXboxMenu::Copy(LPCMINVOKECOMMANDINFO pici)
{
    HRESULT hr = CutCopy(false);
    return hr;
}


HRESULT CXboxMenu::CutCopy(bool fCut)
{
 
    // Get a DataObject
    IDataObject *pDataObject;
    HRESULT hr;
    hr = CXboxDataObject::Create(m_uItemCount, m_pSelection, &pDataObject);
    if(SUCCEEDED(hr))
    {
        IShellFolderView *pShellFolderView = NULL;

        //
        //  Mark this a copy.
        //
        DataObjUtil::SetPreferredDropEffect(pDataObject, fCut ? DROPEFFECT_MOVE : DROPEFFECT_COPY);
        
        //
        //  Get a shell folder view and set the points, for the cut.
        //
        if(SUCCEEDED(GetSite(IID_PPV_ARG(IShellFolderView, &pShellFolderView))))
          pShellFolderView->SetPoints(pDataObject);
        else
          pShellFolderView = NULL;

        //
        //  Put this up on the clipboard
        //  
        hr = OleSetClipboard(pDataObject);

        //
        //  Set the clipboard and release the pShellFolderView
        //
        if(pShellFolderView)
        {
            pShellFolderView->SetClipboard(fCut);
            pShellFolderView->Release();
        }

        //
        //  The clipboard will have referenced this, and if it hasn't
        //  we will be returning an error.  Either, we are not keeping
        //  a copy of the pointer, so release it.
        //
        pDataObject->Release();
    }
    return hr;
}

HRESULT CXboxMenu::Paste(LPCMINVOKECOMMANDINFO pici)
{
    HRESULT hr; 
    IDataObject *pDataObject;

    hr = OleGetClipboard(&pDataObject);
    if(FAILED(hr) || ! CDropOperation::GetDropFormat(pDataObject))
    {
        WindowUtils::MessageBoxResource(pici->hwnd, IDS_NOTHING_TO_PASTE, IDS_ERROR_PASTE_CAPTION, MB_OK|MB_ICONERROR);
        return E_FAIL;
    }

    //
    //  Get the preferred drop effect
    //
    DWORD dwEffect;
    hr = DataObjUtil::GetPreferredDropEffect(pDataObject, &dwEffect);
    if(FAILED(hr))
    {
        dwEffect = DROPEFFECT_COPY;
    }

    CDropOperation *pDropOperation = new CDropOperation(m_pSelection, pDataObject, dwEffect, pici->hwnd);
    if(pDropOperation)
    {
        pDropOperation->StartTransfer();
    } else
    {
        WindowUtils::MessageBoxResource(pici->hwnd, IDS_ERROR_LOW_MEMORY, IDS_ERROR_PASTE_CAPTION, MB_OK|MB_ICONERROR);
    }
    pDataObject->Release();
    return S_OK;
}

HRESULT CXboxMenu::Delete(LPCMINVOKECOMMANDINFO pici)
/*++
  Routine Description:
    Called to delete items.
--*/
{
    CWaitCursor waitCursor;

    if(0==m_uItemCount) return E_FAIL;

    CXboxDelete deleteItems(pici->hwnd, m_uItemCount, (pici->fMask&CMIC_MASK_FLAG_NO_UI) ? true : false);
    m_pSelection->VisitEach(&deleteItems, IXboxVisitor::FlagContinue|IXboxVisitor::FlagRecurse);

    return S_OK;
}

HRESULT CXboxMenu::Rename(LPCMINVOKECOMMANDINFO pici)
{
    return S_OK;
}

HRESULT CXboxMenu::Properties(LPCMINVOKECOMMANDINFO pici)
{
    HRESULT hr;
    CWaitCursor waitCursor;
    
    CXboxPropertySheet *pPropSheet = new CXboxPropertySheet;
    hr = pPropSheet->Initialize(m_uItemCount, m_pSelection);
    if(SUCCEEDED(hr))
    {
        //
        //  pPropSheet deletes itself when the property sheet closes.
        //
        pPropSheet->DoProperties(0, NULL);
    } else
    {
        delete pPropSheet;
    }

    return S_OK;
}

HRESULT CXboxMenu::Security(LPCMINVOKECOMMANDINFO pici)
{
    HRESULT hr;
    CWaitCursor waitCursor;
    
    CXboxPropertySheet *pPropSheet = new CXboxPropertySheet;
    hr = pPropSheet->Initialize(m_uItemCount, m_pSelection);
    if(SUCCEEDED(hr))
    {
        //
        //  pPropSheet deletes itself when the property sheet closes.
        //
        pPropSheet->DoProperties(1, NULL);
    } else
    {
        delete pPropSheet;
    }

    return hr;
}

HRESULT CXboxMenu::NewFolder(LPCMINVOKECOMMANDINFO pici)
/*++
  Routine Description:
    Creates a new folder in the given folder.  Basically,
    using the selection as the "drop target."


--*/
{
    char szTargetWireName[MAX_PATH];
    char szNewFolder[40];
    IXboxConnection *pConnection = m_pSelection->GetXboxConnection();
    HRESULT hr;

    //
    //  Create a new folder.
    //
    UINT uFolderNum = 1;
    LoadStringA(_Module.GetModuleInstance(), IDS_NEW_FOLDER, szNewFolder, sizeof(szNewFolder));
    do
    {
        m_pSelection->GetTargetWireName(szTargetWireName, szNewFolder);
        hr = pConnection->HrMkdir(szTargetWireName);
        if(XBDM_ALREADYEXISTS == hr)
        {
            WindowUtils::rsprintf(szNewFolder, IDS_NEW_FOLDER_TEMPLATE, ++uFolderNum);
        }
    } while(XBDM_ALREADYEXISTS == hr);
    if(FAILED(hr))
    {
        char szError[60];
        FormatUtils::XboxErrorString(hr, szError, sizeof(szError));
        WindowUtils::MessageBoxResource(pici->hwnd, IDS_ERROR_CREATE_FOLDER, IDS_ERROR_CREATE_FOLDER_CAPTION, MB_OK|MB_ICONSTOP, szError);
        return hr;
    }

    //
    //  Make a pidl
    //
    LPITEMIDLIST pidl = m_pSelection->GetTargetPidl(szNewFolder);
    if(!pidl)
    {
        return E_OUTOFMEMORY;
    }

    //
    //  Send out notifications.
    //
    SHChangeNotify(SHCNE_MKDIR, SHCNF_FLUSH|SHCNF_IDLIST, pidl, NULL);
    
    LPITEMIDLIST pidlSimple = CPidlUtils::LastItem(pidl);


    //
    //  Position and select the folder for edit
    //
    
    IShellView2         *pShellView2;
    IShellFolderView    *pShellFolderView;
    hr = GetSite(IID_PPV_ARG(IShellFolderView, &pShellFolderView));
    if(SUCCEEDED(hr))
    {
        POINT pt;
        hr = pShellFolderView->GetDropPoint(&pt);
        if(SUCCEEDED(hr))
        {
            hr = GetSite(IID_PPV_ARG(IShellView2, &pShellView2));
            if(SUCCEEDED(hr))
            {
                hr = pShellView2->SelectAndPositionItem(pidlSimple,SVSI_SELECT|SVSI_EDIT|SVSI_DESELECTOTHERS|SVSI_ENSUREVISIBLE,&pt);
                pShellView2->Release();
            }
        }
        pShellFolderView->Release();
    }

    CPidlUtils::Free(pidl);
    return hr;
}

HRESULT CXboxMenu::NewConsole(LPCMINVOKECOMMANDINFO pici)
/*++
  Routine Description:
    Launch the Add Console Wizard
--*/
{
    CWaitCursor waitCursor;
    ExecuteAddConsoleWizard();
    return S_OK;
}


class CExplore : public IXboxVisitor
{
  public:
    CExplore(LPCMINVOKECOMMANDINFO pici, IShellBrowser *pShellBrowser, BOOL fOpen=TRUE) :
        m_pici(pici), m_pShellBrowser(pShellBrowser), m_fOpen(fOpen), m_fFirstOne(TRUE){}
    virtual void VisitRoot         (IXboxVisit *pRoot,                DWORD *pdwFlags);
    virtual void VisitAddConsole   (IXboxVisit *pAddConsole,          DWORD *pdwFlags);
    virtual void VisitConsole      (IXboxConsoleVisit   *pConsole,    DWORD *pdwFlags);   
    virtual void VisitVolume       (IXboxVolumeVisit    *pVolume,     DWORD *pdwFlags);
    virtual void VisitFileOrDir    (IXboxFileOrDirVisit *pFileOrDir,  DWORD *pdwFlags);
    virtual void VisitDirectoryPost(IXboxFileOrDirVisit *pFileOrDir,  DWORD *pdwFlags){}
  protected:
    void Explore(IXboxVisit *pItem);
  private:
    BOOL m_fOpen;
    BOOL m_fFirstOne;
    LPCMINVOKECOMMANDINFO m_pici;
    IShellBrowser *m_pShellBrowser;
};

void CExplore::VisitRoot(IXboxVisit *pRoot, DWORD *pdwFlags)
{
    _ASSERTE(FALSE);
}
void CExplore::VisitAddConsole(IXboxVisit *pAddConsole, DWORD *pdwFlags)
{
    ExecuteAddConsoleWizard();
}
void CExplore::VisitConsole(IXboxConsoleVisit *pConsole, DWORD *pdwFlags)
{
    Explore(pConsole);
}
void CExplore::VisitVolume(IXboxVolumeVisit *pVolume, DWORD *pdwFlags)
{
    Explore(pVolume);
}
void CExplore::VisitFileOrDir(IXboxFileOrDirVisit *pFileOrDir, DWORD *pdwFlags)
{
    Explore(pFileOrDir);
}

#define SEE_MASK_SHARED (SEE_MASK_FLAG_NO_UI | SEE_MASK_HOTKEY | SEE_MASK_NO_CONSOLE)
void CExplore::Explore(IXboxVisit *pItem)
{ 
    LPITEMIDLIST pidl = NULL;
    UINT uFlags;
    if(m_fOpen)
    {   
        uFlags = m_fFirstOne ? (SBSP_DEFBROWSER|SBSP_OPENMODE|SBSP_RELATIVE) : (SBSP_NEWBROWSER|SBSP_OPENMODE|SBSP_RELATIVE);
    } else
    {
        uFlags = SBSP_NEWBROWSER|SBSP_EXPLOREMODE|SBSP_RELATIVE;
    }

    // Make sure box is live.
    char szConsoleName[80];
    pItem->GetConsoleName(szConsoleName);
    if(!Utils::VerifyXboxAlive(szConsoleName))
    {
        char szError[60];
        char szName[MAX_PATH];
        pItem->GetName(szName);
        FormatUtils::XboxErrorString(XBDM_CANNOTCONNECT, szError, sizeof(szError));
        WindowUtils::MessageBoxResource(m_pici->hwnd, IDS_ERROR_OPENNING_FOLDER, IDS_ERROR_OPENNING_FOLDER_CAPTION, MB_OK|MB_ICONSTOP, szName, szError);
        return;
    }
    
    if(pItem->GetShellAttributes()&SFGAO_FOLDER)
    {
        if(m_pShellBrowser)
        {
            pidl = pItem->GetPidl(CPidlUtils::PidlTypeSimple);
            if(pidl)
            {
                HRESULT hr = m_pShellBrowser->BrowseObject(pidl, uFlags);
                if(FAILED(hr))
                {
                    char szError[60];
                    char szName[MAX_PATH];
                    pItem->GetName(szName);
                    if(HRESULT_FACILITY(hr)==FACILITY_XBDM)
                    {
                        FormatUtils::XboxErrorString(hr, szError, sizeof(szError));
                    } else
                    {       
                        FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM, NULL, hr, 0, szError, sizeof(szError), NULL);
                    }
                    WindowUtils::MessageBoxResource(m_pici->hwnd, IDS_ERROR_OPENNING_FOLDER, IDS_ERROR_OPENNING_FOLDER_CAPTION, MB_OK|MB_ICONSTOP, szName, szError);
                }
                CPidlUtils::Free(pidl);
            }
        } else
        {
            pidl = pItem->GetPidl(CPidlUtils::PidlTypeAbsolute);
            if(pidl)
            {
                SHELLEXECUTEINFOA sei;
                ZeroMemory(&sei, sizeof(SHELLEXECUTEINFOA));
                sei.cbSize = sizeof(SHELLEXECUTEINFOA);
                sei.hwnd = m_fOpen ? m_pici->hwnd : NULL;
                sei.fMask = SEE_MASK_IDLIST | (m_pici->fMask & SEE_MASK_SHARED);
                sei.nShow = m_pici->nShow;
                sei.dwHotKey = m_pici->dwHotKey;
                sei.hIcon = m_pici->hIcon;
                sei.lpParameters = m_pici->lpParameters;
                sei.lpDirectory = m_pici->lpDirectory;
                sei.lpVerb = m_fOpen ? "open" : "explore";
                sei.lpIDList = pItem->GetPidl(CPidlUtils::PidlTypeAbsolute);
                ShellExecuteExA(&sei);
                CPidlUtils::Free(pidl);
            }
        }
    }
    m_fFirstOne = FALSE;
}

HRESULT CXboxMenu::Explore(LPCMINVOKECOMMANDINFO pici)
{
    CWaitCursor waitCursor;
    ExploreOpen(pici, FALSE);
    return S_OK;
}

HRESULT CXboxMenu::Open(LPCMINVOKECOMMANDINFO pici)
{
    CWaitCursor waitCursor;
    ExploreOpen(pici, TRUE);
    return S_OK;
}

void CXboxMenu::ExploreOpen(LPCMINVOKECOMMANDINFO pici, BOOL fOpen)
{
    IShellBrowser *pShellBrowser = NULL;
    if(m_uItemCount)
    {
        if(m_pUnknownSite)
        {
            HRESULT hr = GetService(SID_SShellBrowser, IID_PPV_ARG(IShellBrowser, &pShellBrowser));
            if(FAILED(hr))
            {
                pShellBrowser = NULL;
            }
        }
        CExplore explore(pici, pShellBrowser, fOpen);
        m_pSelection->VisitEach(&explore, IXboxVisitor::FlagContinue);
        
    } else
    {
        _ASSERTE(FALSE);
    }
}

class CRebootLaunch : public IXboxVisitor
{
  public:
    CRebootLaunch(BOOL fCold = FALSE, BOOL fSameTitle = FALSE) : m_fCold(fCold), m_fSameTitle(fSameTitle){}
    virtual void VisitRoot         (IXboxVisit *pRoot,                DWORD *pdwFlags){_ASSERT(FALSE);}
    virtual void VisitAddConsole   (IXboxVisit *pAddConsole,          DWORD *pdwFlags){_ASSERT(FALSE);}
    virtual void VisitConsole      (IXboxConsoleVisit   *pConsole,    DWORD *pdwFlags);
    virtual void VisitVolume       (IXboxVolumeVisit    *pVolume,     DWORD *pdwFlags){_ASSERT(FALSE);}
    virtual void VisitFileOrDir    (IXboxFileOrDirVisit *pFileOrDir,  DWORD *pdwFlags);
    virtual void VisitDirectoryPost(IXboxFileOrDirVisit *pFileOrDir,  DWORD *pdwFlags){_ASSERT(FALSE);}
  protected:
    void Reboot(IXboxVisit *pVisit, LPCSTR pszWireName);
    BOOL m_fCold;
    BOOL m_fSameTitle;
};

void CRebootLaunch::VisitConsole(IXboxConsoleVisit *pConsole, DWORD *pdwFlags)
{
    Reboot(pConsole, NULL);
}
void CRebootLaunch::VisitFileOrDir(IXboxFileOrDirVisit *pFileOrDir,  DWORD *pdwFlags)
{
    char szWireName[MAX_PATH];
    pFileOrDir->GetWireName(szWireName);
    if(CXboxFolder::IsXbeFile(szWireName))
    {
        Reboot(pFileOrDir, szWireName);
    }
}

void CRebootLaunch::Reboot(IXboxVisit *pVisit, LPCSTR pszWireName)
{
    char szConsoleName[60];
    DM_XBE dmXbe;
    pVisit->GetConsoleName(szConsoleName);
    IXboxConnection *pConnection;
    if(SUCCEEDED(Utils::GetXboxConnection(szConsoleName, &pConnection)))
    {
        if(!pszWireName && m_fSameTitle)
        {
            if(SUCCEEDED(pConnection->HrGetXbeInfo(NULL, &dmXbe)))
            {
                pszWireName = dmXbe.LaunchPath;
            }
        }
        pConnection->HrReboot(m_fCold ? 0 : DMBOOT_WARM, pszWireName);
        pConnection->Release();
    }
}

HRESULT CXboxMenu::RebootWarm(LPCMINVOKECOMMANDINFO pici)
{
    CWaitCursor waitCursor;
    CRebootLaunch rebootLaunch(FALSE, FALSE);
    m_pSelection->VisitEach(&rebootLaunch, IXboxVisitor::FlagContinue);
    return S_OK;
}

HRESULT CXboxMenu::RebootSameTitle(LPCMINVOKECOMMANDINFO pici)
{
    CWaitCursor waitCursor;
    CRebootLaunch rebootLaunch(FALSE, TRUE);
    m_pSelection->VisitEach(&rebootLaunch, IXboxVisitor::FlagContinue);
    return S_OK;
}

HRESULT CXboxMenu::RebootCold(LPCMINVOKECOMMANDINFO pici)
{
    CWaitCursor waitCursor;
    CRebootLaunch rebootLaunch(TRUE, FALSE);
    m_pSelection->VisitEach(&rebootLaunch, IXboxVisitor::FlagContinue);
    return S_OK;
}

HRESULT CXboxMenu::Launch(LPCMINVOKECOMMANDINFO pici)
{
    CWaitCursor waitCursor;
    CRebootLaunch rebootLaunch;
    m_pSelection->VisitEach(&rebootLaunch, IXboxVisitor::FlagContinue);
    return S_OK;
}

class CCreateDesktopShortcuts : public IXboxVisitor
{
    public:
       CCreateDesktopShortcuts();
        virtual void VisitRoot         (IXboxVisit *pRoot,                DWORD *pdwFlags){Visit(pRoot, pdwFlags);}
        virtual void VisitAddConsole   (IXboxVisit *pAddConsole,          DWORD *pdwFlags){Visit(pAddConsole, pdwFlags);}
        virtual void VisitConsole      (IXboxConsoleVisit   *pConsole,    DWORD *pdwFlags){Visit(pConsole, pdwFlags);}
        virtual void VisitVolume       (IXboxVolumeVisit    *pVolume,     DWORD *pdwFlags){Visit(pVolume, pdwFlags);}
        virtual void VisitFileOrDir    (IXboxFileOrDirVisit *pFileOrDir,  DWORD *pdwFlags){Visit(pFileOrDir, pdwFlags);}
        virtual void VisitDirectoryPost(IXboxFileOrDirVisit *pFileOrDir,  DWORD *pdwFlags){_ASSERT(FALSE);}
    private:
        void Visit(IXboxVisit *pItem, DWORD *pdwFlags);
        char m_szDesktopPath[MAX_PATH];
};

CCreateDesktopShortcuts::CCreateDesktopShortcuts()
{
    if(FAILED(SHGetFolderPathA(NULL, CSIDL_DESKTOPDIRECTORY, NULL, SHGFP_TYPE_CURRENT, m_szDesktopPath)))
    {
        *m_szDesktopPath = '\0';
    }
}

    
void CCreateDesktopShortcuts::Visit(IXboxVisit *pItem, DWORD *pdwFlags)
{
    HRESULT hr;
    ULONG ulAttributes = pItem->GetShellAttributes();
    if(!(SFGAO_FOLDER&ulAttributes))
    {
        return;
    }

    IShellLinkA *pShellLink;
    IPersistFile *pPersistFile;

    // Create an IShellLink object and get a pointer to the IShellLink
	// interface (returned from CoCreateInstance).
    hr = CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellLinkA, &pShellLink));
    if(SUCCEEDED(hr))
    {
       hr = pShellLink->QueryInterface(IID_PPV_ARG(IPersistFile, &pPersistFile));
	   if (SUCCEEDED(hr))
	   {
           LPITEMIDLIST pidl = pItem->GetPidl(CPidlUtils::PidlTypeAbsolute);
           if(pidl)
           {
                hr = pShellLink->SetIDList(pidl);
                CPidlUtils::Free(pidl);
                if(SUCCEEDED(hr))
                {
                    char szConsoleName[80];
                    char szItemName[MAX_PATH];
                    char szShortCutName[MAX_PATH];
                    pItem->GetConsoleName(szConsoleName);
                    pItem->GetName(szItemName);
                    WindowUtils::rsprintf(szShortCutName, IDS_NORMAL_NAME_FORMAT, szItemName, szConsoleName);
                    // Set the description of the shortcut.
                  	hr = pShellLink->SetDescription(szShortCutName);

                    if(SUCCEEDED(hr))
                    {   
                        WCHAR szPathName[MAX_PATH];
                        wsprintf(szPathName, L"%hs\\%hs.lnk", m_szDesktopPath, szShortCutName);
                        hr = pPersistFile->Save(szPathName, TRUE);
                    }
                }
           }
           pPersistFile->Release();
       }
       pShellLink->Release();
    }
}


HRESULT CXboxMenu::CreateShortcut(LPCMINVOKECOMMANDINFO pici)
{
    //Prompt user
    if(IDYES==WindowUtils::MessageBoxResource(pici->hwnd, IDS_CONFIRM_DESKTOP_SHORTCUT, IDS_CONFIRM_DESKTOP_SHORTCUT_CAPTION, MB_YESNO|MB_ICONQUESTION))
    {
        CCreateDesktopShortcuts createDesktopShortCuts;
        m_pSelection->VisitEach(&createDesktopShortCuts, IXboxVisitor::FlagContinue); 
    }
    return S_OK;
}


class CScreenCapture : public IXboxVisitor
{
  public:
    CScreenCapture(HWND hWnd):m_hWnd(hWnd){if(!m_hWnd) m_hWnd = GetDesktopWindow();}
    virtual void VisitRoot         (IXboxVisit *pRoot,                DWORD *pdwFlags){_ASSERT(FALSE);}
    virtual void VisitAddConsole   (IXboxVisit *pAddConsole,          DWORD *pdwFlags){_ASSERT(FALSE);}
    virtual void VisitConsole      (IXboxConsoleVisit   *pConsole,    DWORD *pdwFlags);
    virtual void VisitVolume       (IXboxVolumeVisit    *pVolume,     DWORD *pdwFlags){_ASSERT(FALSE);}
    virtual void VisitFileOrDir    (IXboxFileOrDirVisit *pFileOrDir,  DWORD *pdwFlags){_ASSERT(FALSE);}
    virtual void VisitDirectoryPost(IXboxFileOrDirVisit *pFileOrDir,  DWORD *pdwFlags){_ASSERT(FALSE);}
  private:
    HWND m_hWnd;
};

void CScreenCapture::VisitConsole(IXboxConsoleVisit *pConsole, DWORD *pdwFlags)
{
    char szConsoleName[60];
    pConsole->GetConsoleName(szConsoleName);
    Utils::ScreenCapture(m_hWnd, szConsoleName);
}

HRESULT CXboxMenu::Capture(LPCMINVOKECOMMANDINFO pici)
{
    CScreenCapture screenCapture(pici->hwnd);
    m_pSelection->VisitEach(&screenCapture, IXboxVisitor::FlagContinue);
    return S_OK;
}


void CSetDefault::VisitConsole(IXboxConsoleVisit *pConsole, DWORD *pdwFlags)
{
    if(m_fSet)
    {
        pConsole->SetDefault(TRUE);
        *pdwFlags = 0;
    } else
    {
        char szConsoleName[60];
        pConsole->GetConsoleName(szConsoleName);
        CManageConsoles manageConsole;
        m_fIsDefault = manageConsole.IsDefault(szConsoleName);
        *pdwFlags = 0;
    }
}

void CSetDefault::SetDefault(CXboxFolder *pSelection)
{
    m_fSet = TRUE;
    pSelection->VisitEach(this, IXboxVisitor::FlagContinue);
}

BOOL CSetDefault::IsDefault(CXboxFolder  *pSelection)
{
    m_fSet = FALSE;
    pSelection->VisitEach(this, IXboxVisitor::FlagContinue);
    return m_fIsDefault;
}

HRESULT CXboxMenu::SetDefault(LPCMINVOKECOMMANDINFO pici)
{
    CWaitCursor waitCursor;
    CSetDefault setDefault;
    setDefault.SetDefault(m_pSelection);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbshlext\objectwithsite.h ===
/*++

Copyright (c) Microsoft Corporation


Module Name:

    objectwithsite.h

Abstract:
    
    Declaration of an CShellObjectWithSite class that always
    queries for IShellFolderView. 

Environment:

    Windows 2000
    Uses ATL

Notes:

Revision History:

    July 2001 - created by Mitchell Dernis (mitchd)

--*/

class CShellObjectWithSite : public IObjectWithSite
{

  public:

   /*
   ** c'tor, d'tor
   */
   CShellObjectWithSite() : m_pUnknownSite(NULL) {}
   virtual ~CShellObjectWithSite()
   {
      if(m_pUnknownSite) m_pUnknownSite->Release();
   }

   /*
   **  IObjectWithSite Methods
   */
   STDMETHOD(SetSite)(IUnknown* pUnkSite);
   STDMETHOD(GetSite)(REFIID riid, void **ppvSite);
   
   /*
   **  An extra convenience function gets a service from the site interface
   */
   STDMETHOD(GetService)(REFGUID guidService, REFIID riid, void **ppvService);

  protected:
   IUnknown *m_pUnknownSite;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbshlext\objectwithsite.cpp ===
/*++

Copyright (c) Microsoft Corporation


Module Name:

    objectwithsite.cpp

Abstract:
    
    Implementation of CShellObjectWithSite class that always
    queries for IShellFolderView.

    Classes that inherit from this class use only its site's IShellFolderView.
    Or require that the site implement IShellFolderView.  This is true of the
    context menu, view callback, and drop target.

Environment:

    Windows 2000
    Uses ATL

Notes:

Revision History:

    July 2001 - created by Mitchell Dernis (mitchd)

--*/

#include <stdafx.h>

HRESULT CShellObjectWithSite::SetSite(IUnknown* pUnkSite)
/*++
  Routine Description:
    
    Sets (or clears) our owner site.

  Arguments:
    
    pUnkSite -  the IUnknown of the owning site.

  Return Value:

    Docs say always S_OK.

--*/
{
    //
    //  If we already have a site, release it.
    //

    if(m_pUnknownSite)
    {
        m_pUnknownSite->Release();
        m_pUnknownSite= NULL;
    }

    //
    //  If pUnkSite is not NULL, QI for IShellFolderView, this has the
    //  effect of AddRef'ing too.
    m_pUnknownSite = pUnkSite;
    if(m_pUnknownSite)
        m_pUnknownSite->AddRef();

    return S_OK;
}


HRESULT CShellObjectWithSite::GetSite(REFIID riid, void **ppvSite)
/*++
  Routine Description:

    The CDefView calls us with its IUknown almost immediately.  We usually
    want the IShellFolderView interface of the site, we QI for that and store
    it, rather than the pUnkSite itself.

  Arguments:

    riid - desired interface.
    ppvSite - [OUT] pointer to receive interface pointer.

  Return Value:

    S_OK - success.
    E_FAIL - we don't have a site
    E_NOINTERFACE - the return code from QI if the site doesn't have the desired interface.

--*/
{
    HRESULT hr = E_FAIL;

    if(m_pUnknownSite)
    {
        hr = m_pUnknownSite->QueryInterface(riid, ppvSite);
    }

    return hr;
}


HRESULT CShellObjectWithSite::GetService(REFGUID guidService, REFIID riid, void **ppvService)
{
    HRESULT hr = E_FAIL;
    IServiceProvider *pServiceProvider;

    if(m_pUnknownSite)
    {
      hr = m_pUnknownSite->QueryInterface(IID_PPV_ARG(IServiceProvider, &pServiceProvider));
      if(SUCCEEDED(hr))
      {
        hr = pServiceProvider->QueryService(guidService, riid, ppvService);
        pServiceProvider->Release();
      }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbshlext\pidl.cpp ===
#include "stdafx.h"

//**
//** Methods for use by CComEnum
//**
//**
void CPidlUtils::init(LPITEMIDLIST* p)
{
    *p = NULL;
}
HRESULT CPidlUtils::copy(LPITEMIDLIST* pTo, const LPITEMIDLIST* pFrom)
{

    *pTo = CPidlUtils::Copy(*pFrom);
    if(!*pTo) return E_OUTOFMEMORY;
    return S_OK;
}

void CPidlUtils::destroy(LPITEMIDLIST* p)
{
  if(*p)
  {
    g_pShellMalloc->Free(*p);
    *p = NULL;
  }
}


//**
//** Methods for use by CXboxFolders
//**
//**

ULONG CPidlUtils::GetLength(LPCITEMIDLIST pidl)
{
    ULONG size = 2; //The size is at least the two terminating NULL.
    while(pidl->mkid.cb)
    {
        size += pidl->mkid.cb;
        pidl = AdvancePtr(pidl, pidl->mkid.cb);
    }
    return size;
}

LPITEMIDLIST CPidlUtils::Copy(LPCITEMIDLIST Pidl, UINT uExtraAllocation)
{
    ULONG pidlSize = GetLength(Pidl);
    LPITEMIDLIST pidlCopy = (LPITEMIDLIST)g_pShellMalloc->Alloc(pidlSize+uExtraAllocation);
    if(pidlCopy)
    {
        memcpy(pidlCopy, Pidl, pidlSize);
    }
    return pidlCopy;
}

void CPidlUtils::Free(LPITEMIDLIST pidl)
{
    g_pShellMalloc->Free(pidl);
}

LPITEMIDLIST CPidlUtils::LastItem(LPITEMIDLIST pidl)
{
    LPITEMIDLIST prevPidl = NULL;
    while(pidl->mkid.cb)
    {
        prevPidl = pidl;
        pidl = AdvancePtr(pidl, pidl->mkid.cb);
    }
    return prevPidl;
}

LPITEMIDLIST CPidlUtils::Concatenate(LPITEMIDLIST dest, LPCITEMIDLIST src)
{
    ULONG destSize = g_pShellMalloc->GetSize(dest);
    ULONG concatLength = GetLength(dest) - 2; //drop the termination from the dest
    ULONG sourceLength = GetLength(src);
    ULONG requiredSize = concatLength + sourceLength;
    if(requiredSize > destSize)
    {
        dest = (LPITEMIDLIST) g_pShellMalloc->Realloc((PVOID)dest, destSize);
    }
    if(dest)
    {
        memcpy((PVOID)((ULONG)dest+concatLength), (PVOID)src, sourceLength);
    }
    return dest;
}

//**
//** Debug method
//**
//**

void CPidlUtils::DumpPidl(LPCITEMIDLIST pidl)
{
    CHAR FormatBuffer[MAX_PATH];
    //CHAR FormatBuffer2[MAX_PATH];
    int bufferIndex = 0;
    LPCITEMIDLIST pidlOrg = pidl;
    OutputDebugStringA("PIDL:");
    while(pidl->mkid.cb)
    {
        int abIDLength = pidl->mkid.cb - sizeof(USHORT);
        wsprintfA(FormatBuffer, "cb=%d,abID=\'",pidl->mkid.cb);
        OutputDebugStringA(FormatBuffer);
        memcpy(FormatBuffer, pidl->mkid.abID, abIDLength);
        FormatBuffer[abIDLength] = '\'';
        FormatBuffer[abIDLength+1] = ':';
        FormatBuffer[abIDLength+2] = '\0';
        for(int i = 0; i < abIDLength; i++)
        {
            if( FormatBuffer[i] < 32 ) FormatBuffer[i] = ' ';
            if( FormatBuffer[i] > 127 ) FormatBuffer[i] = '.';
        }
        //wsprintfA(FormatBuffer2, "%s", FormatBuffer);
        OutputDebugStringA(FormatBuffer);
        pidl = AdvancePtr(pidl, pidl->mkid.cb);
    }
    OutputDebugStringA("PIDLEND\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbshlext\pidl.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    pidl.h

Abstract:

    A number of utility methods for using pidls.

Environment:

    Windows 2000 and Later 
    User Mode

Revision History:
    
    02-05-2000 : created

--*/
#ifndef __PIDL_H__
#define __PIDL_H__


//-----------------------------------------------------------------------
// AdvancePtr cleans up the really ugly casting necessary to walk arrays
// of variable lengths structures, such as pidls.  Being a template, it
// works with any type of structure.
//-----------------------------------------------------------------------
template <class T>
inline T *AdvancePtr(T *pT, ULONG cb)
{
    return (T *)(((ULONG)pT) + cb);
}

class CPidlUtils
{
  public:

    enum PIDLTYPE
    {
        PidlTypeSimple,  // Single SHITEMID
        PidlTypeRoot,    // Root of Namespace Extension (i.e. Xbox Root)
        PidlTypeAbsolute // Root of System Namespace (i.e. Desktop)
    };
    //Methods specifically intended for use with the ATL CComEnum class.
    //Unlike the methods below which take a point to IMalloc, these use
    //SHGetMalloc.
    static void init(LPITEMIDLIST* p);
    static HRESULT copy(LPITEMIDLIST* pTo, const LPITEMIDLIST* pFrom);
    static void destroy(LPITEMIDLIST* p);

    //Utility Functions for PIDLs
    static ULONG         GetLength(LPCITEMIDLIST pidl);
    static LPITEMIDLIST  Copy(LPCITEMIDLIST pidl, UINT uExtraAllocation = 0);
    static void          Free(LPITEMIDLIST pidl);
    static LPITEMIDLIST  NextItem(LPITEMIDLIST pidl) {return AdvancePtr(pidl, pidl->mkid.cb);}
    static LPITEMIDLIST  LastItem(LPITEMIDLIST pidl);
    static LPITEMIDLIST  Concatenate(LPITEMIDLIST dest, LPCITEMIDLIST src);
    static void          DumpPidl(LPCITEMIDLIST pidl);
};

#ifdef NEVER
#define DEBUG_DUMP_PIDL(pidl) CPidlUtils::DumpPidl(pidl)
#else
#define DEBUG_DUMP_PIDL(pidl)
#endif


#endif //__PIDL_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbshlext\prop.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    prop.cpp

Abstract:

    Implementation of the property sheets dialogs

Environment:

    Windows 2000 and Later 
    User Mode

Revision History:
    
    05-25-2001 : created (mitchd)

--*/

#include <stdafx.h>
#include "drawpie.h"

#define DMPL_PRIV_ALL     (DMPL_PRIV_READ|DMPL_PRIV_WRITE|DMPL_PRIV_MANAGE|DMPL_PRIV_CONFIGURE|DMPL_PRIV_CONTROL)
#define DMPL_PRIV_INITIAL (DMPL_PRIV_READ|DMPL_PRIV_WRITE)

PropertyPageInfo::~PropertyPageInfo(){delete pPropertyPage;}

HRESULT 
CXboxPropertySheet::Initialize(
    UINT         uItemCount,
    CXboxFolder *pSelection
    )
/*++
  Routine Description:
    Initialize basically visits each of the selected items.
    
    Allocation of memory for property pages is put off
    until the first item is visited.  At that time
    we know how many pages will be allocated (one for
    each item, or one total), and we can allocate
    our basic structures.

    If the first item is a volume, then we visit each of the items
    and create a CGeneralVolumePage for each and insert them
    into ourselves.

    If the first itme is a file or folder, then we create
    a CFSItemGeneralPage, and initialize it with the selection.
    It will make a clone.  We can then terminate the visiting,
    it will need to visit each them itself.
--*/
{
    m_uItemCount = uItemCount;
    m_pSelection = pSelection;
    m_fFirstVisit = TRUE;
    pSelection->VisitEach(this, IXboxVisitor::FlagContinue);
    m_pSelection = NULL;  //we were just borrowing this.
    return m_hrInitialize;
}

void CXboxPropertySheet::VisitRoot(IXboxVisit *pRoot, DWORD *pdwFlags)
/*++
  Routine Description:
    Trying to create a property page for the root.  There isn't one
    at this time, set an error.
--*/
{
    *pdwFlags = 0;
    m_hrInitialize = E_INVALIDARG;
}

void CXboxPropertySheet::VisitAddConsole(IXboxVisit *pAddConsole, DWORD *pdwFlags)
/*++
  Routine Description:
    Trying to create a property page for the "Add Xbox" item.  There isn't one
    at this time, set an error.
--*/
{
    *pdwFlags = 0;
    m_hrInitialize = E_INVALIDARG;
}

void CXboxPropertySheet::VisitConsole(IXboxConsoleVisit *pConsole, DWORD *pdwFlags)
/*++
  Routine Description:
    Trying to create a property page for a console.  There isn't one at this time,
    set an error.
--*/
{
    HRESULT hr;
    BOOL fMultipleConsoles = (m_uItemCount > 1) ? TRUE: FALSE;
    if(m_fFirstVisit)
    {
        m_fFirstVisit = FALSE;
        m_hrInitialize = E_OUTOFMEMORY;
        if(fMultipleConsoles)
        {
            m_uMaxPages = m_uItemCount;
        } else
        {
            m_uMaxPages = MAX_CONSOLE_PAGES;
        }
        m_uPageCount = 0;
        m_pPages = new PropertyPageInfo[m_uMaxPages];
        if(m_pPages)
        {
            m_pPropSheetPages = new PROPSHEETPAGEA[m_uMaxPages];
            if(m_pPropSheetPages)
            {
                m_hrInitialize = S_OK;
            }
        }
        if(FAILED(m_hrInitialize))
        {
            *pdwFlags = 0;
            return;
        }
    }

    char szConsoleName[MAX_PATH];
    IXboxConnection *pConnection;
    pConsole->GetConsoleName(szConsoleName);
    hr  = Utils::GetXboxConnection(szConsoleName, &pConnection);
    if(SUCCEEDED(hr))
    {
        //
        //  Add the general page for this console
        //  
        CConsoleGeneralPage *pGeneralPage = new CConsoleGeneralPage(
                                                        pConnection,
                                                        szConsoleName,
                                                        fMultipleConsoles
                                                        );
        if(pGeneralPage)
           AddPage(pGeneralPage);
        
        //
        // If there are not multiple pages
        // add the settings, securities, and and advanced settings
        //
        if(!fMultipleConsoles)
        {
            /*
            CConsoleSettingsPage *pSettingsPage = new CConsoleSettingsPage(pConnection);
            if(pSettingsPage)
              AddPage(pSettingsPage);
            */
            CConsoleSecurityPage *pSecurityPage = new CConsoleSecurityPage(pConnection, szConsoleName);
            if(pSecurityPage)
            {
               if(S_OK==pSecurityPage->InitSecuritySupport())
               {
                  AddPage(pSecurityPage);
               }
               else
               {
                  delete pSecurityPage;
               }
            }
            
            CConsoleAdvancedPage *pAdvancedPage = new CConsoleAdvancedPage(pConnection, szConsoleName);
            if(pAdvancedPage)
              AddPage(pAdvancedPage);
        }
    } else
    {
        // Display the console cannot be found dialog.
        WindowUtils::MessageBoxResource(NULL, IDS_CONSOLE_NOT_AVAILABLE, IDS_GENERIC_CAPTION, MB_OK|MB_ICONSTOP, szConsoleName);
    }
    return;
}

void CXboxPropertySheet::VisitVolume(IXboxVolumeVisit *pVolume, DWORD *pdwFlags)
/*++
  Routine Description:
    Trying to create a property page for a console.  There isn't one at this time,
    set an error.
--*/
{
    if(m_fFirstVisit)
    {
        m_fFirstVisit = FALSE;
        m_hrInitialize = E_OUTOFMEMORY;
        m_uMaxPages = m_uItemCount;
        m_uPageCount = 0;
        m_pPages = new PropertyPageInfo[m_uMaxPages];
        if(m_pPages)
        {
            m_pPropSheetPages = new PROPSHEETPAGEA[m_uMaxPages];
            if(m_pPropSheetPages)
            {
                m_hrInitialize = S_OK;
            }
        }
        if(FAILED(m_hrInitialize))
        {
            *pdwFlags = 0;
            return;
        }
    }


    //
    //  Now create a property sheet for the volume, and add it.
    //
    char szConsoleName[40];
    char        szDriveLetter[4];
    char        szDriveDescription[60];
    ULONGLONG   ullTotalSpace;
    ULONGLONG   ullFreeSpace;
    UINT        uVolumeType;
    pVolume->GetName(szDriveLetter);
    pVolume->GetConsoleName(szConsoleName);
    WindowUtils::rsprintf(szDriveDescription, IDS_NORMAL_NAME_FORMAT, szDriveLetter, szConsoleName);
    pVolume->GetDiskCapacity(&ullTotalSpace, &ullFreeSpace);
    uVolumeType = (UINT)pVolume->GetVolumeType();
    CVolumeGeneralPage *pVolumePage = 
        new CVolumeGeneralPage(
            szDriveDescription,
            ullTotalSpace,
            ullFreeSpace,
            uVolumeType,
            (m_uItemCount > 1) ? TRUE : FALSE
            );
    if(pVolumePage)
    {
        AddPage(pVolumePage);
    } else
    {
        m_hrInitialize = E_FAIL;
        *pdwFlags = 0;
        return;
    }
}

void CXboxPropertySheet::VisitFileOrDir(IXboxFileOrDirVisit *pFileOrDir, DWORD *pdwFlags)
/*++
  Routine Description:
    
    There are three cases where we get called:
    1) For a single folder.
    2) For a single file.
    3) First visit for multiple-items.

    In all cases, we instantiated a single property page to represent the item(s).  The
    c'tor CFSItemGeneralPage figures everything out, and clones the selection.

--*/
{
    m_hrInitialize = E_FAIL;
    m_uMaxPages = 1;
    m_uPageCount = 0;
    m_pPages = new PropertyPageInfo[m_uMaxPages];
    if(m_pPages)
    {
        m_pPropSheetPages = new PROPSHEETPAGEA[m_uMaxPages];
        if(m_pPropSheetPages)
        {
            m_hrInitialize = S_OK;
        }

        CFSItemGeneralPage *pGeneralPage = new CFSItemGeneralPage(m_pSelection, pFileOrDir, m_uItemCount);
        if(pGeneralPage)
        {
            AddPage(pGeneralPage);
        }
    }
    //
    //  No need to continue visiting sites.
    //

    *pdwFlags = 0;
}


void
CXboxPropertySheet::AddPage(
    CPropertyPage *pPage
    )
/*++
  Routine Description:
    Add a property page to a property sheet.  This must be done before calling DoProperties.
--*/
{
    UINT uPageIndex;
    _ASSERTE(m_uPageCount < m_uMaxPages);
    
    //
    //  Add a pointer to the page to our array of property pages.
    //
    uPageIndex = m_uPageCount++;
    m_pPages[uPageIndex].pPropertyPage = pPage;

    //
    //  Get the page to fillout its PROPSHEETPAGEA structure.
    //
    pPage->FilloutPropSheetPage(m_pPropSheetPages+uPageIndex);
}

HRESULT 
CXboxPropertySheet::DoProperties(
    UINT uStartPage,
    HWND hwndParent
    )
{
    m_hWndParent = hwndParent;
    m_uStartPage = uStartPage;
    if(m_uPageCount > 0)
    {
        DWORD  dwThreadId;
        if(SHCreateThread(CXboxPropertySheet::ThreadProcStart, (PVOID)this, CTF_COINIT|CTF_PROCESS_REF, NULL))
        {
            return S_OK;
        } else
        {
            delete this;
            return HRESULT_FROM_WIN32(GetLastError());
        }
    }
    return S_OK;
}

DWORD CXboxPropertySheet::ThreadProc()
{
    char szCaption[36];
    PROPSHEETHEADERA propSheetHeader;
    propSheetHeader.dwSize = sizeof(PROPSHEETHEADERA);
    propSheetHeader.dwFlags = PSH_PROPSHEETPAGE | PSH_PROPTITLE;
    propSheetHeader.hwndParent = WindowUtils::CreateWorkerWindow(m_hWndParent);;
    propSheetHeader.hInstance = NULL;
    propSheetHeader.hIcon = NULL;
    propSheetHeader.pszCaption = NULL;
    propSheetHeader.nPages = m_uPageCount;
    propSheetHeader.nStartPage = m_uStartPage;
    propSheetHeader.ppsp = m_pPropSheetPages;
    propSheetHeader.pfnCallback  = NULL;

    _ASSERTE(m_uPageCount > 0);

    //
    //  Get the caption from the first page.
    //  If there are multiple pages add ...
    //
    if(m_pPages[0].pPropertyPage->GetCaption(szCaption, ARRAYSIZE(szCaption)))
    {
        if(m_uItemCount  > 1)
        {
            wsprintfA(m_szCaption, "%s,...", szCaption);
        } else
        {
            strcpy(m_szCaption, szCaption);
        }
        propSheetHeader.pszCaption = m_szCaption;
    }
    PropertySheetA(&propSheetHeader);

    //
    //  Destroy yourself on exit
    //
    delete this;
    
    return 0;
}

INT_PTR CALLBACK CPropertyPage::DialogProc(HWND hWndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CPropertyPage *pThis;

    //
    //  WM_INITDIALOG is special.
    //
    if(WM_INITDIALOG==uMsg)
    {
        PROPSHEETPAGEA *pPropSheetPage = (PROPSHEETPAGEA *)lParam;
        pThis = (CPropertyPage *)pPropSheetPage->lParam;
        SetWindowLong(hWndDlg,DWL_USER,(LONG)pThis);
        pThis->m_hPropDlg = hWndDlg;
        return pThis->OnInitDialog((HWND)wParam);
    }

    pThis = (CPropertyPage *)GetWindowLong(hWndDlg, DWL_USER);
    if(pThis)
    {
        switch(uMsg)
        {
          case WM_COMMAND:
            return pThis->OnCommand(wParam, lParam);
          case WM_DRAWITEM:
            return pThis->OnDrawItem((UINT)(wParam), (LPDRAWITEMSTRUCT)lParam); 
          case WM_NOTIFY:
            {
                LPPSHNOTIFY pPropSheetNotify = (LPPSHNOTIFY)lParam;
                if(PSN_APPLY == pPropSheetNotify->hdr.code)
                {
                    //
                    // If OnApply returns False, the changes could not be applied.
                    // So set a bad return result.
                    //
                    if(!pThis->OnApply(pPropSheetNotify->lParam ? true : false))
                    {
                        SetWindowLong(pThis->m_hPropDlg, DWL_MSGRESULT, PSNRET_INVALID);
                        return true;
                    }
                } else if(PSN_SETACTIVE == pPropSheetNotify->hdr.code)
                {
                    return pThis->OnSetActive();
                }
            }
          default:        
            return pThis->OnMessage(uMsg, wParam, lParam);
        }
    }
    return 0;
}

void 
CPropertyPage::FilloutPropSheetPage(
    PROPSHEETPAGEA *pPropSheetPage
    )
{
    pPropSheetPage->dwSize = sizeof(PROPSHEETPAGE);
    pPropSheetPage->dwFlags = PSP_DEFAULT;
    pPropSheetPage->hInstance = _Module.GetModuleInstance();
    pPropSheetPage->pfnDlgProc = DialogProc;
    pPropSheetPage->pfnCallback = NULL;
    pPropSheetPage->lParam = (LPARAM)this;
    CompletePropSheetPage(pPropSheetPage);
}

int CPropertyPage::OnMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    return 0;
}

int CPropertyPage::OnCommand(WPARAM wParam, LPARAM lParam)
{
    return 0;
}

BOOL CVolumeGeneralPage::GetCaption(LPSTR szBuffer, ULONG ccBuffer)
{
    szBuffer[--ccBuffer] = TEXT('\0');
    strncpy(szBuffer, m_szDriveDescription, ccBuffer);
    return TRUE;
}

void CVolumeGeneralPage::CompletePropSheetPage(PROPSHEETPAGEA *pPropSheetPage)
{
    //
    //  The client will have passed in m_fUseDriveOnTabName on construction.
    //  This tells us that we need to override the "General" tab name, with
    //  the drive description.  This feature is for the case where multiple
    //  drives are opened in a single property sheet.
    //
    
    if(m_fDriveOnTab)
    {
        pPropSheetPage->dwFlags |= PSP_USETITLE;
        pPropSheetPage->pszTitle = m_szDriveDescription;
    }
    pPropSheetPage->pszTemplate = MAKEINTRESOURCEA(IDD_DRV_GENERAL);
}

void CVolumeGeneralPage::DrawColorRect(HDC hdc, COLORREF crDraw, const RECT *prc)
{
    HBRUSH hbDraw = CreateSolidBrush(crDraw);
    if (hbDraw)
    {
        HBRUSH hbOld = (HBRUSH)SelectObject(hdc, hbDraw);
        if (hbOld)
        {
            PatBlt(hdc, prc->left, prc->top,
                prc->right - prc->left,
                prc->bottom - prc->top,
                PATCOPY);
            
            SelectObject(hdc, hbOld);
        }
        
        DeleteObject(hbDraw);
    }
}

int CVolumeGeneralPage::OnInitDialog(HWND)
/*++
  Routine Descriptor:
    Handles initializing a volume general property page.
    We need to initialize each of the controls on the dialog
    with the correct data.

  Arguments:
    HWND is the default control, we don't need it here.
--*/
{
    
    HWND  hWndCtrl;
    char  szFormatBuffer[1024];

    //
    //  Update the drive letter information
    //
    hWndCtrl = GetDlgItem(m_hPropDlg, IDC_DRV_LETTER1);
    if(hWndCtrl) SetWindowTextA(hWndCtrl, m_szDriveDescription);

    //
    //  Update the drive type.  (For now it is always
    //
    hWndCtrl = GetDlgItem(m_hPropDlg, IDC_DRV_TYPE);
    if(hWndCtrl)
    {
        LoadStringA(_Module.GetModuleInstance(), m_uVolumeType, szFormatBuffer, sizeof(szFormatBuffer));
        SetWindowTextA(hWndCtrl, szFormatBuffer);
    }
    
    //
    //  Update the Used Bytes.
    //
    ULONGLONG ullUsedSpace = m_ullTotalSpace-m_ullFreeSpace;
    hWndCtrl = GetDlgItem(m_hPropDlg, IDC_DRV_USEDBYTES);
    if(hWndCtrl)
    {
        FormatUtils::FileSizeBytes(ullUsedSpace,szFormatBuffer);
        SetWindowTextA(hWndCtrl, szFormatBuffer);
    }

    //
    // Update Used Megabyes or GigaBytes
    //
    hWndCtrl = GetDlgItem(m_hPropDlg, IDC_DRV_USEDMB);
    if(hWndCtrl)
    {
        FormatUtils::FileSize(ullUsedSpace, szFormatBuffer);
        SetWindowTextA(hWndCtrl, szFormatBuffer);
    }

    //
    //  Update the Free Bytes.
    //
    hWndCtrl = GetDlgItem(m_hPropDlg, IDC_DRV_FREEBYTES);
    if(hWndCtrl)
    {
        FormatUtils::FileSizeBytes(m_ullFreeSpace,szFormatBuffer);
        SetWindowTextA(hWndCtrl, szFormatBuffer);
    }

    //
    // Update Free Megabyes or GigaBytes
    //
    hWndCtrl = GetDlgItem(m_hPropDlg, IDC_DRV_FREEMB);
    if(hWndCtrl)
    {
        FormatUtils::FileSize(m_ullFreeSpace, szFormatBuffer);
        SetWindowTextA(hWndCtrl, szFormatBuffer);
    }

    
    //
    //  Update the Total Bytes.
    //
    hWndCtrl = GetDlgItem(m_hPropDlg, IDC_DRV_TOTBYTES);
    if(hWndCtrl)
    {
        FormatUtils::FileSizeBytes(m_ullTotalSpace, szFormatBuffer);
        SetWindowTextA(hWndCtrl, szFormatBuffer);
    }

    //
    // Update Total Megabyes or GigaBytes
    //
    hWndCtrl = GetDlgItem(m_hPropDlg, IDC_DRV_TOTMB);
    if(hWndCtrl)
    {
        FormatUtils::FileSize(m_ullTotalSpace,szFormatBuffer);
        SetWindowTextA(hWndCtrl, szFormatBuffer);
    }

    return 1;
}

const COLORREF c_crPieColors[] =
{
    RGB(  0,   0, 255),      // Blue
    RGB(255,   0, 255),      // Red-Blue
    RGB(  0,   0, 128),      // 1/2 Blue
    RGB(128,   0, 128),      // 1/2 Red-Blue
};

INT_PTR CVolumeGeneralPage::OnDrawItem(UINT uItem, LPDRAWITEMSTRUCT pDrawItem)
{
    switch(uItem)
    {
        case IDC_DRV_PIE:
         {
           DWORD dwPctX10 = m_ullTotalSpace ?
                (DWORD)((__int64)1000 * (m_ullTotalSpace - m_ullFreeSpace) / m_ullTotalSpace) : 
                1000;

            if(!m_dwPieShadowHgt)
            {
                SIZE size;
                GetTextExtentPoint(pDrawItem->hDC, TEXT("W"), 1, &size);
                m_dwPieShadowHgt = size.cy * 2/3;
            }

            DrawPie(
                pDrawItem->hDC,
                &pDrawItem->rcItem,
                dwPctX10,
                m_ullFreeSpace==0 || m_ullFreeSpace==m_ullTotalSpace,
                m_dwPieShadowHgt,
                c_crPieColors);
         }
         break;
        case IDC_DRV_USEDCOLOR:
         DrawColorRect(pDrawItem->hDC, c_crPieColors[DP_USEDCOLOR], &pDrawItem->rcItem);
         break;
        case IDC_DRV_FREECOLOR:
         DrawColorRect(pDrawItem->hDC, c_crPieColors[DP_FREECOLOR], &pDrawItem->rcItem);
         break;
        default:
         return 0;
    }
    return 1;
}

CFSItemGeneralPage::CFSItemGeneralPage(
    CXboxFolder *pSelection,
    IXboxFileOrDirVisit *pFileOrDir,
    UINT uItemCount
    ) : m_pSelection(NULL), m_fNameChanged(false),
        m_fReadOnlyChanged(false), m_fHiddenChanged(false),
        m_hThread(NULL)
{
    
    char  szLocationTemp[MAX_XBOX_PATH];
    LPSTR pszParse;
    CGetAttributes getAttributes(&m_MultiFileAttributes);

    //
    //  Get the location
    //
    pSelection->GetPath(szLocationTemp);

    //
    //  uItemCount==0 is a special case, the selection
    //  is not a child of the CXboxFolder, but it is the
    //  the CXboxFolder itself, so we get the location
    //  by stripping one path element off the end.
    //

    if(0==uItemCount)
    {
      pszParse = strrchr(szLocationTemp, '\\');
      *pszParse = '\0';
    }
    
    //
    //  Replace the '\\' after the console name.
    //  Get pszParse to point to the rest of the
    //  location.
    //
    pszParse = strchr(szLocationTemp, '\\');
    *pszParse++ = '\0';
    wsprintfA(m_szLocation, "%c:%s(On \'%s\')", *pszParse, pszParse+1, szLocationTemp);
        
    //
    //  Now determine the dialog to display (FILE, FOLDER, MULTIFILE)
    //
    pFileOrDir->GetName(m_szNameBuffer);
    if(uItemCount < 2)
    {
        getAttributes.VisitFileOrDir(pFileOrDir, NULL);
        if(m_MultiFileAttributes.dwAttributes&FILE_ATTRIBUTE_DIRECTORY)
        {
            m_uTemplateResource = IDD_FOLDERPROP;
            m_MultiFileAttributes.dwFolderCount--;
        } else
        {
            m_uTemplateResource = IDD_FILEPROP;
        }
    } else
    {
        pSelection->VisitEach(&getAttributes, IXboxVisitor::FlagContinue);
        m_uTemplateResource = IDD_FILEMULTPROP;
    }

    //
    //  Clone the selection, for the thread proc
    //
    pSelection->Clone(&m_pSelection);
}

DWORD CFSItemGeneralPage::ThreadProc()
/*++
  Routine Description.
    Visits the selection recursively to get a full count of files \ folders and the total size.
--*/
{
    XBOX_MULTIFILE_ATTRIBUTES multiFileAttributes;
    CGetAttributes getAttributes(&multiFileAttributes, false, GetAttributesCallback, (PVOID)this);
    m_pSelection->VisitEach(&getAttributes, IXboxVisitor::FlagRecurse|IXboxVisitor::FlagContinue);
    return 0;
}

bool CFSItemGeneralPage::GetAttributesCallback(PVOID pvThis, XBOX_MULTIFILE_ATTRIBUTES *pMultiFileAttributes)
{
    CFSItemGeneralPage *pThis = (CFSItemGeneralPage *)pvThis;
    if(pThis->m_fKillThread) return false;

    if(pMultiFileAttributes->ullTotalSize > pThis->m_MultiFileAttributes.ullTotalSize)
    {
        pThis->m_MultiFileAttributes.ullTotalSize = pMultiFileAttributes->ullTotalSize;
    }
    if(pMultiFileAttributes->dwFileCount > pThis->m_MultiFileAttributes.dwFileCount)
    {
        pThis->m_MultiFileAttributes.dwFileCount = pMultiFileAttributes->dwFileCount;
    }
    DWORD dwFolderCount = pMultiFileAttributes->dwFolderCount;
    if(IDD_FOLDERPROP == pThis->m_uTemplateResource) dwFolderCount--;
    if(dwFolderCount > pThis->m_MultiFileAttributes.dwFolderCount)
    {
        pThis->m_MultiFileAttributes.dwFolderCount = dwFolderCount;
    }

    //
    //  Tell the filesystem page to update itself.
    //

    PostMessage(pThis->m_hPropDlg, WM_PROPPAGE_REFRESH_CONTENTS, 0, 0);
    return true;
}


void CFSItemGeneralPage::SynchronizeUpdateThread()
{
    if(m_hThread)
    {
        m_fKillThread = true;
        WaitForSingleObject(m_hThread, INFINITE);
        CloseHandle(m_hThread);
        m_hThread = NULL;
    }
}
BOOL CFSItemGeneralPage::GetCaption(LPSTR szBuffer, ULONG)
/*++
  Routine Description:
    Returns the name of the first item.  If there is more than one appends
    ",..." to the name.
--*/
{
    strcpy(szBuffer, m_szNameBuffer);
    return TRUE;
}

INT_PTR CFSItemGeneralPage::OnInitDialog(HWND hwndDefaultControl)
{

    HWND hWndCtrl;
    char szFormatBuffer[MAX_PATH];

    //
    //  Initialize the Name Field if it has one
    //
    hWndCtrl = GetDlgItem(m_hPropDlg, IDC_NAMEEDIT);
    if(hWndCtrl)
    {
        SetWindowTextA(hWndCtrl, m_szNameBuffer);
    }

    //
    //  Initialize the Icon Field if it has one.
    //
    hWndCtrl = GetDlgItem(m_hPropDlg, IDC_ITEMICON);
    if(hWndCtrl)
    {
        //Get the large icon
        DWORD dwRet = 0;
        BOOL fSuccess;
        SHFILEINFOA ShellFileInfo;
        fSuccess = SHGetFileInfoA(
                    m_szNameBuffer,
                    0,
                    &ShellFileInfo,
                    sizeof(ShellFileInfo),
                    SHGFI_USEFILEATTRIBUTES|SHGFI_ICON|SHGFI_LARGEICON 
                    );
        if(fSuccess)
        {
            WindowUtils::ReplaceWindowIcon(hWndCtrl, ShellFileInfo.hIcon);
        }
    }

    //
    //  Set the file type.
    //

    hWndCtrl = GetDlgItem(m_hPropDlg, IDC_FILETYPE);
    if(hWndCtrl)
    {
        SetWindowTextA(hWndCtrl, m_MultiFileAttributes.szTypeName);
    }

    //
    //  File location - basically get the fullname of the first
    //  item, and lop off the last filename.
    //
    hWndCtrl = GetDlgItem(m_hPropDlg, IDC_LOCATION);
    if(hWndCtrl)
    {
        SetWindowTextA(hWndCtrl, m_szLocation);
    }
    
    hWndCtrl = GetDlgItem(m_hPropDlg, IDC_FILESIZE);
    if(hWndCtrl)
    {
        FormatUtils::FileSize(m_MultiFileAttributes.ullTotalSize, szFormatBuffer);
        SetWindowTextA(hWndCtrl, szFormatBuffer);
    }

    hWndCtrl = GetDlgItem(m_hPropDlg, IDC_CONTAINS);
    if(hWndCtrl)
    {
        WindowUtils::rsprintf(
            szFormatBuffer,
            IDS_CONTAINS_FORMAT,
            m_MultiFileAttributes.dwFileCount,
            m_MultiFileAttributes.dwFolderCount
            );
        SetWindowTextA(hWndCtrl, szFormatBuffer);
    }
    
    hWndCtrl = GetDlgItem(m_hPropDlg, IDC_CREATED);
    if(hWndCtrl)
    {
        FormatUtils::FileTime(
            &m_MultiFileAttributes.CreationTime,
            szFormatBuffer,
            DATE_LONGDATE
            );
        SetWindowTextA(hWndCtrl, szFormatBuffer);
    }

    hWndCtrl = GetDlgItem(m_hPropDlg, IDC_LASTMODIFIED);
    if(hWndCtrl)
    {
        FormatUtils::FileTime(
            &m_MultiFileAttributes.ChangeTime,
            szFormatBuffer,
            DATE_LONGDATE
            );
        SetWindowTextA(hWndCtrl, szFormatBuffer);
    }
    

    //
    //  Set the readonly checkbox
    //
    hWndCtrl = GetDlgItem(m_hPropDlg, IDC_READONLY);
    if(hWndCtrl)
    {
       WPARAM buttonState;
       if(m_MultiFileAttributes.dwValidAttributes&FILE_ATTRIBUTE_READONLY)
       {
         if(m_MultiFileAttributes.dwAttributes&FILE_ATTRIBUTE_READONLY)
         {
            buttonState = BST_CHECKED;
         } else
         {
            buttonState = BST_UNCHECKED; 
         }
       } else
       {
           buttonState = BST_INDETERMINATE;
           
       }
       SendMessage(hWndCtrl, BM_SETCHECK, buttonState, 0);
    }

    //
    //  Set the hidden checkbox
    //
    hWndCtrl = GetDlgItem(m_hPropDlg, IDC_HIDDEN);
    if(hWndCtrl)
    {
       WPARAM buttonState;
       if(m_MultiFileAttributes.dwValidAttributes&FILE_ATTRIBUTE_HIDDEN)
       {
         if(m_MultiFileAttributes.dwAttributes&FILE_ATTRIBUTE_HIDDEN)
         {
            buttonState = BST_CHECKED;
         } else
         {
            buttonState = BST_UNCHECKED;
         }
       } else
       {
            buttonState = BST_INDETERMINATE;
       }
       SendMessage(hWndCtrl, BM_SETCHECK, buttonState, 0);
    }
    //
    //  Then name cannot have changed yet.
    //
    m_fNameChanged = false;
    m_fReadOnlyChanged = false;
    m_fHiddenChanged = false;

    //
    //  Start the recursive update.
    //

    _ASSERTE(m_pSelection);

    if(IDD_FILEPROP != m_uTemplateResource)
    {
        DWORD dwThreadId;
        m_fKillThread = false;
        m_hThread = CreateThread(NULL, 0, CFSItemGeneralPage::StartThreadProc, this, 0, &dwThreadId);
    }

    return 1;
}

void CFSItemGeneralPage::CompletePropSheetPage(PROPSHEETPAGEA *pPropSheetPage)
/*++
  Routine Description:
    We need to complete the PROPSHEETPAGE structure.  The CPropertyPage
    has already done as much as it could.  Basically, we need to choose
    the template.  There are three possibilities:
    1) We represent one and only one file.  Use IDD_FILEPROP.
    2) We represent one and only one folder.  Use IDD_FOLDERPROP.
    3) We represent two or more items, files and\or folders.  Use IDD_FILEMULTPROP.
--*/
{
    pPropSheetPage->pszTemplate = MAKEINTRESOURCEA(m_uTemplateResource);
}


INT_PTR CFSItemGeneralPage::OnCommand(WPARAM wParam, LPARAM lParam)
{
    UINT uControlId = LOWORD(wParam);
    UINT uCommand = HIWORD(wParam);

    //
    //  If READ ONLY or HIDDEN IS CHANGED, just tell our parent
    //  to enable the Apply Button.
    //
    if ( uCommand == BN_CLICKED) 
    { 
        if(uControlId==IDC_READONLY)
        {
           m_fReadOnlyChanged = true;
           SendMessage(GetParent(m_hPropDlg), PSM_CHANGED, (WPARAM)m_hPropDlg, 0); 
           return TRUE;
        }
        if(uControlId==IDC_HIDDEN)
        {
           m_fHiddenChanged = true;
           SendMessage(GetParent(m_hPropDlg), PSM_CHANGED, (WPARAM)m_hPropDlg, 0); 
           return TRUE;
        }
    }
    
    if (uCommand == EN_CHANGE)
    {
        if(uControlId == IDC_NAMEEDIT)
        {
           m_fNameChanged = true;
           return TRUE;
        }
    }
    
    return  FALSE;
}


INT_PTR CFSItemGeneralPage::OnMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    char szFormatBuffer[MAX_PATH];
    if(uMsg==WM_PROPPAGE_REFRESH_CONTENTS)
    {
        HWND hWndCtrl = GetDlgItem(m_hPropDlg, IDC_FILESIZE);
        if(hWndCtrl)
        {
            FormatUtils::FileSize(m_MultiFileAttributes.ullTotalSize, szFormatBuffer);
            SetWindowTextA(hWndCtrl, szFormatBuffer);
        }

        hWndCtrl = GetDlgItem(m_hPropDlg, IDC_CONTAINS);
        if(hWndCtrl)
        {
            WindowUtils::rsprintf(
                szFormatBuffer,
                IDS_CONTAINS_FORMAT,
                m_MultiFileAttributes.dwFileCount,
                m_MultiFileAttributes.dwFolderCount
                );
            SetWindowTextA(hWndCtrl, szFormatBuffer);
        }
        return TRUE;
    } else if(WM_NOTIFY==uMsg)
    {
        LPPSHNOTIFY pPropSheetNotify = (LPPSHNOTIFY)lParam;
        if(PSN_QUERYCANCEL == pPropSheetNotify->hdr.code)
        {
            SynchronizeUpdateThread();
        }
        return TRUE;
    }
    return FALSE;
}


class CSetName : public IXboxVisitor
{
 public:
  CSetName(LPSTR pszNewName, HWND hWnd): m_pszNewName(pszNewName), m_hWnd(hWnd){}
  void VisitRoot(IXboxVisit *pRoot, DWORD *pdwFlags){_ASSERTE(FALSE);}
  void VisitAddConsole(IXboxVisit *pAddConsole, DWORD *pdwFlags){_ASSERTE(FALSE);}
  void VisitConsole(IXboxConsoleVisit *pConsole, DWORD *pdwFlags){_ASSERTE(FALSE);}
  void VisitVolume(IXboxVolumeVisit *pVolume, DWORD *pdwFlags){_ASSERTE(FALSE);}
  void VisitDirectoryPost (IXboxFileOrDirVisit *pFileOrDir, DWORD *pdwFlags) {_ASSERTE(FALSE);}
  
  void VisitFileOrDir(IXboxFileOrDirVisit *pFileOrDir, DWORD *pdwFlags)
  {
        m_hr = pFileOrDir->SetName(m_hWnd, m_pszNewName);
  }
  HRESULT m_hr;
  LPSTR   m_pszNewName;
  HWND    m_hWnd;
};

bool CFSItemGeneralPage::OnApply(bool fClose)
{
    
    HWND  hWndCtrl;
    DWORD dwSetAttributes = 0;
    DWORD dwClearAttributes = 0;
    bool  fRet = true;

    SynchronizeUpdateThread();

    //
    //  Retrieve the state of the read-only and hidden check-boxes
    //
    if(m_fReadOnlyChanged)
    {
        LONG lState = SendDlgItemMessage(m_hPropDlg, IDC_READONLY, BM_GETSTATE, 0, 0);
        switch(lState)
        {
           case BST_CHECKED:
              dwSetAttributes |= FILE_ATTRIBUTE_READONLY;
              break;
           case BST_UNCHECKED:
              dwClearAttributes |= FILE_ATTRIBUTE_READONLY;
              break;
           case BST_INDETERMINATE:
           default:
              break;
        }
    }

    if(m_fHiddenChanged)
    {
        LONG lState = SendDlgItemMessage(m_hPropDlg, IDC_HIDDEN, BM_GETSTATE, 0, 0);
        switch(lState)
        {
           case BST_CHECKED:
              dwSetAttributes |= FILE_ATTRIBUTE_HIDDEN;
              break;
           case BST_UNCHECKED:
              dwClearAttributes |= FILE_ATTRIBUTE_HIDDEN;
              break;
           case BST_INDETERMINATE:
           default:
              break;
        }
    }

    if(dwSetAttributes || dwClearAttributes)
    {
       bool fUpdateAttributes = true;
       DWORD dwVisitorFlags = IXboxVisitor::FlagContinue;

       if( 
            ((IDD_FOLDERPROP == m_uTemplateResource) && (m_MultiFileAttributes.dwFolderCount || m_MultiFileAttributes.dwFileCount)) ||
            ((IDD_FILEMULTPROP == m_uTemplateResource) && m_MultiFileAttributes.dwFolderCount)
        )
        {
            
            UINT uRet = Dialog::ConfirmSetAttributes(m_hPropDlg,dwSetAttributes,dwClearAttributes, (IDD_FILEMULTPROP == m_uTemplateResource));
            if(IDCANCEL==uRet)
            {
                fUpdateAttributes = false;
            } else if(IDC_XB_YESTOALL==uRet)
            {
                dwVisitorFlags |= IXboxVisitor::FlagRecurse;
            }
       }

       if(fUpdateAttributes)
       {
            CSetAttributes setAttributes(dwSetAttributes, dwClearAttributes);
            _ASSERTE(m_pSelection);
            m_pSelection->VisitEach(&setAttributes, dwVisitorFlags);
            m_fReadOnlyChanged = false;
            m_fHiddenChanged = false;
       }
    }

    if(fClose && m_fNameChanged)
    {
        m_fNameChanged = false;
        hWndCtrl = GetDlgItem(m_hPropDlg, IDC_NAMEEDIT);
        if(hWndCtrl)
        {
            CHAR szNewName[MAX_PATH];
            GetWindowTextA(hWndCtrl, szNewName, sizeof(szNewName));
            if(strcmp(m_szNameBuffer, szNewName))
            {
                
                CSetName setName(szNewName, m_hPropDlg);
                m_pSelection->VisitEach(&setName, IXboxVisitor::FlagContinue);
                if(FAILED(setName.m_hr))
                {
                    char szError[60];
                    FormatUtils::XboxErrorString(setName.m_hr, szError, sizeof(szError));
                    WindowUtils::MessageBoxResource(m_hPropDlg, IDS_RENAME_XBDM_ERROR, IDS_RENAME_ERROR_CAPTION, MB_OK|MB_ICONSTOP, szError);
                }
            }
        }
    }
    return fRet;
}


//-----------------------------------------------------------
//  General Page for Consoles
//-----------------------------------------------------------
CConsoleGeneralPage::CConsoleGeneralPage(
           IXboxConnection *pConnection,
           LPCSTR           pszConsoleName,
           BOOL             fMultipleConsoles
           ) : m_pConnection(pConnection), m_fMultipleConsoles(fMultipleConsoles)
{
    _ASSERT(m_pConnection);
    m_pConnection->AddRef();
    strcpy(m_szConsoleName, pszConsoleName);
}

BOOL
CConsoleGeneralPage::GetCaption(
    LPSTR szBuffer,
    ULONG ccBuffer
    )
{
    strncpy(szBuffer, m_szConsoleName, ccBuffer);
    return TRUE;

}

INT_PTR
CConsoleGeneralPage::OnInitDialog(
    HWND hwndDefaultControl
    )
{
    DWORD dwIpAddress;
    DWORD dwSize;
    DM_XBE dmXbe;
    char  szFormatBuffer[MAX_PATH];
    SYSTEMTIME sysTime;
    HRESULT hr;

    dwSize = sizeof(szFormatBuffer);
    if(SUCCEEDED(m_pConnection->HrGetNameOfXbox(szFormatBuffer, &dwSize, FALSE)))
    {
        SetWindowTextA(GetDlgItem(m_hPropDlg, IDC_NAMEEDIT), szFormatBuffer);
    }

    //Check if we need to replace the icon for the default console.
    CManageConsoles manageConsole;
    if(manageConsole.IsDefault(m_szConsoleName))
    {
        HICON hDefaultConsole = LoadIcon(_Module.GetModuleInstance(), MAKEINTRESOURCE(IDI_CONSOLE_DEFAULT));
        if(hDefaultConsole)
            WindowUtils::ReplaceWindowIcon(GetDlgItem(m_hPropDlg, IDC_ITEMICON), hDefaultConsole);
    }

    if(SUCCEEDED(m_pConnection->HrResolveXboxName(&dwIpAddress)))
    {
        wsprintfA(szFormatBuffer, "%d.%d.%d.%d", (dwIpAddress >> 24)&0xFF, (dwIpAddress >> 16)&0xFF, (dwIpAddress >> 8)&0xFF, dwIpAddress&0xFF);
    } else
    {
        LoadStringA(_Module.GetModuleInstance(), IDS_TITLE_NOT_AVAILABLE, szFormatBuffer, sizeof(szFormatBuffer));
    }
    SetWindowTextA(GetDlgItem(m_hPropDlg, IDC_IPADDRESS), szFormatBuffer);

    if(SUCCEEDED(m_pConnection->HrGetAltAddress(&dwIpAddress)))
    {
        wsprintfA(szFormatBuffer, "%d.%d.%d.%d", (dwIpAddress >> 24)&0xFF, (dwIpAddress >> 16)&0xFF, (dwIpAddress >> 8)&0xFF, dwIpAddress&0xFF);
        SetWindowTextA(GetDlgItem(m_hPropDlg, IDC_ALTIPADDRESS), szFormatBuffer);
    } else
    {
        ShowWindow(GetDlgItem(m_hPropDlg, IDC_ALTIPADDRESS), SW_HIDE);
        ShowWindow(GetDlgItem(m_hPropDlg, IDC_ALTIPADDRESS_TEXT), SW_HIDE);
    }

    hr = m_pConnection->HrGetXbeInfo(NULL, &dmXbe);
    if(XBDM_NOSUCHFILE == hr)
    {
        LoadStringA(_Module.GetModuleInstance(), IDS_DEFAULT_TITLE, dmXbe.LaunchPath, sizeof(dmXbe.LaunchPath));
    } else if(FAILED(hr))
    {
        LoadStringA(_Module.GetModuleInstance(), IDS_TITLE_NOT_AVAILABLE, dmXbe.LaunchPath, sizeof(dmXbe.LaunchPath));
    }
    HWND hRunningTitle = GetDlgItem(m_hPropDlg, IDC_RUNNINGTITLE);
    SetWindowTextA(hRunningTitle, dmXbe.LaunchPath);
    
    //Uggh, the launch path is often longer than the field.  The user can tab to it, and use the HSCROLL capability
    //to see the whole thing.  The end of the path is usually more interesting than the beginning, so we help the user
    //out by scrolling it.
    dwSize = strlen(dmXbe.LaunchPath);
    SendMessage(hRunningTitle, EM_SETSEL, dwSize, dwSize);

    return 1;
}

void 
CConsoleGeneralPage::CompletePropSheetPage(
    PROPSHEETPAGEA *pPropSheetPage
    )
{
     //
    //  The client will have passed in m_fUseDriveOnTabName on construction.
    //  This tells us that we need to override the "General" tab name, with
    //  the drive description.  This feature is for the case where multiple
    //  drives are opened in a single property sheet.
    //
    
    if(m_fMultipleConsoles)
    {
        pPropSheetPage->dwFlags |= PSP_USETITLE;
        pPropSheetPage->pszTitle = m_szConsoleName;
    }
    pPropSheetPage->pszTemplate = MAKEINTRESOURCEA(IDD_CONSOLE_GENERAL);
}

//-----------------------------------------------------------
//  Security Page for Consoles
//-----------------------------------------------------------
CConsoleSecurityPage::CConsoleSecurityPage(
    IXboxConnection *pConnection, LPCSTR pszConsoleName
    ) : m_pConnection(pConnection), m_dwAccess(0),
        m_fLocked(FALSE),  m_fManageMode(FALSE),
        m_fSecureMode(FALSE), m_pUserAccessChangeList(NULL),
        m_iLastSelected(0), m_fUpdatingUI(FALSE)
{
    _ASSERT(m_pConnection);
    m_pConnection->AddRef();
    strcpy(m_szConsoleName, pszConsoleName);
}

BOOL
CConsoleSecurityPage::GetCaption(
    LPSTR szBuffer,
    ULONG ccBuffer
    )
{
    *szBuffer = '\0';
    return TRUE;
}

HRESULT CConsoleSecurityPage::InitSecuritySupport()
/*++
  Routine Description:  Determine if the box supports the security.  If so, figure out if the box
  is locked.  If it is locked determine if the current user has manage mode.  Then initialize all
  the data strucures as appropriate.
--*/
{
    HRESULT hr;


    //
    //  Is the box locked?
    //
    
    hr = m_pConnection->HrIsSecurityEnabled(&m_fLocked);
    if(FAILED(hr))
    {
        return hr;    
    }

    //
    //  If the box is not locked, check to see if it supports security
    //

    if(!m_fLocked)
    {
        //
        // Does this box support security?  Basically, send a security command supported in November to the
        // box, if it fails with XBDM_INVALIDCMD, then it doesn't support security.  You have to choose it
        // carefully.  HrGetUserAccess will work, but make sure you pass 
        //
        char szBuffer[255];
        DWORD dwSize = 255;
        hr = m_pConnection->HrSendCommand("GETUSERPRIV NAME=BOGUS", szBuffer, &dwSize);
        if(XBDM_INVALIDCMD == hr)
            return S_FALSE;

    } else    
    {
        //
        //  Find out what access we have.
        //  (Prior to build 4114 this didn't work, you got your
        //   machine name and asked about it.  However, this only
        //   worked if you manage permissions. So we try the new
        //   real way and then fall back to the old way - in which
        //   case you will see that you have no access, if you
        //   don't have manage.)
        //
        hr = m_pConnection->HrGetUserAccess(NULL, &m_dwAccess);
        if(XBDM_UNDEFINED == hr)
        {
            char szComputerName[MAX_COMPUTERNAME_LENGTH+1];
            DWORD dwComputerNameLength = sizeof(szComputerName);
            GetComputerNameA(szComputerName, &dwComputerNameLength);
            hr = m_pConnection->HrGetUserAccess(szComputerName, &m_dwAccess);
        }
        if(FAILED(hr))
        {
            m_dwAccess = 0;
        }
        if(m_dwAccess&DMPL_PRIV_MANAGE)
        {
            m_fManageMode  = TRUE;
            InitUserList();
        }
    }
    return S_OK;
}

HRESULT CConsoleSecurityPage::InitUserList()
{
    // Populate the user list.
    PDM_WALK_USERS      pdmWalkUsersList;
    DWORD               dwUserCount;
    HRESULT             hr;
    USER_ACCESS_CHANGE *pNewUser;
    
    hr=m_pConnection->HrOpenUserList(&pdmWalkUsersList, &dwUserCount);
    if(SUCCEEDED(hr))
    {
        while(dwUserCount-- && SUCCEEDED(hr))
        {
            pNewUser = new USER_ACCESS_CHANGE;
            if(pNewUser)
            {
                pNewUser->dwFlags = 0;
                hr = m_pConnection->HrWalkUserList(&pdmWalkUsersList, &pNewUser->dmUser);
                if(SUCCEEDED(hr))
                {
                    pNewUser->dwNewAccess = pNewUser->dmUser.AccessPrivileges;
                    pNewUser->pNextUser = m_pUserAccessChangeList;
                    m_pUserAccessChangeList = pNewUser;
                } else
                {
                    delete pNewUser;
                }
            } else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        m_pConnection->HrCloseUserList(pdmWalkUsersList);
    }
    return hr;
}


INT_PTR 
CConsoleSecurityPage::OnInitDialog(
    HWND hwndDefaultControl
    )
{
    
    //  Cache the handles of the commonly access children
    m_hWndAccess = GetDlgItem(m_hPropDlg, IDC_SECURITY_ACCESS); 
    m_hWndUsers = GetDlgItem(m_hPropDlg, IDC_SECURITY_USERLIST);

    // Add the name column for report view.
    LVCOLUMN lvc;
    lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_SUBITEM;
    lvc.fmt = LVCFMT_LEFT;
    lvc.pszText =  L"";
    lvc.cx = 175;
    lvc.iSubItem = 0;
    ListView_InsertColumn(m_hWndAccess, 0, &lvc);
    ListView_InsertColumn(m_hWndUsers, 0, &lvc);
    ListView_SetExtendedListViewStyle(m_hWndAccess, LVS_EX_CHECKBOXES);

    // Show and Hide the appropriate Windows, based on the
    ShowHideWindows();
    UpdateData();

    return OnSetActive();
}

INT_PTR CConsoleSecurityPage::OnSetActive()
{
    return 1;
}

void CConsoleSecurityPage::ShowHideWindows()
{
    //
    //  Turn the m_fLocked and m_fManageMode flags into
    //  show flags for the windows to hide or show.
    //
    int iLockedShow   = m_fLocked ? SW_SHOW : SW_HIDE;
    int iUnlockShow   = m_fLocked ? SW_HIDE : SW_SHOW;
    int iManageShow   = m_fManageMode ? SW_SHOW : SW_HIDE;
    int iNoManageShow = (m_fLocked && !m_fManageMode) ? SW_SHOW : SW_HIDE;
    
    // Items Visible only when unlocked
    ShowWindow(GetDlgItem(m_hPropDlg, IDC_SECURITY_UNLOCKED_TEXT), iUnlockShow);
    ShowWindow(GetDlgItem(m_hPropDlg, IDC_SECURITY_LOCK_BUTTON),   iUnlockShow);
    
    // Items Visible if Locked (regardless of manage mode versus not manage mode
    ShowWindow(m_hWndAccess, iLockedShow);
    ShowWindow(GetDlgItem(m_hPropDlg, IDC_SECURITY_ACCESS_TEXT), iLockedShow);
    
    // Items Visible only in managed mode.
    ShowWindow(m_hWndUsers, iManageShow);
    ShowWindow(GetDlgItem(m_hPropDlg, IDC_SECURITY_MACHINES),        iManageShow);
    ShowWindow(GetDlgItem(m_hPropDlg, IDC_SECURITY_ADD),             iManageShow);
    ShowWindow(GetDlgItem(m_hPropDlg, IDC_SECURITY_REMOVE),          iManageShow);
    ShowWindow(GetDlgItem(m_hPropDlg, IDC_SECURITY_UNLOCK),          iManageShow);
    ShowWindow(GetDlgItem(m_hPropDlg, IDC_SECURITY_CHANGE_PASSWORD), iManageShow);

    // Hide the password entry
    ShowWindow(GetDlgItem(m_hPropDlg, IDC_SECURITY_MANAGE_TEXT),     iNoManageShow);
    ShowWindow(GetDlgItem(m_hPropDlg, IDC_SECURITY_PASSWORD_TEXT),   iNoManageShow);
    ShowWindow(GetDlgItem(m_hPropDlg, IDC_SECURITY_PASSWORD_EDIT),   iNoManageShow);
    ShowWindow(GetDlgItem(m_hPropDlg, IDC_SECURITY_MANAGE_BUTTON),   iNoManageShow);
}

INT_PTR
CConsoleSecurityPage::OnCommand(WPARAM wParam, LPARAM lParam)
{
    UINT uControlId = LOWORD(wParam);
    UINT uCommand = HIWORD(wParam);

    //
    //  Look for button presses that require action
    //
    if (uCommand == BN_CLICKED) 
    { 
        switch(uControlId)
        {
            case IDC_SECURITY_ADD:
                _ASSERTE(m_fLocked && m_fManageMode);
                AddUser();
                break;
            case IDC_SECURITY_REMOVE:
                _ASSERTE(m_fLocked && m_fManageMode);
                RemoveUser();
                break;
            case IDC_SECURITY_UNLOCK:
                _ASSERTE(m_fLocked && m_fManageMode);
                UnLockConsole();
                break;
            case IDC_SECURITY_CHANGE_PASSWORD:
                _ASSERTE(m_fLocked && m_fManageMode);
                ChangePassword();
                break;
            case IDC_SECURITY_LOCK_BUTTON:
                _ASSERTE(!m_fLocked);
                LockConsole();
                break;
            case IDC_SECURITY_MANAGE_BUTTON:
                _ASSERTE(m_fLocked && !m_fManageMode);
                StartSecureMode();
                break;
            default:
                return FALSE;
        }
        return TRUE;
    }
    return FALSE;
}

INT_PTR
CConsoleSecurityPage::OnMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{    
    if(WM_NOTIFY==uMsg)
    {
        //Most of the paths below require that we now the currently
        //selected USER_ACCESS_CHANGE item
        INT iSelectedUser = ListView_GetNextItem(m_hWndUsers, -1, LVNI_ALL | LVNI_SELECTED);
        LVITEMA lvItem;
        memset(&lvItem, 0, sizeof(lvItem));
        lvItem.iItem = iSelectedUser;
        lvItem.iSubItem = 0;
        lvItem.mask = LVIF_PARAM;
        SendMessage(m_hWndUsers, LVM_GETITEMA, 0, (LPARAM)&lvItem);
        USER_ACCESS_CHANGE *pUserChangeItem = (USER_ACCESS_CHANGE *)lvItem.lParam;

        LPNMHDR pnmhdr = (LPNMHDR)lParam;
        if(pnmhdr->idFrom == IDC_SECURITY_ACCESS)
        {
            if(!m_fUpdatingUI) //Prevent us from changing our flags, because we are initializing things.
            {
                if(pnmhdr->code == LVN_ITEMCHANGED)
                {
                    NMLISTVIEW *pListView = (NMLISTVIEW *)pnmhdr;
                    DWORD dwAccessBit = (DWORD)pListView->lParam;
                    if(pUserChangeItem)
                    {
                        //Read the checked state, use it to update the access
                        //of the currently selected item.
                        if(ListView_GetCheckState(m_hWndAccess, pListView->iItem))
                        {
                            pUserChangeItem->dwNewAccess |= dwAccessBit;
                        } else
                        {
                            pUserChangeItem->dwNewAccess &= ~dwAccessBit;
                        }
                        SetApplyButton();
                      }
                }
            }
        } else if(pnmhdr->idFrom == IDC_SECURITY_USERLIST)
        {
            if(NM_CLICK==pnmhdr->code)
            {
                if(-1 == iSelectedUser)
                {
                    if(m_pUserAccessChangeList)
                    {
                        iSelectedUser = m_iLastSelected;
                        ListView_SetItemState(m_hWndUsers, iSelectedUser, LVIS_SELECTED, LVIS_SELECTED);
                    }
                } else
                {
                    m_iLastSelected = iSelectedUser;
                    if(pUserChangeItem)
                    {
                        // Update the Access Info based on the new selection
                        UpdateAccessInfo(pUserChangeItem->dmUser.UserName, pUserChangeItem->dwNewAccess);
                        return TRUE;
                    }
                }
            }
        }
    }
    return 0;
}

void 
CConsoleSecurityPage::CompletePropSheetPage(
    PROPSHEETPAGEA *pPropSheetPage
    )
{
    pPropSheetPage->pszTemplate = MAKEINTRESOURCEA(IDD_CONSOLE_SECURITY);
}

void CConsoleSecurityPage::AddUser()
{
    char szUserName[255];
    int  iItem;
    if(IDOK==Dialog::PromptUserName(m_hPropDlg, szUserName, sizeof(szUserName)))
    {
        // Look to see if the user is in our list
        USER_ACCESS_CHANGE *pNewUser;
        pNewUser = m_pUserAccessChangeList;
        while(pNewUser)
        {
            if(0==_stricmp(pNewUser->dmUser.UserName, szUserName))
            {
                // Found a match, this user is already in our list.

                // See if it is marked remove, this means that it does
                // not appear in the UI, as it will be removed when changes
                // are applied.  In this case, we clear the remove flag
                // and reset the permissions, then we have to add
                if(pNewUser->dwFlags & UACF_REMOVE)
                {
                    pNewUser->dwFlags &= ~UACF_REMOVE;
                    break;
                } else
                {
                    // The user is already in the list, and displayed in the UI.  So this is user error.
                    // What to do?  We could a) show a message telling the user that they are blind and
                    // that the machine is already in the list, or b) we could just shift focus to the
                    // machine in the list, or c) do both a) and b).  I like b) for now.
                    LVFINDINFO findInfo;
                    findInfo.flags = LVFI_PARAM;
                    findInfo.lParam = (LPARAM)pNewUser;
                    iItem = SendMessage(m_hWndUsers, LVM_FINDITEM, -1, (LPARAM)&findInfo);
                    _ASSERT(-1 != iItem);  //Indicates that are logic screwed up somewhere.
                    ListView_SetItemState(m_hWndUsers, iItem, LVIS_SELECTED, LVIS_SELECTED);
                    m_iLastSelected = iItem;
                    UpdateAccessInfo(pNewUser->dmUser.UserName, pNewUser->dwNewAccess);
                    //we are done, go home
                    return;
                }
            }
            pNewUser = pNewUser->pNextUser;
        }

        // We didn't have the item in our list yet.
        if(!pNewUser)
        {
            pNewUser = new USER_ACCESS_CHANGE;
            if(!pNewUser)
            {
                WindowUtils::MessageBoxResource(m_hPropDlg, IDS_ERROR_LOW_MEMORY, IDS_GENERIC_CAPTION, MB_OK|MB_ICONSTOP);
                return;
            }
            pNewUser->dwFlags = UACF_ADD;
            strcpy(pNewUser->dmUser.UserName, szUserName);
            pNewUser->dmUser.AccessPrivileges = 0;
            pNewUser->dwNewAccess = DMPL_PRIV_INITIAL;
            pNewUser->pNextUser = m_pUserAccessChangeList;
            m_pUserAccessChangeList = pNewUser;
        }

        // We get here only if the user was in the list, but marked UACF_REMOVE, or if we just
        // added it to the list.  Either way, it is not in the list view, so we should add it.
        LVITEMA lvItem;
        memset(&lvItem, 0, sizeof(lvItem));
        lvItem.mask = LVIF_PARAM | LVIF_TEXT;
        lvItem.iItem = -1;
        lvItem.iSubItem = 0;
        lvItem.pszText = pNewUser->dmUser.UserName; 
        lvItem.cchTextMax = sizeof(pNewUser->dmUser.UserName);  
        lvItem.lParam = (LPARAM)pNewUser;
        iItem = SendMessage(m_hWndUsers, LVM_INSERTITEMA, 0, (LPARAM)&lvItem);
        _ASSERT(-1!=iItem);
        //Now that it is added, set focus to it, and update the check marks.
        ListView_SetItemState(m_hWndUsers, iItem, LVIS_SELECTED, LVIS_SELECTED);
        m_iLastSelected = iItem;
        UpdateAccessInfo(pNewUser->dmUser.UserName, pNewUser->dwNewAccess);
        SetApplyButton();
    }
}

void CConsoleSecurityPage::RemoveUser()
{
    USER_ACCESS_CHANGE *pUserChangeItem;
    LVITEMA lvItem;

    //Get the selected user
    INT iSelectedUser = ListView_GetNextItem(m_hWndUsers, -1, LVNI_ALL | LVNI_SELECTED);
    _ASSERTE(-1 != iSelectedUser);

    //Get the Selected item
    memset(&lvItem, 0, sizeof(lvItem));
    lvItem.iItem = iSelectedUser;
    lvItem.iSubItem = 0;
    lvItem.mask = LVIF_PARAM;
    SendMessage(m_hWndUsers, LVM_GETITEMA, 0, (LPARAM)&lvItem);
    pUserChangeItem = (USER_ACCESS_CHANGE *)lvItem.lParam;

    //Remove the item from the list (removing it from the display).
    ListView_DeleteItem(m_hWndUsers, iSelectedUser);
     
    //Mark the item for removal, when apply is hit.
    pUserChangeItem->dwFlags |= UACF_REMOVE;

    // Now set focus, on the new item that took its place.
    int itemCount = ListView_GetItemCount(m_hWndUsers);
    if(itemCount)
    {
        if(iSelectedUser >= itemCount) iSelectedUser--;
        ListView_SetItemState(m_hWndUsers, iSelectedUser, LVIS_SELECTED, LVIS_SELECTED);
        m_iLastSelected = iSelectedUser;

        // Get the newly selected item
        memset(&lvItem, 0, sizeof(lvItem));
        lvItem.iItem = iSelectedUser;
        lvItem.iSubItem = 0;
        lvItem.mask = LVIF_PARAM;
        SendMessage(m_hWndUsers, LVM_GETITEMA, 0, (LPARAM)&lvItem);
        pUserChangeItem = (USER_ACCESS_CHANGE *)lvItem.lParam;
    
        // Update the Access Info based on the new selection
        UpdateAccessInfo(pUserChangeItem->dmUser.UserName, pUserChangeItem->dwNewAccess);
    } else
    {
        UpdateAccessInfo("", 0);
        EnableWindow(m_hWndAccess, FALSE);
    }
    SetApplyButton();
}

void CConsoleSecurityPage::UnLockConsole()
{
    //Show Unlock Warning
    if(
        IDOK==WindowUtils::MessageBoxResource(
                    m_hPropDlg, IDS_SECURITY_UNLOCK_WARNING,
                    IDS_SECURITY_UNLOCK_WARNING_CAPTION, MB_OKCANCEL| MB_ICONINFORMATION,
                    m_szConsoleName)
    ){
        HRESULT hr;

        //Do the unlock.
        hr = m_pConnection->HrEnableSecurity(FALSE);
        if(SUCCEEDED(hr))
        {
            // The box is unlocked - delete the data we've got
            m_fLocked = FALSE;
            m_fManageMode = FALSE;
            m_fSecureMode = FALSE;
            m_dwAccess = 0;
            DeleteUserList();   //Forget about the users
            ShowHideWindows();  //Switch the UI
            UpdateData();       //Update the data (this will delete everything from the list view).
            
            // Now any changes to this page are effectively applied, so tell the propsheet.
            SendMessage(GetParent(m_hPropDlg), PSM_UNCHANGED, (WPARAM)m_hPropDlg, (LPARAM)0);
        } else
        {
            char szError[60];
            FormatUtils::XboxErrorString(hr, szError, sizeof(szError));
            WindowUtils::MessageBoxResource(m_hPropDlg, IDS_COULDNT_UNLOCK_CONSOLE, IDS_GENERIC_CAPTION, MB_OK|MB_ICONSTOP, m_szConsoleName,szError);
        }
    }
}

void CConsoleSecurityPage::ChangePassword()
{
    char szNewPassword[255];
    int  iItem;
    if(IDOK==Dialog::PromptNewPassword(m_hPropDlg, szNewPassword, sizeof(szNewPassword)))
    {
        HRESULT hr = m_pConnection->HrSetAdminPassword(szNewPassword);
        if(SUCCEEDED(hr))
        {
            WindowUtils::MessageBoxResource(m_hPropDlg, IDS_PASSWORD_SET, IDS_PASSWORD_SET_CAPTION, MB_OK, m_szConsoleName);
        } else
        {
            char szError[60];
            FormatUtils::XboxErrorString(hr, szError, sizeof(szError));
            WindowUtils::MessageBoxResource(m_hPropDlg, IDS_COULDNT_SET_PASSWORD, IDS_PASSWORD_SET_CAPTION, MB_OK|MB_ICONSTOP, m_szConsoleName, szError);
        }
    }
}

void CConsoleSecurityPage::LockConsole()
{
    //Show Lock Warning
    if(
        IDOK==WindowUtils::MessageBoxResource(
                    m_hPropDlg, IDS_SECURITY_LOCK_WARNING,
                    IDS_SECURITY_LOCK_WARNING_CAPTION, MB_OKCANCEL| MB_ICONINFORMATION,
                    m_szConsoleName)
    ){
        HRESULT hr;

        //Do the unlock.
        hr = m_pConnection->HrUseSharedConnection(TRUE);
        if(SUCCEEDED(hr))
        {
            hr = m_pConnection->HrEnableSecurity(TRUE);
            if(SUCCEEDED(hr))
            {
                char szComputerName[MAX_COMPUTERNAME_LENGTH+1];
                DWORD dwComputerNameLength = sizeof(szComputerName);
                GetComputerNameA(szComputerName, &dwComputerNameLength);
                hr = m_pConnection->HrAddUser(szComputerName, DMPL_PRIV_ALL);
                if(SUCCEEDED(hr))
                {
                    // The box is locked, we should have manage permission now.
                    m_fLocked = TRUE;
                    m_fManageMode = TRUE;
                    m_fSecureMode = FALSE;
                    m_dwAccess = DMPL_PRIV_ALL;
                    InitUserList();      //Update the data.
                    UpdateData();       //Update the data
                    ShowHideWindows();  //Switch the UI
                }            
                // Now any changes to this page are effectively applied, so tell the propsheet.
                SendMessage(GetParent(m_hPropDlg), PSM_UNCHANGED, (WPARAM)m_hPropDlg, (LPARAM)0);
            } else
            {
                //Try unlocking if we couldn't set a user, for whatever good it will do.
                m_pConnection->HrEnableSecurity(FALSE);
            }
            hr = m_pConnection->HrUseSharedConnection(FALSE);
        }

        if(FAILED(hr))
        {
            char szError[60];
            FormatUtils::XboxErrorString(hr, szError, sizeof(szError));
            WindowUtils::MessageBoxResource(m_hPropDlg, IDS_COULDNT_LOCK_CONSOLE, IDS_GENERIC_CAPTION, MB_OK|MB_ICONSTOP, m_szConsoleName,szError);
        }
    }
}

void CConsoleSecurityPage::StartSecureMode()
{
    char szPassword[MAX_PATH];
    HRESULT hr;
    GetDlgItemTextA(m_hPropDlg, IDC_SECURITY_PASSWORD_EDIT, szPassword, MAX_PATH);
    hr = m_pConnection->HrUseSharedConnection(TRUE);
    if(SUCCEEDED(hr))
    {
        hr = m_pConnection->HrUseSecureConnection(szPassword);
        if(SUCCEEDED(hr))
        {
            m_fSecureMode = TRUE;
            m_fManageMode = TRUE;
            InitUserList();
            ShowHideWindows();
            UpdateData();
        }
    }

    if(FAILED(hr))
    {
        char szErrorString[80];
        FormatUtils::XboxErrorString(hr, szErrorString, sizeof(szErrorString));
        WindowUtils::MessageBoxResource(m_hPropDlg, IDS_SECURE_CONNECTION_FAILED, IDS_GENERIC_CAPTION, MB_ICONSTOP|MB_OK, m_szConsoleName, szErrorString);
    }
}

void CConsoleSecurityPage::DeleteUserList()
{
    while(m_pUserAccessChangeList)
    {
        USER_ACCESS_CHANGE   *pTemp = m_pUserAccessChangeList;
        m_pUserAccessChangeList =  pTemp->pNextUser;
        delete pTemp;
    }
}

static DWORD AccessBitFromResource(int i)
{
    switch(i)
    {
      case IDS_PERMISSION_READ:
          return DMPL_PRIV_READ;
      case IDS_PERMISSION_WRITE:
          return DMPL_PRIV_WRITE;
      case IDS_PERMISSION_MANAGE:
          return DMPL_PRIV_MANAGE;
      case IDS_PERMISSION_CONFIGURE:
          return DMPL_PRIV_CONFIGURE;
      case IDS_PERMISSION_CONTROL:
          return DMPL_PRIV_CONTROL;
    }
    return 0;
}

void CConsoleSecurityPage::UpdateData()
{
    USER_ACCESS_CHANGE *pUserChangeItem;
    LVITEMA lvItem;
    ListView_DeleteAllItems(m_hWndAccess);
    ListView_DeleteAllItems(m_hWndUsers);
    
    int iItem = 0;

    if(m_fLocked)
    {
        if(m_fManageMode)
        {
            char szAccessName[60];
            for(int i=IDS_PERMISSION_READ; i <= IDS_PERMISSION_MANAGE; i++)
            {
                LoadStringA(_Module.GetModuleInstance(), i, szAccessName, sizeof(szAccessName));
                lvItem.mask = LVIF_PARAM | LVIF_TEXT;
                lvItem.iItem = PERMISSION_LISTVIEW_INDEX(i); //Just a big value.
                lvItem.iSubItem = 0;
                lvItem.lParam = AccessBitFromResource(i);
                lvItem.pszText = szAccessName;
                lvItem.cchTextMax = sizeof(pUserChangeItem->dmUser.UserName);
                SendMessage(m_hWndAccess, LVM_INSERTITEMA, 0, (LPARAM)&lvItem);
            }
            ListView_SetItemState(m_hWndAccess, iItem, LVIS_SELECTED, LVIS_SELECTED);
            pUserChangeItem = m_pUserAccessChangeList;
            while(pUserChangeItem)
            {
                if(!(UACF_REMOVE&pUserChangeItem->dwFlags))
                {
                    memset(&lvItem, 0, sizeof(lvItem));
                    lvItem.mask = LVIF_PARAM | LVIF_TEXT;
                    lvItem.iItem = iItem++;
                    lvItem.iSubItem = 0;
                    lvItem.pszText = pUserChangeItem->dmUser.UserName; 
                    lvItem.cchTextMax = sizeof(pUserChangeItem->dmUser.UserName);  
                    lvItem.lParam = (LPARAM)pUserChangeItem;
                    SendMessage(m_hWndUsers, LVM_INSERTITEMA, 0, (LPARAM)&lvItem);
                }
                pUserChangeItem = pUserChangeItem->pNextUser;
            }
            //  Select the first user.
            ListView_SetItemState(m_hWndUsers, 0, LVIS_SELECTED, LVIS_SELECTED);
            m_iLastSelected = 0;
            memset(&lvItem, 0, sizeof(lvItem));
            lvItem.mask = LVIF_PARAM;
            SendMessage(m_hWndUsers, LVM_GETITEMA, 0, (LPARAM)&lvItem);
            pUserChangeItem = (USER_ACCESS_CHANGE *)lvItem.lParam;
            if(pUserChangeItem)
            {
                UpdateAccessInfo(pUserChangeItem->dmUser.UserName, pUserChangeItem->dwNewAccess);
            }
        } else
        {
            char szThisComputer[40];
            LoadStringA(_Module.GetModuleInstance(), IDS_LITERAL_THIS_COMPUTER, szThisComputer, sizeof(szThisComputer));
            UpdateAccessInfo(szThisComputer, m_dwAccess, FALSE);
        }
    }
}

void CConsoleSecurityPage::UpdateAccessInfo(LPCSTR UserName, DWORD dwAccess, BOOL fEnable)
{
    //Set the Permissions for
    char szBuffer[255];
    WindowUtils::rsprintf(szBuffer, IDS_SECURITY_PERMISSIONS_FOR, UserName);
    SetWindowTextA(GetDlgItem(m_hPropDlg, IDC_SECURITY_ACCESS_TEXT), szBuffer);
    m_fUpdatingUI = TRUE;
    //Set all of the check boxes.
    ListView_SetCheckState(m_hWndAccess, PERMISSION_LISTVIEW_INDEX(IDS_PERMISSION_READ),
                           (dwAccess&DMPL_PRIV_READ ? TRUE : FALSE));
    ListView_SetCheckState(m_hWndAccess, PERMISSION_LISTVIEW_INDEX(IDS_PERMISSION_WRITE),
                           (dwAccess&DMPL_PRIV_WRITE ? TRUE : FALSE));
    ListView_SetCheckState(m_hWndAccess, PERMISSION_LISTVIEW_INDEX(IDS_PERMISSION_CONFIGURE),
                           (dwAccess&DMPL_PRIV_CONFIGURE ? TRUE : FALSE));
    ListView_SetCheckState(m_hWndAccess, PERMISSION_LISTVIEW_INDEX(IDS_PERMISSION_CONTROL),
                           (dwAccess&DMPL_PRIV_CONTROL ? TRUE : FALSE));
    ListView_SetCheckState(m_hWndAccess, PERMISSION_LISTVIEW_INDEX(IDS_PERMISSION_MANAGE),
                           (dwAccess&DMPL_PRIV_MANAGE ? TRUE : FALSE));
    EnableWindow(m_hWndAccess, fEnable);
    m_fUpdatingUI = FALSE;
}


#define UACF_ADDANDREMOVE (UACF_ADD|UACF_REMOVE)  

void CConsoleSecurityPage::SetApplyButton()
{
    // Walk through the change list, and find out if there
    // is anything that needs to be applied.
    //
    // Add, Remove, and changed permissions.
    BOOL fEnableApply = FALSE;
    USER_ACCESS_CHANGE *pUserChangeItem;
    pUserChangeItem = m_pUserAccessChangeList;
    while(pUserChangeItem)
    {
        // If add and remove are both set, the item does not require work on apply,
        // it is just tracking access, so if the user adds it back then we remember
        // the last known access. Cool, eh? So we skip these.
        if(UACF_ADDANDREMOVE != (UACF_ADDANDREMOVE&pUserChangeItem->dwFlags))
        {
            // If either add or remove are set (we ruled out both)
            // Then we need  to enable apply
            if(UACF_ADDANDREMOVE&pUserChangeItem->dwFlags)
            {
                fEnableApply = TRUE;
                break;
            }
            //If the original permissions are different from the
            //new permissions, we need to apply
            if(pUserChangeItem->dmUser.AccessPrivileges != pUserChangeItem->dwNewAccess)
            {
                // we only need one reasons to enable apply
                // no point in search for others.
                fEnableApply = TRUE;
                break;
            }
        }
        //If we are here, we haven't found a reason to enable apply,
        //keep looking.
        pUserChangeItem = pUserChangeItem->pNextUser;
    }

    // Set the apply button, one way or the other.
    SendMessage(GetParent(m_hPropDlg), fEnableApply ? PSM_CHANGED : PSM_UNCHANGED, (WPARAM)m_hPropDlg, (LPARAM)0);
}

bool CConsoleSecurityPage::OnApply(bool fClose)
{
    //If we are not in manage mode there is nothing to apply
    if(!m_fManageMode) return true;
    
    //
    //  Allowing apply.
    //  1) We don't want to allow a locked box that noone has manage privileges to.  So the UI will pop-up an
    //     error on OK or APPLY, if this would happen by applying the changes.  They will be able to get around
    //     this with the xbManage command line tool, but only more sophisticated users will even try that.
    //
    //  2) We apply all the changes, or stop if an error occurs.  To avoid leaving noone with manage privileges,
    //     as soon as we find a user that will have manage privileges after the apply, we move it to the front of
    //     the list.
    //
    //  3) One of the changes may be to take away our own manage privileges.  To avoid not being able to complete
    //     the task, we switch our interface over into shared mode before applying the first change(if it is not already in secure mode).
    //

    HRESULT hr;
    BOOL fSomeoneCanManage = FALSE;
    USER_ACCESS_CHANGE *pUserItem;
    USER_ACCESS_CHANGE *pUserPreviousItem;

    pUserPreviousItem = NULL;
    pUserItem = m_pUserAccessChangeList;
    while(pUserItem)
    {
        //If the item does not have the remove flag it will be here after apply.
        if(!(UACF_REMOVE&pUserItem->dwFlags))
        {
            //Check if the new access, will include manage.
            if(pUserItem->dwNewAccess&DMPL_PRIV_MANAGE)
            {
                fSomeoneCanManage = TRUE;
                //The first item in our list before attempting to apply should
                //be an item with manage privilege.
                if(pUserPreviousItem)
                {
                    pUserPreviousItem->pNextUser = pUserItem->pNextUser;
                    pUserItem->pNextUser = m_pUserAccessChangeList;
                    m_pUserAccessChangeList = pUserItem;
                }
                break;
            }
        }
        pUserPreviousItem = pUserItem;
        pUserItem = pUserItem->pNextUser;
    }

    if(!fSomeoneCanManage)
    {
        // If we apply this, there will not be a single user who may manage.
        // Tell the user no way.
        WindowUtils::MessageBoxResource(NULL, IDS_CANNOT_REMOVE_LAST_MANAGER, IDS_GENERIC_CAPTION, MB_OK|MB_ICONSTOP, m_szConsoleName);
        // Don't let the user close the dialog.
        return false;
    }

    // Now let's go ahead and apply changes.
    hr = S_OK;
    if(!m_fSecureMode)
        hr = m_pConnection->HrUseSharedConnection(TRUE);
    
    //Make sure that our connection is shared.
    if(SUCCEEDED(hr))
    {
        pUserPreviousItem = NULL;
        pUserItem = m_pUserAccessChangeList;
        while(pUserItem)
        {
            //If the remove flag is set, we need MAY need to remove it.
            if(pUserItem->dwFlags&UACF_REMOVE)
            {
                //If the Add flag is set, then this user was added since
                //changes were last applied, and no need to remove them
                if(!(pUserItem->dwFlags&UACF_ADD))
                {
                    hr = m_pConnection->HrRemoveUser(pUserItem->dmUser.UserName);
                    if(FAILED(hr)) break;
                }
                // Remove delete this item from our change list, since
                // the console no longer exists.
                if(pUserPreviousItem)
                    pUserPreviousItem->pNextUser = pUserItem->pNextUser;
                else
                    m_pUserAccessChangeList = pUserItem->pNextUser;
                // The previous item doesn't change, so just update
                // user item and continue.
                pUserItem = pUserItem->pNextUser;
                continue;
            }
            
            //If the add flag is set, then we need to add it (notice that if the
            //remove flag was set, we didn't fall through to here)
            if(pUserItem->dwFlags&UACF_ADD)
            {
                hr = m_pConnection->HrAddUser(pUserItem->dmUser.UserName, pUserItem->dwNewAccess);
                if(FAILED(hr)) break;
                pUserItem->dmUser.AccessPrivileges = pUserItem->dwNewAccess;
                pUserItem->dwFlags &= ~UACF_ADD;
            } else if(pUserItem->dmUser.AccessPrivileges != pUserItem->dwNewAccess)
            {
                hr = m_pConnection->HrSetUserAccess(pUserItem->dmUser.UserName, pUserItem->dwNewAccess);
                if(FAILED(hr)) break;
                pUserItem->dmUser.AccessPrivileges = pUserItem->dwNewAccess;
            }
            pUserPreviousItem = pUserItem;
            pUserItem = pUserItem->pNextUser;
        }
        // done with the shared conneciton.
        if(!m_fSecureMode)
            m_pConnection->HrUseSharedConnection(FALSE);
    }

    // Reset the Apply Button
    SetApplyButton();

    // Recheck that we have manage permissions, if we don't switch out of this mode.
    if(!m_fSecureMode)
    {
            //  Find out what access we have.
            //  (Prior to build 4114 this didn't work, you got your
            //   machine name and asked about it.  However, this only
            //   worked if you manage permissions. So we try the new
            //   real way and then fall back to the old way - in which
            //   case you will see that you have no access, if you
            //   don't have manage.)
            //
            m_dwAccess = 0;
            if(SUCCEEDED(m_pConnection->HrGetUserAccess(NULL, &m_dwAccess)))
            {
                char szComputerName[MAX_COMPUTERNAME_LENGTH+1];
                DWORD dwComputerNameLength = sizeof(szComputerName);
                GetComputerNameA(szComputerName, &dwComputerNameLength);
                m_pConnection->HrGetUserAccess(szComputerName, &m_dwAccess);
            }
            if(!(DMPL_PRIV_MANAGE&m_dwAccess))
            {
                m_fManageMode = FALSE;
                DeleteUserList();   //Forget about the users
                ShowHideWindows();  //Switch the UI
                UpdateData();
            }
    }


    if(FAILED(hr))
    {
        char szError[60];
        FormatUtils::XboxErrorString(hr, szError, sizeof(szError));
        WindowUtils::MessageBoxResource(m_hPropDlg, IDS_COULDNT_APPLY_SECURITY_CHANGES, IDS_GENERIC_CAPTION, MB_OK|MB_ICONSTOP, szError);
        return false;
    }
    
    return true;
}

//-----------------------------------------------------------
//  Settings Page for Consoles
//-----------------------------------------------------------
CConsoleSettingsPage::CConsoleSettingsPage(
    IXboxConnection *pConnection
    ) : m_pConnection(pConnection)
{
    _ASSERT(m_pConnection);
    m_pConnection->AddRef();
}

BOOL
CConsoleSettingsPage::GetCaption(
    LPSTR szBuffer,
    ULONG ccBuffer
    )
{
    *szBuffer = '\0';
    return TRUE;
}

INT_PTR 
CConsoleSettingsPage::OnInitDialog(
    HWND hwndDefaultControl
    )
{
    return 1;
}

void 
CConsoleSettingsPage::CompletePropSheetPage(
    PROPSHEETPAGEA *pPropSheetPage
    )
{
    pPropSheetPage->pszTemplate = MAKEINTRESOURCEA(IDD_CONSOLE_SETTING);
}

//-----------------------------------------------------------
//  Advanced Page for Consoles
//-----------------------------------------------------------
CConsoleAdvancedPage ::CConsoleAdvancedPage(
    IXboxConnection *pConnection,
    LPCSTR           pszConsoleName
    ) : m_pConnection(pConnection)
{
    _ASSERT(m_pConnection);
    m_pConnection->AddRef();
    strcpy(m_szConsoleName, pszConsoleName);
}

BOOL
CConsoleAdvancedPage::GetCaption(
    LPSTR szBuffer,
    ULONG ccBuffer
    )
{
    *szBuffer = '\0';
    return TRUE;
}

INT_PTR 
CConsoleAdvancedPage::OnInitDialog(
    HWND hwndDefaultControl
    )
{
    HWND hWndCtrl;

    // The default state for warm boot is checked
    CheckDlgButton(m_hPropDlg, IDC_WARMBOOT, BST_CHECKED);
    return 1;
}


void 
CConsoleAdvancedPage::CompletePropSheetPage(
    PROPSHEETPAGEA *pPropSheetPage
    )
{
    pPropSheetPage->pszTemplate = MAKEINTRESOURCEA(IDD_CONSOLE_ADVANCED);
}

INT_PTR
CConsoleAdvancedPage::OnCommand(WPARAM wParam, LPARAM lParam)
{
    UINT uControlId = LOWORD(wParam);
    UINT uCommand = HIWORD(wParam);
    HRESULT hr;

    //
    //  Look for button presses that require action
    //
    if ( uCommand == BN_CLICKED) 
    { 
        //
        //  If the reboot button was pressed, read the control with the
        //  boot parameters and perform the reboot.
        //
        if(uControlId==IDC_REBOOT)
        {
           CWaitCursor waitCursor;
           DM_XBE dmXbe;
           LPCSTR pszLaunchTitle = NULL;
           DWORD dwFlags = 0;
           //  Get the state of IDC_WARMBOOT, and of IDC_RUNNINGTITLE
           if(IsDlgButtonChecked(m_hPropDlg, IDC_WARMBOOT))
           {
             dwFlags = DMBOOT_WARM;
           }
           
           if(IsDlgButtonChecked(m_hPropDlg, IDC_RUNNINGTITLE))
           {
             hr = m_pConnection->HrGetXbeInfo(NULL, &dmXbe);
             if(SUCCEEDED(hr))
             {
                pszLaunchTitle = dmXbe.LaunchPath;
             }
             // The error case is hit when the dash is running, this is not
             // really an error, pszLaunchTitle will be NULL, and we reboot
             // into the default title as expected.
           }
           hr = m_pConnection->HrReboot(dwFlags, pszLaunchTitle);
           if(FAILED(hr))
           {
                char szError[60];
                FormatUtils::XboxErrorString(hr, szError, sizeof(szError));
                WindowUtils::MessageBoxResource(m_hPropDlg, IDS_COULDNT_REBOOT, IDS_GENERIC_CAPTION, MB_OK|MB_ICONSTOP, m_szConsoleName, szError);
           }
           return TRUE;
        }

        //
        //  If the IDC_CAPTURE button was pressed, do a screen capture.
        //
        else if(uControlId==IDC_CAPTURE)
        {
            Utils::ScreenCapture(m_hPropDlg, m_szConsoleName);
            return TRUE;
        }
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbshlext\prop.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    prop.h

Abstract:

    Class definitions for property page dialogs.

Environment:

    Windows 2000 and Later 
    User Mode

Revision History:
    
    05-27-2001 : created (mitchd)

--*/


//
//
//

const UINT WM_PROPPAGE_REFRESH_CONTENTS=WM_APP+1;
const UINT MAX_CONSOLE_PAGES=4; //There are four console pages


class CPropertyPage;

struct PropertyPageInfo
{
    PropertyPageInfo():pPropertyPage(NULL){}
    ~PropertyPageInfo();
    CPropertyPage *pPropertyPage;  // Pointer to a property Page
};

class CXboxPropertySheet : public IXboxVisitor
{
  public:
    CXboxPropertySheet() : 
        m_uMaxPages(0),
        m_uPageCount(0),
        m_pPages(NULL),
        m_pPropSheetPages(NULL),
        m_hrInitialize(E_FAIL)
        {}
    ~CXboxPropertySheet() {delete [] m_pPages; delete [] m_pPropSheetPages;}

    /*
    ** IXboxVisitor
    */
    
    void VisitRoot(IXboxVisit *pRoot, DWORD *pdwFlags);
    void VisitAddConsole(IXboxVisit *pAddConsole, DWORD *pdwFlags);
    void VisitConsole(IXboxConsoleVisit *pConsole, DWORD *pdwFlags);
    void VisitVolume(IXboxVolumeVisit *pVolume, DWORD *pdwFlags);
    void VisitFileOrDir(IXboxFileOrDirVisit *pFileOrDir, DWORD *pdwFlags);
    void VisitDirectoryPost (IXboxFileOrDirVisit *pFileOrDir, DWORD *pdwFlags) {_ASSERTE(FALSE);}

    HRESULT Initialize(UINT uItemCount, CXboxFolder *pSelection);
    HRESULT DoProperties(UINT uStartPage, HWND hwndParent);
    void AddPage(CPropertyPage *pPage);

  private:

    static DWORD ThreadProcStart(LPVOID pvThis) {return ((CXboxPropertySheet *)pvThis)->ThreadProc();}
    DWORD ThreadProc();

    UINT              m_uItemCount;
    UINT              m_uMaxPages;
    UINT              m_uPageCount;
    PropertyPageInfo *m_pPages;
    PROPSHEETPAGEA   *m_pPropSheetPages;
    char              m_szCaption[MAX_PATH];
    CXboxFolder      *m_pSelection;
    BOOL              m_fFirstVisit;
    HWND              m_hWndParent;
    UINT              m_uStartPage;

    //Outlaw Copy C'tor and Assignment
    CXboxPropertySheet(const CXboxPropertySheet&);
    CXboxPropertySheet& operator=(const CXboxPropertySheet&);

    HRESULT m_hrInitialize;
};

class CPropertyPage
{
  public:
    CPropertyPage() : m_hPropDlg(NULL){}
    virtual BOOL GetCaption(LPSTR szBuffer, ULONG ccBuffer) {return FALSE;}

  protected:
    virtual INT_PTR OnInitDialog(HWND hwndDefaultControl) = 0;
    virtual INT_PTR OnCommand(WPARAM wParam, LPARAM lParam);
    virtual INT_PTR OnMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);
    virtual INT_PTR OnDrawItem(UINT uItem, LPDRAWITEMSTRUCT pDrawItem) {return 0;}
    virtual bool    OnApply(bool fClose) {return true;}
    virtual INT_PTR OnSetActive() {return 0;}

    static INT_PTR CALLBACK DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

    HWND m_hPropDlg;
    virtual void CompletePropSheetPage(PROPSHEETPAGEA *pPropSheetPage) = 0;
    
  private:

    void FilloutPropSheetPage(PROPSHEETPAGEA *pPropSheetPage);
    CXboxPropertySheet *pParent;
    friend class CXboxPropertySheet;
};


class CVolumeGeneralPage : public CPropertyPage
/*++
  Class Description:
    Implements one of three general property pages:
      File, Folder, or Multiple Items.  These pages
      are similar enough, that it is basically just
      a different template a few branches.
--*/
{
    public:
      CVolumeGeneralPage(
          LPSTR     pszDriveDescription,
          ULONGLONG ullTotalSpace,
          ULONGLONG ullFreeSpace,
          UINT      uVolumeType,
          BOOL      fDriveOnTab
          ) : m_ullTotalSpace(ullTotalSpace), m_ullFreeSpace(ullFreeSpace),
              m_uVolumeType(uVolumeType), m_fDriveOnTab(fDriveOnTab), 
              m_dwPieShadowHgt(0)
      {
          strcpy(m_szDriveDescription,pszDriveDescription); 
      }

      virtual BOOL GetCaption(LPSTR szBuffer, ULONG ccBuffer);
    protected:
      virtual INT_PTR OnInitDialog(HWND hwndDefaultControl);
      virtual INT_PTR OnDrawItem(UINT uItem, LPDRAWITEMSTRUCT pDrawItem);
      virtual void CompletePropSheetPage(PROPSHEETPAGEA *pPropSheetPage);
    private:
      void DrawColorRect(HDC hdc, COLORREF crDraw, const RECT *prc);

      ULONGLONG m_ullTotalSpace;
      ULONGLONG m_ullFreeSpace;
      UINT      m_uVolumeType;
      BOOL      m_fDriveOnTab;
      DWORD     m_dwPieShadowHgt;
      char      m_szDriveDescription[40];
};

class CFSItemGeneralPage : public CPropertyPage
/*++
  Class Description:
    Implements one of three general property pages:
      File, Folder, or Multiple Items.  These pages
      are similar enough, that it is basically just
      a different template a few branches.
--*/
{
    public:

       CFSItemGeneralPage(
           CXboxFolder         *pSelection,
           IXboxFileOrDirVisit *pFileOrDir,
           UINT                 uItemCount
           );
      ~CFSItemGeneralPage() {_ASSERTE(m_pSelection); m_pSelection->Release(); m_pSelection=NULL;}
      virtual BOOL GetCaption(LPSTR szBuffer, ULONG ccBuffer);

    protected:
      
      virtual INT_PTR OnInitDialog(HWND hwndDefaultControl);
      virtual void CompletePropSheetPage(PROPSHEETPAGEA *pPropSheetPage);
      virtual INT_PTR OnCommand(WPARAM wParam, LPARAM lParam);
      virtual INT_PTR OnMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);
      virtual bool    OnApply(bool fClose);

      static DWORD StartThreadProc(PVOID pvThis) {return ((CFSItemGeneralPage *)pvThis)->ThreadProc();}
      DWORD ThreadProc();
      static bool GetAttributesCallback(PVOID pvThis, XBOX_MULTIFILE_ATTRIBUTES *pMultiFileAttributes);

      void SynchronizeUpdateThread();

    private:

      CXboxFolder               *m_pSelection;
      char                      m_szNameBuffer[MAX_PATH];
      char                      m_szLocation[MAX_XBOX_PATH];
      bool                      m_fNameChanged;
      bool                      m_fReadOnlyChanged;
      bool                      m_fHiddenChanged;
      UINT                      m_uTemplateResource;
      XBOX_MULTIFILE_ATTRIBUTES m_MultiFileAttributes;
      bool                      m_fKillThread;
      HANDLE                    m_hThread;
};


class CConsoleGeneralPage : public CPropertyPage
/*++
  Class Description:
    Implements the general page for console items.
      
--*/
{
    public:
      CConsoleGeneralPage(
           IXboxConnection  *pConnection,
           LPCSTR           pszConsoleName,
           BOOL             fMultipleConsoles
           );
      ~CConsoleGeneralPage() {m_pConnection->Release();}
      virtual BOOL GetCaption(LPSTR szBuffer, ULONG ccBuffer);

    protected:
      
      virtual INT_PTR OnInitDialog(HWND hwndDefaultControl);
      virtual void CompletePropSheetPage(PROPSHEETPAGEA *pPropSheetPage);
      
      /*
      virtual INT_PTR OnCommand(WPARAM wParam, LPARAM lParam);
      virtual INT_PTR OnMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);
      virtual bool    OnApply(bool fClose);
      */

    private:

      IXboxConnection *m_pConnection;
      char             m_szConsoleName[MAX_PATH];
      BOOL             m_fMultipleConsoles;
};

class CConsoleSecurityPage : public CPropertyPage
/*++
  Class Description:
    Implements the security page for console items.
      
--*/
{
    public:
      CConsoleSecurityPage (
           IXboxConnection *pConnection,
           LPCSTR           pszConsoleName
           );
      ~CConsoleSecurityPage() {m_pConnection->Release();DeleteUserList();}
      HRESULT InitSecuritySupport();
      virtual BOOL GetCaption(LPSTR szBuffer, ULONG ccBuffer);

    protected:
      
      virtual INT_PTR OnInitDialog(HWND hwndDefaultControl);
      virtual void CompletePropSheetPage(PROPSHEETPAGEA *pPropSheetPage);
      virtual INT_PTR OnSetActive();
      virtual INT_PTR OnCommand(WPARAM wParam, LPARAM lParam);
      virtual INT_PTR OnMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);
      virtual bool    OnApply(bool fClose);

    private:
      
      HRESULT InitUserList();
      void UpdateData();
      void UpdateAccessInfo(LPCSTR UserName, DWORD dwAccess, BOOL fEnable = TRUE);
      void DeleteUserList();
      void ShowHideWindows();
      void SetApplyButton();

      //Button Click Handlers
      void AddUser();
      void RemoveUser();
      void UnLockConsole();
      void ChangePassword();
      void LockConsole();
      void StartSecureMode();
        
      // Structure for tracking changes.
      struct USER_ACCESS_CHANGE
      {
        USER_ACCESS_CHANGE  *pNextUser;
        DM_USER             dmUser;
        DWORD               dwNewAccess;
        DWORD               dwFlags;
      };
      #define UACF_ADD     0x01
      #define UACF_REMOVE  0x02
      
      BOOL  m_fLocked;
      BOOL  m_fSecureMode;
      BOOL  m_fManageMode;
      DWORD m_dwAccess;
      HWND  m_hWndAccess;
      HWND  m_hWndUsers;
      int   m_iLastSelected;
      BOOL  m_fUpdatingUI;
      USER_ACCESS_CHANGE   *m_pUserAccessChangeList;
      
      IXboxConnection      *m_pConnection;
      char                  m_szConsoleName[MAX_PATH];
      
};


class CConsoleSettingsPage : public CPropertyPage
/*++
  Class Description:
    Implements the settings page for console items.
      
--*/
{
    public:
      CConsoleSettingsPage (
           IXboxConnection *pConnection
           );
      ~CConsoleSettingsPage() {m_pConnection->Release();}
      virtual BOOL GetCaption(LPSTR szBuffer, ULONG ccBuffer);

    protected:
      
      virtual INT_PTR OnInitDialog(HWND hwndDefaultControl);
      virtual void CompletePropSheetPage(PROPSHEETPAGEA *pPropSheetPage);
      
      /*
      virtual INT_PTR OnCommand(WPARAM wParam, LPARAM lParam);
      virtual INT_PTR OnMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);
      virtual bool    OnApply(bool fClose);
      */

    private:

      IXboxConnection *m_pConnection;
};


class CConsoleAdvancedPage : public CPropertyPage
/*++
  Class Description:
    Implements the advanced page for console items.
      
--*/
{
    public:
      CConsoleAdvancedPage (
           IXboxConnection *pConnection,
           LPCSTR           pszConsoleName
           );
      ~CConsoleAdvancedPage() {m_pConnection->Release();}
      virtual BOOL GetCaption(LPSTR szBuffer, ULONG ccBuffer);

    protected:
      
      virtual INT_PTR OnInitDialog(HWND hwndDefaultControl);
      virtual void CompletePropSheetPage(PROPSHEETPAGEA *pPropSheetPage);
      virtual INT_PTR OnCommand(WPARAM wParam, LPARAM lParam);
      /*
      virtual INT_PTR OnMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);
      virtual bool    OnApply(bool fClose);
      */

    private:

      IXboxConnection *m_pConnection;
      char             m_szConsoleName[MAX_PATH];
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbshlext\resource.h ===
//
// Resource IDs
//

//
//  Self Registration Script
//
#define IDR_XBOXFOLDER                  101


// Icons
//
//  ***MUST READ*** IF YOU ADD OR ALTER ICONS!!!!!
//
//  Bug 10152 - The shell ruthlessly caches icons, and there is no reliable way to force it to refresh certain images in the
//              cache or the whole cache.  Consequently, any new icon we access by telling the shell its location (i.e. through the
//              registry or IExtractIcon::GetIconLoaction) must occupy a new index that we have never told the shell had an icon at it
//              before.  Prior to this fix we had used temporary icons, or we had rearranged the icon index order.  Now that we have
//              final icons, we need to fix this bug.  Indices 0-12 (Resources IDs 201-213) previously had some icon at them.  Some we
//              may have previously told the shell about, others maybe not.  Since I don't know for sure, we will assume that on some
//              machine somewhere the shell has icon an icon at each of these locations.  It is OK to use these indices for Icons we
//              load ourselves with LoadIcon (for dialogs, property pages, etc), but not icons we tell the shell about.  In the future
//              following the below instructions for use and documentation should avoid any problems.  - mitchd (1/16/2002)
//
//              INSTRUCTIONS FOR MODIFYING ICONS: Document the use of icon indices.  There are four possibilites
//               a) SHELL       -  this icon is loaded by the shell given the location.  If you update this icon or it becomes obsolete replace
//                                 it with a placeholder.  Place the updated icon at a new index.
//
//               b) INTERNAL(DO NOT REPLACE WITH SHELL) - this icon is loaded internally only.  It was previously used for SHELL
//                                                        icon and can never be used for a SHELL icon again.
//
//               c) INTERNAL    - this icon is loaded internally.  It was never used for a shell icon, so you could put a new
//                                shell icon in its place.
//               d) PLACEHOLDER - this icon is currently not in use.  It was previously used for a shell icon, so you may not put another SHELL icon here.
//

#define IDI_BASE                        201
#define IDI_REPLACE                     201   //INTERNAL  (DO NOT REPLACE WITH SHELL)
#define IDI_DELETE                      202   //INTERNAL  (DO NOT REPLACE WITH SHELL)
#define IDI_MOVE                        203   //INTERNAL  (DO NOT REPLACE WITH SHELL)
#define IDI_MULDOC                      204   //INTERNAL  (DO NOT REPLACE WITH SHELL)
#define IDI_CAMERA                      205   //INTERNAL  (DO NOT REPLACE WITH SHELL)
#define IDI_REBOOT                      206   //INTERNAL  (DO NOT REPLACE WITH SHELL)
#define IDI_RESERVED_207                207   //PLACEHOLDER
#define IDI_RESERVED_208                208   //PLACEHOLDER
#define IDI_RESERVED_209                209   //PLACEHOLDER
#define IDI_RESERVED_210                210   //PLACEHOLDER
#define IDI_RESERVED_211                211   //PLACEHOLDER
#define IDI_RESERVED_212                212   //PLACEHOLDER
#define IDI_RESERVED_213                213   //PLACEHOLDER
#define IDI_MAIN                        214   //SHELL  - Referenced by the XboxFolder.rgs script, it tells the
                                              //         shell the IDI_MAIN is the icon for Xbox Neighborhood.
                                              //         note that the index for the registry ICON_INDEX(IDI_MAIN) =
                                              //         IDI_MAIN-IDI_BASE = 13
#define IDI_ADD_CONSOLE                 215   //SHELL
#define IDI_CONSOLE                     216   //SHELL
#define IDI_CONSOLE_DEFAULT             217   //SHELL
#define IDI_VOLUME                      218   //SHELL
#define IDI_FOLDER                      219   //SHELL
#define IDI_XBE                         220   //SHELL
#define ICON_INDEX(rsrcId) (rsrcId-IDI_BASE)

//
//  Column headers names for various detail views
//
#define IDS_COLUMN_HEADER_NAME              301
#define IDS_COLUMN_HEADER_IPADDR            302
#define IDS_COLUMN_HEADER_TYPE              303
#define IDS_COLUMN_HEADER_FREE_CAPACITY     304
#define IDS_COLUMN_HEADER_TOTAL_CAPACITY    305
#define IDS_COLUMN_HEADER_SIZE              306
#define IDS_COLUMN_HEADER_MODIFIED          307
#define IDS_COLUMN_HEADER_CREATED           308  //Not Currently Used
#define IDS_COLUMN_HEADER_ATTRIBUTES        309

//
//  Resource IDs for the Menu Strings
//
#define IDS_CM_NEW                319
#define IDS_CM_REBOOT             320
#define IDS_CM_LAUNCH             321
#define IDS_CM_OPEN               322
#define IDS_CM_EXPLORE            323
#define IDS_CM_REBOOT_WARM        324
#define IDS_CM_REBOOT_SAME_TITLE  325
#define IDS_CM_REBOOT_COLD        326
#define IDS_CM_CAPTURE            327
#define IDS_CM_SETDEFAULT         328
#define IDS_CM_SECURITY           329
#define IDS_CM_CUT                330
#define IDS_CM_COPY               331
#define IDS_CM_PASTE              332
#define IDS_CM_DELETE             333
#define IDS_CM_RENAME             334
#define IDS_CM_NEW_FOLDER         335
#define IDS_CM_NEW_CONSOLE        336
#define IDS_CM_PROPERTIES         337

#define HELP_ID_FROM_COMMAND_ID(_X_) ((_X_)+(IDS_CMH_LAUNCH-IDS_CM_LAUNCH))

#define IDS_CMH_LAUNCH             338
#define IDS_CMH_OPEN               339
#define IDS_CMH_EXPLORE            340
#define IDS_CMH_REBOOT_WARM        341
#define IDS_CMH_REBOOT_SAME_TITLE  342
#define IDS_CMH_REBOOT_COLD        343
#define IDS_CMH_CAPTURE            344
#define IDS_CMH_SETDEFAULT         345
#define IDS_CMH_SECURITY           346
#define IDS_CMH_CUT                347
#define IDS_CMH_COPY               348
#define IDS_CMH_PASTE              349
#define IDS_CMH_DELETE             350
#define IDS_CMH_RENAME             351
#define IDS_CMH_NEW_FOLDER         352
#define IDS_CMH_NEW_CONSOLE        353
#define IDS_CMH_PROPERTIES         354

//
//  Progress Strings
//
#define IDS_FILE_COPY_PROGRESS_TITLE        360
#define IDS_FILE_MOVE_PROGRESS_TITLE        361
#define IDS_FILE_COPY_PROGRESS_PREPARING    363
#define IDS_FILE_MOVE_PROGRESS_PREPARING    364
#define IDS_FILE_PROGRESS_TARGET            365
#define IDS_FILE_PROGRESS_CANCEL            366
#define IDS_FILE_DELETE_PROGRESS_TITLE      367
#define IDS_FILE_DELETE_PROGRESS_STATUS     368

//
//  Drive Types
//

#define IDS_DRIVETYPE_MEMORY_UNIT           375
#define IDS_DRIVETYPE_MAIN_ROOT             376
#define IDS_DRIVETYPE_BOOT                  377
#define IDS_DRIVETYPE_DEVELOPMENT           378
#define IDS_DRIVETYPE_TITLE_ROOT            379
#define IDS_DRIVETYPE_TITLE_CURRENT         380
#define IDS_DRIVETYPE_SAVED_CURRENT         381
#define IDS_DRIVETYPE_SAVED_ROOT            382
#define IDS_DRIVETYPE_SCRATCH               383
#define IDS_DRIVETYPE_DASH                  384
#define IDS_DRIVETYPE_UNKNOWN               385

//
// Confirmation Strings
//

#define IDS_CONFIRM_REMOVE_CONSOLE_CAPTION   400
#define IDS_CONFIRM_REMOVE_CONSOLE           401
#define IDS_CONFIRM_REMOVE_MULTIPLE_CONSOLES 402
#define IDS_CONFIRM_REMOVE_DEFAULT_CONSOLE   403
#define IDS_CONFIRM_RO_FILE_MOVE_CAPTION     404
#define IDS_CONFIRM_RO_FILE_MOVE             405
#define IDS_CONFIRM_RO_FOLDER_MOVE_CAPTION   406
#define IDS_CONFIRM_RO_FOLDER_MOVE           407
#define IDS_CONFIRM_FOLDER_REPLACE_CAPTION   408
#define IDS_CONFIRM_FOLDER_REPLACE           409
#define IDS_CONFIRM_DELETE_CAPTION           410
#define IDS_CONFIRM_DELETE                   411
#define IDS_CONFIRM_DELETE_RO                412
#define IDS_CONFIRM_DELETE_FOLDER_CAPTION    413
#define IDS_CONFIRM_DELETE_FOLDER            414
#define IDS_CONFIRM_DELETE_RO_FOLDER         415
#define IDS_CONFIRM_DELETE_MULTIPLE_CAPTION  416
#define IDS_CONFIRM_DELETE_MULTIPLE          417
#define IDS_CONFIRM_RENAME_CAPTION           418
#define IDS_CONFIRM_RENAME_RO_FILE           419
#define IDS_CONFIRM_DESKTOP_SHORTCUT_CAPTION 420
#define IDS_CONFIRM_DESKTOP_SHORTCUT         421

//
// helper strings for confirmation dialogs
//

#define IDS_THISFOLDER                       450
#define IDS_THESELECTEDITEMS                 451
#define IDS_READONLY                         452
#define IDS_NOTREADONLY                      453
#define IDS_HIDE                             454
#define IDS_UNHIDE                           455


//
//  Error Strings and Captions for Error Boxes
//

#define IDS_GENERIC_CAPTION                  500
#define IDS_CANNOT_DELETE_ROOT               501
#define IDS_CANNOT_DELETE_ADD_XBOX           502
#define IDS_CONSOLE_NOT_FOUND                503
#define IDS_CONSOLE_NOT_AVAILABLE            504
#define IDS_SECURE_CONNECTION_FAILED         505
#define IDS_COULDNT_UNLOCK_CONSOLE           506
#define IDS_COULDNT_LOCK_CONSOLE             507
#define IDS_CANNOT_REMOVE_LAST_MANAGER       508
#define IDS_COULDNT_APPLY_SECURITY_CHANGES   509
#define IDS_PASSWORD_SET_CAPTION             510
#define IDS_PASSWORD_SET                     511
#define IDS_COULDNT_SET_PASSWORD             512
#define IDS_COULDNT_REBOOT                   513
#define IDS_COULDNT_GET_SCREEN_SHOT          514
#define IDS_RENAME_ERROR_CAPTION             515
#define IDS_RENAME_ERROR_ILLEGAL_CHARACTERS  516
#define IDS_RENAME_XBDM_ERROR                517
#define IDS_TRANSFER_FAILED                  518
#define IDS_TRANSFER_FAILED_CAPTION          519
#define IDS_ERROR_LOW_MEMORY                 520
#define IDS_COULDNT_REPLACE_DIR_W_FILE       521
#define IDS_COULDNT_REPLACE_DIR_W_FILE_MULTI 522
#define IDS_COULDNT_REPLACE_FILE             523
#define IDS_COULDNT_CREATE_TARGET_DIR        524
#define IDS_CREATE_TEMP_FILE_FAILED          525
#define IDS_COULDNT_CONNECT_TO_XBOX          526
#define IDS_COULDNT_MOVE_FILE                527
#define IDS_COULDNT_READ_SOURCE_FILE         528
#define IDS_TRANSFER_ILLEGAL_FILENAME        529
#define IDS_TRANSFER_ILLEGAL_FILENAME_W      530
#define IDS_ERROR_PASTE_CAPTION              531
#define IDS_NOTHING_TO_PASTE                 532
#define IDS_ERROR_CREATE_FOLDER_CAPTION      533
#define IDS_ERROR_CREATE_FOLDER              534
#define IDS_ERROR_OPENNING_FOLDER_CAPTION    535
#define IDS_ERROR_OPENNING_FOLDER            536
#define IDS_ERROR_VOLUME_FULL                537

//
//  General Page for File\Folder
//
#define IDS_CONTAINS_FORMAT                  700
#define IDS_FILETYPE_VARIOUS                 701

//
//  General Page for Console
//
#define IDS_DEFAULT_TITLE                    710
#define IDS_TITLE_NOT_AVAILABLE              711

//
//  Security Page for Console
//

#define IDS_SECURITY_PERMISSIONS_FOR         720
#define IDS_SECURITY_UNLOCK_WARNING          721
#define IDS_SECURITY_UNLOCK_WARNING_CAPTION  722
#define IDS_SECURITY_LOCK_WARNING            723
#define IDS_SECURITY_LOCK_WARNING_CAPTION    724

//
//  Add Console Wizard Strings
//

#define IDS_ADDCONSOLE_GETNAME_TITLE         750
#define IDS_ADDCONSOLE_GETNAME_SUBTITLE      751
#define IDS_ADDCONSOLE_ACCESSDENIED_TITLE    752
#define IDS_ADDCONSOLE_ACCESSDENIED_SUBTITLE 753
#define IDS_ADDCONSOLE_MAKEDEFAULT_TITLE     754
#define IDS_ADDCONSOLE_MAKEDEFAULT_SUBTITLE  755
#define IDS_ADDCONSOLE_MAKEDEFAULT_QUESTION  756

//
//  Strings for Status Bar
//

#define IDS_STATUS_OBJECT_COUNT_FORMAT       780
#define IDS_STATUS_SELOBJECT_COUNT_FORMAT    781
#define IDS_STATUS_VOLUME                    782
#define IDS_STATUS_FILE                      783

//
//  Access Permission Names, the order of the Ids
//  determine the order in the security page listview.
//  
#define IDS_PERMISSION_READ                  800
#define IDS_PERMISSION_WRITE                 801
#define IDS_PERMISSION_CONFIGURE             802
#define IDS_PERMISSION_CONTROL               803
#define IDS_PERMISSION_MANAGE                804
#define PERMISSION_LISTVIEW_INDEX(_x_) (_x_ - IDS_PERMISSION_READ)

//
//  Misc Strings
//

#define IDS_ROOT_SHORT_CUT_NAME              850
#define IDS_ROOT_SHORT_CUT_DESCRIPTION       851
#define IDS_LITERAL_YES                      853
#define IDS_LITERAL_NO                       854
#define IDS_LITERAL_THIS_COMPUTER            855
#define IDS_NEW_FOLDER                       856
#define IDS_NEW_FOLDER_TEMPLATE              857
#define IDS_NORMAL_NAME_FORMAT               858

//
//  Preloaded strings (frequently loaded strings
//  that we keep one lazy loaded copy of in global
//  memory)
//
#define IDS_FIRST_PRELOADED_STRING              950

#define IDS_PRELOAD_FOLDER_TYPE_NAME            950
#define IDS_PRELOAD_FILESIZE_FORMAT_BYTES       951
#define IDS_PRELOAD_FILESIZE_FORMAT_KB          952
#define IDS_PRELOAD_FILESIZE_FORMAT_MB          953
#define IDS_PRELOAD_FILESIZE_FORMAT_GB          954
#define IDS_PRELOAD_FILEBYTESIZE_FORMAT1        955
#define IDS_PRELOAD_FILEBYTESIZE_FORMAT2        956
#define IDS_PRELOAD_XBOX_ZONE_NAME              957
#define IDS_PRELOAD_STATUS_ADD_CONSOLE_FORMAT   958
#define IDS_NEXT_PRELOADED_STRING               959

//
//  Error Strings that correspond with errors codes returned from xboxdbg.lib
//

#define IDC_XBDM_NOERRORSTRING  0x8200
#define IDC_E_UNEXPECTED        0x8201
#define IDC_E_INVALIDARG        0x8202

//
// These IDs are programmatically generated from error codes.  The exact values
// do matter.
//

#define IDC_XBDM_UNDEFINED        0x8000
#define IDC_XBDM_MAXCONNECT       0x8001
#define IDC_XBDM_NOSUCHFILE       0x8002
#define IDC_XBDM_NOMODULE         0x8003
#define IDC_XBDM_MEMUNMAPPED      0x8004
#define IDC_XBDM_NOTHREAD         0x8005
#define IDC_XBDM_INVALIDCMD       0x8007
#define IDC_XBDM_NOTSTOPPED       0x8008
#define IDC_XBDM_MUSTCOPY         0x8009
#define IDC_XBDM_ALREADYEXISTS    0x800A
#define IDC_XBDM_DIRNOTEMPTY      0x800B
#define IDC_XBDM_BADFILENAME      0x800C
#define IDC_XBDM_CANNOTCREATE     0x800D
#define IDC_XBDM_CANNOTACCESS     0x800E
#define IDC_XBDM_DEVICEFULL       0x800F
#define IDC_XBDM_NOTDEBUGGABLE    0x8010
#define IDC_XBDM_BADCOUNTTYPE     0x8011
#define IDC_XBDM_COUNTUNAVAILABLE 0x8012

#define IDC_XBDM_CANNOTCONNECT    0x8100
#define IDC_XBDM_CONNECTIONLOST   0x8101
#define IDC_XBDM_FILEERROR        0x8103
#define IDC_XBDM_NOTXBEFILE       0x8106
#define IDC_XBDM_MEMSETINCOMPLETE 0x8107
#define IDC_XBDM_NOXBOXNAME       0x8108

//
//  Dialogs
//

#define   IDD_CONFIRM_REPLACE         1201
#define   IDD_CONFIRM_FOLDER_REPLACE  1202
#define   IDD_CONFIRM_DELETE          1203
#define   IDD_CONFIRM_MOVE            1204
#define   IDD_CONFIRM_REMOVEDIR       1205
#define   IDD_DRV_GENERAL             1206
#define   IDD_FILEPROP                1207
#define   IDD_FOLDERPROP              1208
#define   IDD_FILEMULTPROP            1209
#define   IDD_ATTRIBS_RECURSIVE       1210
#define   IDD_CONSOLE_GENERAL         1211
#define   IDD_CONSOLE_SETTING         1212
#define   IDD_CONSOLE_SECURITY        1213
#define   IDD_CONSOLE_ADVANCED        1214
#define   IDD_ADDCONSOLE_WELCOME      1215
#define   IDD_ADDCONSOLE_GETNAME      1216
#define   IDD_ADDCONSOLE_ACCESSDENIED 1217
#define   IDD_ADDCONSOLE_MAKEDEFAULT  1218
#define   IDD_ADDCONSOLE_FINISH       1219
#define   IDD_USERNAME_PROMPT         1220
#define   IDD_PASSWORD_PROMPT         1221


//
//  Command ID used by multiple dialogs
//  (put XB in the name to avoid conflict
//  with standard IDC names)
//
#define   IDC_XB_YES          1301
#define   IDC_XB_YESTOALL     1302
#define   IDC_XB_NO           1303
#define   IDC_XB_NOTOALL      1304
#define   IDC_XB_CANCEL       1305
#define   IDC_XB_FILENAME     1306 
#define   IDC_XB_FILESIZE     1307
#define   IDC_XB_FILETIME     1308
#define   IDC_XB_FILEICON     1309
#define   IDC_XB_FILESIZE2    1310
#define   IDC_XB_FILETIME2    1311
#define   IDC_XB_FILEICON2    1312
#define   IDC_XB_TEXT         1313
#define   IDC_XB_TITLE        1314

//
//  Command IDs Used in the driver property
//  pages.
//
#define IDC_DRV_ICON            1321
#define IDC_DRV_LETTER1         1222
#define IDC_DRV_TYPE_TXT        1323
#define IDC_DRV_TYPE            1324
#define IDC_DRV_USEDCOLOR       1325
#define IDC_DRV_USEDBYTES_TXT   1326
#define IDC_DRV_USEDBYTES       1327
#define IDC_DRV_USEDMB          1328
#define IDC_DRV_FREECOLOR       1329
#define IDC_DRV_FREEBYTES_TXT   1330
#define IDC_DRV_FREEBYTES       1331
#define IDC_DRV_FREEMB          1332
#define IDC_DRV_TOTSEP          1333
#define IDC_DRV_TOTBYTES_TXT    1334
#define IDC_DRV_TOTBYTES        1335
#define IDC_DRV_TOTMB           1336
#define IDC_DRV_PIE             1337
#define IDC_DRV_TOTSEP2         1338

//
//  Command IDs for the file,
//  folder, and multiple file
//  property pages
//  
#define IDC_ITEMICON          1351
#define IDC_NAMEEDIT          1352
#define IDC_FILETYPE          1353
#define IDC_LOCATION          1354
#define IDC_FILESIZE          1355
#define IDC_CREATED           1356
#define IDC_LASTMODIFIED      1357
#define IDC_READONLY          1358
#define IDC_HIDDEN            1359
#define IDC_CONTAINS          1360

//
//  Command ID's for the Console property pages
//
#define IDC_IPADDRESS         1371
#define IDC_ALTIPADDRESS      1372
#define IDC_ALTIPADDRESS_TEXT 1373
#define IDC_RUNNINGTITLE      1374
#define IDC_SYSTEMTIME        1375
#define IDC_WARMBOOT          1376
#define IDC_COLDBOOT          1377
#define IDC_REBOOT            1378
#define IDC_CAPTURE           1379


//
//  Controls on Confirmation Dialogs
//
#define IDC_ATTRIBSTOAPPLY    1401
#define IDC_RECURSIVE         1402
#define IDC_NOTRECURSIVE      1403
#define IDC_RECURSIVE_TXT     1404

//
//  Controls used by the Add Xbox Wizard
//
#define IDC_ADDCONSOLE_NAME                1451
#define IDC_ADDCONSOLE_PASSWORD            1452
#define IDC_ADDCONSOLE_YES                 1453
#define IDC_ADDCONSOLE_NO                  1454
#define IDC_ADDCONSOLE_MAKEDEFAULT         1455
#define IDC_ADDCONSOLE_PERMISSIONS_CAPTION 1456 
#define IDC_ADDCONSOLE_PERMISSIONS         1457
#define IDC_ADDCONSOLE_COMPLETE            1458
#define IDC_ADDCONSOLE_READ                1459
#define IDC_ADDCONSOLE_WRITE               1460
#define IDC_ADDCONSOLE_CONFIGURE           1461
#define IDC_ADDCONSOLE_CONTROL             1462
#define IDC_ADDCONSOLE_MANAGE              1463

//
//  Controls on the Console Security Page
//
#define IDC_SECURITY_MACHINES              1470
#define IDC_SECURITY_USERLIST              1471
#define IDC_SECURITY_ADD                   1472
#define IDC_SECURITY_REMOVE                1473
#define IDC_SECURITY_ACCESS                1474
#define IDC_SECURITY_ACCESS_TEXT           1475
#define IDC_SECURITY_UNLOCK                1476
#define IDC_SECURITY_CHANGE_PASSWORD       1477
#define IDC_SECURITY_MANAGE_TEXT           1478
#define IDC_SECURITY_PASSWORD_TEXT         1479
#define IDC_SECURITY_PASSWORD_EDIT         1480
#define IDC_SECURITY_MANAGE_BUTTON         1481
#define IDC_SECURITY_UNLOCKED_TEXT         1482
#define IDC_SECURITY_LOCK_BUTTON           1483
#define IDC_SECURITY_CONFIRM_PASSWORD      1484
#define IDC_SECURITY_PASSWORD_MISMATCH     1485

//
//  Resource ID of the Drop Popup Context Menu
//  (a.k.a. Copy\Move\Cancel)
//
#define IDM_CONTEXT_MENU_DROP   1551

//           
//  These definitions get sucked in by windows.h
//  but not for resources.
//
#ifdef RC_INVOKED
#define	DROPEFFECT_NONE	0
#define	DROPEFFECT_COPY	1
#define	DROPEFFECT_MOVE	2
#endif 

//
//  Animation
//
#define IDA_COPY    1601
#define IDA_DELETE  1602

//
//  Bitmaps
//
#define IDB_WATERMARK 1701
#define IDB_HEADER    1702
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbshlext\stdafx.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    stdafx.h

Abstract:
    
    Precompiled Header for Xbox Namespace Shell Extension

--*/
#ifndef __XBSHLEXT_STDAFX_H__
#define __XBSHLEXT_STDAFX_H__

//-----------------------------------------------------------
//  We have some dependencies on Shell 5.0
//-----------------------------------------------------------
#define STRICT
#ifdef _WIN32_WINNT
#undef _WIN32_WINNT
#endif
#define _WIN32_WINNT 0x0500

//-----------------------------------------------------------
//  Standard ATL Stuff
//-----------------------------------------------------------
#define _ATL_APARTMENT_THREADED
//#define _ATL_DEBUG_INTERFACES
#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>
#include <assert.h>

//-----------------------------------------------------------
//  Shell Headers
//-----------------------------------------------------------
#include <shlobj.h>

//-----------------------------------------------------------
//  Some generic globals
//-----------------------------------------------------------//
extern IMalloc *g_pShellMalloc;
extern CLIPFORMAT CF_FILECONTENTS;
extern CLIPFORMAT CF_FILEDESCRIPTORA;
extern CLIPFORMAT CF_FILEDESCRIPTORW;
extern CLIPFORMAT CF_FILENAMEMAPA;
extern CLIPFORMAT CF_FILENAMEMAPW;
extern CLIPFORMAT CF_FILENAME;
extern CLIPFORMAT CF_PREFERREDDROPEFFECT;
extern CLIPFORMAT CF_PERFORMEDDDROPEFFECT;
extern CLIPFORMAT CF_LOGICALPERFORMEDDROPEFFECT;
extern CLIPFORMAT CF_PASTESUCCEEDED;
extern CLIPFORMAT CF_SHELLIDLIST;
extern CLIPFORMAT CF_XBOXFILEDESCRIPTOR;

//-------------------------------------------------------------
//  A useful macro that I saw used in some shell code.  Used
//  when calling QueryInterface and QueryService.  Adds a modicum
//  of type safety.
//-------------------------------------------------------------
#ifndef IID_PPV_ARG
#define IID_PPV_ARG(IType, ppType) IID_##IType, reinterpret_cast<void **>(static_cast<IType**>(ppType))
#endif

//-----------------------------------------------------------
//  Other misc. macros
//-----------------------------------------------------------
#define I2BIT(_index_) (1<<(_index_))  //Converts an index to a bit

//-----------------------------------------------------------
//  XDK Headers
//-----------------------------------------------------------
#include <xboxdbg.h>
#include <ixbconn.h>

//-----------------------------------------------------------
//  Private Shell headers
//-----------------------------------------------------------
#include <shlobj.h>
#include <ntquery.h>
#include <shlobjp.h>
#include <shldispp.h>
#include <shlguidp.h>

//-----------------------------------------------------------
// shell extension headers
//-----------------------------------------------------------
#include "resource.h"
#include "debug.h"
#include "xbshlext.h"       // MIDL Generated Header
#include "utils.h"          // Basic Utilities
#include "objectwithsite.h" // CShellObjectWithSite
#include "pidl.h"           // Pidl Utilities
#include "visit.h"          // Visiting Xbox Items (IXboxVisitor, IXboxVisit, etc.)
#include "xbfolder.h"       // CXboxFolder (and derivatives)
#include "console.h"        // CManageConsoles
#include "delete.h"         // CXboxDelete
#include "attrib.h"         // CGetAttributes, CSetAttributes
#include "icon.h"           // CXboxExtractIcon
#include "menu.h"           // CxboxMenu
#include "prop.h"           // Property Pages (all of them)
#include "wizard.h"         // Wizards (especially the add new console)
#include "dataobj.h"        // CXboxDataObject
#include "drop.h"           // CXboxDropTarget
#include "CXboxStream.h"    // CXboxStream
#include "view.h"           // CXboxViewCB

#endif // __XBSHLEXT_STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbshlext\shellfolder.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    shellfolder.cpp

Abstract:

   Implementation of Interface for CXboxFolder:

       IPersistFolder
       IShellFolder
       IBrowserFrameOptions

Environment:

    Windows 2000 and Later 
    User Mode
    Compiles UNICODE, but uses many ANSI APIs explictly.

Revision History:
    
    06-29-2001 : created

--*/
#include "stdafx.h"

//-----------------------------------------------------------------------------------------------------
//  IPersist\IPersistFolder
//-----------------------------------------------------------------------------------------------------
HRESULT
CXboxFolder::GetClassID(
    LPCLSID lpClassID
    )
/*++
  Routine Description:
    Should return the CLSID of our IShellFolder implementation.
    This is probably used by clients to make short-cuts.
--*/
{
    if(lpClassID)
    {
        *lpClassID = __uuidof(XboxFolder);
        return S_OK;
    }
    return E_FAIL;
}


HRESULT
CXboxFolder::Initialize(
    LPCITEMIDLIST pidl
    )
/*++
  Routine Description:
    Only CXboxRoot supports Initialize so we return E_NOTIMPL and override this
    in CXboxRoot.
--*/
{
    _ASSERTE("IPersistFolder::Initialize on non-root item" && FALSE);
    return E_NOTIMPL;
}

HRESULT
CXboxRoot::Initialize(
    LPCITEMIDLIST pidlRoot
    )
/*++
  Routine Description:
    Implements IPersistFolder::Initialize for CXboxRoot.
    
    The hard part is getting the name of Xbox root, since the
    name can be changed by the user.  We use SHGetFileInfo

  Arguments:
    pidlRoot - pidl of Xbox root.
  
--*/
{
    HRESULT hr;
    SHFILEINFOA shellFileInfo;
    ENTER_SPEW
    DEBUG_DUMP_PIDL(pidlRoot);

    //
    //  SHGetFileInfoA should be able to get our root name from the registry.
    //
    
    if(SHGetFileInfoA((LPSTR)pidlRoot, 0, &shellFileInfo, sizeof(shellFileInfo), SHGFI_PIDL|SHGFI_DISPLAYNAME))
    {

        //
        //  Call the base initialization.
        //

        hr = InitBaseClass(
              shellFileInfo.szDisplayName,
              ROOT_SHELL_ATTRIBUTES,
              pidlRoot);
        m_uPathDepth = 0;
    } else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    
    return hr;
}


//-----------------------------------------------------------------------------------------------------
//  IShellFolder
//-----------------------------------------------------------------------------------------------------

HRESULT CXboxFolder::BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv){return E_NOTIMPL;}

HRESULT CXboxRoot::BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
/*++
  Routine Description:
  
    Implements IShellFolder::BindToObject.  Gets an IShellFolder * for any in the namespace.
    This may be an immediate child or any number of levels down.

  Arguments:
  
    pidl - pidl of child to get.
    pbc  - a binding context, we just ignore this.
    riid - interface to get.
    ppv  - out parameter for interface.

  Result:
    
    S_OK on success.
    E_INVALIDARG - if the pidl does not represent a valid child.
    E_NOINTERFACE - if the desired interface does not exist.
    
  Comments:
    
    The pidl must be relative.  The first SHITEM ID will always be the machine name.
    We can us this to a connection interface.

    PathFromPidl will get the whole path from the pidl AND tell us the depth (i.e.
    the count of SHITEMIDs in the pidl).

    If Depth is 1, we need a console.
    If Depth is 2, we need a volume.
    If Depth is greater than 2, we need a directory.

    The silly shell tries to bind to the Add Xbox wizard, when resolving a short-cut.  This despite the
    fact that it doesn't have attributes that might suggest that this is possible.  So we need to
    detect this case and simply fail.  Then it tries to open it without binding.

--*/
{
    char  szPathName[MAX_XBOX_PATH];
    UINT  uDepth;
    IXboxConnection *pConnection;
    HRESULT hr;

    ENTER_SPEW
    DEBUG_DUMP_IID(riid);
    ATLTRACE("\n");
    DEBUG_DUMP_PIDL(pidl);

    
    uDepth = PathFromPidl(pidl, szPathName);
    
    //
    //  It is not legal to send a NULL pidl.
    //
    if(0==uDepth)
    {
        _ASSERTE(FALSE);
        return E_INVALIDARG;
    }

    if('?' == *pidl->mkid.abID)
    {
        return E_FAIL;
    }

    //
    //  Get a connection interface
    //

    hr = Utils::GetXboxConnection((LPSTR)pidl->mkid.abID, &pConnection);
    if(FAILED(hr))
    {
        if(pbc)
        {
            char szError[60];
            FormatUtils::XboxErrorString(hr, szError, sizeof(szError));

            //
            //  BUGBUG: No parent hwnd for this message box (chrispi fixed a build break here)
            //

            WindowUtils::MessageBoxResource(NULL, IDS_ERROR_OPENNING_FOLDER, IDS_ERROR_OPENNING_FOLDER_CAPTION, MB_OK|MB_ICONSTOP, szPathName, szError);
        }
        RETURN(hr);
    }

    if(1==uDepth)
    {
        hr = CXboxConsole::Create(szPathName, m_pidlRoot, pConnection, riid, ppv);
    } else if(2==uDepth)
    {
        hr = CXboxVolume::Create(szPathName, m_pidlRoot, pConnection, riid, ppv);
    } else
    {
        hr = CXboxDirectory::Create(szPathName, m_pidlRoot, pConnection, riid, ppv);
    }
    RETURN(hr);
}

HRESULT CXboxConsole::BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
/*++
  Routine Description:
  
    Same as CXboxRoot::BindToObject with a couple of differences in the implementation:
    
    1) We already have a connection it is one of our members.

    2) We need to concatanate the path with our own.

    3) If Depth is 1, we need a Volume.
       If Depth is greater than 1, we need a Directory.
--*/
{
    char  szPathName[MAX_XBOX_PATH];
    LPSTR pszPathName;
    UINT  uDepth;
    IXboxConnection *pConnection;
    HRESULT hr;

    ENTER_SPEW
    DEBUG_DUMP_IID(riid);
    ATLTRACE("\n");
    DEBUG_DUMP_PIDL(pidl);

    //
    //  Initialize the path buffer with the path to use.
    //
    GetPath(szPathName);
    pszPathName = szPathName + GetPathLen();

    //
    //  Append a '\\'
    //
    *pszPathName++ = '\\';

    //
    //  Append the path from the relative pidl
    //
    uDepth = PathFromPidl(pidl, pszPathName);
    
    //
    //  It is not legal to send a NULL pidl.
    //
    if(0==uDepth)
    {
        _ASSERTE(FALSE);
        RETURN(E_INVALIDARG);
    }

    //
    //  Create the correct object depending on the depth.
    //
    if(1==uDepth)
    {
        hr = CXboxVolume::Create(szPathName, m_pidlRoot, m_pConnection, riid, ppv);
    } else
    {
        hr = CXboxDirectory::Create(szPathName, m_pidlRoot, m_pConnection, riid, ppv);
    }
    RETURN(hr);
}

HRESULT CXboxFileSystemFolder::BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
/*++
  Routine Description:
  
    Same as CXboxConsole::BindToObject with a couple of differences in the implementation:
    
    Always Create a directory.
--*/
{
    char  szPathName[MAX_XBOX_PATH];
    LPSTR pszPathName;
    UINT  uDepth;
    IXboxConnection *pConnection;
    HRESULT hr;
    
    ENTER_SPEW
    DEBUG_DUMP_IID(riid);
    ATLTRACE("\n");
    DEBUG_DUMP_PIDL(pidl);

    //
    //  Initialize the path buffer with the path to use.
    //
    GetPath(szPathName);
    pszPathName = szPathName + GetPathLen();

    //
    //  Append a '\\'
    //
    *pszPathName++ = '\\';

    //
    //  Append the path from the relative pidl
    //
    uDepth = PathFromPidl(pidl, pszPathName);
    
    //
    //  It is not legal to send a NULL pidl.
    //
    if(0==uDepth)
    {
        _ASSERTE(FALSE);
        RETURN(E_INVALIDARG);
    }

    hr = CXboxDirectory::Create(szPathName, m_pidlRoot, m_pConnection, riid, ppv);
    
    RETURN(hr);
}


HRESULT CXboxFolder::BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
/*++
  Routine Description:
    We don't implement IStorage interfaces for each of our items, so we do not support
    this at the present time.  I am not 100% what this storage would like.
--*/
{
    ENTER_SPEW
    return E_NOTIMPL;
}

HRESULT CXboxFolder::CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
/*++
  Routine Description:
   Implements IShellFolder::CompareIDs.  Compares two pidls for the purpose of sorting or
   for determining identity.

  Arguments:
   lParam  - Use SHCIDS_COLUMNMASK (lower sixteen bits) to get column IDs.
             SCHIDS_ALLFIELDS masks a bit in the high word.
   pidl1   - first item id.
   pidl2   - second item id.

  Return Value:
    S_EQUAL   - if they refer to the same object.
    S_GREATER - if pidl1 is greater than pidl2
    S_LESS    - if pidl1 is before pidl2.
    
    Failure codes (E_EQUAL, E_GREATER, E_LESS) in some situations, see caveats.

 Caveats:

   This appears to be a simple idea, but I found this to be one of the most deceptively
   sophisticated methods in the shell API.  Even small bugs cause really strange behavior.
   
   All sorts of layers use this to determine pidl identity.  Within the shell only the owning
   namespace extension can properly say whether two pidls refer to the same object.  This is how
   you ask.

   It is not acceptable to fail an identity check just because the pidl may no longer be valid
   (i.e. the xbox is not reachable, or the item has been deleted).  This is especially true
   as the shell's CDefView calls this to find the correct item to remove from the view after
   it is notified of an item being deleted.

   Note that all Xbox SHITEMID's are just null terminated upper-case strings containing the
   item name, with cb set correctly for pidls.  To sort by something other than name we must
   access the item over the wire (or from a member variable if we recently cached the information).

   So here are the rules:

   1) Pidls are identical if a case insensitive compare of each SHITEMID is 0.  We do not and
      must not talk over the wire for this!  Return 0 immediately.
   2) If pidls are identical to a point, but then one is shorter than the other, the shorter
      one comes first.
   3) If pidls are different at any SHITEMID besides the last one (for both pidls), then the
      the alphabetically earlier one is first.
   4) We only support sorting by anything other than name if each pidl is a simple pid.  In this
      case we call CompareItemIDs, which considers the column ID.  Otherwise, we just compare
      by name only.**
   5) If CompareItemIDs fails (an item doesn't exist or cannot be reached), we still cannot fail
      if SHCIDS_ALLFIELDS is set. In this case, an invalid item appears after a valid item.  Two
      invalid items are sorted by name.

   ** Whether this is sufficient remains to be seen.  The difficulty is that it is really inefficient
   to compare by criteria other than name, if we need to look down more than one level.  Additionally,
   the code to do the comparison would be completely different than anything that exists now.

--*/
{
    HRESULT hr;
    LPCITEMIDLIST pidl1Temp = pidl1;
    LPCITEMIDLIST pidl2Temp = pidl2;
    int iNameCmp;
    USHORT cbTotal=0;
    BOOL fCannotFail = (0==lParam) ? TRUE : FALSE;
    
    ATLTRACE("CompareIDs: %d\n", lParam);
    DEBUG_DUMP_PIDL(pidl1);
    DEBUG_DUMP_PIDL(pidl2);

    //
    // Loop over all SHITEMID's
    //
    while (pidl1Temp->mkid.cb && pidl2Temp->mkid.cb)
    {
        //
        //  Case-insensitve compare one level of SHITEMIDs
        //

        iNameCmp = _stricmp((char *)pidl1Temp->mkid.abID, (char *)pidl2Temp->mkid.abID);

        //
        //  If they were different, we have stuff to do.
        //

        if (iNameCmp)
        {
            // Check if this was the end of the pidl.
            //
            LPCITEMIDLIST pidl1End = AdvancePtr(pidl1Temp, pidl1Temp->mkid.cb);
            LPCITEMIDLIST pidl2End = AdvancePtr(pidl2Temp, pidl2Temp->mkid.cb);

            if (pidl1End->mkid.cb || pidl2End->mkid.cb)
            //
            //  Not the end so just return the result of the last string compare.
            //
            { 
                hr = ResultFromCompare(iNameCmp);
            }
            else
            //
            //  It was the end of the pidl, call the proper CompareItemIDs
            //
            {
                //
                //  If the common parent is not us, we do not support support
                //  anything but name based ordering.
                //
                if(cbTotal)
                {

                    ATLTRACE("Inefficient CompareItemIDs.");
                    _ASSERTE(0==(lParam&SHCIDS_COLUMNMASK));
                    hr = ResultFromCompare(iNameCmp);

                } else
                //
                //  The common parent is us.  That is good, that we probably won't have to
                //  hit the wire.  (When the sort criteria was set, we refreshed our children).
                //
                {
                    hr = CompareItemIDs(lParam&SHCIDS_COLUMNMASK, iNameCmp, &pidl1Temp->mkid, &pidl2Temp->mkid);
                }
                
                //
                // Check if the common parent failed the comparison, and if we cannot fail.
                //

                if(FAILED(hr) && fCannotFail)
                {
                    //Get rid of the severity and facility, and just keep the result
                    //stored by CompareItemIDs
                    hr = LOWORD(hr); 
                }
            }
            RETURN(hr);
        } else
        {
          //
          // Tracking the pidl length as we go will help, when
          // we need to get a CXboxFolder.
          //
          cbTotal += pidl1Temp->mkid.cb;
        }
        pidl1Temp = AdvancePtr(pidl1Temp, pidl1Temp->mkid.cb);
        pidl2Temp = AdvancePtr(pidl2Temp, pidl2Temp->mkid.cb);
    }

    // If we're here, either:
    //  1)  the pidls are identical to the end of one, but the other has a greater depth
    //  2)  the pidls are identical
    //
    if (pidl1Temp->mkid.cb)
    {
        _ASSERTE(!pidl2Temp->mkid.cb); // Sanity check.
        hr = S_GREATER;
    }
    else if (pidl2Temp->mkid.cb)
    {
        _ASSERTE(!pidl1Temp->mkid.cb); // Sanity check.
        hr = S_LESS;
    }
    else
    {
        hr = S_EQUAL;
    }
    RETURN(hr);
}


HRESULT CXboxFolder::CreateViewObject(HWND hwnd, REFIID riid, void **ppv)
/*++
  Routine Description:
    Implements IShellFolder::CreateViewObject.

    This routine has two purposes really.

    1) Get a view (IShellView or IShellView2).  This we handle here.
    
    2) It can also ask for anything that GetUIObjectOf can ask for.
       This we handle by calling GetUIObjectOf with cidl set to 0, and
       apidl set to NULL.  See GetUIObjectOf comments to understand
       why this works this way.
--*/
{
   HRESULT hr;
   ENTER_SPEW
   DEBUG_DUMP_IID(riid);

   //
   //   If it is not looking for a shell view, just defer
   //   to GetUIObjectOf.
   //
   if( (IID_IShellView==riid) || (IID_IShellView2==riid) )
   {
       //
       //   Instantiate our view callback.
       //
       return CXboxViewCB::CreateShellView(this, hwnd, riid, ppv);
   }
      
   return GetUIObjectOf(hwnd, 0, NULL, riid, NULL, ppv);
}

HRESULT CXboxFolder::EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList **ppEnumIDList)
/*++
  Routine Description:
    Implements IShellFolder::EnumObjects.
    
    We can implement this all here since all we need are the simple pidls and the
    shell attributes. 
--*/
{
    HRESULT hr;
    CComObject<CEnumIdList> *pEnumerator = NULL;
    UINT uChildIndex, uFilteredChildCount;
    DWORD dwXorMask, dwAndMask;
    
    ENTER_SPEW

    //
    // Null the out parameter in case we need to fail.
    //
    *ppEnumIDList = NULL;  

    //  BUILD FILTER MASK FOR CHILDREN
    //
    //  The efficient filter based on bits is to create an
    //  XOR mask and an AND mask.  If the result is zero the
    //  the item is accepted.
    //
    //  With this scheme any bit can force a reject, but every
    //  bit must accept for the item to be accepted.
    //
    //  IN  ^ XORMASK & ANDMASK = OUT  | Comment
    //================================================================================
    //   X  |    X         0    =  0   | If ANDMASK clear, always accept
    //--------------------------------------------------------------------------------  
    //   1  |    1         1    =  0   | ANDMASK set, XORMASK set then
    //   0  |    1         1    =  1   | Accept if IN is set
    //--------------------------------------------------------------------------------  
    //   1  |    0         1    =  1   | ANDMASK set, XORMASK clear then
    //   0  |    0         1    =  0   | Accept if IN is clear
    //--------------------------------------------------------------------------------  
    //
    dwXorMask = 0;
    dwAndMask = 0;
    if(!(grfFlags&SHCONTF_INCLUDEHIDDEN)) 
    {
        dwAndMask |= SFGAO_HIDDEN;
    }

    //
    //  Switch on the state of SHCONTF_NONFOLDERS and SHCONTF_FOLDERS flag.
    //

    DWORD dwFolderBits = (SHCONTF_NONFOLDERS|SHCONTF_FOLDERS)&grfFlags;
    switch(dwFolderBits)
    {
        case SHCONTF_FOLDERS:
          dwXorMask |= SFGAO_FOLDER;
          //fall through to set the AND mask
        case SHCONTF_NONFOLDERS:
          dwAndMask |= SFGAO_FOLDER;
          break;
        case 0:
          // Someone is asking for neither folders nor non-folders.
          // What is the point of even calling?  The logical response
          // is to enumerate nothing, but give them everything anyway.
          //
          // Fall through to the case of both, after asserting.
          _ASSERTE(FALSE);
        case (SHCONTF_NONFOLDERS|SHCONTF_FOLDERS):
          break;
    };

    //
    // Refresh our child list.
    //

    hr = RefreshChildren();
    if(FAILED(hr))
    {
        return hr;
    }
    
    //
    //  Allocate array of PIDLs for all our children, even though
    //  some might not make it through the filter, we shouldn't
    //  over allocate by much.
    //

    LPITEMIDLIST *enumPidlArray = new LPITEMIDLIST[m_uChildCount];
    if(NULL == enumPidlArray) return E_OUTOFMEMORY;
    memset(enumPidlArray, 0, m_uChildCount*sizeof(LPITEMIDLIST));

    //
    //  Walk our children.  Filter them based on grfFlags and
    //  add them to enumPidlArray.
    //

    for(uChildIndex = 0, uFilteredChildCount = 0; uChildIndex < m_uChildCount; uChildIndex++)
    {
        if(0 == ((m_rgulChildShellAttributes[uChildIndex]^dwXorMask)&dwAndMask))
        {
            enumPidlArray[uFilteredChildCount] = GetChildPidl(uChildIndex, CPidlUtils::PidlTypeSimple);
            if(enumPidlArray[uFilteredChildCount])
            {
                uFilteredChildCount++;
            }
        }
    }
    
    //
    //  Create an enumerator object
    //
    hr = CComObject<CEnumIdList>::CreateInstance(&pEnumerator);

    //
    //  Initialize the enumerator object with our child array
    //

    if(SUCCEEDED(hr))
    {
        //
        //  We know that these next two operations cannot fail based on the implemenation
        //  of ATL's enumerator.
        //
        hr = pEnumerator->Init(enumPidlArray, enumPidlArray+uFilteredChildCount, NULL, AtlFlagTakeOwnership);
        _ASSERTE(SUCCEEDED(hr));
        
        hr = pEnumerator->QueryInterface(IID_IEnumIDList, (void **)ppEnumIDList);
        _ASSERTE(SUCCEEDED(hr));

    } else
    {
      //
      //  If we could not create an enumerator, we need to free
      //  the array ourselves.
      //

      for(uChildIndex = 0; uChildIndex < uFilteredChildCount; uChildIndex++)
      {
        g_pShellMalloc->Free(enumPidlArray[uChildIndex]);
      }
    }
       
    return hr;
}


HRESULT CXboxFolder::GetAttributesOf(UINT cidl, LPCITEMIDLIST * apidl, ULONG * drgfInOut)
/*++
  Routine Description:
    Implements IShellFolder::GetAttributesOf.

    Gets the shell attributes of a subset of children.

    1) Make sure we have a child list.
    
    2) Loop over all the simple pidls.

    3) For each, get our child index, then and its attributes with *drgfInOut.

  Arguments:
    cidl      - count of SHITEMIDs in apild.
    apidl     - array of cidl simple pidls (i.e. a single SHITEMID per pidl).
    drgfInOut - IN  = attributes the caller wants.
                OUT = union (bitwise AND) of attributes wanted by caller and supported by all the specified
                      children.
  Return Value:
   S_OK   - on success
   E_FAIL - if any of the pidls are not valid items

  Remarks:
   Sometimes cidl is 0, this is not documented.  In this case, we just return our own attributes.

--*/             
{
    UINT uItemIdIndex;
    UINT uChildIndex;
    HRESULT hr;

    ENTER_SPEW

    //
    //  Handle the query self case.
    //
    if(0==cidl)
    {
        *drgfInOut &= m_ulShellAttributes;
        *drgfInOut &= ~SFGAO_CANLINK;
        RETURN(S_OK);
    }

    if(*drgfInOut&SFGAO_VALIDATE)
    {
        m_fChildrenValid = FALSE;
    }
    hr = RefreshChildren();
    if(FAILED(hr))
    {
        return hr;
    }

    for(uItemIdIndex = 0; uItemIdIndex < cidl; uItemIdIndex++)
    {
        //
        //  If this is our pidl, apidl[uItemIdIndex]->mkid.abID is
        //  then name of the child.  If it is not our child, it is illegal, but
        //  still not that dangerous, we won't run over the end of the buffer
        //  or anything as the pidl itself is double NULL terminated.
        //

        hr = GetChildIndex((LPSTR)apidl[uItemIdIndex]->mkid.abID, &uChildIndex);
 
        //
        //  bitwise-AND in the flags.
        //

        if(FAILED(hr))
        {
            *drgfInOut = 0;
            return hr;
        } else
        {
            *drgfInOut &= m_rgulChildShellAttributes[uChildIndex];
        }
    }

    return S_OK;
}

HRESULT CXboxFolder::GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, STRRET *psr)
/*++
  Routine Description:
    Implements IShellFolder::GetDisplayNameOf.  Gets the display name of a child item.

  Arguments:
    pidl   - Relative pidl of item.
    uFlags - one or more of [SHGDN_NORMAL|SHGDN_INFOLDER] & [SHGDN_FOREDITING|SHGDN_FORADDRESSBAR|SHGDN_FORPARSING]
    psr    - reurn string value.


  Return Value:
   S_OK   - on success
   E_FAIL - if any of the pidls are not valid items

 Comments:

   ARRGH:  The documents big time suck on what to do with the flags!  The set of five example cases in the SHGNO
   entry of the docs is an extended subset of what callers will actually do.  In other words, the five examples
   are marginally useful.  Basically, you can refer to the docs with following ammendments:  (these cases are exact
   matches for uFlags, other combinations are of course possible)

  SHGFN_NORMAL - This name is definately what ends up as short-cut names.  It seems to be called for other purposes too, but
  I never see this UI show up, so who knows.  The docs say the path should be relative to the desktop.  Not really, rather it
  
  SHGDN_FORADDRESSBAR - The shell sends this to get the title of the window, when the user has NOT turned on the full-path name in title bar option.

  SHGDN_FORADDRESSBAR|SHGDN_FORPARSING - The shell sends this to get the title of the window, when the user has turned on the full-path name in title bar option.
  
--*/             
{
    LPCITEMIDLIST pidlWalk;
    UINT          uCharacterCount;
    LPCSTR        pszRootName;
    UINT          uRootLength;
    UINT          uParentLength;
    UINT          uChildLength;
    UINT          uTotalLength;
    SHFILEINFOA   shellFileInfo;
    char          szPidlPath[MAX_XBOX_PATH];

    ENTER_SPEW
    DEBUG_DUMP_PIDL(pidl);

    pidlWalk = AdvancePtr(pidl, pidl->mkid.cb);

    //  The normal display for the root, or for a console, is just the simple
    //  short name as return by SHGDN_INFOLDER.
    if(SHGDN_NORMAL==uFlags && (m_uPathDepth<1))
    {
        uFlags = SHGDN_INFOLDER;
    }

    //
    //  The condition was originally SHGDN_INFOLDER, however, this was not sufficient.
    //  The code that updates the title always passes SHGDN_FORADDRESSBAR, if it wants the full
    //  path it also sets SHGDN_FORPARSING.  The documentation on the *actual* use of the flags
    //  by the shell is wrong, but by now we expect nothing more.
    //
    if(uFlags&SHGDN_INFOLDER || ((uFlags&SHGDN_FORADDRESSBAR) && !(SHGDN_FORPARSING&uFlags)))
    {
        //
        //  We are guaranteed to be a simple pidl, if the
        //  caller plays by the rules.  Make sure the caller
        //  is playing by the rules!
        //

        if(pidlWalk->mkid.cb)
        {
            return E_FAIL;
        }

        //
        //  The name is simply pidl->mkid.abID, just
        //  after cb, which is of size sizeof(USHORT).
        //
        
        psr->uType = STRRET_OFFSET;
        psr->uOffset = sizeof(USHORT);
        
       
        //If first character is '?' skip it.
        if('?'==pidl->mkid.abID[0])
        {
            psr->uOffset += 1;
        }
        return S_OK;
    }
    
    // If we are normal, then we have a nicely formated display.
    if(SHGDN_NORMAL==uFlags)
    {   
        //The name is <item> on <machine>.
        char *pszItem = (LPSTR)pidl->mkid.abID;
        char szConsoleName[MAX_XBOX_PATH];
        //Handle Add Xbox wizard
        if('?'==*pszItem) pszItem++;
        GetConsoleName(szConsoleName);
        psr->uType = STRRET_CSTR;
        WindowUtils::rsprintf(psr->cStr, IDS_NORMAL_NAME_FORMAT, pszItem, szConsoleName);
        return S_OK;
    }

    // Get the name of our root.
    if(SHGetFileInfoA((LPSTR)m_pidlRoot, 0, &shellFileInfo, sizeof(shellFileInfo), SHGFI_PIDL|SHGFI_DISPLAYNAME))
    {
        pszRootName = shellFileInfo.szDisplayName;
        uRootLength = 
        uTotalLength = strlen(shellFileInfo.szDisplayName);
        uTotalLength += 1; // the one is for '\\'
    } else
    {
        RETURN(HRESULT_FROM_WIN32(GetLastError()));
    }

    //
    // If we are not the root, add in our path length
    //
    if(0 != m_uPathDepth)
    {
        uParentLength = GetPathLen(); 
        uTotalLength += uParentLength + 1;  // the one is for '\\'
    } else
    {
        uParentLength = 0;
    }
    
    //
    // Path from pidl.
    //
    PathFromPidl(pidl, szPidlPath);
    uChildLength = strlen(szPidlPath)+1;  // the one is for '\0'
    uTotalLength += uChildLength;

    //
    //  Now we have easy access to three pieces:
    //  the root name, our name (if we are not
    //  the root), and the pidl name relative to us.
    //


    //
    //  The total name may be longer than MAX_PATH, so be careful
    //  with psr

    if(MAX_PATH >= uTotalLength)
    {
        LPSTR pszPosition;

        //
        //  Use cStr, copy one element at a time.
        //

        psr->uType = STRRET_CSTR;
        pszPosition = psr->cStr;

        //
        //  The root name, use memcpy, since we
        //  already know the length.
        //

        memcpy(pszPosition, pszRootName, uRootLength);
        pszPosition += uRootLength;

        //
        //  Add a '\\'
        //

        *pszPosition++ = '\\';

        //
        //  If we are not the root, add the parent 
        //  path (that would be this object's path)
        //

        if(uParentLength)
        {
            GetPath(pszPosition);
            pszPosition += uParentLength;
            *pszPosition++ = '\\';
        }

        //
        //  Add the path we got from the pidl.
        //

        memcpy(pszPosition, szPidlPath, uChildLength);
        ATLTRACE("DisplayName = %s\n", psr->cStr);



    } else

    //
    //  Too long STRRET_CSTR, use STRRET_WSTR.
    //
    {
        //
        //  Allocate a buffer for the string with the shell's IMalloc
        //
        LPWSTR pwszPosition = (LPOLESTR)g_pShellMalloc->Alloc(uTotalLength*sizeof(WCHAR));
        if(pwszPosition)
        {
            //
            //  Exactly the same as the cStr case, except
            //  we convert to WCHAR as we copy.
            //

            psr->uType = STRRET_WSTR;
            psr->pOleStr = pwszPosition;
            Utils::CopyAtoW(pwszPosition, pszRootName);
            pwszPosition += uRootLength;
            *pwszPosition++ = L'\\';
            if(uParentLength)
            {
                GetPath(pwszPosition);
                pwszPosition += uParentLength*sizeof(WCHAR);
                *pwszPosition++ = L'\\';
            }
            Utils::CopyAtoW(pwszPosition, szPidlPath);
            ATLTRACE("DisplayName = %ls\n", psr->pOleStr);

        } else
        {
            //
            //  Couldn't allocate buffer/
            //

            return E_OUTOFMEMORY;
        }
    }

    

    return S_OK;
}


HRESULT CXboxFolder::GetUIObjectOf(HWND hwnd, UINT cidl, LPCITEMIDLIST * apidl, REFIID riid, UINT * prgfInOut, void **ppv)
/*++
  Routine Description:
    Implements IShellFolder::GetUIObjectOf.

    Can serve up the following object types:

       Interface     |   C++ Class
       ==========================
       IContextMenu  |  CXboxMenu 
       IDataObject   |  CXboxDataObject
       IDropTarget   |  CXboxDropTarget
       IExtractIcon  |  CXboxIcon

   Arguments:
    hwnd      - if any UI needs to be presented.
    cidl      - number of items items in apidl.
    apidl     - array of child pidls for which to get an object.
    riid      - interface ID desired for object.
    prgfInOut - reserved.
    ppv       - receives pointer.

--*/
{
    HRESULT hr = E_OUTOFMEMORY;

    ENTER_SPEW
    DEBUG_DUMP_IID(riid);

    if(cidl)
    {
        //
        //  If asking for child's object, we need to refresh the list
        //
        hr = RefreshChildren();
        if(FAILED(hr))
        {
            return hr;
        }
    }
    
    //
    //  NULL ppv in case we fail.
    //

    *ppv = NULL;

    //
    //  IExtractIcon is a special case, handle it first.
    //

    if(IID_IExtractIcon == riid)
    {
        CComObject<CXboxExtractIcon> *pExtractIcon = new CComObject<CXboxExtractIcon>;
        if(pExtractIcon)
        {
            VisitThese(cidl, apidl, pExtractIcon, IXboxVisitor::FlagContinue);
            hr = pExtractIcon->GetHResult();
            if(SUCCEEDED(hr))
            {
                hr = pExtractIcon->QueryInterface(IID_IExtractIcon, ppv);
                _ASSERTE(SUCCEEDED(hr));
            } else
            {
                delete pExtractIcon;
            }
        }
        RETURN(hr);
    }

    //
    //  Create the desired object type
    //
    hr = E_NOINTERFACE;

    if(IID_IContextMenu == riid)
    {
        hr = CXboxMenu::Create(cidl, apidl, this, (IContextMenu **)ppv);
    } else if(IID_IDataObject == riid)
    {
        hr = CXboxDataObject::Create(cidl, apidl, this, (IDataObject **)ppv);
    } else if (IID_IDropTarget == riid)
    {
        hr = CXboxDropTarget::Create(hwnd, cidl, apidl, this, (IDropTarget **)ppv);
    } else
    {
        hr = E_NOINTERFACE;
    }
    
    RETURN(hr);
}


HRESULT CXboxFolder::ParseDisplayName(HWND hwnd, LPBC pbc, LPOLESTR pszDisplayName, ULONG *pchEaten, LPITEMIDLIST *ppidl, ULONG *pdwAttributes)
/*++
  Routine Description:
    Implements IShellFolder::ParseDisplayName

    Get a pidl from a display name.  The pidl must be child (not necessarily immediate) of this object.

  Arguments:

    hwnd           - If we decide to display some UI.
    pbc            - a bind context (we ignore it)
    pszDisplayName - a name to parse (UNICODE)
    pchEaten       - [OUT OPTIONAL] how many characters did we eat.
    ppidl          - [OUT] the pidl that matches the display na,e
    pdwAttributes  - [IN OUT OPTIONAL] the desired attributes.

  Return Value:

    On Success - S_OK.
    On Failure - OLE defined error.

  Comments:

    if(pdwAttributes && ((*pdwAttributes)&SFGAO_VALIDATE)) we must make sure the item exists.  If it does not
    we must return an error.  In general, if pdwAttributes, we need to get the attributes.  If the attributes
    selected are determined by class only (i.e. NOT SFGAO_READONLY, SFGAO_HIDDEN, or in most cases SFGAO_FOLDER)
    we can often answer with a canned response.  Otherwise, we have to go over the wire anyway, which validates
    
    We always parse to the end, so *pchEaten is always _wcslen(pszDisplayName) if pchEaten.
--*/
{
    HRESULT  hr = S_OK;
    BOOL     fLeadingSlash;
    BOOL     fTrailingSlash;
    UINT     uDisplayNameLen;
    UINT     uRelativeDepth;
    BOOL     fStrippedProtocol = FALSE;
    
    ENTER_SPEW
    ATLTRACE("DisplayName = %ls", pszDisplayName);

    //
    //  Handle the case were this is the xbox:// protocol
    //
    if(0==wcsncmp(pszDisplayName, L"xbox://", 7))
    {
        pszDisplayName += 7;
        LPWSTR pwszParse = pszDisplayName;
        while(*pwszParse)
        {
            // convert '/' to '\\'
            if(L'/'==*pwszParse) *pwszParse = L'\\';
            pwszParse++;
        }
        if(L'\\' == *(pwszParse-1)) *(pwszParse-1) = L'\0';  //strip '/' or '\\' at the end.
        fStrippedProtocol = TRUE;
    }
    
    //
    //  Get a pidl
    //

    *ppidl =  PidlFromPath(
                   pszDisplayName,
                   &uDisplayNameLen,
                   &uRelativeDepth,
                   &fLeadingSlash,
                   &fTrailingSlash
                   );
    
    //
    //  If we didn't get a pidl there is one reason,
    //  out of memory.
    //

    if(!*ppidl)
    {
        return E_OUTOFMEMORY;
    }

    //
    //  We really don't expect to see pidls with a leading slash.
    //

    _ASSERTE(FALSE == fLeadingSlash);
    

    //
    //  We ate everything. 
    //

    if(pchEaten)
    {
        *pchEaten = uDisplayNameLen;
        if(fStrippedProtocol) *pchEaten += 7;
    }

    //
    //  If attributes are desired, we need to the parent
    //  or the item.
    //

    if(pdwAttributes)
    {
        LPSTR pszPathName = (LPSTR)_alloca(uDisplayNameLen+1);
        Utils::CopyWtoA(pszPathName, fLeadingSlash ? pszDisplayName+1 : pszDisplayName);

        //
        //  If the relative depth is one, it is an immediate child.
        //  As long as SFGAO_VALIDATE is not requested, we can often
        //  just fill out the attributes from our child cache.
        //

        if((1 == uRelativeDepth) && m_fChildrenValid)
        {
            if(!(*pdwAttributes&SFGAO_VALIDATE))
            {
                UINT uChildIndex;
                hr = GetChildIndex(pszPathName, &uChildIndex);
                if(SUCCEEDED(hr))
                {
                    *pdwAttributes &= m_rgulChildShellAttributes[uChildIndex];

                    //
                    //  If the path had a trailing slash and SFGAO_FOLDER
                    //  is not set, it is an illegal path.
                    //

                    if(fTrailingSlash && !(*pdwAttributes&SFGAO_FOLDER))
                    {
                        g_pShellMalloc->Free(*ppidl);
                        *ppidl = NULL;
                        _ASSERT(FALSE);//For early debug purposes.
                        return E_FAIL;
                    }
                    ATLTRACE("Pidl Not verified: ");
                    DEBUG_DUMP_PIDL(*ppidl);
                    return S_OK;
                }
            }
        }
        
        //
        //  We weren't able to get the attributes the quick and dirty way
        //  (either SFGAO_VALIDATE or we had now cached attributes).  So now
        //  force a wire transaction.
        //
        
        hr = ValidateItem(pszPathName, uRelativeDepth, pdwAttributes);
        if(FAILED(hr))
        {
            g_pShellMalloc->Free(*ppidl);
            *ppidl = NULL; 
        }
    }
    if(SUCCEEDED(hr))
    {
        ATLTRACE("Pidl verified: ");
        DEBUG_DUMP_PIDL(*ppidl);
    }
    RETURN(hr);
}


HRESULT CXboxFolder::SetNameOf(HWND hWnd, LPCITEMIDLIST pidl, LPCOLESTR pszName, DWORD uFlags, LPITEMIDLIST *ppidl)
/*++
  Routine Description:
    Does not implement IShellFolder::SetNameOf for consoles or volumes.  This is currently not supported.

    Proper filtering of menu's should prevent ever hitting this routine.
--*/
{
    _ASSERT(FALSE);
    return E_NOTIMPL;
}

HRESULT CXboxFileSystemFolder::SetNameOf(HWND hWnd, LPCITEMIDLIST pidl, LPCOLESTR pszName, DWORD uFlags, LPITEMIDLIST *ppidl)
/*++
  Routine Description:
    Implements IShellFolder::SetNameOf

    Renames a directory or file on an Xbox.

  Arguments:

    hWnd           - If we need to display some UI.
    pidl           - Exactly one SHITEMID.
    pszName        - new name of item.
    uFlags         - type of name.
    ppidl          - [OUT] new pidl of item after rename.

  Return Value:

    On Success - S_OK.
    On Failure - OLE defined error.

  Comments:

    This routine is responsible for sending the rename over the wire.  If hWnd is valid, errors
    are displayed to the user.

    There are four principle reasons that this can fail:

    1) Xbox is unreachable.
    2) Source file does not exist.
    3) Name collision: i.e. new name is already taken.
    4) New name is not a valid item name (too long, illegal character, etc.)

    The first conversion of UNICODE to ANSI will susbstitute '#' for anything with
    the high byte set.  This catchs some illegal character problems.

    For all of these, we hit the wire, and display (and return) an error, based on the
    return value of IXboxConnection::Rename
--*/
{
    HRESULT      hr;
    char         *pszNewName;
    char         szWireNameSource[MAX_PATH];
    char         szWireNameDest[MAX_PATH];
    UINT         uIllegalCharacterCount;
    UINT         uFailResource;
    LPITEMIDLIST pidlAbsolute;
    UINT         uChildIndex;
    UINT         uNewNameLen;
    BOOL         fReturnSuccess = TRUE;
    
    if(ppidl) *ppidl = NULL;

    //
    //  Allocate space for new name
    //

    uNewNameLen = wcslen(pszName)+1;
    pszNewName = new char[uNewNameLen];
    if(!pszNewName)
    {
        return E_OUTOFMEMORY;
    }

    //
    //  Unicode to ANSI conversion
    //

    uIllegalCharacterCount = Utils::CopyWtoA(pszNewName, pszName);
    if(uIllegalCharacterCount)
    {
        if(hWnd)
        {
            WindowUtils::MessageBoxResource(hWnd, IDS_RENAME_ERROR_ILLEGAL_CHARACTERS, IDS_RENAME_ERROR_CAPTION, MB_ICONSTOP|MB_OK);
        }
        delete [] pszNewName;
        return E_INVALIDARG;
    }

    //
    //  It had better be a direct child, find it in our child list.
    //

    RefreshChildren();
    hr = GetChildIndex((LPSTR)pidl->mkid.abID, &uChildIndex);
    if(FAILED(hr))
    {   
        char szError[60];
        FormatUtils::XboxErrorString(hr, szError, sizeof(szError));
        WindowUtils::MessageBoxResource(hWnd, IDS_RENAME_XBDM_ERROR, IDS_RENAME_ERROR_CAPTION, MB_OK|MB_ICONSTOP, szError);
        delete [] pszNewName;
        return hr;
    }

    //
    //  We will need an absolute pidl later to send a notification
    //

    pidlAbsolute = GetChildPidl(uChildIndex, CPidlUtils::PidlTypeAbsolute);

    //
    //  Get the wire names
    //

    GetWireName(szWireNameSource, m_pszPathName, (LPSTR)pidl->mkid.abID);
    GetWireName(szWireNameDest, m_pszPathName, pszNewName);

    hr = SetName(hWnd, szWireNameSource, szWireNameDest);
    if(FAILED(hr))
    {
        char szError[60];
        FormatUtils::XboxErrorString(hr, szError, sizeof(szError));
        if(hWnd)
        {
            WindowUtils::MessageBoxResource(hWnd, IDS_RENAME_XBDM_ERROR, IDS_RENAME_ERROR_CAPTION, MB_OK|MB_ICONSTOP, szError);
        }
    }

    //
    //  After success, update child name
    //  

    if(SUCCEEDED(hr))
    {
        LPITEMIDLIST newPidl;

        //
        //  Update the childname, and file type
        //

        strcpy(m_rgChildFileAttributes[uChildIndex].Name, pszNewName);
        if(!(m_rgChildFileAttributes[uChildIndex].Attributes&FILE_ATTRIBUTE_DIRECTORY))
        {
            delete m_rgszChildTypeNames[uChildIndex];
            m_rgszChildTypeNames[uChildIndex] = GetFileTypeName(&m_rgChildFileAttributes[uChildIndex]);
        }

        //
        //  Get the new full pidl
        //

        newPidl = GetChildPidl(uChildIndex, CPidlUtils::PidlTypeAbsolute);
        if(newPidl)
        {
            if(pidlAbsolute)
            {
                //
                //  Send the notification
                //
                
                SHChangeNotify( 
                    (m_rgulChildShellAttributes[uChildIndex]&SFGAO_FOLDER) ? SHCNE_RENAMEFOLDER : SHCNE_RENAMEITEM,
                    SHCNF_IDLIST|SHCNF_FLUSH,
                    pidlAbsolute,
                    newPidl
                    );

                //
                //  Get pidl for out parameter
                //
            }
            
            g_pShellMalloc->Free(newPidl);
             
            if(ppidl)
            {
                *ppidl = GetChildPidl(uChildIndex, CPidlUtils::PidlTypeSimple);
            }
            
        }
    }
    
    //
    //  Done with the new name, we are not going to use it.
    //
    delete [] pszNewName;

    //
    //  If we managed to allocate the original pidlAbsolute, we need to free it now.
    //

    if(pidlAbsolute)
    {
        g_pShellMalloc->Free(pidlAbsolute);
    }

    if(fReturnSuccess)
    {
        return S_OK;
    }
    return hr;
}


HRESULT CXboxFileSystemFolder::SetName(HWND hWnd, LPSTR szWireNameOld, LPSTR szWireNameNew)
{

    HRESULT hr;

    //
    //  Work-around for bug 10218.  FATX doesn't properly handle renaming
    //  a file to itself perhaps with different capitalization. Since this is
    //  in the kernel ROM and it is not at all important for games, it will
    //  never get fixed.  Basically, we do not support change the capitalization
    //  of the name, we succeed and don't change it.
    if(0==_stricmp(szWireNameOld, szWireNameNew))
    {
            return S_OK;
    }
  
    hr = m_pConnection->HrRenameFile(szWireNameOld, szWireNameNew);
    if(FAILED(hr))
    {
        HRESULT hrLoc;
        DM_FILE_ATTRIBUTES dmFileAttributes;
        DWORD dwOldAttributes;

        //
        //  The return value was XBDM_CANNOTACCESS, see if it was read only,
        //  

        if(hr==XBDM_CANNOTACCESS)
        {
            hrLoc = m_pConnection->HrGetFileAttributes(szWireNameOld, &dmFileAttributes);
            if(SUCCEEDED(hrLoc))
            {
                dwOldAttributes = dmFileAttributes.Attributes;
                if(dwOldAttributes&FILE_ATTRIBUTE_READONLY)
                {
                    // We need to confirm renaming when it is on a read only file.  If we were provided
                    // with an hWnd, and it is not a directory, confirm
                    if(hWnd && !(dwOldAttributes&FILE_ATTRIBUTE_DIRECTORY))
                    {
                        LPSTR pszNewFriendlyName = strrchr(szWireNameNew, '\\');
                        pszNewFriendlyName++;
                        LPSTR pszOldFriendlyName = strrchr(szWireNameOld, '\\');
                        pszOldFriendlyName++;
                        //Confirm renaming of read-only file.
                        if(IDYES != WindowUtils::MessageBoxResource(
                                                    hWnd,
                                                    IDS_CONFIRM_RENAME_RO_FILE,
                                                    IDS_CONFIRM_RENAME_CAPTION,
                                                    MB_YESNO|MB_ICONQUESTION,
                                                    pszOldFriendlyName, pszNewFriendlyName)
                                                    ){
                            // The user didn't want to rename, just return success.
                            // Anything else causes the shell to pop of an error dialog.                           
                            return S_OK;
                        }

                    }
                    dmFileAttributes.Attributes = FILE_ATTRIBUTE_NORMAL;
                    hrLoc = m_pConnection->HrSetFileAttributes(szWireNameOld, &dmFileAttributes);
                    if(SUCCEEDED(hrLoc))
                    {
                        hr = m_pConnection->HrRenameFile(szWireNameOld, szWireNameNew);
                        //Set the attributes back
                        dmFileAttributes.Attributes = dwOldAttributes;
                        m_pConnection->HrSetFileAttributes(SUCCEEDED(hr) ? szWireNameNew : szWireNameOld, &dmFileAttributes);
                    }
                }
            }
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbshlext\utils.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    utils.cpp

Abstract:

    Miscellaneous Utility Methods

Environment:

    Windows 2000 and Later 
    User Mode

Revision History:
    
    03-27-2001 : created

--*/

#include "stdafx.h"
#include <stdio.h>

using namespace Utils;

STDAPI InitVariantFromBuffer(VARIANT *pvar, const void *pv, UINT cb)
{
    HRESULT hres;
    SAFEARRAY *psa = SafeArrayCreateVector(VT_UI1, 0, cb);   // create a one-dimensional safe array
    if (psa) 
    {
        memcpy(psa->pvData, pv, cb);

        memset(pvar, 0, sizeof(*pvar));  // VariantInit()
        pvar->vt = VT_ARRAY | VT_UI1;
        pvar->parray = psa;
        hres = S_OK;
    }
    else
        hres = E_OUTOFMEMORY;
    return hres;
}

STDAPI InitVariantFromString(VARIANT *pvar, LPCSTR szString)
{
   OLECHAR  oleszString[MAX_PATH];
   LPCSTR   szTemp = szString;
   LPOLESTR oleszTemp = oleszString; 

   //Copy to OLECHAR
   while(szTemp) *oleszTemp++ = (OLECHAR)*szTemp++;
   
   //Copy variant
   pvar->vt = VT_BSTR;
   pvar->bstrVal = SysAllocString(oleszString);
   if(pvar->bstrVal)
   {
        return S_OK;
   }
   
   return E_OUTOFMEMORY;
}


void FormatUtils::FileSize(ULONGLONG ullFileSize, LPSTR pszOutputBuffer)
/*++
  Routine Description:
    Give the nFileSizeHigh and nFileSizeLow of file formats the size as a readable string in the
    caller's buffer.
  Arguments:
    ullFileSize        - size of the file in bytes
    pszOutputBuffer    - pointer to user buffer to receive formated size - 
                         assumed to be large enough (25 characters?)
--*/
{
    UINT   uFormatResource = IDS_PRELOAD_FILESIZE_FORMAT_BYTES;
    double dbFileSize      = (double)ullFileSize;

    //
    //  Depending on the size the result in bytes, KB, MB, or GB.
    //  
    while(dbFileSize >= 1024 && uFormatResource!=IDS_PRELOAD_FILESIZE_FORMAT_GB)
    {
        dbFileSize /= 1024;
        uFormatResource++;
    }
    // Cannot use wsprintf, as it does not format floating point.
    sprintf(pszOutputBuffer, WindowUtils::GetPreloadedString(uFormatResource), dbFileSize);
}

static void FormatByteStringRecurse(ULONGLONG ullBytes, LPSTR *pszNextChar)
{
    if(ullBytes > 1000)
    {
        FormatByteStringRecurse(ullBytes/1000, pszNextChar);
        *pszNextChar += wsprintfA(
                            *pszNextChar,
                            WindowUtils::GetPreloadedString(IDS_PRELOAD_FILEBYTESIZE_FORMAT1),
                            (ULONG)(ullBytes%1000));
        return;
    }
    *pszNextChar += wsprintfA(*pszNextChar, "%d", (ULONG)ullBytes);
}

void FormatUtils::FileSizeBytes(ULONGLONG ullBytes, LPSTR pszOutputBuffer)
/*++
  Routine Description:
    Take a long long and convert it to a string indicating the count of bytes.
    The key feature that wsprintf cannot do is create a comma separate number.
--*/
{
    FormatByteStringRecurse(ullBytes, &pszOutputBuffer);
    strcpy(pszOutputBuffer, WindowUtils::GetPreloadedString(IDS_PRELOAD_FILEBYTESIZE_FORMAT2));
}

void FormatUtils::FileTime(const FILETIME *cpftTime, LPSTR pszOutputBuffer, DWORD dwFlags)
/*++
  Routine Description:
    Uses the WIN32 international API to format file times.  Takes a file time and produces a string
    with the user's selected localized date format immediately followed by the user's selected
    localized time format.
  
  Arguments:
    cpftTime         - filetime (modified or created)
    pszOutputBuffer  - buffer to receive string.  Should be of length MAX_PATH.
    dwFlags          - DATE_SHORTDATE or DATE_LONGDATE (Actually, anything that GetDateFormat accepts)

--*/
{
    SYSTEMTIME sysTime;
    int iCharCount;
    if(FileTimeToSystemTime(cpftTime, &sysTime))
    {
        //
        // Convert System Time to Local Time
        //
        TIME_ZONE_INFORMATION tzi;
        SYSTEMTIME sysTimeLocal;
        if(GetTimeZoneInformation(&tzi) != TIME_ZONE_ID_UNKNOWN)
        {
	        if(SystemTimeToTzSpecificLocalTime(&tzi, &sysTime, &sysTimeLocal))
            {
		        sysTime = sysTimeLocal;
            }
        }

        //
        //  Get date, and time
        //
        pszOutputBuffer[0] = '\0';
        iCharCount = GetDateFormatA(LOCALE_USER_DEFAULT, dwFlags, &sysTime, NULL, pszOutputBuffer, MAX_PATH);
        if(iCharCount)
        {
            pszOutputBuffer[iCharCount-1] = ' ';
            pszOutputBuffer[iCharCount] = '\0';
            GetTimeFormatA(LOCALE_USER_DEFAULT, 0, &sysTime, NULL, pszOutputBuffer+iCharCount, MAX_PATH-iCharCount);
        }
    }
}

void FormatUtils::FileAttributes(DWORD dwAttributes, LPSTR pszOutputBuffer)
{
    UINT uIndex;
    uIndex = 0;
    if(dwAttributes&FILE_ATTRIBUTE_READONLY)
    {
        pszOutputBuffer[uIndex++] = 'R';
    }
    if(dwAttributes&FILE_ATTRIBUTE_HIDDEN)
    {
        pszOutputBuffer[uIndex++] = 'H';
    }
    pszOutputBuffer[uIndex] = '\0';
}

UINT FGetErrorStringResourceId(HRESULT hr)
{
	switch(hr) {
	case E_FAIL:
	case E_UNEXPECTED:
		return IDC_E_UNEXPECTED;
	case E_INVALIDARG:
		return IDC_E_INVALIDARG;
    default:
        if(FAILED(hr) && HRESULT_FACILITY(hr) == FACILITY_XBDM)
            return 0x8000 | (hr & 0xfff);
        break;
	}
    return 0;
}
HRESULT FormatUtils::XboxErrorString(HRESULT hr, LPSTR lpBuffer, int nBufferMax)
{
    UINT    resourceId;
    int     len=TRUE;
    HRESULT hrRes = XBDM_NOERR;

    //Parameter check.
    if( (!lpBuffer) || (nBufferMax <= 0))
    {
        return E_INVALIDARG;
    }
    
    //Make sure it is an XBDM facility, otherwise use FormatMessage.
    if(FACILITY_XBDM == HRESULT_FACILITY(hr))
    {

        //Get the resource ID
        resourceId = FGetErrorStringResourceId(hr);
        if(0==resourceId) 
        {
            hrRes = XBDM_NOERRORSTRING;
            resourceId = IDC_XBDM_NOERRORSTRING;
        }

        //Load the string
        len = LoadStringA(_Module.GetModuleInstance(), resourceId, lpBuffer, nBufferMax);
        
    } else
    {
       if(!FormatMessageA( FORMAT_MESSAGE_FROM_SYSTEM, NULL, hr, 0, lpBuffer, nBufferMax, NULL))
       {
           len = LoadStringA(_Module.GetModuleInstance(), IDC_E_UNEXPECTED, lpBuffer, nBufferMax);
       }
    }
    if(0==len)
    {
       hrRes = HRESULT_FROM_WIN32(GetLastError());
    }
    return hrRes;
}

BOOL WindowUtils::SubstituteWindowText(HWND hWnd,...)
/*++
  Routine Description:
    Reads the window text of any Window and treats it as the format string.
    Then calls _vstprintf to format the string and puts it back in the
    Window.

  Arguments:
    nFileSizeHigh       - high DWORD of filesize
    nFileSizeLow        - low DWORD of filesize
    ptszOutputBuffer    - pointer to user buffer to receive formated size
    ccBufferSize        - count in characters of ptszOutputBuffer
--*/
{
    va_list vl;
    char szFormat[256];
    char szResult[1024];
    BOOL fResult;

    va_start(vl, hWnd); 
    fResult = GetWindowTextA(hWnd, szFormat, ARRAYSIZE(szFormat));
    if(fResult)
    {
        wvsprintfA(szResult, szFormat, vl);
        fResult = SetWindowTextA(hWnd, szResult);
    }
    va_end(vl);
    return fResult;
}

int  WindowUtils::rsprintf(LPSTR pBuffer, UINT uFormatResource,...)
{
    int i=0;
    va_list vl;
    char szFormat[512];
    if(LoadStringA(_Module.GetModuleInstance(), uFormatResource, szFormat, sizeof(szFormat)))
    {
        va_start(vl, uFormatResource); 
        i = wvsprintfA(pBuffer, szFormat, vl);
        va_end(vl);
    }
    return i;
}


void WindowUtils::ReplaceWindowIcon(HWND hWnd, HICON hIcon)
{
    if (hIcon)
    {
        hIcon = (HICON)SendMessage(hWnd, STM_SETICON, (WPARAM)hIcon, 0L);
        if (hIcon)
            DestroyIcon(hIcon);
    }
}

int WindowUtils::MessageBoxResource(HWND hWnd, UINT uTextResource, UINT uCaptionResource, UINT uType, ...)
{
    va_list vl;
    char MessageText[512];
    char MessageTextTemplate[255];
    char MessageCaption[255];
    if(LoadStringA(_Module.GetModuleInstance(), uTextResource,  MessageTextTemplate, ARRAYSIZE(MessageTextTemplate)))
    {
        va_start(vl, uType);
        wvsprintfA(MessageText, MessageTextTemplate, vl);
        va_end(vl);
    }
    LoadStringA(_Module.GetModuleInstance(), uCaptionResource,  MessageCaption, ARRAYSIZE(MessageCaption));
    return MessageBoxA(hWnd, MessageText, MessageCaption, uType);
}


HANDLE WindowUtils::CreateTempFile(char *pszFileName, bool fOpen)
/*++
  Routine Description:
   Creates a temporary file, opens it, and returns the handle and the
   name.

   This is useful, because usually when you generate a temporary filename
   you also want to open it.  Furthermore, the WIN32 API for generating
   temporary filenames are just too flexible.
--*/
{
    char szTempPath[MAX_PATH];
    HANDLE hFile = INVALID_HANDLE_VALUE;
    if(GetTempPathA(sizeof(szTempPath), szTempPath))
    {
        if(GetTempFileNameA(szTempPath, "xse", 0, pszFileName))
        {
            if(fOpen)
            {
                hFile = CreateFileA(
                    pszFileName,
                    GENERIC_READ|GENERIC_WRITE,
                    0,
                    NULL,
                    CREATE_ALWAYS,
                    FILE_ATTRIBUTE_NORMAL|
                    FILE_ATTRIBUTE_TEMPORARY,
                    NULL
                    );
            } else
            {
                hFile = 0;
            }
        }
    }
    return hFile;
}

HWND WindowUtils::CreateWorkerWindow(HWND hWndParent)
{
    WNDCLASSA wc = {0};
    if(!GetClassInfoA(_Module.GetModuleInstance(), "XboxWorker", &wc))
    {
        wc.lpfnWndProc = DefWindowProcA;
        wc.cbWndExtra = sizeof(void *);
        wc.hInstance = _Module.GetModuleInstance();
        wc.hCursor = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground = (HBRUSH)(COLOR_BTNFACE + 1);
        wc.lpszClassName = "XboxWorker";
        RegisterClassA(&wc);
    }

    HWND hwnd = CreateWindowExA(0, "XboxWorker", NULL, 0, 0, 0, 0, 0, NULL, NULL, _Module.GetModuleInstance(), NULL);
    if(hwnd)
    {
        SetWindowLongPtr(hwnd, 0, NULL);
    }
    return hwnd;
}

BOOL WindowUtils::IsMainShellProcess()
{
    DWORD dwProcessId;
    HWND hWndDesktop = GetDesktopWindow();
    GetWindowThreadProcessId(hWndDesktop, &dwProcessId);
    return dwProcessId == GetCurrentProcessId();
}

class CPreloadedStrings
{
  public:
    CPreloadedStrings();
    ~CPreloadedStrings();
    LPCSTR GetString(UINT uResourceId);
  private:
    LPSTR m_Strings[IDS_NEXT_PRELOADED_STRING-IDS_FIRST_PRELOADED_STRING];
};

CPreloadedStrings::CPreloadedStrings()
{
    memset(m_Strings, 0, sizeof(m_Strings));
}

CPreloadedStrings::~CPreloadedStrings()
{
    UINT uIndex;
    for(uIndex = 0; uIndex < (IDS_NEXT_PRELOADED_STRING-IDS_FIRST_PRELOADED_STRING); uIndex++)
    {
        delete m_Strings[uIndex];
    }
}

LPCSTR CPreloadedStrings::GetString(UINT uResourceId)
/*++
  Routine Description:
    Returns a constant pointer to a resource string.

    Implements a lazy load-once model.
--*/
{
    _ASSERTE(uResourceId >= IDS_FIRST_PRELOADED_STRING); 
    _ASSERTE(uResourceId < IDS_NEXT_PRELOADED_STRING); 

    UINT uIndex;
    uIndex = uResourceId-IDS_FIRST_PRELOADED_STRING;
    
    if(NULL == m_Strings[uIndex])
    {
        char szStringBuffer[512];
        if(LoadStringA(_Module.GetModuleInstance(), uResourceId, szStringBuffer, sizeof(szStringBuffer)))
        {
            m_Strings[uIndex] = new char[strlen(szStringBuffer)+1];
            if(m_Strings[uIndex])
            {
                strcpy(m_Strings[uIndex], szStringBuffer);
            }
        }
    }
    
    return m_Strings[uIndex];
}
CPreloadedStrings g_PreloadedStrings;


LPCSTR WindowUtils::GetPreloadedString(UINT uResourceId)
/*++
  Routine Description:

    Gets a preloaded string.
    Uses CPreloadedStrings to do the work.  The main point of CPreloadedStrings
    is so that the d'tor can cleanup automagically when the module is unloaded,
    so that we do not leak.

  Arguments:

    uResourceID - ID of string to preload. Must be in preloaded string range.
--*/
{
    return g_PreloadedStrings.GetString(uResourceId);
}


UINT Utils::CopyWtoA(LPSTR pszDest, LPCWSTR pwszSource)
/*++
  Routine Description:
    Copys a UNICODE string to ASCII (not MBCS).  It substitutes
    # for every unrecognized character.  It returns the count of
    such characters.
--*/
{
    UINT uSubstituteCount = 0;
    while(*pwszSource)
    {
        if(*pwszSource&0xff00)
        {
            uSubstituteCount++;
            pwszSource++;
            *pszDest++ = '#';
        } else
        {
            *pszDest++ = (char)(*pwszSource++);
        }
    }
    *pszDest = '\0';
    return uSubstituteCount;
}

HRESULT Utils::GetXboxConnection(LPCSTR szXboxName, IXboxConnection **ppXboxConnection, DWORD dwMillisecondTimeout)
{
    HRESULT hr;
    hr = DmGetXboxConnection(szXboxName,XBCONN_VERSION,ppXboxConnection);
    if(SUCCEEDED(hr))
    {
        hr = (*ppXboxConnection)->HrSetConnectionTimeout(dwMillisecondTimeout, 0);
        if(FAILED(hr))
        {
            (*ppXboxConnection)->Release();
            *ppXboxConnection = NULL;
        }
    }
    return hr;
}

BOOL Utils::VerifyXboxAlive(LPCSTR szXboxName)
{
    BOOL fResult = FALSE;
    HRESULT hr;
    IXboxConnection *pConnection;
    hr = DmGetXboxConnection(szXboxName,XBCONN_VERSION, &pConnection);
    if(SUCCEEDED(hr))
    {
        char szConsoleName[20];
        DWORD dwLen = sizeof(szConsoleName);
        hr = pConnection->HrGetNameOfXbox(szConsoleName, &dwLen, FALSE);
        pConnection->Release();
        if((XBDM_CANNOTCONNECT != hr) && (XBDM_CONNECTIONLOST != hr))
        {
            fResult = TRUE;
        }
    }
    return fResult;
}

HRESULT Utils::ScreenCapture(HWND hWnd, LPCSTR szXboxName)
{
  CWaitCursor waitCursor;
  char szImagePath[MAX_PATH];
  char szImageFile[MAX_PATH];
  UINT uImageNumber = 1;
  UINT uPathLen;
  DWORD dwError;
  HRESULT hr;

  //Get the mypictures folder
  SHGetFolderPathA(hWnd, CSIDL_MYPICTURES|CSIDL_FLAG_CREATE, NULL, SHGFP_TYPE_CURRENT,szImagePath);
  uPathLen = strlen(szImagePath);
           
  //Terminate the path with '\\'
  if(szImagePath[uPathLen-1] != '\\')
  {
    szImagePath[uPathLen++] = '\\';
    szImagePath[uPathLen]='\0';
  }
           
  do
  {
    HANDLE hFile;
    wsprintfA(szImageFile, "%s%s-image%d.bmp", szImagePath, szXboxName, uImageNumber++);
    hFile = CreateFileA(szImageFile, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);

    if(INVALID_HANDLE_VALUE != hFile)
    {
        dwError = ERROR_SUCCESS;
        CloseHandle(hFile);
        IXboxConnection *pConnection;
        hr = Utils::GetXboxConnection(szXboxName, &pConnection);
        if(SUCCEEDED(hr))
        {
            hr = pConnection->HrScreenShot(szImageFile);
            if(SUCCEEDED(hr))
            {
                SHELLEXECUTEINFOA shellExecuteInfo;
                memset(&shellExecuteInfo, 0, sizeof(SHELLEXECUTEINFOA));
                shellExecuteInfo.cbSize = sizeof(SHELLEXECUTEINFOA);
                shellExecuteInfo.hwnd = hWnd;
                shellExecuteInfo.lpVerb = "open";
                shellExecuteInfo.lpFile = szImageFile;
                shellExecuteInfo.nShow = SW_SHOWNORMAL;
                ShellExecuteExA(&shellExecuteInfo);
             }
        }
        if(FAILED(hr))
        {
            char szError[60];
            FormatUtils::XboxErrorString(hr, szError, sizeof(szError));
            WindowUtils::MessageBoxResource(hWnd, IDS_COULDNT_GET_SCREEN_SHOT, IDS_GENERIC_CAPTION, MB_OK|MB_ICONSTOP, szXboxName, szError);
            DeleteFileA(szImageFile);
        }
        break;
    }
    dwError = GetLastError();
  } while(ERROR_FILE_EXISTS == dwError  || ERROR_ALREADY_EXISTS == dwError);
  
  if(ERROR_SUCCESS != dwError)
  { 
    char szError[60];
    FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwError, 0, szError, sizeof(szError), NULL);
    WindowUtils::MessageBoxResource(hWnd, IDS_COULDNT_GET_SCREEN_SHOT, IDS_GENERIC_CAPTION, MB_OK|MB_ICONSTOP, szXboxName, szError);
    hr = HRESULT_FROM_WIN32(dwError);
   }
   return hr;
}

HRESULT Utils::XboxErrorToWindowsError(HRESULT hr)
{
    switch(hr)
    {
        case XBDM_MAXCONNECT:
            return HRESULT_FROM_WIN32(ERROR_REQ_NOT_ACCEP);
        case XBDM_BADFILENAME:
            return HRESULT_FROM_WIN32(ERROR_INVALID_NAME);
        case XBDM_NOSUCHFILE:
            return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        case XBDM_CANNOTACCESS:
            return E_ACCESSDENIED;
        case XBDM_CANNOTCREATE:
            return HRESULT_FROM_WIN32(ERROR_CANNOT_MAKE);
        case XBDM_DEVICEFULL:
            return HRESULT_FROM_WIN32(ERROR_DISK_FULL);
        case XBDM_ALREADYEXISTS:
            return HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS);
        case XBDM_DIRNOTEMPTY:
            return HRESULT_FROM_WIN32(ERROR_DIR_NOT_EMPTY);
        case XBDM_CANNOTCONNECT:
        case XBDM_CONNECTIONLOST:
            return HRESULT_FROM_WIN32(ERROR_CONNECTION_UNAVAIL);
        // The rest of these are either not applicable to the shell extension,
        // Or should never be returned, or are simply too generic to worry about.
        case XBDM_NOMODULE:
        case XBDM_MEMUNMAPPED:
        case XBDM_NOTHREAD:
        case XBDM_CLOCKNOTSET:
        case XBDM_INVALIDCMD:
        case XBDM_NOTSTOPPED:
        case XBDM_MUSTCOPY:
        case XBDM_NOTDEBUGGABLE:
        case XBDM_BADCOUNTTYPE:
        case XBDM_COUNTUNAVAILABLE:
        case XBDM_NOTLOCKED:
        case XBDM_KEYXCHG:
        case XBDM_FILEERROR:
        case XBDM_ENDOFLIST:
        case XBDM_BUFFER_TOO_SMALL:
        case XBDM_NOTXBEFILE:
        case XBDM_MEMSETINCOMPLETE:
        case XBDM_NOXBOXNAME:
        case XBDM_NOERRORSTRING:
        case XBDM_CONNECTED:
        case XBDM_MULTIRESPONSE:
        case XBDM_BINRESPONSE:
        case XBDM_READYFORBIN:
        case XBDM_DEDICATED:
        default:
            return E_FAIL;

    }
    return E_FAIL;
}

HRESULT ComUtils::QueryService(IUnknown* pUnknown, REFGUID guidService, REFIID riid, void **ppv)
/*++
 Routine Description:
   Little Utility to get a COM service.
--*/
{
    HRESULT hres;
    IServiceProvider *pServiceProvider = NULL;

    *ppv = NULL;
    if(!pUnknown)
        return E_FAIL;

    hres = pUnknown->QueryInterface(IID_IServiceProvider, (void **)&pServiceProvider);

    if(SUCCEEDED(hres))
    {
        hres = pServiceProvider->QueryService(guidService, riid, ppv);
        pServiceProvider->Release();
    }
    return hres;
}


void ComUtils::DumpIID(REFIID riid)
{
    if(riid == IID_IShellFolder)
    {
        OutputDebugStringA("IID_IShellFolder");
    } else if (riid == IID_IShellFolder2)
    {
        OutputDebugStringA("IID_IShellFolder2");
    } else if (riid == IID_IPersistFolder)
    {
        OutputDebugStringA("IID_IPersistFolder");
    } else if (riid == IID_IPersistFolder2)
    {
        OutputDebugStringA("IID_IPersistFolder2");
    } else if (riid == IID_IDataObject)
    {
        OutputDebugStringA("IID_IDataObject");
    } else if (riid == IID_IContextMenu)
    {
        OutputDebugStringA("IID_IContextMenu");
    } else if (riid == IID_IDropTarget)
    {
        OutputDebugStringA("IID_IDropTarget");
    } else if (riid == IID_IExtractIcon)
    {
        OutputDebugStringA("IID_IExtractIcon");
    } else if (riid == IID_IShellView)
    {
        OutputDebugStringA("IID_IShellView");
    } else if (riid == IID_IShellView2)
    {
        OutputDebugStringA("IID_IShellView2");
    } else if (riid == IID_IShellFolderView)
    {
        OutputDebugStringA("IID_IShellFolderView");
    } else if (riid == IID_IUnknown)
    {
        OutputDebugStringA("IID_IUnknown");
    } else if (riid == IID_IDropSource)
    {
        OutputDebugStringA("IID_IDropSource");
    } else if (riid == IID_IObjectWithSite)
    {
        OutputDebugStringA("IID_IObjectWithSite");
    } else if (riid == IID_IShellLink)
    {
        OutputDebugStringA("IID_IShellLink");
    } else if (riid == IID_IDelegateFolder)
    {
        OutputDebugStringA("IID_IDelegateFolder");
    } else
    {
        WCHAR wszBuffer[60];
        StringFromGUID2(riid, wszBuffer, ARRAYSIZE(wszBuffer));
        OutputDebugStringW(wszBuffer);
    }
}  


HRESULT ComUtils::QueryWindow(HWND *phWnd, IUnknown *pUnk)
/*++
  Given an IUnknown interface to an object it just may support another interface that allows you to retrieve its
  Window.  For example, a progress dialog.  It is worth a try.  Callers should have a fall back plan
  though since this isn't officially documented.  The shell code tried IOleWindow, IShellView and IInternetSecurityMgr.
  This routine doesn't bother trying IInternetSecurityMgr.  It probably doesn't need to try IShellView either.

  Unlike the shell's IUnknown_GetWindow, this routine preserves the value of *phWnd on failure.  Why?  This way
  the caller may set it to the default choice, and not bother checking the error code.  If this routine fails,
  then they will just get their own default.
--*/
{
    HRESULT hr = E_INVALIDARG;
    if (pUnk) 
    {
        HWND hOrgWnd = *phWnd;
        *phWnd = NULL;

        IOleWindow* pOleWindow;
        IShellView* pShellView;

        hr = pUnk->QueryInterface(IID_PPV_ARG(IOleWindow, &pOleWindow));
        if (SUCCEEDED(hr))
        {
            hr = pOleWindow->GetWindow(phWnd);
            pOleWindow->Release();
        }
        else if (SUCCEEDED(hr = pUnk->QueryInterface(IID_PPV_ARG(IShellView, &pShellView))))
        {
            hr = pShellView->GetWindow(phWnd);
            pShellView->Release();
        }

        // If this failed, restore the original.
        if(FAILED(hr))
        {
            *phWnd = hOrgWnd;
        }
    }
    return hr;
}

HRESULT DataObjUtil::SetHGLOBAL(IDataObject *pdtobj, UINT cf, HGLOBAL hGlobal)
{
    FORMATETC fmte = {(CLIPFORMAT) cf, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM medium;

    medium.tymed = TYMED_HGLOBAL;
    medium.hGlobal = hGlobal;
    medium.pUnkForRelease = NULL;

    // give the data object ownership of ths
    return pdtobj->SetData(&fmte, &medium, TRUE);
}

HRESULT DataObjUtil::SetDWORD(IDataObject *pdtobj, UINT cf, DWORD dw)
{
    HRESULT hr = E_OUTOFMEMORY;
    DWORD *pdw = (DWORD *)GlobalAlloc(GPTR, sizeof(DWORD));
    if (pdw)
    {
        *pdw = dw;
        hr = SetHGLOBAL(pdtobj, cf, pdw);

        if (FAILED(hr))
            GlobalFree((HGLOBAL)pdw);
    }
    return hr;
}


HRESULT DataObjUtil::GetDWORD(IDataObject *pDataObject, UINT cf, DWORD *pdw)
{
    FORMATETC formatEtc = {(CLIPFORMAT) cf, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM stgMedium;
    *pdw = 0;    
    HRESULT hr = pDataObject->GetData(&formatEtc, &stgMedium);
    if(SUCCEEDED(hr))
    {
        *pdw = *((DWORD *)GlobalLock(stgMedium.hGlobal));
        ReleaseStgMedium(&stgMedium);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbshlext\utils.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    utils.h

Abstract:
    
    All kinds of utility methods.  These are sorted by namespaces
    and implemented in various files.

    namespace Utils - 

Environment:

    Windows 2000 and Later 
    User Mode

Revision History:
    
    03-27-2001 : created

--*/
#ifndef __UTILS_H__
#define __UTILS_H__

//-----------------------------------------------------------
//  Useful Macros
//-----------------------------------------------------------
#ifndef ARRAYSIZE
#define ARRAYSIZE(a) (sizeof(a)/sizeof((a)[0]))
#endif

//-----------------------------------------------------------
//  Utilities for using standard Windows Stuff:
//      Resources, Windows, Icons, Files, etc.
//-----------------------------------------------------------
namespace WindowUtils
{
    BOOL   SubstituteWindowText(HWND hWnd,...);
    int    rsprintf(LPSTR pBuffer, UINT uFormatResource,...);
    void   ReplaceWindowIcon(HWND hWnd, HICON hIcon);
    int    MessageBoxResource(HWND hWnd, UINT uTextResource, UINT uCaptionResource, UINT uType, ...);
    HANDLE CreateTempFile(char *pszFileName, bool fOpen=true);
    LPCSTR GetPreloadedString(UINT uResourceId);
    HWND   CreateWorkerWindow(HWND hWndParent);
    BOOL   IsMainShellProcess();
}

//-----------------------------------------------------------
//  Wait cursor
//-----------------------------------------------------------
class CWaitCursor
{
  public:
    CWaitCursor() : m_hOldCursor(NULL), m_fWait(false) {Set();}
    ~CWaitCursor(){Reset();}
    inline void Set() {if(!m_fWait) m_hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT)); m_fWait=true;}
    inline void Reset() {if(m_fWait) SetCursor(m_hOldCursor); m_fWait = false;}
    bool    m_fWait;
    HCURSOR m_hOldCursor;
};

//-----------------------------------------------------------
//  Formatting of various properties for display.
//-----------------------------------------------------------
namespace FormatUtils
{
    void FileSize(ULONGLONG ullFileSize, LPSTR pszOutputBuffer);
    void FileSizeBytes(ULONGLONG ullBytes, LPSTR pszOutputBuffer);
    void FileTime(const FILETIME *cpftTime, LPSTR pszOutputBuffer, DWORD dwFlags = DATE_SHORTDATE);
    void FileAttributes(DWORD dwAttributes, LPSTR pszOutputBuffer);
    HRESULT XboxErrorString(HRESULT hr, LPSTR szString, int nBufferMax);
}

//-----------------------------------------------------------
//  Utilities for working with COM.
//-----------------------------------------------------------
namespace ComUtils
{
    HRESULT QueryService(IUnknown* pUnknown, REFGUID guidService, REFIID riid, void **ppv);
    void DumpIID(REFIID riid);
    HRESULT QueryWindow(HWND *phWnd, IUnknown *pUnk);
}
#if NEVER
#define DEBUG_DUMP_IID(_riid_) ComUtils::DumpIID(_riid_)
#else
#define DEBUG_DUMP_IID(_riid_)
#endif

//-----------------------------------------------------------
//  Truly Miscellaneous Utilities.
//-----------------------------------------------------------
namespace Utils
{
    inline void CopyAtoW(LPWSTR pwszDest, LPCSTR pszSource) {while(*pszSource) *pwszDest++ = (WCHAR)(*pszSource++); *pwszDest = (WCHAR)*pszSource;}
    UINT CopyWtoA(LPSTR pszDest, LPCWSTR pwszSource);
    HRESULT GetXboxConnection(LPCSTR szXboxName, IXboxConnection **ppXboxConnection, DWORD dwMillisecondTimeout = 5000);
    BOOL VerifyXboxAlive(LPCSTR szXboxName);
    HRESULT ScreenCapture(HWND hWnd, LPCSTR szXboxName);
    HRESULT XboxErrorToWindowsError(HRESULT hr);
}

//-----------------------------------------------------------
//  Utilities For Manipulating DataObjects
//-----------------------------------------------------------
namespace DataObjUtil
{
    HRESULT SetHGLOBAL(IDataObject *pdtobj, UINT cf, HGLOBAL hGlobal);
    HRESULT SetDWORD(IDataObject *pdtobj, UINT cf, DWORD dw);
    HRESULT GetDWORD(IDataObject *pDataObject, UINT cf, DWORD *pdw);
    inline HRESULT SetPreferredDropEffect(IDataObject *pdtobj, DWORD dwEffect)
    {
        return SetDWORD(pdtobj, CF_PREFERREDDROPEFFECT, dwEffect);
    }
    inline HRESULT SetPerformedDropEffect(IDataObject *pdtobj, DWORD dwEffect)
    {
        return SetDWORD(pdtobj, CF_PERFORMEDDDROPEFFECT, dwEffect);
    }
    inline HRESULT SetPasteSucceeded(IDataObject *pdtobj, DWORD dwEffect)
    {
        return SetDWORD(pdtobj, CF_PASTESUCCEEDED, dwEffect);
    }
    inline HRESULT GetPreferredDropEffect(IDataObject *pdtobj, DWORD *pdwEffect)
    {
        return GetDWORD(pdtobj, CF_PREFERREDDROPEFFECT, pdwEffect);
    }
    inline HRESULT GetPerformedDropEffect(IDataObject *pdtobj, DWORD *pdwEffect)
    {
        return GetDWORD(pdtobj, CF_PERFORMEDDDROPEFFECT, pdwEffect);
    }
    inline HRESULT GetPasteSucceeded(IDataObject *pdtobj, DWORD *pdwEffect)
    {
        return GetDWORD(pdtobj, CF_PASTESUCCEEDED, pdwEffect);
    }
}

//-----------------------------------------------------------
//  Utilities For Displaying Dialogs 
//-----------------------------------------------------------
namespace Dialog
{

UINT
ConfirmReadOnlyMove(
    HWND hwndParent,
    LPCSTR pszFileName,
    bool fFolder
    );

UINT
ConfirmFolderReplace(
    HWND hWndParent,
    LPCSTR pszFileName
    );

UINT
ConfirmFileReplace(
    HWND hwndParent,
    LPCSTR pszFileName,
    WIN32_FILE_ATTRIBUTE_DATA *pTargetFileAttributes,
    WIN32_FILE_ATTRIBUTE_DATA *pSourceFileAttributes
    );


UINT
ConfirmDelete(
    HWND hWndParent,
    LPCSTR pszFileName,
    bool fFolder,
    bool fReadOnly
    );

UINT
ConfirmDeleteMultiple(
    HWND hWndParent,
    UINT uCount
    );

UINT
ConfirmDeleteFolder(
    HWND hWndParent,
    LPCSTR pszFileName
    );

UINT 
ConfirmSetAttributes(
    HWND hWndParent,
    DWORD dwSetAttributes,
    DWORD dwClearAttributes,
    BOOL fMultiItem
    );

UINT
PromptUserName(
    HWND hWndParent,
    LPSTR pszUserName,
    int iMaxCount
    );

UINT
PromptNewPassword(
    HWND hWndParent,
    LPSTR pszPassword,
    int iMaxCount
    );

}

#endif __UTILS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbshlext\view.h ===
/*++

Copyright (c) Microsoft Corporation


Module Name:

    view.h

Abstract:
    
    Declaration of the various classes which implement the folder views.

Environment:

    Windows 2000
    Uses ATL
    Depends on Private shell32 and shdocvw APIs

Notes:

Revision History:

    March 2001 - created by Mitchell Dernis (mitchd)

--*/
#ifndef __XBOXVIEW_H__
#define __XBOXVIEW_H__

//-------------------------------------------------------------------------------
//  Declaration of CXboxViewCB
//-------------------------------------------------------------------------------
class ATL_NO_VTABLE CXboxViewCB : 
	public CComObjectRootEx<CComMultiThreadModel>,
    public CShellObjectWithSite,
    public IShellFolderViewCB
    CTRACKABLEOBJECT
{
 public:

  /*
  ** ATL COM INTERFACE MAP
  */

  DECLARE_PROTECT_FINAL_CONSTRUCT()
  BEGIN_COM_MAP(CXboxViewCB)
    COM_INTERFACE_ENTRY_IID(IID_IObjectWithSite, CShellObjectWithSite)
    COM_INTERFACE_ENTRY_IID(IID_IShellFolderViewCB, IShellFolderViewCB)
  END_COM_MAP()

 public:

  /*
  **  IShellFolderViewCB Method (one and only)
  */
 
  STDMETHOD(MessageSFVCB)(UINT uMsg, WPARAM wParam, LPARAM lParam);

  /*
  **
  **  IShellFolderViewCB is nothing more than dispatch type interface wrapping
  **  windows messages.  The implementation of MessageSFVCB cracks the applicable
  **  messages and calls the appropriate virtual functions listed below, some of
  **  which are pure virtual.
  */
 
  HRESULT OnDefItemCount(LPINT pi);
  HRESULT OnGetHelpText(int ici, LPWSTR pszHelpText, int cChar);
  HRESULT OnGetPane(DWORD dwPaneID, DWORD *pdwPane);
  HRESULT OnRefresh(BOOL fReload);
  HRESULT OnDidDragDrop(DWORD dwDropEffect, IDataObject * pdto);
  HRESULT OnGetDetailsOf(UINT ici, PDETAILSINFO pdi);
  HRESULT OnInvokeCommand(UINT idc);
  HRESULT OnGetNotify(LPITEMIDLIST * ppidl, LONG * lEvents);
  HRESULT OnFSNotify(LPITEMIDLIST  pidl, LONG lEvent);
  HRESULT OnThisIDList(LPITEMIDLIST * ppidl);
  HRESULT OnSetISFV(IShellFolderView *pShellFolderView);
  HRESULT OnColumnClick(UINT ici);
  HRESULT OnUpdateStatusBar(void);
  //NYI - but we really don't want the default behavior
  HRESULT OnAddPropertyPages(SFVM_PROPPAGE_DATA * pData) {return E_NOTIMPL;}
  HRESULT OnSize(LONG x, LONG y) {return SetStatusParts();}
  
  HRESULT OnMergeMenu(LPQCMINFO pqcm){return S_OK;}
  HRESULT OnUnMergeMenu(HMENU hMenu){return S_OK;}


  /*
  **  Utility Methods
  */
  HRESULT SetStatusParts();
  

  /*
  ** Construction related methods
  */

  static HRESULT CreateShellView(CXboxFolder *pXboxFolder, HWND hWnd, REFIID riid, void **ppv);
  CXboxViewCB() : m_pXboxFolder(NULL) {INIT_TRACKABLEOBJECT_NAME(CXboxViewCB);}
  ~CXboxViewCB()
  {
      if(m_pXboxFolder) m_pXboxFolder->Release();
  }
  
  protected:
    CXboxFolder       *m_pXboxFolder;    // The CXboxItem which this view is displaying
    HWND               m_hWnd;           // The Window of IShellView
};

#endif //__XBOXVIEW_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbshlext\view.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    view.cpp

Abstract:

    Implementation of CXboxViewCB

Environment:

    Windows 2000 and Later 
    User Mode
    ATL
    Depends on Private Shell APIs.

Revision History:
    
    03-28-2001 : created (mitchd)

--*/

#include "stdafx.h"


//------------------------------------------------------------
//  Useful Definitions
//------------------------------------------------------------
#define XBOX_SHCNE_EVENTS \
            (SHCNE_DISKEVENTS   |\
             SHCNE_ASSOCCHANGED |\
             SHCNE_RMDIR        |\
             SHCNE_DELETE       |\
             SHCNE_MKDIR        |\
             SHCNE_CREATE       |\
             SHCNE_RENAMEFOLDER |\
             SHCNE_RENAMEITEM   |\
             SHCNE_UPDATEITEM   |\
             SHCNE_ATTRIBUTES)

#define XBOX_STATUS_PART_WIDTH  165

//------------------------------------------------------------
//  Creating a ShellView
//------------------------------------------------------------
HRESULT CXboxViewCB::CreateShellView(CXboxFolder *pXboxFolder, HWND hWnd, REFIID riid, void **ppv)
/*++
  Routine Description:
    Creates a CDefView with an instance of CXboxViewCB as the callback to represent
    the view of pXboxFolder.

    This method mostly could be implemented 
    A factory method for getting an instance of an IShellView, IShellView2 or
    an other method that CDefView supports.
--*/
{
   HRESULT                  hr;
   CComObject<CXboxViewCB> *pViewCB = NULL;
   IShellFolderViewCB      *pShellFolderViewCB = NULL;
   IShellFolder            *pShellFolder = NULL;
   IShellView              *pShellView = NULL;
   
   *ppv = NULL;

   hr = CComObject<CXboxViewCB>::CreateInstance(&pViewCB);
   if(SUCCEEDED(hr))
   {
      //
      // Introduce the view to its parent\creator, this object.
      //
      pXboxFolder->AddRef();
      pViewCB->m_pXboxFolder = pXboxFolder;
      pViewCB->m_hWnd = hWnd;

      //
      // QI the view for its IShellFolderViewCB interface.
      // (This cannot fail.  We know it has the interface.)
      //

      hr = pViewCB->QueryInterface(IID_PPV_ARG(IShellFolderViewCB, &pShellFolderViewCB));
      _ASSERTE(SUCCEEDED(hr));
      
      //
      // QI the CXboxFolder for IShellFolder.
      // (This cannot fail.  We know it has the interface.)
      //

      hr = pXboxFolder->QueryInterface(IID_PPV_ARG(IShellFolder,&pShellFolder));
      _ASSERTE(SUCCEEDED(hr));
      
      //
      //  UNDOCUMENTED:
      //      Calls SHCreateShellFolderView, which is a private undocumented
      //      shell function to create a shell default view.
      //

      SFV_CREATE sfvCreate;
      sfvCreate.cbSize = sizeof(SFV_CREATE);
      sfvCreate.pshf = pShellFolder;
      sfvCreate.psvOuter = NULL;  // Add an outer, if we want to add an interface to the web view.
      sfvCreate.psfvcb = pShellFolderViewCB; // Add a callback later, as the features start taking shape.
      hr = SHCreateShellFolderView(&sfvCreate, &pShellView);
      if(SUCCEEDED(hr))
      {
        *ppv = pShellView;
      }
      
      //
      // We are done with these interfaces.  The shell view should have AddRef'd them
      // during the call to SHCreateShellFolderView.
      //

      pShellFolder->Release();
      pShellFolderViewCB->Release();

   }
   return hr;
}

HRESULT
CXboxViewCB::MessageSFVCB(
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
/*++
  Routine Description:
  
    This is a message dispatch routine for the callback.  For the most part we
    crack messages and call routines that handle each message.  In a few cases,
    the message is handled inline.

--*/
{
    HRESULT hr = E_FAIL;

    switch (uMsg)
    {
      
      //
      // Messages cracked and dispatched
      //
      case DVM_DEFITEMCOUNT:
        hr = OnDefItemCount((LPINT)lParam);
        break;
      case DVM_GETHELPTEXT:
        hr = OnGetHelpText((int)LOWORD(wParam), (LPWSTR)lParam, (int)HIWORD(wParam));
        break;
      case SFVM_GETPANE:
        hr = OnGetPane((DWORD) wParam, (DWORD *)lParam);
        break;
      case DVM_REFRESH:
        hr = OnRefresh((BOOL) wParam);
        break;
      case DVM_DIDDRAGDROP:
        hr = OnDidDragDrop(wParam, (IDataObject *)lParam);
        break;
      case DVM_GETDETAILSOF:
        hr = OnGetDetailsOf((UINT)wParam, (PDETAILSINFO)lParam);
        break;
      case DVM_COLUMNCLICK:
        hr = OnColumnClick((UINT)wParam);
        break;
      case DVM_MERGEMENU:
        hr = OnMergeMenu((LPQCMINFO)lParam);
        break;
      case DVM_UNMERGEMENU:
        hr = OnUnMergeMenu((HMENU)lParam);
        break;
      case DVM_INVOKECOMMAND:
        hr = OnInvokeCommand((UINT)wParam);
        break;
      case SFVM_GETNOTIFY:
        hr = OnGetNotify((LPITEMIDLIST *) wParam, (LONG *) lParam);
        break;
      case SFVM_FSNOTIFY:
        hr = OnFSNotify((LPITEMIDLIST) wParam, (LONG ) lParam);
        break;
      case SFVM_SIZE:
        hr = OnSize((LONG) wParam, (LONG) lParam);
        break;
      case DVM_UPDATESTATUSBAR:
        hr = OnUpdateStatusBar();
        break;
      case SFVM_THISIDLIST:
        hr = OnThisIDList((LPITEMIDLIST *) lParam);
        break;
      case SFVM_ADDPROPERTYPAGES:
        hr = OnAddPropertyPages((SFVM_PROPPAGE_DATA *)lParam);
        break;
      //
      // Messages handled in place
      //
      case SFVM_BACKGROUNDENUMDONE:
        hr = S_OK;
        break;
      case DVM_INITMENUPOPUP:
        hr =S_OK;
        break;
      case DVM_RELEASE:
      {
        IShellFolderViewCB *pfv = (IShellFolderViewCB*)lParam;
        if (pfv)
            hr = pfv->Release();
      }
        break;
      case DVM_BACKGROUNDENUM:
        //  WARNING!  If we return S_OK from DVM_BACKGROUNDENUM, we also
        //  are promising that we support free threading on our IEnumIDList
        //  interface!  This allows the shell to do enumeration on our
        //  IEnumIDList on a separate background thread.
        hr = S_OK; // Don't enum in background
        break;
      case SFVM_DONTCUSTOMIZE:
        if (lParam)
            *((BOOL *) lParam) = FALSE;  // Yes, we are customizable.
        hr = S_OK;
        break;
      case SFVM_GETZONE:
        //Consider us the local machine (for now anyway).
        *((DWORD *)lParam) = URLZONE_LOCAL_MACHINE;
        hr = S_OK;
        break;
      case DVM_WINDOWCREATED:
        hr = S_OK;
        break;

    // Others that aren't currently handled.
#if 0
    NOTHANDLED(SFVM_SETISFV);           //We handle SetSite
    NOTHANDLED(DVM_GETTOOLTIPTEXT);
    NOTHANDLED(SFVM_QUERYFSNOTIFY);
    
    NOTHANDLED(SFVM_GETHELPTOPIC);
    NOTHANDLED(DVM_GETBUTTONINFO);
    NOTHANDLED(DVM_GETBUTTONS);
    NOTHANDLED(DVM_SELCHANGE);
    NOTHANDLED(DVM_DRAWITEM);
    NOTHANDLED(DVM_MEASUREITEM);
    NOTHANDLED(DVM_EXITMENULOOP);
    NOTHANDLED(DVM_GETCCHMAX);
    NOTHANDLED(DVM_WINDOWDESTROY);
    NOTHANDLED(DVM_SETFOCUS);
    NOTHANDLED(DVM_KILLFOCUS);
    NOTHANDLED(DVM_QUERYCOPYHOOK);
    NOTHANDLED(DVM_NOTIFYCOPYHOOK);
    NOTHANDLED(DVM_DEFVIEWMODE);
    NOTHANDLED(DVM_INSERTITEM);         // Too verbose
    NOTHANDLED(DVM_DELETEITEM);         // Too verbose
    NOTHANDLED(DVM_GETWORKINGDIR);
    NOTHANDLED(DVM_GETCOLSAVESTREAM);
    NOTHANDLED(DVM_SELECTALL);
    NOTHANDLED(DVM_SUPPORTSIDENTIFY);
    NOTHANDLED(DVM_FOLDERISPARENT);
#endif
    default:
        hr = E_NOTIMPL;
        break;
    }

    return hr;
}


HRESULT CXboxViewCB::OnDefItemCount(LPINT pi)
/*++
  Routine Description:
    Requests a preliminary guess of how many items we may have.

  Comments:
    Ask our Xbox Folder how many children we have.  In many
    circumstances it knows.  Just in case it doesn't we
    set the fGuesstimate parameter as TRUE.  This tells the
    folder not to do something time consuming like go over the
    wire, if it doesn't already know.  Instead it makes a better
    guess than we can.
    
  Arguments:
    pi - pointer to receive count.
--*/
{
    *pi = m_pXboxFolder->GetChildCount(TRUE);
    return S_OK;
}



HRESULT CXboxViewCB::OnGetHelpText(int /*ici*/, LPWSTR pszHelpText, int cChar)
/*++
  Routine Description:  
    Gets a help string for each UI element.
  Arguments:
    ici - column index
    pszHelpText - help string
    cChar - count in characters of pszHelpText buffer.
--*/
{
    wcsncpy(pszHelpText, L"", cChar);
    return S_OK;
}

HRESULT CXboxViewCB::OnGetPane(DWORD dwPaneID, DWORD *pdwPane)
/*++
  Routine Description:  
    Not 100% clear on the concept, yet, but I am pretty sure:
    
    Divides the status bar into multiple panes.  You may assign an ordinal
    to each pane type.  The bar is divided into enough panes for your highest
    oridinal.  If some numbers are skipped you just have blank panes.

  Arguments:
    dwPaneID - pane type
    pdwPane - pointer to oridinal for pane

  Remarks:
    *pdwPane is NO_PANE (-1) on entry.

--*/
{
    return S_OK;
}


HRESULT CXboxViewCB::OnRefresh(BOOL fReload)
/*++
  Routine Description:  
    Reenumerate everything.  The default view does most of the work.  However,
    we need to tell our CXboxFolder to invalidate the information

  Arguments:
    fReload - TRUE if we have to this
    
--*/
{
    //We can deal later
    if(fReload)
    {
        //
        //  The folder should forget about its children
        //  and go and reenumerate them.
        //
        m_pXboxFolder->InvalidateChildList();
        
    }
    return S_OK;
}



HRESULT CXboxViewCB::OnDidDragDrop(DWORD dwDropEffect, IDataObject * pdo)
/*++
  Routine Description:  
    Notifies us that a drag and drop operation completed.  If it was a move,
    return FALSE.  This basically delegates the delete portion to our
    parent.  It should work by calling delete on our context menu.
--*/
{
    HRESULT hr = S_OK;
    if (DROPEFFECT_MOVE == dwDropEffect)
    {
        IAsyncOperation *pao;
        hr = pdo->QueryInterface(IID_IAsyncOperation, (void **) &pao);
        if (SUCCEEDED(hr))
        {
            BOOL fInAsyncOp = TRUE;
            hr = S_OK;  // Don't have caller do the delete.
            if(SUCCEEDED(pao->InOperation(&fInAsyncOp)))
            {
                if (FALSE == fInAsyncOp)
                {
                    hr = S_FALSE;   // Have parent do the delete.
                }
            }
            pao->Release();
        }
    }
    return hr;
}

typedef struct _SHELLDETAILSINFO
{
    LPCITEMIDLIST pidl;
    SHELLDETAILS  shellDetails;
    int iImage;
} SHELLDETAILSINFO;


HRESULT CXboxViewCB::OnGetDetailsOf(UINT iColumn, PDETAILSINFO pdi)
/*++
  Routine Description:
    Get information about the columns (either for an item, or the column header).
    Actually, our folder implements not us, so like most everything else, we 
    delegate.
--*/
{
  SHELLDETAILSINFO *pShellDetailsInfo = (SHELLDETAILSINFO *)pdi;
  if(pdi->pidl)
  {
    return m_pXboxFolder->GetDetails(pdi->pidl, iColumn, &pShellDetailsInfo->shellDetails);
  } else
  {
    return m_pXboxFolder->GetColumnHeaderDetails(iColumn, &pShellDetailsInfo->shellDetails);
  }
}

HRESULT CXboxViewCB::OnInvokeCommand(UINT idc)
/*++
  Routine Description:
    Some of the "shared" menu commands end up here, rather than in our context
    menu.  Go figure.  So we need to support them here.

  NYI
--*/
{
    HRESULT hr = S_OK;
    /*
    switch (idc)
    {
        case IDM_SORTBYNAME:
        case IDM_SORTBYSIZE:
        case IDM_SORTBYTYPE:
        case IDM_SORTBYDATE:
          hr = CXboxViewCB::OnColumnClick(MESSAGE_TO_ICI(idc));
          break;
        case IDC_ITEM_NEWFOLDER:
          OnInvokeNewFolder(m_hWnd);
        break;

     default:
        ASSERT(0);
        hr = E_NOTIMPL;
        break;
    }
    */
    return hr;
}



HRESULT CXboxViewCB::OnGetNotify(LPITEMIDLIST *ppidl, LONG * lEvents)
/*++

  Routine Description:
    The browser is asking which notifications we want, and what PIDL
     to use as a context.

  Arguments:
   ppidl - put the pidl here
   lEvents - fill out any event flags you want.
     
--*/
{
    HRESULT hr;
    *lEvents = XBOX_SHCNE_EVENTS;
    *ppidl = m_pXboxFolder->GetPidl(CPidlUtils::PidlTypeAbsolute);
    if(NULL == *ppidl)     
    {
       return E_OUTOFMEMORY;
    }
    return S_OK;
}

HRESULT CXboxViewCB::OnFSNotify(LPITEMIDLIST  pidl, LONG lEvent)
{
    m_pXboxFolder->InvalidateChildList();
    return S_OK;
}

/*++
OnThisIDList
    Routine Description:
     Get the pidl relative to our root.

    Arguments:
     ppidl - put the pidl here
--*/
HRESULT CXboxViewCB::OnThisIDList(LPITEMIDLIST * ppidl)
{
    *ppidl = m_pXboxFolder->GetPidl(CPidlUtils::PidlTypeRoot);
    if(NULL == *ppidl)     
    {
       return E_OUTOFMEMORY;
    }
    return S_OK;
}

HRESULT CXboxViewCB::OnColumnClick(UINT ici)
{
    HRESULT hr;
    IShellFolderView *pShellFolderView;
    hr = GetSite(IID_PPV_ARG(IShellFolderView, &pShellFolderView));
    if(SUCCEEDED(hr))
    {
        hr = pShellFolderView->Rearrange(ici);
        pShellFolderView->Release();
    }
    return hr;
}

HRESULT CXboxViewCB::OnUpdateStatusBar(void)
{
    HRESULT hr;
    LRESULT lr;
    UINT uObjCount = 0;
    UINT uSelectCount = 0;
    LPCITEMIDLIST *pidls = NULL;
    
    //
    //  Get the ShellFolderView, we can get information about the number objects,
    //  how many and which objects are selected.
    //
    IShellFolderView *pShellFolderView;
    hr = GetSite(IID_PPV_ARG(IShellFolderView, &pShellFolderView));
    if(SUCCEEDED(hr))
    {
        //
        //  Get the count of total objects in the view
        //
        hr = pShellFolderView->GetObjectCount(&uObjCount);
        _ASSERT(SUCCEEDED(hr));

        //
        //  Get the selected objects
        //
        hr = pShellFolderView->GetSelectedObjects(&pidls, &uSelectCount);
        _ASSERT(SUCCEEDED(hr));

        //
        //  Get an interface to a shell browser
        //
        IShellBrowser *pShellBrowser;
        hr = GetService(SID_SShellBrowser, IID_PPV_ARG(IShellBrowser, &pShellBrowser));
        if(SUCCEEDED(hr))
        {
            /*
            **  Main of the operations may fail.  Oh well, the status bar won't look right.  Don't bother
            **  saving or looking at the error codes, since there is nothing to be done about it.
            */
            
            //
            //  Update the Icon in the zone area
            //
            HICON hXboxIcon = (HICON)LoadImage(_Module.GetModuleInstance(), MAKEINTRESOURCE(IDI_MAIN), IMAGE_ICON, 16, 16, LR_LOADMAP3DCOLORS);
            pShellBrowser->SendControlMsg(FCW_STATUS, SB_SETICON, (WPARAM)1, (LPARAM)hXboxIcon, &lr);

            //
            //  Update the Text in the zone area
            //
            char szConsoleName[60];
            m_pXboxFolder->GetConsoleName(szConsoleName);
            if(*szConsoleName)
            {
                pShellBrowser->SendControlMsg(FCW_STATUS, SB_SETTEXTA, (WPARAM)1, (LPARAM)szConsoleName, &lr);
            } else
            {
                pShellBrowser->SendControlMsg(FCW_STATUS, SB_SETTEXTA, (WPARAM)1, (LPARAM)WindowUtils::GetPreloadedString(IDS_PRELOAD_XBOX_ZONE_NAME), &lr);
            }
            
            //
            //  If there are no objects selected, show the object count in the 0th part
            //
            if(0==uSelectCount)
            {
                char szBuffer[30];
                WindowUtils::rsprintf(szBuffer, IDS_STATUS_OBJECT_COUNT_FORMAT, uObjCount);
                pShellBrowser->SendControlMsg(FCW_STATUS, SB_SETTEXTA, (WPARAM)0, (LPARAM)szBuffer, &lr);
            }
            //
            //  If there is more than one object selected, show the selected object count in the 0th part
            //
            else if(1<uSelectCount)
            {
                char szBuffer[30];
                WindowUtils::rsprintf(szBuffer, IDS_STATUS_SELOBJECT_COUNT_FORMAT, uSelectCount);
                pShellBrowser->SendControlMsg(FCW_STATUS, SB_SETTEXTA, (WPARAM)0, (LPARAM)szBuffer, &lr);
            }
            //
            //  Othewise, let the folder set the text for the 0th part
            //
            else
            {
                m_pXboxFolder->SetStatusBarText(pShellBrowser, pidls[0]);
            }
            pShellBrowser->Release();
        }

        //
        //  Done with the ShellFolderView
        //
        pShellFolderView->Release();
    }
    
    // Whether or not we managed to update the status bar, we probably don't want to alert the
    // shell or the user, so just say S_OK.
    return S_OK;
}


HRESULT CXboxViewCB::SetStatusParts()
{
    HRESULT hr;
    LRESULT lr;
    UINT i;
    HWND hStatusWnd;
    RECT statusRect;
    UINT uRightCoordinateArray[2];

    // Get the pShellBrowser, without it we cannot do anything.
    IShellBrowser *pShellBrowser;
    hr = GetService(SID_SShellBrowser, IID_PPV_ARG(IShellBrowser, &pShellBrowser));
    if(FAILED(hr))
        return hr;

    // Get the status window
    hr = pShellBrowser->GetControlWindow(FCW_STATUS, &hStatusWnd);
    if(SUCCEEDED(hr))
    {
        // Get the client rect of the status window
        if(GetClientRect(hStatusWnd, &statusRect))
        {
            // Calculate where the divider goes between the two pains.
            if(statusRect.right < 2*XBOX_STATUS_PART_WIDTH)
            {
                uRightCoordinateArray[0] = statusRect.right/2;
            } else
            {
                uRightCoordinateArray[0] = statusRect.right - XBOX_STATUS_PART_WIDTH;
            }
            uRightCoordinateArray[1] = -1;
            
            // Update the SB_SETPARTS
            hr = pShellBrowser->SendControlMsg(
                    FCW_STATUS, SB_SETPARTS, (WPARAM)2, (LPARAM)uRightCoordinateArray, &lr);
        }else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    //Done with the shell browser
    pShellBrowser->Release();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbshlext\visit.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    visit.cpp

Abstract:

  Implements the visitor model for CXboxFolder items.

  This uses a number of helper classes all defined and
  implemented here.  These are all mutual friends of the
  appropriate CXboxFolder class and should be considered
  part of their private implementation.

  In general, the Visit member of the various CXboxFolder
  instantiates one of these helpers on the stack, updates
  its internal context and then calls the appropriate
  member of IVisitor.

Environment:

    Windows 2000 and Later 
    User Mode
    Compiles UNICODE, but explictly most things are ANSI,
    since the Xbox filesystem is all ANSI.

Revision History:
    
    07-13-01 Created by Mitchell Dernis (mitchd)

--*/
#include <stdafx.h>

//-------------------------------------------------------------------
//  CFolderVisit - base class implements IXboxVisit for everone that
//                 is not 'FromSelf' or 'Recurse'
//-------------------------------------------------------------------
class CFolderVisit : public IXboxVisit
{
 public:
   virtual void         GetName(OUT LPSTR pszItemName)
                            {strcpy(pszItemName, m_pFolder->m_rgpszChildNames[m_uChildIndex]);}

   virtual LPITEMIDLIST GetPidl(CPidlUtils::PIDLTYPE PidlType)
                            {return m_pFolder->GetChildPidl(m_uChildIndex, PidlType);}

   virtual ULONG        GetShellAttributes()
                            {return m_pFolder->m_rgulChildShellAttributes[m_uChildIndex];}

   virtual void         GetConsoleName(OUT LPSTR pszConsoleName);
   
   //   Context 
   //
   CXboxFolder *m_pFolder;
   UINT         m_uChildIndex;
};

void CFolderVisit::GetConsoleName(OUT LPSTR pszConsoleName)
{
    LPSTR pszPathName;
    
    if(m_pFolder->m_uPathDepth)
    {
        pszPathName = m_pFolder->m_pszPathName;
    } else
    {
        pszPathName = m_pFolder->m_rgpszChildNames[this->m_uChildIndex];
    }
    while(*pszPathName && (*pszPathName!='\\'))
    {
        *pszConsoleName++ = *pszPathName++;
    }
    *pszConsoleName = '\0';
}

//-------------------------------------------------------------------
//  CFolderVisitFromSelf - base class implements IXboxVisit for everone that
//                         is 'FromSelf'
//-------------------------------------------------------------------
class CFolderVisitFromSelf : public IXboxVisit
{
 public:
   virtual void         GetName(OUT LPSTR pszItemName)
                            {m_pFolder->GetName(pszItemName);}

   virtual LPITEMIDLIST GetPidl(CPidlUtils::PIDLTYPE PidlType)
                            {return m_pFolder->GetPidl(PidlType);}

   virtual ULONG        GetShellAttributes()
                            {return m_pFolder->GetShellAttributes();}
   
   virtual void         GetConsoleName(OUT LPSTR pszConsoleName);
   //
   //   Context 
   //
   CXboxFolder *m_pFolder;
};

void CFolderVisitFromSelf::GetConsoleName(OUT LPSTR pszConsoleName)
{
    LPSTR pszPathName = m_pFolder->m_pszPathName;
    if(m_pFolder->m_uPathDepth)
    {
        while(*pszPathName && (*pszPathName!='\\'))
        {
            *pszConsoleName++ = *pszPathName++;
        }
    }
    *pszConsoleName = '\0';
}

//-------------------------------------------------------------------
//  MACRO to help everyone inheriting from CFolderVisit or CFolderVisitFromSelf
//-------------------------------------------------------------------
#define USE_BASE_VISITIMPL(_BaseType_)\
    virtual void GetName(OUT LPSTR pszItemName){_BaseType_::GetName(pszItemName);}\
    virtual LPITEMIDLIST GetPidl(CPidlUtils::PIDLTYPE PidlType){return _BaseType_::GetPidl(PidlType);}\
    virtual ULONG GetShellAttributes() {return _BaseType_::GetShellAttributes();}\
    virtual void GetConsoleName(OUT LPSTR pszConsoleName) {_BaseType_::GetConsoleName(pszConsoleName);}


//-------------------------------------------------------------------
// CConsoleVisit - implements IXboxConsoleVisit for CXboxRoot
//-------------------------------------------------------------------
class CConsoleVisit : public CFolderVisit, public IXboxConsoleVisit
{
  public:
   virtual DWORD        GetIPAddress()
                            {return m_pRoot->GetChildIpAddress(m_uChildIndex, TRUE);}
   virtual void         SetDefault(BOOL fMakeDefault);
   virtual BOOL         GetDefault();

   //
   //   Context 
   //
   CXboxRoot    *m_pRoot;
   USE_BASE_VISITIMPL(CFolderVisit)
   
};

void CConsoleVisit::SetDefault(BOOL fMakeDefault)
{
    CManageConsoles manageConsoles;
    manageConsoles.SetDefault(fMakeDefault ? m_pFolder->m_rgpszChildNames[m_uChildIndex] : NULL);
}
BOOL CConsoleVisit::GetDefault()
{
    CManageConsoles manageConsoles;
    return manageConsoles.IsDefault(m_pFolder->m_rgpszChildNames[m_uChildIndex]);
}

//-------------------------------------------------------------------
// CConsoleVisit - implements IXboxConsoleVisit for CXboxConsole
//-------------------------------------------------------------------
class CConsoleVisitFromSelf : public CFolderVisitFromSelf, public IXboxConsoleVisit
{
  public:
   virtual DWORD        GetIPAddress()
                            {return m_pConsole->m_dwIPAddress;}
   virtual void         SetDefault(BOOL fMakeDefault);
   virtual BOOL         GetDefault();

   //
   //   Context 
   //
   CXboxConsole        *m_pConsole;
    USE_BASE_VISITIMPL(CFolderVisitFromSelf)
};

void CConsoleVisitFromSelf::SetDefault(BOOL fMakeDefault)
{
    CManageConsoles manageConsoles;
    manageConsoles.SetDefault(fMakeDefault ? m_pFolder->m_pszPathName : NULL);
}
BOOL CConsoleVisitFromSelf::GetDefault()
{
    CManageConsoles manageConsoles;
    return manageConsoles.IsDefault(m_pFolder->m_pszPathName);
}

//-------------------------------------------------------------------
// CVolumeVisit - implements IXboxVolumeVisit for CXboxConsole
//-------------------------------------------------------------------
class CVolumeVisit :  public CFolderVisit, public IXboxVolumeVisit
{
  public:
   virtual int   GetVolumeType()
                    {return m_pConsole->m_rguChildVolumeType[m_uChildIndex];}
   virtual void  GetDiskCapacity(PULONGLONG pullTotalCapacity, PULONGLONG pullFreeCapacity)
                    {*pullTotalCapacity = m_pConsole->m_rgullChildTotalSpace[m_uChildIndex];
                     *pullFreeCapacity  = m_pConsole->m_rgullChildFreeSpace[m_uChildIndex];}
  
   //
   //   Context 
   //
   CXboxConsole *m_pConsole;
   USE_BASE_VISITIMPL(CFolderVisit)
};

//-------------------------------------------------------------------
// CVolumeVisitFromSelf - implements IXboxVolumeVisit for CXboxVolume
//-------------------------------------------------------------------
class CVolumeVisitFromSelf : public CFolderVisitFromSelf, public IXboxVolumeVisit
{
  public:
   virtual int          GetVolumeType()
                            {return m_pVolume->m_uVolumeType;}
   virtual void         GetDiskCapacity(PULONGLONG pullTotalCapacity, PULONGLONG pullFreeCapacity);
  
   //
   //   Context
   //
   CXboxVolume *m_pVolume;
   USE_BASE_VISITIMPL(CFolderVisitFromSelf)
};

void  CVolumeVisitFromSelf::GetDiskCapacity(PULONGLONG pullTotalCapacity, PULONGLONG pullFreeCapacity)
{
    char szWireName[MAX_PATH];
    CXboxFolder::GetWireName(
        szWireName,
        NULL,
        m_pVolume->m_pszPathName
        );
    ULARGE_INTEGER uliBogus;
    m_pVolume->m_pConnection->HrGetDiskFreeSpace(
                szWireName,
                (PULARGE_INTEGER)pullFreeCapacity,
                (PULARGE_INTEGER)pullTotalCapacity,
                &uliBogus
                );

}
//---------------------------------------------------------------------
// CFileOrDirVisit - implements IXboxFileOrDirVisit for a parent CXboxFileSystemFolder
//---------------------------------------------------------------------
class CFileOrDirVisit: public CFolderVisit, public IXboxFileOrDirVisit
{
  public:
   virtual void    GetFileAttributes(PDM_FILE_ATTRIBUTES pdmFileAttributes);
   virtual HRESULT SetFileAttributes(PDM_FILE_ATTRIBUTES pdmFileAttributes);
   virtual HRESULT SetName(HWND hWnd, LPSTR pszNewName);
   virtual HRESULT Delete();
   virtual void    GetWireName(LPSTR pszWireName);
   //
   //   Context
   //
   CXboxFileSystemFolder *m_pFileSystemFolder;
   USE_BASE_VISITIMPL(CFolderVisit)
};

void  CFileOrDirVisit::GetFileAttributes(PDM_FILE_ATTRIBUTES pDmFileAttributes)
{
    memcpy(
      pDmFileAttributes,
      &m_pFileSystemFolder->m_rgChildFileAttributes[m_uChildIndex],
      sizeof(DM_FILE_ATTRIBUTES)
      );
}

HRESULT CFileOrDirVisit::SetFileAttributes(PDM_FILE_ATTRIBUTES pdmFileAttributes)
{
    char szWireName[MAX_PATH];
    CXboxFolder::GetWireName(
        szWireName,
        m_pFileSystemFolder->m_pszPathName,
        m_pFileSystemFolder->m_rgpszChildNames[m_uChildIndex]
        );
    if(!pdmFileAttributes->Attributes) pdmFileAttributes->Attributes = FILE_ATTRIBUTE_NORMAL;
    HRESULT hr=m_pFileSystemFolder->m_pConnection->HrSetFileAttributes(szWireName, pdmFileAttributes);
    if(SUCCEEDED(hr))
    {
        m_pFileSystemFolder->m_rgChildFileAttributes[m_uChildIndex].Attributes = pdmFileAttributes->Attributes;
        if(pdmFileAttributes->Attributes&FILE_ATTRIBUTE_READONLY)
        {
            m_pFileSystemFolder->m_rgulChildShellAttributes[m_uChildIndex] |= SFGAO_READONLY;
        } else
        {
            m_pFileSystemFolder->m_rgulChildShellAttributes[m_uChildIndex] &= ~SFGAO_READONLY;
        }
        
        if(pdmFileAttributes->Attributes&FILE_ATTRIBUTE_HIDDEN)
        {
            m_pFileSystemFolder->m_rgulChildShellAttributes[m_uChildIndex] |= (SFGAO_HIDDEN|SFGAO_GHOSTED);
        } else
        {
            m_pFileSystemFolder->m_rgulChildShellAttributes[m_uChildIndex] &= ~(SFGAO_HIDDEN|SFGAO_GHOSTED);
        }
    }
    return hr;
}

HRESULT CFileOrDirVisit::SetName(HWND hWnd, LPSTR pszNewName)
{
    if(strlen(pszNewName) != _mbstrlen(pszNewName))
    {
        return XBDM_BADFILENAME;;
    }

    HRESULT hr = S_OK;
    char szWireNameOld[MAX_PATH];
    char szWireNameNew[MAX_PATH];
    LPSTR pszNewNameCopy  = new char[strlen(pszNewName)+1];
    if(pszNewNameCopy)
    {
        strcpy(pszNewNameCopy, pszNewName);
        CXboxFolder::GetWireName(
            szWireNameOld,
            m_pFileSystemFolder->m_pszPathName,
            m_pFileSystemFolder->m_rgpszChildNames[m_uChildIndex]
            );
    
        CXboxFolder::GetWireName(
            szWireNameNew,
            m_pFileSystemFolder->m_pszPathName,
            pszNewNameCopy
            );
    
        LPITEMIDLIST oldPidl = GetPidl(CPidlUtils::PidlTypeAbsolute);

        if(oldPidl)
        {
            hr = m_pFileSystemFolder->SetName(hWnd, szWireNameOld, szWireNameNew);
            if(SUCCEEDED(hr))
            {
                delete m_pFileSystemFolder->m_rgpszChildNames[m_uChildIndex];
                m_pFileSystemFolder->m_rgpszChildNames[m_uChildIndex] = pszNewNameCopy;
                LPITEMIDLIST newPidl = GetPidl(CPidlUtils::PidlTypeAbsolute);
                if(newPidl)
                {
                    DWORD dwEvent;
                    if(m_pFileSystemFolder->m_rgulChildShellAttributes[m_uChildIndex]&SFGAO_FOLDER)
                    {
                        dwEvent = SHCNE_RENAMEFOLDER;
                    } else
                    {
                        dwEvent = SHCNE_RENAMEITEM;
                    }
                    SHChangeNotify(dwEvent, SHCNF_FLUSH|SHCNF_IDLIST, oldPidl, newPidl);
                    CPidlUtils::Free(newPidl);
                }
            } else
            {
                delete [] pszNewNameCopy;
            }
            CPidlUtils::Free(oldPidl);
        }
    }
    return hr;
}

HRESULT CFileOrDirVisit::Delete()
{
    char szWireName[MAX_PATH];
    HRESULT hr;
    IXboxConnection *pConnection = m_pFileSystemFolder->m_pConnection;
    BOOL fIsFolder = (m_pFileSystemFolder->m_rgulChildShellAttributes[m_uChildIndex]&SFGAO_FOLDER) ? TRUE : FALSE;

    //
    //  It is probably pretty bad to do this, if this is not
    //  a selection clone.  Infact, the selection code, itself
    //  is toast after deleting everything.  One additionally hopes
    //  that any none clones are going to get refreshed.
    //
    _ASSERTE(m_pFileSystemFolder->m_fSelectionClone);

    CXboxFolder::GetWireName(
        szWireName,
        m_pFileSystemFolder->m_pszPathName,
        m_pFileSystemFolder->m_rgpszChildNames[m_uChildIndex]
        );

    hr = pConnection->HrDeleteFile(szWireName, fIsFolder);

    if(hr==XBDM_CANNOTACCESS)
    {
        HRESULT hrLoc;
        DM_FILE_ATTRIBUTES dmFileAttributes;
        DWORD dwOldAttributes;

        hrLoc = pConnection->HrGetFileAttributes(szWireName, &dmFileAttributes);
        if(SUCCEEDED(hrLoc))
        {
            dwOldAttributes = dmFileAttributes.Attributes;
            if(dwOldAttributes&FILE_ATTRIBUTE_READONLY)
            {
                dmFileAttributes.Attributes = FILE_ATTRIBUTE_NORMAL;
                hrLoc = pConnection->HrSetFileAttributes(szWireName, &dmFileAttributes);
                if(SUCCEEDED(hrLoc))
                {
                    hr = pConnection->HrDeleteFile(szWireName, fIsFolder);
                    if(FAILED(hr))
                    {
                        dmFileAttributes.Attributes = dwOldAttributes;
                        pConnection->HrSetFileAttributes(szWireName, &dmFileAttributes);
                    }
                }
            }
        }
    }
    return hr;
}

void CFileOrDirVisit::GetWireName(LPSTR pszWireName)
{
    CXboxFolder::GetWireName(
        pszWireName,
        m_pFileSystemFolder->m_pszPathName,
        m_pFileSystemFolder->m_rgpszChildNames[m_uChildIndex]
        );
}

//---------------------------------------------------------------------
// CFileOrDirVisit - implements IXboxFileOrDirVisit for CXboxDirectory
//---------------------------------------------------------------------
class CDirectoryVisitFromSelf: public CFolderVisitFromSelf, public IXboxFileOrDirVisit
{
  public:
   virtual void         GetFileAttributes(PDM_FILE_ATTRIBUTES pDmFileAttributes);
   virtual HRESULT      SetFileAttributes(PDM_FILE_ATTRIBUTES pdmFileAttributes);
   virtual HRESULT      SetName(HWND hWnd, LPSTR pszNewName);
   virtual HRESULT      Delete();
   virtual void         GetWireName(LPSTR pszWireName);
   //
   //   Context
   //
   CXboxFileSystemFolder *m_pFileSystemFolder;
   USE_BASE_VISITIMPL(CFolderVisitFromSelf)
};

void CDirectoryVisitFromSelf::GetFileAttributes(PDM_FILE_ATTRIBUTES pDmFileAttributes)
{
    char szWireName[MAX_PATH];
    m_pFileSystemFolder->GetWireName(szWireName, NULL, m_pFileSystemFolder->m_pszPathName);
    m_pFileSystemFolder->m_pConnection->HrGetFileAttributes(szWireName, pDmFileAttributes);
    strcpy(pDmFileAttributes->Name, m_pFileSystemFolder->m_pszName);
}
HRESULT CDirectoryVisitFromSelf::SetFileAttributes(PDM_FILE_ATTRIBUTES pdmFileAttributes)
{
    HRESULT hr;
    char szWireName[MAX_PATH];
    m_pFileSystemFolder->GetWireName(szWireName, NULL, m_pFileSystemFolder->m_pszPathName);
    if(!pdmFileAttributes->Attributes) pdmFileAttributes->Attributes = FILE_ATTRIBUTE_NORMAL;
    hr = m_pFileSystemFolder->m_pConnection->HrSetFileAttributes(szWireName, pdmFileAttributes);
    if(SUCCEEDED(hr))
    {
        if(pdmFileAttributes->Attributes&FILE_ATTRIBUTE_READONLY)
        {
            m_pFileSystemFolder->m_ulShellAttributes |= SFGAO_READONLY;
        } else
        {
            m_pFileSystemFolder->m_ulShellAttributes &= ~SFGAO_READONLY;
        }
        
        if(pdmFileAttributes->Attributes&FILE_ATTRIBUTE_HIDDEN)
        {
            m_pFileSystemFolder->m_ulShellAttributes |= (SFGAO_HIDDEN|SFGAO_GHOSTED);
        } else
        {
            m_pFileSystemFolder->m_ulShellAttributes &= ~(SFGAO_HIDDEN|SFGAO_GHOSTED);
        }
    }
    return hr;
}

HRESULT CDirectoryVisitFromSelf::SetName(HWND hWnd, LPSTR pszNewName)
{
    UINT uNewNameLen = strlen(pszNewName);
    if(uNewNameLen != _mbstrlen(pszNewName))
    {
        return XBDM_BADFILENAME;
    }

    HRESULT hr = S_OK;
    char  szWireNameOld[MAX_PATH];
    char  szWireNameNew[MAX_PATH];
    LPSTR pszParse;
    CXboxFolder::GetWireName(szWireNameOld, NULL, m_pFileSystemFolder->m_pszPathName);
    strcpy(szWireNameNew, szWireNameOld);
    pszParse = strrchr(szWireNameNew, '\\');
    strcpy(++pszParse, pszNewName);

    LPITEMIDLIST oldPidl = GetPidl(CPidlUtils::PidlTypeAbsolute);
    if(oldPidl)
    {
        hr = m_pFileSystemFolder->SetName(hWnd, szWireNameOld, szWireNameNew);
        if(SUCCEEDED(hr))
        {
            LPITEMIDLIST newPidl = CPidlUtils::Copy(oldPidl, uNewNameLen);
            if(newPidl)
            {
                DWORD dwEvent;
                LPITEMIDLIST lastItem = CPidlUtils::LastItem(newPidl);
                lastItem->mkid.cb = uNewNameLen+sizeof(UCHAR)+sizeof(USHORT);
                strcpy((LPSTR)lastItem->mkid.abID,pszNewName);
                lastItem = AdvancePtr(lastItem, lastItem->mkid.cb);
                lastItem->mkid.cb = 0;
            
                if(m_pFileSystemFolder->m_ulShellAttributes&SFGAO_FOLDER)
                {
                    dwEvent = SHCNE_RENAMEFOLDER;
                } else
                {
                    dwEvent = SHCNE_RENAMEITEM;
                }
                SHChangeNotify(dwEvent, SHCNF_FLUSH|SHCNF_IDLIST, oldPidl, newPidl);
                CPidlUtils::Free(newPidl);
            }
        }
        CPidlUtils::Free(oldPidl);
    }
    return hr;
}
HRESULT CDirectoryVisitFromSelf::Delete()
{
    _ASSERTE(FALSE);
    return E_NOTIMPL;
}

void CDirectoryVisitFromSelf::GetWireName(LPSTR pszWireName)
{
    CXboxFolder::GetWireName(pszWireName, NULL, m_pFileSystemFolder->m_pszPathName);
}

//---------------------------------------------------------------------
// CFileOrDirVisit - implements IXboxFileOrDirVisit while recursing directories
//---------------------------------------------------------------------
class CFileOrDirVisitRecurse: public IXboxFileOrDirVisit
{
  public:
   virtual void         GetName(OUT LPSTR pszItemName);
   virtual LPITEMIDLIST GetPidl(CPidlUtils::PIDLTYPE PidlType);
   virtual ULONG        GetShellAttributes();
   virtual void         GetConsoleName(OUT LPSTR pszConsoleName);
   virtual void         GetFileAttributes(PDM_FILE_ATTRIBUTES pdmFileAttributes);
   virtual HRESULT      SetFileAttributes(PDM_FILE_ATTRIBUTES pdmFileAttributes);
   virtual HRESULT      SetName(HWND hWnd, LPSTR pszNewName){return E_NOTIMPL;}
   virtual HRESULT      Delete();
   virtual void         GetWireName(LPSTR pszWireName);
   

   //
   //   Actually perform recursion.
   //
   static void Go(
       CXboxFileSystemFolder *pDirectory,
       LPCSTR pszRelativePath,
       IXboxVisitor *pVisitor,
       DWORD* pdwFlags
       );
   
   void Recurse(DWORD *pdwFlags);
   
   //
   //   Recurse Context
   //
   char m_szWireName[MAX_PATH];
   IXboxVisitor *m_pVisitor;
   IXboxConnection *m_pConnection;
   CXboxFileSystemFolder *m_pDirectory;
   PDM_FILE_ATTRIBUTES m_pdmFileAttributes;
   LPSTR m_pszName;
};

void 
CFileOrDirVisitRecurse::Go(
   CXboxFileSystemFolder *pDirectory,
   LPCSTR pszRelativePath,
   IXboxVisitor *pVisitor,
   DWORD* pdwFlags
   )
{
    CFileOrDirVisitRecurse recurseObject;
    recurseObject.m_pConnection = pDirectory->m_pConnection;
    recurseObject.m_pDirectory = pDirectory;
    recurseObject.m_pVisitor = pVisitor;
    if(pszRelativePath)
    {
      CXboxFolder::GetWireName(recurseObject.m_szWireName, pDirectory->m_pszPathName, pszRelativePath);
      recurseObject.m_pszName = strrchr(recurseObject.m_szWireName, '\\') + 1;
    } else
    {
      CXboxFolder::GetWireName(recurseObject.m_szWireName, NULL, pDirectory->m_pszPathName);
      recurseObject.m_pszName = recurseObject.m_szWireName + strlen(recurseObject.m_szWireName);
    }
    recurseObject.Recurse(pdwFlags);
}
   
void
CFileOrDirVisitRecurse::Recurse(DWORD *pdwFlags)
{
    PDM_WALK_DIR        pdmWalkDir = NULL;
    DM_FILE_ATTRIBUTES  dmFileAttributes;
    LPSTR               pszNextChar;
    DWORD               dwCount;
    if(SUCCEEDED(m_pConnection->HrOpenDir(&pdmWalkDir, m_szWireName, &dwCount)))
    {
        pszNextChar = m_szWireName + strlen(m_szWireName);
        *pszNextChar++ = '\\';
        while(SUCCEEDED(m_pConnection->HrWalkDir(&pdmWalkDir, NULL, &dmFileAttributes)))
        {
            m_pdmFileAttributes = &dmFileAttributes;
            strcpy(pszNextChar, dmFileAttributes.Name);
            m_pVisitor->VisitFileOrDir(this, pdwFlags);
            if(*pdwFlags&IXboxVisitor::FlagRecurse)
            {
                Recurse(pdwFlags);
            }
            if((dmFileAttributes.Attributes&FILE_ATTRIBUTE_DIRECTORY)&&(*pdwFlags&IXboxVisitor::FlagCallPost))
            {
                m_pdmFileAttributes = &dmFileAttributes;
                m_pVisitor->VisitDirectoryPost(this, pdwFlags);
            }
        }
        m_pConnection->HrCloseDir(pdmWalkDir);
        *(--pszNextChar) = '\0';
    }
}


void CFileOrDirVisitRecurse::GetName(OUT LPSTR pszItemName)
/*++
  Routine Description:
    Should return the name relative to where we are recursing from.
--*/
{
    strcpy(pszItemName, m_pszName);
}   

LPITEMIDLIST CFileOrDirVisitRecurse::GetPidl(CPidlUtils::PIDLTYPE PidlType)
/*++
  Routine Description:
    
--*/
{
    UINT uRelativeDepth = 1;
    UINT uRelativeLength = 0;
    LPSTR pszWalk = m_pszName;
    LPSTR pszSimpleName = pszWalk;
    UINT  uSimpleNameLength = 0;
    LPITEMIDLIST pidlOut;
    LPITEMIDLIST pidlWalk;
    

    while(*pszWalk)
    {
        uRelativeLength++;
        uSimpleNameLength++;
        if(*pszWalk++ == '\\')
        {
            uRelativeDepth++;
            uSimpleNameLength=0;
            pszSimpleName = pszWalk;
        }
    }

    if(PidlType == CPidlUtils::PidlTypeSimple)
    {
        pidlOut = (LPITEMIDLIST)g_pShellMalloc->Alloc(uSimpleNameLength+sizeof(CHAR)+2*sizeof(USHORT));
        if(pidlOut)
        {
            pidlOut->mkid.cb = uSimpleNameLength+sizeof(CHAR)+sizeof(USHORT);
            memcpy(pidlOut->mkid.abID, pszSimpleName, uSimpleNameLength+1);
            pidlWalk = AdvancePtr(pidlOut, pidlOut->mkid.cb);
            pidlWalk->mkid.cb = 0;
        }
    } else
    {
        //
        //  Calculate how many extra bytes we need for the relative
        //  part of the pidl after whatever we get for the directory.
        //
        UINT uExtraAllocation = uRelativeLength + sizeof(USHORT)*(uRelativeDepth+1)+sizeof(UCHAR);
        //
        //  Get the directories portion of the pidl.
        //
        pidlOut = m_pDirectory->GetPidl(PidlType, uExtraAllocation);

        //
        //  Add our relative poriton of the pidl.
        //
        if(pidlOut)
        {
            LPSTR pszPidlWalk;
            pidlWalk = pidlOut;
            while(pidlWalk->mkid.cb)
            {
                pidlWalk = AdvancePtr(pidlWalk, pidlWalk->mkid.cb);
            }
            pszWalk = m_pszName;
            pszPidlWalk = (LPSTR)pidlWalk->mkid.abID;
            uSimpleNameLength = 0;
            while(*pszWalk)
            {
                uSimpleNameLength++;
                if(*pszWalk != '\\')
                {
                    *pszPidlWalk++ = *pszWalk;
                    
                } else
                {
                    *pszPidlWalk = '\0';
                    pidlWalk->mkid.cb = uSimpleNameLength+sizeof(USHORT);
                    pidlWalk = AdvancePtr(pidlWalk, pidlWalk->mkid.cb);
                    uSimpleNameLength = 0;
                    pszPidlWalk = (LPSTR)pidlWalk->mkid.abID;
                }
                pszWalk++;
            }
            *pszPidlWalk = '\0';
            pidlWalk->mkid.cb = uSimpleNameLength+sizeof(UCHAR)+sizeof(USHORT);
            pidlWalk = AdvancePtr(pidlWalk, pidlWalk->mkid.cb);
            pidlWalk->mkid.cb = 0;
        }
    }
    return pidlOut;
}

ULONG CFileOrDirVisitRecurse::GetShellAttributes()
{
  ULONG ulShellAttributes;
  if(m_pdmFileAttributes->Attributes&FILE_ATTRIBUTE_DIRECTORY)
  {
    ulShellAttributes = DIRECTORY_SHELL_ATTRIBUTES;
  } else
  {
    ulShellAttributes  = FILE_SHELL_ATTRIBUTES;
  }
  if(m_pdmFileAttributes->Attributes&FILE_ATTRIBUTE_READONLY)
  {
    ulShellAttributes  |= SFGAO_READONLY;
  }
  if(m_pdmFileAttributes->Attributes&FILE_ATTRIBUTE_HIDDEN)
  {
    ulShellAttributes  |= (SFGAO_HIDDEN|SFGAO_GHOSTED);
  }
  return ulShellAttributes;
}

void CFileOrDirVisitRecurse::GetConsoleName(OUT LPSTR pszConsoleName)
{
    LPSTR pszPathName = m_pDirectory->m_pszPathName;
    while(*pszPathName && (*pszPathName!='\\'))
    {
        *pszConsoleName++ = *pszPathName++;
    }
    *pszConsoleName = '\0';
}

void CFileOrDirVisitRecurse::GetFileAttributes(PDM_FILE_ATTRIBUTES pDmFileAttributes)
{
    memcpy(pDmFileAttributes, m_pdmFileAttributes, sizeof(DM_FILE_ATTRIBUTES));
}

HRESULT CFileOrDirVisitRecurse::SetFileAttributes(PDM_FILE_ATTRIBUTES pdmFileAttributes)
{
    HRESULT hr;
    DWORD dwOldAttributes = m_pdmFileAttributes->Attributes;
    if(!pdmFileAttributes->Attributes)
    {
        pdmFileAttributes->Attributes = FILE_ATTRIBUTE_NORMAL;
    }
    hr = m_pConnection->HrSetFileAttributes(m_szWireName, pdmFileAttributes);
    if(SUCCEEDED(hr))
    {
        m_pdmFileAttributes->Attributes = pdmFileAttributes->Attributes;
    }
    return hr;
}


HRESULT CFileOrDirVisitRecurse::Delete()
{
    HRESULT hr;
    BOOL fIsFolder = m_pdmFileAttributes->Attributes&FILE_ATTRIBUTE_DIRECTORY ? TRUE : FALSE;
    hr = m_pConnection->HrDeleteFile(m_szWireName, fIsFolder);
    if(hr==XBDM_CANNOTACCESS)
    {
        HRESULT hrLoc;
        
        DWORD dwOldAttributes;
        
        dwOldAttributes = m_pdmFileAttributes->Attributes;
        if(dwOldAttributes&FILE_ATTRIBUTE_READONLY)
        {
            m_pdmFileAttributes->Attributes = FILE_ATTRIBUTE_NORMAL;
            hrLoc = m_pConnection->HrSetFileAttributes(m_szWireName, m_pdmFileAttributes);
            if(SUCCEEDED(hrLoc))
            {
                hr = m_pConnection->HrDeleteFile(m_szWireName, fIsFolder);
                if(FAILED(hr))
                {
                    m_pdmFileAttributes->Attributes = dwOldAttributes;
                    m_pConnection->HrSetFileAttributes(m_szWireName, m_pdmFileAttributes);
                }
            }
        }
    }
    return hr;
}

void CFileOrDirVisitRecurse::GetWireName(LPSTR pszWireName)
{
    strcpy(pszWireName, m_szWireName);
}

//---------------------------------------------------------------------
// Various Implementations of visit.
//---------------------------------------------------------------------
void CXboxRoot::Visit(UINT uIndexCount, const UINT *puIndexList, IXboxVisitor *pVisitor, DWORD dwFlags)
{
    //
    //  You cannot call without FlagContinue.
    //

    dwFlags |= IXboxVisitor::FlagContinue;
    if(0==uIndexCount)
    {
        CFolderVisitFromSelf visit;
        visit.m_pFolder = this;
        pVisitor->VisitRoot(&visit, &dwFlags);
    } else
    {
        UINT uLoop;
        CConsoleVisit consoleVisit;      // All of our children excepting the "Add Console" is a console, so ready this.
        consoleVisit.m_pFolder = this;
        consoleVisit.m_pRoot = this;
        for(uLoop = 0; uLoop < uIndexCount; uLoop++)
        {
            //
            //  Check for the "Add New Console" whose first character 
            //  is always '?', this is the only item for which this
            //  can be true.
            //
            if('?'==*m_rgpszChildNames[puIndexList[uLoop]])
            {
                CFolderVisit visitFolder;
                visitFolder.m_pFolder = this;
                visitFolder.m_uChildIndex = puIndexList[uLoop];
                pVisitor->VisitAddConsole(&visitFolder, &dwFlags);
            } else
            {
                consoleVisit.m_uChildIndex = puIndexList[uLoop];
                pVisitor->VisitConsole(&consoleVisit, &dwFlags);
            }
            if(!(dwFlags&IXboxVisitor::FlagContinue))
            {
                break;
            }
        }
    }
}


void CXboxConsole::Visit(UINT uIndexCount, const UINT *puIndexList, IXboxVisitor *pVisitor, DWORD dwFlags)
{
    //
    //  You cannot call without FlagContinue.
    //
    m_pConnection->HrUseSharedConnection(TRUE);
    dwFlags |= IXboxVisitor::FlagContinue;
    if(0==uIndexCount)
    {
        CConsoleVisitFromSelf visitConsole;
        visitConsole.m_pFolder = this;
        visitConsole.m_pConsole = this;
        pVisitor->VisitConsole(&visitConsole, &dwFlags);
    } else
    {
        UINT uLoop;
        CVolumeVisit volumeVisit;      // All of our children are volumes
        volumeVisit.m_pFolder = this;
        volumeVisit.m_pConsole = this;
        for(uLoop = 0; uLoop < uIndexCount; uLoop++)
        {
            volumeVisit.m_uChildIndex = puIndexList[uLoop];
            pVisitor->VisitVolume(&volumeVisit, &dwFlags);
            if(!(dwFlags&IXboxVisitor::FlagContinue))
            {
                break;
            }
        }
    }
    m_pConnection->HrUseSharedConnection(FALSE);
}


void CXboxVolume::Visit(UINT uIndexCount, const UINT *puIndexList, IXboxVisitor *pVisitor, DWORD dwFlags)
{
    //
    //  You cannot call without FlagContinue.
    //
    m_pConnection->HrUseSharedConnection(TRUE);
    dwFlags |= IXboxVisitor::FlagContinue;
    if(0==uIndexCount)
    {
        CVolumeVisitFromSelf visitVolume;
        visitVolume.m_pFolder = this;
        visitVolume.m_pVolume = this;
        pVisitor->VisitVolume(&visitVolume, &dwFlags);
    } else
    {
        UINT uLoop;
        CFileOrDirVisit fileOrDirVisit;      // All of our children are files or directories
        fileOrDirVisit.m_pFolder = this;
        fileOrDirVisit.m_pFileSystemFolder = this;
        for(uLoop = 0; uLoop < uIndexCount; uLoop++)
        {
            fileOrDirVisit.m_uChildIndex = puIndexList[uLoop];
            pVisitor->VisitFileOrDir(&fileOrDirVisit, &dwFlags);
            if(!(dwFlags&IXboxVisitor::FlagContinue))
            {
                break;
            }

            if(
                (dwFlags&IXboxVisitor::FlagRecurse) && 
                (m_rgChildFileAttributes[puIndexList[uLoop]].Attributes&FILE_ATTRIBUTE_DIRECTORY)
            )
            {
                CFileOrDirVisitRecurse::Go(this, m_rgpszChildNames[puIndexList[uLoop]], pVisitor, &dwFlags);
                if(dwFlags&IXboxVisitor::FlagCallPost)
                {
                    pVisitor->VisitDirectoryPost(&fileOrDirVisit, &dwFlags);
                    if(!(dwFlags&IXboxVisitor::FlagContinue))
                    {
                        break;
                    }
                }
            }
        }
    }
    m_pConnection->HrUseSharedConnection(FALSE);
}

void CXboxDirectory::Visit(UINT uIndexCount, const UINT *puIndexList, IXboxVisitor *pVisitor, DWORD dwFlags)
{
    //
    //  You cannot call without FlagContinue.
    //
    m_pConnection->HrUseSharedConnection(TRUE);
    dwFlags |= IXboxVisitor::FlagContinue;
    if(0==uIndexCount)
    {
        CDirectoryVisitFromSelf visitDirectory;
        visitDirectory.m_pFolder = this;
        visitDirectory.m_pFileSystemFolder = this;
        pVisitor->VisitFileOrDir(&visitDirectory, &dwFlags);
        if(dwFlags&IXboxVisitor::FlagRecurse)
        {
            if(dwFlags&IXboxVisitor::FlagRecurse)
            {
                CFileOrDirVisitRecurse::Go(this, NULL, pVisitor, &dwFlags);
                if(dwFlags&IXboxVisitor::FlagCallPost)
                {
                    pVisitor->VisitFileOrDir(&visitDirectory, &dwFlags);
                }
            }

        }
    } else
    {
        UINT uLoop;
        CFileOrDirVisit fileOrDirVisit;      // All of our children are files or directories
        fileOrDirVisit.m_pFolder = this;
        fileOrDirVisit.m_pFileSystemFolder = this;
        for(uLoop = 0; uLoop < uIndexCount; uLoop++)
        {
            fileOrDirVisit.m_uChildIndex = puIndexList[uLoop];
            pVisitor->VisitFileOrDir(&fileOrDirVisit, &dwFlags);
            if(!(dwFlags&IXboxVisitor::FlagContinue))
            {
                break;
            }

            if(dwFlags&IXboxVisitor::FlagRecurse)
            {
                if(
                    (dwFlags&IXboxVisitor::FlagRecurse) && 
                    (m_rgChildFileAttributes[puIndexList[uLoop]].Attributes&FILE_ATTRIBUTE_DIRECTORY)
                )
                {
                    CFileOrDirVisitRecurse::Go(this, m_rgpszChildNames[puIndexList[uLoop]], pVisitor, &dwFlags);
                    if(dwFlags&IXboxVisitor::FlagCallPost)
                    {
                        pVisitor->VisitDirectoryPost(&fileOrDirVisit, &dwFlags);
                        if(!(dwFlags&IXboxVisitor::FlagContinue))
                        {
                            break;
                        }
                    }
                }
            }
        }
    }
    m_pConnection->HrUseSharedConnection(FALSE);
}


void CXboxFolder::VisitEach(IXboxVisitor *pVisitor, DWORD dwFlags)
/*++
  Routine Description:
    
--*/
{
    //
    //  Allocate an index list.
    //
    UINT *puIndexList = NULL;
    if(m_uChildCount)
    {
        puIndexList = new UINT[m_uChildCount];
        if(!puIndexList) return;
    }
    
    UINT uIndex;
    //
    //  Populate for all of the children.
    //
    for(uIndex=0; uIndex < m_uChildCount; uIndex++) puIndexList[uIndex] = uIndex;
    //
    //  Do the visits
    //
    Visit(m_uChildCount, puIndexList, pVisitor, dwFlags);
    delete [] puIndexList;

}

void CXboxFolder::VisitThese(UINT cidl, LPCITEMIDLIST *apidl, IXboxVisitor *pVisitor, DWORD dwFlags)
/*++
  Routine Description:
        
--*/
{
    HRESULT hr = S_OK;
    UINT *puIndexList = NULL;

    if(cidl)
    {
        _ASSERTE(apidl);
        hr = BuildSelectionIndexList(cidl, apidl, &puIndexList);
    } else
    {
        _ASSERTE(!apidl);
    }

    //
    //  Let the class specific portion finish.
    //
    if(SUCCEEDED(hr))
    {
        Visit(cidl, puIndexList, pVisitor, dwFlags);
        delete [] puIndexList;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbshlext\wizard.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    wizard.h

Abstract:

    Class definitions for wizard property sheets and pages.

Environment:

    Windows 2000 and Later 
    User Mode

Revision History:
    
    08-07-2001 : created (mitchd)

--*/


class CWizardPage;
struct WizardPageInfo
{
    WizardPageInfo():pWizardPage(NULL){}
    CWizardPage *pWizardPage;  // Pointer to a property Page
};

class CWizard
{
  public:
    CWizard() : 
        m_uMaxPages(0),
        m_uPageCount(0),
        m_pPages(NULL),
        m_pPropSheetPages(NULL),
        m_hrInitialize(E_FAIL)
        {}
    ~CWizard() {delete [] m_pPages; delete [] m_pPropSheetPages; DeleteObject(m_hTitleFont);}
    
    HRESULT Initialize(UINT uPages);
    HRESULT DoWizard(HWND hwndParent);
    void AddPage(CWizardPage *pPage);

  private:

    UINT              m_uItemCount;
    UINT              m_uMaxPages;
    UINT              m_uPageCount;
    WizardPageInfo   *m_pPages;
    PROPSHEETPAGEA   *m_pPropSheetPages;
    char              m_szCaption[MAX_PATH];
    HWND              m_hWndParent;
    HFONT             m_hTitleFont;

    //Outlaw Copy C'tor and Assignment
    CWizard(const CWizard&);
    CWizard& operator=(const CWizard&);

    HRESULT m_hrInitialize;
};

class CWizardPage
{
  public:
    CWizardPage() : m_hPageDlg(NULL), m_hTitleFont(NULL) {}
  protected:
    virtual INT_PTR OnInitDialog(HWND hwndDefaultControl);
    virtual INT_PTR OnCommand(WPARAM wParam, LPARAM lParam){return 0;}
    virtual INT_PTR OnMessage(UINT uMsg, WPARAM wParam, LPARAM lParam){return 0;}

    
    virtual INT_PTR OnSetActive()=0;
    virtual INT_PTR OnWizBack(){return 0;}
    virtual INT_PTR OnWizNext(){return 0;}
    virtual INT_PTR OnWizFinish(){return 0;}
    virtual INT_PTR OnNotify(LPNMHDR pnmhdr){return 0;}
    
    static INT_PTR CALLBACK DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    virtual void CompletePropSheetPage(PROPSHEETPAGEA *pPropSheetPage) = 0;
    
    HWND    m_hPageDlg;
  private:

    void FilloutPropSheetPage(PROPSHEETPAGEA *pPropSheetPage, HFONT hTitleFont);
    HFONT   m_hTitleFont;
    CWizard *pParent;
    friend class CWizard;
};

class CAddConsoleData
{
  public:
    CAddConsoleData():
        m_fConsoleIsValid(FALSE),m_dwIpAddress(0), m_fMakeDefault(FALSE), m_dwAccess(0)
        {
            *m_szConsoleName='\0';
            *m_szPassword='\0';
        }
    
    BOOL    SetConsoleName(LPCSTR pszConsoleName);
    BOOL    GetConsoleName(LPSTR pszConsoleName);
    BOOL    GetIpAddress(PDWORD pdwIpAddress);
    void    SetMakeDefault(BOOL fSet);
    BOOL    GetMakeDefault();
    BOOL    ShowAccessDenied();
    void    SetDesiredAccess(DWORD dwAccess);
    DWORD   GetDesiredAccess();
    HRESULT SetPassword(LPCSTR pszAdminPassword);
    HRESULT OnFinish();

  private:
    BOOL    m_fConsoleIsValid;
    char    m_szConsoleName[MAX_CONSOLE_NAME];
    char    m_szPassword[MAX_CONSOLE_NAME];
    DWORD   m_dwIpAddress;
    BOOL    m_fMakeDefault;
    DWORD   m_dwAccess;
    DWORD   m_dwDesiredAccess;
    BOOL    m_fShowAccessDenied;
};

class CAddConsoleWelcome : public CWizardPage
{
    public:
     CAddConsoleWelcome(){}

    protected:

     virtual INT_PTR OnSetActive();
     virtual void CompletePropSheetPage(PROPSHEETPAGEA *pPropSheetPage);
};

class CAddConsoleGetName : public CWizardPage
{
    public:
      CAddConsoleGetName(CAddConsoleData *pAddConsoleData) : m_pAddConsoleData(pAddConsoleData){}

    protected:
    
      virtual INT_PTR OnSetActive();
      virtual INT_PTR OnWizNext();
      virtual INT_PTR OnWizBack();
      virtual INT_PTR OnCommand(WPARAM wParam, LPARAM lParam);
      virtual INT_PTR OnInitDialog(HWND hwndDefaultControl);
      virtual void CompletePropSheetPage(PROPSHEETPAGEA *pPropSheetPage);

      CAddConsoleData *m_pAddConsoleData;
};

class CAddConsoleAccessDenied : public CWizardPage
{
    public:
      CAddConsoleAccessDenied(CAddConsoleData *pAddConsoleData) : m_pAddConsoleData(pAddConsoleData){}

    protected:
    
      virtual INT_PTR OnSetActive();
      virtual INT_PTR OnWizNext();
      virtual INT_PTR OnWizBack();
      virtual INT_PTR OnCommand(WPARAM wParam, LPARAM lParam);
      virtual INT_PTR OnInitDialog(HWND hwndDefaultControl);
      virtual void CompletePropSheetPage(PROPSHEETPAGEA *pPropSheetPage);

      CAddConsoleData *m_pAddConsoleData;
};

class CAddConsoleMakeDefault : public CWizardPage
{
    public:
      CAddConsoleMakeDefault(CAddConsoleData *pAddConsoleData) : m_pAddConsoleData(pAddConsoleData){}

    protected:
    
      virtual INT_PTR OnSetActive();
      virtual INT_PTR OnWizNext();
      virtual INT_PTR OnWizBack();

      virtual INT_PTR OnInitDialog(HWND hwndDefaultControl);
      virtual void CompletePropSheetPage(PROPSHEETPAGEA *pPropSheetPage);

      CAddConsoleData *m_pAddConsoleData;
};

class CAddConsoleFinish : public CWizardPage
{
    public:
      CAddConsoleFinish(CAddConsoleData *pAddConsoleData) : m_pAddConsoleData(pAddConsoleData){}

    protected:
      
      virtual INT_PTR OnSetActive();
      virtual INT_PTR OnWizBack();
      virtual INT_PTR OnWizFinish();

      virtual void CompletePropSheetPage(PROPSHEETPAGEA *pPropSheetPage);
      CAddConsoleData *m_pAddConsoleData;
};

extern void ExecuteAddConsoleWizard();
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbshlext\wizard.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    wizard.cpp

Abstract:

    Implementation of the add new console
    wizard

Environment:

    Windows 2000 and Later 
    User Mode

Revision History:
    
    08-07-2001 : created (mitchd)

--*/

#include <stdafx.h>
#define DMPL_PRIV_ALL (DMPL_PRIV_READ|DMPL_PRIV_WRITE|DMPL_PRIV_MANAGE|DMPL_PRIV_CONFIGURE|DMPL_PRIV_CONTROL)

HRESULT CWizard::Initialize(UINT uMaxPages)
{
    m_hrInitialize = E_OUTOFMEMORY;
    m_uMaxPages = uMaxPages;
    m_uPageCount = 0;
    m_pPages = new WizardPageInfo[m_uMaxPages];
    if(m_pPages)
    {
        m_pPropSheetPages = new PROPSHEETPAGEA[m_uMaxPages];
        if(m_pPropSheetPages)
        {
            m_hrInitialize = S_OK;
        
            //  Create the title font
            NONCLIENTMETRICS ncm = {0};
	        ncm.cbSize = sizeof(ncm);
	        SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);
	        LOGFONT TitleLogFont = ncm.lfMessageFont;
	        TitleLogFont.lfWeight = FW_BOLD;
	        lstrcpy(TitleLogFont.lfFaceName, TEXT("Verdana Bold"));
	        HDC hdc = GetDC(NULL);
	        INT FontSize = 12;
	        TitleLogFont.lfHeight = 0 - GetDeviceCaps(hdc, LOGPIXELSY) * FontSize / 72;
	        m_hTitleFont = CreateFontIndirect(&TitleLogFont);
	        ReleaseDC(NULL, hdc);
        } else
        {
            delete [] m_pPages;
            m_pPages = NULL;
        }
    }
    return m_hrInitialize;
}

HRESULT CWizard::DoWizard(HWND hwndParent)
{
    PROPSHEETHEADERA propSheetHeader;
    propSheetHeader.dwSize = sizeof(PROPSHEETHEADERA);
    propSheetHeader.dwFlags = PSH_WIZARD97 | PSH_WATERMARK | PSH_HEADER | PSH_PROPSHEETPAGE ;
    propSheetHeader.hwndParent = hwndParent;
    propSheetHeader.hInstance = _Module.GetModuleInstance();
    propSheetHeader.hIcon = NULL;
    propSheetHeader.pszCaption = NULL;
    propSheetHeader.nPages = m_uPageCount;
    propSheetHeader.nStartPage = 0;
    propSheetHeader.ppsp = m_pPropSheetPages;
    propSheetHeader.pfnCallback  = NULL;
    propSheetHeader.pszbmWatermark = MAKEINTRESOURCEA(IDB_WATERMARK);
    propSheetHeader.pszbmHeader = MAKEINTRESOURCEA(IDB_HEADER);

    _ASSERTE(m_uPageCount > 0);
    long lError = PropertySheetA(&propSheetHeader);
    if(-1==lError)
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }
    return S_OK;
}

void CWizard::AddPage(CWizardPage *pPage)
{
    UINT uPageIndex;
    _ASSERTE(m_uPageCount < m_uMaxPages);
    
    //
    //  Add a pointer to the page to our array of property pages.
    //
    uPageIndex = m_uPageCount++;
    m_pPages[uPageIndex].pWizardPage = pPage;

    //
    //  Get the page to fillout its PROPSHEETPAGEA structure.
    //
    pPage->FilloutPropSheetPage(m_pPropSheetPages+uPageIndex, m_hTitleFont);
}


INT_PTR CALLBACK CWizardPage::DialogProc(HWND hWndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CWizardPage *pThis;

    //
    //  WM_INITDIALOG is special.
    //
    if(WM_INITDIALOG==uMsg)
    {
        PROPSHEETPAGEA *pPropSheetPage = (PROPSHEETPAGEA *)lParam;
        pThis = (CWizardPage *)pPropSheetPage->lParam;
        SetWindowLong(hWndDlg,DWL_USER,(LONG)pThis);
        pThis->m_hPageDlg = hWndDlg;
        return pThis->OnInitDialog((HWND)wParam);
    }

    pThis = (CWizardPage *)GetWindowLong(hWndDlg, DWL_USER);
    if(pThis)
    {
        switch(uMsg)
        {
          
          case WM_NOTIFY:
          {
            LPNMHDR lpnm = (LPNMHDR) lParam;
            switch (lpnm->code)
            {
                case PSN_SETACTIVE: //Enable the Next button
                    return pThis->OnSetActive();
                case PSN_WIZBACK:
                    return pThis->OnWizBack();
                case PSN_WIZNEXT:
                    return pThis->OnWizNext();
                case PSN_WIZFINISH:
                    return pThis->OnWizFinish();
                default:
                    {
                    INT_PTR iRet = pThis->OnNotify(lpnm);
                    if(iRet)return iRet;
                    }break;
            }
          }
          case WM_COMMAND:
            return pThis->OnCommand(wParam, lParam);
          default:        
            return pThis->OnMessage(uMsg, wParam, lParam);
        }
    }
    return 0;
}

INT_PTR CWizardPage::OnInitDialog(HWND hwndDefaultControl)
{
    // If the page has an item of IDC_XB_TITLE it should be
    // in the title font.
    HWND hwndTitle = GetDlgItem(m_hPageDlg, IDC_XB_TITLE);
    if(hwndTitle)
    {
        SendMessage(hwndTitle, WM_SETFONT, (WPARAM)m_hTitleFont, 0);
    }
    return 0;
}

void CWizardPage::FilloutPropSheetPage(PROPSHEETPAGEA *pPropSheetPage, HFONT hTitleFont)
{
    m_hTitleFont = hTitleFont;
    pPropSheetPage->dwSize = sizeof(PROPSHEETPAGE);
    pPropSheetPage->dwFlags = PSP_DEFAULT;
    pPropSheetPage->hInstance = _Module.GetModuleInstance();
    pPropSheetPage->pfnDlgProc = DialogProc;
    pPropSheetPage->pfnCallback = NULL;
    pPropSheetPage->lParam = (LPARAM)this;
    CompletePropSheetPage(pPropSheetPage);
}

void CAddConsoleWelcome::CompletePropSheetPage(PROPSHEETPAGEA *pPropSheetPage)
{
	pPropSheetPage->dwFlags |= PSP_HIDEHEADER;
	pPropSheetPage->pszTemplate = MAKEINTRESOURCEA(IDD_ADDCONSOLE_WELCOME);
}

INT_PTR CAddConsoleWelcome::OnSetActive()
{
    PropSheet_SetWizButtons(GetParent(m_hPageDlg), PSWIZB_NEXT);
    return 0;
}

INT_PTR CAddConsoleGetName::OnInitDialog(HWND)
{
    return TRUE;
}

void CAddConsoleGetName::CompletePropSheetPage(PROPSHEETPAGEA *pPropSheetPage)
{
    pPropSheetPage->dwFlags |= PSP_USEHEADERTITLE|PSP_USEHEADERSUBTITLE;
    pPropSheetPage->pszTemplate = MAKEINTRESOURCEA(IDD_ADDCONSOLE_GETNAME);
	pPropSheetPage->pszHeaderTitle =    MAKEINTRESOURCEA(IDS_ADDCONSOLE_GETNAME_TITLE);
	pPropSheetPage->pszHeaderSubTitle = MAKEINTRESOURCEA(IDS_ADDCONSOLE_GETNAME_SUBTITLE);
}

INT_PTR CAddConsoleGetName::OnSetActive()
{
    HWND hwndCtrl = GetDlgItem(m_hPageDlg, IDC_ADDCONSOLE_NAME);
    if(hwndCtrl)
    {
       char szConsoleName[80];
       if(m_pAddConsoleData->GetConsoleName(szConsoleName))
       {
            PropSheet_SetWizButtons(GetParent(m_hPageDlg),PSWIZB_BACK|PSWIZB_NEXT);
       } else
       {
            PropSheet_SetWizButtons(GetParent(m_hPageDlg),PSWIZB_BACK);
       }
       SetWindowTextA(hwndCtrl, szConsoleName);
    }
    return 0;
}

INT_PTR CAddConsoleGetName::OnWizNext()
{
    char szConsoleName[80];
    DWORD dwIpAddress;
    
    // Retrieve the name of the console
    HWND hwndCtrl = GetDlgItem(m_hPageDlg, IDC_ADDCONSOLE_NAME);
    GetWindowTextA(hwndCtrl, szConsoleName, sizeof(szConsoleName));
    m_pAddConsoleData->SetConsoleName(szConsoleName);

    //Make sure that the Xbox exists.
    if(!m_pAddConsoleData->GetIpAddress(&dwIpAddress))
    {
        // Could not find Xbox - show dialog, and return to this page.
        WindowUtils::MessageBoxResource(m_hPageDlg, IDS_CONSOLE_NOT_FOUND, IDS_GENERIC_CAPTION, MB_OK|MB_ICONSTOP, szConsoleName);
        SetWindowLong(m_hPageDlg, DWL_MSGRESULT, IDD_ADDCONSOLE_GETNAME);
    } else
    {
        SetWindowLong(m_hPageDlg, DWL_MSGRESULT, m_pAddConsoleData->ShowAccessDenied() ? IDD_ADDCONSOLE_ACCESSDENIED : IDD_ADDCONSOLE_MAKEDEFAULT);
    }
    return TRUE;
}

INT_PTR CAddConsoleGetName::OnWizBack()
{
    SetWindowLong(m_hPageDlg, DWL_MSGRESULT, IDD_ADDCONSOLE_WELCOME);
    return TRUE;
}

INT_PTR CAddConsoleGetName::OnCommand(WPARAM wParam, LPARAM lParam)
{
    char szConsoleName[80];
    UINT uControlId = LOWORD(wParam);
    UINT uCommand = HIWORD(wParam);
    if (uCommand == EN_CHANGE)
    {
        if(uControlId == IDC_ADDCONSOLE_NAME)
        {
           if(GetWindowTextA(GetDlgItem(m_hPageDlg, IDC_ADDCONSOLE_NAME), szConsoleName, sizeof(szConsoleName)))
           {
                PropSheet_SetWizButtons(GetParent(m_hPageDlg),PSWIZB_BACK|PSWIZB_NEXT);
           } else
           {
                PropSheet_SetWizButtons(GetParent(m_hPageDlg),PSWIZB_BACK);
           }
           return TRUE;
        }
    }
    return FALSE;
}

void CAddConsoleAccessDenied::CompletePropSheetPage(PROPSHEETPAGEA *pPropSheetPage)
{
    pPropSheetPage->dwFlags |= PSP_USEHEADERTITLE|PSP_USEHEADERSUBTITLE;
    pPropSheetPage->pszTemplate = MAKEINTRESOURCEA(IDD_ADDCONSOLE_ACCESSDENIED);
	pPropSheetPage->pszHeaderTitle =    MAKEINTRESOURCEA(IDS_ADDCONSOLE_ACCESSDENIED_TITLE);
	pPropSheetPage->pszHeaderSubTitle = MAKEINTRESOURCEA(IDS_ADDCONSOLE_ACCESSDENIED_SUBTITLE);
}

INT_PTR CAddConsoleAccessDenied::OnInitDialog(HWND hwndDefaultControl)
{
    return TRUE;
}

INT_PTR CAddConsoleAccessDenied::OnSetActive()
{
    char szPassword[50];
    DWORD dwDesiredAccess = m_pAddConsoleData->GetDesiredAccess();
    
    // Set the check boxes
    CheckDlgButton(m_hPageDlg, IDC_ADDCONSOLE_READ,      (dwDesiredAccess&DMPL_PRIV_READ)      ? BST_CHECKED : BST_UNCHECKED);
    CheckDlgButton(m_hPageDlg, IDC_ADDCONSOLE_WRITE,     (dwDesiredAccess&DMPL_PRIV_WRITE)     ? BST_CHECKED : BST_UNCHECKED);
    CheckDlgButton(m_hPageDlg, IDC_ADDCONSOLE_MANAGE,    (dwDesiredAccess&DMPL_PRIV_MANAGE)    ? BST_CHECKED : BST_UNCHECKED);
    CheckDlgButton(m_hPageDlg, IDC_ADDCONSOLE_CONFIGURE, (dwDesiredAccess&DMPL_PRIV_CONFIGURE) ? BST_CHECKED : BST_UNCHECKED);
    CheckDlgButton(m_hPageDlg, IDC_ADDCONSOLE_CONTROL,   (dwDesiredAccess&DMPL_PRIV_CONTROL)   ? BST_CHECKED : BST_UNCHECKED);
    
    // If there is any access at all, and their is any password, then enable the next button
    if(dwDesiredAccess)
    {
        // Get the window text to see if there is password in it.
        if(GetWindowTextA(GetDlgItem(m_hPageDlg, IDC_ADDCONSOLE_PASSWORD), szPassword, sizeof(szPassword)))
        {
            PropSheet_SetWizButtons(GetParent(m_hPageDlg), PSWIZB_BACK | PSWIZB_NEXT);
            return TRUE;
        }
    }
    
    //If we fell through to here, we are not ready to enable the next button
    PropSheet_SetWizButtons(GetParent(m_hPageDlg), PSWIZB_BACK);
    return TRUE;
}

INT_PTR CAddConsoleAccessDenied::OnWizNext()
{
    HRESULT hr;
    char szPassword[60];
    // We need to validate the password, if it is valid go on to the 
    // make default page.  Otherwise, pop-up an invalid password dialog
    // and stay right here.
    GetWindowTextA(GetDlgItem(m_hPageDlg, IDC_ADDCONSOLE_PASSWORD), szPassword, sizeof(szPassword));
    hr = m_pAddConsoleData->SetPassword(szPassword);
    if(SUCCEEDED(hr))
    {
        SetWindowLong(m_hPageDlg, DWL_MSGRESULT, IDD_ADDCONSOLE_MAKEDEFAULT);
    } else
    {
        char szConsoleName[60];
        char szErrorString[80];
        m_pAddConsoleData->GetConsoleName(szConsoleName);
        FormatUtils::XboxErrorString(hr, szErrorString, sizeof(szErrorString));
        //
        //  Format the error code, and tell the user why we cannot move on to the next step.
        //
        WindowUtils::MessageBoxResource(m_hPageDlg, IDS_SECURE_CONNECTION_FAILED, IDS_GENERIC_CAPTION, MB_ICONSTOP|MB_OK, szConsoleName, szErrorString);
        SetWindowLong(m_hPageDlg, DWL_MSGRESULT, IDD_ADDCONSOLE_ACCESSDENIED);
    }
    return TRUE;    
}

INT_PTR CAddConsoleAccessDenied::OnWizBack()
{
    SetWindowLong(m_hPageDlg, DWL_MSGRESULT, IDD_ADDCONSOLE_GETNAME);
    return TRUE;
}

INT_PTR CAddConsoleAccessDenied::OnCommand(WPARAM wParam, LPARAM lParam)
{
    char szPassword[80];
    UINT uControlId = LOWORD(wParam);
    UINT uCommand = HIWORD(wParam);
    DWORD dwDesiredAccess = m_pAddConsoleData->GetDesiredAccess();
    BOOL fReturn = FALSE;
    
    if(uCommand == EN_CHANGE)
    {
        if(uControlId == IDC_ADDCONSOLE_PASSWORD)
        {
          fReturn = TRUE;
        }
    } else if(uCommand == BN_CLICKED)
    {
        fReturn = TRUE;
        switch(uControlId)
        {
          case IDC_ADDCONSOLE_READ:
            dwDesiredAccess ^= DMPL_PRIV_READ;
            break;                
          case IDC_ADDCONSOLE_WRITE:
            dwDesiredAccess ^= DMPL_PRIV_WRITE;
            break;
          case IDC_ADDCONSOLE_MANAGE:
            dwDesiredAccess ^= DMPL_PRIV_MANAGE;
            break;
          case IDC_ADDCONSOLE_CONFIGURE:
            dwDesiredAccess ^= DMPL_PRIV_CONFIGURE;
            break;
          case IDC_ADDCONSOLE_CONTROL:
            dwDesiredAccess ^= DMPL_PRIV_CONTROL;
            break;
          default:
             fReturn = FALSE;
        };
        m_pAddConsoleData->SetDesiredAccess(dwDesiredAccess);
    }

    if(dwDesiredAccess)
    {
        if(GetWindowTextA(GetDlgItem(m_hPageDlg, IDC_ADDCONSOLE_PASSWORD), szPassword, sizeof(szPassword)))
        {
            PropSheet_SetWizButtons(GetParent(m_hPageDlg),PSWIZB_BACK | PSWIZB_NEXT);
            return fReturn;
         }
    }
    PropSheet_SetWizButtons(GetParent(m_hPageDlg),PSWIZB_BACK);
    return fReturn;
}
   
void CAddConsoleMakeDefault::CompletePropSheetPage(PROPSHEETPAGEA *pPropSheetPage)
{
    pPropSheetPage->dwFlags |= PSP_USEHEADERTITLE|PSP_USEHEADERSUBTITLE;
    pPropSheetPage->pszTemplate = MAKEINTRESOURCEA(IDD_ADDCONSOLE_MAKEDEFAULT);
	pPropSheetPage->pszHeaderTitle =    MAKEINTRESOURCEA(IDS_ADDCONSOLE_MAKEDEFAULT_TITLE);
	pPropSheetPage->pszHeaderSubTitle = MAKEINTRESOURCEA(IDS_ADDCONSOLE_MAKEDEFAULT_SUBTITLE);
}

INT_PTR CAddConsoleMakeDefault::OnInitDialog(HWND hwndDefaultControl)
{
    return TRUE;
}

INT_PTR CAddConsoleMakeDefault::OnSetActive()
{
    char szConsoleName[60];
    char szQuestion[120];
    m_pAddConsoleData->GetConsoleName(szConsoleName);
    WindowUtils::rsprintf(szQuestion, IDS_ADDCONSOLE_MAKEDEFAULT_QUESTION, szConsoleName);
    SetWindowTextA(GetDlgItem(m_hPageDlg, IDC_ADDCONSOLE_MAKEDEFAULT), szQuestion);
    BOOL fMakeDefault = m_pAddConsoleData->GetMakeDefault();
    CheckDlgButton(m_hPageDlg, IDC_ADDCONSOLE_YES, fMakeDefault ? BST_CHECKED : BST_UNCHECKED);
    CheckDlgButton(m_hPageDlg, IDC_ADDCONSOLE_NO, fMakeDefault ? BST_UNCHECKED : BST_CHECKED);
    PropSheet_SetWizButtons(GetParent(m_hPageDlg), PSWIZB_BACK|PSWIZB_NEXT);
    return TRUE;
}

INT_PTR CAddConsoleMakeDefault::OnWizNext()
{
    m_pAddConsoleData->SetMakeDefault((BST_CHECKED==IsDlgButtonChecked(m_hPageDlg, IDC_ADDCONSOLE_YES)) ? TRUE : FALSE);
    SetWindowLong(m_hPageDlg, DWL_MSGRESULT, IDD_ADDCONSOLE_FINISH);
    return TRUE;
}

INT_PTR CAddConsoleMakeDefault::OnWizBack()
{
    SetWindowLong(m_hPageDlg, DWL_MSGRESULT, m_pAddConsoleData->ShowAccessDenied() ? IDD_ADDCONSOLE_ACCESSDENIED : IDD_ADDCONSOLE_GETNAME);
    return TRUE;
}

void CAddConsoleFinish::CompletePropSheetPage(PROPSHEETPAGEA *pPropSheetPage)
{
    pPropSheetPage->dwFlags |= PSP_HIDEHEADER;
	pPropSheetPage->pszTemplate = MAKEINTRESOURCEA(IDD_ADDCONSOLE_FINISH);
}

INT_PTR CAddConsoleFinish::OnSetActive()
{
    char szTemp[80];
    char szConsole[100];
    DWORD dwIpAddress;
    
    //
    //  Fill out the Xbox Name and IP address
    //
    m_pAddConsoleData->GetConsoleName(szTemp);
    m_pAddConsoleData->GetIpAddress(&dwIpAddress);
    wsprintfA(szConsole, "%s(%d.%d.%d.%d)", szTemp, (dwIpAddress >> 24)&0xFF, (dwIpAddress >> 16)&0xFF, (dwIpAddress >> 8)&0xFF, dwIpAddress&0xFF);
    SetWindowTextA(GetDlgItem(m_hPageDlg,IDC_ADDCONSOLE_NAME), szConsole);
    
    //
    //  Fill out the MAKEDEFAULT field
    //
    LoadStringA(_Module.GetModuleInstance(), m_pAddConsoleData->GetMakeDefault() ? IDS_LITERAL_YES : IDS_LITERAL_NO, szTemp, sizeof(szTemp));
    SetWindowTextA(GetDlgItem(m_hPageDlg,IDC_ADDCONSOLE_MAKEDEFAULT), szTemp);

    //
    //  Fill out permission changes.
    //
    if(m_pAddConsoleData->ShowAccessDenied())
    {   
        char szPermissions[100] = {0};
        ShowWindow(GetDlgItem(m_hPageDlg,IDC_ADDCONSOLE_PERMISSIONS_CAPTION), SW_SHOW);
        ShowWindow(GetDlgItem(m_hPageDlg,IDC_ADDCONSOLE_PERMISSIONS), SW_SHOW);

        //Go through each of the permissions and add a string if necessary.
        //Since I don't want to depend on the actual order of the bits in the
        //access flags (they are defined by xboxdbg), I best just test each 
        //one with individually, rather than looping.
        
        DWORD dwAccess = m_pAddConsoleData->GetDesiredAccess();
        if(dwAccess&DMPL_PRIV_READ)
        {
            dwAccess &= ~DMPL_PRIV_READ;
            LoadStringA(_Module.GetModuleInstance(), IDS_PERMISSION_READ, szTemp, sizeof(szTemp));
            strcat(szPermissions, szTemp);
            if(dwAccess) strcat(szPermissions, ", ");
        }
        if(dwAccess&DMPL_PRIV_WRITE)
        {
            dwAccess &= ~DMPL_PRIV_WRITE;
            LoadStringA(_Module.GetModuleInstance(), IDS_PERMISSION_WRITE, szTemp, sizeof(szTemp));
            strcat(szPermissions, szTemp);
            if(dwAccess) strcat(szPermissions, ", ");
        }
        if(dwAccess&DMPL_PRIV_CONFIGURE)
        {
            dwAccess &= ~DMPL_PRIV_CONFIGURE;
            LoadStringA(_Module.GetModuleInstance(), IDS_PERMISSION_CONFIGURE, szTemp, sizeof(szTemp));
            strcat(szPermissions, szTemp);
            if(dwAccess) strcat(szPermissions, ", ");
        }
        if(dwAccess&DMPL_PRIV_CONTROL)
        {
            dwAccess &= ~DMPL_PRIV_CONTROL;
            LoadStringA(_Module.GetModuleInstance(), IDS_PERMISSION_CONTROL, szTemp, sizeof(szTemp));
            strcat(szPermissions, szTemp);
            if(dwAccess) strcat(szPermissions, ", ");
        }
        if(dwAccess&DMPL_PRIV_MANAGE)
        {
            dwAccess &= ~DMPL_PRIV_MANAGE;
            LoadStringA(_Module.GetModuleInstance(), IDS_PERMISSION_MANAGE, szTemp, sizeof(szTemp));
            strcat(szPermissions, szTemp);
        }
        SetWindowTextA(GetDlgItem(m_hPageDlg,IDC_ADDCONSOLE_PERMISSIONS), szPermissions);

    } else
    {
        ShowWindow(GetDlgItem(m_hPageDlg,IDC_ADDCONSOLE_PERMISSIONS_CAPTION), SW_HIDE);
        ShowWindow(GetDlgItem(m_hPageDlg,IDC_ADDCONSOLE_PERMISSIONS), SW_HIDE);
    }

    PropSheet_SetWizButtons(GetParent(m_hPageDlg), PSWIZB_BACK|PSWIZB_FINISH);
    return 0;
}

INT_PTR CAddConsoleFinish::OnWizBack()
{
    SetWindowLong(m_hPageDlg, DWL_MSGRESULT, IDD_ADDCONSOLE_MAKEDEFAULT);
    return TRUE;
}

INT_PTR CAddConsoleFinish::OnWizFinish()
{
    HRESULT hr = m_pAddConsoleData->OnFinish();
    if(FAILED(hr))
    {
        char szConsoleName[60];
        char szErrorString[80];
        m_pAddConsoleData->GetConsoleName(szConsoleName);
        FormatUtils::XboxErrorString(hr, szErrorString, sizeof(szErrorString));
        WindowUtils::MessageBoxResource(m_hPageDlg, IDS_SECURE_CONNECTION_FAILED, IDS_GENERIC_CAPTION, MB_ICONSTOP|MB_OK, szConsoleName, szErrorString);
        return TRUE;
    }        
    return 0;
}

HRESULT CAddConsoleData::OnFinish()
{
    HRESULT hr = S_OK;
    
    // Step 1:  If we need to change the access permissions
    //           do that first.
    if(m_dwAccess != m_dwDesiredAccess)
    {

        IXboxConnection *pConnection;
        hr = Utils::GetXboxConnection(m_szConsoleName, &pConnection);
        if(SUCCEEDED(hr))
        {
            hr = pConnection->HrUseSharedConnection(TRUE);
            if(SUCCEEDED(hr))
            {
                hr = pConnection->HrUseSecureConnection(m_szPassword);
                if(SUCCEEDED(hr))
                {   

                    char szComputerName[MAX_COMPUTERNAME_LENGTH+1];
                    DWORD dwComputerNameLength = sizeof(szComputerName);
                    if(GetComputerNameA(szComputerName, &dwComputerNameLength))
                    {
                        hr = pConnection->HrSetUserAccess(szComputerName, m_dwDesiredAccess);
                    } else 
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                    }
                    // Trust that GetComputerNameA will never ever return XBDM_NOSUCHFILE, considering it has facility code, this
                    // is a very good bet.
                    if(XBDM_NOSUCHFILE == hr)
                    {
                        hr = pConnection->HrAddUser(szComputerName, m_dwDesiredAccess);
                    } 
                }
            }
            pConnection->Release();
        }
    }
    if(FAILED(hr))
    {
        return hr;
    }

    // Step 2:  Add to the Xbox namespace
    //
    CManageConsoles manageConsole;
    manageConsole.Add(m_szConsoleName);

    // Step 3:  If we were suppose to make this default than do that.
    if(m_fMakeDefault)
    {
        manageConsole.SetDefault(m_szConsoleName);
    }

    // Step 4: Tell the shell that the contents of Xbox Neighbor hood has
    //         changed.
    SHChangeNotify(SHCNE_UPDATEDIR, SHCNF_PATH|SHCNF_FLUSH, ROOT_GUID_NAME_WIDE, NULL);

    return hr;
}

BOOL  CAddConsoleData::SetConsoleName(LPCSTR pszConsoleName)
{
    strcpy(m_szConsoleName, pszConsoleName);
    IXboxConnection *pConnection;
    
    // Wipe out any information we have on the console
    m_fConsoleIsValid = FALSE;
    m_fMakeDefault = FALSE;
    m_dwAccess = 0; //Assume no access, until we know otherwise
    m_dwIpAddress = 0;
    m_szPassword[0] = '\0';
    
    if(SUCCEEDED(Utils::GetXboxConnection(m_szConsoleName,&pConnection)))
    {
        if(SUCCEEDED(pConnection->HrResolveXboxName(&m_dwIpAddress)))
        {
            BOOL fLocked = FALSE;
            if(SUCCEEDED(pConnection->HrIsSecurityEnabled(&fLocked)))
            {
                //If this succeeded then we know the box exists.
                m_fConsoleIsValid = TRUE;
                if(fLocked)
                {
                    //
                    //  Assume no access, until we can get it.
                    //
                    m_dwAccess = 0;
            
                    //
                    //  If they don't have access
                    //
                    HRESULT hr = pConnection->HrGetUserAccess(NULL, &m_dwAccess);
                    if(XBDM_UNDEFINED==hr)
                    {
                        //Prior to build 4114, we couldn't just get our own permission by passing
                        //NULL.  It would fail with XBDM_UNDEFINED.  We could ask by machine name,
                        //but that only works if we have manage permission.  Just say all priviledge
                        //so that the use can add the box.
                        //If they don't have access, then they won't be able to do anything with, big whoop.
                        //And they won't have the nice convience of our access denied page.
                        m_dwAccess = DMPL_PRIV_ALL;
                    }
                }  else
                {
                    m_dwAccess = DMPL_PRIV_ALL;
                }
            }
        }
        pConnection->Release();
    }
    
    // By default the user wants the currently desired access.
    m_dwDesiredAccess = m_dwAccess;
    return m_fConsoleIsValid;
}

BOOL  CAddConsoleData::GetConsoleName(LPSTR pszConsoleName)
{
    _ASSERTE(pszConsoleName);
    strcpy(pszConsoleName, m_szConsoleName);
    return ('\0'==*pszConsoleName) ? FALSE : TRUE;
}

BOOL  CAddConsoleData::GetIpAddress(PDWORD pdwIpAddress)
{
    if(m_fConsoleIsValid)
    {
        *pdwIpAddress = m_dwIpAddress;
        return TRUE;
    }
    return FALSE;
}

void  CAddConsoleData::SetMakeDefault(BOOL fSet)
{
    m_fMakeDefault = fSet;
}

BOOL  CAddConsoleData::GetMakeDefault()
{
    return m_fMakeDefault;
}

BOOL  CAddConsoleData::ShowAccessDenied()
{
    return (m_dwAccess&DMPL_PRIV_ALL) ? FALSE : TRUE;
}

void  CAddConsoleData::SetDesiredAccess(DWORD dwDesiredAccess)
{
    m_dwDesiredAccess = dwDesiredAccess;
}

DWORD CAddConsoleData::GetDesiredAccess()
{
    return (m_dwDesiredAccess&DMPL_PRIV_ALL);
}

HRESULT  CAddConsoleData::SetPassword(LPCSTR pszAdminPassword)
{   
    strcpy(m_szPassword, pszAdminPassword);
    HRESULT hr;
    //
    // Validate the password, do this by making a connection, and attempting to 
    // establish a secure connection.
    //
    IXboxConnection *pConnection;
    hr = Utils::GetXboxConnection(m_szConsoleName,&pConnection);
    if(SUCCEEDED(hr))
    {
        hr = pConnection->HrUseSharedConnection(TRUE);
        if(SUCCEEDED(hr))
        {
            hr = pConnection->HrUseSecureConnection(m_szPassword);
        }
        pConnection->Release();
    }
    return hr;
}

DWORD WINAPI ExecuteAddConsoleWizardThread(PVOID)
{
    HRESULT hr;
    CAddConsoleData addConsoleData;
    CWizard wizard;
    hr = wizard.Initialize(5);
    if(SUCCEEDED(hr))
    {
        CAddConsoleWelcome      welcome;
        CAddConsoleGetName      getName(&addConsoleData);
        CAddConsoleAccessDenied accessDenied(&addConsoleData);
        CAddConsoleMakeDefault  makeDefault(&addConsoleData);
        CAddConsoleFinish       finish(&addConsoleData);

        wizard.AddPage(&welcome);
        wizard.AddPage(&getName);
        wizard.AddPage(&accessDenied);
        wizard.AddPage(&makeDefault);
        wizard.AddPage(&finish);
    }
    HWND hwndWorker = WindowUtils::CreateWorkerWindow(NULL);
    wizard.DoWizard(hwndWorker);
    if(hwndWorker) DestroyWindow(hwndWorker);
    return 0;
}

extern void ExecuteAddConsoleWizard()
{
    SHCreateThread(ExecuteAddConsoleWizardThread, NULL, CTF_COINIT|CTF_PROCESS_REF, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbshlext\visit.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    visit.h

Abstract:

  1)  Declares the IXboxVisitor class.  This is a callback interface
      implemented by clients that need to "visit" the items of a
      folder.  Visiting can also be done recursively.


  2)  Declares IXboxXXXXVisit interfaces.  These are interfaces
      implemented by simple private helpers of the CXboxFolder
      family of classes.  They basically encapsulate and distill
      what can be done when visiting a particular item type.

Environment:

    Windows 2000 and Later 
    User Mode
    Compiles UNICODE, but explictly most things are ANSI,
    since the Xbox filesystem is all ANSI.

Revision History:
    
    07-03-01 Created by Mitchell Dernis (mitchd)

--*/

//-------------------------------------------------------------------------------
//  Interface to a visit
//-------------------------------------------------------------------------------

class IXboxVisit
/*++
  Interface Description:
    Things you can do when visiting any Xbox Item
--*/
{ 
  public:
   virtual void         GetName(OUT LPSTR pszItemName) = 0;
   virtual LPITEMIDLIST GetPidl(CPidlUtils::PIDLTYPE PidlType) = 0;
   virtual ULONG        GetShellAttributes() = 0;
   virtual void         GetConsoleName(OUT LPSTR pszConsoleName) = 0;
};

class IXboxConsoleVisit : public IXboxVisit
/*++
  Interface Description:
    Things you can do when visiting an Xbox Console
--*/
{
  public:
   virtual DWORD GetIPAddress() = 0;
   virtual void  SetDefault(BOOL fMakeDefault) = 0;
   virtual BOOL  GetDefault() = 0;
};

class IXboxVolumeVisit : public IXboxVisit
/*++
  Interface Description:
    Things you can do when visiting an Xbox Volume.
--*/
{
 public:
   virtual int  GetVolumeType() = 0; // Returns string Resource ID
   virtual void GetDiskCapacity(PULONGLONG pullTotalCapacity, PULONGLONG pullFreeCapacity) = 0;
};

class IXboxFileOrDirVisit : public IXboxVisit
/*++
  Interface Description:
    Things you can do when visiting an Xbox Directory or File.
--*/
{
 public:
  virtual void    GetFileAttributes(PDM_FILE_ATTRIBUTES pDmFileAttributes) = 0;
  virtual HRESULT SetFileAttributes(PDM_FILE_ATTRIBUTES pDmFileAttributes) = 0;
  virtual HRESULT SetName(HWND hWnd, LPSTR pszNewName) = 0;
  virtual HRESULT Delete() = 0;
  virtual void GetWireName(LPSTR pszWireName) = 0;
};

//-------------------------------------------------------------------------------
//  Declare of IXboxVisitor Interface.
//-------------------------------------------------------------------------------
class IXboxVisitor
/*++
  Interface Description:
    Used to call back a visitor for each "selected item" and\or to recurse items.

  Implemented By:
    Clients of CXboxFolder that need to walk a selection of items and possibly
    recurse them.

  How is it used:
    The client calls CXBoxFolder::VisitEach or CXboxFolder::VisitThese.  It is called
    back on the appropriate method for each of the items dictated by the context and
    parameters of VisitEach or VisitThese.

    If recursion is desired the Visit???? method is always called recursing down
    the tree, Visit????Post is called on the way back up.
--*/
{
  public:

    virtual void VisitRoot         (IXboxVisit *pRoot,                DWORD *pdwFlags) = 0;   
    virtual void VisitAddConsole   (IXboxVisit *pAddConsole,          DWORD *pdwFlags) = 0;
    virtual void VisitConsole      (IXboxConsoleVisit   *pConsole,    DWORD *pdwFlags) = 0;   
    virtual void VisitVolume       (IXboxVolumeVisit    *pVolume,     DWORD *pdwFlags) = 0;
    virtual void VisitFileOrDir    (IXboxFileOrDirVisit *pFileOrDir,  DWORD *pdwFlags) = 0;

    //
    //  Directories may be recursed.  This method is called, when recursing a directory,
    //  after its children have been recursed.
    //
    virtual void VisitDirectoryPost (IXboxFileOrDirVisit *pFileOrDir, DWORD *pdwFlags) = 0;

    enum _Flags
    {
        FlagContinue = 1,
        FlagRecurse  = 2,   //Only applies to directories
        FlagCallPost = 4,   //Only applies to directories (requires FlagRecurse)
        
    };
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbshlext\wizold.h ===
###
### THIS FILE IS FOR ARCHIVAL PURPOSES
### CAddConsoleData Has been changed extensively, and I just wanted to preserve the code
### somewhere.  The major cause of the change is that this version of the Add New Console
### wizard allowed adding more than one Xbox at a time, the new wizard does not allow this.
###

/*++

Copyright (c) Microsoft Corporation

Module Name:

    wizard.h

Abstract:

    Class definitions for wizard property sheets and pages.

Environment:

    Windows 2000 and Later 
    User Mode

Revision History:
    
    08-07-2001 : created (mitchd)

--*/


class CWizardPage;
struct WizardPageInfo
{
    WizardPageInfo():pWizardPage(NULL){}
    CWizardPage *pWizardPage;  // Pointer to a property Page
};

class CWizard
{
  public:
    CWizard() : 
        m_uMaxPages(0),
        m_uPageCount(0),
        m_pPages(NULL),
        m_pPropSheetPages(NULL),
        m_hrInitialize(E_FAIL)
        {}
    ~CWizard() {delete [] m_pPages; delete [] m_pPropSheetPages; DeleteObject(m_hTitleFont);}
    
    HRESULT Initialize(UINT uPages);
    HRESULT DoWizard(HWND hwndParent);
    void AddPage(CWizardPage *pPage);

  private:

    UINT              m_uItemCount;
    UINT              m_uMaxPages;
    UINT              m_uPageCount;
    WizardPageInfo   *m_pPages;
    PROPSHEETPAGEA   *m_pPropSheetPages;
    char              m_szCaption[MAX_PATH];
    HWND              m_hWndParent;
    HFONT             m_hTitleFont;

    //Outlaw Copy C'tor and Assignment
    CWizard(const CWizard&);
    CWizard& operator=(const CWizard&);

    HRESULT m_hrInitialize;
};

class CWizardPage
{
  public:
    CWizardPage() : m_hPageDlg(NULL), m_hTitleFont(NULL) {}
  protected:
    virtual INT_PTR OnInitDialog(HWND hwndDefaultControl);
    virtual INT_PTR OnCommand(WPARAM wParam, LPARAM lParam){return 0;}
    virtual INT_PTR OnMessage(UINT uMsg, WPARAM wParam, LPARAM lParam){return 0;}

    
    virtual INT_PTR OnSetActive()=0;
    virtual INT_PTR OnWizBack(){return 0;}
    virtual INT_PTR OnWizNext(){return 0;}
    virtual INT_PTR OnWizFinish(){return 0;}
    virtual INT_PTR OnNotify(LPNMHDR pnmhdr){return 0;}
    
    static INT_PTR CALLBACK DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    virtual void CompletePropSheetPage(PROPSHEETPAGEA *pPropSheetPage) = 0;
    
    HWND    m_hPageDlg;
  private:

    void FilloutPropSheetPage(PROPSHEETPAGEA *pPropSheetPage, HFONT hTitleFont);
    HFONT   m_hTitleFont;
    CWizard *pParent;
    friend class CWizard;
};

struct CONSOLE_INFO
{
    LPSTR           pszName;
    DWORD           dwIpAddress;
    BOOL            fSelected;
    BOOL            fLocalSubnet;
    CONSOLE_INFO    *pPrevious;
    CONSOLE_INFO    *pNext;
};

class CAddConsoleData
{
  public:
    CAddConsoleData() : m_fChoose(FALSE), m_iConsoleCount(0), m_iConsolesSelected(0), m_pConsoles(NULL), m_pConsolesTail(NULL){}

    void InitListView(HWND hListView, bool fChooser = FALSE);
    void RefreshListView(HWND hListView);
    void AddConsole(HWND hListView, LPSTR pszConsoleName);
    INT_PTR OnNotify(LPNMHDR pnmhdr);

    void OnFinish();

    int  GetSelectCount() {return m_iConsolesSelected;}
    void GetSelectedItemsString(LPSTR pszBuffer, UINT ccBuffer);
    
    BOOL         m_fChoose;

  protected:
     void AddItemToListView(HWND hListView, int index, CONSOLE_INFO *pConsole);

  private:
    int           m_iConsoleCount;
    int           m_iConsolesSelected;
    CONSOLE_INFO *m_pConsoles;
    CONSOLE_INFO *m_pConsolesTail;
};

class CAddConsoleWelcome : public CWizardPage
{
    public:
     CAddConsoleWelcome(){}

    protected:

     virtual INT_PTR OnSetActive();
     virtual void CompletePropSheetPage(PROPSHEETPAGEA *pPropSheetPage);
};

#if NEVER
class CAddConsoleHow : public CWizardPage
{
    public:
      CAddConsoleHow(CAddConsoleData *pAddConsoleData) : m_pAddConsoleData(pAddConsoleData){}

    protected:
      virtual void CompletePropSheetPage(PROPSHEETPAGEA *pPropSheetPage);
      virtual INT_PTR OnSetActive();
      virtual INT_PTR OnWizNext();
      virtual INT_PTR OnCommand(WPARAM wParam, LPARAM lParam);
      CAddConsoleData *m_pAddConsoleData;
};


class CAddConsoleChoose : public CWizardPage
{
    public:
      CAddConsoleChoose(CAddConsoleData *pAddConsoleData) : m_pAddConsoleData(pAddConsoleData){}

    protected:
    
      virtual INT_PTR OnSetActive();
      virtual INT_PTR OnWizNext();
      virtual INT_PTR OnWizBack();
      virtual INT_PTR OnNotify(LPNMHDR pnmhdr);

      virtual INT_PTR OnInitDialog(HWND hwndDefaultControl);
      virtual void CompletePropSheetPage(PROPSHEETPAGEA *pPropSheetPage);
      //virtual INT_PTR OnCommand(WPARAM wParam, LPARAM lParam);

      CAddConsoleData *m_pAddConsoleData;
};
#endif NEVER

class CAddConsoleByName : public CWizardPage
{
    public:
      CAddConsoleByName(CAddConsoleData *pAddConsoleData) : m_pAddConsoleData(pAddConsoleData){}

    protected:
    
      virtual INT_PTR OnSetActive();
      virtual INT_PTR OnWizNext();
      virtual INT_PTR OnWizBack();
      virtual INT_PTR OnNotify(LPNMHDR pnmhdr);
      virtual INT_PTR OnCommand(WPARAM wParam, LPARAM lParam);

      virtual INT_PTR OnInitDialog(HWND hwndDefaultControl);
      virtual void CompletePropSheetPage(PROPSHEETPAGEA *pPropSheetPage);
      //virtual INT_PTR OnCommand(WPARAM wParam, LPARAM lParam);

      CAddConsoleData *m_pAddConsoleData;
};

class CAddConsoleFinish : public CWizardPage
{
    public:
      CAddConsoleFinish(CAddConsoleData *pAddConsoleData) : m_pAddConsoleData(pAddConsoleData){}

    protected:
      
      virtual INT_PTR OnSetActive();
      virtual INT_PTR OnWizBack();
      virtual INT_PTR OnWizFinish();

      virtual void CompletePropSheetPage(PROPSHEETPAGEA *pPropSheetPage);
      CAddConsoleData *m_pAddConsoleData;
};

extern void ExecuteAddConsoleWizard();
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbshlext\xbfolder.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    xbfolder.cpp

Abstract:

   Implementation of CXboxFolder and its derivatives.

Environment:

    Windows 2000 and Later 
    User Mode
    Compiles UNICODE, but uses many ANSI APIs explictly.

Revision History:
    
    06-29-2001 : created

--*/

#include "stdafx.h"

/********
*********  Organization of Code.  Rather than implementing every class in a different code
*********  file. All the methods declared in the base class as virtual are implemented for
*********  each inheriting class one after the other.  For the most part methods are
*********  implemented in the order they are declared.  They only deviations is that 
*********  in some cases, public, protected and private are interleaved.
********/

/*
** Construction:
**
**   CXboxFolder implements a default constructor
**   and an InitBaseClass method.
**
**   Every derived class that can be instantiated
**   implements: 
**
**      1) a private constructor
**      1) a public  static Create   method
**      2) a public  virtual Clone   method
**      3) a public  virtual Destroy method
**
**   EXCEPT CXboxRoot is special.  It is served
**      by the module's class factory and the
**      default c'tor works.  It is initialized with
**      
**
**   Create:
**      Constructs a class and initializes it to mirror
**      the desired item.  If it fails, there is no memory
**      allocation.
**
**      The arguments to Create a class specific.
**
**   Clone:
**   CloneSelection:
**      Constucts an duplicate of itself with a specified
**      subset of children.
**
**   Destroy:
**      Destroys the object completely cleaning up, the object
**      then deletes itself.  Destroy fails and ASSERTS during
**      recursion.
**
**   The also usually have a private c'tor that initialize
**   anything fail-safe.
*/


/*
** Constructors - initialize members to a known state
**                real construction is left for 
**                the Create methods (which use
**                CXboxFolder::InitBaseClass)
*/

CXboxFolder::CXboxFolder() : 
    m_pszPathName(NULL),
    m_pszName(NULL),
    m_ulShellAttributes(0),
    m_uPathDepth(0),
    m_uPathLen(0),
    m_pidlRoot(NULL),
    m_uRootPidlLen(0),
    m_fSelectionClone(FALSE),
    m_fChildrenValid(FALSE),
    m_uAllocatedChildCount(0),   
    m_uChildCount(0), 
    m_uLastChildIndex(0),
    m_rgpszChildNames(NULL),
    m_rgulChildShellAttributes(NULL)
{
    INIT_TRACKABLEOBJECT_NAME(CXboxFolder);
}

CXboxRoot::CXboxRoot() :  
  m_rgdwChildIPAddresses(NULL),
  m_rgpszActualNames(NULL),
  m_uDefaultConsole((UINT)-1)
{
    INIT_TRACKABLEOBJECT_NAME(CXboxRoot);  
    m_dwSelectionVerbs = ROOT_VERBS;
}

CXboxConsole::CXboxConsole() :
  m_pConnection(NULL),
  m_pszDisplayName(NULL),
  m_dwIPAddress(0),
  m_rgullChildFreeSpace(NULL),
  m_rgullChildTotalSpace(NULL),
  m_rguChildVolumeType(NULL)
{
  INIT_TRACKABLEOBJECT_NAME(CXboxConsole);
  m_dwSelectionVerbs = CONSOLE_VERBS;
}

CXboxFileSystemFolder::CXboxFileSystemFolder() :
  m_rgChildFileAttributes(NULL),
  m_rgszChildTypeNames(NULL)
{
    INIT_TRACKABLEOBJECT_NAME(CXboxConsole);
}

HRESULT 
CXboxFolder::InitBaseClass(
    LPCSTR          pszPathName,
    ULONG           ulShellAttributes,
    LPCITEMIDLIST   pidlRoot
    )
/*++
  Routine Description:
    Initializes the name, pidl, and ShellAttributes
    of a newly created CXboxFolder.
--*/
{
    _ASSERTE(pszPathName);
    LPCSTR pszParse = pszPathName;

    //
    //  Setup the name and path members
    //

    m_uPathLen = 0;
    m_uPathDepth = 1;
    while(*pszParse)
    {
        if(L'\\' == *pszParse)
        {
            m_uPathDepth++;
        }
        m_uPathLen++;
        pszParse++;
    }
    m_pszPathName = new CHAR[m_uPathLen+1];
    
    if(m_pszPathName)
    {
        //
        // Assume that memcpy is more efficient than
        // strcpy, since we already know the length
        //

        memcpy(m_pszPathName, pszPathName, m_uPathLen+1);

        //
        //  m_pszName is pointer to the simple name.
        //  If '\\' is not found than it is the same
        //  as m_pszPathName.
        //

        m_pszName = strrchr(m_pszPathName, '\\');
        if(m_pszName)
        {
          m_pszName++;
        }else
        {
          m_pszName = m_pszPathName;
        } 
        
    } else
    {
        return E_OUTOFMEMORY;
    }
    
    //
    // Setup pidl members
    //

    m_pidlRoot = CPidlUtils::Copy(pidlRoot);
    if(m_pidlRoot)
    {
        m_uRootPidlLen = CPidlUtils::GetLength(m_pidlRoot);
    } else
    {
        delete [] m_pszPathName;
        m_pszPathName = NULL;
        return E_OUTOFMEMORY;
    }

    //
    //  Copy the shell attributes
    //

    m_ulShellAttributes = ulShellAttributes;
    
    return S_OK;
}

HRESULT
CXboxConsole::Create(
    LPCSTR          pszResolveName,
    LPCITEMIDLIST   pidlRoot,
    IXboxConnection *pConnection,
    REFIID          riid,
    void            **ppv
    )
/*++
  Routine Description:
    Creates an object of type CXboxConsole.
  Arguments:
    pszResolveName  - name to use finding on the wire finding the box.
                      This name goes into the pidl.
    pidlRoot        - pidl of Xbox root.
    pConnection     - connection to talk to console.
    riid            - desired interface.
    ppv             - pointer to receive new CXboxConsole.
--*/
{
    HRESULT hr;
    CComObject<CXboxConsole> *pNewConsole;

    *ppv = NULL;

    hr = CComObject<CXboxConsole>::CreateInstance(&pNewConsole);
    if(SUCCEEDED(hr))
    {
        hr = pNewConsole->InitBaseClass(
                    pszResolveName,
                    CONSOLE_SHELL_ATTRIBUTES,
                    pidlRoot
                    );
        
        if(SUCCEEDED(hr))
        {
            // 
            // The name oif the box is the resolve name.  If the box is specified
            // by IP address, we only show the actual name in the property page.
            //
            UINT uDisplayNameLen = strlen(pszResolveName)+1;
            pNewConsole->m_pszDisplayName = new char[uDisplayNameLen];
            if(pNewConsole->m_pszDisplayName)
            {
                memcpy(pNewConsole->m_pszDisplayName, pszResolveName, uDisplayNameLen);
                hr = pConnection->HrResolveXboxName(&pNewConsole->m_dwIPAddress);
                if(SUCCEEDED(hr))
                {
                    pConnection->AddRef();
                    pNewConsole->m_pConnection = pConnection;
                    hr = pNewConsole->QueryInterface(riid, ppv);
                }
            } else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        if(!SUCCEEDED(hr))
        {
            delete pNewConsole;
        }
    }
    return hr;
}

HRESULT 
CXboxVolume::Create(
    LPCSTR          pszPathName,
    LPCITEMIDLIST   pidlRoot,
    IXboxConnection *pConnection,
    REFIID          riid,
    void            **ppv
    )
/*++
  Routine Description:
    Creates an object of type CXboxVolume.
  Arguments:
    pszPathName  - name to use finding on the wire finding the box.
                   This name goes into the pidl.
    pidlRoot     - pidl of Xbox root.
    pConnection  - connection to talk to volume.
    riid         - desired interface.
    ppv          - pointer to receive new CXboxVolume.
--*/
{
    HRESULT hr = E_OUTOFMEMORY;
    CComObject<CXboxVolume> *pNewVolume;

    *ppv = NULL;
    
    hr = CComObject<CXboxVolume>::CreateInstance(&pNewVolume);
    if(SUCCEEDED(hr))
    {
        hr = pNewVolume->InitBaseClass(
                pszPathName,
                VOLUME_SHELL_ATTRIBUTES|SFGAO_CANRENAME,
                pidlRoot
                );

        if(SUCCEEDED(hr))
        {
            pConnection->AddRef();
            pNewVolume->m_pConnection = pConnection;
            hr = pNewVolume->QueryInterface(riid, ppv);
        }
        
        if(!SUCCEEDED(hr))
        {
            delete pNewVolume;
        }
    }

    return hr;
}

HRESULT 
CXboxDirectory::Create(
    LPCSTR          pszPathName,
    LPCITEMIDLIST   pidlRoot,
    IXboxConnection *pConnection,
    REFIID          riid,
    void            **ppv
    )
{
    HRESULT hr = E_OUTOFMEMORY;
    CComObject<CXboxDirectory> *pNewDirectory;

    *ppv = NULL;
    
    hr = CComObject<CXboxDirectory>::CreateInstance(&pNewDirectory);
    if(SUCCEEDED(hr))
    {
        hr = pNewDirectory->InitBaseClass(
                pszPathName,
                DIRECTORY_SHELL_ATTRIBUTES,
                pidlRoot
                );

        if(SUCCEEDED(hr))
        {
            pConnection->AddRef();
            pNewDirectory->m_pConnection = pConnection;
            hr = pNewDirectory->QueryInterface(riid, ppv);
        }
        
        if(!SUCCEEDED(hr))
        {
            delete pNewDirectory;
        }
    }
    return hr;
}

void CXboxFolder::Destroy()
{
    delete [] m_pszPathName;
    m_pszPathName = NULL;
    CPidlUtils::Free(m_pidlRoot);
    FreeChildren();
}

void CXboxConsole::Destroy()
{
    m_pConnection->Release();
    m_pConnection = NULL;
    delete m_pszDisplayName;
    m_pszDisplayName = NULL;
    CXboxFolder::Destroy();
}

void CXboxFileSystemFolder::Destroy()
{
    m_pConnection->Release();
    m_pConnection = NULL;
    CXboxFolder::Destroy();
}

/*
**  Clone - Makes a copy of a CXboxFolder, including:
**
**          Information about item.
**          Current Selection.
**
**          
*/

HRESULT CXboxFolder::BuildSelectionIndexList(UINT cidl, LPCITEMIDLIST *apidl, UINT **ppuIndexList)
{
    HRESULT hr;
    UINT *puIndexList = NULL;
    UINT uIndex;

    *ppuIndexList = NULL;
    
    _ASSERTE(cidl);
    _ASSERTE(apidl);

    //
    //  Build an index list.
    //
    puIndexList = new UINT[cidl];
    if(!puIndexList)
    {
        return E_OUTOFMEMORY;
    }

    //
    //  Walk the pidls and build a list of indices
    //
    for(uIndex = 0; uIndex < cidl; uIndex++)
    {
        hr = GetChildIndex((LPSTR)apidl[uIndex]->mkid.abID, puIndexList+uIndex);
        if(FAILED(hr))
        {
            delete [] puIndexList;    
            return hr;
        }
    }

    *ppuIndexList = puIndexList;
    return S_OK;
}

HRESULT CXboxFolder::DuplicateBaseMembers(CXboxFolder *pClone)
/*++
  Routine Description:

   Duplicates (for cloning purposes) the base CXBoxFolder members
   that do not need to be handled in a class specific way.  This is
   mostly:

   Name, Pidl and Shell Attribute related members.

  Argument:

   pClone - clone to be initialized.

  Return Value:
   S_OK           - on success.
   E_OUTOFMEMORY  - If an allocation failed.

--*/
{
    pClone->m_pszPathName  = new char[m_uPathLen+1];
    if(pClone->m_pszPathName)
    {
        memcpy(pClone->m_pszPathName, m_pszPathName, m_uPathLen+1);
        pClone->m_pszName = pClone->m_pszPathName + (m_pszName - m_pszPathName);
        pClone->m_pidlRoot = (LPITEMIDLIST)g_pShellMalloc->Alloc(m_uRootPidlLen);
        if(pClone->m_pidlRoot)
        {
            memcpy(pClone->m_pidlRoot, m_pidlRoot, m_uRootPidlLen);
        } else
        {
            delete [] pClone->m_pszPathName;
            return E_OUTOFMEMORY;
        }
    } else
    {
        return E_OUTOFMEMORY;
    }

    pClone->m_uPathLen = m_uPathLen;
    pClone->m_uPathDepth = m_uPathDepth;
    pClone->m_uRootPidlLen = m_uRootPidlLen;
    pClone->m_ulShellAttributes = m_ulShellAttributes;
    pClone->m_fSelectionClone = TRUE;
    pClone->m_fChildrenValid = TRUE;
    pClone->m_uAllocatedChildCount = 0;
    pClone->m_uChildCount = 0;
    pClone->m_uLastChildIndex = 0;
    pClone->m_rgpszChildNames = NULL;
    pClone->m_rgulChildShellAttributes = NULL;

    return S_OK;
}

HRESULT CXboxFolder::CloneSelection(UINT cidl, LPCITEMIDLIST *apidl, CXboxFolder **ppSelectionClone)
{
    HRESULT hr = S_OK;
    UINT *puIndexList = NULL;

    if(cidl)
    {
        _ASSERTE(apidl);
        hr = BuildSelectionIndexList(cidl, apidl, &puIndexList);
    } else
    {
        _ASSERTE(!apidl);
    }

    //
    //  Let the class specific portion finish.
    //
    if(SUCCEEDED(hr))
    {
        hr = CloneSelection(cidl, puIndexList, ppSelectionClone);
        delete [] puIndexList;
    }
    return hr;
}


HRESULT CXboxFolder::Clone(CXboxFolder **ppSelectionClone)
{
    _ASSERTE(m_fSelectionClone);
    
    //
    //  Copy all the children
    //
    UINT *puIndexList = new UINT[m_uChildCount];
    if(!puIndexList)
    {
        return E_OUTOFMEMORY;
    }
    UINT uIndex;
    for(uIndex=0; uIndex < m_uChildCount; uIndex++) puIndexList[uIndex] = uIndex;
    
    HRESULT hr = CloneSelection(m_uChildCount, puIndexList, ppSelectionClone);
    delete [] puIndexList;
    return hr;
}


HRESULT CXboxRoot::CloneSelection(UINT uIndexCount, const UINT *puIndexList, CXboxFolder **ppSelectionClone)
{
    HRESULT hr = S_OK;
    CComObject<CXboxRoot> *pClone;

    *ppSelectionClone = NULL;

    //
    //  Create the new folder, unitialized
    //

    hr = CComObject<CXboxRoot>::CreateInstance(&pClone);
    if(FAILED(hr))
    {
        return hr;
    }

    pClone->AddRef();  //It needs a reference count, so we can delete with release.

    //
    //  Now copy all the common base guts
    //
    hr = DuplicateBaseMembers(pClone);
    
    //
    //  Now handle class specific and children
    //
    if(SUCCEEDED(hr))
    {
        pClone->m_rgdwChildIPAddresses = NULL;
        pClone->m_rgpszActualNames = NULL;
        pClone->m_uDefaultConsole = 0;
        if(uIndexCount)
        {
            UINT uIndex;
            hr = pClone->ReallocateChildren(uIndexCount);
            pClone->m_dwSelectionVerbs = CONSOLE_VERBS;
            for(uIndex = 0; uIndex < uIndexCount; uIndex++, pClone->m_uChildCount++)
            {
                //
                //  Copy the name.
                //

                UINT uNameLength = strlen(m_rgpszChildNames[puIndexList[uIndex]])+1;
                pClone->m_rgpszChildNames[uIndex] = new char[uNameLength];
                if(pClone->m_rgpszChildNames[uIndex])
                {
                   memcpy(pClone->m_rgpszChildNames[uIndex], m_rgpszChildNames[puIndexList[uIndex]], uNameLength);
                } else
                {
                   hr = E_OUTOFMEMORY;
                   break;
                }

                //
                //  If one of the items is the AddConsole Wizard, change the available verbs
                //
                if(*m_rgpszChildNames[puIndexList[uIndex]] == '?')
                {
                    pClone->m_dwSelectionVerbs = ADDCONSOLE_VERBS;
                }

                //
                //  Copy the shell attributes
                //

                pClone->m_rgulChildShellAttributes[uIndex] = m_rgulChildShellAttributes[puIndexList[uIndex]];

                //
                //  Copy the ip addresses
                //

                pClone->m_rgdwChildIPAddresses[uIndex] = m_rgdwChildIPAddresses[puIndexList[uIndex]];
                
                //  Copy the actual names
                if(m_rgpszActualNames[puIndexList[uIndex]])
                {
                    if(XBOX_USE_USER_PROVIDED_NAME == m_rgpszActualNames[puIndexList[uIndex]])
                    {
                        pClone->m_rgpszActualNames[uIndex] = XBOX_USE_USER_PROVIDED_NAME;
                    } else
                    {
                        UINT uNameLen = strlen(m_rgpszActualNames[puIndexList[uIndex]])+1;
                        pClone->m_rgpszActualNames[uIndex] = new char[uNameLen];
                        if(pClone->m_rgpszActualNames[uIndex])
                        {
                            //we know the length so memcpy is more efficient.
                            memcpy(pClone->m_rgpszActualNames[uIndex], m_rgpszActualNames[puIndexList[uIndex]], uNameLen);
                        }
                    }
                }
            }
        }
    }
    
    if(SUCCEEDED(hr))
    {
        *ppSelectionClone = pClone;
    } else
    {
        pClone->Release();
    }

    return hr;
}



HRESULT CXboxConsole::CloneSelection(UINT uIndexCount, const UINT *puIndexList, CXboxFolder **ppSelectionClone)
{
    HRESULT hr = S_OK;
    LPSTR   pszDriveLetters;
    CComObject<CXboxConsole> *pClone;

    *ppSelectionClone = NULL;

    //
    //  Create the new folder, unitialized
    //

    hr = CComObject<CXboxConsole>::CreateInstance(&pClone);
    if(FAILED(hr))
    {
        return hr;
    }

    pClone->AddRef();  //It needs a reference count, so we can delete with release.

    //
    //  Now copy all the common base guts
    //
    hr = DuplicateBaseMembers(pClone);
    
    //
    //  Now handle class specific and children
    //
    if(SUCCEEDED(hr))
    {
        UINT uNameLength = strlen(m_pszDisplayName)+1;
        pClone->m_pszDisplayName = new char[uNameLength];
        if(!pClone->m_pszDisplayName)
        {
            hr = E_OUTOFMEMORY;
        } else
        {
            memcpy(pClone->m_pszDisplayName, m_pszDisplayName, uNameLength);
            pClone->m_pConnection = m_pConnection;
            m_pConnection->AddRef();
            pClone->m_dwIPAddress = m_dwIPAddress;
            if(uIndexCount)
            {
                UINT uIndex;
                pClone->m_dwSelectionVerbs = VOLUME_VERBS;
                hr = pClone->ReallocateChildren(uIndexCount);
                pszDriveLetters = new char[2*uIndexCount];
                if(pszDriveLetters)
                {
                    for(uIndex = 0; uIndex < uIndexCount; uIndex++, pClone->m_uChildCount++)
                    {
                        //
                        //  Copy the name.
                        //

                        pClone->m_rgpszChildNames[uIndex] = pszDriveLetters;
                        *pszDriveLetters++ = *m_rgpszChildNames[puIndexList[uIndex]];
                        *pszDriveLetters++ = '\0';

                        //
                        //  Copy the shell attributes
                        //

                        pClone->m_rgulChildShellAttributes[uIndex] = m_rgulChildShellAttributes[puIndexList[uIndex]];

                        //
                        //  Copy the class specific information
                        //

                        pClone->m_rgullChildFreeSpace[uIndex]  = m_rgullChildFreeSpace[puIndexList[uIndex]];
                        pClone->m_rgullChildTotalSpace[uIndex] = m_rgullChildTotalSpace[puIndexList[uIndex]];
                        pClone->m_rguChildVolumeType[uIndex]   = m_rguChildVolumeType[puIndexList[uIndex]];
                    }
                }
            }
        }
    }
    
    if(SUCCEEDED(hr))
    {
        *ppSelectionClone = pClone;
    } else
    {
        //
        //  Should clean up everything we managed to set.
        //

        pClone->Release();
    }

    return hr;
}


HRESULT CXboxFileSystemFolder::CloneSelection(UINT uIndexCount, const UINT *puIndexList, CXboxFileSystemFolder *pClone)
{
    //
    //  Now copy all the common base guts
    //
    HRESULT hr = DuplicateBaseMembers(pClone);
    
    //
    //  Now handle class specific and children
    //
    if(SUCCEEDED(hr))
    {
        pClone->m_pConnection = m_pConnection;
        m_pConnection->AddRef();
        if(uIndexCount)
        {
            UINT uIndex;
            // Assume the maximum number of verbs.  As we go through actual items
            // we AND with the ones that actually apply.
            pClone->m_dwSelectionVerbs = DIRECTORY_VERBS|DIRECTORY_VERBS|FILE_VERBS|XBE_VERBS;
            hr = pClone->ReallocateChildren(uIndexCount);
            for(uIndex = 0; uIndex < uIndexCount; uIndex++, pClone->m_uChildCount++)
            {
                //
                //  Copy the name.
                //

                UINT uNameLength = strlen(m_rgpszChildNames[puIndexList[uIndex]])+1;
                pClone->m_rgpszChildNames[uIndex] = new char[uNameLength];
                if(pClone->m_rgpszChildNames[uIndex])
                {
                   memcpy(pClone->m_rgpszChildNames[uIndex], m_rgpszChildNames[puIndexList[uIndex]], uNameLength);
                } else
                {
                   hr = E_OUTOFMEMORY;
                   break;
                }

                //
                //  Copy the type name.
                //

                uNameLength = strlen(m_rgszChildTypeNames[puIndexList[uIndex]])+1;
                pClone->m_rgszChildTypeNames[uIndex] = new char[uNameLength];
                if(pClone->m_rgszChildTypeNames[uIndex])
                {
                   memcpy(pClone->m_rgszChildTypeNames[uIndex], m_rgszChildTypeNames[puIndexList[uIndex]], uNameLength);
                } else
                {
                   hr = E_OUTOFMEMORY;
                   break;
                }

                //
                //  Copy the shell attributes
                //

                pClone->m_rgulChildShellAttributes[uIndex] = m_rgulChildShellAttributes[puIndexList[uIndex]];

                //
                //  Copy the file attributes
                //

                memcpy(
                   &pClone->m_rgChildFileAttributes[uIndex],
                   &m_rgChildFileAttributes[puIndexList[uIndex]],
                   sizeof(DM_FILE_ATTRIBUTES)
                   );

                // Figure out the supported verbs
                if(pClone->m_rgChildFileAttributes[uIndex].Attributes&FILE_ATTRIBUTE_DIRECTORY)
                {
                    pClone->m_dwSelectionVerbs &= DIRECTORY_VERBS;
                } else
                {
                    //If it is an XBE file, AND with XBE verbs
                    if(IsXbeFile(pClone->m_rgpszChildNames[uIndex]))
                    {
                        pClone->m_dwSelectionVerbs &= XBE_VERBS;
                    } else
                    {
                        pClone->m_dwSelectionVerbs &= FILE_VERBS;
                    }
                }
            }
        }
    }
    
    return hr;
}


HRESULT CXboxVolume::CloneSelection(UINT uIndexCount, const UINT *puIndexList, CXboxFolder **ppSelectionClone)
{
    HRESULT hr = S_OK;
    CComObject<CXboxVolume> *pClone;

    *ppSelectionClone = NULL;

    //
    //  Create the new folder, unitialized
    //

    hr = CComObject<CXboxVolume>::CreateInstance(&pClone);
    if(FAILED(hr))
    {
        return hr;
    }

    pClone->AddRef();  //It needs a reference count, so we can delete with release.

    hr = CXboxFileSystemFolder::CloneSelection(uIndexCount, puIndexList, pClone);
    
    if(SUCCEEDED(hr))
    {
        pClone->m_uVolumeType = m_uVolumeType;
        *ppSelectionClone = pClone;
    } else
    {
        //
        //  Should clean up everything we managed to set.
        //

        pClone->Release();
    }

    return hr;
}


HRESULT CXboxDirectory::CloneSelection(UINT uIndexCount, const UINT *puIndexList, CXboxFolder **ppSelectionClone)
{
    HRESULT hr = S_OK;
    CComObject<CXboxDirectory> *pClone;

    *ppSelectionClone = NULL;

    //
    //  Create the new folder, unitialized
    //

    hr = CComObject<CXboxDirectory>::CreateInstance(&pClone);
    if(FAILED(hr))
    {
        return hr;
    }

    pClone->AddRef();  //It needs a reference count, so we can delete with release.

    hr = CXboxFileSystemFolder::CloneSelection(uIndexCount, puIndexList, pClone);
    
    if(SUCCEEDED(hr))
    {
        *ppSelectionClone = pClone;
    } else
    {
        //
        //  Should clean up everything we managed to set.
        //

        pClone->Release();
    }

    return hr;
}

UINT CXboxFolder::GetPidlLen(CPidlUtils::PIDLTYPE PidlType)
/*++
  Routine Description:
   Computes the length of a pidl from the name information.
  Arguments:
   PidlType - The type pidl for which to get the length.  Valid values are:

              CXboxFolder::PidlTypeSimple   - a single SHITEMID, i.e. relative to the immediate
                                            parent.

              CXboxFolder::PidlTypeRoot     - relative to Xbox Root, but not including the
                                            the portion from the Desktop to Xbox Root.
              CXboxFolder::PidlTypeAbsolute - the fully qualified pidl, including the Desktop.
  Return Value:
   The size of the desired pidl in bytes.
--*/
{
  //
  //  Special handling for root
  //
  if(0==m_uPathDepth)
  {
    return m_uRootPidlLen;
  }

  //
  // Each SHITEMID in the pidl is a NULL terminated
  // string corresponding exactly to the Name of the
  // item.
  //
  
  //
  // Start sizeof(USHORT) to termiante the pidl +
  // the sizeof(CHAR) for the last NULL.
  //
  
  UINT uPidlLen = sizeof(USHORT)+sizeof(CHAR);

  //
  //  Switch on the pidl type
  //
  switch (PidlType)
  {
    case CPidlUtils::PidlTypeSimple:
      //Add in the length of the simple name.
      uPidlLen += strlen(m_pszName);
      break;
    case CPidlUtils::PidlTypeAbsolute:
      uPidlLen += m_uRootPidlLen;
      uPidlLen -= sizeof(USHORT); //The root pidl was already terminated
      //Fall through
    case CPidlUtils::PidlTypeRoot:
      //Add in the path len, the extra '\0' are a wash
      //with missing '\'.
      uPidlLen += m_uPathLen;
      //Add in a USHORT for each cb of each SHITEMID.
      uPidlLen += (m_uPathDepth*sizeof(USHORT));
      break;
    default:
      _ASSERTE("PidlType Unknown" && FALSE);
  }

  return uPidlLen;
}

LPITEMIDLIST CXboxFolder::GetPidl(CPidlUtils::PIDLTYPE PidlType, UINT uExtraAllocation)
/*++
 Routine Description:
  Get a Pidl for the current XboxItem.   Allocate memory using
  the Shell IMalloc (i.e. from SHGetMalloc) and fills it in with desire pidl.
 Arguments:
  PidlType          - See GetPidlLen for allowed values.
  uExtraAllocation  - Extra bytes to allocate beyond those required.  Used for
                      tacking on extra SHITEMID by GetChildPidl.
 Return Value:
  On success - the desired pidl.
  On failure - NULL.  The only failure mode is an out of memory failure.
--*/
{
  UINT uPidlLen = GetPidlLen(PidlType);
  LPITEMIDLIST pidl = (LPITEMIDLIST)g_pShellMalloc->Alloc(uPidlLen+uExtraAllocation);
  LPITEMIDLIST pidlWalk = pidl;
  LPSTR pszPath = m_pszPathName;
  USHORT cb;
  if(pidl)
  {
    //
    //  If this is the root (m_uPathDepth is 0)
    //  just copy the m_pidlRoot.
    //
    if(!m_uPathDepth)
    {
        memcpy(pidlWalk, m_pidlRoot, m_uRootPidlLen);
    } else
    //
    //  Otherwise, we have more work.
    //
    {
        //
        // If we need an absolute pidl, start with the root.
        //

        if(PidlType==CPidlUtils::PidlTypeAbsolute)
        {
            // Copy root pidl (leaving off termination.
            memcpy(pidlWalk, m_pidlRoot, m_uRootPidlLen-sizeof(USHORT));
            pidlWalk = AdvancePtr(pidlWalk, m_uRootPidlLen-sizeof(USHORT));
        }
    
        //
        // Otherwise if it is simple, get only the last item id.
        //
    
        else if(PidlType==CPidlUtils::PidlTypeSimple)
        {
            pszPath = m_pszName;
        }
    
        //
        // Copy each item from the path.
        //

        while(*pszPath)
        {
            cb = 0;
            while(*pszPath && (*pszPath != '\\')) pidlWalk->mkid.abID[cb++] = *pszPath++;
            pidlWalk->mkid.abID[cb++] = '\0';
            if(*pszPath == '\\') pszPath++;
            pidlWalk->mkid.cb = cb+sizeof(USHORT);
            pidlWalk = AdvancePtr(pidlWalk, pidlWalk->mkid.cb);
        }

        //
        //  Terminate the pidl
        //

        pidlWalk->mkid.cb = 0;
    }
  }
  _ASSERTE(pidl);
  ATLTRACE("GetPidl returning:(0x%0.8x)",pidl);
  DEBUG_DUMP_PIDL(pidl);
  return pidl;
}

HRESULT CXboxFolder::CompareItemIDs(UINT uColumn, int iNameCmp, const SHITEMID *pItemId1, const SHITEMID *pItemId2)
/*++
 Routine Description:
    Compares two immediate children of a CXboxFolder based on an uColumn.  The Column
      ID is specific to the class type of the CXboxFolder.
      
  Arguments:
      uColumn  - index of column to sort bt.
      iNameCmp - result of case-insenstive comparison on builds carried out by caller.
      pItemId1 - simple SHITEMID of first ID to compare.
      pItemId2 - simple SHITEMID of second ID to compare.

  Return Value:
      S_EQUAL    - Items are the same.  This actually should never happen as sameness can
                   and is determined by CXboxFolder::CompareIDs, which is the only caller.
      S_LESS     - pItemId1 comes before pItemId2
      S_GREATER  - pItemId1 comes after  pItemId2
      E_EQUAL    - Comparison failed, however items should be considered equal.  In theory,
                   a random caller may get this, but this case is not expected to be hit.
      E_LESS     - Comparison failed, however, if must succeed pItemId1 should be
                   before pItemId2
      E_GREATER  - Comparison failed, however, if must succeed pItemId2 should be
                   before pItemId1

  Comments:

      This routine turns is not virtual.  It turns the pItemId1, and pItemId2 into indices
      into the list of children.  Then it calls 
      CompareItemIDs(UINT iColumn, int iNameCmp, UINT uChildIndex1, UINT uChildIndex2),
      which does this real class dependent work.

      If either of the children are not found, then error results.  In the case of an error:
       1) If pItemId1 and pItemId2 are both invalid, return FailFromShort(iNameCmp)
       2) If only one them is invalid put the valid one first.

--*/

{
    HRESULT hr, hr2;
    UINT    uChildIndex1;
    UINT    uChildIndex2;
    
    hr=GetChildIndex((LPCSTR)pItemId1->abID, &uChildIndex1);
    hr2=GetChildIndex((LPCSTR)pItemId2->abID, &uChildIndex2);
    
    if(SUCCEEDED(hr))
    {
        if(SUCCEEDED(hr2))
        {
            //
            //  If the indices match they are equal
            //
            if(uChildIndex1 == uChildIndex2)
            {
                return 0;
            }
            return CompareItemIDs(uColumn, iNameCmp, uChildIndex1, uChildIndex2);
        } else
        {
            //
            // pItemId1 is valid and pItemId2 is not.
            //
            return ResultFromCompare(-1, true);
        }
    }
    
    //
    //  If we are here pItemId1 is invalid
    //

    if(SUCCEEDED(hr2))
    {
        //
        // pItemId2 is valid and pItemId1 is not.
        //
        return ResultFromCompare(1, true);
    }

    //
    //  Neither is valid
    //
    return ResultFromCompare(iNameCmp, true);
}

/*
**  Method Description: CompareItemIDs(UINT uColumn, int iNameCmp, UINT uChildIndex1, UINT uChildIndex2)
**
**      Compares two immediate children of a CXboxFolder based on an uColumn.  The Column
**      ID is specific to the class type of the CXboxFolder.
**      
**  Arguments:
**      uColumn      - index of column to sort bt.
**      iNameCmp     - result of case-insenstive comparison on builds carried out by caller.
**      uChildIndex1 - index of first child to compare
**      uChildIndex2 - index of second child to compare
**
**  Implemented By:
**      CXboxRoot           - Its children are CXboxConsole and the "Add New Console Wizard"
**      CXboxConsole        - Its children are CXboxVolume
**      CXboxFileSystemFolder - Its children are CXboxDirOrFile.
**
**  Return Value:
**      S_EQUAL    - Items are the same.  This actually should never happen as sameness can and is
**                   determined by CXboxFolder::CompareIDs, which is the only caller.
**      S_LESS     - pFolderId1 comes before pFolderId2
**      S_GREATER  - pFolderId1 comes after  pFolderId2
**
**      Cannot Fail.
**
**  Comments:
**
**      Identical items are those that have the same case-insensitive name.  If uColumn
**      sorts by a criteria other than name,  a name comparison is used to break ties.
**
**  Sort Order:
**      The interpretation of uColumn is on a class by class basis. See comments on individual
**      implementations below for details.
*/

HRESULT CXboxRoot::CompareItemIDs(UINT uColumn, int iNameCmp, UINT uChildIndex1, UINT uChildIndex2)
/*++
 Routine Description:
  Root implemenation, see overview for CompareItemIDs above.

 Sort Order by uColumn:
    XBOX_CONSOLE_COLUMN_NAME (0):   Sort by the name of the console.
    XBOX_CONSOLE_COLUMN_IPADDR (1): Sort by the IP address of the console.
    
    Regardless of uColumn, the "Add New Console" wizard is always before
    any of the consoles.
  
  Implementation Notes:
  
    index 0 is always the "Add New Console" wizard.

    Two different pidls could refer to the same Xbox, one by name and the other
    by IP address.  After must dicussion it was decided that these will be treated
    as two different boxes for all purposes.  Matching up the boxes requires some
    twisted logic, and may have severe perfromance implications as well.  This will
    effect very few users, and the consequences of not matching them are exceedingly
    benign.
    
--*/    
{
    _ASSERTE(uChildIndex1!=uChildIndex2);   

    //
    // Check for "Add New Console" wizard
    //

    if(0==uChildIndex1)
    {
      return S_LESS;
    } 
            
    if(0==uChildIndex2)
    {
      return S_GREATER;
    }

    //
    //  Compare passed on uColumn
    //
    
    if(uColumn == XBOX_CONSOLE_COLUMN_IPADDR)
    {
      DWORD dwIpAddressChild1 = GetChildIpAddress(uChildIndex1);
      DWORD dwIpAddressChild2 = GetChildIpAddress(uChildIndex2);
      if(dwIpAddressChild1 < dwIpAddressChild2)
      {
        return S_LESS;
      } else if(dwIpAddressChild1 > dwIpAddressChild2)
      {
        return S_GREATER;
      }
    }
    
    return ResultFromCompare(iNameCmp);
}

HRESULT CXboxConsole::CompareItemIDs(UINT uColumn, int iNameCmp, UINT uChildIndex1, UINT uChildIndex2)
/*++
 Routine Description:
  Console implemenation, see overview for CompareItemIDs above.

  Sort Order by uColumn:
    XBOX_VOLUME_COLUMN_NAME (0):          Sort by the name (drive letter) of the volume.
    XBOX_VOLUME_COLUMN_TYPE (1):          Sort by the type of volume (MU versus HD).
    XBOX_VOLUME_COLUMN_FREE_CAPACITY (2): Sort by the free capacity of volume.
    XBOX_VOLUME_COLUMN_TOTAL_CAPACITY(3): Sort by the total capacity of volume.
    
--*/
{
    _ASSERTE(uChildIndex1!=uChildIndex2);   

    //
    //  Compare based on uColumn
    //
    switch (uColumn)
    {
      case XBOX_VOLUME_COLUMN_TYPE:
        if(m_rguChildVolumeType[uChildIndex1] < m_rguChildVolumeType[uChildIndex2])
        {
            return S_LESS;
        }
        if(m_rguChildVolumeType[uChildIndex1] > m_rguChildVolumeType[uChildIndex2])
        {
            return S_GREATER;
        }
        break;
      case XBOX_VOLUME_COLUMN_FREE_CAPACITY:
        if(m_rgullChildFreeSpace[uChildIndex1] < m_rgullChildFreeSpace[uChildIndex2])
        {
            return S_LESS;
        }
        if(m_rgullChildFreeSpace[uChildIndex1] > m_rgullChildFreeSpace[uChildIndex2])
        {
            return S_GREATER;
        }
        break;
      case XBOX_VOLUME_COLUMN_TOTAL_CAPACITY:
        if(m_rgullChildTotalSpace[uChildIndex1] < m_rgullChildTotalSpace[uChildIndex2])
        {
            return S_LESS;
        }
        if(m_rgullChildTotalSpace[uChildIndex1] > m_rgullChildTotalSpace[uChildIndex2])
        {
            return S_GREATER;
        }
        break;
      case XBOX_VOLUME_COLUMN_NAME:
      default:
          break;
    }
    //
    //  If they were equal by other qualities fall back on name.
    //
    return ResultFromCompare(iNameCmp);
}

HRESULT CXboxFileSystemFolder::CompareItemIDs(UINT uColumn, int iNameCmp, UINT uChildIndex1, UINT uChildIndex2)
/*++
 Routine Description:
  Console implemenation, see overview for CompareItemIDs above.

  Sort Order by uColumn:
    XBOX_FILE_COLUMN_NAME      (0): Sort by the name file or directory.
    XBOX_FILE_COLUMN_SIZE      (1): Sort by the size of the file.
    XBOX_FILE_COLUMN_TYPE      (2): Sort by the type of file.
    XBOX_FILE_COLUMN_MODIFIED  (3): Sort by the date modified.
    XBOX_FILE_COLUMN_ATTRIBUTE (4): Sort by the file attributes.
    
    Regardless of uColumn, directories always appear before files.
--*/
{
    _ASSERTE(uChildIndex1!=uChildIndex2);
    BOOL fBothDirectories = FALSE;

    //
    // If one is a Directory and the other is not, the directory
    // comes first.
    //

    if(m_rgChildFileAttributes[uChildIndex1].Attributes&FILE_ATTRIBUTE_DIRECTORY)
    {
      if(m_rgChildFileAttributes[uChildIndex2].Attributes&FILE_ATTRIBUTE_DIRECTORY)
      {
         fBothDirectories = TRUE;
      }
      else {
        return S_LESS;  
      }
    } else
    {
      if(m_rgChildFileAttributes[uChildIndex2].Attributes&FILE_ATTRIBUTE_DIRECTORY)
      {
        return S_GREATER;  
      }
    }

    //
    //  Compare based on uColumn
    //
    switch (uColumn)
    {
      case XBOX_FILE_COLUMN_ATTRIBUTE:
        if(m_rgChildFileAttributes[uChildIndex1].Attributes < m_rgChildFileAttributes[uChildIndex2].Attributes)
        {
            return S_LESS;
        }
        if(m_rgChildFileAttributes[uChildIndex1].Attributes > m_rgChildFileAttributes[uChildIndex2].Attributes)
        {
            return S_GREATER;
        }
        break;
      case XBOX_FILE_COLUMN_MODIFIED:
        if(m_rgChildFileAttributes[uChildIndex1].ChangeTime.dwHighDateTime < 
           m_rgChildFileAttributes[uChildIndex2].ChangeTime.dwHighDateTime)
        {
            return S_LESS;
        }
        if(m_rgChildFileAttributes[uChildIndex1].ChangeTime.dwHighDateTime > 
           m_rgChildFileAttributes[uChildIndex2].ChangeTime.dwHighDateTime)
        {
            return S_GREATER;
        }
        if(m_rgChildFileAttributes[uChildIndex1].ChangeTime.dwLowDateTime  < 
           m_rgChildFileAttributes[uChildIndex2].ChangeTime.dwLowDateTime)
        {
            return S_LESS;
        }
        if(m_rgChildFileAttributes[uChildIndex1].ChangeTime.dwLowDateTime  > 
           m_rgChildFileAttributes[uChildIndex2].ChangeTime.dwLowDateTime)
        {
            return S_GREATER;
        }
        break;

      case XBOX_FILE_COLUMN_SIZE:
        if(!fBothDirectories)
        {
            if(m_rgChildFileAttributes[uChildIndex1].SizeHigh < 
               m_rgChildFileAttributes[uChildIndex2].SizeHigh)
            {
                return S_LESS;
            }
            if(m_rgChildFileAttributes[uChildIndex1].SizeHigh > 
               m_rgChildFileAttributes[uChildIndex2].SizeHigh)
            {
                return S_GREATER;
            }
            if(m_rgChildFileAttributes[uChildIndex1].SizeLow  < 
               m_rgChildFileAttributes[uChildIndex2].SizeLow)
            {
                return S_LESS;
            }
            if(m_rgChildFileAttributes[uChildIndex1].SizeLow  > 
               m_rgChildFileAttributes[uChildIndex2].SizeLow)
            {
                return S_GREATER;
            }
        }
        break;
      case XBOX_FILE_COLUMN_TYPE:
        if(!fBothDirectories)
        {
            int iTypeCmp;
            iTypeCmp = _stricmp(m_rgszChildTypeNames[uChildIndex1], m_rgszChildTypeNames[uChildIndex2]);
            if(iTypeCmp)
            {
                return ResultFromCompare(iTypeCmp);
            }
        }
        break;
      case XBOX_FILE_COLUMN_NAME:
      default:
          break;
    }
    //
    //  If they were equal by other qualities fall back on name.
    //
    return ResultFromCompare(iNameCmp);
}

BOOL CXboxFolder::AreItemsIDsIdentical(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, BOOL *pfSameMachine)
/*++
 Routine Description:
   This routine compares two absolute pidls to determine 1) If they are identical, and 2)
   if they are on the same machine.

   It is static.  It is part of CXboxFolder purely to contain the pidl interpretation encapsulated in this class.
--*/
{
    //Check the first item id, the machine name
    if(_stricmp((char *)pidl1->mkid.abID, (char *)pidl2->mkid.abID))
    {
        *pfSameMachine = FALSE;
        return FALSE;
    }
    *pfSameMachine = TRUE;  //Same machine

    //Check the rest of the item ids.
    do
    {
        //Advance to comparing the next pidl's
        pidl1 = AdvancePtr(pidl1, pidl1->mkid.cb);
        pidl2 = AdvancePtr(pidl2, pidl2->mkid.cb);
        
        // Check loop termination conditions.
        if(0==pidl1->mkid.cb)
        {
            if(0==pidl2->mkid.cb)
            {
                // At the end of pidl1 and pidl2, these are the same.
                return TRUE;
            }
            //At end of pidl1, but not pidl2, these are different.
            return FALSE;
        } else if(0==pidl2->mkid.cb)
        {
            //At end of pidl2, but not pidl1, these are different.
            return FALSE;
        }
        // At the end of neither pidl1 or pidl2, so keep looping.
    } while(0==_stricmp((char *)pidl1->mkid.abID, (char *)pidl2->mkid.abID));

    //We fell out of the loop when a difference was found, these are different.
    return FALSE;
}

UINT CXboxFolder::GetChildCount(BOOL fGuesstimate)
/*++
  Routine Description:
    Gets the count of child items.  If the child list is invalid
    can guess or can force enumeration.
  Arguments:
    fGuesstimate - if true take a guess rather than force enumeration.
  Return Value:
    Child Count, or guess.
--*/
{
    //
    //  If the children are not valid, decide whether or 
    //  not to guess or refresh the children.
    //

    if(!m_fChildrenValid)
    {

        if(fGuesstimate)
        {
            //TODO: Performance tune this value, perhaps by class.
            return 15;
        } else
        {
            RefreshChildren();
        }
    }
    return m_uChildCount;
}

HRESULT CXboxFolder::GetChildIndex(LPCSTR pszChildName, UINT *puIndex)
/*++
  Routine Description:
    Searchs for a child by name and returns an index.

  Arguments:
    pszChildName - [IN]  name of child to search for.
    puIndex      - [OUT] pointer to receive index of child.
  
  Comments:
    1) Does NOT refresh children.  Fails if the
       child list is invalid.
    2) Must be an immediate child.
    3) Must handle trailing '\\' so we don't simply use strcmp
    4) Convert to upper case while comparing.

  Performance Tuning:

    This routine is called a lot.  As often as not, it is called for exactly the same item it was
    called for the previous time.  50% of the other items it is called for the very next item.
    So our search loop always starts on the previously returned index.
    
--*/
{
    //
    // Only search if the child list is valid.
    //

    if(m_fChildrenValid && m_uChildCount)
    {
        UINT uIndex;    

        //
        //  Loop over children, looking for a matching name
        //
        uIndex = m_uLastChildIndex;
        do
        {
            LPCSTR pszSource = m_rgpszChildNames[uIndex];
            LPCSTR pszTarget = pszChildName;
            BOOL   fMatch = TRUE;

            //
            //  check for a match
            //
            while(*pszSource && *pszTarget)
            {
                if(toupper(*pszSource++) != toupper(*pszTarget++))
                {   
                    fMatch = FALSE;
                    break;
                }
            }
            
            //
            //  All the common characters are the
            //  same, check to see if one is longer
            //  than the other.
            //
            if(fMatch)
            {
                //
                // If the sources is at the end, and the
                // target is at the end (including a trailing '\\'
                // then they match.
                //
                if(('\0'==*pszSource) && (('\0'==*pszTarget)||('\\'==*pszTarget)))
                {
                    *puIndex = m_uLastChildIndex = uIndex;
                    return S_OK;
                }
            }
            //Increment uIndex for the next loop
            uIndex = (uIndex+1)%m_uChildCount;
        } while(uIndex != m_uLastChildIndex);  //loop until we get back where we started.
    }

    //
    //  No match, :(
    //

    *puIndex = 0;
    return E_FAIL;
}

LPITEMIDLIST CXboxFolder::GetChildPidl(UINT uIndex, CPidlUtils::PIDLTYPE PidlType)
/*++
 Routine Description:
  Creates a pidl for a child.

 Arguments:
  uIndex   - index of child for which to create pidl.
  PidlType - See CPidlUtils for pidl types.

 Return Value:
  On success, pointer to requested pidl.
  On failure, NULL.

 Comment:
  If CPidlUtils::PidlTypeSimple it is all done here, otherwise GetPidl is invoked.
   
--*/
{
   LPITEMIDLIST pidlReturn = NULL;
   LPITEMIDLIST pidlWalk = NULL;

   //
   //  If the children are not valid, return NULL.
   //

   if(!m_fChildrenValid) return NULL;

   //
   // Calculate the length of the pidl
   //
   UINT uChildItemIdLen = strlen(m_rgpszChildNames[uIndex]) + sizeof(USHORT) + sizeof(char);
   
   //
   // If not simple add our pidl length to that of the
   // child.
   //

   if(PidlType != CPidlUtils::PidlTypeSimple)
   {
       //
       //  Get our pidl, and ask for space at end to tack on
       //  our child.
       //

       pidlReturn = GetPidl(PidlType, uChildItemIdLen);

       //
       //  Go to the end of the pidl.
       //
       if(pidlReturn)
       {
         pidlWalk = AdvancePtr(pidlReturn, GetPidlLen(PidlType)-2);
        _ASSERT(0==pidlWalk->mkid.cb);
       }
   } else
   //
   //   Otherwise, allocate space for a simple pidl
   //
   {
       pidlReturn = 
       pidlWalk = (LPITEMIDLIST)g_pShellMalloc->Alloc(uChildItemIdLen+sizeof(USHORT));
   }

   //
   //  If the allocation worked, we need to add the SHITEMID for our child.
   //

   if(pidlWalk)
   {
       LPSTR pszChildNameTarget = (LPSTR)pidlWalk->mkid.abID;
       LPSTR pszChildNameSource = m_rgpszChildNames[uIndex];
       while(*pszChildNameSource)
       {
          *pszChildNameTarget++ = *pszChildNameSource++;
       }
       *pszChildNameTarget++ = *pszChildNameSource++;
       pidlWalk->mkid.cb = (USHORT)uChildItemIdLen;
       pidlWalk = AdvancePtr(pidlWalk, uChildItemIdLen);
       pidlWalk->mkid.cb = 0;
   }
   _ASSERTE(pidlReturn);
   return pidlReturn;
}

void CXboxFolder::GetSelectShellAttributes(IN OUT ULONG *pulShellAttributes)
{
    _ASSERTE(m_fSelectionClone);
    
    if(m_uChildCount)
    {
        UINT uIndex;
        for(uIndex = 0; uIndex < m_uChildCount; uIndex++)
        {
            *pulShellAttributes &= m_rgulChildShellAttributes[uIndex];
        }
    } else
    {
        *pulShellAttributes &= m_ulShellAttributes;
    }
    return;
}

HRESULT CXboxRoot::RefreshChildren()
/*++
  Routine Description:
    RefreshChildren reads the list of known boxes from registry.

    1) Gets count of items from registry.
    2) Free's existing children.
    3) Allocate new children.
    4) Use CManageConsoles to handle all the registery stuff.

--*/
{
    HRESULT hr;
    UINT    uChildCount;
    char    szConsoleName[MAX_CONSOLE_NAME];
    DWORD   dwConsoleNameSize;
    DWORD   dwConsoleCountSize;
    
    //
    //  If the children are already valid then there is no reason
    //  to do this.
    //
    if(m_fChildrenValid)
    {
        return S_OK;
    }

    CManageConsoles consoleManager;

    //
    //  The extra child is for the Add New Console Wizard.
    //
    uChildCount = consoleManager.GetMaxCount() + 1;
    
    //
    //  Free Children
    //

    FreeChildren();
    _ASSERTE(0==m_uChildCount);

    //
    //  Allocate Children
    //
    hr = ReallocateChildren(uChildCount);
    if(FAILED(hr))
    {
        return hr;
    }
    
    //
    //  Initialize Add New Console Wizard entry
    //

    m_rgpszChildNames[m_uChildCount] = new char[sizeof(ADD_NEW_CONSOLE_PIDL_NAME)];
    if(m_rgpszChildNames[m_uChildCount])
    {
         memcpy(m_rgpszChildNames[m_uChildCount], ADD_NEW_CONSOLE_PIDL_NAME, sizeof(ADD_NEW_CONSOLE_PIDL_NAME));
         m_rgulChildShellAttributes[m_uChildCount] = ADDNEWCONSOLE_SHELL_ATTRIBUTES;
         m_rgpszActualNames[m_uChildCount] = XBOX_USE_USER_PROVIDED_NAME;
         m_uChildCount++;
    }

    //
    //  Enumerate Consoles
    //
    
    dwConsoleNameSize = sizeof(szConsoleName);
    while( (m_uChildCount < uChildCount) && consoleManager.GetNext(szConsoleName, &dwConsoleNameSize))
    {
        //
        //  Allocate space to store the console name
        //
        dwConsoleNameSize+=1;
        m_rgpszChildNames[m_uChildCount] = new char[dwConsoleNameSize];
        
     
        //
        //  If the allocation worked, setup the console.
        //
        if(m_rgpszChildNames[m_uChildCount])
        {
            if(consoleManager.IsDefault(szConsoleName))
            {   
                m_uDefaultConsole = m_uChildCount;
            }
            IXboxConnection *pConnection;
            memcpy(m_rgpszChildNames[m_uChildCount], szConsoleName, dwConsoleNameSize);
            m_rgulChildShellAttributes[m_uChildCount] = CONSOLE_SHELL_ATTRIBUTES;
            m_rgdwChildIPAddresses[m_uChildCount] = 0;
            m_rgpszActualNames[m_uChildCount] = NULL;
            
            /*
            hr = Utils::GetXboxConnection(szConsoleName, &pConnection);
            if(SUCCEEDED(hr))
            {
                m_rgdwChildIPAddresses[m_uChildCount] = 0;
                pConnection->HrResolveXboxName(&m_rgdwChildIPAddresses[m_uChildCount]);
                pConnection->Release();
            }
            */
            m_uChildCount++;
        }

        // For next iteration
        dwConsoleNameSize = sizeof(szConsoleName);
    }

    //
    //  Set the children valid is true here, otherwise the
    //  default Xbox will show up twice.
    m_fChildrenValid = TRUE;
    
    return S_OK;
}

DWORD CXboxRoot::GetChildIpAddress(UINT uChildIndex, BOOL fRetry)
{
    HRESULT hr = S_OK;
    _ASSERTE(uChildIndex <= m_uChildCount);
    
    //
    //  If the IP address is INVALID_HANDLE_VALUE, then we have tried
    //  to get it in the past and failed.  If fRetry, then
    //  we try the wire protocol again to get it, otherwise we
    //  return 0 for the IP address.
    //
    if(0xFFFFFFFF == m_rgdwChildIPAddresses[uChildIndex])
    {
        if(!fRetry) return 0;
        m_rgdwChildIPAddresses[uChildIndex] = 0;
    }

    //
    //  If the IP address is 0, then we have to go over the wire
    //  to get it.
    //
    if(!m_rgdwChildIPAddresses[uChildIndex])
    {
        IXboxConnection *pConnection;
        hr = Utils::GetXboxConnection(m_rgpszChildNames[uChildIndex], &pConnection);
        if(SUCCEEDED(hr))
        {
            hr = pConnection->HrResolveXboxName(&m_rgdwChildIPAddresses[uChildIndex]);
            pConnection->Release();
        }
        //
        //  If we failed getting the interface or resolving the Xbox name to an IP address
        //  then we mark the IP address as INVALID_HANDLE_VALUE, and return 0.
        //
        if(FAILED(hr))
        {
            m_rgdwChildIPAddresses[uChildIndex] = 0xFFFFFFFF;
            return 0;
        }
    }

    //
    //  Return what we have.
    //
    return m_rgdwChildIPAddresses[uChildIndex];
}

LPCSTR CXboxRoot::GetActualName(UINT uChildIndex)
{

    HRESULT hr;
    hr = S_OK;
    _ASSERTE(uChildIndex <= m_uChildCount);

    //
    //  If the actual name is available, just use it.
    //
    if(m_rgpszActualNames[uChildIndex])
    {
        //  If the name is XBOX_USE_USER_PROVIDED_NAME, it means use the
        //  name that is is in the registry, that the user provided.
        if(XBOX_USE_USER_PROVIDED_NAME == m_rgpszActualNames[uChildIndex])
        {
            return m_rgpszChildNames[uChildIndex];
        }
        // Otherwise, it is a pointer and we should return it.
        return m_rgpszActualNames[uChildIndex];
    }

    //
    // If the user provided the name, then just use it.
    //
    if(INADDR_NONE==inet_addr(m_rgpszChildNames[uChildIndex]))
    {
        m_rgpszActualNames[uChildIndex] = XBOX_USE_USER_PROVIDED_NAME;
        return m_rgpszChildNames[uChildIndex];
    }
    

    // If we are here, we need to go over the wire to get the name.
    // Don't try going over the wire, if we failed at our last attempt
    // to find the box, when getting the IP address.
    if(0xFFFFFFFF != m_rgdwChildIPAddresses[uChildIndex])
    {
        IXboxConnection *pConnection;
        hr = Utils::GetXboxConnection(m_rgpszChildNames[uChildIndex], &pConnection);
        if(SUCCEEDED(hr))
        {
            char  szName[60];
            DWORD dwNameLen;
            hr = pConnection->HrGetNameOfXbox(szName, &dwNameLen, FALSE);
            if(SUCCEEDED(hr))
            {
                m_rgpszActualNames[uChildIndex] = new char[++dwNameLen];
                if(m_rgpszActualNames[uChildIndex])
                {
                    memcpy(m_rgpszActualNames[uChildIndex], szName, dwNameLen);
                    return m_rgpszActualNames[uChildIndex];
                }
            }
            pConnection->Release();
        }
    }
    
    //
    // If we are here, then we couldn't get the actual name for some
    // reason, return whatever the user typed.
    //
    return m_rgpszChildNames[uChildIndex];
}

HRESULT CXboxConsole::RefreshChildren()
/*++
  Routine Description:
    RefreshChildren query for all the volumes
    and rebuild the list of children.

    1) Gets count of items from registry.
    2) Free's existing children.
    3) Allocate new children.
    4) populate the children from registry.
    5) get the default console, and if necessary
       add it to the registry.
    
  Comments:
    How many volumes can there be?  E, S, T, U, V, X, plus
    C and Y (internal only) + 8 MU's, + any aliases.
    Figure that we will never see more that 24.  That is small
    enough that we can just allocate them all.
    
--*/
{
    HRESULT         hr;
    char            szVolumeName[4];
    char            szDriveLetters[24];
    char            *pszDriveNames;
    DWORD           dwDriveCount = 24;
    DWORD           dwDriveIndex;
    ULARGE_INTEGER  uliBogus;

    if(m_fChildrenValid)
    {
        return S_OK;
    }
    
    //
    //  Get the list of drives
    //
    hr = m_pConnection->HrGetDriveList(szDriveLetters, &dwDriveCount);
    if(FAILED(hr))
    {
        return hr;
    }

    //
    //  Allocate space for all the names.
    //
    pszDriveNames = new char[2*dwDriveCount];
    if(!pszDriveNames)
    {
        return E_OUTOFMEMORY;
    }

    //
    //  Free Children
    //

    FreeChildren();
    _ASSERTE(0==m_uChildCount);

    //
    //  Allocate Children
    //
    hr = ReallocateChildren(dwDriveCount);
    
    //
    //  Will be needed as we go through the drive letters
    //
    szVolumeName[1]=':';
    szVolumeName[2]='\\';
    szVolumeName[3]='\0';

    //
    //  Loop over all the volumes and collect information.
    //

    for(dwDriveIndex = 0; dwDriveIndex < dwDriveCount; dwDriveIndex++)
    {
        szVolumeName[0] = szDriveLetters[dwDriveIndex];
        m_rgpszChildNames[m_uChildCount] = pszDriveNames;
        *pszDriveNames++ = *szVolumeName;
        *pszDriveNames++ = '\0';
        m_rgulChildShellAttributes[m_uChildCount] = VOLUME_SHELL_ATTRIBUTES;
        m_rguChildVolumeType[m_uChildCount] = CXboxVolume::GetVolumeType(*szVolumeName);
        
        //
        // Go over the wire to get the free space and total space.
        //
        
        m_pConnection->HrGetDiskFreeSpace(
                        szVolumeName,
                        &uliBogus,
                        (PULARGE_INTEGER)&m_rgullChildTotalSpace[m_uChildCount],
                        (PULARGE_INTEGER)&m_rgullChildFreeSpace[m_uChildCount]
                        );
        m_uChildCount++;
    }

    m_fChildrenValid = TRUE;
    return S_OK;
}

UINT CXboxVolume::GetVolumeType(char cDriveLetter)
{
    cDriveLetter = (char)toupper(cDriveLetter);
    if((cDriveLetter >= 'F') && (cDriveLetter<= 'M'))
    {
        return IDS_DRIVETYPE_MEMORY_UNIT;
    }

    switch(cDriveLetter)
    {
        case 'C':
            return IDS_DRIVETYPE_MAIN_ROOT;
        case 'D':
            return IDS_DRIVETYPE_BOOT; 
        case 'E':
            return IDS_DRIVETYPE_DEVELOPMENT; 
        case 'S':
            return IDS_DRIVETYPE_TITLE_ROOT; 
        case 'T':
            return IDS_DRIVETYPE_TITLE_CURRENT; 
        case 'U':
            return IDS_DRIVETYPE_SAVED_CURRENT; 
        case 'V':
            return IDS_DRIVETYPE_SAVED_ROOT;
        case 'X':
            return IDS_DRIVETYPE_SCRATCH;
        case 'Y':
            return IDS_DRIVETYPE_DASH;
    } 
    return IDS_DRIVETYPE_UNKNOWN;
}

HRESULT CXboxFileSystemFolder::RefreshChildren()
/*++
  Routine Description:
    Walks the directory and creates all the children.  All children
    are either directories or files.
--*/
{
    char szWireName[MAX_PATH];
    PDM_WALK_DIR pdmWalkDir;
    DWORD dwFileCount;
    HRESULT hr;

    if(m_fChildrenValid)
    {
        return S_OK;
    }
    
    //
    //  Get the wire name (for our self).
    //
    GetWireName(szWireName, NULL, m_pszPathName);

    //
    //  Get the first child, as well as a count.
    //
    hr = m_pConnection->HrOpenDir(&pdmWalkDir, szWireName, &dwFileCount);
    if(FAILED(hr))
    {
        return hr;
    }   

    //
    //  Free Children
    //

    FreeChildren();
    _ASSERTE(0==m_uChildCount);

    //
    //  Allocate Children
    //
    hr = ReallocateChildren(dwFileCount);
    if(SUCCEEDED(hr))
    {

        //
        //  Now fill in the children.
        //
        while(SUCCEEDED(m_pConnection->HrWalkDir(&pdmWalkDir, NULL, &m_rgChildFileAttributes[m_uChildCount])))
        {   
            //
            // Have the name point at the name in the DM_FILE_ATTRIBUTES
            //

            m_rgpszChildNames[m_uChildCount] = m_rgChildFileAttributes[m_uChildCount].Name;

            //
            //  Figure out the shell attributes and file type
            //  from the attributes.
            //

            if(m_rgChildFileAttributes[m_uChildCount].Attributes&FILE_ATTRIBUTE_DIRECTORY)
            {
              m_rgulChildShellAttributes[m_uChildCount] = DIRECTORY_SHELL_ATTRIBUTES;
              m_rgszChildTypeNames[m_uChildCount] = (LPSTR)WindowUtils::GetPreloadedString(IDS_PRELOAD_FOLDER_TYPE_NAME);
            } else
            {
              m_rgulChildShellAttributes[m_uChildCount] = FILE_SHELL_ATTRIBUTES;
              m_rgszChildTypeNames[m_uChildCount] = GetFileTypeName(&m_rgChildFileAttributes[m_uChildCount]);
            }
            if(m_rgChildFileAttributes[m_uChildCount].Attributes&FILE_ATTRIBUTE_READONLY)
            {
              m_rgulChildShellAttributes[m_uChildCount] |= SFGAO_READONLY;
            }
            if(m_rgChildFileAttributes[m_uChildCount].Attributes&FILE_ATTRIBUTE_HIDDEN)
            {
              m_rgulChildShellAttributes[m_uChildCount] |= (SFGAO_HIDDEN|SFGAO_GHOSTED);
            }
            m_uChildCount++;
        }
    }
    m_fChildrenValid = TRUE;
    return S_OK;
}


HRESULT CXboxRoot::ReallocateChildren(UINT uChildCount)
{
    
    if(uChildCount > m_uAllocatedChildCount)
    {
        LPSTR *rgpszChildNames;
        ULONG *rgulChildShellAttributes;
        DWORD *rgdwChildIPAddresses;
        LPSTR *rgpszActualNames;

        //
        // Allocate new arrays
        //
        rgpszChildNames          = new LPSTR[uChildCount];
        rgulChildShellAttributes = new ULONG[uChildCount];
        rgdwChildIPAddresses     = new DWORD[uChildCount];
        rgpszActualNames         = new LPSTR[uChildCount];

        if( !rgpszChildNames || !rgulChildShellAttributes || !rgdwChildIPAddresses || !rgpszActualNames)
        {
            delete [] rgpszChildNames;
            delete [] rgulChildShellAttributes;
            delete [] rgdwChildIPAddresses;
            delete [] rgpszActualNames;
            return E_OUTOFMEMORY;
        } else
        {
            if(m_uChildCount)
            {
                memcpy(rgpszChildNames,          m_rgpszChildNames,          sizeof(LPSTR)*m_uChildCount);
                memcpy(rgulChildShellAttributes, m_rgulChildShellAttributes, sizeof(ULONG)*m_uChildCount);
                memcpy(rgdwChildIPAddresses,     m_rgdwChildIPAddresses,     sizeof(DWORD)*m_uChildCount);
                memcpy(rgpszActualNames,         m_rgpszActualNames,         sizeof(LPSTR)*m_uChildCount);
            }
            
            delete [] m_rgpszChildNames;
            delete [] m_rgulChildShellAttributes;
            delete [] m_rgdwChildIPAddresses;
            delete [] m_rgpszActualNames;          
            
            m_rgpszChildNames          = rgpszChildNames;
            m_rgulChildShellAttributes = rgulChildShellAttributes;
            m_rgdwChildIPAddresses     = rgdwChildIPAddresses;
            m_rgpszActualNames         = rgpszActualNames;

            m_uAllocatedChildCount = uChildCount;
        }
    }
    return S_OK;
}

HRESULT CXboxConsole::ReallocateChildren(UINT uChildCount)
{

    if(uChildCount > m_uAllocatedChildCount)
    {
        LPSTR     *rgpszChildNames;
        ULONG     *rgulChildShellAttributes;
        ULONGLONG *rgullChildFreeSpace;
        ULONGLONG *rgullChildTotalSpace;
        UINT      *rguChildVolumeType;

        //
        // Allocate new arrays
        //

        rgpszChildNames          = new LPSTR[uChildCount];
        rgulChildShellAttributes = new ULONG[uChildCount];
        rgullChildFreeSpace      = new ULONGLONG[uChildCount];
        rgullChildTotalSpace     = new ULONGLONG[uChildCount];
        rguChildVolumeType       = new UINT[uChildCount];

        if( 
            !rgpszChildNames ||
            !rgulChildShellAttributes ||
            !rgullChildFreeSpace ||
            !rgullChildTotalSpace ||
            !rguChildVolumeType
        )
        {
            delete [] rgpszChildNames;
            delete [] rgulChildShellAttributes;
            delete [] rgullChildFreeSpace;
            delete [] rgullChildTotalSpace;
            delete [] rguChildVolumeType;
            return E_OUTOFMEMORY;

        } else
        {
            if(m_uChildCount)
            {
                memcpy(rgpszChildNames,          m_rgpszChildNames,          sizeof(LPSTR)*m_uChildCount);
                memcpy(rgulChildShellAttributes, m_rgulChildShellAttributes, sizeof(ULONG)*m_uChildCount);
                memcpy(rgullChildFreeSpace,      m_rgullChildFreeSpace,      sizeof(ULONGLONG)*m_uChildCount);
                memcpy(rgullChildTotalSpace,     m_rgullChildTotalSpace,     sizeof(ULONGLONG)*m_uChildCount);
                memcpy(rguChildVolumeType,       m_rguChildVolumeType,       sizeof(UINT)*m_uChildCount);
            }
            
            delete [] m_rgpszChildNames;
            delete [] m_rgulChildShellAttributes;
            delete [] m_rgullChildFreeSpace;
            delete [] m_rgullChildTotalSpace;
            delete [] m_rguChildVolumeType;
            
            m_rgpszChildNames          = rgpszChildNames;
            m_rgulChildShellAttributes = rgulChildShellAttributes;
            m_rgullChildFreeSpace      = rgullChildFreeSpace;
            m_rgullChildTotalSpace     = rgullChildTotalSpace;
            m_rguChildVolumeType       = rguChildVolumeType;

            m_uAllocatedChildCount = uChildCount;
        }
    }
    return S_OK;
}

HRESULT CXboxFileSystemFolder::ReallocateChildren(UINT uChildCount)
{
    
    if(uChildCount > m_uAllocatedChildCount)
    {
        LPSTR              *rgpszChildNames;
        ULONG              *rgulChildShellAttributes;
        DM_FILE_ATTRIBUTES *rgChildFileAttributes;
        LPSTR              *rgszChildTypeNames;

        //
        // Allocate new arrays
        //

        rgpszChildNames            = new LPSTR[uChildCount];
        rgulChildShellAttributes   = new ULONG[uChildCount];
        rgChildFileAttributes      = new DM_FILE_ATTRIBUTES[uChildCount];
        rgszChildTypeNames         = new LPSTR[uChildCount];

        if( 
            !rgpszChildNames ||
            !rgulChildShellAttributes ||
            !rgChildFileAttributes ||
            !rgszChildTypeNames
        )
        {
            delete [] rgpszChildNames;
            delete [] rgulChildShellAttributes;
            delete [] rgChildFileAttributes;
            delete [] rgszChildTypeNames;
            return E_OUTOFMEMORY;

        } else
        {
            if(m_uChildCount)
            {
                memcpy(rgpszChildNames,          m_rgpszChildNames,          sizeof(LPSTR)*m_uChildCount);
                memcpy(rgulChildShellAttributes, m_rgulChildShellAttributes, sizeof(ULONG)*m_uChildCount);

                memcpy(rgChildFileAttributes,    m_rgChildFileAttributes,    sizeof(DM_FILE_ATTRIBUTES)*m_uChildCount);
                memcpy(rgszChildTypeNames,       m_rgszChildTypeNames,       sizeof(LPSTR)*m_uChildCount);
            }
            
            delete [] m_rgpszChildNames;
            delete [] m_rgulChildShellAttributes;
            delete [] m_rgChildFileAttributes;
            delete [] m_rgszChildTypeNames;
            
            m_rgpszChildNames          = rgpszChildNames;
            m_rgulChildShellAttributes = rgulChildShellAttributes;
            m_rgChildFileAttributes    = rgChildFileAttributes;
            m_rgszChildTypeNames       = rgszChildTypeNames;

            m_uAllocatedChildCount = uChildCount;
        }
    }
    return S_OK;
}

void CXboxRoot::FreeChildren()
/*++
  Routine Description:
    Frees the data structues associate with children of the root.
--*/
{
    UINT uIndex;

    for(uIndex = 0; uIndex < m_uChildCount; uIndex++)
    {
        delete m_rgpszChildNames[uIndex];
        
        //XBOX_USE_USER_PROVIDED_NAME - means that the actual name is the same as the name
        //                       thus, it is not really a pointer, not is it NULL, so don't delete!
        if(XBOX_USE_USER_PROVIDED_NAME!=m_rgpszActualNames[uIndex])
            delete [] m_rgpszActualNames[uIndex];
    }

    delete [] m_rgpszChildNames;
    delete [] m_rgulChildShellAttributes;
    delete [] m_rgdwChildIPAddresses;
    delete [] m_rgpszActualNames;
    
    m_rgpszChildNames = NULL;
    m_rgulChildShellAttributes = NULL;
    m_rgdwChildIPAddresses = NULL;
    m_rgpszActualNames = NULL;
    
    m_uAllocatedChildCount = 0;
    m_uChildCount = 0;
    m_uLastChildIndex = 0;
}

void CXboxConsole::FreeChildren()
/*++
  Routine Description:
    Frees the data structues associate with children of a console.
--*/
{
    UINT uIndex;

    delete [] m_rgpszChildNames;
    delete [] m_rgulChildShellAttributes;
    
    delete [] m_rgullChildFreeSpace;
    delete [] m_rgullChildTotalSpace;
    delete [] m_rguChildVolumeType;
  
    m_rgpszChildNames          = NULL;
    m_rgulChildShellAttributes = NULL;
    m_rgullChildFreeSpace      = NULL;
    m_rgullChildTotalSpace     = NULL;
    m_rguChildVolumeType       = NULL;

    m_uAllocatedChildCount = 0;
    m_uChildCount = 0;
    m_uLastChildIndex = 0;
}

void CXboxFileSystemFolder::FreeChildren()
/*++
  Routine Description:
    Frees the data structues associate with children of the root.
--*/
{
    UINT uIndex;

    for(uIndex = 0; uIndex < m_uChildCount; uIndex++)
    {
        if(!(m_rgChildFileAttributes[uIndex].Attributes&FILE_ATTRIBUTE_DIRECTORY))
        {
            delete m_rgszChildTypeNames[uIndex];
        }
    }
    delete [] m_rgpszChildNames;
    delete [] m_rgulChildShellAttributes;
    delete [] m_rgChildFileAttributes;
    delete [] m_rgszChildTypeNames;

    m_rgpszChildNames          = NULL;
    m_rgulChildShellAttributes = NULL;
    m_rgChildFileAttributes    = NULL;
    m_rgszChildTypeNames       = NULL;

    m_uAllocatedChildCount = 0;
    m_uChildCount = 0;
    m_uLastChildIndex = 0;
}



HRESULT CXboxRoot::ValidateItem(LPCSTR pszPathName, UINT uRelativeDepth, DWORD *pdwAttributes)
/*++
  Routine Description:
    Validates a child item over the wire and gets its shell attributes.  It does not rely on
    any cached information and does not look at the child list.  It can also look down multiple
    levels.
  Arguments:
    pszPathName    - path relative to this item (the root)
    uRelativeDepth - number of filesystem elements in the relative path.
    pdwAttributes  - [IN]  desired shell attribute flags
                     [OUT] desired shell attribute flags that apply to item.
  Return Value:
    S_OK if item exists.
    various errors if it does not.
--*/
{
  HRESULT            hr;
  char               szNameBuffer[MAX_PATH];
  LPSTR              pszTarget;
  LPCSTR             pszSource;
  IXboxConnection    *pConnection = NULL;
  DM_FILE_ATTRIBUTES dmFileAttributes;

  //
  //  Is it the "Add New Console Wizard"
  //  TODO: Implement this.
  //


  //
  //  Get a console connection
  //
  pszTarget = szNameBuffer;
  pszSource = pszPathName;
  while(('\0'!=*pszSource) && ('\\'!=*pszSource))
  {
    *pszTarget++ = *pszSource++;
  }
  *pszTarget = '\0';
  hr = Utils::GetXboxConnection(szNameBuffer, &pConnection);
  if(FAILED(hr)) return hr;

  //
  //  If item is a console, we are done.
  //
  if(1==uRelativeDepth)
  {
    
    //
    //  Don't need to the box anymore.
    //

    pConnection->Release();

    //
    //  If we are going to succeed, and the attributes
    //  are requested, then fill out the attributes.
    //
    if(SUCCEEDED(hr) && pdwAttributes)
    {
        *pdwAttributes &= CONSOLE_SHELL_ATTRIBUTES;
    }
    return hr;
  }

  //
  //  Build the wire name, and try to get the file attributes.
  //

  GetWireName(szNameBuffer, NULL, pszPathName);
  hr = pConnection->HrGetFileAttributes(szNameBuffer, &dmFileAttributes);
  pConnection->Release(); //Done with the connection, success or not.
  if(SUCCEEDED(hr))
  {
    DWORD dwAttributes;
    
    //
    //  Is it a volume?
    //
    if(2==uRelativeDepth)
    {
        _ASSERTE(dmFileAttributes.Attributes&FILE_ATTRIBUTE_DIRECTORY);
        dwAttributes = VOLUME_SHELL_ATTRIBUTES;
    } else if(dmFileAttributes.Attributes&FILE_ATTRIBUTE_DIRECTORY)
    //
    //  Or a directory?
    //
    {
        dwAttributes = DIRECTORY_SHELL_ATTRIBUTES;
    } else
    //
    //  Then must be a file.
    //
    {
        dwAttributes = FILE_SHELL_ATTRIBUTES;
    }

    //
    //  OR in SFGAO_READONLY and SFGAO_HIDDEN if applicable.
    //

    if(dmFileAttributes.Attributes&FILE_ATTRIBUTE_READONLY)
    {
        dwAttributes |= SFGAO_READONLY;
    }
    if(dmFileAttributes.Attributes&FILE_ATTRIBUTE_HIDDEN)
    {
        dwAttributes |= (SFGAO_HIDDEN|SFGAO_GHOSTED);
    }

    //
    // Set the out parameter
    //
    *pdwAttributes &= dwAttributes;
  }
  return hr;
}

HRESULT CXboxConsole::ValidateItem(LPCSTR pszPathName, UINT uRelativeDepth, DWORD *pdwAttributes)
/*++
  Routine Description:
    Validates a child item over the wire and gets its shell attributes.  It does not rely on
    any cached information and does not look at the child list.  It can also look down multiple
    levels.
  Arguments:
    pszPathName    - path relative to this item (the root)
    uRelativeDepth - number of filesystem elements in the relative path.
    pdwAttributes  - [IN]  desired shell attribute flags
                     [OUT] desired shell attribute flags that apply to item.
  Return Value:
    S_OK if item exists.
    various errors if it does not.
--*/
{
  HRESULT            hr;
  char               szNameBuffer[MAX_PATH];
  DM_FILE_ATTRIBUTES dmFileAttributes;

  //
  //  Build the wire name, and try to get the file attributes.
  //

  GetWireName(szNameBuffer, m_pszPathName , pszPathName);
  hr = m_pConnection->HrGetFileAttributes(szNameBuffer, &dmFileAttributes);
  if(SUCCEEDED(hr))
  {
    DWORD dwAttributes;
    
    //
    //  Is it a volume?
    //
    if(1==uRelativeDepth)
    {
        _ASSERTE(dmFileAttributes.Attributes&FILE_ATTRIBUTE_DIRECTORY);
        dwAttributes = VOLUME_SHELL_ATTRIBUTES;
    } else if(dmFileAttributes.Attributes&FILE_ATTRIBUTE_DIRECTORY)
    //
    //  Or a directory?
    //
    {
        dwAttributes = DIRECTORY_SHELL_ATTRIBUTES;
    } else
    //
    //  Then must be a file.
    //
    {
        dwAttributes = FILE_SHELL_ATTRIBUTES;
    }

    //
    //  OR in SFGAO_READONLY and SFGAO_HIDDEN if applicable.
    //

    if(dmFileAttributes.Attributes&FILE_ATTRIBUTE_READONLY)
    {
        dwAttributes |= SFGAO_READONLY;
    }
    if(dmFileAttributes.Attributes&FILE_ATTRIBUTE_HIDDEN)
    {
        dwAttributes |= (SFGAO_HIDDEN|SFGAO_GHOSTED);
    }

    //
    // Set the out parameter
    //
    *pdwAttributes &= dwAttributes;
  }
  return hr;
}

HRESULT CXboxFileSystemFolder::ValidateItem(LPCSTR pszPathName, UINT, DWORD *pdwAttributes)
/*++
  Routine Description:
    Validates a child item over the wire and gets its shell attributes.  It does not rely on
    any cached information and does not look at the child list.  It can also look down multiple
    levels.
  Arguments:
    pszPathName    - path relative to this item (the root)
    uRelativeDepth - number of filesystem elements in the relative path.
    pdwAttributes  - [IN]  desired shell attribute flags
                     [OUT] desired shell attribute flags that apply to item.
  Return Value:
    S_OK if item exists.
    various errors if it does not.
--*/
{
  HRESULT            hr;
  char               szNameBuffer[MAX_PATH];
  DM_FILE_ATTRIBUTES dmFileAttributes;

  //
  //  Build the wire name, and try to get the file attributes.
  //

  GetWireName(szNameBuffer, m_pszPathName , pszPathName);
  hr = m_pConnection->HrGetFileAttributes(szNameBuffer, &dmFileAttributes);
  if(SUCCEEDED(hr))
  {
    DWORD dwAttributes;
    
    //
    //  Is it a directory?
    //
    if(dmFileAttributes.Attributes&FILE_ATTRIBUTE_DIRECTORY)
    {
        dwAttributes = DIRECTORY_SHELL_ATTRIBUTES;
    } else
    //
    //  Then must be a file.
    //
    {
        dwAttributes = FILE_SHELL_ATTRIBUTES;
    }

    //
    //  OR in SFGAO_READONLY and SFGAO_HIDDEN if applicable.
    //

    if(dmFileAttributes.Attributes&FILE_ATTRIBUTE_READONLY)
    {
        dwAttributes |= SFGAO_READONLY;
    }
    if(dmFileAttributes.Attributes&FILE_ATTRIBUTE_HIDDEN)
    {
        dwAttributes |= (SFGAO_HIDDEN|SFGAO_GHOSTED);
    }

    //
    // Set the out parameter
    //
    *pdwAttributes &= dwAttributes;
  }
  return hr;
}

HRESULT CXboxFileSystemFolder::ReceiveFile(LPSTR pszRelativeRemoteFile, LPSTR szLocalFile)
/*++
  Routine Description:
    Receives a file over the wire and stores it in szLocalFile.  This is designed only
    to be used with selection clone.
  Arguments:
    pszRelativeRemoteFile - the filename to get relative to the parent folder of the
                            selection.  Unless the parent is the selection.
    szLocalFile           - full path of the file to copy to on the local system.
--*/
{
    char szWireName[MAX_PATH];
    _ASSERT(m_fSelectionClone && m_fChildrenValid);
    //
    //  If this has children, then the path is relative to our main path
    //
    if(m_uChildCount)
    {
        GetWireName(szWireName, m_pszPathName, pszRelativeRemoteFile);
    } else
    //
    //  Otherwise, the first part of the relative path is just our name
    //  we should skip it.
    //
    {
        UINT uNameLen = strlen(m_pszName);
        _ASSERT(0==_strnicmp(pszRelativeRemoteFile, m_pszName, uNameLen));
        pszRelativeRemoteFile += uNameLen;
        _ASSERT('\\'==*pszRelativeRemoteFile);
        GetWireName(szWireName, m_pszPathName, ++pszRelativeRemoteFile);
    }
    return m_pConnection->HrReceiveFile(szLocalFile, szWireName);
}

void CXboxFolder::GetTargetWireName(LPSTR pszWireName, LPSTR pszRelativeRemoteFile)
/*++
  Routine Description:
    A helper for all of the file transfer methods where the CXboxFolder is the target.
    It gets the filename of a target file relative to the selection.

    There are three cases:
      1) This object is not a selection clone.  The filename is always relative to the folder.
      2) This object is a selection clone with no children.  Same as 1).
      3) This object is a selection clone with exactly one child.  The filename is relative to
         that only child.

    It is illegal to call this on a selection clone with more than one child, the method ASSERTs.
    
--*/
{
    BOOL fFirstChild = FALSE;
    if(m_fSelectionClone)
    {
        _ASSERT(m_fChildrenValid);
        _ASSERT(m_uChildCount < 2);
        if(1==m_uChildCount)
        {
            fFirstChild=TRUE;
        }
    }

    if(fFirstChild)
    {
        GetWireName(pszWireName, m_pszPathName, m_rgpszChildNames[0]);
        if(pszRelativeRemoteFile)
        {
            UINT uWirePos = strlen(pszWireName) - 1;
            if(pszWireName[uWirePos++]!='\\') pszWireName[uWirePos++] = '\\';
            strcpy(pszWireName+uWirePos, pszRelativeRemoteFile);
        }
    } else
    {
        if(pszRelativeRemoteFile)
        {
            GetWireName(pszWireName, m_pszPathName, pszRelativeRemoteFile);
        } else
        {
            GetWireName(pszWireName, NULL, m_pszPathName);
        }
    }
}

BOOL CXboxFolder::IsXbeFile(LPCSTR pszFileName)
{
    LPCSTR pszExtension = strrchr(pszFileName, '.');
    return pszExtension ? !_stricmp( ++pszExtension, "XBE") : FALSE;
}

LPITEMIDLIST CXboxFolder::GetTargetPidl(LPSTR pszRelativeRemoteFile)
/*++
  Routine Description:
    This pidls a target pidl relative to a selection.  This is called
    for drop and paste operation.  Generally, the target is a selection.
    Depending on how the operation progressed, the selection is either
    this object,  or one (and only one) of its children.  So this selection
    object will have a single child.

    This routine glues the pidl of this object, and its child (if necessary)
    to the pszRelativeRemoteFile (if non-NULL), and generate a full
    absolute pidl.
--*/
{
    BOOL fFirstChild = FALSE;
    UINT uFirstChildLen = 0;
    //If this is a selection clone (generally it will be), we need to make some checks.
    if(m_fSelectionClone)
    {
        //It better be a valid clone with a single child in the selection.
        _ASSERT(m_fChildrenValid);
        _ASSERT(m_uChildCount < 2);
        //If there is a child, the first child must be included in the pidl
        if(1==m_uChildCount)
        {
            fFirstChild=TRUE;
        }
    }

    // For starters, we don't need any extra bytes at the end our pidl
    UINT uExtraAllocation = 0;
    
    // Add in space for the first child if we need it.
    if(fFirstChild)
    {
        uFirstChildLen = strlen(m_rgpszChildNames[0])+1;
        uExtraAllocation = sizeof(USHORT)+uFirstChildLen;
    }
    
    // Compute the pidl size for the relative part.
    LPSTR pszWalk = pszRelativeRemoteFile;
    //For each path element, add a USHORT for the cb of the ItemID.
    while(pszWalk)
    {
        uExtraAllocation += sizeof(USHORT);
        pszWalk = strchr(pszWalk, '\\');
        if(pszWalk) pszWalk++;
    }

    //Add in the lenght of the actual path.  Basically, each '\\' will be replaced
    //by a '\0'.  We already accounted for the cb portions.  Add one for the final
    //'\0' which strlen leaves out.
    if(pszRelativeRemoteFile)
        uExtraAllocation += strlen(pszRelativeRemoteFile)+1;

    // Get our pidl, and ask for the extra allocation at the end that we need.
    LPITEMIDLIST pidlReturn = GetPidl(CPidlUtils::PidlTypeAbsolute, uExtraAllocation);
    if(pidlReturn)
    {
        LPSTR pszPidlWalk;
        LPITEMIDLIST pidlWalk;
        UINT uSimpleNameLength;

        // Walk to the end of our pidl.
        pidlWalk = pidlReturn;
        while(pidlWalk->mkid.cb)
        {
            pidlWalk = AdvancePtr(pidlWalk, pidlWalk->mkid.cb);
        }

        // If we need to include the first child, do it here.
        if(fFirstChild)
        {
            pidlWalk->mkid.cb=uFirstChildLen+sizeof(USHORT);
            memcpy(pidlWalk->mkid.abID, m_rgpszChildNames[0], uFirstChildLen);
            pidlWalk = AdvancePtr(pidlWalk, pidlWalk->mkid.cb);
            pidlWalk->mkid.cb = 0;
        }

        // Now add the relative portion, if there is one.
        if(pszRelativeRemoteFile)
        {
            pszWalk = pszRelativeRemoteFile;
            pszPidlWalk = (LPSTR)pidlWalk->mkid.abID;
            uSimpleNameLength = 0;
            while(*pszWalk)
            {
                uSimpleNameLength++;
                if(*pszWalk != '\\')
                {
                    *pszPidlWalk++ = *pszWalk;
                } else
                {
                    *pszPidlWalk = '\0';
                    pidlWalk->mkid.cb = uSimpleNameLength+sizeof(USHORT);
                    pidlWalk = AdvancePtr(pidlWalk, pidlWalk->mkid.cb);
                    uSimpleNameLength = 0;
                    pszPidlWalk = (LPSTR)pidlWalk->mkid.abID;
                }
                pszWalk++;
            }
            *pszPidlWalk = '\0';
            pidlWalk->mkid.cb = uSimpleNameLength+sizeof(UCHAR)+sizeof(USHORT);
            pidlWalk = AdvancePtr(pidlWalk, pidlWalk->mkid.cb);
            pidlWalk->mkid.cb = 0;
        }
    }
    return pidlReturn;
}

LPITEMIDLIST CXboxFolder::GetSourcePidl(LPCSTR pszFolder, LPCSTR pszItem)
{
    UINT uAllocLength = m_uRootPidlLen;
    UINT uLoop;
    
    LPCSTR pszWalk = pszFolder; 
    for(uLoop=0;uLoop<2;uLoop++)
    {
        while(pszWalk)
        {
            uAllocLength += sizeof(USHORT);
            pszWalk = strchr(pszWalk, '\\');
            if(pszWalk) pszWalk++;
        }
        
        pszWalk = pszItem;
    }
    uAllocLength += strlen(pszFolder)+strlen(pszItem)+2;

    LPITEMIDLIST pidlOut = (LPITEMIDLIST) g_pShellMalloc->Alloc(uAllocLength);
    LPITEMIDLIST pidlWalk;
    LPSTR        pszPidlWalk;
    UINT         uSimpleNameLength;
    if(pidlOut)
    {
        pidlWalk = pidlOut;
        memcpy(pidlWalk, m_pidlRoot, m_uRootPidlLen);
        //Go to the end of the root
        while(pidlWalk->mkid.cb)
        {
            pidlWalk = AdvancePtr(pidlWalk, pidlWalk->mkid.cb);
        }

        pszWalk = pszFolder;
        for(uLoop=0;uLoop<2;uLoop++)
        {
            pszPidlWalk = (LPSTR)pidlWalk->mkid.abID;
            uSimpleNameLength = 0;
            while(*pszWalk)
            {
                uSimpleNameLength++;
                if(*pszWalk != '\\')
                {
                    *pszPidlWalk++ = *pszWalk;
                } else
                {
                    *pszPidlWalk = '\0';
                    pidlWalk->mkid.cb = uSimpleNameLength+sizeof(USHORT);
                    pidlWalk = AdvancePtr(pidlWalk, pidlWalk->mkid.cb);
                    uSimpleNameLength = 0;
                    pszPidlWalk = (LPSTR)pidlWalk->mkid.abID;
                }
                pszWalk++;
            }
            *pszPidlWalk = '\0';
            pidlWalk->mkid.cb = uSimpleNameLength+sizeof(UCHAR)+sizeof(USHORT);
            pidlWalk = AdvancePtr(pidlWalk, pidlWalk->mkid.cb);
            pszWalk = pszItem;
        }
        pidlWalk->mkid.cb = 0;
    }
    return pidlOut;
}

void CXboxFolder::GetConsoleName(LPSTR pszConsole)
{
    LPSTR pszParse = m_pszPathName;
    while(*pszParse!='\\' && *pszParse)
    {
        *pszConsole++ = *pszParse++;
    }
    *pszConsole = '\0';
}


UINT CXboxFolder::PathFromPidl(LPCITEMIDLIST pidl, LPSTR pszPathName)
/*++
 Routine Description:
   A utility that parse an Xbox pidl and turns it into a path name.
   It returns the depth of the path.
   
--*/
{
    LPSTR pszName = pszPathName;
    LPCITEMIDLIST pidlWalk = pidl;
    UINT uPathLength; //With NULL termination
    UINT uDepth = 0;

    while(pidlWalk->mkid.cb)
    {
        uDepth++;

        //
        // Safely copy the name
        //
        uPathLength = pidlWalk->mkid.cb-sizeof(USHORT);
        
        //If first character is '?' skip it.
        if('?'==pidl->mkid.abID[0])
        {
            uPathLength--;
            memcpy(pszName, pidlWalk->mkid.abID+1, uPathLength--);
        } else
        {
            memcpy(pszName, pidlWalk->mkid.abID, uPathLength--);
        }
        _ASSERT('\0'==pszName[uPathLength]);
        pszName += uPathLength;

        //
        //  Replace '\0' with a '\\' character
        //
        *pszName++ = '\\';

        //
        //  Move on to next item in pidl
        //
        pidlWalk = AdvancePtr(pidlWalk, pidlWalk->mkid.cb);
    }

    //
    //  Cut the '\\' off the end.  If the depth is zero there
    //  is no '\\' so don't do it.
    //
    if(uDepth) pszName--;
    
    //
    //  NULL terminate the string.
    //
    *pszName =  '\0';

    return uDepth;
}

LPITEMIDLIST
CXboxFolder::PidlFromPath(
    LPCWSTR pwszPathName,
    UINT *puPathLength,
    UINT *puPathDepth,
    BOOL *pfLeadingSlash,
    BOOL *pfTrailingSlash
    )
/*++
 Routine Description:
   Allocates and creates a pidl from a path.  Also computes display
   name length, and path.
   
--*/
{
    LPCWSTR      pwszParse = pwszPathName;
    UINT         uPathLength = 0;
    UINT         uRelativeDepth = 1;
    UINT         uPidlLength;
    LPITEMIDLIST pidl;
    LPITEMIDLIST pidlParse;
    UINT         uItemLength;    
    
    
    _ASSERTE(pfLeadingSlash);
    _ASSERTE(pfTrailingSlash);


    //
    //  Determine if it has a leading slash
    //

    if(L'\\' == *pwszParse)
    {
        uPathLength++;
        pwszParse++;
        *pfLeadingSlash = TRUE;
    } else
    {
        *pfLeadingSlash = FALSE;
    }

    //
    //  First Pass: Determine the length and depth
    //
    
    *pfTrailingSlash = FALSE;
    while(*pwszParse)
    {
        if(L'\\' == *pwszParse)
        {
            uPathLength++;
            pwszParse++;
            if(L'\0'==*pwszParse)
            {
                *pfTrailingSlash = TRUE;
                break;
            }
            uRelativeDepth++;
        }
        uPathLength++;
        pwszParse++;
    }

    //
    //  Restore the parse pointer
    //

    pwszParse = pwszPathName;

    //
    //  Calculate the pidl length = USHORT for each level, length of string.
    //  Then added a character if the path did not have trailing slash.
    //  Finally subtract one if there was a leading slash.
    //

    uPidlLength = ((uRelativeDepth+1)*sizeof(USHORT))+uPathLength;
    if(!*pfTrailingSlash) uPidlLength++;
    if(*pfLeadingSlash)
    {
        uPidlLength--;
        pwszParse++;  //while we are at it, skip the leading slash
    }

    //
    //  Allocate the pidl
    //

    pidl = (LPITEMIDLIST)g_pShellMalloc->Alloc(uPidlLength);
    
    //
    //  Create pidl if we managed to allocate it.
    //

    if(pidl)
    {
        
        //
        //  Second Pass: Copy the names from the path to the pidl
        //
        pidlParse = pidl;
        uItemLength = 0;
        while(*pwszParse)
        {
            if(L'\\' == *pwszParse)
            {
                pwszParse++;
                pidlParse->mkid.abID[uItemLength++] = '\0';
                pidlParse->mkid.cb = (uItemLength + sizeof(USHORT));
                pidlParse = AdvancePtr(pidlParse, pidlParse->mkid.cb);
                uItemLength = 0;
            } else
            {
                pidlParse->mkid.abID[uItemLength++] = (UCHAR)(*pwszParse++);
            }
        }

        //
        //  If there was not a trailing '\\', terminate the last item.
        //
        if(!*pfTrailingSlash)
        {
            pidlParse->mkid.abID[uItemLength++] = '\0';
            pidlParse->mkid.cb = (uItemLength + sizeof(USHORT));
            pidlParse = AdvancePtr(pidlParse, pidlParse->mkid.cb);
        }

        //
        //  Terminate the pidl
        //
        pidlParse->mkid.cb = 0;
    }
    
    //
    //  Fill out the OUT paramteres
    //
    if(puPathLength)
    {
        *puPathLength = uPathLength;
    }
    if(puPathDepth)
    {
        *puPathDepth = uRelativeDepth;
    }

    return pidl;
}

void CXboxFolder::GetWireName(LPSTR pszWireName, LPCSTR pszInitialPath, LPCSTR pszFinalPath)
/*++
  Routine Description:
    Gets the wire name from a full path.

  Arguments:
    pszWireName    - [OUT] buffer to receive wire name.
    pszInitialPath - [IN] initial part of full path.
    pszFinalPath   - [IN] final part of full path.

  Comments:
    Most clients of this method have two portions of the path.  The path from Xbox
    root (starting with the console name) to themselves, and the relative path
    from themselves to some child item (perhaps multiple levels down).  As a convenience,
    this routine accepts the path as two pieces.

    Some clients do not have the path in two pieces.  These should pass NULL for pszInitialPath,
    and pass the entire path in pszFilePath.

--*/
{
    LPCSTR pszNextElement;
    BOOL   fFinalPart;
    _ASSERTE(pszFinalPath);
    
    //
    //  Initialize pszNextElement
    //

    if(pszInitialPath)
    {
        pszNextElement = pszInitialPath;
        fFinalPart = FALSE;
    } else
    {
        pszNextElement = pszFinalPath;
        fFinalPart = TRUE;
    }

    //
    //  The first item is always the console.
    //  we just want to skip that.
    //

    pszNextElement = strchr(pszNextElement, '\\');
    if(!pszNextElement || ('\0' == *(++pszNextElement)))
    {
        _ASSERTE(!fFinalPart);  //Malformed path
        pszNextElement = pszFinalPath;
        fFinalPart = TRUE;   
    }
    
    //
    //  Now process the volume. Always one character.
    //
    *pszWireName++ = *pszNextElement++;
    *pszWireName++ = ':';
    *pszWireName++ = '\\';

    //
    //  If the next character is '\\' then skip it.
    //
    if('\\' == *pszNextElement)
    {
        pszNextElement++;
    }

    //
    //  Handle the case where the paths are split at the volume.
    //
    if('\0' == *pszNextElement)
    {
        if(fFinalPart)
        {
            *pszWireName = '\0';
            return;
        }
        pszNextElement = pszFinalPath;
        fFinalPart = TRUE; 
    }
    
    //
    //  Loop until a break;
    //
    while(TRUE)
    {
        //
        //  Copy a path element.
        //
        while(('\\' != *pszNextElement) && ('\0' != *pszNextElement))
        {
            *pszWireName++ = *pszNextElement++;
        }

        //
        //  Skip '\\' if we see one.
        //

        if('\\' == *pszNextElement)
        {
            pszNextElement++;
        }

        //
        //  Check if we have hit the end of the
        //  current string.

        if('\0' == *pszNextElement)
        {
            //
            //  If this was the final part, we
            //  are done.
            //

            if(fFinalPart) break;

            //
            //  Otherwise, move to the final part.
            //
            pszNextElement = pszFinalPath;
            fFinalPart = TRUE; 
        }

        //
        //  Looks like there is another path element so
        //  add a '\\' as a path delimitor
        //
        *pszWireName++ = '\\';
    }

    *pszWireName = '\0';
    //
    //  All Done :)
    //

    return;
}

LPSTR CXboxFileSystemFolder::GetFileTypeName(PDM_FILE_ATTRIBUTES pdmFileAttributes)
{

    SHFILEINFOA shellFileInfo;
    LPSTR       pszTypeName = NULL;
    
    if( SHGetFileInfoA(
          pdmFileAttributes->Name,
          pdmFileAttributes->Attributes,
          &shellFileInfo,
          sizeof(shellFileInfo),
          SHGFI_USEFILEATTRIBUTES | SHGFI_TYPENAME 
          )
    ){
      UINT uTypeNameSize = strlen(shellFileInfo.szTypeName)+1;
      pszTypeName = new char[uTypeNameSize];
      if(pszTypeName)
      {
        memcpy(pszTypeName, shellFileInfo.szTypeName, uTypeNameSize);
      }
    }

    return pszTypeName;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbshlext\wizold.cpp ===
###
### THIS FILE IS FOR ARCHIVAL PURPOSES
### CAddConsoleData Has been changed extensively, and I just wanted to preserve the code
### somewhere.  The major cause of the change is that this version of the Add New Console
### wizard allowed adding more than one Xbox at a time, the new wizard does not allow this.
###

/*++

Copyright (c) Microsoft Corporation

Module Name:

    wizard.cpp

Abstract:

    Implementation of the add new console
    wizard

Environment:

    Windows 2000 and Later 
    User Mode

Revision History:
    
    08-07-2001 : created (mitchd)

--*/

#include <stdafx.h>

HRESULT CWizard::Initialize(UINT uMaxPages)
{
    m_hrInitialize = E_OUTOFMEMORY;
    m_uMaxPages = uMaxPages;
    m_uPageCount = 0;
    m_pPages = new WizardPageInfo[m_uMaxPages];
    if(m_pPages)
    {
        m_pPropSheetPages = new PROPSHEETPAGEA[m_uMaxPages];
        if(m_pPropSheetPages)
        {
            m_hrInitialize = S_OK;
        
            //  Create the title font
            NONCLIENTMETRICS ncm = {0};
	        ncm.cbSize = sizeof(ncm);
	        SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);
	        LOGFONT TitleLogFont = ncm.lfMessageFont;
	        TitleLogFont.lfWeight = FW_BOLD;
	        lstrcpy(TitleLogFont.lfFaceName, TEXT("Verdana Bold"));
	        HDC hdc = GetDC(NULL);
	        INT FontSize = 12;
	        TitleLogFont.lfHeight = 0 - GetDeviceCaps(hdc, LOGPIXELSY) * FontSize / 72;
	        m_hTitleFont = CreateFontIndirect(&TitleLogFont);
	        ReleaseDC(NULL, hdc);
        } else
        {
            delete [] m_pPages;
            m_pPages = NULL;
        }
    }
    return m_hrInitialize;
}

HRESULT CWizard::DoWizard(HWND hwndParent)
{
    PROPSHEETHEADERA propSheetHeader;
    propSheetHeader.dwSize = sizeof(PROPSHEETHEADERA);
    propSheetHeader.dwFlags = PSH_WIZARD97 | PSH_WATERMARK | PSH_HEADER | PSH_PROPSHEETPAGE ;
    propSheetHeader.hwndParent = GetDesktopWindow();
    propSheetHeader.hInstance = _Module.GetModuleInstance();
    propSheetHeader.hIcon = NULL;
    propSheetHeader.pszCaption = NULL;
    propSheetHeader.nPages = m_uPageCount;
    propSheetHeader.nStartPage = 0;
    propSheetHeader.ppsp = m_pPropSheetPages;
    propSheetHeader.pfnCallback  = NULL;
    propSheetHeader.pszbmWatermark = MAKEINTRESOURCEA(IDB_WATERMARK);
    propSheetHeader.pszbmHeader = MAKEINTRESOURCEA(IDB_HEADER);

    _ASSERTE(m_uPageCount > 0);
    long lError = PropertySheetA(&propSheetHeader);
    if(-1==lError)
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }
    return S_OK;
}

void CWizard::AddPage(CWizardPage *pPage)
{
    UINT uPageIndex;
    _ASSERTE(m_uPageCount < m_uMaxPages);
    
    //
    //  Add a pointer to the page to our array of property pages.
    //
    uPageIndex = m_uPageCount++;
    m_pPages[uPageIndex].pWizardPage = pPage;

    //
    //  Get the page to fillout its PROPSHEETPAGEA structure.
    //
    pPage->FilloutPropSheetPage(m_pPropSheetPages+uPageIndex, m_hTitleFont);
}


INT_PTR CALLBACK CWizardPage::DialogProc(HWND hWndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CWizardPage *pThis;

    //
    //  WM_INITDIALOG is special.
    //
    if(WM_INITDIALOG==uMsg)
    {
        PROPSHEETPAGEA *pPropSheetPage = (PROPSHEETPAGEA *)lParam;
        pThis = (CWizardPage *)pPropSheetPage->lParam;
        SetWindowLong(hWndDlg,DWL_USER,(LONG)pThis);
        pThis->m_hPageDlg = hWndDlg;
        return pThis->OnInitDialog((HWND)wParam);
    }

    pThis = (CWizardPage *)GetWindowLong(hWndDlg, DWL_USER);
    if(pThis)
    {
        switch(uMsg)
        {
          
          case WM_NOTIFY:
          {
            LPNMHDR lpnm = (LPNMHDR) lParam;
            switch (lpnm->code)
            {
                case PSN_SETACTIVE: //Enable the Next button
                    return pThis->OnSetActive();
                case PSN_WIZBACK:
                    return pThis->OnWizBack();
                case PSN_WIZNEXT:
                    return pThis->OnWizNext();
                case PSN_WIZFINISH:
                    return pThis->OnWizFinish();
                default:
                    {
                    INT_PTR iRet = pThis->OnNotify(lpnm);
                    if(iRet)return iRet;
                    }break;
            }
          }
          case WM_COMMAND:
            return pThis->OnCommand(wParam, lParam);
          default:        
            return pThis->OnMessage(uMsg, wParam, lParam);
        }
    }
    return 0;
}

INT_PTR CWizardPage::OnInitDialog(HWND hwndDefaultControl)
{
    // If the page has an item of IDC_XB_TITLE it should be
    // in the title font.
    HWND hwndTitle = GetDlgItem(m_hPageDlg, IDC_XB_TITLE);
    if(hwndTitle)
    {
        SendMessage(hwndTitle, WM_SETFONT, (WPARAM)m_hTitleFont, 0);
    }
    return 0;
}

void CWizardPage::FilloutPropSheetPage(PROPSHEETPAGEA *pPropSheetPage, HFONT hTitleFont)
{
    m_hTitleFont = hTitleFont;
    pPropSheetPage->dwSize = sizeof(PROPSHEETPAGE);
    pPropSheetPage->dwFlags = PSP_DEFAULT;
    pPropSheetPage->hInstance = _Module.GetModuleInstance();
    pPropSheetPage->pfnDlgProc = DialogProc;
    pPropSheetPage->pfnCallback = NULL;
    pPropSheetPage->lParam = (LPARAM)this;
    CompletePropSheetPage(pPropSheetPage);
}

void CAddConsoleWelcome::CompletePropSheetPage(PROPSHEETPAGEA *pPropSheetPage)
{
	pPropSheetPage->dwFlags |= PSP_HIDEHEADER;
	pPropSheetPage->pszTemplate = MAKEINTRESOURCEA(IDD_ADDCONSOLE_WELCOME);
}

INT_PTR CAddConsoleWelcome::OnSetActive()
{
    PropSheet_SetWizButtons(GetParent(m_hPageDlg), PSWIZB_NEXT);
    return 0;
}

#ifdef NEVER
void CAddConsoleHow::CompletePropSheetPage(PROPSHEETPAGEA *pPropSheetPage)
{
    pPropSheetPage->dwFlags |= PSP_USEHEADERTITLE|PSP_USEHEADERSUBTITLE;
    pPropSheetPage->pszTemplate = MAKEINTRESOURCEA(IDD_ADDCONSOLE_HOW);
	pPropSheetPage->pszHeaderTitle =    MAKEINTRESOURCEA(IDS_ADDCONSOLE_HOW_TITLE);
	pPropSheetPage->pszHeaderSubTitle = MAKEINTRESOURCEA(IDS_ADDCONSOLE_HOW_SUBTITLE);
}

INT_PTR CAddConsoleHow::OnSetActive()
{
    HWND hwndCtrl = GetDlgItem(m_hPageDlg, m_pAddConsoleData->m_fChoose ? IDC_ADDCONSOLE_CHOOSE : IDC_ADDCONSOLE_BYNAME);
    if(hwndCtrl)
    {
        SendMessage(hwndCtrl, BM_SETCHECK, BST_UNCHECKED, 0);
    }
    PropSheet_SetWizButtons(GetParent(m_hPageDlg), PSWIZB_BACK|PSWIZB_NEXT);
    return 0;
}

INT_PTR CAddConsoleHow::OnWizNext()
{
    SetWindowLong(m_hPageDlg, DWL_MSGRESULT, /*m_pAddConsoleData->m_fChoose ? IDD_ADDCONSOLE_CHOOSE : */IDD_ADDCONSOLE_BYNAME);
    return TRUE;
}

INT_PTR CAddConsoleHow::OnCommand(WPARAM wParam, LPARAM lParam)
{
    UINT uControlId = LOWORD(wParam);
    UINT uCommand = HIWORD(wParam);
    
    //
    //  Flip m_pAddConsoleData->fChoose when the
    //  radio buttons are clicked.
    //
    if( uCommand == BN_CLICKED) 
    { 
        if(uControlId==IDC_ADDCONSOLE_CHOOSE)
        {
            m_pAddConsoleData->m_fChoose = TRUE;
            return TRUE;
        }
        if(uControlId==IDC_ADDCONSOLE_BYNAME)
        {
           m_pAddConsoleData->m_fChoose = FALSE;
           return TRUE;
        }
    }
    return FALSE;
}

INT_PTR CAddConsoleChoose::OnInitDialog(HWND)
{
    // Set up the columns of the list view.
    HWND hwndCtrl = GetDlgItem(m_hPageDlg, IDC_ADDCONSOLE_LIST);
    if(hwndCtrl)
    {
        m_pAddConsoleData->InitListView(hwndCtrl, true);
        return TRUE; 
    }
    return FALSE;
}
void CAddConsoleChoose::CompletePropSheetPage(PROPSHEETPAGEA *pPropSheetPage)
{
    pPropSheetPage->dwFlags |= PSP_USEHEADERTITLE|PSP_USEHEADERSUBTITLE;
    pPropSheetPage->pszTemplate = MAKEINTRESOURCEA(IDD_ADDCONSOLE_CHOOSE);
	pPropSheetPage->pszHeaderTitle =    MAKEINTRESOURCEA(IDS_ADDCONSOLE_CHOOSE_TITLE);
	pPropSheetPage->pszHeaderSubTitle = MAKEINTRESOURCEA(IDS_ADDCONSOLE_CHOOSE_SUBTITLE);
}

INT_PTR CAddConsoleChoose::OnSetActive()
{
    HWND hwndCtrl = GetDlgItem(m_hPageDlg, IDC_ADDCONSOLE_LIST);
    if(hwndCtrl)
    {
        m_pAddConsoleData->RefreshListView(hwndCtrl);
        PropSheet_SetWizButtons(
            GetParent(m_hPageDlg),
            m_pAddConsoleData->GetSelectCount() ? PSWIZB_BACK|PSWIZB_NEXT : PSWIZB_BACK
            );
    }
    return 0;
}

INT_PTR CAddConsoleChoose::OnWizNext()
{
    SetWindowLong(m_hPageDlg, DWL_MSGRESULT, IDD_ADDCONSOLE_FINISH);
    return TRUE;   
}

INT_PTR CAddConsoleChoose::OnWizBack()
{
    SetWindowLong(m_hPageDlg, DWL_MSGRESULT, IDD_ADDCONSOLE_HOW);
    return TRUE;   
}

INT_PTR CAddConsoleChoose::OnNotify(LPNMHDR pnmhdr)
{
    INT_PTR iRet = 0;
    if(IDC_ADDCONSOLE_LIST==pnmhdr->idFrom)
    {
        
        iRet = m_pAddConsoleData->OnNotify(pnmhdr);
        PropSheet_SetWizButtons(
            GetParent(m_hPageDlg),
            m_pAddConsoleData->GetSelectCount() ? PSWIZB_BACK|PSWIZB_NEXT : PSWIZB_BACK
            );
    }
    return iRet;
}
#endif NEVER

INT_PTR CAddConsoleByName::OnInitDialog(HWND)
{
    // Set up the columns of the list view.
    HWND hwndCtrl = GetDlgItem(m_hPageDlg, IDC_ADDCONSOLE_LIST);
    if(hwndCtrl)
    {   
       m_pAddConsoleData->InitListView(hwndCtrl);
       return TRUE; 
    }
    return FALSE;
}

void CAddConsoleByName::CompletePropSheetPage(PROPSHEETPAGEA *pPropSheetPage)
{
    pPropSheetPage->dwFlags |= PSP_USEHEADERTITLE|PSP_USEHEADERSUBTITLE;
    pPropSheetPage->pszTemplate = MAKEINTRESOURCEA(IDD_ADDCONSOLE_BYNAME);
	pPropSheetPage->pszHeaderTitle =    MAKEINTRESOURCEA(IDS_ADDCONSOLE_BYNAME_TITLE);
	pPropSheetPage->pszHeaderSubTitle = MAKEINTRESOURCEA(IDS_ADDCONSOLE_BYNAME_SUBTITLE);
}

INT_PTR CAddConsoleByName::OnSetActive()
{
   
    HWND hwndCtrl = GetDlgItem(m_hPageDlg, IDC_ADDCONSOLE_LIST);
    if(hwndCtrl)
    {
        m_pAddConsoleData->RefreshListView(hwndCtrl);
        PropSheet_SetWizButtons(
            GetParent(m_hPageDlg),
            m_pAddConsoleData->GetSelectCount() ? PSWIZB_BACK|PSWIZB_NEXT : PSWIZB_BACK
            );
    }
    return 0;
}

INT_PTR CAddConsoleByName::OnWizNext()
{
    SetWindowLong(m_hPageDlg, DWL_MSGRESULT, IDD_ADDCONSOLE_FINISH);
    return TRUE;
}

INT_PTR CAddConsoleByName::OnWizBack()
{
    SetWindowLong(m_hPageDlg, DWL_MSGRESULT, IDD_ADDCONSOLE_WELCOME);
    return TRUE;   
}

INT_PTR CAddConsoleByName::OnNotify(LPNMHDR pnmhdr)
{
    INT_PTR iRet = 0;
    if(IDC_ADDCONSOLE_LIST==pnmhdr->idFrom)
    {
        
        iRet = m_pAddConsoleData->OnNotify(pnmhdr);
        PropSheet_SetWizButtons(
            GetParent(m_hPageDlg),
            m_pAddConsoleData->GetSelectCount() ? PSWIZB_BACK|PSWIZB_NEXT : PSWIZB_BACK
            );
    }
    return iRet;
}

INT_PTR CAddConsoleByName::OnCommand(WPARAM wParam, LPARAM lParam)
{
    UINT uControlId = LOWORD(wParam);
    UINT uCommand = HIWORD(wParam);
    
    //
    //  If Flip the m_fRecursive as buttons are pressed.
    //  
    //
    if(uCommand == BN_CLICKED) 
    {
        if(uControlId == IDC_ADDCONSOLE_ADD)
        {
            HWND hEditWnd = GetDlgItem(this->m_hPageDlg, IDC_ADDCONSOLE_NAME);
            if(hEditWnd)
            {
                char szConsoleName[MAX_PATH]; 
                GetWindowTextA(hEditWnd, szConsoleName, sizeof(szConsoleName));
                HWND hListView = GetDlgItem(m_hPageDlg, IDC_ADDCONSOLE_LIST);
                if(hListView)
                {
                    m_pAddConsoleData->AddConsole(hListView, szConsoleName);
                }
            }
            return TRUE;
        }
    }
    return FALSE;
}

void CAddConsoleFinish::CompletePropSheetPage(PROPSHEETPAGEA *pPropSheetPage)
{
    pPropSheetPage->dwFlags |= PSP_HIDEHEADER;
	pPropSheetPage->pszTemplate = MAKEINTRESOURCEA(IDD_ADDCONSOLE_FINISH);
}

INT_PTR CAddConsoleFinish::OnSetActive()
{
    PropSheet_SetWizButtons(GetParent(m_hPageDlg), PSWIZB_BACK|PSWIZB_FINISH);
    HWND hCtrl = GetDlgItem(m_hPageDlg, IDC_ADDCONSOLE_LIST);
    if(hCtrl)
    {
        char szList[1024];
        m_pAddConsoleData->GetSelectedItemsString(szList, sizeof(szList));
        SetWindowTextA(hCtrl, szList);
    }
    return 0;
}

INT_PTR CAddConsoleFinish::OnWizBack()
{
    SetWindowLong(m_hPageDlg, DWL_MSGRESULT, m_pAddConsoleData->m_fChoose ? IDD_ADDCONSOLE_CHOOSE : IDD_ADDCONSOLE_BYNAME);
    return TRUE;
}

INT_PTR CAddConsoleFinish::OnWizFinish()
{
    m_pAddConsoleData->OnFinish();
    return 0;
}

void CAddConsoleData::InitListView(HWND hListView, bool fChoose)
{
    TCHAR tszText[256];     // temporary buffer 
    LVCOLUMN lvc;
        
    lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    lvc.fmt = LVCFMT_LEFT;
    lvc.pszText =  tszText;
        
    lvc.cx = 175;
    lvc.iSubItem = 0;
    LoadString(_Module.GetModuleInstance(), IDS_COLUMN_HEADER_NAME, tszText, ARRAYSIZE(tszText));
    ListView_InsertColumn(hListView, 0, &lvc);
        
    lvc.cx = 100;
    lvc.iSubItem = 1;
    LoadString(_Module.GetModuleInstance(), IDS_COLUMN_HEADER_IPADDR, tszText, ARRAYSIZE(tszText));
    ListView_InsertColumn(hListView, 1, &lvc);
    
    if(fChoose)
    {
        ListView_SetExtendedListViewStyle(hListView, LVS_EX_CHECKBOXES);
    }

}

void CAddConsoleData::RefreshListView(HWND hListView)
{
    
    // First Delete everything.
    ListView_DeleteAllItems(hListView);
    CONSOLE_INFO *pConsole = m_pConsoles;
    int iItem = 0;
    
    
    while(pConsole)
    {
        if(m_fChoose || pConsole->fSelected)
        {
            AddItemToListView(hListView, iItem, pConsole);
            iItem++;
        }
        pConsole = pConsole->pNext;
    }
};

void CAddConsoleData::AddConsole(HWND hListView, LPSTR pszConsoleName)
{
    _ASSERTE(!m_fChoose);
    HRESULT hr;
    CONSOLE_INFO *pNewConsole;

    // Don't add it if we already have it.
    pNewConsole = m_pConsoles;
    while(pNewConsole)
    {
        if(0==_stricmp(pszConsoleName, pNewConsole->pszName))
        {
            return;
        }
        pNewConsole = pNewConsole->pNext;
    }
    
    pNewConsole = new CONSOLE_INFO;
    if(pNewConsole)
    {
        memset(pNewConsole, 0, sizeof(CONSOLE_INFO));
        IXboxConnection *pConnection;
        hr = DmGetXboxConnection(pszConsoleName, XBCONN_VERSION, &pConnection);
        if(SUCCEEDED(hr))
        {
            hr = pConnection->HrResolveXboxName(&pNewConsole->dwIpAddress);
            pConnection->Release();
        }
        if(FAILED(hr))
        {
            MessageBoxA(GetParent(hListView), "Could not find specified Xbox", "BUGBUG - Finish Dialog", MB_OK|MB_ICONERROR);
            delete pNewConsole;
            return;
        }
        UINT uNameLen = strlen(pszConsoleName)+1;
        pNewConsole->pszName = new char[uNameLen];
        if(pNewConsole)
        {
            memcpy(pNewConsole->pszName, pszConsoleName, uNameLen);
            pNewConsole->fSelected = TRUE;
            m_iConsolesSelected++;
            pNewConsole->fLocalSubnet = FALSE;
        
            // Insert into tail of list
            pNewConsole->pNext = NULL;
            if(m_pConsoles)
            {
                pNewConsole->pPrevious = m_pConsolesTail;
                m_pConsolesTail->pNext = pNewConsole;
                m_pConsolesTail = pNewConsole;
            } else
            {
                pNewConsole->pPrevious = NULL;
                m_pConsolesTail = m_pConsoles = pNewConsole;
            }
            //  Insert into List View
            AddItemToListView(hListView, m_iConsoleCount++, pNewConsole);
        } else
        {
            delete pNewConsole;
        }
    }
}


INT_PTR CAddConsoleData::OnNotify(LPNMHDR pnmhdr)
{
    CONSOLE_INFO *pConsole;
    if(pnmhdr->code == LVN_GETDISPINFOA)
    {
        LVITEMA *pItem;
        pItem = &((NMLVDISPINFOA *)pnmhdr)->item;
        pConsole = (CONSOLE_INFO *)pItem->lParam;
        switch(pItem->iSubItem)
        {
          case 0:
           wsprintfA(pItem->pszText, "%hs", pConsole->pszName);
           break;
          case 1:
           wsprintfA(pItem->pszText,
             "%d.%d.%d.%d", 
             (pConsole->dwIpAddress >> 24)&0xFF,
             (pConsole->dwIpAddress >> 16)&0xFF,
             (pConsole->dwIpAddress >> 8)&0xFF,
             pConsole->dwIpAddress&0xFF
              );
           break;
          default:
            break;
         }
        return TRUE;
    } else if(pnmhdr->code == LVN_ITEMCHANGED)
    {
        NMLISTVIEW *pListView = (NMLISTVIEW *)pnmhdr;
        pConsole = (CONSOLE_INFO *)pListView->lParam;
        BOOL fSelected = (pListView->uNewState>>12)-1;
        if(fSelected != pConsole->fSelected)
        {
            pConsole->fSelected = fSelected;
            if(fSelected)
            {
                m_iConsolesSelected++;
            } else 
            {
                m_iConsolesSelected--;
            }
        }
        return TRUE;
    }
    return FALSE;
}

void CAddConsoleData::AddItemToListView(HWND hListView, int index, CONSOLE_INFO *pConsole)
{
    LVITEM lvi;
    lvi.mask = LVIF_DI_SETITEM|LVIF_PARAM|LVIF_TEXT;
    lvi.pszText = LPSTR_TEXTCALLBACK;
    lvi.cchTextMax = MAX_PATH;
    lvi.iItem = index;
    lvi.iSubItem = 0;
    lvi.lParam = (LPARAM)pConsole;
    
    //Arrgghh - When you insert an item into a list view it is
    //          never checked (according to the docs, even if
    //          we were to set LVIF_STATE! and lvi.iState).
    //          The list view sends a notification to that
    //          effect, which this class processes and then clears
    //          pConsole->fSelected all before ListView_InsertItem
    //          returns.  So the work around is to cache fSelected
    //          here before ListView_InsertItem and then to immediately
    //          restore the state with ListView_SetCheck.
    BOOL fSelected = pConsole->fSelected;
    ListView_InsertItem(hListView, &lvi);
    ListView_SetCheckState(hListView, index, fSelected);
};

void CAddConsoleData::GetSelectedItemsString(LPSTR pszBuffer, UINT ccBuffer)
{
    CONSOLE_INFO *pConsole;
    BOOL fShortened=FALSE;
    pConsole = m_pConsoles;
    ccBuffer -= sizeof(",...");  //subtract room for temination.
    while(pConsole && ccBuffer)
    {
        if(pConsole->fSelected)
        {
            UINT uNameLen = strlen(pConsole->pszName);
            if(uNameLen > ccBuffer)
            {
                break;
                fShortened = TRUE;
            }
            memcpy(pszBuffer, pConsole->pszName, uNameLen);
            pszBuffer += uNameLen;
            *pszBuffer++ = ',';
            *pszBuffer++ = ' ';
            ccBuffer -= uNameLen;
            if(ccBuffer < 2) break;
            ccBuffer--;
        }
        pConsole = pConsole->pNext;
    }
    pszBuffer -= 2;
    if(fShortened) strcpy(pszBuffer, ",...");
    *pszBuffer++ = '\0';
}

void CAddConsoleData::OnFinish()
{
    HKEY hConsoleKey;
    //
    //  Open\Create the console key
    //
    CManageConsoles consoleManager;

    CONSOLE_INFO *pConsole;
    pConsole = m_pConsoles;
    while(pConsole)
    {
        if(pConsole->fSelected)
        {
            consoleManager.Add(pConsole->pszName);
        }
        pConsole = pConsole->pNext;
    }
    SHChangeNotify(SHCNE_UPDATEDIR, SHCNF_PATH|SHCNF_FLUSH, ROOT_GUID_NAME_WIDE, NULL);
}

extern void ExecuteAddConsoleWizard()
{
    HRESULT hr;
    CAddConsoleData addConsoleData;
    CWizard wizard;
    
    hr = wizard.Initialize(5);
    if(SUCCEEDED(hr))
    {
        CAddConsoleWelcome welcome;
#ifdef NEVER
        CAddConsoleHow     how(&addConsoleData);
        CAddConsoleChoose  choose(&addConsoleData);
#endif
        CAddConsoleByName  byname(&addConsoleData);
        CAddConsoleFinish  finish(&addConsoleData);

        wizard.AddPage(&welcome);
#ifdef NEVER
        wizard.AddPage(&how);
        wizard.AddPage(&choose);
#endif 
        wizard.AddPage(&byname);
        wizard.AddPage(&finish);
    }
    wizard.DoWizard(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbshlext\xbfolder.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    xbfolder.h

Abstract:

    CXboxFolder implements IShellFolder, IPersistFolder, IBrowserFrameOptions.
    
      
    Beyond implementing these public interfaces, it is the base class for all the "folder" types
    in the Xbox Shell Namespace Extension:  These include: CXboxRoot, CXboxConsole,
    CXboxVolume, and CXboxDirectory.  CXboxVolume and CXboxDirectory have much in common and rely
    on a common intermediate class, CXBoxFileSystemFolder.

    A virtual depcition of the Xbox Namespace might look like this:   

    CXboxRoot
        |___CXboxConsole1___CXboxConsoleN
             |
             |_CXboxVolume(E)_____CXboxVolume(T)__...
               |
               |__CXboxDirectory__CXboxDirectory...
                    |
                    |_CXboxDirectory...
                        |
                        ...
                
    This does not include non-folder items.   Non-folder items are tracked by their container folder.

Selection Clones:
    
    A CXboxFolder is referenced counted like any COM object.  However, it is not always desirable to
    pass around pointers to the same object.  Two cases arises in the shell extension:

    1) IShellFolder::GetUIObjectOf is called to get DataObjects and MenuContexts among other things.
       These objects need a snap shot of a group of selected items.   They do not need to know about
       the other "un-selected" children, nor do they need to necessarily track dynamic changes.  (If
       one of the selected items is deleted out from under it, an appropriate error is generated when
       an operation is attempted.  The shell does the same thing.)

    2) Some operations (display of property pages, copying files, or deleting files) are best performed
       asynchronously in a different thread.  By the far the easiest way to manage thread conflicts is
       to pass a clone (and coincidently this also involves a selection) to the thread.

    Thus CXboxFolder has the concept of selection clone.   A selection clone is created via:
    CXboxFolder::CloneSelection.  It is reference counted like other COM objects

Environment:

    Windows 2000 and Later 
    User Mode

Revision History:
    
    02-05-2001 : created (xtree.h)
    06-27-2001 : change caching scheme (xbitem.cpp)

--*/

//-------------------------------------------------------------------------------
// Constants
//-------------------------------------------------------------------------------
const int  MAX_CONSOLE_NAME = 40;
const int  MAX_XBOX_PATH = MAX_PATH+MAX_CONSOLE_NAME;
const char ROOT_GUID_NAME[] = "::{DB15FEDD-96B8-4DA9-97E0-7E5CCA05CC44}";
const WCHAR ROOT_GUID_NAME_WIDE[] = L"::{DB15FEDD-96B8-4DA9-97E0-7E5CCA05CC44}";
const char XBOX_SHELL_EXTENSION_KEY[] = "Software\\Microsoft\\XboxSDK\\xbshlext";
const char XBOX_SHELL_EXTENSION_CONSOLE_KEY[] = "Software\\Microsoft\\XboxSDK\\xbshlext\\Consoles";
const char ADD_NEW_CONSOLE_PIDL_NAME[] = "?Add Xbox";

//---------------------------------------------------------------------------------
// Basic shell attributes for these various item types
//---------------------------------------------------------------------------------
#define ROOT_SHELL_ATTRIBUTES\
        (SFGAO_CANLINK|SFGAO_CANRENAME|SFGAO_FOLDER|SFGAO_HASSUBFOLDER|\
         SFGAO_BROWSABLE)
        
#define CONSOLE_SHELL_ATTRIBUTES\
        (SFGAO_CANLINK|SFGAO_CANDELETE|SFGAO_HASPROPSHEET|SFGAO_FOLDER|SFGAO_HASSUBFOLDER|\
         SFGAO_BROWSABLE)

#define VOLUME_SHELL_ATTRIBUTES\
        (SFGAO_CANLINK|SFGAO_HASPROPSHEET|SFGAO_DROPTARGET|SFGAO_FOLDER|\
         SFGAO_HASSUBFOLDER)

#define DIRECTORY_SHELL_ATTRIBUTES\
        (SFGAO_CANCOPY|SFGAO_CANMOVE|SFGAO_CANLINK|SFGAO_CANRENAME|\
         SFGAO_CANDELETE|SFGAO_HASPROPSHEET|SFGAO_DROPTARGET|SFGAO_FOLDER|\
         SFGAO_HASSUBFOLDER)
  
#define FILE_SHELL_ATTRIBUTES\
        (SFGAO_CANCOPY|SFGAO_CANMOVE|SFGAO_CANRENAME|\
         SFGAO_CANDELETE|SFGAO_HASPROPSHEET)

#define ADDNEWCONSOLE_SHELL_ATTRIBUTES\
        (SFGAO_CANLINK)

//-----------------------------------------------------------------
//  VERB IDs.  These correspond to the verbs in the context menu
//  NOTE: IF YOU CHANGE THESE DEFINITIONS, YOU MUST CHANGE THE MENU
//        TABLE IN MENU.CPP
//-----------------------------------------------------
#define VERB_LAUNCH            0
#define VERB_OPEN              1
#define VERB_EXPLORE           2
#define VERB_REBOOT_WARM       3
#define VERB_REBOOT_SAME_TITLE 4
#define VERB_REBOOT_COLD       5
#define VERB_CAPTURE           6
#define VERB_SECURITY          7
#define VERB_SETDEFAULT        8
#define VERB_CUT               9
#define VERB_COPY             10
#define VERB_PASTE            11
#define VERB_DELETE           12
#define VERB_RENAME           13
#define VERB_NEWFOLDER        14
#define VERB_NEWCONSOLE       15
#define VERB_PROPERTIES       16

#define VERB_REBOOT_BITS    (I2BIT(VERB_REBOOT_WARM)|I2BIT(VERB_REBOOT_SAME_TITLE)|I2BIT(VERB_REBOOT_COLD))


#define ROOT_VERBS       (I2BIT(VERB_OPEN)|I2BIT(VERB_EXPLORE)|I2BIT(VERB_RENAME)|I2BIT(VERB_NEWCONSOLE))
#define CONSOLE_VERBS    (I2BIT(VERB_OPEN)|I2BIT(VERB_EXPLORE)|VERB_REBOOT_BITS|I2BIT(VERB_CAPTURE)|I2BIT(VERB_SETDEFAULT)|I2BIT(VERB_SECURITY)|I2BIT(VERB_DELETE)|I2BIT(VERB_PROPERTIES))
#define VOLUME_VERBS     (I2BIT(VERB_OPEN)|I2BIT(VERB_EXPLORE)|I2BIT(VERB_PASTE)|I2BIT(VERB_NEWFOLDER)|I2BIT(VERB_PROPERTIES))
#define DIRECTORY_VERBS  (I2BIT(VERB_OPEN)|I2BIT(VERB_EXPLORE)|I2BIT(VERB_CUT)|I2BIT(VERB_COPY)|\
                          I2BIT(VERB_PASTE)|I2BIT(VERB_DELETE)|I2BIT(VERB_RENAME)|I2BIT(VERB_NEWFOLDER)|I2BIT(VERB_PROPERTIES))
#define FILE_VERBS       (I2BIT(VERB_CUT)|I2BIT(VERB_COPY)|I2BIT(VERB_DELETE)|I2BIT(VERB_RENAME)|I2BIT(VERB_PROPERTIES))
#define ADDCONSOLE_VERBS (I2BIT(VERB_OPEN))
#define XBE_VERBS        (I2BIT(VERB_LAUNCH)|FILE_VERBS)

//---------------------------------------------------------------------------------
//  Names of columns associated with their index
//---------------------------------------------------------------------------------
#define XBOX_CONSOLE_COLUMN_NAME          0
#define XBOX_CONSOLE_COLUMN_IPADDR        1
#define XBOX_VOLUME_COLUMN_NAME           0
#define XBOX_VOLUME_COLUMN_TYPE           1
#define XBOX_VOLUME_COLUMN_FREE_CAPACITY  2
#define XBOX_VOLUME_COLUMN_TOTAL_CAPACITY 3
#define XBOX_FILE_COLUMN_NAME             0
#define XBOX_FILE_COLUMN_SIZE             1
#define XBOX_FILE_COLUMN_TYPE             2
#define XBOX_FILE_COLUMN_MODIFIED         3
#define XBOX_FILE_COLUMN_ATTRIBUTE        4

//---------------------------------------------------------------------------------
// Return Values For CompareIDs
//---------------------------------------------------------------------------------
#define S_EQUAL     0x00000000
#define S_GREATER   0x00000001
#define S_LESS      0x0000FFFF
#define E_EQUAL     0x80000000
#define E_GREATER   0x80000001
#define E_LESS      0x8000FFFF
inline HRESULT ResultFromCompare(int iCompare, bool fFail = false)
{
   HRESULT hr;
   hr = (((iCompare) > 0) ? S_GREATER : (((iCompare) < 0) ? S_LESS : S_EQUAL));
   if(fFail)
   {
        hr |= 0x80000000;
   }
   return hr;
}

//-------------------------------------------------------------------------------
//  Forward Declare All The CXboxFolder Classes.
//-------------------------------------------------------------------------------
class CXboxFolder;
class CXboxRoot;            
class CXboxConsole;         
class CXboxFileSystemFolder;
class CXboxVolume;
class CXboxDirectory;

//-------------------------------------------------------------------------------
//  Forward Declaration of visitor classes needed by CXboxFolder (as pointers)
//-------------------------------------------------------------------------------
class IXboxConsoleVisit;
class IXboxVolumeVisit;
class IXboxDirectoryVisit;
class IXboxFileVisit;
class IXboxVisitor;

//-------------------------------------------------------------------------------
//  Declaration of CXboxFolder
//-------------------------------------------------------------------------------
class ATL_NO_VTABLE CXboxFolder : 
	public CComObjectRootEx<CComMultiThreadModel>,
    public IShellFolder,
    public IPersistFolder
    CTRACKABLEOBJECT
{

 public:

  /*
  ** ATL COM INTERFACE MAP
  */
  DECLARE_PROTECT_FINAL_CONSTRUCT()
  BEGIN_COM_MAP(CXboxFolder)
    COM_INTERFACE_ENTRY_IID(IID_IPersistFolder, IPersistFolder)
    COM_INTERFACE_ENTRY_IID(IID_IShellFolder, IShellFolder)
  END_COM_MAP()
 
  /*
  ** ATL let's us customize registration of our object,
  ** if we just declare an UpdateRegistry method.
  */
  static HRESULT WINAPI UpdateRegistry(BOOL bRegister);

 public:

  /*
  ** IShellFolder Methods
  */
  STDMETHOD(BindToObject)(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv);
  STDMETHOD(BindToStorage)(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv);
  STDMETHOD(CompareIDs)(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
  STDMETHOD(CreateViewObject)(HWND hwnd, REFIID riid, void **ppv);
  STDMETHOD(EnumObjects)(HWND hwnd, DWORD grfFlags, IEnumIDList **ppenumIDList);
  STDMETHOD(GetAttributesOf)(UINT cidl, LPCITEMIDLIST * apidl, ULONG * drgfInOut);
  STDMETHOD(GetDisplayNameOf)(LPCITEMIDLIST pidl, DWORD uFlags, STRRET *psr);
  STDMETHOD(GetUIObjectOf)(HWND hwnd, UINT cidl, LPCITEMIDLIST * apidl, REFIID riid, UINT * prgfInOut, void **ppv);
  STDMETHOD(ParseDisplayName)(HWND hwnd, LPBC pbc, LPOLESTR pszDisplayName, ULONG *pchEaten, LPITEMIDLIST *ppidl, ULONG *pdwAttributes);
  STDMETHOD(SetNameOf)(HWND hwnd, LPCITEMIDLIST pidl, LPCOLESTR pszName, DWORD uFlags, LPITEMIDLIST *ppidl);
  
  /*
  ** IPersistFolder Methods
  */

  STDMETHOD(GetClassID)(LPCLSID lpClassID);   //IPersist really
  STDMETHOD(Initialize)(LPCITEMIDLIST pidl);

  /*
  ** Construction
  */
  HRESULT CXboxFolder::CloneSelection(UINT cidl, LPCITEMIDLIST *apidl, CXboxFolder **ppSelectionClone);
  HRESULT Clone(CXboxFolder **ppSelectionClone);

  /*
  ** Get Name and Attribute of Self
  */

  inline LPCSTR GetNamePtr() {return m_pszPathName;}
  inline LPCSTR GetPathNamePtr() {return m_pszName;}
  inline void   GetName(OUT LPSTR pszName) {strcpy(pszName, m_pszName);}
  inline void   GetPath(OUT LPSTR pszPath) {strcpy(pszPath, m_pszPathName);}
  inline void   GetName(OUT LPWSTR pwszName) {Utils::CopyAtoW(pwszName, m_pszName);}
  inline void   GetPath(OUT LPWSTR pwszPath) {Utils::CopyAtoW(pwszPath, m_pszPathName);}
  inline UINT   GetPathLen() {return m_uPathLen;}
  inline ULONG  GetShellAttributes() {return m_ulShellAttributes;}
  
  /*
  ** Item Identifiers
  */
  UINT          GetPidlLen(CPidlUtils::PIDLTYPE PidlType);
  LPITEMIDLIST  GetPidl(CPidlUtils::PIDLTYPE PidlType, UINT uExtraAllocation=0);

  /*
  ** Get Name and Attribute of Children
  */
  inline  void InvalidateChildList() {m_fChildrenValid=FALSE;}
  void    GetSelectShellAttributes(IN OUT ULONG *pulShellAttributes);
  inline  DWORD GetVerbsForSelection() {return m_fSelectionClone ? m_dwSelectionVerbs : 0;}
  UINT    GetChildCount(BOOL fGuesstimate = FALSE);
  
  /*
  ** Column Details
  */
  virtual HRESULT GetColumnHeaderDetails(IN UINT iColumn, OUT SHELLDETAILS *pShellDetails){return E_NOTIMPL;}
  virtual HRESULT GetDetails(IN LPCITEMIDLIST pidl, UINT iColumn, OUT SHELLDETAILS *pShellDetails){return E_NOTIMPL;}
  virtual HRESULT SetStatusBarText(IShellBrowser *pShellBrowser, LPCITEMIDLIST pidlSelect){}
  
  /*
  ** Visitors
  */
  void VisitEach(IXboxVisitor *pVisitor, DWORD dwFlags);
  void VisitThese(UINT cidl, LPCITEMIDLIST *apidl, IXboxVisitor *pVisitor, DWORD dwFlags);
    
  /*
  ** Utility
  */
  static UINT PathFromPidl(LPCITEMIDLIST pidl, LPSTR pszPathName);
  static LPITEMIDLIST PidlFromPath(LPCWSTR pwszPathName, UINT *puPathLength, UINT *puPathDepth,
                                   BOOL *pfLeadingSlash, BOOL *pfTrailingSlash);
  
  static void GetWireName(LPSTR pszWireName, LPCSTR pszInitialPath, LPCSTR pszFinalPath);
  static BOOL IsXbeFile(LPCSTR pszFileName);
  static  BOOL AreItemsIDsIdentical(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, BOOL *pfSameMachine);

  /*
  ** File Transfer
  */
  virtual HRESULT ReceiveFile(LPSTR pszRelativeRemoteFile, LPSTR szLocalFile){return E_FAIL;}
  virtual LPITEMIDLIST GetSourcePidl(LPCSTR pszFolder, LPCSTR pszItem);

  virtual void GetConsoleName(LPSTR pszConsole);
  virtual void GetTargetWireName(LPSTR pszWireName, LPSTR pszRelativeRemoteFile);
  virtual LPITEMIDLIST GetTargetPidl(LPSTR pszRelativeRemoteFile);
  virtual IXboxConnection *GetXboxConnection(){return NULL;}

 protected:

  /*
  ** Construction, Destruction and Cloning
  */
  CXboxFolder();
  virtual void Destroy();

  HRESULT 
  InitBaseClass(
    LPCSTR          pszPathName,
    ULONG           ulShellAttributes,
    LPCITEMIDLIST   pidlRoot
    );

  HRESULT DuplicateBaseMembers(CXboxFolder *pClone);
  virtual HRESULT CloneSelection(UINT uIndexCount, const UINT *puIndexList, CXboxFolder **ppSelectionClone){return E_NOTIMPL;}
  
  /*
  ** Children
  */
  HRESULT GetChildIndex(LPCSTR pszChildName, UINT *puIndex);
  HRESULT BuildSelectionIndexList(UINT cidl, LPCITEMIDLIST *apidl, UINT **ppuIndexList);
  LPITEMIDLIST GetChildPidl(UINT uIndex, CPidlUtils::PIDLTYPE PidlType);
  virtual HRESULT RefreshChildren(){return E_NOTIMPL;}
  virtual HRESULT ReallocateChildren(UINT uChildCount){return E_NOTIMPL;}
  virtual void FreeChildren(){}
  virtual HRESULT ValidateItem(LPCSTR pszPathName, UINT uRelativeDepth, DWORD *pdwAttributes){return E_NOTIMPL;}
  virtual void Visit(UINT uIndexCount, const UINT *puIndexList, IXboxVisitor *pVisitor, DWORD dwFlags){}

  /*
  ** Item Identifiers
  */

  HRESULT CompareItemIDs(UINT iColumn, int iNameCmp, const SHITEMID *pItem1, const SHITEMID *pItem2);
  virtual HRESULT CompareItemIDs(UINT iColumn, int iNameCmp, UINT uChildIndex1, UINT uChildIndex2){return E_NOTIMPL;}


  /*
  ** Variables pertaining to self
  */

  LPSTR         m_pszPathName;       // Pointer to full path
  LPSTR         m_pszName;           // Pointer to item name
  ULONG         m_ulShellAttributes; // The shell's SFGAO_XXXX flags.
  UINT          m_uPathDepth;        // How many ancestor's up to root, e.g. root is 0.
  UINT          m_uPathLen;          // Stored Length of the full path
  LPITEMIDLIST  m_pidlRoot;          // Pidl of our root (e.g. desktop to Xbox root)
  UINT          m_uRootPidlLen;      // Length of our pidl root.

  /*
  ** Variables pertaining to children
  */
  BOOL  m_fSelectionClone;           // If TRUE indicates that this instance is a clone of a selection.
  BOOL  m_fChildrenValid;            // Clear on creation, cleared by 
  UINT  m_uAllocatedChildCount;      // Length of Arrays of children
  UINT  m_uChildCount;               // Number of children
  LPSTR *m_rgpszChildNames;          // Array of name strings for each child
  ULONG *m_rgulChildShellAttributes; // Array of SFGAO_XXXX flags for each child
  ULONG m_dwSelectionVerbs;          // Verbs that apply to the current selection, only set if m_fSelectionClone.
  UINT  m_uLastChildIndex;           // Used for optimizing GetChildIndex.  See GetChildIndex implementation
                                     // for details.

 
 protected:
  ~CXboxFolder(){}              //force destroy 
 private:
  
  /*
  ** Stuff we outlaw, good C++ to prevent abuse.
  */
  
  CXboxFolder(CXboxFolder&);            //no implicit copying
  CXboxFolder& operator=(CXboxFolder&); //no assigning

  friend class CFolderVisit;
  friend class CFolderVisitFromSelf;
  friend class CDirectoryVisitFromSelf;
  friend class CConsoleVisit;
  friend class CConsoleVisitFromSelf;
      
};

class CXboxRoot : public CXboxFolder, public CComCoClass<CXboxRoot, &CLSID_XboxFolder>
{

 public:

  /*
  **  IPersistFolder (overrides CXboxFolder implementatio)
  */
  STDMETHOD(Initialize)(LPCITEMIDLIST pidl);

  /*
  ** IShellFolder Methods
  */
  STDMETHOD(BindToObject)(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv);

  /*
  ** Construction
  */
  CXboxRoot();

  /*
  ** Disallow file transfer
  */
  virtual void GetTargetWireName(LPSTR pszWireName, LPSTR pszRelativeRemoteFile){_ASSERT(FALSE);}
  virtual void GetConsoleName(LPSTR pszConsole) {*pszConsole='\0';}
  
  /*
  ** Column Details
  */

  virtual HRESULT GetColumnHeaderDetails(UINT iColumn, SHELLDETAILS *pShellDetails);
  virtual HRESULT GetDetails(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pShellDetails);
  virtual HRESULT SetStatusBarText(IShellBrowser *pShellBrowser, LPCITEMIDLIST pidlSelect);

 protected:
 
  /*
  **  Cloning
  */
  virtual HRESULT CloneSelection(UINT uIndexCount, const UINT *puIndexList, CXboxFolder **ppSelectionClone);

  /*
  ** Children
  */
  virtual HRESULT RefreshChildren();
  virtual void FreeChildren();
  virtual HRESULT ReallocateChildren(UINT uChildCount);
  virtual HRESULT ValidateItem(LPCSTR pszPathName, UINT uRelativeDepth, DWORD *pdwAttributes);
  virtual void Visit(UINT uIndexCount, const UINT *puIndexList, IXboxVisitor *pVisitor, DWORD dwFlags);

  /*
  ** Item Identifiers
  */

  virtual HRESULT CompareItemIDs(UINT iColumn, int iNameCmp, UINT uChildIndex1, UINT uChildIndex2);
  
  /*
  ** Root specific information about children.
  */
  DWORD  GetChildIpAddress(UINT uChildIndex, BOOL fRetry = FALSE);
  LPCSTR GetActualName(UINT uChildIndex);
  
  DWORD *m_rgdwChildIPAddresses; //Array of IP address for each of the children.
  UINT  m_uDefaultConsole;       //Index into child array. 
  LPSTR *m_rgpszActualNames;     //Array of actual Xbox names, fetched on demand.
  #define XBOX_USE_USER_PROVIDED_NAME ((LPSTR)(0xFFFFFFFF))

  /*
  ** Stuff we outlaw, good C++ to prevent abuse.
  */
private:
  CXboxRoot(CXboxRoot&);             //no implicit copying
  CXboxRoot& operator =(CXboxRoot&); //no assigning

  friend class CConsoleVisit;

};

class CXboxConsole : public CXboxFolder
{

 public:

  /*
  ** IShellFolder Methods
  */
  STDMETHOD(BindToObject)(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv);
  
  /*
  ** Construction
  */

  static  HRESULT Create(
                    LPCSTR          pszResolveName,
                    LPCITEMIDLIST   pidlRoot,
                    IXboxConnection *pConnection,
                    REFIID          riid,
                    void            **ppv
                    );

  /*
  ** Column Details
  */

  virtual HRESULT GetColumnHeaderDetails(UINT iColumn, SHELLDETAILS *pShellDetails);
  virtual HRESULT GetDetails(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pShellDetails);
  virtual HRESULT SetStatusBarText(IShellBrowser *pShellBrowser, LPCITEMIDLIST pidlSelect);
  
  /*
  ** File Transfer
  */
  virtual IXboxConnection *GetXboxConnection(){m_pConnection->AddRef();return m_pConnection;}
  
 protected:
  
  /*
  **  Cloning
  */
  virtual HRESULT CloneSelection(UINT uIndexCount, const UINT *puIndexList, CXboxFolder **ppSelectionClone);
  
  /*
  ** Children
  */
  virtual HRESULT RefreshChildren();
  virtual HRESULT ReallocateChildren(UINT uChildCount);
  virtual void FreeChildren();
  virtual HRESULT ValidateItem(LPCSTR pszPathName, UINT uRelativeDepth, DWORD *pdwAttributes);
  virtual void Visit(UINT uIndexCount, const UINT *puIndexList, IXboxVisitor *pVisitor, DWORD dwFlags);

  /*
  ** Item Identifiers
  */

  virtual HRESULT CompareItemIDs(UINT iColumn, int iNameCmp, UINT uChildIndex1, UINT uChildIndex2);

 protected:

  /*
  ** c'tor and d'tor
  */
  CXboxConsole();   
  virtual void Destroy();
    
  /*
  **  Information about the console
  */
  IXboxConnection *m_pConnection;
  LPSTR            m_pszDisplayName;
  DWORD            m_dwIPAddress;

  /*
  **  Console Specific Information About 
  **  Information about children   
  */
  
  ULONGLONG *m_rgullChildFreeSpace;  // In bytes.
  ULONGLONG *m_rgullChildTotalSpace; // In bytes.
  UINT      *m_rguChildVolumeType;   // IDS_DRIVETYPE_FIXEDDISK or IDS_DRIVETYPE_MEMORY_UNIT
  
  /*
  ** Stuff we outlaw, good C++ to prevent abuse.
  */
 private:
  CXboxConsole(CXboxConsole&);             //no implicit copying
  CXboxConsole& operator =(CXboxConsole&); //no assigning

  friend class CConsoleVisitFromSelf;
  friend class CVolumeVisit;

};

class CXboxFileSystemFolder : public CXboxFolder
{

 public:

  /*
  ** IShellFolder Methods
  */
  STDMETHOD(BindToObject)(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv);
  STDMETHOD(SetNameOf)(HWND hwnd, LPCITEMIDLIST pidl, LPCOLESTR pszName, DWORD uFlags, LPITEMIDLIST *ppidl);

  /*
  ** Column Details
  */

  virtual HRESULT GetColumnHeaderDetails(UINT iColumn, SHELLDETAILS *pShellDetails);
  virtual HRESULT GetDetails(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pShellDetails);
  virtual HRESULT SetStatusBarText(IShellBrowser *pShellBrowser, LPCITEMIDLIST pidlSelect);
  
  /*
  ** File Transfer - as source
  */
  virtual HRESULT ReceiveFile(LPSTR pszRelativeRemoteFile, LPSTR szLocalFile);
  
  /*
  ** File Transfer - as target
  */
  virtual IXboxConnection *GetXboxConnection(){m_pConnection->AddRef();return m_pConnection;}

 protected:
  
  /*
  ** c'tor and d'tor
  */
  CXboxFileSystemFolder();
  virtual void Destroy();
  HRESULT CloneSelection(UINT uIndexCount, const UINT *puIndexList, CXboxFileSystemFolder *pClone);

  /*
  ** Children
  */
  virtual HRESULT RefreshChildren();
  virtual HRESULT ReallocateChildren(UINT uChildCount);
  virtual void FreeChildren();
  virtual HRESULT ValidateItem(LPCSTR pszPathName, UINT uRelativeDepth, DWORD *pdwAttributes);
  HRESULT SetName(HWND hWnd, LPSTR szWireNameOld, LPSTR szWireNameNew);

  /*
  ** Item Identifiers
  */

  virtual HRESULT CompareItemIDs(UINT iColumn, int iNameCmp, UINT uChildIndex1, UINT uChildIndex2);

  /*
  **  File Specific Information about children
  */

  IXboxConnection    *m_pConnection;
  DM_FILE_ATTRIBUTES *m_rgChildFileAttributes;  //Array of File Attributes for Children
  LPSTR              *m_rgszChildTypeNames;     //Array of Type Names (as returned by SHGetFileInfo)

  /*
  ** utility
  */
  static LPSTR GetFileTypeName(PDM_FILE_ATTRIBUTES pdmFileAttributes);

  /*
  ** Stuff we outlaw, good C++ to prevent abuse.
  */
 
 private:
  CXboxFileSystemFolder(CXboxFileSystemFolder&);             //no implicit copying
  CXboxFileSystemFolder& operator =(CXboxFileSystemFolder&); //no assigning

  friend class CFileOrDirVisit;
  friend class CFileOrDirVisitRecurse;
  friend class CFileOrDirVisitFromSelf;
  friend class CDirectoryVisitFromSelf;
};

class CXboxVolume : public CXboxFileSystemFolder
{
 public:
  
  /*
  ** Construction
  */
  CXboxVolume::CXboxVolume(){INIT_TRACKABLEOBJECT_NAME(CXboxVolume);m_dwSelectionVerbs = VOLUME_VERBS;}
  static HRESULT Create(
                    LPCSTR          pszPathName,              
                    LPCITEMIDLIST   pidlRoot,
                    IXboxConnection *pConnection,
                    REFIID          riid,
                    void            **ppv
                    );

  static UINT GetVolumeType(char cDriveLetter);

 protected:

  /*
  **  Operations on selections
  */
  virtual HRESULT CloneSelection(UINT uIndexCount, const UINT *puIndexList, CXboxFolder **ppSelectionClone);
  virtual void Visit(UINT uIndexCount, const UINT *puIndexList, IXboxVisitor *pVisitor, DWORD dwFlags);

  /*
  ** Information about this volume
  */
  UINT m_uVolumeType;

  friend class CVolumeVisitFromSelf;
};

class CXboxDirectory : public CXboxFileSystemFolder
{
 public:
  /*
  ** Construction
  */
  CXboxDirectory::CXboxDirectory(){INIT_TRACKABLEOBJECT_NAME(CXboxDirectory);m_dwSelectionVerbs = DIRECTORY_VERBS;}
  static HRESULT Create(
                    LPCSTR          pszPathName,
                    LPCITEMIDLIST   pidlRoot,
                    IXboxConnection *pConnection,
                    REFIID          riid,
                    void            **ppv
                    );
 protected:
  /*
  **  Operations on selections
  */
  virtual HRESULT CloneSelection(UINT uIndexCount, const UINT *puIndexList, CXboxFolder **ppSelectionClone);
  virtual void Visit(UINT uIndexCount, const UINT *puIndexList, IXboxVisitor *pVisitor, DWORD dwFlags);

  
};

//-------------------------------------------------------------------------------
//  Specialize ATL's CComEnum to do IEnumIDList
//-------------------------------------------------------------------------------
typedef CComEnum<IEnumIDList,&IID_IEnumIDList,LPITEMIDLIST,CPidlUtils,CComMultiThreadModel> CEnumIdList;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbshlext\xbshlext2.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    xbshlext.cpp

Abstract:

   Implementation of DLL Exports.
   Mostly ripped from ATL wizard generated code.

Environment:

    Windows 2000 and Later 
    User Mode
    Compiles UNICODE, but uses many ANSI APIs explictly.

Revision History:
    
    07-03-2001 : created

--*/


#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "xbshlext.h"
//#include "xbshlext_i.c"

//-------------------------------------------------------------------------------
//  ATL Module and Object 
//-------------------------------------------------------------------------------
CComModule _Module;
BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_XboxFolder, CXboxRoot)
END_OBJECT_MAP()

//-------------------------------------------------------------------------------
//  Global pointer to shell's IMalloc
//-------------------------------------------------------------------------------
IMalloc *g_pShellMalloc = NULL;

//-------------------------------------------------------------------------------
// DLL Entry Point - Standard ATL Implemenation.
//-------------------------------------------------------------------------------
extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_SHELLEXTLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

//-------------------------------------------------------------------------------
//  In addition to ATL stuff, do Just In Time cleanup, if necessary.
//-------------------------------------------------------------------------------
STDAPI DllCanUnloadNow(void)
{
    //
    //  See if we can unload
    //
    HRESULT hr;
    hr = (_Module.GetLockCount()==0) ? S_OK : S_FALSE;

    //
    //  Cleanup a few things if we are going to return S_OK;
    //
    if(S_OK==hr)
    {
        //
        //  Release the shell's IMalloc
        //
        if(g_pShellMalloc)
        {
            g_pShellMalloc->Release();
            g_pShellMalloc = NULL;
        }
    } else
    {
        DUMP_TRACKED_OBJECTS();
    }
    return hr;
}

//-------------------------------------------------------------------------------
// Returns a class factory to create an object of the requested type
//-------------------------------------------------------------------------------
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    HRESULT hr = S_OK;
    //
    //  Basically, everyone needs the shell's IMalloc, so just keep a global.
    //  Refuse to create any objects if we cannot get one.
    //
    if(!g_pShellMalloc)
    {
        hr = SHGetMalloc(&g_pShellMalloc);
    }
    if(SUCCEEDED(hr))
    {
        hr = _Module.GetClassObject(rclsid, riid, ppv);
    }
    return hr;
}

/*  UpdateShellImages which used GetIconSize and SetIconSize.
 *
 *  Don't bother:
 *
 *  This didn't work all that well, because the most common upgrade scenario ends up
 *  calling DllRegisterServer during a reboot, when the desktop isn't running, and then
 *  this code doesn't work!  So the user is still stuck with the wrong icons.  We sold out
 *  and fixed the brute force way, by adding placeholder icons to take up the icon indices
 *  the shell had already cached.
 *
 *  It caused an ugly flash anyway!
 *
int GetIconSize()
{
    TCHAR ach[20];
    DWORD cb = sizeof(ach);
    DWORD dwType;
    
    // Get the icon size from GetSystemMetrics
    int cxIcon = GetSystemMetrics(SM_CXICON);

    //But prefer to get it from the registry
    if(ERROR_SUCCESS == SHGetValue(
                            HKEY_CURRENT_USER,
                            TEXT("Control Panel\\Desktop\\WindowMetrics"),
                            TEXT("Shell Icon Size"),
                            &dwType,
                            (LPVOID)ach,
                            &cb))
    {
        _ASSERTE(dwType==REG_SZ);
        if( (ach[0] >= TEXT('0')) && (ach[0] <= TEXT('9')))
            return _ttoi(ach);
    }
    
    return cxIcon;
    
}

void SetIconSize(int iSize)
{
    TCHAR ach[20];
    _ltot(iSize, ach, 10);
    SHSetValue(
        HKEY_CURRENT_USER,
        TEXT("Control Panel\\Desktop\\WindowMetrics"),
        TEXT("Shell Icon Size"),
        REG_SZ,
        (LPVOID)ach,
        _tcslen(ach)*sizeof(TCHAR));
}

void UpdateShellImages()
{
    ICONMETRICS iconMetrics;
    iconMetrics.cbSize = sizeof(iconMetrics);

    // The principle here is that we can force the shell to rebuild its image list
    // if we change the shell icon size, or color depth in the registry, and then
    // call FileIconInit(BOOL fRestoreCache = TRUE). This is an evil hack, BUT we
    // cannot be first, and we certainly won't be the last to do this.  Unfortunately,
    // we need to preserve the size, so we need to do this it twice.
    
    int iOrgSize = GetIconSize();
    int iNewSize = iOrgSize-1;
    SetIconSize(iNewSize);
    //Found this in Desktop Settings Code, it is only partially documented, but it is all in public headers.
    //Will force icon updates
    SystemParametersInfo(SPI_GETICONMETRICS, sizeof(iconMetrics), &iconMetrics, 0);
    SystemParametersInfo(SPI_SETICONMETRICS, sizeof(iconMetrics), &iconMetrics, SPIF_UPDATEINIFILE | SPIF_SENDWININICHANGE);
    SetIconSize(iOrgSize);
    SystemParametersInfo(SPI_GETICONMETRICS, sizeof(iconMetrics), &iconMetrics, 0);
    SystemParametersInfo(SPI_SETICONMETRICS, sizeof(iconMetrics), &iconMetrics, SPIF_UPDATEINIFILE | SPIF_SENDWININICHANGE);
}*/


//-------------------------------------------------------------------------------
// DllRegisterServer - Adds entries to the system registry
//-------------------------------------------------------------------------------
STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    HRESULT hr = _Module.RegisterServer();
    
    if(SUCCEEDED(hr))
    {
        //
        // notify the shell that we installed a new namespace.
        //
        SHChangeNotify(SHCNE_MKDIR, SHCNF_PATH|SHCNF_FLUSH, ROOT_GUID_NAME_WIDE, NULL);
        
        //
        //  Create a shortcut on the start menu (don't fail registration if this
        //  doesn't work.)
        //
        
        HRESULT hres; //Different error value, we don't return this one.
        IShellLinkW* psl; 
        // Get a pointer to the IShellLink interface. 
        hres = CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, IID_IShellLinkW, (LPVOID *) &psl); 
        if (SUCCEEDED(hres))
        { 
            IPersistFile* ppf; 
            WCHAR wszShortcutPath[MAX_PATH];
            WCHAR wszShortcutName[40];
            WCHAR wszShortcutDescription[60];
            LoadStringW(_Module.GetModuleInstance(), IDS_ROOT_SHORT_CUT_NAME, wszShortcutName, ARRAYSIZE(wszShortcutName));
            LoadStringW(_Module.GetModuleInstance(), IDS_ROOT_SHORT_CUT_DESCRIPTION, wszShortcutDescription, ARRAYSIZE(wszShortcutDescription));

            // Set the path to the shortcut target and add the 
            // description. 
            psl->SetPath(ROOT_GUID_NAME_WIDE); 
            psl->SetDescription(wszShortcutDescription); 
            
            hres = SHGetFolderPathW( NULL, CSIDL_COMMON_PROGRAMS, NULL, SHGFP_TYPE_CURRENT, wszShortcutPath);
            if(SUCCEEDED(hres))
            {
                wcscat(wszShortcutPath, wszShortcutName);
                // Query IShellLink for the IPersistFile interface for saving the 
                // shortcut in persistent storage. 
                hres = psl->QueryInterface(IID_IPersistFile, (LPVOID*)&ppf); 
                if (SUCCEEDED(hres))
                { 
                    // Save the link by calling IPersistFile::Save. 
                    hres = ppf->Save(wszShortcutPath, TRUE); 
                    ppf->Release(); 
                }
            }
            psl->Release();

        }
        //UpdateShellImages();
    }
    return hr;
}

//-------------------------------------------------------------------------------
// DllUnregisterServer - Removes entries from the system registry
//-------------------------------------------------------------------------------
STDAPI DllUnregisterServer(void)
{
    HRESULT hr = _Module.UnregisterServer(TRUE);
    
    if(SUCCEEDED(hr))
    {
        //Remove the shortcut
        HRESULT hres;
        WCHAR wszShortcutPath[MAX_PATH];
        hres = SHGetFolderPathW( NULL, CSIDL_COMMON_PROGRAMS, NULL, SHGFP_TYPE_CURRENT, wszShortcutPath);
        if(SUCCEEDED(hres))
        {
            WCHAR wszShortcutName[40];
            LoadStringW(_Module.GetModuleInstance(), IDS_ROOT_SHORT_CUT_NAME, wszShortcutName, ARRAYSIZE(wszShortcutName));
            wcscat(wszShortcutPath, wszShortcutName);
            DeleteFileW(wszShortcutPath);  // The use may have deleted it already."
        }
        // Tell the shell that we removed the shell extension
        SHChangeNotify(SHCNE_RMDIR, SHCNF_PATH|SHCNF_FLUSH, ROOT_GUID_NAME_WIDE, NULL);
    }
    return hr;
}

HRESULT WINAPI CXboxFolder::UpdateRegistry(BOOL bRegister)
/*++
  Routine Description:
    
    Modifies the normal ATL class registration.  This is how to create more
    map entries for script susbstitution.  We create three:

    RUNDLLPATH    - The full path to rundll32.exe
    FIRST_ARG     - "%1" the script sees % as a special character, so a subst
                    is necessary to get this through.
    XBOX_HTT_PATH - Path to xbox.htt - assumed to be in the same place as this
                    module.

    Then we just run the script our of our resource.

  Comments:

    It is a static member of CXboxFolder, because ATL registers classes not
    servers.

--*/
{
    USES_CONVERSION;
    TCHAR szRunDllBuffer[_MAX_PATH];
    TCHAR szXboxHttBuffer[_MAX_PATH];

    //Allocate and terminate the regMapEntries
    _ATL_REGMAP_ENTRY regMapEntries[4];
    memset(&regMapEntries[3], 0, sizeof(_ATL_REGMAP_ENTRY)); //terminate the list

    //Fill out the first entry for RUNDLLPATH
    HRESULT hr = SHGetFolderPath(NULL, CSIDL_SYSTEM, NULL, SHGFP_TYPE_DEFAULT, szRunDllBuffer);
    _ASSERTE(SUCCEEDED(hr));
    ULONG ulSystemDirLen = _tcslen(szRunDllBuffer);
    _tcscpy(szRunDllBuffer + ulSystemDirLen, TEXT("\\rundll32.exe"));
    regMapEntries[0].szKey = OLESTR("RUNDLLPATH");
    regMapEntries[0].szData = T2OLE(szRunDllBuffer);

    //Fill out the second entry for %1 (this crap is necessary because the .rgs
    //script is way to simplist, with no escape sequences.
    regMapEntries[1].szKey = OLESTR("FIRST_ARG");
    regMapEntries[1].szData = OLESTR("%1");

    //Fill out the XBOX_HTT_PATH
    GetModuleFileName(_Module.GetModuleInstance(), szXboxHttBuffer, ARRAYSIZE(szXboxHttBuffer));
    _tcscpy(_tcsrchr(szXboxHttBuffer, '\\') + 1, TEXT("xbox.htt"));
    regMapEntries[2].szKey = OLESTR("XBOX_HTT_PATH");
    regMapEntries[2].szData = T2OLE(szXboxHttBuffer);

    return _Module.UpdateRegistryFromResource(IDR_XBOXFOLDER, bRegister, regMapEntries);
}

void CALLBACK LaunchExplorer(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow)
/*++
 Routine Description:
   The pluggable protocol stuff doesn't work all that well, because explorer cannot
   navigate to our pidl.  Somehow it finds our class, and we get to parse the display
   name (successfully!), but it is expecting our pidl to be some special case URL thing,
   which it is not.  The shell guys are useless here.  As Buzz put it, "I mention 'pluggable
   protocol' and people run the other way."

   However, 'explorer.exe /e,::{OUR CLSID}\<path to folder>' works just find.  So, rather than
   launch explorer, our pluggable protocol launches RunDLL32.exe, which calls this
   entry point.  Here we turn xbox://<path to folder>/ into ::{OUR CLSID}\<path to folder and
   we call explorer with it using WinExec.

   Note that we can do other neat things here.  Like:
     1) If a file is specified redirect to the parent folder.
--*/
{
  const char *szProtocolName = "xbox://";
  const int   szProtocolNameLen = (sizeof("xbox://")/sizeof(char))-1;
  const char *szCommandFormat = "explorer.exe ::{DB15FEDD-96B8-4DA9-97E0-7E5CCA05CC44}\\%s";
  char szCommand[1024];

  if(0==strncmp(szProtocolName, lpszCmdLine, szProtocolNameLen))
  {
    lpszCmdLine += szProtocolNameLen;
    int CmdLineLen = strlen(lpszCmdLine);
    if('/'==lpszCmdLine[CmdLineLen-1])
    {   
        lpszCmdLine[CmdLineLen-1] = '\0';
    }
    wsprintfA(szCommand, szCommandFormat, lpszCmdLine);
    WinExec(szCommand, nCmdShow);
  } else
  {
    MessageBoxA(hwnd, lpszCmdLine, "LaunchExplorer - Bad Args", MB_OK|MB_ICONERROR);
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbshlext\obj\i386\xbshlext.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Sun May 05 19:52:16 2002
 */
/* Compiler settings for xbshlext.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_SHELLEXTLib,0x5BFF97B9,0xAFFD,0x45C2,0x93,0x6D,0x09,0x3C,0x65,0x2E,0x98,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_XboxFolder,0xDB15FEDD,0x96B8,0x4DA9,0x97,0xE0,0x7E,0x5C,0xCA,0x05,0xCC,0x44);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Sun May 05 19:52:16 2002
 */
/* Compiler settings for xbshlext.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_SHELLEXTLib,0x5BFF97B9,0xAFFD,0x45C2,0x93,0x6D,0x09,0x3C,0x65,0x2E,0x98,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_XboxFolder,0xDB15FEDD,0x96B8,0x4DA9,0x97,0xE0,0x7E,0x5C,0xCA,0x05,0xCC,0x44);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbshlext\sdkp\inc\prsht.h ===
/*****************************************************************************\
*                                                                             *
* prsht.h - - Interface for the Windows Property Sheet Pages                  *
*                                                                             *
* Version 1.0                                                                 *
*                                                                             *
* Copyright (c) 1991-1998, Microsoft Corp.      All rights reserved.          *
*                                                                             *
\*****************************************************************************/

#ifndef _PRSHT_H_
#define _PRSHT_H_

#ifndef _WINRESRC_
#ifndef _WIN32_IE
#define _WIN32_IE 0x0501
#else
#if (_WIN32_IE < 0x0400) && defined(_WIN32_WINNT) && (_WIN32_WINNT >= 0x0500)
#error _WIN32_IE setting conflicts with _WIN32_WINNT setting
#endif
#endif
#endif

//
// Define API decoration for direct importing of DLL references.
//
#ifndef WINCOMMCTRLAPI
#if !defined(_COMCTL32_) && defined(_WIN32)
#define WINCOMMCTRLAPI DECLSPEC_IMPORT
#else
#define WINCOMMCTRLAPI
#endif
#endif // WINCOMMCTRLAPI

#ifndef CCSIZEOF_STRUCT
#define CCSIZEOF_STRUCT(structname, member)  (((int)((LPBYTE)(&((structname*)0)->member) - ((LPBYTE)((structname*)0)))) + sizeof(((structname*)0)->member))
#endif

//
// For compilers that don't support nameless unions
//
#ifndef DUMMYUNIONNAME
#ifdef NONAMELESSUNION
#define DUMMYUNIONNAME   u
#define DUMMYUNIONNAME2  u2
#define DUMMYUNIONNAME3  u3
#define DUMMYUNIONNAME4  u4
#define DUMMYUNIONNAME5  u5
#else
#define DUMMYUNIONNAME
#define DUMMYUNIONNAME2
#define DUMMYUNIONNAME3
#define DUMMYUNIONNAME4
#define DUMMYUNIONNAME5
#endif
#endif // DUMMYUNIONNAME

#ifdef _WIN64
#include <pshpack8.h>
#else
#include <pshpack4.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif


#ifndef SNDMSG
#ifdef __cplusplus
#ifndef _MAC
#define SNDMSG ::SendMessage
#else
#define SNDMSG ::AfxSendMessage
#endif
#else
#ifndef _MAC
#define SNDMSG SendMessage
#else
#define SNDMSG AfxSendMessage
#endif
#endif
#endif // ifndef SNDMSG

#define MAXPROPPAGES            100

struct _PSP;
typedef struct _PSP FAR* HPROPSHEETPAGE;

#ifndef MIDL_PASS
struct _PROPSHEETPAGEA;
struct _PROPSHEETPAGEW;
#endif

typedef UINT (CALLBACK FAR * LPFNPSPCALLBACKA)(HWND hwnd, UINT uMsg, struct _PROPSHEETPAGEA FAR *ppsp);
typedef UINT (CALLBACK FAR * LPFNPSPCALLBACKW)(HWND hwnd, UINT uMsg, struct _PROPSHEETPAGEW FAR *ppsp);

#ifdef UNICODE
#define LPFNPSPCALLBACK         LPFNPSPCALLBACKW
#else
#define LPFNPSPCALLBACK         LPFNPSPCALLBACKA
#endif

#define PSP_DEFAULT                0x00000000
#define PSP_DLGINDIRECT            0x00000001
#define PSP_USEHICON               0x00000002
#define PSP_USEICONID              0x00000004
#define PSP_USETITLE               0x00000008
#define PSP_RTLREADING             0x00000010

#define PSP_HASHELP                0x00000020
#define PSP_USEREFPARENT           0x00000040
#define PSP_USECALLBACK            0x00000080
#define PSP_PREMATURE              0x00000400

#if (_WIN32_IE >= 0x0400)
//----- New flags for wizard97 --------------
#define PSP_HIDEHEADER             0x00000800
#define PSP_USEHEADERTITLE         0x00001000
#define PSP_USEHEADERSUBTITLE      0x00002000
//-------------------------------------------
#endif


#if (_WIN32_IE >= 0x0500)
#define PSPCB_ADDREF            0
#endif
#define PSPCB_RELEASE           1
#define PSPCB_CREATE            2

#define PROPSHEETPAGEA_V1_SIZE CCSIZEOF_STRUCT(PROPSHEETPAGEA, pcRefParent)
#define PROPSHEETPAGEW_V1_SIZE CCSIZEOF_STRUCT(PROPSHEETPAGEW, pcRefParent)

typedef struct _PROPSHEETPAGEA {
        DWORD           dwSize;
        DWORD           dwFlags;
        HINSTANCE       hInstance;
        union {
            LPCSTR          pszTemplate;
#ifdef _WIN32
            LPCDLGTEMPLATE  pResource;
#else
            const VOID FAR *pResource;
#endif
        } DUMMYUNIONNAME;
        union {
            HICON       hIcon;
            LPCSTR      pszIcon;
        } DUMMYUNIONNAME2;
        LPCSTR          pszTitle;
        DLGPROC         pfnDlgProc;
        LPARAM          lParam;
        LPFNPSPCALLBACKA pfnCallback;
        UINT FAR * pcRefParent;

#if (_WIN32_IE >= 0x0400)
        LPCSTR pszHeaderTitle;    // this is displayed in the header
        LPCSTR pszHeaderSubTitle; //
#endif
} PROPSHEETPAGEA, FAR *LPPROPSHEETPAGEA;
typedef const PROPSHEETPAGEA FAR *LPCPROPSHEETPAGEA;

typedef struct _PROPSHEETPAGEW {
        DWORD           dwSize;
        DWORD           dwFlags;
        HINSTANCE       hInstance;
        union {
            LPCWSTR          pszTemplate;
#ifdef _WIN32
            LPCDLGTEMPLATE  pResource;
#else
            const VOID FAR *pResource;
#endif
        }DUMMYUNIONNAME;
        union {
            HICON       hIcon;
            LPCWSTR      pszIcon;
        }DUMMYUNIONNAME2;
        LPCWSTR          pszTitle;
        DLGPROC         pfnDlgProc;
        LPARAM          lParam;
        LPFNPSPCALLBACKW pfnCallback;
        UINT FAR * pcRefParent;

#if (_WIN32_IE >= 0x0400)
        LPCWSTR pszHeaderTitle;    // this is displayed in the header
        LPCWSTR pszHeaderSubTitle; ///
#endif
} PROPSHEETPAGEW, FAR *LPPROPSHEETPAGEW;
typedef const PROPSHEETPAGEW FAR *LPCPROPSHEETPAGEW;

#if 0 // IEUNIX reserved.
/* Macros for the missing definitions.  */
/* Not all, because mostly used in C++. */
#if __STDC__ || defined (NONAMELESSUNION)
#   define PSP_pszTemplate(X) ((X).u.pszTemplate)
#else
#   define PSP_pszTemplate(X) ((X).pszTemplate)
#endif
#endif

#ifdef UNICODE
#define PROPSHEETPAGE           PROPSHEETPAGEW
#define LPPROPSHEETPAGE         LPPROPSHEETPAGEW
#define LPCPROPSHEETPAGE        LPCPROPSHEETPAGEW
#define PROPSHEETPAGE_V1_SIZE PROPSHEETPAGEW_V1_SIZE
#else
#define PROPSHEETPAGE           PROPSHEETPAGEA
#define LPPROPSHEETPAGE         LPPROPSHEETPAGEA
#define LPCPROPSHEETPAGE        LPCPROPSHEETPAGEA
#define PROPSHEETPAGE_V1_SIZE PROPSHEETPAGEA_V1_SIZE
#endif


#define PSH_DEFAULT             0x00000000
#define PSH_PROPTITLE           0x00000001
#define PSH_USEHICON            0x00000002
#define PSH_USEICONID           0x00000004
#define PSH_PROPSHEETPAGE       0x00000008
#define PSH_WIZARDHASFINISH     0x00000010
#define PSH_WIZARD              0x00000020
#define PSH_USEPSTARTPAGE       0x00000040
#define PSH_NOAPPLYNOW          0x00000080
#define PSH_USECALLBACK         0x00000100
#define PSH_HASHELP             0x00000200
#define PSH_MODELESS            0x00000400
#define PSH_RTLREADING          0x00000800
#define PSH_WIZARDCONTEXTHELP   0x00001000

#if (_WIN32_IE >= 0x0400)
//----- New flags for wizard97 -----------
#if (_WIN32_IE < 0x0500)
#define PSH_WIZARD97            0x00002000
#else
#define PSH_WIZARD97            0x01000000
#endif
// 0x00004000 was not used by any previous release
#define PSH_WATERMARK           0x00008000
#define PSH_USEHBMWATERMARK     0x00010000  // user pass in a hbmWatermark instead of pszbmWatermark
#define PSH_USEHPLWATERMARK     0x00020000  //
#define PSH_STRETCHWATERMARK    0x00040000  // stretchwatermark also applies for the header
#define PSH_HEADER              0x00080000
#define PSH_USEHBMHEADER        0x00100000
#define PSH_USEPAGELANG         0x00200000  // use frame dialog template matched to page
//----------------------------------------
#endif

#if (_WIN32_IE >= 0x0500)
//----- New flags for wizard-lite --------
#define PSH_WIZARD_LITE         0x00400000
#define PSH_NOCONTEXTHELP       0x02000000
//----------------------------------------
#endif


typedef int (CALLBACK *PFNPROPSHEETCALLBACK)(HWND, UINT, LPARAM);

#define PROPSHEETHEADERA_V1_SIZE CCSIZEOF_STRUCT(PROPSHEETHEADERA, pfnCallback)
#define PROPSHEETHEADERW_V1_SIZE CCSIZEOF_STRUCT(PROPSHEETHEADERW, pfnCallback)

typedef struct _PROPSHEETHEADERA {
        DWORD           dwSize;
        DWORD           dwFlags;
        HWND            hwndParent;
        HINSTANCE       hInstance;
        union {
            HICON       hIcon;
            LPCSTR      pszIcon;
        }DUMMYUNIONNAME;
        LPCSTR          pszCaption;

        UINT            nPages;
        union {
            UINT        nStartPage;
            LPCSTR      pStartPage;
        }DUMMYUNIONNAME2;
        union {
            LPCPROPSHEETPAGEA ppsp;
            HPROPSHEETPAGE FAR *phpage;
        }DUMMYUNIONNAME3;
        PFNPROPSHEETCALLBACK pfnCallback;

#if (_WIN32_IE >= 0x0400)
        union {
            HBITMAP hbmWatermark;
            LPCSTR pszbmWatermark;
        } DUMMYUNIONNAME4;
        HPALETTE hplWatermark;
        union {
            HBITMAP hbmHeader;     // Header  bitmap shares the palette with watermark
            LPCSTR pszbmHeader;
        } DUMMYUNIONNAME5;
#endif
} PROPSHEETHEADERA, FAR *LPPROPSHEETHEADERA;

typedef const PROPSHEETHEADERA FAR *LPCPROPSHEETHEADERA;

typedef struct _PROPSHEETHEADERW {
        DWORD           dwSize;
        DWORD           dwFlags;
        HWND            hwndParent;
        HINSTANCE       hInstance;
        union {
            HICON       hIcon;
            LPCWSTR     pszIcon;
        }DUMMYUNIONNAME;
        LPCWSTR         pszCaption;


        UINT            nPages;
        union {
            UINT        nStartPage;
            LPCWSTR     pStartPage;
        }DUMMYUNIONNAME2;
        union {
            LPCPROPSHEETPAGEW ppsp;
            HPROPSHEETPAGE FAR *phpage;
        }DUMMYUNIONNAME3;
        PFNPROPSHEETCALLBACK pfnCallback;

#if (_WIN32_IE >= 0x0400)
        union {
            HBITMAP hbmWatermark;
            LPCWSTR pszbmWatermark;
        } DUMMYUNIONNAME4;
        HPALETTE hplWatermark;
        union {
            HBITMAP hbmHeader;
            LPCWSTR pszbmHeader;
        } DUMMYUNIONNAME5;
#endif
} PROPSHEETHEADERW, FAR *LPPROPSHEETHEADERW;
typedef const PROPSHEETHEADERW FAR *LPCPROPSHEETHEADERW;

#if 0 //IEUNIX reserved.
/* Macros for the missing definitions.  */
/* Not all, because mostly used in C++. */
#if __STDC__ || defined (NONAMELESSUNION)
#   define PSH_nStartPage(X) ((X).u2.nStartPage)
#   define PSH_ppsp(X)       ((X).u3.ppsp)
#else
#   define PSH_nStartPage(X) ((X).nStartPage)
#   define PSH_ppsp(X)       ((X).ppsp)
#endif
#endif

#ifdef UNICODE
#define PROPSHEETHEADER         PROPSHEETHEADERW
#define LPPROPSHEETHEADER       LPPROPSHEETHEADERW
#define LPCPROPSHEETHEADER      LPCPROPSHEETHEADERW
#define PROPSHEETHEADER_V1_SIZE PROPSHEETHEADERW_V1_SIZE
#else
#define PROPSHEETHEADER         PROPSHEETHEADERA
#define LPPROPSHEETHEADER       LPPROPSHEETHEADERA
#define LPCPROPSHEETHEADER      LPCPROPSHEETHEADERA
#define PROPSHEETHEADER_V1_SIZE PROPSHEETHEADERA_V1_SIZE
#endif


#define PSCB_INITIALIZED  1
#define PSCB_PRECREATE    2

WINCOMMCTRLAPI HPROPSHEETPAGE WINAPI CreatePropertySheetPageA(LPCPROPSHEETPAGEA);
WINCOMMCTRLAPI HPROPSHEETPAGE WINAPI CreatePropertySheetPageW(LPCPROPSHEETPAGEW);
WINCOMMCTRLAPI BOOL           WINAPI DestroyPropertySheetPage(HPROPSHEETPAGE);
WINCOMMCTRLAPI INT_PTR        WINAPI PropertySheetA(LPCPROPSHEETHEADERA);
WINCOMMCTRLAPI INT_PTR        WINAPI PropertySheetW(LPCPROPSHEETHEADERW);

#ifdef UNICODE
#define CreatePropertySheetPage  CreatePropertySheetPageW
#define PropertySheet            PropertySheetW
#else
#define CreatePropertySheetPage  CreatePropertySheetPageA
#define PropertySheet            PropertySheetA
#endif



typedef BOOL (CALLBACK FAR * LPFNADDPROPSHEETPAGE)(HPROPSHEETPAGE, LPARAM);
typedef BOOL (CALLBACK FAR * LPFNADDPROPSHEETPAGES)(LPVOID, LPFNADDPROPSHEETPAGE, LPARAM);


typedef struct _PSHNOTIFY
{
    NMHDR hdr;
    LPARAM lParam;
} PSHNOTIFY, FAR *LPPSHNOTIFY;

#define PSN_FIRST               (0U-200U)
#define PSN_LAST                (0U-299U)


#define PSN_SETACTIVE           (PSN_FIRST-0)
#define PSN_KILLACTIVE          (PSN_FIRST-1)
// #define PSN_VALIDATE            (PSN_FIRST-1)
#define PSN_APPLY               (PSN_FIRST-2)
#define PSN_RESET               (PSN_FIRST-3)
// #define PSN_CANCEL              (PSN_FIRST-3)
#define PSN_HELP                (PSN_FIRST-5)
#define PSN_WIZBACK             (PSN_FIRST-6)
#define PSN_WIZNEXT             (PSN_FIRST-7)
#define PSN_WIZFINISH           (PSN_FIRST-8)
#define PSN_QUERYCANCEL         (PSN_FIRST-9)
#if (_WIN32_IE >= 0x0400)
#define PSN_GETOBJECT           (PSN_FIRST-10)
#endif // 0x0400
#if (_WIN32_IE >= 0x0500)
#define PSN_TRANSLATEACCELERATOR (PSN_FIRST-12)
#define PSN_QUERYINITIALFOCUS   (PSN_FIRST-13)
#endif // 0x0500

#define PSNRET_NOERROR              0
#define PSNRET_INVALID              1
#define PSNRET_INVALID_NOCHANGEPAGE 2
#define PSNRET_MESSAGEHANDLED       3

#define PSM_SETCURSEL           (WM_USER + 101)
#define PropSheet_SetCurSel(hDlg, hpage, index) \
        SNDMSG(hDlg, PSM_SETCURSEL, (WPARAM)index, (LPARAM)hpage)


#define PSM_REMOVEPAGE          (WM_USER + 102)
#define PropSheet_RemovePage(hDlg, index, hpage) \
        SNDMSG(hDlg, PSM_REMOVEPAGE, index, (LPARAM)hpage)


#define PSM_ADDPAGE             (WM_USER + 103)
#define PropSheet_AddPage(hDlg, hpage) \
        SNDMSG(hDlg, PSM_ADDPAGE, 0, (LPARAM)hpage)


#define PSM_CHANGED             (WM_USER + 104)
#define PropSheet_Changed(hDlg, hwnd) \
        SNDMSG(hDlg, PSM_CHANGED, (WPARAM)hwnd, 0L)


#define PSM_RESTARTWINDOWS      (WM_USER + 105)
#define PropSheet_RestartWindows(hDlg) \
        SNDMSG(hDlg, PSM_RESTARTWINDOWS, 0, 0L)


#define PSM_REBOOTSYSTEM        (WM_USER + 106)
#define PropSheet_RebootSystem(hDlg) \
        SNDMSG(hDlg, PSM_REBOOTSYSTEM, 0, 0L)


#define PSM_CANCELTOCLOSE       (WM_USER + 107)
#define PropSheet_CancelToClose(hDlg) \
        PostMessage(hDlg, PSM_CANCELTOCLOSE, 0, 0L)


#define PSM_QUERYSIBLINGS       (WM_USER + 108)
#define PropSheet_QuerySiblings(hDlg, wParam, lParam) \
        SNDMSG(hDlg, PSM_QUERYSIBLINGS, wParam, lParam)


#define PSM_UNCHANGED           (WM_USER + 109)
#define PropSheet_UnChanged(hDlg, hwnd) \
        SNDMSG(hDlg, PSM_UNCHANGED, (WPARAM)hwnd, 0L)


#define PSM_APPLY               (WM_USER + 110)
#define PropSheet_Apply(hDlg) \
        SNDMSG(hDlg, PSM_APPLY, 0, 0L)


#define PSM_SETTITLEA           (WM_USER + 111)
#define PSM_SETTITLEW           (WM_USER + 120)


#ifdef UNICODE
#define PSM_SETTITLE            PSM_SETTITLEW
#else
#define PSM_SETTITLE            PSM_SETTITLEA
#endif

#define PropSheet_SetTitle(hDlg, wStyle, lpszText)\
        SNDMSG(hDlg, PSM_SETTITLE, wStyle, (LPARAM)(LPCTSTR)lpszText)


#define PSM_SETWIZBUTTONS       (WM_USER + 112)
#define PropSheet_SetWizButtons(hDlg, dwFlags) \
        PostMessage(hDlg, PSM_SETWIZBUTTONS, 0, (LPARAM)dwFlags)


#define PSWIZB_BACK             0x00000001
#define PSWIZB_NEXT             0x00000002
#define PSWIZB_FINISH           0x00000004
#define PSWIZB_DISABLEDFINISH   0x00000008


#define PSM_PRESSBUTTON         (WM_USER + 113)
#define PropSheet_PressButton(hDlg, iButton) \
        PostMessage(hDlg, PSM_PRESSBUTTON, (WPARAM)iButton, 0)


#define PSBTN_BACK              0
#define PSBTN_NEXT              1
#define PSBTN_FINISH            2
#define PSBTN_OK                3
#define PSBTN_APPLYNOW          4
#define PSBTN_CANCEL            5
#define PSBTN_HELP              6
#define PSBTN_MAX               6



#define PSM_SETCURSELID         (WM_USER + 114)
#define PropSheet_SetCurSelByID(hDlg, id) \
        SNDMSG(hDlg, PSM_SETCURSELID, 0, (LPARAM)id)


#define PSM_SETFINISHTEXTA      (WM_USER + 115)
#define PSM_SETFINISHTEXTW      (WM_USER + 121)

#ifdef UNICODE
#define PSM_SETFINISHTEXT       PSM_SETFINISHTEXTW
#else
#define PSM_SETFINISHTEXT       PSM_SETFINISHTEXTA
#endif

#define PropSheet_SetFinishText(hDlg, lpszText) \
        SNDMSG(hDlg, PSM_SETFINISHTEXT, 0, (LPARAM)lpszText)


#define PSM_GETTABCONTROL       (WM_USER + 116)
#define PropSheet_GetTabControl(hDlg) \
        (HWND)SNDMSG(hDlg, PSM_GETTABCONTROL, 0, 0)

#define PSM_ISDIALOGMESSAGE     (WM_USER + 117)
#define PropSheet_IsDialogMessage(hDlg, pMsg) \
        (BOOL)SNDMSG(hDlg, PSM_ISDIALOGMESSAGE, 0, (LPARAM)pMsg)

#define PSM_GETCURRENTPAGEHWND  (WM_USER + 118)
#define PropSheet_GetCurrentPageHwnd(hDlg) \
        (HWND)SNDMSG(hDlg, PSM_GETCURRENTPAGEHWND, 0, 0L)

#define PSM_INSERTPAGE          (WM_USER + 119)
#define PropSheet_InsertPage(hDlg, index, hpage) \
        SNDMSG(hDlg, PSM_INSERTPAGE, (WPARAM)(index), (LPARAM)(hpage))


#if (_WIN32_IE >= 0x0500)
#define PSM_SETHEADERTITLEA     (WM_USER + 125)
#define PSM_SETHEADERTITLEW     (WM_USER + 126)

#ifdef UNICODE
#define PSM_SETHEADERTITLE      PSM_SETHEADERTITLEW
#else
#define PSM_SETHEADERTITLE      PSM_SETHEADERTITLEA
#endif

#define PropSheet_SetHeaderTitle(hDlg, index, lpszText) \
        SNDMSG(hDlg, PSM_SETHEADERTITLE, (WPARAM)(index), (LPARAM)(lpszText))


#define PSM_SETHEADERSUBTITLEA     (WM_USER + 127)
#define PSM_SETHEADERSUBTITLEW     (WM_USER + 128)

#ifdef UNICODE
#define PSM_SETHEADERSUBTITLE      PSM_SETHEADERSUBTITLEW
#else
#define PSM_SETHEADERSUBTITLE      PSM_SETHEADERSUBTITLEA
#endif

#define PropSheet_SetHeaderSubTitle(hDlg, index, lpszText) \
        SNDMSG(hDlg, PSM_SETHEADERSUBTITLE, (WPARAM)(index), (LPARAM)(lpszText))

#define PSM_HWNDTOINDEX            (WM_USER + 129)
#define PropSheet_HwndToIndex(hDlg, hwnd) \
        (int)SNDMSG(hDlg, PSM_HWNDTOINDEX, (WPARAM)(hwnd), 0)

#define PSM_INDEXTOHWND            (WM_USER + 130)
#define PropSheet_IndexToHwnd(hDlg, i) \
        (HWND)SNDMSG(hDlg, PSM_INDEXTOHWND, (WPARAM)(i), 0)

#define PSM_PAGETOINDEX            (WM_USER + 131)
#define PropSheet_PageToIndex(hDlg, hpage) \
        (int)SNDMSG(hDlg, PSM_PAGETOINDEX, 0, (LPARAM)(hpage))

#define PSM_INDEXTOPAGE            (WM_USER + 132)
#define PropSheet_IndexToPage(hDlg, i) \
        (HPROPSHEETPAGE)SNDMSG(hDlg, PSM_INDEXTOPAGE, (WPARAM)(i), 0)

#define PSM_IDTOINDEX              (WM_USER + 133)
#define PropSheet_IdToIndex(hDlg, id) \
        (int)SNDMSG(hDlg, PSM_IDTOINDEX, 0, (LPARAM)(id))

#define PSM_INDEXTOID              (WM_USER + 134)
#define PropSheet_IndexToId(hDlg, i) \
        SNDMSG(hDlg, PSM_INDEXTOID, (WPARAM)(i), 0)

#define PSM_GETRESULT              (WM_USER + 135)
#define PropSheet_GetResult(hDlg) \
        SNDMSG(hDlg, PSM_GETRESULT, 0, 0)

#define PSM_RECALCPAGESIZES        (WM_USER + 136)
#define PropSheet_RecalcPageSizes(hDlg) \
        SNDMSG(hDlg, PSM_RECALCPAGESIZES, 0, 0)
#endif // 0x0500

#define ID_PSRESTARTWINDOWS     0x2
#define ID_PSREBOOTSYSTEM       (ID_PSRESTARTWINDOWS | 0x1)


#define WIZ_CXDLG               276
#define WIZ_CYDLG               140

#define WIZ_CXBMP               80

#define WIZ_BODYX               92
#define WIZ_BODYCX              184

#define PROP_SM_CXDLG           212
#define PROP_SM_CYDLG           188

#define PROP_MED_CXDLG          227
#define PROP_MED_CYDLG          215

#define PROP_LG_CXDLG           252
#define PROP_LG_CYDLG           218


#ifdef __cplusplus
}
#endif

#include <poppack.h>


#endif  // _PRSHT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbshlext\obj\i386\xbshlext.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Sun May 05 19:52:16 2002
 */
/* Compiler settings for xbshlext.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __xbshlext_h__
#define __xbshlext_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __XboxFolder_FWD_DEFINED__
#define __XboxFolder_FWD_DEFINED__

#ifdef __cplusplus
typedef class XboxFolder XboxFolder;
#else
typedef struct XboxFolder XboxFolder;
#endif /* __cplusplus */

#endif 	/* __XboxFolder_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "shObjIdl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 


#ifndef __SHELLEXTLib_LIBRARY_DEFINED__
#define __SHELLEXTLib_LIBRARY_DEFINED__

/* library SHELLEXTLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_SHELLEXTLib;

EXTERN_C const CLSID CLSID_XboxFolder;

#ifdef __cplusplus

class DECLSPEC_UUID("DB15FEDD-96B8-4DA9-97E0-7E5CCA05CC44")
XboxFolder;
#endif
#endif /* __SHELLEXTLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbshlext\sdkp\inc\shlguidp.h ===
#ifndef _SHLGUIDP_H_
#define _SHLGUIDP_H_

#ifndef _WIN32_IE
#define _WIN32_IE 0x0501
#else
#if (_WIN32_IE < 0x0400) && defined(_WIN32_WINNT) && (_WIN32_WINNT >= 0x0500)
#error _WIN32_IE setting conflicts with _WIN32_WINNT setting
#endif
#endif

#ifndef DEFINE_SHLGUID
#define DEFINE_SHLGUID(name, l, w1, w2) DEFINE_GUID(name, l, w1, w2, 0xC0,0,0,0,0,0,0,0x46)
#endif
#if (_WIN32_IE >= 0x0400)
#endif
#if (_WIN32_IE >= 0x0400)
DEFINE_GUID(IID_IShellIconOverlayManager, 0x63B51F80L, 0xC868, 0x11D0, 0x99, 0x9C, 0x00, 0xC0, 0x4F, 0xD6, 0x55, 0xE1);
// {6B707A1C-744F-11d2-86B9-00C04F8EEA99}
DEFINE_GUID(IID_IBrowserBand, 0x6b707a1c, 0x744f, 0x11d2, 0x86, 0xb9, 0x0, 0xc0, 0x4f, 0x8e, 0xea, 0x99);

// {95CE8410-7027-11D1-B879-006008059382}
DEFINE_GUID(IID_IShellTreeWalker, 0x95CE8410L, 0x7027, 0x11D1, 0xB8, 0x79, 0x00, 0x60, 0x08, 0x05, 0x93, 0x82);
// {95CE8411-7027-11D1-B879-006008059382}
DEFINE_GUID(IID_IShellTreeWalkerCallBack, 0x95CE8411L, 0x7027, 0x11D1, 0xB8, 0x79, 0x00, 0x60, 0x08, 0x05, 0x93, 0x82);
// {be1af9f0-b231-11d2-963e-00c04f79adf0}
DEFINE_GUID(IID_IDropTargetWithDADSupport, 0xb0061660, 0xb231, 0x11d2, 0x96, 0x3e, 0x00, 0xc0, 0x4f, 0x79, 0xad, 0xf0);
// {27DC26B1-41B3-11D1-B850-006008059382}
DEFINE_GUID(CLSID_CMultiMonConfig,           0x27DC26B1L, 0x41B3, 0x11D1, 0xB8, 0x50, 0x00, 0x60, 0x08, 0x05, 0x93, 0x82);
// {95CE8412-7027-11D1-B879-006008059382}
DEFINE_GUID(CLSID_CShellTreeWalker,          0x95CE8412L, 0x7027, 0x11D1, 0xB8, 0x79, 0x00, 0x60, 0x08, 0x05, 0x93, 0x82);
#if (_WIN32_IE >= 0x0500)
// {48C8118C-B924-11d1-98D5-00C04FB687DA}
DEFINE_GUID(IID_IShellImageStore,            0x48c8118c, 0xb924, 0x11d1, 0x98, 0xd5, 0x0, 0xc0, 0x4f, 0xb6, 0x87, 0xda);

// {6DFD582B-92E3-11d1-98A3-00C04FB687DA}
DEFINE_GUID(IID_IEnumShellImageStore,        0x6dfd582b, 0x92e3, 0x11d1, 0x98, 0xa3, 0x0, 0xc0, 0x4f, 0xb6, 0x87, 0xda);

// {1EBDCF80-A200-11d0-A3A4-00C04FD706EC}
DEFINE_GUID(CLSID_ShellThumbnailDiskCache,   0x1ebdcf80, 0xa200, 0x11d0, 0xa3, 0xa4, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec);
#endif

// same interface as IID_IExtractImage
// {D4029EC0-0920-11d1-9A0B-00C04FC2D6C1}
DEFINE_GUID(IID_IExtractLogo,                0xd4029ec0, 0x920, 0x11d1, 0x9a, 0xb, 0x0, 0xc0, 0x4f, 0xc2, 0xd6, 0xc1);

// {6CCB7BE0-6807-11d0-B810-00C04FD706EC}
DEFINE_GUID(IID_IShellTaskScheduler,         0x6ccb7be0, 0x6807, 0x11d0, 0xb8, 0x10, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec);

// {603D3800-BD81-11d0-A3A5-00C04FD706EC}
DEFINE_GUID(CLSID_ShellTaskScheduler,        0x603d3800, 0xbd81, 0x11d0, 0xa3, 0xa5, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec);

// {603D3801-BD81-11d0-A3A5-00C04FD706EC}
DEFINE_GUID(CLSID_SharedTaskScheduler,       0x603d3801, 0xbd81, 0x11d0, 0xa3, 0xa5, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec);

// {3F4EEF80-BFE8-11d0-A3A5-00C04FD706EC}
DEFINE_GUID(CLSID_ImageListCache,            0x3f4eef80, 0xbfe8, 0x11d0, 0xa3, 0xa5, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec);

// {4FCE9180-BFE8-11d0-A3A5-00C04FD706EC}
DEFINE_GUID(IID_IImageCache,                 0x4fce9180, 0xbfe8, 0x11d0, 0xa3, 0xa5, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec);

#if (_WIN32_IE >= 0x0500)
// {AC3E9E59-96D7-11d1-98A4-00C04FB687DA}
DEFINE_GUID(IID_IImageCache2,                0xac3e9e59, 0x96d7, 0x11d1, 0x98, 0xa4, 0x0, 0xc0, 0x4f, 0xb6, 0x87, 0xda);

// {7BB0B520-B1A7-11d2-BB23-00C04F79ABCD}
DEFINE_GUID(IID_IThumbnailView,              0x7bb0b520, 0xb1a7, 0x11d2, 0xbb, 0x23, 0x0, 0xc0, 0x4f, 0x79, 0xab, 0xcd);

#endif

DEFINE_GUID(IID_IMultiMonitorDockingSite, 0x03879DE0L, 0xA205, 0x11D0, 0x99, 0xCB, 0x00, 0xC0, 0x4F, 0xD6, 0x55, 0xE1); 
DEFINE_GUID(CGID_AddressEditBox, 0x72730b70, 0xe8f7, 0x11d0, 0xbc, 0x44, 0x0, 0xaa, 0x0, 0x6c, 0xe2, 0xf5);

// {27DC26B0-41B3-11D1-B850-006008059382}
DEFINE_GUID(IID_IMultiMonConfig, 0x27DC26B0L, 0x41B3, 0x11D1, 0xB8, 0x50, 0x00, 0x60, 0x08, 0x05, 0x93, 0x82);

// {45B324CE-B8A1-11d1-98D3-00C04FB687DA}
DEFINE_GUID(IID_IScaleAndSharpenImage2, 0x45b324ce, 0xb8a1, 0x11d1, 0x98, 0xd3, 0x0, 0xc0, 0x4f, 0xb6, 0x87, 0xda);

// {8A4D3EDC-13A4-11d1-9A22-00C04FC2D6C1}
DEFINE_GUID(CLSID_ThumbnailScaler, 0x8a4d3edc, 0x13a4, 0x11d1, 0x9a, 0x22, 0x0, 0xc0, 0x4f, 0xc2, 0xd6, 0xc1);

// {04B3813B-0A23-11d2-B5AC-006097DF5BD4} - For JITting in FTP Shell Extension.
DEFINE_GUID(CLSID_FTPShellExtension, 0x4b3813b, 0xa23, 0x11d2, 0xb5, 0xac, 0x0, 0x60, 0x97, 0xdf, 0x5b, 0xd4);

// {????} - For JITting in HTML Help Feature
DEFINE_GUID(CLSID_IEHelp, 0x45ea75a0L, 0xa269, 0x11d1, 0xb5, 0xbf, 0x00, 0x00, 0xf8, 0x05, 0x15, 0x15);

#define CGID_ShellToolband IID_IDeskBand  //
#endif // _WIN32_IE >= 0x0400
#if (_WIN32_IE >= 0x0400)
DEFINE_GUID(IID_IShellDetails2,         0xb1223e01, 0xb1db, 0x11d0, 0x82, 0xcc, 0x0, 0xc0, 0x4f, 0xd5, 0xae, 0x38);
DEFINE_GUID(IID_IDeskBar,               0xEB0FE173L, 0x1A3A, 0x11D0, 0x89, 0xB3, 0x00, 0xA0, 0xC9, 0x0A, 0x90, 0xAC);
DEFINE_GUID(IID_IDeskBarClient,         0xEB0FE175L, 0x1A3A, 0x11D0, 0x89, 0xB3, 0x00, 0xA0, 0xC9, 0x0A, 0x90, 0xAC);
DEFINE_GUID(IID_IBandSite,              0x4CF504B0L, 0xDE96, 0x11D0, 0x8B, 0x3F, 0x00, 0xA0, 0xC9, 0x11, 0xE8, 0xE5);
DEFINE_GUID(IID_IWinEventHandler,       0xEA5F2D61L, 0xE008, 0x11CF, 0x99, 0xCB, 0x00, 0xC0, 0x4F, 0xD6, 0x44, 0x97);
#define SID_SBandSite IID_IBandSite

#define CGID_BandSite  IID_IBandSite
#define CGID_DeskBar  IID_IDeskBar
#define CGID_DeskBarClient IID_IDeskBarClient

// These can probably move back to shell\inc\shellp.h...
DEFINE_GUID(SID_DefView,                0x6D12FE80, 0x7911, 0x11CF, 0x95, 0x34, 0x00, 0x00, 0xC0, 0x5B, 0xAE, 0x0B);
DEFINE_GUID(CGID_DefView,               0x4af07f10, 0xd231, 0x11d0, 0xb9, 0x42, 0x0, 0xa0, 0xc9, 0x3, 0x12, 0xe1);

DEFINE_GUID(CLSID_MenuBand,             0x5b4dae26, 0xb807, 0x11d0, 0x98, 0x15, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);
#define CLSID_ShellMenu CLSID_MenuBand

// {568804CD-CBD7-11d0-9816-00C04FD91972}
DEFINE_GUID(IID_IMenuBand,                  0x568804cd, 0xcbd7, 0x11d0, 0x98, 0x16, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);

// {EE1F7637-E138-11d1-8379-00C04FD918D0}
DEFINE_GUID(IID_IShellMenu,                 0xee1f7637, 0xe138, 0x11d1, 0x83, 0x79, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xd0);

// {4CA300A1-9B8D-11d1-8B22-00C04FD918D0}
DEFINE_GUID(IID_IShellMenuCallback,         0x4ca300a1, 0x9b8d, 0x11d1, 0x8b, 0x22, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xd0);

// {8278F931-2A3E-11d2-838F-00C04FD918D0}
DEFINE_GUID(CLSID_TrackShellMenu, 
0x8278f931, 0x2a3e, 0x11d2, 0x83, 0x8f, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xd0);

// {8278F932-2A3E-11d2-838F-00C04FD918D0}
DEFINE_GUID(IID_ITrackShellMenu, 
0x8278f932, 0x2a3e, 0x11d2, 0x83, 0x8f, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xd0);

// {0D14E31C-D8C0-11d0-9816-00C04FD91972}
DEFINE_GUID(SID_SMenuBandHandler,           0xd14e31c, 0xd8c0, 0x11d0, 0x98, 0x16, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);

DEFINE_GUID(IID_IAddressBand,           0x106E86E1, 0x52B5, 0x11D0, 0xBF, 0xED, 0x0, 0xAA, 0x0, 0x5B, 0x43, 0x83);

/// AddressEditBox stuff
// {A08C11D1-A228-11d0-825B-00AA005B4383}
DEFINE_GUID(IID_IAddressEditBox, 0xa08c11d1, 0xa228, 0x11d0, 0x82, 0x5b, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x83);
DEFINE_GUID(CLSID_AddressEditBox,0xa08c11d2, 0xa228, 0x11d0, 0x82, 0x5b, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x83);


// {D12F26B1-D90A-11d0-830D-00AA005B4383}
DEFINE_GUID(IID_IRestrict, 0xd12f26b1, 0xd90a, 0x11d0, 0x83, 0xd, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x83);

// {D12F26B2-D90A-11d0-830D-00AA005B4383}
DEFINE_GUID(SID_SRestrictionHandler, 0xd12f26b2, 0xd90a, 0x11d0, 0x83, 0xd, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x83);

// {D12F26B3-D90A-11d0-830D-00AA005B4383}
DEFINE_GUID(RID_RDeskBars, 0xd12f26b3, 0xd90a, 0x11d0, 0x83, 0xd, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x83);

// IShellFolderBand stuff
// {7FE80CC8-C247-11d0-B93A-00A0C90312E1}
DEFINE_GUID(IID_IShellFolderBand, 0x7fe80cc8, 0xc247, 0x11d0, 0xb9, 0x3a, 0x0, 0xa0, 0xc9, 0x3, 0x12, 0xe1);
#define CGID_ShellFolderBand    IID_IShellFolderBand

// favorites band
// {EFA24E61-B078-11d0-89E4-00C04FC9E26E}
DEFINE_GUID(CLSID_FavBand,              0xefa24e61, 0xb078, 0x11d0, 0x89, 0xe4, 0x0, 0xc0, 0x4f, 0xc9, 0xe2, 0x6e);

// history band
// {EFA24E62-B078-11d0-89E4-00C04FC9E26E}
DEFINE_GUID(CLSID_HistBand,              0xefa24e62, 0xb078, 0x11d0, 0x89, 0xe4, 0x0, 0xc0, 0x4f, 0xc9, 0xe2, 0x6e);

// channels band
// {EFA24E63-B078-11d0-89E4-00C04FC9E26E}
DEFINE_GUID(CLSID_ChannelBand,          0xefa24e63, 0xb078, 0x11d0, 0x89, 0xe4, 0x0, 0xc0, 0x4f, 0xc9, 0xe2, 0x6e);

// IQueryCodePage {C7B236CE-EE80-11D0-985F-006008059382}
DEFINE_GUID(IID_IQueryCodePage, 0xC7B236CEL, 0xEE80, 0x11D0, 0x98, 0x5F, 0x00, 0x60, 0x08, 0x05, 0x93, 0x82);

#if (_WIN32_IE >= 0x0500)
// 37A378C0-F82D-11CE-AE65-08002B2E1262
DEFINE_GUID(IID_IShellFolderView, 0x37A378C0L, 0xF82D, 0x11CE, 0xAE, 0x65, 0x08, 0x00, 0x2B, 0x2E, 0x12, 0x62);
// 3D8ECEA0-0242-11CF-AE65-08002B2E1262
DEFINE_GUID(IID_IEnumSFVViews, 0x3D8ECEA0L, 0x0242, 0x11CF, 0xAE, 0x65, 0x08, 0x00, 0x2B, 0x2E, 0x12, 0x62);
// D5E37E20-0257-11CF-AE65-08002B2E1262
DEFINE_GUID(IID_IPersistString, 0xD5E37E20L, 0x0257, 0x11CF, 0xAE, 0x65, 0x08, 0x00, 0x2B, 0x2E, 0x12, 0x62);
// {8210BAC0-C6D2-11cf-89AA-00A0C9054129}
DEFINE_GUID(IID_IDefViewExtInit, 0x8210bac0, 0xc6d2, 0x11cf, 0x89, 0xaa, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29);
// {2CEB7CB2-E64C-11d2-9652-00C04FC30871}
DEFINE_GUID(IID_IDefViewExtInit2, 0x2ceb7cb2, 0xe64c, 0x11d2, 0x96, 0x52, 0x0, 0xc0, 0x4f, 0xc3, 0x8, 0x71);


// 710EB7A0-45ED-11D0-924A-0020AFC7AC4D
DEFINE_GUID(IID_IDefViewFrame, 0x710EB7A0L, 0x45ED, 0x11D0, 0x92, 0x4A, 0x00, 0x20, 0xAF, 0xC7, 0xAC, 0x4D);


// 710EB7A1-45ED-11D0-924A-0020AFC7AC4D
DEFINE_GUID(IID_IDefViewFrame2, 0x710EB7A1L, 0x45ED, 0x11D0, 0x92, 0x4A, 0x00, 0x20, 0xAF, 0xC7, 0xAC, 0x4D);

#endif // _WIN32_IE >= 0x0500

DEFINE_GUID(IID_IExplorerToolbar,       0x8455F0C1L, 0x158F, 0x11D0, 0x89, 0xAE, 0x00, 0xA0, 0xC9, 0x0A, 0x90, 0xAC);
#define SID_SExplorerToolbar IID_IExplorerToolbar

//
//  When the browser is navigating to a document, we call IBC::SetObjectParam
// with "{d4db6850-5385-11d0-89e9-00a0c90a90ac}" so that the DocObject can get
// to the client site while processing IPersistMoniker::Load.
//
#define WSZGUID_OPID_DocObjClientSite L"{d4db6850-5385-11d0-89e9-00a0c90a90ac}"
DEFINE_GUID(OPID_DobObjClientSite,0xd4db6850L, 0x5385, 0x11d0, 0x89, 0xe9, 0x00, 0xa0, 0xc9, 0x0a, 0x90, 0xac);
#endif // _WIN32_IE >= 0x0400

// 0057D0E0-3573-11CF-AE69-08002B2E1262
DEFINE_GUID(VID_LargeIcons, 0x0057D0E0L, 0x3573, 0x11CF, 0xAE, 0x69, 0x08, 0x00, 0x2B, 0x2E, 0x12, 0x62);
// 089000C0-3573-11CF-AE69-08002B2E1262
DEFINE_GUID(VID_SmallIcons, 0x089000C0L, 0x3573, 0x11CF, 0xAE, 0x69, 0x08, 0x00, 0x2B, 0x2E, 0x12, 0x62);
// 0E1FA5E0-3573-11CF-AE69-08002B2E1262
DEFINE_GUID(VID_List      , 0x0E1FA5E0L, 0x3573, 0x11CF, 0xAE, 0x69, 0x08, 0x00, 0x2B, 0x2E, 0x12, 0x62);
// 137E7700-3573-11CF-AE69-08002B2E1262
DEFINE_GUID(VID_Details   , 0x137E7700L, 0x3573, 0x11CF, 0xAE, 0x69, 0x08, 0x00, 0x2B, 0x2E, 0x12, 0x62);
// 5984FFE0-28D4-11CF-AE66-08002B2E1262
#if (_WIN32_IE >= 0x0400)
DEFINE_GUID(VID_WebView, 0x5984FFE0L, 0x28D4, 0x11CF, 0xAE, 0x66, 0x08, 0x00, 0x2B, 0x2E, 0x12, 0x62);
// {BE098140-A513-11d0-A3A4-00C04FD706EC}
DEFINE_GUID(VID_FolderState, 0xbe098140, 0xa513, 0x11d0, 0xa3, 0xa4, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec);
#endif // _WIN32_IE >= 0x0400
// To keep people from breaking, let the old misnamed dudes work
#define IID_IShellExplorer        IID_IWebBrowser
#define DIID_DShellExplorerEvents DIID_DWebBrowserEvents
#define CLSID_ShellExplorer       CLSID_WebBrowser
#define IID_DIExplorer            IID_IWebBrowserApp
#define DIID_DExplorerEvents      DIID_DInternetExplorer
#if (_WIN32_IE >= 0x0400)
#define DIID_DInternetExplorerEvents DIID_DWebBrowserEvents
#define DInternetExplorerEvents DWebBrowserEvents
#define IID_IInternetExplorer IID_IWebBrowserApp

// Thumbnail Guids
DEFINE_GUID(IID_IThumbnail,             0x6d45a930L, 0xf71a, 0x11d0, 0x9e, 0xa7, 0x00, 0x80, 0x5f, 0x71, 0x47, 0x72);
DEFINE_GUID(CLSID_Thumbnail,            0x7487cd30L, 0xf71a, 0x11d0, 0x9e, 0xa7, 0x00, 0x80, 0x5f, 0x71, 0x47, 0x72);
#endif // _WIN32_IE >= 0x0400

#if (_WIN32_IE >= 0x0400)

// 266F5E60-80E6-11CF-A12B-00AA004AE837
DEFINE_GUID(CLSID_CShellTargetFrame, 0x266F5E60L, 0x80E6, 0x11CF, 0xA1, 0x2B, 0x00, 0xAA, 0x00, 0x4A, 0xE8, 0x37);

//B091E540-83E3-11CF-A713-0020AFD79762
DEFINE_GUID(CLSID_FileTypes, 0xB091E540, 0x83E3, 0x11CF, 0xA7,0x13,0x00,0x20,0xAF,0xD7,0x97,0x62);

// CShellList implementation
//
// {FC2A24F0-5876-11d0-97D8-00C04FD91972}
DEFINE_GUID(CLSID_CShellList, 0xfc2a24f0, 0x5876, 0x11d0, 0x97, 0xd8, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);

// {FE5C88F4-587F-11d0-97D8-00C04FD91972}
DEFINE_GUID(IID_IShellList, 0xfe5c88f4, 0x587f, 0x11d0, 0x97, 0xd8, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);

// {FE5C88F5-587F-11d0-97D8-00C04FD91972}
DEFINE_GUID(IID_IShellListSink, 0xfe5c88f5, 0x587f, 0x11d0, 0x97, 0xd8, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);

// {A2B0DD40-CC59-11d0-A3A5-00C04FD706EC}
DEFINE_GUID( CLSID_IESplashScreen, 0xa2b0dd40, 0xcc59, 0x11d0, 0xa3, 0xa5, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec);

// {CB81A3CB-1039-11d1-AB74-00C04FC30936}
DEFINE_GUID( IID_ISplashScreen, 0xcb81a3cb, 0x1039, 0x11d1, 0xab, 0x74, 0x0, 0xc0, 0x4f, 0xc3, 0x9, 0x36);


#endif

#if (_WIN32_IE >= 0x0300)
// {05f6fe1a-ecef-11d0-aae7-00c04fc9b304}
DEFINE_GUID( CLSID_IntDitherer, 0x05f6fe1a, 0xecef, 0x11d0, 0xaa, 0xe7, 0x0, 0xc0, 0x4f, 0xc9, 0xb3, 0x04 );

// {06670ca0-ecef-11d0-aae7-00c04fc9b304}
DEFINE_GUID( IID_IIntDitherer, 0x06670ca0, 0xecef, 0x11d0, 0xaa, 0xe7, 0x0, 0xc0, 0x4f, 0xc9, 0xb3, 0x04 );

#endif // _WIN32_IE >= 0x0300

#if (_WIN32_IE >= 0x0400)
// {52502EE0-EC80-11D0-89AB-00C04FC2972D}
DEFINE_GUID(IID_IActiveDesktopP, 0x52502EE0L, 0xEC80, 0x11D0, 0x89, 0xAB, 0x00, 0xC0, 0x4F, 0xC2, 0x97, 0x2D);

// {B22754E2-4574-11d1-9888-006097DEACF9}
DEFINE_GUID(IID_IADesktopP2, 0xb22754e2, 0x4574, 0x11d1, 0x98, 0x88, 0x0, 0x60, 0x97, 0xde, 0xac, 0xf9);

// {f39a0dc0-9cc8-11d0-a599-00c04fd64433}
DEFINE_GUID(CLSID_CDFView, 0xf39a0dc0L, 0x9cc8, 0x11d0, 0xa5, 0x99, 0x00, 0xc0, 0x4f, 0xd6, 0x44, 0x33);
#endif  // _WIN32_IE >= 0x0400
#if (_WIN32_IE >= 0x0500)
//  MonikerHelper is currently internal only.
// {679d9e36-f8f9-11d2-8deb-00c04f6837d5}
DEFINE_GUID(IID_IMonikerHelper, 0x679d9e36, 0xf8f9, 0x11d2, 0x8d, 0xeb, 0x00, 0xc0, 0x4f, 0x68, 0x37, 0xd5);

// {679d9e37-f8f9-11d2-8deb-00c04f6837d5}
DEFINE_GUID(CLSID_CShellMonikerHelper, 0x679d9e37, 0xf8f9, 0x11d2, 0x8d, 0xeb, 0x00, 0xc0, 0x4f, 0x68, 0x37, 0xd5);

// Define the CLSID for local and net users prop pages
// {D707877E-4D9C-11d2-8784-F6E920524153}
DEFINE_GUID(CLSID_UserPropertyPages, 
0xd707877e, 0x4d9c, 0x11d2, 0x87, 0x84, 0xf6, 0xe9, 0x20, 0x52, 0x41, 0x53);

// IOleCommandTarget arugments for the Network Connections Folder.
// {EAF70CE4-B521-11d1-B550-00C04FD918D0}
DEFINE_GUID(CGID_ConnectionsFolder, 
    0xeaf70ce4, 0xb521, 0x11d1, 0xb5, 0x50, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xd0);

// {C0A651F5-B48B-11d2-B5ED-006097C686F6}
DEFINE_GUID(IID_IShellFolderFilterSite,  0xc0a651f5, 0xb48b, 0x11d2, 0xb5, 0xed, 0x0, 0x60, 0x97, 0xc6, 0x86, 0xf6);
// {9CC22886-DC8E-11d2-B1D0-00C04F8EEB3E}
DEFINE_GUID(IID_IShellFolderFilter,		 0x9cc22886, 0xdc8e, 0x11d2, 0xb1, 0xd0, 0x0, 0xc0, 0x4f, 0x8e, 0xeb, 0x3e);

// {A470F8CF-A1E8-4f65-8335-227475AA5C46}
DEFINE_GUID(CLSID_EncryptionContextMenuHandler, 0xa470f8cf, 0xa1e8, 0x4f65, 0x83, 0x35, 0x22, 0x74, 0x75, 0xAA, 0x5C, 0x46);
#endif // _WIN32_IE >= 0x0500
#endif // _SHLGUIDP_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\xbshlext\sdkp\inc\shldispp.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0279 */
/* at Wed Jan 24 20:18:24 2001
 */
/* Compiler settings for shldispp.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __shldispp_h__
#define __shldispp_h__

/* Forward Declarations */ 

#ifndef __IFolderViewOC_FWD_DEFINED__
#define __IFolderViewOC_FWD_DEFINED__
typedef interface IFolderViewOC IFolderViewOC;
#endif 	/* __IFolderViewOC_FWD_DEFINED__ */


#ifndef __DShellFolderViewEvents_FWD_DEFINED__
#define __DShellFolderViewEvents_FWD_DEFINED__
typedef interface DShellFolderViewEvents DShellFolderViewEvents;
#endif 	/* __DShellFolderViewEvents_FWD_DEFINED__ */


#ifndef __ShellFolderViewOC_FWD_DEFINED__
#define __ShellFolderViewOC_FWD_DEFINED__

#ifdef __cplusplus
typedef class ShellFolderViewOC ShellFolderViewOC;
#else
typedef struct ShellFolderViewOC ShellFolderViewOC;
#endif /* __cplusplus */

#endif 	/* __ShellFolderViewOC_FWD_DEFINED__ */


#ifndef __DFConstraint_FWD_DEFINED__
#define __DFConstraint_FWD_DEFINED__
typedef interface DFConstraint DFConstraint;
#endif 	/* __DFConstraint_FWD_DEFINED__ */


#ifndef __ISearchCommandExt_FWD_DEFINED__
#define __ISearchCommandExt_FWD_DEFINED__
typedef interface ISearchCommandExt ISearchCommandExt;
#endif 	/* __ISearchCommandExt_FWD_DEFINED__ */


#ifndef __FolderItem_FWD_DEFINED__
#define __FolderItem_FWD_DEFINED__
typedef interface FolderItem FolderItem;
#endif 	/* __FolderItem_FWD_DEFINED__ */


#ifndef __FolderItems_FWD_DEFINED__
#define __FolderItems_FWD_DEFINED__
typedef interface FolderItems FolderItems;
#endif 	/* __FolderItems_FWD_DEFINED__ */


#ifndef __FolderItemVerb_FWD_DEFINED__
#define __FolderItemVerb_FWD_DEFINED__
typedef interface FolderItemVerb FolderItemVerb;
#endif 	/* __FolderItemVerb_FWD_DEFINED__ */


#ifndef __FolderItemVerbs_FWD_DEFINED__
#define __FolderItemVerbs_FWD_DEFINED__
typedef interface FolderItemVerbs FolderItemVerbs;
#endif 	/* __FolderItemVerbs_FWD_DEFINED__ */


#ifndef __Folder_FWD_DEFINED__
#define __Folder_FWD_DEFINED__
typedef interface Folder Folder;
#endif 	/* __Folder_FWD_DEFINED__ */


#ifndef __Folder2_FWD_DEFINED__
#define __Folder2_FWD_DEFINED__
typedef interface Folder2 Folder2;
#endif 	/* __Folder2_FWD_DEFINED__ */


#ifndef __FolderItem2_FWD_DEFINED__
#define __FolderItem2_FWD_DEFINED__
typedef interface FolderItem2 FolderItem2;
#endif 	/* __FolderItem2_FWD_DEFINED__ */


#ifndef __ShellFolderItem_FWD_DEFINED__
#define __ShellFolderItem_FWD_DEFINED__

#ifdef __cplusplus
typedef class ShellFolderItem ShellFolderItem;
#else
typedef struct ShellFolderItem ShellFolderItem;
#endif /* __cplusplus */

#endif 	/* __ShellFolderItem_FWD_DEFINED__ */


#ifndef __FolderItems2_FWD_DEFINED__
#define __FolderItems2_FWD_DEFINED__
typedef interface FolderItems2 FolderItems2;
#endif 	/* __FolderItems2_FWD_DEFINED__ */


#ifndef __IShellLinkDual_FWD_DEFINED__
#define __IShellLinkDual_FWD_DEFINED__
typedef interface IShellLinkDual IShellLinkDual;
#endif 	/* __IShellLinkDual_FWD_DEFINED__ */


#ifndef __IShellLinkDual2_FWD_DEFINED__
#define __IShellLinkDual2_FWD_DEFINED__
typedef interface IShellLinkDual2 IShellLinkDual2;
#endif 	/* __IShellLinkDual2_FWD_DEFINED__ */


#ifndef __ShellLinkObject_FWD_DEFINED__
#define __ShellLinkObject_FWD_DEFINED__

#ifdef __cplusplus
typedef class ShellLinkObject ShellLinkObject;
#else
typedef struct ShellLinkObject ShellLinkObject;
#endif /* __cplusplus */

#endif 	/* __ShellLinkObject_FWD_DEFINED__ */


#ifndef __IShellFolderViewDual_FWD_DEFINED__
#define __IShellFolderViewDual_FWD_DEFINED__
typedef interface IShellFolderViewDual IShellFolderViewDual;
#endif 	/* __IShellFolderViewDual_FWD_DEFINED__ */


#ifndef __ShellFolderView_FWD_DEFINED__
#define __ShellFolderView_FWD_DEFINED__

#ifdef __cplusplus
typedef class ShellFolderView ShellFolderView;
#else
typedef struct ShellFolderView ShellFolderView;
#endif /* __cplusplus */

#endif 	/* __ShellFolderView_FWD_DEFINED__ */


#ifndef __IShellDispatch_FWD_DEFINED__
#define __IShellDispatch_FWD_DEFINED__
typedef interface IShellDispatch IShellDispatch;
#endif 	/* __IShellDispatch_FWD_DEFINED__ */


#ifndef __IShellDispatch2_FWD_DEFINED__
#define __IShellDispatch2_FWD_DEFINED__
typedef interface IShellDispatch2 IShellDispatch2;
#endif 	/* __IShellDispatch2_FWD_DEFINED__ */


#ifndef __Shell_FWD_DEFINED__
#define __Shell_FWD_DEFINED__

#ifdef __cplusplus
typedef class Shell Shell;
#else
typedef struct Shell Shell;
#endif /* __cplusplus */

#endif 	/* __Shell_FWD_DEFINED__ */


#ifndef __ShellDispatchInproc_FWD_DEFINED__
#define __ShellDispatchInproc_FWD_DEFINED__

#ifdef __cplusplus
typedef class ShellDispatchInproc ShellDispatchInproc;
#else
typedef struct ShellDispatchInproc ShellDispatchInproc;
#endif /* __cplusplus */

#endif 	/* __ShellDispatchInproc_FWD_DEFINED__ */


#ifndef __WebViewFolderContents_FWD_DEFINED__
#define __WebViewFolderContents_FWD_DEFINED__

#ifdef __cplusplus
typedef class WebViewFolderContents WebViewFolderContents;
#else
typedef struct WebViewFolderContents WebViewFolderContents;
#endif /* __cplusplus */

#endif 	/* __WebViewFolderContents_FWD_DEFINED__ */


#ifndef __DSearchCommandEvents_FWD_DEFINED__
#define __DSearchCommandEvents_FWD_DEFINED__
typedef interface DSearchCommandEvents DSearchCommandEvents;
#endif 	/* __DSearchCommandEvents_FWD_DEFINED__ */


#ifndef __SearchCommand_FWD_DEFINED__
#define __SearchCommand_FWD_DEFINED__

#ifdef __cplusplus
typedef class SearchCommand SearchCommand;
#else
typedef struct SearchCommand SearchCommand;
#endif /* __cplusplus */

#endif 	/* __SearchCommand_FWD_DEFINED__ */


#ifndef __IFileSearchBand_FWD_DEFINED__
#define __IFileSearchBand_FWD_DEFINED__
typedef interface IFileSearchBand IFileSearchBand;
#endif 	/* __IFileSearchBand_FWD_DEFINED__ */


#ifndef __FileSearchBand_FWD_DEFINED__
#define __FileSearchBand_FWD_DEFINED__

#ifdef __cplusplus
typedef class FileSearchBand FileSearchBand;
#else
typedef struct FileSearchBand FileSearchBand;
#endif /* __cplusplus */

#endif 	/* __FileSearchBand_FWD_DEFINED__ */


#ifndef __IAutoComplete_FWD_DEFINED__
#define __IAutoComplete_FWD_DEFINED__
typedef interface IAutoComplete IAutoComplete;
#endif 	/* __IAutoComplete_FWD_DEFINED__ */


#ifndef __IAutoComplete2_FWD_DEFINED__
#define __IAutoComplete2_FWD_DEFINED__
typedef interface IAutoComplete2 IAutoComplete2;
#endif 	/* __IAutoComplete2_FWD_DEFINED__ */


#ifndef __IAsyncOperation_FWD_DEFINED__
#define __IAsyncOperation_FWD_DEFINED__
typedef interface IAsyncOperation IAsyncOperation;
#endif 	/* __IAsyncOperation_FWD_DEFINED__ */


#ifndef __IBrowserFrameOptions_FWD_DEFINED__
#define __IBrowserFrameOptions_FWD_DEFINED__
typedef interface IBrowserFrameOptions IBrowserFrameOptions;
#endif 	/* __IBrowserFrameOptions_FWD_DEFINED__ */


/* header files for imported files */
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_shldispp_0000 */
/* [local] */ 


EXTERN_C const IID IID_IAsyncOperation;
#ifndef _SHLDISP_PUB_H_
#define _SHLDISP_PUB_H_



extern RPC_IF_HANDLE __MIDL_itf_shldispp_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shldispp_0000_v0_0_s_ifspec;


#ifndef __Shell32_LIBRARY_DEFINED__
#define __Shell32_LIBRARY_DEFINED__

/* library Shell32 */
/* [version][lcid][helpstring][uuid] */ 

typedef /* [helpstring][uuid] */  DECLSPEC_UUID("418f4e6a-b903-11d1-b0a6-00c04fc33aa5") 
enum SearchCommandExecuteErrors
    {	SCEE_PATHNOTFOUND	= 1,
	SCEE_MAXFILESFOUND	= SCEE_PATHNOTFOUND + 1,
	SCEE_INDEXSEARCH	= SCEE_MAXFILESFOUND + 1,
	SCEE_CONSTRAINT	= SCEE_INDEXSEARCH + 1,
	SCEE_SCOPEMISMATCH	= SCEE_CONSTRAINT + 1,
	SCEE_CASESENINDEX	= SCEE_SCOPEMISMATCH + 1,
	SCEE_INDEXNOTCOMPLETE	= SCEE_CASESENINDEX + 1
    }	SearchCommandExecuteErrors;





typedef /* [helpstring][uuid] */  DECLSPEC_UUID("35f1a0d0-3e9a-11d2-8499-005345000000") 
enum OfflineFolderStatus
    {	OFS_INACTIVE	= -1,
	OFS_ONLINE	= OFS_INACTIVE + 1,
	OFS_OFFLINE	= OFS_ONLINE + 1,
	OFS_SERVERBACK	= OFS_OFFLINE + 1,
	OFS_DIRTYCACHE	= OFS_SERVERBACK + 1
    }	OfflineFolderStatus;

typedef /* [helpstring][uuid] */  DECLSPEC_UUID("742A99A0-C77E-11D0-A32C-00A0C91EEDBA") 
enum ShellFolderViewOptions
    {	SFVVO_SHOWALLOBJECTS	= 0x1,
	SFVVO_SHOWEXTENSIONS	= 0x2,
	SFVVO_SHOWCOMPCOLOR	= 0x8,
	SFVVO_SHOWSYSFILES	= 0x20,
	SFVVO_WIN95CLASSIC	= 0x40,
	SFVVO_DOUBLECLICKINWEBVIEW	= 0x80,
	SFVVO_DESKTOPHTML	= 0x200
    }	ShellFolderViewOptions;

typedef /* [helpstring][uuid] */  DECLSPEC_UUID("CA31EA20-48D0-11CF-8350-444553540000") 
enum ShellSpecialFolderConstants
    {	ssfDESKTOP	= 0,
	ssfPROGRAMS	= 0x2,
	ssfCONTROLS	= 0x3,
	ssfPRINTERS	= 0x4,
	ssfPERSONAL	= 0x5,
	ssfFAVORITES	= 0x6,
	ssfSTARTUP	= 0x7,
	ssfRECENT	= 0x8,
	ssfSENDTO	= 0x9,
	ssfBITBUCKET	= 0xa,
	ssfSTARTMENU	= 0xb,
	ssfDESKTOPDIRECTORY	= 0x10,
	ssfDRIVES	= 0x11,
	ssfNETWORK	= 0x12,
	ssfNETHOOD	= 0x13,
	ssfFONTS	= 0x14,
	ssfTEMPLATES	= 0x15,
	ssfCOMMONSTARTMENU	= 0x16,
	ssfCOMMONPROGRAMS	= 0x17,
	ssfCOMMONSTARTUP	= 0x18,
	ssfCOMMONDESKTOPDIR	= 0x19,
	ssfAPPDATA	= 0x1a,
	ssfPRINTHOOD	= 0x1b,
	ssfLOCALAPPDATA	= 0x1c,
	ssfALTSTARTUP	= 0x1d,
	ssfCOMMONALTSTARTUP	= 0x1e,
	ssfCOMMONFAVORITES	= 0x1f,
	ssfINTERNETCACHE	= 0x20,
	ssfCOOKIES	= 0x21,
	ssfHISTORY	= 0x22,
	ssfCOMMONAPPDATA	= 0x23,
	ssfWINDOWS	= 0x24,
	ssfSYSTEM	= 0x25,
	ssfPROGRAMFILES	= 0x26,
	ssfMYPICTURES	= 0x27,
	ssfPROFILE	= 0x28,
	ssfSYSTEMx86	= 0x29,
	ssfPROGRAMFILESx86	= 0x30
    }	ShellSpecialFolderConstants;


EXTERN_C const IID LIBID_Shell32;

#ifndef __IFolderViewOC_INTERFACE_DEFINED__
#define __IFolderViewOC_INTERFACE_DEFINED__

/* interface IFolderViewOC */
/* [object][dual][oleautomation][hidden][helpcontext][helpstring][uuid] */ 


EXTERN_C const IID IID_IFolderViewOC;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9BA05970-F6A8-11CF-A442-00A0C90A8F39")
    IFolderViewOC : public IDispatch
    {
    public:
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE SetFolderView( 
            /* [in] */ IDispatch __RPC_FAR *pdisp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFolderViewOCVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IFolderViewOC __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IFolderViewOC __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IFolderViewOC __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IFolderViewOC __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IFolderViewOC __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IFolderViewOC __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IFolderViewOC __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFolderView )( 
            IFolderViewOC __RPC_FAR * This,
            /* [in] */ IDispatch __RPC_FAR *pdisp);
        
        END_INTERFACE
    } IFolderViewOCVtbl;

    interface IFolderViewOC
    {
        CONST_VTBL struct IFolderViewOCVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFolderViewOC_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFolderViewOC_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFolderViewOC_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFolderViewOC_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFolderViewOC_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFolderViewOC_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFolderViewOC_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFolderViewOC_SetFolderView(This,pdisp)	\
    (This)->lpVtbl -> SetFolderView(This,pdisp)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IFolderViewOC_SetFolderView_Proxy( 
    IFolderViewOC __RPC_FAR * This,
    /* [in] */ IDispatch __RPC_FAR *pdisp);


void __RPC_STUB IFolderViewOC_SetFolderView_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFolderViewOC_INTERFACE_DEFINED__ */


#ifndef __DShellFolderViewEvents_DISPINTERFACE_DEFINED__
#define __DShellFolderViewEvents_DISPINTERFACE_DEFINED__

/* dispinterface DShellFolderViewEvents */
/* [helpstring][uuid] */ 


EXTERN_C const IID DIID_DShellFolderViewEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("62112AA2-EBE4-11cf-A5FB-0020AFE7292D")
    DShellFolderViewEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct DShellFolderViewEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            DShellFolderViewEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            DShellFolderViewEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            DShellFolderViewEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            DShellFolderViewEvents __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            DShellFolderViewEvents __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            DShellFolderViewEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            DShellFolderViewEvents __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } DShellFolderViewEventsVtbl;

    interface DShellFolderViewEvents
    {
        CONST_VTBL struct DShellFolderViewEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define DShellFolderViewEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define DShellFolderViewEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define DShellFolderViewEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define DShellFolderViewEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define DShellFolderViewEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define DShellFolderViewEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define DShellFolderViewEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __DShellFolderViewEvents_DISPINTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_ShellFolderViewOC;

#ifdef __cplusplus

class DECLSPEC_UUID("9BA05971-F6A8-11CF-A442-00A0C90A8F39")
ShellFolderViewOC;
#endif

#ifndef __DFConstraint_INTERFACE_DEFINED__
#define __DFConstraint_INTERFACE_DEFINED__

/* interface DFConstraint */
/* [object][dual][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_DFConstraint;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4a3df050-23bd-11d2-939f-00a0c91eedba")
    DFConstraint : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *pbs) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Value( 
            /* [retval][out] */ VARIANT __RPC_FAR *pv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct DFConstraintVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            DFConstraint __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            DFConstraint __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            DFConstraint __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            DFConstraint __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            DFConstraint __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            DFConstraint __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            DFConstraint __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            DFConstraint __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbs);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Value )( 
            DFConstraint __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pv);
        
        END_INTERFACE
    } DFConstraintVtbl;

    interface DFConstraint
    {
        CONST_VTBL struct DFConstraintVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define DFConstraint_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define DFConstraint_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define DFConstraint_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define DFConstraint_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define DFConstraint_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define DFConstraint_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define DFConstraint_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define DFConstraint_get_Name(This,pbs)	\
    (This)->lpVtbl -> get_Name(This,pbs)

#define DFConstraint_get_Value(This,pv)	\
    (This)->lpVtbl -> get_Value(This,pv)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE DFConstraint_get_Name_Proxy( 
    DFConstraint __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbs);


void __RPC_STUB DFConstraint_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE DFConstraint_get_Value_Proxy( 
    DFConstraint __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pv);


void __RPC_STUB DFConstraint_get_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __DFConstraint_INTERFACE_DEFINED__ */


#ifndef __ISearchCommandExt_INTERFACE_DEFINED__
#define __ISearchCommandExt_INTERFACE_DEFINED__

/* interface ISearchCommandExt */
/* [object][oleautomation][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ISearchCommandExt;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1D2EFD50-75CE-11d1-B75A-00A0C90564FE")
    ISearchCommandExt : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ClearResults( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE NavigateToSearchResults( void) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ProgressText( 
            /* [retval][out] */ BSTR __RPC_FAR *pbs) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SaveSearch( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetErrorInfo( 
            /* [out] */ BSTR __RPC_FAR *pbs,
            /* [retval][out] */ int __RPC_FAR *phr) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SearchFor( 
            /* [in] */ int iFor) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetScopeInfo( 
            /* [in] */ BSTR bsScope,
            /* [out] */ int __RPC_FAR *pdwScopeInfo) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RestoreSavedSearch( 
            /* [in] */ VARIANT __RPC_FAR *pvarFile) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Execute( 
            /* [optional][in] */ VARIANT __RPC_FAR *RecordsAffected,
            /* [optional][in] */ VARIANT __RPC_FAR *Parameters,
            /* [optional][in] */ long Options) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AddConstraint( 
            /* [in] */ BSTR Name,
            /* [in] */ VARIANT Value) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetNextConstraint( 
            /* [in] */ VARIANT_BOOL fReset,
            /* [retval][out] */ DFConstraint __RPC_FAR *__RPC_FAR *ppdfc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISearchCommandExtVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISearchCommandExt __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISearchCommandExt __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISearchCommandExt __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ISearchCommandExt __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ISearchCommandExt __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ISearchCommandExt __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ISearchCommandExt __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ClearResults )( 
            ISearchCommandExt __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NavigateToSearchResults )( 
            ISearchCommandExt __RPC_FAR * This);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ProgressText )( 
            ISearchCommandExt __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbs);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveSearch )( 
            ISearchCommandExt __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetErrorInfo )( 
            ISearchCommandExt __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbs,
            /* [retval][out] */ int __RPC_FAR *phr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SearchFor )( 
            ISearchCommandExt __RPC_FAR * This,
            /* [in] */ int iFor);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetScopeInfo )( 
            ISearchCommandExt __RPC_FAR * This,
            /* [in] */ BSTR bsScope,
            /* [out] */ int __RPC_FAR *pdwScopeInfo);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RestoreSavedSearch )( 
            ISearchCommandExt __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *pvarFile);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Execute )( 
            ISearchCommandExt __RPC_FAR * This,
            /* [optional][in] */ VARIANT __RPC_FAR *RecordsAffected,
            /* [optional][in] */ VARIANT __RPC_FAR *Parameters,
            /* [optional][in] */ long Options);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddConstraint )( 
            ISearchCommandExt __RPC_FAR * This,
            /* [in] */ BSTR Name,
            /* [in] */ VARIANT Value);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNextConstraint )( 
            ISearchCommandExt __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL fReset,
            /* [retval][out] */ DFConstraint __RPC_FAR *__RPC_FAR *ppdfc);
        
        END_INTERFACE
    } ISearchCommandExtVtbl;

    interface ISearchCommandExt
    {
        CONST_VTBL struct ISearchCommandExtVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISearchCommandExt_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISearchCommandExt_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISearchCommandExt_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISearchCommandExt_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISearchCommandExt_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISearchCommandExt_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISearchCommandExt_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISearchCommandExt_ClearResults(This)	\
    (This)->lpVtbl -> ClearResults(This)

#define ISearchCommandExt_NavigateToSearchResults(This)	\
    (This)->lpVtbl -> NavigateToSearchResults(This)

#define ISearchCommandExt_get_ProgressText(This,pbs)	\
    (This)->lpVtbl -> get_ProgressText(This,pbs)

#define ISearchCommandExt_SaveSearch(This)	\
    (This)->lpVtbl -> SaveSearch(This)

#define ISearchCommandExt_GetErrorInfo(This,pbs,phr)	\
    (This)->lpVtbl -> GetErrorInfo(This,pbs,phr)

#define ISearchCommandExt_SearchFor(This,iFor)	\
    (This)->lpVtbl -> SearchFor(This,iFor)

#define ISearchCommandExt_GetScopeInfo(This,bsScope,pdwScopeInfo)	\
    (This)->lpVtbl -> GetScopeInfo(This,bsScope,pdwScopeInfo)

#define ISearchCommandExt_RestoreSavedSearch(This,pvarFile)	\
    (This)->lpVtbl -> RestoreSavedSearch(This,pvarFile)

#define ISearchCommandExt_Execute(This,RecordsAffected,Parameters,Options)	\
    (This)->lpVtbl -> Execute(This,RecordsAffected,Parameters,Options)

#define ISearchCommandExt_AddConstraint(This,Name,Value)	\
    (This)->lpVtbl -> AddConstraint(This,Name,Value)

#define ISearchCommandExt_GetNextConstraint(This,fReset,ppdfc)	\
    (This)->lpVtbl -> GetNextConstraint(This,fReset,ppdfc)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISearchCommandExt_ClearResults_Proxy( 
    ISearchCommandExt __RPC_FAR * This);


void __RPC_STUB ISearchCommandExt_ClearResults_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISearchCommandExt_NavigateToSearchResults_Proxy( 
    ISearchCommandExt __RPC_FAR * This);


void __RPC_STUB ISearchCommandExt_NavigateToSearchResults_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ISearchCommandExt_get_ProgressText_Proxy( 
    ISearchCommandExt __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbs);


void __RPC_STUB ISearchCommandExt_get_ProgressText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISearchCommandExt_SaveSearch_Proxy( 
    ISearchCommandExt __RPC_FAR * This);


void __RPC_STUB ISearchCommandExt_SaveSearch_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISearchCommandExt_GetErrorInfo_Proxy( 
    ISearchCommandExt __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbs,
    /* [retval][out] */ int __RPC_FAR *phr);


void __RPC_STUB ISearchCommandExt_GetErrorInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISearchCommandExt_SearchFor_Proxy( 
    ISearchCommandExt __RPC_FAR * This,
    /* [in] */ int iFor);


void __RPC_STUB ISearchCommandExt_SearchFor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISearchCommandExt_GetScopeInfo_Proxy( 
    ISearchCommandExt __RPC_FAR * This,
    /* [in] */ BSTR bsScope,
    /* [out] */ int __RPC_FAR *pdwScopeInfo);


void __RPC_STUB ISearchCommandExt_GetScopeInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISearchCommandExt_RestoreSavedSearch_Proxy( 
    ISearchCommandExt __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *pvarFile);


void __RPC_STUB ISearchCommandExt_RestoreSavedSearch_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISearchCommandExt_Execute_Proxy( 
    ISearchCommandExt __RPC_FAR * This,
    /* [optional][in] */ VARIANT __RPC_FAR *RecordsAffected,
    /* [optional][in] */ VARIANT __RPC_FAR *Parameters,
    /* [optional][in] */ long Options);


void __RPC_STUB ISearchCommandExt_Execute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISearchCommandExt_AddConstraint_Proxy( 
    ISearchCommandExt __RPC_FAR * This,
    /* [in] */ BSTR Name,
    /* [in] */ VARIANT Value);


void __RPC_STUB ISearchCommandExt_AddConstraint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISearchCommandExt_GetNextConstraint_Proxy( 
    ISearchCommandExt __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL fReset,
    /* [retval][out] */ DFConstraint __RPC_FAR *__RPC_FAR *ppdfc);


void __RPC_STUB ISearchCommandExt_GetNextConstraint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISearchCommandExt_INTERFACE_DEFINED__ */


#ifndef __FolderItem_INTERFACE_DEFINED__
#define __FolderItem_INTERFACE_DEFINED__

/* interface FolderItem */
/* [object][dual][oleautomation][helpstring][uuid] */ 

typedef /* [unique] */ FolderItem __RPC_FAR *LPFOLDERITEM;


EXTERN_C const IID IID_FolderItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FAC32C80-CBE4-11CE-8350-444553540000")
    FolderItem : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Application( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *pbs) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Name( 
            /* [in] */ BSTR bs) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Path( 
            /* [retval][out] */ BSTR __RPC_FAR *pbs) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_GetLink( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_GetFolder( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_IsLink( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_IsFolder( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_IsFileSystem( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_IsBrowsable( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ModifyDate( 
            /* [retval][out] */ DATE __RPC_FAR *pdt) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_ModifyDate( 
            /* [in] */ DATE dt) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Size( 
            /* [retval][out] */ LONG __RPC_FAR *pul) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ BSTR __RPC_FAR *pbs) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Verbs( 
            /* [retval][out] */ FolderItemVerbs __RPC_FAR *__RPC_FAR *ppfic) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE InvokeVerb( 
            /* [optional][in] */ VARIANT vVerb) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct FolderItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            FolderItem __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            FolderItem __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            FolderItem __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            FolderItem __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            FolderItem __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            FolderItem __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            FolderItem __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            FolderItem __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            FolderItem __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            FolderItem __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbs);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Name )( 
            FolderItem __RPC_FAR * This,
            /* [in] */ BSTR bs);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Path )( 
            FolderItem __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbs);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_GetLink )( 
            FolderItem __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_GetFolder )( 
            FolderItem __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IsLink )( 
            FolderItem __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IsFolder )( 
            FolderItem __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IsFileSystem )( 
            FolderItem __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IsBrowsable )( 
            FolderItem __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ModifyDate )( 
            FolderItem __RPC_FAR * This,
            /* [retval][out] */ DATE __RPC_FAR *pdt);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ModifyDate )( 
            FolderItem __RPC_FAR * This,
            /* [in] */ DATE dt);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Size )( 
            FolderItem __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *pul);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Type )( 
            FolderItem __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbs);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Verbs )( 
            FolderItem __RPC_FAR * This,
            /* [retval][out] */ FolderItemVerbs __RPC_FAR *__RPC_FAR *ppfic);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InvokeVerb )( 
            FolderItem __RPC_FAR * This,
            /* [optional][in] */ VARIANT vVerb);
        
        END_INTERFACE
    } FolderItemVtbl;

    interface FolderItem
    {
        CONST_VTBL struct FolderItemVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define FolderItem_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define FolderItem_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define FolderItem_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define FolderItem_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define FolderItem_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define FolderItem_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define FolderItem_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define FolderItem_get_Application(This,ppid)	\
    (This)->lpVtbl -> get_Application(This,ppid)

#define FolderItem_get_Parent(This,ppid)	\
    (This)->lpVtbl -> get_Parent(This,ppid)

#define FolderItem_get_Name(This,pbs)	\
    (This)->lpVtbl -> get_Name(This,pbs)

#define FolderItem_put_Name(This,bs)	\
    (This)->lpVtbl -> put_Name(This,bs)

#define FolderItem_get_Path(This,pbs)	\
    (This)->lpVtbl -> get_Path(This,pbs)

#define FolderItem_get_GetLink(This,ppid)	\
    (This)->lpVtbl -> get_GetLink(This,ppid)

#define FolderItem_get_GetFolder(This,ppid)	\
    (This)->lpVtbl -> get_GetFolder(This,ppid)

#define FolderItem_get_IsLink(This,pb)	\
    (This)->lpVtbl -> get_IsLink(This,pb)

#define FolderItem_get_IsFolder(This,pb)	\
    (This)->lpVtbl -> get_IsFolder(This,pb)

#define FolderItem_get_IsFileSystem(This,pb)	\
    (This)->lpVtbl -> get_IsFileSystem(This,pb)

#define FolderItem_get_IsBrowsable(This,pb)	\
    (This)->lpVtbl -> get_IsBrowsable(This,pb)

#define FolderItem_get_ModifyDate(This,pdt)	\
    (This)->lpVtbl -> get_ModifyDate(This,pdt)

#define FolderItem_put_ModifyDate(This,dt)	\
    (This)->lpVtbl -> put_ModifyDate(This,dt)

#define FolderItem_get_Size(This,pul)	\
    (This)->lpVtbl -> get_Size(This,pul)

#define FolderItem_get_Type(This,pbs)	\
    (This)->lpVtbl -> get_Type(This,pbs)

#define FolderItem_Verbs(This,ppfic)	\
    (This)->lpVtbl -> Verbs(This,ppfic)

#define FolderItem_InvokeVerb(This,vVerb)	\
    (This)->lpVtbl -> InvokeVerb(This,vVerb)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE FolderItem_get_Application_Proxy( 
    FolderItem __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);


void __RPC_STUB FolderItem_get_Application_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE FolderItem_get_Parent_Proxy( 
    FolderItem __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);


void __RPC_STUB FolderItem_get_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE FolderItem_get_Name_Proxy( 
    FolderItem __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbs);


void __RPC_STUB FolderItem_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE FolderItem_put_Name_Proxy( 
    FolderItem __RPC_FAR * This,
    /* [in] */ BSTR bs);


void __RPC_STUB FolderItem_put_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE FolderItem_get_Path_Proxy( 
    FolderItem __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbs);


void __RPC_STUB FolderItem_get_Path_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE FolderItem_get_GetLink_Proxy( 
    FolderItem __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);


void __RPC_STUB FolderItem_get_GetLink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE FolderItem_get_GetFolder_Proxy( 
    FolderItem __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);


void __RPC_STUB FolderItem_get_GetFolder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE FolderItem_get_IsLink_Proxy( 
    FolderItem __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb);


void __RPC_STUB FolderItem_get_IsLink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE FolderItem_get_IsFolder_Proxy( 
    FolderItem __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb);


void __RPC_STUB FolderItem_get_IsFolder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE FolderItem_get_IsFileSystem_Proxy( 
    FolderItem __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb);


void __RPC_STUB FolderItem_get_IsFileSystem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE FolderItem_get_IsBrowsable_Proxy( 
    FolderItem __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb);


void __RPC_STUB FolderItem_get_IsBrowsable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE FolderItem_get_ModifyDate_Proxy( 
    FolderItem __RPC_FAR * This,
    /* [retval][out] */ DATE __RPC_FAR *pdt);


void __RPC_STUB FolderItem_get_ModifyDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE FolderItem_put_ModifyDate_Proxy( 
    FolderItem __RPC_FAR * This,
    /* [in] */ DATE dt);


void __RPC_STUB FolderItem_put_ModifyDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE FolderItem_get_Size_Proxy( 
    FolderItem __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *pul);


void __RPC_STUB FolderItem_get_Size_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE FolderItem_get_Type_Proxy( 
    FolderItem __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbs);


void __RPC_STUB FolderItem_get_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE FolderItem_Verbs_Proxy( 
    FolderItem __RPC_FAR * This,
    /* [retval][out] */ FolderItemVerbs __RPC_FAR *__RPC_FAR *ppfic);


void __RPC_STUB FolderItem_Verbs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE FolderItem_InvokeVerb_Proxy( 
    FolderItem __RPC_FAR * This,
    /* [optional][in] */ VARIANT vVerb);


void __RPC_STUB FolderItem_InvokeVerb_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __FolderItem_INTERFACE_DEFINED__ */


#ifndef __FolderItems_INTERFACE_DEFINED__
#define __FolderItems_INTERFACE_DEFINED__

/* interface FolderItems */
/* [object][dual][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_FolderItems;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("744129E0-CBE5-11CE-8350-444553540000")
    FolderItems : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *plCount) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Application( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [optional][in] */ VARIANT index,
            /* [retval][out] */ FolderItem __RPC_FAR *__RPC_FAR *ppid) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE _NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct FolderItemsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            FolderItems __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            FolderItems __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            FolderItems __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            FolderItems __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            FolderItems __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            FolderItems __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            FolderItems __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            FolderItems __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plCount);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            FolderItems __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            FolderItems __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Item )( 
            FolderItems __RPC_FAR * This,
            /* [optional][in] */ VARIANT index,
            /* [retval][out] */ FolderItem __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *_NewEnum )( 
            FolderItems __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk);
        
        END_INTERFACE
    } FolderItemsVtbl;

    interface FolderItems
    {
        CONST_VTBL struct FolderItemsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define FolderItems_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define FolderItems_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define FolderItems_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define FolderItems_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define FolderItems_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define FolderItems_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define FolderItems_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define FolderItems_get_Count(This,plCount)	\
    (This)->lpVtbl -> get_Count(This,plCount)

#define FolderItems_get_Application(This,ppid)	\
    (This)->lpVtbl -> get_Application(This,ppid)

#define FolderItems_get_Parent(This,ppid)	\
    (This)->lpVtbl -> get_Parent(This,ppid)

#define FolderItems_Item(This,index,ppid)	\
    (This)->lpVtbl -> Item(This,index,ppid)

#define FolderItems__NewEnum(This,ppunk)	\
    (This)->lpVtbl -> _NewEnum(This,ppunk)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE FolderItems_get_Count_Proxy( 
    FolderItems __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plCount);


void __RPC_STUB FolderItems_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE FolderItems_get_Application_Proxy( 
    FolderItems __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);


void __RPC_STUB FolderItems_get_Application_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE FolderItems_get_Parent_Proxy( 
    FolderItems __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);


void __RPC_STUB FolderItems_get_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE FolderItems_Item_Proxy( 
    FolderItems __RPC_FAR * This,
    /* [optional][in] */ VARIANT index,
    /* [retval][out] */ FolderItem __RPC_FAR *__RPC_FAR *ppid);


void __RPC_STUB FolderItems_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE FolderItems__NewEnum_Proxy( 
    FolderItems __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk);


void __RPC_STUB FolderItems__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __FolderItems_INTERFACE_DEFINED__ */


#ifndef __FolderItemVerb_INTERFACE_DEFINED__
#define __FolderItemVerb_INTERFACE_DEFINED__

/* interface FolderItemVerb */
/* [object][dual][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_FolderItemVerb;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("08EC3E00-50B0-11CF-960C-0080C7F4EE85")
    FolderItemVerb : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Application( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *pbs) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DoIt( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct FolderItemVerbVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            FolderItemVerb __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            FolderItemVerb __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            FolderItemVerb __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            FolderItemVerb __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            FolderItemVerb __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            FolderItemVerb __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            FolderItemVerb __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            FolderItemVerb __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            FolderItemVerb __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            FolderItemVerb __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbs);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DoIt )( 
            FolderItemVerb __RPC_FAR * This);
        
        END_INTERFACE
    } FolderItemVerbVtbl;

    interface FolderItemVerb
    {
        CONST_VTBL struct FolderItemVerbVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define FolderItemVerb_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define FolderItemVerb_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define FolderItemVerb_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define FolderItemVerb_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define FolderItemVerb_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define FolderItemVerb_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define FolderItemVerb_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define FolderItemVerb_get_Application(This,ppid)	\
    (This)->lpVtbl -> get_Application(This,ppid)

#define FolderItemVerb_get_Parent(This,ppid)	\
    (This)->lpVtbl -> get_Parent(This,ppid)

#define FolderItemVerb_get_Name(This,pbs)	\
    (This)->lpVtbl -> get_Name(This,pbs)

#define FolderItemVerb_DoIt(This)	\
    (This)->lpVtbl -> DoIt(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE FolderItemVerb_get_Application_Proxy( 
    FolderItemVerb __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);


void __RPC_STUB FolderItemVerb_get_Application_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE FolderItemVerb_get_Parent_Proxy( 
    FolderItemVerb __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);


void __RPC_STUB FolderItemVerb_get_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE FolderItemVerb_get_Name_Proxy( 
    FolderItemVerb __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbs);


void __RPC_STUB FolderItemVerb_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE FolderItemVerb_DoIt_Proxy( 
    FolderItemVerb __RPC_FAR * This);


void __RPC_STUB FolderItemVerb_DoIt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __FolderItemVerb_INTERFACE_DEFINED__ */


#ifndef __FolderItemVerbs_INTERFACE_DEFINED__
#define __FolderItemVerbs_INTERFACE_DEFINED__

/* interface FolderItemVerbs */
/* [object][dual][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_FolderItemVerbs;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1F8352C0-50B0-11CF-960C-0080C7F4EE85")
    FolderItemVerbs : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *plCount) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Application( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [optional][in] */ VARIANT index,
            /* [retval][out] */ FolderItemVerb __RPC_FAR *__RPC_FAR *ppid) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE _NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct FolderItemVerbsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            FolderItemVerbs __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            FolderItemVerbs __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            FolderItemVerbs __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            FolderItemVerbs __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            FolderItemVerbs __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            FolderItemVerbs __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            FolderItemVerbs __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            FolderItemVerbs __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plCount);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            FolderItemVerbs __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            FolderItemVerbs __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Item )( 
            FolderItemVerbs __RPC_FAR * This,
            /* [optional][in] */ VARIANT index,
            /* [retval][out] */ FolderItemVerb __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *_NewEnum )( 
            FolderItemVerbs __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk);
        
        END_INTERFACE
    } FolderItemVerbsVtbl;

    interface FolderItemVerbs
    {
        CONST_VTBL struct FolderItemVerbsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define FolderItemVerbs_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define FolderItemVerbs_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define FolderItemVerbs_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define FolderItemVerbs_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define FolderItemVerbs_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define FolderItemVerbs_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define FolderItemVerbs_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define FolderItemVerbs_get_Count(This,plCount)	\
    (This)->lpVtbl -> get_Count(This,plCount)

#define FolderItemVerbs_get_Application(This,ppid)	\
    (This)->lpVtbl -> get_Application(This,ppid)

#define FolderItemVerbs_get_Parent(This,ppid)	\
    (This)->lpVtbl -> get_Parent(This,ppid)

#define FolderItemVerbs_Item(This,index,ppid)	\
    (This)->lpVtbl -> Item(This,index,ppid)

#define FolderItemVerbs__NewEnum(This,ppunk)	\
    (This)->lpVtbl -> _NewEnum(This,ppunk)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE FolderItemVerbs_get_Count_Proxy( 
    FolderItemVerbs __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plCount);


void __RPC_STUB FolderItemVerbs_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE FolderItemVerbs_get_Application_Proxy( 
    FolderItemVerbs __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);


void __RPC_STUB FolderItemVerbs_get_Application_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE FolderItemVerbs_get_Parent_Proxy( 
    FolderItemVerbs __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);


void __RPC_STUB FolderItemVerbs_get_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE FolderItemVerbs_Item_Proxy( 
    FolderItemVerbs __RPC_FAR * This,
    /* [optional][in] */ VARIANT index,
    /* [retval][out] */ FolderItemVerb __RPC_FAR *__RPC_FAR *ppid);


void __RPC_STUB FolderItemVerbs_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE FolderItemVerbs__NewEnum_Proxy( 
    FolderItemVerbs __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk);


void __RPC_STUB FolderItemVerbs__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __FolderItemVerbs_INTERFACE_DEFINED__ */


#ifndef __Folder_INTERFACE_DEFINED__
#define __Folder_INTERFACE_DEFINED__

/* interface Folder */
/* [object][dual][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_Folder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BBCBDE60-C3FF-11CE-8350-444553540000")
    Folder : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Title( 
            /* [retval][out] */ BSTR __RPC_FAR *pbs) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Application( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ParentFolder( 
            /* [retval][out] */ Folder __RPC_FAR *__RPC_FAR *ppsf) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Items( 
            /* [retval][out] */ FolderItems __RPC_FAR *__RPC_FAR *ppid) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ParseName( 
            /* [in] */ BSTR bName,
            /* [retval][out] */ FolderItem __RPC_FAR *__RPC_FAR *ppid) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE NewFolder( 
            /* [in] */ BSTR bName,
            /* [optional][in] */ VARIANT vOptions) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE MoveHere( 
            /* [in] */ VARIANT vItem,
            /* [optional][in] */ VARIANT vOptions) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CopyHere( 
            /* [in] */ VARIANT vItem,
            /* [optional][in] */ VARIANT vOptions) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDetailsOf( 
            /* [in] */ VARIANT vItem,
            /* [in] */ int iColumn,
            /* [retval][out] */ BSTR __RPC_FAR *pbs) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct FolderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            Folder __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            Folder __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            Folder __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            Folder __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            Folder __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            Folder __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            Folder __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Title )( 
            Folder __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbs);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            Folder __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            Folder __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ParentFolder )( 
            Folder __RPC_FAR * This,
            /* [retval][out] */ Folder __RPC_FAR *__RPC_FAR *ppsf);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Items )( 
            Folder __RPC_FAR * This,
            /* [retval][out] */ FolderItems __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ParseName )( 
            Folder __RPC_FAR * This,
            /* [in] */ BSTR bName,
            /* [retval][out] */ FolderItem __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NewFolder )( 
            Folder __RPC_FAR * This,
            /* [in] */ BSTR bName,
            /* [optional][in] */ VARIANT vOptions);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveHere )( 
            Folder __RPC_FAR * This,
            /* [in] */ VARIANT vItem,
            /* [optional][in] */ VARIANT vOptions);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CopyHere )( 
            Folder __RPC_FAR * This,
            /* [in] */ VARIANT vItem,
            /* [optional][in] */ VARIANT vOptions);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDetailsOf )( 
            Folder __RPC_FAR * This,
            /* [in] */ VARIANT vItem,
            /* [in] */ int iColumn,
            /* [retval][out] */ BSTR __RPC_FAR *pbs);
        
        END_INTERFACE
    } FolderVtbl;

    interface Folder
    {
        CONST_VTBL struct FolderVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define Folder_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define Folder_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define Folder_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define Folder_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define Folder_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define Folder_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define Folder_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define Folder_get_Title(This,pbs)	\
    (This)->lpVtbl -> get_Title(This,pbs)

#define Folder_get_Application(This,ppid)	\
    (This)->lpVtbl -> get_Application(This,ppid)

#define Folder_get_Parent(This,ppid)	\
    (This)->lpVtbl -> get_Parent(This,ppid)

#define Folder_get_ParentFolder(This,ppsf)	\
    (This)->lpVtbl -> get_ParentFolder(This,ppsf)

#define Folder_Items(This,ppid)	\
    (This)->lpVtbl -> Items(This,ppid)

#define Folder_ParseName(This,bName,ppid)	\
    (This)->lpVtbl -> ParseName(This,bName,ppid)

#define Folder_NewFolder(This,bName,vOptions)	\
    (This)->lpVtbl -> NewFolder(This,bName,vOptions)

#define Folder_MoveHere(This,vItem,vOptions)	\
    (This)->lpVtbl -> MoveHere(This,vItem,vOptions)

#define Folder_CopyHere(This,vItem,vOptions)	\
    (This)->lpVtbl -> CopyHere(This,vItem,vOptions)

#define Folder_GetDetailsOf(This,vItem,iColumn,pbs)	\
    (This)->lpVtbl -> GetDetailsOf(This,vItem,iColumn,pbs)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE Folder_get_Title_Proxy( 
    Folder __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbs);


void __RPC_STUB Folder_get_Title_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE Folder_get_Application_Proxy( 
    Folder __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);


void __RPC_STUB Folder_get_Application_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE Folder_get_Parent_Proxy( 
    Folder __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);


void __RPC_STUB Folder_get_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE Folder_get_ParentFolder_Proxy( 
    Folder __RPC_FAR * This,
    /* [retval][out] */ Folder __RPC_FAR *__RPC_FAR *ppsf);


void __RPC_STUB Folder_get_ParentFolder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE Folder_Items_Proxy( 
    Folder __RPC_FAR * This,
    /* [retval][out] */ FolderItems __RPC_FAR *__RPC_FAR *ppid);


void __RPC_STUB Folder_Items_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE Folder_ParseName_Proxy( 
    Folder __RPC_FAR * This,
    /* [in] */ BSTR bName,
    /* [retval][out] */ FolderItem __RPC_FAR *__RPC_FAR *ppid);


void __RPC_STUB Folder_ParseName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE Folder_NewFolder_Proxy( 
    Folder __RPC_FAR * This,
    /* [in] */ BSTR bName,
    /* [optional][in] */ VARIANT vOptions);


void __RPC_STUB Folder_NewFolder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE Folder_MoveHere_Proxy( 
    Folder __RPC_FAR * This,
    /* [in] */ VARIANT vItem,
    /* [optional][in] */ VARIANT vOptions);


void __RPC_STUB Folder_MoveHere_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE Folder_CopyHere_Proxy( 
    Folder __RPC_FAR * This,
    /* [in] */ VARIANT vItem,
    /* [optional][in] */ VARIANT vOptions);


void __RPC_STUB Folder_CopyHere_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE Folder_GetDetailsOf_Proxy( 
    Folder __RPC_FAR * This,
    /* [in] */ VARIANT vItem,
    /* [in] */ int iColumn,
    /* [retval][out] */ BSTR __RPC_FAR *pbs);


void __RPC_STUB Folder_GetDetailsOf_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __Folder_INTERFACE_DEFINED__ */


#ifndef __Folder2_INTERFACE_DEFINED__
#define __Folder2_INTERFACE_DEFINED__

/* interface Folder2 */
/* [object][dual][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_Folder2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f0d2d8ef-3890-11d2-bf8b-00c04fb93661")
    Folder2 : public Folder
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Self( 
            /* [retval][out] */ FolderItem __RPC_FAR *__RPC_FAR *ppfi) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_OfflineStatus( 
            /* [retval][out] */ LONG __RPC_FAR *pul) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Synchronize( void) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_HaveToShowWebViewBarricade( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbHaveToShowWebViewBarricade) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DismissedWebViewBarricade( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct Folder2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            Folder2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            Folder2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            Folder2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            Folder2 __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            Folder2 __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            Folder2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            Folder2 __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Title )( 
            Folder2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbs);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            Folder2 __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            Folder2 __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ParentFolder )( 
            Folder2 __RPC_FAR * This,
            /* [retval][out] */ Folder __RPC_FAR *__RPC_FAR *ppsf);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Items )( 
            Folder2 __RPC_FAR * This,
            /* [retval][out] */ FolderItems __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ParseName )( 
            Folder2 __RPC_FAR * This,
            /* [in] */ BSTR bName,
            /* [retval][out] */ FolderItem __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NewFolder )( 
            Folder2 __RPC_FAR * This,
            /* [in] */ BSTR bName,
            /* [optional][in] */ VARIANT vOptions);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveHere )( 
            Folder2 __RPC_FAR * This,
            /* [in] */ VARIANT vItem,
            /* [optional][in] */ VARIANT vOptions);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CopyHere )( 
            Folder2 __RPC_FAR * This,
            /* [in] */ VARIANT vItem,
            /* [optional][in] */ VARIANT vOptions);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDetailsOf )( 
            Folder2 __RPC_FAR * This,
            /* [in] */ VARIANT vItem,
            /* [in] */ int iColumn,
            /* [retval][out] */ BSTR __RPC_FAR *pbs);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Self )( 
            Folder2 __RPC_FAR * This,
            /* [retval][out] */ FolderItem __RPC_FAR *__RPC_FAR *ppfi);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_OfflineStatus )( 
            Folder2 __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *pul);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Synchronize )( 
            Folder2 __RPC_FAR * This);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HaveToShowWebViewBarricade )( 
            Folder2 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbHaveToShowWebViewBarricade);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DismissedWebViewBarricade )( 
            Folder2 __RPC_FAR * This);
        
        END_INTERFACE
    } Folder2Vtbl;

    interface Folder2
    {
        CONST_VTBL struct Folder2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define Folder2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define Folder2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define Folder2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define Folder2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define Folder2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define Folder2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define Folder2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define Folder2_get_Title(This,pbs)	\
    (This)->lpVtbl -> get_Title(This,pbs)

#define Folder2_get_Application(This,ppid)	\
    (This)->lpVtbl -> get_Application(This,ppid)

#define Folder2_get_Parent(This,ppid)	\
    (This)->lpVtbl -> get_Parent(This,ppid)

#define Folder2_get_ParentFolder(This,ppsf)	\
    (This)->lpVtbl -> get_ParentFolder(This,ppsf)

#define Folder2_Items(This,ppid)	\
    (This)->lpVtbl -> Items(This,ppid)

#define Folder2_ParseName(This,bName,ppid)	\
    (This)->lpVtbl -> ParseName(This,bName,ppid)

#define Folder2_NewFolder(This,bName,vOptions)	\
    (This)->lpVtbl -> NewFolder(This,bName,vOptions)

#define Folder2_MoveHere(This,vItem,vOptions)	\
    (This)->lpVtbl -> MoveHere(This,vItem,vOptions)

#define Folder2_CopyHere(This,vItem,vOptions)	\
    (This)->lpVtbl -> CopyHere(This,vItem,vOptions)

#define Folder2_GetDetailsOf(This,vItem,iColumn,pbs)	\
    (This)->lpVtbl -> GetDetailsOf(This,vItem,iColumn,pbs)


#define Folder2_get_Self(This,ppfi)	\
    (This)->lpVtbl -> get_Self(This,ppfi)

#define Folder2_get_OfflineStatus(This,pul)	\
    (This)->lpVtbl -> get_OfflineStatus(This,pul)

#define Folder2_Synchronize(This)	\
    (This)->lpVtbl -> Synchronize(This)

#define Folder2_get_HaveToShowWebViewBarricade(This,pbHaveToShowWebViewBarricade)	\
    (This)->lpVtbl -> get_HaveToShowWebViewBarricade(This,pbHaveToShowWebViewBarricade)

#define Folder2_DismissedWebViewBarricade(This)	\
    (This)->lpVtbl -> DismissedWebViewBarricade(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE Folder2_get_Self_Proxy( 
    Folder2 __RPC_FAR * This,
    /* [retval][out] */ FolderItem __RPC_FAR *__RPC_FAR *ppfi);


void __RPC_STUB Folder2_get_Self_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE Folder2_get_OfflineStatus_Proxy( 
    Folder2 __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *pul);


void __RPC_STUB Folder2_get_OfflineStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE Folder2_Synchronize_Proxy( 
    Folder2 __RPC_FAR * This);


void __RPC_STUB Folder2_Synchronize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE Folder2_get_HaveToShowWebViewBarricade_Proxy( 
    Folder2 __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbHaveToShowWebViewBarricade);


void __RPC_STUB Folder2_get_HaveToShowWebViewBarricade_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE Folder2_DismissedWebViewBarricade_Proxy( 
    Folder2 __RPC_FAR * This);


void __RPC_STUB Folder2_DismissedWebViewBarricade_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __Folder2_INTERFACE_DEFINED__ */


#ifndef __FolderItem2_INTERFACE_DEFINED__
#define __FolderItem2_INTERFACE_DEFINED__

/* interface FolderItem2 */
/* [object][dual][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_FolderItem2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("edc817aa-92b8-11d1-b075-00c04fc33aa5")
    FolderItem2 : public FolderItem
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE InvokeVerbEx( 
            /* [optional][in] */ VARIANT vVerb,
            /* [optional][in] */ VARIANT vArgs) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ExtendedProperty( 
            /* [in] */ BSTR bstrPropName,
            /* [retval][out] */ VARIANT __RPC_FAR *pvRet) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct FolderItem2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            FolderItem2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            FolderItem2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            FolderItem2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            FolderItem2 __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            FolderItem2 __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            FolderItem2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            FolderItem2 __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            FolderItem2 __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            FolderItem2 __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            FolderItem2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbs);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Name )( 
            FolderItem2 __RPC_FAR * This,
            /* [in] */ BSTR bs);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Path )( 
            FolderItem2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbs);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_GetLink )( 
            FolderItem2 __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_GetFolder )( 
            FolderItem2 __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IsLink )( 
            FolderItem2 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IsFolder )( 
            FolderItem2 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IsFileSystem )( 
            FolderItem2 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IsBrowsable )( 
            FolderItem2 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ModifyDate )( 
            FolderItem2 __RPC_FAR * This,
            /* [retval][out] */ DATE __RPC_FAR *pdt);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ModifyDate )( 
            FolderItem2 __RPC_FAR * This,
            /* [in] */ DATE dt);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Size )( 
            FolderItem2 __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *pul);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Type )( 
            FolderItem2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbs);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Verbs )( 
            FolderItem2 __RPC_FAR * This,
            /* [retval][out] */ FolderItemVerbs __RPC_FAR *__RPC_FAR *ppfic);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InvokeVerb )( 
            FolderItem2 __RPC_FAR * This,
            /* [optional][in] */ VARIANT vVerb);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InvokeVerbEx )( 
            FolderItem2 __RPC_FAR * This,
            /* [optional][in] */ VARIANT vVerb,
            /* [optional][in] */ VARIANT vArgs);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExtendedProperty )( 
            FolderItem2 __RPC_FAR * This,
            /* [in] */ BSTR bstrPropName,
            /* [retval][out] */ VARIANT __RPC_FAR *pvRet);
        
        END_INTERFACE
    } FolderItem2Vtbl;

    interface FolderItem2
    {
        CONST_VTBL struct FolderItem2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define FolderItem2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define FolderItem2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define FolderItem2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define FolderItem2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define FolderItem2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define FolderItem2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define FolderItem2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define FolderItem2_get_Application(This,ppid)	\
    (This)->lpVtbl -> get_Application(This,ppid)

#define FolderItem2_get_Parent(This,ppid)	\
    (This)->lpVtbl -> get_Parent(This,ppid)

#define FolderItem2_get_Name(This,pbs)	\
    (This)->lpVtbl -> get_Name(This,pbs)

#define FolderItem2_put_Name(This,bs)	\
    (This)->lpVtbl -> put_Name(This,bs)

#define FolderItem2_get_Path(This,pbs)	\
    (This)->lpVtbl -> get_Path(This,pbs)

#define FolderItem2_get_GetLink(This,ppid)	\
    (This)->lpVtbl -> get_GetLink(This,ppid)

#define FolderItem2_get_GetFolder(This,ppid)	\
    (This)->lpVtbl -> get_GetFolder(This,ppid)

#define FolderItem2_get_IsLink(This,pb)	\
    (This)->lpVtbl -> get_IsLink(This,pb)

#define FolderItem2_get_IsFolder(This,pb)	\
    (This)->lpVtbl -> get_IsFolder(This,pb)

#define FolderItem2_get_IsFileSystem(This,pb)	\
    (This)->lpVtbl -> get_IsFileSystem(This,pb)

#define FolderItem2_get_IsBrowsable(This,pb)	\
    (This)->lpVtbl -> get_IsBrowsable(This,pb)

#define FolderItem2_get_ModifyDate(This,pdt)	\
    (This)->lpVtbl -> get_ModifyDate(This,pdt)

#define FolderItem2_put_ModifyDate(This,dt)	\
    (This)->lpVtbl -> put_ModifyDate(This,dt)

#define FolderItem2_get_Size(This,pul)	\
    (This)->lpVtbl -> get_Size(This,pul)

#define FolderItem2_get_Type(This,pbs)	\
    (This)->lpVtbl -> get_Type(This,pbs)

#define FolderItem2_Verbs(This,ppfic)	\
    (This)->lpVtbl -> Verbs(This,ppfic)

#define FolderItem2_InvokeVerb(This,vVerb)	\
    (This)->lpVtbl -> InvokeVerb(This,vVerb)


#define FolderItem2_InvokeVerbEx(This,vVerb,vArgs)	\
    (This)->lpVtbl -> InvokeVerbEx(This,vVerb,vArgs)

#define FolderItem2_ExtendedProperty(This,bstrPropName,pvRet)	\
    (This)->lpVtbl -> ExtendedProperty(This,bstrPropName,pvRet)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE FolderItem2_InvokeVerbEx_Proxy( 
    FolderItem2 __RPC_FAR * This,
    /* [optional][in] */ VARIANT vVerb,
    /* [optional][in] */ VARIANT vArgs);


void __RPC_STUB FolderItem2_InvokeVerbEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE FolderItem2_ExtendedProperty_Proxy( 
    FolderItem2 __RPC_FAR * This,
    /* [in] */ BSTR bstrPropName,
    /* [retval][out] */ VARIANT __RPC_FAR *pvRet);


void __RPC_STUB FolderItem2_ExtendedProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __FolderItem2_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_ShellFolderItem;

#ifdef __cplusplus

class DECLSPEC_UUID("2fe352ea-fd1f-11d2-b1f4-00c04f8eeb3e")
ShellFolderItem;
#endif

#ifndef __FolderItems2_INTERFACE_DEFINED__
#define __FolderItems2_INTERFACE_DEFINED__

/* interface FolderItems2 */
/* [object][dual][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_FolderItems2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C94F0AD0-F363-11d2-A327-00C04F8EEC7F")
    FolderItems2 : public FolderItems
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE InvokeVerbEx( 
            /* [optional][in] */ VARIANT vVerb,
            /* [optional][in] */ VARIANT vArgs) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct FolderItems2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            FolderItems2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            FolderItems2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            FolderItems2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            FolderItems2 __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            FolderItems2 __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            FolderItems2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            FolderItems2 __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            FolderItems2 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plCount);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            FolderItems2 __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            FolderItems2 __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Item )( 
            FolderItems2 __RPC_FAR * This,
            /* [optional][in] */ VARIANT index,
            /* [retval][out] */ FolderItem __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *_NewEnum )( 
            FolderItems2 __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InvokeVerbEx )( 
            FolderItems2 __RPC_FAR * This,
            /* [optional][in] */ VARIANT vVerb,
            /* [optional][in] */ VARIANT vArgs);
        
        END_INTERFACE
    } FolderItems2Vtbl;

    interface FolderItems2
    {
        CONST_VTBL struct FolderItems2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define FolderItems2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define FolderItems2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define FolderItems2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define FolderItems2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define FolderItems2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define FolderItems2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define FolderItems2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define FolderItems2_get_Count(This,plCount)	\
    (This)->lpVtbl -> get_Count(This,plCount)

#define FolderItems2_get_Application(This,ppid)	\
    (This)->lpVtbl -> get_Application(This,ppid)

#define FolderItems2_get_Parent(This,ppid)	\
    (This)->lpVtbl -> get_Parent(This,ppid)

#define FolderItems2_Item(This,index,ppid)	\
    (This)->lpVtbl -> Item(This,index,ppid)

#define FolderItems2__NewEnum(This,ppunk)	\
    (This)->lpVtbl -> _NewEnum(This,ppunk)


#define FolderItems2_InvokeVerbEx(This,vVerb,vArgs)	\
    (This)->lpVtbl -> InvokeVerbEx(This,vVerb,vArgs)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE FolderItems2_InvokeVerbEx_Proxy( 
    FolderItems2 __RPC_FAR * This,
    /* [optional][in] */ VARIANT vVerb,
    /* [optional][in] */ VARIANT vArgs);


void __RPC_STUB FolderItems2_InvokeVerbEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __FolderItems2_INTERFACE_DEFINED__ */


#ifndef __IShellLinkDual_INTERFACE_DEFINED__
#define __IShellLinkDual_INTERFACE_DEFINED__

/* interface IShellLinkDual */
/* [object][hidden][dual][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_IShellLinkDual;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("88A05C00-F000-11CE-8350-444553540000")
    IShellLinkDual : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Path( 
            /* [retval][out] */ BSTR __RPC_FAR *pbs) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Path( 
            /* [in] */ BSTR bs) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ BSTR __RPC_FAR *pbs) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Description( 
            /* [in] */ BSTR bs) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_WorkingDirectory( 
            /* [retval][out] */ BSTR __RPC_FAR *pbs) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_WorkingDirectory( 
            /* [in] */ BSTR bs) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Arguments( 
            /* [retval][out] */ BSTR __RPC_FAR *pbs) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Arguments( 
            /* [in] */ BSTR bs) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Hotkey( 
            /* [retval][out] */ int __RPC_FAR *piHK) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Hotkey( 
            /* [in] */ int iHK) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ShowCommand( 
            /* [retval][out] */ int __RPC_FAR *piShowCommand) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_ShowCommand( 
            /* [in] */ int iShowCommand) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Resolve( 
            /* [in] */ int fFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetIconLocation( 
            /* [out] */ BSTR __RPC_FAR *pbs,
            /* [retval][out] */ int __RPC_FAR *piIcon) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetIconLocation( 
            /* [in] */ BSTR bs,
            /* [in] */ int iIcon) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Save( 
            /* [optional][in] */ VARIANT vWhere) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellLinkDualVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IShellLinkDual __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IShellLinkDual __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IShellLinkDual __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IShellLinkDual __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IShellLinkDual __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IShellLinkDual __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IShellLinkDual __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Path )( 
            IShellLinkDual __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbs);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Path )( 
            IShellLinkDual __RPC_FAR * This,
            /* [in] */ BSTR bs);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Description )( 
            IShellLinkDual __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbs);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Description )( 
            IShellLinkDual __RPC_FAR * This,
            /* [in] */ BSTR bs);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_WorkingDirectory )( 
            IShellLinkDual __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbs);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_WorkingDirectory )( 
            IShellLinkDual __RPC_FAR * This,
            /* [in] */ BSTR bs);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Arguments )( 
            IShellLinkDual __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbs);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Arguments )( 
            IShellLinkDual __RPC_FAR * This,
            /* [in] */ BSTR bs);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Hotkey )( 
            IShellLinkDual __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *piHK);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Hotkey )( 
            IShellLinkDual __RPC_FAR * This,
            /* [in] */ int iHK);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ShowCommand )( 
            IShellLinkDual __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *piShowCommand);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ShowCommand )( 
            IShellLinkDual __RPC_FAR * This,
            /* [in] */ int iShowCommand);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Resolve )( 
            IShellLinkDual __RPC_FAR * This,
            /* [in] */ int fFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIconLocation )( 
            IShellLinkDual __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbs,
            /* [retval][out] */ int __RPC_FAR *piIcon);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetIconLocation )( 
            IShellLinkDual __RPC_FAR * This,
            /* [in] */ BSTR bs,
            /* [in] */ int iIcon);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Save )( 
            IShellLinkDual __RPC_FAR * This,
            /* [optional][in] */ VARIANT vWhere);
        
        END_INTERFACE
    } IShellLinkDualVtbl;

    interface IShellLinkDual
    {
        CONST_VTBL struct IShellLinkDualVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellLinkDual_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IShellLinkDual_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IShellLinkDual_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IShellLinkDual_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IShellLinkDual_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IShellLinkDual_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IShellLinkDual_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IShellLinkDual_get_Path(This,pbs)	\
    (This)->lpVtbl -> get_Path(This,pbs)

#define IShellLinkDual_put_Path(This,bs)	\
    (This)->lpVtbl -> put_Path(This,bs)

#define IShellLinkDual_get_Description(This,pbs)	\
    (This)->lpVtbl -> get_Description(This,pbs)

#define IShellLinkDual_put_Description(This,bs)	\
    (This)->lpVtbl -> put_Description(This,bs)

#define IShellLinkDual_get_WorkingDirectory(This,pbs)	\
    (This)->lpVtbl -> get_WorkingDirectory(This,pbs)

#define IShellLinkDual_put_WorkingDirectory(This,bs)	\
    (This)->lpVtbl -> put_WorkingDirectory(This,bs)

#define IShellLinkDual_get_Arguments(This,pbs)	\
    (This)->lpVtbl -> get_Arguments(This,pbs)

#define IShellLinkDual_put_Arguments(This,bs)	\
    (This)->lpVtbl -> put_Arguments(This,bs)

#define IShellLinkDual_get_Hotkey(This,piHK)	\
    (This)->lpVtbl -> get_Hotkey(This,piHK)

#define IShellLinkDual_put_Hotkey(This,iHK)	\
    (This)->lpVtbl -> put_Hotkey(This,iHK)

#define IShellLinkDual_get_ShowCommand(This,piShowCommand)	\
    (This)->lpVtbl -> get_ShowCommand(This,piShowCommand)

#define IShellLinkDual_put_ShowCommand(This,iShowCommand)	\
    (This)->lpVtbl -> put_ShowCommand(This,iShowCommand)

#define IShellLinkDual_Resolve(This,fFlags)	\
    (This)->lpVtbl -> Resolve(This,fFlags)

#define IShellLinkDual_GetIconLocation(This,pbs,piIcon)	\
    (This)->lpVtbl -> GetIconLocation(This,pbs,piIcon)

#define IShellLinkDual_SetIconLocation(This,bs,iIcon)	\
    (This)->lpVtbl -> SetIconLocation(This,bs,iIcon)

#define IShellLinkDual_Save(This,vWhere)	\
    (This)->lpVtbl -> Save(This,vWhere)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IShellLinkDual_get_Path_Proxy( 
    IShellLinkDual __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbs);


void __RPC_STUB IShellLinkDual_get_Path_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IShellLinkDual_put_Path_Proxy( 
    IShellLinkDual __RPC_FAR * This,
    /* [in] */ BSTR bs);


void __RPC_STUB IShellLinkDual_put_Path_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IShellLinkDual_get_Description_Proxy( 
    IShellLinkDual __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbs);


void __RPC_STUB IShellLinkDual_get_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IShellLinkDual_put_Description_Proxy( 
    IShellLinkDual __RPC_FAR * This,
    /* [in] */ BSTR bs);


void __RPC_STUB IShellLinkDual_put_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IShellLinkDual_get_WorkingDirectory_Proxy( 
    IShellLinkDual __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbs);


void __RPC_STUB IShellLinkDual_get_WorkingDirectory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IShellLinkDual_put_WorkingDirectory_Proxy( 
    IShellLinkDual __RPC_FAR * This,
    /* [in] */ BSTR bs);


void __RPC_STUB IShellLinkDual_put_WorkingDirectory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IShellLinkDual_get_Arguments_Proxy( 
    IShellLinkDual __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbs);


void __RPC_STUB IShellLinkDual_get_Arguments_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IShellLinkDual_put_Arguments_Proxy( 
    IShellLinkDual __RPC_FAR * This,
    /* [in] */ BSTR bs);


void __RPC_STUB IShellLinkDual_put_Arguments_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IShellLinkDual_get_Hotkey_Proxy( 
    IShellLinkDual __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *piHK);


void __RPC_STUB IShellLinkDual_get_Hotkey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IShellLinkDual_put_Hotkey_Proxy( 
    IShellLinkDual __RPC_FAR * This,
    /* [in] */ int iHK);


void __RPC_STUB IShellLinkDual_put_Hotkey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IShellLinkDual_get_ShowCommand_Proxy( 
    IShellLinkDual __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *piShowCommand);


void __RPC_STUB IShellLinkDual_get_ShowCommand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IShellLinkDual_put_ShowCommand_Proxy( 
    IShellLinkDual __RPC_FAR * This,
    /* [in] */ int iShowCommand);


void __RPC_STUB IShellLinkDual_put_ShowCommand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellLinkDual_Resolve_Proxy( 
    IShellLinkDual __RPC_FAR * This,
    /* [in] */ int fFlags);


void __RPC_STUB IShellLinkDual_Resolve_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellLinkDual_GetIconLocation_Proxy( 
    IShellLinkDual __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbs,
    /* [retval][out] */ int __RPC_FAR *piIcon);


void __RPC_STUB IShellLinkDual_GetIconLocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellLinkDual_SetIconLocation_Proxy( 
    IShellLinkDual __RPC_FAR * This,
    /* [in] */ BSTR bs,
    /* [in] */ int iIcon);


void __RPC_STUB IShellLinkDual_SetIconLocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellLinkDual_Save_Proxy( 
    IShellLinkDual __RPC_FAR * This,
    /* [optional][in] */ VARIANT vWhere);


void __RPC_STUB IShellLinkDual_Save_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IShellLinkDual_INTERFACE_DEFINED__ */


#ifndef __IShellLinkDual2_INTERFACE_DEFINED__
#define __IShellLinkDual2_INTERFACE_DEFINED__

/* interface IShellLinkDual2 */
/* [object][hidden][dual][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_IShellLinkDual2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("317EE249-F12E-11d2-B1E4-00C04F8EEB3E")
    IShellLinkDual2 : public IShellLinkDual
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Target( 
            /* [retval][out] */ FolderItem __RPC_FAR *__RPC_FAR *ppfi) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellLinkDual2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IShellLinkDual2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IShellLinkDual2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IShellLinkDual2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IShellLinkDual2 __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IShellLinkDual2 __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IShellLinkDual2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IShellLinkDual2 __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Path )( 
            IShellLinkDual2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbs);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Path )( 
            IShellLinkDual2 __RPC_FAR * This,
            /* [in] */ BSTR bs);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Description )( 
            IShellLinkDual2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbs);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Description )( 
            IShellLinkDual2 __RPC_FAR * This,
            /* [in] */ BSTR bs);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_WorkingDirectory )( 
            IShellLinkDual2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbs);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_WorkingDirectory )( 
            IShellLinkDual2 __RPC_FAR * This,
            /* [in] */ BSTR bs);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Arguments )( 
            IShellLinkDual2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbs);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Arguments )( 
            IShellLinkDual2 __RPC_FAR * This,
            /* [in] */ BSTR bs);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Hotkey )( 
            IShellLinkDual2 __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *piHK);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Hotkey )( 
            IShellLinkDual2 __RPC_FAR * This,
            /* [in] */ int iHK);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ShowCommand )( 
            IShellLinkDual2 __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *piShowCommand);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ShowCommand )( 
            IShellLinkDual2 __RPC_FAR * This,
            /* [in] */ int iShowCommand);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Resolve )( 
            IShellLinkDual2 __RPC_FAR * This,
            /* [in] */ int fFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIconLocation )( 
            IShellLinkDual2 __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbs,
            /* [retval][out] */ int __RPC_FAR *piIcon);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetIconLocation )( 
            IShellLinkDual2 __RPC_FAR * This,
            /* [in] */ BSTR bs,
            /* [in] */ int iIcon);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Save )( 
            IShellLinkDual2 __RPC_FAR * This,
            /* [optional][in] */ VARIANT vWhere);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Target )( 
            IShellLinkDual2 __RPC_FAR * This,
            /* [retval][out] */ FolderItem __RPC_FAR *__RPC_FAR *ppfi);
        
        END_INTERFACE
    } IShellLinkDual2Vtbl;

    interface IShellLinkDual2
    {
        CONST_VTBL struct IShellLinkDual2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellLinkDual2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IShellLinkDual2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IShellLinkDual2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IShellLinkDual2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IShellLinkDual2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IShellLinkDual2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IShellLinkDual2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IShellLinkDual2_get_Path(This,pbs)	\
    (This)->lpVtbl -> get_Path(This,pbs)

#define IShellLinkDual2_put_Path(This,bs)	\
    (This)->lpVtbl -> put_Path(This,bs)

#define IShellLinkDual2_get_Description(This,pbs)	\
    (This)->lpVtbl -> get_Description(This,pbs)

#define IShellLinkDual2_put_Description(This,bs)	\
    (This)->lpVtbl -> put_Description(This,bs)

#define IShellLinkDual2_get_WorkingDirectory(This,pbs)	\
    (This)->lpVtbl -> get_WorkingDirectory(This,pbs)

#define IShellLinkDual2_put_WorkingDirectory(This,bs)	\
    (This)->lpVtbl -> put_WorkingDirectory(This,bs)

#define IShellLinkDual2_get_Arguments(This,pbs)	\
    (This)->lpVtbl -> get_Arguments(This,pbs)

#define IShellLinkDual2_put_Arguments(This,bs)	\
    (This)->lpVtbl -> put_Arguments(This,bs)

#define IShellLinkDual2_get_Hotkey(This,piHK)	\
    (This)->lpVtbl -> get_Hotkey(This,piHK)

#define IShellLinkDual2_put_Hotkey(This,iHK)	\
    (This)->lpVtbl -> put_Hotkey(This,iHK)

#define IShellLinkDual2_get_ShowCommand(This,piShowCommand)	\
    (This)->lpVtbl -> get_ShowCommand(This,piShowCommand)

#define IShellLinkDual2_put_ShowCommand(This,iShowCommand)	\
    (This)->lpVtbl -> put_ShowCommand(This,iShowCommand)

#define IShellLinkDual2_Resolve(This,fFlags)	\
    (This)->lpVtbl -> Resolve(This,fFlags)

#define IShellLinkDual2_GetIconLocation(This,pbs,piIcon)	\
    (This)->lpVtbl -> GetIconLocation(This,pbs,piIcon)

#define IShellLinkDual2_SetIconLocation(This,bs,iIcon)	\
    (This)->lpVtbl -> SetIconLocation(This,bs,iIcon)

#define IShellLinkDual2_Save(This,vWhere)	\
    (This)->lpVtbl -> Save(This,vWhere)


#define IShellLinkDual2_get_Target(This,ppfi)	\
    (This)->lpVtbl -> get_Target(This,ppfi)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IShellLinkDual2_get_Target_Proxy( 
    IShellLinkDual2 __RPC_FAR * This,
    /* [retval][out] */ FolderItem __RPC_FAR *__RPC_FAR *ppfi);


void __RPC_STUB IShellLinkDual2_get_Target_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IShellLinkDual2_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_ShellLinkObject;

#ifdef __cplusplus

class DECLSPEC_UUID("11219420-1768-11d1-95BE-00609797EA4F")
ShellLinkObject;
#endif

#ifndef __IShellFolderViewDual_INTERFACE_DEFINED__
#define __IShellFolderViewDual_INTERFACE_DEFINED__

/* interface IShellFolderViewDual */
/* [object][dual][hidden][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_IShellFolderViewDual;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E7A1AF80-4D96-11CF-960C-0080C7F4EE85")
    IShellFolderViewDual : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Application( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Folder( 
            /* [retval][out] */ Folder __RPC_FAR *__RPC_FAR *ppid) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SelectedItems( 
            /* [retval][out] */ FolderItems __RPC_FAR *__RPC_FAR *ppid) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_FocusedItem( 
            /* [retval][out] */ FolderItem __RPC_FAR *__RPC_FAR *ppid) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SelectItem( 
            /* [in] */ VARIANT __RPC_FAR *pvfi,
            /* [in] */ int dwFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE PopupItemMenu( 
            /* [in] */ FolderItem __RPC_FAR *pfi,
            /* [optional][in] */ VARIANT vx,
            /* [optional][in] */ VARIANT vy,
            /* [retval][out] */ BSTR __RPC_FAR *pbs) = 0;
        
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Script( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp) = 0;
        
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ViewOptions( 
            /* [retval][out] */ long __RPC_FAR *plViewOptions) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellFolderViewDualVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IShellFolderViewDual __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IShellFolderViewDual __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IShellFolderViewDual __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IShellFolderViewDual __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IShellFolderViewDual __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IShellFolderViewDual __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IShellFolderViewDual __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            IShellFolderViewDual __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            IShellFolderViewDual __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Folder )( 
            IShellFolderViewDual __RPC_FAR * This,
            /* [retval][out] */ Folder __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SelectedItems )( 
            IShellFolderViewDual __RPC_FAR * This,
            /* [retval][out] */ FolderItems __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FocusedItem )( 
            IShellFolderViewDual __RPC_FAR * This,
            /* [retval][out] */ FolderItem __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SelectItem )( 
            IShellFolderViewDual __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *pvfi,
            /* [in] */ int dwFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PopupItemMenu )( 
            IShellFolderViewDual __RPC_FAR * This,
            /* [in] */ FolderItem __RPC_FAR *pfi,
            /* [optional][in] */ VARIANT vx,
            /* [optional][in] */ VARIANT vy,
            /* [retval][out] */ BSTR __RPC_FAR *pbs);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Script )( 
            IShellFolderViewDual __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ViewOptions )( 
            IShellFolderViewDual __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plViewOptions);
        
        END_INTERFACE
    } IShellFolderViewDualVtbl;

    interface IShellFolderViewDual
    {
        CONST_VTBL struct IShellFolderViewDualVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellFolderViewDual_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IShellFolderViewDual_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IShellFolderViewDual_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IShellFolderViewDual_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IShellFolderViewDual_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IShellFolderViewDual_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IShellFolderViewDual_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IShellFolderViewDual_get_Application(This,ppid)	\
    (This)->lpVtbl -> get_Application(This,ppid)

#define IShellFolderViewDual_get_Parent(This,ppid)	\
    (This)->lpVtbl -> get_Parent(This,ppid)

#define IShellFolderViewDual_get_Folder(This,ppid)	\
    (This)->lpVtbl -> get_Folder(This,ppid)

#define IShellFolderViewDual_SelectedItems(This,ppid)	\
    (This)->lpVtbl -> SelectedItems(This,ppid)

#define IShellFolderViewDual_get_FocusedItem(This,ppid)	\
    (This)->lpVtbl -> get_FocusedItem(This,ppid)

#define IShellFolderViewDual_SelectItem(This,pvfi,dwFlags)	\
    (This)->lpVtbl -> SelectItem(This,pvfi,dwFlags)

#define IShellFolderViewDual_PopupItemMenu(This,pfi,vx,vy,pbs)	\
    (This)->lpVtbl -> PopupItemMenu(This,pfi,vx,vy,pbs)

#define IShellFolderViewDual_get_Script(This,ppDisp)	\
    (This)->lpVtbl -> get_Script(This,ppDisp)

#define IShellFolderViewDual_get_ViewOptions(This,plViewOptions)	\
    (This)->lpVtbl -> get_ViewOptions(This,plViewOptions)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IShellFolderViewDual_get_Application_Proxy( 
    IShellFolderViewDual __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);


void __RPC_STUB IShellFolderViewDual_get_Application_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IShellFolderViewDual_get_Parent_Proxy( 
    IShellFolderViewDual __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);


void __RPC_STUB IShellFolderViewDual_get_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IShellFolderViewDual_get_Folder_Proxy( 
    IShellFolderViewDual __RPC_FAR * This,
    /* [retval][out] */ Folder __RPC_FAR *__RPC_FAR *ppid);


void __RPC_STUB IShellFolderViewDual_get_Folder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellFolderViewDual_SelectedItems_Proxy( 
    IShellFolderViewDual __RPC_FAR * This,
    /* [retval][out] */ FolderItems __RPC_FAR *__RPC_FAR *ppid);


void __RPC_STUB IShellFolderViewDual_SelectedItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IShellFolderViewDual_get_FocusedItem_Proxy( 
    IShellFolderViewDual __RPC_FAR * This,
    /* [retval][out] */ FolderItem __RPC_FAR *__RPC_FAR *ppid);


void __RPC_STUB IShellFolderViewDual_get_FocusedItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellFolderViewDual_SelectItem_Proxy( 
    IShellFolderViewDual __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *pvfi,
    /* [in] */ int dwFlags);


void __RPC_STUB IShellFolderViewDual_SelectItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellFolderViewDual_PopupItemMenu_Proxy( 
    IShellFolderViewDual __RPC_FAR * This,
    /* [in] */ FolderItem __RPC_FAR *pfi,
    /* [optional][in] */ VARIANT vx,
    /* [optional][in] */ VARIANT vy,
    /* [retval][out] */ BSTR __RPC_FAR *pbs);


void __RPC_STUB IShellFolderViewDual_PopupItemMenu_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IShellFolderViewDual_get_Script_Proxy( 
    IShellFolderViewDual __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp);


void __RPC_STUB IShellFolderViewDual_get_Script_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IShellFolderViewDual_get_ViewOptions_Proxy( 
    IShellFolderViewDual __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plViewOptions);


void __RPC_STUB IShellFolderViewDual_get_ViewOptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IShellFolderViewDual_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_ShellFolderView;

#ifdef __cplusplus

class DECLSPEC_UUID("62112AA1-EBE4-11cf-A5FB-0020AFE7292D")
ShellFolderView;
#endif

#ifndef __IShellDispatch_INTERFACE_DEFINED__
#define __IShellDispatch_INTERFACE_DEFINED__

/* interface IShellDispatch */
/* [object][dual][hidden][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_IShellDispatch;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D8F015C0-C278-11CE-A49E-444553540000")
    IShellDispatch : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Application( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE NameSpace( 
            /* [in] */ VARIANT vDir,
            /* [retval][out] */ Folder __RPC_FAR *__RPC_FAR *ppsdf) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE BrowseForFolder( 
            /* [in] */ long Hwnd,
            /* [in] */ BSTR Title,
            /* [in] */ long Options,
            /* [optional][in] */ VARIANT RootFolder,
            /* [retval][out] */ Folder __RPC_FAR *__RPC_FAR *ppsdf) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Windows( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Open( 
            /* [in] */ VARIANT vDir) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Explore( 
            /* [in] */ VARIANT vDir) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE MinimizeAll( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE UndoMinimizeALL( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FileRun( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CascadeWindows( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE TileVertically( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE TileHorizontally( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ShutdownWindows( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Suspend( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EjectPC( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetTime( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE TrayProperties( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Help( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FindFiles( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FindComputer( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RefreshMenu( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ControlPanelItem( 
            /* [in] */ BSTR szDir) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellDispatchVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IShellDispatch __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IShellDispatch __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IShellDispatch __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IShellDispatch __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IShellDispatch __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IShellDispatch __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IShellDispatch __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            IShellDispatch __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            IShellDispatch __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NameSpace )( 
            IShellDispatch __RPC_FAR * This,
            /* [in] */ VARIANT vDir,
            /* [retval][out] */ Folder __RPC_FAR *__RPC_FAR *ppsdf);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BrowseForFolder )( 
            IShellDispatch __RPC_FAR * This,
            /* [in] */ long Hwnd,
            /* [in] */ BSTR Title,
            /* [in] */ long Options,
            /* [optional][in] */ VARIANT RootFolder,
            /* [retval][out] */ Folder __RPC_FAR *__RPC_FAR *ppsdf);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Windows )( 
            IShellDispatch __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )( 
            IShellDispatch __RPC_FAR * This,
            /* [in] */ VARIANT vDir);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Explore )( 
            IShellDispatch __RPC_FAR * This,
            /* [in] */ VARIANT vDir);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MinimizeAll )( 
            IShellDispatch __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UndoMinimizeALL )( 
            IShellDispatch __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FileRun )( 
            IShellDispatch __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CascadeWindows )( 
            IShellDispatch __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TileVertically )( 
            IShellDispatch __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TileHorizontally )( 
            IShellDispatch __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ShutdownWindows )( 
            IShellDispatch __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Suspend )( 
            IShellDispatch __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EjectPC )( 
            IShellDispatch __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetTime )( 
            IShellDispatch __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TrayProperties )( 
            IShellDispatch __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Help )( 
            IShellDispatch __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindFiles )( 
            IShellDispatch __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindComputer )( 
            IShellDispatch __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RefreshMenu )( 
            IShellDispatch __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ControlPanelItem )( 
            IShellDispatch __RPC_FAR * This,
            /* [in] */ BSTR szDir);
        
        END_INTERFACE
    } IShellDispatchVtbl;

    interface IShellDispatch
    {
        CONST_VTBL struct IShellDispatchVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellDispatch_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IShellDispatch_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IShellDispatch_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IShellDispatch_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IShellDispatch_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IShellDispatch_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IShellDispatch_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IShellDispatch_get_Application(This,ppid)	\
    (This)->lpVtbl -> get_Application(This,ppid)

#define IShellDispatch_get_Parent(This,ppid)	\
    (This)->lpVtbl -> get_Parent(This,ppid)

#define IShellDispatch_NameSpace(This,vDir,ppsdf)	\
    (This)->lpVtbl -> NameSpace(This,vDir,ppsdf)

#define IShellDispatch_BrowseForFolder(This,Hwnd,Title,Options,RootFolder,ppsdf)	\
    (This)->lpVtbl -> BrowseForFolder(This,Hwnd,Title,Options,RootFolder,ppsdf)

#define IShellDispatch_Windows(This,ppid)	\
    (This)->lpVtbl -> Windows(This,ppid)

#define IShellDispatch_Open(This,vDir)	\
    (This)->lpVtbl -> Open(This,vDir)

#define IShellDispatch_Explore(This,vDir)	\
    (This)->lpVtbl -> Explore(This,vDir)

#define IShellDispatch_MinimizeAll(This)	\
    (This)->lpVtbl -> MinimizeAll(This)

#define IShellDispatch_UndoMinimizeALL(This)	\
    (This)->lpVtbl -> UndoMinimizeALL(This)

#define IShellDispatch_FileRun(This)	\
    (This)->lpVtbl -> FileRun(This)

#define IShellDispatch_CascadeWindows(This)	\
    (This)->lpVtbl -> CascadeWindows(This)

#define IShellDispatch_TileVertically(This)	\
    (This)->lpVtbl -> TileVertically(This)

#define IShellDispatch_TileHorizontally(This)	\
    (This)->lpVtbl -> TileHorizontally(This)

#define IShellDispatch_ShutdownWindows(This)	\
    (This)->lpVtbl -> ShutdownWindows(This)

#define IShellDispatch_Suspend(This)	\
    (This)->lpVtbl -> Suspend(This)

#define IShellDispatch_EjectPC(This)	\
    (This)->lpVtbl -> EjectPC(This)

#define IShellDispatch_SetTime(This)	\
    (This)->lpVtbl -> SetTime(This)

#define IShellDispatch_TrayProperties(This)	\
    (This)->lpVtbl -> TrayProperties(This)

#define IShellDispatch_Help(This)	\
    (This)->lpVtbl -> Help(This)

#define IShellDispatch_FindFiles(This)	\
    (This)->lpVtbl -> FindFiles(This)

#define IShellDispatch_FindComputer(This)	\
    (This)->lpVtbl -> FindComputer(This)

#define IShellDispatch_RefreshMenu(This)	\
    (This)->lpVtbl -> RefreshMenu(This)

#define IShellDispatch_ControlPanelItem(This,szDir)	\
    (This)->lpVtbl -> ControlPanelItem(This,szDir)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IShellDispatch_get_Application_Proxy( 
    IShellDispatch __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);


void __RPC_STUB IShellDispatch_get_Application_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IShellDispatch_get_Parent_Proxy( 
    IShellDispatch __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);


void __RPC_STUB IShellDispatch_get_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellDispatch_NameSpace_Proxy( 
    IShellDispatch __RPC_FAR * This,
    /* [in] */ VARIANT vDir,
    /* [retval][out] */ Folder __RPC_FAR *__RPC_FAR *ppsdf);


void __RPC_STUB IShellDispatch_NameSpace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellDispatch_BrowseForFolder_Proxy( 
    IShellDispatch __RPC_FAR * This,
    /* [in] */ long Hwnd,
    /* [in] */ BSTR Title,
    /* [in] */ long Options,
    /* [optional][in] */ VARIANT RootFolder,
    /* [retval][out] */ Folder __RPC_FAR *__RPC_FAR *ppsdf);


void __RPC_STUB IShellDispatch_BrowseForFolder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellDispatch_Windows_Proxy( 
    IShellDispatch __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);


void __RPC_STUB IShellDispatch_Windows_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellDispatch_Open_Proxy( 
    IShellDispatch __RPC_FAR * This,
    /* [in] */ VARIANT vDir);


void __RPC_STUB IShellDispatch_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellDispatch_Explore_Proxy( 
    IShellDispatch __RPC_FAR * This,
    /* [in] */ VARIANT vDir);


void __RPC_STUB IShellDispatch_Explore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellDispatch_MinimizeAll_Proxy( 
    IShellDispatch __RPC_FAR * This);


void __RPC_STUB IShellDispatch_MinimizeAll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellDispatch_UndoMinimizeALL_Proxy( 
    IShellDispatch __RPC_FAR * This);


void __RPC_STUB IShellDispatch_UndoMinimizeALL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellDispatch_FileRun_Proxy( 
    IShellDispatch __RPC_FAR * This);


void __RPC_STUB IShellDispatch_FileRun_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellDispatch_CascadeWindows_Proxy( 
    IShellDispatch __RPC_FAR * This);


void __RPC_STUB IShellDispatch_CascadeWindows_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellDispatch_TileVertically_Proxy( 
    IShellDispatch __RPC_FAR * This);


void __RPC_STUB IShellDispatch_TileVertically_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellDispatch_TileHorizontally_Proxy( 
    IShellDispatch __RPC_FAR * This);


void __RPC_STUB IShellDispatch_TileHorizontally_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellDispatch_ShutdownWindows_Proxy( 
    IShellDispatch __RPC_FAR * This);


void __RPC_STUB IShellDispatch_ShutdownWindows_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellDispatch_Suspend_Proxy( 
    IShellDispatch __RPC_FAR * This);


void __RPC_STUB IShellDispatch_Suspend_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellDispatch_EjectPC_Proxy( 
    IShellDispatch __RPC_FAR * This);


void __RPC_STUB IShellDispatch_EjectPC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellDispatch_SetTime_Proxy( 
    IShellDispatch __RPC_FAR * This);


void __RPC_STUB IShellDispatch_SetTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellDispatch_TrayProperties_Proxy( 
    IShellDispatch __RPC_FAR * This);


void __RPC_STUB IShellDispatch_TrayProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellDispatch_Help_Proxy( 
    IShellDispatch __RPC_FAR * This);


void __RPC_STUB IShellDispatch_Help_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellDispatch_FindFiles_Proxy( 
    IShellDispatch __RPC_FAR * This);


void __RPC_STUB IShellDispatch_FindFiles_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellDispatch_FindComputer_Proxy( 
    IShellDispatch __RPC_FAR * This);


void __RPC_STUB IShellDispatch_FindComputer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellDispatch_RefreshMenu_Proxy( 
    IShellDispatch __RPC_FAR * This);


void __RPC_STUB IShellDispatch_RefreshMenu_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellDispatch_ControlPanelItem_Proxy( 
    IShellDispatch __RPC_FAR * This,
    /* [in] */ BSTR szDir);


void __RPC_STUB IShellDispatch_ControlPanelItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IShellDispatch_INTERFACE_DEFINED__ */


#ifndef __IShellDispatch2_INTERFACE_DEFINED__
#define __IShellDispatch2_INTERFACE_DEFINED__

/* interface IShellDispatch2 */
/* [object][dual][hidden][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_IShellDispatch2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A4C6892C-3BA9-11d2-9DEA-00C04FB16162")
    IShellDispatch2 : public IShellDispatch
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE IsRestricted( 
            /* [in] */ BSTR Group,
            /* [in] */ BSTR Restriction,
            /* [retval][out] */ long __RPC_FAR *plRestrictValue) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ShellExecute( 
            /* [in] */ BSTR File,
            /* [optional][in] */ VARIANT vArgs,
            /* [optional][in] */ VARIANT vDir,
            /* [optional][in] */ VARIANT vOperation,
            /* [optional][in] */ VARIANT vShow) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FindPrinter( 
            /* [optional][in] */ BSTR name,
            /* [optional][in] */ BSTR location,
            /* [optional][in] */ BSTR model) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSystemInformation( 
            /* [in] */ BSTR name,
            /* [retval][out] */ VARIANT __RPC_FAR *pv) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ServiceStart( 
            /* [in] */ BSTR ServiceName,
            /* [in] */ VARIANT Persistent,
            /* [retval][out] */ VARIANT __RPC_FAR *pSuccess) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ServiceStop( 
            /* [in] */ BSTR ServiceName,
            /* [in] */ VARIANT Persistent,
            /* [retval][out] */ VARIANT __RPC_FAR *pSuccess) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE IsServiceRunning( 
            /* [in] */ BSTR ServiceName,
            /* [retval][out] */ VARIANT __RPC_FAR *pRunning) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CanStartStopService( 
            /* [in] */ BSTR ServiceName,
            /* [retval][out] */ VARIANT __RPC_FAR *pCanStartStop) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ShowBrowserBar( 
            /* [in] */ BSTR bstrClsid,
            /* [in] */ VARIANT bShow,
            /* [retval][out] */ VARIANT __RPC_FAR *pSuccess) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellDispatch2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IShellDispatch2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IShellDispatch2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IShellDispatch2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IShellDispatch2 __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IShellDispatch2 __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IShellDispatch2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IShellDispatch2 __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            IShellDispatch2 __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            IShellDispatch2 __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NameSpace )( 
            IShellDispatch2 __RPC_FAR * This,
            /* [in] */ VARIANT vDir,
            /* [retval][out] */ Folder __RPC_FAR *__RPC_FAR *ppsdf);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BrowseForFolder )( 
            IShellDispatch2 __RPC_FAR * This,
            /* [in] */ long Hwnd,
            /* [in] */ BSTR Title,
            /* [in] */ long Options,
            /* [optional][in] */ VARIANT RootFolder,
            /* [retval][out] */ Folder __RPC_FAR *__RPC_FAR *ppsdf);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Windows )( 
            IShellDispatch2 __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )( 
            IShellDispatch2 __RPC_FAR * This,
            /* [in] */ VARIANT vDir);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Explore )( 
            IShellDispatch2 __RPC_FAR * This,
            /* [in] */ VARIANT vDir);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MinimizeAll )( 
            IShellDispatch2 __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UndoMinimizeALL )( 
            IShellDispatch2 __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FileRun )( 
            IShellDispatch2 __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CascadeWindows )( 
            IShellDispatch2 __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TileVertically )( 
            IShellDispatch2 __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TileHorizontally )( 
            IShellDispatch2 __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ShutdownWindows )( 
            IShellDispatch2 __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Suspend )( 
            IShellDispatch2 __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EjectPC )( 
            IShellDispatch2 __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetTime )( 
            IShellDispatch2 __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TrayProperties )( 
            IShellDispatch2 __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Help )( 
            IShellDispatch2 __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindFiles )( 
            IShellDispatch2 __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindComputer )( 
            IShellDispatch2 __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RefreshMenu )( 
            IShellDispatch2 __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ControlPanelItem )( 
            IShellDispatch2 __RPC_FAR * This,
            /* [in] */ BSTR szDir);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsRestricted )( 
            IShellDispatch2 __RPC_FAR * This,
            /* [in] */ BSTR Group,
            /* [in] */ BSTR Restriction,
            /* [retval][out] */ long __RPC_FAR *plRestrictValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ShellExecute )( 
            IShellDispatch2 __RPC_FAR * This,
            /* [in] */ BSTR File,
            /* [optional][in] */ VARIANT vArgs,
            /* [optional][in] */ VARIANT vDir,
            /* [optional][in] */ VARIANT vOperation,
            /* [optional][in] */ VARIANT vShow);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindPrinter )( 
            IShellDispatch2 __RPC_FAR * This,
            /* [optional][in] */ BSTR name,
            /* [optional][in] */ BSTR location,
            /* [optional][in] */ BSTR model);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSystemInformation )( 
            IShellDispatch2 __RPC_FAR * This,
            /* [in] */ BSTR name,
            /* [retval][out] */ VARIANT __RPC_FAR *pv);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ServiceStart )( 
            IShellDispatch2 __RPC_FAR * This,
            /* [in] */ BSTR ServiceName,
            /* [in] */ VARIANT Persistent,
            /* [retval][out] */ VARIANT __RPC_FAR *pSuccess);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ServiceStop )( 
            IShellDispatch2 __RPC_FAR * This,
            /* [in] */ BSTR ServiceName,
            /* [in] */ VARIANT Persistent,
            /* [retval][out] */ VARIANT __RPC_FAR *pSuccess);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsServiceRunning )( 
            IShellDispatch2 __RPC_FAR * This,
            /* [in] */ BSTR ServiceName,
            /* [retval][out] */ VARIANT __RPC_FAR *pRunning);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CanStartStopService )( 
            IShellDispatch2 __RPC_FAR * This,
            /* [in] */ BSTR ServiceName,
            /* [retval][out] */ VARIANT __RPC_FAR *pCanStartStop);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ShowBrowserBar )( 
            IShellDispatch2 __RPC_FAR * This,
            /* [in] */ BSTR bstrClsid,
            /* [in] */ VARIANT bShow,
            /* [retval][out] */ VARIANT __RPC_FAR *pSuccess);
        
        END_INTERFACE
    } IShellDispatch2Vtbl;

    interface IShellDispatch2
    {
        CONST_VTBL struct IShellDispatch2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellDispatch2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IShellDispatch2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IShellDispatch2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IShellDispatch2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IShellDispatch2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IShellDispatch2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IShellDispatch2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,p